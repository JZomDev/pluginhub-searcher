/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// From AttackStyles RuneLite plugin
// Located at: https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/attackstyles/AttackStyle.java
// or net.runelite.client.plugins.attackstyles.AttackStyle

package com.maxhitcalc;

import lombok.Getter;
import net.runelite.api.Skill;

enum AttackStyle
{
    ACCURATE("Accurate", Skill.ATTACK),
    AGGRESSIVE("Aggressive", Skill.STRENGTH),
    DEFENSIVE("Defensive", Skill.DEFENCE),
    CONTROLLED("Controlled", Skill.ATTACK, Skill.STRENGTH, Skill.DEFENCE),
    RANGING("Ranging", Skill.RANGED),
    LONGRANGE("Longrange", Skill.RANGED, Skill.DEFENCE),
    CASTING("Casting", Skill.MAGIC),
    DEFENSIVE_CASTING("Defensive Casting", Skill.MAGIC, Skill.DEFENCE),
    OTHER("Other");

    @Getter
    private final String name;
    @Getter
    private final Skill[] skills;

    AttackStyle(String name, Skill... skills)
    {
        this.name = name;
        this.skills = skills;
    }
}
/* BlowpipeDartType.java
 *
 * Copyright (c) 2024, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

public enum BlowpipeDartType
{
    MITHRIL,
    ADAMANT,
    RUNE,
    AMETHYST,
    DRAGON
}

/* CombatSpell.java
 * Separates spells by SpriteID. Useful for getting the selected auto-cast spell.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import lombok.Getter;

import java.util.ArrayList;

/**
 * Contains definitions of combat spells and functions for retrieving them.
 * Selected Autocast Varbit is Varbit 276
 *
 *
 */
public enum CombatSpell
{
    // In order of autocast varbit
    WIND_STRIKE(1, 15, 65, "WIND STRIKE", 1,2, "standard", SpellType.Air, 1),
    WATER_STRIKE(2, 17, 67, "WATER STRIKE", 5,4, "standard", SpellType.Water, 1),
    EARTH_STRIKE(3, 19, 69, "EARTH STRIKE", 9,6, "standard", SpellType.Earth, 1),
    FIRE_STRIKE(4, 21, 71, "FIRE STRIKE", 13,8, "standard", SpellType.Fire, 1),
    WIND_BOLT(5,23, 73, "WIND BOLT", 17,9, "standard", SpellType.Air,2),
    WATER_BOLT(6,26, 76, "WATER BOLT", 23,10, "standard", SpellType.Water, 2),
    EARTH_BOLT(7,29, 79, "EARTH BOLT", 29,11, "standard", SpellType.Earth, 2),
    FIRE_BOLT(8,32, 82, "FIRE BOLT", 35,12, "standard", SpellType.Fire, 2),
    WIND_BLAST(9,35, 85, "WIND BLAST", 41,13, "standard", SpellType.Air,3),
    WATER_BLAST(10,38, 88, "WATER BLAST",47,14, "standard", SpellType.Water, 3),
    EARTH_BLAST(11,40, 90, "EARTH BLAST", 53,15, "standard", SpellType.Earth, 3),
    FIRE_BLAST(12,44, 94, "FIRE BLAST", 59,16, "standard", SpellType.Fire, 3),
    WIND_WAVE(13,46, 96, "WIND WAVE", 62,17, "standard", SpellType.Air,4),
    WATER_WAVE(14,48, 98, "WATER WAVE", 65,18, "standard", SpellType.Water, 4),
    EARTH_WAVE(15,51, 101, "EARTH WAVE", 70,19, "standard", SpellType.Earth, 4),
    FIRE_WAVE(16,52, 102, "FIRE WAVE", 75,20, "standard", SpellType.Fire, 4),

    CRUMBLE_UNDEAD(17,34, 84, "CRUMBLE UNDEAD", 39,15, "standard",0),
    MAGIC_DART(18, 324, 374, "MAGIC DART", 50,10, "standard",0),
    CLAWS_OF_GUTHIX(19, 60, 110, "CLAWS OF GUTHIX", 60,20, "standard",0),
    FLAMES_OF_ZAMORAK(20, 59, 109, "FLAMES OF ZAMORAK", 60,20, "standard",0),

    SMOKE_RUSH(31, 329, 379, "SMOKE RUSH", 50,13, "ancients",0),
    SHADOW_RUSH(32, 337, 387, "SHADOW RUSH", 52,14, "ancients",0),
    BLOOD_RUSH(33,333, 383, "BLOOD RUSH", 56,15, "ancients",0),
    ICE_RUSH(34,325, 375, "ICE RUSH", 58,16, "ancients",0),
    SMOKE_BURST(35, 330, 380, "SMOKE BURST", 62,17, "ancients",0),
    SHADOW_BURST(36, 338, 388, "SHADOW BURST", 64,18, "ancients",0),
    BLOOD_BURST(37, 334, 384, "BLOOD BURST", 68,21, "ancients",0),
    ICE_BURST(38, 326, 381, "ICE BURST", 70,22, "ancients",0),
    SMOKE_BLITZ(39, 331, 389, "SMOKE BLITZ", 74,23, "ancients",0),
    SHADOW_BLITZ(40, 339, 389, "SHADOW BLITZ", 76,24, "ancients",0),
    BLOOD_BLITZ(41, 335, 385, "BLOOD BLITZ", 80,25, "ancients",0),
    ICE_BLITZ(42, 327, 377, "ICE BLITZ", 82,26, "ancients",0),
    SMOKE_BARRAGE(43, 332, 382, "SMOKE BARRAGE", 86,27, "ancients",0),
    SHADOW_BARRAGE(44, 340, 390, "SHADOW BARRAGE", 88,28, "ancients",0),
    BLOOD_BARRAGE(45, 336, 386, "BLOOD BARRAGE", 92,29, "ancients",0),
    ICE_BARRAGE(46, 328, 378, "ICE BARRAGE", 94,30, "ancients",0),
    IBAN_BLAST(47, 53, 103, "IBAN BLAST", 50,25, "standard",0),
    WIND_SURGE(48, 362, 412, "WIND SURGE", 81,21, "standard",SpellType.Air,5),
    WATER_SURGE(49, 363, 413, "WATER SURGE", 85,22, "standard",SpellType.Water,5),
    EARTH_SURGE(50,364, 414, "EARTH SURGE", 90,23, "standard",SpellType.Earth,5),
    FIRE_SURGE(51, 365, 415, "FIRE SURGE", 95,24, "standard",SpellType.Fire,5),
    SARADOMIN_STRIKE(52, 61, 111, "SARADOMIN STRIKE", 60, 20, "standard",0),
    INFERIOR_DEMONBANE(53,1302, 1321, "INFERIOR DEMONBANE", 44,16, "arceuss",0),
    SUPERIOR_DEMONBANE(54, 1303, 1322, "SUPERIOR DEMONBANE", 62,23, "arceuss",0),
    DARK_DEMONBANE(55, 1304, 1323, "DARK DEMONBANE", 82,30, "arceuss",0),
    GHOSTLY_GRASP(56,1267, 1292, "GHOSTLY GRASP", 35,12, "arceuss",0),
    SKELETAL_GRASP(57,1268, 1293, "SKELETAL GRASP", 56,17, "arceuss",0),
    UNDEAD_GRASP(58, 1269, 1294, "UNDEAD GRASP", 79,24, "arceuss",0);


    @Getter
    private final int autocastVarbitValue;
    @Getter
    private final int spriteID;
    @Getter
    private final int disabledSpriteID;
    @Getter
    private final String name;
    @Getter
    private final int reqLevel;
    @Getter
    private final int baseDamage;
    @Getter
    private final String spellbook;
    @Getter
    private final SpellType spellType;
    @Getter
    private final int tier;

    /**
     * Gets a CombatSpell from a Varbit ID
     * @param value int, varbit value of spell
     * @return Spell, or null for failure
     */
    public static CombatSpell getSpellbyVarbitValue(int value)
    {
        for (CombatSpell spell : CombatSpell.values())
        {
            if(spell.autocastVarbitValue == value){
                return spell;
            }
        }

        // error, failure
        return null;
    }

    /**
     * Finds a CombatSpell based on sprite ID
     * @param spriteID int
     * @return Spell, or null for failure
     */
    public static CombatSpell getSpellBySpriteID(int spriteID)
    {
        for (CombatSpell spell : CombatSpell.values())
        {
            if(spell.spriteID == spriteID){
                return spell;
            }
        }

        // error, failure
        return null;
    }

    /**
     * Finds a CombatSpell based on its disabled sprite ID
     * @param spriteID int
     * @return Spell, or null for failure
     */
    public static CombatSpell getSpellByDisabledSpriteID(int spriteID)
    {
        // Spells that
        for (CombatSpell spell : CombatSpell.values())
        {
            if(spell.disabledSpriteID == spriteID){
                return spell;
            }
        }

        // error, failure
        return null;
    }

    /**
     * Returns if a CombatSpell has a Type
     */
    public boolean hasType(){
        if(this.spellType != SpellType.NoType)
            return true;

        return false;
    }

    public static CombatSpell[] getSpellsOfTier(int tier, String spellbook){
        ArrayList<CombatSpell> results = new ArrayList<>();

        for (CombatSpell spell : CombatSpell.values())
        {
            if (spell.getSpellbook().equals(spellbook))
            {
                if (spell.getTier() == tier)
                {
                    // found spell of correct tier and spellbook
                    results.add(spell);
                }
            }
        }

        return results.toArray(new CombatSpell[results.size()]);
    }

    CombatSpell(int autocastVarbitValue, int spriteID, int disabledSpriteID, String name, int reqLevel, int baseDamage, String spellbook, SpellType spellType, int tier)
    {
        this.autocastVarbitValue = autocastVarbitValue;
        this.spriteID = spriteID;
        this.disabledSpriteID = disabledSpriteID;
        this.name = name;
        this.reqLevel = reqLevel;
        this.baseDamage = baseDamage;
        this.spellbook = spellbook;
        this.spellType = spellType;
        this.tier = tier;
    }

    /**
     * Constructor: No type given
     */
    CombatSpell(int autocastVarbitValue, int spriteID, int disabledSpriteID, String name, int reqLevel, int baseDamage, String spellbook, int tier)
    {
        this.autocastVarbitValue = autocastVarbitValue;
        this.spriteID = spriteID;
        this.disabledSpriteID = disabledSpriteID;
        this.name = name;
        this.reqLevel = reqLevel;
        this.baseDamage = baseDamage;
        this.spellbook = spellbook;
        this.spellType = SpellType.NoType;
        this.tier = tier;
    }
}

/* EquipmentItems.java
 * Contains Functions for retrieving information about currently equipped items.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.gameval.InventoryID;

public class EquipmentItems
{
    /**
     * Gets Currently Equipped Items
     *
     * @param client
     *
     * @return Item[] of all Equipped Items
     */
    public static Item[] getCurrentlyEquipped(Client client)
    {
        Item[] playerEquipment;
        if (client.getItemContainer(InventoryID.WORN) != null )
        {
            playerEquipment = client.getItemContainer(InventoryID.WORN).getItems();
        }
        else
        {
            playerEquipment = null;
        }

        return playerEquipment;
    }

    /**
     * Get Item Name in Specific Slot of Specified Equipment Set <br>
     *
     * @param client
     * @param ITEMSLOT the item slot id that will be checked
     * @param playerEquipment specified Item list
     * @return string of item name, returns empty string if ITEMSLOT is empty
     */
    public static String getItemNameInGivenSetSlot(Client client, Item[] playerEquipment, EquipmentInventorySlot ITEMSLOT)
    {
        String itemName = "";

        if(playerEquipment != null){
            if(playerEquipment.length > ITEMSLOT.getSlotIdx()
                    && playerEquipment[ITEMSLOT.getSlotIdx()] != null)
            {
                itemName = client.getItemDefinition(playerEquipment[ITEMSLOT.getSlotIdx()].getId()).getName();
            }
        }

        return itemName;
    }

    /**
     * Get Item ID in Specific Slot with a specified equipment list <br>
     *
     * @param playerEquipment specified Item list
     * @param ITEMSLOT the item slot id that will be checked
     *
     * @return int of item id, returns -1 if empty
     */
    public static int getItemIdInGivenSetSlot(Item[] playerEquipment, EquipmentInventorySlot ITEMSLOT)
    {
        int itemID = -1;

        if(playerEquipment != null) {
            if(playerEquipment.length > ITEMSLOT.getSlotIdx()
                    && playerEquipment[ITEMSLOT.getSlotIdx()] != null)
            {
                itemID = playerEquipment[ITEMSLOT.getSlotIdx()].getId();
            }
        }

        return itemID;
    }

    public static Item[] getQuiverItem(Client client)
    {
        Item[] quiverItem;

        if (client.getItemContainer(InventoryID.DIZANAS_QUIVER_AMMO) != null )
        {
            quiverItem = client.getItemContainer(InventoryID.DIZANAS_QUIVER_AMMO).getItems(); // returns as an array, but should only have 1 item or none
        }
        else
        {
            quiverItem = null;
        }

        return quiverItem;
    }

    public static String getQuiverItemName(Client client)
    {
        String itemName = "";

        Item[] quiverItems = getQuiverItem(client);

        if (quiverItems != null)
        {
            if(quiverItems.length > 0)
            {
                itemName = client.getItemDefinition(quiverItems[0].getId()).getName();
            }
        }

        return itemName;
    }

    public static int getQuiverItemID(Client client)
    {
        int itemID = -1;

        Item[] quiverItems = getQuiverItem(client);

        if (quiverItems != null)
        {
            if(quiverItems.length > 0)
            {
                itemID = quiverItems[0].getId();
            }
        }

        return itemID;
    }

    /**
     * Returns if a given ammo could be fired from a weapon,
     * does not take into account the tier of ammo or tier of weapon
     *
     * @param ammoTypeName name of ammo item
     * @param weaponName name of weapon
     *
     * @return boolean, true or false
     */
    public static boolean doesAmmoMatchWeapon(String ammoTypeName, String weaponName)
    {
        // Arrows -> bows
        if (ammoTypeName.toLowerCase().contains("arrow")) {
            // Ogre arrow -> ogre bow
            if (ammoTypeName.toLowerCase().contains("ogre")) {
                if(weaponName.toLowerCase().contains("ogre")) return true;
            }
            // all other arrows -> any bow
            else {
                if(weaponName.toLowerCase().contains("bow") && !weaponName.toLowerCase().contains("crossbow")) return true;
            }
        }
        // Brutal Arrows
        else if(ammoTypeName.toLowerCase().contains("brutal")) {
            if(weaponName.toLowerCase().contains("ogre")) return true;
        }
        // Bolts -> crossbows
        else if(ammoTypeName.toLowerCase().contains("bolts")) {
            // Kebbit bolts -> hunters' crossbow
            if(ammoTypeName.toLowerCase().contains("kebbit")) {
                if(weaponName.toLowerCase().contains("hunters' crossbow")) return true;
            }
            // Antler bolts -> hunter's sunlight crossbow
            else if(ammoTypeName.toLowerCase().contains("antler")){
                if(weaponName.toLowerCase().contains("hunters' sunlight crossbow")) return true;
            }
            // Bone bolts -> Dorgeshuun crossbow
            else if (ammoTypeName.toLowerCase().contains("bone")) {
                if(weaponName.toLowerCase().contains("dorgeshuun")) return true;
            }
            // All other types of bolts -> normal crossbows
            else {
                if(weaponName.toLowerCase().contains("crossbow")) return true;
            }
        }
        // Bolt rack -> Karil's
        else if(ammoTypeName.toLowerCase().contains("rack")) {
            if(weaponName.toLowerCase().contains("karil's")) return true;
        }
        // Javelin -> Ballistae
        else if(ammoTypeName.toLowerCase().contains("javelin")) {
            if(weaponName.toLowerCase().contains("ballistae")) return true;
        }
        // Tar -> Salamander
        else if(ammoTypeName.toLowerCase().contains("tar")) {
            if(weaponName.toLowerCase().contains("salamader")) return true;
        }

        // otherwise, ammo does match!
        return false;
    }
}

/* InventoryItemMaxHit.java
 * Contains functions required for calculating max hit based on hovered equipment in inventory.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.game.ItemManager;

public class InventoryItemMaxHit
{
    protected MaxHitCalcConfig config;
    private MaxHit maxHits;
    protected ItemManager itemManager;
    protected Client client;

    InventoryItemMaxHit(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        this.config = config;
        this.maxHits = new MaxHit(plugin, config, itemManager, client);
        this.itemManager = itemManager;
        this.client = client;
    }

    // Crudely determines attack style based on an item's name
    private AttackStyle determineAttackStyle(int weaponID)
    {
        AttackStyle attackStyle;

        // Ranged
        if (client.getItemDefinition(weaponID).getName().contains("bow")
                || client.getItemDefinition(weaponID).getName().contains("Bow")
                || client.getItemDefinition(weaponID).getName().contains("chinchompa")
                || client.getItemDefinition(weaponID).getName().contains("Chinchompa")
                || client.getItemDefinition(weaponID).getName().contains("ballista")
                || client.getItemDefinition(weaponID).getName().contains("dart")
                || client.getItemDefinition(weaponID).getName().contains("knife")
                || client.getItemDefinition(weaponID).getName().contains("thrownaxe")
                || client.getItemDefinition(weaponID).getName().contains("Toktz-xil-ul")
                || client.getItemDefinition(weaponID).getName().contains("blowpipe")
                || client.getItemDefinition(weaponID).getName().contains("Tonalztics of ralos")
                || client.getItemDefinition(weaponID).getName().contains("Eclipse atlatl")
                || client.getItemDefinition(weaponID).getName().contains("Hunter's spear"))
        {
            attackStyle = AttackStyle.RANGING;
        }
        // Magic
        else if (client.getItemDefinition(weaponID).getName().contains("sceptre")
                || client.getItemDefinition(weaponID).getName().contains("staff")
                || client.getItemDefinition(weaponID).getName().contains("Trident")
                || client.getItemDefinition(weaponID).getName().contains("Tumeken's shadow")
                || client.getItemDefinition(weaponID).getName().contains("Staff")
                || client.getItemDefinition(weaponID).getName().contains("wand")
                || client.getItemDefinition(weaponID).getName().contains("crozier")
                || client.getItemDefinition(weaponID).getName().contains("Void knight mace")
                || client.getItemDefinition(weaponID).getName().contains("Blue moon spear"))
        {

            attackStyle = AttackStyle.CASTING;
        }
        else {
            // Assume Melee
            attackStyle = AttackStyle.AGGRESSIVE;
        }

        return attackStyle;
    }

    private Item[] changeEquipment(Item[] currentEquipment, int itemID, int slotID)
    {
        Item[] newEquipment = new Item[14];

        for(int i = 0; i < newEquipment.length; i++)
        {
            if(currentEquipment != null)
            {
                if(i < currentEquipment.length)
                {
                    if (currentEquipment[i] != null)
                    {
                        newEquipment[i] = currentEquipment[i]; // Set new slot item to old slot item
                    }
                }
            }

            if (newEquipment[i] == null)
            {
                newEquipment[i] = new Item(-1, 1);
            }
        }

        newEquipment[slotID] = new Item(itemID, 1);

        return newEquipment;
    }


    /**
     * Predicts max hit of a given item if it is equipped.
     *
     * @param itemID int of Item ID to do prediction on
     * @param slotID int of slot the item will replace
     * @return Max Hit Prediction as Double
     */
    public double predict(int itemID, int slotID)
    {
        // Initialize Variables
        int attackStyleID = client.getVarpValue(VarPlayerID.COM_MODE); // Varplayer: Attack Style
        int weaponTypeID = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);  // Varbit: Equipped Weapon Type
        AttackStyle attackStyle = null;

        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);

        // Determine if Attack Style is correct
        if(slotID == 3)
        {
            // IS A WEAPON
            attackStyle = determineAttackStyle(itemID);
        }
        else
        {
            // Get Current Attack Style
            AttackStyle[] weaponAttackStyles = WeaponType.getWeaponTypeStyles(client, weaponTypeID);
            attackStyle = weaponAttackStyles[attackStyleID];
        }

        // Get corrected slot ID if player is not fully equipped
        //slotID = InventoryItemMaxHit.getCorrectedSlotID(client, slotID);

        // Change equipment slot to new item
        playerEquipment = changeEquipment(playerEquipment, itemID, slotID);

        // Find what type to calculate
        if(attackStyle.equals(AttackStyle.ACCURATE) || attackStyle.equals(AttackStyle.AGGRESSIVE) || attackStyle.equals(AttackStyle.CONTROLLED) || attackStyle.equals(AttackStyle.DEFENSIVE))
        {
            return maxHits.calculateMeleeMaxHit(playerEquipment, attackStyle, attackStyleID, false);
        }
        else if (attackStyle.equals(AttackStyle.RANGING) || attackStyle.equals(AttackStyle.LONGRANGE))
        {
            return maxHits.calculateRangedMaxHit(playerEquipment, attackStyle, attackStyleID);
        }
        else if ((attackStyle.equals(AttackStyle.CASTING)  || attackStyle.equals(AttackStyle.DEFENSIVE_CASTING)))
        {
            double magicMaxHit = maxHits.calculateMagicMaxHit(playerEquipment, attackStyle);

            // If -1, error, skip
            if (magicMaxHit > -1){
                return magicMaxHit;
            }
        }

        return -1;

    }
}

/* MaxAgainstType.java
 * Contains the function for calculating the max hit against specific type.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Skill;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.game.ItemManager;
import java.util.ArrayList;
import java.util.List;

/**
 * Contains functions for calculating max hit vs specific types of npc.
 */
public class MaxAgainstType extends MaxHit {
    MaxAgainstType(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        super(plugin, config, itemManager, client);
    }

    protected List<Double> getTypeBonus(AttackStyle attackStyle, Item[] playerEquipment)
    {
        List<Double> typeBonusToApply = new ArrayList<>();

        // Get Required Items
        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        String amuletItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.AMULET);
        String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
        String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
        String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);

        /*
         Order bonuses by when the bonus was added to the game, not when the item was added
        */

        // Melee Checks
        if(attackStyle == AttackStyle.AGGRESSIVE || attackStyle == AttackStyle.CONTROLLED || attackStyle == AttackStyle.ACCURATE || attackStyle == AttackStyle.DEFENSIVE)
        {
            // Undead and Slayer checks, they are mutually exclusive
            // Salve Amulet (e), Added 22 January 2007
            if (amuletItemName.contains("Salve amulet (e)"))
            {
                typeBonusToApply.add(1.2);
            }
            else if (amuletItemName.contains("Salve amulet(ei)"))
            {
                typeBonusToApply.add(1.2);
            }
            // Black Mask, Added 4 July 2006
            else if (headItemName.contains("Black mask"))
            {
                typeBonusToApply.add(1.1667);
            }
            // Slayer Helm, same as black mask, Attribute Added 4 July 2006
            else if (headItemName.contains("Slayer helmet"))
            {
                typeBonusToApply.add(1.1667);
            }
            else if (headItemName.contains("slayer helmet"))
            {
                typeBonusToApply.add(1.1667);
            }
            // Salve Amulet, Added 21 December 2004
            else if (amuletItemName.contains("Salve amulet"))
            {
                typeBonusToApply.add(1.15);
            }

            // Demonbane, added 4 January 2001
            if(weaponItemName.contains("Silverlight"))
            {
                typeBonusToApply.add(1.6) ;
            }
            else if(weaponItemName.contains("Darklight"))
            {
                typeBonusToApply.add(1.6); // same bonus as silverlight
            }

            // Shades, added 22 March 2006
            if(weaponItemName.contains("Gadderhammer"))
            {
                typeBonusToApply.add(1.25);
            }

            // Demonbane, added 9 June 2016
            if(weaponItemName.contains("Arclight"))
            {
                typeBonusToApply.add(1.7); // different from silverlight and darklight
            }
            else if(weaponItemName.contains("Emberlight"))
            {
                typeBonusToApply.add(1.7); //same as Arclight, but does not degrade
            }

            // Leaf-bladed Battleaxe vs Turoths and Kurasks, 15 September 2016
            if(weaponItemName.contains("Leaf-bladed battleaxe"))
            {
                typeBonusToApply.add(1.175);
            }

            // Dragonbane, added 5 January 2017
            if(weaponItemName.contains("Dragon hunter"))
            {
                typeBonusToApply.add(1.2); // same as dragon hunter crossbow boost which was added first
            }

            // Vampyre, added 24 May 2018
            if(weaponItemName.contains("Ivandis flail"))
            {
                typeBonusToApply.add(1.2);
            }

            // Wilderness, added 26 July 2018
            if(weaponItemName.contains("Viggora's"))
            {
                if(!weaponItemName.contains("(u)"))
                {
                    typeBonusToApply.add(1.5);
                }
            }

            // Wilderness, added 26 July 2018
            if(weaponItemName.contains("Ursine chainmace"))
            {
                if(!weaponItemName.contains("(u)"))
                {
                    typeBonusToApply.add(1.5);
                }
            }

            // Inquisitor's Crush Bonus, added 6 February 2020, set effect removed 25 September 2024
            // Now, wearing the Mace is the only requirement for the inquisitor's crush bonus
            if (weaponItemName.contains("Inquisitor"))
            {
                // If on crush style, which for the mace is all styles except controlled
                if (attackStyle != AttackStyle.CONTROLLED)
                {
                    typeBonusToApply.add(1.025); // +2.5% for the mace

                    // +2.5% crush dmg bonus for each armor piece if wearing the mace
                    if (headItemName.contains("Inquisitor's"))
                    {
                        typeBonusToApply.add(1.025);
                    }

                    if (bodyItemName.contains("Inquisitor's"))
                    {
                        typeBonusToApply.add(1.025);
                    }

                    if (legsItemName.contains("Inquisitor's"))
                    {
                        typeBonusToApply.add(1.025);
                    }
                }
            }

            // Vampyre, added 4 June 2020
            if(weaponItemName.contains("Blisterwood flail"))
            {
                typeBonusToApply.add(1.25);
            }

            // Golem bonus, added 14 April 2021, updated on 28 April 2021
            if(weaponItemName.contains("Barronite mace"))
            {
                typeBonusToApply.add(1.15);
            }

            // Kalphite, acording to Mod Ash, added with Partisan, 27 April 2022
            if(weaponItemName.contains("Keris"))
            {
                if(weaponItemName.contains("amascut"))
                {
                    typeBonusToApply.add(1.15);
                }
                else {
                    typeBonusToApply.add(1.33);
                }
            }

            // Demonbane, added 10 July 2024
            if(weaponItemName.contains("Burning claws"))
            {
                typeBonusToApply.add(1.05) ;
            }

        }
        // Ranged Checks
        else if (attackStyle == AttackStyle.RANGING || attackStyle == AttackStyle.LONGRANGE)
        {
            // Salve Amulet (ei), added 1 May 2014
            if (amuletItemName.contains("Salve amulet(ei)"))
            {
                typeBonusToApply.add(1.2);
            }
            // Salve Amulet (i), added 1 May 2014
            else if (amuletItemName.contains("Salve amulet(i)"))
            {
                typeBonusToApply.add(1.1667) ;
            }
            // Black Mask (i), added 26 September 2013
            else if (headItemName.contains("Black mask"))
            {
                if (headItemName.contains("(i)"))
                {
                    typeBonusToApply.add(1.15);
                }
            }
            // Slayer helm (i)
            else if (headItemName.contains("Slayer helmet (i)"))
            {
                typeBonusToApply.add(1.15); // same as black mask (i) boost which was added first
            }
            else if (headItemName.contains("slayer helmet (i)"))
            {
                typeBonusToApply.add(1.15); // same as black mask (i) boost which was added first
            }

            // Dragonbane, added 5 January 2017
            if(weaponItemName.contains("Dragon hunter"))
            {
                typeBonusToApply.add(1.25);
            }

            // Wilderness, added 26 July 2018
            if(weaponItemName.contains("Craw's bow"))
            {
                if(!weaponItemName.contains("(u)"))
                {
                    typeBonusToApply.add(1.5);
                }
            }

            // Wilderness, added 26 July 2018
            if(weaponItemName.contains("Webweaver bow"))
            {
                if(!weaponItemName.contains("(u)"))
                {
                    typeBonusToApply.add(1.5);
                }
            }

            // Demonbane, added 10 July 2024
            if(weaponItemName.contains("Scorching bow"))
            {
                typeBonusToApply.add(1.3);
            }

        }
        // Magic Checks
        else if (attackStyle == AttackStyle.CASTING || attackStyle == AttackStyle.DEFENSIVE_CASTING)
        {
            // Salve Amulet (ei), added 1 May 2014
            if (amuletItemName.contains("Salve amulet(ei)"))
            {
                typeBonusToApply.add(1.2);
            }
            // Salve Amulet (i), added 1 May 2014
            else if (amuletItemName.contains("Salve amulet(i)"))
            {
                typeBonusToApply.add(1.15) ;
            }
            // Black Mask (i), added 26 September 2013
            else if (headItemName.contains("Black mask"))
            {
                if (headItemName.contains("(i)"))
                {
                    typeBonusToApply.add(1.15);
                }
            }
            // Slayer helm (i)
            else if (headItemName.contains("Slayer helmet (i)"))
            {
                typeBonusToApply.add(1.15); // same as black mask (i) boost which was added first
            }
            else if (headItemName.contains("slayer helmet (i)"))
            {
                typeBonusToApply.add(1.15); // same as black mask (i) boost which was added first
            }

            // Dragonbane, added 5 January 2017 ; OR potentially "new" type since value is different from original, added 25 September 2024
            if(weaponItemName.contains("Dragon hunter"))
            {
                typeBonusToApply.add(1.4);
            }

            // Wilderness, added 26 July 2018
            if(weaponItemName.contains("Thammaron's sceptre"))
            {
                if(!weaponItemName.contains("(u)"))
                {
                    typeBonusToApply.add(1.5);
                }
            }

            // Wilderness, added 26 July 2018
            if(weaponItemName.contains("Accursed sceptre"))
            {
                if(!weaponItemName.contains("u)"))
                {
                    typeBonusToApply.add(1.5);
                }
            }
        }

        return typeBonusToApply; // List of Modifiers
    }

    // Needed for type calculations with Slayer Staff (e) and Purging Staff vs Demons
    protected double getSpellBaseHit(Item[] playerEquipment, AttackStyle weaponAttackStyle)
    {
        double basehit = 0;
        double magicLevel = client.getBoostedSkillLevel(Skill.MAGIC);

        String weaponItemName = "";
        if(playerEquipment.length > EquipmentInventorySlot.WEAPON.getSlotIdx()
                && playerEquipment[EquipmentInventorySlot.WEAPON.getSlotIdx()] != null)
        {
            weaponItemName = client.getItemDefinition(playerEquipment[EquipmentInventorySlot.WEAPON.getSlotIdx()].getId()).getName();
        }

        String capeItemName = "";
        if(playerEquipment.length > EquipmentInventorySlot.CAPE.getSlotIdx()
                && playerEquipment[EquipmentInventorySlot.CAPE.getSlotIdx()] != null)
        {
            capeItemName = client.getItemDefinition(playerEquipment[EquipmentInventorySlot.CAPE.getSlotIdx()].getId()).getName();
        }

        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Magic Weapon: " + client.getItemDefinition(playerItems[EquipmentInventorySlot.WEAPON.getSlotIdx()].getId()).getName(), null);

        // Powered Staff Check
        // Trident of the Seas
        if(weaponItemName.contains("of the seas"))
        {
            basehit = Math.max((Math.floor((Math.min(magicLevel, 125) - 15) / 3)), 1); // Corrected, thanks to Mod Ash
        }
        // Trident of the Swamp
        else if(weaponItemName.contains("of the swamp"))
        {
            basehit = Math.max((Math.floor(((Math.min(magicLevel, 125) - 6) / 3))), 3); // Corrected, thanks to Mod Ash
        }
        // Sanquinesti Staff
        else if(weaponItemName.contains("Sanguinesti"))
        {
            basehit = Math.max((Math.floor(((Math.min(magicLevel, 125) - 3) / 3))), 4); // Corrected, thanks to Mod Ash
        }
        // Thammaron's Sceptre
        else if(weaponItemName.contains("Thammaron's"))
        {
            basehit = (Math.floor(magicLevel/3) - 8);
        }
        // Accursed Sceptre
        else if(weaponItemName.contains("Accursed"))
        {
            basehit = (Math.floor(magicLevel/3) - 6);
        }
        // Tumeken's Shadow
        else if(weaponItemName.contains("Tumeken"))
        {
            basehit = (Math.floor(magicLevel/3) + 1);
        }
        // Warped sceptre
        else if(weaponItemName.contains("Warped sceptre"))
        {
            // Current Wiki Value
            basehit = Math.floor(((8*magicLevel)+96)/37);
        }
        // Crystal staff (basic)
        else if(weaponItemName.contains("Crystal staff (basic)"))
        {
            basehit = 23;
        }
        // Crystal staff (attuned)
        else if(weaponItemName.contains("Crystal staff (attuned)"))
        {
            basehit = 31;
        }
        // Crystal staff (perfected)
        else if(weaponItemName.contains("Crystal staff (perfected)"))
        {
            basehit = 39;
        }
        else if(weaponItemName.contains("Bone staff"))
        {
            basehit = Math.floor(magicLevel/3) + 5;
        }
        // The Eye of Ayak
        else if(weaponItemName.contains("Eye of Ayak"))
        {
            basehit = Math.floor(magicLevel/3) - 6;
        }
        // Autocasted Spell
        else
        {
            // Check if casting without spell selected
            int selectedSpellId = client.getVarbitValue(VarbitID.AUTOCAST_SPELL); // Varbit 276 is Selected Autocasted Spell
            if (selectedSpellId == 0)
            {
                // no spell selected
                return -1; // error
            }

            CombatSpell selectedSpell = CombatSpell.getSpellbyVarbitValue(selectedSpellId);

            // Debug
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "VsType: Selected Spell ID: " + selectedSpellId, null);
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "VsType: Selected Spell: " + selectedSpell, null);

            // Specific Selected Spell Cases
            if (selectedSpell != null)
            {
                // Magic Dart Case
                if(selectedSpell == CombatSpell.MAGIC_DART)
                {
                    double magicDartDamage = Math.floor(magicLevel * ((double)1/10)) + 10;

                    if(weaponItemName.contains("Slayer's staff (e)"))
                    {
                        magicDartDamage = Math.floor(magicLevel * ((double)1/6)) + 13;
                    }

                    basehit = magicDartDamage;
                }
                else
                {
                    // FIND TIER, FIND HIGHEST IN TIER
                    if (selectedSpell.getTier() == 0)
                    {
                        // NO TIER,
                        basehit = selectedSpell.getBaseDamage();
                    }
                    else
                    {
                        // GET TIER, Get highest tier in level
                        int spellTier = selectedSpell.getTier();
                        String spellbook = selectedSpell.getSpellbook();

                        CombatSpell[] spellsInTier = CombatSpell.getSpellsOfTier(spellTier, spellbook);

                        for(CombatSpell spell : spellsInTier)
                        {
                            if(magicLevel >= spell.getReqLevel())
                            {
                                if (basehit <= spell.getBaseDamage())
                                {
                                    // new highest found
                                    basehit = spell.getBaseDamage();
                                }
                            }
                        }

                        // Error, didn't find usable spell
                        if (basehit == 0)
                            return -1; // error
                    }
                }

                // Purging Staff Boost to Demonbane spells
                if(weaponItemName.contains("Purging staff"))
                {
                    if((selectedSpell == CombatSpell.INFERIOR_DEMONBANE) || (selectedSpell == CombatSpell.SUPERIOR_DEMONBANE) || (selectedSpell == CombatSpell.DARK_DEMONBANE))
                    {
                        basehit = (selectedSpell.getBaseDamage() * 2); // Demonbane spells are doubled
                    }
                }

                // God Spell Cases with Charge
                if((selectedSpell == CombatSpell.FLAMES_OF_ZAMORAK) || (selectedSpell == CombatSpell.CLAWS_OF_GUTHIX) || (selectedSpell == CombatSpell.SARADOMIN_STRIKE))
                {
                    if (client.getVarpValue(VarPlayerID.MAGEARENA_CHARGE) > 0) // Varplayer: Charge God Spell
                    {
                        if(selectedSpell == CombatSpell.CLAWS_OF_GUTHIX &&
                                (capeItemName.toLowerCase().contains("guthix cape") ||  capeItemName.toLowerCase().contains("guthix max cape")))
                        {
                            basehit = 30;
                        }
                        else if(selectedSpell == CombatSpell.FLAMES_OF_ZAMORAK &&
                                (capeItemName.toLowerCase().contains("zamorak cape") || capeItemName.toLowerCase().contains("zamorak max cape")))
                        {
                            basehit = 30;
                        }
                        else if(selectedSpell == CombatSpell.SARADOMIN_STRIKE &&
                                (capeItemName.toLowerCase().contains("saradomin cape") || capeItemName.toLowerCase().contains("saradomin max cape")))
                        {
                            basehit = 30;
                        }
                        else
                        {
                            basehit = 20;
                        }
                    }
                    else
                    {
                        basehit = 20;
                    }
                }
            }
        }

        return basehit;
    }

    protected double calculateMagicMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle)
    {
        // Calculate Magic Max Hit
        // Step 1: Find the base hit of the spell
        double spellBaseMaxHit = getSpellBaseHit(playerEquipment, weaponAttackStyle);

        // Step 2: Calculate the Magic Damage Bonus
        double magicDmgBonus = getMagicEquipmentBoost(playerEquipment);

        double maxDamage = (spellBaseMaxHit * magicDmgBonus);

        // Step 3: Calculate Bonuses
        // Tome Bonuses
        double correctTomeSpellBonus = getTomeSpellBonus(playerEquipment, weaponAttackStyle); // default 1
        maxDamage = maxDamage * correctTomeSpellBonus;

        return maxDamage;
    }

    private double calculateTypeMaxHit()
    {
        int attackStyleID = client.getVarpValue(VarPlayerID.COM_MODE); // Varplayer: Attack Style
        int weaponTypeID = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);  // Varbit: Equipped Weapon Type

        // Get Current Attack Style
        AttackStyle[] weaponAttackStyles = WeaponType.getWeaponTypeStyles(client, weaponTypeID);
        AttackStyle attackStyle = weaponAttackStyles[attackStyleID];

        // Get Current Equipment
        Item[] playerEquipment;
        if (client.getItemContainer(InventoryID.WORN) != null ) // Equipment container ID = 94
        {
            playerEquipment = client.getItemContainer(InventoryID.WORN).getItems();
        }
        else
        {
            playerEquipment = null;
        }

        // Find what type to calculate
        if(attackStyle.equals(AttackStyle.ACCURATE) || attackStyle.equals(AttackStyle.AGGRESSIVE) || attackStyle.equals(AttackStyle.CONTROLLED) || attackStyle.equals(AttackStyle.DEFENSIVE))
        {
            return calculateMeleeMaxHit(playerEquipment, attackStyle, attackStyleID, false);
        }
        else if (attackStyle.equals(AttackStyle.RANGING) || attackStyle.equals(AttackStyle.LONGRANGE))
        {
            return calculateRangedMaxHit(playerEquipment, attackStyle, attackStyleID);
        }
        else if ((attackStyle.equals(AttackStyle.CASTING)  || attackStyle.equals(AttackStyle.DEFENSIVE_CASTING)))
        {
            return calculateMagicMaxHit(playerEquipment, attackStyle);
        }
        else
        {
            return -1;
        }
    }

    /**
     * Calculates Max Hit Vs Types
     *
     * @return Max Hit vs Types as Double
     */
    public double calculate()
    {
        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);
        int attackStyleID = client.getVarpValue(VarPlayerID.COM_MODE); // Varplayer: Attack Style
        int weaponTypeID = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);  // Varbit: Equipped Weapon Type

        // Get Current Attack Style
        AttackStyle[] weaponAttackStyles = WeaponType.getWeaponTypeStyles(client, weaponTypeID);
        AttackStyle attackStyle = weaponAttackStyles[attackStyleID];
        if (attackStyle == null)
            return 0;

        // Get Type modifier
        List<Double> typeModifiersList = this.getTypeBonus(attackStyle, playerEquipment);

        // Debug Modifiers
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Type Modifiers: " + typeModifiersList.toString(), null);

        // Get Max hit
        MaxHit normalMaxCalc = new MaxHit(plugin, config, itemManager, client);
        double maxHit = normalMaxCalc.calculate(false); // Normal Max
        double maxHitVsType = Math.floor(this.calculateTypeMaxHit()); // Vs Type Max

        String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        CombatSpell spell = getSpell();

        // Remove bonuses that are constant from normal max hit in order to calculate max vs type.
        // Remove default + 2 colossal blade bonus
        if(weaponName.contains("Colossal blade"))
        {
            maxHitVsType = maxHitVsType - 2; // remove default bonus
        }

        // remove default +10 rat bonus
        if(weaponName.contains("Bone mace") || weaponName.contains("Bone shortbow"))
        {
            maxHitVsType = maxHitVsType - 10;
        }

        // Iterate through modifiers, flooring after multiplying
        if(!typeModifiersList.isEmpty())
        {
            for (double modifier: typeModifiersList)
            {
                maxHitVsType = Math.floor(maxHitVsType * modifier);
            }
        }

        // Re Add Bonuses that do not scale
        // Re-add Colossal Blade Increase, factoring in other modifiers.
        if(weaponName.contains("Colossal blade"))
        {
            int sizeBonus = (2 * Math.min(plugin.NPCSize, 5));

            maxHitVsType = maxHitVsType + sizeBonus;
        }

        // Re-add Rat +10 Damage Bonus
        if(weaponName.contains("Bone mace") || weaponName.contains("Bone shortbow"))
        {
            maxHitVsType = maxHitVsType + 10;
        }

        // Mark of darkness bonuses
        if(spell != null)
        {
            if(plugin.markOfDarknessActive)
            {
                if(spell.getName().toLowerCase().contains("demonbane"))
                {
                    if(weaponName.toLowerCase().contains("purging staff"))
                    {
                        double bonusDmg = Math.floor(maxHitVsType) * 0.5;
                        maxHitVsType = Math.floor(maxHitVsType) + Math.floor(bonusDmg);
                    }
                    else
                    {
                        double bonusDmg = Math.floor(maxHitVsType) * 0.25;
                        maxHitVsType = Math.floor(maxHitVsType) + Math.floor(bonusDmg);
                    }
                }
            }
        }

        // Final step: Calculate and add spell type weakness Bonus
        if (spell != null && spell.hasType())
        {
            // Get original base hit to add elemental bonus
            double spellBaseHit = 0;
            double magicLevel = client.getBoostedSkillLevel(Skill.MAGIC);

            if (spell.getTier() == 0)
            {
                // NO TIER,
                spellBaseHit = spell.getBaseDamage();
            }
            else {
                // GET TIER, Get highest tier in level
                int spellTier = spell.getTier();
                String spellbook = spell.getSpellbook();

                CombatSpell[] spellsInTier = CombatSpell.getSpellsOfTier(spellTier, spellbook);

                for (CombatSpell itSpell : spellsInTier) {
                    if (magicLevel >= spell.getReqLevel()) {
                        if (spellBaseHit <= itSpell.getBaseDamage()) {
                            // new highest found
                            spellBaseHit = itSpell.getBaseDamage();
                        }
                    }
                }
            }

            if (plugin.selectedNPCName != null)
            {
                NPCTypeWeakness weaknessBonus = NPCTypeWeakness.findWeaknessByName(plugin.selectedNPCName);
                if (weaknessBonus != null)
                {
                    if(spell.getSpellType() == weaknessBonus.getElementalWeakness())
                    {
                        int bonusPercent = weaknessBonus.getWeaknessPercent();

                        double typeBonusDamage = spellBaseHit * ((double) bonusPercent / (double)100);
                        maxHitVsType = maxHitVsType + typeBonusDamage;
                    }
                }
            }
        }

        // Twinflame Staff Double Hit bonus
        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        if (weaponItemName.toLowerCase().contains("twinflame staff"))
        {
            if (spell != null && spell.getSpellbook().contains("standard")) {

                if(!spell.getName().toLowerCase().contains("strike") && !spell.getName().toLowerCase().contains("surge"))
                {
                    double bonusHit = Math.floor(maxHitVsType) * 0.4;
                    maxHitVsType = Math.floor(maxHitVsType) + Math.floor(bonusHit);
                }
            }
        }

        if(maxHit >= maxHitVsType)
        {
            return 0; // No Type Bonus
        }
        else
        {
            return maxHitVsType;
        }
    }
}

/* MaxHit.java
 * Contains all functions necessary for calculating the normal max hit per attack type.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.Skill;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.game.ItemManager;

import java.util.ArrayList;
import java.util.List;

/**
 * Contains functions for calculating standard max hit.
 */
public class MaxHit {

    protected MaxHitCalcPlugin plugin;
    protected MaxHitCalcConfig config;
    protected ItemManager itemManager;
    protected Client client;

    MaxHit(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        this.plugin = plugin;
        this.config = config;
        this.itemManager = itemManager;
        this.client = client;
    }

    // Get Prayer Bonus for Max Hit Calculation
    protected double getPrayerBonus(AttackStyle weaponAttackStyle)
    {
        // Melee Prayers
        if(weaponAttackStyle == AttackStyle.ACCURATE || weaponAttackStyle == AttackStyle.AGGRESSIVE || weaponAttackStyle == AttackStyle.CONTROLLED || weaponAttackStyle == AttackStyle.DEFENSIVE)
        {
            // Burst of Strength
            if(client.getVarbitValue(VarbitID.PRAYER_BURSTOFSTRENGTH) == 1) return 1.05;

            // Superhuman Strength
            if(client.getVarbitValue(VarbitID.PRAYER_SUPERHUMANSTRENGTH) == 1) return 1.1;

            // Ultimate Strength
            if(client.getVarbitValue(VarbitID.PRAYER_ULTIMATESTRENGTH) == 1) return 1.15;

            // Chivalry
            if(client.getVarbitValue(VarbitID.PRAYER_CHIVALRY) == 1) return 1.18;

            // Piety
            if(client.getVarbitValue(VarbitID.PRAYER_PIETY) == 1) return 1.23;
        }

        // Ranged Prayers
        if(weaponAttackStyle == AttackStyle.RANGING || weaponAttackStyle == AttackStyle.LONGRANGE)
        {
            // Sharp Eye
            if(client.getVarbitValue(VarbitID.PRAYER_SHARPEYE) == 1) return 1.05;

            // Hawk Eye
            if(client.getVarbitValue(VarbitID.PRAYER_HAWKEYE) == 1) return 1.1;

            // Eagle Eye / Deadeye
            if(client.getVarbitValue(VarbitID.PRAYER_DEADEYE) == 1 || client.getVarbitValue(VarbitID.PRAYER_EAGLEEYE) == 1)
            {
                int deadeyeUnlocked = client.getVarbitValue(VarbitID.PRAYER_DEADEYE_UNLOCKED);

                //System.out.println("deadEyeUnlocked = " + deadeyeUnlocked);

                if (deadeyeUnlocked == 0)
                {
                    //System.out.println("Eagle Eye Active");
                    return 1.15;
                }
                else if (deadeyeUnlocked == 1)
                {
                    //System.out.println("Dead eye Active");
                    return 1.18;
                }
            }

            // Rigour
            if(client.getVarbitValue(VarbitID.PRAYER_RIGOUR) == 1) return 1.23;
        }

        return 1; // default
    }

    protected double getSoulStackBonus()
    {
        int soulStack = client.getVarpValue(VarPlayerID.SOULREAPER_STACKS);

        return 0.06 * soulStack;
    }

    // Get Attack Style Bonus for Melee or Ranged
    protected int getAttackStyleBonus(AttackStyle weaponAttackStyle, int attackStyleID)
    {
        // Return attack style bonus
        // Melee bonuses
        if (weaponAttackStyle.getName().equalsIgnoreCase("Aggressive")) return 3;

        if (weaponAttackStyle.getName().equalsIgnoreCase("Controlled")) return 1;

        // Ranged bonus
        if (weaponAttackStyle.getName().equalsIgnoreCase("RANGING"))
        {
            if(attackStyleID == 0) return 3;
        }

        return 0; // default
    }

    // Get Melee Strength Bonus from Weapon and armor
    protected double getMeleeStrengthBonus(Item[] playerEquipment)
    {
        if (playerEquipment == null) return 0;

        double strengthBonus = 0;

        // Get Melee Strength Bonus of each equipped Item
        for (Item equipmentItem: playerEquipment)
        {
            if (equipmentItem != null)
            {
                if(equipmentItem.getId() != -1)
                {
                    int equipmentID = equipmentItem.getId();

                    // Ensure not null
                    if(itemManager.getItemStats(equipmentID) != null)
                    {
                        int equipmentStrengthStat = itemManager.getItemStats(equipmentID).getEquipment().getStr();

                        strengthBonus += equipmentStrengthStat;
                    }
                }
            }
        }

        return strengthBonus;
    }

    protected double getVoidMeleeBonus(Item[] playerEquipment)
    {
        if (playerEquipment == null) return 1;

        // Get required items for void check
        String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
        String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
        String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);
        String glovesItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.GLOVES);

        // Check for set bonus
        if (headItemName.contains("Void melee"))
        {
            if (glovesItemName.contains("Void"))
            {
                // Melee helm and gloves, check for elite or not
                if (bodyItemName.contains("Void"))
                {
                    if (legsItemName.contains("Void"))
                    {
                        // Normal void set
                        return 1.1;
                    }
                }
                else if (bodyItemName.contains("Elite void"))
                {
                    if(legsItemName.contains("Elite void"))
                    {
                        // Elite void set
                        return 1.1; // same for melee
                    }
                }
            }
        }

        // Void Set incomplete, no bonus
        return 1;
    }

    // Passive Melee Set effects
    protected List<Double> getMeleeSpecialBonusMultiplier(Item[] playerEquipment)
    {
        List<Double> specialBonusesToApply = new ArrayList<>();

        if (playerEquipment == null) return specialBonusesToApply;

        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
        String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
        String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);
        String ammuletItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.AMULET);

        // SPECIAL BONUSES MUST BE ORDERED CORRECTLY.
        // Dharok's Set Check
        if (headItemName.contains("Dharok's"))
        {
            if(bodyItemName.contains("Dharok's"))
            {
                if(legsItemName.contains("Dharok's"))
                {
                    if(weaponItemName.contains("Dharok's"))
                    {
                        // Passed Check, Dharok's Set Equipped, Apply Effect
                        double baseHP = client.getRealSkillLevel(Skill.HITPOINTS);
                        double currentHP = client.getBoostedSkillLevel(Skill.HITPOINTS);
                        double dharokBonus = ((((baseHP - currentHP) / 100) * (baseHP / 100)));

                        specialBonusesToApply.add(dharokBonus);
                    }
                }
            }
        }

        // Obsidian Set Check
        if (headItemName.contains("Obsidian"))
        {
            if(bodyItemName.contains("Obsidian"))
            {
                if(legsItemName.contains("Obsidian"))
                {
                    if(weaponItemName.contains("ket") || weaponItemName.contains("xil"))
                    {
                        specialBonusesToApply.add(0.1);
                    }
                }
            }
        }

        // Berserker Necklace and Obisidian Melee Check
        if(weaponItemName.contains("ket") || weaponItemName.contains("xil"))
        {
            if(ammuletItemName.contains("Berserker"))
            {
                specialBonusesToApply.add(0.2);
            }
        }

        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Special Bonus: " + specialBonus, null);

        return specialBonusesToApply;
    }

    // Calculate Melee Max Hit
    protected double calculateMeleeMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, int attackStyleID, boolean isSpecialAttack)
    {
        // Calculate Melee Max Hit
        // Step 1: Calculate effective Strength
        int strengthLevel = client.getBoostedSkillLevel(Skill.STRENGTH);
        double prayerBonus = getPrayerBonus(weaponAttackStyle);
        int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
        double voidBonus = getVoidMeleeBonus(playerEquipment); // default 1;
        double soulStackBonus = getSoulStackBonus();
        double effectiveSoulStackLevel = 0;

        if (!isSpecialAttack)
        {
            effectiveSoulStackLevel = Math.floor(strengthLevel * soulStackBonus);
        }

        double effectiveStrength = Math.floor((Math.floor(strengthLevel * prayerBonus) + effectiveSoulStackLevel + styleBonus + 8) * voidBonus);

        // Step 2: Calculate the base damage
        double strengthBonus = getMeleeStrengthBonus(playerEquipment); // default 0

        double baseDamage = (0.5 + (effectiveStrength * ((strengthBonus + 64)/640)));
        double flooredBaseDamage = Math.floor(baseDamage);

        // Step 3: Calculate the bonus damage
        List<Double> specialBonusMultipliers = getMeleeSpecialBonusMultiplier(playerEquipment); // default empty

        double maxHit = flooredBaseDamage;

        if(!specialBonusMultipliers.isEmpty())
        {
            for (double bonus: specialBonusMultipliers)
            {
                maxHit += Math.floor(maxHit * bonus);
            }
        }

        // Osmumten's Fang Decrease
        String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        if (weaponName.contains("Osmumten's fang"))
        {
            maxHit = maxHit * 0.85 + 1;
        }

        // Colossal Blade Base Increase
        if(weaponName.contains("Colossal blade")){
            maxHit = maxHit + 2;
        }

        // Rat Default +10 damage Bonus
        if(weaponName.contains("Bone mace"))
        {
            maxHit = maxHit + 10;
        }

        // Complete
        return maxHit;
    }

    // Get Ranged Void Bonus for Elite and Normal Sets
    protected double getVoidRangedBonus(Item[] playerEquipment)
    {
        // Get required items for void check
        String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
        String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
        String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);
        String glovesItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.GLOVES);

        // Check for set bonus
        if (headItemName.contains("Void ranger"))
        {
            if (glovesItemName.contains("Void"))
            {
                // Ranged helm and gloves, check for elite or not
                if (bodyItemName.contains("Void"))
                {
                    if (legsItemName.contains("Void"))
                    {
                        // Normal void set
                        return 1.1;
                    }
                }
                else if (bodyItemName.contains("Elite void"))
                {
                    if(legsItemName.contains("Elite void"))
                    {
                        // Elite void set
                        return 1.125;
                    }
                }
            }
        }

        // Void Set incomplete, no bonus
        return 1;
    }

    // Get Ranged Strength Bonus from Equipment
    protected double getRangedStrengthBonus(Item[] playerEquipment)
    {
        double rangedStrengthBonus = 0;

        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Weapon Name: " + client.getItemDefinition(playerEquipment[EquipmentInventorySlot.WEAPON.getSlotIdx()].getId()).getName(), null);

        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        int weaponID = EquipmentItems.getItemIdInGivenSetSlot(playerEquipment, EquipmentInventorySlot.WEAPON);

        String ammoItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.AMMO);
        int ammoID = EquipmentItems.getItemIdInGivenSetSlot(playerEquipment, EquipmentInventorySlot.AMMO);

        String capeItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.CAPE);
        int capeID = EquipmentItems.getItemIdInGivenSetSlot(playerEquipment, EquipmentInventorySlot.CAPE);

        String quiverItemName;
        int quiverItemID;

        boolean skipAmmo = false;
        boolean calcWithMelee = false;

        // Cases to skip ammo: throwing weapons, crystal bow, blowpipe
        if (weaponItemName.contains("dart") || weaponItemName.contains("knife") || weaponItemName.contains("thrownaxe") || weaponItemName.contains("Toktz-xil-ul"))
        {
            // "Stackable" Throwing weapons
            skipAmmo = true;
        }
        else if(weaponItemName.contains("Morrigan's javelin") || weaponItemName.contains("Morrigan's throwing axe") || weaponItemName.contains("Mud pie"))
        {
            // Not Stackable Throwing Weapons
            skipAmmo = true;
        }
        else if (weaponItemName.contains("Crystal bow")
                || weaponItemName.contains("faerdhinen")
                || weaponItemName.contains("Webweaver")
                || weaponItemName.contains("Craw's"))
        {
            skipAmmo = true;
        }
        else if(weaponItemName.contains("blowpipe"))
        {
            skipAmmo = true;

            if(plugin.selectedDartType == BlowpipeDartType.ADAMANT)
            {
                rangedStrengthBonus += 17;
            }
            else if(plugin.selectedDartType == BlowpipeDartType.RUNE)
            {
                rangedStrengthBonus += 26;
            }
            else if(plugin.selectedDartType == BlowpipeDartType.AMETHYST)
            {
                rangedStrengthBonus += 28;
            }
            else if(plugin.selectedDartType == BlowpipeDartType.DRAGON)
            {
                rangedStrengthBonus += 35;
            }
            else
            {
                rangedStrengthBonus += 9; // default and lowest (mithril)
            }
        }
        else if(weaponItemName.contains("Tonalztics"))
        {
            skipAmmo = true;
        }
        else if(weaponItemName.contains("atlatl"))
        {
            skipAmmo = true;
            calcWithMelee = true;
        }
        else if(weaponItemName.contains("Hunter's spear"))
        {
            skipAmmo = true;
            calcWithMelee = true;
        }

        // Check Ammo type matches up with weapon
        if(!skipAmmo)
        {
            // Check if ammo type matches with weapon, otherwise skip ammo slot in calc
            if(ammoID != -1)
            {
                if(!EquipmentItems.doesAmmoMatchWeapon(ammoItemName, weaponItemName))
                {
                    // Ammo did not match weapon, skip ammo for calc
                    skipAmmo = true;
                }
            }


            // Quiver Check
//            if(capeItemName.toLowerCase().contains("quiver"))
//            {
//                quiverItemName = EquipmentItems.getQuiverItemName(client);
//                quiverItemID = EquipmentItems.getQuiverItemID(client);
//
//
////                if(!capeItemName.toLowerCase().contains("uncharged"))
////                {
////                    rangedStrengthBonus += 1; // Bonus range strength to ammo when Quiver is charged
////                }
//
//                if (ammoID != -1 && quiverItemID != -1)
//                {
//                    // determine if we use quiver's ammo, or default slot ammo, or Neither!
//
//                    if(weaponItemName.toLowerCase().contains("bow"))
//                    {
//                        if(ammoItemName.toLowerCase().contains())
//                    }
//                }
//                else if (ammoID == -1 && quiverItemID >= 0) {
//
//                }
//                else if(ammoID )
//            }
        }



        // Get Ranged Strength Bonus of each equipped Item
        for (Item equipmentItem: playerEquipment)
        {
            if (equipmentItem != null)
            {
                if(equipmentItem.getId() != -1)
                {
                    int equipmentID = equipmentItem.getId();

                    // Ensure not null
                    if(itemManager.getItemStats(equipmentID) != null)
                    {
                        if(!calcWithMelee)
                        {
                            int equipmentStrengthStat = itemManager.getItemStats(equipmentID).getEquipment().getRstr();

                            if (equipmentID != ammoID || !skipAmmo)
                            {
                                // If equipment ID == Ammo, skip if skipAmmo is true
                                rangedStrengthBonus += equipmentStrengthStat;
                            }
                        }
                        else
                        {
                            int equipmentStrengthStat = itemManager.getItemStats(equipmentID).getEquipment().getStr();

                            if (equipmentID != ammoID || !skipAmmo)
                            {
                                // If equipment ID == Ammo, skip if skipAmmo is true
                                rangedStrengthBonus += equipmentStrengthStat;
                            }
                        }

                    }
                }
            }
        }

        return rangedStrengthBonus;
    }

    // Get Gear Boost, for instance Crystal Armor set bonus
    protected double getRangeGearBoost(Item[] playerEquipment)
    {
        double damagePercentBonus = 1;

        // Get Required Item Names for checks
        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
        String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
        String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);


        if (weaponItemName.contains("Crystal bow") || weaponItemName.contains("faerdhinen"))
        {
            // Crystal Armor Damage bonus
            if (headItemName.contains("Crystal helm"))
            {
                if(!headItemName.contains("(basic)")
                        || !headItemName.contains("(attuned)")
                        || !headItemName.contains("(perfected)"))
                {
                    damagePercentBonus += 0.025;
                }
            }

            if (bodyItemName.contains("Crystal body"))
            {
                if(!bodyItemName.contains("(basic)")
                        || !bodyItemName.contains("(attuned)")
                        || !bodyItemName.contains("(perfected)"))
                {
                    damagePercentBonus += 0.075;
                }
            }

            if (legsItemName.contains("Crystal legs"))
            {
                if(!legsItemName.contains("(basic)")
                        || !legsItemName.contains("(attuned)")
                        || !legsItemName.contains("(perfected)"))
                {
                    damagePercentBonus += 0.05;
                }
            }
        }

        return damagePercentBonus;
    }

    // Calculate Ranged Max Hit
    protected double calculateRangedMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, int attackStyleID)
    {
        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);

        // Calculate Ranged Max Hit
        // Step 1: Calculate effective ranged Strength
        int rangedLevel = client.getBoostedSkillLevel(Skill.RANGED);
        double prayerBonus = getPrayerBonus(weaponAttackStyle);
        int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
        double voidBonus = getVoidRangedBonus(playerEquipment); // default 1;

        // If using the atlatl, calculate with strength instead of ranged
        if(weaponItemName.contains("atlatl"))
        {
            rangedLevel  = client.getBoostedSkillLevel(Skill.STRENGTH);
        }

        double effectiveRangedStrength = Math.floor((Math.floor(rangedLevel * prayerBonus) + styleBonus + 8) * voidBonus);

        // Step 2: Calculate the max hit
        double equipmentRangedStrength = getRangedStrengthBonus(playerEquipment);
        double gearBonus = getRangeGearBoost(playerEquipment);

        double maxHit = (0.5 + (((effectiveRangedStrength * (equipmentRangedStrength + 64))/640) * gearBonus) );

        // Step 3: Bonus damage from special attack and effects
        // Rat Default +10 damage Bonus

        if(weaponItemName.contains("Bone shortbow"))
        {
            maxHit = maxHit + 10;
        }

        // Tonalztics of Ralos (uncharged) max hit is 75% of normal
        if(weaponItemName.contains("Tonalztics of ralos"))
        {
            maxHit = Math.floor(maxHit * 0.75); // unknown if flooring here causes miscalcs
            if(!weaponItemName.contains("(uncharged)"))
            {
                maxHit = maxHit * 2;
            }
        }

        return maxHit;
    }

    protected double getSpellBaseHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, double magicLevel)
    {
        double basehit = 0;

        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        String capeItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.CAPE);
        String glovesItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.GLOVES);

        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Magic Weapon: " + client.getItemDefinition(playerItems[EquipmentInventorySlot.WEAPON.getSlotIdx()].getId()).getName(), null);

        // Powered Staff Check
        // Trident of the Seas
        if(weaponItemName.contains("of the seas"))
        {
            basehit = Math.max((Math.floor((Math.min(magicLevel, 125) - 15) / 3)), 1); // Corrected, thanks to Mod Ash
        }
        // Trident of the Swamp
        else if(weaponItemName.contains("of the swamp"))
        {
            basehit = Math.max((Math.floor(((Math.min(magicLevel, 125) - 6) / 3))), 3); // Corrected, thanks to Mod Ash
        }
        // Sanquinesti Staff
        else if(weaponItemName.contains("Sanguinesti"))
        {
            basehit = Math.max((Math.floor(((Math.min(magicLevel, 125) - 3) / 3))), 4); // Corrected, thanks to Mod Ash
        }
        // Thammaron's Sceptre
        else if(weaponItemName.contains("Thammaron's"))
        {
            basehit = (Math.floor(magicLevel/3) - 8);
        }
        // Accursed Sceptre
        else if(weaponItemName.contains("Accursed"))
        {
            basehit = (Math.floor(magicLevel/3) - 6);
        }
        // Tumeken's Shadow
        else if(weaponItemName.contains("Tumeken"))
        {
            basehit = (Math.floor(magicLevel/3) + 1);
        }
        // Warped sceptre
        else if(weaponItemName.contains("Warped sceptre"))
        {
            // Current Wiki Value
            basehit = Math.floor(((8*magicLevel)+96)/37);

            /* My math estimate
            if(magicLevel >= 99)
            {
                basehit = Math.floor((magicLevel/5) + 4.2);
            }
            else
            {
                basehit = Math.floor((magicLevel/5) + 3.6);
            }
            */
        }
        // Crystal staff (basic)
        else if(weaponItemName.contains("Crystal staff (basic)"))
        {
            basehit = 23;
        }
        // Crystal staff (attuned)
        else if(weaponItemName.contains("Crystal staff (attuned)"))
        {
            basehit = 31;
        }
        // Crystal staff (perfected)
        else if(weaponItemName.contains("Crystal staff (perfected)"))
        {
            basehit = 39;
        }
        // Corrupted staff (basic)
        else if(weaponItemName.contains("Corrupted staff (basic)"))
        {
            basehit = 23;
        }
        // Corrupted staff (attuned)
        else if(weaponItemName.contains("Corrupted staff (attuned)"))
        {
            basehit = 31;
        }
        // Corrupted staff (perfected)
        else if(weaponItemName.contains("Corrupted staff (perfected)"))
        {
            basehit = 39;
        }
        // Bone Staff
        else if(weaponItemName.contains("Bone staff"))
        {
            basehit = Math.floor(magicLevel/3) + 5;
        }
        // The Eye of Ayak
        else if(weaponItemName.contains("Eye of Ayak"))
        {
            basehit = Math.floor(magicLevel/3) - 6;
        }
        // Autocasted Spell
        else
        {
            int selectedSpellId = client.getVarbitValue(VarbitID.AUTOCAST_SPELL); // Varbit 276 is Selected Autocasted Spell
            if (selectedSpellId == 0)
            {
                // no spell selected
                return -1; // error
            }

            CombatSpell selectedSpell = CombatSpell.getSpellbyVarbitValue(selectedSpellId); // returns null as default

            // Debug
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "MH: Selected Spell: " + selectedSpell, null);

            // Specific Selected Spell Cases
            if (selectedSpell == null)
            {
                //System.out.println("Error");
                return -1; // error
            }
            else
            {
                // Magic Dart Case
                if(selectedSpell == CombatSpell.MAGIC_DART)
                {
                    double magicDartDamage = Math.floor(magicLevel * ((double)1/10)) + 10;

                    basehit = magicDartDamage;
                }
                else
                {
                    // FIND TIER, FIND HIGHEST IN TIER
                    if (selectedSpell.getTier() == 0)
                    {
                        // NO TIER,
                        basehit = selectedSpell.getBaseDamage();
                    }
                    else
                    {
                        // GET TIER, Get highest tier in level
                        int spellTier = selectedSpell.getTier();
                        String spellbook = selectedSpell.getSpellbook();

                        CombatSpell[] spellsInTier = CombatSpell.getSpellsOfTier(spellTier, spellbook);

                        for(CombatSpell spell : spellsInTier)
                        {
                            if(magicLevel >= spell.getReqLevel())
                            {
                                if (basehit <= spell.getBaseDamage())
                                {
                                    // new highest found
                                    basehit = spell.getBaseDamage();
                                }
                            }
                        }

                        // Error, didn't find usable spell
                        if (basehit == 0)
                            return -1; // error
                    }


                }

                // God Spell Cases with Charge
                if((selectedSpell == CombatSpell.FLAMES_OF_ZAMORAK) || (selectedSpell == CombatSpell.CLAWS_OF_GUTHIX) || (selectedSpell == CombatSpell.SARADOMIN_STRIKE))
                {
                    if (client.getVarpValue(VarPlayerID.MAGEARENA_CHARGE) > 0) // Varplayer: Charge God Spell
                    {
                        if(selectedSpell == CombatSpell.CLAWS_OF_GUTHIX &&
                                (capeItemName.toLowerCase().contains("guthix cape") ||  capeItemName.toLowerCase().contains("guthix max cape")))
                        {
                            basehit = 30;
                        }
                        else if(selectedSpell == CombatSpell.FLAMES_OF_ZAMORAK &&
                                (capeItemName.toLowerCase().contains("zamorak cape") || capeItemName.toLowerCase().contains("zamorak max cape")))
                        {
                            basehit = 30;
                        }
                        else if(selectedSpell == CombatSpell.SARADOMIN_STRIKE &&
                                (capeItemName.toLowerCase().contains("saradomin cape") || capeItemName.toLowerCase().contains("saradomin max cape")))
                        {
                            basehit = 30;
                        }
                        else
                        {
                            basehit = 20;
                        }
                    }
                    else
                    {
                        basehit = 20;
                    }
                }

                // Chaos Gauntlet Bonus Check
                if(selectedSpell.getName().toLowerCase().contains("bolt"))
                {
                    if (glovesItemName.toLowerCase().contains("chaos gauntlets"))
                    {
                        basehit += 3;
                    }
                }
            }
        }

        return basehit;
    }

    // Get Spell Info
    protected CombatSpell getSpell(){
        int selectedSpellId = client.getVarbitValue(VarbitID.AUTOCAST_SPELL); // Varbit 276 is Selected Autocasted Spell
        if (selectedSpellId == 0)
        {
            // no spell selected
            return null; // error
        }

        CombatSpell selectedSpell = CombatSpell.getSpellbyVarbitValue(selectedSpellId); // returns null as default

        return selectedSpell;
    }

    protected double getMagicEquipmentBoost(Item[] playerEquipment)
    {
        if (playerEquipment == null) return 1;

        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        double magicdamagebonus = 0;

        // Get Magic Strength Bonus of each equipped Item
        for (Item equipmentItem: playerEquipment)
        {
            if (equipmentItem != null)
            {
                if (equipmentItem.getId() != -1)
                {
                    int equipmentID = equipmentItem.getId();

                    double equipmentMagicBonusStat = 0;

                    // Ensure not null
                    if(itemManager.getItemStats(equipmentID) != null)
                    {
                        equipmentMagicBonusStat = itemManager.getItemStats(equipmentID).getEquipment().getMdmg();

                        magicdamagebonus += (equipmentMagicBonusStat/100);
                    }

                }
            }
        }

        // Get Void 2.5% bonus if necessary, otherwise +0
        magicdamagebonus += getVoidMagicBonus(playerEquipment);

        // Get Tumeken's Shadow Bonus
        if(weaponItemName.contains("Tumeken"))
        {
            magicdamagebonus *= 3;

            magicdamagebonus = Math.min(magicdamagebonus, 1);
        }

        // Get Virtus Robe's Damage Bonus for Ancient Magicks
        CombatSpell selectedSpell = CombatSpell.getSpellbyVarbitValue(client.getVarbitValue(VarbitID.AUTOCAST_SPELL));
        if(selectedSpell != null){
            if (selectedSpell.getName().toLowerCase().contains("smoke")
                    || selectedSpell.getName().toLowerCase().contains("shadow")
                    || selectedSpell.getName().toLowerCase().contains("blood")
                    || selectedSpell.getName().toLowerCase().contains("ice"))
            {
                // Get Item names
                String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
                String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
                String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);

                // Add bonus per robe
                if(headItemName.toLowerCase().contains("virtus"))
                {
                    magicdamagebonus += 0.03; // 1% added normally, add 3% to make total 4% bonus
                }

                if(bodyItemName.toLowerCase().contains("virtus"))
                {
                    magicdamagebonus += 0.03;
                }

                if(legsItemName.toLowerCase().contains("virtus"))
                {
                    magicdamagebonus += 0.03;
                }
            }
        }

        // Prayer Bonuses
        // Mystic Lore
        if(client.getVarbitValue(VarbitID.PRAYER_MYSTICLORE) == 1) magicdamagebonus += 0.01;

        // Mystic Might / Mystic Vigour
        if(client.getVarbitValue(VarbitID.PRAYER_MYSTICMIGHT) == 1 || client.getVarbitValue(VarbitID.PRAYER_MYSTICVIGOUR) == 1)
        {
            int vigourUnlocked = client.getVarbitValue(VarbitID.PRAYER_MYSTIC_VIGOUR_UNLOCKED);

            //System.out.println("MysticVigour = " + vigourUnlocked);

            if (vigourUnlocked == 0)
            {
                //System.out.println("Mystic Might Active");
                magicdamagebonus += 0.02;
            }
            else if (vigourUnlocked == 1)
            {
                //System.out.println("Mystic Vigour Active");
                magicdamagebonus += 0.03;
            }
        }

        // Augury
        if(client.getVarbitValue(VarbitID.PRAYER_AUGURY) == 1) magicdamagebonus += 0.04;


        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Bonus Magic Damage: " + magicdamagebonus*100 + "%", null);

        // Smoke Battlestaff Dmg Bonus
        CombatSpell spell = getSpell();
        if (weaponItemName.toLowerCase().contains("smoke battlestaff") || weaponItemName.toLowerCase().contains("smoke staff"))
        {
            if (spell != null && spell.getSpellbook().contains("standard")) {
                magicdamagebonus += 0.1;
            }
        }

        // Twinflame Staff Magic Dmg Bonus
        if (weaponItemName.toLowerCase().contains("twinflame staff"))
        {
            if (spell != null && spell.getSpellbook().contains("standard")) {
                magicdamagebonus += 0.1;
            }
        }

        return 1 + magicdamagebonus; // Default is 1.
    }

    protected double getVoidMagicBonus(Item[] playerEquipment)
    {
        if (playerEquipment == null) return 0;

        // Get required items for void check
        String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
        String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
        String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);
        String glovesItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.GLOVES);

        // Check for set bonus
        if (headItemName.contains("Void mage"))
        {
            if (glovesItemName.contains("Void"))
            {
                if (bodyItemName.contains("Elite void"))
                {
                    if(legsItemName.contains("Elite void"))
                    {
                        // Elite void set
                        return 0.05; // 5% magic dmg bonus
                    }
                }
            }
        }

        // Elite Void Set incomplete, no bonus
        return 0;
    }

    protected double getTomeSpellBonus(Item[] playerEquipment, AttackStyle weaponAttackStyle)
    {
        String shieldItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.SHIELD);

        // Check if casting without spell selected
        int selectedSpellId = client.getVarbitValue(VarbitID.AUTOCAST_SPELL); // Varbit 276 is Selected Autocasted Spell
        if (selectedSpellId == 0)
        {
            // no spell selected
            return 1; // no bonus, default
        }

        CombatSpell selectedSpell = CombatSpell.getSpellbyVarbitValue(selectedSpellId); // returns null as default

        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Selected Spell Sprite ID: " + spellSpriteID, null);
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Selected Spell: " + selectedSpell, null);

        // Spell is selected, not casting from weapon
        if (selectedSpell == null)
        {
            return 1; // no bonus, default
        }
        else
        {
            if (selectedSpell.getName().toLowerCase().contains("fire"))
            {
                // Check for tome of fire
                if (shieldItemName.contains("Tome of fire"))
                {
                    if (!shieldItemName.contains("(empty)"))
                    {
                        return 1.1;
                    }
                }
            }

            if (selectedSpell.getName().toLowerCase().contains("water"))
            {
                // Check for tome of water
                if (shieldItemName.contains("Tome of water"))
                {
                    if (!shieldItemName.contains("(empty)"))
                    {
                        return 1.1;
                    }
                }
            }

            if (selectedSpell.getName().toLowerCase().contains("earth"))
            {
                // Check for tome of water
                if (shieldItemName.contains("Tome of earth"))
                {
                    if (!shieldItemName.contains("(empty)"))
                    {
                        return 1.1;
                    }
                }
            }
        }

        return 1;
    }

    // Calculate Standard Magic Max Hit
    protected double calculateMagicMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle)
    {
        // Calculate Magic Max Hit
        // Step 1: Find the base hit of the spell
        double spellBaseMaxHit = getSpellBaseHit(playerEquipment, weaponAttackStyle, client.getBoostedSkillLevel(Skill.MAGIC));

        if (spellBaseMaxHit == 0)
        {
            return -1;
        }

        // Step 2: Calculate the Magic Damage Bonus
        double magicDmgBonus = getMagicEquipmentBoost(playerEquipment);

        double maxDamage = (spellBaseMaxHit * magicDmgBonus);

        // Step 3: Calculate Bonuses
        // Tome Bonuses
        double correctTomeSpellBonus = getTomeSpellBonus(playerEquipment, weaponAttackStyle); // default 1
        maxDamage = maxDamage * correctTomeSpellBonus;

        // Final step: Calculate and add spell type weakness Bonus
        CombatSpell spell = getSpell();
        if (spell != null && spell.hasType())
        {
            if (plugin.selectedNPCName != null)
            {
                NPCTypeWeakness weaknessBonus = NPCTypeWeakness.findWeaknessByName(plugin.selectedNPCName);
                if (weaknessBonus != null)
                {
                    if(spell.getSpellType() == weaknessBonus.getElementalWeakness())
                    {
                        int bonusPercent = weaknessBonus.getWeaknessPercent();

                        double typeBonusDamage = spellBaseMaxHit * ((double) bonusPercent / (double)100);
                        maxDamage = maxDamage + typeBonusDamage;
                    }
                }
            }
        }

        // Twinflame Staff Double Hit bonus
        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        if (weaponItemName.toLowerCase().contains("twinflame staff"))
        {
            if (spell != null && spell.getSpellbook().contains("standard"))
            {
                if(!spell.getName().toLowerCase().contains("strike") && !spell.getName().toLowerCase().contains("surge"))
                {
                    double bonusHit = Math.floor(maxDamage) * 0.4;
                    maxDamage = Math.floor(maxDamage) + Math.floor(bonusHit);
                }
            }
        }

        return maxDamage;
    }

    /**
     * Calculates the standard max hit based on current equipment and player status.
     *
     * @param isSpecialAttack boolean
     * @return Max Hit as Double
     */
    public double calculate(boolean isSpecialAttack)
    {
        int attackStyleID = client.getVarpValue(VarPlayerID.COM_MODE); // Varplayer: Attack Style
        int weaponTypeID = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);  // Varbit: Equipped Weapon Type

        // Get Current Attack Style
        AttackStyle[] weaponAttackStyles = WeaponType.getWeaponTypeStyles(client, weaponTypeID);
        AttackStyle attackStyle = weaponAttackStyles[attackStyleID];
        if (attackStyle == null)
            return -1;

        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);

        // Find what type to calculate
        if(attackStyle.equals(AttackStyle.ACCURATE) || attackStyle.equals(AttackStyle.AGGRESSIVE) || attackStyle.equals(AttackStyle.CONTROLLED) || attackStyle.equals(AttackStyle.DEFENSIVE))
        {
            return this.calculateMeleeMaxHit(playerEquipment, attackStyle, attackStyleID, isSpecialAttack);
        }
        else if (attackStyle.equals(AttackStyle.RANGING) || attackStyle.equals(AttackStyle.LONGRANGE))
        {
            return this.calculateRangedMaxHit(playerEquipment, attackStyle, attackStyleID);
        }
        else if ((attackStyle.equals(AttackStyle.CASTING)  || attackStyle.equals(AttackStyle.DEFENSIVE_CASTING)))
        {
            return this.calculateMagicMaxHit(playerEquipment, attackStyle);
        }
        else
        {
            return -1;
        }
    }
}

/* MaxHitCalcConfig.java
 * Contains all config items for the plugin.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("MaxHitCalc")
public interface MaxHitCalcConfig extends Config
{
	@ConfigSection(
			name = "Main Panel",
			description = "Settings relating to the Main Panel",
			position =  2,
			closedByDefault = false
	)
	String mainPanelSettings = "Main Panel";

	@ConfigSection(
			name = "Special Attack Settings",
			description = "Settings for Special Attacks and Weapons",
			position =  3,
			closedByDefault = false
	)
	String specSettings = "Special Attack Settings";

	@ConfigSection(
			name = "Inventory Settings",
			description = "Settings relating to tooltips on Inventory Items",
			position =  4,
			closedByDefault = false
	)
	String inventorySettings = "Inventory Settings";

	@ConfigSection(
			name = "Spell Settings",
			description = "Settings relating to tooltips on Spells",
			position =  5,
			closedByDefault = false
	)
	String spellSettings = "Spell Settings";

	// Persistent Blowdart Setting
	@ConfigItem(
			keyName = "blowpipeDartType",
			name = "Blowpipe Dart Type",
			description = "Sets the Dart type for calculation",
			position = 0
	)
	default BlowpipeDartType blowpipeDartType()
	{
		return BlowpipeDartType.MITHRIL;
	}

	// Show Max Hit
	@ConfigItem(
			keyName = "showMaxHit",
			name = "Display Max Hit",
			description = "Shows your Max Hit with equipped item.",
			position = 0,
			section = mainPanelSettings
	)
	default boolean showMaxHit()
	{
		return true;
	}

	// Show Max Spec
	@ConfigItem(
		keyName = "showSpec",
		name = "Display Max Spec",
		description = "Shows your Max Spec with equipped items.",
		position = 1,
		section = mainPanelSettings
	)
	default boolean showSpec()
	{
		return true;
	}

	// Show Max Hit vs Type
	@ConfigItem(
			keyName = "showType",
			name = "Display Max Hit vs Type",
			description = "Shows your Max Hit vs current Type bonus.",
			position = 2,
			section = mainPanelSettings
	)
	default boolean showType()
	{
		return true;
	}

	// Show Max Spec vs Type
	@ConfigItem(
			keyName = "showSpecVsType",
			name = "Display Max Spec vs Type",
			description = "Shows your Max Spec vs current Type bonus.",
			position = 3,
			section = mainPanelSettings
	)
	default boolean showSpecVsType()
	{
		return true;
	}

	// Show Predicted Requirements for next Max Hit
	@ConfigItem(
			keyName = "showPredictionTooltip",
			name = "Tooltip for Predicted Next Max Hit",
			description = "Hover over the panel for a prediction of requirements for next max hit.",
			position = 4,
			section = mainPanelSettings
	)
	default boolean showPredictionTooltip()
	{
		return true;
	}

	// Whether to show or hide the plugin's side panel
	@ConfigItem(
			keyName = "showPanel",
			name = "Show Side Panel",
			description = "Enable or disable the side panel",
			position = 5,
			section = mainPanelSettings
	)
	default boolean showPanel() { return true; }

	// Show Predicted Requirements for next Max Hit
	@ConfigItem(
			keyName = "displayDoubleHitWeaponsAsOneHit",
			name = "Combine Multi Hit Specs as One Hit",
			description = "Weapons like the DDS will display as one hit calculation.",
			position = 0,
			section = specSettings
	)
	default boolean displayMultiHitWeaponsAsOneHit()
	{
		return true;
	}

	// Show Predicted Max Hit when hovering over item in inventory
	@ConfigItem(
			keyName = "showInventoryTooltip",
			name = "Tooltip on Inventory Items",
			description = "Hover over an item in your inventory to see it's max hit impact when equipped.",
			position = 0,
			section = inventorySettings
	)
	default boolean showInventoryTooltip() { return true; }

	// Show Predicted Max Hit when hovering over item in bank or bank inventory
	@ConfigItem(
			keyName = "showBankTooltip",
			name = "Tooltip on Bank Items",
			description = "Hover over an item in your bank to see it's max hit impact when equipped.",
			position = 1,
			section = inventorySettings
	)
	default boolean showBankTooltip()
	{
		return true;
	}

	// Show Predicted Max Hit when hovering over spell in Spellbook
	@ConfigItem(
			keyName = "showSpellbookTooltip",
			name = "Tooltip on Spells in Spellbook",
			description = "Hover over a spell in the spellbook to see its current max hit.",
			position = 0,
			section = spellSettings
	)
	default boolean showSpellbookTooltip()
	{
		return true;
	}

	// Show Predicted Max Hit when hovering over spell in Autocast Seleciton
	@ConfigItem(
			keyName = "showAutocastSelectionTooltip",
			name = "Tooltip on Spells in Autocast Selection",
			description = "Hover over a spell in the autocast selection to see its current max hit.",
			position = 1,
			section = spellSettings
	)
	default boolean showAutocastSelectionTooltip()
	{
		return true;
	}

	// Show Predicted Max Hit for spells that are currently disabled (not enough runes)
	@ConfigItem(
			keyName = "showTooltipOnDisabledSpells",
			name = "Tooltip on Disabled Spells",
			description = "Show max hit on spells you don't have the runes to use.",
			position = 2,
			section = spellSettings
	)
	default boolean showTooltipOnDisabledSpells()
	{
		return true;
	}

	@ConfigItem(
			keyName = "timeToWaitBeforeResettingSelectedNPC",
			name = "Time To Wait Before Resetting Selected NPC",
			description = "NPC is selected when attacking, calculating any magic weaknesses and will be removed after a certain amount of time. (in minutes) 0 = No Resetting",
			position = 3,
			section = spellSettings
	)
	default int timeToWaitBeforeResettingSelectedNPC() { return 2; }
}

/* MaxHitCalcOverlay.java
 * Code for plugin main display panel and tooltip.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.Menu;
import net.runelite.api.MenuEntry;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.*;
import net.runelite.api.Item;
import net.runelite.client.plugins.itemstats.StatChange;
import net.runelite.client.plugins.itemstats.Effect;
import net.runelite.client.plugins.itemstats.ItemStatChanges;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.game.ItemStats;
import net.runelite.client.game.ItemManager;
import javax.inject.Inject;
import java.awt.*;
import java.util.List;


public class MaxHitCalcOverlay extends OverlayPanel
{
    private final MaxHitCalcPlugin plugin;
    private final MaxHitCalcConfig config;
    @Inject
    private TooltipManager tooltipManager;
    @Inject
    private ItemManager itemManager;
    @Inject
    private ItemStatChanges statChanges;
    @Inject
    private Client client;

    @Inject
    MaxHitCalcOverlay(MaxHitCalcPlugin plugin, MaxHitCalcConfig config)
    {
        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
        setLayer(OverlayLayer.ABOVE_SCENE);

        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        panelComponent.getChildren().clear();

        // Don't Display if 0, or -1 (error)
        if(plugin.maxHit > 0 && config.showMaxHit())
        {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Max Hit:")
                    .right(Integer.toString(plugin.maxHit))
                    .build());
        }

        // Don't Display if 0 (not useful) or turned off
        if(plugin.maxSpec > 0 && config.showSpec())
        {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Max Spec Hit:")
                    .right(Integer.toString(plugin.maxSpec))
                    .build());
        }

        // Don't Display if 0 (not useful) or turned off
        if(plugin.maxVsType > 0 && config.showType())
        {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Max Hit vs Type:")
                    .right(Integer.toString(plugin.maxVsType))
                    .build());
        }

        // Don't Display if 0 (not useful) or turned off
        if(plugin.maxSpecVsType > 0 && config.showSpecVsType())
        {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Max Spec vs Type:")
                    .right(Integer.toString(plugin.maxSpecVsType))
                    .build());
        }

        // Tooltip for Prediction
        if (config.showPredictionTooltip())
        {
            // Check for mouse
            if(this.getBounds().contains(
                client.getMouseCanvasPosition().getX(),
                client.getMouseCanvasPosition().getY()))
            {
                String tooltipString = predictedMaxHitTooltip();

                // Check if useful
                if(tooltipString != null)
                {
                    // Display tooltip
                    tooltipManager.add(new Tooltip(tooltipString));
                }
            }
        }

        // Bank & Inventory Item Tooltip
        if (config.showInventoryTooltip() || config.showBankTooltip())
        {
            getInventoryMaxHitTooltip(plugin.maxHit);
        }

        // Spellbook Spell Tooltip
        if (config.showSpellbookTooltip())
        {
            getSpellbookMaxHitTooltip();
        }

        // Autocast Selection Tooltip
        if(config.showAutocastSelectionTooltip())
        {
            getAutocastSelectionMaxHitTooltip();
        }

        return super.render(graphics);
    }

    private String predictedMaxHitTooltip()
    {
        PredictNextMax predictNextMaxes = new PredictNextMax(plugin, config, itemManager, client);
        List<Object> prediction = predictNextMaxes.predict();

        String result = "Next Max Hit at: </br>";

        if (prediction.get(0).equals("melee"))
        {
            result += prediction.get(1) + " Strength Levels </br>" + prediction.get(2) + " Strength Bonus </br>" + (int)((double)prediction.get(3) * 100) + "% Str. Prayer Bonus";
            return result;
        }
        else if (prediction.get(0).equals("ranged"))
        {
            // Atlatl check
            if(prediction.get(1).equals(0) && !prediction.get(2).equals(0))
            {
                result += prediction.get(2) + " Strength Levels </br>" + prediction.get(3) + " Strength Bonus </br>";
            }
            else {
                result += prediction.get(1) + " Ranged Levels </br>" + prediction.get(3) + " Ranged Strength Bonus </br>";
            }

            result += (int)((double)prediction.get(4) * 100) + "% Ranged Prayer Bonus";

            return result;
        }
        else if (prediction.get(0).equals("magic"))
        {
            // Magic Level not always used for max hit
            if (!prediction.get(1).equals(0))
            {
                result += prediction.get(1) + " Magic Levels </br>";
            }

            // Magic Damage Bonus always used for max hit
            result += (int)((double)prediction.get(2) * 100) + "% Magic Damage Bonus";

            return result;
        }
        else
        {
            return null;
        }
    }

    private void getInventoryMaxHitTooltip(int maxHit)
    {
        // Tooltip on item in inventory
        Menu clientMenu = client.getMenu();
        MenuEntry[] menu = clientMenu.getMenuEntries();
        int menuSize = menu.length;
        if (menuSize == 0)
        {
            return;
        }

        // Get Inventory
        MenuEntry entry = menu[menuSize - 1];
        Widget widget = entry.getWidget();
        if (widget == null)
        {
            return;
        }

        // Get Hovered Item
        int itemID = -1;
        // Check if inventory item
        if(config.showInventoryTooltip())
        {
            if (WidgetUtil.componentToInterface(widget.getId()) == InterfaceID.INVENTORY) // Inventory Interface ID
            {
                itemID = widget.getItemId();
            }
        }
        // Check if Bank item
        if (config.showBankTooltip())
        {
            if (WidgetUtil.componentToInterface(widget.getId()) == InterfaceID.BANKMAIN) // Bank Interface ID
            {
                itemID = widget.getItemId();
            }
        }
        // Check if "Bank Invetory" Item, shows with either option true
        if (config.showInventoryTooltip() || config.showBankTooltip())
        {
            if (WidgetUtil.componentToInterface(widget.getId()) == InterfaceID.BANKSIDE) // Bank Inventory Interface ID
            {
                itemID = widget.getItemId();
            }
        }
        // Check if Group Storage item
        if (config.showBankTooltip())
        {
            if (WidgetUtil.componentToInterface(widget.getId()) == InterfaceID.SHARED_BANK) // Bank Interface ID
            {
                itemID = widget.getItemId();
            }
        }
        // Check if "Group Storage Invetory" Item, shows with either option true
        if (config.showInventoryTooltip() || config.showBankTooltip())
        {
            if (WidgetUtil.componentToInterface(widget.getId()) == InterfaceID.SHARED_BANK_SIDE) // Bank Inventory Interface ID
            {
                itemID = widget.getItemId();
            }
        }


        // Prepare Tooltip
        if (itemID != -1)
        {
            ItemStats stats = itemManager.getItemStats(itemID);
            if(stats != null)
            {
                if(stats.getEquipment() != null)
                {
                    int slotID = stats.getEquipment().getSlot();

                    InventoryItemMaxHit inventoryMaxHits = new InventoryItemMaxHit(plugin, config, itemManager, client);
                    int maxWithItem = (int) inventoryMaxHits.predict(itemID, slotID);

                    // If no error
                    if (maxWithItem != -1){
                        int deltaMax = maxWithItem - maxHit;

                        // Display depending on Negative or Positive Increase
                        String tooltip = "";
                        if(deltaMax < 0)
                        {
                            // Negative
                            tooltip = "Max hit: " + ColorUtil.wrapWithColorTag("-" + Math.abs(deltaMax), Color.RED);
                        }
                        else if (deltaMax > 0)
                        {
                            tooltip = "Max hit: " + ColorUtil.wrapWithColorTag("+" + deltaMax, Color.GREEN);
                        }
                        else
                        {
                            return;
                        }

                        tooltipManager.add(new Tooltip(tooltip));
                    }

                }
                else
                {
                    // Check for Consumable
                    final Effect change = statChanges.get(itemID);

                    if(change != null)
                    {
                        StatChange[] statChanges = change.calculate(client).getStatChanges();

                        if(statChanges.length > 0)
                        {
                            StatChangedMaxHit statcChangedMaxHits = new StatChangedMaxHit(plugin, config, itemManager, client);
                            int maxWithChangedStats = (int) statcChangedMaxHits.predict(statChanges);

                            // If no error
                            if (maxWithChangedStats != -1){
                                int deltaMax = maxWithChangedStats - maxHit;

                                // Display depending on Negative or Positive Increase
                                String tooltip = "";
                                if(deltaMax < 0)
                                {
                                    // Negative
                                    tooltip = "Max hit: " + ColorUtil.wrapWithColorTag("-" + Math.abs(deltaMax), Color.RED);
                                }
                                else if (deltaMax > 0)
                                {
                                    tooltip = "Max hit: " + ColorUtil.wrapWithColorTag("+" + deltaMax, Color.GREEN);
                                }
                                else
                                {
                                    return;
                                }

                                tooltipManager.add(new Tooltip(tooltip));
                            }
                        }
                    }
                }
            }

        }
    }

    private void getSpellbookMaxHitTooltip()
    {
        // Tooltip on item in inventory
        Menu clientMenu = client.getMenu();
        MenuEntry[] menu = clientMenu.getMenuEntries();
        int menuSize = menu.length;
        if (menuSize == 0)
        {
            return;
        }

        // Get Spellbook
        MenuEntry entry = menu[menuSize - 1];
        Widget widget = entry.getWidget();
        if (widget == null)
        {
            return;
        }

        final int group = WidgetUtil.componentToInterface(widget.getId());
        int spellSpriteID = -1;

        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Group ID: " + group, ""); // DEBUG
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Spell Sprite ID: " + widget.getSpriteId(), ""); // DEBUG

        // Get Spell Sprite ID if actually in Spellbook
        if(group == InterfaceID.MAGIC_SPELLBOOK) // Spellbook Interface ID = 218
        {
            spellSpriteID = widget.getSpriteId();
        }

        // Prepare Tooltip
        if (spellSpriteID != -1)
        {
            // Get Combat Spell Info
            CombatSpell spell = CombatSpell.getSpellBySpriteID(spellSpriteID);

            // Check if spell is disabled
            if (spell == null && config.showTooltipOnDisabledSpells()){
                spell = CombatSpell.getSpellByDisabledSpriteID(spellSpriteID);
            }

            if(spell != null)
            {
                // Spell is a combat spell, continue with calc

                // Get Current Equipment
                Item[] playerEquipment;
                if (client.getItemContainer(InventoryID.WORN) != null ) // Equipment Inventory ID
                {
                    playerEquipment = client.getItemContainer(InventoryID.WORN).getItems();
                }
                else {
                    playerEquipment = null;
                }

                // Calculate Max Hit
                SpellbookSpellMaxHit spellbookMaxHits = new SpellbookSpellMaxHit(plugin, config, itemManager, client);
                int spellbookMaxHit = (int)spellbookMaxHits.calculateMagicMaxHit(playerEquipment, spell);

                // Error Check
                if (spellbookMaxHit > 0)
                {
                    String tooltip = "Max hit: " + spellbookMaxHit;
                    tooltipManager.add(new Tooltip(tooltip));
                }
            }
        }
    }

    private void getAutocastSelectionMaxHitTooltip()
    {
        // Tooltip on item in inventory
        Menu clientMenu = client.getMenu();
        MenuEntry[] menu = clientMenu.getMenuEntries();
        int menuSize = menu.length;
        if (menuSize == 0)
        {
            return;
        }

        // Get Autocast Selection Screen
        MenuEntry entry = menu[menuSize - 1];
        Widget widget = entry.getWidget();
        if (widget == null)
        {
            return;
        }

        final int group = WidgetUtil.componentToInterface(widget.getId());
        int spellSpriteID = -1;

        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Group ID: " + group, ""); // DEBUG
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Spell Sprite ID: " + widget.getSpriteId(), ""); // DEBUG

        // Get Spell Sprite ID if actually in Autocast Selection
        if(group == InterfaceID.AUTOCAST) // Autocast Interface = 201
        {
            spellSpriteID = widget.getSpriteId();
        }

        // Prepare Tooltip
        if (spellSpriteID != -1)
        {
            // Get Combat Spell Info
            CombatSpell spell = CombatSpell.getSpellBySpriteID(spellSpriteID);

            // Check if spell is disabled
            if (spell == null && config.showTooltipOnDisabledSpells()){
                spell = CombatSpell.getSpellByDisabledSpriteID(spellSpriteID);
            }

            if(spell != null)
            {
                // Spell is a combat spell, continue with calc

                // Get Current Equipment
                Item[] playerEquipment;
                if (client.getItemContainer(InventoryID.WORN) != null ) // Equipment Inventory ID
                {
                    playerEquipment = client.getItemContainer(InventoryID.WORN).getItems();
                }
                else
                {
                    playerEquipment = null;
                }

                // Calculate Max Hit
                SpellbookSpellMaxHit spellbookMaxHits = new SpellbookSpellMaxHit(plugin, config, itemManager, client);
                int spellbookMaxHit = (int)spellbookMaxHits.calculateMagicMaxHit(playerEquipment, spell);

                // Error Check
                if (spellbookMaxHit > 0)
                {
                    String tooltip = "Max hit: " + spellbookMaxHit;
                    tooltipManager.add(new Tooltip(tooltip));
                }
            }
        }
    }
}

/* MaxHitCalcPanel.java
 * Code for plugin panel which changes calculation settings
 *
 *
 * Copyright (c) 2024, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import com.google.inject.Inject;

import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Nullable;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;


public class MaxHitCalcPanel extends PluginPanel
{
    @Inject
    @Nullable
    private Client client;

    @Inject
    private EventBus eventBus;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ConfigManager configManager;

    private MaxHitCalcPlugin plugin;
    private MaxHitCalcConfig config;

    // UI Settings
    private JComboBox dartList = new JComboBox();
    private JComboBox colossalBladeList = new JComboBox();

    // NPC Selection Data
    private JComboBox npcList = new JComboBox();
    private JLabel npcNameHeader = new JLabel("No NPC Selected", SwingConstants.LEFT);
    private JLabel weaknessLabel = new JLabel("---");
    private JLabel weaknessIcon = new JLabel("---");
    private JLabel weaknessPercentLabel = new JLabel("---");


    enum ColossalBladeSizeBonus
    {
        ONE(1) {

            @Override
            public String toString() {
                return "1x1";
            }
        },
        TWO(2) {
            @Override
            public String toString() {
                return "2x2";
            }
        },
        THREE(3) {
            @Override
            public String toString() {
                return "3x3";
            }
        },
        FOUR(4) {
            @Override
            public String toString() {
                return "4x4";
            }
        },
        FIVE(5) {
            @Override
            public String toString() {
                return "5x5 +";
            }
        };

        public final int monsterSize;

        ColossalBladeSizeBonus(int monsterSize) {
            this.monsterSize = monsterSize;
        }
    }

    void init(MaxHitCalcPlugin plugin, MaxHitCalcConfig config)
    {
        this.plugin = plugin;
        this.config = config;

        // Initial Settings
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(new EmptyBorder(10, 10, 10, 10));

        // Title Panel
        JPanel titlePanel = new JPanel();
        titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        titlePanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        titlePanel.setLayout(new GridLayout(0, 1));

        JLabel titleLabel = new JLabel();
        titleLabel.setText("Calculation Settings");

        titlePanel.add(titleLabel);


        // Content section
        JPanel contentPanel = new JPanel();
        contentPanel.setBorder(new EmptyBorder(10, 0, 0, 0));
        contentPanel.setLayout(new GridLayout(0, 1));

        // Construct main panel
        JPanel panel = new JPanel();
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new EmptyBorder(10, 10, 10, 10));
        panel.setLayout(new GridBagLayout());
        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.ipadx = 0;

        // Blowpipe Dart Setting
        JLabel dartSettingLabel = new JLabel("Blowpipe Dart:");
        dartSettingLabel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        c.gridx = 0;
        c.gridy = 0;
        c.ipady = 0;
        c.weightx = 0.7;
        c.weighty = 0;
        c.insets = new Insets(0,0,0,0);  //top padding
        c.anchor = GridBagConstraints.LINE_START;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridwidth = 1;

        panel.add(dartSettingLabel, c);


        // Create Dropdown menu for selecting Dart type
        dartList = new JComboBox(BlowpipeDartType.values());
        dartList.setPrototypeDisplayValue("123456789");
        BlowpipeDartType selectedDart = (BlowpipeDartType)configManager.getConfiguration("MaxHitCalc", "blowpipeDartType", BlowpipeDartType.class);
        dartList.setSelectedIndex(selectedDart.ordinal()); // 0 = Mithril
        dartList.addActionListener(e -> onDartSwitched());

        c.gridx = 1;
        c.gridy = 0;
        c.ipady = 0;
        c.weightx = 0.3;
        c.weighty = 0;
        c.insets = new Insets(0,0,0,0);  //top padding
//        c.anchor = GridBagConstraints.LINE_END;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridwidth = 1;

        panel.add(dartList, c);


        c.gridx = 0;
        c.gridy = 1;
        c.ipady = 0;
        c.weightx = 0;
        c.weighty = 0;
        c.insets = new Insets(10,0,0,0);  //top padding
        c.anchor = GridBagConstraints.CENTER;
        c.gridwidth = 2;

        panel.add(Box.createGlue(), c);

        // Colossal Blade NPC Size Setting
        JLabel cbladeSettingLabel = new JLabel("NPC Size:");
        cbladeSettingLabel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        cbladeSettingLabel.setLayout(new GridLayout(2, 1));

        c.gridx = 0;
        c.gridy = 2;
        c.ipady = 0;
        c.weightx = 0.7;
        c.weighty = 0;
        c.insets = new Insets(0,0,0,0);  //top padding
        c.anchor = GridBagConstraints.LINE_START;
        c.gridwidth = 1;

        panel.add(cbladeSettingLabel, c);

        // Dropdown for NPC Size
        colossalBladeList = new JComboBox(ColossalBladeSizeBonus.values());
        colossalBladeList.setPrototypeDisplayValue("12345");
        colossalBladeList.setSelectedIndex(0);
        colossalBladeList.addActionListener(e -> onCBladeSettingSwitched());

        c.gridx = 1;
        c.gridy = 2;
        c.ipady = 0;
        c.weightx = 0.3;
        c.weighty = 0;
        c.insets = new Insets(0,0,0,0);  //top padding
        c.anchor = GridBagConstraints.LINE_END;
        c.gridwidth = 1;

        panel.add(colossalBladeList, c);

        c.gridx = 0;
        c.gridy = 3;
        c.ipady = 0;
        c.weightx = 0;
        c.weighty = 0;
        c.insets = new Insets(10,0,0,0);  //top padding
        c.anchor = GridBagConstraints.CENTER;
        c.gridwidth = 2;

        panel.add(Box.createGlue(), c);


        // Select NPC
        JLabel npcWeaknessLabel = new JLabel("Select NPC:");
        npcWeaknessLabel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        npcWeaknessLabel.setLayout(new GridLayout(2, 1));

        c.gridx = 0;
        c.gridy = 4;
        c.ipady = 0;
        c.weightx = 0.5;
        c.weighty = 0;
        c.insets = new Insets(0,0,0,0);  //top padding
        c.anchor = GridBagConstraints.LINE_START;
        c.gridwidth = 1;

        panel.add(npcWeaknessLabel, c);

        // Dropdown for NPC selection
        npcList = new JComboBox(NPCTypeWeakness.values());
        npcList.setPrototypeDisplayValue("1234567890123");
        npcList.setSelectedIndex(0);
        npcList.addActionListener(e -> onNpcSelected());

        c.gridx = 1;
        c.gridy = 4;
        c.ipady = 0;
        c.weightx = 0.5;
        c.weighty = 0;
        c.insets = new Insets(0,0,0,0);  //top padding
        c.anchor = GridBagConstraints.LINE_END;
        c.gridwidth = 1;

        panel.add(npcList, c);

        c.gridx = 0;
        c.gridy = 5;
        c.ipady = 0;
        c.weightx = 0;
        c.weighty = 0;
        c.insets = new Insets(10,0,0,0);  //top padding
        c.anchor = GridBagConstraints.CENTER;
        c.gridwidth = 2;

        panel.add(Box.createGlue(), c);

        // Selected NPC info panel
        JPanel selectedNPCPanel = new JPanel(new BorderLayout(10, 10));
        selectedNPCPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        selectedNPCPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        npcNameHeader = new JLabel("No NPC Selected", SwingConstants.LEFT);
        npcNameHeader.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        selectedNPCPanel.add(npcNameHeader, BorderLayout.NORTH);

        JPanel imagePanel = new JPanel(new GridLayout(1, 3, 0, 0));

        // Selected NPC icon
        weaknessLabel = new JLabel("---");
        weaknessLabel.setHorizontalAlignment(SwingConstants.CENTER);
        weaknessLabel.setVerticalAlignment(SwingConstants.CENTER);
        imagePanel.add(weaknessLabel);

        // NPC weakness icon
        weaknessIcon = new JLabel("---");
        weaknessIcon.setHorizontalAlignment(SwingConstants.CENTER);
        weaknessIcon.setVerticalAlignment(SwingConstants.CENTER);
        imagePanel.add(weaknessIcon);

        weaknessPercentLabel = new JLabel("---");
        weaknessPercentLabel.setHorizontalAlignment(SwingConstants.CENTER);
        weaknessPercentLabel.setVerticalAlignment(SwingConstants.CENTER);
        imagePanel.add(weaknessPercentLabel);

        selectedNPCPanel.add(imagePanel, BorderLayout.CENTER);

        c.gridx = 0;
        c.gridy = 6;
        c.ipady = 0;
        c.weightx = 2;
        c.weighty = 0;
//        c.insets = new Insets(0,0,0,0);  //top padding
//        c.anchor = GridBagConstraints.CENTER;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridwidth = 2;

        panel.add(selectedNPCPanel, c);

        c.gridx = 0;
        c.gridy = 7;
        c.ipady = 0;
        c.weightx = 0;
        c.weighty = 0;
        c.insets = new Insets(10,0,0,0);  //top padding
        c.anchor = GridBagConstraints.CENTER;
        c.gridwidth = 2;

        panel.add(Box.createGlue(), c);

        JButton resetButton = new JButton("Reset");
        resetButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                resetNPCviaPanel();
            }
        });

        c.gridx = 0;
        c.gridy = 8;
        c.ipady = 0;
        c.weightx = 0;
        c.weighty = 0;
        c.insets = new Insets(0,0,0,0);  //top padding
        c.anchor = GridBagConstraints.CENTER;
        c.gridwidth = 1;
        c.gridheight = 0;

        panel.add(resetButton, c);

        contentPanel.add(panel);

        // Final,
        add(titlePanel, BorderLayout.NORTH);
        add(contentPanel, BorderLayout.CENTER);

        eventBus.register(this);
    }

    void deinit()
    {
        eventBus.unregister(this);
    }

    void onNpcSelected(){
        if(npcList.getSelectedIndex() == 0)
        {
            // handle as reset, means NONE is selected
            resetNpcInfoPanel();
        }
        else {
            NPCTypeWeakness selectedNPCWeakness = NPCTypeWeakness.values()[npcList.getSelectedIndex()];
            setNpcInfoPanel(selectedNPCWeakness);

            // Recalculate plugin
            plugin.selectedNPCName = selectedNPCWeakness.getNPCName();
            plugin.npcSelectedByPanel = true;
        }
    }

    void setNpcInfoPanel(NPCTypeWeakness selectedNPCWeakness){
        npcNameHeader.setText(selectedNPCWeakness.getNPCName());

        weaknessLabel.setText("Weakness:");

        weaknessIcon.setText("");
        switch (selectedNPCWeakness.getElementalWeakness())
        {
            case Air: weaknessIcon.setIcon(PanelIcons.AIR_RUNE_ICON); break;
            case Water: weaknessIcon.setIcon(PanelIcons.WATER_RUNE_ICON); break;
            case Earth: weaknessIcon.setIcon(PanelIcons.EARTH_RUNE_ICON); break;
            case Fire: weaknessIcon.setIcon(PanelIcons.FIRE_RUNE_ICON); break;
            case NoType: weaknessIcon.setIcon(PanelIcons.EMPTY_RUNE_ICON); break;
        }

        weaknessPercentLabel.setText(selectedNPCWeakness.getWeaknessPercent() + "%");
    }


    void resetNpcInfoPanel()
    {
        npcNameHeader.setText("No NPC Selected");

        weaknessLabel.setText("---");

        weaknessIcon.setIcon(null);
        weaknessIcon.setText("---");

        weaknessPercentLabel.setText("---");
    }


    void onDartSwitched()
    {
        BlowpipeDartType selectedDart = BlowpipeDartType.values()[dartList.getSelectedIndex()];
        configManager.setConfiguration("MaxHitCalc", "blowpipeDartType", selectedDart);
        plugin.selectedDartType = selectedDart;
        plugin.dartSettingChanged = true;
    }

    void configDartSwitched()
    {
        dartList.setSelectedIndex(config.blowpipeDartType().ordinal());
        plugin.selectedDartType = config.blowpipeDartType();
    }

    void onCBladeSettingSwitched()
    {
        plugin.NPCSize = Math.max(1, colossalBladeList.getSelectedIndex()+1); // index 0 == 1, index 1 == 2, etc...
        plugin.npcSizeSettingChanged = true;
    }

    void resetNPCviaPanel(){
        // Reset size
        colossalBladeList.setSelectedIndex(0);

        // Reset Npc selection panel
        resetNpcInfoPanel();
    }

    // Set panel info automatically from plugin
    void setNPCviaPlugin()
    {
        // Set Size
        int size = Math.min(plugin.NPCSize, 5);
        colossalBladeList.setSelectedIndex(size-1);

        // Set NPC Info panel
        NPCTypeWeakness selectedNpc = NPCTypeWeakness.findWeaknessByName(plugin.selectedNPCName);
        if (selectedNpc != null) {
            setNpcInfoPanel(selectedNpc);
        }
        else {
            resetNpcInfoPanel();

            // Set name
            npcNameHeader.setText(plugin.selectedNPCName);

            weaknessLabel.setText("Weakness:");

            weaknessIcon.setText("");
            weaknessIcon.setIcon(PanelIcons.EMPTY_RUNE_ICON);

            weaknessPercentLabel.setText("0%");
        }
    }
}

/* MaxHitCalcPlugin.java
 * Main program code for Max Hit Calc RuneLite plugin.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import com.google.inject.Provides;
import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.NPC;
import net.runelite.api.Skill;
import net.runelite.api.events.*;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.ClientToolbar;

import java.awt.image.BufferedImage;

@Slf4j
@PluginDescriptor(
	name = "Max Hit Calculator",
	description = "Calculates Max Hit stats for the current equipment setup.",
	tags = "max hit, combat, stats, helpful, melee, ranged, magic"
)
public class MaxHitCalcPlugin extends Plugin
{
	@Inject
	private OverlayManager overlayManager;

	@Inject
	private MaxHitCalcOverlay pluginOverlay;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private MaxHitCalcConfig config;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ConfigManager configManager;

	// UI Panels
	@Inject
	private ClientToolbar clientToolbar;
	private MaxHitCalcPanel panel;
	private NavigationButton navButton;

	//
	private MaxHit maxHits;
	private MaxSpec maxSpecs;
	private MaxAgainstType maxAgainstTypes;
	private MaxSpecAgainstType maxSpecsAgainstTypes;

	// Public Max Hit variables, calculated when Equipment changes
	public int maxHit = 0;
	public int maxSpec = 0;
	public int maxVsType = 0;
	public int maxSpecVsType = 0;

	// Variable to check custom "gamestate"
	private boolean gameReady; // false before logged-in screen, true once logged-in screen closes, reset on logout

	// Variables for Currently interacting NPC
	public String selectedNPCName;
	public int selectedNPCExpiryTime = Integer.MAX_VALUE;
	boolean npcSelectedByPanel = false;
	boolean npcResetByPanel = false;

	// Vars for Calculations
	public int NPCSize = 1;
	boolean npcSizeSettingChanged = false;
	boolean markOfDarknessActive = false;

	public BlowpipeDartType selectedDartType = BlowpipeDartType.MITHRIL;
	boolean dartSettingChanged = false;




	@Subscribe
	public void onChatMessage(ChatMessage chatMessageReceived)
	{
		String message = chatMessageReceived.getMessage().toLowerCase();

		// Mark of darkness workaround since it doesn't seem to change a varbit
		if(message.contains("you have placed a mark of darkness upon yourself."))
		{
			markOfDarknessActive = true;
			calculateMaxes();
		}
		if(message.contains("your mark of darkness has faded away."))
		{
			markOfDarknessActive = false;
			calculateMaxes();
		}

		// DEBUG CHAT COMMANDS
//		if(chatMessageReceived.getMessage().equals("!Mhcdebug"))
//		{
//			calculateMaxes();
//			System.out.println("=================S==================");
//			System.out.println("MH: " + maxHit);
//			System.out.println("MS: " + maxSpec);
//			System.out.println("MHvT: " + maxVsType);
//			System.out.println("MSvT: " + maxSpecVsType);
//			System.out.println("=================E==================");
//		}
//		if(chatMessageReceived.getMessage().equals("!Allstyles"))
//		{
//			System.out.println("================S===============");
//			int[] weaponStyles = client.getEnum(EnumID.WEAPON_STYLES).getIntVals();
//
//			for(int i = 0; i < weaponStyles.length; i++)
//			{
//				System.out.println("i: " + i + "; WS: " + weaponStyles[i]);
//			}
//			System.out.println("================E===============");
//		}
//
//		if(chatMessageReceived.getMessage().equals("!Getstyle"))
//		{
//			int attackStyleID = client.getVarpValue(VarPlayer.ATTACK_STYLE);
//			int weaponTypeID = client.getVarbitValue(Varbits.EQUIPPED_WEAPON_TYPE);
//
//			System.out.println("=================S==================");
//			System.out.println("WTID: " + weaponTypeID);
//			System.out.println("ASID: " + attackStyleID);
//			System.out.println("=================E==================");
//		}
	}

	@Provides
	MaxHitCalcConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(MaxHitCalcConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(pluginOverlay);

		// Check if plugin started while game is running
		if (client.getGameState().equals(GameState.LOGGED_IN))
		{
			gameReady = true; // Set true if game is logged in and ready
		}
		else
		{
			gameReady = false; // Set false on normal runelite boot
		}

		maxHits = new MaxHit(this, config, itemManager, client);
		maxSpecs = new MaxSpec(this, config, itemManager, client);
		maxAgainstTypes = new MaxAgainstType(this, config, itemManager, client);
		maxSpecsAgainstTypes = new MaxSpecAgainstType(this, config, itemManager, client);


		// UI Startup
		panel = injector.getInstance(MaxHitCalcPanel.class);
		panel.init(this, config);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");

		navButton = NavigationButton.builder()
				.tooltip("Max Hit Calc")
				.icon(icon)
				.priority(7)
				.panel(panel)
				.build();

		if(config.showPanel()) {
			clientToolbar.addNavigation(navButton);
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(pluginOverlay);

		panel.deinit();
		clientToolbar.removeNavigation(navButton);
		panel = null;
		navButton = null;
	}

	// On Widget Closed, check for when login screen is closed
	@Subscribe
	public void onWidgetClosed(WidgetClosed widget)
	{
		if (widget.getGroupId() == InterfaceID.WELCOME_SCREEN) // "Click to play" screen interface id = 378
		{
			gameReady = true; // Set as soon as user closes welcome screen
			calculateMaxes();
		}
	}

	// Un-ready when logged out.
	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		// On return to login screen, gameReady = false
		if (event.getGameState().equals(GameState.LOGIN_SCREEN))
		{
			gameReady = false;
		}
	}

	// OnItemContainerChanged, waiting for equipment container
	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		// On Item Equip/de-equip
		if(event.getContainerId() == InventoryID.WORN) // Equipment Container ID
		{
			calculateMaxes();
		}
	}

	// OnVarbitChanged, waiting for change in prayer, attack style, or selected spell
	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		if(!gameReady)
		{
			// Fix for potential out-of-order startup problems (logging in without welcome screen)
			if (client.getGameState() == GameState.LOGGED_IN)
			{
				gameReady = true;
			}
			else
			{
				return; // do nothing, before you can see the game
			}
		}

//		System.out.println("Varplayer: " + event.getVarpId());
//		System.out.println("Varbit: " + event.getVarbitId());
//		System.out.println("Varbit value: " + event.getValue());

		// On prayer changed: 83 = normal prayerbook
		if (event.getVarpId() == VarPlayerID.PRAYER0)
		{
			calculateMaxes();
		}

		// On attack style changed
		if (event.getVarpId() == VarPlayerID.COM_MODE) // Varplayer: Attack Style
		{
			calculateMaxes();
		}

		// On selected Spell changed
		if (event.getVarbitId() == VarbitID.AUTOCAST_SPELL)
		{
			calculateMaxes();
		}

		// On soul stack changed
		if (event.getVarpId() == VarPlayerID.SOULREAPER_STACKS) // Varplayer: Soul Stack
		{
			calculateMaxes();
		}

		// On Charge Spell Buff Start/End
		if(event.getVarpId() == VarPlayerID.MAGEARENA_CHARGE) // Varplayer: Charge God Spell
		{
			calculateMaxes();
		}
	}

	// OnStatChanged, waiting for skill changes, boosted or levelled
	@Subscribe
	public void onStatChanged(StatChanged event)
	{
		// On Strength Changed
		if(event.getSkill() == Skill.STRENGTH)
		{
			calculateMaxes();
		}
		// On Ranged Changed
		if(event.getSkill() == Skill.RANGED)
		{
			calculateMaxes();
		}
		// On Magic Changed
		if(event.getSkill() == Skill.MAGIC)
		{
			calculateMaxes();
		}
		// On HP Changed
		if(event.getSkill() == Skill.HITPOINTS)
		{
			calculateMaxes();
		}
	}

	// On config Changed, run calculations
	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		// Only update for this plugin!
		if(event.getGroup().contains("MaxHitCalc"))
		{
			if(gameReady)
			{
				clientThread.invoke(this::calculateMaxes);

				// Update on panel if updated in settings
				if(event.getKey().equals("blowpipeDartType"))
				{
					panel.configDartSwitched();
				}
			}

			// Show or hide the side panel
			if(config.showPanel()) {
				clientToolbar.addNavigation(navButton);
			} else {
				clientToolbar.removeNavigation(navButton);
			}
		}
	}

	// Get Selected NPC from interaction
	@Subscribe
	public void onInteractingChanged(InteractingChanged interaction)
	{
		// Verify interaction is between user and npc
		if(interaction.getSource() != null)
		{
			// Verify source == local player
			String localPlayerName = client.getLocalPlayer().getName();
			String sourceName = interaction.getSource().getName();

			if(localPlayerName.equals(sourceName))
			{
				if(interaction.getTarget() != null)
				{
					NPC rawNPC = (NPC)interaction.getTarget();

					if(rawNPC != null)
					{
						// Do nothing for combat dummy or bankers, etc
						if(rawNPC.getCombatLevel() == 0) return; // Can't fight it, don't calc it

						if(config.timeToWaitBeforeResettingSelectedNPC() > 0)
						{
							selectedNPCExpiryTime = client.getTickCount() + (int)((config.timeToWaitBeforeResettingSelectedNPC() * 60)/0.6);
						}

						// Get necessary vars: name and size
						selectedNPCName = rawNPC.getComposition().getName();
						NPCSize = Math.max(1, rawNPC.getComposition().getSize()); // enforce to 1, incase of error

						panel.setNPCviaPlugin();

						calculateMaxes();
					}
				}
			}
		}
	}

	// After certain amount of ticks, clear clickedNPC
	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		// If NPC is selected, wait for time to expire to deselect it
		if(selectedNPCName != null)
		{
			if (selectedNPCExpiryTime < client.getTickCount() && config.timeToWaitBeforeResettingSelectedNPC() != 0)
			{
				selectedNPCName = null;
				NPCSize = 1;
				selectedNPCExpiryTime = Integer.MAX_VALUE; // Set higher than tick count
				panel.resetNPCviaPanel();
				calculateMaxes();
			}
		}

		// Check flags set by panel
		// Update tick after panel settings are changed
		if(npcSizeSettingChanged)
		{
			calculateMaxes();
			npcSizeSettingChanged = false;
		}

		if(dartSettingChanged)
		{
			calculateMaxes();
			configManager.setConfiguration("MaxHitCalc", "blowpipeDartType", selectedDartType);
			dartSettingChanged = false;
		}

		if(npcSelectedByPanel)
		{
			calculateMaxes();
			npcSelectedByPanel = false;
		}

		if (npcResetByPanel)
		{
			calculateMaxes();
			npcResetByPanel = false;
		}
	}

	// Calculates all panel max hits.
	public void calculateMaxes()
	{
		// Calculate Normal Max Hits
		maxHit = (int)Math.floor(maxHits.calculate(false));

		// Calculate Special Attack Max Hit
		maxSpec = (int)Math.floor(maxSpecs.calculate());
		if(config.displayMultiHitWeaponsAsOneHit())
		{
			int multiHitSpec = maxSpecs.getSpecMultiHit(maxSpec);
			if(multiHitSpec != 0)
			{
				maxSpec = multiHitSpec;
			}
		}

		// Calculate Max Hit vs Types of NPCs
		maxVsType = (int)Math.floor(maxAgainstTypes.calculate());


		// Calculate Special Attack Max Hit vs Types of NPCs
		maxSpecVsType = (int)Math.floor(maxSpecsAgainstTypes.calculate());
		if(config.displayMultiHitWeaponsAsOneHit())
		{
			int multiHitSpec = maxSpecs.getSpecMultiHit(maxSpecVsType);
			if(multiHitSpec != 0)
			{
				maxSpecVsType = multiHitSpec;
			}
		}
	}
}

/* MaxSpec.java
 * Contains the function for getting the damage bonus from special weapons.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.Skill;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.client.game.ItemManager;

/**
 * Contains functions for calculating max hit from a special attack weapon.
 */
public class MaxSpec
{
    private MaxHitCalcConfig config;
    private MaxHit maxHits;
    private ItemManager itemManager;
    private Client client;

    MaxSpec(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        this.config = config;
        this.maxHits = new MaxHit(plugin, config, itemManager, client);
        this.itemManager = itemManager;
        this.client = client;
    }

    double getSpecWeaponStat(Item[] playerEquipment)
    {
        String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        String ammoItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.AMMO);

        // Check if we even have a spec weapon
        // ***********************************************************************
        // Melee Spec weapon checks
        if(weaponName.contains("Armadyl godsword"))
        {
            return 1.375;
        }

        if(weaponName.contains("Ancient godsword"))
        {
            return 1.1;
        }

        if(weaponName.contains("Bandos godsword"))
        {
            return 1.21;
        }

        if(weaponName.contains("Saradomin godsword"))
        {
            return 1.1;
        }

        if(weaponName.contains("Zamorak godsword"))
        {
            return 1.1;
        }

        if(weaponName.contains("Saradomin sword"))
        {
            return 1.1;
        }

        if(weaponName.contains("Dragon dagger"))
        {
            return 1.15;
        }

        if(weaponName.contains("Dragon sword"))
        {
            return 1.25;
        }

        if(weaponName.contains("Dragon halberd"))
        {
            return 1.1;
        }

        if(weaponName.contains("Crystal halberd"))
        {
            if(!weaponName.contains("(basic)") && !weaponName.contains("(attuned)") && !weaponName.contains("(perfected)"))
            {
                return 1.1;
            }
        }

        if(weaponName.contains("Barrelchest"))
        {
            return 1.1;
        }

        if(weaponName.contains("Dragon hasta"))
        {
            return 1.0 + (0.5 * ((double)client.getVarpValue(VarPlayerID.SA_ENERGY) /1000)); // Varplayer: Special Attack Percent
        }

        if(weaponName.contains("Dragon longsword"))
        {
            return 1.25;
        }

        if(weaponName.contains("Dragon mace"))
        {
            return 1.5;
        }

        if(weaponName.contains("Dragon warhammer"))
        {
            return 1.5;
        }

        if(weaponName.contains("Rune claws"))
        {
            return 1.1;
        }

        if(weaponName.contains("Abyssal bludgeon"))
        {
            double currentPrayer = client.getBoostedSkillLevel(Skill.PRAYER);
            double totalPrayer = client.getRealSkillLevel(Skill.PRAYER);
            return (1 +(0.005 * (totalPrayer - currentPrayer)));
        }

        if(weaponName.contains("Saradomin's blessed sword"))
        {
            return 1.25;
        }

        if (weaponName.contains("Osmumten's fang"))
        {
            return 1.16666667;
        }

        if(weaponName.contains("Voidwaker"))
        {
            return 1.5;
        }

        if(weaponName.contains("Vesta's longsword"))
        {
            return 1.20;
        }

        if(weaponName.contains("Statius's warhammer"))
        {
            return 1.25;
        }

        if(weaponName.contains("Soulreaper axe"))
        {
            return 1 + maxHits.getSoulStackBonus();
        }

        if(weaponName.contains("Dual macuahuitl"))
        {
            return 1.25;
        }

        if(weaponName.contains("Arkan blade"))
        {
            return 1.5;
        }

        // ***********************************************************************
        // Ranged Spec weapon checks
        if(weaponName.contains("Dark bow"))
        {
            if(ammoItemName.contains("Dragon arrow"))
            {
                return 1.5;
            }
            else if (ammoItemName.contains("arrow"))
            {
                return 1.3;
            }
        }
        if(weaponName.contains("Zaryte crossbow"))
        {
            if(ammoItemName.contains("bolts (e)"))
            {
                return 1.1;
            }
        }
        if(weaponName.contains("Dragon crossbow"))
        {
            return 1.2;
        }
        if(weaponName.contains("crossbow"))
        {
            if(ammoItemName.contains("Diamond bolts (e)"))
            {
                return 1.15;
            }

            if(ammoItemName.contains("Dragonstone bolts (e)"))
            {
                return 1.45;
            }

            if(ammoItemName.contains("Onyx bolts (e)"))
            {
                return 1.15;
            }

            if(ammoItemName.contains("Opal bolts (e)"))
            {
                return 1.25;
            }
        }

        if(weaponName.contains("Morrigan's throwing axe"))
        {
            return 1.25;
        }

        if(weaponName.contains("Webweaver bow"))
        {
            return 0.4;
        }

        if(weaponName.contains("Toxic blowpipe"))
        {
            return 1.5;
        }

        if(weaponName.contains("ballista"))
        {
            return 1.25;
        }

        // ***********************************************************************
        // Magic Spec weapon checks
        if(weaponName.contains("Eye of Ayak"))
        {
            return 1.3;
        }

        return 0; // Not a spec weapon with a damage boost
    }

    // Returns the maximum hit of a spec weapon that hits multiple times in one move.
    // Returns 0 if not a multi hit spec weapon.
    public int getSpecMultiHit(int hit)
    {
        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);

        String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);

        // Melee Double Hit Spec Weapons
        if(weaponName.contains("Dragon dagger"))
        {
            return hit * 2;
        }

        if(weaponName.contains("Dragon claws"))
        {
            int first = hit - 1;
            int second = (hit - (hit/2)) - 1;
            int third = (hit - ((hit*3/4))) - 1;
            int fourth = third + 1;

            // Debug
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "First: " + first, null);
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Second: " + second, null);
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Third: " + third, null);
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Fourth: " + fourth, null);

            return first + second + third + fourth;
        }

        if(weaponName.contains("Abyssal dagger"))
        {
            int secondHit = (int)(hit * 0.85);
            return hit + secondHit;
        }

        if(weaponName.contains("Saradomin sword"))
        {
            return hit + 16;
        }

        // Range Double Hit Spec Weapons
        if(weaponName.contains("Magic shortbow"))
        {
            return hit * 2;
        }

        if (weaponName.contains("Dragon knife"))
        {
            return hit * 2;
        }

        if(weaponName.contains("Webweaver bow"))
        {
            return hit * 4;
        }

        if(weaponName.contains("Burning claws"))
        {
            int absoluteMax = (int) (hit * 1.75);
            int realMax = (int) (absoluteMax * 0.25) + (int) (absoluteMax * 0.25) + (int) (absoluteMax * 0.5);
            return realMax;
        }

        // else
        return 0;
    }

    /**
     * Calculates Max Hit of a Special Attack.
     *
     * @return Max Hit of Special Attack as Double
     */
    public double calculate()
    {
        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);

        // Get Config Settings
        boolean doubleHitSetting = config.displayMultiHitWeaponsAsOneHit();

        // Get Spec modifier
        double specialAttackWeapon = this.getSpecWeaponStat(playerEquipment);

        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Spec Modifier: " + specialAttackWeapon, null);

        double maxHit = maxHits.calculate(true);
        if(specialAttackWeapon != 0)
        {
            // Get Max hit then calculate Spec
            double maxSpecHit = Math.floor(maxHit) * specialAttackWeapon;

            return maxSpecHit;
        }
        else if (doubleHitSetting && (this.getSpecMultiHit((int)Math.floor(maxHit)) != 0))
        {
            // Niche cases where Special Attack does not increase Damage, but does hit twice. E.g: Dragon Knives, Magic Shortbow
            return maxHit;
        }

        return 0; // No spec attack on weapon
    }
}

/* MaxSpecAgainstType.java
 * Calculates Max hit for special attacks vs enemy types.
 *
 *
 * Copyright (c) 2024, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.gameval.*;
import net.runelite.client.game.ItemManager;
import java.util.List;

/**
 * Contains functions for calculating max hit of a special attack weapon vs specific types of npc.
 */
public class MaxSpecAgainstType extends MaxAgainstType
{
    private MaxSpec maxSpecs;

    MaxSpecAgainstType(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        super(plugin, config, itemManager, client);

        maxSpecs = new MaxSpec(plugin, config, itemManager, client);
    }

    /**
     * Calculates Max hit of a special attack against specific type bonuses
     *
     * @return Max hit as Double
     */
    public double calculate()
    {
        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);

        if (playerEquipment == null) return 0;

        int attackStyleID = client.getVarpValue(VarPlayerID.COM_MODE); // Varplayer: Attack Style
        int weaponTypeID = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);  // Varbit: Equipped Weapon Type

        // Get Current Attack Style
        AttackStyle[] weaponAttackStyles = WeaponType.getWeaponTypeStyles(client, weaponTypeID);
        AttackStyle attackStyle = weaponAttackStyles[attackStyleID];
        if (attackStyle == null)
            return 0;

        // Get Type modifier
        List<Double> typeModifiersList = getTypeBonus(attackStyle, playerEquipment);

        if(!typeModifiersList.isEmpty())
        {
            // Get Max hit then calculate Spec
            double maxSpec = maxSpecs.calculate();

            if(maxSpec != 0)
            {
                double maxSpecVsTypeHit = Math.floor(maxSpec);
                // Iterate through modifiers, flooring after multiplying
                for (double modifier: typeModifiersList)
                {
                    maxSpecVsTypeHit = Math.floor(maxSpecVsTypeHit * modifier);
                }

                return maxSpecVsTypeHit;
            }
        }

        return 0; // No Type Bonus
    }
}

/* NPCTypeWeakness.java
 * Enum for all NPC's with a type weakness.
 *
 *
 * Copyright (c) 2024, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import lombok.Getter;

import javax.swing.*;


/**
 *
 * Contains all known type bonuses against different NPC's.
 * Updated based on https://oldschool.runescape.wiki/w/Elemental_weakness and the Weakness Changes 2025 Proposal
 * Last updated on 7/12/25
 *
 */

public enum NPCTypeWeakness
{
    None("None", SpellType.NoType, 0),
    // In Alphabetical Order
    AberrantSpectre("Aberrant Spectre", SpellType.Air, 50),
    AbhorrentSpectre("Abhorrent Spectre", SpellType.Air, 50),
    AbyssalPortal("Abyssal Portal", SpellType.Fire, 50),
    AdamantDragon("Adamant Dragon", SpellType.Earth, 50),
    AgrithNaar("Agrith Naar", SpellType.Water, 25),
    Ahrim("Ahrim", SpellType.Air, 50, true),
    AirElemental("Air Elemental", SpellType.Air, 30),
    AkkhasShadow("Akkha's Shadow", SpellType.Air, 60),
    AlbinoBat("Albino Bat", SpellType.Air, 40),
    AlchemicalHydra("Alchemical Hydra", SpellType.Earth, 50),
    AmmoniteCrab("Ammonite Crab", SpellType.Earth, 25),
    Amoxliatl("Amoxliatl", SpellType.Fire, 30),
    AncientWyvern("Ancient Wyvern", SpellType.Air, 35),
    AncientZygomite("Ancient Zygomite", SpellType.Fire, 40),
    AngryBarbarianSpirit("Angry Barbarian Spirit", SpellType.Air, 30),
    AnimatedArmour("Armour", SpellType.Earth, 30, true), // all metal types
    AnimatedSpade("Animated Spade", SpellType.Earth, 25),
    Ankou("Ankou", SpellType.Air, 40),
    Apparition("Apparition", SpellType.Air, 40),
    Araxxor("Araxxor", SpellType.Fire, 50),
    Araxyte("Araxyte", SpellType.Fire, 50),
    ArcaneScarab("Arcane Scarab", SpellType.Fire, 50),
    ArmadyleanGuard("Armadylean Guard", SpellType.Air, 30),
    ArmouredZombie("Armoured Zombie", SpellType.Fire, 50),
    Arrg("Arrg", SpellType.Earth, 50),
    Asyn("Asyn", SpellType.Air, 40, true), // Shade and shadow
    Aviansie("Aviansie", SpellType.Air, 45),
    BabyRoc("Baby Roc", SpellType.Air, 30),
    BabyTanglefoot("Baby Tanglefoot", SpellType.Fire, 20),
    BalfrugKreeyath("Balfrug Kreeyath", SpellType.Water, 25),
    Banshee("Banshee", SpellType.Air, 30),
    BarkBlamishSnail("Bark Blamish Snail", SpellType.Earth, 30),
    Basilisk("Basilisk", SpellType.Earth, 40, true), // normal and monstrous
    Bat("Bat", SpellType.Air, 35),
    BearCub("Bear Cub", SpellType.Fire, 25),
    Berry("Berry", SpellType.Earth, 20),
    BerserkBarbarianSpirit("Berserk Barbarian Spirit", SpellType.Air, 25),
    BigWolf("Big Wolf", SpellType.Fire, 20),
    BigFrog("Big Frog", SpellType.Earth, 25),
    BillyGoat("Billy Goat", SpellType.Fire, 10),
    Bird("Bird", SpellType.Air, 25),
    BlackBear("Black Bear", SpellType.Fire, 30),
    BlackDemon("Black Demon", SpellType.Water, 40),
    BlackDragon("Black Dragon", SpellType.Water, 50, true), // Brutal, Baby, and normal black dragons all have the same %
    BlackJaguar("Black Jaguar", SpellType.Fire, 30),
    BlessedSpider("Blessed Spider", SpellType.Fire, 50),
    BloodBlamishSnail("Blood Blamish Snail", SpellType.Earth, 30),
    BloodMoon("Blood Moon", SpellType.Air, 15),
    BloodJaguar("Blood Jaguar", SpellType.Earth, 15),
    BloodSpawn("Blood Spawn", SpellType.Earth, 50),
    BlueMoon("Blue Moon", SpellType.Air, 15),
    BlueDragon("Blue Dragon", SpellType.Water, 50, true), // Brutal, Baby, and normal blue dragons all have the same %
    Boar("Boar", SpellType.Fire, 20),
    BodyGolem("Body Golem", SpellType.Earth, 35),
    BronzeDragon("Bronze Dragon", SpellType.Earth, 50),
    BrandaTheFireQueen("Branda the Fire Queen", SpellType.Water, 50),
    BruiseBlamishSnail("Bruise Blamish Snail", SpellType.Earth, 25),
    Bryophyta("Bryophyta", SpellType.Fire, 50),
    Callisto("Cerberus", SpellType.Fire, 30),
    CaveBug("Cave Bug", SpellType.Fire, 50),
    CaveGoblin("Cave Goblin", SpellType.Fire, 40, true), // normal, guard, and miner
    CaveHorror("Cave Horror", SpellType.Fire, 30),
    CaveKraken("Cave Kraken", SpellType.Earth, 50),
    CaveSlime("Cave Slime", SpellType.Earth, 50),
    Cerberus("Cerberus", SpellType.Water, 40),
    ChampionOfScabaras("Champion of Scabaras", SpellType.Fire, 35),
    ChaosElemental("Chaos Elemental", SpellType.Air, 50),
    ChaosGolem("Chaos Golem", SpellType.Earth, 35),
    ChilledJelly("Chilled Jelly", SpellType.Fire, 50),
    ChokeDevil("Choke Devil", SpellType.Air, 25),
    Chronozon("Chronozon", SpellType.Water, 25),
    ColossalHydra("Colossal Hydra", SpellType.Earth, 40),
    CorporealBeast("Corporeal Beast", SpellType.Earth, 10),
    Crab("Crab", SpellType.Earth, 20),
    Crocodile("Crocodile", SpellType.Earth, 40),
    CryptSpider("Crypt Spider", SpellType.Fire, 50),
    Dad("Dad", SpellType.Earth, 40),
    Dagannoth("Dagannoth", SpellType.Earth, 35, true), // normal, prime, rex, supreme, fledgling, mother, and spawn
    DarkAnkou("Dark Ankou", SpellType.Air, 20),
    DarkBeast("Dark Beast", SpellType.Earth, 60),
    Dawn("Dawn", SpellType.Earth, 70),
    DeadlyRedSpider("Deadly Red Spider", SpellType.Fire, 40),
    DeathWing("Death Wing", SpellType.Air, 20),
    Delrith("Delrith", SpellType.Water, 15),
    DemonicGorilla("Demonic Gorilla", SpellType.Water, 35),
    DeviantSpectre("Deviant Spectre", SpellType.Air, 30),
    Dharok("Dharok", SpellType.Air, 50, true),
    DontKnowWhat("Don't Know What", SpellType.Fire, 40),
    Doomion("Doomion", SpellType.Water, 25),
    Drake("Drake", SpellType.Water, 50),
    Dusk("Dusk", SpellType.Earth, 40),
    DustDevil("Dust Devil", SpellType.Air, 35),
    EarthWarriorChampion("Earth Warrior Champion", SpellType.Earth, 50),
    EarthElemental("Earth Elemental", SpellType.Earth, 50),
    EarthWarrior("Earth Warrior", SpellType.Earth, 50),
    EclipseMoon("Eclipse Moon", SpellType.Air, 15),
    EldricTheIceKing("Eldric the Ice King", SpellType.Fire, 50),
    ElidinisWarden("Elidinis' Warden", SpellType.Earth, 50),
    Elvarg("Elvarg", SpellType.Water, 30),
    EnragedBarbarianSpirit("Enraged Barbarian Spirit", SpellType.Air, 15),
    Ent("Ent", SpellType.Fire, 40),
    EntranaFirebird("Entrana Firebird", SpellType.Water, 100),
    EvilSpirit("Evil Spirit", SpellType.Air, 30),
    Fareed("Fareed", SpellType.Water, 30),
    FerociousBarbarianSpirit("Ferocious Barbarian Spirit", SpellType.Water, 30),
    FeverSpider("Fever Spider", SpellType.Fire, 25),
    FireWarriorOfLesarkus("Fire Warrior of Lesarkus", SpellType.Water, 100),
    FireElemental("Fire Elemental", SpellType.Water, 100),
    FireGiant("Fire Giant", SpellType.Water, 100),
    FiyrShade("Fiyr Shade", SpellType.Air, 40),
    Flambeed("Flambeed", SpellType.Water, 50),
    FlawedGolem("Flawed Golem", SpellType.Earth, 35),
    FleshCrawler("Flesh Crawler", SpellType.Fire, 20),
    FlightKilisa("Flight Kilisa", SpellType.Air, 30), // Needs icon
    FlockleaderGeerin("Flockleader Geerin", SpellType.Air, 30), // Needs icon
    Flower("Flower", SpellType.Fire, 100),
    ForgottenSoul("Forgotten Soul", SpellType.Air, 50),
    Fox("Fox", SpellType.Fire, 25),
    FrenziedIceTroll("Frenzied Ice Troll", SpellType.Fire, 50, true), // female, grunt, male, and runt
    Frog("Frog", SpellType.Earth, 40),
    Frogeel("Frogeel", SpellType.Earth, 40),
    FrostCrab("Frost Crab", SpellType.Fire, 100),
    FrostNagua("Frost Nagua",SpellType.Fire, 50),
    Galvek("Galvek", SpellType.Water, 40),
    Gargoyle("Gargoyle", SpellType.Earth, 40, true), // normal and marble
    GeneralGraardor("General Graardor", SpellType.Earth, 40),
    Ghast("Ghast", SpellType.Air, 25),
    Ghost("Ghost", SpellType.Air, 50),
    GiantBat("Giant Bat", SpellType.Air, 10),
    GiantCryptSpider("Giant Crypt Spider", SpellType.Fire, 40),
    GiantFrog("Giant Frog", SpellType.Earth, 25),
    GiantLobster("Giant Lobster", SpellType.Earth, 25),
    GiantMole("Giant Mole", SpellType.Earth, 50),
    GiantMosquito("Giant Mosquito", SpellType.Fire, 40),
    GiantRoc("Giant Roc", SpellType.Air, 35),
    GiantRockCrab("Giant Rock Crab", SpellType.Earth, 20),
    GiantRockslug("Giant Rockslug", SpellType.Earth, 20),
    GiantScarab("Giant Scarab", SpellType.Fire, 50),
    GiantSkeleton("Giant Skeleton", SpellType.Earth, 40),
    GiantSnail("Giant Snail", SpellType.Earth, 45),
    GiantSpider("Giant spider", SpellType.Fire, 50),
    Glod("Glod", SpellType.Earth, 50),
    GraveScorpion("Grave Scorpion", SpellType.Fire, 40),
    GreaterDemon("Greater Demon", SpellType.Water, 40),
    GreaterSkeletonHellhound("Greater Skeleton Hellhound", SpellType.Earth, 40),
    GreatOlm("Great Olm", SpellType.Earth, 50),
    GreenDragon("Green Dragon", SpellType.Water, 50, true), // Brutal, Baby, and normal blue dragons all have the same %
    GrizzlyBear("Grizzly Bear", SpellType.Fire, 20), // normal and cub
    Guthan("Guthan", SpellType.Air, 50, true),
    HarpieBugSwarm("Harpie Bug Swarm", SpellType.Fire, 50),
    Hellhound("Hellhound", SpellType.Water, 50),
    Hespori("Hespori", SpellType.Fire, 100),
    HillGiant("Hill Giant", SpellType.Earth, 25),
    Holthion("Holthion", SpellType.Water, 10),
    HopelessCreature("Hopeless Creature", SpellType.Fire, 40),
    Hueycoatl("Hueycoatl", SpellType.Earth, 60, true), // all entities of it
    HugeSpider("Huge Spider", SpellType.Fire, 40),
    Hydra("Hydra", SpellType.Earth, 40),
    IceDemon("Ice Demon", SpellType.Fire, 150),
    Icefiend("Icefiend", SpellType.Fire, 100),
    IceGiant("Ice Giant", SpellType.Fire, 100),
    Icelord("Icelord", SpellType.Fire, 30),
    IceQueen("Ice Queen", SpellType.Fire, 100),
    IceSpider("Ice Spider", SpellType.Fire, 100),
    IceTroll("Ice Troll", SpellType.Fire, 100, true), // Ordinary, Male, and Female all have the same %
    IceTrollGrunt("Ice Troll Grunt", SpellType.Fire, 35),
    IceTrollKing("Ice Troll King", SpellType.Fire, 35),
    IceTrollRunt("Ice Troll Runt", SpellType.Fire, 50),
    IceWarrior("Ice Warrior", SpellType.Fire, 100),
    IceWolf("Ice Wolf", SpellType.Fire, 20),
    Imp("Imp", SpellType.Water, 10),
    ImpChampion("Imp Champion", SpellType.Water, 10),
    InfernalPyrelord("Infernal Pyrelord", SpellType.Water, 10),
    IronDragon("Iron Dragon", SpellType.Earth, 50),
    IrvigSenay("Irvig Senay", SpellType.Air, 15),
    Jackal("Jackal", SpellType.Fire, 10),
    Jaguar("Jaguar", SpellType.Fire, 10), // don't use partial
    JaguarCub("Jaguar Cub", SpellType.Fire, 10),
    Jal("Jal-", SpellType.Water, 40, true), // multiple tzhaar jal-
    JalTokJad("JalTok-Jad", SpellType.Water, 40),
    Jelly("Jelly", SpellType.Earth, 35),
    Jogre("Jogre", SpellType.Fire, 25), // normal and champion
    Jormungand("Jormungand", SpellType.Earth, 40),
    JudgeOfYama("Judge of Yama", SpellType.Water, 15),
    JungleDemon("Jungle Demon", SpellType.Fire, 25),
    JungleWolf("Jungle Wolf", SpellType.Fire, 15),
    JungleHorror("Jungle Horror", SpellType.Fire, 25),
    JungleSpider("Jungle Spider", SpellType.Fire, 25),
    Kalphite("Kalphite", SpellType.Fire, 40, true), // normal, Guardian, QUeen, Soldier, and Worker
    Kalrag("Kalrag", SpellType.Fire, 10),
    Kamil("Kamil", SpellType.Fire, 10),
    Karamel("Karamel", SpellType.Fire, 40),
    Karil("Karil", SpellType.Air, 50, true),
    KasondeTheCraven("Kasonde the Craven", SpellType.Air, 15),
    KetZek("Ket-Zek", SpellType.Water, 40),
    KetlaTheUnworthy("Ketla the Unworthy", SpellType.Air, 15),
    Kephri("Kephri", SpellType.Fire, 35), // 40% with shield, not possible to calculate
    Killerwatt("Killerwatt", SpellType.Air, 60),
    KingBlackDragon("King Black Dragon", SpellType.Water, 50),
    KingSandCrab("King Sand Crab", SpellType.Earth, 15),
    KingScorpion("King Scorpion", SpellType.Fire, 20),
    Kob("Kob", SpellType.Earth, 20),
    Kraka("Kraka", SpellType.Earth, 20),
    Kraken("Kraken", SpellType.Earth, 50),
    Kreearra("Kree'arra", SpellType.Air, 30),
    KrilTsutsaroth("K'ril Tsutsaroth", SpellType.Water, 30),
    LargeMosquito("Large Mosquito", SpellType.Fire, 40),
    LavaDragon("Lava Dragon", SpellType.Water, 50),
    LesserDemon("Lesser Demon", SpellType.Water, 40),
    LoarShade("Loar Shade", SpellType.Air, 40),
    Lobstrosity("Lobstrosity", SpellType.Earth, 25),
    Locust("Locust", SpellType.Earth, 40),
    LocustRider("Locust Rider", SpellType.Earth, 25),
    LongTailedWyvern("Long-tailed Wyvern", SpellType.Air, 25),
    MindGolem("Mind Golem", SpellType.Earth, 35),
    MithrilDragon("Mithril Dragon", SpellType.Earth, 50),
    Mogre("Mogre", SpellType.Earth, 20),
    Molanisk("Molanisk", SpellType.Earth, 20),
    MonkeyZombie("Monkey Zombie", SpellType.Fire, 50),
    MossGiant("Moss Giant", SpellType.Fire, 50),
    MossGuardian("Moss Guardian", SpellType.Fire, 50),
    Mother("Mother", SpellType.Fire, 20),
    MountainTroll("Mountain Troll", SpellType.Earth, 50),
    Mudskipper("Mudskipper", SpellType.Earth, 20),
    Mummy("Mummy", SpellType.Fire, 50),
    MutatedTortoise("Mutated Tortoise", SpellType.Earth, 25),
    Muttadile("Muttadile", SpellType.Earth, 40),
    MyreBlamishSnail("Myre Blamish Snail", SpellType.Earth, 25),
    Nazastarool("Nazastarool", SpellType.Air, 20),
    Nezikchened("Nezikchened", SpellType.Water, 10),
    NuclearSmokeDevil("Nuclear Smoke Devil", SpellType.Air, 20),
    Nylocas("Nylocas", SpellType.Fire, 15, true), // Athanatos, Hagios, Ischyros, Matomenos, Prikipas, Toxobolos, and Vasilias
    Obor("Obor", SpellType.Earth, 20),
    OchreBlamishSnail("Ochre Blamish Snail", SpellType.Earth, 25),
    Ogre("Ogre", SpellType.Earth, 20, true), // normal, chieftain, shaman, ogress and reanimated
    Ork("Ork", SpellType.Earth, 15),
    Othainian("Othainian", SpellType.Water, 10),
    OtherworldlyBeing("Otherworldly Being", SpellType.Air, 35),
    Parasite("Parasite", SpellType.Fire, 50),
    PeeHat("Pee Hat", SpellType.Earth, 20),
    Penguin("Penguin", SpellType.Fire, 25),
    PerstenTheDeceitful("Persten the Deceitful", SpellType.Air, 15),
    PhantomMuspah("Phantom Muspah", SpellType.Air, 65),
    PhrinShade("Phrin Shade", SpellType.Air, 40),
    PoisonSpider("Poison Spider", SpellType.Fire, 40),
    Porcupine("Porcupine", SpellType.Fire, 20),
    Pyrefiend("Pyrefiend", SpellType.Water, 100),
    Pyrelord("Pyrelord", SpellType.Water, 100),
    Rabbit("Rabbit", SpellType.Fire, 15),
    Ram("Ram", SpellType.Fire, 20),
    RanalphDevere("Ranalph Devere", SpellType.Air, 10),
    ReanimatedAviansie("Reanimated Aviansie", SpellType.Air, 30),
    ReanimatedBear("Reanimated Bear", SpellType.Fire, 20),
    ReanimatedDagannoth("Reanimated Dagannoth", SpellType.Earth, 50),
    ReanimatedDemon("Reanimated Demon", SpellType.Water, 10),
    ReanimatedDragon("Reanimated Dragon", SpellType.Water, 50),
    ReanimatedGiant("Reanimated Giant", SpellType.Earth, 20),
    ReanimatedGoblin("Reanimated Goblin", SpellType.Fire, 10),
    ReanimatedHellhound("Reanimated Hellhound", SpellType.Water, 10),
    ReanimatedImp("Reanimated Imp", SpellType.Water, 10),
    ReanimatedKalphite("Reanimated Kalphite", SpellType.Fire, 50),
    RedDragon("Red Dragon", SpellType.Water, 50, true), // Brutal, Baby, and normal black dragons all have the same %
    RepugnantSpectre("Repugnant Spectre", SpellType.Air, 40),
    Revenant("Revenant", SpellType.Air, 30),
    Riyl("Riyl", SpellType.Air, 40, true), // Shade and shadow
    RockCrab("Rock Crab", SpellType.Earth, 20),
    RockGolem("Rock Golem", SpellType.Earth, 40),
    RockLobster("Rock Lobster", SpellType.Earth, 25),
    Rockslug("Rockslug", SpellType.Earth, 25),
    RuneDragon("Rune dragon", SpellType.Earth, 50),
    RuniteGolem("Runite Golem", SpellType.Earth, 60),
    SanTojalon("San Tojalon", SpellType.Air, 10),
    SandCrab("Sand Crab", SpellType.Earth, 20),
    SandSnake("Sand Snake", SpellType.Air, 40),
    Sarachnis("Sarachnis", SpellType.Fire, 40),
    Scarab("Scarab", SpellType.Fire, 40),
    ScarabMage("Scarab Mage", SpellType.Fire, 50),
    ScarabSwarm("Scarab Swarm", SpellType.Fire, 40),
    ScarredImp("Scarred Imp", SpellType.Water, 10),
    ScarredLesserDemon("Scarred Lesser Demon", SpellType.Water, 10),
    Scorpia("Scorpia", SpellType.Fire, 35),
    Scorpion("Scorpion", SpellType.Fire, 25, true), // normal, Khazard, Pit, Poison, and reanimated
    ScreamingBanshee("Screaming Banshee", SpellType.Air, 40),
    ScreamingTwistedBanshee("Screaming Twisted Banshee", SpellType.Air, 40),
    SeaSnake("Sea Snake", SpellType.Earth, 20, true), // Giant, young and Hatchling
    SeaTroll("Sea Troll", SpellType.Earth, 15, true), // normal and queen
    Seagull("Seagull", SpellType.Air, 20),
    Shade("Shade", SpellType.Air, 40),
    Shadow("Shadow", SpellType.Air, 40),
    ShadowWyrm("Shadow Wyrm", SpellType.Air, 50),
    ShadowSpider("Shadow Spider", SpellType.Air, 40),
    SkeletalHellhound("Skeletal Hellhound", SpellType.Earth, 35),
    SkeletalWyvern("Skeletal Wyvern", SpellType.Fire, 25),
    Skeleton("Skeleton", SpellType.Earth, 40, true), // normal, mage, brute, fremennik, guard, heavy, hero, thug, champion
    SkeletonHellhound("Skeleton Hellhound", SpellType.Earth, 30),
    SkeletonWarlord("Skeleton Warlord", SpellType.Earth, 20),
    Slagilith("Shadow", SpellType.Earth, 40),
    SmallScarab("Small Scarab", SpellType.Fire, 50),
    SmokeDevil("Smoke Devil", SpellType.Air, 30),
    SoldierScarab("Soldier scarab", SpellType.Fire, 50),
    Spidine("Spidine", SpellType.Fire, 25),
    Spindel("Spindel", SpellType.Fire, 25, true), // Spindel and spiderlings
    SpiritualMage("Spiritual Mage", SpellType.Air, 30),
    SpiritualRanger("Spiritual Ranger", SpellType.Air, 30),
    SpiritualWarrior("Spiritual Warrior", SpellType.Air, 30),
    SpittingWyvern("Spitting Wyvern", SpellType.Air, 25),
    SpittingScarab("Spitting scarab", SpellType.Fire, 50),
    SteelDragon("Steel dragon", SpellType.Earth, 50),
    StoneGuardian("Stone Guardian", SpellType.Earth, 40),
    Strangled("Strangled", SpellType.Fire, 50),
    StrangledBear("Strangled Bear", SpellType.Fire, 60),
    StrangledBoar("Strangled Boar", SpellType.Fire, 60),
    StrangledLynx("Strangled Lynx", SpellType.Fire, 60),
    SulphurNagua("Sulphur Nagua", SpellType.Air, 15),
    SummonedZombie("Summoned Zombie", SpellType.Fire, 50),
    Suqah("Suqah", SpellType.Earth, 20),
    SwampCrab("Swamp Crab", SpellType.Earth, 35),
    SwampFrog("Swamp Frog", SpellType.Earth, 20),
    TalonedWyvern("Taloned Wyvern", SpellType.Air, 35),
    Tanglefoot("Tanglefoot", SpellType.Fire, 35),
    Tekton("Tekton", SpellType.Water, 20),
    TempleSpider("Temple Spider", SpellType.Fire, 40),
    TheDraugen("The Draugen", SpellType.Air, 35),
    TheForsakenAssassin("The Forsaken Assassin", SpellType.Air, 15),
    ThermonuclearSmokeDevil("Thermonuclear Smoke Devil", SpellType.Air, 40),
    TokXil("Tok-Xil", SpellType.Water, 40),
    Torag("Torag", SpellType.Air, 50, true),
    TormentedDemon("Tormented Demon", SpellType.Water, 30),
    TormentedSoul("Tormented Soul", SpellType.Air, 20),
    Tortoise("Tortoise", SpellType.Earth, 20),
    TrappedSoul("Trapped Soul", SpellType.Air, 15),
    TreeSpirit("Tree Spirit", SpellType.Fire, 35),
    TreusDayth("Treus Dayth", SpellType.Air, 25),
    Troll("Troll", SpellType.Earth, 20, true), // normal, reanimated, river, thrower, general, spectator
    TstanonKarlak("Tstanon Karlak", SpellType.Water, 10),
    TumekensWarden("Tumeken's Warden", SpellType.Earth, 50),
    TwistedBanshee("Twisted Banshee", SpellType.Air, 25),
    TzKek("Tz-Kek", SpellType.Water, 40),
    TzKih("Tz-Kih", SpellType.Water, 40),
    TzHaar("TzHaar-", SpellType.Water, 40, true), // reanimated, Hur, Ket, Mej, Xil
    TzKal("TzKal-", SpellType.Water, 40),
    TzTokJad("TzTok-Jad", SpellType.Water, 40),
    Undead("Undead", SpellType.Fire, 50), // druid, lumberjack, zealot, chicken, cow, one
    UriumShade("Urium Shade", SpellType.Air, 40),
    Vardorvis("Vardorvis", SpellType.Fire, 35),
    Venenatis("Venenatis", SpellType.Fire, 40, true), // venenatis and spiderlings
    Verac("Verac", SpellType.Air, 50, true),
    // verzik vitur phase 3?
    VespineSoldier("Vespine Soldier", SpellType.Fire, 40),
    Vespula("Vespula", SpellType.Fire, 50),
    VitreousJelly("Vitreous Jelly", SpellType.Earth, 30),
    Vorkath("Vorkath", SpellType.Water, 40),
    Vulture("Vulture", SpellType.Air, 20),
    Wallasalki("Wallasalki", SpellType.Earth, 30),
    WarpedJelly("Warped Jelly", SpellType.Earth, 30, true), // normal and Vitreous
    WarpedTortoise("Warped Tortoise", SpellType.Earth, 20),
    WaterElemental("Water Elemental", SpellType.Earth, 50),
    Waterfiend("Waterfiend", SpellType.Earth, 50),
    TheWhisperer("The Whisperer", SpellType.Earth, 60),
    WhiteWolf("WhiteWolf", SpellType.Fire, 25),
    Wolf("Wolf", SpellType.Fire, 25), // dont use partial
    Wyrm("Wyrm", SpellType.Air, 50),
    Wyrmling("Wyrmling", SpellType.Air, 50),
    Xarpus("Xarpus", SpellType.Air, 50),
    YtHurKot("Yt-HurKot", SpellType.Water, 40),
    YtMejKot("Yt-MejKot", SpellType.Water, 40),
    ZaklnGritch("Zakl'n Gritch", SpellType.Water, 30),
    Zebak("Zebak", SpellType.Earth, 40),
    Zombie("Zombie", SpellType.Fire, 50, true), // normal, pirate, rat, swab, champion
    ZombifiedSpawn("Zombified Spawn", SpellType.Fire, 50),
    Zulrah("Zulrah", SpellType.Fire, 50),
    Zygomite("Zygomite", SpellType.Fire, 40);

    @Getter
    private final String NPCName;
    @Getter
    private final SpellType elementalWeakness;
    @Getter
    private final int weaknessPercent;
    @Getter
    private final boolean allowPartialSearch;

    /**
     * Gets an NPC's Weakness by searching their name
     * @param name string
     * @return NPCTypeWeakness, or null for failure
     */
    public static NPCTypeWeakness findWeaknessByName(String name)
    {
        if(name == null)
            return null;

        // Search exact name first
        for (NPCTypeWeakness npc : NPCTypeWeakness.values())
        {
            if(npc.NPCName.equalsIgnoreCase(name)){
                return npc;
            }
        }

        // Search names that aren't complete, e.g: baby (black dragon)
        for (NPCTypeWeakness npc : NPCTypeWeakness.values())
        {
            if(npc.allowPartialSearch)
            {
                if(name.toLowerCase().contains(npc.NPCName.toLowerCase())){
                    return npc;
                }
            }
        }

        // error, failure
        return null;
    }

    NPCTypeWeakness(String NPCName, SpellType elementalWeakness, int weaknessPercent)
    {
        this.NPCName = NPCName;
        this.elementalWeakness = elementalWeakness;
        this.weaknessPercent = weaknessPercent;
        this.allowPartialSearch = false;
    }

    NPCTypeWeakness(String NPCName, SpellType elementalWeakness, int weaknessPercent, boolean allowPartialSearch)
    {
        this.NPCName = NPCName;
        this.elementalWeakness = elementalWeakness;
        this.weaknessPercent = weaknessPercent;
        this.allowPartialSearch = allowPartialSearch;
    }
}

package com.maxhitcalc;

import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.image.BufferedImage;

public class PanelIcons {
    public static final ImageIcon AIR_RUNE_ICON;
    public static final ImageIcon WATER_RUNE_ICON;
    public static final ImageIcon EARTH_RUNE_ICON;
    public static final ImageIcon FIRE_RUNE_ICON;
    public static final ImageIcon EMPTY_RUNE_ICON;

    static {
        // Rune icons for weakness display
        final BufferedImage AIR_ICON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/elemental_icons/air.png");
        final BufferedImage WATER_ICON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/elemental_icons/water.png");
        final BufferedImage EARTH_ICON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/elemental_icons/earth.png");
        final BufferedImage FIRE_ICON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/elemental_icons/fire.png");
        final BufferedImage EMPTY_RUNE_ICON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/elemental_icons/no_type.png");

        AIR_RUNE_ICON = new ImageIcon(AIR_ICON_IMG);
        WATER_RUNE_ICON = new ImageIcon(WATER_ICON_IMG);
        EARTH_RUNE_ICON = new ImageIcon(EARTH_ICON_IMG);
        FIRE_RUNE_ICON = new ImageIcon(FIRE_ICON_IMG);
        EMPTY_RUNE_ICON = new ImageIcon(EMPTY_RUNE_ICON_IMG);
    }
}

/* PredictNextMax.java
 * Predicts the required stats to have a new max hit.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.Skill;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.game.ItemManager;
import java.util.Arrays;
import java.util.List;

public class PredictNextMax extends MaxHit
{
    PredictNextMax(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        super(plugin, config, itemManager, client);
    }

    private List<Object> predictNextMeleeMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, int attackStyleID)
    {
        int nextStrengthLevel = 0;
        int nextStrengthBonus = 0;
        double nextPrayerBonus = 0;

        double currentMaxHit = Math.floor(calculateMeleeMaxHit(playerEquipment, weaponAttackStyle, attackStyleID, false));

        // Predict Next Prayer Bonus for Next Max Hit
        for(int i = 1; i <= 23; i++)
        {
            // Calculate Melee Max Hit
            // Step 1: Calculate effective Strength
            int strengthLevel = client.getBoostedSkillLevel(Skill.STRENGTH);
            double prayerBonus = getPrayerBonus(weaponAttackStyle) + (i * 0.01);
            int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
            double voidBonus = getVoidMeleeBonus(playerEquipment); // default 1;
            double soulStackBonus = getSoulStackBonus();
            double effectiveSoulStackLevel = Math.floor(strengthLevel * soulStackBonus);

            double effectiveStrength = Math.floor((Math.floor(strengthLevel * prayerBonus) + effectiveSoulStackLevel + styleBonus + 8) * voidBonus);

            // Step 2: Calculate the base damage
            double strengthBonus = getMeleeStrengthBonus(playerEquipment); // default 0

            double baseDamage = (0.5 + effectiveStrength * ((strengthBonus + 64)/640));
            double flooredBaseDamage = Math.floor(baseDamage);

            // Step 3: Calculate the bonus damage
            List<Double> specialBonusMultipliers = getMeleeSpecialBonusMultiplier(playerEquipment); // default empty

            double predictedMaxHit = flooredBaseDamage;

            if(!specialBonusMultipliers.isEmpty())
            {
                for (double bonus: specialBonusMultipliers)
                {
                    predictedMaxHit += Math.floor(predictedMaxHit * bonus);
                }
            }

            // Osmumten's Fang Decrease
            String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
            if (weaponName.contains("Osmumten's fang"))
            {
                predictedMaxHit = predictedMaxHit * 0.85 + 1;
            }

            // Colossal Blade Base Increase
            if(weaponName.contains("Colossal blade")){
                predictedMaxHit = predictedMaxHit + 2;
            }

            // Rat Default +10 damage Bonus
            if(weaponName.contains("Bone mace"))
            {
                predictedMaxHit = predictedMaxHit + 10;
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextPrayerBonus = (i * 0.01);
                break;
            }
        }

        // Predict Next Strength Bonus for Next Max Hit
        for(int i = 1; i <= 25; i++)
        {
            // Calculate Melee Max Hit
            // Step 1: Calculate effective Strength
            int strengthLevel = client.getBoostedSkillLevel(Skill.STRENGTH);
            double prayerBonus = getPrayerBonus(weaponAttackStyle);
            int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
            double voidBonus = getVoidMeleeBonus(playerEquipment); // default 1;
            double soulStackBonus = getSoulStackBonus();
            double effectiveSoulStackLevel = Math.floor(strengthLevel * soulStackBonus);

            double effectiveStrength = Math.floor((Math.floor(strengthLevel * prayerBonus) + effectiveSoulStackLevel + styleBonus + 8) * voidBonus);

            // Step 2: Calculate the base damage
            double strengthBonus = getMeleeStrengthBonus(playerEquipment) + i; // default 0

            double baseDamage = (0.5 + effectiveStrength * ((strengthBonus + 64)/640));
            double flooredBaseDamage = Math.floor(baseDamage);

            // Step 3: Calculate the bonus damage
            List<Double> specialBonusMultipliers = getMeleeSpecialBonusMultiplier(playerEquipment); // default empty

            double predictedMaxHit = flooredBaseDamage;

            if(!specialBonusMultipliers.isEmpty())
            {
                for (double bonus: specialBonusMultipliers)
                {
                    predictedMaxHit += Math.floor(predictedMaxHit * bonus);
                }
            }

            // Osmumten's Fang Decrease
            String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
            if (weaponName.contains("Osmumten's fang"))
            {
                predictedMaxHit = predictedMaxHit * 0.85 + 1;
            }

            // Colossal Blade Base Increase
            if(weaponName.contains("Colossal blade")){
                predictedMaxHit = predictedMaxHit + 2;
            }

            // Rat Default +10 damage Bonus
            if(weaponName.contains("Bone mace"))
            {
                predictedMaxHit = predictedMaxHit + 10;
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextStrengthBonus = i;
                break;
            }
        }

        // Predict Next Strength Level for Next Max Hit
        for(int i = 1; i <= 20; i++)
        {
            // Calculate Melee Max Hit
            // Step 1: Calculate effective Strength
            int strengthLevel = client.getBoostedSkillLevel(Skill.STRENGTH) + i;
            double prayerBonus = getPrayerBonus(weaponAttackStyle);
            int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
            double voidBonus = getVoidMeleeBonus(playerEquipment); // default 1;
            double soulStackBonus = getSoulStackBonus();
            double effectiveSoulStackLevel = Math.floor(strengthLevel * soulStackBonus);

            double effectiveStrength = Math.floor((Math.floor(strengthLevel * prayerBonus) + effectiveSoulStackLevel + styleBonus + 8) * voidBonus);

            // Step 2: Calculate the base damage
            double strengthBonus = getMeleeStrengthBonus(playerEquipment); // default 0

            double baseDamage = (0.5 + effectiveStrength * ((strengthBonus + 64)/640));
            double flooredBaseDamage = Math.floor(baseDamage);

            // Step 3: Calculate the bonus damage
            List<Double> specialBonusMultipliers = getMeleeSpecialBonusMultiplier(playerEquipment); // default empty

            double predictedMaxHit = flooredBaseDamage;

            if(!specialBonusMultipliers.isEmpty())
            {
                for (double bonus: specialBonusMultipliers)
                {
                    predictedMaxHit += Math.floor(predictedMaxHit * bonus);
                }
            }

            // Osmumten's Fang Decrease
            String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
            if (weaponName.contains("Osmumten's fang"))
            {
                predictedMaxHit = predictedMaxHit * 0.85 + 1;
            }

            // Colossal Blade Base Increase
            if(weaponName.contains("Colossal blade")){
                predictedMaxHit = predictedMaxHit + 2;
            }

            // Rat Default +10 damage Bonus
            if(weaponName.contains("Bone mace"))
            {
                predictedMaxHit = predictedMaxHit + 10;
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextStrengthLevel = i;
                break;
            }
        }

        List<Object> results = Arrays.asList("melee", nextStrengthLevel, nextStrengthBonus, nextPrayerBonus);

        // Complete
        return results;
    }

    private List<Object> predictNextRangeMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, int attackStyleID)
    {
        int nextRangedLevel = 0;
        int nextStrengthLevel = 0;
        int nextRangeEquipmentBonus = 0;
        double nextPrayerBonus = 0;

        double currentMaxHit = Math.floor(calculateRangedMaxHit(playerEquipment, weaponAttackStyle, attackStyleID));

        // Predict Next Ranged Level for Next Max Hit
        for(int i = 1; i <= 20; i++)
        {
            String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
            // If using the atlatl, calculate with strength instead of ranged
            if(weaponItemName.contains("atlatl"))
            {
                break; // Changing range level wont affect atlatl calcs
            }

            // Calculate Ranged Max Hit
            // Step 1: Calculate effective ranged Strength
            int rangedLevel = client.getBoostedSkillLevel(Skill.RANGED) + i;
            double prayerBonus = getPrayerBonus(weaponAttackStyle);
            int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
            double voidBonus = getVoidRangedBonus(playerEquipment); // default 1;

            double effectiveRangedStrength = Math.floor((Math.floor(rangedLevel * prayerBonus) + styleBonus + 8) * voidBonus);

            // Step 2: Calculate the max hit
            double equipmentRangedStrength = getRangedStrengthBonus(playerEquipment);
            double gearBonus = getRangeGearBoost(playerEquipment);

            double predictedMaxHit = (0.5 + (((effectiveRangedStrength * (equipmentRangedStrength + 64))/640) * gearBonus) );

            // Step 3: Bonus damage from special attack and effects
            // Rat Default +10 damage Bonus
            if(weaponItemName.contains("Bone shortbow"))
            {
                predictedMaxHit = predictedMaxHit + 10;
            }

            // Tonalztics of Ralos (uncharged) max hit is 75% of normal
            if(weaponItemName.contains("Tonalztics of ralos"))
            {
                predictedMaxHit = Math.floor(predictedMaxHit * 0.75); // unknown if flooring here causes miscalcs
                if(!weaponItemName.contains("(uncharged)"))
                {
                    predictedMaxHit = predictedMaxHit*2;
                }
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextRangedLevel = i;
                break;
            }
        }

        // Predict Next Strength Level for Next Max Hit (ATLATL)
        for(int i = 1; i <= 20; i++)
        {
            String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
            if(!weaponItemName.contains("atlatl"))
            {
                break; // Changing strength level only affects atlatl
            }

            // Calculate Ranged Max Hit
            // Step 1: Calculate effective ranged Strength
            int rangedLevel = client.getBoostedSkillLevel(Skill.STRENGTH) + i;
            double prayerBonus = getPrayerBonus(weaponAttackStyle);
            int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
            double voidBonus = getVoidRangedBonus(playerEquipment); // default 1;

            double effectiveRangedStrength = Math.floor((Math.floor(rangedLevel * prayerBonus) + styleBonus + 8) * voidBonus);

            // Step 2: Calculate the max hit
            double equipmentRangedStrength = getRangedStrengthBonus(playerEquipment);
            double gearBonus = getRangeGearBoost(playerEquipment);

            double predictedMaxHit = (0.5 + (((effectiveRangedStrength * (equipmentRangedStrength + 64))/640) * gearBonus) );

            // Step 3: Bonus damage from special attack and effects
            // Rat Default +10 damage Bonus
            if(weaponItemName.contains("Bone shortbow"))
            {
                predictedMaxHit = predictedMaxHit + 10;
            }

            // Tonalztics of Ralos (uncharged) max hit is 75% of normal
            if(weaponItemName.contains("Tonalztics of ralos"))
            {
                predictedMaxHit = Math.floor(predictedMaxHit * 0.75); // unknown if flooring here causes miscalcs
                if(!weaponItemName.contains("(uncharged)"))
                {
                    predictedMaxHit = predictedMaxHit*2;
                }
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextStrengthLevel = i;
                break;
            }
        }

        // Predict Next Prayer Bonus for Next Max Hit
        for(int i = 1; i <= 23; i++)
        {
            String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);

            // Calculate Ranged Max Hit
            // Step 1: Calculate effective ranged Strength
            int rangedLevel = client.getBoostedSkillLevel(Skill.RANGED);
            double prayerBonus = getPrayerBonus(weaponAttackStyle) + (i * 0.01);
            int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
            double voidBonus = getVoidRangedBonus(playerEquipment); // default 1;

            // If using the atlatl, calculate with strength instead of ranged
            if(weaponItemName.contains("atlatl"))
            {
                rangedLevel  = client.getBoostedSkillLevel(Skill.STRENGTH);
            }

            double effectiveRangedStrength = Math.floor((Math.floor(rangedLevel * prayerBonus) + styleBonus + 8) * voidBonus);

            // Step 2: Calculate the max hit
            double equipmentRangedStrength = getRangedStrengthBonus(playerEquipment);
            double gearBonus = getRangeGearBoost(playerEquipment);

            double predictedMaxHit = (0.5 + (((effectiveRangedStrength * (equipmentRangedStrength + 64))/640) * gearBonus) );

            // Step 3: Bonus damage from special attack and effects
            // Rat Default +10 damage Bonus
            if(weaponItemName.contains("Bone shortbow"))
            {
                predictedMaxHit = predictedMaxHit + 10;
            }

            // Tonalztics of Ralos (uncharged) max hit is 75% of normal
            if(weaponItemName.contains("Tonalztics of ralos"))
            {
                predictedMaxHit = Math.floor(predictedMaxHit * 0.75); // unknown if flooring here causes miscalcs
                if(!weaponItemName.contains("(uncharged)"))
                {
                    predictedMaxHit = predictedMaxHit*2;
                }
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextPrayerBonus = (i * 0.01);
                break;
            }
        }

        // Predict Next Ranged Equipment Strength Bonus for Next Max Hit
        for(int i = 1; i <= 20; i++)
        {
            String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);

            // Calculate Ranged Max Hit
            // Step 1: Calculate effective ranged Strength
            int rangedLevel = client.getBoostedSkillLevel(Skill.RANGED);
            double prayerBonus = getPrayerBonus(weaponAttackStyle);
            int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
            double voidBonus = getVoidRangedBonus(playerEquipment); // default 1;

            // If using the atlatl, calculate with strength instead of ranged
            if(weaponItemName.contains("atlatl"))
            {
                rangedLevel  = client.getBoostedSkillLevel(Skill.STRENGTH);
            }

            double effectiveRangedStrength = Math.floor((Math.floor(rangedLevel * prayerBonus) + styleBonus + 8) * voidBonus);

            // Step 2: Calculate the max hit
            double equipmentRangedStrength = getRangedStrengthBonus(playerEquipment) + i;
            double gearBonus = getRangeGearBoost(playerEquipment);

            double predictedMaxHit = (0.5 + (((effectiveRangedStrength * (equipmentRangedStrength + 64))/640) * gearBonus) );

            // Step 3: Bonus damage from special attack and effects
            // Rat Default +10 damage Bonus

            if(weaponItemName.contains("Bone shortbow"))
            {
                predictedMaxHit = predictedMaxHit + 10;
            }

            // Tonalztics of Ralos (uncharged) max hit is 75% of normal
            if(weaponItemName.contains("Tonalztics of ralos"))
            {
                predictedMaxHit = Math.floor(predictedMaxHit * 0.75); // unknown if flooring here causes miscalcs
                if(!weaponItemName.contains("(uncharged)"))
                {
                    predictedMaxHit = predictedMaxHit*2;
                }
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextRangeEquipmentBonus = i;
                break;
            }
        }

        List<Object> results = Arrays.asList("ranged", nextRangedLevel, nextStrengthLevel, nextRangeEquipmentBonus, nextPrayerBonus);

        // Complete
        return results;
    }

    private List<Object> predictNextMageMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, int attackStyleID)
    {
        int nextMagicLevel = 0;
        double nextMagicDamageBonus = 0;

        double currentMaxHit = Math.floor(calculateMagicMaxHit(playerEquipment, weaponAttackStyle));
        CombatSpell spell = getSpell();

        // Predict Next Magic Level for Next Max Hit - Only used for Charged Weapons and Magic Dart
        if(spell == null || (spell.getName().toLowerCase().contains("magic dart")))
        {
            for(int i = 1; i <= 20; i++)
            {
                // Calculate Magic Max Hit
                // Step 1: Find the base hit of the spell
                double spellBaseMaxHit = getSpellBaseHit(playerEquipment, weaponAttackStyle, (client.getBoostedSkillLevel(Skill.MAGIC) + i));

                // Step 2: Calculate the Magic Damage Bonus
                double magicDmgBonus = getMagicEquipmentBoost(playerEquipment) + (i * 0.01);

                double predictedMaxHit = (spellBaseMaxHit * magicDmgBonus);

                // Step 3: Calculate Type Bonuses
                // Tome Bonuses
                double correctTomeSpellBonus = getTomeSpellBonus(playerEquipment, weaponAttackStyle); // default 1
                predictedMaxHit = predictedMaxHit * correctTomeSpellBonus;

                // Check if predicted is better than current
                if (Math.floor(predictedMaxHit) > currentMaxHit)
                {
                    nextMagicLevel = i;
                    break;
                }
            }
        }

        // Predict Next Magic Damage Bonus needed for next Max Hit
        for(int i = 1; i <= 50; i++)
        {
            // Calculate Magic Max Hit
            // Step 1: Find the base hit of the spell
            double spellBaseMaxHit = getSpellBaseHit(playerEquipment, weaponAttackStyle, client.getBoostedSkillLevel(Skill.MAGIC));

            // Step 2: Calculate the Magic Damage Bonus
            double magicDmgBonus = getMagicEquipmentBoost(playerEquipment) + (i * 0.01);

            double predictedMaxHit = (spellBaseMaxHit * magicDmgBonus);

            // Step 3: Calculate Type Bonuses
            // Tome Bonuses
            double correctTomeSpellBonus = getTomeSpellBonus(playerEquipment, weaponAttackStyle); // default 1
            predictedMaxHit = predictedMaxHit * correctTomeSpellBonus;

            // Final step: Calculate and add spell type weakness Bonus
            if (spell != null && spell.hasType())
            {
                if (plugin.selectedNPCName != null)
                {
                    NPCTypeWeakness weaknessBonus = NPCTypeWeakness.findWeaknessByName(plugin.selectedNPCName);
                    if (weaknessBonus != null)
                    {
                        if(spell.getSpellType() == weaknessBonus.getElementalWeakness())
                        {
                            int bonusPercent = weaknessBonus.getWeaknessPercent();

                            double typeBonusDamage = spellBaseMaxHit * ((double) bonusPercent / (double)100);
                            predictedMaxHit = predictedMaxHit + typeBonusDamage;
                        }
                    }
                }
            }

            // Twinflame Staff Double Hit bonus
            String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
            if (weaponItemName.toLowerCase().contains("twinflame staff"))
            {
                if (spell != null && spell.getSpellbook().contains("standard")) {

                    if(!spell.getName().toLowerCase().contains("strike") && !spell.getName().toLowerCase().contains("surge"))
                    {
                        double bonusHit = Math.floor(predictedMaxHit) * 0.4;
                        predictedMaxHit = Math.floor(predictedMaxHit) + Math.floor(bonusHit);
                    }
                }
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextMagicDamageBonus = (i * 0.01);
                break;
            }
        }

        List<Object> results = Arrays.asList("magic", nextMagicLevel, nextMagicDamageBonus);

        // Complete
        return results;
    }

    /**
     * Calculates a prediction of stat increases required for a new max hit.<br><br>
     * Predictions for Melee: Strength Level, Equipment Strength Bonus, and Prayer Bonus <br>
     * Predictions for Ranged: Ranged Level, Ranged Equipment Strength Bonus, and Prayer Bonus <br>
     * Predictions for Magic: Magic Level, and Magic Equipment Damage Bonus <br><br>
     *
     * @return List of predictions
     */
    public List<Object> predict()
    {
        int attackStyleID = client.getVarpValue(VarPlayerID.COM_MODE); // Varplayer: Attack Style
        int weaponTypeID = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);  // Varbit: Equipped Weapon Type

        // Get Current Attack Style
        AttackStyle[] weaponAttackStyles = WeaponType.getWeaponTypeStyles(client, weaponTypeID);
        AttackStyle attackStyle = weaponAttackStyles[attackStyleID];
        if (attackStyle == null)
            return null;

        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);

        // Find what type to calculate
        if(attackStyle.equals(AttackStyle.ACCURATE) || attackStyle.equals(AttackStyle.AGGRESSIVE) || attackStyle.equals(AttackStyle.CONTROLLED) || attackStyle.equals(AttackStyle.DEFENSIVE))
        {
            List<Object> meleeResults = this.predictNextMeleeMaxHit(playerEquipment, attackStyle, attackStyleID);

            // index: 0 = "melee", 1 = strength level, 2 = equipment strength bonus, 3 = prayer percent bonus
            return meleeResults;
        }
        else if (attackStyle.equals(AttackStyle.RANGING) || attackStyle.equals(AttackStyle.LONGRANGE))
        {
            List<Object> rangedResults = this.predictNextRangeMaxHit(playerEquipment, attackStyle, attackStyleID);

            // index: 0 = "ranged", 1 = range level, 2 = strength level (Atlatl), 3 = range equipment strength bonus, 4 = prayer percent bonus
            return rangedResults;
        }
        else if ((attackStyle.equals(AttackStyle.CASTING)  || attackStyle.equals(AttackStyle.DEFENSIVE_CASTING)))
        {
            List<Object> mageResults = this.predictNextMageMaxHit(playerEquipment, attackStyle, attackStyleID);

            // index: 0 = "magic", 1 = magic level, 2 = mage equipment damage bonus
            return mageResults;
        }
        else
        {
            return null;
        }
    }
}

/* SpellbookSpellMaxHit.java
 * Calculates Max Hit for magic when given a specific spell.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.Skill;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.client.game.ItemManager;

public class SpellbookSpellMaxHit extends MaxHit
{
    SpellbookSpellMaxHit(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        super(plugin, config, itemManager, client);
    }

    protected double getSpellBaseHit(Item[] playerEquipment, int magicLevel, CombatSpell spell)
    {
        double basehit = 0;

        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        String capeItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.CAPE);
        String glovesItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.GLOVES);

        // God Spells Cases
        if((spell == CombatSpell.FLAMES_OF_ZAMORAK) || (spell == CombatSpell.CLAWS_OF_GUTHIX) || (spell == CombatSpell.SARADOMIN_STRIKE))
        {
            if (client.getVarpValue(VarPlayerID.MAGEARENA_CHARGE) > 0) // Varplayer: Charge God Spell
            {
                if(spell == CombatSpell.CLAWS_OF_GUTHIX &&
                        (capeItemName.toLowerCase().contains("guthix cape") ||  capeItemName.toLowerCase().contains("guthix max cape")))
                {
                    return 30;
                }
                else if(spell == CombatSpell.FLAMES_OF_ZAMORAK &&
                        (capeItemName.toLowerCase().contains("zamorak cape") || capeItemName.toLowerCase().contains("zamorak max cape")))
                {
                    return 30;
                }
                else if(spell == CombatSpell.SARADOMIN_STRIKE &&
                        (capeItemName.toLowerCase().contains("saradomin cape") || capeItemName.toLowerCase().contains("saradomin max cape")))
                {
                    return 30;
                }
                else
                {
                    return 20;
                }
            }
            else
            {
                return 20;
            }
        }
        // Magic Dart Case
        else if(spell == CombatSpell.MAGIC_DART)
        {
            double magicDartDamage = Math.floor(magicLevel * ((double)1/10)) + 10;

            return magicDartDamage;
        }
        else
        {
            // FIND TIER, FIND HIGHEST IN TIER
            if (spell.getTier() == 0)
            {
                // NO TIER,
                basehit = spell.getBaseDamage();
            }
            else if(magicLevel < spell.getReqLevel())
            {
                // Cant use spell
                basehit = -1;
            }
            else
            {
                // GET TIER, Get highest tier in level
                int spellTier = spell.getTier();
                String spellbook = spell.getSpellbook();

                CombatSpell[] spellsInTier = CombatSpell.getSpellsOfTier(spellTier, spellbook);

                for(CombatSpell cSpell : spellsInTier)
                {
                    if(magicLevel >= cSpell.getReqLevel())
                    {
                        if (basehit <= cSpell.getBaseDamage())
                        {
                            // new highest found
                            basehit = cSpell.getBaseDamage();
                        }
                    }
                }

                // Error, didn't find usable spell
                if (basehit == 0)
                    return -1; // error
            }
        }

        // Chaos Gauntlet Bonus Check
        if(spell.getName().toLowerCase().contains("bolt"))
        {
            if (glovesItemName.toLowerCase().contains("chaos gauntlets"))
            {
                basehit += 3;
            }
        }

        return basehit;
    }

    protected double getTomeSpellBonus(Item[] playerEquipment, CombatSpell spell)
    {
        String shieldItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.SHIELD);

        if (spell.getName().toLowerCase().contains("fire"))
        {
            // Check for tome of fire
            if (shieldItemName.contains("Tome of fire"))
            {
                if (!shieldItemName.contains("(empty)"))
                {
                    return 1.1;
                }
            }
        }

        if (spell.getName().toLowerCase().contains("water"))
        {
            // Check for tome of water
            if (shieldItemName.contains("Tome of water"))
            {
                if (!shieldItemName.contains("(empty)"))
                {
                    return 1.1;
                }
            }
        }

        if (spell.getName().toLowerCase().contains("earth"))
        {
            // Check for tome of water
            if (shieldItemName.contains("Tome of earth"))
            {
                if (!shieldItemName.contains("(empty)"))
                {
                    return 1.1;
                }
            }
        }

        return 1;
    }

    /**
     * Calculates Max hit of a specific spell with given equipment.
     *
     * @param playerEquipment current player equipment
     * @param spell selected spell to calculate max hit with
     * @return double, max hit value
     */
    public double calculateMagicMaxHit(Item[] playerEquipment, CombatSpell spell)
    {
        // Calculate Magic Max Hit
        // Step 1: Find the base hit of the spell
        double spellBaseMaxHit = getSpellBaseHit(playerEquipment, client.getBoostedSkillLevel(Skill.MAGIC), spell);

        // Step 2: Calculate the Magic Damage Bonus
        double magicDmgBonus = getMagicEquipmentBoost( playerEquipment);

        double maxDamage = (spellBaseMaxHit * magicDmgBonus);

        // Step 3: Calculate Bonuses
        // Tome Bonuses
        double correctTomeSpellBonus = getTomeSpellBonus(playerEquipment, spell); // default 1
        maxDamage = maxDamage * correctTomeSpellBonus;

        // Final step: Calculate and add spell type weakness Bonus
        if(spell.hasType())
        {
            if(plugin.selectedNPCName != null)
            {
                NPCTypeWeakness weaknessBonus = NPCTypeWeakness.findWeaknessByName(plugin.selectedNPCName);
                if(weaknessBonus != null)
                {
                    if(spell.getSpellType() == weaknessBonus.getElementalWeakness())
                    {
                        int bonusPercent = weaknessBonus.getWeaknessPercent();

                        double typeBonusDamage = spellBaseMaxHit * ((double) bonusPercent / (double)100);
                        maxDamage = maxDamage + typeBonusDamage;
                    }
                }
            }
        }

        // Twinflame Staff Double Hit bonus
        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        if (weaponItemName.toLowerCase().contains("twinflame staff"))
        {
            if (spell != null && spell.getSpellbook().contains("standard")) {

                if(!spell.getName().toLowerCase().contains("strike") && !spell.getName().toLowerCase().contains("surge"))
                {
                    double bonusHit = Math.floor(maxDamage) * 0.4;
                    maxDamage = Math.floor(maxDamage) + Math.floor(bonusHit);
                }
            }
        }

        return maxDamage;
    }
}

/* SpellType.java
 * Separates spells by SpriteID. Useful for getting the selected auto-cast spell.
 *
 *
 * Copyright (c) 2024, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

public enum SpellType {
    Air,
    Water,
    Earth,
    Fire,
    NoType
}

/* InventoryItemMaxHit.java
 * Contains functions required for calculating max hit based on hovered equipment in inventory.
 *
 *
 * Copyright (c) 2025, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.Skill;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.itemstats.StatChange;

import java.util.ArrayList;
import java.util.List;

public class StatChangedMaxHit
{
    protected MaxHitCalcPlugin plugin;
    protected MaxHitCalcConfig config;
    private MaxHit maxHits;
    protected ItemManager itemManager;
    protected Client client;

    StatChangedMaxHit(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        this.config = config;
        this.maxHits = new MaxHit(plugin, config, itemManager, client);
        this.itemManager = itemManager;
        this.client = client;
        this.plugin = plugin;
    }

    boolean checkIfStatChanged(StatChange[] stats, Skill skill)
    {
        String skillName = skill.getName().toLowerCase();

        for(StatChange stat: stats)
        {
            if(stat.getStat().getName().toLowerCase().contains(skillName))
            {
                return true;
            }
        }

        return false;
    }

    int getChangedStatValue(StatChange[] stats, Skill skill)
    {
        String skillName = skill.getName().toLowerCase();

        for(StatChange stat: stats)
        {
            if(stat.getStat().getName().toLowerCase().contains(skillName))
            {
                return stat.getAbsolute();
            }
        }

        return 0;
    }

    // Passive Melee Set effects
    protected List<Double> getMeleeSpecialBonusMultiplier(Item[] playerEquipment, StatChange[] changedStats)
    {
        List<Double> specialBonusesToApply = new ArrayList<>();

        if (playerEquipment == null) return specialBonusesToApply;

        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
        String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
        String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);
        String ammuletItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.AMULET);

        // SPECIAL BONUSES MUST BE ORDERED CORRECTLY.
        // Dharok's Set Check
        if (headItemName.contains("Dharok's"))
        {
            if(bodyItemName.contains("Dharok's"))
            {
                if(legsItemName.contains("Dharok's"))
                {
                    if(weaponItemName.contains("Dharok's"))
                    {
                        // Passed Check, Dharok's Set Equipped, Apply Effect
                        double baseHP = client.getRealSkillLevel(Skill.HITPOINTS);

                        double currentHP = 1;
                        if(checkIfStatChanged(changedStats, Skill.HITPOINTS))
                        {
                            currentHP = getChangedStatValue(changedStats, Skill.HITPOINTS);
                        }
                        else
                        {
                            currentHP = client.getBoostedSkillLevel(Skill.HITPOINTS);
                        }

                        double dharokBonus = ((((baseHP - currentHP) / 100) * (baseHP / 100)));

                        specialBonusesToApply.add(dharokBonus);
                    }
                }
            }
        }

        // Obsidian Set Check
        if (headItemName.contains("Obsidian"))
        {
            if(bodyItemName.contains("Obsidian"))
            {
                if(legsItemName.contains("Obsidian"))
                {
                    if(weaponItemName.contains("ket") || weaponItemName.contains("xil"))
                    {
                        specialBonusesToApply.add(0.1);
                    }
                }
            }
        }

        // Berserker Necklace and Obisidian Melee Check
        if(weaponItemName.contains("ket") || weaponItemName.contains("xil"))
        {
            if(ammuletItemName.contains("Berserker"))
            {
                specialBonusesToApply.add(0.2);
            }
        }

        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Special Bonus: " + specialBonus, null);

        return specialBonusesToApply;
    }

    // Calculate Melee max hit with chagned stats
    protected double calculateMeleeMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, int attackStyleID, boolean isSpecialAttack, StatChange[] changedStats)
    {
        // Calculate Melee Max Hit
        // Step 1: Calculate effective Strength
        int strengthLevel = 1;
        if(checkIfStatChanged(changedStats, Skill.STRENGTH))
        {
            strengthLevel = getChangedStatValue(changedStats, Skill.STRENGTH);
        }
        else
        {
            strengthLevel = client.getBoostedSkillLevel(Skill.STRENGTH);
        }


        double prayerBonus = maxHits.getPrayerBonus(weaponAttackStyle);
        int styleBonus = maxHits.getAttackStyleBonus(weaponAttackStyle, attackStyleID);
        double voidBonus = maxHits.getVoidMeleeBonus(playerEquipment); // default 1;
        double soulStackBonus = maxHits.getSoulStackBonus();
        double effectiveSoulStackLevel = 0;

        if (!isSpecialAttack)
        {
            effectiveSoulStackLevel = Math.floor(strengthLevel * soulStackBonus);
        }

        double effectiveStrength = Math.floor((Math.floor(strengthLevel * prayerBonus) + effectiveSoulStackLevel + styleBonus + 8) * voidBonus);

        // Step 2: Calculate the base damage
        double strengthBonus = maxHits.getMeleeStrengthBonus(playerEquipment); // default 0

        double baseDamage = (0.5 + (effectiveStrength * ((strengthBonus + 64)/640)));
        double flooredBaseDamage = Math.floor(baseDamage);

        // Step 3: Calculate the bonus damage
        List<Double> specialBonusMultipliers = getMeleeSpecialBonusMultiplier(playerEquipment, changedStats); // default empty

        double maxHit = flooredBaseDamage;

        if(!specialBonusMultipliers.isEmpty())
        {
            for (double bonus: specialBonusMultipliers)
            {
                maxHit += Math.floor(maxHit * bonus);
            }
        }

        // Osmumten's Fang Decrease
        String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        if (weaponName.contains("Osmumten's fang"))
        {
            maxHit = maxHit * 0.85 + 1;
        }

        // Colossal Blade Base Increase
        if(weaponName.contains("Colossal blade")){
            maxHit = maxHit + 2;
        }

        // Rat Default +10 damage Bonus
        if(weaponName.contains("Bone mace"))
        {
            maxHit = maxHit + 10;
        }

        // Complete
        return maxHit;
    }

    // Calculate Ranged max hit with changed stats
    protected double calculateRangedMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, int attackStyleID, StatChange[] changedStats)
    {
        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);

        // Calculate Ranged Max Hit
        // Step 1: Calculate effective ranged Strength
        int rangedLevel = 1;
        if(checkIfStatChanged(changedStats, Skill.RANGED))
        {
            rangedLevel = getChangedStatValue(changedStats, Skill.RANGED);
        }
        else
        {
            rangedLevel = client.getBoostedSkillLevel(Skill.RANGED);
        }

        double prayerBonus = maxHits.getPrayerBonus(weaponAttackStyle);
        int styleBonus = maxHits.getAttackStyleBonus(weaponAttackStyle, attackStyleID);
        double voidBonus = maxHits.getVoidRangedBonus(playerEquipment); // default 1;

        // If using the atlatl, calculate with strength instead of ranged
        if(weaponItemName.contains("atlatl"))
        {
            if(checkIfStatChanged(changedStats, Skill.STRENGTH))
            {
                rangedLevel = getChangedStatValue(changedStats, Skill.STRENGTH);
            }
            else
            {
                rangedLevel  = client.getBoostedSkillLevel(Skill.STRENGTH);
            }
        }

        double effectiveRangedStrength = Math.floor((Math.floor(rangedLevel * prayerBonus) + styleBonus + 8) * voidBonus);

        // Step 2: Calculate the max hit
        double equipmentRangedStrength = maxHits.getRangedStrengthBonus(playerEquipment);
        double gearBonus = maxHits.getRangeGearBoost(playerEquipment);

        double maxHit = (0.5 + (((effectiveRangedStrength * (equipmentRangedStrength + 64))/640) * gearBonus) );

        // Step 3: Bonus damage from special attack and effects
        // Rat Default +10 damage Bonus
        if(weaponItemName.contains("Bone shortbow"))
        {
            maxHit = maxHit + 10;
        }

        // Tonalztics of Ralos (uncharged) max hit is 75% of normal
        if(weaponItemName.contains("Tonalztics of ralos"))
        {
            maxHit = Math.floor(maxHit * 0.75); // unknown if flooring here causes miscalcs
            if(!weaponItemName.contains("(uncharged)"))
            {
                maxHit = maxHit * 2;
            }
        }

        return maxHit;
    }

    // Calculate magic max hit with chagned stats
    protected double calculateMagicMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, StatChange[] changedStats)
    {
        // Calculate Magic Max Hit
        // Step 1: Find the base hit of the spell
        int magicLevel = 1;
        if(checkIfStatChanged(changedStats, Skill.MAGIC))
        {
            magicLevel = getChangedStatValue(changedStats, Skill.MAGIC);
        }
        else
        {
            magicLevel = client.getBoostedSkillLevel(Skill.MAGIC);
        }

        double spellBaseMaxHit = maxHits.getSpellBaseHit(playerEquipment, weaponAttackStyle, magicLevel);

        if (spellBaseMaxHit == 0)
        {
            return -1;
        }

        // Step 2: Calculate the Magic Damage Bonus
        double magicDmgBonus = maxHits.getMagicEquipmentBoost(playerEquipment);

        double maxDamage = (spellBaseMaxHit * magicDmgBonus);

        // Step 3: Calculate Bonuses
        // Tome Bonuses
        double correctTomeSpellBonus = maxHits.getTomeSpellBonus(playerEquipment, weaponAttackStyle); // default 1
        maxDamage = maxDamage * correctTomeSpellBonus;

        // Final step: Calculate and add spell type weakness Bonus
        CombatSpell spell = maxHits.getSpell();
        if (spell != null && spell.hasType())
        {
            if (plugin.selectedNPCName != null)
            {
                NPCTypeWeakness weaknessBonus = NPCTypeWeakness.findWeaknessByName(plugin.selectedNPCName);
                if (weaknessBonus != null)
                {
                    if(spell.getSpellType() == weaknessBonus.getElementalWeakness())
                    {
                        int bonusPercent = weaknessBonus.getWeaknessPercent();

                        double typeBonusDamage = spellBaseMaxHit * ((double) bonusPercent / (double)100);
                        maxDamage = maxDamage + typeBonusDamage;
                    }
                }
            }
        }

        // Twinflame Staff Double Hit bonus
        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        if (weaponItemName.toLowerCase().contains("twinflame staff"))
        {
            if (spell != null && spell.getSpellbook().contains("standard"))
            {
                if(!spell.getName().toLowerCase().contains("strike") && !spell.getName().toLowerCase().contains("surge"))
                {
                    double bonusHit = Math.floor(maxDamage) * 0.4;
                    maxDamage = Math.floor(maxDamage) + Math.floor(bonusHit);
                }
            }
        }

        return maxDamage;
    }

    /**
     * Predicts max hit with a given list of changed stats.
     *
     * @param changedStats list of stats that have changed
     * @return Max Hit Prediction as Double
     */
    public double predict(StatChange[] changedStats)
    {
        // Initialize Variables
        int attackStyleID = client.getVarpValue(VarPlayerID.COM_MODE); // Varplayer: Attack Style
        int weaponTypeID = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);  // Varbit: Equipped Weapon Type

        // Get Current Attack Style
        AttackStyle[] weaponAttackStyles = WeaponType.getWeaponTypeStyles(client, weaponTypeID);
        AttackStyle attackStyle = weaponAttackStyles[attackStyleID];
        if (attackStyle == null)
            return -1;

        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);

        // Find what type to calculate
        if(attackStyle.equals(AttackStyle.ACCURATE) || attackStyle.equals(AttackStyle.AGGRESSIVE) || attackStyle.equals(AttackStyle.CONTROLLED) || attackStyle.equals(AttackStyle.DEFENSIVE))
        {
            return calculateMeleeMaxHit(playerEquipment, attackStyle, attackStyleID, false, changedStats);
        }
        else if (attackStyle.equals(AttackStyle.RANGING) || attackStyle.equals(AttackStyle.LONGRANGE))
        {
            return calculateRangedMaxHit(playerEquipment, attackStyle, attackStyleID, changedStats);
        }
        else if ((attackStyle.equals(AttackStyle.CASTING)  || attackStyle.equals(AttackStyle.DEFENSIVE_CASTING)))
        {
            double magicMaxHit = calculateMagicMaxHit(playerEquipment, attackStyle, changedStats);

            // If -1, error, skip
            if (magicMaxHit > -1){
                return magicMaxHit;
            }
        }

        return -1;

    }
}

/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// From AttackStyles RuneLite plugin
// Located at: https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/attackstyles/WeaponType.java
// or net.runelite.client.plugins.attackstyles.AttackStyle

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.EnumID;
import net.runelite.api.ParamID;
import net.runelite.api.StructComposition;

import static com.maxhitcalc.AttackStyle.*;

public class WeaponType
{
    // Modified From runelite.client.plugins.attackstyles.AttackStyle
    protected static AttackStyle[] getWeaponTypeStyles(Client client, int weaponType)
    {
        // Keris partisan returns 30; values can only be from 0-28 ?
        if (weaponType == 30)
            weaponType = 17; // set to equivalent weapon type; accurate, aggr, aggr, defensive

        // Blue moon spear returns 22; enum undefined at 22, change to regular bladed spear: 21
        if (weaponType == 22)
            weaponType = 21;

        int weaponStyleEnum = client.getEnum(EnumID.WEAPON_STYLES).getIntValue(weaponType);
        int[] weaponStyleStructs = client.getEnum(weaponStyleEnum).getIntVals();

        AttackStyle[] styles = new AttackStyle[weaponStyleStructs.length];
        int i = 0;
        for (int style : weaponStyleStructs)
        {
            StructComposition attackStyleStruct = client.getStructComposition(style);
            String attackStyleName = attackStyleStruct.getStringValue(ParamID.ATTACK_STYLE_NAME);

            AttackStyle attackStyle = AttackStyle.valueOf(attackStyleName.toUpperCase());
            if (attackStyle == OTHER)
            {
                // "Other" is used for no style
                ++i;
                continue;
            }

            // "Defensive" is used for Defensive and also Defensive casting
            if (attackStyle == DEFENSIVE)
            {
                // Powered Staves Check, has "defensive" but should be "defensive casting"
                if (weaponType == 24)
                    attackStyle = DEFENSIVE_CASTING;
            }

            styles[i++] = attackStyle;
        }
        return styles;
    }

}
package com.maxhitcalc;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class MaxHitCalcPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(MaxHitCalcPlugin.class);
		RuneLite.main(args);
	}
}
