/*
 * Copyright (c) 2017, Steve <steve.rs.dev@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimsieder.customxpglobes;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;
import javax.inject.Inject;

import com.google.inject.Provides;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.StatChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.xptracker.XpTrackerPlugin;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.overlay.OverlayManager;

@PluginDescriptor(
        name = "Custom XP Globes",
        description = "Runtime XP globes overlay with FORCE/BLACKLIST modes",
        tags = {"experience", "levels", "overlay", "custom"}
)
@PluginDependency(XpTrackerPlugin.class)
public class CustomXpGlobesPlugin extends Plugin
{
    private CustomXpGlobe[] globeCache = new CustomXpGlobe[Skill.values().length];

    private boolean firstMovementDetected = false;
    private int lastX = -1;
    private int lastY = -1;

    @Getter
    private final List<CustomXpGlobe> xpGlobes = new ArrayList<>();

    @Inject
    private CustomXpGlobesConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private CustomXpGlobesOverlay overlay;

    @Inject
    private Client client;

    @Provides
    CustomXpGlobesConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(CustomXpGlobesConfig.class);
    }

    @Override
    protected void startUp()
    {
        overlayManager.add(overlay);
        xpGlobes.clear();
        loadOrRefreshForcedSkills();
    }

    @Override
    protected void shutDown()
    {
        overlayManager.remove(overlay);
        resetGlobeState();
    }

    /**
     * Returns the user-selected priority for a given skill.
     */
    private int getSkillPriority(Skill skill)
    {
        switch (skill)
        {
            case ATTACK: return config.attackPriority();
            case STRENGTH: return config.strengthPriority();
            case DEFENCE: return config.defencePriority();
            case RANGED: return config.rangedPriority();
            case PRAYER: return config.prayerPriority();
            case MAGIC: return config.magicPriority();
            case RUNECRAFT: return config.runecraftPriority();
            case CONSTRUCTION: return config.constructionPriority();
            case HITPOINTS: return config.hitpointsPriority();
            case AGILITY: return config.agilityPriority();
            case HERBLORE: return config.herblorePriority();
            case THIEVING: return config.thievingPriority();
            case CRAFTING: return config.craftingPriority();
            case FLETCHING: return config.fletchingPriority();
            case SLAYER: return config.slayerPriority();
            case HUNTER: return config.hunterPriority();
            case MINING: return config.miningPriority();
            case SMITHING: return config.smithingPriority();
            case FISHING: return config.fishingPriority();
            case COOKING: return config.cookingPriority();
            case FIREMAKING: return config.firemakingPriority();
            case WOODCUTTING: return config.woodcuttingPriority();
            case FARMING: return config.farmingPriority();
            case SAILING: return config.sailingPriority();
            default: return skill.ordinal(); // fallback
        }
    }

    public enum SkillDisplayMode { NORMAL, FORCE, BLACKLIST }

    public SkillDisplayMode getSkillMode(Skill skill)
    {
        CustomXpGlobesConfig.SkillDisplayMode cfgMode;
        switch (skill)
        {
            case ATTACK: cfgMode = config.attackDisplay(); break;
            case STRENGTH: cfgMode = config.strengthDisplay(); break;
            case DEFENCE: cfgMode = config.defenceDisplay(); break;
            case RANGED: cfgMode = config.rangedDisplay(); break;
            case PRAYER: cfgMode = config.prayerDisplay(); break;
            case MAGIC: cfgMode = config.magicDisplay(); break;
            case RUNECRAFT: cfgMode = config.runecraftDisplay(); break;
            case CONSTRUCTION: cfgMode = config.constructionDisplay(); break;
            case AGILITY: cfgMode = config.agilityDisplay(); break;
            case HERBLORE: cfgMode = config.herbloreDisplay(); break;
            case HITPOINTS: cfgMode = config.hitpointsDisplay(); break;
            case THIEVING: cfgMode = config.thievingDisplay(); break;
            case CRAFTING: cfgMode = config.craftingDisplay(); break;
            case FLETCHING: cfgMode = config.fletchingDisplay(); break;
            case SLAYER: cfgMode = config.slayerDisplay(); break;
            case HUNTER: cfgMode = config.hunterDisplay(); break;
            case MINING: cfgMode = config.miningDisplay(); break;
            case SMITHING: cfgMode = config.smithingDisplay(); break;
            case FISHING: cfgMode = config.fishingDisplay(); break;
            case COOKING: cfgMode = config.cookingDisplay(); break;
            case FIREMAKING: cfgMode = config.firemakingDisplay(); break;
            case WOODCUTTING: cfgMode = config.woodcuttingDisplay(); break;
            case FARMING: cfgMode = config.farmingDisplay(); break;
	    case SAILING: cfgMode = config.sailingDisplay(); break;
            default: cfgMode = CustomXpGlobesConfig.SkillDisplayMode.NORMAL; break;
        }

        switch (cfgMode)
        {
            case FORCE: return SkillDisplayMode.FORCE;
            case BLACKLIST: return SkillDisplayMode.BLACKLIST;
            case NORMAL:
            default: return SkillDisplayMode.NORMAL;
        }
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        if (!firstMovementDetected)
        {
            if (client.getLocalPlayer() != null)
            {
                int x = client.getLocalPlayer().getWorldLocation().getX();
                int y = client.getLocalPlayer().getWorldLocation().getY();

                if (lastX != -1 && lastY != -1 && (x != lastX || y != lastY))
                {
                    firstMovementDetected = true;
                }

                lastX = x;
                lastY = y;
            }
        }
    }

    @Subscribe
    public void onStatChanged(StatChanged statChanged)
    {
        Skill skill = statChanged.getSkill();
        int currentXp = statChanged.getXp();
        int currentLevel = statChanged.getLevel();
        int skillIdx = skill.ordinal();

        SkillDisplayMode mode = getSkillMode(skill);
        CustomXpGlobe cachedGlobe = globeCache[skillIdx];
        boolean isForce = mode == SkillDisplayMode.FORCE;

        if (mode == SkillDisplayMode.BLACKLIST)
        {
            return;
        }

        if (mode == SkillDisplayMode.NORMAL && !firstMovementDetected)
        {
            return;
        }

        if (mode == SkillDisplayMode.NORMAL)
        {
            int previousXp = cachedGlobe != null ? cachedGlobe.getCurrentXp() : 0;
            if (currentXp <= previousXp)
            {
                return;
            }
        }

        switch (config.maxedSkillDisplay())
        {
            case HIDE_MAXED:
                if (currentLevel >= Experience.MAX_REAL_LEVEL && !isForce)
                {
                    return;
                }
                break;
            case SHOW_VIRTUAL:
                if (currentLevel >= Experience.MAX_REAL_LEVEL)
                {
                    currentLevel = Experience.getLevelForXp(currentXp);
                }
                break;
            default:
                break;
        }

        if (cachedGlobe != null)
        {
            cachedGlobe.setCurrentXp(currentXp);
            cachedGlobe.setCurrentLevel(currentLevel);
            cachedGlobe.setTime(Instant.now());

            if (!xpGlobes.contains(cachedGlobe))
                addXpGlobe(cachedGlobe, isForce);
        }
        else if (isForce || (mode == SkillDisplayMode.NORMAL && firstMovementDetected))
        {
            cachedGlobe = new CustomXpGlobe(skill, currentXp, currentLevel, Instant.now());
            globeCache[skillIdx] = cachedGlobe;
            addXpGlobe(cachedGlobe, isForce);
        }
    }

    private void sortAndEnforceOrbs()
    {
        // Recalculate priorities for all globes
        xpGlobes.forEach(globe -> globe.setCachedPriority(getSkillPriority(globe.getSkill())));

        // Sort: if forceOrbs is enabled, forced orbs first, otherwise all together
        xpGlobes.sort((a, b) -> {
            SkillDisplayMode aMode = getSkillMode(a.getSkill());
            SkillDisplayMode bMode = getSkillMode(b.getSkill());

            if (config.forceOrbs())
            {
                if (aMode == SkillDisplayMode.FORCE && bMode != SkillDisplayMode.FORCE) return -1;
                if (aMode != SkillDisplayMode.FORCE && bMode == SkillDisplayMode.FORCE) return 1;
            }

            // Compare by cached priority (ascending)
            int cmp = Integer.compare(a.getCachedPriority(), b.getCachedPriority());
            if (cmp != 0) return cmp;

            // Tie-breaker: RuneScape skill order
            return Integer.compare(a.getSkill().ordinal(), b.getSkill().ordinal());
        });

        // Enforce maximum shown orbs
        enforceMaximumOrbs();
    }


    private void addXpGlobe(CustomXpGlobe globe, boolean ignoreMax)
    {
        globe.setCachedPriority(getSkillPriority(globe.getSkill()));
        xpGlobes.add(globe);

        if (!ignoreMax)
        {
            sortAndEnforceOrbs();
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (!event.getGroup().equals("customxpglobes"))
            return;

        loadOrRefreshForcedSkills();

        sortAndEnforceOrbs();
    }

    /**
     * Ensures that the total number of normal orbs does not exceed the allowed maximum,
     * taking into account the number of forced orbs.
     */
    private void enforceMaximumOrbs()
    {
        int forcedCount = (int) xpGlobes.stream()
                .filter(g -> getSkillMode(g.getSkill()) == SkillDisplayMode.FORCE)
                .count();

        int maxNormal = Math.max(config.maximumShownGlobes() - forcedCount, 0);

        // Collect normal orbs sorted oldest first
        List<CustomXpGlobe> normalOrbs = xpGlobes.stream()
                .filter(g -> getSkillMode(g.getSkill()) != SkillDisplayMode.FORCE)
                .sorted(Comparator.comparing(CustomXpGlobe::getTime))
                .collect(Collectors.toList());

        // Remove the oldest normal orbs until the count fits the limit
        while (normalOrbs.size() > maxNormal)
        {
            CustomXpGlobe oldest = normalOrbs.remove(0);
            xpGlobes.remove(oldest);
            globeCache[oldest.getSkill().ordinal()] = null;
        }
    }

    @Schedule(period = 1, unit = ChronoUnit.SECONDS)
    public void removeExpiredXpGlobes()
    {
        Instant expire = Instant.now().minusSeconds(config.xpOrbDuration());
        xpGlobes.removeIf(globe -> {
            boolean expired = getSkillMode(globe.getSkill()) != SkillDisplayMode.FORCE &&
                    globe.getTime().isBefore(expire);
            if (expired)
            {
                globeCache[globe.getSkill().ordinal()] = null;
            }
            return expired;
        });
    }

    private void resetGlobeState()
    {
        xpGlobes.clear();
        globeCache = new CustomXpGlobe[Skill.values().length];
        firstMovementDetected = false; // reset movement detection
        lastX = -1;
        lastY = -1;
    }


    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        switch (event.getGameState())
        {
            case LOADING:
                // Reset movement tracking so normal XP globes wait until the player moves
                firstMovementDetected = false;
                lastX = -1;
                lastY = -1;
                break;
                        
            case LOGIN_SCREEN:
                resetGlobeState(); // clear any data on new session
                loadOrRefreshForcedSkills(); // forced orbs always loaded
                break;

            default:
                break;
        }
    }

    private void loadOrRefreshForcedSkills()
    {
        for (Skill skill : Skill.values())
        {
            int idx = skill.ordinal();
            SkillDisplayMode mode = getSkillMode(skill);

            if (mode == SkillDisplayMode.FORCE && globeCache[idx] == null)
            {
                int xp = client.getSkillExperience(skill);
                int level = client.getRealSkillLevel(skill);

                CustomXpGlobe globe = new CustomXpGlobe(skill, xp, level, Instant.now());
                globeCache[idx] = globe;
                addXpGlobe(globe, true); // ignoreMax = true for forced orbs
            }
        }
        sortAndEnforceOrbs();
    }

}



/*
 * Copyright (c) 2017, Steve <steve.rs.dev@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimsieder.customxpglobes;

import java.awt.Color;
import net.runelite.client.config .Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Units;
import net.runelite.client.config.Range;

@ConfigGroup("customxpglobes")
public interface CustomXpGlobesConfig extends Config
{
    /* ---------------- On Screen Orbs ---------------- */
    @ConfigSection(
            name = "On Screen Orbs",
            description = "Settings for On Screen Orbs",
            position = 0
    )
    String onScreenOrbs = "On Screen Orbs";

    @ConfigItem(
            keyName = "orbsPerLine",
            name = "Max Orbs Per Line",
            description = "Maximum number of XP orbs to display per row/column before wrapping",
            position = 1,
            section = onScreenOrbs
    )
    @Range(
            min = 1,
            max = 23
    )
    default int orbsPerLine() {
        return 10; // default wrap
    }

    @ConfigItem(
            keyName = "maximumShownGlobes",
            name = "Maximum Shown Orbs",
            description = "The maximum number of XP Orbs displayed at once",
            position = 2,
            section = onScreenOrbs
    )
    @Range(
            min = 1,
            max = 23
    )
    default int maximumShownGlobes() {
        return 5; // default value
    }

    @ConfigItem(
            keyName = "alignOrbsVertically",
            name = "Vertical Orbs",
            description = "Aligns the orbs vertically instead of horizontally.",
            position = 5,
            section = onScreenOrbs
    )
    default boolean alignOrbsVertically() {
        return false;
    }

    @ConfigItem(
            keyName = "forceOrbs",
            name = "Forced Orbs Before Normal Orbs",
            description = "If enabled, Forced XP globes display before normal orbs",
            position = 6,
            section = onScreenOrbs
    )
    default boolean forceOrbs() { return false; }

    enum MaxedSkillDisplay {
        NORMAL,           // Show all skills including 99
        HIDE_MAXED,       // Hide maxed skills
        SHOW_VIRTUAL      // Show virtual levels over 99
    }

    @ConfigItem(
            keyName = "maxedSkillDisplay",
            name = "Maxed Skill Display",
            description = "Controls how maxed skills are displayed in XP globes",
            position = 7,
            section = onScreenOrbs
    )
    default MaxedSkillDisplay maxedSkillDisplay() {
        return MaxedSkillDisplay.NORMAL;
    }

    @ConfigItem(
            keyName = "Orb duration",
            name = "Duration of orbs",
            description = "Change the duration the XP orbs are visible.",
            position = 8,
            section = onScreenOrbs
    )
    @Units(Units.SECONDS)
    default int xpOrbDuration() { return 10; }

    @ConfigItem(
            keyName = "lastLineAlignment",
            name = "Last Line Alignment",
            description = "How to align the last row/column if it is not full",
            position = 9,
            section = onScreenOrbs
    )
    default LastLineAlignment lastLineAlignment()
    {
        return LastLineAlignment.CENTER; // default
    }

    enum LastLineAlignment
    {
        LEFT("Left / Top"),
        CENTER("Center"),
        RIGHT("Right / Bottom");

        private final String displayName;

        LastLineAlignment(String displayName)
        {
            this.displayName = displayName;
        }

        @Override
        public String toString()
        {
            return displayName;
        }
    }

    /* ---------------- Customize Orbs ---------------- */
    enum LevelDisplayOption
    {
        NONE,
        SKILL_COLOR,
        CUSTOM_COLOR
    }

    @ConfigSection(
            name = "Customize Orbs",
            description = "Settings for Customizing Orbs",
            position = 12,
            closedByDefault = true
    )
    String customizeOrbs = "Customize Orbs";

    @ConfigItem(
            keyName = "Orb size",
            name = "Size of orbs",
            description = "Change the size of the XP orbs.",
            position = 13,
            section = customizeOrbs
    )
    @Units(Units.PIXELS)
    default int xpOrbSize() {
        return 40;
    }

    @ConfigItem(
            keyName = "enableCustomArcColor",
            name = "Enable custom arc color",
            description = "Enables the custom coloring of the globe's arc instead of using the skill's default color.",
            position = 14,
            section = customizeOrbs
    )
    default boolean enableCustomArcColor() {
        return false;
    }

    @Alpha
    @ConfigItem(
            keyName = "Progress arc color",
            name = "Progress arc color",
            description = "Change the color of the progress arc in the XP orb.",
            position = 15,
            section = customizeOrbs
    )
    default Color progressArcColor() {
        return Color.ORANGE;
    }

    @Alpha
    @ConfigItem(
            keyName = "Progress orb outline color",
            name = "Progress orb outline color",
            description = "Change the color of the progress orb outline.",
            position = 16,
            section = customizeOrbs
    )
    default Color progressOrbOutLineColor() {
        return Color.BLACK;
    }

    @Alpha
    @ConfigItem(
            keyName = "Progress orb background color",
            name = "Progress orb background color",
            description = "Change the color of the progress orb background.",
            position = 17,
            section = customizeOrbs
    )
    default Color progressOrbBackgroundColor() {
        return new Color(128, 128, 128, 127);
    }

    @ConfigItem(
            keyName = "Progress arc width",
            name = "Progress arc width",
            description = "Change the stroke width of the progress arc.",
            position = 18,
            section = customizeOrbs
    )
    @Units(Units.PIXELS)
    default int progressArcStrokeWidth() {
        return 2;
    }

    @ConfigItem(
            keyName = "levelDisplayOption",
            name = "Level Display",
            description = "Choose how the level is displayed inside the orb",
            position = 19,
            section = customizeOrbs
    )
    default LevelDisplayOption levelDisplayOption()
    {
        return LevelDisplayOption.SKILL_COLOR;
    }

    // Helper for conditional visibility
    default boolean isCustomLevel()
    {
        return levelDisplayOption() == LevelDisplayOption.CUSTOM_COLOR;
    }

    @Alpha
    @ConfigItem(
            keyName = "levelColor",
            name = "Level Color",
            description = "Color of the skill level text inside the orb",
            position = 20,
            section = customizeOrbs
    )
    default Color levelColor()
    {
        return Color.YELLOW;
    }

    @ConfigItem(
            keyName = "levelSize",
            name = "Level Size",
            description = "Adjust the level text size (-100 to 100)",
            position = 21,
            section = customizeOrbs
    )
    @Range(min = 0, max = 50)
    default int levelSize()
    {
        return 0;
    }

    @Range(min = -100, max = 100) // allows -100 to +100
    @ConfigItem(
            keyName = "iconVerticalOffset",
            name = "Icon Vertical Offset",
            description = "Move the skill icon up (positive) or down (negative) inside the orb (pixels).",
            position = 24,
            section = customizeOrbs
    )
    default int iconVerticalOffset() {
        return 6;
    }

    @Range(min = -100, max = 100) // allows -100 to +100
    @ConfigItem(
            keyName = "levelVerticalOffset",
            name = "Level Vertical Offset",
            description = "Move the skill level text up (positive) or down (negative) inside the orb (pixels).",
            position = 25,
            section = customizeOrbs
    )
    default int levelVerticalOffset() {
        return -12;
    }

    /* ---------------- Orb Tooltips ---------------- */
    @ConfigSection(
            name = "Orb Tooltips",
            description = "Settings for Orb Tooltips",
            position = 30,
            closedByDefault = true
    )
    String orbTooltips = "Orb Tooltips";

    enum TooltipLine
    {
        NONE("None"),
        CURRENT_TOTAL_XP("Current Total XP"),
        XP_LEFT_FOR_LEVEL("XP Left For Level"),
        ACTIONS_LEFT_BEFORE_LEVEL("Actions Left Before Level"),
        XP_PER_HOUR("XP Per Hour"),
        TIME_TILL_LEVEL("Time Till Level"),
        BLANK("Spacer");

        private final String displayName;

        TooltipLine(String displayName)
        {
            this.displayName = displayName;
        }

        @Override
        public String toString()
        {
            return displayName;
        }
    }

    // ---------------- Enable Tooltips ----------------
    @ConfigItem(
            keyName = "enableTooltips",
            name = "Enable Tooltips",
            description = "Show or hide XP tooltips on the orbs",
            position = 31,
            section = orbTooltips
    )
    default boolean enableTooltips()
    {
        return true;
    }

    // ---------------- Tooltip Lines ----------------
    @ConfigItem(keyName = "tooltipLine1", name = "Line 1", description = "Select the first line", position = 32, section = orbTooltips)
    default TooltipLine tooltipLine1() { return TooltipLine.CURRENT_TOTAL_XP; }

    @ConfigItem(keyName = "tooltipLine2", name = "Line 2", description = "Select the second line", position = 33, section = orbTooltips)
    default TooltipLine tooltipLine2() { return TooltipLine.XP_LEFT_FOR_LEVEL; }

    @ConfigItem(keyName = "tooltipLine3", name = "Line 3", description = "Select the third line", position = 34, section = orbTooltips)
    default TooltipLine tooltipLine3() { return TooltipLine.NONE; }

    @ConfigItem(keyName = "tooltipLine4", name = "Line 4", description = "Select the fourth line", position = 35, section = orbTooltips)
    default TooltipLine tooltipLine4() { return TooltipLine.NONE; }

    @ConfigItem(keyName = "tooltipLine5", name = "Line 5", description = "Select the fifth line", position = 36, section = orbTooltips)
    default TooltipLine tooltipLine5() { return TooltipLine.NONE; }

    // ---------------- Tooltip Colors ----------------
    @ConfigItem(
            keyName = "enableTooltipColors",
            name = "Enable Tooltip Colors",
            description = "Use individual colors for each tooltip line",
            position = 37,
            section = orbTooltips
    )
    default boolean enableTooltipColors() { return false; }

    @Alpha
    @ConfigItem(keyName = "tooltipLine1Color", name = "Line 1 Color", description = "Color for line 1", position = 39, section = orbTooltips)
    default Color tooltipLine1Color() { return Color.ORANGE; }

    @Alpha
    @ConfigItem(keyName = "tooltipLine2Color", name = "Line 2 Color", description = "Color for line 2", position = 40, section = orbTooltips)
    default Color tooltipLine2Color() { return Color.ORANGE; }

    @Alpha
    @ConfigItem(keyName = "tooltipLine3Color", name = "Line 3 Color", description = "Color for line 3", position = 41, section = orbTooltips)
    default Color tooltipLine3Color() { return Color.ORANGE; }

    @Alpha
    @ConfigItem(keyName = "tooltipLine4Color", name = "Line 4 Color", description = "Color for line 4", position = 42, section = orbTooltips)
    default Color tooltipLine4Color() { return Color.ORANGE; }

    @Alpha
    @ConfigItem(keyName = "tooltipLine5Color", name = "Line 5 Color", description = "Color for line 5", position = 43, section = orbTooltips)
    default Color tooltipLine5Color() { return Color.ORANGE; }

    // ---------------- Tooltip Value Colors ----------------
    @ConfigItem(
            keyName = "enableTooltipValueColors",
            name = "Enable Tooltip Value Colors",
            description = "Use individual colors for each tooltip line value",
            position = 44,
            section = orbTooltips
    )
    default boolean enableTooltipValueColors() { return false; }

    @Alpha
    @ConfigItem(keyName = "tooltipLine1ValueColor", name = "Line 1 Value Color", description = "Color for line 1 value", position = 46, section = orbTooltips)
    default Color tooltipLine1ValueColor() { return Color.WHITE; }

    @Alpha
    @ConfigItem(keyName = "tooltipLine2ValueColor", name = "Line 2 Value Color", description = "Color for line 2 value", position = 47, section = orbTooltips)
    default Color tooltipLine2ValueColor() { return Color.WHITE; }

    @Alpha
    @ConfigItem(keyName = "tooltipLine3ValueColor", name = "Line 3 Value Color", description = "Color for line 3 value", position = 48, section = orbTooltips)
    default Color tooltipLine3ValueColor() { return Color.WHITE; }

    @Alpha
    @ConfigItem(keyName = "tooltipLine4ValueColor", name = "Line 4 Value Color", description = "Color for line 4 value", position = 49, section = orbTooltips)
    default Color tooltipLine4ValueColor() { return Color.WHITE; }

    @Alpha
    @ConfigItem(keyName = "tooltipLine5ValueColor", name = "Line 5 Value Color", description = "Color for line 5 value", position = 50, section = orbTooltips)
    default Color tooltipLine5ValueColor() { return Color.WHITE; }

    // ---------------- Skill Name and Level Options ----------------
    enum SkillNameOption
    {
        DEFAULT("Default"),               // Default color (ORANGE for name, WHITE for level)
        MATCH_NAME_COLOR("Skill Color"), // Use the skill's color
        CUSTOM_COLOR("Custom Color");     // Use custom alpha color

        private final String displayName;

        SkillNameOption(String displayName)
        {
            this.displayName = displayName;
        }

        @Override
        public String toString()
        {
            return displayName;
        }
    }

    @ConfigItem(
            keyName = "tooltipSkillNameOption",
            name = "Tooltip Skill Name Option",
            description = "Choose how the skill name color is determined in the tooltip",
            position = 51,
            section = orbTooltips
    )
    default SkillNameOption tooltipSkillNameOption()
    {
        return SkillNameOption.DEFAULT;
    }

    @Alpha
    @ConfigItem(
            keyName = "tooltipSkillNameColor",
            name = "Tooltip Skill Name Color",
            description = "Custom color for skill name (used if 'Custom Color' is selected above)",
            position = 52,
            section = orbTooltips
    )
    default Color tooltipSkillNameColor()
    {
        return Color.decode("#FFFC800");
    }

    @ConfigItem(
            keyName = "tooltipSkillLevelOption",
            name = "Tooltip Skill Level Option",
            description = "Choose how the skill level color is determined in the tooltip",
            position = 53,
            section = orbTooltips
    )
    default SkillNameOption tooltipSkillLevelOption()
    {
        return SkillNameOption.DEFAULT;
    }

    @Alpha
    @ConfigItem(
            keyName = "tooltipSkillLevelColor",
            name = "Tooltip Skill Level Color",
            description = "Custom color for skill level (used if 'Custom Color' is selected above)",
            position = 54,
            section = orbTooltips
    )
    default Color tooltipSkillLevelColor()
    {
        return Color.WHITE;
    }

    /* ---------------- Config Sections ---------------- */
    @ConfigSection(
            name = "Per Orb Loading",
            description = "Set Each Orb To Normal / Forced / Blacklist",
            position = 60,
            closedByDefault = true
    )
    String orbMode = "orbMode";

    @ConfigSection(
            name = "Per Orb Priority",
            description = "Set Priority Level For Each Orb",
            position = 90,
            closedByDefault = true
    )
    String orbPriority = "orbPriority";

    enum SkillDisplayMode
    {
        NORMAL,   // Display XP globe normally (default behavior)
        FORCE,    // Always display XP globe regardless of XP gains
        BLACKLIST // Never display XP globe
    }

        /* ---------------- 1. Agility ---------------- */
    @ConfigItem(keyName = "agilityDisplay", name = "Agility", description = "Agility Orb Display Settings", position = 61, section = orbMode)
    default SkillDisplayMode agilityDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "agilityPriority", name = "Agility Priority", description = "Priority for Agility orb (1-24)", position = 62, section = orbPriority)
    @Range(min = 1, max = 24)
    default int agilityPriority() { return 10; }

    /* ---------------- 2. Attack Skill Settings ---------------- */
    @ConfigItem(keyName = "attackDisplay", name = "Attack", description = "Attack Orb Display Settings", position = 63, section = orbMode)
    default SkillDisplayMode attackDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "attackPriority", name = "Attack Priority", description = "Priority for Attack orb (1-24)", position = 64, section = orbPriority)
    @Range(min = 1, max = 24)
    default int attackPriority() { return 1; }

    /* ---------------- 3. Construction Skill Settings ---------------- */
    @ConfigItem(keyName = "constructionDisplay", name = "Construction", description = "Construction Orb Display Settings", position = 65, section = orbMode)
    default SkillDisplayMode constructionDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "constructionPriority", name = "Construction Priority", description = "Priority for Construction orb (1-24)", position = 66, section = orbPriority)
    @Range(min = 1, max = 24)
    default int constructionPriority() { return 8; }

    /* ---------------- 4. Cooking Skill Settings ---------------- */
    @ConfigItem(keyName = "cookingDisplay", name = "Cooking", description = "Cooking Orb Display Settings", position = 67, section = orbMode)
    default SkillDisplayMode cookingDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "cookingPriority", name = "Cooking Priority", description = "Priority for Cooking orb (1-24)", position = 68, section = orbPriority)
    @Range(min = 1, max = 24)
    default int cookingPriority() { return 20; }

    /* ---------------- 5. Crafting Skill Settings ---------------- */
    @ConfigItem(keyName = "craftingDisplay", name = "Crafting", description = "Crafting Orb Display Settings", position = 69, section = orbMode)
    default SkillDisplayMode craftingDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "craftingPriority", name = "Crafting Priority", description = "Priority for Crafting orb (1-24)", position = 70, section = orbPriority)
    @Range(min = 1, max = 24)
    default int craftingPriority() { return 13; }

    /* ---------------- 6. Defence Skill Settings ---------------- */
    @ConfigItem(keyName = "defenceDisplay", name = "Defence", description = "Defence Orb Display Settings", position = 71, section = orbMode)
    default SkillDisplayMode defenceDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "defencePriority", name = "Defence Priority", description = "Priority for Defence orb (1-24)", position = 72, section = orbPriority)
    @Range(min = 1, max = 24)
    default int defencePriority() { return 3; }

    /* ---------------- 7. Farming Skill Settings ---------------- */
    @ConfigItem(keyName = "farmingDisplay", name = "Farming", description = "Farming Orb Display Settings", position = 73, section = orbMode)
    default SkillDisplayMode farmingDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "farmingPriority", name = "Farming Priority", description = "Priority for Farming orb (1-24)", position = 74, section = orbPriority)
    @Range(min = 1, max = 24)
    default int farmingPriority() { return 23; }

    /* ---------------- 8. Firemaking Skill Settings ---------------- */
    @ConfigItem(keyName = "firemakingDisplay", name = "Firemaking", description = "Firemaking Orb Display Settings", position = 75, section = orbMode)
    default SkillDisplayMode firemakingDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "firemakingPriority", name = "Firemaking Priority", description = "Priority for Firemaking orb (1-24)", position = 76, section = orbPriority)
    @Range(min = 1, max = 24)
    default int firemakingPriority() { return 21; }

    /* ---------------- 9. Fletching Skill Settings ---------------- */
    @ConfigItem(keyName = "fletchingDisplay", name = "Fletching", description = "Fletching Orb Display Settings", position = 77, section = orbMode)
    default SkillDisplayMode fletchingDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "fletchingPriority", name = "Fletching Priority", description = "Priority for Fletching orb (1-24)", position = 78, section = orbPriority)
    @Range(min = 1, max = 24)
    default int fletchingPriority() { return 14; }

    /* ---------------- 10. Fishing Skill Settings ---------------- */
    @ConfigItem(keyName = "fishingDisplay", name = "Fishing", description = "Fishing Orb Display Settings", position = 79, section = orbMode)
    default SkillDisplayMode fishingDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "fishingPriority", name = "Fishing Priority", description = "Priority for Fishing orb (1-24)", position = 80, section = orbPriority)
    @Range(min = 1, max = 24)
    default int fishingPriority() { return 19; }

    /* ---------------- 11. Herblore Skill Settings ---------------- */
    @ConfigItem(keyName = "herbloreDisplay", name = "Herblore", description = "Herblore Orb Display Settings", position = 81, section = orbMode)
    default SkillDisplayMode herbloreDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "herblorePriority", name = "Herblore Priority", description = "Priority for Herblore orb (1-24)", position = 82, section = orbPriority)
    @Range(min = 1, max = 24)
    default int herblorePriority() { return 11; }

    /* ---------------- 12. Hitpoints Skill Settings ---------------- */
    @ConfigItem(keyName = "hitpointsDisplay", name = "Hitpoints", description = "Hitpoints Orb Display Settings", position = 83, section = orbMode)
    default SkillDisplayMode hitpointsDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "hitpointsPriority", name = "Hitpoints Priority", description = "Priority for Hitpoints orb (1-24)", position = 84, section = orbPriority)
    @Range(min = 1, max = 24)
    default int hitpointsPriority() { return 9; }

    /* ---------------- 13. Hunter Skill Settings ---------------- */
    @ConfigItem(keyName = "hunterDisplay", name = "Hunter", description = "Hunter Orb Display Settings", position = 85, section = orbMode)
    default SkillDisplayMode hunterDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "hunterPriority", name = "Hunter Priority", description = "Priority for Hunter orb (1-24)", position = 86, section = orbPriority)
    @Range(min = 1, max = 24)
    default int hunterPriority() { return 16; }

    /* ---------------- 14. Magic Skill Settings ---------------- */
    @ConfigItem(keyName = "magicDisplay", name = "Magic", description = "Magic Orb Display Settings", position = 87, section = orbMode)
    default SkillDisplayMode magicDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "magicPriority", name = "Magic Priority", description = "Priority for Magic orb (1-24)", position = 88, section = orbPriority)
    @Range(min = 1, max = 24)
    default int magicPriority() { return 6; }

    /* ---------------- 15. Mining Skill Settings ---------------- */
    @ConfigItem(keyName = "miningDisplay", name = "Mining", description = "Mining Orb Display Settings", position = 89, section = orbMode)
    default SkillDisplayMode miningDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "miningPriority", name = "Mining Priority", description = "Priority for Mining orb (1-24)", position = 90, section = orbPriority)
    @Range(min = 1, max = 24)
    default int miningPriority() { return 17; }

    /* ---------------- 16. Prayer Skill Settings ---------------- */
    @ConfigItem(keyName = "prayerDisplay", name = "Prayer", description = "Prayer Orb Display Settings", position = 91, section = orbMode)
    default SkillDisplayMode prayerDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "prayerPriority", name = "Prayer Priority", description = "Priority for Prayer orb (1-24)", position = 92, section = orbPriority)
    @Range(min = 1, max = 24)
    default int prayerPriority() { return 5; }

    /* ---------------- 17. Ranged Skill Settings ---------------- */
    @ConfigItem(keyName = "rangedDisplay", name = "Ranged", description = "Ranged Orb Display Settings", position = 93, section = orbMode)
    default SkillDisplayMode rangedDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "rangedPriority", name = "Ranged Priority", description = "Priority for Ranged orb (1-24)", position = 94, section = orbPriority)
    @Range(min = 1, max = 24)
    default int rangedPriority() { return 4; }

    /* ---------------- 18. Runecraft Skill Settings ---------------- */
    @ConfigItem(keyName = "runecraftDisplay", name = "Runecraft", description = "Runecraft Orb Display Settings", position = 95, section = orbMode)
    default SkillDisplayMode runecraftDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "runecraftPriority", name = "Runecraft Priority", description = "Priority for Runecraft orb (1-24)", position = 96, section = orbPriority)
    @Range(min = 1, max = 24)
    default int runecraftPriority() { return 7; }

    /* ---------------- 19. Slayer Skill Settings ---------------- */
    @ConfigItem(keyName = "slayerDisplay", name = "Slayer", description = "Slayer Orb Display Settings", position = 97, section = orbMode)
    default SkillDisplayMode slayerDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "slayerPriority", name = "Slayer Priority", description = "Priority for Slayer orb (1-24)", position = 98, section = orbPriority)
    @Range(min = 1, max = 24)
    default int slayerPriority() { return 15; }

    /* ---------------- 20. Smithing Skill Settings ---------------- */
    @ConfigItem(keyName = "smithingDisplay", name = "Smithing", description = "Smithing Orb Display Settings", position = 99, section = orbMode)
    default SkillDisplayMode smithingDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "smithingPriority", name = "Smithing Priority", description = "Priority for Smithing orb (1-24)", position = 100, section = orbPriority)
    @Range(min = 1, max = 24)
    default int smithingPriority() { return 18; }

    /* ---------------- 21. Strength Skill Settings ---------------- */
    @ConfigItem(keyName = "strengthDisplay", name = "Strength", description = "Strength Orb Display Settings", position = 101, section = orbMode)
    default SkillDisplayMode strengthDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "strengthPriority", name = "Strength Priority", description = "Priority for Strength orb (1-24)", position = 102, section = orbPriority)
    @Range(min = 1, max = 24)
    default int strengthPriority() { return 2; }

    /* ---------------- 22. Thieving Skill Settings ---------------- */
    @ConfigItem(keyName = "thievingDisplay", name = "Thieving", description = "Thieving Orb Display Settings", position = 103, section = orbMode)
    default SkillDisplayMode thievingDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "thievingPriority", name = "Thieving Priority", description = "Priority for Thieving orb (1-24)", position = 104, section = orbPriority)
    @Range(min = 1, max = 24)
    default int thievingPriority() { return 12; }

    /* ---------------- 23. Woodcutting Skill Settings ---------------- */
    @ConfigItem(keyName = "woodcuttingDisplay", name = "Woodcutting", description = "Woodcutting Orb Display Settings", position = 105, section = orbMode)
    default SkillDisplayMode woodcuttingDisplay() { return SkillDisplayMode.NORMAL; }

    @ConfigItem(keyName = "woodcuttingPriority", name = "Woodcutting Priority", description = "Priority for Woodcutting orb (1-24)", position = 106, section = orbPriority)
    @Range(min = 1, max = 24)
    default int woodcuttingPriority() { return 22; }

    /* ---------------- 24. Sailing Skill Settings ---------------- */
	@ConfigItem(keyName = "sailingDisplay", name = "Sailing", description = "SAiling Orb Display Settings", position = 107, section = orbMode)
	default SkillDisplayMode sailingDisplay() { return SkillDisplayMode.NORMAL; }

	@ConfigItem(keyName = "sailingPriority", name = "Sailing Priority", description = "Priority for Sailing orb (1-24)", position = 108, section = orbPriority)
	@Range(min = 1, max = 24)
	default int sailingPriority() { return 24; }
}

/*
 * Copyright (c) 2017, Steve <steve.rs.dev@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimsieder.customxpglobes;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Stroke;
import java.awt.geom.Arc2D;
import java.awt.geom.Ellipse2D;
import java.awt.image.BufferedImage;
import java.text.DecimalFormat;
import java.time.Instant;
import java.util.List;
import java.util.stream.Collectors;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.plugins.xptracker.XpTrackerService;
import net.runelite.client.ui.SkillColor;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ImageUtil;
import com.gimsieder.customxpglobes.CustomXpGlobesConfig.TooltipLine;


public class CustomXpGlobesOverlay extends Overlay
{
    private static final int MINIMUM_STEP = 10;
    private static final int PROGRESS_RADIUS_START = 90;
    private static final int PROGRESS_RADIUS_REMAINDER = 0;
    private static final int PROGRESS_BACKGROUND_SIZE = 5;
    private static final int TOOLTIP_RECT_SIZE_X = 150;
    private static final Color DARK_OVERLAY_COLOR = new Color(0, 0, 0, 180);
    private static final double GLOBE_ICON_RATIO = 0.65;

    private final Client client;
    private final CustomXpGlobesPlugin plugin;
    private final CustomXpGlobesConfig config;
    private final XpTrackerService xpTrackerService;
    private final TooltipManager tooltipManager;
    private final SkillIconManager iconManager;
    private final Tooltip xpTooltip = new Tooltip(new PanelComponent());

    @Inject
    private CustomXpGlobesOverlay(
            Client client,
            CustomXpGlobesPlugin plugin,
            CustomXpGlobesConfig config,
            XpTrackerService xpTrackerService,
            SkillIconManager iconManager,
            TooltipManager tooltipManager)
    {
        super(plugin);
        this.iconManager = iconManager;
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.xpTrackerService = xpTrackerService;
        this.tooltipManager = tooltipManager;
        this.xpTooltip.getComponent().setPreferredSize(new Dimension(TOOLTIP_RECT_SIZE_X, 0));
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        final Instant now = Instant.now();

        // Filter active orbs
        List<CustomXpGlobe> xpGlobes = plugin.getXpGlobes().stream()
                .filter(globe -> {
                    CustomXpGlobesPlugin.SkillDisplayMode mode = plugin.getSkillMode(globe.getSkill());
                    return mode != CustomXpGlobesPlugin.SkillDisplayMode.BLACKLIST &&
                            (mode != CustomXpGlobesPlugin.SkillDisplayMode.NORMAL ||
                                    globe.getTime().plusSeconds(config.xpOrbDuration()).isAfter(now));
                })
                .collect(Collectors.toList());

        if (xpGlobes.isEmpty())
            return null;

        final int orbSize = config.xpOrbSize();
        final int strokeOffset = (int) Math.ceil(Math.max(PROGRESS_BACKGROUND_SIZE, config.progressArcStrokeWidth()) / 2.0);
        final int step = MINIMUM_STEP + orbSize;
        final int maxPerLine = config.orbsPerLine();

        int curX = strokeOffset;
        int curY = strokeOffset;
        int countInLine = 0;

        int maxX = 0;
        int maxY = 0;

        boolean vertical = config.alignOrbsVertically();

        int totalLines = (xpGlobes.size() + maxPerLine - 1) / maxPerLine; // ceil division
        int lastLineCount = xpGlobes.size() % maxPerLine;
        if (lastLineCount == 0) lastLineCount = maxPerLine;

        for (int i = 0; i < xpGlobes.size(); i++)
        {
            int lineIndex = i / maxPerLine;

            // Only align the last line if it's incomplete AND there is more than 1 line
            if (countInLine == 0 && lineIndex == totalLines - 1 && lastLineCount < maxPerLine && totalLines > 1)
            {
                int offset = (maxPerLine - lastLineCount) * step;

                switch (config.lastLineAlignment())
                {
                    case CENTER:
                        offset /= 2;
                        break;
                    case RIGHT:
                        // full offset
                        break;
                    case LEFT:
                    default:
                        offset = 0;
                        break;
                }

                if (vertical)
                    curY += offset;
                else
                    curX += offset;
            }

            CustomXpGlobe xpGlobe = xpGlobes.get(i);
            int startXp = xpTrackerService.getStartGoalXp(xpGlobe.getSkill());
            int goalXp = xpTrackerService.getEndGoalXp(xpGlobe.getSkill());

            renderProgressCircle(graphics, xpGlobe, startXp, goalXp, curX, curY, getBounds());

            // Track overlay size (include orb edge)
            maxX = Math.max(maxX, curX + orbSize);
            maxY = Math.max(maxY, curY + orbSize);

            // Step logic
            if (++countInLine >= maxPerLine)
            {
                countInLine = 0;
                if (vertical)
                {
                    curX += step;
                    curY = strokeOffset;
                }
                else
                {
                    curX = strokeOffset;
                    curY += step;
                }
            }
            else
            {
                if (vertical)
                    curY += step;
                else
                    curX += step;
            }
        }

        return new Dimension(maxX + strokeOffset, maxY + strokeOffset);
    }


    private double getSkillProgress(int startXp, int currentXp, int goalXp)
    {
        double xpGained = currentXp - startXp;
        double xpGoal = goalXp - startXp;

        return ((xpGained / xpGoal) * 100);
    }

    private double getSkillProgressRadius(int startXp, int currentXp, int goalXp)
    {
        return -(3.6 * getSkillProgress(startXp, currentXp, goalXp)); //arc goes backwards
    }

    private void renderProgressCircle(Graphics2D graphics, CustomXpGlobe skillToDraw, int startXp, int goalXp, int x, int y, Rectangle bounds)
    {
        double radiusCurrentXp = getSkillProgressRadius(startXp, skillToDraw.getCurrentXp(), goalXp);
        double radiusToGoalXp = 360; //draw a circle

        Ellipse2D backgroundCircle = drawEllipse(graphics, x, y);

        // draw orb icon
        drawSkillImage(graphics, skillToDraw, x, y);

        // draw skill level
        drawSkillLevel(graphics, skillToDraw, x, y);

        Point mouse = client.getMouseCanvasPosition();
        int mouseX = mouse.getX() - bounds.x;
        int mouseY = mouse.getY() - bounds.y;

        // If mouse is hovering the globe
        if (backgroundCircle.contains(mouseX, mouseY))
        {
            // Fill a darker overlay circle
            graphics.setColor(DARK_OVERLAY_COLOR);
            graphics.fill(backgroundCircle);

            drawProgressLabel(graphics, skillToDraw, startXp, goalXp, x, y);

            if (config.enableTooltips())
            {
                drawTooltip(skillToDraw, goalXp);
            }
        }

        graphics.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);

        drawProgressArc(
                graphics,
                x, y,
                config.xpOrbSize(), config.xpOrbSize(),
                PROGRESS_RADIUS_REMAINDER, radiusToGoalXp,
                PROGRESS_BACKGROUND_SIZE,
                config.progressOrbOutLineColor()
        );
        drawProgressArc(
                graphics,
                x, y,
                config.xpOrbSize(), config.xpOrbSize(),
                PROGRESS_RADIUS_START, radiusCurrentXp,
                config.progressArcStrokeWidth(),
                config.enableCustomArcColor() ? config.progressArcColor() : SkillColor.find(skillToDraw.getSkill()).getColor());
    }

    private void drawProgressLabel(Graphics2D graphics, CustomXpGlobe globe, int startXp, int goalXp, int x, int y)
    {
        if (goalXp <= globe.getCurrentXp())
        {
            return;
        }

        // Convert to int just to limit the decimal cases
        String progress = (int) (getSkillProgress(startXp, globe.getCurrentXp(), goalXp)) + "%";

        final FontMetrics metrics = graphics.getFontMetrics();
        int drawX = x + (config.xpOrbSize() / 2) - (metrics.stringWidth(progress) / 2);
        int drawY = y + (config.xpOrbSize() / 2) + (metrics.getHeight() / 2);

        OverlayUtil.renderTextLocation(graphics, new Point(drawX, drawY), progress, Color.WHITE);
    }

    private void drawProgressArc(Graphics2D graphics, int x, int y, int w, int h, double radiusStart, double radiusEnd, int strokeWidth, Color color)
    {
        Stroke stroke = graphics.getStroke();
        graphics.setStroke(new BasicStroke(strokeWidth, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL));
        graphics.setColor(color);
        graphics.draw(new Arc2D.Double(
                x, y,
                w, h,
                radiusStart, radiusEnd,
                Arc2D.OPEN));
        graphics.setStroke(stroke);
    }

    private Ellipse2D drawEllipse(Graphics2D graphics, int x, int y)
    {
        graphics.setColor(config.progressOrbBackgroundColor());
        Ellipse2D ellipse = new Ellipse2D.Double(x, y, config.xpOrbSize(), config.xpOrbSize());
        graphics.fill(ellipse);
        graphics.draw(ellipse);
        return ellipse;
    }

    private void drawSkillImage(Graphics2D graphics, CustomXpGlobe xpGlobe, int x, int y)
    {
        final int orbSize = config.xpOrbSize();
        final BufferedImage skillImage = getScaledSkillIcon(xpGlobe, orbSize);

        if (skillImage == null)
            return;

        int yOffset = -config.iconVerticalOffset(); // positive config moves icon up, negative moves down
        graphics.drawImage(
                skillImage,
                x + (orbSize / 2) - (skillImage.getWidth() / 2),
                y + (orbSize / 2) - (skillImage.getHeight() / 2) + yOffset,
                null
        );
    }

    private void drawSkillLevel(Graphics2D graphics, CustomXpGlobe xpGlobe, int x, int y)
    {
        // If the Level Display is NONE, skip drawing
        if (config.levelDisplayOption() == CustomXpGlobesConfig.LevelDisplayOption.NONE)
            return;

        final int orbSize = config.xpOrbSize();
        String skillLevel = String.valueOf(xpGlobe.getCurrentLevel());

        // Calculate font size based on orb size and config levelSize
        int baseFontSize = Math.max(12, orbSize / 3);
        int adjustedFontSize = baseFontSize + config.levelSize(); // levelSize allows user adjustment
        graphics.setFont(new Font("Tahoma", Font.PLAIN, adjustedFontSize));

        FontMetrics fm = graphics.getFontMetrics();
        int textWidth = fm.stringWidth(skillLevel);
        int textHeight = fm.getHeight();

        int textX = x + (orbSize / 2) - (textWidth / 2);
        int textY = y + (orbSize / 2) + (textHeight / 2) - 2 - config.levelVerticalOffset();

        // Choose text color
        Color fillColor = config.levelDisplayOption() == CustomXpGlobesConfig.LevelDisplayOption.CUSTOM_COLOR
                ? config.levelColor()
                : SkillColor.find(xpGlobe.getSkill()).getColor();

        // Draw black border by offsetting around the text
        graphics.setColor(Color.BLACK);
        for (int dx = -1; dx <= 1; dx++)
        {
            for (int dy = -1; dy <= 1; dy++)
            {
                if (dx == 0 && dy == 0) continue; // skip center
                graphics.drawString(skillLevel, textX + dx, textY + dy);
            }
        }

        // Draw the actual level text
        graphics.setColor(fillColor);
        graphics.drawString(skillLevel, textX, textY);
    }

    private BufferedImage getScaledSkillIcon(CustomXpGlobe xpGlobe, int orbSize)
    {
        // Cache the previous icon if the size hasn't changed
        if (xpGlobe.getSkillIcon() != null && xpGlobe.getSize() == orbSize)
        {
            return xpGlobe.getSkillIcon();
        }

        BufferedImage icon = iconManager.getSkillImage(xpGlobe.getSkill());
        if (icon == null)
        {
            return null;
        }

        final int size = orbSize - config.progressArcStrokeWidth();
        final int scaledIconSize = (int) (size * GLOBE_ICON_RATIO);
        if (scaledIconSize <= 0)
        {
            return null;
        }

        icon = ImageUtil.resizeImage(icon, scaledIconSize, scaledIconSize, true);

        xpGlobe.setSkillIcon(icon);
        xpGlobe.setSize(orbSize);
        return icon;
    }

    private void drawTooltip(CustomXpGlobe mouseOverSkill, int goalXp)
    {
        if (!config.enableTooltips())
            return;

        // Reset hover timer
        mouseOverSkill.setTime(Instant.now());

        DecimalFormat decimalFormat = new DecimalFormat("###,###,###");
        final PanelComponent xpTooltip = (PanelComponent) this.xpTooltip.getComponent();
        xpTooltip.getChildren().clear();

        // Skill Name at top
        Color skillNameColor;
        switch (config.tooltipSkillNameOption())
        {
            case MATCH_NAME_COLOR:
                skillNameColor = SkillColor.find(mouseOverSkill.getSkill()).getColor();
                break;
            case CUSTOM_COLOR:
                skillNameColor = config.tooltipSkillNameColor();
                break;
            default:
                skillNameColor = Color.ORANGE; // Default color
        }

        // Skill Level at top
        Color skillLevelColor;
        switch (config.tooltipSkillLevelOption())
        {
            case MATCH_NAME_COLOR:
                skillLevelColor = SkillColor.find(mouseOverSkill.getSkill()).getColor();
                break;
            case CUSTOM_COLOR:
                skillLevelColor = config.tooltipSkillLevelColor();
                break;
            default:
                skillLevelColor = Color.WHITE; // Default
        }

        xpTooltip.getChildren().add(LineComponent.builder()
                .left(mouseOverSkill.getSkill().getName())
                .leftColor(skillNameColor)
                .right(String.valueOf(mouseOverSkill.getCurrentLevel()))
                .rightColor(skillLevelColor)
                .build());

        // Collect configured lines
        TooltipLine[] linesConfig = new TooltipLine[]
                {
                        config.tooltipLine1(),
                        config.tooltipLine2(),
                        config.tooltipLine3(),
                        config.tooltipLine4(),
                        config.tooltipLine5()
                };

        // Render tooltip lines dynamically
        for (int i = 0; i < linesConfig.length; i++)
        {
            TooltipLine line = linesConfig[i];
            if (line == TooltipLine.NONE)
                continue;
            if (line == TooltipLine.BLANK)
            {
                xpTooltip.getChildren().add(LineComponent.builder().left(" ").build());
                continue;
            }

            Color lineColor = getTooltipLineColor(i + 1);
            Color valueColor = getTooltipLineValueColor(i + 1);

            switch (line)
            {
                case CURRENT_TOTAL_XP:
                    xpTooltip.getChildren().add(LineComponent.builder()
                            .left("Current Total XP:")
                            .leftColor(lineColor)
                            .right(decimalFormat.format(mouseOverSkill.getCurrentXp()))
                            .rightColor(valueColor)
                            .build());
                    break;

                case XP_LEFT_FOR_LEVEL:
                    if (goalXp > mouseOverSkill.getCurrentXp())
                    {
                        int xpLeft = goalXp - mouseOverSkill.getCurrentXp();
                        xpTooltip.getChildren().add(LineComponent.builder()
                                .left("XP Till Level:")
                                .leftColor(lineColor)
                                .right(decimalFormat.format(xpLeft))
                                .rightColor(valueColor)
                                .build());
                    }
                    break;

                case ACTIONS_LEFT_BEFORE_LEVEL:
                    if (goalXp > mouseOverSkill.getCurrentXp())
                    {
                        int actionsLeft = xpTrackerService.getActionsLeft(mouseOverSkill.getSkill());
                        if (actionsLeft != Integer.MAX_VALUE)
                        {
                            xpTooltip.getChildren().add(LineComponent.builder()
                                    .left("Actions Left:")
                                    .leftColor(lineColor)
                                    .right(decimalFormat.format(actionsLeft))
                                    .rightColor(valueColor)
                                    .build());
                        }
                    }
                    break;

                case XP_PER_HOUR:
                    if (goalXp > mouseOverSkill.getCurrentXp())
                    {
                        int xpHr = xpTrackerService.getXpHr(mouseOverSkill.getSkill());
                        if (xpHr != 0)
                        {
                            xpTooltip.getChildren().add(LineComponent.builder()
                                    .left("XP Per Hour:")
                                    .leftColor(lineColor)
                                    .right(decimalFormat.format(xpHr))
                                    .rightColor(valueColor)
                                    .build());
                        }
                    }
                    break;

                case TIME_TILL_LEVEL:
                    if (goalXp > mouseOverSkill.getCurrentXp())
                    {
                        String timeLeft = xpTrackerService.getTimeTilGoal(mouseOverSkill.getSkill());
                        xpTooltip.getChildren().add(LineComponent.builder()
                                .left("Time Till Level:")
                                .leftColor(lineColor)
                                .right(timeLeft)
                                .rightColor(valueColor)
                                .build());
                    }
                    break;
            }
        }

        tooltipManager.add(this.xpTooltip);
    }

    private Color getTooltipLineColor(int lineIndex)
    {
        if (!config.enableTooltipColors())
        {
            return Color.ORANGE; // default fallback when colors are disabled
        }

        switch (lineIndex)
        {
            case 1: return config.tooltipLine1Color();
            case 2: return config.tooltipLine2Color();
            case 3: return config.tooltipLine3Color();
            case 4: return config.tooltipLine4Color();
            case 5: return config.tooltipLine5Color();
            default: return Color.ORANGE;
        }
    }

    private Color getTooltipLineValueColor(int lineIndex)
    {
        if (!config.enableTooltipValueColors())
        {
            return Color.WHITE; // default fallback when value colors are disabled
        }

        switch (lineIndex)
        {
            case 1: return config.tooltipLine1ValueColor();
            case 2: return config.tooltipLine2ValueColor();
            case 3: return config.tooltipLine3ValueColor();
            case 4: return config.tooltipLine4ValueColor();
            case 5: return config.tooltipLine5ValueColor();
            default: return Color.WHITE;
        }
    }


}



/*
 * Copyright (c) 2017, Steve <steve.rs.dev@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimsieder.customxpglobes;

import java.awt.image.BufferedImage;
import java.time.Instant;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Skill;

@Getter
@Setter
class CustomXpGlobe
{
	private Skill skill;
	private int currentXp;
	private int currentLevel;
	private Instant time;
	private int size;
    private transient BufferedImage skillIcon;
    private int cachedPriority;

    CustomXpGlobe(Skill skill, int currentXp, int currentLevel, Instant time)
	{
		this.skill = skill;
		this.currentXp = currentXp;
		this.currentLevel = currentLevel;
		this.time = time;
	}

}


