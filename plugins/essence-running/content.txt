package com.essencerunning;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class EssenceRunningPluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(EssenceRunningPlugin.class);
        RuneLite.main(args);
    }
}

package com.essencerunning;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

public class EssenceRunningItemDropdown {

    @Getter
    @RequiredArgsConstructor
    public enum BindingNecklace {
        WEAR("Wear"),
        CHECK("Check"),
        USE("Use"),
        DESTROY("Destroy");

        private final String option;
    }

    @Getter
    @RequiredArgsConstructor
    public enum CraftingCape {
        WEAR("Wear"),
        TELEPORT("Teleport"),
        USE("Use"),
        DROP("Drop");

        private final String option;
    }

    @Getter
    @RequiredArgsConstructor
    public enum EssencePouch {
        FILL("Fill"),
        EMPTY("Empty"),
        CHECK("Check"),
        USE("Use"),
        DROP("Drop");

        private final String option;
    }

    @Getter
    @RequiredArgsConstructor
    public enum HighlightEquipBindingNecklace {
        OFF("Off"),
        EQUIP("Equip");

        private final String option;

        @Override
        public String toString() {
            return this.option;
        }
    }

    @Getter
    @RequiredArgsConstructor
    public enum HighlightTradeBindingNecklace {
        OFF("Off"),
        TWENTY_FIVE("25"),
        TWENTY_SIX("26 (Pure)");

        private final String option;

        @Override
        public String toString() {
            return this.option;
        }
    }

    @Getter
    @RequiredArgsConstructor
    public enum ClanChatOverlayHeight {
        ZERO(0),
        ONE(1),
        TWO(2),
        THREE(3),
        FOUR(4),
        FIVE(5),
        SIX(6),
        SEVEN(7),
        EIGHT(8);

        private final int option;

        @Override
        public String toString() {
            return Integer.toString(this.option);
        }
    }
}

package com.essencerunning;

import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

import javax.inject.Inject;
import java.awt.Dimension;
import java.awt.Graphics2D;

public class EssenceRunningStatisticsOverlay extends Overlay {

    private final EssenceRunningPlugin plugin;
    private final EssenceRunningConfig config;

    private final PanelComponent panelComponent = new PanelComponent();

    @Inject
    private EssenceRunningStatisticsOverlay(final EssenceRunningPlugin plugin, final EssenceRunningConfig config) {
        super(plugin);
        this.plugin = plugin;
        this.config = config;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        panelComponent.getChildren().clear();

        if (config.enableRunecrafterMode() && config.sessionStatistics()) {
            final EssenceRunningSession session = plugin.getSession();

            panelComponent.getChildren().add(LineComponent.builder().left("Runner").right("Ess/Neck").build());

            session.getRunners().forEach(runner -> panelComponent.getChildren().add(
                LineComponent.builder()
                    .left(runner.getRsn())
                    .right(runner.getPureEssenceTraded() + "/" + runner.getBindingNecklaceTraded())
                    .build()));

            if (session.getTotalFireRunesCrafted() > 0) {
                panelComponent.getChildren().add(LineComponent.builder().left("Fire Runes Crafted").right(
                    Integer.toString(session.getTotalFireRunesCrafted())).build());
            }
        }

        return panelComponent.render(graphics);
    }
}

package com.essencerunning;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("essencerunning")
public interface EssenceRunningConfig extends Config {

    @ConfigItem(
        position = 0,
        keyName = "clanChatOverlayHeight",
        name = "Clan Chat Overlay Height",
        description = "Displays messages in the clan chat as an overlay on top of the chat box"
    )
    default EssenceRunningItemDropdown.ClanChatOverlayHeight clanChatOverlayHeight() {
        return EssenceRunningItemDropdown.ClanChatOverlayHeight.ZERO;
    }

    @ConfigItem(
        position = 1,
        keyName = "filterTradeMessages",
        name = "Filter Trade Messages",
        description = "Filters out all messages in trade chat except for 'wishes to trade with you'"
    )
    default boolean filterTradeMessages() {
        return false;
    }

    @ConfigSection(
        name = "Runecrafter Settings",
        description = "Section that houses all the relevant settings for Runecrafters",
        position = 100
    )
    String runecrafterSettings = "runecrafterSettings";

    @ConfigItem(
        position = 0,
        keyName = "enableRunecraftingMode",
        name = "Enable Runecrafting Mode",
        description = "Must be enabled for any features in this section to work",
        section = runecrafterSettings
    )
    default boolean enableRunecrafterMode() {
        return false;
    }

    @ConfigItem(
        position = 1,
        keyName = "sessionStatistics",
        name = "Session Statistics",
        description = "Displays statistics such as Pure essence/Binding necklace traded per runner and Fire runes crafted",
        section = runecrafterSettings
    )
    default boolean sessionStatistics() {
        return true;
    }

    @ConfigItem(
        position = 2,
        keyName = "preventFireRunes",
        name = "Prevent Fire runes",
        description = "Forces menu to open when you click the Fire Altar if you would accidentally craft Fire runes",
        section = runecrafterSettings
    )
    default boolean preventFireRunes() {
        return true;
    }

    @ConfigItem(
        position = 3,
        keyName = "highlightEquipBindingNecklace",
        name = "Highlight Equip Binding necklace",
        description = "Highlights Binding necklace if you have no amulet equipped",
        section = runecrafterSettings
    )
    default EssenceRunningItemDropdown.HighlightEquipBindingNecklace highlightEquipBindingNecklace() {
        return EssenceRunningItemDropdown.HighlightEquipBindingNecklace.EQUIP;
    }

    @ConfigItem(
            position = 4,
            keyName = "showAccurateMagicImbue",
            name = "Accurate Magic imbue timer in ticks",
            description = "Configures whether magic imbue timer is displayed in ticks",
            section = runecrafterSettings
    )
    default boolean showAccurateMagicImbue()
    {
        return true;
    }

    @ConfigSection(
        name = "Runner Settings",
        description = "Section that houses all the relevant settings for Runners",
        position = 200
    )
    String runnerSettings = "runnerSettings";

    @ConfigItem(
        position = 0,
        keyName = "enableRunnerMode",
        name = "Enable Runner Mode",
        description = "Must be enabled for any features in this section to work",
        section = runnerSettings
    )
    default boolean enableRunnerMode() {
        return false;
    }

    @ConfigItem(
        position = 1,
        keyName = "highlightTradeBindingNecklace",
        name = "Highlight Trade Binding necklace",
        description = "Highlights Binding necklace if the Runecrafter has 25/26 slots available in trade",
        section = runnerSettings
    )
    default EssenceRunningItemDropdown.HighlightTradeBindingNecklace highlightTradeBindingNecklace() {
        return EssenceRunningItemDropdown.HighlightTradeBindingNecklace.TWENTY_FIVE;
    }

    @ConfigItem(
        position = 2,
        keyName = "highlightRingOfDueling",
        name = "Highlight Ring of dueling",
        description = "Highlights Ring of dueling(8) if you have no ring equipped",
        section = runnerSettings
    )
    default boolean highlightRingOfDueling() {
        return true;
    }

    @ConfigItem(
        position = 3,
        keyName = "highlightTradeSent",
        name = "Highlight Trade Sent",
        description = "Highlights chat box to green if trade offer has been successfully sent",
        section = runnerSettings
    )
    default boolean highlightTradeSent() {
        return true;
    }

    @ConfigItem(
            position = 4,
            keyName = "preventTradeCancel",
            name = "Prevent Trade Cancel",
            description = "Prevents you from accidentally Teleporting/Emptying when awaiting Trader to Accept on Second Trade Screen",
            section = runnerSettings
    )
    default boolean preventTradeCancel() {
        return true;
    }

    @ConfigSection(
        name = "Runner Left-Click Settings",
        description = "Section that houses all the relevant settings for modifying left-click behavior",
        position = 300
    )
    String leftClickSection = "leftClickSection";

    @ConfigItem(
        position = 0,
        keyName = "leftClickCustomization",
        name = "Enable Customizable Left-Click",
        description = "Allows customization of left-clicks on items below that persist",
        section = leftClickSection
    )
    default boolean leftClickCustomization() {
        return false;
    }

    @ConfigItem(
        position = 1,
        keyName = "swapOfferAll",
        name = "Swap Offer-All",
        description = "Swaps the 'Offer' option to 'Offer-All'",
        section = leftClickSection
    )
    default boolean swapOfferAll() {
        return true;
    }

    @ConfigItem(
        position = 2,
        keyName = "swapBankOp",
        name = "Swap Bank Op",
        description = "Swaps the extra menu option in banks (Wield, Eat, etc.)",
        section = leftClickSection
    )
    default boolean swapBankOp() {
        return true;
    }

    @ConfigItem(
        position = 3,
        keyName = "excludeBindingNecklaceOp",
        name = "Exclude Binding necklace Op",
        description = "Exclude swapping Binding necklace to 'Wear', should Disable this while soloing",
        section = leftClickSection
    )
    default boolean excludeBindingNecklaceOp() {
        return true;
    }

    @ConfigItem(
        position = 4,
        keyName = "swapBankWithdrawOp",
        name = "Swap Bank Withdraw Op",
        description = "Swaps the Withdraw quantity of certain items (Ring of dueling, Binding necklace, etc.)",
        section = leftClickSection
    )
    default boolean swapBankWithdrawOp() {
        return true;
    }

    @ConfigItem(
        position = 6,
        keyName = "essencePouch",
        name = "Essence pouch",
        description = "Customize left-click of 'Essence pouch' in inventory",
        section = leftClickSection
    )
    default EssenceRunningItemDropdown.EssencePouch essencePouch() {
        return EssenceRunningItemDropdown.EssencePouch.EMPTY;
    }

    @ConfigItem(
        position = 7,
        keyName = "bindingNecklace",
        name = "Binding necklace",
        description = "Customize left-click of 'Binding necklace' in inventory",
        section = leftClickSection
    )
    default EssenceRunningItemDropdown.BindingNecklace bindingNecklace() {
        return EssenceRunningItemDropdown.BindingNecklace.USE;
    }

    @ConfigItem(
        position = 11,
        keyName = "craftingCape",
        name = "Crafting cape",
        description = "Customize left-click of 'Crafting cape' in inventory",
        section = leftClickSection
    )
    default EssenceRunningItemDropdown.CraftingCape craftingCape() {
        return EssenceRunningItemDropdown.CraftingCape.TELEPORT;
    }
}

package com.essencerunning;

import com.google.common.collect.ArrayListMultimap;
import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuShouldLeftClick;
import net.runelite.api.widgets.Widget;
import net.runelite.client.util.Text;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class EssenceRunningUtils {

    private static final String TRADING_WITH = "Trading with:<br>";

    public static void swap(final Client client,
                            final ArrayListMultimap<String, Integer> optionIndexes,
                            final String optionA,
                            final String optionB,
                            final String target,
                            final int index,
                            final boolean strict) {

        final MenuEntry[] menuEntries = client.getMenuEntries();
        final int thisIndex = findIndex(optionIndexes, menuEntries, index, optionB, target, strict);
        final int optionIdx = findIndex(optionIndexes, menuEntries, thisIndex, optionA, target, strict);

        if (thisIndex >= 0 && optionIdx >= 0) {
            swap(client, optionIndexes, menuEntries, optionIdx, thisIndex);
        }
    }

    private static int findIndex(final ArrayListMultimap<String, Integer> optionIndexes,
                                 final MenuEntry[] entries,
                                 final int limit,
                                 final String option,
                                 final String target,
                                 final boolean strict) {

        if (strict) {
            List<Integer> indexes = optionIndexes.get(option);

            // We want the last index which matches the target, as that is what is top-most on the menu
            for (int i = indexes.size() - 1; i >= 0; --i) {
                final int idx = indexes.get(i);
                MenuEntry entry = entries[idx];
                String entryTarget = Text.removeTags(entry.getTarget()).toLowerCase();

                // Limit to the last index which is prior to the current entry
                if (idx <= limit && entryTarget.equals(target)) {
                    return idx;
                }
            }
        } else {
            // Without strict matching we have to iterate all entries up to the current limit...
            for (int i = limit; i >= 0; i--) {
                final MenuEntry entry = entries[i];
                final String entryOption = Text.removeTags(entry.getOption()).toLowerCase();
                final String entryTarget = Text.removeTags(entry.getTarget()).toLowerCase();

                if (entryOption.contains(option.toLowerCase()) && entryTarget.equals(target)) {
                    return i;
                }
            }

        }

        return -1;
    }

    private static void swap(final Client client,
                             final ArrayListMultimap<String, Integer> optionIndexes,
                             final MenuEntry[] entries,
                             final int index1,
                             final int index2) {

        final MenuEntry entry = entries[index1];
        entry.setType((entries[index2].getType()));
        entries[index1] = entries[index2];
        entries[index2] = entry;

        client.setMenuEntries(entries);

        // Rebuild option indexes
        optionIndexes.clear();
        int idx = 0;
        for (MenuEntry menuEntry : entries) {
            final String option = Text.removeTags(menuEntry.getOption()).toLowerCase();
            optionIndexes.put(option, idx++);
        }
    }

    public static void swapBankOp(final Client client, final MenuEntryAdded menuEntryAdded) {

        // Deposit- op 2 is the current deposit amount 1/5/10/x
        if (menuEntryAdded.getType() == MenuAction.CC_OP.getId() && menuEntryAdded.getIdentifier() == 2
            && menuEntryAdded.getOption().startsWith("Deposit-")) {

            final MenuEntry[] menuEntries = client.getMenuEntries();

            // Find the extra menu option; they don't have fixed names, so check based on the menu identifier
            for (int i = menuEntries.length - 1; i >= 0; --i) {
                final MenuEntry entry = menuEntries[i];

                // The extra options are always option 9
                if (entry.getType() == MenuAction.CC_OP_LOW_PRIORITY && entry.getIdentifier() == 9
                    && !entry.getOption().equals("Empty")) { // exclude Runecraft pouch's "Empty" option

                    // we must also raise the priority of the op so it doesn't get sorted later
                    entry.setType(MenuAction.CC_OP);

                    menuEntries[i] = menuEntries[menuEntries.length - 1];
                    menuEntries[menuEntries.length - 1] = entry;

                    client.setMenuEntries(menuEntries);
                    break;
                }
            }
        }
    }

    public static boolean itemEquipped(final Client client, final EquipmentInventorySlot slot) {
        final ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);
        if (equipment != null) {
            final Item[] item = equipment.getItems();
            return item.length > slot.getSlotIdx()
                && item[slot.getSlotIdx()] != null
                && item[slot.getSlotIdx()].getId() > -1;
        }
        return false;
    }

    public static void computeItemsTraded(final Client client, final EssenceRunningSession session) {
        final Widget tradingWith = client.getWidget(334, 30);
        final String tradingPartnerRsn = tradingWith.getText().replace(TRADING_WITH, "");
        final Widget partnerTrades = client.getWidget(334, 29);

        int pureEssenceTraded = 0;
        int bindingNecklaceTraded = 0;
        for (Widget widget : partnerTrades.getChildren()) {
            if (widget.getText().equals("Pure essence")) {
                pureEssenceTraded++;
            } else if (widget.getText().equals("Binding necklace")) {
                bindingNecklaceTraded++;
            }
        }
        session.updateRunnerStatistic(tradingPartnerRsn, pureEssenceTraded, bindingNecklaceTraded);
    }

    public static Map<Integer, String> getClanMessagesMap(final int size) {
        return new LinkedHashMap<Integer, String>(size) {
            @Override
            public boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
                return this.size() > size;
            }
        };
    }
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.essencerunning;

import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.Counter;

import java.awt.Color;
import java.awt.image.BufferedImage;

class EssenceRunningTickCounter extends Counter
{
    EssenceRunningTickCounter(BufferedImage img, Plugin plugin, int amount)
    {
        super(img, plugin, amount);
    }

    private Color textColor;

    @Override
    public Color getTextColor() {
        return this.textColor;
    }

    public void setTextColor(Color color) {
        this.textColor = color;
    }
}




package com.essencerunning;

import com.google.common.collect.ArrayListMultimap;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.awt.Color;
import java.util.Map;

@Slf4j
@PluginDescriptor(
    name = "Essence Running"
)
public class EssenceRunningPlugin extends Plugin {

    private static final String SENDING_TRADE_OFFER = "Sending trade offer...";
    private static final String ACCEPTED_TRADE = "Accepted trade.";
    private static final String CRAFTED_FIRE_RUNES = "You bind the temple's power into fire runes.";
    private static final String WAITING_OTHER_PLAYER = "Waiting for other player...";
    private static final int FIRE_RUNE_EXPERIENCE = 7;
    private static final String MAGIC_IMBUE_EXPIRED_MESSAGE = "Your Magic Imbue charge has ended.";
    private static final String MAGIC_IMBUE_MESSAGE = "You are charged to combine runes!";
    private static final String MAGIC_IMBUE_WARNING = "Your Magic Imbue spell charge is running out...";
    private static final int MAGIC_IMBUE_DURATION = 20;
    private static final int MAGIC_IMBUE_WARNING_DURATION = 10;
    private final ArrayListMultimap<String, Integer> optionIndexes = ArrayListMultimap.create();
    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private EssenceRunningConfig config;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private EssenceRunningOverlay overlay;
    @Inject
    private EssenceRunningStatisticsOverlay statisticsOverlay;
    @Inject
    private EssenceRunningClanChatOverlay clanChatOverlay;
    @Inject
    private SpriteManager spriteManager;
    @Inject
    private InfoBoxManager infoBoxManager;
    @Setter
    private boolean shiftModifier = false;
    @Getter
    private EssenceRunningSession session;

    @Getter
    private boolean ringEquipped = false;

    @Getter
    private boolean amuletEquipped = false;

    @Getter
    private boolean tradeSent = false;

    @Getter
    private Map<Integer, String> clanMessages;
    private int MAX_ENTRIES = 0;

    private int runecraftXp = 0;
    private boolean craftedFireRunes = false;

    private EssenceRunningTickCounter counter;
    private boolean isFirstMessage = false;
    private boolean isCounting = false;

    @Override
    protected void startUp() {
        overlayManager.add(overlay);
        overlayManager.add(statisticsOverlay);
        overlayManager.add(clanChatOverlay);
        session = new EssenceRunningSession();
        MAX_ENTRIES = config.clanChatOverlayHeight().getOption();
        clanMessages = EssenceRunningUtils.getClanMessagesMap(MAX_ENTRIES);
    }

    @Override
    protected void shutDown() {
        infoBoxManager.removeIf(t -> t instanceof EssenceRunningTickCounter);
        overlayManager.remove(overlay);
        overlayManager.remove(statisticsOverlay);
        overlayManager.remove(clanChatOverlay);
        session = null;
    }

    @Provides
    EssenceRunningConfig provideConfig(final ConfigManager configManager) {
        return configManager.getConfig(EssenceRunningConfig.class);
    }

    @Subscribe
    public void onClientTick(final ClientTick clientTick) {

        // The menu is not rebuilt when it is open, so don't swap or else it will repeatedly swap entries
        if (client.getGameState() != GameState.LOGGED_IN || client.isMenuOpen()) {
            return;
        }

        final MenuEntry[] menuEntries = client.getMenuEntries();

        // Build option map for quick lookup in findIndex
        int idx = 0;
        optionIndexes.clear();
        for (MenuEntry entry : menuEntries) {
            final String option = Text.removeTags(entry.getOption()).toLowerCase();
            optionIndexes.put(option, idx++);
        }

        swapMenuEntry(menuEntries.length - 1, menuEntries[menuEntries.length - 1]);
    }

    private void swapMenuEntry(final int index, final MenuEntry menuEntry) {

        if (config.leftClickCustomization()) {
            final String option = Text.removeTags(menuEntry.getOption()).toLowerCase();
            final String target = Text.removeTags(menuEntry.getTarget()).toLowerCase();

            if (config.swapOfferAll() && option.equals("offer")) {
                EssenceRunningUtils.swap(client, optionIndexes, "offer-all", option, target, index, true);
            }

            leftClickCustomization(target, option, index);
        }
    }

    private void leftClickCustomization(final String target, final String option, final int index) {

        String optionA = null;

        if (client.getWidget(WidgetInfo.BANK_CONTAINER) != null) {
            final EssenceRunningItem item = EssenceRunningItem.of(target);
            if (config.swapBankWithdrawOp() && item != null) {
                optionA = "Withdraw-" + item.getWithdrawQuantity();
            }
        } else {
            if (target.equals("small pouch") || target.equals("medium pouch") || target.equals("large pouch") || target.equals("giant pouch") || target.equals("colossal pouch")) {
                optionA = config.essencePouch().getOption();
            } else if (target.equals("binding necklace")) {
                optionA = config.bindingNecklace().getOption();
            } else if (target.startsWith("ring of the elements")) {
                optionA = "Fire Altar";
            } else if (target.startsWith("ring of dueling")) {
                optionA = "PvP Arena";
            } else if (target.startsWith("crafting cape")) {
                optionA = config.craftingCape().getOption();
            } else if (target.equals("amulet of eternal glory")) {
                optionA = "Edgeville";
            }
        }

        if (optionA != null) {
            EssenceRunningUtils.swap(client, optionIndexes, optionA.toLowerCase(), option, target, index, true);
        }
    }

    @Subscribe
    public void onMenuEntryAdded(final MenuEntryAdded menuEntryAdded) {
        if (config.leftClickCustomization()) {
            // The client sorts the MenuEntries for priority after the ClientTick event so have to swap bank in MenuEntryAdded event
            if (config.swapBankOp()) {
                final String target = Text.removeTags(menuEntryAdded.getTarget()).toLowerCase();
                if (!target.startsWith("binding necklace") || !config.excludeBindingNecklaceOp()) {
                    EssenceRunningUtils.swapBankOp(client, menuEntryAdded);
                }
            }
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked) {
        if (config.enableRunecrafterMode() && config.preventFireRunes()) {
            if (menuOptionClicked.getId() == ObjectID.ALTAR_34764 // Fire Altar
                    && menuOptionClicked.getMenuAction() == MenuAction.GAME_OBJECT_FIRST_OPTION) { // Craft-rune
                menuOptionClicked.consume();
                client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Essence Running has prevented you from accidentally creating Fire Runes!", "");
            }
        }
        if (config.enableRunnerMode() && config.preventTradeCancel()) {
            final String option = Text.removeTags(menuOptionClicked.getMenuOption()).toLowerCase();
            final String target = Text.removeTags(menuOptionClicked.getMenuTarget()).toLowerCase();
            final Widget textField = client.getWidget(334, 4);
            if (textField != null && textField.getText().equals(WAITING_OTHER_PLAYER) &&
                    ((target.startsWith("crafting cape") && option.equals("teleport"))
                            || (target.startsWith("ring of dueling") && option.equals("pvp arena"))
                            || (target.equals("ring of the elements") && (option.equals("last destination") || option.equals("fire altar")))
                            || (target.equals("amulet of eternal glory") && option.equals("edgeville"))
                            || (target.equals("small pouch") && option.equals("empty"))
                            || (target.equals("medium pouch") && option.equals("empty"))
                            || (target.equals("large pouch") && option.equals("empty"))
                            || (target.equals("giant pouch") && option.equals("empty"))
                            || (target.equals("colossal pouch") && option.equals("empty")))) {
                client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Essence Running has prevented you from accidentally cancelling the Trade!", "");
                menuOptionClicked.consume();
            }
        }
    }

    @Subscribe
    public void onGameStateChanged(final GameStateChanged event) {
        if (event.getGameState() == GameState.LOGIN_SCREEN) {
            tradeSent = false;
            session.reset();
            runecraftXp = 0;
            craftedFireRunes = false;
            clanMessages.clear();
        } else if (event.getGameState() == GameState.LOGGED_IN) {
            amuletEquipped = EssenceRunningUtils.itemEquipped(client, EquipmentInventorySlot.AMULET);
            ringEquipped = EssenceRunningUtils.itemEquipped(client, EquipmentInventorySlot.RING);
        }
    }

    @Subscribe
    public void onItemContainerChanged(final ItemContainerChanged event) {
        if (event.getItemContainer() == client.getItemContainer(InventoryID.EQUIPMENT)) {
            amuletEquipped = EssenceRunningUtils.itemEquipped(client, EquipmentInventorySlot.AMULET);
            ringEquipped = EssenceRunningUtils.itemEquipped(client, EquipmentInventorySlot.RING);
        }
    }

    @Subscribe
    public void onChatMessage(final ChatMessage event) {
        if (event.getMessage().equals(SENDING_TRADE_OFFER)) {
            tradeSent = true;
        } else if (event.getMessage().equals(ACCEPTED_TRADE)) {
            if (config.enableRunecrafterMode() && config.sessionStatistics()) {
                // Trade widgets are still available at this point
                EssenceRunningUtils.computeItemsTraded(client, session);
            }
        } else if (event.getMessage().equals(CRAFTED_FIRE_RUNES)) {
            craftedFireRunes = true;
        } else if (event.getSender() != null) {
            final String message = event.getName() + ": " + event.getMessage();
            clanMessages.put(message.hashCode(), message);
        }

        if (config.filterTradeMessages() && event.getType() == ChatMessageType.TRADE) {
            ChatLineBuffer buffer = client.getChatLineMap().get(ChatMessageType.TRADE.getType());
            buffer.removeMessageNode(event.getMessageNode());
            clientThread.invoke(() -> client.runScript(ScriptID.BUILD_CHATBOX));
        }

        if (config.enableRunecrafterMode() && config.showAccurateMagicImbue() && event.getMessage().equals(MAGIC_IMBUE_MESSAGE))
        {
            createTickCounter(MAGIC_IMBUE_DURATION);
            isFirstMessage = true;
        }

        if (config.enableRunecrafterMode() && config.showAccurateMagicImbue() && event.getMessage().equals(MAGIC_IMBUE_WARNING))
        {
            if (isFirstMessage)
            {
                if (counter == null)
                    createTickCounter(MAGIC_IMBUE_WARNING_DURATION);
                else
                    isCounting = true;
                isFirstMessage = false;
            }
        }

        if (event.getMessage().equals(MAGIC_IMBUE_EXPIRED_MESSAGE))
        {
            removeTickCounter();
        }
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        if (counter == null)
        {
            return;
        }

        if (counter.getCount() > -1) {
            if (counter.getCount() == 0)
            {
                counter.setTextColor(Color.RED);
            }
            if (isCounting) {
                if (counter.getCount() == MAGIC_IMBUE_WARNING_DURATION + 1)
                {
                    isCounting = false;
                }
                counter.setCount(counter.getCount() - 1);
            }
        }
        else
        {
            removeTickCounter();
        }
    }

    @Subscribe
    public void onWidgetLoaded(final WidgetLoaded event) {
        if (event.getGroupId() == WidgetID.PLAYER_TRADE_SCREEN_GROUP_ID) {
            tradeSent = false;
        }
    }

    @Subscribe
    public void onConfigChanged(final ConfigChanged event) {
        if (event.getGroup().equals("essencerunning")) {
            if (!config.sessionStatistics() && (!session.getRunners().isEmpty() || session.getTotalFireRunesCrafted() != 0)) {
                session.reset();
            }
            if (MAX_ENTRIES != config.clanChatOverlayHeight().getOption()) {
                MAX_ENTRIES = config.clanChatOverlayHeight().getOption();
                Map<Integer, String> temp = EssenceRunningUtils.getClanMessagesMap(MAX_ENTRIES);
                temp.putAll(clanMessages);
                clanMessages = temp;
            }
            if (!config.showAccurateMagicImbue() || !config.enableRunecrafterMode())
            {
                removeTickCounter();
            }
        }
    }

    @Subscribe
    public void onStatChanged(final StatChanged statChanged) {
        if (statChanged.getSkill() == Skill.RUNECRAFT) {
            if (config.enableRunecrafterMode() && config.sessionStatistics()) {
                if (craftedFireRunes) {
                    session.updateCrafterStatistic((statChanged.getXp() - runecraftXp) / FIRE_RUNE_EXPERIENCE);
                    craftedFireRunes = false;
                }
                runecraftXp = statChanged.getXp();
            }
        }
    }

    private void createTickCounter(int duration)
    {
        if (counter == null)
        {
            counter = new EssenceRunningTickCounter(null, this, duration);
            spriteManager.getSpriteAsync(SpriteID.SPELL_MAGIC_IMBUE, 0, counter);
            counter.setTooltip("Magic imbue");
            infoBoxManager.addInfoBox(counter);
            isCounting = true;
        }
        else
        {
            counter.setCount(duration);
            counter.setTextColor(Color.WHITE);
        }
    }

    private void removeTickCounter()
    {
        if (counter == null)
        {
            return;
        }

        infoBoxManager.removeInfoBox(counter);
        counter = null;
        isCounting = false;
    }
}

package com.essencerunning;

import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Shape;

public class EssenceRunningOverlay extends Overlay {

    private static final String FREE_INVENTORY_SLOTS = " free inventory slots.";
    private final EssenceRunningPlugin plugin;
    private final Client client;
    private final EssenceRunningConfig config;

    @Inject
    private EssenceRunningOverlay(final EssenceRunningPlugin plugin, final Client client, final EssenceRunningConfig config) {

        super(plugin);
        this.plugin = plugin;
        this.client = client;
        this.config = config;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(final Graphics2D graphics) {

        renderBindingNecklace(graphics);

        if (config.enableRunnerMode()) {
            final Widget chatbox = client.getWidget(WidgetInfo.CHATBOX);
            if (config.highlightTradeSent() && chatbox != null && !chatbox.isHidden()) {
                drawShape(graphics, chatbox.getBounds(), plugin.isTradeSent() ? Color.GREEN : Color.RED);
            }

            if (config.highlightRingOfDueling() && !plugin.isRingEquipped()) {
                drawWidgetChildren(graphics, client.getWidget(WidgetInfo.BANK_ITEM_CONTAINER), ItemID.RING_OF_DUELING8);
                drawWidgetChildren(graphics, client.getWidget(WidgetInfo.BANK_INVENTORY_ITEMS_CONTAINER), ItemID.RING_OF_DUELING8);
            }
        }

        return null;
    }

    private void renderBindingNecklace(final Graphics2D graphics) {
        if (config.enableRunecrafterMode()) {
            if (config.highlightEquipBindingNecklace() == EssenceRunningItemDropdown.HighlightEquipBindingNecklace.EQUIP) {
                if (!plugin.isAmuletEquipped()) {
                    drawWidgetChildren(graphics, client.getWidget(WidgetInfo.INVENTORY), ItemID.BINDING_NECKLACE);
                    drawWidgetChildren(graphics, client.getWidget(WidgetInfo.BANK_ITEM_CONTAINER), ItemID.BINDING_NECKLACE);
                    drawWidgetChildren(graphics, client.getWidget(WidgetInfo.BANK_INVENTORY_ITEMS_CONTAINER), ItemID.BINDING_NECKLACE);
                }
            }
        }
        if (config.enableRunnerMode()) {
            switch (config.highlightTradeBindingNecklace()) {
                case TWENTY_FIVE:
                case TWENTY_SIX:
                    if (matchFreeInventorySlots()) {
                        // Widget that contains the inventory while inside a trade transaction
                        drawWidgetChildren(graphics, client.getWidget(WidgetID.PLAYER_TRADE_INVENTORY_GROUP_ID, 0), ItemID.BINDING_NECKLACE);
                    }
                    break;
                default:
                    break;
            }
        }
    }

    private void drawWidgetChildren(final Graphics2D graphics, final Widget widget, final int itemId) {
        if (widget != null && widget.getChildren() != null) {
            for (final Widget item : widget.getChildren()) {
                if (!item.isHidden() && item.getItemId() == itemId) {
                    drawShape(graphics, item.getBounds(), Color.RED);
                }
            }
        }
    }

    private void drawShape(final Graphics2D graphics, final Shape shape, final Color color) {
        final Color previousColor = graphics.getColor();
        graphics.setColor(color);
        graphics.draw(shape);
        graphics.setColor(previousColor);
    }

    private boolean matchFreeInventorySlots() {
        // Widget that contains the trading partner's number of free inventory slots
        final Widget freeSlots = client.getWidget(WidgetID.PLAYER_TRADE_SCREEN_GROUP_ID, 9);
        return freeSlots != null && freeSlots.getText().endsWith(config.highlightTradeBindingNecklace().getOption().split(" ")[0] + FREE_INVENTORY_SLOTS);
    }
}

package com.essencerunning;

import lombok.Getter;

import java.util.Optional;
import java.util.Set;
import java.util.TreeSet;

@Getter
public class EssenceRunningSession {

    private final Set<EssenceRunner> runners;
    private int totalFireRunesCrafted;

    public EssenceRunningSession() {
        this.runners = new TreeSet<>();
    }

    public void updateRunnerStatistic(final String rsn, final int pureEssenceTraded, final int bindingNecklaceTraded) {
        final Optional<EssenceRunner> optional = runners.stream().filter(i -> i.getRsn().equals(rsn)).findFirst();
        final EssenceRunner runner = optional.isPresent() ? optional.get() : new EssenceRunner(rsn);

        this.runners.remove(runner);
        runner.increasePureEssenceTraded(pureEssenceTraded);
        runner.increaseBindingNecklaceTraded(bindingNecklaceTraded);

        this.runners.add(runner);
    }

    public void updateCrafterStatistic(final int fireRunesCrafted) {
        this.totalFireRunesCrafted += fireRunesCrafted;
    }

    public void reset() {
        this.runners.clear();
        this.totalFireRunesCrafted = 0;
    }
}

package com.essencerunning;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

import javax.inject.Inject;
import java.awt.Dimension;
import java.awt.Graphics2D;

public class EssenceRunningClanChatOverlay extends Overlay {

    private final EssenceRunningPlugin plugin;
    private final Client client;
    private final EssenceRunningConfig config;

    private final PanelComponent panelComponent = new PanelComponent();

    @Inject
    public EssenceRunningClanChatOverlay(final EssenceRunningPlugin plugin, final Client client, final EssenceRunningConfig config) {
        super(plugin);
        this.plugin = plugin;
        this.client = client;
        this.config = config;

        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(final Graphics2D graphics) {
        panelComponent.getChildren().clear();

        final Widget chatbox = client.getWidget(WidgetInfo.CHATBOX_TRANSPARENT_LINES);
        if (config.clanChatOverlayHeight().getOption() > 0 && chatbox != null && !chatbox.isHidden()) {
            panelComponent.setPreferredSize(new Dimension(chatbox.getWidth(), 0));
            plugin.getClanMessages().values().forEach(message -> panelComponent.getChildren().add(LineComponent.builder().left(message).build()));
        }

        return panelComponent.render(graphics);
    }
}

package com.essencerunning;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

import java.util.HashMap;
import java.util.Map;

@Getter
@RequiredArgsConstructor
public enum EssenceRunningItem {

    BINDING_NECKLACE("binding necklace"),

    EARTH_TALISMAN("earth talisman", 2),

    ENERGY_POTION_1("energy potion(1)"),
    ENERGY_POTION_2("energy potion(2)"),
    ENERGY_POTION_3("energy potion(3)"),
    ENERGY_POTION_4("energy potion(4)"),

    SUPER_ENERGY_1("super energy(1)"),
    SUPER_ENERGY_2("super energy(2)"),
    SUPER_ENERGY_3("super energy(3)"),
    SUPER_ENERGY_4("super energy(4)"),

    RING_OF_DUELING_1("ring of dueling(1)"),
    RING_OF_DUELING_2("ring of dueling(2)"),
    RING_OF_DUELING_3("ring of dueling(3)"),
    RING_OF_DUELING_4("ring of dueling(4)"),
    RING_OF_DUELING_5("ring of dueling(5)"),
    RING_OF_DUELING_6("ring of dueling(6)"),
    RING_OF_DUELING_7("ring of dueling(7)"),
    RING_OF_DUELING_8("ring of dueling(8)"),

    STAMINA_POTION_1("stamina potion(1)"),
    STAMINA_POTION_2("stamina potion(2)"),
    STAMINA_POTION_3("stamina potion(3)"),
    STAMINA_POTION_4("stamina potion(4)"),
    ;

    private static final Map<String, EssenceRunningItem> map = new HashMap<>(values().length);

    static {
        for (EssenceRunningItem item : values()) {
            map.put(item.getName(), item);
        }
    }

    private final String name;
    private final int withdrawQuantity;

    EssenceRunningItem(final String name) {
        this(name, 1);
    }

    public static EssenceRunningItem of(final String name) {
        return map.get(name);
    }
}

package com.essencerunning;

import lombok.Getter;

import java.util.Objects;

@Getter
public class EssenceRunner implements Comparable<EssenceRunner> {

    private final String rsn;
    private int pureEssenceTraded;
    private int bindingNecklaceTraded;

    public EssenceRunner(final String rsn) {
        this.rsn = rsn;
        this.pureEssenceTraded = 0;
        this.bindingNecklaceTraded = 0;
    }

    public void increasePureEssenceTraded(final int amount) {
        this.pureEssenceTraded += amount;
    }

    public void increaseBindingNecklaceTraded(final int amount) {
        this.bindingNecklaceTraded += amount;
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        final EssenceRunner that = (EssenceRunner) o;

        return this.rsn.equals(that.rsn);
    }

    @Override
    public int hashCode() {
        return Objects.hash(this.rsn);
    }

    @Override
    public int compareTo(final EssenceRunner that) {
        final int compareEssence = Integer.compare(that.pureEssenceTraded, this.pureEssenceTraded);
        final int compareBinding = Integer.compare(that.bindingNecklaceTraded, this.bindingNecklaceTraded);

        return compareEssence != 0 ? compareEssence : compareBinding != 0 ? compareBinding : this.rsn.compareTo(that.rsn);
    }
}

