package com.autocasting;

import lombok.AllArgsConstructor;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.gameval.ItemID;

import java.awt.*;

public final class AutocastingConstants
{
	// Config defaults
	public static final int DEFAULT_COUNTER_FLASH_PERIOD = 60;
	public static final int MINIMUM_COUNTER_FLASH_PERIOD = 1;
	public static final int DEFAULT_CAST_RUNES_THRESHOLD = 1000;
	public static final int MINIMUM_CAST_RUNES_THRESHOLD = 1;
	public static final int MAXIMUM_CAST_RUNES_THRESHOLD = 999999;
	public static final int DEFAULT_LOW_RUNES_NOTIFICATION_THRESHOLD = 100;
	public static final Color RED_FLASH_COLOR = new Color(255, 0, 0, 186);

	// Varbits
	public static final int[] VARBIT_RUNE_POUCH_RUNES = {
		VarbitID.RUNE_POUCH_TYPE_1,
		VarbitID.RUNE_POUCH_TYPE_2,
		VarbitID.RUNE_POUCH_TYPE_3,
		VarbitID.RUNE_POUCH_TYPE_4,
	};
	public static final int[] VARBIT_RUNE_POUCH_AMOUNTS = {
		VarbitID.RUNE_POUCH_QUANTITY_1,
		VarbitID.RUNE_POUCH_QUANTITY_2,
		VarbitID.RUNE_POUCH_QUANTITY_3,
		VarbitID.RUNE_POUCH_QUANTITY_4,
	};

	public static final int[] BLACKLISTED_WEAPONS = {
		ItemID.BLISTERWOOD_FLAIL,
		ItemID.SOS_SKULL_SCEPTRE,
		ItemID.SOS_SKULL_SCEPTRE_IMBUED,
		ItemID.SARADOMIN_STAFF,
		ItemID.GUTHIX_STAFF,
		ItemID.ZAMORAK_STAFF
	};

	// Message constants
	public static final String STAT_DRAIN_FORMAT = "Your Magic level has dropped too low to autocast %s!";
	public static final String NO_CASTS_FORMAT = "Out of runes to autocast %s!";
	public static final String LOW_CASTS_FORMAT = "%s casts of %s remaining.";
	public static final String AUOTCAST_NOT_SELECTED_MESSAGE = "Autocast spell not selected!";

	// Other constants
	public static final int OUT_OF_COMBAT_TICK_DELAY = 2;

	@AllArgsConstructor
	public enum OverlayNotificationType
	{
		FLASH("Flash"),
		SOLID("Solid"),
		NONE("None");

		private final String value;

		@Override
		public String toString()
		{
			return value;
		}
	}

	@AllArgsConstructor
	public enum ChatNotificationType
	{
		GAME("Game"),
		BOTH("All"),
		NONE("None");

		private final String value;

		@Override
		public String toString()
		{
			return value;
		}
	}
}

package com.autocasting;

import net.runelite.api.ChatMessageType;
import net.runelite.client.Notifier;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class AutocastingNotifications
{
	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private Notifier notifier;

	@Inject
	private AutocastingConfig config;

	@Inject
	private AutocastingState state;

	public void notifyStatDrain()
	{
		String autocastName = state.getCurrentAutocastSpell().getName();
		String message = String.format(AutocastingConstants.STAT_DRAIN_FORMAT, autocastName);
		sendNotification(message, config.notifyOnStatDrain());
	}

	public void handleCastsUpdated(int previous, int current)
	{
		if (current == 0)
		{
			if (previous != 0)
			{
				notifyNoCasts();
			}
		}
		else
		{
			int threshold = config.lowCastNotificationThreshold();
			if (previous > threshold && current <= threshold)
			{
				notifyLowCasts(current);
			}
		}
	}

	private void notifyNoCasts()
	{
		String autocastName = state.getCurrentAutocastSpell().getName();
		String message = String.format(AutocastingConstants.NO_CASTS_FORMAT, autocastName);
		sendNotification(message, config.notifyOnNoCasts());
	}

	private void notifyLowCasts(int amount)
	{
		String autocastName = state.getCurrentAutocastSpell().getName();
		String message = String.format(AutocastingConstants.LOW_CASTS_FORMAT, amount, autocastName);
		sendNotification(message, config.notifyOnLowCasts());
	}

	public void notifyNoSpellSelected()
	{
		sendNotification(AutocastingConstants.AUOTCAST_NOT_SELECTED_MESSAGE, config.notifyOnNoAutocastSelected());
	}

	private void sendNotification(String message, AutocastingConstants.ChatNotificationType notificationSetting)
	{
		boolean shouldSendMessage = (state.isConsideredInCombat() || config.notifyOutOfCombat())
			&& !state.isBanking();

		if (!shouldSendMessage)
		{
			return;
		}

		switch (notificationSetting)
		{
			case GAME:
				final String chatMessage = new ChatMessageBuilder()
					.append(ChatColorType.HIGHLIGHT)
					.append(message)
					.build();
				chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage(chatMessage)
					.build()
				);
				break;
			case BOTH:
				notifier.notify(message);
				break;
		}
	}
}

package com.autocasting;

import com.autocasting.datatypes.Spell;
import com.google.inject.Inject;
import javax.inject.Singleton;

import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.*;
import net.runelite.client.ui.overlay.components.ComponentOrientation;

import java.awt.*;
import java.awt.image.BufferedImage;

@Singleton
class AutocastingOverlay extends OverlayPanel
{
	private float timeIntoFlash = 0f;
	private boolean isFlashing = true;

	private final int GAP_SIZE = 4;

	private final AutocastingState state;
	private final AutocastingConfig config;
	private final AutocastingClientData clientData;

	@Inject
	private SpriteManager spriteManager;

	@Inject
	AutocastingOverlay(AutocastingPlugin plugin, AutocastingConfig config, AutocastingState state, AutocastingClientData clientData)
	{
		super(plugin);
		this.config = config;
		this.state = state;
		this.clientData = clientData;
		super.setDynamicFont(true);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		boolean shouldRender = config.showOverlay()
			&& state.isEquippedWeaponMagic()
			&& (config.showOverlayOutsideCombat() || state.isConsideredInCombat());
		if (!shouldRender)
		{
			return null;
		}

		if (config.hideUnlikelyItems() && state.isEquippedWeaponBlacklisted())
		{
			return null;
		}

		int casts = state.getCastsRemaining();
		boolean displayCasts = config.showCastsRemaining()
			&& casts <= config.displayCastLimit()
			&& state.hasActiveAutocast();

		String overrideText = getOverrideText(casts);

		TitleComponent textComponent = null;
		String textPart = "";
		if (config.showSpellName() || displayCasts || overrideText != null)
		{
			if (config.showSpellName() && displayCasts)
			{
				textPart = String.format("%s (%s)", getCurrentSpellName(), casts);
			}
			else
			{  // Exactly 1 of the fields needs to be shown
				textPart = displayCasts ? Integer.toString(casts) : getCurrentSpellName();
			}

			if (overrideText != null)
			{
				textPart = overrideText;
			}

			textComponent = TitleComponent.builder()
				.text(textPart)
				.build();
		}

		ImageComponent imageComponent = null;
		if (config.showSpellIcon())
		{
			imageComponent = new ImageComponent(getCurrentSpellImage());
		}

		if (textComponent == null && imageComponent == null)
		{
			return null;
		}

		LayoutableRenderableEntity component;
		if (textComponent != null && imageComponent != null)
		{
			component = SplitComponent.builder()
				.first(textComponent)
				.second(imageComponent)
				.orientation(ComponentOrientation.HORIZONTAL)
				.gap(new Point(GAP_SIZE, 0))
				.build();
		}
		else
		{ // Exactly 1 is nonnull
			component = (textComponent != null) ? textComponent : imageComponent;
		}
		panelComponent.getChildren().clear();
		panelComponent.getChildren().add(component);
		panelComponent.setPreferredSize(new Dimension(
			graphics.getFontMetrics().stringWidth(textPart) + 10,
			0
		));

		configureBackground(casts);
		return panelComponent.render(graphics);
	}

	private String getOverrideText(int casts)
	{
		if (!config.enableOverrideText())
		{
			return null;
		}

		if (state.isMagicLevelTooLowForSpell())
		{
			String override = config.lowMagicLevelText().strip();
			if (!override.equals(""))
			{
				return override;
			}
		}

		if (casts == 0 && state.hasActiveAutocast())
		{
			String override = config.noRunesText().strip();
			if (!override.equals(""))
			{
				return override;
			}
		}
		return null;
	}

	private void configureBackground(int casts)
	{
		boolean shouldAlert = (
			state.isMagicLevelTooLowForSpell()
				|| (casts == 0 && state.hasActiveAutocast())
				|| state.getCurrentAutocastSpell() == Spell.NO_SPELL
		);

		if (config.overlayAlertStyle() == AutocastingConstants.OverlayNotificationType.FLASH)
		{
			flashBackground(shouldAlert);
		}
		else
		{
			solidBackground(shouldAlert);
		}
	}

	private void flashBackground(boolean alert)
	{
		if (alert)
		{
			panelComponent.setBackgroundColor(
				isFlashing ? config.overlayAlertColor() : ComponentConstants.STANDARD_BACKGROUND_COLOR
			);
			// Increment time based on frame duration
			timeIntoFlash += (float) 100 / clientData.fps();
			if (timeIntoFlash >= config.getFlashPeriod())
			{
				isFlashing = !isFlashing;
				timeIntoFlash = 0;
			}
		}
		else
		{
			panelComponent.setBackgroundColor(ComponentConstants.STANDARD_BACKGROUND_COLOR);
			// If not alerting, we reset to defaults such that next alert always starts with a full flash
			isFlashing = true;
			timeIntoFlash = 0;
		}
	}

	private void solidBackground(boolean alert)
	{
		if (alert && config.overlayAlertStyle() == AutocastingConstants.OverlayNotificationType.SOLID)
		{
			panelComponent.setBackgroundColor(config.overlayAlertColor());
		}
		else
		{
			panelComponent.setBackgroundColor(ComponentConstants.STANDARD_BACKGROUND_COLOR);
		}
	}

	private BufferedImage getCurrentSpellImage()
	{
		int spriteId = state.getCurrentAutocastSpell().getSpriteID();
		return spriteManager.getSprite(spriteId, 0);
	}

	private String getCurrentSpellName()
	{
		return state.getCurrentAutocastSpell().getName();
	}

}
package com.autocasting;

import net.runelite.api.Skill;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.events.*;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class AutocastingSubscriptions
{
	@Inject
	private AutocastingState state;

	private boolean updateRunesPostClientTick = false;

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		switch (event.getVarbitId())
		{
			case VarbitID.AUTOCAST_SPELL:
				state.setRecentlySentNoSpellSelectedNotification(false);
			case VarbitID.COMBAT_WEAPON_CATEGORY:
				state.updateIsEquippedWeaponMagic();
				state.updateAutocastSpell();
				break;
			case VarbitID.RUNE_POUCH_TYPE_1:
			case VarbitID.RUNE_POUCH_TYPE_2:
			case VarbitID.RUNE_POUCH_TYPE_3:
			case VarbitID.RUNE_POUCH_TYPE_4:
			case VarbitID.RUNE_POUCH_TYPE_5:
			case VarbitID.RUNE_POUCH_TYPE_6:
			case VarbitID.RUNE_POUCH_QUANTITY_1:
			case VarbitID.RUNE_POUCH_QUANTITY_2:
			case VarbitID.RUNE_POUCH_QUANTITY_3:
			case VarbitID.RUNE_POUCH_QUANTITY_4:
			case VarbitID.RUNE_POUCH_QUANTITY_5:
			case VarbitID.RUNE_POUCH_QUANTITY_6:
				updateRunesPostClientTick = true;
				break;
			case VarbitID.FOUNTAIN_OF_RUNE_ACTIVE:
				state.updateCastsRemaining(false);
				break;
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		switch (event.getGroupId())
		{
			case InterfaceID.BANKMAIN:
			case InterfaceID.BANKSIDE:
			case InterfaceID.BANK_DEPOSITBOX:
			case InterfaceID.SHARED_BANK:
			case InterfaceID.SHARED_BANK_SIDE:
				state.setBanking(true);
				state.setRecentlySentNoSpellSelectedNotification(false);
		}
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event)
	{
		switch (event.getGroupId())
		{
			case InterfaceID.BANKMAIN:
			case InterfaceID.BANKSIDE:
			case InterfaceID.BANK_DEPOSITBOX:
			case InterfaceID.SHARED_BANK:
			case InterfaceID.SHARED_BANK_SIDE:
				state.setBanking(false);
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged event)
	{
		if (event.getSkill() == Skill.MAGIC)
		{
			// Now need to check if new boostedLevel is still high enough for the autocast spell
			int boostedLevel = event.getBoostedLevel();
			state.updateMagicLevel(boostedLevel);
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		if (event.getContainerId() == InventoryID.WORN)
		{
			// Equipped items changed; should check to see if an infinite rune item is equipped
			state.updateInfiniteRuneSources();
			state.updateIsBlacklisted();
		}
		if (event.getContainerId() == InventoryID.INV)
		{
			// Inventory changed; should re-count runes
			state.updateRunes();
		}
	}

	@Subscribe
	public void onPostClientTick(PostClientTick event)
	{
		// After everything settles, final rune counts should definitely be accurate so let's count
		if (updateRunesPostClientTick)
		{
			state.updateRunes();
			updateRunesPostClientTick = false;
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		// This only updates every tick, so we shouldn't be re-computing while rendering each frame
		state.updateCombatStatus();
	}
}

package com.autocasting;

import com.autocasting.datatypes.PlayerInventory;
import com.autocasting.datatypes.RuneType;
import com.autocasting.datatypes.Spell;
import com.autocasting.dependencies.attackstyles.WeaponType;

import lombok.Getter;
import lombok.Setter;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Map;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;

@Singleton
public class AutocastingState
{
	@Inject
	private AutocastingClientData clientData;

	@Inject
	private AutocastingRuneUtil runeUtil;

	@Inject
	private AutocastingNotifications notifications;

	@Getter
	@Setter
	private boolean magicLevelTooLowForSpell;

	@Getter
	@Setter
	private boolean isEquippedWeaponMagic;

	@Getter
	@Setter
	private boolean isEquippedWeaponBlacklisted;

	@Getter
	@Setter
	private WeaponType currentWeaponType;

	@Getter
	@Setter
	private Spell currentAutocastSpell;

	@Getter
	@Setter
	private PlayerInventory playerInventory;

	@Getter
	@Setter
	private boolean consideredInCombat;

	@Getter
	@Setter
	private int lastCombatTick;

	@Getter
	@Setter
	private Map<RuneType, Integer> availableRunes;

	@Getter
	@Setter
	private int castsRemaining;

	@Getter
	@Setter
	private boolean banking;

	@Getter
	@Setter
	private boolean recentlySentNoSpellSelectedNotification;

	public void updateAutocastSpell()
	{
		// Get new autocast spell.
		Spell newAutocastSpell = clientData.getAutocastSpell();
		if (newAutocastSpell == null)
		{
			return;
		}
		if (newAutocastSpell.getVarbitValue() == Spell.NO_SPELL.getVarbitValue())
		{
			if (isEquippedWeaponMagic && !recentlySentNoSpellSelectedNotification) {
				notifications.notifyNoSpellSelected();
				recentlySentNoSpellSelectedNotification = true;
			}
		}

		// If the new spell is not null, and there is currently no autocast spell selected, update it
		if (currentAutocastSpell == null || newAutocastSpell.getVarbitValue() != currentAutocastSpell.getVarbitValue())
		{
			currentAutocastSpell = newAutocastSpell;
		}
		updateCastsRemaining(true);
	}

	public boolean hasActiveAutocast()
	{
		return currentAutocastSpell != null && currentAutocastSpell != Spell.NO_SPELL;
	}

    /*
    Calculating casts remaining is a 3 stage process, first we check inventory, equipment, and rune pouch for relevant items
    These get set on PlayerInventory. Subscription hooks will call stage 1 methods - updateRunes, updateInfiniteRuneSources
    At the end of both functions the second stage is called which computes total runes based on all factors.
    Finally based on current autocast spell and stage 2 results we can math out the number of casts available
    */

	public void updateRunes()
	{
		setPlayerInventory(runeUtil.updateInventory(playerInventory));
		calculateNetRuneTypes();
	}

	public void updateInfiniteRuneSources()
	{
		setPlayerInventory(runeUtil.updateEquipment(playerInventory));
		calculateNetRuneTypes();
	}

	private void calculateNetRuneTypes()
	{
		setAvailableRunes(runeUtil.availableRunes(playerInventory));
		updateCastsRemaining(false);
	}

	public void updateCastsRemaining(boolean autocastSpellUpdate)
	{
		if (currentAutocastSpell == null || currentAutocastSpell == Spell.NO_SPELL)
		{
			castsRemaining = 0;
			return;
		}
		if (availableRunes == null) {
			// Race condition upon startup, autocast varbit may be set before inventory is loaded.
			// availableRunes will not be set, but will get set soon after; update casts remaining then
			castsRemaining = 0;
			return;
		}

		int newCastsRemaining = runeUtil.calculateCastsRemaining(currentAutocastSpell, availableRunes);
		if (!autocastSpellUpdate && castsRemaining != newCastsRemaining)
		{
			// The number updated, so let's go through the configs and see if we need to send notifications
			notifications.handleCastsUpdated(castsRemaining, newCastsRemaining);
		}
		castsRemaining = newCastsRemaining;
	}

	public void updateIsEquippedWeaponMagic()
	{
		int weaponTypeID = clientData.getWeaponTypeId();
		WeaponType newWeaponType = WeaponType.getWeaponType(weaponTypeID);
		if (newWeaponType == currentWeaponType)
		{
			return;
		}
		currentWeaponType = newWeaponType;

		isEquippedWeaponMagic = newWeaponType == WeaponType.TYPE_18 ||
								newWeaponType == WeaponType.TYPE_21 ||
								newWeaponType == WeaponType.TYPE_22;

		// The below types do have a casting option, but do not autocast spells, so leave them out.
		// TYPE_6: These are salamanders. They do not autocast, but give magic xp, so technically have a "casting" option.
		// TYPE_23: Trident, Sanguinesti, etc. Do not have autocast options, so do not show overlay when these are equipped.
	}

	public void updateIsBlacklisted()
	{
		ItemContainer equipment = clientData.getEquipment();
		Item weaponSlot = equipment.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
		if (weaponSlot == null) {
			isEquippedWeaponBlacklisted = false;
			return;
		}

		int weaponId = weaponSlot.getId();
		for (int blacklistedId : AutocastingConstants.BLACKLISTED_WEAPONS) {
			if (weaponId == blacklistedId) {
				isEquippedWeaponBlacklisted = true;
				return;
			}
		}
		isEquippedWeaponBlacklisted = false;
	}

	public void updateMagicLevel(int boostedLevel)
	{
		Spell autocastSpell = Spell.getSpell(clientData.getAutocastVarbit());

		if (boostedLevel < autocastSpell.getLevelRequirement())
		{
			// We don't need to send new messages or update state if it didn't actually change
			if (!magicLevelTooLowForSpell)
			{
				magicLevelTooLowForSpell = true;
				notifications.notifyStatDrain();
			}
		}
		else
		{
			magicLevelTooLowForSpell = false;
		}
	}

	public void updateCombatStatus()
	{
		boolean inCombat = clientData.isInCombat();
		int currentTick = clientData.getGameTick();
		if (inCombat)
		{
			lastCombatTick = currentTick;
			consideredInCombat = true;
		}
		else
		{
			consideredInCombat = currentTick - lastCombatTick <= AutocastingConstants.OUT_OF_COMBAT_TICK_DELAY;
		}
	}
}

package com.autocasting;

import com.autocasting.datatypes.*;

import net.runelite.api.EnumComposition;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.VarbitID;

import javax.inject.Inject;
import java.util.EnumMap;
import java.util.Map;

public class AutocastingRuneUtil
{
	@Inject
	private AutocastingClientData clientData;

	public PlayerInventory updateInventory(PlayerInventory current)
	{
		PlayerInventory updated = new PlayerInventory();
		if (current != null)
		{
			updated.setMainHand(current.getMainHand());
			updated.setOffHand(current.getOffHand());
		}

		ItemContainer inventory = clientData.getInventory();
		if (inventory == null)
		{
			return updated;
		}

		for (Item item : inventory.getItems())
		{
			int itemId = item.getId();
			int quantity = item.getQuantity();

			Pouch pouch = Pouch.getPouch(itemId);
			if (pouch != null)
			{
				updated.setPouch(pouch);
			}

			RuneItem rune = RuneItem.getRuneItem(itemId);
			if (rune != null)
			{
				updated.addRuneStack(new RuneItemQuantity(rune, quantity));
			}
		}
		return updated;
	}

	public PlayerInventory updateEquipment(PlayerInventory current)
	{
		PlayerInventory updated = new PlayerInventory();
		if (current != null)
		{
			updated.setRunes(current.getRunes());
			updated.setPouch(current.getPouch());
		}

		ItemContainer equipment = clientData.getEquipment();
		Item weaponSlot = equipment.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
		Item shieldSlot = equipment.getItem(EquipmentInventorySlot.SHIELD.getSlotIdx());

		InfiniteRuneItem mainHand = weaponSlot == null ? null : InfiniteRuneItem.getInfiniteRuneItem(weaponSlot.getId());
		updated.setMainHand(mainHand);

		InfiniteRuneItem offHand = shieldSlot == null ? null : InfiniteRuneItem.getInfiniteRuneItem(shieldSlot.getId());
		updated.setOffHand(offHand);

		return updated;
	}

	public Map<RuneType, Integer> availableRunes(PlayerInventory player)
	{
		Map<RuneType, Integer> runes = new EnumMap<>(RuneType.class);

		for (RuneItemQuantity item : player.getRunes())
		{
			for (RuneType t : item.getRune().getMatchingTypes())
			{
				runes.merge(t, item.getQuantity(), Integer::sum);
			}
		}

		if (player.getPouch() != null)
		{
			int pouchSize = 4;
			switch (player.getPouch().getPouchType())
			{
				case THREE_SLOTS:
					pouchSize = 3;
				case FOUR_SLOTS:
					EnumComposition runepouchEnum = clientData.getRunepouchEnum();
					for (int i = 0; i < pouchSize; i++)
					{
						int runepouchId = clientData.varbitValue(AutocastingConstants.VARBIT_RUNE_POUCH_RUNES[i]);
						int amount = clientData.varbitValue(AutocastingConstants.VARBIT_RUNE_POUCH_AMOUNTS[i]);
						if (runepouchId == 0 || amount <= 0)
						{
							continue;
						}
						int runeId = runepouchEnum.getIntValue(runepouchId);
						RuneItem rune = RuneItem.getRuneItem(runeId);
						if (rune != null)
						{
							for (RuneType t : rune.getMatchingTypes())
							{
								runes.merge(t, amount, Integer::sum);
							}
						}
					}
					break;
				case LMS:
					runes.put(RuneType.WATER, Integer.MAX_VALUE);
					runes.put(RuneType.DEATH, Integer.MAX_VALUE);
					runes.put(RuneType.BLOOD, Integer.MAX_VALUE);
					runes.put(RuneType.SOUL, Integer.MAX_VALUE);
					break;
				case INFINITE:
					for (RuneType t : RuneType.values())
					{
						runes.put(t, Integer.MAX_VALUE);
					}
					break;
			}
		}

		InfiniteRuneItem weapon = player.getMainHand();
		if (weapon != null)
		{
			for (RuneType rune : weapon.getMatchingTypes())
			{
				runes.put(rune, Integer.MAX_VALUE);
			}
		}

		InfiniteRuneItem offHand = player.getOffHand();
		if (offHand != null)
		{
			for (RuneType rune : offHand.getMatchingTypes())
			{
				runes.put(rune, Integer.MAX_VALUE);
			}
		}

		return runes;
	}

	public int calculateCastsRemaining(Spell spell, Map<RuneType, Integer> runes)
	{
		if (runes == null)
		{
			// Called before inventory or equipment is initialized on login screens
			return 0;
		}

		if (clientData.varbitValue(VarbitID.FOUNTAIN_OF_RUNE_ACTIVE) == 1)
		{
			return Integer.MAX_VALUE;
		}

		RuneTypeQuantity[] cost = spell.getSpellCost().getRuneCost();

		int lowestCasts = Integer.MAX_VALUE;
		for (RuneTypeQuantity rune : cost)
		{
			RuneType runeType = rune.getRuneType();
			int specificRuneCost = rune.getQuantity();

			Integer amountHeld = runes.getOrDefault(runeType, null);
			if (amountHeld != null)
			{
				// Do division unless we have "infinite", as denoted with MAX_VALUE
				int casts = amountHeld == Integer.MAX_VALUE ? Integer.MAX_VALUE : amountHeld / specificRuneCost;
				lowestCasts = Math.min(casts, lowestCasts);
			}
			else
			{
				// We don't have any of that type of rune
				return 0;
			}
		}
		return lowestCasts;
	}
}

package com.autocasting;

import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

import java.awt.*;

@ConfigGroup("autocasting")
public interface AutocastingConfig extends Config
{
	// OVERLAY

	@ConfigSection(
		name = "Overlay",
		description = "Overlay Settings",
		position = 0
	)
	String overlaySettings = "overlay";

	@ConfigItem(
		keyName = "showOverlay",
		name = "Show Overlay",
		description = "Show/hide overlay",
		position = 1,
		section = overlaySettings
	)
	default boolean showOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showOverlayOutsideCombat",
		name = "Show Outside of Combat",
		description = "Display the autocast overlay panel outside of combat.",
		position = 2,
		section = overlaySettings
	)
	default boolean showOverlayOutsideCombat()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showSpellName",
		name = "Show Spell Name",
		description = "Show/hide spell name",
		position = 3,
		section = overlaySettings
	)
	default boolean showSpellName()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showSpellIcon",
		name = "Show Spell Icon",
		description = "Show/hide spell icon",
		position = 4,
		section = overlaySettings
	)
	default boolean showSpellIcon()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableOverrideText",
		name = "Enable Override Text",
		description = "Allow custom text to be displayed during alerts.",
		position = 5,
		section = overlaySettings
	)
	default boolean enableOverrideText()
	{
		return true;
	}


	@ConfigItem(
		keyName = "lowMagicLevelText",
		name = "Low Magic Level Override Text",
		description = "Text to override spell name when your magic level drops below the required level. Will not override if left blank.",
		position = 6,
		section = overlaySettings
	)
	default String lowMagicLevelText()
	{
		return "RESTORE";
	}

	@ConfigItem(
		keyName = "noRunesText",
		name = "No Runes Override Text",
		description = "Text to override spell name when you run out of runes for your autocast. Will not override if left blank.",
		position = 7,
		section = overlaySettings
	)
	default String noRunesText()
	{
		return "NO RUNES";
	}

	@ConfigItem(
		keyName = "overlayAlertStyle",
		name = "Overlay Alert Style",
		description = "Configures how the overlay behaves when the autocast is unusable.",
		position = 8,
		section = overlaySettings
	)
	default AutocastingConstants.OverlayNotificationType overlayAlertStyle()
	{
		return AutocastingConstants.OverlayNotificationType.FLASH;
	}


	@Alpha
	@ConfigItem(
		keyName = "overlayAlertColor",
		name = "Overlay Alert Color",
		description = "Color of Autocast overlay when flashing/solid",
		position = 9,
		section = overlaySettings
	)
	default Color overlayAlertColor()
	{
		return AutocastingConstants.RED_FLASH_COLOR;
	}

	@Range(min = AutocastingConstants.MINIMUM_COUNTER_FLASH_PERIOD)
	@ConfigItem(
		keyName = "flashPeriod",
		name = "Overlay Flash Period",
		description = "Period (in hundredths of seconds) at which the Autocast overlay flashes. Lower numbers flash faster.",
		position = 10,
		section = overlaySettings
	)
	default int getFlashPeriod()
	{
		return AutocastingConstants.DEFAULT_COUNTER_FLASH_PERIOD;
	}

	@ConfigItem(
		keyName = "showCastsRemaining",
		name = "Display Casts Remaining",
		description = "Puts the amount of casts of your autocast spell you have left, based on your current runes.",
		position = 11,
		section = overlaySettings
	)
	default boolean showCastsRemaining()
	{
		return true;
	}

	@Range(min = AutocastingConstants.MINIMUM_CAST_RUNES_THRESHOLD, max = AutocastingConstants.MAXIMUM_CAST_RUNES_THRESHOLD)
	@ConfigItem(
		keyName = "castRemainingThreshold",
		name = "Display Cast Limit",
		description = "Max amount of remaining casts which will be displayed. (1-999,999)",
		position = 12,
		section = overlaySettings
	)
	default int displayCastLimit()
	{
		return AutocastingConstants.DEFAULT_CAST_RUNES_THRESHOLD;
	}

	@ConfigItem(
		keyName = "hideUnlikelyItems",
		name = "Hide Unlikely Weapons",
		description = "Hide display on items which can autocast but aren't commonly used to cast.",
		position = 13,
		section = overlaySettings
	)
	default boolean hideUnlikelyItems()
	{
		return true;
	}


	// NOTIFICATIONS

	@ConfigSection(
		name = "Notifications",
		description = "In-Game and Desktop Notification Settings",
		position = 14
	)
	String notificationSettings = "notifications";

	@ConfigItem(
		keyName = "notifyOutOfCombat",
		name = "Notify Out Of Combat",
		description = "Controls if notifications for autocast spells will appear outside of combat.",
		position = 15,
		section = notificationSettings
	)
	default boolean notifyOutOfCombat()
	{
		return true;
	}

	@ConfigItem(
		keyName = "notifyOnStatDrain",
		name = "Stat Drain Notification",
		description = "Notifies you when your magic level falls below the level required for your autocast spell.",
		position = 16,
		section = notificationSettings
	)
	default AutocastingConstants.ChatNotificationType notifyOnStatDrain()
	{
		return AutocastingConstants.ChatNotificationType.BOTH;
	}

	@ConfigItem(
		keyName = "notifyOnLowCasts",
		name = "Low Casts Notification",
		description = "Notifies you when your amount of casts falls to or below the Low Cast Threshold.",
		position = 17,
		section = notificationSettings
	)
	default AutocastingConstants.ChatNotificationType notifyOnLowCasts()
	{
		return AutocastingConstants.ChatNotificationType.BOTH;
	}

	@ConfigItem(
		keyName = "notifyOnNoAutocastSelected",
		name = "Alert on No Spell Selected",
		description = "Enter alert mode when no autocast spell is selected.",
		position = 18,
		section = notificationSettings
	)
	default AutocastingConstants.ChatNotificationType notifyOnNoAutocastSelected()
	{
		return AutocastingConstants.ChatNotificationType.NONE;
	}


	@Range(min = AutocastingConstants.MINIMUM_CAST_RUNES_THRESHOLD, max = AutocastingConstants.MAXIMUM_CAST_RUNES_THRESHOLD)
	@ConfigItem(
		keyName = "lowCastNotificationThreshold",
		name = "Low Cast Threshold",
		description = "Amount of casts to notify you on, based on your current runes.",
		position = 19,
		section = notificationSettings
	)
	default int lowCastNotificationThreshold()
	{
		return AutocastingConstants.DEFAULT_LOW_RUNES_NOTIFICATION_THRESHOLD;
	}


	@ConfigItem(
		keyName = "notifyOnLowCasts",
		name = "No Casts Notification",
		description = "Notifies you when you run out of runes to cast your autocast spell.",
		position = 20,
		section = notificationSettings
	)
	default AutocastingConstants.ChatNotificationType notifyOnNoCasts()
	{
		return AutocastingConstants.ChatNotificationType.BOTH;
	}
}

package com.autocasting.datatypes;

import lombok.Data;

/**
 * A "tuple" of RuneItem and a quantity,
 * in other words a stack of physical runes
 */
@Data
public class RuneItemQuantity
{
	private final RuneItem rune;
	private final int quantity;
}

package com.autocasting.datatypes;

import lombok.Getter;
import lombok.Setter;

import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class PlayerInventory
{
	@Getter
	@Setter
	private InfiniteRuneItem mainHand;

	@Getter
	@Setter
	private InfiniteRuneItem offHand;

	@Getter
	@Setter
	private Pouch pouch;

	@Getter
	@Setter
	private List<RuneItemQuantity> runes;

	public PlayerInventory()
	{
		mainHand = null;
		offHand = null;
		pouch = null;
		runes = new ArrayList<>();
	}

	public void clearItems()
	{
		mainHand = null;
		offHand = null;
	}

	public void addRuneStack(RuneItemQuantity runeStack)
	{
		runes.add(runeStack);
	}

	public void clearRunes()
	{
		runes = new ArrayList<>();
	}
}

package com.autocasting.datatypes;

import com.google.common.collect.ImmutableMap;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.ItemID;

import java.util.Map;

@RequiredArgsConstructor
@Getter
public enum Pouch
{

	RUNE_POUCH(ItemID.BH_RUNE_POUCH, PouchType.THREE_SLOTS),
	RUNE_POUCH_L(ItemID.BH_RUNE_POUCH_TROUVER, PouchType.THREE_SLOTS),
	DIVINE_RUNE_POUCH(ItemID.DIVINE_RUNE_POUCH, PouchType.FOUR_SLOTS),
	DIVINE_RUNE_POUCH_L(ItemID.DIVINE_RUNE_POUCH_TROUVER, PouchType.FOUR_SLOTS),
	LMS_POUCH(ItemID.BR_RUNE_REPLACEMENT, PouchType.LMS),
	EMIRS_ARENA_POUCH(ItemID.PVPA_RUNE_REPLACEMENT, PouchType.INFINITE);

	@Getter
	private final int id;

	@Getter
	private final PouchType pouchType;

	private static final Map<Integer, Pouch> POUCH_MAP;

	static
	{
		ImmutableMap.Builder<Integer, Pouch> builder = new ImmutableMap.Builder<>();

		for (Pouch pouch : values())
		{
			builder.put(pouch.getId(), pouch);
		}
		POUCH_MAP = builder.build();
	}

	public static Pouch getPouch(int itemId)
	{
		return POUCH_MAP.getOrDefault(itemId, null);
	}
}

package com.autocasting.datatypes;

import com.google.common.collect.ImmutableMap;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.SpriteID;

import java.util.Map;

@RequiredArgsConstructor
@Getter
public enum Spell
{
	/**
	 * The currently selected autocast spell.
	 * 0        = no spell selected.
	 * <p>
	 * 1 -> 4   = wind, water, earth, fire strike
	 * 5 -> 8   = wind, water, earth, fire bolt
	 * 9 -> 12  = wind, water, earth, fire blast
	 * 13 -> 16 = wind, water, earth, fire wave
	 * 48 -> 51 = wind, water, earth, fire surge
	 * <p>
	 * 31 -> 34 = Smoke, Shadow, Blood, Ice Rush
	 * 35 -> 38 = Smoke, Shadow, Blood, Ice Burst
	 * 39 -> 42 = Smoke, Shadow, Blood, Ice Blitz
	 * 43 -> 46 = Smoke, Shadow, Blood, Ice Barrage
	 * <p>
	 * 53 -> 55 = Inferior, Superior, Dark Demonbane
	 * 56 -> 58 = Ghostly, Skeletal, Undead Grasp
	 * <p>
	 * 47       = Iban's blast
	 * 17       = Crumble Undead
	 * 18       = Magic Dart
	 * 19       = Claws of Guthix
	 * 20       = Flames of Zamorak
	 * 52       = Saradomin Strike
	 */

	NO_SPELL("No spell selected", SpriteID.ROUND_CHECK_BOX_CROSSED, -1, 0, null),

	WIND_STRIKE("Wind Strike", SpriteID.SPELL_WIND_STRIKE, 1, 1, SpellCost.WIND_STRIKE),
	WATER_STRIKE("Water Strike", SpriteID.SPELL_WATER_STRIKE, 5, 2, SpellCost.WATER_STRIKE),
	EARTH_STRIKE("Earth Strike", SpriteID.SPELL_EARTH_STRIKE, 9, 3, SpellCost.EARTH_STRIKE),
	FIRE_STRIKE("Fire Strike", SpriteID.SPELL_FIRE_STRIKE, 13, 4, SpellCost.FIRE_STRIKE),

	WIND_BOLT("Wind Bolt", SpriteID.SPELL_WIND_BOLT, 17, 5, SpellCost.WIND_BOLT),
	WATER_BOLT("Water Bolt", SpriteID.SPELL_WATER_BOLT, 23, 6, SpellCost.WATER_BOLT),
	EARTH_BOLT("Earth Bolt", SpriteID.SPELL_EARTH_BOLT, 29, 7, SpellCost.EARTH_BOLT),
	FIRE_BOLT("Fire Bolt", SpriteID.SPELL_FIRE_BOLT, 35, 8, SpellCost.FIRE_BOLT),

	WIND_BLAST("Wind Blast", SpriteID.SPELL_WIND_BLAST, 41, 9, SpellCost.WIND_BLAST),
	WATER_BLAST("Water Blast", SpriteID.SPELL_WATER_BLAST, 47, 10, SpellCost.WATER_BLAST),
	EARTH_BLAST("Earth Blast", SpriteID.SPELL_EARTH_BLAST, 53, 11, SpellCost.EARTH_BLAST),
	FIRE_BLAST("Fire Blast", SpriteID.SPELL_FIRE_BLAST, 59, 12, SpellCost.FIRE_BLAST),

	WIND_WAVE("Wind Wave", SpriteID.SPELL_WIND_WAVE, 62, 13, SpellCost.WIND_WAVE),
	WATER_WAVE("Water Wave", SpriteID.SPELL_WATER_WAVE, 65, 14, SpellCost.WATER_WAVE),
	EARTH_WAVE("Earth Wave", SpriteID.SPELL_EARTH_WAVE, 70, 15, SpellCost.EARTH_WAVE),
	FIRE_WAVE("Fire Wave", SpriteID.SPELL_FIRE_WAVE, 75, 16, SpellCost.FIRE_WAVE),

	CRUMBLE_UNDEAD("Crumble Undead", SpriteID.SPELL_CRUMBLE_UNDEAD, 39, 17, SpellCost.CRUMBLE_UNDEAD),
	MAGIC_DART("Magic Dart", SpriteID.SPELL_MAGIC_DART, 50, 18, SpellCost.MAGIC_DART),

	CLAWS_OF_GUTHIX("Claws of Guthix", SpriteID.SPELL_CLAWS_OF_GUTHIX, 60, 19, SpellCost.CLAWS_OF_GUTHIX),
	FLAMES_OF_ZAMORAK("Flames of Zamorak", SpriteID.SPELL_FLAMES_OF_ZAMORAK, 60, 20, SpellCost.FLAMES_OF_ZAMORAK),

	// 21 - 30 Unused

	SMOKE_RUSH("Smoke Rush", SpriteID.SPELL_SMOKE_RUSH, 50, 31, SpellCost.SMOKE_RUSH),
	SHADOW_RUSH("Shadow Rush", SpriteID.SPELL_SHADOW_RUSH, 52, 32, SpellCost.SHADOW_RUSH),
	BLOOD_RUSH("Blood Rush", SpriteID.SPELL_BLOOD_RUSH, 56, 33, SpellCost.BLOOD_RUSH),
	ICE_RUSH("Ice Rush", SpriteID.SPELL_ICE_RUSH, 58, 34, SpellCost.ICE_RUSH),

	SMOKE_BURST("Smoke Burst", SpriteID.SPELL_SMOKE_BURST, 62, 35, SpellCost.SMOKE_BURST),
	SHADOW_BURST("Shadow Burst", SpriteID.SPELL_SHADOW_BURST, 64, 36, SpellCost.SHADOW_BURST),
	BLOOD_BURST("Blood Burst", SpriteID.SPELL_BLOOD_BURST, 68, 37, SpellCost.BLOOD_BURST),
	ICE_BURST("Ice Burst", SpriteID.SPELL_ICE_BURST, 70, 38, SpellCost.ICE_BURST),

	SMOKE_BLITZ("Smoke Blitz", SpriteID.SPELL_SMOKE_BLITZ, 74, 39, SpellCost.SMOKE_BLITZ),
	SHADOW_BLITZ("Shadow Blitz", SpriteID.SPELL_SHADOW_BLITZ, 76, 40, SpellCost.SHADOW_BLITZ),
	BLOOD_BLITZ("Blood Blitz", SpriteID.SPELL_BLOOD_BLITZ, 80, 41, SpellCost.BLOOD_BLITZ),
	ICE_BLITZ("Ice Blitz", SpriteID.SPELL_ICE_BLITZ, 82, 42, SpellCost.ICE_BLITZ),

	SMOKE_BARRAGE("Smoke Barrage", SpriteID.SPELL_SMOKE_BARRAGE, 86, 43, SpellCost.SMOKE_BARRAGE),
	SHADOW_BARRAGE("Shadow Barrage", SpriteID.SPELL_SHADOW_BARRAGE, 88, 44, SpellCost.SHADOW_BARRAGE),
	BLOOD_BARRAGE("Blood Barrage", SpriteID.SPELL_BLOOD_BARRAGE, 92, 45, SpellCost.BLOOD_BARRAGE),
	ICE_BARRAGE("Ice Barrage", SpriteID.SPELL_ICE_BARRAGE, 94, 46, SpellCost.ICE_BARRAGE),

	IBAN_BLAST("Iban's Blast", SpriteID.SPELL_IBAN_BLAST, 50, 47, SpellCost.IBAN_BLAST),

	WIND_SURGE("Wind Surge", SpriteID.SPELL_WIND_SURGE, 81, 48, SpellCost.WIND_SURGE),
	WATER_SURGE("Water Surge", SpriteID.SPELL_WATER_SURGE, 85, 49, SpellCost.WATER_SURGE),
	EARTH_SURGE("Earth Surge", SpriteID.SPELL_EARTH_SURGE, 90, 50, SpellCost.EARTH_SURGE),
	FIRE_SURGE("Fire Surge", SpriteID.SPELL_FIRE_SURGE, 95, 51, SpellCost.FIRE_SURGE),

	SARADOMIN_STRIKE("Saradomin Strike", SpriteID.SPELL_SARADOMIN_STRIKE, 60, 52, SpellCost.SARADOMIN_STRIKE),

	INFERIOR_DEMONBANE("Inferior Demonbane", SpriteID.SPELL_INFERIOR_DEMONBANE, 44, 53, SpellCost.INFERIOR_DEMONBANE),
	SUPERIOR_DEMONBANE("Superior Demonbane", SpriteID.SPELL_SUPERIOR_DEMONBANE, 62, 54, SpellCost.SUPERIOR_DEMONBANE),
	DARK_DEMONBANE("Dark Demonbane", SpriteID.SPELL_DARK_DEMONBANE, 82, 55, SpellCost.DARK_DEMONBANE),

	GHOSTLY_GRASP("Ghostly Grasp", SpriteID.SPELL_GHOSTLY_GRASP, 35, 56, SpellCost.GHOSTLY_GRASP),
	SKELETAL_GRASP("Skeletal Grasp", SpriteID.SPELL_SKELETAL_GRASP, 56, 57, SpellCost.SKELETAL_GRASP),
	UNDEAD_GRASP("Undead Grasp", SpriteID.SPELL_UNDEAD_GRASP, 79, 58, SpellCost.UNDEAD_GRASP);

	@Getter
	private final String name;

	@Getter
	private final int spriteID;

	@Getter
	private final int levelRequirement;

	@Getter
	private final int varbitValue;

	@Getter
	private final SpellCost spellCost;

	private static final Map<Integer, Spell> AUTOCAST_SPELLS_MAP;

	static
	{
		ImmutableMap.Builder<Integer, Spell> builder = new ImmutableMap.Builder<>();

		for (Spell spell : values())
		{
			builder.put(spell.getVarbitValue(), spell);
		}
		AUTOCAST_SPELLS_MAP = builder.build();
	}

	public static Spell getSpell(int varbitValue)
	{
		return AUTOCAST_SPELLS_MAP.getOrDefault(varbitValue, null);
	}
}
package com.autocasting.datatypes;

public enum PouchType
{
	THREE_SLOTS,
	FOUR_SLOTS,
	LMS,
	INFINITE
}
package com.autocasting.datatypes;

import com.google.common.collect.ImmutableMap;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.gameval.ItemID;

import java.util.Map;

@RequiredArgsConstructor
@Getter
public enum InfiniteRuneItem
{
	STAFF_OF_AIR(ItemID.STAFF_OF_AIR, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.AIR}),
	AIR_BATTLESTAFF(ItemID.AIR_BATTLESTAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.AIR}),
	MYSTIC_AIR_STAFF(ItemID.MYSTIC_AIR_STAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.AIR}),

	STAFF_OF_WATER(ItemID.STAFF_OF_WATER, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.WATER}),
	WATER_BATTLESTAFF(ItemID.WATER_BATTLESTAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.WATER}),
	MYSTIC_WATER_STAFF(ItemID.MYSTIC_WATER_STAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.WATER}),

	STAFF_OF_EARTH(ItemID.STAFF_OF_EARTH, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.EARTH}),
	EARTH_BATTLESTAFF(ItemID.EARTH_BATTLESTAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.EARTH}),
	MYSTIC_EARTH_STAFF(ItemID.MYSTIC_EARTH_STAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.EARTH}),

	STAFF_OF_FIRE(ItemID.STAFF_OF_FIRE, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.FIRE}),
	FIRE_BATTLESTAFF(ItemID.FIRE_BATTLESTAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.FIRE}),
	MYSTIC_FIRE_STAFF(ItemID.MYSTIC_FIRE_STAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.FIRE}),

	MIST_BATTLESTAFF(ItemID.MIST_BATTLESTAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.AIR, RuneType.WATER}),
	DUST_BATTLESTAFF(ItemID.DUST_BATTLESTAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.AIR, RuneType.EARTH}),
	MUD_BATTLESTAFF(ItemID.MUD_BATTLESTAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.WATER, RuneType.EARTH}),
	SMOKE_BATTLESTAFF(ItemID.SMOKE_BATTLESTAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.AIR, RuneType.FIRE}),
	STEAM_BATTLESTAFF(ItemID.STEAM_BATTLESTAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.WATER, RuneType.FIRE}),
	LAVA_BATTLESTAFF(ItemID.LAVA_BATTLESTAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.EARTH, RuneType.FIRE}),

	// 
	MYSTIC_MIST_STAFF(ItemID.MYSTIC_MIST_BATTLESTAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.AIR, RuneType.WATER}),
	MYSTIC_DUST_STAFF(ItemID.MYSTIC_DUST_BATTLESTAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.AIR, RuneType.EARTH}),
	MYSTIC_MUD_STAFF(ItemID.MYSTIC_MUD_STAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.WATER, RuneType.EARTH}),
	MYSTIC_SMOKE_STAFF(ItemID.MYSTIC_SMOKE_BATTLESTAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.AIR, RuneType.FIRE}),
	MYSTIC_STEAM_STAFF(ItemID.MYSTIC_STEAM_BATTLESTAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.WATER, RuneType.FIRE}),
	MYSTIC_LAVA_STAFF(ItemID.MYSTIC_LAVA_STAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.EARTH, RuneType.FIRE}),

	STEAM_BATTLESTAFF_OR(ItemID.STEAM_BATTLESTAFF_PRETTY, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.WATER, RuneType.FIRE}),
	MYSTIC_STEAM_STAFF_OR(ItemID.MYSTIC_STEAM_BATTLESTAFF_PRETTY, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.WATER, RuneType.FIRE}),
	LAVA_BATTLESTAFF_OR(ItemID.LAVA_BATTLESTAFF_PRETTY, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.EARTH, RuneType.FIRE}),
	MYSTIC_LAVA_STAFF_OR(ItemID.MYSTIC_LAVA_STAFF_PRETTY, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.EARTH, RuneType.FIRE}),

	TWINFLAME_STAFF(ItemID.TWINFLAME_STAFF, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.WATER, RuneType.FIRE}),

	KODAI_WAND(ItemID.KODAI_WAND, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.WATER}),
	KODAI_WAND_23626(ItemID.BR_KODAI_WAND, EquipmentInventorySlot.WEAPON, new RuneType[]{RuneType.WATER}),

	TOME_OF_WATER(ItemID.TOME_OF_WATER, EquipmentInventorySlot.SHIELD, new RuneType[]{RuneType.WATER}),
	TOME_OF_FIRE(ItemID.TOME_OF_FIRE, EquipmentInventorySlot.SHIELD, new RuneType[]{RuneType.FIRE}),
	TOME_OF_EARTH(ItemID.TOME_OF_EARTH, EquipmentInventorySlot.SHIELD, new RuneType[]{RuneType.EARTH});


	@Getter
	private final int itemId;

	@Getter
	private final EquipmentInventorySlot slot;

	@Getter
	private final RuneType[] matchingTypes;

	private static final Map<Integer, InfiniteRuneItem> INFINITE_RUNE_ITEM_MAP;

	static
	{
		ImmutableMap.Builder<Integer, InfiniteRuneItem> builder = new ImmutableMap.Builder<>();

		for (InfiniteRuneItem item : values())
		{
			builder.put(item.getItemId(), item);
		}

		INFINITE_RUNE_ITEM_MAP = builder.build();
	}

	public static InfiniteRuneItem getInfiniteRuneItem(int itemId)
	{
		return INFINITE_RUNE_ITEM_MAP.getOrDefault(itemId, null);
	}
}

package com.autocasting.datatypes;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum SpellCost
{
	WIND_STRIKE(1, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.MIND, 1),
		new RuneTypeQuantity(RuneType.AIR, 1)
	}),

	WATER_STRIKE(2, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.MIND, 1),
		new RuneTypeQuantity(RuneType.WATER, 1),
		new RuneTypeQuantity(RuneType.AIR, 1),
	}),

	EARTH_STRIKE(3, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.MIND, 1),
		new RuneTypeQuantity(RuneType.EARTH, 2),
		new RuneTypeQuantity(RuneType.AIR, 1),
	}),

	FIRE_STRIKE(4, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.MIND, 1),
		new RuneTypeQuantity(RuneType.FIRE, 3),
		new RuneTypeQuantity(RuneType.AIR, 2),
	}),

	WIND_BOLT(5, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.CHAOS, 1),
		new RuneTypeQuantity(RuneType.AIR, 2)
	}),

	WATER_BOLT(6, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.CHAOS, 1),
		new RuneTypeQuantity(RuneType.WATER, 2),
		new RuneTypeQuantity(RuneType.AIR, 2)
	}),

	EARTH_BOLT(7, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.CHAOS, 1),
		new RuneTypeQuantity(RuneType.EARTH, 3),
		new RuneTypeQuantity(RuneType.AIR, 2)
	}),

	FIRE_BOLT(8, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.CHAOS, 1),
		new RuneTypeQuantity(RuneType.FIRE, 4),
		new RuneTypeQuantity(RuneType.AIR, 3)
	}),

	WIND_BLAST(9, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 1),
		new RuneTypeQuantity(RuneType.AIR, 3)
	}),

	WATER_BLAST(10, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 1),
		new RuneTypeQuantity(RuneType.WATER, 3),
		new RuneTypeQuantity(RuneType.AIR, 3)
	}),

	EARTH_BLAST(11, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 1),
		new RuneTypeQuantity(RuneType.EARTH, 4),
		new RuneTypeQuantity(RuneType.AIR, 3)
	}),

	FIRE_BLAST(12, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 1),
		new RuneTypeQuantity(RuneType.FIRE, 5),
		new RuneTypeQuantity(RuneType.AIR, 4)
	}),

	WIND_WAVE(13, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.BLOOD, 1),
		new RuneTypeQuantity(RuneType.AIR, 5)
	}),

	WATER_WAVE(14, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.BLOOD, 1),
		new RuneTypeQuantity(RuneType.WATER, 7),
		new RuneTypeQuantity(RuneType.AIR, 5)
	}),

	EARTH_WAVE(15, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.BLOOD, 1),
		new RuneTypeQuantity(RuneType.EARTH, 7),
		new RuneTypeQuantity(RuneType.AIR, 5)
	}),

	FIRE_WAVE(16, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.BLOOD, 1),
		new RuneTypeQuantity(RuneType.FIRE, 7),
		new RuneTypeQuantity(RuneType.AIR, 5)
	}),

	CRUMBLE_UNDEAD(17, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.CHAOS, 1),
		new RuneTypeQuantity(RuneType.EARTH, 2),
		new RuneTypeQuantity(RuneType.AIR, 2)
	}),

	MAGIC_DART(18, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 1),
		new RuneTypeQuantity(RuneType.MIND, 4),
	}),

	CLAWS_OF_GUTHIX(19, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.BLOOD, 2),
		new RuneTypeQuantity(RuneType.AIR, 4),
		new RuneTypeQuantity(RuneType.FIRE, 1)
	}),

	FLAMES_OF_ZAMORAK(20, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.BLOOD, 2),
		new RuneTypeQuantity(RuneType.AIR, 1),
		new RuneTypeQuantity(RuneType.FIRE, 4)
	}),

	SMOKE_RUSH(31, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 2),
		new RuneTypeQuantity(RuneType.CHAOS, 2),
		new RuneTypeQuantity(RuneType.AIR, 1),
		new RuneTypeQuantity(RuneType.FIRE, 1)
	}),

	SHADOW_RUSH(32, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 2),
		new RuneTypeQuantity(RuneType.CHAOS, 2),
		new RuneTypeQuantity(RuneType.SOUL, 1),
		new RuneTypeQuantity(RuneType.AIR, 1)
	}),

	BLOOD_RUSH(33, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 2),
		new RuneTypeQuantity(RuneType.CHAOS, 2),
		new RuneTypeQuantity(RuneType.BLOOD, 1),
	}),

	ICE_RUSH(34, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 2),
		new RuneTypeQuantity(RuneType.CHAOS, 2),
		new RuneTypeQuantity(RuneType.WATER, 2),
	}),

	SMOKE_BURST(35, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 2),
		new RuneTypeQuantity(RuneType.CHAOS, 4),
		new RuneTypeQuantity(RuneType.AIR, 2),
		new RuneTypeQuantity(RuneType.FIRE, 2)
	}),

	SHADOW_BURST(36, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 2),
		new RuneTypeQuantity(RuneType.CHAOS, 4),
		new RuneTypeQuantity(RuneType.SOUL, 2),
		new RuneTypeQuantity(RuneType.AIR, 1)
	}),

	BLOOD_BURST(37, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 2),
		new RuneTypeQuantity(RuneType.CHAOS, 4),
		new RuneTypeQuantity(RuneType.BLOOD, 2),
	}),

	ICE_BURST(38, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 2),
		new RuneTypeQuantity(RuneType.CHAOS, 4),
		new RuneTypeQuantity(RuneType.WATER, 4),
	}),

	SMOKE_BLITZ(39, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 2),
		new RuneTypeQuantity(RuneType.BLOOD, 2),
		new RuneTypeQuantity(RuneType.AIR, 2),
		new RuneTypeQuantity(RuneType.FIRE, 2)
	}),

	SHADOW_BLITZ(40, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 2),
		new RuneTypeQuantity(RuneType.BLOOD, 2),
		new RuneTypeQuantity(RuneType.SOUL, 2),
		new RuneTypeQuantity(RuneType.AIR, 2)
	}),

	BLOOD_BLITZ(41, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 2),
		new RuneTypeQuantity(RuneType.BLOOD, 4),
	}),

	ICE_BLITZ(42, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 2),
		new RuneTypeQuantity(RuneType.BLOOD, 2),
		new RuneTypeQuantity(RuneType.WATER, 3),
	}),

	SMOKE_BARRAGE(43, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 4),
		new RuneTypeQuantity(RuneType.BLOOD, 2),
		new RuneTypeQuantity(RuneType.AIR, 4),
		new RuneTypeQuantity(RuneType.FIRE, 4)
	}),

	SHADOW_BARRAGE(44, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 4),
		new RuneTypeQuantity(RuneType.BLOOD, 2),
		new RuneTypeQuantity(RuneType.SOUL, 3),
		new RuneTypeQuantity(RuneType.AIR, 4)
	}),

	BLOOD_BARRAGE(45, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 4),
		new RuneTypeQuantity(RuneType.BLOOD, 4),
		new RuneTypeQuantity(RuneType.SOUL, 1),
	}),

	ICE_BARRAGE(46, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 4),
		new RuneTypeQuantity(RuneType.BLOOD, 2),
		new RuneTypeQuantity(RuneType.WATER, 6),
	}),

	IBAN_BLAST(47, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 1),
		new RuneTypeQuantity(RuneType.FIRE, 5)
	}),

	WIND_SURGE(48, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.WRATH, 1),
		new RuneTypeQuantity(RuneType.AIR, 7)
	}),

	WATER_SURGE(49, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.WRATH, 1),
		new RuneTypeQuantity(RuneType.WATER, 10),
		new RuneTypeQuantity(RuneType.AIR, 7)
	}),

	EARTH_SURGE(50, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.WRATH, 1),
		new RuneTypeQuantity(RuneType.EARTH, 10),
		new RuneTypeQuantity(RuneType.AIR, 7)
	}),

	FIRE_SURGE(51, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.WRATH, 1),
		new RuneTypeQuantity(RuneType.FIRE, 10),
		new RuneTypeQuantity(RuneType.AIR, 7)
	}),

	SARADOMIN_STRIKE(52, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.BLOOD, 2),
		new RuneTypeQuantity(RuneType.AIR, 4),
		new RuneTypeQuantity(RuneType.FIRE, 2)
	}),

	INFERIOR_DEMONBANE(53, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.CHAOS, 1),
		new RuneTypeQuantity(RuneType.FIRE, 3)
	}),

	SUPERIOR_DEMONBANE(54, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.SOUL, 1),
		new RuneTypeQuantity(RuneType.FIRE, 5)
	}),

	DARK_DEMONBANE(55, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.SOUL, 2),
		new RuneTypeQuantity(RuneType.FIRE, 7)
	}),

	GHOSTLY_GRASP(56, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.CHAOS, 1),
		new RuneTypeQuantity(RuneType.AIR, 4)
	}),

	SKELETAL_GRASP(57, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.DEATH, 1),
		new RuneTypeQuantity(RuneType.EARTH, 8)
	}),

	UNDEAD_GRASP(58, new RuneTypeQuantity[]{
		new RuneTypeQuantity(RuneType.BLOOD, 1),
		new RuneTypeQuantity(RuneType.FIRE, 12)
	});

	@Getter
	private final int varbitValue;

	@Getter
	private final RuneTypeQuantity[] runeCost;
}

package com.autocasting.datatypes;

import com.google.common.collect.ImmutableMap;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

import net.runelite.api.gameval.ItemID;

import java.util.Map;

/**
 * Represents a physical rune, like you could have in your inventory.
 * May correspond to one or more rune types (i.e. combination runes)
 */
@RequiredArgsConstructor
@Getter
public enum RuneItem
{
	AIR_RUNE(ItemID.AIRRUNE, new RuneType[]{RuneType.AIR}),
	ROGUETRADER_AIRRUNE(ItemID.ROGUETRADER_AIRRUNE, new RuneType[]{RuneType.AIR}),
	_100GUIDE_AIRRUNE_DUM(ItemID._100GUIDE_AIRRUNE_DUM, new RuneType[]{RuneType.AIR}),
	SLUG2_RUNE_AIR(ItemID.SLUG2_RUNE_AIR, new RuneType[]{RuneType.AIR}),
	FAKE_AIRRUNE(ItemID.FAKE_AIRRUNE, new RuneType[]{RuneType.AIR}),
	NZONE_AIRRUNE(ItemID.NZONE_AIRRUNE, new RuneType[]{RuneType.AIR}),

	WATER_RUNE(ItemID.WATERRUNE, new RuneType[]{RuneType.WATER}),
	ROGUETRADER_WATERRUNE(ItemID.ROGUETRADER_WATERRUNE, new RuneType[]{RuneType.WATER}),
	_100GUIDE_WATERRUNE_DUM(ItemID._100GUIDE_WATERRUNE_DUM, new RuneType[]{RuneType.WATER}),
	SLUG2_RUNE_WATER(ItemID.SLUG2_RUNE_WATER, new RuneType[]{RuneType.WATER}),
	FAKE_WATERRUNE(ItemID.FAKE_WATERRUNE, new RuneType[]{RuneType.WATER}),
	NZONE_WATERRUNE(ItemID.NZONE_WATERRUNE, new RuneType[]{RuneType.WATER}),

	EARTH_RUNE(ItemID.EARTHRUNE, new RuneType[]{RuneType.EARTH}),
	ROGUETRADER_EARTHRUNE(ItemID.ROGUETRADER_EARTHRUNE, new RuneType[]{RuneType.EARTH}),
	SLUG2_RUNE_EARTH(ItemID.SLUG2_RUNE_EARTH, new RuneType[]{RuneType.EARTH}),
	FAKE_EARTHRUNE(ItemID.FAKE_EARTHRUNE, new RuneType[]{RuneType.EARTH}),
	NZONE_EARTHRUNE(ItemID.NZONE_EARTHRUNE, new RuneType[]{RuneType.EARTH}),

	FIRE_RUNE(ItemID.FIRERUNE, new RuneType[]{RuneType.FIRE}),
	ROGUETRADER_FIRERUNE(ItemID.ROGUETRADER_FIRERUNE, new RuneType[]{RuneType.FIRE}),
	_100GUIDE_FIRERUNE_DUM(ItemID._100GUIDE_FIRERUNE_DUM, new RuneType[]{RuneType.FIRE}),
	SLUG2_RUNE_FIRE(ItemID.SLUG2_RUNE_FIRE, new RuneType[]{RuneType.FIRE}),
	FAKE_FIRERUNE(ItemID.FAKE_FIRERUNE, new RuneType[]{RuneType.FIRE}),
	NZONE_FIRERUNE(ItemID.NZONE_FIRERUNE, new RuneType[]{RuneType.FIRE}),
	SUNFIRE_RUNE(ItemID.SUNFIRERUNE, new RuneType[]{RuneType.FIRE}),

	MIND_RUNE(ItemID.MINDRUNE, new RuneType[]{RuneType.MIND}),
	ROGUETRADER_MINDRUNE(ItemID.ROGUETRADER_MINDRUNE, new RuneType[]{RuneType.MIND}),
	SLUG2_RUNE_MIND(ItemID.SLUG2_RUNE_MIND, new RuneType[]{RuneType.MIND}),
	FAKE_MINDRUNE(ItemID.FAKE_MINDRUNE, new RuneType[]{RuneType.MIND}),

	BODY_RUNE(ItemID.BODYRUNE, new RuneType[]{RuneType.BODY}),
	ROGUETRADER_BODYRUNE(ItemID.ROGUETRADER_BODYRUNE, new RuneType[]{RuneType.BODY}),
	FAKE_BODYRUNE(ItemID.FAKE_BODYRUNE, new RuneType[]{RuneType.BODY}),

	COSMIC_RUNE(ItemID.COSMICRUNE, new RuneType[]{RuneType.COSMIC}),
	FAKE_COSMICRUNE(ItemID.FAKE_COSMICRUNE, new RuneType[]{RuneType.COSMIC}),

	CHAOS_RUNE(ItemID.CHAOSRUNE, new RuneType[]{RuneType.CHAOS}),
	ROGUETRADER_CHAOSRUNE(ItemID.ROGUETRADER_CHAOSRUNE, new RuneType[]{RuneType.CHAOS}),
	_100GUIDE_CHAOSRUNE_DUM(ItemID._100GUIDE_CHAOSRUNE_DUM, new RuneType[]{RuneType.CHAOS}),
	FAKE_CHAOSRUNE(ItemID.FAKE_CHAOSRUNE, new RuneType[]{RuneType.CHAOS}),
	NZONE_CHAOSRUNE(ItemID.NZONE_CHAOSRUNE, new RuneType[]{RuneType.CHAOS}),

	NATURE_RUNE(ItemID.NATURERUNE, new RuneType[]{RuneType.NATURE}),
	FAKE_NATURERUNE(ItemID.FAKE_NATURERUNE, new RuneType[]{RuneType.NATURE}),

	LAW_RUNE(ItemID.LAWRUNE, new RuneType[]{RuneType.LAW}),
	ROGUETRADER_LAWRUNE(ItemID.ROGUETRADER_LAWRUNE, new RuneType[]{RuneType.LAW}),
	FAKE_LAWRUNE(ItemID.FAKE_LAWRUNE, new RuneType[]{RuneType.LAW}),

	DEATH_RUNE(ItemID.DEATHRUNE, new RuneType[]{RuneType.DEATH}),
	ROGUETRADER_DEATHRUNE(ItemID.ROGUETRADER_DEATHRUNE, new RuneType[]{RuneType.DEATH}),
	FAKE_DEATHRUNE(ItemID.FAKE_DEATHRUNE, new RuneType[]{RuneType.DEATH}),
	NZONE_DEATHRUNE(ItemID.NZONE_DEATHRUNE, new RuneType[]{RuneType.DEATH}),

	ASTRAL_RUNE(ItemID.ASTRALRUNE, new RuneType[]{RuneType.ASTRAL}),
	FAKE_ASTRALRUNE(ItemID.FAKE_ASTRALRUNE, new RuneType[]{RuneType.ASTRAL}),

	BLOOD_RUNE(ItemID.BLOODRUNE, new RuneType[]{RuneType.BLOOD}),
	FAKE_BLOODRUNE(ItemID.FAKE_BLOODRUNE, new RuneType[]{RuneType.BLOOD}),
	NZONE_BLOODRUNE(ItemID.NZONE_BLOODRUNE, new RuneType[]{RuneType.BLOOD}),

	SOUL_RUNE(ItemID.SOULRUNE, new RuneType[]{RuneType.SOUL}),
	FAKE_SOULRUNE(ItemID.FAKE_SOULRUNE, new RuneType[]{RuneType.SOUL}),

	WRATH_RUNE(ItemID.WRATHRUNE, new RuneType[]{RuneType.WRATH}),
	FAKE_WRATHRUNE(ItemID.FAKE_WRATHRUNE, new RuneType[]{RuneType.WRATH}),

	// Combo runes
	MIST_RUNE(ItemID.MISTRUNE, new RuneType[]{RuneType.AIR, RuneType.WATER}),
	DUST_RUNE(ItemID.DUSTRUNE, new RuneType[]{RuneType.AIR, RuneType.EARTH}),
	MUD_RUNE(ItemID.MUDRUNE, new RuneType[]{RuneType.WATER, RuneType.EARTH}),
	SMOKE_RUNE(ItemID.SMOKERUNE, new RuneType[]{RuneType.AIR, RuneType.FIRE}),
	STEAM_RUNE(ItemID.STEAMRUNE, new RuneType[]{RuneType.WATER, RuneType.FIRE}),
	LAVA_RUNE(ItemID.LAVARUNE, new RuneType[]{RuneType.EARTH, RuneType.FIRE}),
	AETHER_RUNE(ItemID.AETHERRUNE, new RuneType[]{RuneType.SOUL, RuneType.COSMIC});

	@Getter
	private final int id;

	@Getter
	private final RuneType[] matchingTypes;

	private static final Map<Integer, RuneItem> RUNE_ITEM_MAP;

	static
	{
		ImmutableMap.Builder<Integer, RuneItem> builder = new ImmutableMap.Builder<>();

		for (RuneItem item : values())
		{
			builder.put(item.getId(), item);
		}
		RUNE_ITEM_MAP = builder.build();
	}

	public static RuneItem getRuneItem(int itemId)
	{
		return RUNE_ITEM_MAP.getOrDefault(itemId, null);
	}
}

package com.autocasting.datatypes;

import lombok.Data;

/**
 * A "tuple" of RuneType and a quantity,
 * in other words the amount of a certain rune to cast a spell
 */
@Data
public class RuneTypeQuantity
{
	private final RuneType runeType;
	private final int quantity;
}

package com.autocasting.datatypes;

/**
 * Base rune types, these are meant to be the costs for certain spells. Physical runes are similar but different,
 * as many different item ids can exist for the same rune (e.g. NMZ runes),
 * and a single id can be two runes at once (combo runes)
 */
public enum RuneType
{
	AIR,
	WATER,
	EARTH,
	FIRE,
	MIND,
	BODY,
	COSMIC,
	CHAOS,
	NATURE,
	LAW,
	DEATH,
	ASTRAL,
	BLOOD,
	SOUL,
	WRATH
}

package com.autocasting;

import com.autocasting.datatypes.Spell;
import com.google.inject.Provides;
import javax.inject.Inject;

import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

/*
TODO: Add remaining spells to AutocastingSpells enum.
TODO: Only show overlay when player is equipping a staff or other autocastable weapon.
*/

@PluginDescriptor(
	name = "Autocasting",
	description = "Tracks your autocast spell and alerts you when it can't be used.",
	tags = {"notifier", "notifications", "mage", "magic", "reduced", "reduction", "level", "drain", "autocasting", "autocast", "cast", "casts", "utilities", "brew", "runes", "tracker", "alert"}
)
public class AutocastingPlugin extends Plugin
{
	@Inject
	private AutocastingState state;

	@Inject
	private AutocastingOverlay autocastOverlay;

	@Inject
	private AutocastingSubscriptions subscriptions;

	@Inject
	private Client client;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Override
	protected void startUp() throws Exception
	{

		eventBus.register(subscriptions);
		clientThread.invoke(this::onStartup);
		overlayManager.add(autocastOverlay);
	}

	@Override
	protected void shutDown() throws Exception
	{
		eventBus.unregister(subscriptions);
		overlayManager.remove(autocastOverlay);
	}

	private void onStartup()
	{
		state.setCurrentAutocastSpell(Spell.NO_SPELL);
	}

	@Provides
	AutocastingConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(AutocastingConfig.class);
	}
}
package com.autocasting;

import com.autocasting.datatypes.Spell;
import net.runelite.api.*;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.VarbitID;

import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;

public class AutocastingClientData
{
	@Inject
	private Client client;

	public int getAutocastVarbit()
	{
		return client.getVarbitValue(VarbitID.AUTOCAST_SPELL);
	}

	public Spell getAutocastSpell()
	{
		int varbitValue = getAutocastVarbit();
		return Spell.getSpell(varbitValue);
	}

	public int getWeaponTypeId()
	{
		return client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);
	}

	// Based off StatusBarsPlugin.java
	public boolean isInCombat()
	{
		final Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null)
		{
			return false;
		}
		final Actor interacting = localPlayer.getInteracting();
		boolean fightingNPC = interacting instanceof NPC && ArrayUtils.contains(((NPC) interacting).getComposition().getActions(), "Attack");
		boolean fightingPlayer = interacting instanceof Player && client.getVarbitValue(VarbitID.PVP_AREA_CLIENT) == 1;
		return fightingNPC || fightingPlayer;
	}

	public int getGameTick()
	{
		return client.getTickCount();
	}

	public int fps()
	{
		return client.getFPS();
	}

	public EnumComposition getRunepouchEnum()
	{
		return client.getEnum(EnumID.RUNEPOUCH_RUNE);
	}

	public int varbitValue(int varbit)
	{
		return client.getVarbitValue(varbit);
	}

	public ItemContainer getInventory()
	{
		return client.getItemContainer(InventoryID.INV);
	}

	public ItemContainer getEquipment()
	{
		return client.getItemContainer(InventoryID.WORN);
	}
}

/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.autocasting.dependencies.attackstyles;

import lombok.Getter;
import net.runelite.api.Skill;

public enum AttackStyle
{
	ACCURATE("Accurate", Skill.ATTACK),
	AGGRESSIVE("Aggressive", Skill.STRENGTH),
	DEFENSIVE("Defensive", Skill.DEFENCE),
	CONTROLLED("Controlled", Skill.ATTACK, Skill.STRENGTH, Skill.DEFENCE),
	RANGING("Ranging", Skill.RANGED),
	LONGRANGE("Longrange", Skill.RANGED, Skill.DEFENCE),
	CASTING("Casting", Skill.MAGIC),
	DEFENSIVE_CASTING("Defensive Casting", Skill.MAGIC, Skill.DEFENCE),
	OTHER("Other");

	@Getter
	private final String name;
	@Getter
	private final Skill[] skills;

	AttackStyle(String name, Skill... skills)
	{
		this.name = name;
		this.skills = skills;
	}
}
/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.autocasting.dependencies.attackstyles;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import java.util.Map;
import lombok.Getter;
import static com.autocasting.dependencies.attackstyles.AttackStyle.ACCURATE;
import static com.autocasting.dependencies.attackstyles.AttackStyle.AGGRESSIVE;
import static com.autocasting.dependencies.attackstyles.AttackStyle.CASTING;
import static com.autocasting.dependencies.attackstyles.AttackStyle.CONTROLLED;
import static com.autocasting.dependencies.attackstyles.AttackStyle.DEFENSIVE;
import static com.autocasting.dependencies.attackstyles.AttackStyle.DEFENSIVE_CASTING;
import static com.autocasting.dependencies.attackstyles.AttackStyle.LONGRANGE;
import static com.autocasting.dependencies.attackstyles.AttackStyle.OTHER;
import static com.autocasting.dependencies.attackstyles.AttackStyle.RANGING;

public enum WeaponType
{
	TYPE_0(ACCURATE, AGGRESSIVE, null, DEFENSIVE),
	TYPE_1(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
	TYPE_2(ACCURATE, AGGRESSIVE, null, DEFENSIVE),
	TYPE_3(RANGING, RANGING, null, LONGRANGE),
	TYPE_4(ACCURATE, AGGRESSIVE, CONTROLLED, DEFENSIVE),
	TYPE_5(RANGING, RANGING, null, LONGRANGE),
	TYPE_6(AGGRESSIVE, RANGING, CASTING, null),
	TYPE_7(RANGING, RANGING, null, LONGRANGE),
	TYPE_8(OTHER, AGGRESSIVE, null, null),
	TYPE_9(ACCURATE, AGGRESSIVE, CONTROLLED, DEFENSIVE),
	TYPE_10(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
	TYPE_11(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
	TYPE_12(CONTROLLED, AGGRESSIVE, null, DEFENSIVE),
	TYPE_13(ACCURATE, AGGRESSIVE, null, DEFENSIVE),
	TYPE_14(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
	TYPE_15(CONTROLLED, CONTROLLED, CONTROLLED, DEFENSIVE),
	TYPE_16(ACCURATE, AGGRESSIVE, CONTROLLED, DEFENSIVE),
	TYPE_17(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
	TYPE_18(ACCURATE, AGGRESSIVE, null, DEFENSIVE, CASTING, DEFENSIVE_CASTING),
	TYPE_19(RANGING, RANGING, null, LONGRANGE),
	TYPE_20(ACCURATE, CONTROLLED, null, DEFENSIVE),
	TYPE_21(ACCURATE, AGGRESSIVE, null, DEFENSIVE, CASTING, DEFENSIVE_CASTING),
	TYPE_22(ACCURATE, AGGRESSIVE, null, DEFENSIVE, CASTING, DEFENSIVE_CASTING),  // Blue Moon Staff
	TYPE_23(CASTING, CASTING, null, DEFENSIVE_CASTING),
	TYPE_24(ACCURATE, AGGRESSIVE, CONTROLLED, DEFENSIVE),
	TYPE_25(CONTROLLED, AGGRESSIVE, null, DEFENSIVE),
	TYPE_26(AGGRESSIVE, AGGRESSIVE, null, AGGRESSIVE),
	TYPE_27(ACCURATE, null, null, OTHER),
	TYPE_28(ACCURATE, ACCURATE, null, LONGRANGE),
	TYPE_29(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE);

	@Getter
	private final AttackStyle[] attackStyles;

	private static final Map<Integer, WeaponType> weaponTypes;

	static
	{
		ImmutableMap.Builder<Integer, WeaponType> builder = new ImmutableMap.Builder<>();

		for (WeaponType weaponType : values())
		{
			builder.put(weaponType.ordinal(), weaponType);
		}

		weaponTypes = builder.build();
	}

	WeaponType(AttackStyle... attackStyles)
	{
		Preconditions.checkArgument(attackStyles.length == 4 || attackStyles.length == 6,
			"WeaponType " + this + " does not have exactly 4 or 6 attack style arguments");
		this.attackStyles = attackStyles;
	}

	public static WeaponType getWeaponType(int id)
	{
		return weaponTypes.get(id);
	}
}
package com.autocasting;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class AutocastingPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(AutocastingPlugin.class);
		RuneLite.main(args);
	}
}
