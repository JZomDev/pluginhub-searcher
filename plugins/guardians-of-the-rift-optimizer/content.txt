package com.hawolt.gotr.data;

public enum MinigameState {
    INITIALIZING, START, ACTIVE, COMPLETE, CLOSED, CLOSING, UNKNOWN
}

package com.hawolt.gotr.data;

public enum TypeAssociation {
    ELEMENTAL, CATALYTIC
}

package com.hawolt.gotr.data;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;

@Getter
public enum Obelisk {
    AIR(43701, 1, 4, ItemID.GOTR_PORTAL_TALISMAN_AIR, TypeAssociation.ELEMENTAL, ChargeableCellType.WEAK),
    MIND(43705, 1, 12, ItemID.GOTR_PORTAL_TALISMAN_MIND, TypeAssociation.CATALYTIC, ChargeableCellType.WEAK),
    WATER(43702, 2, 9, ItemID.GOTR_PORTAL_TALISMAN_WATER, TypeAssociation.ELEMENTAL, ChargeableCellType.MEDIUM),
    EARTH(43703, 3, 11, ItemID.GOTR_PORTAL_TALISMAN_EARTH, TypeAssociation.ELEMENTAL, ChargeableCellType.STRONG),
    FIRE(43704, 4, 11, ItemID.GOTR_PORTAL_TALISMAN_FIRE, TypeAssociation.ELEMENTAL, ChargeableCellType.OVERCHARGED),
    BODY(43709, 2, 5, ItemID.GOTR_PORTAL_TALISMAN_BODY, TypeAssociation.CATALYTIC, ChargeableCellType.WEAK),
    COSMIC(43710, 3, 19, ItemID.GOTR_PORTAL_TALISMAN_COSMIC, TypeAssociation.CATALYTIC, ChargeableCellType.MEDIUM),
    CHAOS(43706, 4, 10, ItemID.GOTR_PORTAL_TALISMAN_CHAOS, TypeAssociation.CATALYTIC, ChargeableCellType.MEDIUM),
    NATURE(43711, 5, 5, ItemID.GOTR_PORTAL_TALISMAN_NATURE, TypeAssociation.CATALYTIC, ChargeableCellType.STRONG),
    LAW(43712, 6, 13, ItemID.GOTR_PORTAL_TALISMAN_LAW, TypeAssociation.CATALYTIC, ChargeableCellType.STRONG),
    DEATH(43707, 7, 6, ItemID.GOTR_PORTAL_TALISMAN_DEATH, TypeAssociation.CATALYTIC, ChargeableCellType.OVERCHARGED),
    BLOOD(43708, 8, 6, ItemID.GOTR_PORTAL_TALISMAN_BLOOD, TypeAssociation.CATALYTIC, ChargeableCellType.OVERCHARGED);
    private final int gameObjectId, indexId, tileDistance, talismanItemId;
    private final TypeAssociation typeAssociation;
    private final ChargeableCellType cellType;

    Obelisk(int gameObjectId, int indexId, int tileDistance, int talismanItemId, TypeAssociation typeAssociation, ChargeableCellType cellType) {
        this.typeAssociation = typeAssociation;
        this.talismanItemId = talismanItemId;
        this.tileDistance = tileDistance;
        this.gameObjectId = gameObjectId;
        this.cellType = cellType;
        this.indexId = indexId;
    }

    public static final Obelisk[] VALUES = Obelisk.values();

    public static Obelisk getByTalismanItemId(int talismanItemId) {
        for (Obelisk obelisk : VALUES) {
            if (obelisk.talismanItemId == talismanItemId) return obelisk;
        }
        return null;
    }

    public static Obelisk getObeliskByRuneIndexId(TypeAssociation association, int indexId) {
        for (Obelisk obelisk : VALUES) {
            if (obelisk.typeAssociation != association) continue;
            if (obelisk.indexId == indexId) return obelisk;
        }
        return null;
    }

    public static Obelisk getObeliskByGameObjectId(int gameObjectId) {
        for (Obelisk obelisk : VALUES) {
            if (obelisk.gameObjectId == gameObjectId) return obelisk;
        }
        return null;
    }
}

package com.hawolt.gotr.data;

import com.google.common.collect.ImmutableSet;
import net.runelite.api.GameState;

import java.util.Arrays;
import java.util.Set;
import java.util.stream.Collectors;

public class StaticConstant {

    // REGEXP
    public static String MINIGAME_POINT_STATUS_TOTAL =
            "Total elemental energy:[^>]+>([\\d,]+).*Total catalytic energy:[^>]+>([\\d,]+).*?\\.";
    public static String MINIGAME_POINT_STATUS_GAINED =
            "Elemental energy attuned:[^>]+>([\\d,]+).*Catalytic energy attuned:[^>]+>([\\d,]+).*?\\.";
    public static String MINIGAME_POINT_STATUS_CHECKUP =
            "You have (\\d+) catalytic energy and (\\d+) elemental energy";

    // GAME MISC
    public static final long GAME_TICK_DURATION = 600L;
    public static final int INVENTORY_CONTAINER_ID = 93;
    public static final int BINDING_NECKLACE_VARP_ID = 487;
    public static final int BINDING_NECKLACE_ITEM_ID = 5521;
    public static final int MINIGAME_PORTAL_SPRITE_ID = 4368;
    public static final int GAME_DIALOG_WIDGET_GROUP = 229;
    public static final int GAME_DIALOG_WIDGET_CONTENT = 1;

    // RUNECRAFT ALTAR IDS
    public static final int RUNECRAFTING_ALTAR_AIR = 34760;
    public static final int RUNECRAFTING_ALTAR_COSMIC = 34766;
    public static final int RUNECRAFTING_ALTAR_WATER = 34762;
    public static final int RUNECRAFTING_ALTAR_EARTH = 34763;
    public static final int RUNECRAFTING_ALTAR_NATURE = 34768;
    public static final int RUNECRAFTING_ALTAR_FIRE = 34764;
    public static final int RUNECRAFTING_ALTAR_BLOOD = 43479;
    public static final int RUNECRAFTING_ALTAR_LAW = 34676;
    public static final int RUNECRAFTING_ALTAR_DEATH = 34770;
    public static final int RUNECRAFTING_ALTAR_CHAOS = 34769;
    public static final int RUNECRAFTING_ALTAR_BODY = 34765;
    public static final int RUNECRAFTING_ALTAR_MIND = 34761;

    // MINIGAME INTERNALS
    public static final int MINIGAME_REGION_ID = 14484;
    public static final int MINIGAME_HUD_UPDATE_SCRIPT_ID = 5980;
    public static final int MINIGAME_ACTIVE_GUARDIAN_ANIMATION_ID = 9363;

    // MINIGAME WIDGET INDICES
    public static final int MINIGAME_WIDGET_GROUP_ID = 746;
    public static final int MINIGAME_WIDGET_CHILD_GAME_ID = 1;
    public static final int MINIGAME_WIDGET_POWER_TEXT_WIDGET_ID = 18;
    public static final int MINIGAME_WIDGET_ELEMENTAL_TEXT_WIDGET_ID = 21;
    public static final int MINIGAME_WIDGET_CATALYTIC_TEXT_WIDGET_ID = 24;

    // MINIGAME WIDGETS IDS
    public static final int MINIGAME_WIDGET_PARENT_ID = 48889858;
    public static final int MINIGAME_WIDGET_PORTAL_ID = 48889882;
    public static final int MINIGAME_WIDGET_GUARDIAN_ID = 48889881;

    // MINIGAME OBJECTS
    public static final int MINIGAME_GREAT_GUARDIAN_NPC_ID = 11403;
    public static final int MINIGAME_PORTAL_OBJECT_ID = 43729;
    public static final int MINIGAME_UNCHARGED_CELL_TABLE_OBJECT_ID = 43732;
    public static final int MINIGAME_DEPOSIT_POOL_ID = 43696;

    // MINIGAME ITEM GROUP: GUARDIAN STONES
    public static final int MINIGAME_GUARDIAN_STONE_ID = 26879;
    public static final int MINIGAME_ELEMENTAL_GUARDIAN_STONE_ID = 26881;
    public static final int MINIGAME_CATALYTIC_GUARDIAN_STONE_ID = 26880;
    public static final int MINIGAME_POLYELEMENTAL_GUARDIAN_STONE_ID = 26941;

    // MINIGAME ITEMS OTHER
    public static final int MINIGAME_UNCHARGED_CELL_ID = 26882;

    // MINIGAME OBELISK OBJECTS
    public static final int MINIGAME_AIR_OBELISK_ID = 43701;
    public static final int MINIGAME_MIND_OBELISK_ID = 43705;
    public static final int MINIGAME_WATER_OBELISK_ID = 43702;
    public static final int MINIGAME_EARTH_OBELISK_ID = 43703;
    public static final int MINIGAME_FIRE_OBELISK_ID = 43704;
    public static final int MINIGAME_BODY_OBELISK_ID = 43709;
    public static final int MINIGAME_COSMIC_OBELISK_ID = 43710;
    public static final int MINIGAME_CHAOS_OBELISK_ID = 43706;
    public static final int MINIGAME_NATURE_OBELISK_ID = 43711;
    public static final int MINIGAME_LAW_OBELISK_ID = 43712;
    public static final int MINIGAME_DEATH_OBELISK_ID = 43707;
    public static final int MINIGAME_BLOOD_OBELISK_ID = 43708;

    // UTILITY DATA SETS
    public static final Set<Integer> MINIGAME_GUARDIAN_STONE_IDS = ImmutableSet.of(
            MINIGAME_ELEMENTAL_GUARDIAN_STONE_ID,
            MINIGAME_CATALYTIC_GUARDIAN_STONE_ID,
            MINIGAME_POLYELEMENTAL_GUARDIAN_STONE_ID
    );

    public static final Set<Integer> MINIGAME_CHARGED_CELL_IDS = Arrays.stream(ChargeableCellType.VALUES)
            .mapToInt(ChargeableCellType::getItemId)
            .boxed()
            .collect(Collectors.toSet());

    public static final Set<Integer> MINIGAME_TALISMAN_IDS = Arrays.stream(Obelisk.VALUES)
            .mapToInt(Obelisk::getTalismanItemId)
            .boxed()
            .collect(Collectors.toSet());

    public static final Set<Integer> MINIGAME_CELL_TILE_IDS = Arrays.stream(CellTile.VALUES)
            .mapToInt(CellTile::getGroundObjectId)
            .boxed()
            .collect(Collectors.toSet());

    public static final Set<Integer> MINIGAME_IDS_OBELISK_ID = Arrays.stream(Obelisk.VALUES)
            .mapToInt(Obelisk::getGameObjectId)
            .boxed()
            .collect(Collectors.toSet());

    public static final Set<GameState> VOLATILE_GAME_STATES = ImmutableSet.of(
            GameState.CONNECTION_LOST,
            GameState.HOPPING,
            GameState.LOADING
    );
}

package com.hawolt.gotr.data;

import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

@Getter
public enum Pouch {
    SMALL(ItemID.RCU_POUCH_SMALL, VarbitID.SMALL_ESSENCE_POUCH),
    MEDIUM(ItemID.RCU_POUCH_SMALL, VarbitID.MEDIUM_ESSENCE_POUCH),
    LARGE(ItemID.RCU_POUCH_SMALL, VarbitID.LARGE_ESSENCE_POUCH),
    GIANT(ItemID.RCU_POUCH_SMALL, VarbitID.GIANT_ESSENCE_POUCH),
    COLOSSAL(ItemID.RCU_POUCH_SMALL, VarbitID.COLOSSAL_ESSENCE_POUCH);

    private final int itemId, varbitId;

    Pouch(int itemId, int varbitId) {
        this.varbitId = varbitId;
        this.itemId = itemId;
    }

    public int getStoredEssenceAmount(Client client) {
        return client.getVarbitValue(varbitId);
    }

    public static final Pouch[] VALUES = Pouch.values();
}
package com.hawolt.gotr.data;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;

@Getter
public enum ChargeableCellType {
    WEAK(ItemID.GOTR_CELL_TIER1, 30),
    MEDIUM(ItemID.GOTR_CELL_TIER2, 100),
    STRONG(ItemID.GOTR_CELL_TIER3, 180),
    OVERCHARGED(ItemID.GOTR_CELL_TIER4, 250);

    private final int itemId, experienceReward;

    ChargeableCellType(int itemId, int experienceReward) {
        this.experienceReward = experienceReward;
        this.itemId = itemId;
    }

    public static ChargeableCellType[] VALUES = ChargeableCellType.values();

    public static ChargeableCellType byItemId(int itemId) {
        for (ChargeableCellType type : VALUES) {
            if (type.itemId == itemId) return type;
        }
        return null;
    }
}

package com.hawolt.gotr.data;

import lombok.Getter;

@Getter
public enum CellTile {
    WEAK(43740),
    MEDIUM(43741),
    STRONG(43742),
    OVERCHARGED(43743);
    private final int groundObjectId;

    CellTile(int groundObjectId) {
        this.groundObjectId = groundObjectId;
    }

    public static CellTile[] VALUES = CellTile.values();
}

package com.hawolt.gotr.data;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerConfig;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;

@Getter
public enum RuneCraftInfo {
    AIR(
            StaticConstant.MINIGAME_AIR_OBELISK_ID,
            5,
            1,
            ItemID.AIRRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_AIR,
            false,
            null
    ),
    MIND(
            StaticConstant.MINIGAME_MIND_OBELISK_ID,
            5.5,
            2,
            ItemID.MINDRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_MIND,
            false,
            null
    ),
    WATER(
            StaticConstant.MINIGAME_WATER_OBELISK_ID,
            6,
            5,
            ItemID.WATERRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_WATER,
            false,
            null
    ),
    MIST_CRAFTED_ON_AIR(
            StaticConstant.MINIGAME_AIR_OBELISK_ID,
            8,
            6,
            ItemID.MISTRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_AIR,
            true,
            RuneCraftInfo.AIR
    ),
    MIST_CRAFTED_ON_WATER(
            StaticConstant.MINIGAME_WATER_OBELISK_ID,
            8.5,
            6,
            ItemID.MISTRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_WATER,
            true,
            RuneCraftInfo.WATER
    ),
    EARTH(
            StaticConstant.MINIGAME_EARTH_OBELISK_ID,
            6.5,
            9,
            ItemID.EARTHRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_EARTH,
            false,
            null
    ),
    DUST_CRAFTED_ON_AIR(
            StaticConstant.MINIGAME_AIR_OBELISK_ID,
            8.3,
            10,
            ItemID.DUSTRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_AIR,
            true,
            RuneCraftInfo.AIR
    ),
    DUST_CRAFTED_ON_EARTH(
            StaticConstant.MINIGAME_EARTH_OBELISK_ID,
            9,
            10,
            ItemID.DUSTRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_EARTH,
            true,
            RuneCraftInfo.EARTH
    ),
    MUD_CRAFTED_ON_WATER(
            StaticConstant.MINIGAME_WATER_OBELISK_ID,
            9.3,
            13,
            ItemID.MUDRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_WATER,
            true,
            RuneCraftInfo.WATER
    ),
    MUD_CRAFTED_ON_EARTH(
            StaticConstant.MINIGAME_EARTH_OBELISK_ID,
            9.5,
            13,
            ItemID.MUDRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_EARTH,
            true,
            RuneCraftInfo.EARTH
    ),
    FIRE(
            StaticConstant.MINIGAME_FIRE_OBELISK_ID,
            7,
            14,
            ItemID.FIRERUNE,
            StaticConstant.RUNECRAFTING_ALTAR_FIRE,
            false,
            null
    ),
    SMOKE_CRAFTED_ON_AIR(
            StaticConstant.MINIGAME_AIR_OBELISK_ID,
            8.5,
            15,
            ItemID.SMOKERUNE,
            StaticConstant.RUNECRAFTING_ALTAR_AIR,
            true,
            RuneCraftInfo.AIR
    ),
    SMOKE_CRAFTED_ON_FIRE(
            StaticConstant.MINIGAME_FIRE_OBELISK_ID,
            9.5,
            15,
            ItemID.SMOKERUNE,
            StaticConstant.RUNECRAFTING_ALTAR_FIRE,
            true,
            RuneCraftInfo.FIRE
    ),
    STEAM_CRAFTED_ON_WATER(
            StaticConstant.MINIGAME_WATER_OBELISK_ID,
            9.3,
            19,
            ItemID.STEAMRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_WATER,
            true,
            RuneCraftInfo.WATER
    ),
    STEAM_CRAFTED_ON_FIRE(
            StaticConstant.MINIGAME_FIRE_OBELISK_ID,
            10,
            19,
            ItemID.STEAMRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_FIRE,
            true,
            RuneCraftInfo.FIRE
    ),
    BODY(
            StaticConstant.MINIGAME_BODY_OBELISK_ID,
            7.5,
            20,
            ItemID.BODYRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_BODY,
            false,
            null
    ),
    LAVA_CRAFTED_ON_EARTH(
            StaticConstant.MINIGAME_EARTH_OBELISK_ID,
            10,
            23,
            ItemID.LAVARUNE,
            StaticConstant.RUNECRAFTING_ALTAR_EARTH,
            true,
            RuneCraftInfo.EARTH
    ),
    LAVA_CRAFTED_ON_FIRE(
            StaticConstant.MINIGAME_FIRE_OBELISK_ID,
            10.5,
            23,
            ItemID.LAVARUNE,
            StaticConstant.RUNECRAFTING_ALTAR_FIRE,
            true,
            RuneCraftInfo.FIRE
    ),
    COSMIC(
            StaticConstant.MINIGAME_COSMIC_OBELISK_ID,
            8,
            27,
            ItemID.COSMICRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_COSMIC,
            false,
            null
    ),
    CHAOS(
            StaticConstant.MINIGAME_CHAOS_OBELISK_ID,
            8.5,
            35,
            ItemID.CHAOSRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_CHAOS,
            false,
            null
    ),
    NATURE(
            StaticConstant.MINIGAME_NATURE_OBELISK_ID,
            9,
            44,
            ItemID.NATURERUNE,
            StaticConstant.RUNECRAFTING_ALTAR_NATURE,
            false,
            null
    ),
    LAW(
            StaticConstant.MINIGAME_LAW_OBELISK_ID,
            9.5,
            54,
            ItemID.LAWRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_LAW,
            false,
            null
    ),
    DEATH(
            StaticConstant.MINIGAME_DEATH_OBELISK_ID,
            10,
            65,
            ItemID.DEATHRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_DEATH,
            false,
            null
    ),
    BLOOD(
            StaticConstant.MINIGAME_BLOOD_OBELISK_ID,
            10.5,
            77,
            ItemID.BLOODRUNE,
            StaticConstant.RUNECRAFTING_ALTAR_BLOOD,
            false,
            null
    );

    private final int guardianGameObjectId, levelRequired, spriteId, altarId;
    private final RuneCraftInfo baseRuneCraftInfo;
    private final boolean isCombinationRune;
    private final double baseExperience;

    RuneCraftInfo(
            int guardianGameObjectId,
            double baseExperience,
            int levelRequired,
            int spriteId,
            int altarId,
            boolean isCombinationRune,
            RuneCraftInfo baseRuneCraftInfo
    ) {
        this.guardianGameObjectId = guardianGameObjectId;
        this.baseRuneCraftInfo = baseRuneCraftInfo;
        this.isCombinationRune = isCombinationRune;
        this.baseExperience = baseExperience;
        this.levelRequired = levelRequired;
        this.spriteId = spriteId;
        this.altarId = altarId;
    }

    @Override
    public String toString() {
        return name().split("_")[0];
    }

    public static RuneCraftInfo find(GuardianOfTheRiftOptimizerConfig config, int altarId) {
        switch (altarId) {
            case StaticConstant.RUNECRAFTING_ALTAR_AIR:
                return config.airAltar().relation;
            case StaticConstant.RUNECRAFTING_ALTAR_MIND:
                return RuneCraftInfo.MIND;
            case StaticConstant.RUNECRAFTING_ALTAR_WATER:
                return config.waterAltar().relation;
            case StaticConstant.RUNECRAFTING_ALTAR_EARTH:
                return config.earthAltar().relation;
            case StaticConstant.RUNECRAFTING_ALTAR_FIRE:
                return config.fireAltar().relation;
            case StaticConstant.RUNECRAFTING_ALTAR_BODY:
                return RuneCraftInfo.BODY;
            case StaticConstant.RUNECRAFTING_ALTAR_COSMIC:
                return RuneCraftInfo.COSMIC;
            case StaticConstant.RUNECRAFTING_ALTAR_CHAOS:
                return RuneCraftInfo.CHAOS;
            case StaticConstant.RUNECRAFTING_ALTAR_NATURE:
                return RuneCraftInfo.NATURE;
            case StaticConstant.RUNECRAFTING_ALTAR_LAW:
                return RuneCraftInfo.LAW;
            case StaticConstant.RUNECRAFTING_ALTAR_DEATH:
                return RuneCraftInfo.DEATH;
            case StaticConstant.RUNECRAFTING_ALTAR_BLOOD:
                return RuneCraftInfo.BLOOD;
            default:
                return null;
        }
    }

    public static RuneCraftInfo find(GuardianOfTheRiftOptimizerConfig config, Obelisk obelisk) {
        switch (obelisk) {
            case AIR:
                return config.airAltar().relation;
            case MIND:
                return RuneCraftInfo.MIND;
            case WATER:
                return config.waterAltar().relation;
            case EARTH:
                return config.earthAltar().relation;
            case FIRE:
                return config.fireAltar().relation;
            case BODY:
                return RuneCraftInfo.BODY;
            case COSMIC:
                return RuneCraftInfo.COSMIC;
            case CHAOS:
                return RuneCraftInfo.CHAOS;
            case NATURE:
                return RuneCraftInfo.NATURE;
            case LAW:
                return RuneCraftInfo.LAW;
            case DEATH:
                return RuneCraftInfo.DEATH;
            case BLOOD:
                return RuneCraftInfo.BLOOD;
            default:
                throw new IllegalArgumentException("Unknown Obelisk: " + obelisk);
        }
    }

    public static final RuneCraftInfo[] VALUES = RuneCraftInfo.values();
}

package com.hawolt.gotr.data;

import lombok.Getter;

@Getter
public enum EssencePile {
    ELEMENTAL_ESSENCE_PILE(43722, TypeAssociation.ELEMENTAL),
    CATALYTIC_ESSENCE_PILE(43723, TypeAssociation.CATALYTIC);
    private final TypeAssociation typeAssociation;
    private final int gameObjectId;

    EssencePile(int gameObjectId, TypeAssociation typeAssociation) {
        this.typeAssociation = typeAssociation;
        this.gameObjectId = gameObjectId;
    }
}

package com.hawolt.gotr.data;

public enum ObeliskType {
    OPTIMAL, SECONDARY
}

package com.hawolt.gotr;

import com.google.inject.Provides;
import com.hawolt.gotr.overlay.*;
import com.hawolt.gotr.slices.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;

import javax.inject.Inject;
import javax.inject.Named;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

@Slf4j
@PluginDescriptor(
        name = "Guardians of the Rift Optimizer",
        description = "Various utilities to improve and optimize the Guardians of the Rift minigame",
        tags = {"minigame", "overlay", "guardians of the rift", "gotr", "minmax", "ehp"}
)
public class GuardianOfTheRiftOptimizerPlugin extends Plugin {

    @Getter
    @Inject
    @Named("developerMode")
    private boolean developerMode;

    @Inject
    @Getter(AccessLevel.PUBLIC)
    private GuardianOfTheRiftOptimizerConfig config;

    @Inject
    @Getter(AccessLevel.PUBLIC)
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private EventBus bus;

    // DEBUG SLICE

    @Inject
    private EventDebugSlice eventDebugSlice;

    // PLUGIN SLICES

    @Inject
    @Getter(AccessLevel.PUBLIC)
    private InventorySlice inventoryEssenceSlice;

    @Inject
    @Getter(AccessLevel.PUBLIC)
    private BindingNecklaceSlice bindingNecklaceSlice;

    @Inject
    @Getter(AccessLevel.PUBLIC)
    private PouchEssenceSlice pouchEssenceSlice;

    @Inject
    @Getter(AccessLevel.PUBLIC)
    private PathfinderSlice pathfinderSlice;

    @Inject
    @Getter(AccessLevel.PUBLIC)
    private EquipmentSlice equipmentSlice;

    @Inject
    private BindingNecklaceIndicatorOverlay bindingNecklaceIndicatorOverlay;

    @Inject
    private HighlightGreatGuardianOverlay highlightGreatGuardianOverlay;

    @Inject
    private HighlightCellTableOverlay highlightCellTableOverlay;

    @Inject
    private HighlightCellTileOverlay highlightCellTileOverlay;

    @Inject
    private HighlightDepositPoolOverlay depositPoolOverlay;

    @Inject
    private HighlightPortalOverlay highlightPortalOverlay;

    @Inject
    private NecklaceWarningOverlay necklaceWarningOverlay;

    @Inject
    private TickTimestampSlice tickTimestampSlice;

    @Inject
    private PointStatusOverlay pointStatusOverlay;

    @Inject
    private RenderSafetySlice renderSafetySlice;

    @Inject
    private StartTimeOverlay startTimeOverlay;

    @Inject
    private MenuOptionSlice menuOptionSlice;

    @Inject
    private MinigameSlice minigameSlice;

    @Inject
    private ObeliskSlice obeliskSlice;

    @Inject
    private MuteSlice muteSlice;

    // OVERLAY

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private PortalIndicatorOverlay portalIndicatorOverlay;

    @Inject
    private HighlightObeliskOverlay highlightGuardianOverlay;

    @Inject
    private InternalDebugOverlay debugOverlay;

    // PLUGIN LOGIC

    @Getter(AccessLevel.NONE)
    private final Set<Slice> slices = new HashSet<>();

    public void add(Slice... slices) {
        this.slices.addAll(Arrays.asList(slices));
    }

    @Override
    protected void startUp() throws Exception {
        if (developerMode) this.add(eventDebugSlice);
        this.add(
                bindingNecklaceIndicatorOverlay,
                highlightGreatGuardianOverlay,
                highlightCellTableOverlay,
                highlightGuardianOverlay,
                highlightCellTileOverlay,
                highlightPortalOverlay,
                necklaceWarningOverlay,
                portalIndicatorOverlay,
                inventoryEssenceSlice,
                bindingNecklaceSlice,
                pointStatusOverlay,
                depositPoolOverlay,
                tickTimestampSlice,
                renderSafetySlice,
                pouchEssenceSlice,
                startTimeOverlay,
                pathfinderSlice,
                menuOptionSlice,
                equipmentSlice,
                minigameSlice,
                obeliskSlice,
                debugOverlay,
                muteSlice
        );
        for (Slice slice : slices) {
            if (slice.isClientThreadRequiredOnStartup()) {
                this.clientThread.invokeLater(slice::startup);
            } else {
                slice.startup();
            }
            if (slice instanceof AbstractMinigameRenderer) {
                AbstractMinigameRenderer renderer = (AbstractMinigameRenderer) slice;
                this.overlayManager.add(renderer);
            } else if (slice instanceof OverlayPanel) {
                OverlayPanel panel = (OverlayPanel) slice;
                this.overlayManager.add(panel);
            }
        }
    }

    @Override
    protected void shutDown() throws Exception {
        for (Slice slice : slices) {
            if (slice.isClientThreadRequiredOnShutDown()) {
                this.clientThread.invokeLater(slice::shutdown);
            } else {
                slice.shutdown();
            }
            if (slice instanceof AbstractMinigameRenderer) {
                AbstractMinigameRenderer renderer = (AbstractMinigameRenderer) slice;
                this.overlayManager.remove(renderer);
            } else if (slice instanceof OverlayPanel) {
                OverlayPanel panel = (OverlayPanel) slice;
                this.overlayManager.remove(panel);
            }
        }
    }

    @Provides
    GuardianOfTheRiftOptimizerConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(GuardianOfTheRiftOptimizerConfig.class);
    }
}

package com.hawolt.gotr;

public interface Slice {
    void startup();

    void shutdown();

    boolean isClientThreadRequiredOnStartup();

    boolean isClientThreadRequiredOnShutDown();
}
package com.hawolt.gotr;

import net.runelite.api.Client;
import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;

public abstract class AbstractPluginSlice implements Slice {
    @Inject
    protected Client client;
    @Inject
    protected EventBus bus;
    @Inject
    protected GuardianOfTheRiftOptimizerPlugin plugin;

    @Override
    public void startup() {
        this.bus.register(this);
        this.startUp();
    }

    @Override
    public void shutdown() {
        this.bus.unregister(this);
        this.shutDown();
    }

    @Override
    public boolean isClientThreadRequiredOnStartup() {
        return false;
    }

    @Override
    public boolean isClientThreadRequiredOnShutDown() {
        return false;
    }

    protected abstract void startUp();

    protected abstract void shutDown();
}

package com.hawolt.gotr;

import com.hawolt.gotr.data.RuneCraftInfo;
import net.runelite.client.config.*;
import net.runelite.client.ui.overlay.OverlayPosition;

import java.awt.*;

@ConfigGroup("guardiansOfTheRiftOptimizer")
public interface GuardianOfTheRiftOptimizerConfig extends Config {

    @ConfigSection(
            position = 0,
            name = "Rune Configuration",
            description = "Configure which runes you are crafting on the elemental altars"
    )
    String combinationRuneConfiguration = "combinationRuneConfiguration";

    enum AirAlterOptionEnum {
        AIR(RuneCraftInfo.AIR),
        MIST(RuneCraftInfo.MIST_CRAFTED_ON_AIR),
        DUST(RuneCraftInfo.DUST_CRAFTED_ON_AIR),
        SMOKE(RuneCraftInfo.SMOKE_CRAFTED_ON_AIR);
        public final RuneCraftInfo relation;

        AirAlterOptionEnum(final RuneCraftInfo relation) {
            this.relation = relation;
        }
    }

    @ConfigItem(
            position = 0,
            keyName = "airAltar",
            name = "Air Altar",
            description = "The rune to be crafted",
            section = combinationRuneConfiguration
    )
    default AirAlterOptionEnum airAltar() {
        return AirAlterOptionEnum.AIR;
    }

    enum WaterAlterOptionEnum {
        WATER(RuneCraftInfo.WATER),
        MIST(RuneCraftInfo.MIST_CRAFTED_ON_WATER),
        MUD(RuneCraftInfo.MUD_CRAFTED_ON_WATER),
        STEAM(RuneCraftInfo.STEAM_CRAFTED_ON_WATER);
        public final RuneCraftInfo relation;

        WaterAlterOptionEnum(final RuneCraftInfo relation) {
            this.relation = relation;
        }
    }

    @ConfigItem(
            position = 1,
            keyName = "waterAltar",
            name = "Water Altar",
            description = "The rune to be crafted",
            section = combinationRuneConfiguration
    )
    default WaterAlterOptionEnum waterAltar() {
        return WaterAlterOptionEnum.WATER;
    }

    enum EarthAlterOptionEnum {
        EARTH(RuneCraftInfo.EARTH),
        DUST(RuneCraftInfo.DUST_CRAFTED_ON_EARTH),
        MUD(RuneCraftInfo.MUD_CRAFTED_ON_EARTH),
        LAVA(RuneCraftInfo.LAVA_CRAFTED_ON_EARTH);
        public final RuneCraftInfo relation;

        EarthAlterOptionEnum(final RuneCraftInfo relation) {
            this.relation = relation;
        }
    }

    @ConfigItem(
            position = 2,
            keyName = "earthAltar",
            name = "Earth Altar",
            description = "The rune to be crafted",
            section = combinationRuneConfiguration
    )
    default EarthAlterOptionEnum earthAltar() {
        return EarthAlterOptionEnum.EARTH;
    }

    enum FireAlterOptionEnum {
        FIRE(RuneCraftInfo.FIRE),
        SMOKE(RuneCraftInfo.SMOKE_CRAFTED_ON_FIRE),
        STEAM(RuneCraftInfo.STEAM_CRAFTED_ON_FIRE),
        LAVA(RuneCraftInfo.LAVA_CRAFTED_ON_FIRE);
        public final RuneCraftInfo relation;

        FireAlterOptionEnum(final RuneCraftInfo relation) {
            this.relation = relation;
        }
    }

    @ConfigItem(
            position = 3,
            keyName = "fireAltar",
            name = "Fire Altar",
            description = "The rune to be crafted",
            section = combinationRuneConfiguration
    )
    default FireAlterOptionEnum fireAltar() {
        return FireAlterOptionEnum.FIRE;
    }

    @ConfigSection(
            position = 1,
            name = "Optimal Guardian",
            description = "Customize the outline for the Optimal Guardian"
    )
    String optimalGuardianConfiguration = "optimalGuardianConfiguration";

    @ConfigItem(
            keyName = "optimalGuardianTimerEnabled",
            name = "Guardian Despawn Timer",
            description = "Whether to draw a timer for the Guardian Despawn",
            position = 0,
            section = optimalGuardianConfiguration
    )
    default boolean isOptimalGuardianTimerEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "optimalGuardianSpriteEnabled",
            name = "Guardian Rune Sprite",
            description = "Whether to draw the according Rune Sprite",
            position = 1,
            section = optimalGuardianConfiguration
    )
    default boolean isOptimalGuardianSpriteEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "optimalGuardianRunTime",
            name = "Show Time To Guardian",
            description = "Will show you how much time is required to reach the Guardian",
            position = 2,
            section = optimalGuardianConfiguration
    )
    default boolean isOptimalGuardianRunTime() {
        return true;
    }

    @ConfigItem(
            keyName = "optimalGuardianOutlineEnabled",
            name = "Guardian Outline",
            description = "Whether to draw an outline or not",
            position = 3,
            section = optimalGuardianConfiguration
    )
    default boolean isOptimalGuardianOutlineEnabled() {
        return true;
    }

    @Alpha
    @ConfigItem(
            keyName = "optimalGuardianOutlineColor",
            name = "Outline",
            description = "Color of the outline",
            position = 4,
            section = optimalGuardianConfiguration
    )
    default Color optimalGuardianOutlineColor() {
        return new Color(51, 255, 153, 255);
    }


    @Range(
            min = 1,
            max = 5
    )
    @ConfigItem(
            keyName = "optimalGuardianOutlineWidth",
            name = "Outline width",
            description = "Width for the outline to be drawn",
            position = 5,
            section = optimalGuardianConfiguration
    )
    default int optimalGuardianOutlineWidth() {
        return 5;
    }

    @Range(
            min = 1,
            max = 5
    )
    @ConfigItem(
            keyName = "optimalGuardianOutlineFeatherDistance",
            name = "Feather Distance",
            description = "Smoothing distance for the outline",
            position = 6,
            section = optimalGuardianConfiguration
    )
    default int optimalGuardianOutlineFeatherDistance() {
        return 3;
    }

    @ConfigSection(
            position = 2,
            name = "Secondary Guardian",
            description = "Customize the outline for the Secondary Guardian"
    )
    String secondaryGuardianConfiguration = "secondaryGuardianConfiguration";

    @ConfigItem(
            keyName = "secondaryGuardianTimerEnabled",
            name = "Guardian Despawn Timer",
            description = "Whether to draw a timer for the Guardian Despawn",
            position = 0,
            section = secondaryGuardianConfiguration
    )
    default boolean isSecondaryGuardianTimerEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "secondaryGuardianSpriteEnabled",
            name = "Guardian Rune Sprite",
            description = "Whether to draw the according Rune Sprite",
            position = 1,
            section = secondaryGuardianConfiguration
    )
    default boolean isSecondaryGuardianSpriteEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "secondaryGuardianRunTime",
            name = "Show Time To Guardian",
            description = "Will show you how much time is required to reach the Guardian",
            position = 2,
            section = secondaryGuardianConfiguration
    )
    default boolean isSecondaryGuardianRunTime() {
        return true;
    }

    @ConfigItem(
            keyName = "secondaryGuardianOutlineEnabled",
            name = "Guardian Outline",
            description = "Whether to draw an outline or not",
            position = 3,
            section = secondaryGuardianConfiguration
    )
    default boolean isSecondaryGuardianOutlineEnabled() {
        return true;
    }

    @Alpha
    @ConfigItem(
            keyName = "secondaryGuardianOutlineColor",
            name = "Outline",
            description = "Color of the outline",
            position = 4,
            section = secondaryGuardianConfiguration
    )
    default Color secondaryGuardianOutlineColor() {
        return new Color(255, 255, 255, 204);
    }


    @Range(
            min = 1,
            max = 5
    )
    @ConfigItem(
            keyName = "secondaryGuardianOutlineWidth",
            name = "Outline width",
            description = "Width for the outline to be drawn",
            position = 5,
            section = secondaryGuardianConfiguration
    )
    default int secondaryGuardianOutlineWidth() {
        return 3;
    }

    @Range(
            min = 1,
            max = 5
    )
    @ConfigItem(
            keyName = "secondaryGuardianOutlineFeatherDistance",
            name = "Feather Distance",
            description = "Smoothing distance for the outline",
            position = 6,
            section = secondaryGuardianConfiguration
    )
    default int secondaryGuardianOutlineFeatherDistance() {
        return 5;
    }

    @ConfigSection(
            position = 3,
            name = "Menu Swapping",
            description = "Hide specific Menu Options if conditions match"
    )
    String menuSwappingConfiguration = "menuSwappingConfiguration";

    @ConfigItem(
            keyName = "hideApprenticeTalkTo",
            name = "Hide Talk-to",
            description = "Hides the left click Talk-to option on the Apprentices",
            position = 0,
            section = menuSwappingConfiguration
    )
    default boolean isHideApprenticeTalkTo() {
        return true;
    }

    @ConfigItem(
            keyName = "hideGuardianPowerUp",
            name = "Hide Power-Up",
            description = "Hides the left click Power-up option when there is no essence in the inventory",
            position = 1,
            section = menuSwappingConfiguration
    )
    default boolean isHideGuardianPowerUp() {
        return true;
    }

    @ConfigItem(
            keyName = "hideGroundItemPlaceCell",
            name = "Hide Place-cell",
            description = "Hides the left click Place-cell option when there is no cell in the inventory",
            position = 2,
            section = menuSwappingConfiguration
    )
    default boolean isHideGroundItemPlaceCell() {
        return true;
    }

    @ConfigItem(
            keyName = "hideGuardianAssembleNoMaterial",
            name = "Hide Assemble (Chisel/Cell)",
            description = "Hides the left click Assemble option if you have no Chisel or Cell",
            position = 3,
            section = menuSwappingConfiguration
    )
    default boolean isHideGuardianAssembleNoMaterial() {
        return true;
    }

    @ConfigItem(
            keyName = "hideGuardianAssembleAllActive",
            name = "Hide Assemble (10 Guardian)",
            description = "Hides the left click Assemble option if all Guardians are active",
            position = 4,
            section = menuSwappingConfiguration
    )
    default boolean isHideGuardianAssembleAllActive() {
        return true;
    }

    @ConfigItem(
            keyName = "hideUseOptionOnPlayer",
            name = "Hide Use on Player for Runes",
            description = "Hides the Use Option on other Players for any rune",
            position = 5,
            section = menuSwappingConfiguration
    )
    default boolean isHideUseOptionOnPlayer() {
        return false;
    }

    @ConfigItem(
            keyName = "hideDepositPoolDepositOption",
            name = "Hide Deposit (Deposit Pool)",
            description = "Hides the left click Deposit option",
            position = 6,
            section = menuSwappingConfiguration
    )
    default boolean isHideDepositPoolDepositOption() {
        return false;
    }

    @ConfigItem(
            keyName = "hideRunesUseOption",
            name = "Hide Use in Minigame (Runes)",
            description = "Hides the left click Use option",
            position = 7,
            section = menuSwappingConfiguration
    )
    default boolean isHideRuneUseInMinigame() {
        return false;
    }

    @ConfigSection(
            position = 4,
            name = "Miscellaneous",
            description = "Various Quality of Life options"
    )
    String miscellaneousConfiguration = "miscellaneousConfiguration";

    @ConfigItem(
            keyName = "hideApprenticeHelpMessages",
            name = "Mute Apprentice Instructions",
            description = "Mutes help messages from the Apprentices",
            position = 0,
            section = miscellaneousConfiguration
    )
    default boolean isHideApprenticeHelpMessages() {
        return true;
    }

    @ConfigItem(
            keyName = "showGameStartTimer",
            name = "Game Start Timer",
            description = "Replace Guardian Power Bar with a Game Start timer when applicable",
            position = 1,
            section = miscellaneousConfiguration
    )
    default boolean isShowGameStartTimer() {
        return true;
    }

    @ConfigItem(
            keyName = "showTimeSinceLastPortal",
            name = "Time since last Portal",
            description = "Display the time that has elapsed since the last Portal has despawned",
            position = 2,
            section = miscellaneousConfiguration
    )
    default boolean isShowTimeSinceLastPortal() {
        return true;
    }

    @ConfigItem(
            keyName = "showBindingNecklaceStatus",
            name = "Binding Necklace Info",
            description = "Display an indicator whether your Binding Necklace is equipped or not and its charges",
            position = 3,
            section = miscellaneousConfiguration
    )
    default boolean isShowBindingNecklaceStatus() {
        return true;
    }

    @Range(
            min = 0,
            max = 16
    )
    @ConfigItem(
            keyName = "bindingNecklaceChargeWarningThreshold",
            name = "Charge Warning",
            description = "Display a red outline when on or below specified Binding Necklace charges",
            position = 4,
            section = miscellaneousConfiguration
    )
    default int bindingNecklaceChargeWarningThreshold() {
        return 5;
    }

    @ConfigItem(
            keyName = "showBindingNecklaceWarning",
            name = "Binding Necklace Altar Warning",
            description = "Display an indicator on an Elemental Altar when you have no Binding Necklace",
            position = 5,
            section = miscellaneousConfiguration
    )
    default boolean isShowBindingNecklaceWarning() {
        return true;
    }

    @ConfigItem(
            keyName = "showPointStatusInfobox",
            name = "Point Status Infobox",
            description = "Display an additional Infobox with a minigame Point Status",
            position = 6,
            section = miscellaneousConfiguration
    )
    default boolean isShowPointStatusInfobox() {
        return true;
    }

    @ConfigItem(
            keyName = "pointStatusInfoboxPosition",
            name = "Position",
            description = "Set the position for the Point Status Overlay",
            position = 7,
            section = miscellaneousConfiguration
    )
    default OverlayPosition pointStatusOverlayPosition() {
        return OverlayPosition.BOTTOM_LEFT;
    }

    @ConfigSection(
            position = 5,
            name = "The Great Guardian",
            description = "Options to enhance The Great Guardian"
    )
    String theGreatGuardianConfiguration = "theGreatGuardianConfiguration";

    @ConfigItem(
            keyName = "theGreatGuardianOutlineEnabled",
            name = "The Great Guardian Outline",
            description = "Whether to draw an outline or not",
            position = 3,
            section = theGreatGuardianConfiguration
    )
    default boolean isTheGreatGuardianOutlineEnabled() {
        return true;
    }

    @Alpha
    @ConfigItem(
            keyName = "theGreatGuardianOutlineColor",
            name = "Outline",
            description = "Color of the outline",
            position = 4,
            section = theGreatGuardianConfiguration
    )
    default Color theGreatGuardianOutlineColor() {
        return new Color(255, 255, 255, 204);
    }


    @Range(
            min = 1,
            max = 5
    )
    @ConfigItem(
            keyName = "theGreatGuardianOutlineWidth",
            name = "Outline width",
            description = "Width for the outline to be drawn",
            position = 5,
            section = theGreatGuardianConfiguration
    )
    default int theGreatGuardianOutlineWidth() {
        return 3;
    }

    @Range(
            min = 1,
            max = 5
    )
    @ConfigItem(
            keyName = "theGreatGuardianOutlineFeatherDistance",
            name = "Feather Distance",
            description = "Smoothing distance for the outline",
            position = 6,
            section = theGreatGuardianConfiguration
    )
    default int theGreatGuardianOutlineFeatherDistance() {
        return 5;
    }

    @ConfigSection(
            position = 6,
            name = "Cell Tiles",
            description = "Options to enhance the Cell Tiles"
    )
    String cellTileConfiguration = "cellTileConfiguration";

    @ConfigItem(
            keyName = "cellTilesOutlineEnabled",
            name = "Cell Tile Outline",
            description = "Whether to draw an outline or not",
            position = 3,
            section = cellTileConfiguration
    )
    default boolean isCellTilesOutlineEnabled() {
        return true;
    }

    @Alpha
    @ConfigItem(
            keyName = "cellTilesOutlineColor",
            name = "Outline",
            description = "Color of the outline",
            position = 4,
            section = cellTileConfiguration
    )
    default Color cellTilesOutlineColor() {
        return new Color(255, 255, 255, 204);
    }


    @Range(
            min = 1,
            max = 5
    )
    @ConfigItem(
            keyName = "cellTilesOutlineWidth",
            name = "Outline width",
            description = "Width for the outline to be drawn",
            position = 5,
            section = cellTileConfiguration
    )
    default int cellTilesOutlineWidth() {
        return 3;
    }

    @Range(
            min = 1,
            max = 5
    )
    @ConfigItem(
            keyName = "cellTilesOutlineFeatherDistance",
            name = "Feather Distance",
            description = "Smoothing distance for the outline",
            position = 6,
            section = cellTileConfiguration
    )
    default int cellTilesOutlineFeatherDistance() {
        return 5;
    }

    @ConfigSection(
            position = 7,
            name = "Uncharged Cell Table",
            description = "Options to enhance the Uncharged Cell Table"
    )
    String unchargedCellTableConfiguration = "unchargedCellTableConfiguration";

    @ConfigItem(
            keyName = "cellTableOutlineEnabled",
            name = "Cell Table Outline",
            description = "Whether to draw an outline or not",
            position = 3,
            section = unchargedCellTableConfiguration
    )
    default boolean isCellTableOutlineEnabled() {
        return true;
    }

    @Alpha
    @ConfigItem(
            keyName = "cellTableOutlineColor",
            name = "Outline",
            description = "Color of the outline",
            position = 4,
            section = unchargedCellTableConfiguration
    )
    default Color cellTableOutlineColor() {
        return new Color(255, 255, 255, 204);
    }


    @Range(
            min = 1,
            max = 5
    )
    @ConfigItem(
            keyName = "cellTableOutlineWidth",
            name = "Outline width",
            description = "Width for the outline to be drawn",
            position = 5,
            section = unchargedCellTableConfiguration
    )
    default int cellTableOutlineWidth() {
        return 3;
    }

    @Range(
            min = 1,
            max = 5
    )
    @ConfigItem(
            keyName = "cellTableOutlineFeatherDistance",
            name = "Feather Distance",
            description = "Smoothing distance for the outline",
            position = 6,
            section = unchargedCellTableConfiguration
    )
    default int cellTableOutlineFeatherDistance() {
        return 5;
    }

    @ConfigSection(
            position = 8,
            name = "Portal",
            description = "Options to enhance the Portal"
    )
    String portalConfiguration = "portalConfiguration";

    @ConfigItem(
            keyName = "portalOutlineEnabled",
            name = "Portal Outline",
            description = "Whether to draw an outline or not",
            position = 1,
            section = portalConfiguration
    )
    default boolean isPortalOutlineEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "portalTimeRemainingEnabled",
            name = "Portal Time Remaining",
            description = "Display time until Portal will despawn",
            position = 1,
            section = portalConfiguration
    )
    default boolean isPortalTimeRemainingEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "portalRunTimeEnabled",
            name = "Portal Distance Time",
            description = "Display time needed to reach the Portal",
            position = 2,
            section = portalConfiguration
    )
    default boolean isPortalRunTimeEnabled() {
        return true;
    }

    @Alpha
    @ConfigItem(
            keyName = "portalOutlineColor",
            name = "Outline",
            description = "Color of the outline",
            position = 3,
            section = portalConfiguration
    )
    default Color portalOutlineColor() {
        return new Color(255, 255, 255, 204);
    }


    @Range(
            min = 1,
            max = 5
    )
    @ConfigItem(
            keyName = "portalOutlineWidth",
            name = "Outline width",
            description = "Width for the outline to be drawn",
            position = 4,
            section = portalConfiguration
    )
    default int portalOutlineWidth() {
        return 3;
    }

    @Range(
            min = 1,
            max = 5
    )
    @ConfigItem(
            keyName = "portalOutlineFeatherDistance",
            name = "Feather Distance",
            description = "Smoothing distance for the outline",
            position = 5,
            section = portalConfiguration
    )
    default int portalOutlineFeatherDistance() {
        return 5;
    }

    @ConfigSection(
            position = 9,
            name = "Deposit Pool",
            description = "Options to enhance the Deposit Pool"
    )
    String depositPoolConfiguration = "depositPoolConfiguration";


    @ConfigItem(
            keyName = "depositPoolOutlineEnabled",
            name = "Deposit Pool Outline",
            description = "Whether to draw an outline or not",
            position = 1,
            section = depositPoolConfiguration
    )
    default boolean isDepositPoolOutlineEnabled() {
        return true;
    }

    @Alpha
    @ConfigItem(
            keyName = "depositPoolOutlineColor",
            name = "Outline",
            description = "Color of the outline",
            position = 2,
            section = depositPoolConfiguration
    )
    default Color depositPoolOutlineColor() {
        return new Color(255, 255, 255, 204);
    }


    @Range(
            min = 1,
            max = 5
    )
    @ConfigItem(
            keyName = "depositPoolOutlineWidth",
            name = "Outline width",
            description = "Width for the outline to be drawn",
            position = 3,
            section = depositPoolConfiguration
    )
    default int depositPoolOutlineWidth() {
        return 3;
    }

    @Range(
            min = 1,
            max = 5
    )
    @ConfigItem(
            keyName = "depositPoolOutlineFeatherDistance",
            name = "Feather Distance",
            description = "Smoothing distance for the outline",
            position = 4,
            section = depositPoolConfiguration
    )
    default int depositPoolOutlineFeatherDistance() {
        return 5;
    }

    @ConfigSection(
            position = 10,
            name = "Debugging",
            description = "Options to display additional information"
    )
    String debugConfiguration = "debugConfiguration";

    @ConfigItem(
            position = 0,
            keyName = "enableInternalWeightDebugging",
            name = "Internal Weight",
            description = "Toggle internal weight debugging",
            section = debugConfiguration
    )
    default boolean enableWeightDebugging() {
        return false;
    }

    @ConfigItem(
            position = 1,
            keyName = "enableOptimalPathDebugging",
            name = "Path to Optimal Guardian",
            description = "Toggle Optimal Path debugging",
            section = debugConfiguration
    )
    default boolean enableOptimalPathDebugging() {
        return false;
    }

    @ConfigItem(
            position = 2,
            keyName = "enableSecondaryPathDebugging",
            name = "Path to Secondary Guardian",
            description = "Toggle Secondary Path debugging",
            section = debugConfiguration
    )
    default boolean enableSecondaryPathDebugging() {
        return false;
    }

    @Alpha
    @ConfigItem(
            keyName = "tileOutlineColor",
            name = "Tile Outline",
            description = "Color of the outline",
            position = 3,
            section = debugConfiguration
    )
    default Color tileOutlineColor() {
        return new Color(255, 255, 255, 179);
    }
}

package com.hawolt.gotr.overlay;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerConfig;
import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import com.hawolt.gotr.data.ObeliskType;
import com.hawolt.gotr.data.StaticConstant;
import com.hawolt.gotr.events.ObeliskAnalysisEvent;
import com.hawolt.gotr.events.TickTimestampEvent;
import com.hawolt.gotr.events.minigame.impl.ObeliskTickRemainingEvent;
import com.hawolt.gotr.utility.ObeliskAnalysis;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.GameObject;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;

public class HighlightObeliskOverlay extends AbstractMinigameRenderer {

    @Inject
    private EventBus bus;
    @Inject
    private ItemManager itemManager;
    @Inject
    private ModelOutlineRenderer modelOutlineRenderer;

    @Getter(AccessLevel.NONE)
    private final GuardianOfTheRiftOptimizerPlugin plugin;
    @Getter(AccessLevel.NONE)
    private final Map<ObeliskType, ObeliskAnalysis[]> map;
    @Getter(AccessLevel.NONE)
    private long lastTickTimestamp;
    @Getter(AccessLevel.NONE)
    private int ticksRemainingUntilUpdate, referenceClientTick;

    @Inject
    public HighlightObeliskOverlay(GuardianOfTheRiftOptimizerPlugin plugin) {
        this.plugin = plugin;
        this.map = new HashMap<>();
        this.setLayer(OverlayLayer.ABOVE_SCENE);
        this.setPosition(OverlayPosition.DYNAMIC);
    }

    @Subscribe
    public void onObeliskAnalysisEvent(ObeliskAnalysisEvent event) {
        this.map.put(event.getObeliskType(), event.getObeliskAnalysis());
    }

    @Subscribe
    public void onObeliskTickRemainingEvent(ObeliskTickRemainingEvent event) {
        this.ticksRemainingUntilUpdate = event.getRemainingTicksUntilUpdate();
        this.referenceClientTick = event.getClientTick();
    }

    @Subscribe
    public void onTickTimestampEvent(TickTimestampEvent event) {
        this.lastTickTimestamp = event.getTimestamp();
    }


    @Override
    public void renderWhenSecure(Graphics2D graphics2D) {
        if (!getRenderSafetyEvent().isWidgetAvailable()) return;
        GuardianOfTheRiftOptimizerConfig config = plugin.getConfig();
        ObeliskAnalysis[] optimalObelisks = map.get(ObeliskType.OPTIMAL);
        ObeliskAnalysis[] secondaryObelisks = map.get(ObeliskType.SECONDARY);
        if (optimalObelisks == null || secondaryObelisks == null) return;
        for (ObeliskAnalysis optimal : optimalObelisks) {
            this.handleGuardianOutlineRender(
                    optimal,
                    config.isOptimalGuardianOutlineEnabled(),
                    config.optimalGuardianOutlineWidth(),
                    config.optimalGuardianOutlineColor(),
                    config.optimalGuardianOutlineFeatherDistance()
            );
            this.handleGuardianSpriteRender(
                    graphics2D,
                    optimal,
                    config.isOptimalGuardianSpriteEnabled()
            );
            this.handleGuardianTimerRender(
                    graphics2D,
                    optimal,
                    config.isOptimalGuardianTimerEnabled()
            );
            this.handleGuardianRunTimeRender(
                    graphics2D,
                    optimal,
                    config.isOptimalGuardianRunTime()
            );
            this.handleGuardianWeightRender(
                    graphics2D,
                    optimal,
                    config.enableWeightDebugging()
            );
        }
        for (ObeliskAnalysis secondary : secondaryObelisks) {
            this.handleGuardianOutlineRender(
                    secondary,
                    config.isSecondaryGuardianOutlineEnabled(),
                    config.secondaryGuardianOutlineWidth(),
                    config.secondaryGuardianOutlineColor(),
                    config.secondaryGuardianOutlineFeatherDistance()
            );
            this.handleGuardianSpriteRender(
                    graphics2D,
                    secondary,
                    config.isSecondaryGuardianSpriteEnabled()
            );
            this.handleGuardianTimerRender(
                    graphics2D,
                    secondary,
                    config.isSecondaryGuardianTimerEnabled()
            );
            this.handleGuardianRunTimeRender(
                    graphics2D,
                    secondary,
                    config.isSecondaryGuardianRunTime()
            );
            this.handleGuardianWeightRender(
                    graphics2D,
                    secondary,
                    config.enableWeightDebugging()
            );
        }
    }

    private void handleGuardianOutlineRender(
            ObeliskAnalysis analysis,
            boolean isEnabled,
            int outlineWidth,
            Color outlineColor,
            int feather
    ) {
        if (!isEnabled) return;
        if (analysis == null) return;
        GameObject object = analysis.getGameObject();
        if (object == null) return;
        try {
            Shape hull = object.getConvexHull();
            if (hull == null) return;
            this.modelOutlineRenderer.drawOutline(
                    object,
                    outlineWidth,
                    outlineColor,
                    feather
            );
        } catch (NullPointerException e) {
            // ignore
        }
    }

    private void handleGuardianTimerRender(
            Graphics2D graphics2D,
            ObeliskAnalysis analysis,
            boolean isEnabled
    ) {
        if (!isEnabled) return;
        if (analysis == null) return;
        GameObject object = analysis.getGameObject();
        if (object == null) return;
        if (analysis.isTalismanAvailable()) return;

        int ticksSinceEvent = plugin.getClient().getTickCount() - referenceClientTick;
        int ticksLeftUntilUpdate = ticksRemainingUntilUpdate - ticksSinceEvent;
        long elapsedSinceLastTick = System.currentTimeMillis() - lastTickTimestamp;
        long remaining = (ticksLeftUntilUpdate * StaticConstant.GAME_TICK_DURATION) - elapsedSinceLastTick;

        if (remaining < 0) return;

        String formatted = formatRemainingTime(remaining);
        Point canvasTextLocation = Perspective.getCanvasTextLocation(
                plugin.getClient(),
                graphics2D,
                object.getLocalLocation(),
                formatted,
                565
        );

        if (canvasTextLocation == null) return;
        OverlayUtil.renderTextLocation(graphics2D, canvasTextLocation, formatted, Color.WHITE);
    }

    private void handleGuardianRunTimeRender(
            Graphics2D graphics2D,
            ObeliskAnalysis analysis,
            boolean isEnabled
    ) {
        if (!isEnabled) return;
        if (analysis == null) return;
        GameObject object = analysis.getGameObject();
        if (object == null) return;

        long timeToRun = (analysis.getNormalizedTileDistance() >> 1)
                * StaticConstant.GAME_TICK_DURATION
                + StaticConstant.GAME_TICK_DURATION;

        String formatted = formatRemainingTime(timeToRun);
        Point canvasTextLocation = Perspective.getCanvasTextLocation(
                plugin.getClient(),
                graphics2D,
                object.getLocalLocation(),
                formatted,
                0
        );

        if (canvasTextLocation == null) return;
        OverlayUtil.renderTextLocation(graphics2D, canvasTextLocation, formatted, Color.WHITE);
    }

    private void handleGuardianWeightRender(
            Graphics2D graphics2D,
            ObeliskAnalysis analysis,
            boolean isEnabled
    ) {
        if (!isEnabled) return;
        if (analysis == null) return;
        GameObject object = analysis.getGameObject();
        if (object == null) return;

        String efficiency = String.format("%.2f", analysis.getWeightedEfficiency());
        Point canvasTextLocation = Perspective.getCanvasTextLocation(
                plugin.getClient(),
                graphics2D,
                object.getLocalLocation(),
                efficiency,
                200
        );

        if (canvasTextLocation == null) return;
        OverlayUtil.renderTextLocation(graphics2D, canvasTextLocation, efficiency, Color.WHITE);
    }

    private void handleGuardianSpriteRender(
            Graphics2D graphics2D,
            ObeliskAnalysis analysis,
            boolean isEnabled
    ) {
        if (!isEnabled) return;
        if (analysis == null) return;
        GameObject object = analysis.getGameObject();
        if (object == null) return;
        BufferedImage sprite = !analysis.isDowngradeBetter() ?
                itemManager.getImage(analysis.getRuneCraftInfo().getSpriteId()) :
                itemManager.getImage(analysis.getRuneCraftInfo().getBaseRuneCraftInfo().getSpriteId());
        OverlayUtil.renderImageLocation(
                plugin.getClient(),
                graphics2D,
                object.getLocalLocation(),
                sprite,
                505
        );
    }

    private String formatRemainingTime(long remaining) {
        remaining = (long) (Math.ceil(remaining / 100.0) * 100);
        long seconds = remaining / 1000;
        long remainingMillis = remaining % 1000;
        long tenths = (long) Math.ceil(remainingMillis / 100.0);
        if (tenths == 10) {
            seconds++;
            tenths = 0;
        }
        return String.format("%d.%d", seconds, tenths);
    }

}

package com.hawolt.gotr.overlay;

import com.hawolt.gotr.Slice;
import com.hawolt.gotr.events.RenderSafetyEvent;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.Overlay;

import javax.inject.Inject;
import java.awt.*;

public abstract class AbstractMinigameRenderer extends Overlay implements Slice {
    @Inject
    protected EventBus bus;

    @Getter(AccessLevel.PROTECTED)
    private RenderSafetyEvent renderSafetyEvent;

    @Override
    public void startup() {
        this.bus.register(this);
    }

    @Override
    public void shutdown() {
        this.bus.unregister(this);
    }

    @Override
    public boolean isClientThreadRequiredOnStartup() {
        return false;
    }

    @Override
    public boolean isClientThreadRequiredOnShutDown() {
        return false;
    }

    @Subscribe
    public void onRenderSafetyEvent(RenderSafetyEvent event) {
        this.renderSafetyEvent = event;
    }

    @Override
    public Dimension render(Graphics2D graphics2D) {
        if (renderSafetyEvent == null) return null;
        if (!renderSafetyEvent.isInGame() || renderSafetyEvent.isVolatileState()) return null;
        this.renderWhenSecure(graphics2D);
        return null;
    }

    public abstract void renderWhenSecure(Graphics2D graphics2D);

    protected void drawStringCenteredToBoundingBox(Graphics2D graphics2D, Rectangle bounds, String text, Color color) {
        FontMetrics fontMetrics = graphics2D.getFontMetrics();
        int stringWidth = fontMetrics.stringWidth(text);
        int textLocationX = bounds.x + ((bounds.width - stringWidth) >> 1);
        int textLocationY = bounds.y + ((bounds.height - fontMetrics.getHeight()) >> 1) + fontMetrics.getAscent();
        graphics2D.setColor(Color.BLACK);
        graphics2D.drawString(text, textLocationX + 1, textLocationY + 1);
        graphics2D.setColor(color);
        graphics2D.drawString(text, textLocationX, textLocationY);
    }
}

package com.hawolt.gotr.overlay;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import com.hawolt.gotr.data.RuneCraftInfo;
import com.hawolt.gotr.events.RenderSafetyEvent;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.GameObject;
import net.runelite.api.ObjectComposition;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

import javax.inject.Inject;
import java.awt.*;

public class NecklaceWarningOverlay extends AbstractMinigameRenderer {

    @Inject
    private ModelOutlineRenderer modelOutlineRenderer;

    @Getter(AccessLevel.NONE)
    private GameObject lastSeenAltar;

    @Getter(AccessLevel.NONE)
    private GuardianOfTheRiftOptimizerPlugin plugin;

    @Inject
    public NecklaceWarningOverlay(GuardianOfTheRiftOptimizerPlugin plugin) {
        this.plugin = plugin;
        this.setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics2D) {
        RenderSafetyEvent renderSafetyEvent = getRenderSafetyEvent();
        if (renderSafetyEvent == null) return null;
        if (!renderSafetyEvent.isWidgetAvailable() || renderSafetyEvent.isVolatileState()) return null;
        this.renderWhenSecure(graphics2D);
        return null;
    }

    private ObjectComposition getObjectComposition(int id) {
        ObjectComposition objectComposition = plugin.getClient().getObjectDefinition(id);
        return objectComposition.getImpostorIds() == null ? objectComposition : objectComposition.getImpostor();
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        GameObject gameObject = event.getGameObject();
        if (gameObject == null) return;
        ObjectComposition composition = getObjectComposition(gameObject.getId());
        if (composition == null) return;
        if (!"Altar".equals(composition.getName())) return;
        RuneCraftInfo runeCraftInfo = RuneCraftInfo.find(
                plugin.getConfig(),
                gameObject.getId()
        );
        if (runeCraftInfo == null || !runeCraftInfo.isCombinationRune()) return;
        this.lastSeenAltar = gameObject;
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        GameObject gameObject = event.getGameObject();
        if (gameObject == null || lastSeenAltar == null) return;
        if (gameObject.getId() != lastSeenAltar.getId()) return;
        this.lastSeenAltar = null;
    }

    @Override
    public void renderWhenSecure(Graphics2D graphics2D) {
        if (lastSeenAltar == null) return;
        if (plugin.getEquipmentSlice().isBindingNecklaceEquipped()) return;
        try {
            Shape hull = lastSeenAltar.getConvexHull();
            if (hull == null) return;
            this.modelOutlineRenderer.drawOutline(
                    lastSeenAltar,
                    5,
                    Color.RED,
                    5
            );
        } catch (NullPointerException e) {
            // ignore
        }
    }

}

package com.hawolt.gotr.overlay;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerConfig;
import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import com.hawolt.gotr.data.MinigameState;
import com.hawolt.gotr.data.StaticConstant;
import com.hawolt.gotr.events.RenderSafetyEvent;
import com.hawolt.gotr.events.minigame.impl.MinigameStateEvent;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.GameState;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;

public class PortalIndicatorOverlay extends AbstractMinigameRenderer {

    @Getter(AccessLevel.NONE)
    private final int SPRITE_DIMENSION_HEIGHT = 32;

    @Getter(AccessLevel.NONE)
    private final int SPRITE_DIMENSION_WIDTH = 32;

    @Getter(AccessLevel.NONE)
    private GuardianOfTheRiftOptimizerPlugin plugin;

    @Getter(AccessLevel.NONE)
    private long lastTickTimestamp, lastPortalDespawnTimestamp, lastInternalUpdateTimestamp;

    @Getter(AccessLevel.NONE)
    private boolean isFirstPortalThisRound;

    @Getter(AccessLevel.NONE)
    private MinigameState minigameState = MinigameState.UNKNOWN;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    public PortalIndicatorOverlay(GuardianOfTheRiftOptimizerPlugin plugin) {
        this.plugin = plugin;
        this.setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Subscribe
    public void onMinigameStateEvent(MinigameStateEvent event) {
        this.minigameState = event.getCurrentMinigameState();
    }

    @Subscribe
    public void onGameState(GameState event) {
        if (event != GameState.LOGGED_IN) return;
        this.lastPortalDespawnTimestamp = 0;
    }

    @Subscribe
    public void onScriptPreFired(ScriptPreFired event) {
        if (event.getScriptId() != StaticConstant.MINIGAME_HUD_UPDATE_SCRIPT_ID) return;
        Object[] arguments = event.getScriptEvent().getArguments();
        int portalTicksRemaining = Integer.parseInt(arguments[11].toString());
        int elementalRuneEnumIndex = Integer.parseInt(arguments[6].toString());
        int catalyticRuneEnumIndex = Integer.parseInt(arguments[7].toString());
        boolean isInStartup = elementalRuneEnumIndex == 0 && catalyticRuneEnumIndex == 0;
        boolean isUnknownPortal = portalTicksRemaining < 0xFFFFFF00;
        this.isFirstPortalThisRound = isUnknownPortal || isInStartup;
        int absoluteTickCount;
        if (isInStartup && portalTicksRemaining == -1) {
            int guardianTicksRemaining = Integer.parseInt(arguments[10].toString());
            absoluteTickCount = Math.abs(guardianTicksRemaining - 200);
            long elapsedSinceLastPortal = absoluteTickCount * StaticConstant.GAME_TICK_DURATION;
            this.lastPortalDespawnTimestamp = System.currentTimeMillis() - elapsedSinceLastPortal;
        } else if (!isUnknownPortal) {
            absoluteTickCount = Math.abs(portalTicksRemaining);
            long elapsedSinceLastPortal = absoluteTickCount * StaticConstant.GAME_TICK_DURATION;
            this.lastPortalDespawnTimestamp = System.currentTimeMillis() - elapsedSinceLastPortal;
        }
    }

    @Override
    public Dimension render(Graphics2D graphics2D) {
        RenderSafetyEvent renderSafetyEvent = getRenderSafetyEvent();
        if (renderSafetyEvent == null) return null;
        if (!renderSafetyEvent.isWidgetAvailable() || renderSafetyEvent.isVolatileState()) return null;
        this.renderWhenSecure(graphics2D);
        return null;
    }

    @Override
    public void renderWhenSecure(Graphics2D graphics) {
        if (minigameState == MinigameState.COMPLETE ||
                minigameState == MinigameState.CLOSING ||
                minigameState == MinigameState.CLOSED ||
                minigameState == MinigameState.INITIALIZING
        ) {
            return;
        }

        GuardianOfTheRiftOptimizerConfig config = plugin.getConfig();
        if (!config.isShowTimeSinceLastPortal()) return;

        Widget parentWidget = plugin.getClient().getWidget(StaticConstant.MINIGAME_WIDGET_PARENT_ID);
        Widget portalWidget = plugin.getClient().getWidget(StaticConstant.MINIGAME_WIDGET_PORTAL_ID);

        if (parentWidget == null || portalWidget == null) return;
        if (parentWidget.isHidden() || !portalWidget.isHidden()) return;

        BufferedImage sprite = spriteManager.getSprite(StaticConstant.MINIGAME_PORTAL_SPRITE_ID, 0);
        if (sprite == null) return;

        BufferedImage spriteInGrayscale = ImageUtil.grayscaleImage(sprite);

        int spriteLocationX = parentWidget.getRelativeX() + portalWidget.getRelativeX() + 16;
        int spriteLocationY = parentWidget.getRelativeY() + portalWidget.getRelativeY() + 12;

        graphics.drawImage(
                spriteInGrayscale,
                spriteLocationX,
                spriteLocationY,
                SPRITE_DIMENSION_WIDTH,
                SPRITE_DIMENSION_HEIGHT,
                null
        );

        long elapsedSinceDespawnInMillis = System.currentTimeMillis() - lastPortalDespawnTimestamp;
        long elapsedSinceDespawnInSeconds = elapsedSinceDespawnInMillis / 1000;

        Color textColor = lastPortalDespawnTimestamp != 0 ?
                getPortalProbabilityColor(elapsedSinceDespawnInSeconds) :
                Color.WHITE;

        String text = lastPortalDespawnTimestamp != 0 ?
                formatRemainingTime(elapsedSinceDespawnInSeconds) :
                "?";

        Rectangle bounds = new Rectangle(
                spriteLocationX,
                spriteLocationY + SPRITE_DIMENSION_HEIGHT + 1,
                SPRITE_DIMENSION_WIDTH,
                24);

        this.drawStringCenteredToBoundingBox(
                graphics,
                bounds,
                text,
                textColor
        );
    }

    private Color getPortalProbabilityColor(long elapsedSinceDespawnInSeconds) {
        if (isFirstPortalThisRound) elapsedSinceDespawnInSeconds -= 40;
        if (elapsedSinceDespawnInSeconds >= 108) return Color.RED;
        else if (elapsedSinceDespawnInSeconds >= 85) return Color.YELLOW;
        return Color.WHITE;
    }

    private String formatRemainingTime(long elapsedSinceDespawnInSeconds) {
        int minutes = (int) (elapsedSinceDespawnInSeconds / 60D);
        int seconds = (int) (elapsedSinceDespawnInSeconds % 60);
        return String.format("%01d:%02d", minutes, seconds);
    }
}

package com.hawolt.gotr.overlay;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerConfig;
import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import com.hawolt.gotr.data.MinigameState;
import com.hawolt.gotr.data.StaticConstant;
import com.hawolt.gotr.events.minigame.impl.MinigameStateEvent;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.NPC;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

import javax.inject.Inject;
import java.awt.*;

public class HighlightGreatGuardianOverlay extends AbstractMinigameRenderer {

    @Inject
    private ModelOutlineRenderer modelOutlineRenderer;

    @Getter(AccessLevel.NONE)
    private GuardianOfTheRiftOptimizerPlugin plugin;

    @Getter(AccessLevel.NONE)
    private MinigameState minigameState;

    @Getter(AccessLevel.NONE)
    private NPC greatGuardian;

    @Inject
    public HighlightGreatGuardianOverlay(GuardianOfTheRiftOptimizerPlugin plugin) {
        this.plugin = plugin;
        this.setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public void shutdown() {
        super.shutdown();
        this.greatGuardian = null;
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned event) {
        NPC npc = event.getNpc();
        if (npc.getId() != StaticConstant.MINIGAME_GREAT_GUARDIAN_NPC_ID) return;
        this.greatGuardian = npc;
    }

    @Subscribe
    public void onMinigameStateEvent(MinigameStateEvent event) {
        this.minigameState = event.getCurrentMinigameState();
    }

    @Override
    public void renderWhenSecure(Graphics2D graphics2D) {
        if (greatGuardian == null) return;
        GuardianOfTheRiftOptimizerConfig config = plugin.getConfig();
        if (!config.isTheGreatGuardianOutlineEnabled()) return;
        if (!plugin.getInventoryEssenceSlice().isGuardianStoneAvailable()) return;
        if (minigameState == MinigameState.CLOSING) return;
        this.modelOutlineRenderer.drawOutline(
                greatGuardian,
                config.theGreatGuardianOutlineWidth(),
                config.theGreatGuardianOutlineColor(),
                config.theGreatGuardianOutlineFeatherDistance()
        );
    }
}

package com.hawolt.gotr.overlay;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerConfig;
import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import com.hawolt.gotr.data.ObeliskType;
import com.hawolt.gotr.data.StaticConstant;
import com.hawolt.gotr.events.ObeliskAnalysisEvent;
import com.hawolt.gotr.utility.ObeliskAnalysis;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class InternalDebugOverlay extends AbstractMinigameRenderer {

    @Inject
    private EventBus bus;

    @Getter(AccessLevel.NONE)
    private final Map<ObeliskType, ObeliskAnalysis[]> map;

    private final GuardianOfTheRiftOptimizerPlugin plugin;

    @Override
    public void startup() {
        this.bus.register(this);
    }

    @Override
    public void shutdown() {
        this.bus.unregister(this);
    }

    @Inject
    public InternalDebugOverlay(GuardianOfTheRiftOptimizerPlugin plugin) {
        this.plugin = plugin;
        this.map = new HashMap<>();
        this.setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Subscribe
    public void onObeliskAnalysisEvent(ObeliskAnalysisEvent event) {
        this.map.put(event.getObeliskType(), event.getObeliskAnalysis());
    }


    @Override
    public void renderWhenSecure(Graphics2D graphics2D) {
        GuardianOfTheRiftOptimizerConfig config = plugin.getConfig();
        ObeliskAnalysis[] optimalObelisks = map.get(ObeliskType.OPTIMAL);
        ObeliskAnalysis[] secondaryObelisks = map.get(ObeliskType.SECONDARY);
        if (optimalObelisks == null || secondaryObelisks == null) return;
        for (ObeliskAnalysis optimal : optimalObelisks) {
            handleTilePath(
                    optimal,
                    graphics2D,
                    config.enableOptimalPathDebugging(),
                    config.tileOutlineColor()
            );
        }
        for (ObeliskAnalysis secondary : secondaryObelisks) {
            handleTilePath(
                    secondary,
                    graphics2D,
                    config.enableSecondaryPathDebugging(),
                    config.tileOutlineColor()
            );
        }
    }

    private void handleTilePath(ObeliskAnalysis analysis, Graphics2D graphics2D, boolean isEnabled, Color outline) {
        if (analysis == null || !isEnabled) return;
        Client client = plugin.getClient();
        int currentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        if (currentRegionId != StaticConstant.MINIGAME_REGION_ID) return;
        List<WorldPoint> pathToGuardian = analysis.getPathToGuardian();
        for (WorldPoint worldPoint : pathToGuardian) {
            renderTile(
                    client,
                    graphics2D,
                    worldPoint,
                    outline
            );
        }
    }

    private void renderTile(
            Client client,
            Graphics2D graphics,
            WorldPoint worldPoint,
            Color outlineColor
    ) {
        LocalPoint localPoint = LocalPoint.fromWorld(client.getLocalPlayer().getWorldView(), worldPoint);
        if (localPoint == null) return;
        Polygon polygon = Perspective.getCanvasTilePoly(plugin.getClient(), localPoint);
        if (polygon == null) return;
        OverlayUtil.renderPolygon(graphics, polygon, outlineColor);
    }
}

package com.hawolt.gotr.overlay;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerConfig;
import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import com.hawolt.gotr.data.StaticConstant;
import com.hawolt.gotr.events.RenderSafetyEvent;
import com.hawolt.gotr.events.TickTimestampEvent;
import com.hawolt.gotr.events.minigame.impl.PortalSpawnEvent;
import com.hawolt.gotr.pathfinding.PathCreator;
import com.hawolt.gotr.pathfinding.Pathfinder;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.GameObject;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;
import org.apache.commons.lang3.tuple.Pair;

import javax.inject.Inject;
import java.awt.*;
import java.util.LinkedList;
import java.util.List;

public class HighlightPortalOverlay extends AbstractMinigameRenderer {
    @Inject
    private ModelOutlineRenderer modelOutlineRenderer;

    @Getter(AccessLevel.NONE)
    private GuardianOfTheRiftOptimizerPlugin plugin;

    @Getter(AccessLevel.NONE)
    private int portalSpawnedOnTick, portalTicksRemaining;

    @Getter(AccessLevel.NONE)
    private List<WorldPoint> pathToPortal;

    @Getter(AccessLevel.NONE)
    private int normalizedTileDistance;

    @Getter(AccessLevel.NONE)
    private long lastTickTimestamp;

    @Getter(AccessLevel.NONE)
    private WorldPoint worldPoint;

    @Getter(AccessLevel.NONE)
    private GameObject portal;

    @Inject
    public HighlightPortalOverlay(GuardianOfTheRiftOptimizerPlugin plugin) {
        this.plugin = plugin;
        this.setLayer(OverlayLayer.ABOVE_SCENE);
        this.setPosition(OverlayPosition.DYNAMIC);
    }

    @Override
    public boolean isClientThreadRequiredOnShutDown() {
        return true;
    }

    @Override
    public void shutdown() {
        super.shutdown();
        this.portal = null;
        this.plugin.getClient().clearHintArrow();
    }

    @Subscribe
    public void onTickTimestampEvent(TickTimestampEvent event) {
        this.lastTickTimestamp = event.getTimestamp();
    }

    @Subscribe
    public void onChatMessage(ChatMessage message) {
        if (message.getType() != ChatMessageType.SPAM && message.getType() != ChatMessageType.GAMEMESSAGE) return;
        String content = message.getMessage();
        if (!content.contains("You step through the portal")) return;
        this.plugin.getClient().clearHintArrow();
    }

    private void updatePathToPortal() {
        Pathfinder pathfinder = new Pathfinder(plugin);
        Pair<List<WorldPoint>, Boolean> pathPair = PathCreator.pathTo(pathfinder, portal);
        this.pathToPortal = PathCreator.make(
                plugin.getClient(),
                pathPair.getLeft(),
                plugin.getPathfinderSlice().getBlockedWorldAreaByNPC(),
                true,
                new LinkedList<>(),
                new LinkedList<>(),
                pathPair.getRight()
        );
        this.normalizedTileDistance = normalizeTileCount(pathToPortal.size());
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        WorldPoint current = plugin.getClient().getLocalPlayer().getWorldLocation();
        RenderSafetyEvent renderSafetyEvent = getRenderSafetyEvent();
        if (!renderSafetyEvent.isWidgetAvailable()) return;
        if (worldPoint == null || !worldPoint.equals(current)) {
            this.updatePathToPortal();
        }
        this.worldPoint = current;
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        GameObject gameObject = event.getGameObject();
        if (gameObject.getId() != StaticConstant.MINIGAME_PORTAL_OBJECT_ID) return;
        this.plugin.getClient().setHintArrow(gameObject.getWorldLocation());
        this.portal = gameObject;
        this.updatePathToPortal();
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        GameObject gameObject = event.getGameObject();
        if (gameObject.getId() != StaticConstant.MINIGAME_PORTAL_OBJECT_ID) return;
        this.plugin.getClient().clearHintArrow();
        this.portal = null;
    }

    @Subscribe
    public void onPortalSpawnEvent(PortalSpawnEvent event) {
        this.portalTicksRemaining = event.getTicksUntilDespawn();
        this.portalSpawnedOnTick = event.getClientTick();
    }

    @Override
    public void renderWhenSecure(Graphics2D graphics2D) {
        if (portal == null) return;
        if (!getRenderSafetyEvent().isWidgetAvailable()) return;
        GuardianOfTheRiftOptimizerConfig config = plugin.getConfig();
        this.renderPortalOutline(config);
        this.renderPortalTime(config, graphics2D);
        this.renderPortalRunTime(config, graphics2D);
    }

    private void renderPortalOutline(GuardianOfTheRiftOptimizerConfig config) {
        if (!config.isPortalOutlineEnabled()) return;
        try {
            this.modelOutlineRenderer.drawOutline(
                    portal,
                    config.portalOutlineWidth(),
                    config.portalOutlineColor(),
                    config.portalOutlineFeatherDistance()
            );
        } catch (Exception e) {

        }
    }

    private void renderPortalTime(GuardianOfTheRiftOptimizerConfig config, Graphics2D graphics2D) {
        if (!config.isShowTimeSinceLastPortal()) return;

        int ticksSinceEvent = plugin.getClient().getTickCount() - portalSpawnedOnTick;
        int ticksLeftUntilUpdate = portalTicksRemaining - ticksSinceEvent;
        long elapsedSinceLastTick = System.currentTimeMillis() - lastTickTimestamp;
        long remaining = (ticksLeftUntilUpdate * StaticConstant.GAME_TICK_DURATION) - elapsedSinceLastTick;

        if (remaining < 0) return;

        String formatted = formatRemainingTime(remaining);
        Point canvasTextLocation = Perspective.getCanvasTextLocation(
                plugin.getClient(),
                graphics2D,
                portal.getLocalLocation(),
                formatted,
                200
        );

        if (canvasTextLocation == null) return;
        OverlayUtil.renderTextLocation(graphics2D, canvasTextLocation, formatted, Color.WHITE);
    }

    private void renderPortalRunTime(GuardianOfTheRiftOptimizerConfig config, Graphics2D graphics2D) {
        if (!config.isPortalRunTimeEnabled()) return;

        long timeToRun = (normalizedTileDistance >> 1)
                * StaticConstant.GAME_TICK_DURATION
                + StaticConstant.GAME_TICK_DURATION;

        String formatted = formatRemainingTime(timeToRun);
        Point canvasTextLocation = Perspective.getCanvasTextLocation(
                plugin.getClient(),
                graphics2D,
                portal.getLocalLocation(),
                formatted,
                0
        );

        if (canvasTextLocation == null) return;
        OverlayUtil.renderTextLocation(graphics2D, canvasTextLocation, formatted, Color.WHITE);
    }

    private String formatRemainingTime(long remaining) {
        remaining = (long) (Math.ceil(remaining / 100.0) * 100);
        long seconds = remaining / 1000;
        long remainingMillis = remaining % 1000;
        long tenths = (long) Math.ceil(remainingMillis / 100.0);
        if (tenths == 10) {
            seconds++;
            tenths = 0;
        }
        return String.format("%d.%d", seconds, tenths);
    }

    private static int normalizeTileCount(int amount) {
        return (amount % 2 == 0) ? amount : amount + 1;
    }
}

package com.hawolt.gotr.overlay;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerConfig;
import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import com.hawolt.gotr.data.StaticConstant;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.GameObject;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

import javax.inject.Inject;
import java.awt.*;

public class HighlightCellTableOverlay extends AbstractMinigameRenderer {

    @Inject
    private ModelOutlineRenderer modelOutlineRenderer;

    @Getter(AccessLevel.NONE)
    private GuardianOfTheRiftOptimizerPlugin plugin;

    @Getter(AccessLevel.NONE)
    private GameObject unchargedCellTable;

    @Inject
    public HighlightCellTableOverlay(GuardianOfTheRiftOptimizerPlugin plugin) {
        this.plugin = plugin;
        this.setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        GameObject gameObject = event.getGameObject();
        if (gameObject.getId() != StaticConstant.MINIGAME_UNCHARGED_CELL_TABLE_OBJECT_ID) return;
        this.unchargedCellTable = gameObject;
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        GameObject gameObject = event.getGameObject();
        if (gameObject.getId() != StaticConstant.MINIGAME_UNCHARGED_CELL_TABLE_OBJECT_ID) return;
        this.unchargedCellTable = null;
    }

    @Override
    public void renderWhenSecure(Graphics2D graphics2D) {
        if (unchargedCellTable == null) return;
        GuardianOfTheRiftOptimizerConfig config = plugin.getConfig();
        if (!config.isCellTableOutlineEnabled()) return;
        int availableUnchargedCells = this.plugin.getInventoryEssenceSlice().getAvailableUnchargedCells();
        if (availableUnchargedCells > 5) return;
        this.modelOutlineRenderer.drawOutline(
                unchargedCellTable,
                config.cellTableOutlineWidth(),
                config.cellTableOutlineColor(),
                config.cellTableOutlineFeatherDistance()
        );
    }
}

package com.hawolt.gotr.overlay;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import com.hawolt.gotr.Slice;
import com.hawolt.gotr.data.MinigameState;
import com.hawolt.gotr.data.StaticConstant;
import com.hawolt.gotr.events.RenderSafetyEvent;
import com.hawolt.gotr.events.minigame.impl.MinigameStateEvent;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;

import javax.inject.Inject;
import java.awt.*;
import java.util.concurrent.TimeUnit;

public class StartTimeOverlay extends OverlayPanel implements Slice {

    @Inject
    protected EventBus bus;

    @Getter(AccessLevel.NONE)
    private MinigameState minigameState = MinigameState.UNKNOWN;

    @Getter(AccessLevel.NONE)
    private final GuardianOfTheRiftOptimizerPlugin plugin;

    @Getter(AccessLevel.NONE)
    private RenderSafetyEvent renderSafetyEvent;

    @Getter(AccessLevel.NONE)
    private boolean isFallBackRenderRequired;

    @Getter(AccessLevel.NONE)
    private long gameWillStartAtTimestamp;

    @Override
    public void startup() {
        this.bus.register(this);
    }

    @Override
    public void shutdown() {
        this.bus.unregister(this);
    }

    @Override
    public boolean isClientThreadRequiredOnStartup() {
        return false;
    }

    @Override
    public boolean isClientThreadRequiredOnShutDown() {
        return false;
    }

    @Inject
    public StartTimeOverlay(GuardianOfTheRiftOptimizerPlugin plugin) {
        this.plugin = plugin;
        this.setPosition(OverlayPosition.TOP_LEFT);
        this.getMenuEntries().add(
                new OverlayMenuEntry(
                        MenuAction.RUNELITE_OVERLAY_CONFIG,
                        OverlayManager.OPTION_CONFIGURE,
                        "Guardians of the Rift Timer"
                )
        );
    }

    @Subscribe
    public void onRenderSafetyEvent(RenderSafetyEvent event) {
        this.renderSafetyEvent = event;
    }

    @Override
    public Dimension render(Graphics2D graphics2D) {
        if (renderSafetyEvent == null) return null;
        if (!isFallBackRenderRequired) return null;
        if (!renderSafetyEvent.isInGame() || renderSafetyEvent.isVolatileState()) return null;
        long secondsUntilGameStart = TimeUnit.MILLISECONDS.toSeconds(
                gameWillStartAtTimestamp - System.currentTimeMillis() + StaticConstant.GAME_TICK_DURATION
        );
        String timeUntilGameStart = secondsUntilGameStart < 0 ? "?" : String.valueOf(secondsUntilGameStart);
        this.panelComponent.getChildren().add(
                LineComponent.builder()
                        .left("Game Starting in:")
                        .right(timeUntilGameStart)
                        .build()
        );
        return super.render(graphics2D);
    }

    @Subscribe
    public void onMinigameStateEvent(MinigameStateEvent event) {
        this.minigameState = event.getCurrentMinigameState();
        if (minigameState == MinigameState.CLOSING && event.getPreviousMinigameState() == MinigameState.COMPLETE) {
            this.gameWillStartAtTimestamp = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(60);
        } else if (minigameState == MinigameState.CLOSED && event.getPreviousMinigameState() == MinigameState.CLOSING) {
            this.gameWillStartAtTimestamp = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(30);
        }
    }

    @Subscribe
    public void onChatMessage(ChatMessage message) {
        if (!renderSafetyEvent.isInGame()) return;
        if (message.getType() != ChatMessageType.SPAM && message.getType() != ChatMessageType.GAMEMESSAGE) return;
        String content = message.getMessage();
        if (content.contains("The rift will become active in 30 seconds.")) {
            this.gameWillStartAtTimestamp = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(30);
        } else if (content.contains("The rift will become active in 10 seconds.")) {
            this.gameWillStartAtTimestamp = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(10);
        } else if (content.contains("The rift will become active in 5 seconds.")) {
            this.gameWillStartAtTimestamp = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(5);
        }
    }

    @Subscribe
    public void onGameState(GameState event) {
        if (event != GameState.LOGGED_IN) return;
        this.gameWillStartAtTimestamp = 0;
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        if (renderSafetyEvent == null) return;
        this.isFallBackRenderRequired = !renderSafetyEvent.isWidgetVisible() && renderSafetyEvent.isInGame();
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event) {
        if (minigameState != MinigameState.CLOSING && minigameState != MinigameState.CLOSED) return;
        int scriptId = event.getScriptId();
        if (scriptId != StaticConstant.MINIGAME_HUD_UPDATE_SCRIPT_ID) return;
        if (!plugin.getConfig().isShowGameStartTimer()) return;
        if (isFallBackRenderRequired) return;
        this.handleGameStartUpdate();
    }

    private void handleGameStartUpdate() {
        Widget target = plugin.getClient().getWidget(
                StaticConstant.MINIGAME_WIDGET_GROUP_ID,
                StaticConstant.MINIGAME_WIDGET_POWER_TEXT_WIDGET_ID
        );
        if (target == null) return;
        this.handleWidgetStartTimeUpdate(target);
    }

    private void handleWidgetStartTimeUpdate(Widget textWidget) {
        long secondsUntilGameStart = TimeUnit.MILLISECONDS.toSeconds(
                gameWillStartAtTimestamp - System.currentTimeMillis() + StaticConstant.GAME_TICK_DURATION
        );
        String timeUntilGameStart = secondsUntilGameStart < 0 ? "?" : String.valueOf(secondsUntilGameStart);
        String textContent = textWidget.getText();
        if (!textContent.contains("Power")) return;
        String updated = String.format("Game Starting in: %s", timeUntilGameStart);
        textWidget.setText(updated);
        textWidget.revalidate();
    }
}

package com.hawolt.gotr.overlay;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerConfig;
import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import com.hawolt.gotr.data.StaticConstant;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.GameObject;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

import javax.inject.Inject;
import java.awt.*;

public class HighlightDepositPoolOverlay extends AbstractMinigameRenderer {

    @Inject
    private ModelOutlineRenderer modelOutlineRenderer;

    @Getter(AccessLevel.NONE)
    private GuardianOfTheRiftOptimizerPlugin plugin;

    @Getter(AccessLevel.NONE)
    private GameObject depositPool;

    @Inject
    public HighlightDepositPoolOverlay(GuardianOfTheRiftOptimizerPlugin plugin) {
        this.plugin = plugin;
        this.setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        GameObject gameObject = event.getGameObject();
        if (gameObject.getId() != StaticConstant.MINIGAME_DEPOSIT_POOL_ID) return;
        this.depositPool = gameObject;
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        GameObject gameObject = event.getGameObject();
        if (gameObject.getId() != StaticConstant.MINIGAME_DEPOSIT_POOL_ID) return;
        this.depositPool = null;
    }

    @Override
    public void renderWhenSecure(Graphics2D graphics2D) {
        if (depositPool == null) return;
        if (!getRenderSafetyEvent().isWidgetAvailable()) return;
        GuardianOfTheRiftOptimizerConfig config = plugin.getConfig();
        if (!config.isDepositPoolOutlineEnabled()) return;
        try {
            Shape hull = depositPool.getConvexHull();
            if (hull == null) return;
            this.modelOutlineRenderer.drawOutline(
                    depositPool,
                    config.depositPoolOutlineWidth(),
                    config.depositPoolOutlineColor(),
                    config.depositPoolOutlineFeatherDistance()
            );
        } catch (NullPointerException e) {
            // ignore
        }
    }
}

package com.hawolt.gotr.overlay;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerConfig;
import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import com.hawolt.gotr.data.ChargeableCellType;
import com.hawolt.gotr.data.StaticConstant;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.GameState;
import net.runelite.api.GroundObject;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GroundObjectSpawned;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

import javax.inject.Inject;
import java.awt.*;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class HighlightCellTileOverlay extends AbstractMinigameRenderer {

    @Inject
    private ModelOutlineRenderer modelOutlineRenderer;

    @Getter(AccessLevel.NONE)
    private GuardianOfTheRiftOptimizerPlugin plugin;

    @Getter(AccessLevel.NONE)
    private final Set<GroundObject> availableCellTypes = new HashSet<>();

    @Inject
    public HighlightCellTileOverlay(GuardianOfTheRiftOptimizerPlugin plugin) {
        this.plugin = plugin;
        this.setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() != GameState.LOADING) return;
        this.availableCellTypes.clear();
    }
    
    @Subscribe
    public void onGroundObjectSpawned(GroundObjectSpawned event) {
        var groundObject = event.getGroundObject();
        if (!StaticConstant.MINIGAME_CELL_TILE_IDS.contains(groundObject.getId())) return;
        this.availableCellTypes.removeIf(
                cellTile -> cellTile.getWorldLocation().distanceTo(groundObject.getWorldLocation()) < 1
        );
        this.availableCellTypes.add(groundObject);
    }

    @Override
    public void renderWhenSecure(Graphics2D graphics2D) {
        GuardianOfTheRiftOptimizerConfig config = plugin.getConfig();
        if (!config.isCellTilesOutlineEnabled()) return;
        ChargeableCellType type = this.plugin.getInventoryEssenceSlice().getAvailableChargeableCellType();
        if (type == null) return;
        WorldPoint currentPlayerLocation = plugin.getClient().getLocalPlayer().getWorldLocation();
        List<GroundObject> sortedNearestToFurthest = this.availableCellTypes.stream().sorted(
                Comparator.comparingInt(a -> a.getWorldLocation().distanceTo(currentPlayerLocation))
        ).collect(Collectors.toList());
        if (sortedNearestToFurthest.isEmpty()) return;
        GroundObject closest = sortedNearestToFurthest.get(0);
        if (closest == null) return;
        this.modelOutlineRenderer.drawOutline(
                closest,
                config.cellTilesOutlineWidth(),
                config.cellTilesOutlineColor(),
                config.cellTilesOutlineFeatherDistance()
        );
    }
}

package com.hawolt.gotr.overlay;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import com.hawolt.gotr.Slice;
import com.hawolt.gotr.data.MinigameState;
import com.hawolt.gotr.data.StaticConstant;
import com.hawolt.gotr.data.TypeAssociation;
import com.hawolt.gotr.events.RenderSafetyEvent;
import com.hawolt.gotr.events.minigame.impl.MinigameStateEvent;
import com.hawolt.gotr.events.minigame.impl.PointGainedEvent;
import com.hawolt.gotr.events.minigame.impl.PointResetEvent;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.MenuAction;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.LineComponent;

import javax.inject.Inject;
import java.awt.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


public class PointStatusOverlay extends OverlayPanel implements Slice {

    @Inject
    protected EventBus bus;

    @Getter(AccessLevel.NONE)
    private final Object lock = new Object();

    @Getter(AccessLevel.NONE)
    private final GuardianOfTheRiftOptimizerPlugin plugin;

    @Getter(AccessLevel.NONE)
    private RenderSafetyEvent renderSafetyEvent;

    @Getter(AccessLevel.NONE)
    private Color potentialPointStatusColor = Color.RED;

    @Getter(AccessLevel.NONE)
    private int elementalPoints, catalyticPoints;

    @Getter(AccessLevel.NONE)
    private int elementalRewardPoints, catalyticRewardPoints;

    @Getter(AccessLevel.NONE)
    private int totalElementalRewardPoints = -1, totalCatalyticRewardPoints = -1;

    @Getter(AccessLevel.NONE)
    private final Pattern CHECKUP_POINT_PATTERN = Pattern.compile(StaticConstant.MINIGAME_POINT_STATUS_CHECKUP);

    @Getter(AccessLevel.NONE)
    private final Pattern GAINED_POINT_PATTERN = Pattern.compile(StaticConstant.MINIGAME_POINT_STATUS_GAINED);

    @Getter(AccessLevel.NONE)
    private final Pattern TOTAL_POINT_PATTERN = Pattern.compile(StaticConstant.MINIGAME_POINT_STATUS_TOTAL);

    @Override
    public void startup() {
        this.bus.register(this);
    }

    @Override
    public void shutdown() {
        this.bus.unregister(this);
    }

    @Override
    public boolean isClientThreadRequiredOnStartup() {
        return false;
    }

    @Override
    public boolean isClientThreadRequiredOnShutDown() {
        return false;
    }

    @Inject
    public PointStatusOverlay(GuardianOfTheRiftOptimizerPlugin plugin) {
        this.plugin = plugin;
        this.setPosition(plugin.getConfig().pointStatusOverlayPosition());
        this.getMenuEntries().add(
                new OverlayMenuEntry(
                        MenuAction.RUNELITE_OVERLAY_CONFIG,
                        OverlayManager.OPTION_CONFIGURE,
                        "Guardians of the Rift Point Analysis"
                )
        );
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged) {
        if (!"pointStatusInfoboxPosition".equals(configChanged.getKey())) return;
        this.setPosition(plugin.getConfig().pointStatusOverlayPosition());
    }

    @Subscribe
    public void onRenderSafetyEvent(RenderSafetyEvent event) {
        this.renderSafetyEvent = event;
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        if (!renderSafetyEvent.isInGame()) return;
        Widget dialog = plugin.getClient().getWidget(
                StaticConstant.GAME_DIALOG_WIDGET_GROUP,
                StaticConstant.GAME_DIALOG_WIDGET_CONTENT
        );
        if (dialog == null) return;
        String content = dialog.getText();
        Matcher matcher = CHECKUP_POINT_PATTERN.matcher(content);
        if (!matcher.find()) return;
        this.totalElementalRewardPoints = Integer.parseInt(matcher.group(2));
        this.totalCatalyticRewardPoints = Integer.parseInt(matcher.group(1));
    }


    @Subscribe
    public void onPointGainedEvent(PointGainedEvent event) {
        synchronized (lock) {
            TypeAssociation typeAssociation = event.getRuneType();
            switch (typeAssociation) {
                case ELEMENTAL:
                    this.elementalPoints += event.getGained();
                    break;
                case CATALYTIC:
                    this.catalyticPoints += event.getGained();
                    break;
            }
        }
        this.potentialPointStatusColor = (elementalPoints + catalyticPoints) >= 300 ?
                Color.GREEN :
                Color.RED;
    }

    @Subscribe
    public void onMinigameStateEvent(MinigameStateEvent event) {
        if (event.getCurrentMinigameState() != MinigameState.CLOSING) return;
        this.onPointResetEvent(null);
    }

    @Subscribe
    public void onPointResetEvent(PointResetEvent event) {
        this.potentialPointStatusColor = Color.RED;
        this.elementalPoints = 0;
        this.catalyticPoints = 0;
    }

    @Subscribe
    public void onChatMessage(ChatMessage message) {
        String content = message.getMessage();
        if (message.getType() == ChatMessageType.GAMEMESSAGE) {
            checkGainedPointStatus(content);
            checkTotalPointStatus(content);
        } else if (message.getType() == ChatMessageType.SPAM) {
            checkPointsSpent(content);
        }
    }

    private void checkPointsSpent(String content) {
        if (!content.startsWith("You found some loot: ")) return;
        this.totalElementalRewardPoints -= 1;
        this.totalCatalyticRewardPoints -= 1;
    }

    private void checkTotalPointStatus(String content) {
        Matcher matcher = TOTAL_POINT_PATTERN.matcher(content);
        if (!matcher.find()) return;
        this.totalElementalRewardPoints = Integer.parseInt(matcher.group(1));
        this.totalCatalyticRewardPoints = Integer.parseInt(matcher.group(2));
    }

    private void checkGainedPointStatus(String content) {
        Matcher matcher = GAINED_POINT_PATTERN.matcher(content);
        if (!matcher.find()) return;
        this.elementalRewardPoints += Integer.parseInt(matcher.group(1));
        this.catalyticRewardPoints += Integer.parseInt(matcher.group(2));
    }

    @Override
    public Dimension render(Graphics2D graphics2D) {
        if (renderSafetyEvent == null) return null;
        if (!plugin.getConfig().isShowPointStatusInfobox()) return null;
        if (renderSafetyEvent.isInGame() || renderSafetyEvent.isWidgetVisible()) {
            this.panelComponent.getChildren().add(
                    LineComponent.builder()
                            .left("Reward Points:")
                            .right(
                                    String.format(
                                            "%s/%s",
                                            totalElementalRewardPoints != -1 ? totalElementalRewardPoints : "?",
                                            totalCatalyticRewardPoints != -1 ? totalCatalyticRewardPoints : "?"
                                    )
                            )
                            .build()
            );
        }
        if (renderSafetyEvent.isWidgetVisible()) {
            this.panelComponent.getChildren().add(
                    LineComponent.builder()
                            .left("Potential:")
                            .rightColor(potentialPointStatusColor)
                            .right(
                                    String.format(
                                            "%s/%s",
                                            String.format("%.2f", elementalPoints / 100D),
                                            String.format("%.2f", catalyticPoints / 100D)
                                    )
                            )
                            .build()
            );
        }
        return super.render(graphics2D);
    }
}

package com.hawolt.gotr.overlay;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import com.hawolt.gotr.data.StaticConstant;
import com.hawolt.gotr.utility.ImageOutline;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.util.ImageUtil;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.io.UncheckedIOException;
import java.util.concurrent.ScheduledExecutorService;

public class BindingNecklaceIndicatorOverlay extends AbstractMinigameRenderer {

    @Inject
    private ItemManager itemManager;

    @Inject
    private ScheduledExecutorService executor;

    @Getter(AccessLevel.NONE)
    private final int SPRITE_DIMENSION_HEIGHT = 32;

    @Getter(AccessLevel.NONE)
    private final int SPRITE_DIMENSION_WIDTH = 32;

    @Getter(AccessLevel.NONE)
    private GuardianOfTheRiftOptimizerPlugin plugin;

    @Getter(AccessLevel.NONE)
    private boolean isMagicImbueActive;

    @Getter(AccessLevel.NONE)
    private BufferedImage blank;

    @Inject
    public BindingNecklaceIndicatorOverlay(GuardianOfTheRiftOptimizerPlugin plugin) {
        this.plugin = plugin;
        this.setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public void startup() {
        super.startup();
        this.blank = ImageUtil.loadImageResource(BindingNecklaceIndicatorOverlay.class, "/blank_sprite.png");
    }

    @Override
    public void shutdown() {
        this.blank = null;
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged changed) {
        if (changed.getVarbitId() != VarbitID.MAGIC_IMBUE_ACTIVE) return;
        this.isMagicImbueActive = changed.getValue() > 0;
    }

    @Override
    public Dimension render(Graphics2D graphics2D) {
        if (blank == null) return null;
        if (getRenderSafetyEvent() == null) return null;
        if (!getRenderSafetyEvent().isWidgetAvailable() || getRenderSafetyEvent().isVolatileState()) return null;
        this.renderWhenSecure(graphics2D);
        return null;
    }

    @Override
    public void renderWhenSecure(Graphics2D graphics2D) {
        if (!plugin.getConfig().isShowBindingNecklaceStatus()) return;

        Widget parentWidget = plugin.getClient().getWidget(StaticConstant.MINIGAME_WIDGET_PARENT_ID);
        Widget guardianWidget = plugin.getClient().getWidget(StaticConstant.MINIGAME_WIDGET_GUARDIAN_ID);

        if (parentWidget == null || guardianWidget == null) return;
        if (parentWidget.isHidden() || guardianWidget.isHidden()) return;


        BufferedImage sprite = itemManager.getImage(StaticConstant.BINDING_NECKLACE_ITEM_ID);
        if (sprite == null) return;

        sprite = !plugin.getEquipmentSlice().isBindingNecklaceEquipped() ?
                ImageUtil.grayscaleImage(sprite) :
                sprite;

        int spriteLocationX = parentWidget.getRelativeX() + guardianWidget.getRelativeX() + guardianWidget.getWidth() + 16;
        int spriteLocationY = parentWidget.getRelativeY() + guardianWidget.getRelativeY() + 12;

        int charges = plugin.getBindingNecklaceSlice().getBindingNecklaceCharges();
        String text = String.format(
                "%s/%s",
                charges <= 0 ? "?" : charges,
                16
        );

        if (charges <= plugin.getConfig().bindingNecklaceChargeWarningThreshold()) {
            graphics2D.drawImage(
                    ImageOutline.create(blank, Color.RED),
                    spriteLocationX - 1,
                    spriteLocationY - 1,
                    null
            );
        } else if (isMagicImbueActive) {
            graphics2D.drawImage(
                    ImageOutline.create(blank, Color.CYAN),
                    spriteLocationX - 1,
                    spriteLocationY - 1,
                    null
            );
        }


        graphics2D.drawImage(
                blank,
                spriteLocationX,
                spriteLocationY,
                null
        );
        graphics2D.drawImage(
                sprite,
                spriteLocationX,
                spriteLocationY,
                null
        );

        Rectangle bounds = new Rectangle(
                spriteLocationX,
                spriteLocationY + SPRITE_DIMENSION_HEIGHT + 1,
                SPRITE_DIMENSION_WIDTH,
                24);

        this.drawStringCenteredToBoundingBox(
                graphics2D,
                bounds,
                text,
                Color.WHITE
        );

    }
}

package com.hawolt.gotr.simulator;

import lombok.Getter;

public class SimulatedPouch {

    @Getter
    private int availableEssenceInPouch;

    public SimulatedPouch(int availableEssenceInPouch) {
        this.availableEssenceInPouch = availableEssenceInPouch;
    }

    public int empty(int requested) {
        if (isEmpty()) return 0;
        int availableForReturn;
        if (requested >= availableEssenceInPouch) {
            availableForReturn = availableEssenceInPouch;
        } else {
            availableForReturn = requested;
        }
        this.availableEssenceInPouch -= availableForReturn;
        return availableForReturn;
    }

    public boolean isEmpty() {
        return availableEssenceInPouch == 0;
    }

    public static SimulatedPouch create(int availableEssenceInPouch) {
        return new SimulatedPouch(availableEssenceInPouch);
    }
}

package com.hawolt.gotr.simulator;

import com.hawolt.gotr.data.RuneCraftInfo;
import lombok.Getter;

@Getter
public class Simulator {

    private final SimulatedEnvironment simulatedEnvironment;
    private final SimulatedInventory simulatedInventory;
    private final SimulatedPouch simulatedPouch;

    public Simulator(
            int availableEssenceInInventory,
            int availableFreeInventorySlots,
            int availableEssenceInPouch,
            int bindingNecklaceCharges,
            RuneCraftInfo runeCraftInfo
    ) {
        this.simulatedPouch = SimulatedPouch.create(
                availableEssenceInPouch
        );
        this.simulatedInventory = SimulatedInventory.create(
                availableEssenceInInventory,
                availableFreeInventorySlots,
                simulatedPouch
        );
        this.simulatedEnvironment = SimulatedEnvironment.create(
                bindingNecklaceCharges,
                runeCraftInfo
        );
    }

    public double simulateTotalCraftedRunes() {
        boolean result;
        do {
            result = simulatedInventory.craft(simulatedEnvironment);
        } while (result);
        return simulatedInventory.getTotalRunesCrafted();
    }

    public static Simulator createInstance(
            int availableEssenceInInventory,
            int availableFreeInventorySlots,
            int availableEssenceInPouch,
            int bindingNecklaceCharges,
            RuneCraftInfo runeCraftInfo
    ) {
        return new Simulator(
                availableEssenceInInventory,
                availableFreeInventorySlots,
                availableEssenceInPouch,
                bindingNecklaceCharges,
                runeCraftInfo
        );
    }
}

package com.hawolt.gotr.simulator;

import com.hawolt.gotr.data.RuneCraftInfo;
import lombok.AccessLevel;
import lombok.Getter;

public class SimulatedEnvironment {

    @Getter(AccessLevel.PUBLIC)
    private final RuneCraftInfo runeCraftInfo;

    private int bindingNecklaceCharges;

    public SimulatedEnvironment(int bindingNecklaceCharges, RuneCraftInfo runeCraftInfo) {
        this.bindingNecklaceCharges = bindingNecklaceCharges;
        this.runeCraftInfo = runeCraftInfo;
    }

    public void consumeBindingNecklaceCharge() {
        this.bindingNecklaceCharges -= 1;
    }

    public boolean isBindingNecklaceChargeAvailable() {
        return bindingNecklaceCharges > 0;
    }

    public static SimulatedEnvironment create(int bindingNecklaceCharges, RuneCraftInfo runeCraftInfo) {
        return new SimulatedEnvironment(
                bindingNecklaceCharges,
                runeCraftInfo
        );
    }
}

package com.hawolt.gotr.simulator;

import com.hawolt.gotr.data.RuneCraftInfo;
import lombok.Getter;

public class SimulatedInventory {
    private final SimulatedPouch simulatedPouch;

    private int
            availableEssenceInInventory,
            availableFreeInventorySlots;

    private boolean isFirstCraft = true;

    @Getter
    private double totalRunesCrafted;

    public SimulatedInventory(
            int availableEssenceInInventory,
            int availableFreeInventorySlots,
            SimulatedPouch simulatedPouch
    ) {
        this.availableEssenceInInventory = availableEssenceInInventory;
        this.availableFreeInventorySlots = availableFreeInventorySlots;
        this.simulatedPouch = simulatedPouch;
    }

    public boolean craft(SimulatedEnvironment environment) {
        if (availableEssenceInInventory == 0 && simulatedPouch.isEmpty()) return false;
        if (availableFreeInventorySlots > 0) {
            int essenceFromPouch = simulatedPouch.empty(availableFreeInventorySlots);
            this.availableFreeInventorySlots -= essenceFromPouch;
            this.availableEssenceInInventory += essenceFromPouch;
        }
        RuneCraftInfo runeCraftInfo = environment.getRuneCraftInfo();
        this.totalRunesCrafted += !runeCraftInfo.isCombinationRune() ?
                availableEssenceInInventory :
                environment.isBindingNecklaceChargeAvailable() ?
                        availableEssenceInInventory :
                        availableEssenceInInventory / 2D;
        if (environment.isBindingNecklaceChargeAvailable()) {
            environment.consumeBindingNecklaceCharge();
        }
        this.availableFreeInventorySlots += availableEssenceInInventory;
        if (isFirstCraft) {
            this.availableFreeInventorySlots -= 1;
            this.isFirstCraft = false;
        }
        this.availableEssenceInInventory = 0;
        return true;
    }

    public static SimulatedInventory create(
            int availableEssenceInInventory,
            int availableFreeInventorySlots,
            SimulatedPouch simulatedPouch
    ) {
        return new SimulatedInventory(
                availableEssenceInInventory,
                availableFreeInventorySlots,
                simulatedPouch

        );
    }
}

package com.hawolt.gotr.utility;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import com.hawolt.gotr.data.Obelisk;
import com.hawolt.gotr.data.RuneCraftInfo;
import com.hawolt.gotr.data.StaticConstant;
import com.hawolt.gotr.pathfinding.PathCreator;
import com.hawolt.gotr.pathfinding.Pathfinder;
import com.hawolt.gotr.simulator.Simulator;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.GameObject;
import net.runelite.api.coords.WorldPoint;
import org.apache.commons.lang3.tuple.Pair;

import java.util.LinkedList;
import java.util.List;
import java.util.Objects;

public class ObeliskAnalysis {

    @Getter(AccessLevel.PUBLIC)
    private final RuneCraftInfo runeCraftInfo;
    @Getter(AccessLevel.PUBLIC)
    private final GameObject gameObject;
    @Getter(AccessLevel.PUBLIC)
    private final Obelisk obelisk;
    @Getter(AccessLevel.PUBLIC)
    private double weightedEfficiency;
    @Getter(AccessLevel.PUBLIC)
    private int normalizedTileDistance;
    @Getter(AccessLevel.PUBLIC)
    private boolean isTalismanAvailable, isDowngradeBetter;

    @Getter(AccessLevel.NONE)
    private final GuardianOfTheRiftOptimizerPlugin plugin;
    @Getter(AccessLevel.PUBLIC)
    private List<WorldPoint> pathToGuardian;

    public ObeliskAnalysis(
            GuardianOfTheRiftOptimizerPlugin plugin,
            Obelisk obelisk,
            GameObject gameObject
    ) {
        this.plugin = plugin;
        this.obelisk = obelisk;
        this.gameObject = gameObject;
        this.runeCraftInfo = RuneCraftInfo.find(plugin.getConfig(), obelisk);
        this.weightedEfficiency = calculateEfficiency();
        this.isTalismanAvailable = plugin.getInventoryEssenceSlice().getAvailableTalismanList().stream()
                .anyMatch(item -> item.getId() == obelisk.getTalismanItemId());
    }

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        ObeliskAnalysis that = (ObeliskAnalysis) o;
        return obelisk == that.obelisk;
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(obelisk);
    }

    private double calculateEfficiency() {
        Pathfinder pathfinder = new Pathfinder(plugin);
        Pair<List<WorldPoint>, Boolean> pathPair = PathCreator.pathTo(pathfinder, gameObject);

        this.pathToGuardian = PathCreator.make(
                plugin.getClient(),
                pathPair.getLeft(),
                plugin.getPathfinderSlice().getBlockedWorldAreaByNPC(),
                true,
                new LinkedList<>(),
                new LinkedList<>(),
                pathPair.getRight()
        );

        int availableEmptyInventorySlots = plugin.getInventoryEssenceSlice().getEmptyInventorySlots();
        int availableEssenceInPouches = plugin.getPouchEssenceSlice().getAvailableEssenceInPouches();
        int availableEssenceInInventory = plugin.getInventoryEssenceSlice().getEssenceInInventory();
        int bindingNecklaceCharges = plugin.getBindingNecklaceSlice().getBindingNecklaceCharges();

        Simulator simulator = Simulator.createInstance(
                availableEssenceInInventory,
                availableEmptyInventorySlots,
                availableEssenceInPouches,
                bindingNecklaceCharges,
                runeCraftInfo
        );

        int totalEssence = availableEssenceInInventory + availableEssenceInPouches;
        double totalRuneYield = simulator.simulateTotalCraftedRunes();

        int outside = normalizeTileCount(pathToGuardian.size());
        int inside = normalizeTileCount(obelisk.getTileDistance()) << 1;
        int cellExperienceReward = plugin.getInventoryEssenceSlice().isUnchargedCellAvailable() ?
                obelisk.getCellType().getExperienceReward() :
                0;

        this.normalizedTileDistance = outside;

        long timeToWalk = (outside + inside) * StaticConstant.GAME_TICK_DURATION;

        double baseExperienceYield = (cellExperienceReward + (runeCraftInfo.getBaseExperience() * totalRuneYield));

        double downGradeExperience = runeCraftInfo.isCombinationRune() ?
                cellExperienceReward + (runeCraftInfo.getBaseRuneCraftInfo().getBaseExperience() * totalEssence) :
                baseExperienceYield;

        if (!runeCraftInfo.isCombinationRune()) {
            this.isDowngradeBetter = false;
        } else {
            if (plugin.getEquipmentSlice().isBindingNecklaceEquipped()) {
                this.isDowngradeBetter = downGradeExperience > baseExperienceYield;
            } else {
                this.isDowngradeBetter = true;
            }
        }

        return ((isDowngradeBetter ? downGradeExperience : baseExperienceYield) / (double) timeToWalk) * 100D;
    }

    private static int normalizeTileCount(int amount) {
        return (amount % 2 == 0) ? amount : amount + 1;
    }

    @Override
    public String toString() {
        return "ObeliskAnalysis{" +
                "runeCraftInfo=" + runeCraftInfo +
                ", obelisk=" + obelisk +
                ", weightedEfficiency=" + weightedEfficiency +
                ", normalizedTileDistance=" + normalizedTileDistance +
                ", isTalismanAvailable=" + isTalismanAvailable +
                ", isDowngradeBetter=" + isDowngradeBetter +
                '}';
    }
}

package com.hawolt.gotr.utility;

import java.awt.*;
import java.awt.image.BufferedImage;

public class ImageOutline {
    public static BufferedImage create(BufferedImage image, Color outlineColor) {
        int width = image.getWidth();
        int height = image.getHeight();

        BufferedImage padded = new BufferedImage(width + 2, height + 2, BufferedImage.TYPE_INT_ARGB);

        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                int pixel = image.getRGB(x, y);
                int alpha = (pixel >> 24) & 0xff;
                if (alpha > 0) {
                    padded.setRGB(x + 1, y + 1, pixel);
                }
            }
        }

        boolean[][] isColored = new boolean[width + 2][height + 2];
        for (int y = 1; y <= height; y++) {
            for (int x = 1; x <= width; x++) {
                int alpha = (padded.getRGB(x, y) >> 24) & 0xff;
                if (alpha > 0) {
                    isColored[x][y] = true;
                }
            }
        }
        for (int y = 1; y <= height; y++) {
            for (int x = 1; x <= width; x++) {
                if (isColored[x][y]) {
                    togglePixel(padded, x, y, outlineColor);
                    togglePixel(padded, x - 1, y, outlineColor);
                    togglePixel(padded, x + 1, y, outlineColor);
                    togglePixel(padded, x, y - 1, outlineColor);
                    togglePixel(padded, x, y + 1, outlineColor);
                }
            }
        }

        return padded;
    }

    private static void togglePixel(BufferedImage image, int x, int y, Color color) {
        if (x < 0 || x >= image.getWidth() || y < 0 || y >= image.getHeight()) return;
        image.setRGB(x, y, color.getRGB());
    }
}

package com.hawolt.gotr.slices;

import com.hawolt.gotr.AbstractPluginSlice;
import com.hawolt.gotr.data.StaticConstant;
import com.hawolt.gotr.events.RenderSafetyEvent;
import com.hawolt.gotr.events.minigame.impl.RegionUpdateEvent;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;

public class RenderSafetySlice extends AbstractPluginSlice {
    @Getter(AccessLevel.PUBLIC)
    private boolean isInGame, isVolatileState, widgetAvailable, widgetVisible;

    @Getter(AccessLevel.NONE)
    private int currentRegionId;

    @Override
    protected void startUp() {

    }

    @Override
    protected void shutDown() {

    }

    @Subscribe
    public void onRegionUpdateEvent(RegionUpdateEvent event) {
        this.currentRegionId = event.getCurrentRegionId();
        this.isInGame = currentRegionId == StaticConstant.MINIGAME_REGION_ID;
        this.bus.post(new RenderSafetyEvent(isVolatileState, isInGame, widgetAvailable, widgetVisible));
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        this.isVolatileState = StaticConstant.VOLATILE_GAME_STATES.contains(event.getGameState());
        this.bus.post(new RenderSafetyEvent(isVolatileState, isInGame, widgetAvailable, widgetVisible));
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        if (client.getGameState() != GameState.LOGGED_IN) return;
        Widget widget = client.getWidget(
                StaticConstant.MINIGAME_WIDGET_GROUP_ID,
                StaticConstant.MINIGAME_WIDGET_CHILD_GAME_ID
        );
        boolean widgetAvailable = null != widget;
        boolean widgetVisible = widgetAvailable && !widget.isHidden();
        if (widgetAvailable == this.widgetAvailable && widgetVisible == this.widgetVisible) return;
        this.widgetAvailable = widgetAvailable;
        this.widgetVisible = widgetVisible;
        this.bus.post(new RenderSafetyEvent(isVolatileState, isInGame, widgetAvailable, widgetVisible));
    }
}

package com.hawolt.gotr.slices;

import com.hawolt.gotr.AbstractPluginSlice;
import com.hawolt.gotr.data.Pouch;
import com.hawolt.gotr.data.StaticConstant;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.client.eventbus.Subscribe;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class PouchEssenceSlice extends AbstractPluginSlice {

    @Getter(AccessLevel.NONE)
    private final Object lock = new Object();

    @Getter(AccessLevel.NONE)
    private final Map<Pouch, Boolean> pouchInUseMapping = new HashMap<>();

    @Override
    public boolean isClientThreadRequiredOnStartup() {
        return true;
    }

    @Override
    protected void startUp() {
        if (client.getGameState() != GameState.LOGGED_IN) return;
        this.handle(client.getItemContainer(StaticConstant.INVENTORY_CONTAINER_ID));
    }

    @Override
    protected void shutDown() {

    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event) {
        if (client.getGameState() != GameState.LOGGED_IN) return;
        if (event.getContainerId() != StaticConstant.INVENTORY_CONTAINER_ID) return;
        this.handle(event.getItemContainer());
    }

    private void handle(ItemContainer container) {
        if (container == null) return;
        Item[] inventory = container.getItems();
        synchronized (lock) {
            for (Pouch pouch : Pouch.VALUES) {
                boolean isPouchInUse = Arrays.stream(inventory)
                        .anyMatch(item -> item.getId() == pouch.getItemId());
                this.pouchInUseMapping.put(pouch, isPouchInUse);
            }
        }
    }

    public int getAvailableEssenceInPouches() {
        synchronized (lock) {
            return pouchInUseMapping.entrySet()
                    .stream()
                    .filter(Map.Entry::getValue)
                    .map(Map.Entry::getKey)
                    .mapToInt(pouch -> pouch.getStoredEssenceAmount(plugin.getClient()))
                    .sum();
        }
    }

}

package com.hawolt.gotr.slices;

import com.hawolt.gotr.AbstractPluginSlice;
import com.hawolt.gotr.events.TickTimestampEvent;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;

public class TickTimestampSlice extends AbstractPluginSlice {
    @Override
    protected void startUp() {

    }

    @Override
    protected void shutDown() {

    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        this.bus.post(new TickTimestampEvent(client.getTickCount(), System.currentTimeMillis()));
    }
}

package com.hawolt.gotr.slices;

import com.hawolt.gotr.AbstractPluginSlice;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.stream.Collectors;

public class PathfinderSlice extends AbstractPluginSlice {
    @Inject
    private Client client;

    @Inject
    private ScheduledExecutorService executor;

    @Getter(AccessLevel.PUBLIC)
    private final List<WorldArea> blockedWorldAreaByNPC = new ArrayList<>();

    @Getter(AccessLevel.PUBLIC)
    private Map<Integer, Integer> objectBlocking, npcBlocking;

    @Override
    protected void startUp() {
        this.executor.execute(() -> {
            this.objectBlocking = load("/loc_blocking.txt");
            this.npcBlocking = load("/npc_blocking.txt");
        });
    }

    @Override
    protected void shutDown() {
        this.objectBlocking = null;
        this.npcBlocking = null;
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        if (objectBlocking == null || npcBlocking == null) return;
        this.updateBlockedByNPC();
    }

    private void updateBlockedByNPC() {
        List<NPC> npcs = client.getLocalPlayer().getWorldView().npcs()
                .stream()
                .collect(Collectors.toCollection(ArrayList::new));
        this.blockedWorldAreaByNPC.clear();
        for (NPC npc : npcs) {
            NPCComposition npcComposition = npc.getTransformedComposition();
            if (npcComposition == null) {
                continue;
            }
            if (getBlockingNPC(npcComposition.getId())) {
                this.blockedWorldAreaByNPC.add(npc.getWorldArea());
            }
        }
    }

    public int getObjectBlocking(final int objectId, final int rotation) {
        if (objectBlocking == null) return 0;
        int blockingValue = objectBlocking.getOrDefault(objectId, 0);
        return rotation == 0 ?
                blockingValue :
                (((blockingValue << rotation) & 0xF) + (blockingValue >> (4 - rotation)));
    }

    public boolean getBlockingNPC(final int npcCompId) {
        if (npcBlocking == null) return false;
        return npcBlocking.getOrDefault(npcCompId, 0) == 1;
    }

    private static Map<Integer, Integer> load(String resource) {
        Map<Integer, Integer> map = new LinkedHashMap<>();
        try (InputStream inputStream = PathfinderSlice.class.getResourceAsStream(resource)) {
            if (inputStream == null) return map;
            String[] content = new String(inputStream.readAllBytes(), StandardCharsets.UTF_8).split("\n");
            for (String line : content) {
                String[] split = line.trim().split("=");
                int id = Integer.parseInt(split[0]);
                int blocking = Integer.parseInt(split[1].split(" ")[0]);
                map.put(id, blocking);
            }
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        return map;
    }
}

package com.hawolt.gotr.slices;

import com.hawolt.gotr.AbstractPluginSlice;
import com.hawolt.gotr.data.MinigameState;
import com.hawolt.gotr.data.StaticConstant;
import com.hawolt.gotr.data.TypeAssociation;
import com.hawolt.gotr.events.minigame.impl.*;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.eventbus.Subscribe;

public class MinigameSlice extends AbstractPluginSlice {

    @Getter(AccessLevel.NONE)
    private int
            elementalEnergy,
            catalyticEnergy,
            currentPower,
            maximumPower,
            portalLocation,
            elementalRuneEnumIndex,
            catalyticRuneEnumIndex,
            currentGuardians,
            maximumGuardians,
            guardianTicksRemaining,
            portalTicksRemaining,
            internalCurrentRegionId,
            internalElementalEnergy,
            internalCatalyticEnergy,
            internalCurrentPower,
            internalMaximumPower,
            internalPortalLocation,
            internalElementalRuneEnumIndex,
            internalCatalyticRuneEnumIndex,
            internalCurrentGuardians,
            internalMaximumGuardians,
            internalGuardianTicksRemaining,
            internalPortalTicksRemaining,
            currentRegionId,
            internalCurrentClientTick;

    @Getter(AccessLevel.NONE)
    private boolean
            isMilestoneDispatched,
            isEligibleForRewardDispatched,
            isRegionUpdateDispatched;

    @Getter(AccessLevel.NONE)
    private MinigameState minigameState;

    @Override
    public void startUp() {
        this.resetMinigameState();
    }

    @Override
    public void shutDown() {

    }

    @Subscribe
    public void onGameTick(GameTick event) {
        if (client.getGameState() != GameState.LOGGED_IN) return;
        this.internalCurrentRegionId = client.getLocalPlayer().getWorldLocation().getRegionID();
        if (currentRegionId != internalCurrentRegionId) {
            this.handleRegionUpdateEvent();
        }
        this.currentPower = internalCurrentPower;
        this.maximumPower = internalMaximumPower;
        this.portalLocation = internalPortalLocation;
        this.elementalEnergy = internalElementalEnergy;
        this.catalyticEnergy = internalCatalyticEnergy;
        this.currentRegionId = internalCurrentRegionId;
        this.currentGuardians = internalCurrentGuardians;
        this.maximumGuardians = internalMaximumGuardians;
        this.portalTicksRemaining = internalPortalTicksRemaining;
        this.guardianTicksRemaining = internalGuardianTicksRemaining;
        this.elementalRuneEnumIndex = internalElementalRuneEnumIndex;
        this.catalyticRuneEnumIndex = internalCatalyticRuneEnumIndex;
    }


    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() != GameState.LOGGED_IN) return;
        this.resetMinigameState();
    }

    private void resetMinigameState() {
        this.internalCurrentPower = Integer.MAX_VALUE;
        this.minigameState = MinigameState.UNKNOWN;
        this.isEligibleForRewardDispatched = false;
        this.isRegionUpdateDispatched = false;
        this.isMilestoneDispatched = false;
    }

    @Subscribe
    public void onScriptPreFired(ScriptPreFired event) {
        if (event.getScriptId() != StaticConstant.MINIGAME_HUD_UPDATE_SCRIPT_ID) return;
        Object[] arguments = event.getScriptEvent().getArguments();
        this.internalElementalEnergy = Integer.parseInt(arguments[1].toString());
        this.internalCatalyticEnergy = Integer.parseInt(arguments[2].toString());
        this.internalCurrentPower = Integer.parseInt(arguments[3].toString());
        this.internalMaximumPower = Integer.parseInt(arguments[4].toString());
        this.internalPortalLocation = Integer.parseInt(arguments[5].toString());
        this.internalElementalRuneEnumIndex = Integer.parseInt(arguments[6].toString());
        this.internalCatalyticRuneEnumIndex = Integer.parseInt(arguments[7].toString());
        this.internalCurrentGuardians = Integer.parseInt(arguments[8].toString());
        this.internalMaximumGuardians = Integer.parseInt(arguments[9].toString());
        this.internalGuardianTicksRemaining = Integer.parseInt(arguments[10].toString());
        this.internalPortalTicksRemaining = Integer.parseInt(arguments[11].toString());
        this.internalCurrentClientTick = client.getTickCount();
        this.handleInternalGameState();
        this.handleInternalGameEvent();
    }

    @Subscribe
    public void onMinigameStateEvent(MinigameStateEvent event) {
        boolean isPreviouslyUnknown = event.getPreviousMinigameState() == MinigameState.UNKNOWN;
        if (event.getCurrentMinigameState() == MinigameState.ACTIVE && isPreviouslyUnknown) {
            int guardianPower = (int) (((double) internalCurrentPower / (double) internalMaximumPower) * 100D);
            this.isMilestoneDispatched = guardianPower >= 60;
        }
        if (event.getCurrentMinigameState() != MinigameState.CLOSED) return;
        this.isMilestoneDispatched = false;
    }

    private void handleInternalGameState() {
        MinigameState minigameState = getMinigameState();
        if (this.minigameState == minigameState) return;

        this.bus.post(new MinigameStateEvent(internalCurrentClientTick, minigameState, this.minigameState));

        if (minigameState == MinigameState.CLOSING && this.minigameState != MinigameState.CLOSING) {
            this.bus.post(new GameStatusEvent(internalCurrentClientTick, currentPower == maximumPower));
        }

        this.minigameState = minigameState;
    }

    private MinigameState getMinigameState() {
        int technicallyStartingPower = internalMaximumPower / 10;
        boolean isGameInIdle = internalCatalyticRuneEnumIndex == 0 && internalElementalRuneEnumIndex == 0;
        MinigameState minigameState;
        if (internalMaximumPower == 0) {
            minigameState = MinigameState.INITIALIZING;
        } else if (internalCurrentPower == internalMaximumPower) {
            minigameState = MinigameState.COMPLETE;
        } else if (internalPortalLocation == 0 && internalCurrentPower == 0 && internalPortalTicksRemaining == -1) {
            minigameState = MinigameState.CLOSED;
        } else if (internalCurrentPower == 0 && internalPortalLocation == -1) {
            minigameState = MinigameState.CLOSING;
        } else if (internalCurrentPower == technicallyStartingPower && isGameInIdle) {
            minigameState = MinigameState.START;
        } else {
            minigameState = MinigameState.ACTIVE;
        }
        return minigameState;
    }

    private void handleInternalGameEvent() {
        this.handleMilestoneEvent();
        this.handlePointResetEvent();
        this.handlePortalSpawnEvent();
        this.handleObeliskUpdateEvent();
        this.handleGuardianSpawnEvent();
        this.handleGuardianDespawnEvent();
        this.handlePortalDespawnSpawnEvent();
        this.handleElementalPointGainEvent();
        this.handleCatalyticPointGainEvent();
    }

    private void handleGuardianDespawnEvent() {
        if (internalCurrentGuardians >= currentGuardians) return;
        this.bus.post(new GuardianDespawnEvent(internalCurrentClientTick, internalCurrentGuardians));
    }

    private void handleGuardianSpawnEvent() {
        if (internalCurrentGuardians <= currentGuardians) return;
        this.bus.post(new GuardianSpawnEvent(internalCurrentClientTick, internalCurrentGuardians));
    }

    private void handleObeliskUpdateEvent() {
        boolean isElementalEnumIndexUpdated = internalElementalRuneEnumIndex != elementalRuneEnumIndex;
        boolean isCatalyticEnumIndexUpdated = internalCatalyticRuneEnumIndex != catalyticRuneEnumIndex;
        if (!isElementalEnumIndexUpdated && !isCatalyticEnumIndexUpdated) return;
        this.bus.post(
                new ObeliskTickRemainingEvent(
                        client.getTickCount(),
                        internalGuardianTicksRemaining
                )
        );
    }

    private void handlePortalDespawnSpawnEvent() {
        if (internalPortalLocation > 0 || portalLocation <= 0) return;
        this.bus.post(new PortalDespawnEvent(internalCurrentClientTick));
    }

    private void handlePortalSpawnEvent() {
        if (internalPortalLocation <= 0 || portalLocation > 0) return;
        this.bus.post(new PortalSpawnEvent(internalCurrentClientTick, internalPortalTicksRemaining));
    }

    private void handlePointResetEvent() {
        if (internalElementalEnergy >= elementalEnergy) return;
        if (internalCatalyticEnergy >= catalyticEnergy) return;
        this.bus.post(new PointResetEvent(internalCurrentClientTick));
    }

    private void handleElementalPointGainEvent() {
        if (internalElementalEnergy <= elementalEnergy) return;
        this.bus.post(
                new PointGainedEvent(
                        internalCurrentClientTick,
                        TypeAssociation.ELEMENTAL,
                        internalElementalEnergy - elementalEnergy,
                        internalElementalEnergy
                )
        );
        this.handleRewardEligibilityEvent();
    }

    private void handleCatalyticPointGainEvent() {
        if (internalCatalyticEnergy <= catalyticEnergy) return;
        this.bus.post(
                new PointGainedEvent(
                        internalCurrentClientTick,
                        TypeAssociation.CATALYTIC,
                        internalCatalyticEnergy - catalyticEnergy,
                        internalCatalyticEnergy
                )
        );
        this.handleRewardEligibilityEvent();
    }

    private void handleRewardEligibilityEvent() {
        if ((internalElementalEnergy + internalCatalyticEnergy) < 300) return;
        this.isEligibleForRewardDispatched = true;
        this.bus.post(new RewardEligibleEvent(internalCurrentClientTick));
    }

    private void handleMilestoneEvent() {
        int guardianPower = (int) (((double) internalCurrentPower / (double) internalMaximumPower) * 100D);
        if (guardianPower < 60 || isMilestoneDispatched) return;
        this.isMilestoneDispatched = true;
        this.bus.post(new MilestoneEvent(internalCurrentClientTick));
    }

    private void handleRegionUpdateEvent() {
        if (internalCurrentRegionId == currentRegionId) return;
        this.bus.post(new RegionUpdateEvent(internalCurrentClientTick, internalCurrentRegionId, currentRegionId));
    }
}

package com.hawolt.gotr.slices;

import com.hawolt.gotr.AbstractPluginSlice;
import com.hawolt.gotr.events.EssenceAmountUpdateEvent;
import com.hawolt.gotr.events.ObeliskAnalysisEvent;
import com.hawolt.gotr.events.RenderSafetyEvent;
import com.hawolt.gotr.events.TickTimestampEvent;
import com.hawolt.gotr.events.minigame.impl.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
public class EventDebugSlice extends AbstractPluginSlice {

    @Override
    protected void startUp() {

    }

    @Override
    protected void shutDown() {

    }

    @Subscribe
    public void onTickTimestampEvent(TickTimestampEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onRenderSafetyEvent(RenderSafetyEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onObeliskAnalysisEvent(ObeliskAnalysisEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onEssenceAmountUpdateEvent(EssenceAmountUpdateEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onRewardEligibleEvent(RewardEligibleEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onRegionUpdateEvent(RegionUpdateEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onPortalSpawnEvent(PortalSpawnEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onPortalDespawnEvent(PortalDespawnEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onPointGainedEvent(PointGainedEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onObeliskUpdateEvent(ObeliskUpdateEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onMinigameStateEvent(MinigameStateEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onMilestoneEvent(MilestoneEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onGuardianSpawnEvent(GuardianSpawnEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onGuardianDespawnEvent(GuardianDespawnEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onGameStatusEvent(GameStatusEvent event) {
        log.info("{}", event);
    }

    @Subscribe
    public void onPointResetEvent(PointResetEvent event) {
        log.info("{}", event);
    }
}

package com.hawolt.gotr.slices;

import com.hawolt.gotr.AbstractPluginSlice;
import com.hawolt.gotr.data.StaticConstant;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.GameState;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.client.eventbus.Subscribe;

import java.util.Arrays;

public class EquipmentSlice extends AbstractPluginSlice {

    @Getter(AccessLevel.PUBLIC)
    private boolean isBindingNecklaceEquipped;


    @Override
    public boolean isClientThreadRequiredOnStartup() {
        return true;
    }

    protected void startUp() {
        if (client.getGameState() != GameState.LOGGED_IN) return;
        this.handle(client.getItemContainer(InventoryID.WORN));
    }

    @Override
    protected void shutDown() {

    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event) {
        if (client.getGameState() != GameState.LOGGED_IN) return;
        if (event.getContainerId() != InventoryID.WORN) return;
        this.handle(event.getItemContainer());
    }

    private void handle(ItemContainer container) {
        if (container == null) return;
        this.isBindingNecklaceEquipped = Arrays.stream(container.getItems())
                .anyMatch(item -> item.getId() == StaticConstant.BINDING_NECKLACE_ITEM_ID);
    }
}

package com.hawolt.gotr.slices;

import com.hawolt.gotr.AbstractPluginSlice;
import com.hawolt.gotr.data.ChargeableCellType;
import com.hawolt.gotr.data.StaticConstant;
import com.hawolt.gotr.events.EssenceAmountUpdateEvent;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.eventbus.Subscribe;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class InventorySlice extends AbstractPluginSlice {

    @Getter(AccessLevel.PUBLIC)
    private int
            essenceInInventory,
            emptyInventorySlots,
            availableUnchargedCells;

    @Getter(AccessLevel.PUBLIC)
    private boolean
            isGuardianStoneAvailable,
            isChargedCellAvailable,
            isChiselAvailable,
            isUnchargedCellAvailable;

    @Getter(AccessLevel.PUBLIC)
    private ChargeableCellType availableChargeableCellType;


    @Getter(AccessLevel.PUBLIC)
    private List<Item> availableTalismanList = Collections.emptyList();


    @Override
    public boolean isClientThreadRequiredOnStartup() {
        return true;
    }

    @Override
    protected void startUp() {
        this.essenceInInventory = 0;
        this.emptyInventorySlots = 0;
        if (client.getGameState() != GameState.LOGGED_IN) return;
        this.handle(client.getItemContainer(InventoryID.INV));
    }

    @Override
    protected void shutDown() {

    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event) {
        if (client.getGameState() != GameState.LOGGED_IN) return;
        if (event.getContainerId() != InventoryID.INV) return;
        this.handle(event.getItemContainer());
    }

    private void handle(ItemContainer container) {
        if (container == null) return;
        Item[] inventory = container.getItems();
        int essenceInInventory = 0;
        int emptyInventorySlots = 0;
        for (Item item : inventory) {
            if (item.getId() == StaticConstant.MINIGAME_GUARDIAN_STONE_ID) essenceInInventory++;
            else if (item.getId() == -1) emptyInventorySlots++;
        }
        if (this.essenceInInventory != essenceInInventory) {
            this.bus.post(new EssenceAmountUpdateEvent(this.essenceInInventory, essenceInInventory));
        }
        this.essenceInInventory = essenceInInventory;
        this.emptyInventorySlots = emptyInventorySlots;
        this.isGuardianStoneAvailable = Arrays.stream(inventory)
                .anyMatch(item -> StaticConstant.MINIGAME_GUARDIAN_STONE_IDS.contains(item.getId()));
        this.isUnchargedCellAvailable = Arrays.stream(inventory)
                .anyMatch(item -> item.getId() == StaticConstant.MINIGAME_UNCHARGED_CELL_ID);
        this.isChargedCellAvailable = Arrays.stream(inventory)
                .anyMatch(item -> StaticConstant.MINIGAME_CHARGED_CELL_IDS.contains(item.getId()));
        this.isChiselAvailable = Arrays.stream(inventory)
                .anyMatch(item -> item.getId() == ItemID.CHISEL);
        this.availableUnchargedCells = Arrays.stream(inventory)
                .filter(item -> item.getId() == StaticConstant.MINIGAME_UNCHARGED_CELL_ID)
                .mapToInt(Item::getQuantity)
                .sum();
        List<ChargeableCellType> chargeableCellTypeList = Arrays.stream(inventory)
                .filter(item -> StaticConstant.MINIGAME_CHARGED_CELL_IDS.contains(item.getId()))
                .map(item -> ChargeableCellType.byItemId(item.getId()))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
        this.availableChargeableCellType = chargeableCellTypeList.isEmpty() ? null : chargeableCellTypeList.get(0);
        this.availableTalismanList = Arrays.stream(inventory)
                .filter(item -> StaticConstant.MINIGAME_TALISMAN_IDS.contains(item.getId()))
                .collect(Collectors.toList());
    }
}

package com.hawolt.gotr.slices;

import com.hawolt.gotr.AbstractPluginSlice;
import com.hawolt.gotr.data.StaticConstant;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.eventbus.Subscribe;

@Getter
public class BindingNecklaceSlice extends AbstractPluginSlice {

    @Getter(AccessLevel.PUBLIC)
    private int bindingNecklaceCharges;

    @Subscribe
    public void onVarbitChanged(VarbitChanged event) {
        if (event.getVarbitId() != -1) return;
        if (event.getVarpId() != StaticConstant.BINDING_NECKLACE_VARP_ID) return;
        this.bindingNecklaceCharges = event.getValue();
    }

    @Override
    public boolean isClientThreadRequiredOnStartup() {
        return true;
    }

    @Override
    protected void startUp() {
        this.bindingNecklaceCharges = client.getVarpValue(StaticConstant.BINDING_NECKLACE_VARP_ID);
    }

    @Override
    protected void shutDown() {

    }
}

package com.hawolt.gotr.slices;

import com.hawolt.gotr.AbstractPluginSlice;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.client.eventbus.Subscribe;

public class MuteSlice extends AbstractPluginSlice {
    @Override
    protected void startUp() {

    }

    @Override
    protected void shutDown() {

    }

    @Subscribe
    public void onOverheadTextChanged(OverheadTextChanged event) {
        if (event.getActor().getName() == null) return;
        if (!plugin.getConfig().isHideApprenticeHelpMessages()) return;
        if (!event.getActor().getName().matches("Apprentice (Tamara|Cordelia)")) return;
        event.getActor().setOverheadText("");
    }
}

package com.hawolt.gotr.slices;

import com.hawolt.gotr.AbstractPluginSlice;
import com.hawolt.gotr.GuardianOfTheRiftOptimizerConfig;
import com.hawolt.gotr.events.RenderSafetyEvent;
import com.hawolt.gotr.events.minigame.impl.GuardianDespawnEvent;
import com.hawolt.gotr.events.minigame.impl.GuardianSpawnEvent;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.PostMenuSort;
import net.runelite.client.eventbus.Subscribe;

import java.util.Arrays;

public class MenuOptionSlice extends AbstractPluginSlice {

    @Getter(AccessLevel.NONE)
    private int currentGuardianAmount;

    @Getter(AccessLevel.NONE)
    private RenderSafetyEvent renderSafetyEvent;

    @Override
    protected void startUp() {

    }

    @Override
    protected void shutDown() {

    }

    @Subscribe
    public void onRenderSafetyEvent(RenderSafetyEvent renderSafetyEvent) {
        this.renderSafetyEvent = renderSafetyEvent;
    }

    @Subscribe
    public void onGuardianDespawnEvent(GuardianDespawnEvent event) {
        this.currentGuardianAmount = event.getCurrentAmountOfGuardians();
    }

    @Subscribe
    public void onGuardianSpawnEvent(GuardianSpawnEvent event) {
        this.currentGuardianAmount = event.getCurrentAmountOfGuardians();
    }

    @Subscribe
    public void onPostMenuSort(PostMenuSort event) {
        if (renderSafetyEvent == null) return;
        if (!renderSafetyEvent.isWidgetAvailable()) return;
        if (client.isMenuOpen()) return;
        InventorySlice inventorySlice = plugin.getInventoryEssenceSlice();
        GuardianOfTheRiftOptimizerConfig config = plugin.getConfig();
        Menu menu = client.getMenu();
        MenuEntry[] entries = menu.getMenuEntries();
        entries = handleGuardianAssembleNoMaterial(config, inventorySlice, entries);
        entries = handleGroundItemPlaceCell(config, inventorySlice, entries);
        entries = handleGuardianPowerUp(config, inventorySlice, entries);
        entries = handleGuardianAssembleAllActive(config, entries);
        entries = handleDepositPoolDepositOption(config, entries);
        entries = handleUseOptionOnPlayer(config, entries);
        entries = handleApprenticeTalkTo(config, entries);
        entries = handleRuneUseOption(config, entries);
        menu.setMenuEntries(entries);
    }

    private MenuEntry[] handleRuneUseOption(GuardianOfTheRiftOptimizerConfig config, MenuEntry[] entries) {
        if (!config.isHideRuneUseInMinigame()) return entries;
        MenuEntry[] adjusted = Arrays.stream(entries)
                .filter(
                        entry ->
                                !entry.getTarget().contains(" rune") ||
                                        !entry.getOption().equals("Use")
                ).toArray(MenuEntry[]::new);
        Arrays.stream(adjusted).filter(entry -> entry.getOption().equals("Drop")).forEach(option -> option.setType(MenuAction.CC_OP));
        return adjusted;
    }

    private MenuEntry[] handleUseOptionOnPlayer(
            GuardianOfTheRiftOptimizerConfig config,
            MenuEntry[] entries
    ) {
        return config.isHideUseOptionOnPlayer() ?
                Arrays.stream(entries)
                        .filter(
                                entry ->
                                        !entry.getTarget().contains(" rune") ||
                                                entry.getPlayer() == null ||
                                                !entry.getOption().equals("Use")
                        ).toArray(MenuEntry[]::new) :
                entries;
    }

    private MenuEntry[] handleDepositPoolDepositOption(
            GuardianOfTheRiftOptimizerConfig config,
            MenuEntry[] entries
    ) {
        return config.isHideDepositPoolDepositOption() ?
                Arrays.stream(entries)
                        .filter(
                                entry ->
                                        entry.getTarget().contains(" rune") ||
                                                (!entry.getOption().contains("Deposit-items") &&
                                                        !entry.getOption().contains("Deposit-runes") &&
                                                        !entry.getTarget().contains("Deposit Pool"))
                        ).toArray(MenuEntry[]::new) :
                entries;
    }

    private MenuEntry[] handleGuardianAssembleNoMaterial(
            GuardianOfTheRiftOptimizerConfig config,
            InventorySlice inventorySlice,
            MenuEntry[] entries
    ) {
        return config.isHideGuardianAssembleNoMaterial() && !inventorySlice.isChiselAvailable() ?
                Arrays.stream(entries)
                        .filter(
                                entry ->
                                        !entry.getOption().contains("Assemble") &&
                                                !entry.getTarget().contains("Essence Pile")
                        ).toArray(MenuEntry[]::new) :
                entries;
    }

    private MenuEntry[] handleGuardianAssembleAllActive(
            GuardianOfTheRiftOptimizerConfig config,
            MenuEntry[] entries
    ) {
        return config.isHideGuardianAssembleAllActive() && currentGuardianAmount == 10 ?
                Arrays.stream(entries)
                        .filter(
                                entry ->
                                        !entry.getOption().contains("Assemble") &&
                                                !entry.getTarget().contains("Essence Pile")
                        ).toArray(MenuEntry[]::new) :
                entries;
    }

    private MenuEntry[] handleGroundItemPlaceCell(
            GuardianOfTheRiftOptimizerConfig config,
            InventorySlice inventorySlice,
            MenuEntry[] entries
    ) {
        return config.isHideGroundItemPlaceCell() && !inventorySlice.isChargedCellAvailable() ?
                Arrays.stream(entries)
                        .filter(
                                entry -> !entry.getOption().contains("Place-cell")
                        ).toArray(MenuEntry[]::new) :
                entries;
    }

    private MenuEntry[] handleGuardianPowerUp(
            GuardianOfTheRiftOptimizerConfig config,
            InventorySlice inventorySlice,
            MenuEntry[] entries
    ) {
        return config.isHideGuardianPowerUp() && !inventorySlice.isGuardianStoneAvailable() ?
                Arrays.stream(entries)
                        .filter(
                                entry -> !entry.getOption().contains("Power-up") ||
                                        !entry.getTarget().contains("Great Guardian")
                        ).toArray(MenuEntry[]::new) :
                entries;
    }

    private MenuEntry[] handleApprenticeTalkTo(GuardianOfTheRiftOptimizerConfig config, MenuEntry[] entries) {
        return config.isHideApprenticeTalkTo() ?
                Arrays.stream(entries)
                        .filter(
                                entry ->
                                        !entry.getOption().contains("Talk-to") &&
                                                (
                                                        !entry.getTarget().contains("Apprentice Cordelia") ||
                                                                !entry.getTarget().contains("Apprentice Tamara")
                                                )
                        ).toArray(MenuEntry[]::new) :
                entries;
    }
}

package com.hawolt.gotr.slices;

import com.hawolt.gotr.AbstractPluginSlice;
import com.hawolt.gotr.data.*;
import com.hawolt.gotr.events.EssenceAmountUpdateEvent;
import com.hawolt.gotr.events.ObeliskAnalysisEvent;
import com.hawolt.gotr.events.RenderSafetyEvent;
import com.hawolt.gotr.events.minigame.impl.MinigameStateEvent;
import com.hawolt.gotr.events.minigame.impl.ObeliskTickRemainingEvent;
import com.hawolt.gotr.events.minigame.impl.ObeliskUpdateEvent;
import com.hawolt.gotr.events.minigame.impl.RegionUpdateEvent;
import com.hawolt.gotr.utility.ObeliskAnalysis;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.Animation;
import net.runelite.api.DynamicObject;
import net.runelite.api.GameObject;
import net.runelite.api.Skill;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class ObeliskSlice extends AbstractPluginSlice {

    @Getter(AccessLevel.NONE)
    private Obelisk elemental, catalytic;

    @Getter(AccessLevel.NONE)
    private WorldPoint worldPoint;

    @Getter(AccessLevel.NONE)
    private MinigameState minigameState;

    @Getter(AccessLevel.NONE)
    private RenderSafetyEvent renderSafetyEvent;

    @Getter(AccessLevel.NONE)
    private boolean isInMinigameRegion;

    @Getter(AccessLevel.NONE)
    private int currentRegionId, currentClientTick;

    @Getter(AccessLevel.NONE)
    private final Map<Integer, GameObject> obeliskGameObjects = new HashMap<>();

    @Getter(AccessLevel.NONE)
    private final List<GameObject> activeObeliskGameObjects = new ArrayList<>();

    @Override
    protected void startUp() {

    }

    @Override
    protected void shutDown() {

    }

    @Subscribe
    public void onRegionUpdateEvent(RegionUpdateEvent event) {
        this.currentRegionId = event.getCurrentRegionId();
        this.isInMinigameRegion = (currentRegionId == StaticConstant.MINIGAME_REGION_ID);
        if (isInMinigameRegion) return;
        this.bus.post(new ObeliskAnalysisEvent(ObeliskType.OPTIMAL));
        this.bus.post(new ObeliskAnalysisEvent(ObeliskType.SECONDARY));
    }

    public void onMinigameStateEvent(MinigameStateEvent event) {
        this.minigameState = event.getCurrentMinigameState();
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        List<GameObject> snapshot = new ArrayList<>(activeObeliskGameObjects);
        this.activeObeliskGameObjects.clear();
        for (GameObject guardian : obeliskGameObjects.values()) {
            Animation animation = ((DynamicObject) guardian.getRenderable()).getAnimation();
            if (animation != null && animation.getId() == StaticConstant.MINIGAME_ACTIVE_GUARDIAN_ANIMATION_ID) {
                activeObeliskGameObjects.add(guardian);
            }
        }
        Set<Integer> snapshotIds = snapshot.stream()
                .map(GameObject::getId)
                .collect(Collectors.toSet());
        Set<Integer> activeGuardianIds = activeObeliskGameObjects.stream()
                .map(GameObject::getId)
                .collect(Collectors.toSet());
        if (!snapshotIds.equals(activeGuardianIds)) handleObeliskUpdate();
        if (currentRegionId != StaticConstant.MINIGAME_REGION_ID) return;
        WorldPoint current = client.getLocalPlayer().getWorldLocation();
        if (minigameState == MinigameState.CLOSING || minigameState == MinigameState.CLOSED) return;
        if (renderSafetyEvent == null || !renderSafetyEvent.isWidgetVisible()) return;
        if (worldPoint == null || !worldPoint.equals(current)) {
            this.updateObeliskEfficiencyWeight();
        }
        this.worldPoint = current;
    }

    private void handleObeliskUpdate() {
        if (activeObeliskGameObjects.size() != 2) {
            this.catalytic = null;
            this.elemental = null;
            this.updateObeliskEfficiencyWeight();
        } else {
            Obelisk first = Obelisk.getObeliskByGameObjectId(activeObeliskGameObjects.get(0).getId());
            Obelisk second = Obelisk.getObeliskByGameObjectId(activeObeliskGameObjects.get(1).getId());
            if (first == null || second == null) return;
            boolean isFirstCatalytic = first.getTypeAssociation() == TypeAssociation.CATALYTIC;
            this.bus.post(
                    new ObeliskUpdateEvent(
                            client.getTickCount(),
                            isFirstCatalytic ? second.getIndexId() : first.getIndexId(),
                            isFirstCatalytic ? first.getIndexId() : second.getIndexId()
                    )
            );
        }
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        GameObject gameObject = event.getGameObject();
        if (!StaticConstant.MINIGAME_IDS_OBELISK_ID.contains(event.getGameObject().getId())) return;
        this.obeliskGameObjects.put(gameObject.getId(), gameObject);
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        GameObject gameObject = event.getGameObject();
        if (!StaticConstant.MINIGAME_IDS_OBELISK_ID.contains(event.getGameObject().getId())) return;
        this.obeliskGameObjects.remove(gameObject.getId());
    }

    @Subscribe
    public void onObeliskUpdateEvent(ObeliskUpdateEvent event) {
        this.catalytic = Obelisk.getObeliskByRuneIndexId(TypeAssociation.CATALYTIC, event.getCatalyticRuneEnumIndex());
        this.elemental = Obelisk.getObeliskByRuneIndexId(TypeAssociation.ELEMENTAL, event.getElementalRuneEnumIndex());
        this.updateObeliskEfficiencyWeight();
    }

    @Subscribe
    public void onEssenceAmountUpdateEvent(EssenceAmountUpdateEvent event) {
        if (currentRegionId != StaticConstant.MINIGAME_REGION_ID) return;
        this.updateObeliskEfficiencyWeight();
    }

    @Subscribe
    public void onRenderSafetyEvent(RenderSafetyEvent event) {
        this.renderSafetyEvent = event;
    }

    private void updateObeliskEfficiencyWeight() {
        if (catalytic == null || elemental == null) {
            this.bus.post(new ObeliskAnalysisEvent(ObeliskType.OPTIMAL));
            this.bus.post(new ObeliskAnalysisEvent(ObeliskType.SECONDARY));
        } else {
            if (!renderSafetyEvent.isInGame() || renderSafetyEvent.isVolatileState() || !isInMinigameRegion) return;
            Stream<Obelisk> available = plugin.getInventoryEssenceSlice().getAvailableTalismanList()
                    .stream()
                    .map(item -> Obelisk.getByTalismanItemId(item.getId()))
                    .filter(Objects::nonNull);
            List<ObeliskAnalysis> list = Stream.concat(
                            Stream.of(elemental, catalytic),
                            available
                    )
                    .distinct()
                    .map(obelisk ->
                            new ObeliskAnalysis(
                                    plugin,
                                    obelisk,
                                    obeliskGameObjects.get(obelisk.getGameObjectId())
                            )
                    )
                    .filter(analysis ->
                            client.getBoostedSkillLevel(Skill.RUNECRAFT) >= analysis.getRuneCraftInfo().getLevelRequired()
                    )

                    .sorted(Comparator.comparingDouble(ObeliskAnalysis::getWeightedEfficiency).reversed())
                    .collect(Collectors.toList());
            if (list.isEmpty()) {
                this.bus.post(new ObeliskAnalysisEvent(ObeliskType.OPTIMAL));
            } else {
                this.bus.post(new ObeliskAnalysisEvent(ObeliskType.OPTIMAL, list.get(0)));
            }
            if (list.size() > 1) {
                ObeliskAnalysis[] secondaries = list.subList(1, list.size()).toArray(ObeliskAnalysis[]::new);
                this.bus.post(new ObeliskAnalysisEvent(ObeliskType.SECONDARY, secondaries));
            } else {
                this.bus.post(new ObeliskAnalysisEvent(ObeliskType.SECONDARY));
            }
        }
    }
}

package com.hawolt.gotr.pathfinding;

import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import org.apache.commons.lang3.tuple.Pair;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class PathCreator {

    public static Pair<List<WorldPoint>, Boolean> pathTo(Pathfinder pathfinder, GameObject gameObject) {
        if (gameObject == null) return Pair.of(Collections.emptyList(), false);
        int objConfig = gameObject.getConfig();
        int sizeX = gameObject.sizeX();
        int sizeY = gameObject.sizeY();
        Point point = gameObject.getSceneMinLocation();
        return pathfinder.pathTo(point.getX(), point.getY(), sizeX, sizeY, objConfig, gameObject.getId());
    }

    private static List<WorldPoint> merge(Client client, List<WorldPoint> middlePathTiles, List<WorldPoint> pathTiles) {
        List<WorldPoint> list = new ArrayList<>();
        //   list.add(client.getLocalPlayer().getWorldLocation());
        list.addAll(middlePathTiles);
        list.addAll(pathTiles);
        return list;
    }

    public static List<WorldPoint> make(
            Client client,
            List<WorldPoint> checkpointWPs,
            List<WorldArea> npcBlockedWorldArea,
            boolean running,
            List<WorldPoint> middlePathTiles,
            List<WorldPoint> pathTiles,
            boolean pathFound
    ) {
        WorldArea currentWA = client.getLocalPlayer().getWorldArea();
        if (currentWA == null || checkpointWPs == null || checkpointWPs.isEmpty()) {
            return merge(client, middlePathTiles, pathTiles);
        }
        if ((currentWA.getPlane() != checkpointWPs.get(0).getPlane()) && pathFound) {
            return merge(client, middlePathTiles, pathTiles);
        }
        boolean runSkip = true;
        int cpTileIndex = 0;
        while (currentWA.toWorldPoint().getX() != checkpointWPs.get(checkpointWPs.size() - 1).getX()
                || currentWA.toWorldPoint().getY() != checkpointWPs.get(checkpointWPs.size() - 1).getY()) {
            WorldPoint cpTileWP = checkpointWPs.get(cpTileIndex);
            if (currentWA.toWorldPoint().equals(cpTileWP)) {
                cpTileIndex += 1;
                cpTileWP = checkpointWPs.get(cpTileIndex);
            }
            int dx = Integer.signum(cpTileWP.getX() - currentWA.getX());
            int dy = Integer.signum(cpTileWP.getY() - currentWA.getY());
            WorldArea finalCurrentWA = currentWA;
            boolean movementCheck = currentWA.canTravelInDirection(client.getTopLevelWorldView(), dx, dy, (worldPoint -> {
                WorldPoint worldPoint1 = new WorldPoint(finalCurrentWA.getX() + dx, finalCurrentWA.getY(), client.getLocalPlayer().getWorldView().getPlane());
                WorldPoint worldPoint2 = new WorldPoint(finalCurrentWA.getX(), finalCurrentWA.getY() + dy, client.getLocalPlayer().getWorldView().getPlane());
                WorldPoint worldPoint3 = new WorldPoint(finalCurrentWA.getX() + dx, finalCurrentWA.getY() + dy, client.getLocalPlayer().getWorldView().getPlane());
                for (WorldArea worldArea : npcBlockedWorldArea) {
                    if (worldArea.contains(worldPoint1) || worldArea.contains(worldPoint2) || worldArea.contains(worldPoint3)) {
                        return false;
                    }
                }
                return true;
            }));
            if (movementCheck) {
                currentWA = new WorldArea(currentWA.getX() + dx, currentWA.getY() + dy, 1, 1, client.getLocalPlayer().getWorldView().getPlane());
                if (currentWA.toWorldPoint().equals(checkpointWPs.get(checkpointWPs.size() - 1)) || !pathFound) {
                    pathTiles.add(currentWA.toWorldPoint());
                } else if (runSkip && running) {
                    middlePathTiles.add(currentWA.toWorldPoint());
                } else {
                    pathTiles.add(currentWA.toWorldPoint());
                }
                runSkip = !runSkip;
                continue;
            }
            movementCheck = currentWA.canTravelInDirection(client.getTopLevelWorldView(), dx, 0, (worldPoint -> {
                for (WorldArea worldArea : npcBlockedWorldArea) {
                    WorldPoint worldPoint1 = new WorldPoint(finalCurrentWA.getX() + dx, finalCurrentWA.getY(), client.getLocalPlayer().getWorldView().getPlane());
                    if (worldArea.contains(worldPoint1)) {
                        return false;
                    }
                }
                return true;
            }));
            if (dx != 0 && movementCheck) {
                currentWA = new WorldArea(currentWA.getX() + dx, currentWA.getY(), 1, 1, client.getLocalPlayer().getWorldView().getPlane());
                if (currentWA.toWorldPoint().equals(checkpointWPs.get(checkpointWPs.size() - 1)) || !pathFound) {
                    pathTiles.add(currentWA.toWorldPoint());
                } else if (runSkip && running) {
                    middlePathTiles.add(currentWA.toWorldPoint());
                } else {
                    pathTiles.add(currentWA.toWorldPoint());
                }
                runSkip = !runSkip;
                continue;
            }
            movementCheck = currentWA.canTravelInDirection(client.getTopLevelWorldView(), 0, dy, (worldPoint -> {
                for (WorldArea worldArea : npcBlockedWorldArea) {
                    WorldPoint worldPoint1 = new WorldPoint(finalCurrentWA.getX(), finalCurrentWA.getY() + dy, client.getLocalPlayer().getWorldView().getPlane());
                    if (worldArea.contains(worldPoint1)) {
                        return false;
                    }
                }
                return true;
            }));
            if (dy != 0 && movementCheck) {
                currentWA = new WorldArea(currentWA.getX(), currentWA.getY() + dy, 1, 1, client.getLocalPlayer().getWorldView().getPlane());
                if (currentWA.toWorldPoint().equals(checkpointWPs.get(checkpointWPs.size() - 1)) || !pathFound) {
                    pathTiles.add(currentWA.toWorldPoint());
                } else if (runSkip && running) {
                    middlePathTiles.add(currentWA.toWorldPoint());
                } else {
                    pathTiles.add(currentWA.toWorldPoint());
                }
                runSkip = !runSkip;
                continue;
            }
            return merge(client, middlePathTiles, pathTiles);
        }
        return merge(client, middlePathTiles, pathTiles);
    }
}

package com.hawolt.gotr.pathfinding;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import net.runelite.api.Client;
import net.runelite.api.CollisionData;
import net.runelite.api.Player;
import net.runelite.api.Tile;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import org.apache.commons.lang3.tuple.Pair;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Pathfinder {
    private final Client client;

    private final GuardianOfTheRiftOptimizerPlugin plugin;

    private final int[][] directions = new int[128][128];

    private final int[][] distances = new int[128][128];

    private final int[] bufferX = new int[4096];

    private final int[] bufferY = new int[4096];

    public Pathfinder(GuardianOfTheRiftOptimizerPlugin plugin) {
        this.client = plugin.getClient();
        this.plugin = plugin;
    }

    public Pair<List<WorldPoint>, Boolean> pathTo(int approxDestinationX, int approxDestinationY, int sizeX, int sizeY, int objConfig, int objID) {
        Player player = client.getLocalPlayer();
        if (player == null) {
            return null;
        }
        int z = client.getLocalPlayer().getWorldView().getPlane();

        CollisionData[] collisionData = client.getLocalPlayer().getWorldView().getCollisionMaps();
        if (collisionData == null) {
            return null;
        }

        // Initialise directions and distances
        for (int i = 0; i < 128; ++i) {
            for (int j = 0; j < 128; ++j) {
                directions[i][j] = 0;
                distances[i][j] = Integer.MAX_VALUE;
            }
        }
        LocalPoint playerTrueTileLocalPoint = LocalPoint.fromWorld(client.getLocalPlayer().getWorldView(), player.getWorldLocation());
        if (playerTrueTileLocalPoint == null) {
            return null;
        }
        int middleX = playerTrueTileLocalPoint.getSceneX();
        int middleY = playerTrueTileLocalPoint.getSceneY();
        int currentX = middleX;
        int currentY = middleY;
        int offsetX = 64;
        int offsetY = 64;
        // Initialise directions and dist
        directions[offsetX][offsetY] = 99;
        distances[offsetX][offsetY] = 0;
        int index1 = 0;
        bufferX[0] = currentX;
        int index2 = 1;
        bufferY[0] = currentY;
        int[][] collisionDataFlags = collisionData[z].getFlags();

        boolean isReachable = false;

        while (index1 != index2) {
            currentX = bufferX[index1];
            currentY = bufferY[index1];
            index1 = index1 + 1 & 4095;
            // currentX is for the local coordinate while currentMapX is for the index in the directions and distances arrays
            int currentMapX = currentX - middleX + offsetX;
            int currentMapY = currentY - middleY + offsetY;

            if (hasArrived(currentX, currentY, approxDestinationX, approxDestinationY, sizeX, sizeY, objConfig, objID, collisionDataFlags)) {
                isReachable = true;
                break;
            }

            int currentDistance = distances[currentMapX][currentMapY] + 1;
            if (currentMapX > 0 && directions[currentMapX - 1][currentMapY] == 0 && (collisionDataFlags[currentX - 1][currentY] & 19136776) == 0) {
                // Able to move 1 tile west
                bufferX[index2] = currentX - 1;
                bufferY[index2] = currentY;
                index2 = index2 + 1 & 4095;
                directions[currentMapX - 1][currentMapY] = 2;
                distances[currentMapX - 1][currentMapY] = currentDistance;
            }

            if (currentMapX < 127 && directions[currentMapX + 1][currentMapY] == 0 && (collisionDataFlags[currentX + 1][currentY] & 19136896) == 0) {
                // Able to move 1 tile east
                bufferX[index2] = currentX + 1;
                bufferY[index2] = currentY;
                index2 = index2 + 1 & 4095;
                directions[currentMapX + 1][currentMapY] = 8;
                distances[currentMapX + 1][currentMapY] = currentDistance;
            }

            if (currentMapY > 0 && directions[currentMapX][currentMapY - 1] == 0 && (collisionDataFlags[currentX][currentY - 1] & 19136770) == 0) {
                // Able to move 1 tile south
                bufferX[index2] = currentX;
                bufferY[index2] = currentY - 1;
                index2 = index2 + 1 & 4095;
                directions[currentMapX][currentMapY - 1] = 1;
                distances[currentMapX][currentMapY - 1] = currentDistance;
            }

            if (currentMapY < 127 && directions[currentMapX][currentMapY + 1] == 0 && (collisionDataFlags[currentX][currentY + 1] & 19136800) == 0) {
                // Able to move 1 tile north
                bufferX[index2] = currentX;
                bufferY[index2] = currentY + 1;
                index2 = index2 + 1 & 4095;
                directions[currentMapX][currentMapY + 1] = 4;
                distances[currentMapX][currentMapY + 1] = currentDistance;
            }

            if (currentMapX > 0 && currentMapY > 0 && directions[currentMapX - 1][currentMapY - 1] == 0 && (collisionDataFlags[currentX - 1][currentY - 1] & 19136782) == 0 && (collisionDataFlags[currentX - 1][currentY] & 19136776) == 0 && (collisionDataFlags[currentX][currentY - 1] & 19136770) == 0) {
                // Able to move 1 tile south-west
                bufferX[index2] = currentX - 1;
                bufferY[index2] = currentY - 1;
                index2 = index2 + 1 & 4095;
                directions[currentMapX - 1][currentMapY - 1] = 3;
                distances[currentMapX - 1][currentMapY - 1] = currentDistance;
            }

            if (currentMapX < 127 && currentMapY > 0 && directions[currentMapX + 1][currentMapY - 1] == 0 && (collisionDataFlags[currentX + 1][currentY - 1] & 19136899) == 0 && (collisionDataFlags[currentX + 1][currentY] & 19136896) == 0 && (collisionDataFlags[currentX][currentY - 1] & 19136770) == 0) {
                // Able to move 1 tile south-east
                bufferX[index2] = currentX + 1;
                bufferY[index2] = currentY - 1;
                index2 = index2 + 1 & 4095;
                directions[currentMapX + 1][currentMapY - 1] = 9;
                distances[currentMapX + 1][currentMapY - 1] = currentDistance;
            }

            if (currentMapX > 0 && currentMapY < 127 && directions[currentMapX - 1][currentMapY + 1] == 0 && (collisionDataFlags[currentX - 1][currentY + 1] & 19136824) == 0 && (collisionDataFlags[currentX - 1][currentY] & 19136776) == 0 && (collisionDataFlags[currentX][currentY + 1] & 19136800) == 0) {
                // Able to move 1 tile north-west
                bufferX[index2] = currentX - 1;
                bufferY[index2] = currentY + 1;
                index2 = index2 + 1 & 4095;
                directions[currentMapX - 1][currentMapY + 1] = 6;
                distances[currentMapX - 1][currentMapY + 1] = currentDistance;
            }

            if (currentMapX < 127 && currentMapY < 127 && directions[currentMapX + 1][currentMapY + 1] == 0 && (collisionDataFlags[currentX + 1][currentY + 1] & 19136992) == 0 && (collisionDataFlags[currentX + 1][currentY] & 19136896) == 0 && (collisionDataFlags[currentX][currentY + 1] & 19136800) == 0) {
                // Able to move 1 tile north-east
                bufferX[index2] = currentX + 1;
                bufferY[index2] = currentY + 1;
                index2 = index2 + 1 & 4095;
                directions[currentMapX + 1][currentMapY + 1] = 12;
                distances[currentMapX + 1][currentMapY + 1] = currentDistance;
            }
        }
        if (!isReachable) {
            // Try find a different reachable tile in the 21x21 area around the target tile, as close as possible to the target tile
            int upperboundDistance = Integer.MAX_VALUE;
            int pathLength = Integer.MAX_VALUE;
            int checkRange = 10;
            for (int i = approxDestinationX - checkRange; i <= checkRange + approxDestinationX; ++i) {
                for (int j = approxDestinationY - checkRange; j <= checkRange + approxDestinationY; ++j) {
                    int currentMapX = i - middleX + offsetX;
                    int currentMapY = j - middleY + offsetY;
                    if (currentMapX >= 0 && currentMapY >= 0 && currentMapX < 128 && currentMapY < 128 && distances[currentMapX][currentMapY] < 100) {
                        int deltaX = 0;
                        if (i < approxDestinationX) {
                            deltaX = approxDestinationX - i;
                        } else if (i > approxDestinationX + sizeX - 1) {
                            deltaX = i - (approxDestinationX + sizeX - 1);
                        }

                        int deltaY = 0;
                        if (j < approxDestinationY) {
                            deltaY = approxDestinationY - j;
                        } else if (j > approxDestinationY + sizeY - 1) {
                            deltaY = j - (approxDestinationY + sizeY - 1);
                        }

                        int distanceSquared = deltaX * deltaX + deltaY * deltaY;
                        if (distanceSquared < upperboundDistance || distanceSquared == upperboundDistance && distances[currentMapX][currentMapY] < pathLength) {
                            upperboundDistance = distanceSquared;
                            pathLength = distances[currentMapX][currentMapY];
                            currentX = i;
                            currentY = j;
                        }
                    }
                }
            }
            if (upperboundDistance == Integer.MAX_VALUE) {
                List<WorldPoint> checkpointWPs = new ArrayList<>();
                return Pair.of(checkpointWPs, false);
            }
        }

        // Getting path from directions and distances
        bufferX[0] = currentX;
        bufferY[0] = currentY;
        int index = 1;
        int directionNew;
        int directionOld;
        for (directionNew = directionOld = directions[currentX - middleX + offsetX][currentY - middleY + offsetY]; middleX != currentX || middleY != currentY; directionNew = directions[currentX - middleX + offsetX][currentY - middleY + offsetY]) {
            if (directionNew != directionOld) {
                // "Corner" of the path --> new checkpoint tile
                directionOld = directionNew;
                bufferX[index] = currentX;
                bufferY[index++] = currentY;
            }

            if ((directionNew & 2) != 0) {
                ++currentX;
            } else if ((directionNew & 8) != 0) {
                --currentX;
            }

            if ((directionNew & 1) != 0) {
                ++currentY;
            } else if ((directionNew & 4) != 0) {
                --currentY;
            }
        }

        int checkpointTileNumber = 1;
        Tile[][][] tiles = client.getLocalPlayer().getWorldView().getScene().getTiles();
        List<WorldPoint> checkpointWPs = new ArrayList<>();
        while (index-- > 0) {
            checkpointWPs.add(tiles[z][bufferX[index]][bufferY[index]].getWorldLocation());
            if (checkpointTileNumber == 25) {
                // Pathfinding only supports up to the 25 first checkpoint tiles
                break;
            }
            checkpointTileNumber++;
        }
        if (checkpointWPs.isEmpty()) {
            checkpointWPs.add(player.getWorldLocation());
            return Pair.of(checkpointWPs, true);
        }
        return Pair.of(checkpointWPs, true);
    }

    public Pair<List<WorldPoint>, Boolean> pathTo(Tile other) {
        return pathTo(other.getSceneLocation().getX(), other.getSceneLocation().getY(), 1, 1, -1, -1);
    }

    private boolean hasArrived(int baseX, int baseY, int targetX, int targetY, int sizeX, int sizeY, int objConfig, int objID, int[][] flags) {
        int objShape = -1;
        int objRot = 0;
        switch (objConfig) {
            case -2:
                objShape = -2;
                break;
            case -1:
                break;
            default: {
                objShape = objConfig & 0x1F;
                objRot = objConfig >>> 6 & 3;
            }
        }
        if (objShape != -2) {
            // Not pathing to an Actor
            if (targetX <= baseX && baseX <= targetX + sizeX - 1 && targetY <= baseY && baseY <= targetY + sizeY - 1) {
                // Inside the object or on the target tile
                return true;
            }
        }
        switch (objShape) {
            case 0: // Pathing to straight wall
                return reachStraightWall(flags, baseX, baseY, targetX, targetY, objRot);
            case 2:    // Pathing to L wall
                return reachLWall(flags, baseX, baseY, targetX, targetY, objRot);
            case 6: // Diagonal wall decoration, diagonal offset
                return reachDiagonalWallDecoration(flags, baseX, baseY, targetX, targetY, objRot);
            case 7: // Diagonal wall decoration, no offset
                return reachDiagonalWallDecoration(flags, baseX, baseY, targetX, targetY, objRot + 2 & 0x3);
            case -2: // Pathing to Actor, not an official flag
            case 8: // Diagonal wall decoration, both sides of the wall
            case 9: // Pathing to diagonal wall
            case 10: // Pathing to straight centrepiece
            case 11: // Pathing to diagonal centrepiece
            case 22: // Pathing to ground decor
            {
                int objFlags = 0;
                if (Arrays.asList(10, 11, 22).contains(objShape)) {
                    objFlags = plugin.getPathfinderSlice().getObjectBlocking(objID, objRot);
                }
                return reachRectangularBoundary(flags, baseX, baseY, targetX, targetY, sizeX, sizeY, objFlags);
            }
        }
        return false;
    }

    private boolean reachRectangularBoundary(int[][] flags, int x, int y, int destX, int destY, int destWidth, int destHeight, int objectFlags) {
        int east = destX + destWidth - 1;
        int north = destY + destHeight - 1;
        if (x == destX - 1 && y >= destY && y <= north &&
                (flags[x][y] & 0x8) == 0 &&
                (objectFlags & 0x8) == 0) {
            //Valid destination tile to the west of the rectangularBoundary
            return true;
        }
        if (x == east + 1 && y >= destY && y <= north &&
                (flags[x][y] & 0x80) == 0 &&
                (objectFlags & 0x2) == 0) {
            //Valid destination tile to the east of the rectangularBoundary
            return true;
        }
        if (y + 1 == destY && x >= destX && x <= east &&
                (flags[x][y] & 0x2) == 0 &&
                (objectFlags & 0x4) == 0) {
            //Valid destination tile to the south of the rectangularBoundary
            return true;
        }
        return y == north + 1 && x >= destX && x <= east &&
                (flags[x][y] & 0x20) == 0 &&
                (objectFlags & 0x1) == 0;
        //Test for valid destination tile to the north of the rectangularBoundary
    }

    private boolean reachStraightWall(int[][] flags, int x, int y, int destX, int destY, int rot) {
        switch (rot) {
            case 0: {
                if (x == destX - 1 && y == destY)
                    return true;
                if (x == destX && y == destY + 1 && (flags[x][y] & 0x12c0120) == 0)
                    return true;
                if (x == destX && y == destY - 1 && (flags[x][y] & 0x12c0102) == 0)
                    return true;
                break;
            }
            case 1: {
                if (x == destX && y == destY + 1)
                    return true;
                if (x == destX - 1 && y == destY && (flags[x][y] & 0x12c0108) == 0)
                    return true;
                if (x == destX + 1 && y == destY && (flags[x][y] & 0x12c0180) == 0)
                    return true;
                break;
            }
            case 2: {
                if (x == destX + 1 && y == destY)
                    return true;
                if (x == destX && y == destY + 1 && (flags[x][y] & 0x12c0120) == 0)
                    return true;
                if (x == destX && y == destY - 1 && (flags[x][y] & 0x12c0102) == 0)
                    return true;
                break;
            }
            case 3: {
                if (x == destX && y == destY - 1)
                    return true;
                if (x == destX - 1 && y == destY && (flags[x][y] & 0x12c0108) == 0)
                    return true;
                if (x == destX + 1 && y == destY && (flags[x][y] & 0x12c0180) == 0)
                    return true;
            }
        }
        return false;
    }

    private boolean reachLWall(int[][] flags, int x, int y, int destX, int destY, int rot) {
        int westWallFlags = 0x12c0108;
        int northWallFlags = 0x12c0120;
        int eastWallFlags = 0x12c0180;
        int southWallFlags = 0x12c0102;
        switch (rot) {
            case 0: {
                westWallFlags = 0;
                northWallFlags = 0;
                break;
            }
            case 1: {
                northWallFlags = 0;
                eastWallFlags = 0;
                break;
            }
            case 2: {
                eastWallFlags = 0;
                southWallFlags = 0;
                break;
            }
            case 3: {
                southWallFlags = 0;
                westWallFlags = 0;
            }
        }
        if (x == destX - 1 && y == destY && (flags[x][y] & westWallFlags) == 0)
            return true;
        if (x == destX && y == destY + 1 && (flags[x][y] & northWallFlags) == 0)
            return true;
        if (x == destX + 1 && y == destY && (flags[x][y] & eastWallFlags) == 0)
            return true;
        return x == destX && y == destY - 1 && (flags[x][y] & southWallFlags) == 0;
    }

    private boolean reachDiagonalWallDecoration(int[][] flags, int x, int y, int destX, int destY, int rot) {
        switch (rot) {
            case 0: {
                if (x == destX + 1 && y == destY && (flags[x][y] & 0x80) == 0)
                    return true;
                if (x == destX && y == destY - 1 && (flags[x][y] & 0x2) == 0)
                    return true;
                break;
            }
            case 1: {
                if (x == destX - 1 && y == destY && (flags[x][y] & 0x4) == 0)
                    return true;
                if (x == destX && y == destY - 1 && (flags[x][y] & 0x2) == 0)
                    return true;
                break;
            }
            case 2: {
                if (x == destX - 1 && y == destY && (flags[x][y] & 0x4) == 0)
                    return true;
                if (x == destX && y == destY + 1 && (flags[x][y] & 0x20) == 0)
                    return true;
                break;
            }
            case 3: {
                if (x == destX + 1 && y == destY && (flags[x][y] & 0x80) == 0)
                    return true;
                if (x == destX && y == destY + 1 && (flags[x][y] & 0x20) == 0)
                    return true;
            }
        }
        return false;
    }
}

package com.hawolt.gotr.events;

import lombok.AccessLevel;
import lombok.Getter;

public class EssenceAmountUpdateEvent {
    @Getter(AccessLevel.PUBLIC)
    private int previous, current;

    public EssenceAmountUpdateEvent(int previous, int current) {
        this.previous = previous;
        this.current = current;
    }

    @Override
    public String toString() {
        return "EssenceAmountUpdateEvent{" +
                "previous=" + previous +
                ", current=" + current +
                '}';
    }
}

package com.hawolt.gotr.events;

import com.hawolt.gotr.data.ObeliskType;
import com.hawolt.gotr.utility.ObeliskAnalysis;
import lombok.Getter;

import java.util.Arrays;

@Getter
public class ObeliskAnalysisEvent {
    private final ObeliskType obeliskType;
    private final ObeliskAnalysis[] obeliskAnalysis;

    public ObeliskAnalysisEvent(ObeliskType obeliskType, ObeliskAnalysis... obeliskAnalysis) {
        this.obeliskAnalysis = obeliskAnalysis;
        this.obeliskType = obeliskType;
    }

    @Override
    public String toString() {
        return "ObeliskAnalysisEvent{" +
                "obeliskType=" + obeliskType +
                ", obeliskAnalysis=" + Arrays.toString(obeliskAnalysis) +
                '}';
    }
}

package com.hawolt.gotr.events.minigame;

import lombok.AccessLevel;
import lombok.Getter;

@Getter(AccessLevel.PUBLIC)
public abstract class AbstractMinigameEvent {

    protected final int clientTick;

    public AbstractMinigameEvent(int clientTick) {
        this.clientTick = clientTick;
    }

    @Override
    public String toString() {
        return "AbstractMinigameEvent{" +
                "clientTick=" + clientTick +
                '}';
    }
}

package com.hawolt.gotr.events.minigame.impl;

import com.hawolt.gotr.data.TypeAssociation;
import com.hawolt.gotr.events.minigame.AbstractMinigameEvent;
import lombok.AccessLevel;
import lombok.Getter;

@Getter(AccessLevel.PUBLIC)
public class PointGainedEvent extends AbstractMinigameEvent {
    private final TypeAssociation runeType;
    private final int gained, total;

    public PointGainedEvent(int clientTick, TypeAssociation runeType, int gained, int total) {
        super(clientTick);
        this.runeType = runeType;
        this.gained = gained;
        this.total = total;
    }

    @Override
    public String toString() {
        return "PointGainedEvent{" +
                "runeType=" + runeType +
                ", gained=" + gained +
                ", total=" + total +
                ", clientTick=" + clientTick +
                '}';
    }
}

package com.hawolt.gotr.events.minigame.impl;

import com.hawolt.gotr.events.minigame.AbstractMinigameEvent;
import lombok.AccessLevel;
import lombok.Getter;

@Getter(AccessLevel.PUBLIC)
public class GuardianDespawnEvent extends AbstractMinigameEvent {
    private final int currentAmountOfGuardians;

    public GuardianDespawnEvent(int clientTick, int currentAmountOfGuardians) {
        super(clientTick);
        this.currentAmountOfGuardians = currentAmountOfGuardians;
    }

    @Override
    public String toString() {
        return "GuardianDespawnEvent{" +
                "currentAmountOfGuardians=" + currentAmountOfGuardians +
                ", clientTick=" + clientTick +
                '}';
    }
}

package com.hawolt.gotr.events.minigame.impl;

import com.hawolt.gotr.events.minigame.AbstractMinigameEvent;
import lombok.AccessLevel;
import lombok.Getter;

@Getter(AccessLevel.PUBLIC)
public class PortalSpawnEvent extends AbstractMinigameEvent {
    @Getter(AccessLevel.PUBLIC)
    private int ticksUntilDespawn;

    public PortalSpawnEvent(int clientTick, int ticksUntilDespawn) {
        super(clientTick);
        this.ticksUntilDespawn = ticksUntilDespawn;
    }

    @Override
    public String toString() {
        return "PortalSpawnEvent{" +
                "ticksUntilDespawn=" + ticksUntilDespawn +
                ", clientTick=" + clientTick +
                '}';
    }
}

package com.hawolt.gotr.events.minigame.impl;

import com.hawolt.gotr.data.MinigameState;
import com.hawolt.gotr.events.minigame.AbstractMinigameEvent;
import lombok.AccessLevel;
import lombok.Getter;

@Getter(AccessLevel.PUBLIC)
public class MinigameStateEvent extends AbstractMinigameEvent {
    private final MinigameState currentMinigameState, previousMinigameState;

    public MinigameStateEvent(int clientTick, MinigameState currentMinigameState, MinigameState previousMinigameState) {
        super(clientTick);
        this.currentMinigameState = currentMinigameState;
        this.previousMinigameState = previousMinigameState;
    }

    @Override
    public String toString() {
        return "MinigameStateEvent{" +
                "currentMinigameState=" + currentMinigameState +
                ", previousMinigameState=" + previousMinigameState +
                ", clientTick=" + clientTick +
                '}';
    }
}

package com.hawolt.gotr.events.minigame.impl;

import com.hawolt.gotr.events.minigame.AbstractMinigameEvent;
import lombok.AccessLevel;
import lombok.Getter;

@Getter(AccessLevel.PUBLIC)
public class MilestoneEvent extends AbstractMinigameEvent {
    public MilestoneEvent(int clientTick) {
        super(clientTick);
    }

    @Override
    public String toString() {
        return "MilestoneEvent{" +
                "clientTick=" + clientTick +
                '}';
    }


}

package com.hawolt.gotr.events.minigame.impl;

import com.hawolt.gotr.events.minigame.AbstractMinigameEvent;
import lombok.AccessLevel;
import lombok.Getter;

@Getter(AccessLevel.PUBLIC)
public class GuardianSpawnEvent extends AbstractMinigameEvent {
    private final int currentAmountOfGuardians;

    public GuardianSpawnEvent(int clientTick, int currentAmountOfGuardians) {
        super(clientTick);
        this.currentAmountOfGuardians = currentAmountOfGuardians;
    }

    @Override
    public String toString() {
        return "GuardianSpawnEvent{" +
                "currentAmountOfGuardians=" + currentAmountOfGuardians +
                ", clientTick=" + clientTick +
                '}';
    }
}

package com.hawolt.gotr.events.minigame.impl;

import com.hawolt.gotr.events.minigame.AbstractMinigameEvent;
import lombok.AccessLevel;
import lombok.Getter;

@Getter(AccessLevel.PUBLIC)
public class RegionUpdateEvent extends AbstractMinigameEvent {
    private final int currentRegionId, previousRegionId;

    public RegionUpdateEvent(int clientTick, int currentRegionId, int previousRegionId) {
        super(clientTick);
        this.previousRegionId = previousRegionId;
        this.currentRegionId = currentRegionId;
    }

    @Override
    public String toString() {
        return "RegionUpdateEvent{" +
                "currentRegionId=" + currentRegionId +
                ", previousRegionId=" + previousRegionId +
                ", clientTick=" + clientTick +
                '}';
    }
}

package com.hawolt.gotr.events.minigame.impl;

import com.hawolt.gotr.events.minigame.AbstractMinigameEvent;
import lombok.AccessLevel;
import lombok.Getter;

@Getter(AccessLevel.PUBLIC)
public class RewardEligibleEvent extends AbstractMinigameEvent {
    public RewardEligibleEvent(int clientTick) {
        super(clientTick);
    }

    @Override
    public String toString() {
        return "RewardEligibleEvent{" +
                "clientTick=" + clientTick +
                '}';
    }
}

package com.hawolt.gotr.events.minigame.impl;

import com.hawolt.gotr.events.minigame.AbstractMinigameEvent;
import lombok.AccessLevel;
import lombok.Getter;

@Getter(AccessLevel.PUBLIC)
public class PortalDespawnEvent extends AbstractMinigameEvent {
    public PortalDespawnEvent(int clientTick) {
        super(clientTick);
    }

    @Override
    public String toString() {
        return "PortalDespawnEvent{" +
                "clientTick=" + clientTick +
                '}';
    }
}

package com.hawolt.gotr.events.minigame.impl;

import com.hawolt.gotr.events.minigame.AbstractMinigameEvent;
import lombok.AccessLevel;
import lombok.Getter;

@Getter(AccessLevel.PUBLIC)
public class PointResetEvent extends AbstractMinigameEvent {
    public PointResetEvent(int clientTick) {
        super(clientTick);
    }

    @Override
    public String toString() {
        return "PointResetEvent{" +
                "clientTick=" + clientTick +
                '}';
    }


}

package com.hawolt.gotr.events.minigame.impl;

import com.hawolt.gotr.events.minigame.AbstractMinigameEvent;
import lombok.AccessLevel;
import lombok.Getter;

@Getter(AccessLevel.PUBLIC)
public class ObeliskTickRemainingEvent extends AbstractMinigameEvent {
    private final int remainingTicksUntilUpdate;

    public ObeliskTickRemainingEvent(
            int clientTick,
            int remainingTicksUntilUpdate
    ) {
        super(clientTick);
        this.remainingTicksUntilUpdate = remainingTicksUntilUpdate;
    }

    @Override
    public String toString() {
        return "ObeliskTickRemainingEvent{" +
                "remainingTicksUntilUpdate=" + remainingTicksUntilUpdate +
                ", clientTick=" + clientTick +
                '}';
    }
}

package com.hawolt.gotr.events.minigame.impl;

import com.hawolt.gotr.events.minigame.AbstractMinigameEvent;
import lombok.AccessLevel;
import lombok.Getter;

@Getter(AccessLevel.PUBLIC)
public class ObeliskUpdateEvent extends AbstractMinigameEvent {
    private final int elementalRuneEnumIndex, catalyticRuneEnumIndex;

    public ObeliskUpdateEvent(
            int clientTick,
            int elementalRuneEnumIndex,
            int catalyticRuneEnumIndex
    ) {
        super(clientTick);
        this.elementalRuneEnumIndex = elementalRuneEnumIndex;
        this.catalyticRuneEnumIndex = catalyticRuneEnumIndex;
    }

    @Override
    public String toString() {
        return "ObeliskUpdateEvent{" +
                "elementalRuneEnumIndex=" + elementalRuneEnumIndex +
                ", catalyticRuneEnumIndex=" + catalyticRuneEnumIndex +
                ", clientTick=" + clientTick +
                '}';
    }
}

package com.hawolt.gotr.events.minigame.impl;

import com.hawolt.gotr.events.minigame.AbstractMinigameEvent;
import lombok.AccessLevel;
import lombok.Getter;

@Getter(AccessLevel.PUBLIC)
public class GameStatusEvent extends AbstractMinigameEvent {

    private final boolean isGameWon;

    public GameStatusEvent(int clientTick, boolean isGameWon) {
        super(clientTick);
        this.isGameWon = isGameWon;
    }

    @Override
    public String toString() {
        return "GameStatusEvent{" +
                "isGameWon=" + isGameWon +
                ", clientTick=" + clientTick +
                '}';
    }
}

package com.hawolt.gotr.events;

import lombok.AccessLevel;
import lombok.Getter;

public class RenderSafetyEvent {
    @Getter(AccessLevel.PUBLIC)
    private final boolean isVolatileState, isInGame, isWidgetAvailable, isWidgetVisible;

    public RenderSafetyEvent(
            boolean isVolatileState,
            boolean isInGame,
            boolean isWidgetAvailable,
            boolean isWidgetVisible
    ) {
        this.isWidgetAvailable = isWidgetAvailable;
        this.isVolatileState = isVolatileState;
        this.isWidgetVisible = isWidgetVisible;
        this.isInGame = isInGame;
    }

    @Override
    public String toString() {
        return "RenderSafetyEvent{" +
                "isVolatileState=" + isVolatileState +
                ", isInGame=" + isInGame +
                ", isWidgetAvailable=" + isWidgetAvailable +
                ", isWidgetVisible=" + isWidgetVisible +
                '}';
    }
}

package com.hawolt.gotr.events;

import lombok.Getter;

@Getter
public class TickTimestampEvent {
    private final long timestamp;
    private final int tick;

    public TickTimestampEvent(int tick, long timestamp) {
        this.timestamp = timestamp;
        this.tick = tick;
    }

    @Override
    public String toString() {
        return "TickTimestampEvent{" +
                "timestamp=" + timestamp +
                ", tick=" + tick +
                '}';
    }
}

package com.hawolt;

import com.hawolt.gotr.GuardianOfTheRiftOptimizerPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GuardianOfTheRiftOptimizerPlugin.class);
		RuneLite.main(args);
	}
}
