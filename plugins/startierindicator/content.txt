package com.starinfo;

import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;

public class DiscordTimeStamp
{
	public static String relativeTimeNow()
	{
		long number = ZonedDateTime.ofInstant(Instant.now(), ZoneId.systemDefault()).toEpochSecond();
		return "<t:" + number + ":R>";
	}

	public static String relativeTimeNowPlus(int ticks)
	{
		int seconds = (int) (ticks * 0.6);
		long number = ZonedDateTime.ofInstant(Instant.now().plusSeconds(seconds), ZoneId.systemDefault()).toEpochSecond();
		return "<t:" + number + ":R>";
	}
}

/*
 * Copyright (c) 2022, Cute Rock
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.starinfo;

import com.google.common.base.Strings;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Shape;
import javax.inject.Inject;
import net.runelite.api.Point;
import net.runelite.api.Skill;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.util.ColorUtil;

public class StarInfoOverlay extends Overlay
{

	private static final int Y_ADJUST = 12;
	private final StarInfoPlugin plugin;
	private final StarInfoConfig config;
	private Color textColor;

	@Inject
	StarInfoOverlay(StarInfoPlugin plugin, StarInfoConfig config)
	{
		this.plugin = plugin;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPriority(OverlayPriority.LOW);
	}

	public void updateConfig()
	{
		textColor = config.getTextColor();
	}

	@Override
	public Dimension render(final Graphics2D graphics)
	{
		if (plugin.stars.isEmpty())
		{
			return null;
		}
		Star star = plugin.stars.get(0);

		if (config.colorStar() && star.getObject() != null)
		{
			Shape shape = star.getObject().getConvexHull();
			if (shape != null)
			{
				OverlayUtil.renderPolygon(graphics, shape, getStarColor());
			}
		}

		int health = star.getHealth();
		// health bar
		Point starLocation = star.getObject().getCanvasLocation(190);
		if (starLocation != null && !config.hideHealthBar() && health > 0)
		{
			try
			{
				starLocation = new Point(starLocation.getX() - config.healthBarWidth() / 2, starLocation.getY() - config.healthBarHeight() - 14);
				Color prevColor = graphics.getColor();
				graphics.setColor(config.getHpColorBack());
				graphics.fillRect(starLocation.getX(), starLocation.getY(), config.healthBarWidth(), config.healthBarHeight());
				graphics.setColor(config.getHpColorFore());
				graphics.fillRect(starLocation.getX(), starLocation.getY(), health * config.healthBarWidth() / 100, config.healthBarHeight());
				graphics.setColor(prevColor);
			}
			catch (Exception e)
			{
				return null;
			}
		}

		// Tier and Health Percent
		int yOff = 0;

		String text = "T" + star.getTier();
		if (health >= 0 && config.showPercent())
		{
			text += " " + health + "%";
		}
		starLocation = star.getObject().getCanvasTextLocation(graphics, text, 190);
		if (starLocation != null)
		{
			try
			{
				starLocation = new Point(starLocation.getX(), starLocation.getY() + yOff);
				overlayText(graphics, starLocation, text);
			}
			catch (Exception e)
			{
				return null;
			}
		}

		if (config.showMiners() && star.getMiners() != null && !star.getMiners().equals(Star.UNKNOWN_MINERS))
		{
			if (config.compact())
			{
				text = star.getMiners() + "M";
			}
			else
			{
				text = "Miners: " + star.getMiners();
			}
			starLocation = star.getObject().getCanvasTextLocation(graphics, text, 190);
			if (starLocation != null)
			{
				try
				{
					yOff += Y_ADJUST;
					starLocation = new Point(starLocation.getX(), starLocation.getY() + yOff);
					overlayText(graphics, starLocation, text);
				}
				catch (Exception e)
				{
					return null;
				}
			}
		}

		// time estimate
		if (!config.estimateLayerTime().equals(EstimateConfig.NONE))
		{
			int ticks = -1;
			if (star.getTierTicksEstimate() != null && star.getTier() <= star.getTierTicksEstimate().length) {
				ticks = star.getTierTicksEstimate()[star.getTier() - 1];
			}
			text = config.compact() ? "" : "Layer: ";
			if (config.estimateLayerTime().equals(EstimateConfig.TICKS))
			{
				text += ticks;
			}
			else
			{
				int seconds = (ticks % 100) * 3 / 5;
				int minutes = ticks / 100;
				text += minutes + ":" + String.format("%02d", seconds);
			}
			starLocation = star.getObject().getCanvasTextLocation(graphics, text, 190);
			if (starLocation != null && ticks >= 0)
			{
				try
				{
					yOff += Y_ADJUST;
					starLocation = new Point(starLocation.getX(), starLocation.getY() + yOff);
					overlayText(graphics, starLocation, text);
				}
				catch (Exception e)
				{
					return null;
				}
			}
		}

		if (!config.estimateDeathTime().equals(EstimateConfig.NONE) && star.getTierTicksEstimate() != null)
		{
			int ticks = star.getTierTicksEstimate()[0];
			text = config.compact() ? "" : "Dead: ";
			if (config.estimateDeathTime().equals(EstimateConfig.TICKS))
			{
				text += ticks;
			}
			else
			{
				int seconds = (ticks % 100) * 3 / 5;
				int minutes = ticks / 100;
				text += minutes + ":" + String.format("%02d", seconds);
			}
			starLocation = star.getObject().getCanvasTextLocation(graphics, text, 190);
			if (starLocation != null)
			{
				try
				{
					yOff += Y_ADJUST;
					starLocation = new Point(starLocation.getX(), starLocation.getY() + yOff);
					overlayText(graphics, starLocation, text);
				}
				catch (Exception e)
				{
					return null;
				}
			}
		}

		double xpPerHour = plugin.getXpPerHour();
		if (xpPerHour > 0 && config.xpPerHour())
		{
			text = Math.round(xpPerHour) + " xp/hr";
			starLocation = star.getObject().getCanvasTextLocation(graphics, text, 190);
			if (starLocation != null)
			{
				try
				{
					yOff += Y_ADJUST;
					starLocation = new Point(starLocation.getX(), starLocation.getY() + yOff);
					overlayText(graphics, starLocation, text);
				}
				catch (Exception e)
				{
					return null;
				}
			}
		}

		double dustPerHour = plugin.getDustPerHour();
		if (dustPerHour > 0 && config.dustPerHour())
		{
			text = String.format("%d sd/hr", Math.round(dustPerHour));
			starLocation = star.getObject().getCanvasTextLocation(graphics, text, 190);
			if (starLocation != null)
			{
				try
				{
					yOff += Y_ADJUST;
					starLocation = new Point(starLocation.getX(), starLocation.getY() + yOff);
					overlayText(graphics, starLocation, text);
				}
				catch (Exception e)
				{
					return null;
				}
			}
		}

		return null;
	}

	private void overlayText(Graphics2D graphics, Point starLocation, String text)
	{
		if (config.thickOutline())
		{
			renderThickOutlineText(graphics, starLocation, text, textColor);
		}
		else
		{
			OverlayUtil.renderTextLocation(graphics, starLocation, text, textColor);
		}
	}

	private Color getStarColor()
	{
		if (plugin.stars.isEmpty())
		{
			return Color.RED;
		}
		Star star = plugin.stars.get(0);
		int level = plugin.client.getBoostedSkillLevel(Skill.MINING);
		if (level < star.getTier() * 10)
		{
			return Color.RED;
		}
		return Color.GREEN;
	}

	private static void renderThickOutlineText(Graphics2D graphics, Point txtLoc, String text, Color color)
	{
		if (Strings.isNullOrEmpty(text))
		{
			return;
		}

		int x = txtLoc.getX();
		int y = txtLoc.getY();

		graphics.setColor(Color.BLACK);
		graphics.drawString(text, x + 1, y + 1);
		graphics.drawString(text, x + 1, y);
		graphics.drawString(text, x + 1, y - 1);
		graphics.drawString(text, x, y + 1);
		graphics.drawString(text, x, y - 1);
		graphics.drawString(text, x - 1, y + 1);
		graphics.drawString(text, x - 1, y);
		graphics.drawString(text, x - 1, y - 1);

		graphics.setColor(ColorUtil.colorWithAlpha(color, 0xFF));
		graphics.drawString(text, x, y);
	}
}
/*
 * Copyright (c) 2022, Cute Rock
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.starinfo;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Notification;
import net.runelite.client.config.Range;

@ConfigGroup("starinfoplugin")
public interface StarInfoConfig extends Config
{

	String TEXT_COLOR_KEY = "textColor";
	String THICK_OUTLINE = "thickOutline";
	String INFO_BOX_KEY = "infoBox";
	String BONUS_INFO_BOX_KEY = "showStarDiscovery";
	String HINT_ARROW_KEY = "hintArrow";
	String SHOW_PERCENT = "showPercent";
	String SHOW_DUST = "showDust";
	String SHOW_MINERS = "showMiners";
	String COLOR_STAR = "colorStar";
	String CLIPBOARD = "copyToClipboard";
	String T0_IN_COPY = "t0inCopy";
	String ADD_TO_CHAT = "addToChat";
	String NOTIFY_TIER_CHANGE = "notifyTierChange";
	String REMOVE_DISTANCE = "removeDistance";
	String ESTIMATE_LAYER = "estimateLayerTime";
	String ESTIMATE_DEPLETION_TIME = "estimateFullTime";

	@ConfigSection(
		name = "Text Overlay",
		description = "Settings for the text overlaid on stars",
		position = 0
	)
	String textOverlaySection = "textOverlaySection";

	@Alpha
	@ConfigItem(
		position = 1,
		keyName = TEXT_COLOR_KEY,
		name = "Text color",
		section = textOverlaySection,
		description = "Sets the color of the text above a star."
	)
	default Color getTextColor()
	{
		return Color.GREEN;
	}

	@ConfigItem(
		position = 2,
		keyName = THICK_OUTLINE,
		name = "Thick Text Outline",
		section = textOverlaySection,
		description = "Use thick text outline on star info overlay"
	)
	default boolean thickOutline()
	{
		return true;
	}

	@ConfigItem(
		position = 3,
		keyName = SHOW_MINERS,
		name = "Show Miners",
		section = textOverlaySection,
		description = "Display number of active star miners, e.g. 5M = 5 Miners"
	)
	default boolean showMiners()
	{
		return true;
	}

	@ConfigItem(
		position = 4,
		keyName = SHOW_PERCENT,
		name = "Show Layer %",
		section = textOverlaySection,
		description = "Display the health percentage of the current layer"
	)
	default boolean showPercent()
	{
		return true;
	}

	@ConfigItem(
		position = 6,
		keyName = ESTIMATE_LAYER,
		name = "Estimate Layer Time",
		section = textOverlaySection,
		description = "Display estimated time till the current layer finishes"
	)
	default EstimateConfig estimateLayerTime()
	{
		return EstimateConfig.NONE;
	}

	@ConfigItem(
		position = 8,
		keyName = ESTIMATE_DEPLETION_TIME,
		name = "Estimate Depletion Time",
		section = textOverlaySection,
		description = "Display estimated time till the star depletes"
	)
	default EstimateConfig estimateDeathTime()
	{
		return EstimateConfig.NONE;
	}

	@ConfigItem(
		position = 9,
		keyName = "xpPerHour",
		name = "Layer Xp/Hr",
		section = textOverlaySection,
		description = "Display Xp/Hr for current layer"
	)
	default boolean xpPerHour()
	{
		return false;
	}

	@ConfigItem(
		position = 10,
		keyName = "dustPerHour",
		name = "Dust/Hr",
		section = textOverlaySection,
		description = "Display how much Dust per Hour you mine for current layer"
	)
	default boolean dustPerHour()
	{
		return false;
	}

	@ConfigItem(
		position = 12,
		keyName = "compactText",
		name = "Compact text",
		section = textOverlaySection,
		description = "Use abbreviations and less text"
	)
	default boolean compact()
	{
		return false;
	}

	@ConfigItem(
		position = 13,
		keyName = INFO_BOX_KEY,
		name = "Show Info Box",
		description = "Whether to display star status info box"
	)
	default boolean showInfoBox()
	{
		return true;
	}

	@ConfigItem(
		position = 14,
		keyName = BONUS_INFO_BOX_KEY,
		name = "Show Star Discovery",
		description = "Whether to display star discovery boost info box"
	)
	default boolean showStarDiscovery()
	{
		return true;
	}

	@ConfigItem(
		position = 15,
		keyName = HINT_ARROW_KEY,
		name = "Show Hint Arrow",
		description = "Whether to display hint arrow pointing to star"
	)
	default boolean showHintArrow()
	{
		return true;
	}

	@ConfigItem(
		position = 16,
		keyName = COLOR_STAR,
		name = "Highlight Star",
		description = "Highlights stars green if you can mine it, and red if you can't"
	)
	default boolean colorStar()
	{
		return true;
	}

	@ConfigItem(
		position = 17,
		keyName = CLIPBOARD,
		name = "Copy to Clipboard Option",
		description = "Allows you to right click stars and copy their information"
	)
	default boolean copyToClipboard()
	{
		return true;
	}

	@ConfigItem(
		position = 18,
		keyName = T0_IN_COPY,
		name = "T0 Clipboard estimate",
		description = "Adds time estimate till star is dead to copy option message"
	)
	default boolean addT0Estimate()
	{
		return false;
	}

	@ConfigItem(
		position = 19,
		keyName = ADD_TO_CHAT,
		name = "Add Stars to Chat",
		description = "Adds a message to the game chat when stars are found with their tier/world/location"
	)
	default boolean addToChat()
	{
		return true;
	}

	@ConfigItem(
		position = 20,
		keyName = NOTIFY_TIER_CHANGE,
		name = "Notify Tier Change",
		description = "Notifies you when a star changes tier"
	)
	default Notification notifyTierChange()
	{
		return Notification.ON;
	}

	@ConfigSection(
		name = "Health Bar",
		description = "Settings for the health bar on stars",
		position = 21,
		closedByDefault = true
	)
	String healthBarSection = "healthBarSection";

	@ConfigItem(
		position = 22,
		keyName = "hideHealthBar",
		name = "Hide health bar",
		section = healthBarSection,
		description = "Hides the health bar of the star"
	)
	default boolean hideHealthBar()
	{
		return false;
	}

	@Range(
		min = 1,
		max = 40
	)
	@ConfigItem(
		position = 23,
		keyName = "healthBarHeight",
		name = "Health bar height",
		section = healthBarSection,
		description = "The height of the health bar (5 default)"
	)
	default int healthBarHeight()
	{
		return 5;
	}

	@Range(
		min = 10,
		max = 400
	)
	@ConfigItem(
		position = 24,
		keyName = "healthBarWidth",
		name = "Health bar width",
		section = healthBarSection,
		description = "The width of the health bar (50 default)"
	)
	default int healthBarWidth()
	{
		return 50;
	}

	@Alpha
	@ConfigItem(
		position = 25,
		keyName = "hpColorFore",
		name = "Hp left color",
		section = healthBarSection,
		description = "Sets the hp bar's hp left color"
	)
	default Color getHpColorFore()
	{
		return new Color(0,169,255, 180);
	}

	@Alpha
	@ConfigItem(
		position = 26,
		keyName = "hpColorBack",
		name = "Hp background color",
		section = healthBarSection,
		description = "Sets the hp bar's background color"
	)
	default Color getHpColorBack()
	{
		return new Color(0,22,33, 180);
	}

	@Range(
		min = 32,
		max = 90
	)
	@ConfigItem(
		position = 27,
		keyName = REMOVE_DISTANCE,
		name = "Remove distance",
		description = "The tile distance above which star info is removed"
	)
	default int removeDistance()
	{
		return 32;
	}
}

package com.starinfo;

import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.Counter;
import javax.annotation.Nonnull;
import java.awt.Color;
import java.awt.image.BufferedImage;

public class BonusCounter extends Counter
{
	private final StarInfoPlugin plugin;

	public BonusCounter(BufferedImage image, @Nonnull Plugin plugin, int bonus)
	{
		super(image, plugin, bonus);
		this.plugin = (StarInfoPlugin) plugin;
	}

	@Override
	public String getText()
	{
		return String.valueOf(plugin.bonusCount);
	}

	@Override
	public Color getTextColor()
	{
		return Color.WHITE;
	}
}

package com.starinfo;

import javax.inject.Inject;
import net.runelite.client.game.WorldService;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldType;

public class WorldInfo
{
	@Inject
	private WorldService worldService;

	public void update(Star star) {
		if (worldService.getWorlds() == null) {
			star.setWorldInfo("");
			return;
		}
		World world = worldService.getWorlds().findWorld(star.getWorld());
		if (world == null) {
			star.setWorldInfo("");
			return;
		}

		String msg = "";
		if (!world.getTypes().contains(WorldType.MEMBERS)) {
			msg += " f2p";
		}

		boolean pvp = world.getTypes().contains(WorldType.PVP);
		if (pvp) {
			msg += " PvP";
		}

		if ((pvp || star.getLocation().isWildy()) && world.getTypes().contains(WorldType.HIGH_RISK)) {
			msg += " High Risk";
		}

		if (world.getTypes().contains(WorldType.SKILL_TOTAL)) {
			msg += " " + world.getActivity();
		}

		if (!msg.isEmpty()) {
			msg = " -" + msg;
		}
		star.setWorldInfo(msg);
	}
}

package com.starinfo;

public class TierData
{
	private static final TierData[] data = new TierData[] {
		new TierData(0.29 * 255, 0.46 * 255, 32, 0, 700), //t1
		new TierData( 0.29 * 255, 0.46 * 255, 32, 0, 700), //t2
		new TierData( 0.29 * 255, 0.46 * 255, 32, 0, 700), //t3
		new TierData( 0.29 * 255, 0.46 * 255, 32, 0, 700), //t4
		new TierData( 0.29 * 255, 0.46 * 255, 32, 0, 700), //t5
		new TierData( 0.29 * 255, 0.46 * 255, 32, 0, 700), //t6
		new TierData(0.29 * 255, 0.46 * 255, 32, 0, 700), //t7
		new TierData(0.29 * 255, 0.46 * 255, 32, 0, 700), //t8
		new TierData(0.29 * 255, 0.46 * 255, 32, 0, 700) //t9
	};

	public final double lowChance;
	public final double highChance;
	public final double xp;
	public final double doubleDustChance;
	public final int tickTime;

	TierData(double lowChance, double highChance, double xp, double doubleDustChance, int tickTime)
	{
		this.lowChance = lowChance;
		this.highChance = highChance;
		this.xp = xp;
		this.doubleDustChance = doubleDustChance;
		this.tickTime = tickTime;
	}

	public static TierData get(int tier)
	{
		if (tier < 1 || tier > data.length) {
			return null;
		}
		return data[tier - 1];
	}

	public double getChance(int level) {
		return (1 + Math.floor(lowChance * (99 - level) / 98) + Math.floor(highChance * (level - 1) / 98)) / 256;
	}
}

/*
 * Copyright (c) 2022, Cute Rock
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.starinfo;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.inject.Provides;
import java.awt.Color;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import javax.inject.Inject;
import lombok.Getter;
import net.runelite.api.AnimationID;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import static net.runelite.api.ItemID.*;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.NullNpcID;
import net.runelite.api.Player;
import net.runelite.api.PlayerComposition;
import net.runelite.api.Renderable;
import net.runelite.api.Skill;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;
import net.runelite.api.WorldType;
import net.runelite.api.coords.Angle;
import net.runelite.api.coords.Direction;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.kit.KitType;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.callback.Hooks;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;

@PluginDescriptor(
	name = "Star Info",
	description = "Displays tier, number of miners, health % above shooting stars"
)
public class StarInfoPlugin extends Plugin
{
	private static final int VARBIT_STAR_DISCOVERY = 15351; //  Star discovery buff: Returns the amount of bonus stardust the player will receive from stars.
	private static final int NPC_ID = NullNpcID.NULL_10629;
	private static final int MAX_PLAYER_LOAD_DIST = 13;
	private static final Queue<Star> despawnQueue = new LinkedList<>();

	private static final Set<Integer> dragonPickSpecAnims = ImmutableSet.of(
		7138, // Dragon pickaxe
		334, // Dragon pickaxe (upgraded)
		8781, // Dragon pickaxe (or) (Trailblazer) / Infernal pickaxe (or)
		8330, // Dragon pickaxe (or)
		8329, // Crystal pickaxe
		3410 // infernal pickaxe
		// 3rd age pickaxe
	);

	private static final Map<Integer, Double> pickAnims = ImmutableMap.<Integer, Double>builder().
		put(AnimationID.MINING_CRASHEDSTAR_ADAMANT, 3.0).
		put(AnimationID.MINING_TRAILBLAZER_PICKAXE, 17.0 / 6).
		put(AnimationID.MINING_CRASHEDSTAR_BLACK, 5.0).
		put(AnimationID.MINING_CRASHEDSTAR_BRONZE, 8.0).
		put(AnimationID.MINING_CRASHEDSTAR_GILDED, 3.0).
		put(AnimationID.MINING_CRASHEDSTAR_CRYSTAL, 2.75).
		put(AnimationID.MINING_CRASHEDSTAR_3A, 17.0 / 6).
		put(AnimationID.MINING_CRASHEDSTAR_DRAGON, 17.0 / 6).
		put(AnimationID.MINING_CRASHEDSTAR_DRAGON_OR, 17.0 / 6).
		put(AnimationID.MINING_CRASHEDSTAR_DRAGON_OR_TRAILBLAZER, 17.0 / 6).
		put(AnimationID.MINING_CRASHEDSTAR_DRAGON_UPGRADED, 17.0 / 6).
		put(AnimationID.MINING_CRASHEDSTAR_INFERNAL, 17.0 / 6).
		put(AnimationID.MINING_CRASHEDSTAR_MITHRIL, 5.0).
		put(AnimationID.MINING_CRASHEDSTAR_IRON, 7.0).
		put(AnimationID.MINING_CRASHEDSTAR_RUNE, 3.0).
		put(AnimationID.MINING_CRASHEDSTAR_STEEL, 6.0).
		put(AnimationID.MINING_TRAILBLAZER_PICKAXE_3, 17.0 / 6).
		put(7138, 17.0 / 6).
		put(334, 17.0 / 6).
		put(8781, 17.0 / 6).
		put(8330, 17.0 / 6).
		put(3410, 17.0 / 6).
		put(8329, 2.75).
		build();

	private static final int MINING_CACHE_TIME = 13; // count player as a miner if they have done mining anim within this many ticks ago
	private static final Map<String, Integer> playerLastMined = new HashMap<>();

	private final Hooks.RenderableDrawListener drawListener = this::shouldDraw;

	@Inject
	private StarInfoOverlay starOverlay;

	public final List<Star> stars = new ArrayList<>();

	@Getter
	private double xpPerHour = -1;

	@Getter
	private double dustPerHour = -1;

	private boolean hintArrowShown = false;

	public int layerTimer = 0;

	public int bonusCount;

	@Inject
	private InfoBoxManager infoBoxManager;

	private StarInfoBox infoBox;
	
	private BonusCounter bonusCounter;

	private BufferedImage BONUS_IMAGE;

	@Inject
	private ItemManager itemManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	Client client;

	@Inject
	ClientThread clientThread;

	@Inject
	private StarInfoConfig starConfig;

	@Inject
	private WorldInfo worldInfo;

	@Inject
	private Hooks hooks;

	@Inject
	private Notifier notifier;

	@Provides
	StarInfoConfig
	provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(StarInfoConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(starOverlay);
		starOverlay.updateConfig();
		hooks.registerRenderableDrawListener(drawListener);
		BONUS_IMAGE = itemManager.getImage(STARDUST, 175, false);

		clientThread.invoke(() ->
		{
			if (client.getGameState() != GameState.LOGGED_IN)
			{
				return;
			}

			bonusCount = client.getVarbitValue(VARBIT_STAR_DISCOVERY);

			if (starConfig.showStarDiscovery())
			{
				updateBonusCounter();
			}
		});
	}

	@Override
	protected void shutDown() throws Exception
	{
		clear();
		refresh();
		overlayManager.remove(starOverlay);
		infoBox = null;
		removeBonusCounter();
		hooks.unregisterRenderableDrawListener(drawListener);
	}

	private void clear()
	{
		playerLastMined.clear();
		stars.clear();
		layerTimer = 0;
	}

	private boolean shouldDraw(Renderable renderable, boolean b)
	{
		if (!(renderable instanceof NPC))
		{
			return true;
		}

		NPC npc = (NPC) renderable;
		return npc.getId() != NPC_ID;
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
		if (event.getNpc().getId() != NPC_ID)
		{
			return;
		}
		for (Star star : stars)
		{
			if (star.getWorldPoint().equals(event.getNpc().getWorldLocation()))
			{
				star.setNpc(event.getNpc());
				refresh();
				return;
			}
		}
		Star star = new Star(event.getNpc(), client.getWorld());
		worldInfo.update(star);
		stars.add(0, star);
		refresh();
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		if (event.getVarbitId() != VARBIT_STAR_DISCOVERY)
		{
			return;
		}

		bonusCount = event.getValue();

		if (!starConfig.showStarDiscovery() || bonusCount == 0)
		{
			removeBonusCounter();
			return;
		}

		updateBonusCounter();
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
		if (event.getNpc().getId() != NPC_ID)
		{
			return;
		}
		for (Star star : stars)
		{
			if (star.getWorldPoint().equals(event.getNpc().getWorldLocation()))
			{
				star.setNpc(null);
				refresh();
				return;
			}
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		int tier = Star.getTier(event.getGameObject().getId());
		if (tier < 0)
		{
			return;
		}

		boolean newStar = false;
		Star star = null;
		for (Star s : stars)
		{
			if (s.getWorldPoint().equals(event.getGameObject().getWorldLocation()))
			{
				s.setObject(event.getGameObject());
				s.resetHealth();
				star = s;
				layerTimer = 0;
				despawnQueue.remove(star);
				break;
			}
		}
		if (star == null)
		{
			star = new Star(event.getGameObject(), client.getWorld());
			worldInfo.update(star);
			stars.add(0, star);
			newStar = true;
		}

		if (newStar && starConfig.addToChat())
		{
			client.addChatMessage(ChatMessageType.CONSOLE, "", star.getMessage(), "");
		}
		refresh();
	}

	private boolean nextToStar(Player p, Star star)
	{
		WorldArea areaH = new WorldArea(star.getWorldPoint().dx(-1), 4, 2);
		WorldArea areaV = new WorldArea(star.getWorldPoint().dy(-1), 2, 4);
		return p.getWorldLocation().isInArea2D(areaH, areaV);
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned event)
	{
		int tier = Star.getTier(event.getGameObject().getId());
		if (tier < 0)
		{
			return;
		}

		for (Star star : stars)
		{
			if (event.getGameObject().equals(event.getGameObject()) || event.getGameObject().getWorldLocation().equals(star.getWorldPoint()))
			{
				despawnQueue.add(star);
				if (nextToStar(client.getLocalPlayer(), star)) {
					notifier.notify(starConfig.notifyTierChange(), "Star layer mined (Shooting Star Info)");
				}
				break;
			}
		}
	}

	void updateMiners(Star star)
	{
		int distToStar = client.getLocalPlayer().getWorldLocation().distanceTo(new WorldArea(star.getWorldPoint(), 2, 2));
		if (distToStar > MAX_PLAYER_LOAD_DIST)
		{
			star.setMiners(Star.UNKNOWN_MINERS);
			return;
		}
		WorldArea areaH = new WorldArea(star.getWorldPoint().dx(-1), 4, 2);
		WorldArea areaV = new WorldArea(star.getWorldPoint().dy(-1), 2, 4);
		int count = 0;
		int tickCount = client.getTickCount();
//		List<PlayerInfo> miners = new ArrayList<>();
		for (Player p : client.getPlayers())
		{
			if (!p.getWorldLocation().isInArea2D(areaH, areaV)) // Skip players not next to the star
			{
				continue;
			}
			if (!facingObject(p.getWorldLocation(), p.getOrientation(), star.getWorldPoint()))
			{
				continue;
			}
			if (pickAnims.containsKey(p.getAnimation())) // count anyone that is doing mining animation
			{
				count++;
				playerLastMined.put(p.getName(), tickCount);
//				miners.add(new PlayerInfo(p.getName()));
				continue;
			}
			if (p.getHealthRatio() < 0 || !playerLastMined.containsKey(p.getName()))
			{
				continue;
			}
			int ticksSinceMinedLast = tickCount - playerLastMined.get(p.getName());
			if (ticksSinceMinedLast < MINING_CACHE_TIME)
			{
				count++;
//				miners.add(new PlayerInfo(p.getName()));
			}
		}
		if (starConfig.addT0Estimate() || starConfig.estimateDeathTime() != EstimateConfig.NONE || starConfig.estimateLayerTime() != EstimateConfig.NONE)
		{
			refreshEstimate(star);
		}
		layerTimer += 1;
		star.setMiners(Integer.toString(count));
	}

	public void refreshEstimate(Star star)
	{
		int[] ticks = getTicksEstimates(star);
		star.setTierTicksEstimate(ticks);
	}

	private int[] getTicksEstimates(Star star)
	{
		if (star.getHealth() < 0) {
			return null;
		}
		int startTier = star.getTier();
		if (startTier < 0) {
			return null;
		}
		int tier = startTier;
		int[] ticks = new int[startTier];
		int totalTicks = 0;
		while (tier > 0) {
			TierData tierData = TierData.get(tier);
			if (tierData == null) {
				return null;
			}
			double healthScale = tier == startTier ? (star.getHealth() / 100.0) : 1;

			totalTicks += (int) Math.ceil(healthScale * tierData.tickTime);
			tier--;
			ticks[tier] = totalTicks;
		}
		return ticks;
	}

	private double getPickTicks(Player p)
	{
		int animId = p.getAnimation();
		if (animId == AnimationID.MINING_CRYSTAL_PICKAXE) {
			// animation id is shared for active/inactive so need to look at equipment
			// note that they may not be wielding the pickaxe at all, in which case we can't know for sure
			int weaponId = p.getPlayerComposition().getEquipmentId(KitType.WEAPON);
			if (weaponId == ItemID.CRYSTAL_PICKAXE_INACTIVE) {
				return 17.0 / 6;
			}
		}
		return pickAnims.getOrDefault(p.getAnimation(), 17.0 / 6);
	}

	private double prospectorXpMulti(PlayerComposition playerComposition)
	{
		double multi = 1.0;
		if (playerComposition.getEquipmentId(KitType.HEAD) == GOLDEN_PROSPECTOR_HELMET
			|| playerComposition.getEquipmentId(KitType.HEAD) == PROSPECTOR_HELMET)
		{
			multi += 0.004;
		}
		if (playerComposition.getEquipmentId(KitType.BOOTS) == GOLDEN_PROSPECTOR_BOOTS
			|| playerComposition.getEquipmentId(KitType.HEAD) == PROSPECTOR_BOOTS)
		{
			multi += 0.002;
		}
		if (playerComposition.getEquipmentId(KitType.TORSO) == GOLDEN_PROSPECTOR_JACKET
			|| playerComposition.getEquipmentId(KitType.HEAD) == PROSPECTOR_JACKET
			|| playerComposition.getEquipmentId(KitType.HEAD) == VARROCK_ARMOUR_4)
		{
			multi += 0.008;
		}
		if (playerComposition.getEquipmentId(KitType.LEGS) == GOLDEN_PROSPECTOR_LEGS
			|| playerComposition.getEquipmentId(KitType.HEAD) == PROSPECTOR_LEGS)
		{
			multi += 0.006;
		}
		if (multi > 1.019) { // check for full set bonus
			multi += 0.005;
		}
		return multi;
	}

	private boolean facingObject(WorldPoint p1, int orientation, WorldPoint p2)
	{
		Direction dir = new Angle(orientation).getNearestDirection();
		WorldPoint dif = p2.dx(-p1.getX()).dy(-p1.getY());
		switch (dir)
		{
			case NORTH:
				return dif.getY() > 0;
			case SOUTH:
				return dif.getY() < 0;
			case EAST:
				return dif.getX() > 0;
			case WEST:
				return dif.getX() < 0;
		}
		return false;
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged state)
	{
		if (state.getGameState() == GameState.HOPPING || state.getGameState() == GameState.LOGGING_IN)
		{
			clear();
			refresh();
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		if (stars.isEmpty())
		{
			return;
		}
		Iterator<Star> it = stars.iterator();
		boolean refresh = false;
		while (it.hasNext())
		{
			Star star = it.next();
			if (despawnQueue.contains(star) || client.getLocalPlayer().getWorldLocation().distanceTo(star.getWorldPoint()) > starConfig.removeDistance())
			{
				layerTimer = 0;
				it.remove();
				refresh = true;
				despawnQueue.remove(star);
			}
		}

		if (!stars.isEmpty())
		{
			Star star = stars.get(0);
			updateMiners(star);
			refreshHintArrow();
		}

		if (starConfig.xpPerHour() || starConfig.dustPerHour())
		{
			updateXpDustPerHour();
		}

		if (refresh)
		{
			refresh();
		}
	}

	private void updateXpDustPerHour() {
		Player player = client.getLocalPlayer();
		if (player == null || stars.isEmpty()) {
			dustPerHour = -1;
			xpPerHour = -1;
			return;
		}

		Star star = stars.get(0);
		TierData tierData = TierData.get(star.getTier());
		if (tierData == null || !nextToStar(star, player.getWorldLocation())) {
			dustPerHour = -1;
			xpPerHour = -1;
			return;
		}

		int animId = player.getAnimation();
		if (!pickAnims.containsKey(animId)) {
			dustPerHour = -1;
			xpPerHour = -1;
			return;
		}

		int level = client.getBoostedSkillLevel(Skill.MINING);
		boolean members = client.getWorldType().contains(WorldType.MEMBERS);
		ItemContainer equip = client.getItemContainer(InventoryID.EQUIPMENT);
		if (members && equip != null) {
			Item ringItem = equip.getItem(EquipmentInventorySlot.RING.getSlotIdx());
			if (ringItem != null && ringItem.getId() == ItemID.CELESTIAL_RING) {
				level += 4;
			}
		}

		double ticks = getPickTicks(player);
		double chance = tierData.getChance(level);
		double dustPerTick = chance / ticks;
		double xp = members ? tierData.xp : tierData.xp / 2.0; // f2p is half xp
		double xpPerTick = dustPerTick * xp;
		if (members) {
			xpPerTick *= prospectorXpMulti(player.getPlayerComposition());
		}
		xpPerHour = xpPerTick * 6000;
		dustPerHour = dustPerTick * (1 + tierData.doubleDustChance) * 6000;
	}

	public void toggleHintArrow(boolean show) {
		if (show) {
			if (!stars.isEmpty() && !hintArrowShown) {
				Star star = stars.get(0);
				client.setHintArrow(star.getWorldPoint());
				hintArrowShown = true;
			}
		} else if (hintArrowShown) {
			client.clearHintArrow();
			hintArrowShown = false;
		}
	}

	public void refreshHintArrow() {
//		client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Refresh hint arrow", "");
		if (stars.isEmpty())
		{
			if (starConfig.showHintArrow())
			{
				toggleHintArrow(false);
			}
		}
		else
		{
			Star star = stars.get(0);
			if (starConfig.showHintArrow())
			{
				if (nextToStar(star, client.getLocalPlayer().getWorldLocation())) {
					toggleHintArrow(false);
				} else {
					toggleHintArrow(true);
				}
			}
		}
	}

	public void refresh()
	{
		if (stars.isEmpty())
		{
			if (starConfig.showInfoBox())
			{
				infoBoxManager.removeInfoBox(infoBox);
			}
		}
		else
		{
			Star star = stars.get(0);
			if (starConfig.showInfoBox())
			{
				infoBoxManager.removeInfoBox(infoBox);
				infoBox = new StarInfoBox(itemManager.getImage(25547), this, star);
				infoBoxManager.addInfoBox(infoBox);
			}
		}
		refreshHintArrow();
	}

	private void updateBonusCounter()
	{
		String tooltip = ColorUtil.wrapWithColorTag("Star Discovery", new Color(255, 119, 0)) + "</br>"
				+ ColorUtil.wrapWithColorTag("Bonus stardust: ", Color.YELLOW) + bonusCount;

		if (bonusCounter != null)
		{
			bonusCounter.setCount(bonusCount);
			bonusCounter.setTooltip(tooltip);
			return;
		}

		removeBonusCounter();

		if (bonusCount == 0)
		{
			return;
		}

		bonusCounter = new BonusCounter(BONUS_IMAGE, this, bonusCount);
		bonusCounter.setTooltip(tooltip);
		infoBoxManager.addInfoBox(bonusCounter);
	}

	private void removeBonusCounter()
	{
		if (bonusCounter == null)
		{
			return;
		}

		infoBoxManager.removeInfoBox(bonusCounter);
		bonusCounter = null;
	}

	private boolean nextToStar(Star star, WorldPoint worldPoint) {
		WorldArea areaH = new WorldArea(star.getWorldPoint().dx(-1), 4, 2);
		WorldArea areaV = new WorldArea(star.getWorldPoint().dy(-1), 2, 4);
		return worldPoint.isInArea2D(areaH, areaV);
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		if (stars.isEmpty() || event.getType() != MenuAction.EXAMINE_OBJECT.getId() || !starConfig.copyToClipboard())
		{
			return;
		}

		final Tile tile = client.getScene().getTiles()[client.getPlane()][event.getActionParam0()][event.getActionParam1()];
		final TileObject tileObject = findTileObject(tile, event.getIdentifier());

		if (tileObject == null || !tile.getWorldLocation().equals(stars.get(0).getWorldPoint()) || Star.getTier(tileObject.getId()) < 0)
		{
			return;
		}

		client.createMenuEntry(-1)
			.setOption("Copy")
			.setTarget(event.getTarget())
			.setParam0(event.getActionParam0())
			.setParam1(event.getActionParam1())
			.setIdentifier(event.getIdentifier())
			.setType(MenuAction.RUNELITE)
			.onClick(menuEntry -> copy(menuEntry, false));

		client.createMenuEntry(-2)
			.setOption("Detailed copy")
			.setTarget(event.getTarget())
			.setParam0(event.getActionParam0())
			.setParam1(event.getActionParam1())
			.setIdentifier(event.getIdentifier())
			.setType(MenuAction.RUNELITE)
			.onClick(menuEntry -> copy(menuEntry, true));
	}

	private void copy(MenuEntry menuEntry, boolean detailed)
	{
		if (stars.isEmpty())
		{
			return;
		}
		Star star = stars.get(0);
		String content = "W" + star.getWorld() + " T" + star.getTier() + " ";
		if (star.getHealth() >= 0)
		{
			content += star.getHealth() + "% ";
		}
		if (!star.getMiners().equals(Star.UNKNOWN_MINERS))
		{
			content += "- " + star.getMiners() + " Miners - ";
		}
		content += star.getLocation().getDescription();
		content += star.getWorldInfo();
		content += " " + DiscordTimeStamp.relativeTimeNow();
		if (detailed && star.getTierTicksEstimate() != null) {
			for (int i = star.getTierTicksEstimate().length - 1; i >= 0; i--) {
				content += "\nT"+i+" estimate: " + DiscordTimeStamp.relativeTimeNowPlus(star.getTierTicksEstimate()[i]);
			}
		}
		else if (star.getTierTicksEstimate() != null && starConfig.addT0Estimate())
		{
			content += " T0 estimate: " + DiscordTimeStamp.relativeTimeNowPlus(star.getTierTicksEstimate()[0]);
		}

		final StringSelection stringSelection = new StringSelection(content);
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(stringSelection, null);
		client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Copied star information to clipboard.", "");
	}

	private TileObject findTileObject(Tile tile, int id)
	{
		if (tile == null)
		{
			return null;
		}
		for (GameObject object : tile.getGameObjects())
		{
			if (object != null && object.getId() == id)
			{
				return object;
			}
		}
		return null;
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals("starinfoplugin"))
		{
			return;
		}
		switch (event.getKey())
		{
			case StarInfoConfig.TEXT_COLOR_KEY:
				starOverlay.updateConfig();
				break;
			case StarInfoConfig.INFO_BOX_KEY:
				if (starConfig.showInfoBox())
				{
					refresh();
				}
				else
				{
					infoBoxManager.removeInfoBox(infoBox);
					infoBox = null;
				}
				break;
			case StarInfoConfig.BONUS_INFO_BOX_KEY:
				if (starConfig.showStarDiscovery())
				{
					updateBonusCounter();
				}
				else
				{
					removeBonusCounter();
				}
				break;
			case StarInfoConfig.HINT_ARROW_KEY:
				if (starConfig.showHintArrow())
				{
					refresh();
				}
				else
				{
					toggleHintArrow(false);
				}
				break;
		}
	}
}
package com.starinfo;

public enum EstimateConfig
{
	NONE,
	SECONDS,
	TICKS,
	;
}

package com.starinfo;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.Getter;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;

public class Location
{
	private static final Map<Point, Location> locations = new HashMap<>();

	private final Point point;
	@Getter
	private final String description;
	@Getter
	private final boolean wildy;

	static {
		List<Location> locationList = Arrays.asList(
			/*
			ASGARNIA
			 */
			new Location(new Point(2974, 3241), "Rimmington mine"),
			new Location(new Point(2940, 3280), "Crafting guild"),
			new Location(new Point(2906, 3355), "West Falador mine"),
			new Location(new Point(3030, 3348), "East Falador bank"),
			new Location(new Point(3018, 3443), "North Dwarven Mine entrance"),
			new Location(new Point(2882, 3474), "Taverley house portal"),
			/*
			CRANDOR/KARAMJA
			 */
			new Location(new Point(2736, 3221), "Brimhaven northwest gold mine"),
			new Location(new Point(2742, 3143), "Brimhaven south dungeon entrance"),
			new Location(new Point(2845, 3037), "Nature Altar mine north of Shilo"),
			new Location(new Point(2827, 2999), "Shilo Village gem mine"),
			new Location(new Point(2835, 3296), "North Crandor"),
			new Location(new Point(2822, 3238), "South Crandor"),
			/*
			DESERT
			 */
			new Location(new Point(3296, 3298), "Al Kharid mine"),
			new Location(new Point(3276, 3164), "Al Kharid bank"),
			new Location(new Point(3351, 3281), "Mage Training Arena entrance"),
			new Location(new Point(3424, 3160), "Nw of Uzer (Eagle's Eyrie)"),
			new Location(new Point(3434, 2889), "Nardah bank"),
			new Location(new Point(3316, 2867), "Agility Pyramid mine"),
			new Location(new Point(3171, 2910), "Desert Quarry mine"),
			/*
			FELDIP HILLS/ISLE OF SOULS
			 */
			new Location(new Point(2567, 2858), "Corsair Cove bank"),
			new Location(new Point(2483, 2886), "Corsair Resource Area"),
			new Location(new Point(2468, 2842), "Myths' Guild"),
			new Location(new Point(2571, 2964), "Feldip Hills (aks fairy ring)"),
			new Location(new Point(2630, 2993), "Rantz cave"),
			new Location(new Point(2200, 2792), "Soul Wars south mine"),
			/*
			FOSSIL ISLAND/MOS LE HARMLESS
			 */
			new Location(new Point(3818, 3801), "Fossil Island Volcanic Mine entrance"),
			new Location(new Point(3774, 3814), "Fossil Island rune rocks"),
			new Location(new Point(3686, 2969), "Mos Le'Harmless west bank"),
			/*
			FREMENNIK/LUNAR ISLE
			 */
			new Location(new Point(2727, 3683), "Keldagrim entrance mine"),
			new Location(new Point(2683, 3699), "Rellekka mine"),
			new Location(new Point(2393, 3814), "Jatizso mine entrance"),
			new Location(new Point(2375, 3832), "Neitiznot south of rune rock"),
			new Location(new Point(2528, 3887), "Miscellania mine (cip fairy ring)"),
			new Location(new Point(2139, 3938), "Lunar Isle mine entrance"),
			/*
			KANDARIN
			 */
			new Location(new Point(2602, 3086), "Yanille bank"),
			new Location(new Point(2624, 3141), "Port Khazard mine"),
			new Location(new Point(2608, 3233), "Ardougne Monastery"),
			new Location(new Point(2705, 3333), "South of Legends' Guild"),
			new Location(new Point(2804, 3434), "Catherby bank"),
			new Location(new Point(2589, 3478), "Coal Trucks west of Seers'"),
			/*
			KOUREND
			 */
			new Location(new Point(1778, 3493), "Hosidius mine"),
			new Location(new Point(1769, 3709), "Port Piscarilius mine in Kourend"),
			new Location(new Point(1597, 3648), "Shayzien mine south of Kourend Castle"),
			new Location(new Point(1534, 3747), "South Lovakengj bank"),
			new Location(new Point(1437, 3840), "Lovakite mine"),
			new Location(new Point(1760, 3853), "Arceuus dense essence mine"),
			/*
			KEBOS LOWLANDS
			 */
			new Location(new Point(1322, 3816), "Mount Karuulm bank"),
			new Location(new Point(1279, 3817), "Mount Karuulm mine"),
			new Location(new Point(1210, 3651), "Kebos Swamp mine"),
			new Location(new Point(1258, 3564), "Chambers of Xeric bank"),
			/*
			MISTHALIN
			 */
			new Location(new Point(3258, 3408), "Varrock east bank"),
			new Location(new Point(3290, 3353), "South-east Varrock mine"),
			new Location(new Point(3175, 3362), "Champions' Guild mine"),
			new Location(new Point(3094, 3235), "Draynor Village"),
			new Location(new Point(3153, 3150), "West Lumbridge Swamp mine"),
			new Location(new Point(3230, 3155), "East Lumbridge Swamp mine"),
			/*
			MORYTANIA
			 */
			new Location(new Point(3635, 3340), "Darkmeyer ess. mine entrance"),
			new Location(new Point(3650, 3214), "Theatre of Blood bank"),
			new Location(new Point(3505, 3485), "Canifis bank"),
			new Location(new Point(3500, 3219), "Burgh de Rott bank"),
			new Location(new Point(3451, 3233), "Abandoned Mine west of Burgh"),
			/*
			PISCATORIS/GNOME STRONGHOLD
			 */
			new Location(new Point(2444, 3490), "West of Grand Tree"),
			new Location(new Point(2448, 3436), "Gnome Stronghold spirit tree"),
			new Location(new Point(2341, 3635), "Piscatoris (akq fairy ring)"),
			/*
			TIRANNWN
			 */
			new Location(new Point(2329, 3163), "Lletya"),
			new Location(new Point(2269, 3158), "Isafdar runite rocks"),
			new Location(new Point(3274, 6055), "Prifddinas Zalcano entrance"),
			new Location(new Point(2318, 3269), "Arandar mine north of Lleyta"),
			new Location(new Point(2173, 3409), "Mynydd nw of Prifddinas"),
			/*
			WILDERNESS
			 */
			new Location(new Point(3108, 3569), "Mage of Zamorak mine (lvl 7 Wildy)", true),
			new Location(new Point(3018, 3593), "Skeleton mine (lvl 10 Wildy)", true),
			new Location(new Point(3093, 3756), "Hobgoblin mine (lvl 30 Wildy)", true),
			new Location(new Point(3057, 3887), "Lava maze runite mine (lvl 46 Wildy)", true),
			new Location(new Point(3049, 3940), "Pirates' Hideout (lvl 53 Wildy)", true),
			new Location(new Point(3091, 3962), "Mage Arena bank (lvl 56 Wildy)", true),
			new Location(new Point(3188, 3932), "Wilderness Resource Area", true),

			/*
			VARLAMORE
			 */
			new Location(new Point(1742, 2954), "Varlamore South East mine"),
			new Location(new Point(1771, 3102), "Varlamore colosseum entrance bank"),
			new Location(new Point(1486, 3089), "Mine north-west of hunter guild")
		);

		for (Location location : locationList) {
			locations.put(location.point, location);
		}
	}

	public Location(Point point, String description, boolean wildy)
	{
		this.point = point;
		this.description = description;
		this.wildy = wildy;
	}

	public Location(Point point, String description)
	{
		this(point, description, false);
	}

	public static Location forLocation(WorldPoint worldPoint)
	{
		Point point = new Point(worldPoint.getX(), worldPoint.getY());
		Location location = locations.get(point);
		if (location == null) {
			return new Location(point, "Unknown location: " + point.getX() + ", " + point.getY(), false);
		}
		return location;
	}
}

package com.starinfo;

import java.awt.Color;
import java.awt.image.BufferedImage;
import javax.annotation.Nonnull;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;

public class StarInfoBox extends InfoBox
{
	private final Star star;

	public StarInfoBox(BufferedImage image, @Nonnull Plugin plugin, Star star)
	{
		super(image, plugin);
		this.star = star;
	}

	@Override
	public String getText()
	{
		String text = "T" + star.getTier();
		if (star.getMiners() != null && !star.getMiners().equals(Star.UNKNOWN_MINERS))
		{
			text += " " + star.getMiners() + "M";
		}
		return text;
	}

	@Override
	public Color getTextColor()
	{
		return Color.WHITE;
	}
}
package com.starinfo;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class PlayerInfo
{
	public String username;
}

package com.starinfo;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.GameObject;
import net.runelite.api.NPC;
import net.runelite.api.ObjectID;
import net.runelite.api.coords.WorldPoint;

public class Star
{
	public static final String UNKNOWN_MINERS = "?";

	private static final int[] TIER_IDS = new int[]{
		ObjectID.CRASHED_STAR_41229,
		ObjectID.CRASHED_STAR_41228,
		ObjectID.CRASHED_STAR_41227,
		ObjectID.CRASHED_STAR_41226,
		ObjectID.CRASHED_STAR_41225,
		ObjectID.CRASHED_STAR_41224,
		ObjectID.CRASHED_STAR_41223,
		ObjectID.CRASHED_STAR_41021,
		ObjectID.CRASHED_STAR,
	};

	@Getter
	private final WorldPoint worldPoint;
	@Getter
	private final int world;
	@Getter
	@Setter
	private NPC npc;
	@Getter
	@Setter
	private GameObject object;
	@Setter
	@Getter
	private String miners = UNKNOWN_MINERS;
	@Getter
	private final Location location;
	private int health = -1;
	@Getter
	@Setter
	private int[] tierTicksEstimate;
	@Getter
	@Setter
	private String worldInfo = "";

	public Star(NPC npc, int world)
	{
		this.npc = npc;
		this.worldPoint = npc.getWorldLocation();
		this.location = Location.forLocation(worldPoint);
		this.world = world;
	}

	public Star(GameObject gameObject, int world)
	{
		this.object = gameObject;
		this.worldPoint = gameObject.getWorldLocation();
		this.location = Location.forLocation(worldPoint);
		this.world = world;
	}

	public int getTier()
	{
		if (object == null)
		{
			return -1;
		}
		return getTier(object.getId());
	}

	public static int getTier(int id)
	{
		for (int i = 0; i < TIER_IDS.length; i++)
		{
			if (id == TIER_IDS[i])
			{
				return i + 1;
			}
		}
		return -1;
	}

	/**
	 * @return Health Percentage 0-100 of current layer. -1 if not known.
	 */
	public int getHealth()
	{
		if (npc == null)
		{
			return health;
		}
		if (npc.getHealthRatio() >= 0)
		{
			health = 100 * npc.getHealthRatio() / npc.getHealthScale();
		}
		else if (npc.isDead())
		{
			health = -1;
		}
		return health;
	}

	public String getMessage()
	{
		return "Star Found: W" + world + " T" + getTier() + " " + location.getDescription() + worldInfo;
	}

	public void resetHealth()
	{
		health = 100;
	}
}
package com.starinfo;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class StarInfoPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(StarInfoPlugin.class);
		RuneLite.main(args);
	}
}
