package com.jebscape.core;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class JebScapePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(JebScapePlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class RuneLiteKitLoader
{
	private static final Logger logger = LoggerFactory.getLogger(RuneLiteKitLoader.class);
	
	public RuneLiteKitDefinition load(int id, byte[] b)
	{
		RuneLiteKitDefinition def = new RuneLiteKitDefinition(id);
		RuneLiteInputStream is = new RuneLiteInputStream(b);
		
		for (;;)
		{
			int opcode = is.readUnsignedByte();
			if (opcode == 0)
			{
				break;
			}
			
			if (opcode == 1)
			{
				def.bodyPartId = is.readUnsignedByte();
			}
			else if (opcode == 2)
			{
				int length = is.readUnsignedByte();
				def.models = new int[length];
				
				for (int index = 0; index < length; ++index)
				{
					def.models[index] = is.readUnsignedShort();
				}
			}
			else if (opcode == 3)
			{
				def.nonSelectable = true;
			}
			else if (opcode == 40)
			{
				int length = is.readUnsignedByte();
				def.recolorToFind = new short[length];
				def.recolorToReplace = new short[length];
				
				for (int index = 0; index < length; ++index)
				{
					def.recolorToFind[index] = is.readShort();
					def.recolorToReplace[index] = is.readShort();
				}
			}
			else if (opcode == 41)
			{
				int length = is.readUnsignedByte();
				def.retextureToFind = new short[length];
				def.retextureToReplace = new short[length];
				
				for (int index = 0; index < length; ++index)
				{
					def.retextureToFind[index] = is.readShort();
					def.retextureToReplace[index] = is.readShort();
				}
			}
			else if (opcode >= 60 && opcode < 70)
			{
				def.chatheadModels[opcode - 60] = is.readUnsignedShort();
			}
		}
		
		return def;
	}
}
/*
 * Copyright (c) 2016-2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import java.util.Map;
import lombok.Data;

@Data
public class RuneLiteItemDefinition
{
	public final int id;
	
	public String name = "null";
	public String examine;
	public String unknown1;
	
	public int resizeX = 128;
	public int resizeY = 128;
	public int resizeZ = 128;
	
	public int xan2d = 0;
	public int yan2d = 0;
	public int zan2d = 0;
	
	public int cost = 1;
	public boolean isTradeable;
	public int stackable = 0;
	public int inventoryModel;
	
	public int wearPos1;
	public int wearPos2;
	public int wearPos3;
	
	public boolean members = false;
	
	public short[] colorFind;
	public short[] colorReplace;
	public short[] textureFind;
	public short[] textureReplace;
	
	public int zoom2d = 2000;
	public int xOffset2d = 0;
	public int yOffset2d = 0;
	
	public int ambient;
	public int contrast;
	
	public int[] countCo;
	public int[] countObj;
	
	public String[] options = new String[]{null, null, "Take", null, null};
	public String[][] subops;
	
	public String[] interfaceOptions = new String[]{null, null, null, null, "Drop"};
	
	public int maleModel0 = -1;
	public int maleModel1 = -1;
	public int maleModel2 = -1;
	public int maleOffset;
	public int maleHeadModel = -1;
	public int maleHeadModel2 = -1;
	
	public int femaleModel0 = -1;
	public int femaleModel1 = -1;
	public int femaleModel2 = -1;
	public int femaleOffset;
	public int femaleHeadModel = -1;
	public int femaleHeadModel2 = -1;
	
	public int category;
	
	public int notedID = -1;
	public int notedTemplate = -1;
	
	public int team;
	public int weight;
	
	public int shiftClickDropIndex = -2;
	
	public int boughtId = -1;
	public int boughtTemplateId = -1;
	
	public int placeholderId = -1;
	public int placeholderTemplateId = -1;
	
	public Map<Integer, Object> params = null;
	
	public void linkNote(RuneLiteItemDefinition notedItem, RuneLiteItemDefinition unnotedItem)
	{
		this.inventoryModel = notedItem.inventoryModel;
		this.zoom2d = notedItem.zoom2d;
		this.xan2d = notedItem.xan2d;
		this.yan2d = notedItem.yan2d;
		this.zan2d = notedItem.zan2d;
		this.xOffset2d = notedItem.xOffset2d;
		this.yOffset2d = notedItem.yOffset2d;
		this.colorFind = notedItem.colorFind;
		this.colorReplace = notedItem.colorReplace;
		this.textureFind = notedItem.textureFind;
		this.textureReplace = notedItem.textureReplace;
		this.name = unnotedItem.name;
		this.members = unnotedItem.members;
		this.cost = unnotedItem.cost;
		this.stackable = 1;
	}
	
	public void linkBought(RuneLiteItemDefinition var1, RuneLiteItemDefinition var2)
	{
		this.inventoryModel = var1.inventoryModel;
		this.zoom2d = var1.zoom2d;
		this.xan2d = var1.xan2d;
		this.yan2d = var1.yan2d;
		this.zan2d = var1.zan2d;
		this.xOffset2d = var1.xOffset2d;
		this.yOffset2d = var1.yOffset2d;
		this.colorFind = var2.colorFind;
		this.colorReplace = var2.colorReplace;
		this.textureFind = var2.textureFind;
		this.textureReplace = var2.textureReplace;
		this.name = var2.name;
		this.members = var2.members;
		this.stackable = var2.stackable;
		this.maleModel0 = var2.maleModel0;
		this.maleModel1 = var2.maleModel1;
		this.maleModel2 = var2.maleModel2;
		this.femaleModel0 = var2.femaleModel0;
		this.femaleModel1 = var2.femaleModel1;
		this.femaleModel2 = var2.femaleModel2;
		this.maleHeadModel = var2.maleHeadModel;
		this.maleHeadModel2 = var2.maleHeadModel2;
		this.femaleHeadModel = var2.femaleHeadModel;
		this.femaleHeadModel2 = var2.femaleHeadModel2;
		this.team = var2.team;
		this.options = var2.options;
		this.interfaceOptions = new String[5];
		if (var2.interfaceOptions != null)
		{
			for (int var3 = 0; var3 < 4; ++var3)
			{
				this.interfaceOptions[var3] = var2.interfaceOptions[var3];
			}
		}
		
		this.interfaceOptions[4] = "Discard";
		this.cost = 0;
	}
	
	public void linkPlaceholder(RuneLiteItemDefinition var1, RuneLiteItemDefinition var2)
	{
		this.inventoryModel = var1.inventoryModel;
		this.zoom2d = var1.zoom2d;
		this.xan2d = var1.xan2d;
		this.yan2d = var1.yan2d;
		this.zan2d = var1.zan2d;
		this.xOffset2d = var1.xOffset2d;
		this.yOffset2d = var1.yOffset2d;
		this.colorFind = var1.colorFind;
		this.colorReplace = var1.colorReplace;
		this.textureFind = var1.textureFind;
		this.textureReplace = var1.textureReplace;
		this.stackable = var1.stackable;
		this.name = var2.name;
		this.cost = 0;
		this.members = false;
		this.isTradeable = false;
	}
}
/*
 * Copyright (c) 2023, Justin Ead (Jebrim) <jebscapeplugin@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.api.Skill;

@ConfigGroup("jebscape")
public interface JebScapeConfig extends Config
{
	enum JebScapeSkill
	{
		OVERALL("Overall"),
		ATTACK("Attack"),
		DEFENCE("Defence"),
		STRENGTH("Strength"),
		HITPOINTS("Hitpoints"),
		RANGED("Ranged"),
		PRAYER("Prayer"),
		MAGIC("Magic"),
		COOKING("Cooking"),
		WOODCUTTING("Woodcutting"),
		FLETCHING("Fletching"),
		FISHING("Fishing"),
		FIREMAKING("Firemaking"),
		CRAFTING("Crafting"),
		SMITHING("Smithing"),
		MINING("Mining"),
		HERBLORE("Herblore"),
		AGILITY("Agility"),
		THIEVING("Thieving"),
		SLAYER("Slayer"),
		FARMING("Farming"),
		RUNECRAFT("Runecraft"),
		HUNTER("Hunter"),
		CONSTRUCTION("Construction"),
		SAILING("Sailing");
		
		private final String name;
		
		JebScapeSkill(String name)
		{
			this.name = name;
		}
		
		public String getName()
		{
			return name;
		}
		
		public String toString()
		{
			return name;
		}
	};
	
	@ConfigSection(
			position = 0,
			name = "Megaserver",
			description = "Enables seeing and chatting with players on other worlds."
	)
	String megaserverSection = "megaserverSection";
	
	@ConfigItem(
			position = 1,
			keyName = "showSelfGhost",
			name = "Always Show Self Ghost",
			description = "Check this to always see your own ghost as others on JebScape would see it.",
			section = megaserverSection
	)
	default boolean showSelfGhost()
	{
		return true;
	}
	
	@ConfigSection(
			position = 2,
			name = "Live Hiscores",
			description = "Tracks post-200m XP gains and rank changes every tick. Requires JebScape account to participate."
	)
	String liveHiscoresSection = "liveHiscoresSection";
	
	@ConfigItem(
			position = 3,
			keyName = "hideLiveHiscores",
			name = "Hide Live Hiscores",
			description = "Uncheck this to make live hiscores visible again.",
			section = liveHiscoresSection
	)
	default boolean hideLiveHiscores()
	{
		return false;
	}
	
	@ConfigItem(
			position = 4,
			keyName = "selectSkillLiveHiscores",
			name = "Select Skill",
			description = "Select the skill to watch.",
			section = liveHiscoresSection
	)
	default JebScapeSkill selectSkillLiveHiscores()
	{
		return JebScapeSkill.OVERALL;
	}
	
	@Range(
			min = 1,
			max = 99996
	)
	@ConfigItem(
			position = 5,
			keyName = "startRankLiveHiscores",
			name = "Rank",
			description = "Enter the starting rank being watched.",
			section = liveHiscoresSection
	)
	default int startRankLiveHiscores()
	{
		return 1;
	}
}

/*
 * Copyright (c) 2023, Justin Ead (Jebrim) <jebscapeplugin@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import net.runelite.api.*;
import net.runelite.api.coords.*;
import net.runelite.client.chat.*;

public class JebScapeActor
{
	private Client client;
	private ChatMessageManager chatMessageManager;
	private RuneLiteObject rlObject;
	private Model defaultModel;
	private int world;
	private int plane;
	private String actorName;
	private String overheadText;
	private String chatMessage;
	private static final int MAX_CHAT_MESSAGE_TIME = 6; // number of game ticks that chat message will be visible above player's head
	private int remainingOverheadChatMessageTime;
	
	private static class Target
	{
		public WorldPoint worldDestinationPosition;
		public LocalPoint localDestinationPosition;
		public int tileMovementSpeed;
		public int jauDestinationOrientation;
		public int primaryAnimationID;
		public boolean isPoseAnimation;
		public boolean isInteracting;
		public boolean isMidPoint;
		public boolean isInstanced;
		public int gameTick;
	}
	
	private static final int MAX_TARGET_QUEUE_SIZE = 10;
	private final Target[] targetQueue = new Target[MAX_TARGET_QUEUE_SIZE];
	private int currentTargetIndex;
	private int targetQueueSize;
	
	private int currentMovementSpeed;
	private int currentAnimationID;
	private int animationStall; // stalls movement animations while playing certain primary animations
	
	
	private static final int BLOCKING_DIRECTIONS_5x5[][] = {
			{CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_EAST,	CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_EAST,	CollisionDataFlag.BLOCK_MOVEMENT_SOUTH,	CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_WEST,	CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_WEST},
			{CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_EAST,	CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_EAST,	CollisionDataFlag.BLOCK_MOVEMENT_SOUTH,	CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_WEST,	CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_WEST},
			{CollisionDataFlag.BLOCK_MOVEMENT_EAST,			CollisionDataFlag.BLOCK_MOVEMENT_EAST,			0,										CollisionDataFlag.BLOCK_MOVEMENT_WEST,			CollisionDataFlag.BLOCK_MOVEMENT_WEST},
			{CollisionDataFlag.BLOCK_MOVEMENT_NORTH_EAST,	CollisionDataFlag.BLOCK_MOVEMENT_NORTH_EAST,	CollisionDataFlag.BLOCK_MOVEMENT_NORTH,	CollisionDataFlag.BLOCK_MOVEMENT_NORTH_WEST,	CollisionDataFlag.BLOCK_MOVEMENT_NORTH_WEST},
			{CollisionDataFlag.BLOCK_MOVEMENT_NORTH_EAST,	CollisionDataFlag.BLOCK_MOVEMENT_NORTH_EAST,	CollisionDataFlag.BLOCK_MOVEMENT_NORTH,	CollisionDataFlag.BLOCK_MOVEMENT_NORTH_WEST,	CollisionDataFlag.BLOCK_MOVEMENT_NORTH_WEST}};
	
	private static final int JAU_DIRECTIONS_5X5[][] = {
			{768,	768,	1024,	1280,	1280},
			{768,	768,	1024,	1280,	1280},
			{512,	512,	0,		1536,	1536},
			{256,	256,	0,		1792,	1792},
			{256,	256,	0,		1792,	1792}};
	private static final int CENTER_INDEX_5X5 = 2;
	
	private enum POSE_ANIM
	{
		IDLE,
		WALK,
		RUN,
		WALK_ROTATE_180,
		WALK_STRAFE_LEFT,
		WALK_STRAFE_RIGHT,
		IDLE_ROTATE_LEFT,
		IDLE_ROTATE_RIGHT
	}
	Animation[] animationPoses = new Animation[8];
	int[] animationPoseIDs = new int[8];
	
	
	public void init(Client client, ChatMessageManager chatMessageManager)
	{
		this.client = client;
		this.rlObject = client.createRuneLiteObject();
		for (int i = 0; i < MAX_TARGET_QUEUE_SIZE; i++)
			targetQueue[i] = new Target();
		this.chatMessageManager = chatMessageManager;
	}
	
	public void setDefaultModel(Model model)
	{
		this.defaultModel = model;
		rlObject.setModel(model);
	}
	
	public void setModel(Model model)
	{
		// TODO: consider splitting weapon/shield slot separate from the rest of the model so these can be removed as needed when animating
		rlObject.setModel(model);
		if (rlObject.isActive())
		{
			// reset if model has updated
			rlObject.setActive(false);
			rlObject.setActive(true);
		}
	}
	
	public void spawn(WorldPoint position, int jauOrientation)
	{
		LocalPoint localPosition = LocalPoint.fromWorld(client, position);
		if (localPosition != null && client.getPlane() == position.getPlane())
			rlObject.setLocation(localPosition, position.getPlane());
		else
			return;
		rlObject.setOrientation(jauOrientation);
		setPoseAnimations(client.getLocalPlayer());
		rlObject.setAnimation(animationPoses[POSE_ANIM.IDLE.ordinal()]);
		rlObject.setShouldLoop(true);
		rlObject.setActive(true);
		this.plane = position.getPlane();
		this.currentAnimationID = -1;
		this.currentMovementSpeed = 0;
		this.currentTargetIndex = 0;
		this.targetQueueSize = 0;
		this.remainingOverheadChatMessageTime = 0;
	}
	
	public void despawn()
	{
		rlObject.setActive(false);
		rlObject.setModel(defaultModel);
		this.overheadText = "";
		this.actorName = "";
		this.chatMessage = "";
		this.remainingOverheadChatMessageTime = 0;
		this.world = 0;
		this.plane = 0;
		this.currentAnimationID = -1;
		this.currentMovementSpeed = 0;
		this.currentTargetIndex = 0;
		this.targetQueueSize = 0;
	}
	
	public void setPoseAnimations(Actor actor)
	{
		this.animationPoseIDs[POSE_ANIM.IDLE.ordinal()] = actor.getIdlePoseAnimation();
		this.animationPoseIDs[POSE_ANIM.WALK.ordinal()] = actor.getWalkAnimation();
		this.animationPoseIDs[POSE_ANIM.RUN.ordinal()] = actor.getRunAnimation();
		this.animationPoseIDs[POSE_ANIM.WALK_ROTATE_180.ordinal()] = actor.getWalkRotate180();
		this.animationPoseIDs[POSE_ANIM.WALK_STRAFE_LEFT.ordinal()] = actor.getWalkRotateLeft(); // rotate is a misnomer here
		this.animationPoseIDs[POSE_ANIM.WALK_STRAFE_RIGHT.ordinal()] = actor.getWalkRotateRight(); // rotate is a misnomer here
		this.animationPoseIDs[POSE_ANIM.IDLE_ROTATE_LEFT.ordinal()] = actor.getIdleRotateLeft();
		this.animationPoseIDs[POSE_ANIM.IDLE_ROTATE_RIGHT.ordinal()] = actor.getIdleRotateRight();
		
		for (int i = 0; i < 8; i++)
			this.animationPoses[i] = client.loadAnimation(animationPoseIDs[i]);
	}
	
	public WorldPoint getWorldLocation()
	{
		return targetQueueSize > 0 ? targetQueue[currentTargetIndex].worldDestinationPosition : WorldPoint.fromLocal(client, rlObject.getLocation());
	}
	
	public LocalPoint getLocalLocation()
	{
		return rlObject.getLocation();
	}
	
	public boolean isActive()
	{
		return rlObject != null && rlObject.isActive();
	}
	
	public void setWorld(int world)
	{
		this.world = world;
	}
	
	public int getWorld()
	{
		return world;
	}
	
	public void setName(String name)
	{
		this.actorName = name;
		
		if (world != 0)
			overheadText = "[W" + world + "] ";
		else
			overheadText = "";
		
		overheadText += name;
	}
	
	public String getName()
	{
		return actorName;
	}
	
	public String getOverheadText()
	{
		return overheadText;
	}
	
	public void setChatMessage(String chatMessage)
	{
		this.chatMessage = chatMessage;
		this.remainingOverheadChatMessageTime = MAX_CHAT_MESSAGE_TIME;
		
		ChatMessageBuilder message = new ChatMessageBuilder();
		message.append(ChatColorType.NORMAL).append(chatMessage);
		chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.PUBLICCHAT)
				.name(actorName)
				.runeLiteFormattedMessage(message.build())
				.sender(null)
				.build());
	}
	
	public String getChatMessage()
	{
		return chatMessage;
	}
	
	// moveTo() adds target movement states to the queue for later per-frame updating for rendering in onClientTick()
	// Set this every game tick for each new position (usually only up to 2 tiles out)
	// This is not set up for pathfinding to the final destination of distant targets (you will just move there directly)
	// It will, however, handle nearby collision detection (1-2 tiles away from you) under certain scenarios
	// jauOrientation is not used if isInteracting is false; it will instead default to the angle being moved towards
	public void moveTo(WorldPoint worldPosition, int jauOrientation, int primaryAnimationID, boolean isInteracting, boolean isPoseAnimation, boolean isInstanced, int gameTick)
	{
		// respawn this actor if it was previously despawned
		if (!rlObject.isActive())
		{
			spawn(worldPosition, jauOrientation);
			
			// if still not active, just exit
			if (!rlObject.isActive())
				return;
		}
		
		// just clear the queue and move immediately to the destination if many ticks behind
		if (targetQueueSize >= MAX_TARGET_QUEUE_SIZE - 2)
			this.targetQueueSize = 0;
		
		int prevTargetIndex = (currentTargetIndex + targetQueueSize - 1) % MAX_TARGET_QUEUE_SIZE;
		int newTargetIndex = (currentTargetIndex + targetQueueSize) % MAX_TARGET_QUEUE_SIZE;
		LocalPoint localPosition = LocalPoint.fromWorld(client, worldPosition);
		
		if (localPosition == null)
			return;
		
		// use current position if nothing is in queue
		WorldPoint prevWorldPosition;
		if (targetQueueSize++ > 0)
		{
			prevWorldPosition = targetQueue[prevTargetIndex].worldDestinationPosition;
			// TODO: check if a different primaryAnimationID exists; if so, modify the old one with our new one (hopefully this prevents the extra tick of animation repeating)
		}
		else
		{
			prevWorldPosition = WorldPoint.fromLocal(client, rlObject.getLocation());
		}
		
		int distance = prevWorldPosition.distanceTo(worldPosition);
		if (distance > 0 && distance <= 2)
		{
			int dx = worldPosition.getX() - prevWorldPosition.getX();
			int dy = worldPosition.getY() - prevWorldPosition.getY();
			
			boolean useMidPointTile = false;
			
			if (distance == 1 && dx != 0 && dy != 0) // test for blockage along diagonal
			{
				// if blocked diagonally, go around in an L shape (2 options)
				int[][] colliders = client.getCollisionMaps()[worldPosition.getPlane()].getFlags();
				final int diagonalTest = BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5 - dy][CENTER_INDEX_5X5 + dx];
				final int axisXTest = BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5][CENTER_INDEX_5X5 + dx] | BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5 + dy][CENTER_INDEX_5X5] | CollisionDataFlag.BLOCK_MOVEMENT_FULL;
				final int axisYTest = BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5 - dy][CENTER_INDEX_5X5] | BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5][CENTER_INDEX_5X5 - dx] | CollisionDataFlag.BLOCK_MOVEMENT_FULL;
				
				int diagonalFlag = colliders[localPosition.getSceneX()][localPosition.getSceneY()];
				int axisXFlag = colliders[localPosition.getSceneX()][localPosition.getSceneY() - dy];
				int axisYFlag = colliders[localPosition.getSceneX() - dx][localPosition.getSceneY()];
				
				if ((axisXFlag & axisXTest) != 0 || (axisYFlag & axisYTest) != 0 || (diagonalFlag & diagonalTest) != 0)
				{
					// the path along the diagonal is blocked
					useMidPointTile = true;
					distance = 2; // we are now running in an L shape
					
					// if the priority East-West path is clear, we'll default to this direction
					if ((axisXFlag & axisXTest) == 0)
						dy = 0;
					else
						dx = 0;
				}
			}
			else if (distance == 2 && Math.abs(Math.abs(dy) - Math.abs(dx)) == 1) // test for blockage along knight-style moves
			{
				useMidPointTile = true; // we will always need a midpoint for these types of moves
				int[][] colliders = client.getCollisionMaps()[worldPosition.getPlane()].getFlags();
				final int diagonalTest = BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5 - dy][CENTER_INDEX_5X5 + dx];
				final int axisXTest = BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5][CENTER_INDEX_5X5 + dx] | BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5 + dy][CENTER_INDEX_5X5] | CollisionDataFlag.BLOCK_MOVEMENT_FULL;
				final int axisYTest = BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5 - dy][CENTER_INDEX_5X5] | BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5][CENTER_INDEX_5X5 - dx] | CollisionDataFlag.BLOCK_MOVEMENT_FULL;
				
				int dxSign = Integer.signum(dx);
				int dySign = Integer.signum(dy);
				int diagonalFlag = colliders[localPosition.getSceneX()][localPosition.getSceneY()];
				int axisXFlag = colliders[localPosition.getSceneX()][localPosition.getSceneY() - Integer.signum(dySign)];
				int axisYFlag = colliders[localPosition.getSceneX() - Integer.signum(dxSign)][localPosition.getSceneY()];
				
				// do we go straight or diagonal? test straight first and fall back to diagonal if it fails
				// priority is West > East > South > North > Southwest > Southeast > Northwest > Northeast
				if ((axisXFlag & axisXTest) == 0 && (axisYFlag & axisYTest) == 0 && (diagonalFlag & diagonalTest) == 0)
				{
					// the cardinal direction is clear (or we glitched), so let's go straight
					if (Math.abs(dx) == 2)
					{
						dx = dxSign;
						dy = 0;
					}
					else
					{
						dx = 0;
						dy = dySign;
					}
				}
				else
				{
					// we've established that the cardinal direction is blocked, so let's go along the diagonal
					if (Math.abs(dx) == 2)
						dx = dxSign;
					else
						dy = dySign;
				}
			}
			
			if (useMidPointTile)
			{
				WorldPoint midPoint = new WorldPoint(prevWorldPosition.getX() + dx, prevWorldPosition.getY() + dy, prevWorldPosition.getPlane());
				
				// handle rotation if we have no interacting target
				if (!isInteracting)
				{
					// the actor needs to look in the direction being moved toward
					// the distance between these points should be guaranteed to be 1 here
					dx = midPoint.getX() - prevWorldPosition.getX();
					dy = midPoint.getY() - prevWorldPosition.getY();
					jauOrientation = JAU_DIRECTIONS_5X5[CENTER_INDEX_5X5 - dy][CENTER_INDEX_5X5 + dx];
				}
				
				this.targetQueue[newTargetIndex].worldDestinationPosition = midPoint;
				this.targetQueue[newTargetIndex].localDestinationPosition = LocalPoint.fromWorld(client, midPoint);
				this.targetQueue[newTargetIndex].tileMovementSpeed = distance;
				this.targetQueue[newTargetIndex].jauDestinationOrientation = jauOrientation;
				this.targetQueue[newTargetIndex].primaryAnimationID = primaryAnimationID;
				this.targetQueue[newTargetIndex].isPoseAnimation = isPoseAnimation;
				this.targetQueue[newTargetIndex].isInteracting = isInteracting;
				this.targetQueue[newTargetIndex].isMidPoint = true;
				this.targetQueue[newTargetIndex].isInstanced = isInstanced;
				this.targetQueue[newTargetIndex].gameTick = gameTick;
				
				newTargetIndex = (currentTargetIndex + targetQueueSize++) % MAX_TARGET_QUEUE_SIZE;
				prevWorldPosition = midPoint;
			}
			
			// handle rotation if we have no interacting target
			if (!isInteracting)
			{
				// the actor needs to look in the direction being moved toward
				// the distance between these points may be up to 2
				dx = worldPosition.getX() - prevWorldPosition.getX();
				dy = worldPosition.getY() - prevWorldPosition.getY();
				jauOrientation = JAU_DIRECTIONS_5X5[CENTER_INDEX_5X5 - dy][CENTER_INDEX_5X5 + dx];
			}
		}
		
		this.targetQueue[newTargetIndex].worldDestinationPosition = worldPosition;
		this.targetQueue[newTargetIndex].localDestinationPosition = localPosition;
		this.targetQueue[newTargetIndex].tileMovementSpeed = distance;
		this.targetQueue[newTargetIndex].jauDestinationOrientation = jauOrientation;
		this.targetQueue[newTargetIndex].primaryAnimationID = primaryAnimationID;
		this.targetQueue[newTargetIndex].isInteracting = isInteracting;
		this.targetQueue[newTargetIndex].isPoseAnimation = isPoseAnimation;
		this.targetQueue[newTargetIndex].isMidPoint = false;
		this.targetQueue[newTargetIndex].isInstanced = isInstanced;
		this.targetQueue[newTargetIndex].gameTick = gameTick;
		
		// handle chat message
		if (remainingOverheadChatMessageTime > 0)
		{
			this.remainingOverheadChatMessageTime--;
			
			// overhead chat should not remain visible after this
			if (remainingOverheadChatMessageTime == 0 && !chatMessage.isEmpty())
				this.chatMessage = "";
		}
	}
	
	// onClientTick() updates the per-frame state needed for rendering actor movement
	public boolean onClientTick()
	{
		if (rlObject.isActive())
		{
			if (targetQueueSize > 0)
			{
				int targetPlane = targetQueue[currentTargetIndex].worldDestinationPosition.getPlane();
				LocalPoint targetPosition = targetQueue[currentTargetIndex].localDestinationPosition;
				int targetOrientation = targetQueue[currentTargetIndex].jauDestinationOrientation;
				
				if (client.getPlane() != targetPlane || plane != targetPlane || targetPosition == null || !targetPosition.isInScene() || targetOrientation < 0)
				{
					// this actor is no longer in a visible area, so let's despawn it
					despawn();
					return false;
				}
				
				// handle animations - there's still some jankiness, but let's return to the basics for now...
				// TODO: handle animation stalling, remove extra tick of animation that's playing, and strafing when interacting
				int animationID = targetQueue[currentTargetIndex].primaryAnimationID;
				int speed = targetQueue[currentTargetIndex].tileMovementSpeed;
				int poseIndexToUpdate = -1;
				boolean poseChanged = false;
				
				// update stored pose animation
				if (targetQueue[currentTargetIndex].isPoseAnimation && animationID >= 0)
				{
					int currentGameTick = targetQueue[currentTargetIndex].gameTick;
					
					if (currentGameTick == 0 || currentGameTick == 8)
						poseIndexToUpdate = 0;
					else if ((currentGameTick & 0x1) == 0x1)
						poseIndexToUpdate = 1;
					else
						poseIndexToUpdate = 2;
					
					if (animationPoseIDs[poseIndexToUpdate] != animationID)
					{
						this.animationPoseIDs[poseIndexToUpdate] = animationID;
						this.animationPoses[poseIndexToUpdate] = client.loadAnimation(animationID);
						poseChanged = true;
					}
				}
				
				// we don't want to go beyond run (speed of 2)
				int cappedSpeed = speed > 2 ? 2 : speed;
				int cappedCurrentMovementSpeed = currentMovementSpeed > 2 ? 2 : currentMovementSpeed;
				if (!targetQueue[currentTargetIndex].isPoseAnimation && currentAnimationID != animationID)
				{
					rlObject.setAnimation(client.loadAnimation(animationID));
					this.currentAnimationID = animationID;
				}
				else if (targetQueue[currentTargetIndex].isPoseAnimation && ((currentAnimationID >= 0) || (cappedCurrentMovementSpeed != cappedSpeed) || (poseChanged && poseIndexToUpdate == cappedSpeed)))
				{
					rlObject.setAnimation(animationPoses[cappedSpeed]);
					this.currentAnimationID = -1;
				}
				
				this.currentMovementSpeed = speed;
				
				LocalPoint currentPosition = rlObject.getLocation();
				int currentOrientation = rlObject.getOrientation();
				int dx = targetPosition.getX() - currentPosition.getX();
				int dy = targetPosition.getY() - currentPosition.getY();
				
				// are we not where we need to be?
				if (dx != 0 || dy != 0)
				{
					// continue moving until we reach target
					int movementPerClientTick = 4;
					if (currentOrientation != targetOrientation && !targetQueue[currentTargetIndex].isInteracting)
						movementPerClientTick = 2;
					if (targetQueueSize > 2)
						movementPerClientTick = 6;
					if (targetQueueSize > 3)
						movementPerClientTick = 8;
					if (animationStall > 0 && targetQueueSize > 1)
					{
						movementPerClientTick = 8;
						animationStall--;
					}
					
					if (animationStall == 0)
					{
						// compute the number of local points to move this tick
						int lpSpeed = currentMovementSpeed * movementPerClientTick;
						
						if (lpSpeed > 0)
						{
							// only use the delta if it won't send up past the target
							if (Math.abs(dx) > lpSpeed)
								dx = Integer.signum(dx) * lpSpeed;
							if (Math.abs(dy) > lpSpeed)
								dy = Integer.signum(dy) * lpSpeed;
						}
						
						LocalPoint newLocation = new LocalPoint(currentPosition.getX() + dx, currentPosition.getY() + dy);
						rlObject.setLocation(newLocation, targetPlane);
					}
					
					currentPosition = rlObject.getLocation();
					dx = targetPosition.getX() - currentPosition.getX();
					dy = targetPosition.getY() - currentPosition.getY();
				}
				
				// compute the turn we need to make
				final int JAU_FULL_ROTATION = 2048;
				int dJau = (targetOrientation - currentOrientation) % JAU_FULL_ROTATION;
				
				if (dJau != 0)
				{
					final int JAU_HALF_ROTATION = 1024;
					final int JAU_TURN_SPEED = 32;
					int dJauCW = Math.abs(dJau);
					
					if (dJauCW > JAU_HALF_ROTATION) // use the shortest turn
						dJau = (currentOrientation - targetOrientation) % JAU_FULL_ROTATION;
					else if (dJauCW == JAU_HALF_ROTATION) // always turn right when turning around
						dJau = dJauCW;
					
					// only use the delta if it won't send up past the target
					if (Math.abs(dJau) > JAU_TURN_SPEED)
						dJau = Integer.signum(dJau) * JAU_TURN_SPEED;
					
					int newOrientation = (JAU_FULL_ROTATION + rlObject.getOrientation() + dJau) % JAU_FULL_ROTATION;
					rlObject.setOrientation(newOrientation);
					dJau = (targetOrientation - newOrientation) % JAU_FULL_ROTATION;
				}
				
				// have we arrived at our target?
				if (dx == 0 && dy == 0 && dJau == 0)
				{
					// if so, pull out the next target
					currentTargetIndex = (currentTargetIndex + 1) % MAX_TARGET_QUEUE_SIZE;
					targetQueueSize--;
				}
			}
			
			return true;
		}
		
		return false;
	}
}

/*
 * Copyright (c) 2023, Justin Ead (Jebrim) <jebscapeplugin@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import java.awt.*;
import javax.inject.Inject;
import net.runelite.api.*;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.ui.overlay.components.*;
import net.runelite.client.ui.overlay.tooltip.*;
import net.runelite.client.util.*;

public class JebScapeLiveHiscoresOverlay extends OverlayPanel
{
	private static final String RANK_COLUMN_HEADER = "Rank";
	private static final String NAME_COLUMN_HEADER = "Name";
	private static final String LEVEL_COLUMN_HEADER = "Level";
	private static final String XP_COLUMN_HEADER = "XP";
	private int currentSkill;
	private int currentStartRank;
	private String[] currentPlayerNames;
	private int[] currentLevels;
	private long[] currentXPs;
	private boolean[] currentOnlineStatuses;
	private boolean containsData;
	
	private static class SkillFrame
	{
		private int skill;
		private int startRank;
		private String[] playerNames;
		private int[] levels;
		private long[] XPs;
		private boolean[] onlineStatuses;
	}
	
	private final int MAX_SKILL_FRAME_QUEUE_SIZE = 10;
	private final JebScapeLiveHiscoresOverlay.SkillFrame[] skillFrameQueue = new JebScapeLiveHiscoresOverlay.SkillFrame[MAX_SKILL_FRAME_QUEUE_SIZE];
	private int currentSkillFrameIndex;
	private int skillFrameQueueSize;
	
	@Inject
	JebScapePlugin plugin;
	@Inject
	private TooltipManager tooltipManager;
	private Client client;
	private final Color headerColor = new Color(5, 248, 242, 218);
	private final Color onlineColor = new Color(5, 248, 5, 218);
	private final Tooltip guestTooltip = new Tooltip("Requires JebScape account to participate. See JebScape settings to configure.");
	private final Tooltip accountTooltip = new Tooltip("See JebScape settings to configure.");
	private boolean isVisible;
	
	public void init(Client client)
	{
		this.client = client;
		this.isVisible = false;
		this.containsData = false;
		this.currentSkill = 0;
		this.currentSkillFrameIndex = 0;
		this.skillFrameQueueSize = 0;
		
		for (int i = 0; i < MAX_SKILL_FRAME_QUEUE_SIZE; i++)
			skillFrameQueue[i] = new JebScapeLiveHiscoresOverlay.SkillFrame();
		
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(OverlayPriority.LOW);
		setLayer(OverlayLayer.ABOVE_SCENE);
		setMovable(true);
		setClearChildren(true);
	}
	
	public boolean isVisible()
	{
		return isVisible;
	}
	
	public void updateSkillHiscoresData(int skill, int startRank, String[] playerNames, int[] levels, long[] XPs, boolean[] onlineStatuses)
	{
		// just clear the queue and move immediately to the destination if many ticks behind or if skill suddenly changes
		if (skillFrameQueueSize >= MAX_SKILL_FRAME_QUEUE_SIZE - 2 || currentSkill != skill)
		{
			currentSkill = skill;
			this.skillFrameQueueSize = 0;
		}
			
		int newSkillFrameIndex = (currentSkillFrameIndex + skillFrameQueueSize++) % MAX_SKILL_FRAME_QUEUE_SIZE;
		
		// we accumulate in a buffer per JebScape packet received, which may involve more than one packet in a Jagex tick, or even none
		skillFrameQueue[newSkillFrameIndex].skill = skill;
		skillFrameQueue[newSkillFrameIndex].startRank = startRank;
		skillFrameQueue[newSkillFrameIndex].playerNames = playerNames;
		skillFrameQueue[newSkillFrameIndex].levels = levels;
		skillFrameQueue[newSkillFrameIndex].XPs = XPs;
		skillFrameQueue[newSkillFrameIndex].onlineStatuses = onlineStatuses;
		
		setContainsData(true);
	}
	
	public void onGameTick()
	{
		// we digest only once per Jagex game tick, thereby smoothening out the visual updates
		if (skillFrameQueueSize > 0)
		{
			currentSkill = skillFrameQueue[currentSkillFrameIndex].skill;
			currentStartRank = skillFrameQueue[currentSkillFrameIndex].startRank;
			currentPlayerNames = skillFrameQueue[currentSkillFrameIndex].playerNames;
			currentLevels = skillFrameQueue[currentSkillFrameIndex].levels;
			currentXPs = skillFrameQueue[currentSkillFrameIndex].XPs;
			currentOnlineStatuses = skillFrameQueue[currentSkillFrameIndex].onlineStatuses;
			
			// move forward head of queue
			currentSkillFrameIndex = (currentSkillFrameIndex + 1) % MAX_SKILL_FRAME_QUEUE_SIZE;
			skillFrameQueueSize--;
		}
	}
	
	public void setContainsData(boolean containsData)
	{
		this.containsData = containsData;
	}
	
	public void hide()
	{
		this.isVisible = false;
	}
	
	public void show()
	{
		this.isVisible = true;
	}
	
	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!isVisible || !containsData || currentXPs == null || currentXPs.length == 0)
			return super.render(graphics);
		
		setPreferredSize(new Dimension(320, 100));
		
		getPanelComponent().getChildren().add(
				TitleComponent.builder()
						.text("JebScape Live Hiscores")
						.color(headerColor)
						.build());
		
		if (currentSkill == 0)
		{
			getPanelComponent().getChildren().add(
					TitleComponent.builder()
							.text("Overall")
							.color(headerColor)
							.build());
		}
		else if (currentSkill <= Skill.values().length)
		{
			getPanelComponent().getChildren().add(
					TitleComponent.builder()
							.text(Skill.values()[currentSkill - 1].getName())
							.color(headerColor)
							.build());
		}
		else
		{
			getPanelComponent().getChildren().add(
					TitleComponent.builder()
							.text("Unknown Skill")
							.color(headerColor)
							.build());
		}
		
		RuneLiteTableComponent liveHiscoresTable = new RuneLiteTableComponent();
		
		liveHiscoresTable.setColumnAlignments(
				RuneLiteTableComponent.TableAlignment.LEFT,
				RuneLiteTableComponent.TableAlignment.CENTER,
				RuneLiteTableComponent.TableAlignment.CENTER,
				RuneLiteTableComponent.TableAlignment.RIGHT);
		
		liveHiscoresTable.addRow(
				ColorUtil.prependColorTag(RANK_COLUMN_HEADER, headerColor),
				ColorUtil.prependColorTag(NAME_COLUMN_HEADER, headerColor),
				ColorUtil.prependColorTag(LEVEL_COLUMN_HEADER, headerColor),
				ColorUtil.prependColorTag(XP_COLUMN_HEADER, headerColor));
		
		for (int i = 0; i < currentXPs.length; ++i)
		{
			if (currentPlayerNames[i] == null || currentPlayerNames[i].length() == 0)
			{
				currentPlayerNames[i] = "[No Player Ranked]";
			}
			
			if (currentOnlineStatuses[i])
			{
				liveHiscoresTable.addRow(
						ColorUtil.prependColorTag(Integer.toString(currentStartRank + i), onlineColor),
						ColorUtil.prependColorTag(currentPlayerNames[i], onlineColor),
						ColorUtil.prependColorTag(Integer.toString(currentLevels[i]), onlineColor),
						ColorUtil.prependColorTag(String.format("%,d", currentXPs[i]), onlineColor)
				);
			}
			else
			{
				liveHiscoresTable.addRow(
						Integer.toString(currentStartRank + i),
						currentPlayerNames[i],
						Integer.toString(currentLevels[i]),
						String.format("%,d", currentXPs[i])
				);
			}
		}
		
		getPanelComponent().getChildren().add(liveHiscoresTable);
		
		// check if widget is being hovered over to add tooltip
		Rectangle bounds = getBounds();
		net.runelite.api.Point mousePosition = client.getMouseCanvasPosition();
		
		if (bounds.contains(mousePosition.getX(), mousePosition.getY()))
		{
			if (plugin.getUseAccountKey())
				tooltipManager.add(accountTooltip);
			else
				tooltipManager.add(guestTooltip);
		}
		
		return super.render(graphics);
	}
}

/*
 * Copyright (c) 2016-2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import java.io.IOException;
import java.nio.ByteBuffer;

public class RuneLiteInputStream extends java.io.InputStream
{
	private static final char[] CHARACTERS = new char[]
			{
					'\u20ac', '\u0000', '\u201a', '\u0192', '\u201e', '\u2026',
					'\u2020', '\u2021', '\u02c6', '\u2030', '\u0160', '\u2039',
					'\u0152', '\u0000', '\u017d', '\u0000', '\u0000', '\u2018',
					'\u2019', '\u201c', '\u201d', '\u2022', '\u2013', '\u2014',
					'\u02dc', '\u2122', '\u0161', '\u203a', '\u0153', '\u0000',
					'\u017e', '\u0178'
			};
	
	private final ByteBuffer buffer;
	
	public RuneLiteInputStream(byte[] buffer)
	{
		this.buffer = ByteBuffer.wrap(buffer);
	}
	
	public byte[] getArray()
	{
		assert buffer.hasArray();
		return buffer.array();
	}
	
	@Override
	public String toString()
	{
		return "InputStream{" + "buffer=" + buffer + '}';
	}
	
	public int read24BitInt()
	{
		return (this.readUnsignedByte() << 16) + (this.readUnsignedByte() << 8) + this.readUnsignedByte();
	}
	
	public void skip(int length)
	{
		int pos = buffer.position();
		pos += length;
		buffer.position(pos);
	}
	
	public void setOffset(int offset)
	{
		buffer.position(offset);
	}
	
	public int getOffset()
	{
		return buffer.position();
	}
	
	public int getLength()
	{
		return buffer.limit();
	}
	
	public int remaining()
	{
		return buffer.remaining();
	}
	
	public byte readByte()
	{
		return buffer.get();
	}
	
	public void readBytes(byte[] buffer, int off, int len)
	{
		this.buffer.get(buffer, off, len);
	}
	
	public void readBytes(byte[] buffer)
	{
		this.buffer.get(buffer);
	}
	
	public int readUnsignedByte()
	{
		return this.readByte() & 0xFF;
	}
	
	public int readUnsignedShort()
	{
		return buffer.getShort() & 0xFFFF;
	}
	
	public short readShort()
	{
		return buffer.getShort();
	}
	
	public int readInt()
	{
		return buffer.getInt();
	}
	
	public long readLong()
	{
		return buffer.getLong();
	}
	
	public byte peek()
	{
		return buffer.get(buffer.position());
	}
	
	public int readBigSmart()
	{
		return peek() >= 0 ? (this.readUnsignedShort() & 0xFFFF) : (this.readInt() & Integer.MAX_VALUE);
	}
	
	public int readBigSmart2()
	{
		if (peek() < 0)
		{
			return readInt() & Integer.MAX_VALUE; // and off sign bit
		}
		int value = readUnsignedShort();
		return value == 32767 ? -1 : value;
	}
	
	public int readShortSmart()
	{
		int peek = this.peek() & 0xFF;
		return peek < 128 ? this.readUnsignedByte() - 64 : this.readUnsignedShort() - 0xc000;
	}
	
	public int readUnsignedShortSmartMinusOne()
	{
		int peek = this.peek() & 0xFF;
		return peek < 128 ? this.readUnsignedByte() - 1 : this.readUnsignedShort() - 0x8001;
	}
	
	public int readUnsignedShortSmart()
	{
		int peek = this.peek() & 0xFF;
		return peek < 128 ? this.readUnsignedByte() : this.readUnsignedShort() - 0x8000;
	}
	
	public int readUnsignedIntSmartShortCompat()
	{
		int var1 = 0;
		
		int var2;
		for (var2 = this.readUnsignedShortSmart(); var2 == 32767; var2 = this.readUnsignedShortSmart())
		{
			var1 += 32767;
		}
		
		var1 += var2;
		return var1;
	}
	
	public String readString()
	{
		StringBuilder sb = new StringBuilder();
		
		for (; ; )
		{
			int ch = this.readUnsignedByte();
			
			if (ch == 0)
			{
				break;
			}
			
			if (ch >= 128 && ch < 160)
			{
				char var7 = CHARACTERS[ch - 128];
				if (0 == var7)
				{
					var7 = '?';
				}
				
				ch = var7;
			}
			
			sb.append((char) ch);
		}
		return sb.toString();
	}
	
	public String readString2()
	{
		if (this.readByte() != 0)
		{
			throw new IllegalStateException("Invalid jstr2");
		}
		else
		{
			return readString();
		}
	}
	
	public String readStringOrNull()
	{
		if (this.peek() != 0)
		{
			return readString();
		}
		else
		{
			this.readByte(); // discard
			return null;
		}
	}
	
	public int readVarInt()
	{
		byte var1 = this.readByte();
		
		int var2;
		for (var2 = 0; var1 < 0; var1 = this.readByte())
		{
			var2 = (var2 | var1 & 127) << 7;
		}
		
		return var2 | var1;
	}
	
	public int readVarInt2()
	{
		int value = 0;
		int bits = 0;
		int read;
		do
		{
			read = readUnsignedByte();
			value |= (read & 0x7F) << bits;
			bits += 7;
		} while (read > 127);
		return value;
	}
	
	public byte[] getRemaining()
	{
		byte[] b = new byte[buffer.remaining()];
		buffer.get(b);
		return b;
	}
	
	@Override
	public int read() throws IOException
	{
		return this.readUnsignedByte();
	}
}
/*
 * Copyright (c) 2023, Justin Ead (Jebrim) <jebscapeplugin@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import net.runelite.api.*;
import net.runelite.api.coords.*;
import net.runelite.api.events.*;
import net.runelite.api.kit.*;
import net.runelite.client.chat.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.util.Text;

import java.nio.charset.*;
import java.util.Arrays;

public class MegaserverMod
{
	public final int MEGASERVER_MOVEMENT_UPDATE_CMD = 0x1; // 0001
	public final int LIVE_HISCORES_STATS_UPDATE_CMD = 0x2; // 0010
	public final int ADMIN_CONTROL_CMD = 0x4; // 0100
	private final int MAX_GHOSTS = 64;
	private static final int NUM_SKILLS = 24; // includes upcoming Sailing skill
	private int post200mXpAccumulator[] = new int[NUM_SKILLS];
	private int skillTypeToTrack = 0;
	private int startRankToTrack = 1;
	private static final int NUM_RANKS = 5;
	private String[] liveHiscoresPlayerNames = new String[NUM_RANKS];
	private int[] liveHiscoresLevels = new int[NUM_RANKS];
	private long[] liveHiscoresXPs = new long[NUM_RANKS];
	private boolean[] liveHiscoresOnlineStatuses = new boolean[NUM_RANKS];
	private boolean isActive = false;
	private Client client;
	private JebScapeConnection server;
	private JebScapeLiveHiscoresOverlay liveHiscoresOverlay;
	private ChatMessageManager chatMessageManager;
	private ConfigManager configManager;
	private JebScapeModelLoader modelLoader = new JebScapeModelLoader();
	private int[] coreData = new int[3];
	private int[] gameSubData = new int[4];
	private int playerCapeID = 31;
	private int prevPlayerCapeID = 31;
	private int prevChatTick = -1;
	private boolean selfGhostDirty = true;
	private boolean[] ghostsDirty = new boolean[MAX_GHOSTS];
	private boolean showSelfGhost = false;
	private int defaultMaleHairPartID = 0;
	private int defaultMaleJawPartID = 0;
	private int defaultFemaleHairPartID = 12;
	private int defaultFemaleJawPartID = 4;
	private int prevDefaultHairPartID = -1;
	private int prevDefaultJawPartID = -1;
	private Model defaultGhostModel;
	private JebScapeActor selfGhost = new JebScapeActor();
	private JebScapeActor[] ghosts = new JebScapeActor[MAX_GHOSTS];
	private int[] prevSelfGhostEquipmentIDs = new int[7];
	private int[] prevSelfGhostBodyPartIDs = new int[3];
	private int[][] prevGhostModelData = new int[MAX_GHOSTS][4];
	private int[] prevGhostCapeID = new int[MAX_GHOSTS];
	private int[] ghostCapeID = new int[MAX_GHOSTS];
	private byte[] nameBytes = new byte[12];
	private byte[] chatBytes = new byte[80];
	private int[] equipmentIDs = new int[7];
	private int[] bodyPartIDs = new int[3];
	private String chatMessageToSend = "";
	private int cmdType = 0;
	private int cmdArg = 0;
	
	public void init(Client client, JebScapeConnection server, JebScapeActorIndicatorOverlay indicatorOverlay, JebScapeMinimapOverlay minimapOverlay, JebScapeLiveHiscoresOverlay liveHiscoresOverlay, ChatMessageManager chatMessageManager, ConfigManager configManager)
	{
		this.client = client;
		this.server = server;
		this.configManager = configManager;
		
		modelLoader.init(client);

		for (int i = 0; i < MAX_GHOSTS; i++)
		{
			ghosts[i] = new JebScapeActor();
		}

		indicatorOverlay.setJebScapeActors(ghosts);
		minimapOverlay.setJebScapeActors(ghosts);

		this.liveHiscoresOverlay = liveHiscoresOverlay;
		liveHiscoresOverlay.setContainsData(false);
		
		this.chatMessageManager = chatMessageManager;
	}
	
	// must only be called once logged in
	public void start()
	{
		// restart if already active
		if (isActive)
			stop();
		
		if (!server.isChatLoggedIn())
		{
			liveHiscoresOverlay.setContainsData(false);
			resetPost200mXpAccumulators();
		}

		selfGhost.init(client, chatMessageManager);
		this.prevPlayerCapeID = 31;
		this.playerCapeID = 31;
		this.selfGhostDirty = true;

		this.prevDefaultHairPartID = -1;
		this.prevDefaultJawPartID = -1;

		int isFemale = client.getLocalPlayer().getPlayerComposition().getGender();
		String keyConfig = configManager.getRSProfileConfiguration("JebScape", "HairPartID");
		if (keyConfig != null)
		{
			this.prevDefaultHairPartID = Integer.parseInt(keyConfig);

			if (isFemale == 1)
			{
				this.defaultFemaleHairPartID = this.prevDefaultHairPartID;
			}
			else
			{
				this.defaultMaleHairPartID = this.prevDefaultHairPartID;
			}
		}

		keyConfig = configManager.getRSProfileConfiguration("JebScape", "JawPartID");
		if (keyConfig != null)
		{
			this.prevDefaultJawPartID = Integer.parseInt(keyConfig);

			if (isFemale == 1)
			{
				this.defaultFemaleJawPartID = this.prevDefaultJawPartID;
			}
			else
			{
				this.defaultMaleJawPartID = this.prevDefaultJawPartID;
			}
		}

		for (int i = 0; i < MAX_GHOSTS; i++)
		{
			ghosts[i].init(client, chatMessageManager);
			this.prevGhostCapeID[i] = 31;
			this.ghostCapeID[i] = 31;
			this.ghostsDirty[i] = true;
		}

		loadGhostRenderables();

		this.isActive = true;
	}
	
	public void stop()
	{
		if (!isActive)
			return;
		
		this.isActive = false;
		this.playerCapeID = 31;
		this.prevPlayerCapeID = 31;
		this.prevChatTick = -1;
		this.selfGhostDirty = true;
		this.chatMessageToSend = "";
		
		if (!server.isChatLoggedIn())
		{
			liveHiscoresOverlay.setContainsData(false);
			resetPost200mXpAccumulators();
		}
		
		selfGhost.despawn();
		for (int i = 0; i < MAX_GHOSTS; i++)
		{
			ghosts[i].despawn();
			this.prevGhostModelData[i][0] = 0;
			this.prevGhostModelData[i][1] = 0;
			this.prevGhostModelData[i][2] = 0;
			this.prevGhostModelData[i][3] = 0;
			this.prevGhostCapeID[i] = 31;
			this.ghostCapeID[i] = 31;
			this.ghostsDirty[i] = true;
		}
	}
	
	public boolean isActive()
	{
		return isActive;
	}
	
	public void showSelfGhost()
	{
		this.showSelfGhost = true;
	}
	
	public void hideSelfGhost()
	{
		this.showSelfGhost = false;
	}
	
	public void onChatMessage(ChatMessage chatMessage)
	{
		if (chatMessage.getName() != null && (chatMessage.getType() == ChatMessageType.PUBLICCHAT || chatMessage.getType() == ChatMessageType.MODCHAT))
		{
			String senderName = Text.sanitize(chatMessage.getName());
			String playerName = Text.sanitize(client.getLocalPlayer().getName());
			// check if we were the sender
			if (chatMessage.getName() != null && senderName.contentEquals(playerName))
			{
				this.chatMessageToSend = chatMessage.getMessage();
			}
		}
	}
	
	public void onCommandExecuted(int cmdType, int cmdArg)
	{
		this.cmdType = cmdType;
		this.cmdArg = cmdArg;
		this.chatMessageToSend = " ";
	}
	
	public void onAnimationChanged(AnimationChanged animationChanged)
	{
		// TODO: check against the local player; maybe checking this earlier will help fix some of our animation issues
	}
	
	public void onFakeXpDrop(FakeXpDrop fakeXpDrop)
	{
		Skill skill = fakeXpDrop.getSkill();
		this.post200mXpAccumulator[skill.ordinal()] += fakeXpDrop.getXp();
	}
	
	public void resetPost200mXpAccumulators()
	{
		Arrays.fill(this.post200mXpAccumulator, 0);
	}
	
	public void setLiveHiscoresSkillType(int skillType)
	{
		this.skillTypeToTrack = skillType;
	}
	
	public void setLiveHiscoresStartRank(int startRank)
	{
		this.startRankToTrack = startRank;
	}

	// returns number of game data bytes sent
	public int onGameTick()
	{
		// must occur before packets are unpacked
		liveHiscoresOverlay.onGameTick();
		
		// analyze most recent data received from the server
		JebScapeServerData[][] chatServerData = server.getRecentChatServerData();
		int[] numChatPacketsSent = server.getNumChatServerPacketsSent();
		int currentChatTick = server.getCurrentChatTick();
		final int JAU_PACKING_RATIO = 32;
		
		// this will update up to 64 ghosts with up to 16 past ticks' worth of data
		// doing this makes us more resilient to unpredictable network delays with either the OSRS server or JebScape server
		// we start with the oldest data first...
		for (int i = 0; i < server.TICKS_UNTIL_LOGOUT; i++)
		{
			// start the cycle from the earliest tick we might have data on
			int chatTick = (currentChatTick + i) % server.TICKS_UNTIL_LOGOUT;

			// only bother if we've received any packets for this tick
			if (numChatPacketsSent[chatTick] > 0)
			{
				boolean isFirstPacket = true;

				for (int packetID = 0; packetID < server.CHAT_SERVER_PACKETS_PER_TICK; packetID++)
				{
					JebScapeServerData data = chatServerData[chatTick][packetID];
					boolean emptyPacket = data.isEmpty();
					boolean containsMegaserverCmd = false;
					boolean containsLiveHiscoresCmd = false;
					int playerWorldFlags = 0;
					int playerWorld = 0;
					int playerWorldLocationX = 0;
					int playerWorldLocationY = 0;
					int playerWorldLocationPlane = 0;
					int playerPackedOrientation = 0;
					int playerAnimationID = 0;
					boolean playerIsInteracting = false;
					boolean playerIsPoseAnimation = false;
					boolean isInstanced = false;

					// let's initialize our player position data
					if (!emptyPacket)
					{
						// unpack the core data
						// 8 bitflags for game command
						// 1 bit isPVP
						// 1 bit isInstanced
						// 6 bits reserved
						// 14 bits world
						// 2 bits plane
						containsMegaserverCmd = ((data.blocks[0][1] & 0xFF) & // bitflag, so let's just test the one bit
								MEGASERVER_MOVEMENT_UPDATE_CMD) != 0;					// 8/32 bits
						containsLiveHiscoresCmd = ((data.blocks[0][1] & 0xFF) & // bitflag, so let's just test the one bit
								LIVE_HISCORES_STATS_UPDATE_CMD) != 0;					// 8/32 bits
						playerWorldFlags = (data.blocks[0][1] >>> 8) & 0xFF;			// 16/32 bits
						playerWorld = (data.blocks[0][1] >>> 16) & 0x3FFF;				// 30/32 bits
						playerWorldLocationPlane = (data.blocks[0][1] >>> 30) & 0x3; 	// 32/32 bits

						// 16 bits world X position
						// 16 bits world Y position
						playerWorldLocationX = (data.blocks[0][2] & 0xFFFF);			// 16/32 bits
						playerWorldLocationY = ((data.blocks[0][2] >>> 16) & 0xFFFF);	// 32/32 bits

						// 10 bits reserved
						// 6 bits packedOrientation
						// 14 bits animationID
						// 1 bit isInteracting
						// 1 bit isPoseAnimation
						playerPackedOrientation = (data.blocks[0][3] >>> 10) & 0x3F;		// 16/32 bits
						playerAnimationID = (data.blocks[0][3] >>> 16) & 0x3FFF;			// 30/32 bits
						playerIsInteracting = ((data.blocks[0][3] >>> 30) & 0x1) == 0x1;	// 31/32 bits
						playerIsPoseAnimation = ((data.blocks[0][3] >>> 31) & 0x1) == 0x1;	// 32/32 bits

						// experimental implementation for instances
						isInstanced = ((playerWorldFlags >>> 0x1) & 0x1) == 0x1;
						if (client.isInInstancedRegion() && isInstanced)
						{
							// find the difference between the instance positions
							WorldPoint currentPlayerWorldPosition = client.getLocalPlayer().getWorldLocation();
							WorldPoint currentPlayerInstancePosition = WorldPoint.fromLocalInstance(client, LocalPoint.fromWorld(client, currentPlayerWorldPosition));
							int dx = playerWorldLocationX - currentPlayerInstancePosition.getX();
							int dy = playerWorldLocationY - currentPlayerInstancePosition.getY();

							// add this difference to where our player happens to be located in normal world space
							playerWorldLocationX = currentPlayerWorldPosition.getX() + dx;
							playerWorldLocationY = currentPlayerWorldPosition.getY() + dy;
							playerWorldLocationPlane = currentPlayerWorldPosition.getPlane();
						}

						// profile stats:
						/*
						if (packetID == 0)
						{
							int coreTickTime = data.blocks[26][0];
							int totalTickTime = data.blocks[26][1];
							int postTickTime = data.blocks[26][2];
							int playerCount = data.blocks[26][3];
							client.addChatMessage(ChatMessageType.TENSECTIMEOUT, "", "Core: " + coreTickTime + " Total: " + totalTickTime + " Post: " + postTickTime + " Players: " + playerCount, null);
						}
						//*/
					}

					if (playerWorld == client.getWorld())
					{
						if (isFirstPacket && showSelfGhost && prevChatTick != chatTick)
						{
							// handle updating self ghost here
							WorldPoint ghostPosition = new WorldPoint(playerWorldLocationX, playerWorldLocationY, playerWorldLocationPlane);
							selfGhost.moveTo(ghostPosition, playerPackedOrientation * JAU_PACKING_RATIO, playerAnimationID, playerIsInteracting, playerIsPoseAnimation, isInstanced, chatTick);
							this.prevChatTick = chatTick; // this prevents packets with the same server gameTick across two different client gameTicks from repeating the same moveTo destination
							isFirstPacket = false;
						}

						// all ghost positional data within a packet is relative to 15 tiles SW of where the server believes the player to be
						playerWorldLocationX -= 15;
						playerWorldLocationY -= 15;

						// 16 ghosts per packet, split across 4 sections (5 blocks each)
						for (int sectionID = 0; sectionID < 4; sectionID++)
						{
							int ghostDataBlockIdx = sectionID * 5 + 1; // 1, 6, 11, 16

							// there are 4 ghosts per data block
							for (int j = 0; j < JebScapeServerData.DATA_BLOCK_SIZE; j++)
							{
								int ghostID = (packetID * 16) + (sectionID * JebScapeServerData.DATA_BLOCK_SIZE) + j;

								// all data outside the total range must necessarily have despawned ghosts
								if (packetID >= numChatPacketsSent[chatTick])
								{
									ghosts[ghostID].despawn();
									this.prevGhostModelData[ghostID][0] = 0;
									this.prevGhostModelData[ghostID][1] = 0;
									this.prevGhostModelData[ghostID][2] = 0;
									this.prevGhostModelData[ghostID][3] = 0;
									this.prevGhostCapeID[ghostID] = 31;
									this.ghostCapeID[ghostID] = 31;
								}
								else if (!emptyPacket) // within range and not empty, so let's process
								{
									// each piece of ghost data is 4 bytes
									int ghostData = data.blocks[ghostDataBlockIdx][j];

									// if the values are 0x1F (31) for each dx and dy, then the ghost has despawned
									// 10 bits combined for dx and dy; check first if despawned
									boolean despawned = (ghostData & 0x3FF) == 0x3FF; // 10 bits (if dx and dy are both all 1s)

									if (despawned)
									{
										ghosts[ghostID].despawn();
										this.prevGhostModelData[ghostID][0] = 0;
										this.prevGhostModelData[ghostID][1] = 0;
										this.prevGhostModelData[ghostID][2] = 0;
										this.prevGhostModelData[ghostID][3] = 0;
										this.prevGhostCapeID[ghostID] = 31;
										this.ghostCapeID[ghostID] = 31;
									}
									else
									{
										// not despawned, so let's extract the full data
										// 5 bits dx
										// 5 bits dy
										// 6 bits packedOrientation
										// 14 bits animationID
										// 1 bit isInteracting
										// 1 bit isPoseAnimation
										int dx = ghostData & 0x1F;										// 5/32 bits
										int dy = (ghostData >>> 5) & 0x1F;								// 10/32 bits
										int packedOrientation = (ghostData >>> 10) & 0x3F;				// 16/32 bits
										int animationID = (ghostData >>> 16) & 0x3FFF;					// 30/32 bits
										boolean isInteracting = ((ghostData >>> 30) & 0x1) == 0x1;		// 31/32 bits
										boolean isPoseAnimation = ((ghostData >>> 31) & 0x1) == 0x1;	// 32/32 bits

										WorldPoint ghostPosition = new WorldPoint(playerWorldLocationX + dx, playerWorldLocationY + dy, playerWorldLocationPlane);
										ghosts[ghostID].moveTo(ghostPosition, packedOrientation * JAU_PACKING_RATIO, animationID, isInteracting, isPoseAnimation, isInstanced, chatTick);
										
										int blockIdx = ghostDataBlockIdx + j + 1;

										if ((chatTick & 0x1) == 0x1)
										{
											boolean modelDataChanged = data.blocks[blockIdx][0] != prevGhostModelData[ghostID][0];
											modelDataChanged = modelDataChanged || (data.blocks[blockIdx][1] != prevGhostModelData[ghostID][1]);
											modelDataChanged = modelDataChanged || (data.blocks[blockIdx][2] != prevGhostModelData[ghostID][2]);
											modelDataChanged = modelDataChanged || (data.blocks[blockIdx][3] != prevGhostModelData[ghostID][3]);
											modelDataChanged = modelDataChanged || ghostCapeID[ghostID] != prevGhostCapeID[ghostID];
											modelDataChanged = modelDataChanged || ghostsDirty[ghostID];

											this.prevGhostModelData[ghostID][0] = data.blocks[blockIdx][0];
											this.prevGhostModelData[ghostID][1] = data.blocks[blockIdx][1];
											this.prevGhostModelData[ghostID][2] = data.blocks[blockIdx][2];
											this.prevGhostModelData[ghostID][3] = data.blocks[blockIdx][3];
											this.prevGhostCapeID[ghostID] = ghostCapeID[ghostID];
											ghostsDirty[ghostID] = false;

											if (modelDataChanged)
											{
												// extract ghost model data
												equipmentIDs[0] = data.blocks[blockIdx][0] & 0xFFFF;
												equipmentIDs[1] = (data.blocks[blockIdx][0] >>> 16) & 0xFFFF;

												equipmentIDs[2] = data.blocks[blockIdx][1] & 0xFFFF;
												equipmentIDs[3] = (data.blocks[blockIdx][1] >>> 16) & 0xFFFF;

												equipmentIDs[4] = data.blocks[blockIdx][2] & 0xFFFF;
												equipmentIDs[5] = (data.blocks[blockIdx][2] >>> 16) & 0xFFFF;

												equipmentIDs[6] = data.blocks[blockIdx][3] & 0xFFFF;
												int isFemale = (data.blocks[blockIdx][3] >>> 31) & 0x1;
												bodyPartIDs = modelLoader.unpackBodyParts((data.blocks[blockIdx][3] >>> 16) & 0x7FFF, isFemale);

												Model ghostModel = modelLoader.loadPlayerGhostRenderable(equipmentIDs, bodyPartIDs, isFemale, ghostCapeID[ghostID]);
												ghosts[ghostID].setModel(ghostModel);
											}
										}
										else
										{
											// extract ghost world and name
											int ghostWorld = data.blocks[blockIdx][0] & 0x3FFF;
											ghosts[ghostID].setWorld(ghostWorld);
											this.ghostCapeID[ghostID] = (data.blocks[blockIdx][0] >>> 14) & 0x1F;

											nameBytes[0] = (byte)(data.blocks[blockIdx][1] & 0xFF);
											nameBytes[1] = (byte)((data.blocks[blockIdx][1] >>> 8) & 0xFF);
											nameBytes[2] = (byte)((data.blocks[blockIdx][1] >>> 16) & 0xFF);
											nameBytes[3] = (byte)((data.blocks[blockIdx][1] >>> 24) & 0xFF);

											nameBytes[4] = (byte)(data.blocks[blockIdx][2] & 0xFF);
											nameBytes[5] = (byte)((data.blocks[blockIdx][2] >>> 8) & 0xFF);
											nameBytes[6] = (byte)((data.blocks[blockIdx][2] >>> 16) & 0xFF);
											nameBytes[7] = (byte)((data.blocks[blockIdx][2] >>> 24) & 0xFF);

											nameBytes[8] = (byte)(data.blocks[blockIdx][3] & 0xFF);
											nameBytes[9] = (byte)((data.blocks[blockIdx][3] >>> 8) & 0xFF);
											nameBytes[10] = (byte)((data.blocks[blockIdx][3] >>> 16) & 0xFF);
											nameBytes[11] = (byte)((data.blocks[blockIdx][3] >>> 24) & 0xFF);

											ghosts[ghostID].setName(new String(nameBytes, StandardCharsets.UTF_8).trim());
										}
									}
								}
							}
						}

						if (containsMegaserverCmd) // contains chat messages (TODO: fix naming and how this command works so there's only 1 bit ever used)
						{
							// extract chat message
							int ghostWorld = data.blocks[28][0];

							if (ghostWorld != 0)
							{
								// a chat message exists, so let's extract the rest
								nameBytes[0] = (byte)(data.blocks[28][1] & 0xFF);
								nameBytes[1] = (byte)((data.blocks[28][1] >>> 8) & 0xFF);
								nameBytes[2] = (byte)((data.blocks[28][1] >>> 16) & 0xFF);
								nameBytes[3] = (byte)((data.blocks[28][1] >>> 24) & 0xFF);

								nameBytes[4] = (byte)(data.blocks[28][2] & 0xFF);
								nameBytes[5] = (byte)((data.blocks[28][2] >>> 8) & 0xFF);
								nameBytes[6] = (byte)((data.blocks[28][2] >>> 16) & 0xFF);
								nameBytes[7] = (byte)((data.blocks[28][2] >>> 24) & 0xFF);

								nameBytes[8] = (byte)(data.blocks[28][3] & 0xFF);
								nameBytes[9] = (byte)((data.blocks[28][3] >>> 8) & 0xFF);
								nameBytes[10] = (byte)((data.blocks[28][3] >>> 16) & 0xFF);
								nameBytes[11] = (byte)((data.blocks[28][3] >>> 24) & 0xFF);

								String senderName = new String(nameBytes, StandardCharsets.UTF_8).trim();
								// now let's see if we can find the corresponding ghost for this chat message
								for (int ghostID = 0; ghostID < MAX_GHOSTS; ghostID++)
								{
									JebScapeActor ghost = ghosts[ghostID];
									if (ghost.isActive())
									{
										String name = ghost.getName();
										if (ghost.getWorld() == ghostWorld && name != null && name.contentEquals(senderName))
										{
											// we found our ghost, let's proceed
											int index = 0;
											for (int j = 29; j < 34; j++)
											{
												for (int k = 0; k < 4; k++)
												{
													chatBytes[index++] = (byte)(data.blocks[j][k] & 0xFF);
													chatBytes[index++] = (byte)((data.blocks[j][k] >>> 8) & 0xFF);
													chatBytes[index++] = (byte)((data.blocks[j][k] >>> 16) & 0xFF);
													chatBytes[index++] = (byte)((data.blocks[j][k] >>> 24) & 0xFF);
												}
											}

											ghosts[ghostID].setChatMessage(new String(chatBytes, StandardCharsets.UTF_8).trim());
											break;
										}
									}
								}
							}
						}
						else if (containsLiveHiscoresCmd) // contains live hiscores data instead
						{
							// player coreData contains info on the current monitored player rather than oneself

							// unpack the sub data
							// 3 bits monitoredPlayerRankOffset (ranks 0-4; all 1 bits mean none is monitored)
							// 17 bits startingRank (the ranks we pass down are offset by this)
							// 12 bits liveHiscoresLevels[0]
							int monitoredPlayerRankOffset = data.blocks[28][0] & 0x7;		// 3/32 bits
							int startRank = (data.blocks[28][0] >>> 3) & 0x1FFFF;			// 20/32 bits
							liveHiscoresLevels[0] = (data.blocks[28][0] >>> 20) & 0xFFF;	// 32/32 bits

							// 12 bits liveHiscoresLevels[1]
							// 12 bits liveHiscoresLevels[2]
							// 8 bits reserved
							liveHiscoresLevels[1] = data.blocks[28][1] & 0xFFF;				// 12/32 bits
							liveHiscoresLevels[2] = (data.blocks[28][1] >>> 12) & 0xFFF;	// 24/32 bits

							// 12 bits liveHiscoresLevels[3]
							// 12 bits liveHiscoresLevels[4]
							// 8 bits reserved
							liveHiscoresLevels[3] = data.blocks[28][2] & 0xFFF;				// 12/32 bits
							liveHiscoresLevels[4] = (data.blocks[28][2] >>> 12) & 0xFFF;	// 24/32 bits

							// 5 bits skill type
							// 2 bits reserved
							// 25 bits for Overall upperXPs; 5 bits each
							// 2 bits reserved
							int skillType = data.blocks[28][3] & 0x5F;								// 5/32 bits
							//int reserved = (data.subDataBlocks[0][3] >>> 5) & 0x3;				// 7/32 bits
							liveHiscoresXPs[0] = (long)((data.blocks[28][3] >>> 7) & 0x1F) << 31;	// 12/32 bits
							liveHiscoresXPs[1] = (long)((data.blocks[28][3] >>> 12) & 0x1F) << 31;	// 17/32 bits
							liveHiscoresXPs[2] = (long)((data.blocks[28][3] >>> 17) & 0x1F) << 31;	// 22/32 bits
							liveHiscoresXPs[3] = (long)((data.blocks[28][3] >>> 22) & 0x1F) << 31;	// 27/32 bits
							liveHiscoresXPs[4] = (long)((data.blocks[28][3] >>> 27) & 0x1F) << 31;	// 32/32 bits

							for (int j = 0; j < NUM_RANKS; j++)
							{
								int blockIdx = j + 29;
								liveHiscoresXPs[j] |= data.blocks[blockIdx][0] & 0x7FFFFFFF;				// 31/32 bits
								liveHiscoresOnlineStatuses[j] = ((data.blocks[blockIdx][0] >>> 31) == 0x1);	// 32/32 bits

								nameBytes[0] = (byte)(data.blocks[blockIdx][1] & 0xFF);
								nameBytes[1] = (byte)((data.blocks[blockIdx][1] >>> 8) & 0xFF);
								nameBytes[2] = (byte)((data.blocks[blockIdx][1] >>> 16) & 0xFF);
								nameBytes[3] = (byte)((data.blocks[blockIdx][1] >>> 24) & 0xFF);

								nameBytes[4] = (byte)(data.blocks[blockIdx][2] & 0xFF);
								nameBytes[5] = (byte)((data.blocks[blockIdx][2] >>> 8) & 0xFF);
								nameBytes[6] = (byte)((data.blocks[blockIdx][2] >>> 16) & 0xFF);
								nameBytes[7] = (byte)((data.blocks[blockIdx][2] >>> 24) & 0xFF);

								nameBytes[8] = (byte)(data.blocks[blockIdx][3] & 0xFF);
								nameBytes[9] = (byte)((data.blocks[blockIdx][3] >>> 8) & 0xFF);
								nameBytes[10] = (byte)((data.blocks[blockIdx][3] >>> 16) & 0xFF);
								nameBytes[11] = (byte)((data.blocks[blockIdx][3] >>> 24) & 0xFF);

								liveHiscoresPlayerNames[j] = new String(nameBytes, StandardCharsets.UTF_8).trim();
							}

							liveHiscoresOverlay.updateSkillHiscoresData(skillType, startRank, liveHiscoresPlayerNames, liveHiscoresLevels, liveHiscoresXPs, liveHiscoresOnlineStatuses);

							if (startRank == 1 && liveHiscoresPlayerNames[0].contentEquals(client.getLocalPlayer().getName()))
							{
								// if our player is rank 1 in a skill, let's update their capeID accordingly
								// set to female max cape if rank 1 Overall is female
								this.playerCapeID = (skillType == 0 && client.getLocalPlayer().getPlayerComposition().getGender() == 1) ? JebScapeModelLoader.femaleMaxCapeID : skillType;
							}
						}
					}
				}
			}
		}
		
		// now let's send our data to the server for the current tick
		Player player = client.getLocalPlayer();
		WorldPoint position = player.getWorldLocation();
		boolean isPoseAnimation = player.getAnimation() == -1;
		int animationID = player.getAnimation();
		if (isPoseAnimation)
		{
			if (currentChatTick == 0 || currentChatTick == 8)
				animationID = player.getIdlePoseAnimation();
			else if ((currentChatTick & 0x1) == 0x1)
				animationID = player.getWalkAnimation();
			else
				animationID = player.getRunAnimation();
		}
		boolean isInteracting = player.getInteracting() != null;
		int packedOrientation = player.getOrientation() / JAU_PACKING_RATIO;
		boolean isPVP = WorldType.isPvpWorld(client.getWorldType());
		boolean isInstanced = client.isInInstancedRegion();
		
		if (isInstanced)
			position = WorldPoint.fromLocalInstance(client, LocalPoint.fromWorld(client, position));
		
		// populate the packet body
		// 8 bitflags for game command
		// 1 bit isPVP
		// 1 bit isInstanced
		// 6 bits reserved
		// 14 bits world
		// 2 bits plane
		coreData[0] = MEGASERVER_MOVEMENT_UPDATE_CMD & 0xFF;// 8/32 bits
		coreData[0] |= (isPVP ? 0x1 : 0x0) << 8;			// 9/32 bits
		coreData[0] |= (isInstanced ? 0x1 : 0x0) << 9;		// 10/32 bits
		coreData[0] |= (0x0 & 0x3F) << 10;					// 16/32 bits
		coreData[0] |= (client.getWorld() & 0x3FFF) << 16;	// 30/32 bits
		coreData[0] |= (client.getPlane() & 0x3) << 30;		// 32/32 bits
		
		// 16 bits world X position
		// 16 bits world Y position
		coreData[1] = position.getX() & 0xFFFF;				// 16/32 bits
		coreData[1] |= (position.getY() & 0xFFFF) << 16;	// 32/32 bits
		
		// 5 bits reserved
		// 5 bits playerCapeID
		// 6 bits packedOrientation
		// 14 bits animationID
		// 1 bit isInteracting
		// 1 bit isPoseAnimation
		coreData[2] = (0x0 & 0x3FF) << 5;					// 5/32 bits
		coreData[2] |= (playerCapeID & 0x1F) << 5;			// 10/32 bits
		coreData[2] |= (packedOrientation & 0x3F) << 10;	// 16/32 bits
		coreData[2] |= (animationID & 0x3FFF) << 16;		// 30/32 bits
		coreData[2] |= (isInteracting ? 0x1 : 0x0) << 30;	// 31/32 bits
		coreData[2] |= (isPoseAnimation ? 0x1 : 0x0) << 31;	// 32/32 bits
		
		// get player models and send them across as well
		PlayerComposition playerComposition = player.getPlayerComposition();
		int[] allEquipmentIDs = playerComposition.getEquipmentIds();
		equipmentIDs[0] = allEquipmentIDs[KitType.AMULET.ordinal()];
		equipmentIDs[1] = allEquipmentIDs[KitType.WEAPON.ordinal()];
		equipmentIDs[2] = allEquipmentIDs[KitType.TORSO.ordinal()];
		equipmentIDs[3] = allEquipmentIDs[KitType.SHIELD.ordinal()];
		equipmentIDs[4] = allEquipmentIDs[KitType.LEGS.ordinal()];
		equipmentIDs[5] = allEquipmentIDs[KitType.HANDS.ordinal()];
		equipmentIDs[6] = allEquipmentIDs[KitType.BOOTS.ordinal()];

		int hairID = playerComposition.getKitId(KitType.HAIR);
		int jawID = playerComposition.getKitId(KitType.JAW);
		int armsID = playerComposition.getKitId(KitType.ARMS);
		int isFemale = playerComposition.getGender();

		if (hairID >= 0)
		{
			int hairPartID = JebScapeModelLoader.kitIDtoBodyPartMap[hairID];

			if (isFemale == 1)
				this.defaultFemaleHairPartID = hairPartID;
			else
				this.defaultMaleHairPartID = hairPartID;

			if (prevDefaultHairPartID != hairPartID)
			{
				configManager.setRSProfileConfiguration("JebScape", "HairPartID", hairPartID);
				this.prevDefaultHairPartID = hairPartID;
			}
		}

		if (jawID >= 0)
		{
			int jawPartID = JebScapeModelLoader.kitIDtoBodyPartMap[jawID];

			if (isFemale == 1)
				this.defaultFemaleJawPartID = jawPartID;
			else
				this.defaultMaleJawPartID = jawPartID;

			if (prevDefaultJawPartID != jawPartID)
			{
				configManager.setRSProfileConfiguration("JebScape", "JawPartID", jawPartID);
				this.prevDefaultJawPartID = jawPartID;
			}
		}

		bodyPartIDs[0] = hairID >= 0 ? JebScapeModelLoader.kitIDtoBodyPartMap[hairID] : (isFemale == 1 ? defaultFemaleHairPartID : defaultMaleHairPartID);
		bodyPartIDs[1] = jawID >= 0 ? JebScapeModelLoader.kitIDtoBodyPartMap[jawID] : (isFemale == 1 ? defaultFemaleJawPartID : defaultMaleJawPartID);
		bodyPartIDs[2] = armsID >= 0 ? JebScapeModelLoader.kitIDtoBodyPartMap[armsID] : 0;

		if (showSelfGhost)
		{
			if ((prevChatTick & 0x1) == 0x1)
			{
				boolean modelHasChanged = false;
				
				for (int i = 0; i < equipmentIDs.length; i++)
				{
					modelHasChanged = modelHasChanged || (equipmentIDs[i] != prevSelfGhostEquipmentIDs[i]);
					this.prevSelfGhostEquipmentIDs[i] = equipmentIDs[i];
				}
				
				for (int i = 0; i < bodyPartIDs.length; i++)
				{
					modelHasChanged = modelHasChanged || (bodyPartIDs[i] != prevSelfGhostBodyPartIDs[i]);
					this.prevSelfGhostBodyPartIDs[i] = bodyPartIDs[i];
				}
				
				modelHasChanged = modelHasChanged || (playerCapeID != prevPlayerCapeID);
				modelHasChanged = modelHasChanged || selfGhostDirty;
				this.prevPlayerCapeID = playerCapeID;
				this.selfGhostDirty = false;
				
				if (modelHasChanged)
				{
					selfGhost.setModel(modelLoader.loadPlayerGhostRenderable(equipmentIDs, bodyPartIDs, isFemale, playerCapeID));
				}
			}
		}
		else
		{
			selfGhost.despawn();
		}
		
		// 16 bits per equipment ID (2x)
		gameSubData[0] = equipmentIDs[0] & 0xFFFF;			// 16/32 bits
		gameSubData[0] |= (equipmentIDs[1] & 0xFFFF) << 16;	// 32/32 bits
		
		// 16 bits per equipment ID (2x)
		gameSubData[1] = equipmentIDs[2] & 0xFFFF;			// 16/32 bits
		gameSubData[1] |= (equipmentIDs[3] & 0xFFFF) << 16;	// 32/32 bits
		
		// 16 bits per equipment ID (2x)
		gameSubData[2] = equipmentIDs[4] & 0xFFFF;			// 16/32 bits
		gameSubData[2] |= (equipmentIDs[5] & 0xFFFF) << 16;	// 32/32 bits
		
		// 16 bits equipment ID
		// 15 bits packed body part IDs
		// 1 bit isFemale
		gameSubData[3] = equipmentIDs[6] & 0xFFFF;												// 16/32 bits
		gameSubData[3] |= (modelLoader.packBodyParts(bodyPartIDs, isFemale) & 0x7FFF) << 16;	// 31/32 bits
		gameSubData[3] |= (isFemale == 1 ? 1 : 0) << 31;										// 32/32 bits

		byte[] extraChatData = new byte[96];
		
		if (!chatMessageToSend.isEmpty()) // check if we've recently sent a chat message
		{
			if (cmdType != 0)
			{
				coreData[0] |= ADMIN_CONTROL_CMD;
				extraChatData[91] = (byte)(cmdType & 0xFF);
				extraChatData[92] = (byte)(cmdArg);
				extraChatData[93] = (byte)((cmdArg) >>> 8);
				extraChatData[94] = (byte)((cmdArg) >>> 16);
				extraChatData[95] = (byte)((cmdArg) >>> 24);
				
				this.cmdType = 0;
				this.cmdArg = 0;
			}
			else
			{
				extraChatData = chatMessageToSend.getBytes(StandardCharsets.UTF_8);
			}
			
			this.chatMessageToSend = "";
		}
		else
		{
			// update the command flag sent
			coreData[0] |= LIVE_HISCORES_STATS_UPDATE_CMD;
			
			// TODO: account for Overall or custom skill
			int skillType = skillTypeToTrack;
			
			// TODO: pack monitor player type and value
			// we are going to pack these slightly differently, with 1 bit per skill
			int userInputDataA = 0; // reserved for custom JebScape skill
			int userInputDataB = 0; // reserved for upper bits of custom JebScape skill & monitored player data
			int userInputDataC = startRankToTrack & 0x1FFFF;	// 17/24 bits
			userInputDataC |= (skillType & 0x7F) << 17;			// 24/24 bits
			
			if (!server.isChatGuest()) // authenticated
			{
				// if we're not sending a chat message this tick, then let's send a stat update for the hiscores
				Skill skills[] = Skill.values();
				final int numSkills = skills.length;
				for (int i = 0; i < numSkills; i++)
				{
					int xp = client.getSkillExperience(skills[i]);
					if (xp == 200000000) // if maxed out
					{
						// let's include our accumulated fake xp drops; clamp it to be safe from buffer overflows
						post200mXpAccumulator[i] = Math.max(0, Math.min(336870911, post200mXpAccumulator[i])); // 2^29 - 1 - 200m
						xp += post200mXpAccumulator[i];
						
						// if we surpass 300m xp gained within a single login session, reset back to 0 to avoid risking an uncontrolled buffer overflow
						// the server has comparable behavior, so as long as this one packet doesn't get lost, we should be okay...
						// I would still advise the player log out before 300m xp is gained in a single session just in case
						if (post200mXpAccumulator[i] > 300000000)
						{
							resetPost200mXpAccumulators();
						}
					}
					
					xp = (xp & 0x1FFFFFFF); // use only 29 bits
					
					extraChatData[i * 4] = (byte)(xp);          	// 8/32 bits
					extraChatData[i * 4 + 1] = (byte)(xp >>> 8);	// 16/32 bits
					extraChatData[i * 4 + 2] = (byte)(xp >>> 16);	// 24/32 bits
					extraChatData[i * 4 + 3] = (byte)(xp >>> 24);	// 29/32 bits
				}
			}
			
			for (int i = 0; i < NUM_SKILLS; i++)
			{
				// we have 3 bits to spare per skill, let's pack them in one at a time
				extraChatData[i * 4 + 3] |= (byte)(((userInputDataA >>> i) & 0x1) << 5);    // 30/32 bits
				extraChatData[i * 4 + 3] |= (byte)(((userInputDataB >>> i) & 0x1) << 6);    // 31/32 bits
				extraChatData[i * 4 + 3] |= (byte)(((userInputDataC >>> i) & 0x1) << 7);    // 32/32 bits
			}
		}
		
		return server.sendGameData(coreData, gameSubData, extraChatData) ? 12 : 0; // TODO: Why are we returning 12 here?
	}
	
	public void onClientTick(ClientTick clientTick)
	{
		if (!isActive)
			return;
		
		// never unset dirty here
		boolean result = !selfGhost.onClientTick();
		this.selfGhostDirty = selfGhostDirty ? true : result;
		for (int i = 0; i < MAX_GHOSTS; i++)
		{
			// update local position and orientation
			result = !ghosts[i].onClientTick();
			this.ghostsDirty[i] = ghostsDirty[i] ? true : result;
		}
	}
	
	private void loadGhostRenderables()
	{
		this.defaultGhostModel = client.loadModel(9925); // null blank model

		selfGhost.setDefaultModel(defaultGhostModel);
		selfGhost.setPoseAnimations(client.getLocalPlayer());
		for (int i = 0; i < MAX_GHOSTS; i++)
		{
			ghosts[i].setDefaultModel(defaultGhostModel);
			ghosts[i].setPoseAnimations(client.getLocalPlayer());
		}
	}
}

/*
 * Copyright (c) 2023, Justin Ead (Jebrim) <jebscapeplugin@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Font;
import java.awt.FontMetrics;
import javax.inject.Singleton;
import net.runelite.api.*;
import net.runelite.api.Perspective;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.*;

@Singleton
public class JebScapeActorIndicatorOverlay extends Overlay
{
	private JebScapeActor[] actors;
	private Client client;
	private final Color color = new Color(5, 248, 242, 218);
	
	public void init(Client client)
	{
		this.client = client;
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPriority(OverlayPriority.HIGHEST);
		setPosition(OverlayPosition.TOP_LEFT);
		setMovable(false);
	}
	
	public void setJebScapeActors(JebScapeActor[] actors)
	{
		this.actors = actors;
	}
	
	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (actors != null)
		{
			for (int i = 0; i < actors.length; ++i)
			{
				JebScapeActor actor = actors[i];
				if (actor.isActive())
				{
					String overheadText = actor.getOverheadText();
					if (overheadText != null && !overheadText.isEmpty())
					{
						Point textLocation = Perspective.localToCanvas(client, actor.getLocalLocation(), client.getPlane(), 260);
						
						if (textLocation != null)
						{
							Font chatFont = FontManager.getRunescapeSmallFont();
							
							// shift the position to center over the actor
							FontMetrics metrics = graphics.getFontMetrics(chatFont);
							// divide by 2 through bitshift
							textLocation = new Point(textLocation.getX() - (metrics.stringWidth(overheadText) >>> 1), textLocation.getY());
							
							if (textLocation != null)
							{
								graphics.setFont(chatFont);
								OverlayUtil.renderTextLocation(graphics, textLocation, overheadText, color);
							}
						}
					}
					
					String chatMessage = actor.getChatMessage();
					if (chatMessage != null && !chatMessage.isEmpty())
					{
						Point textLocation = Perspective.localToCanvas(client, actor.getLocalLocation(), client.getPlane(), 225);
						
						if (textLocation != null)
						{
							Font chatFont = FontManager.getRunescapeBoldFont();
							
							// shift the position to center over the actor
							FontMetrics metrics = graphics.getFontMetrics(chatFont);
							// divide by 2 through bitshift
							textLocation = new Point(textLocation.getX() - (metrics.stringWidth(chatMessage) >>> 1), textLocation.getY());
							
							if (textLocation != null)
							{
								graphics.setFont(chatFont);
								OverlayUtil.renderTextLocation(graphics, textLocation, chatMessage, JagexColors.YELLOW_INTERFACE_TEXT);
							}
						}
					}
				}
			}
		}
		
		return null;
	}
}

/*
 * Copyright (c) 2023, Justin Ead (Jebrim) <jebscapeplugin@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

// this class excludes the packet header and focuses on the remaining 124 of the total 128 bytes
public class JebScapeServerData
{
	public static final int DATA_BLOCK_SIZE = 4; // 4 bytes each
	public static final int NUM_DATA_BLOCKS = 34; // 34 blocks at 4 bytes each (544 bytes)
	public int[][] blocks = new int[NUM_DATA_BLOCKS][DATA_BLOCK_SIZE];	// 544/544 bytes

	public void setData(JebScapePacket packet)
	{
		packet.buffer.rewind();

		for (int i = 0; i < NUM_DATA_BLOCKS; i++)
			for (int j = 0; j < DATA_BLOCK_SIZE; j++)
				blocks[i][j] = packet.buffer.getInt();
	}
	
	void clear()
	{
		for (int i = 0; i < NUM_DATA_BLOCKS; i++)
			for (int j = 0; j < DATA_BLOCK_SIZE; j++)
				blocks[i][j] = 0;
	}
	
	public boolean isEmpty()
	{
		return blocks[0][0] == 0;
	}
}

/*
 * Copyright (c) 2023, Justin Ead (Jebrim) <jebscapeplugin@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import java.awt.*;
import java.awt.Point;
import java.awt.event.MouseEvent;
import javax.inject.Inject;
import net.runelite.api.*;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.ui.overlay.components.*;
import net.runelite.client.ui.overlay.components.ComponentOrientation;
import net.runelite.client.ui.overlay.tooltip.*;
import net.runelite.client.input.*;

public class JebScapeProfilePinOverlay extends Overlay implements MouseListener
{
	private Client client;
	private JebScapePlugin plugin;
	@Inject
	private TooltipManager tooltipManager;
	@Inject MouseManager mouseManager;
	private Color defaultBackgroundColor;
	private Color hoverColor;
	private Color pressedColor;
	private final Color cyanColor = new Color(5, 248, 242, 218);
	private final Tooltip[] pinTooltips = new Tooltip[10];
	private final Dimension dimension = new Dimension(160, 25);
	private PanelComponent panelComponent = new PanelComponent();
	private PanelComponent bottomPanelComponent = new PanelComponent();
	private PanelComponent[] pinPanelComponents = new PanelComponent[10];
	private TitleComponent titleComponent;
	private TitleComponent[] pinTitleComponents = new TitleComponent[10];
	private int[] pinValues = new int[4];
	private int currentPinIndex = 0;
	private boolean isVisible;
	
	public void init(Client client, JebScapePlugin plugin)
	{
		this.client = client;
		this.plugin = plugin;
		this.isVisible = false;
		
		setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
		setPriority(OverlayPriority.HIGH);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setMovable(false);
		
		mouseManager.registerMouseListener(this);
		
		panelComponent.getChildren().clear();
		panelComponent.setPreferredSize(dimension);
		panelComponent.setOrientation(ComponentOrientation.VERTICAL);
		
		titleComponent = TitleComponent.builder()
				.text("JebScape PIN: _ _ _ _")
				.color(cyanColor)
				.preferredSize(dimension)
				.build();
		
		panelComponent.getChildren().add(titleComponent);
		
		bottomPanelComponent.getChildren().clear();
		bottomPanelComponent.setPreferredSize(dimension);
		bottomPanelComponent.setOrientation(ComponentOrientation.HORIZONTAL);
		bottomPanelComponent.setGap(new Point(7, 20));
		panelComponent.getChildren().add(bottomPanelComponent);
		this.defaultBackgroundColor = bottomPanelComponent.getBackgroundColor();
		this.hoverColor = defaultBackgroundColor.brighter();
		this.pressedColor = defaultBackgroundColor.darker();
		
		for (int i = 0; i < 10; i++)
		{
			pinTitleComponents[i] = TitleComponent.builder()
							.text(Integer.toString(i))
							.color(cyanColor)
							.preferredLocation(new Point(40 * i, 20))
							.preferredSize(new Dimension(45, 20))
							.build();
			this.pinPanelComponents[i] = new PanelComponent();
			pinPanelComponents[i].setGap(new Point(40, 20));
			pinPanelComponents[i].setPreferredSize(new Dimension(45, 20));
			pinPanelComponents[i].setOrientation(ComponentOrientation.HORIZONTAL);
			pinPanelComponents[i].getChildren().add(pinTitleComponents[i]);
			bottomPanelComponent.getChildren().add(pinPanelComponents[i]);
			pinTooltips[i] = new Tooltip("Enter " + i);
		}
		
		for (int i = 0; i < 4; i++)
		{
			pinValues[i] = -1;
		}
	}
	
	public void cleanup()
	{
		mouseManager.unregisterMouseListener(this);
	}
	
	public void hide()
	{
		this.isVisible = false;
		
		for (int i = 0; i < 4; i++)
		{
			pinValues[i] = -1;
		}
	}
	
	public void show()
	{
		this.isVisible = true;
		this.currentPinIndex = 0;
		
		for (int i = 0; i < 10; i++)
		{
			pinPanelComponents[i].setBackgroundColor(defaultBackgroundColor);
		}
		
		for (int i = 0; i < 4; i++)
		{
			pinValues[i] = -1;
		}
		
		titleComponent.setText("JebScape PIN: _ _ _ _");
	}
	
	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (isVisible)
		{
			// check if widget is being hovered over
			Rectangle bounds = getBounds();
			net.runelite.api.Point mousePosition = client.getMouseCanvasPosition();
			
			for (int i = 0; i < 10; i++)
			{
				Rectangle pinBounds = pinTitleComponents[i].getBounds();
				Rectangle newCombined = new Rectangle(bounds.x + pinBounds.x - 7, bounds.y + pinBounds.y - 7, 15, 35);
				if (newCombined.contains(mousePosition.getX(), mousePosition.getY()))
				{
					tooltipManager.add(pinTooltips[i]);
				}
			}
			
			return panelComponent.render(graphics);
		}
		
		return null;
	}
	
	@Override
	public MouseEvent mouseClicked(MouseEvent mouseEvent)
	{
		if (isVisible)
		{
			// check if widget is being hovered over
			Rectangle bounds = getBounds();
			net.runelite.api.Point mousePosition = client.getMouseCanvasPosition();
			
			for (int i = 0; i < 10; i++)
			{
				Rectangle pinBounds = pinTitleComponents[i].getBounds();
				Rectangle newCombined = new Rectangle(bounds.x + pinBounds.x - 7, bounds.y + pinBounds.y - 7, 15, 35);
				if (newCombined.contains(mousePosition.getX(), mousePosition.getY()))
				{
					pinPanelComponents[i].setBackgroundColor(pressedColor);
					pinValues[currentPinIndex] = i;
					this.currentPinIndex++;
					
					String pinLabelText = "JebScape PIN:";
					for (int pinIndex = 0; pinIndex < 4; pinIndex++)
					{
						if (pinIndex < currentPinIndex)
						{
							pinLabelText += " " + pinValues[pinIndex];
						}
						else
						{
							pinLabelText += " _";
						}
					}
					
					titleComponent.setText(pinLabelText);
					
					if (currentPinIndex == 4)
					{
						plugin.setAccountKeySalt(pinValues);
					}
					
					mouseEvent.consume();
				}
			}
		}
		
		return mouseEvent;
	}
	
	@Override
	public MouseEvent mousePressed(MouseEvent mouseEvent)
	{
		if (isVisible)
		{
			// check if widget is being hovered over
			Rectangle bounds = getBounds();
			net.runelite.api.Point mousePosition = client.getMouseCanvasPosition();
			
			for (int i = 0; i < 10; i++)
			{
				Rectangle pinBounds = pinTitleComponents[i].getBounds();
				Rectangle newCombined = new Rectangle(bounds.x + pinBounds.x - 7, bounds.y + pinBounds.y - 7, 15, 35);
				if (newCombined.contains(mousePosition.getX(), mousePosition.getY()))
				{
					mouseEvent.consume();
				}
			}
		}
		
		return mouseEvent;
	}
	
	@Override
	public MouseEvent mouseReleased(MouseEvent mouseEvent)
	{
		if (isVisible)
		{
			// check if widget is being hovered over
			Rectangle bounds = getBounds();
			net.runelite.api.Point mousePosition = client.getMouseCanvasPosition();
			
			for (int i = 0; i < 10; i++)
			{
				Rectangle pinBounds = pinTitleComponents[i].getBounds();
				Rectangle newCombined = new Rectangle(bounds.x + pinBounds.x - 7, bounds.y + pinBounds.y - 7, 15, 35);
				if (newCombined.contains(mousePosition.getX(), mousePosition.getY()))
				{
					mouseEvent.consume();
				}
			}
		}
		
		return mouseEvent;
	}
	
	@Override
	public MouseEvent mouseDragged(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}
	
	@Override
	public MouseEvent mouseMoved(MouseEvent mouseEvent)
	{
		if (isVisible)
		{
			// check if widget is being hovered over
			Rectangle bounds = getBounds();
			net.runelite.api.Point mousePosition = client.getMouseCanvasPosition();
			
			for (int i = 0; i < 10; i++)
			{
				Rectangle pinBounds = pinTitleComponents[i].getBounds();
				Rectangle newCombined = new Rectangle(bounds.x + pinBounds.x - 7, bounds.y + pinBounds.y - 7, 15, 35);
				if (newCombined.contains(mousePosition.getX(), mousePosition.getY()))
				{
					pinPanelComponents[i].setBackgroundColor(hoverColor);
				}
				else
				{
					pinPanelComponents[i].setBackgroundColor(defaultBackgroundColor);
				}
			}
		}
		
		return mouseEvent;
	}
	
	@Override
	public MouseEvent mouseEntered(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}
	
	@Override
	public MouseEvent mouseExited(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}
}
/*
 * Copyright (c) 2023, Justin Ead (Jebrim) <jebscapeplugin@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.*;

public class JebScapeMinimapOverlay extends Overlay
{
	private JebScapeActor[] actors;
	private Client client;
	private final Color color = new Color(5, 248, 242, 218);
	
	public void init(Client client)
	{
		this.client = client;
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(OverlayPriority.HIGHEST);
		setPosition(OverlayPosition.DYNAMIC);
		setMovable(false);
	}
	
	public void setJebScapeActors(JebScapeActor[] actors)
	{
		this.actors = actors;
	}
	
	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (actors != null)
		{
			SpritePixels[] mapDots = client.getMapDots();
			
			if (mapDots != null)
			{
				for (int i = 0; i < actors.length; i++)
				{
					JebScapeActor actor = actors[i];
					if (actor.isActive())
					{
						Point minimapPoint = Perspective.localToMinimap(client, actors[i].getLocalLocation());
						if (minimapPoint != null)
						{
							OverlayUtil.renderMinimapLocation(graphics, minimapPoint, color);
						}
					}
				}
			}
		}
		
		return null;
	}
}

/*
 * Copyright (c) 2023, Justin Ead (Jebrim) <jebscapeplugin@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import net.runelite.api.*;

public class JebScapeModelLoader
{
	private enum BodyPart
	{
		MALE_HAIR,
		MALE_JAW,
		MALE_TORSO,
		MALE_ARMS,
		MALE_HANDS,
		MALE_LEGS,
		MALE_FEET,
		FEMALE_HAIR,
		FEMALE_JAW,
		FEMALE_TORSO,
		FEMALE_ARMS,
		FEMALE_HANDS,
		FEMALE_LEGS,
		FEMALE_FEET
	}

	private static int[][] hairKitMap = new int[2][128];
	private static int[][] jawKitMap = new int[2][32];
	private static int[][] armsKitMap = new int[2][32];
	private static int NUM_KIT_IDS = PlayerComposition.ITEM_OFFSET - PlayerComposition.KIT_OFFSET;
	public static int[] kitIDtoBodyPartMap = new int[NUM_KIT_IDS];
	private static int numMaleHairKits = 0;
	private static int numMaleJawKits = 0;
	private static int numMaleArmsKits = 0;
	private static int numFemaleHairKits = 0;
	private static int numFemaleJawKits = 0;
	private static int numFemaleArmsKits = 0;
	
	private static final short[] BODY_COLOURS_1_SOURCE = new short[]{
			6798, 8741, 25238, 4626, 4550
	};
	private static final short[][] BODY_COLOURS_1_DEST = new short[][]{
			{6798, 107, 10283, 16, 4797, 7744, 5799, 4634, -31839, 22433, 2983, -11343, 8, 5281, 10438, 3650, -27322, -21845, 200, 571, 908, 21830, 28946, -15701, -14010, -22122, 937, 8130, -13422, 30385},
			{8741, 12, -1506, -22374, 7735, 8404, 1701, -27106, 24094, 10153, -8915, 4783, 1341, 16578, -30533, 25239, 8, 5281, 10438, 3650, -27322, -21845, 200, 571, 908, 21830, 28946, -15701, -14010},
			{25238, 8742, 12, -1506, -22374, 7735, 8404, 1701, -27106, 24094, 10153, -8915, 4783, 1341, 16578, -30533, 8, 5281, 10438, 3650, -27322, -21845, 200, 571, 908, 21830, 28946, -15701, -14010},
			{4626, 11146, 6439, 12, 4758, 10270},
			{4550, 4537, 5681, 5673, 5790, 6806, 8076, 4574, 17050, 0, 127, -31821, -17991}
	};
	private static final short[] BODY_COLOURS_2_SOURCE = new short[]{
			-10304, 9104, -1, -1, -1
	};
	private static final short[][] BODY_COLOURS_2_DEST = new short[][]{
			{6554, 115, 10304, 28, 5702, 7756, 5681, 4510, -31835, 22437, 2859, -11339, 16, 5157, 10446, 3658, -27314, -21965, 472, 580, 784, 21966, 28950, -15697, -14002, -22116, 945, 8144, -13414, 30389},
			{9104, 10275, 7595, 3610, 7975, 8526, 918, -26734, 24466, 10145, -6882, 5027, 1457, 16565, -30545, 25486, 24, 5392, 10429, 3673, -27335, -21957, 192, 687, 412, 21821, 28835, -15460, -14019},
			new short[0],
			new short[0],
			new short[0]
	};
	
	private Client client;
	private IndexDataBase gameDB;
	
	private static final int GHOST_COLOR = 18626;
	private static final int GHOST_TRANSPARENCY = 60;
	private static final int DEFAULT_MALE_GHOST_CAPE = 3189;
	private static final int DEFAULT_FEMALE_GHOST_CAPE = 3194;
	
	private static final int KIT_CONFIG_TYPE = 3;
	private RuneLiteKitLoader kitLoader = new RuneLiteKitLoader();
	
	private static final int ITEM_CONFIG_TYPE = 10;
	private RuneLiteItemLoader itemLoader = new RuneLiteItemLoader();
	
	private static final int NUM_MODEL_DATA = 38;
	private ModelData[] modelData = new ModelData[NUM_MODEL_DATA];
	private int[] modelIDs = new int[NUM_MODEL_DATA];
	
	public void init(Client client)
	{
		this.client = client;
		this.gameDB = client.getIndexConfig();

		this.numMaleHairKits = 0;
		this.numMaleJawKits = 0;
		this.numMaleArmsKits = 0;
		this.numFemaleHairKits = 0;
		this.numFemaleJawKits = 0;
		this.numFemaleArmsKits = 0;
		
		for (int i = 0; i < NUM_KIT_IDS; i++)
			kitIDtoBodyPartMap[i] = 0;

		// maintain a null state for arms but not hair or jaw
		armsKitMap[0][numMaleArmsKits++] = -1;
		armsKitMap[1][numFemaleArmsKits++] = -1;

		for (int i = 0; i < NUM_KIT_IDS; i++)
		{
			byte[] kitData;
			try
			{
				kitData = gameDB.loadData(KIT_CONFIG_TYPE, i);
			}
			catch (Exception e)
			{
				break;
			}

			if (kitData != null)
			{
				RuneLiteKitDefinition kitDefinition = kitLoader.load(i, kitData);

				if (kitDefinition.bodyPartId == BodyPart.MALE_HAIR.ordinal())
					hairKitMap[0][numMaleHairKits++] = i;
				else if (kitDefinition.bodyPartId == BodyPart.MALE_JAW.ordinal())
					jawKitMap[0][numMaleJawKits++] = i;
				else if (kitDefinition.bodyPartId == BodyPart.MALE_ARMS.ordinal())
					armsKitMap[0][numMaleArmsKits++] = i;
				else if (kitDefinition.bodyPartId == BodyPart.FEMALE_HAIR.ordinal())
					hairKitMap[1][numFemaleHairKits++] = i;
				else if (kitDefinition.bodyPartId == BodyPart.FEMALE_JAW.ordinal())
					jawKitMap[1][numFemaleJawKits++] = i;
				else if (kitDefinition.bodyPartId == BodyPart.FEMALE_ARMS.ordinal())
					armsKitMap[1][numFemaleArmsKits++] = i;
			}
		}

		// male
		for (int i = 0; i < numMaleHairKits; i++)
			kitIDtoBodyPartMap[hairKitMap[0][i]] = i;
		for (int i = 0; i < numMaleJawKits; i++)
			kitIDtoBodyPartMap[jawKitMap[0][i]] = i;
		for (int i = 1; i < numMaleArmsKits; i++)
			kitIDtoBodyPartMap[armsKitMap[0][i]] = i;

		// female
		for (int i = 0; i < numFemaleHairKits; i++)
			kitIDtoBodyPartMap[hairKitMap[1][i]] = i;
		for (int i = 0; i < numFemaleJawKits; i++)
			kitIDtoBodyPartMap[jawKitMap[1][i]] = i;
		for (int i = 1; i < numFemaleArmsKits; i++)
			kitIDtoBodyPartMap[armsKitMap[1][i]] = i;
	}

	public int packBodyParts(int[] bodyPartIDs, int gender)
	{
		int packedData = bodyPartIDs[0];

		if (gender != 1) // if male
		{
			packedData += bodyPartIDs[1] * numMaleHairKits;
			packedData += bodyPartIDs[2] * numMaleHairKits * numMaleJawKits;
		}
		else
		{
			packedData += bodyPartIDs[1] * numFemaleHairKits;
			packedData += bodyPartIDs[2] * numFemaleHairKits * numFemaleJawKits;
		}

		return packedData;
	}

	private static int[] unpackedBodyParts = new int[3];
	public int[] unpackBodyParts(int packedBodyParts, int gender)
	{
		if (gender != 1) // if male
		{
			unpackedBodyParts[0] = packedBodyParts % numMaleHairKits;
			packedBodyParts /= numMaleHairKits;
			unpackedBodyParts[1] = packedBodyParts % numMaleJawKits;
			packedBodyParts /= numMaleJawKits;
			unpackedBodyParts[2] = packedBodyParts % numMaleArmsKits;
		}
		else
		{
			unpackedBodyParts[0] = packedBodyParts % numFemaleHairKits;
			packedBodyParts /= numFemaleHairKits;
			unpackedBodyParts[1] = packedBodyParts % numFemaleJawKits;
			packedBodyParts /= numFemaleJawKits;
			unpackedBodyParts[2] = packedBodyParts % numFemaleArmsKits;
		}

		return unpackedBodyParts;
	}
	
	private static ModelData recolourKitModel(ModelData modelData, int bodyPart, int[] kitRecolours)
	{
		/*
		0 = Hair, Jaw
		1 = Torso, Arms
		2 = Legs
		3 = Boots
		4 = Hands, Other
		*/
		switch (bodyPart)
		{
			case 0:
				modelData.recolor(BODY_COLOURS_1_SOURCE[0], BODY_COLOURS_1_DEST[0][kitRecolours[0]]);
				modelData.recolor(BODY_COLOURS_2_SOURCE[0], BODY_COLOURS_2_DEST[0][kitRecolours[0]]);
				modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
				break;
			case 1:
				modelData.recolor(BODY_COLOURS_1_SOURCE[1], BODY_COLOURS_1_DEST[1][kitRecolours[1]]);
				modelData.recolor(BODY_COLOURS_2_SOURCE[1], BODY_COLOURS_2_DEST[1][kitRecolours[1]]);
				modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
				break;
			case 2:
				modelData.recolor(BODY_COLOURS_1_SOURCE[2], BODY_COLOURS_1_DEST[2][kitRecolours[2]]);
				modelData.recolor(BODY_COLOURS_1_SOURCE[3], BODY_COLOURS_1_DEST[3][kitRecolours[3]]);
				modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
				break;
			case 3:
				modelData.recolor(BODY_COLOURS_1_SOURCE[3], BODY_COLOURS_1_DEST[3][kitRecolours[3]]);
				modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
				break;
			case 4:
				modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
		}
		
		return modelData;
	}
	
	public Model loadPlayerCloneRenderable()
	{
		if (gameDB == null)
		{
			this.gameDB = client.getIndexConfig();
		}
		
		Player player = client.getLocalPlayer();
		PlayerComposition playerComposition = player.getPlayerComposition();
		int gender = playerComposition.getGender();
		int[] equipmentIds = playerComposition.getEquipmentIds();
		
		int numModelIDs = 0;
		
		int[] colorIDs = playerComposition.getColors();
		ColorTextureOverride[] overrides = playerComposition.getColorTextureOverrides();
		
		for (int i = 0; i < equipmentIds.length; i++)
		{
			if (equipmentIds[i] > PlayerComposition.ITEM_OFFSET)
			{
				int itemID = equipmentIds[i] - PlayerComposition.ITEM_OFFSET;
				byte[] itemData = gameDB.loadData(ITEM_CONFIG_TYPE, itemID);

				if (itemData != null)
				{
					RuneLiteItemDefinition itemDefinition = itemLoader.load(itemID, itemData);
					int startingCount = numModelIDs;
					if (gender == 1)
					{
						if (itemDefinition.femaleModel0 >= 0)
							modelIDs[numModelIDs++] = itemDefinition.femaleModel0;
						if (itemDefinition.femaleModel1 >= 0)
							modelIDs[numModelIDs++] = itemDefinition.femaleModel1;
						if (itemDefinition.femaleModel2 >= 0)
							modelIDs[numModelIDs++] = itemDefinition.femaleModel2;
					}
					else
					{
						if (itemDefinition.maleModel0 >= 0)
							modelIDs[numModelIDs++] = itemDefinition.maleModel0;
						if (itemDefinition.maleModel1 >= 0)
							modelIDs[numModelIDs++] = itemDefinition.maleModel1;
						if (itemDefinition.maleModel2 >= 0)
							modelIDs[numModelIDs++] = itemDefinition.maleModel2;
					}
				
					for (int modelIndex = startingCount; modelIndex < numModelIDs; modelIndex++)
					{
						modelData[modelIndex] = client.loadModelData(modelIDs[modelIndex]);
						if (itemDefinition.colorFind != null)
						{
							int numToRecolor = itemDefinition.colorFind.length;
							for (int recolorIndex = 0; recolorIndex < numToRecolor; recolorIndex++)
							{
								short replaceColor = itemDefinition.colorReplace[recolorIndex];
								if (overrides != null && overrides.length >= i && overrides[i].getColorToReplaceWith() != null && overrides[i].getColorToReplaceWith().length >= 0)
								{
									replaceColor = overrides[i].getColorToReplaceWith()[recolorIndex];
								}
								modelData[modelIndex].recolor(itemDefinition.colorFind[recolorIndex], replaceColor);
							}
						}
					}
				}
			}
			else if (equipmentIds[i] >= PlayerComposition.KIT_OFFSET)
			{
				int kitID = equipmentIds[i] - PlayerComposition.KIT_OFFSET;
				byte[] kitData = gameDB.loadData(KIT_CONFIG_TYPE, kitID);

				if (kitData != null)
				{
					RuneLiteKitDefinition kitDefinition = kitLoader.load(kitID, kitData);
					for (int j = 0; j < kitDefinition.models.length; j++)
					{
						modelIDs[numModelIDs] = kitDefinition.models[j];
						modelData[numModelIDs] = client.loadModelData(modelIDs[numModelIDs]);

						if (kitDefinition.recolorToFind != null)
						{
							int numToRecolor = kitDefinition.recolorToFind.length;
							for (int recolorIndex = 0; recolorIndex < numToRecolor; recolorIndex++)
							{
								modelData[numModelIDs].recolor(kitDefinition.recolorToFind[recolorIndex], kitDefinition.recolorToReplace[recolorIndex]);
							}
						}

						final int[] bodyPartMap = { 0, 0, 1, 1, 4, 2, 3 };
						if (kitDefinition.bodyPartId >= 0)
						{
							recolourKitModel(modelData[numModelIDs], bodyPartMap[kitDefinition.bodyPartId], colorIDs);
						}

						numModelIDs++;
					}
				}
			}
		}
		
		ModelData combinedModelData = client.mergeModels(modelData, numModelIDs);
		
		// use the same lighting parameters used for NPCs by Jagex
		// TODO: This is a bit bright compared to what the actual players look like; tweak dimmer
		return combinedModelData.light(64, 850, -30, -50, -30);
	}
	
	public static final int femaleMaxCapeID = 25;
	
	private static final int[] skillcapeIDs = new int[]
	{
			29616,	// MAX CAPE MALE
			18919, 	// ATTACK
			18927,	// DEFENCE
			18952,	// STRENGTH
			18979,	// HITPOINTS
			18930,	// RANGED
			18944,	// PRAYER
			18941,	// MAGIC
			18923,	// COOKING
			18957,	// WOODCUTTING
			18937,	// FLETCHING
			18933,	// FISHING
			18931,	// FIREMAKING
			18926,	// CRAFTING
			19100,	// SMITHING
			19099,	// MINING
			18936,	// HERBLORE
			18917,	// AGILITY
			18958,	// THIEVING
			18949,	// SLAYER
			18921,	// FARMING
			18947,	// RUNECRAFT
			19873,	// HUNTER
			18922,	// CONSTRUCTION
			29617,	// MAX CAPE BUCKET
			29624	// MAX CAPE FEMALE
	};
	
	private int[] kitIDs = new int[3];
	
	public Model loadPlayerGhostRenderable(int[] equipmentIDs, int[] bodyPartIDs, int gender, int capeID)
	{
		if (gameDB == null)
		{
			this.gameDB = client.getIndexConfig();
		}
		
		int numModelIDs = 0;
		
		for (int i = 0; i < equipmentIDs.length; i++)
		{
			if (equipmentIDs[i] > PlayerComposition.ITEM_OFFSET)
			{
				int itemID = equipmentIDs[i] - PlayerComposition.ITEM_OFFSET;
				byte[] itemData;
				try
				{
					itemData = gameDB.loadData(ITEM_CONFIG_TYPE, itemID);
				}
				catch (Exception e)
				{
					continue;
				}

				if (itemData != null)
				{
					RuneLiteItemDefinition itemDefinition = itemLoader.load(itemID, itemData);
					if (gender == 1)
					{
						if (itemDefinition.femaleModel0 >= 0)
							modelIDs[numModelIDs++] = itemDefinition.femaleModel0;
						if (itemDefinition.femaleModel1 >= 0)
							modelIDs[numModelIDs++] = itemDefinition.femaleModel1;
						if (itemDefinition.femaleModel2 >= 0)
							modelIDs[numModelIDs++] = itemDefinition.femaleModel2;
					}
					else
					{
						if (itemDefinition.maleModel0 >= 0)
							modelIDs[numModelIDs++] = itemDefinition.maleModel0;
						if (itemDefinition.maleModel1 >= 0)
							modelIDs[numModelIDs++] = itemDefinition.maleModel1;
						if (itemDefinition.maleModel2 >= 0)
							modelIDs[numModelIDs++] = itemDefinition.maleModel2;
					}
				}
			}
			else if (equipmentIDs[i] >= PlayerComposition.KIT_OFFSET)
			{
				int kitID = equipmentIDs[i] - PlayerComposition.KIT_OFFSET;
				byte[] kitData;
				try
				{
					kitData = gameDB.loadData(KIT_CONFIG_TYPE, kitID);
				}
				catch (Exception e)
				{
					continue;
				}

				if (kitData != null)
				{
					RuneLiteKitDefinition kitDefinition = kitLoader.load(kitID, kitData);
					for (int j = 0; j < kitDefinition.models.length; j++)
					{
						modelIDs[numModelIDs++] = kitDefinition.models[j];
					}
				}
			}
		}

		int genderIndex = gender == 1 ? 1 : 0;
		kitIDs[0] = hairKitMap[genderIndex][bodyPartIDs[0]];
		kitIDs[1] = jawKitMap[genderIndex][bodyPartIDs[1]];
		kitIDs[2] = armsKitMap[genderIndex][bodyPartIDs[2]];

		for (int i = 0; i < kitIDs.length; i++)
		{
			byte[] kitData;
			try
			{
				kitData = gameDB.loadData(KIT_CONFIG_TYPE, kitIDs[i]);
			}
			catch (Exception e)
			{
				continue;
			}

			if (kitData != null)
			{
				RuneLiteKitDefinition kitDefinition = kitLoader.load(kitIDs[i], kitData);
				for (int j = 0; j < kitDefinition.models.length; j++)
				{
					modelIDs[numModelIDs++] = kitDefinition.models[j];
				}
			}
		}
		
		modelIDs[numModelIDs++] = 9925; // null filler that guarantees model remains transparent

		int defaultGhostCape = gender == 1 ? DEFAULT_FEMALE_GHOST_CAPE : DEFAULT_MALE_GHOST_CAPE;
		modelIDs[numModelIDs++] = (capeID < 0 || capeID >= skillcapeIDs.length) ? defaultGhostCape : skillcapeIDs[capeID]; // we decide the cape used, not the player

		numModelIDs = numModelIDs > NUM_MODEL_DATA ? NUM_MODEL_DATA : numModelIDs; // cap it to ensure it doesn't exceed NUM_MODEL_DATA
		
		for (int i = 0; i < numModelIDs; i++)
		{
			modelData[i] = client.loadModelData(modelIDs[i]);
		}
		int numCapeFaces = modelData[numModelIDs - 1].getFaceColors().length;
		
		ModelData combinedModelData = client.mergeModels(modelData, numModelIDs);
		ModelData clonedModelData = combinedModelData.cloneColors();
		if (clonedModelData.getFaceTransparencies() != null)
			clonedModelData = clonedModelData.cloneTransparencies();
		if (clonedModelData.getFaceTextures() != null)
			clonedModelData = clonedModelData.cloneTextures();
		short[] clonedColors = clonedModelData.getFaceColors();

		int numToReplace = (modelIDs[numModelIDs - 1] == defaultGhostCape) ? clonedColors.length : clonedColors.length - numCapeFaces;
		for (int i = 0; i < numToReplace; i++)
		{
			clonedColors[i] = GHOST_COLOR;
		}
		
		if (clonedModelData.getFaceTransparencies() != null)
		{
			for (int i = 0; i < clonedModelData.getFaceTransparencies().length; i++)
			{
				if (clonedModelData.getFaceTransparencies()[i] == 0)
					clonedModelData.getFaceTransparencies()[i] = GHOST_TRANSPARENCY;
			}
		}

		if (clonedModelData.getFaceTextures() != null)
		{
			for (int i = 0; i < clonedModelData.getFaceTextures().length; i++)
			{
				clonedModelData.getFaceTextures()[i] = -1;
			}
		}
		
		// use the same lighting parameters used for NPCs by Jagex
		return clonedModelData.light(64, 850, -30, -50, -30);
	}
}

/*
 * Copyright (c) 2023, Justin Ead (Jebrim) <jebscapeplugin@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import com.google.inject.Provides;

import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.*;
import net.runelite.client.chat.*;
import net.runelite.client.callback.*;
import net.runelite.client.config.*;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.*;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.*;

@Slf4j
@PluginDescriptor(name = "JebScape")
public class JebScapePlugin extends Plugin
{
	@Inject
	private Client client;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private JebScapeActorIndicatorOverlay actorIndicatorOverlay;
	@Inject
	private JebScapeMinimapOverlay minimapOverlay;
	@Inject
	private JebScapeLiveHiscoresOverlay liveHiscoresOverlay;
	@Inject
	private JebScapeProfilePinOverlay profilePinOverlay;
	@Inject
	private ClientThread clientThread;
	@Inject
	private JebScapeConfig config;
	@Inject
	private ConfigManager configManager;
	@Inject
	private ChatMessageManager chatMessageManager;
	private JebScapeConnection server = new JebScapeConnection();
	private MegaserverMod megaserverMod = new MegaserverMod();
	private boolean useMegaserverMod = true;
	private boolean useAccountKey = false;
	private long chatAccountKey = 0;
	private long accountKeySalt = 0;
	private boolean replaceAccountKeySalt = false;
	private int loginTimeout = 0;
	private int loginAttempts = 0;
	
	private final static int NUM_HASH_SALT_PAIRS = 4;
	private static class AccountHashSaltPair
	{
		long accountHash;
		long accountKeySalt;
	}
	private AccountHashSaltPair[] accountHashSaltPairs = new AccountHashSaltPair[NUM_HASH_SALT_PAIRS];
	private int accountHashSaltPairIndex = -1;
	
	@Override
	protected void startUp() throws Exception
	{
		log.info("JebScape has started!");
		
		server.init();
		if (!server.connect())
			log.debug("ERROR: JebScape datagram channel failed to connect.");
		
		actorIndicatorOverlay.init(client);
		minimapOverlay.init(client);
		liveHiscoresOverlay.init(client);
		profilePinOverlay.init(client, this);
		
		overlayManager.add(actorIndicatorOverlay);
		overlayManager.add(minimapOverlay);
		overlayManager.add(liveHiscoresOverlay);
		overlayManager.add(profilePinOverlay);
		
		for (int i = 0; i < NUM_HASH_SALT_PAIRS; i++)
		{
			accountHashSaltPairs[i] = new AccountHashSaltPair();
			accountHashSaltPairs[i].accountHash = 0;
			accountHashSaltPairs[i].accountKeySalt = 0;
		}
		
		clientThread.invoke(() ->
		{
			useMegaserverMod = true;
			megaserverMod.init(client, server, actorIndicatorOverlay, minimapOverlay, liveHiscoresOverlay, chatMessageManager, configManager);
			
			if (configManager.getConfiguration("jebscape", "showSelfGhost", boolean.class))
				megaserverMod.showSelfGhost();
			else
				megaserverMod.hideSelfGhost();
			
			if (configManager.getConfiguration("jebscape", "hideLiveHiscores", boolean.class))
				liveHiscoresOverlay.hide();
			else
				liveHiscoresOverlay.show();
			
			JebScapeConfig.JebScapeSkill skill = configManager.getConfiguration("jebscape", "selectSkillLiveHiscores", JebScapeConfig.JebScapeSkill.class);
			megaserverMod.setLiveHiscoresSkillType(skill.ordinal());
			megaserverMod.setLiveHiscoresStartRank(configManager.getConfiguration("jebscape", "startRankLiveHiscores", int.class));
		});
	}
	
	@Override
	protected void shutDown() throws Exception
	{
		clientThread.invoke(() ->
		{
			server.logout();
			megaserverMod.resetPost200mXpAccumulators();
			megaserverMod.stop();
		});
		
		for (int i = 0; i < NUM_HASH_SALT_PAIRS; i++)
		{
			accountHashSaltPairs[i].accountHash = 0;
			accountHashSaltPairs[i].accountKeySalt = 0;
		}
		
		this.useAccountKey = false;
		this.chatAccountKey = 0;
		this.accountKeySalt = 0;
		this.loginTimeout = 0;
		this.replaceAccountKeySalt = false;
		
		profilePinOverlay.cleanup();
		overlayManager.remove(profilePinOverlay);
		overlayManager.remove(liveHiscoresOverlay);
		overlayManager.remove(minimapOverlay);
		overlayManager.remove(actorIndicatorOverlay);
		server.disconnect();
		
		log.info("JebScape has stopped!");
	}
	
	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		// if no longer logged into OSRS, disconnect
		if (gameStateChanged.getGameState() != GameState.LOGGED_IN && client.getGameState() != GameState.LOADING)
		{
			server.logout();
			profilePinOverlay.hide();
			liveHiscoresOverlay.setContainsData(false);
			megaserverMod.resetPost200mXpAccumulators();
			this.loginTimeout = 0;
			this.accountKeySalt = 0;
		}
		else if (gameStateChanged.getGameState() != GameState.LOGGED_IN)
		{
			// reset the mod on loading screens, but not the server login status
			megaserverMod.stop();
		}
	}
	
	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		if (megaserverMod.isActive())
			megaserverMod.onChatMessage(chatMessage);
	}
	
	@Subscribe
	public void onCommandExecuted(CommandExecuted commandExecuted)
	{
		if (commandExecuted.getCommand().contentEquals("jeb"))
		{
			boolean success = false;
			String[] args = commandExecuted.getArguments();
			if (args.length == 2)
			{
				try
				{
					int cmdType = Integer.parseInt(args[0]);
					int cmdArg = Integer.parseInt(args[1]);
					
					if (megaserverMod.isActive())
						megaserverMod.onCommandExecuted(cmdType, cmdArg);
					
					success = true;
				}
				catch (Exception e)
				{
					success = false;
				}
			}
			
			if (!success)
			{
				ChatMessageBuilder message = new ChatMessageBuilder();
				message.append(ChatColorType.HIGHLIGHT).append("Invalid JebScape command.");
				chatMessageManager.queue(QueuedMessage.builder()
						.type(ChatMessageType.GAMEMESSAGE)
						.runeLiteFormattedMessage(message.build().replaceAll("colHIGHLIGHT", "col=02f502"))
						.build());
			}
		}
	}
	
	@Subscribe
	public void onAnimationChanged(AnimationChanged animationChanged)
	{
		if (megaserverMod.isActive())
			megaserverMod.onAnimationChanged(animationChanged);
	}
	
	@Subscribe
	public void onFakeXpDrop(FakeXpDrop fakeXpDrop)
	{
		if (megaserverMod.isActive())
			megaserverMod.onFakeXpDrop(fakeXpDrop);
	}
	
	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (configChanged.getGroup().contentEquals("jebscape"))
		{
			if (configChanged.getKey().contentEquals("showSelfGhost"))
			{
				if (config.showSelfGhost())
				{
					megaserverMod.showSelfGhost();
				}
				else
				{
					megaserverMod.hideSelfGhost();
				}
			}
			
			if (configChanged.getKey().contentEquals("hideLiveHiscores"))
			{
				if (config.hideLiveHiscores())
				{
					liveHiscoresOverlay.hide();
				}
				else
				{
					liveHiscoresOverlay.show();
				}
			}
			
			if (configChanged.getKey().contentEquals("selectSkillLiveHiscores"))
			{
				megaserverMod.setLiveHiscoresSkillType(config.selectSkillLiveHiscores().ordinal());
			}
			
			if (configChanged.getKey().contentEquals("startRankLiveHiscores"))
			{
				megaserverMod.setLiveHiscoresStartRank(config.startRankLiveHiscores());
			}
		}
	}
	
	public void setAccountKeySalt(int[] pinValues)
	{
		this.accountKeySalt = (long)pinValues[0] << 4;
		this.accountKeySalt |= (long)pinValues[1] << 16;
		this.accountKeySalt |= (long)pinValues[2] << 36;
		this.accountKeySalt |= (long)pinValues[3] << 60;
		
		profilePinOverlay.hide();
		
		clientThread.invokeLater(() ->
		{
			long accountHash = client.getAccountHash();
			boolean foundExistingPair = false;
			for (int i = 0; i < NUM_HASH_SALT_PAIRS; i++)
			{
				if (accountHashSaltPairs[i].accountHash == accountHash)
				{
					this.accountHashSaltPairs[i].accountKeySalt = accountKeySalt;
					this.accountHashSaltPairIndex = i;
					foundExistingPair = true;
					break;
				}
			}
			
			if (!foundExistingPair)
			{
				this.accountHashSaltPairIndex = (accountHashSaltPairIndex + 1) % NUM_HASH_SALT_PAIRS;
				this.accountHashSaltPairs[accountHashSaltPairIndex].accountHash = accountHash;
				this.accountHashSaltPairs[accountHashSaltPairIndex].accountKeySalt = accountKeySalt;
			}
			
			ChatMessageBuilder message;
			if (replaceAccountKeySalt)
			{
				this.replaceAccountKeySalt = false;
				if (chatAccountKey != 0)
				{
					configManager.setRSProfileConfiguration("JebScape", "Key", chatAccountKey ^ client.getAccountHash() ^ accountKeySalt);
				
					if (accountKeySalt == 0)
					{
						message = new ChatMessageBuilder();
						message.append(ChatColorType.HIGHLIGHT).append("Your JebScape PIN has been removed.");
						chatMessageManager.queue(QueuedMessage.builder()
								.type(ChatMessageType.GAMEMESSAGE)
								.runeLiteFormattedMessage(message.build().replaceAll("colHIGHLIGHT", "col=02f502"))
								.build());
						
						message = new ChatMessageBuilder();
						message.append(ChatColorType.NORMAL).append("Click here to create a PIN to secure the JebScape login credentials stored within your RuneLite profile.");
						chatMessageManager.queue(QueuedMessage.builder()
								.type(ChatMessageType.WELCOME)
								.runeLiteFormattedMessage(message.build())
								.build());
					}
					else
					{
						message = new ChatMessageBuilder();
						message.append(ChatColorType.HIGHLIGHT).append("Your new JebScape PIN has been created. It will apply to all JebScape accounts linked to your RuneLite profile.");
						chatMessageManager.queue(QueuedMessage.builder()
								.type(ChatMessageType.GAMEMESSAGE)
								.runeLiteFormattedMessage(message.build().replaceAll("colHIGHLIGHT", "col=02f502"))
								.build());
						
						message = new ChatMessageBuilder();
						message.append(ChatColorType.NORMAL).append("Click here if you would like to change your JebScape PIN.");
						chatMessageManager.queue(QueuedMessage.builder()
								.type(ChatMessageType.WELCOME)
								.runeLiteFormattedMessage(message.build())
								.build());
					}
				}
				else
				{
					message = new ChatMessageBuilder();
					message.append(ChatColorType.HIGHLIGHT).append("Error setting PIN. Please report this bug in the JebScape Discord server.");
					chatMessageManager.queue(QueuedMessage.builder()
							.type(ChatMessageType.GAMEMESSAGE)
							.runeLiteFormattedMessage(message.build().replaceAll("colHIGHLIGHT", "col=f50202"))
							.build());
				}
			}
			else
			{
				message = new ChatMessageBuilder();
				message.append(ChatColorType.NORMAL).append("Attempting to log in...");
				chatMessageManager.queue(QueuedMessage.builder()
						.type(ChatMessageType.WELCOME)
						.runeLiteFormattedMessage(message.build())
						.build());
				
				server.logout();
				megaserverMod.resetPost200mXpAccumulators();
				megaserverMod.stop();
			}
		});
	}
	
	public boolean getUseAccountKey()
	{
		return useAccountKey;
	}
	
	public void addGameMessage(String message)
	{
		clientThread.invokeLater(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, null));
	}
	
	@Subscribe
	// onGameTick() only runs upon completion of Jagex server packet processing
	public void onGameTick(GameTick gameTick)
	{
		if (!useMegaserverMod && megaserverMod.isActive())
		{
			server.logout();
			megaserverMod.resetPost200mXpAccumulators();
			megaserverMod.stop();
		}
		
		// don't tick anything if not logged into OSRS
		if (useMegaserverMod && (client.getGameState() == GameState.LOGGED_IN || client.getGameState() == GameState.LOADING))
		{
			boolean prevChatLoginStatus = server.isChatLoggedIn();
			RuneScapeProfileType rsProfileType = RuneScapeProfileType.getCurrent(client);
			
			if (!server.isChatLoggedIn())
			{
				long accountHash = client.getAccountHash();
				for (int i = 0; i < NUM_HASH_SALT_PAIRS; i++)
				{
					if (accountHashSaltPairs[i].accountHash == accountHash)
					{
						this.accountKeySalt = accountHashSaltPairs[i].accountKeySalt;
						this.accountHashSaltPairIndex = i;
						break;
					}
				}

				// clear out any obsolete keys players might still have lying around
				//configManager.unsetRSProfileConfiguration("JebScape", "KeyGame"); // TODO: uncomment this at a later date
				configManager.unsetRSProfileConfiguration("JebScape", "JebScapeAccountKey");
				configManager.unsetRSProfileConfiguration("JebScape", "AccountKeyGame");
				configManager.unsetRSProfileConfiguration("JebScape", "AccountKey");

				String keyConfig = configManager.getRSProfileConfiguration("JebScape", "Key");
				if (keyConfig != null)
				{
					Long key = Long.parseLong(keyConfig);
					if (key != null)
					{
						this.chatAccountKey = accountKeySalt ^ client.getAccountHash() ^ key;
					}
					else
					{
						this.chatAccountKey = 0;
					}
				}
				else
				{
					this.chatAccountKey = 0;
				}
			}
			
			// only log in whilst using standard profile to avoid cross-contamination of stats
			this.useAccountKey = rsProfileType == RuneScapeProfileType.STANDARD;
			
			// TODO: Consider processing received data from the JebScape server at a faster pace using onClientTick()
			server.onGameTick();

			if (!server.isChatLoggedIn())
			{
				// we want to clean up if no longer logged in
				if (megaserverMod.isActive())
				{
					megaserverMod.stop();
				}

				// since chat server isn't yet connected, we shouldn't be receiving any data
				liveHiscoresOverlay.setContainsData(false);
				
				// whether we disconnected or just haven't started yet, this should be reset
				megaserverMod.resetPost200mXpAccumulators();

				if (loginTimeout <= 0)
				{
					// log in as a guest
					server.login(client.getAccountHash(), chatAccountKey, useAccountKey, Text.sanitize(client.getLocalPlayer().getName()));
					loginTimeout = 4; // wait 4 ticks before attempting to log in again
				}
				else
				{
					// if we just attempted to log in recently, let's wait a bit
					--loginTimeout;
				}
			}
			else if (client.getAccountHash() == server.getAccountHash())
			{
				int gameDataBytesSent = 0;
				
				// we're logged in, let's play!
				if (!megaserverMod.isActive())
					megaserverMod.start();
				
				gameDataBytesSent += megaserverMod.onGameTick();

				ChatMessageBuilder message;
				if (server.isChatLoggedIn() && !prevChatLoginStatus)
				{
					// send a chat message if we've just logged in
					message = new ChatMessageBuilder();
					message.append(ChatColorType.NORMAL).append("Welcome to JebScape! There are currently " + server.getChatNumOnlinePlayers() + " players online.");
					chatMessageManager.queue(QueuedMessage.builder()
							.type(ChatMessageType.WELCOME)
							.runeLiteFormattedMessage(message.build())
							.build());

					// the chat key is what matters the most right now, so let's prioritize it
					boolean chatLoggedInAsGuest = server.isChatGuest();
					if (useAccountKey)
					{
						if (chatAccountKey != server.getChatAccountKey() || chatAccountKey == 0)
						{
							if (chatAccountKey == 0)
							{
								if (!chatLoggedInAsGuest)
								{
									message = new ChatMessageBuilder();
									message.append(ChatColorType.HIGHLIGHT).append("Your new JebScape account has been automatically created and linked to your OSRS account and RuneLite profile.");
									chatMessageManager.queue(QueuedMessage.builder()
											.type(ChatMessageType.GAMEMESSAGE)
											.runeLiteFormattedMessage(message.build().replaceAll("colHIGHLIGHT", "col=02f502"))
											.build());
									
									this.accountKeySalt = 0;
									this.chatAccountKey = server.getChatAccountKey();
									this.loginAttempts = 0;
									if (chatAccountKey != 0)
									{
										configManager.setRSProfileConfiguration("JebScape", "Key", chatAccountKey ^ client.getAccountHash() ^ accountKeySalt);
									}
									
									message = new ChatMessageBuilder();
									message.append(ChatColorType.HIGHLIGHT).append("Click here to create a PIN to secure the JebScape login credentials stored within your RuneLite profile.");
									chatMessageManager.queue(QueuedMessage.builder()
											.type(ChatMessageType.GAMEMESSAGE)
											.runeLiteFormattedMessage(message.build().replaceAll("colHIGHLIGHT", "col=d4f502"))
											.build());
								}
								else
								{
									message = new ChatMessageBuilder();
									message.append(ChatColorType.HIGHLIGHT).append("You are logged in as a guest. Only one account may be created per day.");
									chatMessageManager.queue(QueuedMessage.builder()
											.type(ChatMessageType.GAMEMESSAGE)
											.runeLiteFormattedMessage(message.build().replaceAll("colHIGHLIGHT", "col=d4f502"))
											.build());
									this.useAccountKey = false;
								}
							}
							else if (loginAttempts == 0)
							{
								// The initial key sent was not valid; an incorrect PIN was tried, so let's get the user to enter in their PIN
								message = new ChatMessageBuilder();
								message.append(ChatColorType.HIGHLIGHT).append("You are logged in as a guest. Enter your PIN to fully log into your JebScape account.");
								chatMessageManager.queue(QueuedMessage.builder()
										.type(ChatMessageType.GAMEMESSAGE)
										.runeLiteFormattedMessage(message.build().replaceAll("colHIGHLIGHT", "col=d4f502"))
										.build());
								
								profilePinOverlay.show();
								this.loginAttempts++;
							}
							else if (loginAttempts < 4)
							{
								// Attempted to log in with PIN but failed
								message = new ChatMessageBuilder();
								message.append(ChatColorType.HIGHLIGHT).append("Login failed. Try again. You are logged in as a guest. Enter your PIN to fully log into your JebScape account.");
								chatMessageManager.queue(QueuedMessage.builder()
										.type(ChatMessageType.GAMEMESSAGE)
										.runeLiteFormattedMessage(message.build().replaceAll("colHIGHLIGHT", "col=d4f502"))
										.build());
								
								profilePinOverlay.show();
								this.loginAttempts++;
							}
							else
							{
								// Too many failed attempts. Give up for now.
								message = new ChatMessageBuilder();
								message.append(ChatColorType.HIGHLIGHT).append("Login attempts exhausted. Try again later. You will remain logged in as a guest.");
								chatMessageManager.queue(QueuedMessage.builder()
										.type(ChatMessageType.GAMEMESSAGE)
										.runeLiteFormattedMessage(message.build().replaceAll("colHIGHLIGHT", "col=d4f502"))
										.build());
							}
						}
						else
						{
							message = new ChatMessageBuilder();
							message.append(ChatColorType.HIGHLIGHT).append("You successfully logged into your JebScape account.");
							chatMessageManager.queue(QueuedMessage.builder()
									.type(ChatMessageType.GAMEMESSAGE)
									.runeLiteFormattedMessage(message.build().replaceAll("colHIGHLIGHT", "col=02f502"))
									.build());
							
							this.loginAttempts = 0;
							
							if (accountKeySalt == 0)
							{
								message = new ChatMessageBuilder();
								message.append(ChatColorType.HIGHLIGHT).append("Click here to create a PIN to secure the JebScape login credentials stored within your RuneLite profile.");
								chatMessageManager.queue(QueuedMessage.builder()
										.type(ChatMessageType.GAMEMESSAGE)
										.runeLiteFormattedMessage(message.build().replaceAll("colHIGHLIGHT", "col=d4f502"))
										.build());
							}
							else
							{
								message = new ChatMessageBuilder();
								message.append(ChatColorType.NORMAL).append("Click here if you would like to change your JebScape PIN.");
								chatMessageManager.queue(QueuedMessage.builder()
										.type(ChatMessageType.WELCOME)
										.runeLiteFormattedMessage(message.build())
										.build());
							}
						}
					}
					else if (chatLoggedInAsGuest)
					{
						message = new ChatMessageBuilder();
						message.append(ChatColorType.HIGHLIGHT).append("You are logged in as a guest. Account login requires a standard world.");
						chatMessageManager.queue(QueuedMessage.builder()
								.type(ChatMessageType.GAMEMESSAGE)
								.runeLiteFormattedMessage(message.build().replaceAll("colHIGHLIGHT", "col=d4f502"))
								.build());
					}
				}
				
				Widget chatWidget = client.getWidget(ComponentID.CHATBOX_MESSAGE_LINES);
				if (chatWidget != null && !server.isChatGuest())
				{
					// TODO: Can we make this only run only when each new message is added instead of every game tick?
					if (accountKeySalt == 0)
					{
						for (Widget w: chatWidget.getDynamicChildren())
						{
							if (Text.removeTags(w.getText()).contains("Click here to create a PIN to secure the JebScape login credentials stored within your RuneLite profile."))
							{
								clientThread.invokeLater(() -> {
									w.setAction(1, "Create new JebScape PIN");
									w.setOnOpListener((JavaScriptCallback) this::clickSetNewProfilePin);
									w.setHasListener(true);
									w.setNoClickThrough(true);
									w.revalidate();
								});
							}
							else
							{
								clientThread.invokeLater(() -> {
									w.setHasListener(false);
									w.setNoClickThrough(false);
									w.revalidate();
								});
							}
						}
					}
					else
					{
						for (Widget w: chatWidget.getDynamicChildren())
						{
							if (Text.removeTags(w.getText()).contains("Click here if you would like to change your JebScape PIN.") )
							{
								clientThread.invokeLater(() -> {
									w.setAction(1, "Set New JebScape PIN");
									w.setOnOpListener((JavaScriptCallback) this::clickSetNewProfilePin);
									w.setHasListener(true);
									w.setNoClickThrough(true);
									w.revalidate();
								});
							}
							else
							{
								clientThread.invokeLater(() -> {
									w.setHasListener(false);
									w.setNoClickThrough(false);
									w.revalidate();
								});
							}
						}
					}
				}
			}
		}
	}
	
	protected void clickSetNewProfilePin(ScriptEvent ev)
	{
		this.replaceAccountKeySalt = true;
		profilePinOverlay.show();
	}
	
	@Subscribe
	public void onClientTick(ClientTick clientTick)
	{
		megaserverMod.onClientTick(clientTick);
	}
	
	@Provides
	JebScapeConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(JebScapeConfig.class);
	}
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import lombok.Data;

@Data
public class RuneLiteKitDefinition
{
	private final int id;
	public short[] recolorToReplace;
	public short[] recolorToFind;
	public short[] retextureToFind;
	public short[] retextureToReplace;
	public int bodyPartId = -1;
	public int[] models;
	public int[] chatheadModels = new int[]
			{
					-1, -1, -1, -1, -1
			};
	public boolean nonSelectable = false;
}
/*
 * Copyright (c) 2023, Justin Ead (Jebrim) <jebscapeplugin@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import java.net.*;
import java.nio.channels.*;
import java.nio.charset.*;

public class JebScapeConnection
{
	private DatagramChannel chatChannel;
	private InetSocketAddress chatAddress;

	private boolean isChatLoggedIn;
	// ticks are tracked as a cyclic value between 0 and TICKS_UNTIL_LOGOUT
	private int currentChatTick; // value representing the current tick the client thinks we should be on
	private int lastReceivedChatTick; // value representing the latest tick we've received from the server
	public static final int TICKS_UNTIL_LOGOUT = 16;
	public static final int CHAT_SERVER_PACKETS_PER_TICK = 4;
	private long accountHash;
	private long chatAccountKey;
	private boolean isChatUsingKey;
	private static final byte[] EMPTY_BYTES = new byte[96];
	private int chatSessionID = -1;
	private int chatServerPacketsReceived = 0x0000; // 1 bit per server packet
	private int chatNumOnlinePlayers = 0;
	
	private static final int PROTOCOL_VERSION = 4;
	private static final int EMPTY_PACKET = 0x0;
	private static final int LOGIN_PACKET = 0x1;
	private static final int GAME_PACKET = 0x2;
	private static final int CHAT_PACKET = 0x3;

	private static final int CHAT_CLIENT_PACKET_SIZE = 144;
	private static final int CHAT_SERVER_PACKET_SIZE = 544;

	private JebScapePacket chatClientPacket = new JebScapePacket();
	private JebScapePacket chatServerPacket = new JebScapePacket();
	private JebScapeServerData[][] chatServerData = new JebScapeServerData[TICKS_UNTIL_LOGOUT][CHAT_SERVER_PACKETS_PER_TICK];
	private int[] numChatServerPacketsSent = new int[TICKS_UNTIL_LOGOUT];
	
	public void init() throws Exception
	{
		chatAddress = new InetSocketAddress("chat.jebscape.com", 43597);
		
		// local test server connection
		//chatAddress = new InetSocketAddress("192.168.1.148", 43597);

		chatChannel = DatagramChannel.open(StandardProtocolFamily.INET);
		chatChannel.configureBlocking(false);
		chatChannel.bind(null);

		isChatLoggedIn = false;

		chatClientPacket.init(CHAT_CLIENT_PACKET_SIZE);

		chatServerPacket.init(CHAT_SERVER_PACKET_SIZE);
		chatServerPacket.erase();

		for (int i = 0; i < TICKS_UNTIL_LOGOUT; i++)
			for (int j = 0; j < CHAT_SERVER_PACKETS_PER_TICK; j++)
				chatServerData[i][j] = new JebScapeServerData();
	}
	
	public boolean connect()
	{
		boolean connected;
		
		try
		{
			if (!chatChannel.isConnected())
				chatChannel.connect(chatAddress);
			
			// we don't care as much if the game server cannot connect, so let's proceed regardless
			connected = chatChannel.isConnected();
		}
		catch (Exception e)
		{
			connected = false;
		}
		
		return connected;
	}
	
	public void disconnect()
	{
		isChatLoggedIn = false;
		chatSessionID = -1;
		
		try
		{
			if (chatChannel.isConnected())
				chatChannel.disconnect();
		}
		catch (Exception e)
		{}
	}

	public boolean isChatLoggedIn()
	{
		return chatChannel.isConnected() && isChatLoggedIn;
	}
	
	public boolean login(long accountHash, long chatAccountKey, boolean useKey, String accountName)
	{
		if (!chatChannel.isConnected())
			connect();
			
		if (!chatChannel.isConnected() || accountName.length() > 12)
			return false;
		
		this.accountHash = accountHash; // 8 bytes
		
		boolean success = false;

		if (!isChatLoggedIn)
		{
			this.chatAccountKey = chatAccountKey; // 8 bytes
			this.isChatUsingKey = useKey;
			chatServerPacketsReceived = 0xFFFF;
			
			// set the header
			// 2 bits login identifier
			// 17 bits last known game session id
			// 1 bit isUsingKey (if false, will log in as guest only)
			// 8 bits protocol version
			// 4 bits reserved
			int loginPacketHeader = LOGIN_PACKET & 0x3;					// 2/32 bits
			loginPacketHeader |= (chatSessionID & 0x1FFFF) << 2;		// 19/32 bits
			loginPacketHeader |= (isChatUsingKey ? 0x1 : 0x0) << 19;	// 20/32 bits
			loginPacketHeader |= (PROTOCOL_VERSION & 0xFF) << 20;		// 28/32 bits
			loginPacketHeader |= 0xF << 28;								// 32/32 bits
			
			byte[] nameBytes = accountName.getBytes(StandardCharsets.UTF_8);
			int strLen = accountName.length();
			long reserved = 0xFFFFFFFFFFFFFFFFL;
			
			try
			{
				chatClientPacket.buffer.clear();
				chatClientPacket.buffer.putInt(loginPacketHeader);								// 4/144 bytes
				chatClientPacket.buffer.putLong(accountHash);									// 12/144 bytes
				chatClientPacket.buffer.putLong(chatAccountKey);								// 20/144 bytes
				chatClientPacket.buffer.put(nameBytes, 0, strLen);						// up to 32/144 bytes
				if (strLen < 12)
					chatClientPacket.buffer.put(EMPTY_BYTES, 0, 12 - strLen);		// 32/144 bytes
				chatClientPacket.buffer.putLong(reserved);										// 40/144 bytes
				chatClientPacket.buffer.putLong(reserved);										// 48/144 bytes
				chatClientPacket.buffer.putLong(reserved);										// 56/144 bytes
				chatClientPacket.buffer.putLong(reserved);										// 64/144 bytes
				chatClientPacket.buffer.putLong(reserved);										// 72/144 bytes
				chatClientPacket.buffer.putLong(reserved);										// 80/144 bytes
				chatClientPacket.buffer.putLong(reserved);										// 88/144 bytes
				chatClientPacket.buffer.putLong(reserved);										// 96/144 bytes
				chatClientPacket.buffer.putLong(reserved);										// 104/144 bytes
				chatClientPacket.buffer.putLong(reserved);										// 112/144 bytes
				chatClientPacket.buffer.putLong(reserved);										// 120/144 bytes
				chatClientPacket.buffer.putLong(reserved);										// 128/144 bytes
				chatClientPacket.buffer.putLong(reserved);										// 136/144 bytes
				chatClientPacket.buffer.putLong(reserved);										// 144/144 bytes
				chatClientPacket.buffer.rewind();
				
				success = chatChannel.write(chatClientPacket.buffer) == CHAT_CLIENT_PACKET_SIZE;
			}
			catch (Exception e)
			{
				try
				{
					chatChannel = DatagramChannel.open(StandardProtocolFamily.INET);
					chatChannel.configureBlocking(false);
					chatChannel.bind(null);
					chatChannel.connect(chatAddress);
					success = chatChannel.write(chatClientPacket.buffer) == CHAT_CLIENT_PACKET_SIZE;
				}
				catch (Exception exception)
				{
					return false;
				}
			}
		}
		
		return success;
	}
	
	public void logout()
	{
		isChatLoggedIn = false;
		currentChatTick = 0;
		lastReceivedChatTick = 0;
		chatSessionID = -1;
		chatNumOnlinePlayers = 0;
	}
	
	public long getAccountHash()
	{
		return accountHash;
	}
	
	public long getChatAccountKey() { return chatAccountKey; }
	
	public boolean isChatGuest()
	{
		return isChatLoggedIn && !isChatUsingKey;
	}
	
	// returns data on all packets received in this tick, but may include late packets from previous ticks
	// start processing from one after lastReceivedChatTick until one wraps around back to lastReceivedChatTick
	public JebScapeServerData[][] getRecentChatServerData()
	{
		return chatServerData;
	}

	public int[] getNumChatServerPacketsSent()
	{
		return numChatServerPacketsSent;
	}

	public int getLastReceivedChatTick()
	{
		return lastReceivedChatTick;
	}

	public int getCurrentChatTick()
	{
		return currentChatTick;
	}

	public int getChatNumOnlinePlayers()
	{
		return chatNumOnlinePlayers;
	}
	
	// must be 3 ints (12 bytes); extraChatData is limited to size of 96 bytes (24 ints)
	public boolean sendGameData(int[] coreData, int[] gameSubData, byte[] extraChatData)
	{
		if (!chatChannel.isConnected())
			return false;
		
		long reserved = 0xFFFFFFFFFFFFFFFFL;
		int bytesWritten = 0;

		if (isChatLoggedIn)
		{
			// set the header
			// 2 bits chat identifier
			// 17 bits last known chat session id
			// 1 bit isUsingKey
			// 4 bits current tick
			// 8 bits reserved
			int packetHeader = CHAT_PACKET & 0x3;				// 2/32 bits
			packetHeader |= (chatSessionID & 0x1FFFF) << 2;		// 19/32 bits
			packetHeader |= (isChatUsingKey ? 0x1 : 0x0) << 19;	// 20/32 bits
			packetHeader |= (currentChatTick & 0xF) << 20;		// 24/32 bits
			packetHeader |= 0xFF << 24;							// 32/32 bits
			
			int bytesLength = extraChatData.length;
			// cut it short if too long
			if (bytesLength > 96)
				bytesLength = 96;
			
			try
			{
				chatClientPacket.buffer.clear();
				chatClientPacket.buffer.putInt(packetHeader);									// 4/144 bytes
				chatClientPacket.buffer.putLong(accountHash);									// 12/144 bytes
				chatClientPacket.buffer.putLong(chatAccountKey);								// 20/144 bytes
				chatClientPacket.buffer.putInt(coreData[0]);									// 24/144 bytes
				chatClientPacket.buffer.putInt(coreData[1]);									// 28/144 bytes
				chatClientPacket.buffer.putInt(coreData[2]);									// 32/144 bytes
				chatClientPacket.buffer.putInt(gameSubData[0]);									// 36/144 bytes
				chatClientPacket.buffer.putInt(gameSubData[1]);									// 42/144 bytes
				chatClientPacket.buffer.putInt(gameSubData[2]);									// 48/144 bytes
				chatClientPacket.buffer.putInt(gameSubData[3]);									// 54/144 bytes
				if (bytesLength > 0)
					chatClientPacket.buffer.put(extraChatData, 0, bytesLength);			// up to 144/144 bytes
				if (bytesLength < 96)
					chatClientPacket.buffer.put(EMPTY_BYTES, 0, 96 - bytesLength);	// 144/144 bytes
				chatClientPacket.buffer.rewind();
				
				bytesWritten += chatChannel.write(chatClientPacket.buffer);
			}
			catch (Exception e)
			{
				try
				{
					chatChannel = DatagramChannel.open(StandardProtocolFamily.INET);
					chatChannel.configureBlocking(false);
					chatChannel.bind(null);
					chatChannel.connect(chatAddress);
					bytesWritten += chatChannel.write(chatClientPacket.buffer);
				}
				catch (Exception exception)
				{
					return false;
				}
			}
		}
		
		return bytesWritten == (CHAT_CLIENT_PACKET_SIZE);
	}
	
	public void onGameTick()
	{
		if (!chatChannel.isConnected())
			return;
		
		// start from scratch on the data we're working with
		for (int i = 0; i < TICKS_UNTIL_LOGOUT; i++)
		{
			numChatServerPacketsSent[i] = 0;
			for (int j = 0; j < CHAT_SERVER_PACKETS_PER_TICK; j++)
				chatServerData[i][j].clear();
		}

		try
		{
			// let's look into what server communications we've received...
			int bytesReceived;
			do
			{
				chatServerPacket.erase();
				chatServerPacket.buffer.clear();
				bytesReceived = chatChannel.read(chatServerPacket.buffer);
				chatServerPacket.buffer.rewind();
				
				if (bytesReceived == CHAT_SERVER_PACKET_SIZE)
				{
					int packetHeader = chatServerPacket.buffer.getInt();
					
					// validate packet header (similar schema as game packet)
					// 2 bits type identifier
					// 17 bits session id
					// 1 bit isUsingKey; logged in (0) as guest w/o key or (1) as secured account w/ key
					// 4 bits current tick
					// 4 bits number of packets sent this tick
					// 4 bits packet id
					int newPacketType = packetHeader & 0x3;							// 2/32 bits
					int newSessionID = (packetHeader >>> 2) & 0x1FFFF;				// 19/32 bits
					boolean newIsUsingKey = ((packetHeader >>> 19) & 0x1) == 0x1;	// 20/32 bits
					int newTick = (packetHeader >>> 20) & 0xF;						// 24/32 bits
					int newNumPacketsSent = (packetHeader >>> 24) & 0xF;			// 28/32 bits
					int newPacketID = (packetHeader >>> 28) & 0xF;					// 32/32 bits
					
					if (newPacketType == LOGIN_PACKET)
					{
						long newKey = chatServerPacket.buffer.getLong();
						int version = chatServerPacket.buffer.getInt();
						
						if (version == PROTOCOL_VERSION)
						{
							// we've received an ACK from the server for our login request
							if (!isChatLoggedIn)
							{
								// place the initial tick timing info here to serve as a baseline
								this.currentChatTick = newTick;
								this.lastReceivedChatTick = newTick;
							}
							
							this.isChatLoggedIn = true;
							this.isChatUsingKey = newIsUsingKey; // if we made a request to log in with a key that was denied, it may allow us in as a guest anyway
							this.chatAccountKey = newIsUsingKey ? newKey : 0;
							this.chatSessionID = newSessionID;
							this.chatNumOnlinePlayers = chatServerPacket.buffer.getInt((26 * JebScapeServerData.DATA_BLOCK_SIZE + 3) * 4);
						}
					}
					
					if (isChatLoggedIn && newPacketType == CHAT_PACKET && chatSessionID == newSessionID)
					{
						// place the latest tick info here
						chatServerData[newTick][newPacketID].setData(chatServerPacket);
						numChatServerPacketsSent[newTick] = newNumPacketsSent + 1; // we store in the range of 0-15 to represent 1-16
					}
				}
			} while (bytesReceived > 0);
		}
		catch (Exception e)
		{
			// not really sure what we want to do here...
		}

		if (isChatLoggedIn)
		{
			int prevReceivedChatTick = lastReceivedChatTick;
			
			// let's analyze the packets we've received to identify the most recent chat tick received
			for (int i = 0; i < TICKS_UNTIL_LOGOUT; i++)
			{
				// start at the last received tick and move forward from there
				// we include it in case some late packets arrive
				int tick = (prevReceivedChatTick + i) % TICKS_UNTIL_LOGOUT;
				if (numChatServerPacketsSent[tick] > 0)
				{
					this.currentChatTick = tick;
					this.lastReceivedChatTick = tick;
				}
			}

			// let's analyze what packets are missing from the most recent chat tick received
			// TODO: not currently used; reanalyze to determine if this is necessary
			this.chatServerPacketsReceived = 0;
			if (numChatServerPacketsSent[lastReceivedChatTick] > 0)
				for (int packetID = 0; packetID < CHAT_SERVER_PACKETS_PER_TICK; packetID++)
					this.chatServerPacketsReceived = (!chatServerData[lastReceivedChatTick][packetID].isEmpty() ? 0x1 : 0x0) << packetID;

			// increment current tick to prepare for the next payload
			// the gap between currentGameTick and lastReceivedGameTick shall grow if no packets are received
			this.currentChatTick = (currentChatTick + 1) % TICKS_UNTIL_LOGOUT;
			
			// if we've cycled around back to the beginning, we've timed out
			if (currentChatTick == lastReceivedChatTick)
				logout();
		}
	}
}

/*
 * Copyright (c) 2018, Jordan Atwood <jordan.atwood423@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.ArrayList;
import javax.annotation.Nonnull;
import lombok.Getter;
import net.runelite.client.util.Text;
import net.runelite.client.ui.overlay.components.*;

public class RuneLiteTableComponent implements LayoutableRenderableEntity
{
	public enum TableAlignment
	{
		LEFT,
		CENTER,
		RIGHT
	}
	
	@Getter
	private final Rectangle bounds = new Rectangle();
	
	private ArrayList<String[]> cells = new ArrayList<>();
	private TableAlignment[] columnAlignments;
	private Color[] columnColors;
	private int numCols;
	private int numRows;
	
	private TableAlignment defaultAlignment = TableAlignment.LEFT;
	private Color defaultColor = Color.WHITE;
	private Dimension gutter = new Dimension(3, 0);
	private Point preferredLocation = new Point();
	private Dimension preferredSize = new Dimension(ComponentConstants.STANDARD_WIDTH, 0);
	
	@Override
	public Dimension render(final Graphics2D graphics)
	{
		final FontMetrics metrics = graphics.getFontMetrics();
		final int[] columnWidths = getColumnWidths(metrics);
		int height = 0;
		
		graphics.translate(preferredLocation.x, preferredLocation.y);
		
		for (int row = 0; row < numRows; row++)
		{
			int x = 0;
			int startingRowHeight = height;
			for (int col = 0; col < numCols; col++)
			{
				int y = startingRowHeight;
				final String[] lines = lineBreakText(getCellText(col, row), columnWidths[col], metrics);
				for (String line : lines)
				{
					final int alignmentOffset = getAlignedPosition(line, getColumnAlignment(col), columnWidths[col], metrics);
					final TextComponent leftLineComponent = new TextComponent();
					y += metrics.getHeight();
					
					leftLineComponent.setPosition(new Point(x + alignmentOffset, y));
					leftLineComponent.setText(line);
					leftLineComponent.setColor(getColumnColor(col));
					leftLineComponent.render(graphics);
				}
				height = Math.max(height, y);
				x += columnWidths[col] + gutter.width;
			}
			height += gutter.height;
		}
		
		graphics.translate(-preferredLocation.x, -preferredLocation.y);
		final Dimension dimension = new Dimension(preferredSize.width, height);
		bounds.setLocation(preferredLocation);
		bounds.setSize(dimension);
		return dimension;
	}
	
	@Override
	public void setPreferredLocation(@Nonnull final Point location)
	{
		this.preferredLocation = location;
	}
	
	@Override
	public void setPreferredSize(@Nonnull final Dimension size)
	{
		this.preferredSize = size;
	}
	
	public void setDefaultColor(@Nonnull final Color color)
	{
		this.defaultColor = color;
	}
	
	public void setDefaultAlignment(@Nonnull final TableAlignment alignment)
	{
		this.defaultAlignment = alignment;
	}
	
	public void setGutter(@Nonnull final Dimension gutter)
	{
		this.gutter = gutter;
	}
	
	public void setColumnColors(@Nonnull Color... colors)
	{
		columnColors = colors;
	}
	
	public void setColumnAlignments(@Nonnull TableAlignment... alignments)
	{
		columnAlignments = alignments;
	}
	
	public void setColumnColor(final int col, final Color color)
	{
		assert columnColors.length > col;
		columnColors[col] = color;
	}
	
	public void setColumnAlignment(final int col, final TableAlignment alignment)
	{
		assert columnAlignments.length > col;
		columnAlignments[col] = alignment;
	}
	
	public void addRow(@Nonnull final String... cells)
	{
		numCols = Math.max(numCols, cells.length);
		numRows++;
		this.cells.add(cells);
	}
	
	public void addRows(@Nonnull final String[]... rows)
	{
		for (String[] row : rows)
		{
			addRow(row);
		}
	}
	
	private Color getColumnColor(final int column)
	{
		if (columnColors == null
				|| columnColors.length <= column
				|| columnColors[column] == null)
		{
			return defaultColor;
		}
		return columnColors[column];
	}
	
	private TableAlignment getColumnAlignment(final int column)
	{
		if (columnAlignments == null
				|| columnAlignments.length <= column
				|| columnAlignments[column] == null)
		{
			return defaultAlignment;
		}
		return columnAlignments[column];
	}
	
	private String getCellText(final int col, final int row)
	{
		assert col < numCols && row < numRows;
		
		if (cells.get(row).length < col)
		{
			return "";
		}
		return cells.get(row)[col];
	}
	
	private int[] getColumnWidths(final FontMetrics metrics)
	{
		// Based on https://stackoverflow.com/questions/22206825/algorithm-for-calculating-variable-column-widths-for-set-table-width
		int[] maxtextw = new int[numCols];      // max text width over all rows
		int[] maxwordw = new int[numCols];      // max width of longest word
		boolean[] flex = new boolean[numCols];  // is column flexible?
		boolean[] wrap = new boolean[numCols];  // can column be wrapped?
		int[] finalcolw = new int[numCols];     // final width of columns
		
		for (int col = 0; col < numCols; col++)
		{
			for (int row = 0; row < numRows; row++)
			{
				final String cell = getCellText(col, row);
				final int cellWidth = getTextWidth(metrics, cell);
				
				maxtextw[col] = Math.max(maxtextw[col], cellWidth);
				for (String word : cell.split(" "))
				{
					maxwordw[col] = Math.max(maxwordw[col], getTextWidth(metrics, word));
				}
				
				if (maxtextw[col] == cellWidth)
				{
					wrap[col] = cell.contains(" ");
				}
			}
		}
		
		int left = preferredSize.width - (numCols - 1) * gutter.width;
		final double avg = (double) left / numCols;
		int nflex = 0;
		
		// Determine whether columns should be flexible and assign width of non-flexible cells
		for (int col = 0; col < numCols; col++)
		{
			// This limit can be adjusted as needed
			final double maxNonFlexLimit = 1.5 * avg;
			
			flex[col] = maxtextw[col] > maxNonFlexLimit;
			if (flex[col])
			{
				nflex++;
			}
			else
			{
				finalcolw[col] = maxtextw[col];
				left -= finalcolw[col];
			}
		}
		
		// If there is not enough space, make columns that could be word-wrapped flexible too
		if (left < nflex * avg)
		{
			for (int col = 0; col < numCols; col++)
			{
				if (!flex[col] && wrap[col])
				{
					left += finalcolw[col];
					finalcolw[col] = 0;
					flex[col] = true;
					nflex++;
				}
			}
		}
		
		// Calculate weights for flexible columns. The max width is capped at the table width to
		// treat columns that have to be wrapped more or less equal
		int tot = 0;
		for (int col = 0; col < numCols; col++)
		{
			if (flex[col])
			{
				maxtextw[col] = Math.min(maxtextw[col], preferredSize.width);
				tot += maxtextw[col];
			}
		}
		
		// Now assign the actual width for flexible columns. Make sure that it is at least as long
		// as the longest word length
		for (int col = 0; col < numCols; col++)
		{
			if (flex[col])
			{
				finalcolw[col] = left * maxtextw[col] / tot;
				finalcolw[col] = Math.max(finalcolw[col], maxwordw[col]);
				left -= finalcolw[col];
			}
		}
		
		// When the sum of column widths is less than the total space available, distribute the
		// extra space equally across all columns
		final int extraPerCol = left / numCols;
		for (int col = 0; col < numCols; col++)
		{
			finalcolw[col] += extraPerCol;
			left -= extraPerCol;
		}
		// Add any remainder to the right-most column
		finalcolw[finalcolw.length - 1] += left;
		
		return finalcolw;
	}
	
	private static int getTextWidth(final FontMetrics metrics, final String cell)
	{
		return metrics.stringWidth(Text.removeTags(cell));
	}
	
	private static String[] lineBreakText(final String text, final int maxWidth, final FontMetrics metrics)
	{
		final String[] words = text.split(" ");
		
		if (words.length == 0)
		{
			return new String[0];
		}
		
		final StringBuilder wrapped = new StringBuilder(words[0]);
		int spaceLeft = maxWidth - getTextWidth(metrics, wrapped.toString());
		
		for (int i = 1; i < words.length; i++)
		{
			final String word = words[i];
			final int wordLen = getTextWidth(metrics, word);
			final int spaceWidth = metrics.stringWidth(" ");
			
			if (wordLen + spaceWidth > spaceLeft)
			{
				wrapped.append('\n').append(word);
				spaceLeft = maxWidth - wordLen;
			}
			else
			{
				wrapped.append(' ').append(word);
				spaceLeft -= spaceWidth + wordLen;
			}
		}
		
		return wrapped.toString().split("\n");
	}
	
	private static int getAlignedPosition(final String str, final TableAlignment alignment, final int columnWidth, final FontMetrics metrics)
	{
		final int stringWidth = getTextWidth(metrics, str);
		int offset = 0;
		
		switch (alignment)
		{
			case LEFT:
				break;
			case CENTER:
				offset = (columnWidth / 2) - (stringWidth / 2);
				break;
			case RIGHT:
				offset = columnWidth - stringWidth;
				break;
		}
		return offset;
	}
}
/*
 * Copyright (c) 2023, Justin Ead (Jebrim) <jebscapeplugin@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.jebscape.core;

import java.nio.*;

public class JebScapePacket
{
	public ByteBuffer buffer;
	private byte emptyBuffer[];
	
	public void init(int size)
	{
		buffer = ByteBuffer.allocateDirect(size);
		buffer.order(ByteOrder.LITTLE_ENDIAN);
		emptyBuffer = new byte[size];
		erase();
	}
	
	// turns the packet into an empty packet of all 0s
	public void erase()
	{
		buffer.clear();
		buffer.put(emptyBuffer);
		buffer.rewind();
	}
}

/*
 * Copyright (c) 2016-2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.jebscape.core;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;

public class RuneLiteItemLoader
{
	private static final Logger logger = LoggerFactory.getLogger(RuneLiteItemLoader.class);
	
	public RuneLiteItemDefinition load(int id, byte[] b)
	{
		RuneLiteItemDefinition def = new RuneLiteItemDefinition(id);
		RuneLiteInputStream is = new RuneLiteInputStream(b);
		
		while (true)
		{
			int opcode = is.readUnsignedByte();
			if (opcode == 0)
			{
				break;
			}
			
			this.decodeValues(opcode, def, is);
		}
		
		post(def);
		
		return def;
	}
	
	private void decodeValues(int opcode, RuneLiteItemDefinition def, RuneLiteInputStream stream)
	{
		if (opcode == 1)
		{
			def.inventoryModel = stream.readUnsignedShort();
		}
		else if (opcode == 2)
		{
			def.name = stream.readString();
		}
		else if (opcode == 3)
		{
			def.examine = stream.readString();
		}
		else if (opcode == 4)
		{
			def.zoom2d = stream.readUnsignedShort();
		}
		else if (opcode == 5)
		{
			def.xan2d = stream.readUnsignedShort();
		}
		else if (opcode == 6)
		{
			def.yan2d = stream.readUnsignedShort();
		}
		else if (opcode == 7)
		{
			def.xOffset2d = stream.readUnsignedShort();
			if (def.xOffset2d > 32767)
			{
				def.xOffset2d -= 65536;
			}
		}
		else if (opcode == 8)
		{
			def.yOffset2d = stream.readUnsignedShort();
			if (def.yOffset2d > 32767)
			{
				def.yOffset2d -= 65536;
			}
		}
		else if (opcode == 9)
		{
			def.unknown1 = stream.readString();
		}
		else if (opcode == 11)
		{
			def.stackable = 1;
		}
		else if (opcode == 12)
		{
			def.cost = stream.readInt();
		}
		else if (opcode == 13)
		{
			def.wearPos1 = stream.readByte();
		}
		else if (opcode == 14)
		{
			def.wearPos2 = stream.readByte();
		}
		else if (opcode == 16)
		{
			def.members = true;
		}
		else if (opcode == 23)
		{
			def.maleModel0 = stream.readUnsignedShort();
			def.maleOffset = stream.readUnsignedByte();
		}
		else if (opcode == 24)
		{
			def.maleModel1 = stream.readUnsignedShort();
		}
		else if (opcode == 25)
		{
			def.femaleModel0 = stream.readUnsignedShort();
			def.femaleOffset = stream.readUnsignedByte();
		}
		else if (opcode == 26)
		{
			def.femaleModel1 = stream.readUnsignedShort();
		}
		else if (opcode == 27)
		{
			def.wearPos3 = stream.readByte();
		}
		else if (opcode >= 30 && opcode < 35)
		{
			def.options[opcode - 30] = stream.readString();
			if (def.options[opcode - 30].equalsIgnoreCase("Hidden"))
			{
				def.options[opcode - 30] = null;
			}
		}
		else if (opcode >= 35 && opcode < 40)
		{
			def.interfaceOptions[opcode - 35] = stream.readString();
		}
		else if (opcode == 40)
		{
			int var5 = stream.readUnsignedByte();
			def.colorFind = new short[var5];
			def.colorReplace = new short[var5];
			
			for (int var4 = 0; var4 < var5; ++var4)
			{
				def.colorFind[var4] = (short) stream.readUnsignedShort();
				def.colorReplace[var4] = (short) stream.readUnsignedShort();
			}
			
		}
		else if (opcode == 41)
		{
			int var5 = stream.readUnsignedByte();
			def.textureFind = new short[var5];
			def.textureReplace = new short[var5];
			
			for (int var4 = 0; var4 < var5; ++var4)
			{
				def.textureFind[var4] = (short) stream.readUnsignedShort();
				def.textureReplace[var4] = (short) stream.readUnsignedShort();
			}
			
		}
		else if (opcode == 42)
		{
			def.shiftClickDropIndex = stream.readByte();
		}
		else if (opcode == 43)
		{
			int opId = stream.readUnsignedByte();
			if (def.subops == null)
			{
				def.subops = new String[5][];
			}

			boolean valid = opId >= 0 && opId < 5;
			if (valid && def.subops[opId] == null)
			{
				def.subops[opId] = new String[20];
			}

			while (true)
			{
				int subopId = stream.readUnsignedByte() - 1;
				if (subopId == -1)
				{
					break;
				}

				String op = stream.readString();
				if (valid && subopId >= 0 && subopId < 20)
				{
					def.subops[opId][subopId] = op;
				}
			}
		}
		else if (opcode == 65)
		{
			def.isTradeable = true;
		}
		else if (opcode == 75)
		{
			def.weight = stream.readShort();
		}
		else if (opcode == 78)
		{
			def.maleModel2 = stream.readUnsignedShort();
		}
		else if (opcode == 79)
		{
			def.femaleModel2 = stream.readUnsignedShort();
		}
		else if (opcode == 90)
		{
			def.maleHeadModel = stream.readUnsignedShort();
		}
		else if (opcode == 91)
		{
			def.femaleHeadModel = stream.readUnsignedShort();
		}
		else if (opcode == 92)
		{
			def.maleHeadModel2 = stream.readUnsignedShort();
		}
		else if (opcode == 93)
		{
			def.femaleHeadModel2 = stream.readUnsignedShort();
		}
		else if (opcode == 94)
		{
			def.category = stream.readUnsignedShort();
		}
		else if (opcode == 95)
		{
			def.zan2d = stream.readUnsignedShort();
		}
		else if (opcode == 97)
		{
			def.notedID = stream.readUnsignedShort();
		}
		else if (opcode == 98)
		{
			def.notedTemplate = stream.readUnsignedShort();
		}
		else if (opcode >= 100 && opcode < 110)
		{
			if (def.countObj == null)
			{
				def.countObj = new int[10];
				def.countCo = new int[10];
			}
			
			def.countObj[opcode - 100] = stream.readUnsignedShort();
			def.countCo[opcode - 100] = stream.readUnsignedShort();
		}
		else if (opcode == 110)
		{
			def.resizeX = stream.readUnsignedShort();
		}
		else if (opcode == 111)
		{
			def.resizeY = stream.readUnsignedShort();
		}
		else if (opcode == 112)
		{
			def.resizeZ = stream.readUnsignedShort();
		}
		else if (opcode == 113)
		{
			def.ambient = stream.readByte();
		}
		else if (opcode == 114)
		{
			def.contrast = stream.readByte();
		}
		else if (opcode == 115)
		{
			def.team = stream.readUnsignedByte();
		}
		else if (opcode == 139)
		{
			def.boughtId = stream.readUnsignedShort();
		}
		else if (opcode == 140)
		{
			def.boughtTemplateId = stream.readUnsignedShort();
		}
		else if (opcode == 148)
		{
			def.placeholderId = stream.readUnsignedShort();
		}
		else if (opcode == 149)
		{
			def.placeholderTemplateId = stream.readUnsignedShort();
		}
		else if (opcode == 249)
		{
			int length = stream.readUnsignedByte();
			
			def.params = new HashMap<>(length);
			
			for (int i = 0; i < length; i++)
			{
				boolean isString = stream.readUnsignedByte() == 1;
				int key = stream.read24BitInt();
				Object value;
				
				if (isString)
				{
					value = stream.readString();
				}
				
				else
				{
					value = stream.readInt();
				}
				
				def.params.put(key, value);
			}
		}
		else
		{
			logger.warn("Unrecognized opcode {}", opcode);
		}
	}
	
	private void post(RuneLiteItemDefinition def)
	{
		if (def.stackable == 1)
		{
			def.weight = 0;
		}
	}
}
