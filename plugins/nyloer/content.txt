package com.nyloer;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class NyloerTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(NyloerPlugin.class);
		RuneLite.main(args);
	}
}

package com.nyloer;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;


@ConfigGroup(NyloerConfig.GROUP)
public interface NyloerConfig extends Config
{
	String GROUP = "nyloer";

	@ConfigSection(
		name = "General Settings",
		position = 0,
		description = "General settings",
		closedByDefault = false
	)
	String generalSettings = "generalSettings";

	@ConfigItem(
		position = 0,
		keyName = "showNylocasSymbol",
		name = "Show Nylocas Symbol",
		description = "Displays selected symbol instead of wave.",
		section = generalSettings
	)
	default boolean showNylocasSymbol()
	{
		return true;
	}

	@ConfigItem(
		position = 1,
		keyName = "meleeNylocasSymbol",
		name = "Melee Symbol",
		description = "Symbol of melee nylocas.",
		section = generalSettings
	)
	default String meleeNylocasSymbol()
	{
		return "I";
	}

	@ConfigItem(
		position = 2,
		keyName = "rangeNylocasSymbol",
		name = "Range Symbol",
		description = "Symbol of range nylocas.",
		section = generalSettings
	)
	default String rangeNylocasSymbol()
	{
		return "T";
	}

	@ConfigItem(
		position = 3,
		keyName = "mageNylocasSymbol",
		name = "Mage Symbol",
		description = "Symbol of mage nylocas.",
		section = generalSettings
	)
	default String mageNylocasSymbol()
	{
		return "H";
	}

	@ConfigItem(
		position = 4,
		keyName = "showNylocasWave",
		name = "Show Nylocas Wave",
		description = "Display wave on nylocas. \"Show nylocas symbol\" must be disabled.",
		section = generalSettings
	)
	default boolean showNylocasWave()
	{
		return false;
	}

	@ConfigItem(
		position = 5,
		keyName = "wavePrefix",
		name = "Wave Spawn Prefix",
		description = "Prefix for spawned nylocas from waves.",
		section = generalSettings
	)
	default String wavePrefix()
	{
		return "";
	}

	@ConfigItem(
		position = 6,
		keyName = "splitPrefix",
		name = "Split Spawn Prefix",
		description = "Prefix for spawned nylocas from splits.",
		section = generalSettings
	)
	default String splitPrefix()
	{
		return "s";
	}

	@ConfigItem(
		position = 7,
		keyName = "tileHighlightWidth",
		name = "Tile Highlight Width",
		description = "Tile highlight width",
		section = generalSettings
	)
	default double tileHighlightWidth()
	{
		return 2;
	}

	// ------------------------------------------------------------

	@ConfigSection(
		name = "Font Settings",
		position = 2,
		description = "Fonts settings",
		closedByDefault = true
	)
	String fontsSettings = "fontsSettings";

	@ConfigItem(
		position = 0,
		keyName = "fontsType",
		name = "Font Type",
		description = "Nylocas wave number font type.",
		section = fontsSettings
	)
	default NyloerFonts fontsType()
	{
		return NyloerFonts.ARIAL;
	}

	@ConfigItem(
		position = 1,
		keyName = "fontsBold",
		name = "Bold",
		description = "Nylocas wave number fonts will be bold.",
		section = fontsSettings
	)
	default boolean fontsBold()
	{
		return true;
	}

	@ConfigItem(
		position = 2,
		keyName = "fontsSize",
		name = "Font Size",
		description = "Nylocas wave number size.",
		section = fontsSettings
	)
	default int fontsSize()
	{
		return 12;
	}

	@ConfigItem(
		position = 3,
		keyName = "splitFontsType",
		name = "Split Font Type",
		description = "Nylocas wave number font type (split)",
		section = fontsSettings
	)
	default NyloerFonts splitFontsType()
	{
		return NyloerFonts.ARIAL;
	}

	@ConfigItem(
		position = 4,
		keyName = "splitFontsBold",
		name = "Split Bold",
		description = "Nylocas wave number fonts will be bold (split)",
		section = fontsSettings
	)
	default boolean splitFontsBold()
	{
		return true;
	}

	@ConfigItem(
		position = 5,
		keyName = "splitFontsSize",
		name = "Split Font Size",
		description = "Nylocas wave number size (split)",
		section = fontsSettings
	)
	default int splitFontsSize()
	{
		return 12;
	}

	@Alpha
	@ConfigItem(
		position = 6,
		keyName = "meleeNylocasColor",
		name = "Melee Color",
		description = "Color of melee nylocas.",
		section = fontsSettings
	)
	default Color meleeNylocasColor()
	{
		return Color.WHITE;
	}

	@Alpha
	@ConfigItem(
		position = 7,
		keyName = "meleeNylocasOutlineColor",
		name = "Melee Outline Color",
		description = "Outline color of melee nylocas.",
		section = fontsSettings
	)
	default Color meleeNylocasOutlineColor()
	{
		return Color.BLACK;
	}

	@Alpha
	@ConfigItem(
		position = 8,
		keyName = "rangeNylocasColor",
		name = "Range Color",
		description = "Color of range nylocas.",
		section = fontsSettings
	)
	default Color rangeNylocasColor()
	{
		return Color.GREEN;
	}

	@Alpha
	@ConfigItem(
		position = 9,
		keyName = "rangeNylocasOutlineColor",
		name = "Range Outline Color",
		description = "Outline color of range nylocas.",
		section = fontsSettings
	)
	default Color rangeNylocasOutlineColor()
	{
		return Color.BLACK;
	}

	@Alpha
	@ConfigItem(
		position = 10,
		keyName = "mageNylocasColor",
		name = "Mage Color",
		description = "Color of mage nylocas.",
		section = fontsSettings
	)
	default Color mageNylocasColor()
	{
		return Color.CYAN;
	}

	@Alpha
	@ConfigItem(
		position = 11,
		keyName = "mageNylocasOutlineColor",
		name = "Mage Outline Color",
		description = "Outline color of mage nylocas.",
		section = fontsSettings
	)
	default Color mageNylocasOutlineColor()
	{
		return Color.BLACK;
	}

	@ConfigItem(
		position = 12,
		keyName = "makeDarkerHotkey",
		name = "Make Darker Hotkey",
		description = "Makes color darker for present nylocas in the room.",
		section = fontsSettings
	)
	default Keybind makeDarkerHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		position = 13,
		keyName = "darkerWave",
		name = "Darker Wave",
		description = "Makes the selected wave nyloes darker, as well as the older ones.",
		section = fontsSettings
	)
	default int darkerWave()
	{
		return 0;
	}

	@ConfigItem(
		position = 14,
		keyName = "darkerWaveOffset",
		name = "Darker Wave Offset",
		description = "",
		section = fontsSettings
	)
	default int darkerWaveOffset()
	{
		return 0;
	}

	@ConfigItem(
		position = 15,
		keyName = "customFontConfig",
		name = "Font config",
		description = "Config settings wave:melee/range/mage:color",
		section = fontsSettings
	)
	default String customFontConfig()
	{
		return "0:mage:#00FFFF";
	}


	// ------------------------------------------------------------
	@ConfigSection(
		name = "Role Swapper",
		position = 3,
		description = "Role Swapper Settings",
		closedByDefault = true
	)
	String roleSwapperSettings = "roleSwapperSettings";

	@ConfigItem(
		keyName = "mageRoleSwaps",
		name = "Mage Swaps",
		description = "Custom swaps for mage role",
		section = roleSwapperSettings,
		position = 0
	)
	default String mageRoleSwaps()
	{
		return "attack,nylocas ischyros*260*\n" +
			"attack,nylocas ischyros*162*\n" +
			"attack,nylocas toxobolos*260*\n" +
			"attack,nylocas toxobolos*162*\n" +
			"attack,nylocas hagios*260*\n" +
			"attack,nylocas hagios*162*";
	}

	@ConfigItem(
		keyName = "mageRoleShiftSwaps",
		name = "Mage Shift Swaps",
		description = "Custom shift swaps for mage role",
		section = roleSwapperSettings,
		position = 1
	)
	default String mageRoleShiftSwaps()
	{
		return "/walk here,*\n" +
			"/attack,nylocas hagios*162*";
	}

	@ConfigItem(
		keyName = "mageHighlightMageTiles",
		name = "Highlight Mage Tiles",
		description = "Highlights mage nylo tiles when mage role is selected.",
		section = roleSwapperSettings,
		position = 2
	)
	default boolean mageHighlightMageTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "mageHighlightRangeTiles",
		name = "Highlight Range Tiles",
		description = "Highlights range nylo tiles when mage role is selected.",
		section = roleSwapperSettings,
		position = 3
	)
	default boolean mageHighlightRangeTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "mageHighlightMeleeTiles",
		name = "Highlight Melee Tiles",
		description = "Highlights melee nylo tiles when mage role is selected.",
		section = roleSwapperSettings,
		position = 4
	)
	default boolean mageHighlightMeleeTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "rangeRoleSwaps",
		name = "Range Swaps",
		description = "Custom swaps for range role",
		section = roleSwapperSettings,
		position = 5
	)
	default String rangeRoleSwaps()
	{
		return "attack,nylocas ischyros*260*\n" +
			"attack,nylocas ischyros*162*\n" +
			"attack,nylocas hagios*260*\n" +
			"attack,nylocas hagios*162*\n" +
			"attack,nylocas toxobolos*260*\n" +
			"attack,nylocas toxobolos*162*";
	}

	@ConfigItem(
		keyName = "rangeRoleShiftSwaps",
		name = "Range Shift Swaps",
		description = "Custom shift swaps for range role",
		section = roleSwapperSettings,
		position = 6
	)
	default String rangeRoleShiftSwaps()
	{
		return "/walk here,*\n" +
			"/attack,nylocas toxobolos*162*";
	}

	@ConfigItem(
		keyName = "rangeHighlightMageTiles",
		name = "Highlight Mage Tiles",
		description = "Highlights mage nylo tiles when range role is selected.",
		section = roleSwapperSettings,
		position = 7
	)
	default boolean rangeHighlightMageTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "rangeHighlightRangeTiles",
		name = "Highlight Range Tiles",
		description = "Highlights range nylo tiles when range role is selected.",
		section = roleSwapperSettings,
		position = 8
	)
	default boolean rangeHighlightRangeTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "rangeHighlightMeleeTiles",
		name = "Highlight Melee Tiles",
		description = "Highlights melee nylo tiles when range role is selected.",
		section = roleSwapperSettings,
		position = 9
	)
	default boolean rangeHighlightMeleeTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "meleeRoleSwaps",
		name = "Melee Swaps",
		description = "Custom swaps for melee role",
		section = roleSwapperSettings,
		position = 10
	)
	default String meleeRoleSwaps()
	{
		return "attack,nylocas hagios*269*\n" +
			"attack,nylocas hagios*162*\n" +
			"attack,nylocas toxobolos*260*\n" +
			"attack,nylocas toxobolos*162*\n" +
			"attack,nylocas ischyros*260*\n" +
			"attack,nylocas ischyros*162*";
	}

	@ConfigItem(
		keyName = "meleeRoleShiftSwaps",
		name = "Melee Shift Swaps",
		description = "Custom shift swaps for melee role",
		section = roleSwapperSettings,
		position = 11
	)
	default String meleeRoleShiftSwaps()
	{
		return "/walk here,*\n" +
			"/attack,nylocas ischyros*162*";
	}

	@ConfigItem(
		keyName = "meleeHighlightMageTiles",
		name = "Highlight Mage Tiles",
		description = "Highlights mage nylo tiles when melee role is selected.",
		section = roleSwapperSettings,
		position = 12
	)
	default boolean meleeHighlightMageTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "meleeHighlightRangeTiles",
		name = "Highlight Range Tiles",
		description = "Highlights range nylo tiles when melee role is selected.",
		section = roleSwapperSettings,
		position = 13
	)
	default boolean meleeHighlightRangeTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "meleeHighlightMeleeTiles",
		name = "Highlight Melee Tiles",
		description = "Highlights melee nylo tiles when melee role is selected.",
		section = roleSwapperSettings,
		position = 14
	)
	default boolean meleeHighlightMeleeTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "customRoleSwaps",
		name = "Custom Swaps",
		description = "Custom swaps for Custom role",
		section = roleSwapperSettings,
		position = 15
	)
	default String customRoleSwaps()
	{
		return "attack,nylocas toxobolos*260*\n" +
			"attack,nylocas toxobolos*162*\n" +
			"attack,nylocas hagios*260*\n" +
			"attack,nylocas hagios*162*\n" +
			"attack,nylocas ischyros*260*\n" +
			"attack,nylocas ischyros*162*";
	}

	@ConfigItem(
		keyName = "customRoleShiftSwaps",
		name = "Custom Shift Swaps",
		description = "Custom shift swaps for Custom role",
		section = roleSwapperSettings,
		position = 16
	)
	default String customRoleShiftSwaps()
	{
		return "/walk here,*\n" +
			"/attack,nylocas hagios*162*";
	}

	@ConfigItem(
		keyName = "customHighlightMageTiles",
		name = "Highlight Mage Tiles",
		description = "Highlights mage nylo tiles when custom role is selected.",
		section = roleSwapperSettings,
		position = 17
	)
	default boolean customHighlightMageTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "customHighlightRangeTiles",
		name = "Highlight Range Tiles",
		description = "Highlights range nylo tiles when custom role is selected.",
		section = roleSwapperSettings,
		position = 18
	)
	default boolean customHighlightRangeTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "customHighlightMeleeTiles",
		name = "Highlight Melee Tiles",
		description = "Highlights melee nylo tiles when custom role is selected.",
		section = roleSwapperSettings,
		position = 19
	)
	default boolean customHighlightMeleeTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "displayMageTilesAsTrueTiles",
		name = "True tiles for mage",
		description = "True tiles will be displayed for magers",
		section = roleSwapperSettings,
		position = 20
	)
	default boolean displayMageTilesAsTrueTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "displayRangeTilesAsTrueTiles",
		name = "True tiles for range",
		description = "True tiles will be displayed for rangers",
		section = roleSwapperSettings,
		position = 21
	)
	default boolean displayRangeTilesAsTrueTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "displayMeleeTilesAsTrueTiles",
		name = "True tiles for melees",
		description = "True tiles will be displayed for melees",
		section = roleSwapperSettings,
		position = 22
	)
	default boolean displayMeleeTilesAsTrueTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "previousRole",
		name = "",
		description = "",
		hidden = true
	)
	default String previousRole()
	{
		return "";
	}

	@ConfigItem(
		keyName = "previousRole",
		name = "",
		description = "",
		hidden = true
	)
	void setPreviousRole(String role);
}

package com.nyloer;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum NyloerFonts
{
	REGULAR("RS Regular"),
	ARIAL("Arial"),
	CAMBRIA("Cambria"),
	ROCKWELL("Rockwell"),
	SEGOE_UI("Segoe Ui"),
	TIMES_NEW_ROMAN("Times New Roman"),
	VERDANA("Verdana"),
	DIALOG("DIALOG"),
	RUNESCAPE("RuneScape");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}
package com.nyloer.stats;


public class Stats
{
	public String totalTime;
	public String bossTime;
	public String wavesTime;

	public int stallCountPre;
	public int stallCount1to12;
	public int stallCount13to19;
	public int stallCount21;
	public int stallCount22to27;
	public int stallCount28;
	public int stallCount29;
	public int stallCount30;

	public int bigsAlive22;
	public int bigsAlive29;
	public int bigsAlive30;
	public int bigsAlive31;

	public int[] bossRotation;

	Stats()
	{
		bossRotation = new int[3];
		reset();
	}

	public void reset()
	{
		totalTime = "";
		bossTime = "";
		wavesTime = "";

		bossRotation[0] = 1;
		bossRotation[1] = 0;
		bossRotation[2] = 0;

		stallCountPre = 0;
		stallCount1to12 = 0;
		stallCount13to19 = 0;
		stallCount21 = 0;
		stallCount22to27 = 0;
		stallCount28 = 0;
		stallCount29 = 0;
		stallCount30 = 0;

		bigsAlive22 = 0;
		bigsAlive29 = 0;
		bigsAlive30 = 0;
		bigsAlive31 = 0;
	}
}
package com.nyloer.stats;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.RequiredArgsConstructor;


@Getter
@RequiredArgsConstructor
@EqualsAndHashCode
public
class Stall
{
	private int wave;
	private int aliveCount;
	private int capSize;
	private int totalStalls;

	public Stall(int wave, int aliveCount, int capSize, int totalStalls)
	{
		this.wave = wave;
		this.aliveCount = aliveCount;
		this.capSize = capSize;
		this.totalStalls = totalStalls;
	}
}
package com.nyloer.stats;

import com.nyloer.NyloerConfig;
import com.nyloer.NyloerPlugin;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;
import java.util.*;
import java.util.regex.Pattern;


@Getter
public class StatsHandler
{
	private final Client client;
	private final NyloerPlugin plugin;
	private final NyloerConfig config;

	private int currentWave;
	private int capSize;
	private int capSizePostcap;
	private int ticksSinceLastWave;

	private final ArrayList<Stall> stalls;
	private final Stats stats;
	private int w1T;
	private int lastNyloDeathT;
	private int bossSpawnT;
	private int bossDeathT;

	private static final Pattern NYLO_RETRY_MESSAGE = Pattern.compile("You have failed. The vampyres take pity on you and allow you to try again...");
	private static final Pattern NYLO_COMPLETE_MESSAGE = Pattern.compile("Wave 'The Nylocas' \\(.*\\) complete!");

	private static final HashMap<Integer, Integer> waveNaturalStalls;
	static
	{
		waveNaturalStalls = new HashMap<>();
		waveNaturalStalls.put(1, 4);
		waveNaturalStalls.put(2, 4);
		waveNaturalStalls.put(3, 4);
		waveNaturalStalls.put(4, 4);
		waveNaturalStalls.put(5, 16);

		waveNaturalStalls.put(6, 4);
		waveNaturalStalls.put(7, 12);
		waveNaturalStalls.put(8, 4);
		waveNaturalStalls.put(9, 12);
		waveNaturalStalls.put(10, 8);

		waveNaturalStalls.put(11, 8);
		waveNaturalStalls.put(12, 8);
		waveNaturalStalls.put(13, 8);
		waveNaturalStalls.put(14, 8);
		waveNaturalStalls.put(15, 8);

		waveNaturalStalls.put(16, 4);
		waveNaturalStalls.put(17, 12);
		waveNaturalStalls.put(18, 8);
		waveNaturalStalls.put(19, 12);
		waveNaturalStalls.put(20, 16);

		waveNaturalStalls.put(21, 8);
		waveNaturalStalls.put(22, 12);
		waveNaturalStalls.put(23, 8);
		waveNaturalStalls.put(24, 8);
		waveNaturalStalls.put(25, 8);

		waveNaturalStalls.put(26, 4);
		waveNaturalStalls.put(27, 8);
		waveNaturalStalls.put(28, 4);
		waveNaturalStalls.put(29, 4);
		waveNaturalStalls.put(30, 4);
	}

	@Inject
	protected StatsHandler(NyloerPlugin plugin, NyloerConfig config)
	{
		this.client = plugin.client;
		this.plugin = plugin;
		this.config = config;

		stalls = new ArrayList<Stall>();
		stats = new Stats();
		reset();
	}

	public void reset()
	{
		currentWave = 0;
		capSize = 12;
		capSizePostcap = 24;
		ticksSinceLastWave = 0;
		stalls.clear();
		stats.reset();

		w1T = -1;
		lastNyloDeathT = -1;
		bossSpawnT = -1;
		bossDeathT = -1;
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (!plugin.isNylocasRegion())
		{
			return;
		}
		if (isCapCheck())
		{
			int nylocasAliveCount = getNylocasAliveCount();
			if (nylocasAliveCount >= capSize)
			{
				addStall(new Stall(currentWave, nylocasAliveCount, capSize, stalls.size() + 1));
			}
		}
		ticksSinceLastWave++;
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned)
	{
		NPC npc = npcSpawned.getNpc();
		NyloerPlugin.NyloerNpc nyloer = plugin.getNyloersIndexMap().get(npc.getIndex());
		if (nyloer != null)
		{
			if ((!nyloer.isSplit()) && (ticksSinceLastWave > 3))
			{
				waveSpawned();
			}
		}
		else if (isNylocasVasiliasSpawn(npc))
		{
			bossSpawnT = client.getTickCount();
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		NPC npc = npcDespawned.getNpc();
		if (isNylocas(npc))
		{
			if (plugin.getNyloersIndexMap().size() == 0)
			{
				lastNyloDeathT = client.getTickCount();
			}
		}
		else if (isNylocasVasiliasDespawn(npc))
		{
			bossDeathT = client.getTickCount();
		}
	}

	@Subscribe
	public void onNpcChanged(NpcChanged npcChanged)
	{
		int npcId = npcChanged.getNpc().getId();
		switch(npcId)
		{
			case NpcID.NYLOCAS_VASILIAS_8355:
			case NpcID.NYLOCAS_VASILIAS_10787:
			case NpcID.NYLOCAS_VASILIAS_10808:
				stats.bossRotation[0]++;
				break;
			case NpcID.NYLOCAS_VASILIAS_8356:
			case NpcID.NYLOCAS_VASILIAS_10788:
			case NpcID.NYLOCAS_VASILIAS_10809:
				stats.bossRotation[1]++;
				break;
			case NpcID.NYLOCAS_VASILIAS_8357:
			case NpcID.NYLOCAS_VASILIAS_10789:
			case NpcID.NYLOCAS_VASILIAS_10810:
				stats.bossRotation[2]++;
				break;
		}
	}

	public void waveSpawned()
	{
		currentWave++;
		ticksSinceLastWave = 0;
		switch (currentWave)
		{
			case 1:
				w1T = client.getTickCount();
				break;
			case 20:
				capSize = capSizePostcap;
			case 22:
				stats.bigsAlive22 = getBigsAliveCount();
				break;
			case 29:
				stats.bigsAlive29 = getBigsAliveCount();
				break;
			case 30:
				stats.bigsAlive30 = getBigsAliveCount();
				break;
			case 31:
				stats.bigsAlive31 = getBigsAliveCount();
				break;
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (!plugin.isNylocasRegion() || event.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}
		String msg = Text.removeTags(event.getMessage());
		if (NYLO_COMPLETE_MESSAGE.matcher(msg).find())
		{
			addStats();
			reset();
		}
		else if (NYLO_RETRY_MESSAGE.matcher(msg).find())
		{
			addStats();
			reset();
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		if (client.getLocalPlayer() == null)
		{
			return;
		}
		int tobVar = client.getVarbitValue(Varbits.THEATRE_OF_BLOOD);
		boolean inTob = tobVar == 2 || tobVar == 3;
		if (!inTob && currentWave != 0)
		{
			addStats();
			reset();
		}
	}

	private void addStall(Stall stall)
	{
		stalls.add(stall);
		plugin.sidePanel.addStall(stall);

		if (stall.getWave() < 20)
		{
			stats.stallCountPre++;
			if (stall.getWave() < 13)
			{
				stats.stallCount1to12++;
			}
			else
			{
				stats.stallCount13to19++;
			}
		}
		switch (stall.getWave())
		{
			case 21:
				stats.stallCount21++;
				break;
			case 22:
			case 23:
			case 24:
			case 26:
			case 27:
				stats.stallCount22to27++;
				break;
			case 28:
				stats.stallCount28++;
				break;
			case 29:
				stats.stallCount29++;
				break;
			case 30:
				stats.stallCount30++;
				break;
		}
	}

	public void addStats()
	{
		if (lastNyloDeathT == -1)
		{
			return;
		}
		int tTotal;
		int tBoss;
		int tBossSpawn;

		int tWaves = lastNyloDeathT - w1T + 4;
		int tBossSpawnWait = 16;
		if ((tWaves % 4) != 0)
		{
			tBossSpawnWait += 4 - (tWaves % 4);
		}
		tBossSpawn = tWaves + tBossSpawnWait;

		if (bossDeathT != -1)
		{
			tBoss = bossDeathT - bossSpawnT + 2;
			if ((tBoss % 4) != 0)
			{
				tBoss += 4 - (tBoss % 4);
			}
			tTotal = tBossSpawn + tBoss;
		}
		else
		{
			tBoss = 0;
			tTotal = 0;
		}
		stats.totalTime = _ticks2Time(tTotal);
		stats.bossTime = _ticks2Time(tBoss);
		stats.wavesTime = _ticks2Time(tBossSpawn);
		plugin.sidePanel.addStats(stats);
	}

	private boolean isCapCheck()
	{
		if ((currentWave > 1) && (currentWave < 31))
		{
			return (ticksSinceLastWave % 4 == 0) && (ticksSinceLastWave >= waveNaturalStalls.get(currentWave));
		}
		return false;
	}

	private int getNylocasAliveCount()
	{
		int nylocasAliveCount = 0;
		for (NPC npc : client.getNpcs())
		{
			if (isNylocas(npc))
			{
				nylocasAliveCount++;
			}
		}
		return nylocasAliveCount;
	}

	private int getBigsAliveCount()
	{
		int bigsAliveCount = 0;
		for (NyloerPlugin.NyloerNpc nyloer : plugin.getNyloersIndexMap().values())
		{
			if (nyloer.getSize().equals("BIG"))
			{
				bigsAliveCount++;
			}
		}
		return bigsAliveCount;
	}

	private boolean isNylocas(NPC npc)
	{
		String name = npc.getName();
		if (name == null)
		{
			return false;
		}
		return (name.equals("Nylocas Ischyros")) || (name.equals("Nylocas Toxobolos")) || (name.equals("Nylocas Hagios"));
	}

	private boolean isNylocasVasiliasSpawn(NPC npc)
	{
		switch (npc.getId())
		{
			case NpcID.NYLOCAS_VASILIAS:
			case NpcID.NYLOCAS_VASILIAS_10786:
			case NpcID.NYLOCAS_VASILIAS_10807:
				return true;
		}
		return false;
	}

	private boolean isNylocasVasiliasDespawn(NPC npc)
	{
		switch (npc.getId())
		{
			case NpcID.NYLOCAS_VASILIAS_8355:
			case NpcID.NYLOCAS_VASILIAS_8356:
			case NpcID.NYLOCAS_VASILIAS_8357:
			case NpcID.NYLOCAS_VASILIAS_10786:
			case NpcID.NYLOCAS_VASILIAS_10807:
				return true;
		}
		return false;
	}

	private String _ticks2Time(int ticks)
	{
		if (ticks == 0)
		{
			return "";
		}
		int millis = ticks * 600;
		String hundredths = String.valueOf(millis % 1000).substring(0, 1);
		return String.format(
			"%d:%02d.%s",
			TimeUnit.MILLISECONDS.toMinutes(millis) % TimeUnit.HOURS.toMinutes(1),
			TimeUnit.MILLISECONDS.toSeconds(millis) % TimeUnit.MINUTES.toSeconds(1),
			hundredths
		);
	}
}

package com.nyloer.overlays;

import com.google.common.collect.ArrayListMultimap;
import com.nyloer.NyloerConfig;
import com.nyloer.NyloerPlugin;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.util.stream.IntStream;
import javax.inject.Inject;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.game.NpcUtil;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

public class NyloerOverlay extends Overlay
{
	public ArrayListMultimap<WorldPoint, NyloerPlugin.NyloerNpc> nyloers;
	private final NyloerConfig config;
	private final NyloerPlugin plugin;
	private final NpcUtil npcUtil;

	@Inject
	private NyloerOverlay(NyloerPlugin plugin, NyloerConfig config, NpcUtil npcUtil)
	{
		this.setPosition(OverlayPosition.DYNAMIC);
		this.setPriority(OverlayPriority.HIGH);
		this.setLayer(OverlayLayer.UNDER_WIDGETS);
		this.npcUtil = npcUtil;
		this.plugin = plugin;
		this.config = config;
		this.nyloers = ArrayListMultimap.create();
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		this.nyloers.clear();
		if (this.plugin.getNylocasAliveCount() == 0)
		{
			return null;
		}
		nyloers = ArrayListMultimap.create();
		int length = this.plugin.getNyloers().size();
		for (int i = length - 1; i >= 0; i--)
		{
			NyloerPlugin.NyloerNpc nyloer = this.plugin.getNyloers().get(i);
			if (nyloer.isAlive() && !npcUtil.isDying(nyloer.getNpc()))
			{
				nyloers.put(nyloer.getNpc().getWorldLocation(), nyloer);
			}
		}
		if (!nyloers.isEmpty())
		{
			graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
			nyloers.asMap().forEach(
				(worldPoint, npcs) -> {
					int offset = 0;
					for (NyloerPlugin.NyloerNpc nyloer : npcs)
					{
						graphics.setFont(nyloer.getFont());
						this.draw(graphics, nyloer, offset);
						offset += graphics.getFontMetrics().getHeight();
					}
				});
		}
		return null;
	}

	private void draw(Graphics2D graphics, NyloerPlugin.NyloerNpc nyloer, int offset)
	{
		String prefix;
		String text;
		if (nyloer.isSplit())
		{
			prefix = config.splitPrefix();
		}
		else
		{
			prefix = config.wavePrefix();
		}
		if (config.showNylocasWave())
		{
			text = prefix + nyloer.getWaveSpawned();
		}
		else if (config.showNylocasSymbol())
		{
			text = prefix + nyloer.getNyloerSymbol();
		}
		else
		{
			text = prefix;
		}
		Point canvasTextLocation = nyloer.getNpc().getCanvasTextLocation(graphics, text, 0);
		if (canvasTextLocation == null)
		{
			return;
		}
		int x = canvasTextLocation.getX();
		int y = canvasTextLocation.getY() + offset;
		graphics.setColor(nyloer.getOutlineColor());
		IntStream.range(-1, 2).forEachOrdered(ex -> {
			IntStream.range(-1, 2).forEachOrdered(ey -> {
				if (ex != 0 && ey != 0)
				{
					graphics.drawString(text, x + ex, y + ey);
				}
			});
		});
		Color color = nyloer.getColor();
		if ((nyloer.getTickSpawned() <= plugin.makeDarkerT) || (nyloer.isColorDarker()))
		{
			color = color.darker().darker();
		}
		graphics.setColor(color);
		graphics.drawString(text, x, y);
	}
}

package com.nyloer.overlays;

import com.nyloer.NyloerConfig;
import com.nyloer.NyloerPlugin;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Shape;
import java.awt.Stroke;
import javax.inject.Inject;
import lombok.Setter;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.NpcUtil;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;


public class NyloerTileOverlay extends Overlay
{
	private final NyloerConfig config;
	private final NyloerPlugin plugin;
	private final NpcUtil npcUtil;

	Stroke highlightWidth;

	@Setter
	private boolean renderMage;
	@Setter
	private boolean renderRange;
	@Setter
	private boolean renderMelee;

	@Inject
	private NyloerTileOverlay(NyloerPlugin plugin, NyloerConfig config, NpcUtil npcUtil)
	{
		this.setPosition(OverlayPosition.DYNAMIC);
		this.setPriority(OverlayPriority.HIGH);
		this.setLayer(OverlayLayer.ABOVE_SCENE);
		this.npcUtil = npcUtil;
		this.plugin = plugin;
		this.config = config;

		this.renderMage = false;
		this.renderRange = false;
		this.renderMelee = false;

		this.highlightWidth = new BasicStroke((float) config.tileHighlightWidth());
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (!configChanged.getGroup().equals(NyloerConfig.GROUP))
		{
			this.highlightWidth = new BasicStroke((float) config.tileHighlightWidth());
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (this.plugin.getNylocasAliveCount() == 0)
		{
			return null;
		}
		for (NyloerPlugin.NyloerNpc nyloer : this.plugin.getNyloersIndexMap().values())
		{
			if ((nyloer.isAlive()) && (!npcUtil.isDying(nyloer.getNpc())))
			{
				switch (nyloer.getStyle())
				{
					case "mage":
						if (renderMage)
						{
							if (config.displayMageTilesAsTrueTiles())
							{
								drawTrueTile(graphics, nyloer);
							}
							else
							{
								drawTile(graphics, nyloer);
							}
						}
						break;
					case "range":
						if (renderRange)
						{
							if (config.displayRangeTilesAsTrueTiles())
							{
								drawTrueTile(graphics, nyloer);
							}
							else
							{
								drawTile(graphics, nyloer);
							}
						}
						break;
					case "melee":
						if (renderMelee)
						{
							if (config.displayMeleeTilesAsTrueTiles())
							{
								drawTrueTile(graphics, nyloer);
							}
							else
							{
								drawTile(graphics, nyloer);
							}
						}
						break;
				}
			}
		}
		return null;
	}

	private void drawTile(Graphics2D graphics, NyloerPlugin.NyloerNpc nyloer)
	{
		Polygon polygon = nyloer.getNpc().getCanvasTilePoly();
		if (polygon != null)
		{
			OverlayUtil.renderPolygon(graphics, polygon, nyloer.getColor(), highlightWidth);
		}
	}

	private void drawTrueTile(Graphics2D graphics, NyloerPlugin.NyloerNpc nyloer)
	{
		NPC npc = nyloer.getNpc();
		NPCComposition npcComposition = npc.getTransformedComposition();
		LocalPoint lp = LocalPoint.fromWorld(plugin.client, npc.getWorldLocation());
		if ((lp != null) && (npcComposition != null))
		{
			final int size = npcComposition.getSize();
			final LocalPoint centerLp = lp.plus(
				Perspective.LOCAL_TILE_SIZE * (size - 1) / 2,
				Perspective.LOCAL_TILE_SIZE * (size - 1) / 2);
			Polygon tilePoly = Perspective.getCanvasTileAreaPoly(plugin.client, centerLp, size);
			renderPoly(graphics, nyloer.getColor(), highlightWidth, tilePoly);
		}
	}

	private void renderPoly(Graphics2D graphics, Color borderColor, Stroke borderStroke, Shape polygon)
	{
		if (polygon != null)
		{
			graphics.setColor(borderColor);
			graphics.setStroke(borderStroke);
			graphics.draw(polygon);
		}
	}
}

package com.nyloer;

import com.google.inject.Provides;
import com.nyloer.stats.StatsHandler;
import com.nyloer.overlays.NyloerOverlay;
import com.nyloer.overlays.NyloerTileOverlay;
import com.nyloer.roleswapper.RoleSwapper;
import java.awt.Color;
import java.awt.Font;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import javax.inject.Inject;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.NpcUtil;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import java.awt.event.KeyEvent;
import org.apache.commons.lang3.ArrayUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.util.ImageUtil;

@PluginDescriptor(
	name = "Nyloer"
)
public class NyloerPlugin extends Plugin implements KeyListener
{
	@Inject
	public Client client;

	@Inject
	public ClientThread clientThread;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private EventBus eventBus;

	@Inject
	public NyloerConfig config;

	@Inject
	public RoleSwapper roleSwapper;

	@Inject
	public StatsHandler statsHandler;

	@Inject
	public CustomFontConfig customFontConfig;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private NpcUtil npcUtil;

	@Inject
	private NyloerOverlay nyloerOverlay;

	@Inject
	public NyloerTileOverlay nyloerTileOverlay;

	@Inject
	private KeyManager keyManager;

	public NyloerSidePanel sidePanel;
	public NavigationButton sidePanelButton;

	private static final int NYLOCAS_REGION_ID = 13122;
	private final int[] NYLOCAS_PILLAR_IDS = {8358, 10811, 10790};
	private final int[] NYLOCAS_NPC_IDS = {
		8342, 8348, 8345, 8351, 8343, 8349, 8346, 8352, 8344, 8350, 8347, 8353,
		10791, 10792, 10793, 10797, 10798, 10799, 10794, 10795, 10796,
		10800, 10801, 10802, 10774, 10777, 10780, 10783, 10775, 10778,
		10781, 10784, 10776, 10779, 10782, 10785
	};
	private final int[] MELEE_NYLOCAS_IDS = {8342, 8345, 8348, 8351, 10774, 10777, 10780, 10783, 10791, 10794, 10797, 10800};
	private final int[] RANGE_NYLOCAS_IDS = {8343, 8346, 8349, 8352, 10775, 10778, 10781, 10784, 10792, 10795, 10798, 10801};
	private final int[] MAGE_NYLOCAS_IDS = {8344, 8347, 8350, 8353, 10776, 10779, 10782, 10785, 10793, 10796, 10799, 10802};

	@Getter
	private boolean isNylocasRegion = false;

	@Getter
	private boolean isNylocasRegionLast = false;

	@Getter
	private boolean pillarsSpawned;

	@Getter
	private int w1T = 0;

	@Getter
	public int makeDarkerT;

	private int _makeDarkerT;

	@Getter
	private int waveNumber;

	@Getter
	private int nylocasAliveCount;

	private int lastWaveTickSpawned;

	@Getter
	ArrayList<NyloerNpc> nyloers = new ArrayList<NyloerNpc>();
	@Getter
	HashMap<Integer, NyloerNpc> nyloersIndexMap = new HashMap<>();

	public static final Logger log = LoggerFactory.getLogger(NyloerPlugin.class);

	@Override
	protected void startUp() throws Exception
	{
		createSidePanel();
		keyManager.registerKeyListener(this);
		eventBus.register(roleSwapper);
		eventBus.register(statsHandler);
		roleSwapper.reloadSwaps();
		start();
	}

	@Override
	protected void shutDown() throws Exception
	{
		removeSidePanel();
		stop();
		keyManager.unregisterKeyListener(this);
		eventBus.unregister(roleSwapper);
		eventBus.unregister(statsHandler);
	}

	@Override
	public void keyTyped(KeyEvent e)
	{
	}

	@Override
	public void keyPressed(KeyEvent e)
	{
		if (config.makeDarkerHotkey().matches(e))
		{
			makeDarkerT = this.client.getTickCount() - 1;
			makeDarkerT -= (makeDarkerT - w1T) % 4;
		}
	}

	@Override
	public void keyReleased(KeyEvent e)
	{
	}

	@Provides
	NyloerConfig provideConfig(ConfigManager configManager)
	{
		return (NyloerConfig) configManager.getConfig(NyloerConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (!configChanged.getGroup().equals(NyloerConfig.GROUP))
		{
			return;
		}
		customFontConfig.getColorSettings().clear();
		customFontConfig.parse(config);
	}

	private void createSidePanel()
	{
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/ico.png");
		sidePanel = new NyloerSidePanel(client, this, config);
		sidePanelButton = NavigationButton.builder().tooltip("Nyloer").icon(icon).priority(6).panel(sidePanel).build();
		clientToolbar.addNavigation(sidePanelButton);
		sidePanel.startPanel();
	}

	private void removeSidePanel()
	{
		clientToolbar.removeNavigation(sidePanelButton);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGIN_SCREEN || event.getGameState() == GameState.HOPPING)
		{
			stop();
		}
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (client.getTickCount() % 5 == 0)
		{
			updateNylocasRegion();
		}
		if (isNylocasRegion && !isNylocasRegionLast)
		{
			start();
		}
		else if (!isNylocasRegion && isNylocasRegionLast)
		{
			stop();
		}
		isNylocasRegionLast = isNylocasRegion;
		if (isNylocasRegion)
		{
			if (client.getTickCount() == _makeDarkerT)
			{
				makeDarkerT = _makeDarkerT;
			}
			for (NyloerNpc nyloer : nyloers)
			{
				if (nyloer.npc.isDead())
				{
					nyloer.setAlive(false);
				}
				else if (nyloer.isAlive)
				{
					nyloer.incrementTicks();
				}
			}
		}
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
		if (!isNylocasRegion)
		{
			return;
		}
		NPC npc = event.getNpc();
		String npcName = npc.getName();
		if (npcName == null)
		{
			return;
		}
		if (!pillarsSpawned && ArrayUtils.contains(NYLOCAS_PILLAR_IDS, npc.getId()))
		{
			reset();
			sidePanel.resetStallsTable();
			pillarsSpawned = true;
			return;
		}
		if (ArrayUtils.contains(NYLOCAS_NPC_IDS, npc.getId()))
		{
			NyloerNpc nyloer = new NyloerNpc(npc);
			if (!nyloer.spawn.equals("SPLIT") && lastWaveTickSpawned != client.getTickCount())
			{
				lastWaveTickSpawned = client.getTickCount();
				++waveNumber;
				++nyloer.waveSpawned;
				nyloer.updateStyle(nyloer.id);
				if (waveNumber == 1)
				{
					w1T = client.getTickCount();
				}
				if (waveNumber == config.darkerWave())
				{
					_makeDarkerT = client.getTickCount() + config.darkerWaveOffset();
				}
			}
			nyloers.add(nyloer);
			nyloersIndexMap.put(nyloer.index, nyloer);
			updateNylocasAliveCount();
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
		if (!isNylocasRegion)
		{
			return;
		}
		NyloerNpc nyloer = nyloersIndexMap.remove(event.getNpc().getIndex());
		if (nyloer != null)
		{
			updateNylocasAliveCount();
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (isNylocasRegion)
		{
			if (event.getType().equals(ChatMessageType.GAMEMESSAGE))
			{
				if (event.getMessage().equals("You have failed. The vampyres take pity on you and allow you to try again..."))
				{
					reset();
				}
			}
		}
	}

	private void start()
	{
		NyloerPlugin.log.debug("Starting Nyloer.");
		customFontConfig.parse(config);
		overlayManager.add(nyloerOverlay);
		overlayManager.add(nyloerTileOverlay);
	}

	private void stop()
	{
		NyloerPlugin.log.debug("Stopping Nyloer.");
		customFontConfig.getColorSettings().clear();
		overlayManager.remove(nyloerOverlay);
		overlayManager.remove(nyloerTileOverlay);
		reset();
	}

	private void reset()
	{
		NyloerPlugin.log.debug("Resetting Nyloer.");
		waveNumber = 0;
		nylocasAliveCount = 0;
		_makeDarkerT = 0;
		pillarsSpawned = false;
		nyloers.clear();
		nyloerOverlay.nyloers.clear();
	}

	private void updateNylocasRegion()
	{
		isNylocasRegion = ArrayUtils.contains(client.getMapRegions(), NYLOCAS_REGION_ID);
	}

	private void updateNylocasAliveCount()
	{
		nylocasAliveCount = nyloersIndexMap.size();
	}

	public class NyloerNpc
	{
		@Getter
		private NPC npc;

		@Getter
		private int id;

		@Getter
		private int lastId;

		@Getter
		private String style;

		@Getter
		private int index;

		@Getter
		private String size;

		@Getter
		@Setter
		private boolean isAlive;

		@Getter
		private boolean isSplit;

		@Getter
		private String spawn;

		@Getter
		private int waveSpawned;

		@Getter
		public int tickSpawned;

		@Getter
		private int ticksAlive;

		@Getter
		private String nyloerSymbol;

		@Getter
		private Color color;

		@Getter
		private Color outlineColor;

		@Getter
		private boolean colorDarker;

		@Getter
		private Font font;

		@Getter
		private String fontConfigKey;

		public void incrementTicks()
		{
			++ticksAlive;
			if (ticksAlive == 52)
			{
				isAlive = false;
			}
			if (lastId != npc.getId())
			{
				lastId = npc.getId();
				updateStyle(npc.getId());
			}
		}

		private void updateStyle(int id)
		{
			if (ArrayUtils.contains(MELEE_NYLOCAS_IDS, id))
			{
				style = "melee";
				fontConfigKey = waveSpawned + "-" + "melee";
				color = config.meleeNylocasColor();
				outlineColor = config.meleeNylocasOutlineColor();
				nyloerSymbol = config.meleeNylocasSymbol();
			}
			else if (ArrayUtils.contains(RANGE_NYLOCAS_IDS, id))
			{
				style = "range";
				fontConfigKey = waveSpawned + "-" + "range";
				color = config.rangeNylocasColor();
				outlineColor = config.rangeNylocasOutlineColor();
				nyloerSymbol = config.rangeNylocasSymbol();
			}
			else if (ArrayUtils.contains(MAGE_NYLOCAS_IDS, id))
			{
				style = "mage";
				fontConfigKey = waveSpawned + "-" + "mage";
				color = config.mageNylocasColor();
				outlineColor = config.mageNylocasOutlineColor();
				nyloerSymbol = config.mageNylocasSymbol();
			}
			else
			{
				fontConfigKey = null;
				color = Color.WHITE;
				outlineColor = Color.BLACK;
				isAlive = false;
			}
			Color customColor = customFontConfig.getColor(fontConfigKey);
			if (customColor != null)
			{
				color = customColor;
			}
			if (colorDarker)
			{
				color = color.darker().darker();
			}
		}

		private void configureFonts()
		{
			int style;
			if (isSplit)
			{
				style = config.splitFontsBold() ? Font.BOLD : Font.PLAIN;
				this.font = new Font(config.splitFontsType().toString(), style, config.splitFontsSize());
			}
			else
			{
				style = config.fontsBold() ? Font.BOLD : Font.PLAIN;
				this.font = new Font(config.fontsType().toString(), style, config.fontsSize());
			}
		}

		private String findSpawn(NPC npc)
		{
			int x = WorldPoint.fromLocalInstance(NyloerPlugin.this.client, npc.getLocalLocation()).getRegionX();
			int y = WorldPoint.fromLocalInstance(NyloerPlugin.this.client, npc.getLocalLocation()).getRegionY();
			if (x == 17 && y == 25)
			{
				return "WEST NORTH";
			}
			else if (x == 17 && y == 24)
			{
				return "WEST SOUTH";
			}
			else if (x == 31 && y == 9)
			{
				return "SOUTH WEST";
			}
			else if (x == 32 && y == 9)
			{
				return "SOUTH EAST";
			}
			else if (x == 46 && y == 24)
			{
				return "EAST SOUTH";
			}
			else if (x == 46 && y == 25)
			{
				if (npc.getComposition().getSize() == 1)
				{
					return "EAST NORTH";
				}
				else
				{
					return "EAST BIG";
				}
			}
			else if (x == 18 && y == 25)
			{
				return "WEST BIG";
			}
			else if (x == 32 && y == 10)
			{
				return "SOUTH BIG";
			}
			else if (x == 47 && y == 25)
			{
				return "EAST BIG 30";
			}
			else
			{
				return "SPLIT";
			}
		}

		public NyloerNpc(NPC npc)
		{
			this.npc = npc;
			this.id = npc.getId();
			this.lastId = npc.getId();
			this.index = npc.getIndex();
			this.isAlive = true;
			this.spawn = findSpawn(npc);
			this.isSplit = this.spawn.equals("SPLIT");
			this.tickSpawned = NyloerPlugin.this.client.getTickCount();
			this.colorDarker = false;
			if (isSplit && tickSpawned > NyloerPlugin.this.lastWaveTickSpawned)
			{
				this.waveSpawned = NyloerPlugin.this.waveNumber + 1;
			}
			else
			{
				this.waveSpawned = NyloerPlugin.this.waveNumber;
			}
			this.ticksAlive = 0;
			this.updateStyle(id);
			this.configureFonts();
			this.size = npc.getComposition().getSize() == 1 ? "SMALL" : "BIG";
		}
	}
}

/*
BSD 2-Clause License

Copyright (c) 2021, geheur
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package com.nyloer.roleswapper;

import com.nyloer.NyloerConfig;
import com.nyloer.NyloerPlugin;
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
import javax.inject.Inject;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import net.runelite.api.Client;
import net.runelite.api.KeyCode;
import net.runelite.api.MenuAction;
import static net.runelite.api.MenuAction.WIDGET_TARGET_ON_NPC;
import static net.runelite.api.MenuAction.WIDGET_TARGET_ON_PLAYER;
import net.runelite.api.events.PostMenuSort;
import net.runelite.api.widgets.Widget;
import static net.runelite.api.widgets.InterfaceID.SPELLBOOK;
import static net.runelite.api.MenuAction.GAME_OBJECT_FIFTH_OPTION;
import static net.runelite.api.MenuAction.PLAYER_EIGHTH_OPTION;
import static net.runelite.api.MenuAction.PLAYER_FIRST_OPTION;
import net.runelite.api.MenuEntry;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.util.Text;


public class RoleSwapper
{
	Client client;
	NyloerPlugin plugin;
	NyloerConfig config;

	@Getter
	@Setter
	String currentRole;

	final List<CustomSwap> mageSwaps = new ArrayList<>();
	final List<CustomSwap> rangeSwaps = new ArrayList<>();
	final List<CustomSwap> meleeSwaps = new ArrayList<>();
	final List<CustomSwap> customSwaps = new ArrayList<>();

	final List<CustomSwap> mageShiftSwaps = new ArrayList<>();
	final List<CustomSwap> rangeShiftSwaps = new ArrayList<>();
	final List<CustomSwap> meleeShiftSwaps = new ArrayList<>();
	final List<CustomSwap> customShiftSwaps = new ArrayList<>();

	@Inject
	protected RoleSwapper(NyloerPlugin plugin, NyloerConfig config)
	{
		this.client = plugin.client;
		this.plugin = plugin;
		this.config = config;
		this.currentRole = null;
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (!configChanged.getGroup().equals(NyloerConfig.GROUP))
		{
			return;
		}
		reloadSwaps();
	}

	public void reloadSwaps()
	{
		clearSwaps();
		mageSwaps.addAll(loadConfigSwaps(config.mageRoleSwaps(), false));
		mageShiftSwaps.addAll(loadConfigSwaps(config.mageRoleShiftSwaps(), true));
		rangeSwaps.addAll(loadConfigSwaps(config.rangeRoleSwaps(), false));
		rangeShiftSwaps.addAll(loadConfigSwaps(config.rangeRoleShiftSwaps(), true));
		meleeSwaps.addAll(loadConfigSwaps(config.meleeRoleSwaps(), false));
		meleeShiftSwaps.addAll(loadConfigSwaps(config.meleeRoleShiftSwaps(), true));
		customSwaps.addAll(loadConfigSwaps(config.customRoleSwaps(), false));
		customShiftSwaps.addAll(loadConfigSwaps(config.customRoleShiftSwaps(), true));
	}

	private void clearSwaps()
	{
		mageSwaps.clear();
		mageShiftSwaps.clear();
		rangeSwaps.clear();
		rangeShiftSwaps.clear();
		meleeSwaps.clear();
		meleeShiftSwaps.clear();
		customSwaps.clear();
		customShiftSwaps.clear();
	}

	private Collection<? extends CustomSwap> loadConfigSwaps(String customSwaps, boolean shiftSwaps)
	{
		List<CustomSwap> swaps = new ArrayList<>();
		for (String customSwap : customSwaps.split("\n"))
		{
			if (customSwap.trim().equals(""))
			{
				continue;
			}
			swaps.add(CustomSwap.fromString(customSwap));
		}
		if (!shiftSwaps)
		{
			swaps.add(CustomSwap.fromString("use,special attack"));
			swaps.add(CustomSwap.fromString("Activate, Quick-Prayers"));
			swaps.add(CustomSwap.fromString("Deactivate, Quick-Prayers"));
		}

		return swaps;
	}

	@Subscribe(priority = -2)
	public void onPostMenuSort(PostMenuSort e)
	{
		swapEntries();
	}

	public void swapEntries()
	{
		if (currentRole == null)
		{
			return;
		}
		MenuEntry[] menuEntries = client.getMenuEntries();
		if (menuEntries.length == 0)
		{
			return;
		}
		int topEntryIndex = menuEntries.length - 1;
		MenuEntry topEntry = menuEntries[topEntryIndex];
		if (_mayNotBeLeftClick(topEntry))
		{
			return;
		}
		int entryIndex = getEntryIndexToSwap(menuEntries);
		if (entryIndex >= 0)
		{
			MenuEntry entryToSwap = menuEntries[entryIndex];
			if (_isProtected(topEntry) || _isProtected(entryToSwap))
			{
				return;
			}

			// minimap orbs
			if (topEntryIndex > entryIndex)
			{
				menuEntries[topEntryIndex] = entryToSwap;
				menuEntries[entryIndex] = topEntry;
				// the client will open the right-click menu on left-click if the entry at the top is a CC_OP_LOW_PRIORITY.
				if (entryToSwap.getType() == MenuAction.CC_OP_LOW_PRIORITY)
				{
					entryToSwap.setType(MenuAction.CC_OP);
				}
			}
		}
		client.setMenuEntries(menuEntries);
	}

	private List<CustomSwap> getCurrentSwaps()
	{
		if (isShiftPressed())
		{
			switch (currentRole)
			{
				case "mage":
					return mageShiftSwaps;
				case "range":
					return rangeShiftSwaps;
				case "melee":
					return meleeShiftSwaps;
				case "custom":
					return customShiftSwaps;
			}
		}
		else
		{
			switch (currentRole)
			{
				case "mage":
					return mageSwaps;
				case "range":
					return rangeSwaps;
				case "melee":
					return meleeSwaps;
				case "custom":
					return customSwaps;
			}
		}
		return null;
	}

	private int getEntryIndexToSwap(MenuEntry[] menuEntries)
	{
		List<CustomSwap> currentSwaps = getCurrentSwaps();
		if (currentSwaps == null)
		{
			return -1;
		}
		int entryIndex = -1;
		int latestMatchingSwapIndex = -1;
		MenuEntry topEntry = menuEntries[menuEntries.length - 1];
		String topEntryOption = Text.standardize(topEntry.getOption());
		String topEntryTarget = Text.standardize(topEntry.getTarget());

		// prefer to swap menu entries that are already at or near the top of the list.
		for (int i = menuEntries.length - 1; i >= 0; i--)
		{
			MenuEntry entry = menuEntries[i];
			String option = Text.standardize(entry.getOption());
			String target = Text.standardize(entry.getTarget());
			int swapIndex = matches(option, target, topEntryOption, topEntryTarget, currentSwaps);
			if (swapIndex > latestMatchingSwapIndex)
			{
				entryIndex = i;
				latestMatchingSwapIndex = swapIndex;
			}
		}
		return entryIndex;
	}

	private boolean _mayNotBeLeftClick(MenuEntry entry)
	{
		MenuAction type = entry.getType();
		if (type.getId() >= PLAYER_FIRST_OPTION.getId() && type.getId() <= PLAYER_EIGHTH_OPTION.getId())
		{
			return true;
		}
		if (type == MenuAction.NPC_FOURTH_OPTION || type == MenuAction.NPC_FIFTH_OPTION)
		{
			if (entry.getNpc() != null)
			{
				String[] actions = entry.getNpc().getTransformedComposition().getActions();
				if ("Lure".equals(actions[3]) || "Knock-out".equals(actions[4]))
				{
					return true;
				}
			}
		}
		if (type == GAME_OBJECT_FIFTH_OPTION)
		{
			return client.getVarbitValue(2176) == 1; // in building mode.
		}
		return false;
	}

	private boolean isShiftPressed()
	{
		return client.isKeyPressed(KeyCode.KC_SHIFT);
	}

	private boolean _isProtected(MenuEntry entry)
	{
		MenuAction type = entry.getType();
		if (type == WIDGET_TARGET_ON_PLAYER || type == WIDGET_TARGET_ON_NPC)
		{
			Widget selectedWidget = client.getSelectedWidget();
			if ((selectedWidget != null) && (selectedWidget.getId() == SPELLBOOK))
			{
				return true;
			}
		}
		return _mayNotBeLeftClick(entry);
	}

	private static int matches(String entryOption, String entryTarget, String topEntryOption, String topEntryTarget, List<CustomSwap> swaps)
	{
		for (int i = 0; i < swaps.size(); i++)
		{
			CustomSwap swap = swaps.get(i);
			if (swap.matches(entryOption, entryTarget, topEntryOption, topEntryTarget))
			{
				return i;
			}
		}
		return -1;
	}

	@Getter
	@ToString
	@RequiredArgsConstructor
	@EqualsAndHashCode
	static class CustomSwap
	{
		private final String option;
		private final String target;
		private final String topOption;
		private final String topTarget;

		private final MatchType optionType;
		private final MatchType targetType;
		private final MatchType topOptionType;
		private final MatchType topTargetType;

		public static CustomSwap fromString(String s)
		{
			String[] split = s.split(",");
			return new CustomSwap(
				split[0].toLowerCase().trim(),
				split.length > 1 ? split[1].toLowerCase().trim() : "",
				split.length > 2 ? split[2].toLowerCase().trim() : null,
				split.length > 3 ? split[3].toLowerCase().trim() : null
			);
		}

		CustomSwap(String option, String target)
		{
			this(option, target, null, null);
		}

		CustomSwap(String option, String target, String topOption, String topTarget)
		{
			this.optionType = MatchType.getType(option);
			this.option = MatchType.prepareMatch(option, optionType);
			this.targetType = MatchType.getType(target);
			this.target = MatchType.prepareMatch(target, targetType);
			this.topOptionType = MatchType.getType(topOption);
			this.topOption = MatchType.prepareMatch(topOption, topOptionType);
			this.topTargetType = MatchType.getType(topTarget);
			this.topTarget = MatchType.prepareMatch(topTarget, topTargetType);
		}

		boolean matches(String option, String target)
		{
			return matches(option, target, "", "");
		}

		public boolean matches(String option, String target, String topOption, String topTarget)
		{
			return optionType.matches(option, this.option) &&
				targetType.matches(target, this.target) &&
				topOptionType.matches(topOption, this.topOption) &&
				topTargetType.matches(topTarget, this.topTarget);
		}
	}
}

/*
BSD 2-Clause License

Copyright (c) 2021, geheur
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.nyloer.roleswapper;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

enum MatchType
{
	EQUALS,
	STARTS_WITH,
	ENDS_WITH,
	CONTAINS,
	WILDCARD,
	IGNORE,
	;

	public boolean matches(String menuText, String swapText)
	{
		switch (this)
		{
			case IGNORE:
				return true;
			case EQUALS:
				return menuText.equals(swapText);
			case STARTS_WITH:
				return menuText.startsWith(swapText);
			case ENDS_WITH:
				return menuText.endsWith(swapText);
			case CONTAINS:
				return menuText.contains(swapText);
			case WILDCARD:
				return menuText.matches(swapText);
			default:
				// shouldn't happen.
				throw new IllegalStateException();
		}
	}

	public static MatchType getType(String s)
	{
		if (s == null)
		{
			return MatchType.IGNORE;
		}

		int star = s.indexOf('*');
		if (star == -1)
		{
			return MatchType.EQUALS;
		}
		if (star == 0)
		{
			if (s.length() == 1)
			{
				return MatchType.IGNORE;
			}
			star = s.indexOf('*', star + 1);
			if (star == -1)
			{
				return MatchType.ENDS_WITH;
			}
			if (star == s.length() - 1)
			{
				return MatchType.CONTAINS;
			}
		}
		else if (star == s.length() - 1)
		{
			return MatchType.STARTS_WITH;
		}

		return MatchType.WILDCARD;
	}

	public static String prepareMatch(String option, MatchType optionType)
	{
		return optionType == MatchType.WILDCARD ? generateWildcardMatcher(option) : removeStars(option);
	}

	private static String removeStars(String s)
	{
		return s == null ? s : s.replaceAll("\\*", "");
	}

	// copied from runelite.
	private static final Pattern WILDCARD_PATTERN = Pattern.compile("(?i)[^*]+|(\\*)");

	private static String generateWildcardMatcher(String pattern)
	{
		final Matcher matcher = WILDCARD_PATTERN.matcher(pattern);
		final StringBuffer buffer = new StringBuffer();

		buffer.append("(?i)");
		while (matcher.find())
		{
			if (matcher.group(1) != null)
			{
				matcher.appendReplacement(buffer, ".*");
			}
			else
			{
				matcher.appendReplacement(buffer, Matcher.quoteReplacement(Pattern.quote(matcher.group(0))));
			}
		}

		matcher.appendTail(buffer);
		return buffer.toString();
	}
}
package com.nyloer;

import java.util.HashMap;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.Text;

import java.awt.Color;


@Slf4j
public class CustomFontConfig
{
	private static final CustomFontConfig INSTANCE = new CustomFontConfig();
	@Getter
	private final HashMap<String, Color> colorSettings = new HashMap<>();

	public Color getColor(String fontConfigKey)
	{
		return colorSettings.get(fontConfigKey);
	}

	public void parse(NyloerConfig config)
	{
		String input = config.customFontConfig();
		if (input == null || input.isEmpty())
		{
			return;
		}
		for (String entry : Text.fromCSV(input))
		{
			try
			{
				String[] parts = entry.split(":");
				colorSettings.put(
					Integer.parseInt(parts[0].trim()) + "-" + parts[1].trim(),
					Color.decode(parts[2].trim())
				);
			}
			catch (Exception e)
			{
				log.debug("Parse exception: \"" + entry + "\"\n" + e.getMessage());
			}
		}
	}

	public static CustomFontConfig getInstance()
	{
		return INSTANCE;
	}
}
package com.nyloer;


import com.nyloer.stats.Stall;
import com.nyloer.stats.Stats;
import java.awt.datatransfer.StringSelection;
import javax.swing.border.TitledBorder;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.LineBorder;
import java.awt.*;


public class NyloerSidePanel extends PluginPanel
{
	private final Client client;
	private final NyloerPlugin plugin;
	private final NyloerConfig config;

	Font tableTitleFont;
	Font buttonFont;
	Font tableFont;
	Font tableHeaderFont;

	JButton buttonMageSwaps;
	JButton buttonRangeSwaps;
	JButton buttonMeleeSwaps;
	JButton buttonCustomSwaps;

	JTable stallsTable;
	DefaultTableModel stallsTableModel;
	JScrollBar stallsTableScrollBar;

	JTable statsTable;
	DefaultTableModel statsTableModel;
	JScrollBar statsTableScrollBar;

	@Inject
	NyloerSidePanel(Client client, NyloerPlugin plugin, NyloerConfig config)
	{
		this.client = client;
		this.config = config;
		this.plugin = plugin;
		this.tableTitleFont = new Font(NyloerFonts.RUNESCAPE.toString(), Font.PLAIN, 16);
		this.buttonFont = new Font(NyloerFonts.DIALOG.toString(), Font.PLAIN, 12);
		this.tableFont = new Font(NyloerFonts.DIALOG.toString(), Font.PLAIN, 12);
		this.tableHeaderFont = new Font(NyloerFonts.DIALOG.toString(), Font.PLAIN, 12);
	}

	public void startPanel()
	{
		getParent().setLayout(new BorderLayout());
		getParent().add(this, BorderLayout.CENTER);
		setLayout(new BorderLayout());
		setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		final JPanel layout = new JPanel();
		BoxLayout boxLayout = new BoxLayout(layout, BoxLayout.Y_AXIS);
		layout.setLayout(boxLayout);
		add(layout, BorderLayout.NORTH);

		layout.add(Box.createRigidArea(new Dimension(0, 15)));
		JPanel swapsFrame = createRoleSwapsFrame();
		layout.add(swapsFrame);

		layout.add(Box.createRigidArea(new Dimension(0, 15)));
		JScrollPane stallsPane = createStallsPane();
		layout.add(stallsPane);

		layout.add(Box.createRigidArea(new Dimension(0, 15)));
		JPanel statsPane = createRecentStatsFrame();
		layout.add(statsPane);
	}

	public void addStall(Stall stall)
	{
		String aliveDisplay = stall.getAliveCount() + "/" + stall.getCapSize();
		stallsTableModel.addRow(new Object[]{stall.getWave(), aliveDisplay, stall.getTotalStalls()});
		stallsTableScrollBar.setValue(stallsTableScrollBar.getMaximum() + 100);
	}

	public void addStats(Stats stats)
	{
		statsTableModel.insertRow(
			0,
			new Object[]{
				stats.totalTime,
				stats.bossTime,
				stats.wavesTime,
				stats.stallCountPre != 0 ? stats.stallCountPre : "",
				stats.stallCount1to12 != 0 ? stats.stallCount1to12 : "",
				stats.stallCount13to19 != 0 ? stats.stallCount13to19 : "",
				stats.stallCount21 != 0 ? stats.stallCount21 : "",
				stats.stallCount22to27 != 0 ? stats.stallCount22to27 : "",
				stats.stallCount28 != 0 ? stats.stallCount28 : "",
				stats.stallCount29 != 0 ? stats.stallCount29 : "",
				stats.stallCount30 != 0 ? stats.stallCount30 : "",
				stats.bigsAlive22 != -1 ? stats.bigsAlive22 : "",
				stats.bigsAlive29 != -1 ? stats.bigsAlive29 : "",
				stats.bigsAlive30 != -1 ? stats.bigsAlive30 : "",
				stats.bigsAlive31 != -1 ? stats.bigsAlive31 : ""
			}
		);
	}

	public void resetStallsTable()
	{
		if (stallsTableModel.getRowCount() > 0)
		{
			for (int i = stallsTableModel.getRowCount() - 1; i > -1; i--)
			{
				stallsTableModel.removeRow(i);
			}
		}
	}

	private JPanel createRoleSwapsFrame()
	{
		JPanel swapsFrame = new JPanel();
		swapsFrame.setLayout(new GridLayout(2, 2));
		TitledBorder border = BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Role Swaps");
		border.setTitleFont(tableTitleFont);
		swapsFrame.setBorder(border);

		buttonMageSwaps = new JButton("Mage");
		buttonRangeSwaps = new JButton("Range");
		buttonMeleeSwaps = new JButton("Melee");
		buttonCustomSwaps = new JButton("Custom");
		buttonMageSwaps.setPreferredSize(new Dimension(40, 40));
		buttonRangeSwaps.setPreferredSize(new Dimension(40, 40));
		buttonMeleeSwaps.setPreferredSize(new Dimension(40, 40));
		buttonCustomSwaps.setPreferredSize(new Dimension(40, 40));
		buttonMageSwaps.setFocusable(false);
		buttonRangeSwaps.setFocusable(false);
		buttonMeleeSwaps.setFocusable(false);
		buttonCustomSwaps.setFocusable(false);
		buttonMageSwaps.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		buttonRangeSwaps.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		buttonMeleeSwaps.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		buttonCustomSwaps.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		buttonMageSwaps.addActionListener(e -> _configureMageSwaps());
		buttonRangeSwaps.addActionListener(e -> _configureRangeSwaps());
		buttonMeleeSwaps.addActionListener(e -> _configureMeleeSwaps());
		buttonCustomSwaps.addActionListener(e -> _configureCustomSwaps());
		swapsFrame.add(buttonMageSwaps);
		swapsFrame.add(buttonMeleeSwaps);
		swapsFrame.add(buttonRangeSwaps);
		swapsFrame.add(buttonCustomSwaps);
		switch (config.previousRole())
		{
			case "mage":
				_configureMageSwaps();
				break;
			case "range":
				_configureRangeSwaps();
				break;
			case "melee":
				_configureMeleeSwaps();
				break;
			case "custom":
				_configureCustomSwaps();
				break;
			default:
				_resetRolesSelection();
		}

		return swapsFrame;
	}

	private JScrollPane createStallsPane()
	{
		stallsTable = new JTable();

		String[] columnNames = {"Wave", "Alive", "Total"};
		stallsTableModel = new DefaultTableModel(columnNames, 0);
		stallsTable.setModel(stallsTableModel);
		stallsTable.getTableHeader().setReorderingAllowed(false);
		stallsTable.setDefaultEditor(Object.class, null);
		stallsTable.setPreferredScrollableViewportSize(new Dimension(0, 325));
		stallsTable.setRowHeight(25);
		stallsTable.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		stallsTable.setFont(tableFont);
		stallsTable.getTableHeader().setFont(tableHeaderFont);
		stallsTable.setRowSelectionAllowed(false);
		stallsTable.setCellSelectionEnabled(false);
		stallsTable.setShowGrid(false);
		stallsTable.setFillsViewportHeight(true);

		DefaultTableCellRenderer cellRenderer = new DefaultTableCellRenderer();
		cellRenderer.setVerticalAlignment(JLabel.CENTER);
		cellRenderer.setHorizontalAlignment(JLabel.CENTER);
		for (int columnIndex = 0; columnIndex < stallsTableModel.getColumnCount(); columnIndex++)
		{
			stallsTable.getColumnModel().getColumn(columnIndex).setCellRenderer(cellRenderer);
		}

		JScrollPane scrollPane = new JScrollPane(
			stallsTable,
			JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
			JScrollPane.HORIZONTAL_SCROLLBAR_NEVER
		);
		TitledBorder border = BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Stalls");
		border.setTitleFont(tableTitleFont);
		scrollPane.setBorder(border);
		scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		stallsTableScrollBar = scrollPane.getVerticalScrollBar();

		return scrollPane;
	}

	private JPanel createRecentStatsFrame()
	{
		JPanel statsFrame = new JPanel();
		BoxLayout boxLayout = new BoxLayout(statsFrame, BoxLayout.Y_AXIS);
		statsFrame.setLayout(boxLayout);
		TitledBorder border = BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Recent Times");
		border.setTitleFont(tableTitleFont);
		statsFrame.setBorder(border);

		statsTable = new JTable();
		String[] columnNames = {"Room", "Boss", "Waves", "Pre", "1-12", "13-19", "21", "22-27", "28", "29", "30", "bigs22", "bigs29", "bigs30", "bigs31"};
		statsTableModel = new DefaultTableModel(columnNames, 0);
		statsTable.setModel(statsTableModel);
		statsTable.getColumnModel().getColumn(0).setPreferredWidth(60);
		statsTable.getColumnModel().getColumn(1).setPreferredWidth(60);
		statsTable.getColumnModel().getColumn(2).setPreferredWidth(60);
		statsTable.getColumnModel().getColumn(3).setPreferredWidth(30);
		statsTable.getColumnModel().getColumn(4).setPreferredWidth(40);
		statsTable.getColumnModel().getColumn(5).setPreferredWidth(40);
		statsTable.getColumnModel().getColumn(6).setPreferredWidth(30);
		statsTable.getColumnModel().getColumn(7).setPreferredWidth(40);
		statsTable.getColumnModel().getColumn(8).setPreferredWidth(30);
		statsTable.getColumnModel().getColumn(9).setPreferredWidth(30);
		statsTable.getColumnModel().getColumn(10).setPreferredWidth(30);
		statsTable.getColumnModel().getColumn(11).setPreferredWidth(40);
		statsTable.getColumnModel().getColumn(12).setPreferredWidth(40);
		statsTable.getColumnModel().getColumn(13).setPreferredWidth(40);
		statsTable.getColumnModel().getColumn(14).setPreferredWidth(40);

		statsTable.getTableHeader().setReorderingAllowed(false);
		statsTable.setDefaultEditor(Object.class, null);
		statsTable.setPreferredScrollableViewportSize(new Dimension(0, 325));
		statsTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
		statsTable.setRowHeight(25);
		statsTable.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		statsTable.setFont(tableFont);
		statsTable.getTableHeader().setFont(tableHeaderFont);
		statsTable.setRowSelectionAllowed(false);
		statsTable.setCellSelectionEnabled(false);
		statsTable.setShowGrid(false);
		statsTable.setFillsViewportHeight(true);

		DefaultTableCellRenderer cellRenderer = new DefaultTableCellRenderer();
		cellRenderer.setVerticalAlignment(JLabel.CENTER);
		cellRenderer.setHorizontalAlignment(JLabel.CENTER);
		for (int columnIndex = 0; columnIndex < statsTableModel.getColumnCount(); columnIndex++)
		{
			statsTable.getColumnModel().getColumn(columnIndex).setCellRenderer(cellRenderer);
		}

		JScrollPane scrollPane = new JScrollPane(
			statsTable,
			JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
			JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS
		);
		scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		statsTableScrollBar = scrollPane.getVerticalScrollBar();
		statsFrame.add(scrollPane);

		JPanel statsButtonFrame = new JPanel();
		statsButtonFrame.setLayout(new GridLayout(1, 2));
		JButton buttonCopyTable = new JButton("Copy");
		JButton buttonClearTable = new JButton("Clear");
		buttonCopyTable.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
		buttonClearTable.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
		buttonCopyTable.setFocusable(false);
		buttonClearTable.setFocusable(false);
		buttonCopyTable.setPreferredSize(new Dimension(40, 25));
		buttonClearTable.setPreferredSize(new Dimension(40, 25));
		buttonCopyTable.setFont(buttonFont);
		buttonClearTable.setFont(buttonFont);
		buttonCopyTable.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		buttonClearTable.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		buttonCopyTable.addActionListener(e -> _copyToClipboard(statsTable));
		buttonClearTable.addActionListener(e -> _resetStatsTable());
		statsButtonFrame.add(buttonCopyTable);
		statsButtonFrame.add(buttonClearTable);
		statsFrame.add(Box.createRigidArea(new Dimension(0, 5)));
		statsFrame.add(statsButtonFrame);

		return statsFrame;
	}

	private void _copyToClipboard(JTable table)
	{
		StringBuffer sbf = new StringBuffer();
		table.selectAll();
		int numCols = table.getSelectedColumnCount();
		int numRows = table.getSelectedRowCount();
		int[] selectedRows = table.getSelectedRows();
		int[] selectsColumns = table.getSelectedColumns();
		table.clearSelection();
		for (int i = 0; i < numCols; i++)
		{
			sbf.append(statsTable.getModel().getColumnName(i));
			sbf.append("\t");
		}
		sbf.append("\n");
		for (int i = 0; i < numRows; i++)
		{
			for (int j = 0; j < numCols; j++)
			{
				sbf.append(table.getValueAt(selectedRows[i], selectsColumns[j]));
				if (j < numCols - 1)
				{
					sbf.append("\t");
				}
			}
			sbf.append("\n");
		}
		StringSelection data = new StringSelection(sbf.toString());
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(data, data);
	}

	private void _resetStatsTable()
	{
		if (statsTableModel.getRowCount() > 0)
		{
			for (int i = statsTableModel.getRowCount() - 1; i > -1; i--)
			{
				statsTableModel.removeRow(i);
			}
		}
	}

	private void _configureMageSwaps()
	{
		NyloerPlugin.log.debug("Configuring mage swaps.");
		String currentRole = plugin.roleSwapper.getCurrentRole();
		_resetRolesSelection();
		if ((currentRole == null) || (!currentRole.equals("mage")))
		{
			config.setPreviousRole("mage");
			plugin.roleSwapper.setCurrentRole("mage");
			plugin.nyloerTileOverlay.setRenderMage(config.mageHighlightMageTiles());
			plugin.nyloerTileOverlay.setRenderRange(config.mageHighlightRangeTiles());
			plugin.nyloerTileOverlay.setRenderMelee(config.mageHighlightMeleeTiles());

			buttonMageSwaps.setForeground(Color.CYAN);
			buttonMageSwaps.setFont(buttonFont);
		}
	}

	private void _configureRangeSwaps()
	{
		NyloerPlugin.log.debug("Configuring range swaps.");
		String currentRole = plugin.roleSwapper.getCurrentRole();
		_resetRolesSelection();
		if ((currentRole == null) || (!currentRole.equals("range")))
		{
			config.setPreviousRole("range");
			plugin.roleSwapper.setCurrentRole("range");
			plugin.nyloerTileOverlay.setRenderMage(config.rangeHighlightMageTiles());
			plugin.nyloerTileOverlay.setRenderRange(config.rangeHighlightRangeTiles());
			plugin.nyloerTileOverlay.setRenderMelee(config.rangeHighlightMeleeTiles());

			buttonRangeSwaps.setForeground(Color.GREEN);
			buttonRangeSwaps.setFont(buttonFont);
		}
	}

	private void _configureMeleeSwaps()
	{
		NyloerPlugin.log.debug("Configuring melee swaps.");
		String currentRole = plugin.roleSwapper.getCurrentRole();
		_resetRolesSelection();
		if ((currentRole == null) || (!currentRole.equals("melee")))
		{
			config.setPreviousRole("melee");
			plugin.roleSwapper.setCurrentRole("melee");
			plugin.nyloerTileOverlay.setRenderMage(config.meleeHighlightMageTiles());
			plugin.nyloerTileOverlay.setRenderRange(config.meleeHighlightRangeTiles());
			plugin.nyloerTileOverlay.setRenderMelee(config.meleeHighlightMeleeTiles());

			buttonMeleeSwaps.setForeground(Color.WHITE);
			buttonMeleeSwaps.setFont(buttonFont);
		}
	}

	private void _configureCustomSwaps()
	{
		NyloerPlugin.log.debug("Configured custom role swaps.");
		String currentRole = plugin.roleSwapper.getCurrentRole();
		_resetRolesSelection();
		if ((currentRole == null) || (!currentRole.equals("custom")))
		{
			config.setPreviousRole("custom");
			plugin.roleSwapper.setCurrentRole("custom");
			plugin.nyloerTileOverlay.setRenderMage(config.customHighlightMageTiles());
			plugin.nyloerTileOverlay.setRenderRange(config.customHighlightRangeTiles());
			plugin.nyloerTileOverlay.setRenderMelee(config.customHighlightMeleeTiles());

			buttonCustomSwaps.setForeground(Color.MAGENTA);
			buttonCustomSwaps.setFont(buttonFont);
		}
	}

	private void _resetRolesSelection()
	{
		config.setPreviousRole("");
		plugin.roleSwapper.setCurrentRole(null);

		plugin.nyloerTileOverlay.setRenderMage(false);
		plugin.nyloerTileOverlay.setRenderRange(false);
		plugin.nyloerTileOverlay.setRenderMelee(false);

		buttonMageSwaps.setForeground(Color.GRAY);
		buttonRangeSwaps.setForeground(Color.GRAY);
		buttonMeleeSwaps.setForeground(Color.GRAY);
		buttonCustomSwaps.setForeground(Color.GRAY);
		buttonMageSwaps.setFont(buttonFont);
		buttonRangeSwaps.setFont(buttonFont);
		buttonMeleeSwaps.setFont(buttonFont);
		buttonCustomSwaps.setFont(buttonFont);
	}
}
