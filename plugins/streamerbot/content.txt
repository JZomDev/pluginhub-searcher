package streamerbot.triggers;


import com.google.gson.Gson;
import streamerbot.StreamerbotConfig;
import streamerbot.messaging.TriggerHandler;
import streamerbot.util.StringToIntAdapter;
import lombok.extern.slf4j.Slf4j;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;

@Slf4j
public abstract class BaseTrigger {
    protected Gson gson;

    @Inject
    void init(Gson gson) {
        this.gson = gson.newBuilder()
                .registerTypeAdapter(Integer.class, new StringToIntAdapter())
                .registerTypeAdapter(int.class, new StringToIntAdapter())
                .create();
    }

    @Inject
    protected ConfigManager configManager;

    @Inject
    protected StreamerbotConfig config;

    @Inject
    protected Client client;

    @Inject
    private TriggerHandler triggerHandler;

    protected void sendRequest(String json) {
        triggerHandler.sendJson(json);
    }
}

package streamerbot.triggers;

import com.google.gson.JsonSyntaxException;
import streamerbot.SettingsManager;
import streamerbot.dinkdata.*;
import streamerbot.dinkdata.DinkNotificationData;
import streamerbot.dinkdata.DinkNotificationType;
import streamerbot.messaging.DoActionRequest;
import net.runelite.client.events.PluginMessage;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import javax.inject.Singleton;
import java.util.Map;

@Slf4j
@Singleton
public class DinkRequestTrigger extends BaseTrigger {

    private static final String DINK_KEY = "dinkplugin";

    public void onPluginMessage(PluginMessage pluginMessage)  {
        if (!pluginMessage.getNamespace().equals(DINK_KEY)) {
            return;
        }

        DinkNotificationType notificationType = DinkNotificationType.fromName(pluginMessage.getName());

        if (notificationType == DinkNotificationType.UNKNOWN) {
            return;
        }

        boolean enabled = configManager.getConfiguration(SettingsManager.CONFIG_GROUP, notificationType.getEnabledKey(), boolean.class);
        String actionName = configManager.getConfiguration(SettingsManager.CONFIG_GROUP, notificationType.getActionKey(), String.class);

        if (!enabled ||  StringUtils.isBlank(actionName)) {
            log.debug("Notification type {} is disabled, returning", notificationType.getType());
            return;
        }

        Map<String, Object> data = pluginMessage.getData();

        Class<? extends DinkNotificationData> clazz = notificationType.getDataClass();
        DinkNotificationData input;

        try {
            input = gson.fromJson(gson.toJsonTree(data), clazz);
        } catch (JsonSyntaxException e) {
            log.warn("Failed to parse Dink death notification: {}", data, e);
            return;
        }

        Map<String, Object> args = input.sanitized(gson);
        DoActionRequest request = new DoActionRequest(actionName,  args);
        String json = gson.toJson(request);
        sendRequest(json);
    }
}


package streamerbot;
import com.google.inject.Provides;
import javax.inject.Inject;

import streamerbot.triggers.DinkRequestTrigger;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PluginMessage;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.util.ColorUtil;

import java.awt.*;


@Slf4j
@PluginDescriptor(
        name = "Streamerbot",
        description = "Lets in-game events trigger Streamerbot actions. <br/>"
                + "Requires the use of the Streamerbot application and Dink plugin",
        tags = {"streamer", "notifier", "trigger", "OBS", "Streamerbot", "Twitch", "Dink"}
)

public class StreamerbotPlugin extends Plugin {
    @Inject
    private ChatMessageManager chatManager;

    @Inject
    private Client client;

    @Inject
    private StreamerbotConfig config;

    @Inject
    private DinkRequestTrigger dinkRequestTrigger;

    @Inject
    private SettingsManager settingsManager;

    @Override
    protected void startUp() {
        log.info("Streamerbot started!");
    }

    @Override
    protected void shutDown()
    {
        log.info("Streamerbot stopped!");
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged) {
        if(!configChanged.getGroup().equals(SettingsManager.CONFIG_GROUP)) {
            return;
        }

        settingsManager.onConfigChanged(configChanged);
    }

    @Subscribe
    public void onPluginMessage(PluginMessage pluginMessage) {
        dinkRequestTrigger.onPluginMessage(pluginMessage);
    }

    private final static Color CYAN = ColorUtil.fromHex("#00c7ff");
    private final static Color RED = ColorUtil.fromHex("#ca2a2d");


    public void queueMessage(String formatted) {
        chatManager.queue(
        QueuedMessage.builder()
                .type(ChatMessageType.CONSOLE)
                .runeLiteFormattedMessage(formatted)
                .build()
        );
    }

    public void addChatWarning(String message) {
        String formatted = String.format("[%s] %s: %s",
                ColorUtil.wrapWithColorTag(getName(), CYAN),
                "Warning",
                ColorUtil.wrapWithColorTag(message, RED)
        );

        queueMessage(formatted);
    }

    public void addChatNotice(String message) {
        String formatted = String.format("[%s] %s: %s",
                ColorUtil.wrapWithColorTag(getName(), CYAN),
                "Notice",
                message
        );

        queueMessage(formatted);
    }

    @Provides
    StreamerbotConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(StreamerbotConfig.class);
    }
}

package streamerbot;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@SuppressWarnings("CyclomaticComplexityInspection")
@ConfigGroup(SettingsManager.CONFIG_GROUP)
public interface StreamerbotConfig extends Config {
    @ConfigItem(
            keyName = "streamerbotAddress",
            name = "Streamerbot address",
            description = "The address of the HTTP server that your Streamerbot instance is running and this plugin will send requests to. <br/>"
            + "Leave this as default, unless you have your Streamerbot server configured differently",
            position = 0
    )

    default String streamerbotAddress() {
        return "http://127.0.0.1:7474";
    }

    @ConfigItem(
            keyName = "warningsEnabled",
            name = "Configuration warnings",
            description = "Receive warnings about incomplete setup. <br/>"
            + "This serves as a gentle reminder while setting up this plugin.",
            position = 1
    )

    default boolean warningsEnabled() {
        return true;
    }


    @ConfigSection(
            name = "Dink notifications",
            description = "Settings for triggering Streamerbot actions upon Dink notifications",
            position = 2,
            closedByDefault = true
    )

    String dinkNotificationSection = "Dink notifications";

    @ConfigItem(
            keyName = SettingsManager.COLLECTION_LOG_ENABLED,
            name = "Enable collection log",
            description = "Trigger an action in Streamerbot when Dink fires a collection log notification",
            position = 3,
            section = dinkNotificationSection
    )

    default boolean collectionLogEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.COLLECTION_LOG_ACTION_NAME,
            name = "Collection log action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink collection log notification",
            position= 4,
            section = dinkNotificationSection
    )

    default String collectionLogActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.PETS_ENABLED,
            name = "Enable pets",
            description = "Trigger an action in Streamerbot when Dink fires a pet notification",
            position = 5,
            section = dinkNotificationSection
    )

    default boolean petsEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.PET_ACTION_NAME,
            name = "Pet action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink pet notification",
            position = 6,
            section = dinkNotificationSection
    )

    default String petActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.LEVEL_ENABLED,
            name = "Enable level",
            description = "Trigger an action in Streamerbot when Dink fires a level notification",
            position = 7,
            section = dinkNotificationSection
    )

    default boolean levelEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.LEVEL_ACTION_NAME,
            name = "Level action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink level notification",
            position = 8,
            section = dinkNotificationSection
    )

    default String levelActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.LOOT_ENABLED,
            name = "Enable loot",
            description = "Trigger an action in Streamerbot when Dink fires a loot notification",
            position = 9,
            section = dinkNotificationSection
    )

    default boolean lootEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.LOOT_ACTION_NAME,
            name = "Loot action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink loot notification",
            position = 10,
            section = dinkNotificationSection
    )

    default String lootActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.DEATH_ENABLED,
            name = "Enable death",
            description = "Trigger an action in Streamerbot when Dink fires a death notification",
            position = 11,
            section = dinkNotificationSection
    )

    default boolean deathEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.DEATH_ACTION_NAME,
            name = "Death action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink death notification",
            position = 12,
            section = dinkNotificationSection
    )

    default String deathActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.SLAYER_ENABLED,
            name = "Enable slayer",
            description = "Trigger an action in Streamerbot when Dink fires a slayer notification",
            position = 13,
            section = dinkNotificationSection
    )

    default boolean slayerEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.SLAYER_ACTION_NAME,
            name = "Slayer action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink slayer notification",
            position = 14,
            section = dinkNotificationSection
    )

    default String slayerActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.QUESTS_ENABLED,
            name = "Enable quests",
            description = "Trigger an action in Streamerbot when Dink fires a quest notification",
            position = 15,
            section = dinkNotificationSection
    )

    default boolean questsEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.QUEST_ACTION_NAME,
            name = "Quest action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink quest notification",
            position = 16,
            section = dinkNotificationSection
    )

    default String questActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.CLUES_ENABLED,
            name = "Enable clue scrolls",
            description = "Trigger an action in Streamerbot when Dink fires a clue notification",
            position = 17,
            section = dinkNotificationSection
    )

    default boolean cluesEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.CLUE_ACTION_NAME,
            name = "Clue action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink clue notification",
            position = 18,
            section = dinkNotificationSection
    )

    default String clueActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.SPEEDRUNS_ENABLED,
            name = "Enable speedruns",
            description = "Trigger an action in Streamerbot when Dink fires a quest speedrun notification",
            position = 19,
            section = dinkNotificationSection
    )

    default boolean speedrunsEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.SPEEDRUN_ACTION_NAME,
            name = "Speedrun action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink quest speedrun notification",
            position = 20,
            section = dinkNotificationSection
    )

    default String speedrunActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.KILL_COUNT_ENABLED,
            name = "Enable kill count",
            description = "Trigger an action in Streamerbot when Dink fires a kill count notification",
            position = 21,
            section = dinkNotificationSection
    )

    default boolean killCountEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.KILL_COUNT_ACTION_NAME,
            name = "Kill count action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink kill count notification",
            position = 22,
            section = dinkNotificationSection
    )

    default String killCountActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.COMBAT_TASK_ENABLED,
            name = "Enable combat tasks",
            description = "Trigger an action in Streamerbot when Dink fires a combat task notification",
            position = 23,
            section = dinkNotificationSection
    )

    default boolean combatTaskEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.COMBAT_TASK_ACTION_NAME,
            name = "Combat task action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink combat task notification",
            position = 24,
            section = dinkNotificationSection
    )

    default String combatTaskActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.DIARY_ENABLED,
            name = "Enable diary",
            description = "Trigger an action in Streamerbot when Dink fires a achievement diary notification",
            position = 25,
            section = dinkNotificationSection
    )

    default boolean diaryEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.DIARY_ACTION_NAME,
            name = "Diary action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink diary notification",
            position = 26,
            section = dinkNotificationSection
    )

    default String diaryActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.GAMBLE_ENABLED,
            name = "Enable BA gamble",
            description = "Trigger an action in Streamerbot when Dink fires a BA gamble notification",
            position = 27,
            section = dinkNotificationSection
    )

    default boolean gambleEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.GAMBLE_ACTION_NAME,
            name = "BA gamble action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink BA gamble notification",
            position = 28,
            section = dinkNotificationSection
    )

    default String gambleActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.PLAYER_KILLS_ENABLED,
            name = "Enable player kills",
            description = "Trigger an action in Streamerbot when Dink fires a player kill notification",
            position = 29,
            section = dinkNotificationSection
    )

    default boolean playerKillsEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.PLAYER_KILL_ACTION_NAME,
            name = "Player kill action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink player kill notification",
            position = 30,
            section = dinkNotificationSection
    )

    default String playerKillActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.GROUP_STORAGE_ENABLED,
            name = "Enable group storage",
            description = "Trigger an action in Streamerbot when Dink fires a group storage transaction notification",
            position = 31,
            section = dinkNotificationSection
    )

    default boolean Enabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.GROUP_STORAGE_ACTION_NAME,
            name = "Group storage action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink group storage transaction notification",
            position = 32,
            section = dinkNotificationSection
    )

    default String groupStorageActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.GRAND_EXCHANGE_ENABLED,
            name = "Enable GE transactions",
            description = "Trigger an action in Streamerbot when Dink fires a Grand Exchange transaction notification",
            position = 33,
            section = dinkNotificationSection
    )

    default boolean grandExchangeEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.GRAND_EXCHANGE_ACTION_NAME,
            name = "GE transaction action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink Grand Exchange transaction notification",
            position = 34,
            section = dinkNotificationSection
    )

    default String grandExchangeActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.TRADES_ENABLED,
            name = "Enable trades",
            description = "Trigger an action in Streamerbot when Dink fires a trade notification",
            position = 35,
            section = dinkNotificationSection
    )

    default boolean tradesEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.TRADES_ACTION_NAME,
            name = "Trades action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink trade notification",
            position = 36,
            section = dinkNotificationSection
    )

    default String tradesActionName() {
        return "";
    }



    @ConfigItem(
            keyName = SettingsManager.CUSTOM_CHAT_ENABLED,
            name = "Enable custom chat",
            description = "Trigger an action in Streamerbot when Dink fires a custom chat notification",
            position = 37,
            section = dinkNotificationSection
    )

    default boolean customChatEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.CUSTOM_CHAT_ACTION_NAME,
            name = "Custom chat action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink custom chat notification",
            position = 38,
            section = dinkNotificationSection
    )

    default String customChatActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.EXTERNAL_PLUGIN_REQUESTS_ENABLED,
            name = "Enable external plugin requests",
            description = "Trigger an action in Streamerbot when Dink fires an external plugin notification",
            position = 39,
            section = dinkNotificationSection
    )

    default boolean externalPluginRequestsEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.EXTERNAL_REQUEST_ACTION_NAME,
            name = "External request action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink external plugin notification",
            position = 40,
            section = dinkNotificationSection
    )

    default String externalRequestActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.LEAGUES_ENABLED,
            name = "Enable leagues notifications",
            description = "Trigger an action in Streamerbot when Dink fires a notification for <br/>" +
                    "leagues area unlock, combat mastery unlock, relic unlock, task completion or trophy unlock",
            position = 41,
            section = dinkNotificationSection

    )

    default boolean leaguesEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.LEAGUES_ACTION_NAME,
            name = "Leagues action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink leagues notification",
            position = 42,
            section = dinkNotificationSection
    )

    default String leaguesActionName() {
        return "";
    }

    @ConfigItem(
            keyName = SettingsManager.META_NOTIFIER_ENABLED,
            name = "Enable meta notifications",
            description = "Trigger an action in Streamerbot when Dink fires login, logout and ToA purple notification <br/>" +
                    "Note: To use this notifier, Dink's 'Custom Metadata Handler' setting in the 'Advanced' section must contain some URL",
            position = 43,
            section = dinkNotificationSection
    )

    default boolean metaNotifierEnabled() {
        return false;
    }

    @ConfigItem(
            keyName = SettingsManager.META_NOTIFIER_ACTION_NAME,
            name = "Meta notifier action name",
            description = "The exact name of the action to trigger in Streamerbot upon a Dink notification",
            position = 44,
            section = dinkNotificationSection
    )

    default String metaNotifierActionName() {
        return "";
    }
}

package streamerbot.util;
import com.google.gson.Gson;

import java.util.Map;

public interface Sanitizable {

   Map<String, Object> sanitized(Gson gson);
}

package streamerbot.util;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;

import java.io.IOException;

public class StringToIntAdapter extends TypeAdapter<Integer> {
    @Override
    public void write(JsonWriter out, Integer value) throws IOException {
        out.value(value);
    }

    @Override
    public Integer read(JsonReader in) throws IOException {
        if (in.peek() == JsonToken.NULL) {
            in.nextNull();
            return null;
        }

        String stringValue = in.nextString();
        try {
            return Integer.parseInt(stringValue);
        } catch (NumberFormatException e) {
            return 0;
        }
    }
}

package streamerbot;

import streamerbot.dinkdata.DinkNotificationType;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.externalplugins.ExternalPluginManager;
import org.apache.commons.lang3.StringUtils;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.List;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = { @Inject })
public class SettingsManager {
    private final StreamerbotPlugin plugin;
    private final StreamerbotConfig config;
    private final ExternalPluginManager externalPluginManager;
    private final ConfigManager configManager;
    private final Client client;


    public static final String CONFIG_GROUP = "streamerbotplugin";

    public static final String COLLECTION_LOG_ENABLED = "collectionLogEnabled";
    public static final String COLLECTION_LOG_ACTION_NAME = "collectionLogActionName";
    public static final String PETS_ENABLED = "petEnabled";
    public static final String PET_ACTION_NAME = "petActionName";
    public static final String LEVEL_ENABLED = "levelEnabled";
    public static final String LEVEL_ACTION_NAME = "levelActionName";
    public static final String LOOT_ENABLED = "lootEnabled";
    public static final String LOOT_ACTION_NAME = "lootActionName";
    public static final String DEATH_ENABLED = "deathEnabled";
    public static final String DEATH_ACTION_NAME = "deathActionName";
    public static final String SLAYER_ENABLED = "slayerEnabled";
    public static final String SLAYER_ACTION_NAME = "slayerActionName";
    public static final String QUESTS_ENABLED = "questEnabled";
    public static final String QUEST_ACTION_NAME = "questActionName";
    public static final String CLUES_ENABLED = "clueEnabled";
    public static final String CLUE_ACTION_NAME = "clueActionName";
    public static final String SPEEDRUNS_ENABLED = "speedrunEnabled";
    public static final String SPEEDRUN_ACTION_NAME = "speedrunActionName";
    public static final String KILL_COUNT_ENABLED = "killCountEnabled";
    public static final String KILL_COUNT_ACTION_NAME = "killCountActionName";
    public static final String COMBAT_TASK_ENABLED = "combatTaskEnabled";
    public static final String COMBAT_TASK_ACTION_NAME = "combatTaskActionName";
    public static final String DIARY_ENABLED = "diaryEnabled";
    public static final String DIARY_ACTION_NAME = "diaryActionName";
    public static final String GAMBLE_ENABLED = "gambleEnabled";
    public static final String GAMBLE_ACTION_NAME = "gambleActionName";
    public static final String PLAYER_KILLS_ENABLED = "pkEnabled";
    public static final String PLAYER_KILL_ACTION_NAME = "playerKillActionName";
    public static final String GROUP_STORAGE_ENABLED = "groupStorageEnabled";
    public static final String GROUP_STORAGE_ACTION_NAME = "groupStorageActionName";
    public static final String GRAND_EXCHANGE_ENABLED = "notifyGrandExchange";
    public static final String GRAND_EXCHANGE_ACTION_NAME = "grandExchangeActionName";
    public static final String TRADES_ENABLED = "notifyTrades";
    public static final String TRADES_ACTION_NAME = "tradesActionName";
    public static final String CUSTOM_CHAT_ENABLED = "notifyChat";
    public static final String CUSTOM_CHAT_ACTION_NAME = "customChatActionName";
    public static final String EXTERNAL_PLUGIN_REQUESTS_ENABLED = "notifyExternal";
    public static final String EXTERNAL_REQUEST_ACTION_NAME = "externalRequestActionName";
    public static final String LEAGUES_ENABLED = "notifyLeagues";
    public static final String LEAGUES_ACTION_NAME = "leaguesActionName";
    public static final String META_NOTIFIER_ENABLED = "metaNotifierEnabled";
    public static final String META_NOTIFIER_ACTION_NAME = "metaNotifierActionName";

    public static final String DINK_PLUGIN_NAME = "dink";
    public static final String DINK_CONFIG_GROUP = "dinkplugin";
    public static final String RUNELITE_CONFIG_GROUP = "runelite";
    public static final String DINK_METADATA_WEBHOOK_KEY = "metadataWebhook";

    private static final String DINK_NOT_INSTALLED_WARNING = "Dink plugin must be installed and configured.";
    private static final String DINK_DISABLED_WARNING = "Dink plugin must be enabled and configured.";
    private static final String DINK_META_DISABLED_WARNING = "To use this trigger, Dink's 'Custom Metadata Handler" +
             " field in 'Advanced' must be not blank.";
    private static final String DINK_NOTIFIER_NOTICE = "The corresponding Dink notifier has been enabled. " +
            "To set the conditions of this notifier, go to the corresponding notifier's settings in Dink.";

    void checkDinkAndWarn(String key) {
        List<String> plugins = externalPluginManager.getInstalledExternalPlugins();
        if (!plugins.contains(DINK_PLUGIN_NAME)) {
            plugin.addChatWarning(DINK_NOT_INSTALLED_WARNING);
            return;
        }

        boolean dinkEnabled = configManager.getConfiguration(RUNELITE_CONFIG_GROUP, DINK_CONFIG_GROUP, boolean.class);
        if (!dinkEnabled) {
            plugin.addChatWarning(DINK_DISABLED_WARNING);
        }

        if (key.equals(META_NOTIFIER_ENABLED)) {
            checkMetaAndWarn();
        } else {
            checkAndSetNotifier(key);
        }
    }

    /**
     * This approach relies on our key names matching those of Dink plugin.
     */

    void checkAndSetNotifier(String key) {
        String notifierEnabled = configManager.getConfiguration(DINK_CONFIG_GROUP, key);
        if("false".equals(notifierEnabled)) { // notifierEnabled should not be null, but this avoids the null just in case
            configManager.setConfiguration(DINK_CONFIG_GROUP, key, true);
            plugin.addChatNotice(DINK_NOTIFIER_NOTICE);
        }
    }

    void checkMetaAndWarn() {
        String dinkMetadataWebhook = configManager.getConfiguration(DINK_CONFIG_GROUP, DINK_METADATA_WEBHOOK_KEY, String.class);
        if (StringUtils.isBlank(dinkMetadataWebhook)) {
            plugin.addChatWarning(DINK_META_DISABLED_WARNING);
        }
    }

    public void onConfigChanged(ConfigChanged configChanged) {
        String key = configChanged.getKey();
        String value = configChanged.getNewValue();

        if (DinkNotificationType.existsWithEnabledKey(key) && "true".equals(value) && config.warningsEnabled() && client.getGameState() == GameState.LOGGED_IN) {
            checkDinkAndWarn(key);
        }
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.EqualsAndHashCode;
import lombok.Data;

import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkCombatAchievementNotificationData extends DinkNotificationData {
    String tier;
    String task;
    int taskPoints;
    int totalPoints;
    int tierProgress = 0;
    int tierTotalPoints = 0;
    int totalPossiblePoints;
    String currentTier = "N/A";
    String nextTier = "N/A";
    String justCompletedTier = "N/A";

    public DinkCombatAchievementNotificationData() {
        super(DinkNotificationType.COMBAT_ACHIEVEMENT);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("tier", tier);
        map.put("task", task);
        map.put("taskPoints", taskPoints);
        map.put("totalPoints", totalPoints);
        map.put("tierProgress", tierProgress);
        map.put("tierTotalPoints", tierTotalPoints);
        map.put("totalPossiblePoints", totalPossiblePoints);
        map.put("currentTier", currentTier);
        map.put("nextTier", nextTier);
        map.put("justCompletedTier", justCompletedTier);

        return map;
    }
}

package streamerbot.dinkdata;

import lombok.Data;

@Data
public class Progress {
    int completed;
    int total;

    public Progress() {
        this.completed = 0;
        this.total = 0;
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkDiaryNotificationData extends DinkNotificationData {
    String area;
    String difficulty;
    int total;
    int tasksCompleted;
    int tasksTotal;
    int areaTasksCompleted;
    int areaTasksTotal;

    public DinkDiaryNotificationData() {
        super(DinkNotificationType.ACHIEVEMENT_DIARY);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("area", area);
        map.put("difficulty", difficulty);
        map.put("total", total);
        map.put("tasksCompleted", tasksCompleted);
        map.put("tasksTotal", tasksTotal);
        map.put("areaTasksCompleted", areaTasksCompleted);
        map.put("areaTasksTotal", areaTasksTotal);

        return map;
    }
}

package streamerbot.dinkdata;

public enum LootCriteria {
    ALLOWLIST,
    DENYLIST,
    VALUE,
    RARITY
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkLeaguesRelicNotificationData extends DinkNotificationData {
    String relic;
    int tier;
    int requiredPoints;
    int totalPoints;
    int pointsUntilNextTier = 0;

    public DinkLeaguesRelicNotificationData() {
        super(DinkNotificationType.LEAGUES_RELIC);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("relic", relic);
        map.put("tier", tier);
        map.put("requiredPoints", requiredPoints);
        map.put("totalPoints", totalPoints);
        map.put("pointsUntilNextTier", pointsUntilNextTier);

        return map;
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkPetNotificationData extends DinkNotificationData {
    String petName = "N/A";
    String milestone = "N/A";
    boolean duplicate;
    boolean previouslyOwned = true; //defaults to true unless collection log notification happens in game
    Double rarity = 0.0;
    int estimatedActions = 0;
    Double luck = 0.0;


    public DinkPetNotificationData() {
        super(DinkNotificationType.PET);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("petName", petName);
        map.put("milestone", milestone);
        map.put("duplicate", duplicate);
        map.put("previouslyOwned", previouslyOwned);
        map.put("rarity", rarity);
        map.put("estimatedActions", estimatedActions);
        map.put("luck", luck);

        return map;
    }
}

package streamerbot.dinkdata;

import lombok.Data;

@Data
public class Pet {
    int itemId;
    String name;
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;


@EqualsAndHashCode(callSuper = true)
@Data
public class DinkDeathNotificationData extends DinkNotificationData {

    long valueLost = 0;
    boolean isPvp = false;
    String killerName = "N/A";
    int killerNpcId = 0;
    Collection<Item> keptItems = Collections.emptySet();
    Collection<Item> lostItems = Collections.emptySet();
    Region location;

    public DinkDeathNotificationData() {
        super(DinkNotificationType.DEATH);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("valueLost", valueLost);
        map.put("isPvp", isPvp);
        map.put("killerName", killerName);
        map.put("killerNpcId", killerNpcId);
        map.put("keptItems", gson.toJson(keptItems));
        map.put("lostItems", gson.toJson(lostItems));
        map.put("location", gson.toJson(location));

        return map;
    }
}
package streamerbot.dinkdata;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.EnumSet;

@EqualsAndHashCode(callSuper = true)
@Data
public class AnnotatedItem extends Item {
    EnumSet<LootCriteria> criteria;
    Double rarity;

    public AnnotatedItem() {
        this.criteria = EnumSet.noneOf(LootCriteria.class);
        this.rarity = 0.0;
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.List;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkTradeNotificationData extends DinkNotificationData {
    String counterparty;
    List<Item> receivedItems;
    List<Item> givenItems;
    long receivedValue;
    long givenValue;

    public DinkTradeNotificationData() {
        super(DinkNotificationType.TRADE);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("counterparty", counterparty);
        map.put("receivedItems", gson.toJson(receivedItems));
        map.put("givenItems", gson.toJson(givenItems));
        map.put("receivedValue", receivedValue);
        map.put("givenValue", givenValue);

        return map;
    }
}

package streamerbot.dinkdata;
import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.HashMap;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkNotificationData extends NotificationData {
    DinkNotificationType notificationType;
    String playerName;
    String accountType;
    String plainText = "N/A";

    public DinkNotificationData() {
    }

    protected DinkNotificationData(DinkNotificationType notificationType) {
        this.notificationType = notificationType;
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = new HashMap<>();
        map.put("notificationType", notificationType);
        map.put("playerName", playerName);
        map.put("accountType", accountType);
        map.put("plainText", plainText);
        return map;
    }
}
package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.EqualsAndHashCode;
import lombok.Data;
import net.runelite.api.GrandExchangeOfferState;

import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkGrandExchangeNotificationData extends DinkNotificationData {
    int slot;
    GrandExchangeOfferState status;
    Item item;
    long marketPrice;
    long targetPrice;
    int targetQuantity;
    long sellerTax = 0;

    public DinkGrandExchangeNotificationData() {
        super(DinkNotificationType.GRAND_EXCHANGE);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("slot", slot);
        map.put("status", gson.toJson(status));
        map.put("item", gson.toJson(item));
        map.put("marketPrice", marketPrice);
        map.put("targetPrice", targetPrice);
        map.put("targetQuantity", targetQuantity);
        map.put("sellerTax", sellerTax);

        return map;
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkLevelNotificationData extends DinkNotificationData {
    Map<String, Integer> levelledSkills;
    Map<String, Integer> allSkills;
    CombatLevel combatLevel;

    public DinkLevelNotificationData() {
        super(DinkNotificationType.LEVEL);
    }

    @Data
    public static class CombatLevel {
        int value;
        boolean increased;
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("levelledSkills", gson.toJson(levelledSkills));
        map.put("allSkills", gson.toJson(allSkills));
        map.put("combatLevel", gson.toJson(combatLevel));
        
        return map;
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkSlayerNotificationData extends DinkNotificationData {
    String slayerTask;
    int slayerCompleted;
    int slayerPoints;
    int killCount = 0;
    String monster = "N/A";

    public DinkSlayerNotificationData() {
        super(DinkNotificationType.SLAYER);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("slayerTask", slayerTask);
        map.put("slayerCompleted", slayerCompleted);
        map.put("slayerPoints", slayerPoints);
        map.put("killCount", killCount);
        map.put("monster", monster);

        return map;
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Map;


@EqualsAndHashCode(callSuper = true, doNotUseGetters = true)
@Data
public class DinkSpeedrunNotificationData extends DinkNotificationData {
    String questName;
    String personalBest;
    String currentTime;
    boolean isPersonalBest;

    public DinkSpeedrunNotificationData() {
        super(DinkNotificationType.SPEEDRUN);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("questName", questName);
        map.put("personalBest", personalBest);
        map.put("currentTime", currentTime);
        map.put("isPersonalBest", isPersonalBest);

        return map;
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkLeaguesTaskNotificationData extends DinkNotificationData {
    String taskName;
    String difficulty;
    int taskPoints;
    int totalPoints;
    int tasksCompleted;

    int tasksUntilNextArea = 0;
    int pointsUntilNextRelic = 0;
    int pointsUntilNextTrophy = 0;
    String earnedTrophy = "N/A";

    public DinkLeaguesTaskNotificationData() {
        super(DinkNotificationType.LEAGUES_TASK);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("taskName", taskName);
        map.put("difficulty", difficulty);
        map.put("taskPoints", taskPoints);
        map.put("totalPoints", totalPoints);
        map.put("tasksCompleted", tasksCompleted);
        map.put("tasksUntilNextArea", tasksUntilNextArea);
        map.put("pointsUntilNextRelic", pointsUntilNextRelic);
        map.put("pointsUntilNextTrophy", pointsUntilNextTrophy);
        map.put("earnedTrophy", earnedTrophy);

        return map;
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Collection;
import java.util.Collections;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkLootNotificationData extends DinkNotificationData {
    Collection<AnnotatedItem> items;
    String source;
    String category;
    int killCount = 0;
    Double rarestProbability = 0.0;
    Collection<String> party = Collections.emptySet();
    int npcId = 0;

    public DinkLootNotificationData() {
        super(DinkNotificationType.LOOT);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("items", gson.toJson(items));
        map.put("source", source);
        map.put("category", category);
        map.put("killCount", killCount);
        map.put("rarestProbability", rarestProbability);
        map.put("party", gson.toJson(party));
        map.put("npcId", npcId);

        return map;
    }
}
package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.List;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkGambleNotificationData extends DinkNotificationData {
    int gambleCount;
    List<Item> items;

    public DinkGambleNotificationData() {
        super(DinkNotificationType.BARBARIAN_ASSAULT_GAMBLE);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("gambleCount", gambleCount);
        map.put("items", gson.toJson(items));

        return map;
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Collection;
import java.util.Collections;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkBossNotificationData extends DinkNotificationData {
    String boss;
    int count;
    String gameMessage;
    String time;
    Boolean isPersonalBest;
    String personalBest = "N/A";
    Collection<String> party = Collections.emptySet();

    public DinkBossNotificationData() {
        super(DinkNotificationType.KILL_COUNT);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("boss", boss);
        map.put("count", count);
        map.put("gameMessage", gameMessage);
        map.put("time", time);
        map.put("isPersonalBest", isPersonalBest);
        map.put("personalBest", personalBest);
        map.put("party", gson.toJson(party));

        return map;
    }
}



package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkLeaguesMasteryNotificationData extends DinkNotificationData {
    String masteryType;
    int masteryTier;

    public DinkLeaguesMasteryNotificationData() {
        super(DinkNotificationType.LEAGUES_MASTERY);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("masteryType", masteryType);
        map.put("masteryTier", masteryTier);

        return map;
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Collections;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkExternalNotificationData extends DinkNotificationData {
    String sourcePlugin;
    Map<String, Object> metadata = Collections.emptyMap();

    public DinkExternalNotificationData() {
        super(DinkNotificationType.EXTERNAL_PLUGIN);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("sourcePlugin", sourcePlugin);
        map.put("metadata", gson.toJson(metadata));

        return map;
    }
}

package streamerbot.dinkdata;

import streamerbot.util.Sanitizable;

public abstract class NotificationData implements Sanitizable {

}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Collection;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkXpNotificationData extends DinkNotificationData {
    Map<String, Integer> xpData;
    Collection<String> milestoneAchieved;
    int interval;

    public DinkXpNotificationData() {
        super(DinkNotificationType.XP_MILESTONE);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("xpData", gson.toJson(xpData));
        map.put("milestoneAchieved", gson.toJson((milestoneAchieved)));
        map.put("interval",interval);

        return map;
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkCollectionNotificationData extends DinkNotificationData {
    String itemName;
    int itemId = 0;
    long price = 0;
    int completedEntries = 0;
    int totalEntries = 0;
    String currentRank = "N/A";
    int rankProgress = 0;
    int logsNeededForNextRank = 0;
    String nextRank = "N/A";
    String justCompletedRank = "N/A";
    String dropperName = "N/A";
    String dropperType = "N/A";
    int dropperKillCount = 0;
    Double dropRate = 0.0;

    public DinkCollectionNotificationData() {
        super(DinkNotificationType.COLLECTION);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("itemName", itemName);
        map.put("itemId", itemId);
        map.put("price", price);
        map.put("completedEntries", completedEntries);
        map.put("totalEntries", totalEntries);
        map.put("currentRank", currentRank);
        map.put("rankProgress", rankProgress);
        map.put("logsNeededForNextRank", logsNeededForNextRank);
        map.put("nextRank", nextRank);
        map.put("justCompletedRank", justCompletedRank);
        map.put("dropperName", dropperName);
        map.put("dropperType", dropperType);
        map.put("dropperKillCount", dropperKillCount);
        map.put("dropRate", dropRate);

        return map;
    }
}
package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;
import java.util.Collections;
import java.util.List;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkLoginNotificationData extends DinkNotificationData {
    Progress collectionLog = new Progress();
    Progress combatAchievementPoints = new Progress();
    Progress achievementDiary = new Progress();
    Progress achievementDiaryTasks = new Progress();
    BarbarianAssault barbarianAssault = new BarbarianAssault();
    SkillData skills = new SkillData();
    Progress questCount = new Progress();
    Progress questPoints = new Progress();
    SlayerData slayer = new SlayerData();
    List<Pet> pets = Collections.emptyList();

    DinkLoginNotificationData() {
        super(DinkNotificationType.LOGIN);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("collectionLog", gson.toJson(collectionLog));
        map.put("combatAchievementPoints", gson.toJson(combatAchievementPoints));
        map.put("achievementDiary", gson.toJson(achievementDiary));
        map.put("achievementDiaryTasks", gson.toJson(achievementDiaryTasks));
        map.put("barbarianAssault", gson.toJson(barbarianAssault));
        map.put("skills", gson.toJson(skills));
        map.put("questCount", gson.toJson(questCount));
        map.put("questPoints", gson.toJson(questPoints));
        map.put("slayer", gson.toJson(slayer));
        map.put("pets", gson.toJson(pets));

        return map;
    }

    @Data
    public static class SkillData {
        long totalExperience;
        int totalLevel;
        Map<String, Integer> levels;
        Map<String, Integer> experience;

        public SkillData() {
            this.totalExperience = 0;
            this. totalLevel = 0;
            this.levels = Collections.emptyMap();
            this.experience = Collections.emptyMap();
        }
    }

    @Data
    public static class BarbarianAssault {
        int highGambleCount;

        public BarbarianAssault(){
            this.highGambleCount = 0;
        }
    }

    @Data
    public static class SlayerData {
        int points;
        int streak;

        public SlayerData() {
            this.points = 0;
            this.streak= 0;
        }
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Collection;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkClueNotificationData extends DinkNotificationData {
    String clueType;
    int numberCompleted;
    Collection<Item> items;

    public DinkClueNotificationData() {
        super(DinkNotificationType.CLUE);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("clueType", clueType);
        map.put("numberCompleted", numberCompleted);
        map.put("items", gson.toJson(items));

        return map;
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkChatNotificationData extends DinkNotificationData {
    String type;
    String source = "N/A";
    String clanTitle = "N/A";
    String message;

    public DinkChatNotificationData() {
        super(DinkNotificationType.CHAT);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("type", type);
        map.put("source", source);
        map.put("clanTitle", clanTitle);
        map.put("message", message);

        return map;
    }
}

package streamerbot.dinkdata;

import lombok.Data;

@Data
public class Item {
    int id;
    int quantity;
    int priceEach;
    String name;
}

package streamerbot.dinkdata;

import lombok.Getter;
import java.util.Map;
import streamerbot.SettingsManager;

@Getter
public enum DinkNotificationType {
    CLUE("CLUE", DinkClueNotificationData.class, SettingsManager.CLUES_ENABLED, SettingsManager.CLUE_ACTION_NAME),
    COLLECTION("COLLECTION", DinkCollectionNotificationData.class, SettingsManager.COLLECTION_LOG_ENABLED, SettingsManager.COLLECTION_LOG_ACTION_NAME),
    DEATH("DEATH", DinkDeathNotificationData.class, SettingsManager.DEATH_ENABLED, SettingsManager.DEATH_ACTION_NAME),
    LEVEL("LEVEL", DinkLevelNotificationData.class, SettingsManager.LEVEL_ENABLED, SettingsManager.LEVEL_ACTION_NAME),
    LOOT("LOOT", DinkLootNotificationData.class, SettingsManager.LOOT_ENABLED, SettingsManager.LOOT_ACTION_NAME),
    PET("PET", DinkPetNotificationData.class, SettingsManager.PETS_ENABLED, SettingsManager.PET_ACTION_NAME),
    QUEST("QUEST", DinkQuestNotificationData.class, SettingsManager.QUESTS_ENABLED, SettingsManager.QUEST_ACTION_NAME),
    SLAYER("SLAYER", DinkSlayerNotificationData.class, SettingsManager.SLAYER_ENABLED, SettingsManager.SLAYER_ACTION_NAME),
    SPEEDRUN("SPEEDRUN", DinkSpeedrunNotificationData.class, SettingsManager.SPEEDRUNS_ENABLED, SettingsManager.SPEEDRUN_ACTION_NAME),
    KILL_COUNT("KILL_COUNT", DinkBossNotificationData.class, SettingsManager.KILL_COUNT_ENABLED, SettingsManager.KILL_COUNT_ACTION_NAME),
    COMBAT_ACHIEVEMENT("COMBAT_ACHIEVEMENT", DinkCombatAchievementNotificationData.class, SettingsManager.COMBAT_TASK_ENABLED, SettingsManager.COMBAT_TASK_ACTION_NAME),
    ACHIEVEMENT_DIARY("ACHIEVEMENT_DIARY", DinkDiaryNotificationData.class, SettingsManager.DIARY_ENABLED, SettingsManager.DIARY_ACTION_NAME),
    BARBARIAN_ASSAULT_GAMBLE("BARBARIAN_ASSAULT_GAMBLE", DinkGambleNotificationData.class, SettingsManager.GAMBLE_ENABLED, SettingsManager.GAMBLE_ACTION_NAME),
    PLAYER_KILL("PLAYER_KILL", DinkPlayerKillNotificationData.class, SettingsManager.PLAYER_KILLS_ENABLED, SettingsManager.PLAYER_KILL_ACTION_NAME),
    GROUP_STORAGE("GROUP_STORAGE", DinkGroupStorageNotificationData.class, SettingsManager.GROUP_STORAGE_ENABLED, SettingsManager.GROUP_STORAGE_ACTION_NAME),
    GRAND_EXCHANGE("GRAND_EXCHANGE", DinkGrandExchangeNotificationData.class, SettingsManager.GRAND_EXCHANGE_ENABLED, SettingsManager.GROUP_STORAGE_ACTION_NAME),
    LEAGUES_AREA("LEAGUES_AREA", DinkLeaguesAreaNotificationData.class, SettingsManager.LEAGUES_ENABLED, SettingsManager.LEAGUES_ACTION_NAME),
    LEAGUES_MASTERY("LEAGUES_MASTERY", DinkLeaguesMasteryNotificationData.class, SettingsManager.LEAGUES_ENABLED, SettingsManager.LEAGUES_ACTION_NAME),
    LEAGUES_RELIC("LEAGUES_RELIC", DinkLeaguesRelicNotificationData.class, SettingsManager.LEAGUES_ENABLED, SettingsManager.LEAGUES_ACTION_NAME),
    LEAGUES_TASK("LEAGUES_TASK", DinkLeaguesTaskNotificationData.class, SettingsManager.LEAGUES_ENABLED, SettingsManager.LEAGUES_ACTION_NAME),
    LOGIN("LOGIN", DinkLoginNotificationData.class, SettingsManager.META_NOTIFIER_ENABLED, SettingsManager.META_NOTIFIER_ACTION_NAME),
    TOA_UNIQUE("TOA_UNIQUE", DinkAmascutPurpleNotificationData.class, SettingsManager.META_NOTIFIER_ENABLED, SettingsManager.META_NOTIFIER_ACTION_NAME),
    TRADE("TRADE", DinkTradeNotificationData.class, SettingsManager.TRADES_ENABLED, SettingsManager.TRADES_ACTION_NAME),
    CHAT("CHAT", DinkChatNotificationData.class, SettingsManager.CUSTOM_CHAT_ENABLED, SettingsManager.CUSTOM_CHAT_ACTION_NAME),
    XP_MILESTONE("XP_MILESTONE", DinkXpNotificationData.class, SettingsManager.LEVEL_ENABLED, SettingsManager.LEVEL_ACTION_NAME),
    EXTERNAL_PLUGIN("EXTERNAL_PLUGIN", DinkExternalNotificationData.class, SettingsManager.EXTERNAL_PLUGIN_REQUESTS_ENABLED, SettingsManager.EXTERNAL_REQUEST_ACTION_NAME),

    //acts as fallback
    UNKNOWN("UNKNOWN");

    private final String type;
    private final Class<? extends DinkNotificationData> dataClass;
    private final String enabledKey;
    private final String actionKey;

    DinkNotificationType(String type) {
        this.type = type;
        this.dataClass = DinkNotificationData.class;
        this.enabledKey = null;
        this.actionKey = null;
    }

    DinkNotificationType(String type, Class<? extends DinkNotificationData> dataClass, String enabledKey, String actionKey) {
        this.type = type;
        this.dataClass = dataClass;
        this.enabledKey = enabledKey;
        this.actionKey = actionKey;
    }

    private static final Map<String, DinkNotificationType> BY_TYPE =
            java.util.Arrays.stream(values())
                    .collect(java.util.stream.Collectors.toUnmodifiableMap(
                            DinkNotificationType::getType,
                            e -> e
                    ));

    public static DinkNotificationType fromName(String name) {
        if (name == null) return UNKNOWN;
        return BY_TYPE.getOrDefault(name, UNKNOWN);
    }

    public static boolean existsWithEnabledKey(String enabledKey) {
        if(enabledKey == null) return false;
        for(DinkNotificationType type : values()) {
            if(type == UNKNOWN) continue;
            if(enabledKey.equals(type.enabledKey)) {
                return true;
            }
        }

        return false;
    }
}
package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkLeaguesAreaNotificationData extends DinkNotificationData {
    String area;
    int index;
    int tasksCompleted;
    int tasksUntilNextArea = 0;

    public DinkLeaguesAreaNotificationData() {
        super(DinkNotificationType.LEAGUES_AREA);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("area", area);
        map.put("index", index);
        map.put("tasksCompleted", tasksCompleted);
        map.put("tasksUntilNextArea", tasksUntilNextArea);

        return map;
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkQuestNotificationData extends DinkNotificationData {
    String questName;
    int completedQuests = 0;
    int totalQuests = 0;
    int questPoints = 0;
    int totalQuestPoints = 0;

    DinkQuestNotificationData () {
        super(DinkNotificationType.QUEST);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("questName", questName);
        map.put("completedQuests", completedQuests);
        map.put("totalQuests", totalQuests);
        map.put("questPoints", questPoints);
        map.put("totalQuestPoints", totalQuestPoints);

        return map;
    }
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.kit.KitType;

import java.util.Map;


@EqualsAndHashCode(callSuper = true)
@Data
public class DinkPlayerKillNotificationData extends DinkNotificationData {
    String victimName;
    int victimCombatLevel;
    Map<KitType, Item> victimEquipment;
    int world = 0;
    WorldPoint location = new WorldPoint(-1, -1, -1);
    int myHitpoints;
    int myLastDamage;

    DinkPlayerKillNotificationData() {
        super(DinkNotificationType.PLAYER_KILL);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("victimName", victimName);
        map.put("victimCombatLevel", victimCombatLevel);
        map.put("victimEquipment", gson.toJson(victimEquipment));
        map.put("world", world);
        map.put("location", gson.toJson(location));
        map.put("myHitpoints", myHitpoints);
        map.put("myLastDamage", myLastDamage);

        return map;
    }
}

package streamerbot.dinkdata;
import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;


import java.util.Collection;
import java.util.Map;


@EqualsAndHashCode(callSuper = true)
@Data
public class DinkAmascutPurpleNotificationData extends DinkNotificationData {
    Collection<String> party;
    int rewardPoints;
    int raidLevel;
    double probability;

    public DinkAmascutPurpleNotificationData() {
        super(DinkNotificationType.TOA_UNIQUE);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("party", gson.toJson(party));
        map.put("rewardPoints", rewardPoints);
        map.put("raidLevel", raidLevel);
        map.put("probability", probability);

        return map;
    }
}

package streamerbot.dinkdata;

import lombok.Data;

@Data
public class Region {
    int regionId;
    int plane;
    boolean instanced;
}

package streamerbot.dinkdata;

import com.google.gson.Gson;
import lombok.Data;
import lombok.EqualsAndHashCode;

import java.util.Collection;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
public class DinkGroupStorageNotificationData extends DinkNotificationData {
    Collection<Item> deposits;
    Collection<Item> withdrawals;
    long netValue;
    String groupName;

    public DinkGroupStorageNotificationData() {
        super(DinkNotificationType.GROUP_STORAGE);
    }

    @Override
    public Map<String, Object> sanitized(Gson gson) {
        Map<String, Object> map = super.sanitized(gson);

        map.put("deposits", gson.toJson(deposits));
        map.put("withdrawals", gson.toJson(withdrawals));
        map.put("netValue", netValue);
        map.put("groupName", groupName);

        return map;
    }
}

package streamerbot.messaging;
import streamerbot.StreamerbotConfig;
import org.apache.commons.lang3.StringUtils;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton
public class TriggerHandler {
    @Inject
    StreamerbotConfig config;

    @Inject
    private OkHttpClient okHttpClient;

    public void sendJson(String payload) {
        if (StringUtils.isBlank(config.streamerbotAddress())) {
            log.debug("No address provided");
            return; // important: don't continue
        }

        RequestBody body = RequestBody.create(
                MediaType.parse("application/json"),
                payload
        );

        Request request = new Request.Builder()
                .url(config.streamerbotAddress() + "/DoAction")
                .post(body)
                .build();

        okHttpClient.newCall(request).enqueue(new okhttp3.Callback() {
            @Override
            public void onFailure(@Nonnull okhttp3.Call call,@Nonnull  java.io.IOException e) {
                log.debug("Error during POST request", e);
            }

            @Override
            public void onResponse(@Nonnull okhttp3.Call call, @Nonnull okhttp3.Response response) {
                try (okhttp3.Response res = response) {
                    if (!res.isSuccessful()) {
                        log.debug("POST request failed. Response Code: {}", res.code());
                    } else {
                        log.debug("POST request succeeded!");
                    }
                }
            }
        });
    }
}

package streamerbot.messaging;
import lombok.Getter;

import java.util.Map;


@Getter
public class DoActionRequest {
    private final Action action;
    private final Map<String, Object> args;

    public DoActionRequest(Action action, Map<String, Object> args) {
        this.action = action;
        this.args = args;
    }

    public DoActionRequest(String name, Map<String, Object> args) {
        this(new Action(name), args);
    }

@Getter
    public static class Action {
        private final String name;

        public Action(String name) {
            this.name = name;
        }
    }
}

package streamerbot;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class StreamerbotPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(StreamerbotPlugin.class);
		RuneLite.main(args);
	}
}
