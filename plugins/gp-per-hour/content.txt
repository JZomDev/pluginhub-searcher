/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, Eric Versteeg <https://github.com/erversteeg>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import java.time.Instant;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;

//Data for a single 'trip'
public class TripData
{
    String identifier = null;
    long runStartTime = 0;
    // if this is null the trip is in progress
    Long runEndTime = null;
    long runtime = 0;
    boolean isPaused = false;

    Map<Integer, Float> initialItemQtys = new HashMap<>();
    Map<Integer, Float> bankedItemQtys = new HashMap<>();
    transient Map<Integer, Float> itemQtys = new HashMap<>();

    boolean isInProgress()
    {
        return runEndTime == null;
    }

    long getRuntime()
    {
        return runtime;
    }

    long getEndTime()
    {
        return (runEndTime == null ? Instant.now().toEpochMilli() : runEndTime);
    }

    // its in the period between banking finished (onNewRun) and two ticks later
    // when we call onPostNewRun. we have this delay because of how you can withdraw from the bank,
    // close it immediately, and still get the items in your inventory a tick later.
    transient boolean isBankDelay;
    //first run needs to be reinitialized on first game tick.
    transient boolean isFirstRun;
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.text.SimpleDateFormat;
import java.util.Comparator;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;

import net.runelite.api.gameval.ItemID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyListener;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

//Tab in the side panel for showing all your sessions
public class SessionHistoryPanel extends JPanel
{
	private static final String HTML_LABEL_TEMPLATE = "<html><body style='color:%s'>%s<span style='color:white'>%s</span></body></html>";
	private static final String durationLabelPrefix = "Duration: ";
	private static final String gpPerHourLabelPrefix = "GP/hr: ";
	private static final String netTotalLabelPrefix = "Net Total: ";
	private static final String totalGainsLabelPrefix = "Gains: ";
	private static final String totalLossesLabelPrefix = "Losses: ";
	private static final String tripCountLabelPrefix = "Trip Count: ";
	private static final String avgTripDurationLabelPrefix = "Avg Trip Time: ";
	private static final Color borderColor = new Color(57, 57, 57);

	private final GPPerHourConfig config;
	private final GPPerHourPlugin plugin;
	private final ItemManager itemManager;
	private final ClientThread clientThread;
	private final SessionManager sessionManager;
	GridBagConstraints constraints = new GridBagConstraints();

	private final List<SessionHistoryPanelData> historyPanels = new LinkedList<>();
	private final IconTextField searchBar = new IconTextField();
	private final JPanel historyPanelContainer = new JPanel();
	private final JScrollPane resultsWrapper;

	SessionHistoryPanel(GPPerHourPlugin plugin, GPPerHourConfig config, ItemManager itemManager,
			ClientThread clientThread, SessionManager sessionManager)
	{
		this.plugin = plugin;
		this.config = config;
		this.itemManager = itemManager;
		this.clientThread = clientThread;
		this.sessionManager = sessionManager;

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		/* The main container, this holds the search bar and the center panel */
		JPanel container = new JPanel();
		container.setLayout(new BorderLayout(5, 15));
		container.setBorder(new EmptyBorder(15, 5, 5, 5));
		container.setBackground(ColorScheme.DARK_GRAY_COLOR);

		searchBar.setIcon(IconTextField.Icon.SEARCH);
		searchBar.setPreferredSize(new Dimension(100, 30));
		searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		searchBar.addKeyListener(new KeyListener()
		{
			@Override
			public void keyTyped(KeyEvent e)
			{
			}

			@Override
			public void keyPressed(KeyEvent e)
			{
			}

			@Override
			public void keyReleased(KeyEvent e)
			{
				redrawPanels(true);
			}
		});
		searchBar.addClearListener(() -> redrawPanels(true));

		historyPanelContainer.setLayout(new GridBagLayout());
		historyPanelContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		constraints.gridx = 0;
		constraints.gridy = 0;
		constraints.insets = new Insets(0, 0, 10, 0); // Add vertical gap

		/* This panel wraps the results panel and guarantees the scrolling behaviour */
		JPanel wrapper = new JPanel(new BorderLayout());
		wrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		wrapper.add(historyPanelContainer, BorderLayout.NORTH);

		/* The results wrapper, this scrolling panel wraps the results container */
		resultsWrapper = new JScrollPane(wrapper);
		resultsWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		resultsWrapper.getVerticalScrollBar().setPreferredSize(new Dimension(12, 0));
		resultsWrapper.getVerticalScrollBar().setBorder(new EmptyBorder(0, 5, 0, 0));
		resultsWrapper.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		resultsWrapper.setVisible(true);

		container.add(searchBar, BorderLayout.NORTH);
		container.add(resultsWrapper, BorderLayout.CENTER);

		add(container, BorderLayout.CENTER);
	}

	void redrawPanels(boolean resetScroll)
	{
		updateSessions();
		if (resetScroll)
		{
			resultsWrapper.getVerticalScrollBar().setValue(0);
		}
	}

	void updateSessions()
	{
		List<SessionStats> sessions = sessionManager.sessionHistory;
		if (!searchBar.getText().isEmpty())
		{
			sessions = filterSessions(sessions, searchBar.getText());
		}
		sessions = sessions.stream().sorted(Comparator.comparingLong(o -> -o.getSessionSaveTime()))
				.collect(Collectors.toList());
		int sessionIndex;
		for (sessionIndex = 0; sessionIndex < sessions.size(); ++sessionIndex)
		{
			ensurePanelCount(sessionIndex + 1);
			renderHistoryPanel(sessions.get(sessionIndex), historyPanels.get(sessionIndex));
		}
		for (int i = sessionIndex; i < historyPanels.size(); ++i)
		{
			historyPanels.get(i).masterPanel.setVisible(false);
		}

		repaint();
		revalidate();
	}

	public List<SessionStats> filterSessions(List<SessionStats> sessionStats, String textToFilter)
	{
		final String textToFilterLower = textToFilter.toLowerCase();
		return sessionStats.stream().filter(i -> i.getSessionName().toLowerCase().contains(textToFilterLower))
				.collect(Collectors.toList());
	}

	void renderHistoryPanel(SessionStats stats, SessionHistoryPanelData panelData)
	{
		panelData.masterPanel.setVisible(true);
		panelData.nameField.setData(stats.sessionName, (String newName) ->
		{
			stats.sessionName = newName;
			sessionManager.overwriteSession(stats);
		});
		SimpleDateFormat sdfLeft = new SimpleDateFormat("MMM dd, yyyy   h:mm a", Locale.US);
		Date date = new Date(stats.getSessionSaveTime());
		String formattedDateLeft = sdfLeft.format(date);
		panelData.subtitleLeft.setText(formattedDateLeft);

		long gpPerHourLong = UI.getGpPerHour(stats.getSessionRuntime(), stats.getNetTotal());
		String gpPerHour = UI.formatGp(gpPerHourLong,
				config.showExactGp()) + "/hr";

		panelData.gpPerHourTabLabel.setText(gpPerHour);
		int gpPerHourCoinsImage = Math.abs((int) gpPerHourLong);
		gpPerHourCoinsImage /= 100;//divide by 100 to get more variation in coins image
		getCoinsImage(gpPerHourCoinsImage, (BufferedImage image) ->
		{
			panelData.coinsLabel.setIcon(new ImageIcon(image));
		}, stats);

		panelData.detailsPanel.setVisible(stats.showDetails);

		if (stats.showDetails)
		{
			panelData.gpPerHourLabel.setText(htmlLabel(gpPerHourLabelPrefix, gpPerHour));
			panelData.netTotalLabel.setText(htmlLabel(netTotalLabelPrefix, UI.formatQuantity(stats.getNetTotal(), false)));
			panelData.totalGainsLabel
					.setText(htmlLabel(totalGainsLabelPrefix, UI.formatGp(stats.getTotalGain(), config.showExactGp())));
			panelData.totalLossesLabel
					.setText(htmlLabel(totalLossesLabelPrefix, UI.formatGp(stats.getTotalLoss(), config.showExactGp())));
			panelData.durationLabel.setText(htmlLabel(durationLabelPrefix, UI.formatTime(stats.getSessionRuntime())));
			boolean showTripCountAndTime = stats.getTripCount() > 1;
			panelData.setTripCountAndDurationVisible(showTripCountAndTime);
			if(showTripCountAndTime)
			{
				panelData.tripCountLabel.setText(htmlLabel(tripCountLabelPrefix, Integer.toString(stats.getTripCount())));
				panelData.avgTripDurationLabel
						.setText(htmlLabel(avgTripDurationLabelPrefix, UI.formatTime(stats.getAvgTripDuration())));
			}
			UI.updateLootGrid(
					UI.sortLedger(
							GPPerHourPlugin.getProfitLossLedger(stats.getInitialQtys(), stats.getQtys())),
					panelData.sessionLootPanelData, itemManager, config, 0);
		}

		panelData.onDetailsPressed = () ->
		{
			stats.showDetails = !stats.showDetails;
			redrawPanels(false);
		};
		panelData.onDeletePressed = () ->
		{
			int confirm = JOptionPane.showConfirmDialog(this, "Are you sure you want to delete this session?", "Warning",
			JOptionPane.OK_CANCEL_OPTION);

			if (confirm == 0)
			{
				clientThread.invokeLater(()-> sessionManager.deleteSession(stats));
			}
		};
	}

	void ensurePanelCount(int size)
	{
		while (historyPanels.size() < size)
		{
			constraints.gridy = historyPanels.size();
			SessionHistoryPanelData data = buildHistoryPanel();
			this.historyPanelContainer.add(data.masterPanel, constraints);
			historyPanels.add(data);
		}
	}

	private class SessionHistoryPanelData
	{
		final JPanel detailsPanel;
		final JLabel gpPerHourTabLabel;
		final JPanel masterPanel = new JPanel();
		final EditableNameField nameField;
		private final JLabel coinsLabel = new JLabel();
		private final JLabel subtitleLeft = new JLabel("Left");
		private final JLabel durationLabel = new JLabel(htmlLabel(durationLabelPrefix, "N/A"));
		private final JLabel gpPerHourLabel = new JLabel(htmlLabel(gpPerHourLabelPrefix, "N/A"));
		private final JLabel netTotalLabel = new JLabel(htmlLabel(netTotalLabelPrefix, "N/A"));
		private final JLabel totalGainsLabel = new JLabel(htmlLabel(totalGainsLabelPrefix, "N/A"));
		private final JLabel totalLossesLabel = new JLabel(htmlLabel(totalLossesLabelPrefix, "N/A"));
		private final JLabel tripCountLabel = new JLabel(htmlLabel(tripCountLabelPrefix, "N/A"));
		private final JLabel avgTripDurationLabel = new JLabel(htmlLabel(avgTripDurationLabelPrefix, "N/A"));
		private final Component tripCountSpacing;
		private final Component avgTripDurationSpacing;
		private final UI.LootPanelData sessionLootPanelData = new UI.LootPanelData();
		Runnable onDetailsPressed;
		Runnable onDeletePressed;

		void setTripCountAndDurationVisible(boolean visible)
		{
			tripCountLabel.setVisible(visible);
			avgTripDurationLabel.setVisible(visible);
			tripCountSpacing.setVisible(visible);
			avgTripDurationSpacing.setVisible(visible);
		}

		SessionHistoryPanelData(SessionHistoryPanel parentPanel)
		{
			masterPanel.setLayout(new BorderLayout(0, 0));

			gpPerHourTabLabel = new JLabel();
			gpPerHourTabLabel.setText("xxx/hr");
			gpPerHourTabLabel.setFont(FontManager.getRunescapeBoldFont());

			RoundedPanel gpPerHourPanel = new RoundedPanel();
			gpPerHourPanel.setLayout(new BorderLayout(5, 0));
			gpPerHourPanel.setBorder(new EmptyBorder(3, 10, 3, 10));
			gpPerHourPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			gpPerHourPanel.setForeground(borderColor);
			gpPerHourPanel.add(coinsLabel, BorderLayout.WEST);
			gpPerHourPanel.add(gpPerHourTabLabel, BorderLayout.CENTER);

			JPanel gpPerHourWrapperPanel = new JPanel();
			gpPerHourWrapperPanel.setLayout(new BorderLayout());
			gpPerHourWrapperPanel.add(gpPerHourPanel, BorderLayout.WEST);

			nameField = new EditableNameField(parentPanel, 50, ColorScheme.DARKER_GRAY_COLOR, null);

			JLabel detailsButton = UI.createIconButton(UI.SESSIONINFO_INFO_ICON, UI.SESSIONINFO_INFO_HOVER_ICON,
					"Show Details", () ->
					{
						onDetailsPressed.run();
					});
			JLabel deleteButton = UI.createIconButton(UI.SESSIONINFO_TRASH_ICON, UI.SESSIONINFO_TRASH_HOVER_ICON,
					"Delete Session", () ->
					{
						onDeletePressed.run();
					});

			JPanel subtitlePanel = new JPanel();
			subtitlePanel.setLayout(new BorderLayout());
			subtitlePanel.setBorder(new EmptyBorder(5, 10, 5, 10));
			subtitlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			subtitlePanel.add(subtitleLeft, BorderLayout.WEST);
			subtitlePanel.add(detailsButton, BorderLayout.CENTER);
			subtitlePanel.add(deleteButton, BorderLayout.EAST);


			JPanel nameAndSubtitlePanel = new JPanel();
			nameAndSubtitlePanel.setLayout(new BorderLayout());
			nameAndSubtitlePanel.setBorder(new MatteBorder(1,1,1,1,borderColor));
			nameAndSubtitlePanel.add(nameField, BorderLayout.NORTH);
			nameAndSubtitlePanel.add(subtitlePanel, BorderLayout.CENTER);

			// Always visible header area
			JPanel headerPanel = new JPanel();
			headerPanel.setLayout(new BorderLayout());
			headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			headerPanel.add(gpPerHourWrapperPanel, BorderLayout.NORTH);
			headerPanel.add(nameAndSubtitlePanel, BorderLayout.CENTER);

			JPanel infoLabels = new JPanel();
			infoLabels.setLayout(new BoxLayout(infoLabels, BoxLayout.Y_AXIS));
			infoLabels.setBorder(new EmptyBorder(8, 10, 8, 10));
			infoLabels.setBackground(ColorScheme.DARKER_GRAY_COLOR);

			int vGap = 8;
			infoLabels.add(gpPerHourLabel);
			UI.addVerticalRigidBox(infoLabels, vGap);
			infoLabels.add(netTotalLabel);
			UI.addVerticalRigidBox(infoLabels, vGap);
			infoLabels.add(totalGainsLabel);
			UI.addVerticalRigidBox(infoLabels, vGap);
			infoLabels.add(totalLossesLabel);
			UI.addVerticalRigidBox(infoLabels, vGap);
			infoLabels.add(tripCountLabel);
			tripCountSpacing = UI.addVerticalRigidBox(infoLabels, vGap);
			infoLabels.add(avgTripDurationLabel);
			avgTripDurationSpacing = UI.addVerticalRigidBox(infoLabels, vGap);
			infoLabels.add(durationLabel);

			sessionLootPanelData.lootPanel.setLayout(new BorderLayout());
			sessionLootPanelData.lootPanel.setBorder(new MatteBorder(1,0,0,0,borderColor));

			detailsPanel = new JPanel();
			detailsPanel.setLayout(new BorderLayout());
			detailsPanel.setBorder(new MatteBorder(0,1,1,1,borderColor));
			detailsPanel.add(infoLabels, BorderLayout.NORTH);
			detailsPanel.add(sessionLootPanelData.lootPanel, BorderLayout.SOUTH);

			masterPanel.add(headerPanel, BorderLayout.NORTH);
			masterPanel.add(detailsPanel, BorderLayout.CENTER);
		}
	}

	SessionHistoryPanelData buildHistoryPanel()
	{
		return new SessionHistoryPanelData(this);
	}

	static String htmlLabel(String key, String valueStr)
	{
		return String.format(HTML_LABEL_TEMPLATE, ColorUtil.toHexColor(ColorScheme.LIGHT_GRAY_COLOR), key, valueStr);
	}

	void getCoinsImage(int quantity, Consumer<BufferedImage> consumer, SessionStats stats)
	{
		if (stats.coinsImage == null)
		{
			AsyncBufferedImage asyncImage = itemManager.getImage(ItemID.COINS, quantity, false);
			Runnable resizeImage = ()->
			{
				stats.coinsImage = ImageUtil.resizeImage(asyncImage, 24, 24);
				consumer.accept(stats.coinsImage);
			};
			asyncImage.onLoaded(resizeImage);
		} else
		{
			consumer.accept(stats.coinsImage);
		}
	}
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, Eric Versteeg <https://github.com/erversteeg>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

//Represent an item that has been processed and is ready to be displayed on the UI (either overlay or active session panel).
public class LedgerItem {
    private final String description;
    private float qty;
    private final float price;
    private final int itemId;

    public LedgerItem(String description, float qty, float price, int itemId)
    {
        this.description = description;
        this.qty = qty;
        this.price = price;
        this.itemId = itemId;
    }

    public String getDescription()
    {
        return description;
    }

    public float getQty()
    {
        return qty;
    }

    public float getPrice()
    {
        return price;
    }

    public int getItemId()
    {
        return itemId;
    }

    public void addQuantityDifference(float qtyDifference)
    {
        qty += qtyDifference;
    }

    public long getCombinedValue()
    {
        return (long) (this.qty * this.price);
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, Eric Versteeg <https://github.com/erversteeg>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup(GPPerHourConfig.GROUP)
public interface GPPerHourConfig extends Config
{
    String version = "version";
	String GROUP = "gpperhour";
	String logOutTimeKey = "log_out_time";
	String fish_barrel = "fish_barrel";
	String kharedsts_memoirs = "kharedsts_memoirs";
	String ash_sanctifier = "ash_sanctifier";
	String bottomless_compost_bucket = "bottomless_compost_bucket";
	String bottomless_compost_bucket_type = "bottomless_compost_bucket_type";
	String log_basket = "log_basket";
	String looting_bag = "looting_bag";
	String blood_essence = "blood_essence";
	String gem_bag = "gem_bag";
	String herb_sack = "herb_sack";
    String seed_box = "seed_box";
    String coal_bag = "coal_bag";
	String sessionKey = "session_stats_";
	String sessionIdentifiersKey = "session_ids";

	static String getSessionKey(String identifier)
	{
		return sessionKey + identifier;
	}






	@ConfigSection(
		name = "Shared Settings",
		description = "The options that apply to both the trip overlay and session panel.",
		position = 50,
		closedByDefault = false
	)
	String sharedSettingSection = "sharedSettingSection";

	public static final String valueModeKey = "valueMode";
	@ConfigItem(
			position = 5,
			keyName = valueModeKey,
			name = "Price Mode",
			description = "Use Runelite value (GE/Wiki or Store price), or low/high alch value.",
			section =  sharedSettingSection
	)
	default GPPerHourPlugin.ValueMode valueMode()
	{
		return GPPerHourPlugin.ValueMode.RUNELITE_VALUE;
	}

	@ConfigItem(
			position = 10,
			keyName = "showExactGp",
			name = "Show Exact Gp",
			description = "Configures whether or not the exact gp value is visible.",
			section =  sharedSettingSection
	)
	default boolean showExactGp()
	{
		return false;
	}

	public static final String showGoldDropsKey = "goldDrops";
    @ConfigItem(
			position = 20,
            keyName = showGoldDropsKey,
			hidden = true,
            name = "Show Gold Drops",
            description = "Show each profit increase or decrease as an XP drop (only works in profit/loss mode).",
			section =  sharedSettingSection
    )
    default boolean goldDrops()
    {
        return false;
    }
	@ConfigItem(
		keyName = showGoldDropsKey,
		name = "",
		description = ""
	)
	void setGoldDrops(boolean value);

	public static final String goldDropDisplayModeKey = "goldDropsDisplayMode";
    @ConfigItem(
			position = 20,
            keyName = goldDropDisplayModeKey,
            name = "Gold Drop Display Mode",
            description = "Show each profit increase or decrease as an XP drop. Vanilla uses normal XP drops. Static appears next to inventory for compat with custom xp drops plugin.",
			section =  sharedSettingSection
    )
    default GoldDropManager.GoldDropDisplayMode goldDropsDisplayMode()
    {
        return GoldDropManager.GoldDropDisplayMode.DISABLED;
    }
	@ConfigItem(
		keyName = goldDropDisplayModeKey,
		name = "",
		description = ""
	)
	void setGoldDropsDisplayMode(GoldDropManager.GoldDropDisplayMode value);

    @ConfigItem(
			position = 21,
            keyName = "goldDropThreshold",
            name = "Gold Drop Threshold",
            description = "Minimum amount of coins that will trigger a gold drop.",
			section =  sharedSettingSection
    )
    default int goldDropThreshold()
    {
        return 0;
    }

    @ConfigItem(
			position = 22,
            keyName = "onlyShowPositiveGoldDrops",
            name = "Only Positive Gold Drops",
            description = "Only show positive gold drops for the good vibes.",
			section =  sharedSettingSection
    )
    default boolean onlyShowPositiveGoldDrops()
    {
        return false;
    }

	@Alpha
	@ConfigItem(
			position = 23,
			keyName = "goldDropsPositiveColor",
			name = "Gold Drop Positive Color",
			description = "Configures the color for a positive gold drop.",
			section =  sharedSettingSection
	)
	default Color goldDropsPositiveColor()
	{
		return new Color(255,255,255,255);
	}

	@Alpha
	@ConfigItem(
			position = 24,
			keyName = "goldDropsNegativeColor",
			name = "Gold Drop Negative Color",
			description = "Configures the color for a negative gold drop.",
			section =  sharedSettingSection
	)
	default Color goldDropsNegativeColor()
	{
		return new Color(255,255,255,255);
	}



	public static final String ignoredItemsKey = "ignoredItems";
	@ConfigItem(
			position = 30,
			keyName = ignoredItemsKey,
			name = "Ignored Items",
			description = "Ignore these items in your inventory (applies after banking).",
			section =  sharedSettingSection
	)
	default String ignoredItems() {
		return "Cannon barrels, Cannon base, Cannon furnace, Cannon stand";
	}










	@ConfigSection(
		name = "Inventory Overlay Settings",
		description = "The options that control the inventory overlay, used to display stats on your active trip.",
		position = 100,
		closedByDefault = true
	)
	String tripOverlaySection = "tripOverlaySection";

	public static final String showTripOverlayKeyName = "showTripOverlay";
	@ConfigItem(
			position = 0,
			keyName = showTripOverlayKeyName,
			name = "Show Inventory Overlay",
			description = "Enables/disables the inventory overlay.",
			section =  tripOverlaySection
	)
	default boolean showTripOverlay()
	{
		return true;
	}

	@ConfigItem(
			position = 1,
			keyName = "alwaysShowTripOverlay",
			name = "Always Show Overlay",
			description = "Show overlay even when the inventory is hidden. Open inventory to refresh the widget position after resizing Runelite.",
			section =  tripOverlaySection
	)
	default boolean alwaysShowTripOverlay()
	{
		return false;
	}

    @ConfigItem(
		position = 5,
		keyName = "inventoryOverlayDisplayMode",
		name = "Overlay Display",
		description = "What data to show on the inventory overlay.",
		section =  tripOverlaySection
	)
	default ActiveTripOverlay.InventoryOverlayDisplayMode inventoryOverlayDisplayMode()
	{
		return ActiveTripOverlay.InventoryOverlayDisplayMode.TRIP_GP_PER_HOUR;
	}

	@ConfigItem(
			position = 10,
			keyName = "showLapTime",
			name = "Show Run Time",
			description = "Configures whether the runtime of the current trip or session is visible.",
			section =  tripOverlaySection
	)
	default boolean showRunTime()
	{
		return false;
	}


	@ConfigItem(
			position = 20,
			keyName = "showCoinStack",
			name = "Show Coin Stack",
			description = "Configures whether or not the coin stack image is visible.",
			section =  tripOverlaySection
	)
	default boolean showCoinStack()
	{
		return true;
	}

	@ConfigItem(
			position = 25,
			keyName = "showWhileBanking",
			name = "Show While Banking",
			description = "Configures whether or not the total is visible while banking.",
			section =  tripOverlaySection
	)
	default boolean showWhileBanking()
	{
		return true;
	}

	@ConfigItem(
			position = 30,
			keyName = "showOnEmpty",
			name = "Show On Empty",
			description = "Configures whether or not to show the total when inventory is empty.",
			section =  tripOverlaySection
	)
	default boolean showOnEmpty()
	{
		return true;
	}

	@ConfigItem(
			position = 35,
			keyName = "showTooltip",
			name = "Show Ledger on Hover",
			description = "Show the ledger when hovering over the trip overlay.",
			section =  tripOverlaySection
	)
	default boolean showLedgerOnHover()
	{
		return true;
	}

	@ConfigItem(
			position = 40,
			keyName = "roundedCorners",
			name = "Rounded Corners",
			description = "Toggle rounded corners.",
			section =  tripOverlaySection
	)
	default boolean roundCorners()
	{
		return true;
	}

	@ConfigItem(
			position = 41,
			keyName = "cornerRadius",
			name = "Corner Radius",
			description = "Configures the corner radius.",
			section =  tripOverlaySection
	)
	default int cornerRadius()
	{
		return 10;
	}

	@ConfigItem(
			position = 45,
			keyName = "alignment",
			name = "Alignment",
			description = "Configures alignment.",
			section =  tripOverlaySection
	)
	default TripOverlayAlignment horizontalAlignment()
	{
		return TripOverlayAlignment.CENTER;
	}

	@ConfigItem(
			position = 50,
			keyName = "inventoryOffsetX",
			name = "Inventory Offset X",
			description = "Configures x-axis offset.",
			section =  tripOverlaySection
	)
	default int inventoryXOffset()
	{
		return 0;
	}

	@ConfigItem(
			position = 51,
			keyName = "inventoryOffsetXNegative",
			name = "Inventory Offset X Negative",
			description = "Configures whether or not the y-axis offset is a negative number.",
			section =  tripOverlaySection
	)
	default boolean isInventoryXOffsetNegative()
	{
		return false;
	}

	@ConfigItem(
			position = 52,
			keyName = "inventoryOffsetY",
			name = "Inventory Offset Y",
			description = "Configures y-axis offset.",
			section =  tripOverlaySection
	)
	default int inventoryYOffset()
	{
		return 42;
	}

	@ConfigItem(
			position = 53,
			keyName = "inventoryOffsetYNegative",
			name = "Inventory Offset Y Negative",
			description = "Configures whether or not the y-axis offset is a negative number.",
			section =  tripOverlaySection
	)
	default boolean isInventoryYOffsetNegative()
	{
		return false;
	}

	@Alpha
	@ConfigItem(
			position = 60,
			keyName = "totalBackgroundColor",
			name = "Background Color",
			description = "Configures the background color.",
			section =  tripOverlaySection
	)
	default Color totalColor()
	{
		return Color.decode("#99903D");
	}

	@ConfigItem(
			position = 61,
			keyName = "totalTextColor",
			name = "Text Color",
			description = "Configures the text color.",
			section =  tripOverlaySection
	)
	default Color textColor()
	{
		return Color.decode("#FFF7E3");
	}

	@Alpha
	@ConfigItem(
			position = 62,
			keyName = "totalBorderColor",
			name = "Border Color",
			description = "Configures the border color.",
			section =  tripOverlaySection
	)
	default Color borderColor()
	{
		return Color.decode("#0E0E0E");
	}

	@Alpha
	@ConfigItem(
			position = 63,
			keyName = "profitBackgroundColor",
			name = "Profit Color",
			description = "Configures profit background color.",
			section =  tripOverlaySection
	)
	default Color profitColor()
	{
		return Color.decode("#245C2D");
	}

	@ConfigItem(
			position = 64,
			keyName = "profitTextColor",
			name = "Profit Text Color",
			description = "Configures profit text color.",
			section =  tripOverlaySection
	)
	default Color profitTextColor()
	{
		return Color.decode("#FFF7E3");
	}

	@Alpha
	@ConfigItem(
			position = 65,
			keyName = "profitBorderColor",
			name = "Profit Border Color",
			description = "Configures profit border color.",
			section =  tripOverlaySection
	)
	default Color profitBorderColor()
	{
		return Color.decode("#0E0E0E");
	}

	@Alpha
	@ConfigItem(
			position = 66,
			keyName = "lossBackgroundColor",
			name = "Loss Color",
			description = "Configures loss background color.",
			section =  tripOverlaySection
	)
	default Color lossColor()
	{
		return Color.decode("#5F1515");
	}

	@ConfigItem(
			position = 67,
			keyName = "lossTextColor",
			name = "Loss Text Color",
			description = "Configures loss text color.",
			section =  tripOverlaySection
	)
	default Color lossTextColor()
	{
		return Color.decode("#FFF7E3");
	}

	@Alpha
	@ConfigItem(
			position = 68,
			keyName = "lossBorderColor",
			name = "Loss Border Color",
			description = "Configures loss border color.",
			section =  tripOverlaySection
	)
	default Color lossBorderColor()
	{
		return Color.decode("#0E0E0E");
	}







	@ConfigSection(
		name = "Session Panel Settings",
		description = "The options that control the side panel, showing active session stats and session history.",
		position = 150,
		closedByDefault = true
	)
	String sessionPanelSection = "sessionPanelSection";

	public static final String enableSessionPanelKeyName = "enableSessionPanel";
	@ConfigItem(
			position = 0,
			keyName = enableSessionPanelKeyName,
			name = "Enable Session Panel",
			description = "Enables/disables the session side panel.",
			section =  sessionPanelSection
	)
	default boolean enableSessionPanel()
	{
		return true;
	}

	public static final String enableSessionTrackingKeyName = "enableSessionTracking";
	@ConfigItem(
			position = 1,
			hidden = true,
			keyName = enableSessionTrackingKeyName,
			name = "Enable Session Tracking",
			description = "Enables/disables session tracking.",
			section =  sessionPanelSection
	)
	default boolean getEnableSessionTracking()
	{
		return true;
	}
	@ConfigItem(
		keyName = enableSessionTrackingKeyName,
		name = "",
		description = ""
	)
	void setEnableSessionTracking(boolean value);

	@ConfigItem(
			position = 5,
			keyName = "autoResumeTrip",
			name = "Auto Resume Trip",
			description = "Automatically resume a paused trip when a profit change is detected.",
			section =  sessionPanelSection
	)
	default boolean autoResumeTrip() {
		return true;
	}

	@ConfigItem(
			position = 10,
			keyName = "ignoreBankTime",
			name = "Ignore Bank time",
			description = "Don't count time with a bank UI open towards session time.",
			section =  sessionPanelSection
	)
	default boolean ignoreBankTime() {
		return false;
	}

	public static final String sidePanelPositionKeyName = "sidePanelPosition";
    @ConfigItem(
            position = 20,
            keyName = sidePanelPositionKeyName,
            name = "Side Panel Position",
            description = "Panel icon position, Lower # = higher pos, Higher # = lower pos ",
			section =  sessionPanelSection
    )
    default int sidePanelPosition() { return 6; }

	public static final String sessionLootGridMaxHeightKeyName = "sessionLootGridMaxHeight";
	@ConfigItem(
			position = 25,
			keyName = sessionLootGridMaxHeightKeyName,
			name = "Loot Grid Max Height",
			description = "The max height of the session panel's loot grid. Prevents force expansion of client.",
			section =  sessionPanelSection
	)
	default int sessionLootGridMaxHeight() { return 225; }








	@ConfigSection(
		name = "Untradeable Values",
		description = "Customize value for items that are not tradeable.",
		position = 200,
		closedByDefault = true
	)
	String untradeableValuesSection = "untradeableValuesSection";

	@ConfigItem(
			position = 5,
			keyName = "tokkulKaramjaGloves",
			name = "Tokkul: Include Karamja Gloves",
			description = "Include karamja glove discount for tokkul price.",
			section =  untradeableValuesSection
	)
	default boolean tokkulKaramjaGloves()
	{
		return false;
	}

	@ConfigItem(
			position = 6,
			keyName = "tokkulValue",
			name = "Tokkul",
			description = "Uses overstock price for buy value, normal stock for sell value.",
			section =  untradeableValuesSection
	)
	default ValueRemapper.TokkulOverride tokkulValue()
	{
		return ValueRemapper.TokkulOverride.NO_VALUE;
	}

	@ConfigItem(
			position = 10,
			keyName = "crystalShardValue",
			name = "C Shard",
			description = "Crystal Shard: Uses enhanced crystal teleport seed for buy value, divine potion profit for sell value.",
			section =  untradeableValuesSection
	)
	default ValueRemapper.CrystalShardOverride crystalShardValue()
	{
		return ValueRemapper.CrystalShardOverride.NO_VALUE;
	}

	@ConfigItem(
			position = 15,
			keyName = "crystalDustValue",
			name = "C Dust",
			description = "Crystal Dust: Uses divine potion profit for value.",
			section =  untradeableValuesSection
	)
	default ValueRemapper.CrystalDustOverride crystalDustValue()
	{
		return ValueRemapper.CrystalDustOverride.NO_VALUE;
	}

	@ConfigItem(
			position = 20,
			keyName = "mermaidsTearValue",
			name = "Mermaid's T",
			description = "Option to use merfolk trident to derive the value.",
			section =  untradeableValuesSection
	)
	default ValueRemapper.MermaidsTearOverride mermaidsTearValue()
	{
		return ValueRemapper.MermaidsTearOverride.NO_VALUE;
	}

	@ConfigItem(
			position = 25,
			keyName = "stardustValue",
			name = "Stardust",
			description = "Option to use value of buyable items to derive the value.",
			section =  untradeableValuesSection
	)
	default ValueRemapper.StardustOverride stardustValue()
	{
		return ValueRemapper.StardustOverride.NO_VALUE;
	}

	@ConfigItem(
			position = 30,
			keyName = "unidentifiedMineralsValue",
			name = "U Minerals",
			description = "Unidentified Minerals: Option to use value of buyable items to derive the value.",
			section =  untradeableValuesSection
	)
	default ValueRemapper.UnidentifiedMineralsOverride unidentifiedMineralsValue()
	{
		return ValueRemapper.UnidentifiedMineralsOverride.NO_VALUE;
	}

	@ConfigItem(
			position = 35,
			keyName = "goldenNuggetValue",
			name = "G Nuggets",
			description = "Golden Nuggets: Option to use value of buyable items to derive the value.",
			section =  untradeableValuesSection
	)
	default ValueRemapper.GoldenNuggetOverride goldenNuggetValue()
	{
		return ValueRemapper.GoldenNuggetOverride.NO_VALUE;
	}

	@ConfigItem(
			position = 40,
			keyName = "hallowedMarkValue",
			name = "Hallowed M",
			description = "Hallowed Mark: Option to use value of buyable items to derive the value.",
			section =  untradeableValuesSection
	)
	default ValueRemapper.HallowedMarkOverride hallowedMarkValue()
	{
		return ValueRemapper.HallowedMarkOverride.NO_VALUE;
	}

	@ConfigItem(
			position = 45,
			keyName = "abyssalPearlsValue",
			name = "Abyssal P",
			description = "Abyssal Pearls: Option to use value of buyable items to derive the value.",
			section =  untradeableValuesSection
	)
	default ValueRemapper.AbyssalPearlsOverride abyssalPearlsValue()
	{
		return ValueRemapper.AbyssalPearlsOverride.NO_VALUE;
	}

	@ConfigItem(
			position = 50,
			keyName = "brimstoneKeyValue",
			name = "Brimstone Key",
			description = "Brimstone Key: Option to set value of zero or average value.",
			section =  untradeableValuesSection
	)
	default ValueRemapper.BrimstoneKeyOverride brimstoneKeyValue()
	{
		return ValueRemapper.BrimstoneKeyOverride.AVERAGE_VALUE;
	}
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, Patrick Watts <https://github.com/pwatts6060>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;

import javax.inject.Inject;

import com.google.common.collect.ImmutableSet;
import com.google.gson.Gson;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuAction;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
//Keeps track of the items in your looting bag, supports all operations except adding items by using them on it when a dialog appears (if there are multiple).
public class LootingBagManager
{
	@Data
	@AllArgsConstructor
	public class PickupAction
	{
		int itemId;
		WorldPoint worldPoint;
	}

	public static final int LOOTING_BAG_CONTAINER = 516;
	private static final Set<Integer> FEROX_REGION = ImmutableSet.of(12600, 12344);
	private static final int LOOTING_BAG_SIZE = 28;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private Gson gson;

	@Inject
	private ScheduledExecutorService executor;

	private Map<Integer, Integer> bagItems = null;
	private int lastLootingBagUseOn = -2;

	private PickupAction lastPickUpAction;

	public void loadConfigData()
	{
		Type mapType = new com.google.gson.reflect.TypeToken<Map<Integer, Integer>>() {}.getType();

		String json = configManager.getRSProfileConfiguration(GPPerHourConfig.GROUP, GPPerHourConfig.looting_bag);
		try 
		{
			bagItems = gson.fromJson(json, mapType);
		}
		catch(Exception e)
		{
			log.error("Failed to load looting bag data from json: " + json, e);
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widgetLoaded)
	{
		if (widgetLoaded.getGroupId() != WidgetUtil.componentToInterface(InterfaceID.WildernessLootingbag.ITEMS))
		{
			return;
		}
		updateValue();
	}

	private void updateValue()
	{
		ItemContainer itemContainer = client.getItemContainer(LOOTING_BAG_CONTAINER);
		if (itemContainer == null)
		{
			if (bagItems == null)
				bagItems = new HashMap<>();
			bagItems.clear();
			saveData();
			return;
		}
		if (bagItems == null)
			bagItems = new HashMap<>();
		bagItems.clear();
		for (Item item : itemContainer.getItems())
		{
			if (item.getId() >= 0)
			{
				bagItems.merge(item.getId(), item.getQuantity(), Integer::sum);
			}
		}
		saveData();
	}

	void addLootingBagContents(Map<Integer,Float> qtyMap)
	{
		//needs to be checked/calibrated
		if (bagItems == null)
		{
			return;
		}
		for (Integer itemId: bagItems.keySet())
		{
			qtyMap.merge(itemId, (float) bagItems.get(itemId), Float::sum);
		}
	}

	//avoid GC
	private Map<Integer, Integer> differenceMap = new HashMap<>();
	private Item[] inventory_items;

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		if (event.getItemContainer() == null)
			return;

		if (event.getContainerId() == InventoryID.INV)
		{
			if (inventory_items != null && bagItems != null &&
				(lastLootingBagUseOn == client.getTickCount() || lastLootingBagUseOn + 1 == client.getTickCount()))
			{
				differenceMap.clear();
				Item[] before = inventory_items;
				Item[] after = event.getItemContainer().getItems();
				for (Item beforeItem : before)
				{
					differenceMap.merge(beforeItem.getId(), 1, Integer::sum);
				}
				for (Item afterItem : after)
				{
					differenceMap.merge(afterItem.getId(), -1, Integer::sum);
				}
				for (Integer itemId : differenceMap.keySet())
				{
					Integer count = differenceMap.get(itemId);
					if (count > 0 && canAddItem(itemId))
					{
						bagItems.merge(itemId, count, Integer::sum);
					}
				}
				saveData();
			}
			inventory_items = event.getItemContainer().getItems();
		}
		if (event.getContainerId() == LOOTING_BAG_CONTAINER)
		{
			updateValue();
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if (event.getMenuAction() == MenuAction.GROUND_ITEM_THIRD_OPTION && event.getMenuOption().equals("Take"))
		{
			WorldPoint point = WorldPoint.fromScene(client, event.getParam0(), event.getParam1(), client.getPlane());
			lastPickUpAction = new PickupAction(event.getId(), point);
		}

		if (event.getMenuAction() == MenuAction.WIDGET_TARGET_ON_WIDGET) {
			ItemContainer itemContainer = client.getItemContainer(InventoryID.INV);
			if (itemContainer == null)
				return;
			Widget widgetA = client.getSelectedWidget();
			if (widgetA == null)
				return;
			Item itemA = itemContainer.getItem(widgetA.getIndex());
			if (itemA == null) 
				return;
			int itemAId = itemA.getId();
			Widget widgetB = event.getWidget();
			if (widgetB == null)
				return;
			Item itemB = itemContainer.getItem(widgetB.getIndex());
			if (itemB == null) 
				return;
			int itemBId = itemB.getId();

			boolean usedItemOnLootingBag = isLootingBag(itemAId) || isLootingBag(itemBId);
			if (usedItemOnLootingBag)
			{
				lastLootingBagUseOn = client.getTickCount();
			}
		}
	}

	private boolean isLootingBag(int itemId)
	{
		return itemId == ItemID.LOOTING_BAG || itemId == ItemID.LOOTING_BAG_OPEN;
	}

	@Subscribe
	public void onItemDespawned(ItemDespawned event)
	{
		if (bagItems == null)
		{
			return;
		}

		// not in wilderness or ferox -> can't pick up items directly into looting bag
		if (client.getVarbitValue(VarbitID.INSIDE_WILDERNESS) == 0
			&& !FEROX_REGION.contains(client.getLocalPlayer().getWorldLocation().getRegionID()))
		{
			return;
		}

		// doesn't have open looting bag
		ItemContainer inv = client.getItemContainer(InventoryID.INV);
		if (inv == null || !inv.contains(ItemID.LOOTING_BAG_OPEN))
		{
			return;
		}

		if (lastPickUpAction == null)
		{
			return;
		}

		// not on same tile
		if (!event.getTile().getWorldLocation().equals(client.getLocalPlayer().getWorldLocation()))
		{
			return;
		}

		if (!event.getTile().getWorldLocation().equals(lastPickUpAction.getWorldPoint()))
		{
			return;
		}

		int itemId = event.getItem().getId();

		if (itemId != lastPickUpAction.getItemId())
		{
			return;
		}

		ItemComposition itemComposition = itemManager.getItemComposition(itemId);

		if (!itemComposition.isTradeable())
		{
			return;
		}

		if (!canAddItem(itemId))
		{
			return;
		}

		int quantity = event.getItem().getQuantity();
		bagItems.merge(itemId, quantity, Integer::sum);
		saveData();
	}

	private boolean canAddItem(int itemId)
	{
		if (isStackable(itemId) && bagItems.containsKey(itemId))
		{
			return true;
		}
		else
		{
			int slotsUsed = 0;
			for (Integer bagItemId : bagItems.keySet())
			{
				slotsUsed += isStackable(bagItemId) ? 1 : bagItems.get(bagItemId);
			}
			return slotsUsed < LOOTING_BAG_SIZE;
		}
	}

	private boolean isStackable(int itemId)
	{
		return itemManager.getItemComposition(itemId).isStackable();
	}

	private void saveData()
	{
		executor.execute(() ->
		{
			configManager.setRSProfileConfiguration(GPPerHourConfig.GROUP, GPPerHourConfig.looting_bag, gson.toJson(this.bagItems));
		});
	}

	public long getPrice(int itemId)
	{
		return itemManager.getItemPrice(itemId);
	}

	boolean needsCheck()
	{
		return bagItems == null;
	}
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import javax.swing.*;
import java.awt.*;

//Custom panel for rounded edges on the top left and top right corners.
public class RoundedPanel extends JPanel {
    @Override
    protected void paintComponent(Graphics g) {
        int arc = 16; // Adjust the arc value to control the roundness of the corners
        int borderWidth = 0; 

        Graphics2D g2d = (Graphics2D) g.create();

        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        g2d.setColor(getBackground());
        g2d.fillArc(borderWidth, borderWidth, arc, arc, 90, 90);
        g2d.fillArc(getWidth() - (borderWidth + arc), borderWidth, arc, arc, 0, 90);
        g2d.fillRect(borderWidth+(arc/2), borderWidth, getWidth() - (2*borderWidth + arc), arc/2);
        g2d.fillRect(borderWidth, arc/2 + borderWidth, getWidth() - 2*borderWidth, getHeight() - (borderWidth + arc/2));

        g2d.setColor(getForeground());
        g2d.drawArc(borderWidth, borderWidth, arc, arc, 90, 90);
        g2d.drawArc(getWidth() - (borderWidth + arc), borderWidth, arc, arc, 0, 90);
        g2d.drawLine(borderWidth + arc/2, borderWidth, getWidth() - arc/2, borderWidth);
        g2d.drawLine(borderWidth, arc/3 + borderWidth, borderWidth, getHeight() - (borderWidth));
        g2d.drawLine(getWidth()- borderWidth-1, arc/3 + borderWidth, getWidth() - borderWidth-1, getHeight() - (borderWidth));

        g2d.dispose();
    }
}
/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import java.lang.reflect.Type;
import java.time.Instant;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ScheduledExecutorService;
import java.util.stream.Collectors;

import com.google.gson.Gson;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
//Business logic for managing all the trips within a session
public class SessionManager
{
	private final GPPerHourPlugin plugin;
	private final GPPerHourConfig config;
	private final ScheduledExecutorService executor;
	private final Gson gson;

	@Getter
	private final Map<String, TripData> activeTrips = new HashMap<>();
	@Getter
	private String activeSessionStartId;
	@Getter
	private String activeSessionEndId;

	public SessionManager(GPPerHourPlugin plugin, GPPerHourConfig config, ScheduledExecutorService executor, Gson gson)
	{
		this.plugin = plugin;
		this.config = config;
		this.executor = executor;
		this.gson = gson;
	}

	void refreshSessionTracking()
	{
		if (isTracking())
		{
			startTracking();
		}
		else
		{
			stopTracking();
		}
	}

	boolean isTracking()
	{
		return config.getEnableSessionTracking() && config.enableSessionPanel();
	}

	void startTracking()
	{
		if (plugin.getState() == RunState.BANK)
		{
			return;
		}
		TripData activeTrip = plugin.getRunData();
		if (activeTrip != null && !activeTrip.isBankDelay && !activeTrip.isFirstRun && activeTrip.isInProgress())
		{
			onTripStarted(activeTrip);
		}
	}

	void stopTracking()
	{
		//remove the active trip if there is one
		String activeTripIdentifier = null;
		for (TripData trip : activeTrips.values())
		{
			if (trip.isInProgress())
			{
				activeTripIdentifier = trip.identifier;
			}
		}
		if (activeTripIdentifier != null)
		{
			deleteTrip(activeTripIdentifier);
		}
	}

	private List<TripData> getSortedTrips()
	{
		return activeTrips.values().stream().sorted(Comparator.comparingLong(o -> o.runStartTime))
			.collect(Collectors.toList());
	}

	SessionStats getActiveSessionStats()
	{
		if (activeSessionStartId == null)
		{
			return null;
		}
		List<TripData> runDataSorted = getSortedTrips();

		long gains = 0;
		long losses = 0;
		long tripDurationSum = 0;
		long totalPauseTime = 0;
		boolean foundStart = false;
		int tripCount = 0;
		Map<Integer, Float> initialQtys = new HashMap<>();
		Map<Integer, Float> qtys = new HashMap<>();
		for (TripData runData : runDataSorted)
		{
			foundStart |= runData.identifier.equals(activeSessionStartId);
			if (!foundStart)
			{
				continue;
			}
			for (Integer initialId : runData.initialItemQtys.keySet())
			{
				initialQtys.merge(initialId, runData.initialItemQtys.get(initialId), Float::sum);
			}
			for (Integer itemId : runData.itemQtys.keySet())
			{
				qtys.merge(itemId, runData.itemQtys.get(itemId), Float::sum);
			}

			List<LedgerItem> ledger = GPPerHourPlugin.getProfitLossLedger(runData.initialItemQtys, runData.itemQtys);
			for (LedgerItem item : ledger)
			{
				long value = item.getCombinedValue();
				if (value > 0)
				{
					gains += value;
				}
				else
				{
					losses += value;
				}
			}
			tripDurationSum += runData.getRuntime();
			totalPauseTime += (runData.getEndTime()-runData.runStartTime) - runData.getRuntime();
			tripCount++;

			if (activeSessionEndId != null && activeSessionEndId.equals(runData.identifier))
			{
				break;
			}
		}
		if (!foundStart)
		{
			log.error("couldn't find start session");
			return null;
		}
		long sessionRuntime = 0;
		if (config.ignoreBankTime())
		{
			sessionRuntime = tripDurationSum;
		}
		else
		{
			long sessionStartTime = getSessionStartTime();
			long sessionEndTime = getSessionEndTime();
			sessionRuntime = (sessionEndTime - sessionStartTime) - totalPauseTime;
		}
		long netTotal = gains + losses;
		long avgTripDuration = (long) (tripDurationSum / ((float) tripCount));

		return new SessionStats(getSessionEndTime(), sessionRuntime, gains, losses, netTotal, tripCount, avgTripDuration, initialQtys, qtys);
	}

	long getSessionStartTime()
	{
		if (activeSessionStartId == null)
		{
			return 0;
		}
		return getSessionStartTrip().runStartTime;
	}

	long getSessionEndTime()
	{
		return (activeSessionEndId == null) ? Instant.now().toEpochMilli()
			: (activeTrips.get(activeSessionEndId).isInProgress() ? Instant.now().toEpochMilli()
			: activeTrips.get(activeSessionEndId).runEndTime);
	}

	boolean isTimeInActiveSession(long time)
	{
		long startTime = getSessionStartTime();
		long endTime = getSessionEndTime();
		return time >= startTime && time <= endTime;
	}

	void setSessionStart(String id)
	{
		activeSessionStartId = id;
		if (id != null)
		{
			TripData startTrip = getSessionStartTrip();
			TripData endtrip = getSessionEndTrip();
			// order is messed up, just make end same as start
			if (endtrip != null && endtrip.runStartTime < startTrip.runStartTime)
			{
				setSessionEnd(id);
			}
		}
	}

	void setSessionEnd(String id)
	{
		activeSessionEndId = id;
		if (id != null)
		{
			TripData startTrip = getSessionStartTrip();
			TripData endtrip = getSessionEndTrip();
			// order is messed up, just make start same as end
			if (startTrip != null && startTrip.runStartTime > endtrip.runStartTime)
			{
				setSessionStart(id);
			}
		}
	}

	TripData getSessionStartTrip()
	{
		if (activeSessionStartId == null)
		{
			return null;
		}
		return activeTrips.get(activeSessionStartId);
	}

	TripData getSessionEndTrip()
	{
		if (activeSessionEndId == null)
		{
			if (activeTrips.size() == 0)
			{
				return null;
			}
			else
			{
				List<TripData> sortedData = getSortedTrips();
				return sortedData.get(sortedData.size() - 1);
			}
		}
		return activeTrips.get(activeSessionEndId);
	}

	void deleteAllTrips()
	{
		List<TripData> allTrips = new LinkedList<>(activeTrips.values());
		activeSessionStartId = null;
		activeSessionEndId = null;
		for(TripData trip : allTrips)
		{
			if (trip.isInProgress())
			{
				activeSessionStartId = trip.identifier;
			}
			else
			{
				activeTrips.remove(trip.identifier);
			}
		}
	}

	//Deletes all trips that started before the specified time.
	void deleteAllTripsBefore(long time)
	{
		List<TripData> allTrips = new LinkedList<>(activeTrips.values());
		for(TripData trip : allTrips)
		{
			if (trip.runStartTime < time)
			{
				deleteTrip(trip.identifier);
			}
		}
	}

	void deleteTrip(String id)
	{
		activeTrips.remove(id);
		if (activeSessionStartId == id)
		{
			if (activeTrips.size() == 0)
			{
				activeSessionStartId = null;
			}
			else
			{
				activeSessionStartId = getSortedTrips().get(0).identifier;
			}
		}
		if (activeSessionEndId == id)
		{
			activeSessionEndId = null;
		}
	}

	void onTripStarted(TripData runData)
	{
		if (!isTracking())
		{
			return;
		}
		activeTrips.put(runData.identifier, runData);
		if (activeSessionStartId == null)
		{
			activeSessionStartId = runData.identifier;
		}
	}

	void onTripCompleted(TripData runData)
	{
		if (!isTracking())
		{
			return;
		}
		// don't care about trips where nothing happened, can remove it from the history
		if (!tripHadChange(runData.initialItemQtys, runData.itemQtys))
		{
			log.debug("nothing changed, ignoring trip");
			deleteTrip(runData.identifier);
			return;
		}
	}

	boolean tripHadChange(Map<Integer, Float> tripStart, Map<Integer, Float> tripEnd)
	{
		List<LedgerItem> ledger = GPPerHourPlugin.getProfitLossLedger(tripStart, tripEnd);
		return !ledger.isEmpty();
	}

	List<SessionStats> sessionHistory = new LinkedList<>();
	List<String> savedSessionIdentifiers = null;
	boolean sessionHistoryDirty;

	void saveNewSession(String name)
	{
		if (savedSessionIdentifiers == null)
		{
			log.error("can't save session, hasn't loaded sessions yet.");
			return;
		}
		executor.execute(()->
		{
			SessionStats statsToSave = getActiveSessionStats();
			if (statsToSave == null)
			{
				return;
			}
			statsToSave.sessionName = name;
			statsToSave.sessionID = UUID.randomUUID().toString();
			sessionHistory.add(statsToSave);

			String json = gson.toJson(statsToSave);
			plugin.saveData(GPPerHourConfig.getSessionKey(statsToSave.sessionID), json);

			savedSessionIdentifiers.add(statsToSave.sessionID);
			saveSessionIdentifiers();
			sessionHistoryDirty = true;
		});
	}

	//assume already exists
	void overwriteSession(SessionStats sessionStats)
	{
		if(sessionStats == null)
		{
			return;
		}
		executor.execute(()->
		{
			String json = gson.toJson(sessionStats);
			plugin.saveData( GPPerHourConfig.getSessionKey(sessionStats.sessionID), json);
			sessionHistoryDirty = true;
		});
	}

	void deleteSession(SessionStats sessionStats)
	{
		if (savedSessionIdentifiers == null)
		{
			log.error("can't delete session, hasn't loaded sessions yet.");
			return;
		}
		if (sessionStats == null)
		{
			return;
		}
		executor.execute(()->
		{
			sessionHistory.remove(sessionStats);
			plugin.deleteData(GPPerHourConfig.getSessionKey(sessionStats.sessionID));

			savedSessionIdentifiers.remove(sessionStats.sessionID);
			saveSessionIdentifiers();
			sessionHistoryDirty = true;
		});
	}

	void saveSessionIdentifiers()
	{
		String json = gson.toJson(savedSessionIdentifiers);
		plugin.saveData(GPPerHourConfig.sessionIdentifiersKey, json);
	}

	void reloadSessions()
	{
		sessionHistory.clear();
		savedSessionIdentifiers = null;
		executor.execute(()->
		{
			Type listType = new com.google.gson.reflect.TypeToken<List<String>>() {}.getType();
			String keysJSON = plugin.readData(GPPerHourConfig.sessionIdentifiersKey);
			try 
			{
				savedSessionIdentifiers = gson.fromJson(keysJSON, listType);
			}
			catch(Exception e)
			{
				log.error("Failed to load session identifiers from json: " + keysJSON, e);
				return;
			}
			if (savedSessionIdentifiers == null)
			{
				savedSessionIdentifiers = new LinkedList<>();
			}
			for (String sessionIdentifier : savedSessionIdentifiers)
			{
				String json = plugin.readData(GPPerHourConfig.getSessionKey(sessionIdentifier));
				if	(json == null)
				{
					continue;
				}
				try 
				{
					SessionStats sessionStats = gson.fromJson(json, SessionStats.class);
					sessionHistory.add(sessionStats);
				}
				catch(Exception e)
				{
					log.error("Failed to load session data from json: " + json, e);
					return;
				}
			}
			sessionHistoryDirty = true;
		});
	}
}

/*
 * Copyright (c) 2023, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.triggers;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.function.Consumer;

public class TriggerWidget {
    public static final int WIDGET_DEFAULT_GROUP_ID = 193;
    public static final int WIDGET_DEFAULT_CHILD_ID = 2;

    public static final int WIDGET_NPC_GROUP_ID = 231;
    public static final int WIDGET_NPC_CHILD_ID = 6;

    @Nonnull public final String message;

    public int group_id;
    public int child_id;
    public Integer sub_child_id;

    public boolean increase_dynamically;

    @Nullable public Consumer<String> consumer;
    @Nullable public Integer charges;

    public TriggerWidget(final int group_id, final int child_id, @Nonnull final String message) {
        this.group_id = group_id;
        this.child_id = child_id;
        this.message = message;
    }

    public TriggerWidget(final int group_id, final int child_id, final int sub_child_id, @Nonnull final String message) {
        this.group_id = group_id;
        this.child_id = child_id;
        this.sub_child_id = sub_child_id;
        this.message = message;
    }

    public TriggerWidget fixedCharges(final int charges) {
        this.charges = charges;
        return this;
    }

    public TriggerWidget extraConsumer(@Nonnull final Consumer<String> consumer) {
        this.consumer = consumer;
        return this;
    }

    public TriggerWidget increaseDynamically() {
        this.increase_dynamically = true;
        return this;
    }
}

/*
 * Copyright (c) 2023, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.triggers;

import java.util.function.Consumer;

import net.runelite.api.TileItem;

public class TriggerItemDespawn {

    public final Consumer<TileItem> consumer;

    public TriggerItemDespawn(final Consumer<TileItem> consumer) {
        this.consumer = consumer;
    }
}

/*
 * Copyright (c) 2023, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.triggers;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

public class TriggerAnimation {
    public final int animation_id;

    public int charges;
    public boolean decrease_charges;
    public boolean equipped;
    public boolean menu_target;

    @Nullable public int[] unallowed_items;
    @Nullable public String menu_option;

    public TriggerAnimation(final int animation_id) {
        this.animation_id = animation_id;
    }

    public TriggerAnimation increaseCharges(final int charges) {
        this.charges = charges;
        this.decrease_charges = false;
        return this;
    }

    public TriggerAnimation decreaseCharges(final int decharges) {
        this.charges = decharges;
        this.decrease_charges = true;
        return this;
    }

    public TriggerAnimation equipped() {
        this.equipped = true;
        return this;
    }

    public TriggerAnimation onItemClick() {
        this.menu_target = true;
        return this;
    }

    public TriggerAnimation unallowedItems(@Nonnull final int[] unallowed_items) {
        this.unallowed_items = unallowed_items;
        return this;
    }

    public TriggerAnimation onMenuOption(@Nonnull final String menu_option) {
        this.menu_option = menu_option;
        return this;
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.triggers;

import javax.annotation.Nullable;

public class TriggerItemContainer {
    public final int inventory_id;

    public boolean increase_by_difference;
    public boolean add_difference;
    public Runnable extra_consumer;

    @Nullable public String menu_target;
    @Nullable public String menu_option;
    @Nullable public Integer fixed_charges;

    public TriggerItemContainer(final int inventory_id) {
        this.inventory_id = inventory_id;
    }

    public TriggerItemContainer menuTarget(final String menu_target) {
        this.menu_target = menu_target;
        return this;
    }

    public TriggerItemContainer menuOption(final String menu_option) {
        this.menu_option = menu_option;
        return this;
    }

    public TriggerItemContainer fixedCharges(final int fixed_charges) {
        this.fixed_charges = fixed_charges;
        return this;
    }

    public TriggerItemContainer increaseByDifference() {
        this.increase_by_difference = true;
        return this;
    }

    public TriggerItemContainer addDifference() {
        this.add_difference = true;
        return this;
    }

    public TriggerItemContainer extraConsumer(Runnable r) {
        this.extra_consumer = r;
        return this;
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.triggers;

import javax.annotation.Nullable;

public class TriggerItem {
    public final int item_id;
    public final boolean is_open_container;

    @Nullable public Integer fixed_charges;
    @Nullable public Integer max_charges;

    public TriggerItem(final int item_id) {
        this.item_id = item_id;
        this.is_open_container = false;
    }

    public TriggerItem(final int item_id, final boolean is_open_container) {
        this.item_id = item_id;
        this.is_open_container = is_open_container;
    }

    public TriggerItem fixedCharges(final int charges) {
        this.fixed_charges = charges;
        return this;
    }

    public TriggerItem maxCharges(final int charges) {
        this.max_charges = charges;
        return this;
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.triggers;

import net.runelite.api.Skill;

public class TriggerXPDrop {

    public final Skill skill;
    public final int discharges;

    private Integer lastXP = null;

    public TriggerXPDrop(final Skill skill, final int discharges) {
        this.skill = skill;
        this.discharges = discharges;
    }

    public boolean updateXP(int currentXP)
    {
        if (lastXP == null || lastXP == currentXP)
        {
            lastXP = currentXP;
            return false;
        }
        lastXP = currentXP;
        return true;
    }
}

/*
 * Copyright (c) 2023, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.triggers;

import net.runelite.api.HitsplatID;

import javax.annotation.Nullable;

public class TriggerHitsplat {
    public final int hitsplat_id;
    public final int discharges;

    public boolean self;
    public boolean equipped;

    @Nullable public int[] animations;

    public TriggerHitsplat(final int discharges) {
        this.hitsplat_id = HitsplatID.DAMAGE_ME;
        this.discharges = discharges;
    }

    public TriggerHitsplat onSelf() {
        this.self = true;
        return this;
    }

    public TriggerHitsplat onEnemy() {
        this.self = false;
        return this;
    }

    public TriggerHitsplat equipped() {
        this.equipped = true;
        return this;
    }

    public TriggerHitsplat onAnimations(final int[] animations) {
        this.animations = animations;
        return this;
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.triggers;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.function.Consumer;
import java.util.regex.Pattern;

public class TriggerChatMessage {
    @Nonnull public final Pattern message;

    public boolean menu_target;
    public boolean equipped;
    public boolean inventory_same;
    public boolean inventory_count_same;
    public boolean multiple_charges;
    public boolean increase_dynamically;
    public boolean decrease_dynamically;
    public boolean notification;

    @Nullable public Consumer<String> consumer;
    @Nullable public Integer fixed_charges;
    @Nullable public Integer decrease_charges;
    @Nullable public Integer increase_charges;
    @Nullable public String notification_message;

    public TriggerChatMessage(@Nonnull final String message) {
        this.message = Pattern.compile(message);
    }

    public TriggerChatMessage fixedCharges(final int charges) {
        this.fixed_charges = charges;
        return this;
    }

    public TriggerChatMessage onItemClick() {
        this.menu_target = true;
        return this;
    }

    public TriggerChatMessage increaseCharges(final int charges) {
        this.increase_charges = charges;
        return this;
    }

    public TriggerChatMessage decreaseCharges(final int charges) {
        this.decrease_charges = charges;
        return this;
    }

    public TriggerChatMessage equipped() {
        this.equipped = true;
        return this;
    }

    public TriggerChatMessage inventorySame() {
        this.inventory_same = true;
        return this;
    }

    public TriggerChatMessage inventoryCountSame() {
        this.inventory_count_same = true;
        return this;
    }

    public TriggerChatMessage extraConsumer(final Consumer<String> consumer) {
        this.consumer = consumer;
        return this;
    }

    public TriggerChatMessage multipleCharges() {
        this.multiple_charges = true;
        return this;
    }

    public TriggerChatMessage increaseDynamically() {
        this.increase_dynamically = true;
        return this;
    }

    public TriggerChatMessage decreaseDynamically() {
        this.decrease_dynamically = true;
        return this;
    }

    public TriggerChatMessage notification() {
        this.notification = true;
        return this;
    }

    public TriggerChatMessage notification(final String message) {
        this.notification = true;
        this.notification_message = message;
        return this;
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.triggers;

import java.util.function.Consumer;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

public class TriggerMenuOption {
    @Nullable public final String target;
    @Nonnull public final String option;

    @Nullable public Integer charges;
    @Nullable public Consumer<String> consumer;

    public TriggerMenuOption(@Nonnull final String target, @Nonnull final String option) {
        this.target = target;
        this.option = option;
    }

    public TriggerMenuOption(@Nonnull final String option) {
        this.target = null;
        this.option = option;
    }

    public TriggerMenuOption fixedCharges(final int charges) {
        this.charges = charges;
        return this;
    }

    public TriggerMenuOption extraConsumer(final Consumer<String> consumer) {
        this.consumer = consumer;
        return this;
    }
}

/*
 * Copyright (c) 2023, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.triggers;

import javax.annotation.Nullable;

public class TriggerReset {
    public final int charges;

    @Nullable public Integer item_id;

    public TriggerReset(final int charges) {
        this.charges = charges;
    }

    public TriggerReset dynamicItem(final int item_id) {
        this.item_id = item_id;
        return this;
    }
}

/*
 * Copyright (c) 2023, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.triggers;

import javax.annotation.Nullable;

public class TriggerGraphic {
    public final int graphic_id;

    public int charges;
    public boolean decrease_charges;
    public boolean equipped;

    @Nullable public int[] unallowed_items;
    @Nullable public String menu_option;

    public TriggerGraphic(final int graphic_id) {
        this.graphic_id = graphic_id;
    }

    public TriggerGraphic increaseCharges(final int charges) {
        this.charges = charges;
        this.decrease_charges = false;
        return this;
    }

    public TriggerGraphic decreaseCharges(final int decharges) {
        this.charges = decharges;
        this.decrease_charges = true;
        return this;
    }

    public TriggerGraphic equipped() {
        this.equipped = true;
        return this;
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges;

public enum ChargesItem {
	ASH_SANCTIFIER,
	BLOOD_ESSENCE,
	BOTTOMLESS_COMPOST_BUCKET,
	FISH_BARREL,
	KHAREDSTS_MEMOIRS,
	LOG_BASKET,
	GEM_BAG,
	HERB_SACK,
	SEED_BOX,
    COAL_BAG
}


/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.gpperhour.GPPerHourConfig;
import com.gpperhour.itemcharges.triggers.TriggerAnimation;
import com.gpperhour.itemcharges.triggers.TriggerChatMessage;
import com.gpperhour.itemcharges.triggers.TriggerGraphic;
import com.gpperhour.itemcharges.triggers.TriggerHitsplat;
import com.gpperhour.itemcharges.triggers.TriggerItem;
import com.gpperhour.itemcharges.triggers.TriggerItemContainer;
import com.gpperhour.itemcharges.triggers.TriggerItemDespawn;
import com.gpperhour.itemcharges.triggers.TriggerMenuOption;
import com.gpperhour.itemcharges.triggers.TriggerReset;
import com.gpperhour.itemcharges.triggers.TriggerWidget;
import com.gpperhour.itemcharges.triggers.TriggerXPDrop;
import com.google.gson.Gson;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuAction;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicChanged;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.http.api.item.ItemPrice;

@Slf4j
public class ChargedItem {

	@Data
	@AllArgsConstructor
	public class PickupAction
	{
		int itemId;
		WorldPoint worldPoint;
	}
	
	public final ChargesItem infobox_id;
	public int item_id;
	protected final Client client;
	protected final ClientThread client_thread;
	protected final ItemManager items;
	protected final ConfigManager configs;
	protected final ChatMessageManager chat_messages;
	protected final Notifier notifier;
	protected final Gson gson;
	protected final ScheduledExecutorService executorService;

	@Nullable public ItemContainer inventory;
	@Nullable protected ItemContainer equipment;
	@Nullable private Item[] inventory_items;

	@Nullable protected String config_key;
	@Nullable protected String[] extra_config_keys;
	@Nullable protected TriggerChatMessage[] triggers_chat_messages;
	@Nullable protected TriggerAnimation[] triggers_animations;
	@Nullable protected TriggerGraphic[] triggers_graphics;
	@Nullable protected TriggerHitsplat[] triggers_hitsplats;
	@Nullable protected TriggerItem[] triggers_items;
	@Nullable protected TriggerWidget[] triggers_widgets;
	@Nullable protected TriggerReset[] triggers_resets;
	@Nullable protected TriggerItemContainer[] triggers_item_containers;
	@Nullable protected TriggerMenuOption[] triggers_menu_options;
	@Nullable protected TriggerXPDrop[] triggers_xp_drops;
	@Nullable protected TriggerItemDespawn trigger_item_despawn;
	protected boolean supportsWidgetOnWidget = false;

	private PickupAction lastPickUpAction;
	private boolean in_equipment;
	private boolean in_inventory;
	private final List<String[]> menu_entries = new ArrayList<>();
	private int animation = -1;
	private int graphic = -1;
	private int lastUseOnMeTick = -2;
	private boolean isInInventoryOrEquipment;
	protected int charges = ChargedItemManager.CHARGES_UNKNOWN;
	@Getter
	protected Map<Integer, Float> itemQuantities = null;

	@Nullable 
	protected Integer negative_full_charges;
	protected boolean zero_charges_is_positive = false;
	// Some items (specifically blood essence) will get their chat message before they are present in the inventory (when activating)
	protected boolean allow_chat_messages_when_not_present = false;
	private int gametick = 0;
	private int gametick_before = 0;

	public ChargedItem(
		final ChargesItem infobox_id,
		final int item_id,
		final Client client,
		final ClientThread client_thread,
		final ConfigManager configs,
		final ItemManager items,
		final ChatMessageManager chat_messages,
		final Notifier notifier,
		final Gson gson,
		final ScheduledExecutorService executorService
	) {
		this.infobox_id = infobox_id;
		this.item_id = item_id;
		this.client = client;
		this.client_thread = client_thread;
		this.configs = configs;
		this.items = items;
		this.chat_messages = chat_messages;
		this.notifier = notifier;
		this.gson = gson;
		this.executorService = executorService;

		client_thread.invokeLater(() -> {
			loadChargesFromConfig();
			onChargesUpdated();
			onItemContainerUpdated(client.getItemContainer(InventoryID.INV));
			onItemContainerUpdated(client.getItemContainer(InventoryID.WORN));
		});
	}

	protected void emptyOrClear()
	{
		if (itemQuantities == null)
			itemQuantities = new HashMap<>();
		else
			itemQuantities.clear();
		onItemQuantitiesModified();
	}

	protected void addItems(Integer itemId, Float count)
	{
		itemQuantities.merge(itemId, count, Float::sum);
		onItemQuantitiesModified();
	}

	protected Integer getItemCount()
	{
		if (itemQuantities == null)
			return 0;
		Float itemCount = 0f;
		for	(Float quantity : itemQuantities.values())
		{
			itemCount += quantity;
		}
		return Math.round(itemCount);
	}

	public boolean hasChargeData()
	{
		return this.charges != ChargedItemManager.CHARGES_UNKNOWN || itemQuantities != null;
	}

	public void onStatChanged(StatChanged event)
	{
		if (!hasChargeData())
			return;
		if (!isInInventoryOrEquipment)
			return;
		if (event.getXp() <= 0)
			return;

		if (triggers_xp_drops != null) {
			for (final TriggerXPDrop trigger_xp_drop : triggers_xp_drops) {
				// Skill is wrong.
				if (trigger_xp_drop.skill != event.getSkill())
					continue;

				if (trigger_xp_drop.updateXP(event.getXp()))
					decreaseCharges(trigger_xp_drop.discharges);
			}
		}
	}

	public void onItemDespawned(ItemDespawned event)
	{
		if (!hasChargeData())
			return;
		if (!isInInventoryOrEquipment)
			return;
		if (this.triggers_items == null)
			return;
		if (this.trigger_item_despawn == null)
			return;
		if (lastPickUpAction == null)
			return;
		if (!event.getTile().getWorldLocation().equals(client.getLocalPlayer().getWorldLocation()))
			return;
		if (!event.getTile().getWorldLocation().equals(lastPickUpAction.getWorldPoint()))
			return;
		if (event.getItem().getId() != lastPickUpAction.getItemId())
			return;
		
		for (TriggerItem triggerItem : this.triggers_items)
		{
			if (triggerItem.item_id == this.item_id)
			{
				//Check to see if the item ID we are currently mapped to is an open container
				if (!triggerItem.is_open_container)
					return;
			}
		}

		trigger_item_despawn.consumer.accept(event.getItem());
	}

	//avoid GC
	private final Map<Integer, Integer> differenceMap = new HashMap<>();

	public void onItemContainersChanged(final ItemContainerChanged event) {

		onItemContainerUpdated(event.getItemContainer());
	}

	protected void onItemContainerUpdated(final ItemContainer itemContainer)
	{
		if (itemContainer == null)
			return;

		int containerId = itemContainer.getId();

		// Find items difference before items are overridden.
		int items_difference = 0;
		if (containerId == InventoryID.INV && inventory_items != null) {
			items_difference = itemsDifference(inventory_items, itemContainer.getItems());
		}

		differenceMap.clear();
		if (containerId == InventoryID.INV && inventory_items != null) {
			Item[] before = inventory_items;
			Item[] after = itemContainer.getItems();
			for (Item beforeItem : before)
			{
				differenceMap.merge(beforeItem.getId(), 1, Integer::sum);
			}
			for (Item afterItem : after)
			{
				differenceMap.merge(afterItem.getId(), -1, Integer::sum);
			}
		}
		if (containerId == InventoryID.INV)
		{
			if (itemQuantities != null && supportsWidgetOnWidget &&
				(lastUseOnMeTick == client.getTickCount() || lastUseOnMeTick + 1 == client.getTickCount()))
			{
				for (Integer itemId : differenceMap.keySet())
				{
					Integer count = differenceMap.get(itemId);
					if (count > 0)
					{
						addItems(itemId, (float) count);
					}
				}
			}
		}

		// Update inventory reference.
		if (containerId == InventoryID.INV) {
			inventory = itemContainer;
			inventory_items = inventory.getItems();
		}

		if (triggers_item_containers != null) {
			for (final TriggerItemContainer trigger_item_container : triggers_item_containers) {
				// Item container is wrong.
				if (trigger_item_container.inventory_id != containerId) continue;

				// Menu target check.
				if (
					trigger_item_container.menu_target != null &&
						menu_entries.stream().noneMatch(entry -> entry[0].equals(trigger_item_container.menu_target))
				) continue;

				// Menu option check.
				if (
					trigger_item_container.menu_option != null &&
						menu_entries.stream().noneMatch(entry -> entry[1].equals(trigger_item_container.menu_option))
				) continue;

				// Fixed charges.
				if (trigger_item_container.fixed_charges != null) {
					setCharges(trigger_item_container.fixed_charges);
					break;
				}

				// Increase by difference of amount of items.
				if (trigger_item_container.increase_by_difference) {
					increaseCharges(items_difference);
					break;
				}
				
				//add missing items
				if (trigger_item_container.add_difference && itemQuantities != null) {

					for (Integer itemId : differenceMap.keySet())
					{
						Integer count = differenceMap.get(itemId);
						if (count != 0)
						{
							addItems(itemId, (float) count);
						}
					}
					break;
				}

				if (trigger_item_container.extra_consumer != null)
				{
					trigger_item_container.extra_consumer.run();
					break;
				}
			}
		}

		// Save inventory and equipment item containers for other uses.
		if (containerId == InventoryID.INV) {
			inventory = itemContainer;
		} else if (containerId == InventoryID.WORN) {
			equipment = itemContainer;
		}

		// No trigger items to detect charges.
		if (triggers_items == null) return;

		boolean in_equipment = false;
		boolean in_inventory = false;
		boolean inInventoryOrEquipment = false;
		Integer charges = null;

		for (final TriggerItem trigger_item : triggers_items) {
			// Find out if item is equipped.
			final boolean in_equipment_item = equipment != null && equipment.contains(trigger_item.item_id);
			final boolean in_inventory_item = inventory != null && inventory.contains(trigger_item.item_id);

			// Find out if infobox should be rendered.
			if (in_inventory_item || in_equipment_item) {
				inInventoryOrEquipment = true;

				// Update infobox item picture and tooltip dynamically based on the items if use has different variant of it.
				if (trigger_item.item_id != item_id) {
					updateItemId(trigger_item.item_id);
				}

				if (in_equipment_item) in_equipment = true;
				if (in_inventory_item) in_inventory = true;
			}

			// Item not found, don't calculate charges.
			if (!in_equipment_item && !in_inventory_item) continue;

			// Find out charges for the item.
			if (trigger_item.fixed_charges != null) {
				if (charges == null) charges = 0;
				charges += inventory != null ? inventory.count(trigger_item.item_id) * trigger_item.fixed_charges : 0;
				charges += equipment != null ? equipment.count(trigger_item.item_id) * trigger_item.fixed_charges : 0;
			}
		}

		// Update infobox variables for other triggers.
		this.in_equipment = in_equipment;
		this.in_inventory = in_inventory;
		this.isInInventoryOrEquipment = inInventoryOrEquipment;
		if (charges != null) this.charges = charges;
	}

	public void onChatMessage(final ChatMessage event) {
		if (
			// No chat messages triggers.
			triggers_chat_messages == null ||
				// Message type that we are not interested in.
				event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM && event.getType() != ChatMessageType.MESBOX ||
				// No config to save charges to.
				config_key == null ||
				// Not in inventory nor in equipment.
				(!isInInventoryOrEquipment && !allow_chat_messages_when_not_present)
		) return;

		final String message = event.getMessage().replaceAll("</?col.*?>", "").replace("<br>", " ").replace("\u00A0", " ");

		for (final TriggerChatMessage chat_message : triggers_chat_messages) {
			final Pattern regex = chat_message.message;
			final Matcher matcher = regex.matcher(message);

			// Message does not match the pattern.
			if (!matcher.find()) continue;

			// Menu target check.
			if (
				chat_message.menu_target &&
					menu_entries.stream().noneMatch(entry -> entry[0].equals(items.getItemComposition(item_id).getName()))
			) continue;

			// Item needs to be equipped.
			if (chat_message.equipped && !in_equipment) continue;

			// Increase charges by fixed amount.
			if (chat_message.increase_charges != null) {
				increaseCharges(chat_message.increase_charges);

				// Decrease charges by fixed amount.
			} else if (chat_message.decrease_charges != null) {
				decreaseCharges(chat_message.decrease_charges);

				// Set charges to fixed amount.
			} else if (chat_message.fixed_charges != null) {
				setCharges(chat_message.fixed_charges);

				// Set charges from multiple amounts.
			} else if (chat_message.multiple_charges) {
				int charges = 0;

				final Matcher matcher_multiple = Pattern.compile(".*?(\\d+)").matcher(message);
				while (matcher_multiple.find()) {
					charges += Integer.parseInt(matcher_multiple.group(1));
				}

				setCharges(charges);

				// Custom consumer.
			} else if (chat_message.consumer != null) {
				chat_message.consumer.accept(message);

				// Set charges dynamically from the chat message.
			} else if (matcher.group("charges") != null) {
				try {
					final int charges = Integer.parseInt(matcher.group("charges").replaceAll(",", "").replaceAll("\\.", ""));

					if (chat_message.increase_dynamically) {
						increaseCharges(charges);
					} else if(chat_message.decrease_dynamically) {
						decreaseCharges(charges);
					} else {
						setCharges(charges);
					}
				} catch (final Exception ignored) {}

				// No trigger found.
			} else {
				continue;
			}

			// Check extra matches groups.
			if (extra_config_keys != null) {
				for (final String extra_group : extra_config_keys) {
					final String extra = matcher.group(extra_group);
					if (extra != null) {
						setConfiguration(config_key + "_" + extra_group, extra.replaceAll(",", ""));
						onChargesUpdated();
					}
				}
			}

			// Notifications.
			if (chat_message.notification) {
				notifier.notify(chat_message.notification_message != null ? chat_message.notification_message : message);
			}

			// Chat message used, no need to check other messages.
			return;
		}
	}
	public void onWidgetLoaded(final WidgetLoaded event) {
		if (triggers_widgets == null || config_key == null) return;

		client_thread.invokeLater(() -> {
			for (final TriggerWidget trigger_widget : triggers_widgets) {
				if (event.getGroupId() != trigger_widget.group_id) continue;

				Widget widget = client.getWidget(trigger_widget.group_id, trigger_widget.child_id);
				if (trigger_widget.sub_child_id != null && widget != null) widget = widget.getChild(trigger_widget.sub_child_id);
				if (widget == null) continue;

				final String message = widget.getText().replaceAll("</?col.*?>", "").replaceAll("<br>", " ");
				final Pattern regex = Pattern.compile(trigger_widget.message);
				final Matcher matcher = regex.matcher(message);
				if (!matcher.find()) continue;

				// Charges amount is fixed.
				if (trigger_widget.charges != null) {
					setCharges(trigger_widget.charges);
					// Charges amount has custom logic.
				} else if (trigger_widget.consumer != null) {
					trigger_widget.consumer.accept(message);
					// Charges amount is dynamic.
				} else if (matcher.group("charges") != null) {
					final int charges = Integer.parseInt(matcher.group("charges").replaceAll(",", ""));

					// Charges increased dynamically.
					if (trigger_widget.increase_dynamically) {
						increaseCharges(charges);
					} else {
						setCharges(charges);
					}
				}

				// Check extra matches groups.
				if (extra_config_keys != null) {
					for (final String extra_group : extra_config_keys) {
						final String extra = matcher.group(extra_group);
						if (extra != null) setConfiguration(config_key + "_" + extra_group, extra);
					}
				}
			}
		});
	}

	public void onAnimationChanged(final AnimationChanged event) {
		// Player check.
		if (event.getActor() != client.getLocalPlayer()) return;

		// Save animation ID for others to use.
		animation = event.getActor().getAnimation();

		// No animations to check.
		if (inventory == null || triggers_animations == null || charges == ChargedItemManager.CHARGES_UNKNOWN || triggers_items == null) return;

		// Check all animation triggers.
		for (final TriggerAnimation trigger_animation : triggers_animations) {
			// Valid animation id check.
			if (trigger_animation.animation_id != event.getActor().getAnimation()) continue;

			// Unallowed items check.
			if (trigger_animation.unallowed_items != null) {
				boolean unallowed_items = false;
				for (final int item_id : trigger_animation.unallowed_items) {
					if (inventory.contains(item_id) || equipment != null && equipment.contains(item_id)) {
						unallowed_items = true;
						break;
					}
				}
				if (unallowed_items) continue;
			}

			// Equipped check.
			if (trigger_animation.equipped) {
				boolean equipped = false;
				for (final TriggerItem trigger_item : triggers_items) {
					if (equipment != null && equipment.contains(trigger_item.item_id)) {
						equipped = true;
						break;
					}
				}
				if (!equipped) continue;
			}

			// Menu target check.
			if (
				trigger_animation.menu_target &&
					menu_entries.stream().noneMatch(entry -> entry[0].equals(items.getItemComposition(item_id).getName()))
			) continue;

			// Menu option check.
			if (
				trigger_animation.menu_option != null &&
					menu_entries.stream().noneMatch(entry -> entry[1].equals(trigger_animation.menu_option))
			) continue;

			// Valid trigger, modify charges.
			if (trigger_animation.decrease_charges) {
				decreaseCharges(trigger_animation.charges);
			} else {
				increaseCharges(trigger_animation.charges);
			}
		}
	}

	public void onGraphicChanged(final GraphicChanged event) {
		// Player check.
		if (event.getActor() != client.getLocalPlayer()) return;

		// Save animation ID for others to use.
		graphic = event.getActor().getGraphic();

		// No animations to check.
		if (inventory == null || triggers_graphics == null || charges == ChargedItemManager.CHARGES_UNKNOWN || triggers_items == null) return;

		// Check all animation triggers.
		for (final TriggerGraphic trigger_graphic : triggers_graphics) {
			// Valid animation id check.
			if (!event.getActor().hasSpotAnim(trigger_graphic.graphic_id)) continue;

			// Unallowed items check.
			if (trigger_graphic.unallowed_items != null) {
				boolean unallowed_items = false;
				for (final int item_id : trigger_graphic.unallowed_items) {
					if (inventory.contains(item_id) || equipment != null && equipment.contains(item_id)) {
						unallowed_items = true;
						break;
					}
				}
				if (unallowed_items) continue;
			}

			// Equipped check.
			if (trigger_graphic.equipped) {
				boolean equipped = false;
				for (final TriggerItem trigger_item : triggers_items) {
					if (equipment != null && equipment.contains(trigger_item.item_id)) {
						equipped = true;
						break;
					}
				}
				if (!equipped) continue;
			}

			// Menu option check.
			if (trigger_graphic.menu_option != null && (menu_entries.stream().noneMatch(entry -> entry[1].equals(trigger_graphic.menu_option)))) continue;

			// Valid trigger, modify charges.
			if (trigger_graphic.decrease_charges) {
				decreaseCharges(trigger_graphic.charges);
			} else {
				increaseCharges(trigger_graphic.charges);
			}
		}
	}

	public void onHitsplatApplied(final HitsplatApplied event) {
		if (triggers_hitsplats == null) return;

		// Check all hitsplat triggers.
		for (final TriggerHitsplat trigger_hitsplat : triggers_hitsplats) {
			// Player check.
			if (trigger_hitsplat.self && event.getActor() != client.getLocalPlayer()) continue;

			// Enemy check.
			if (!trigger_hitsplat.self && (event.getActor() == client.getLocalPlayer() || event.getHitsplat().isOthers())) continue;

			// Hitsplat type check.
			if (trigger_hitsplat.hitsplat_id != event.getHitsplat().getHitsplatType()) continue;

			// Equipped check.
			if (trigger_hitsplat.equipped && triggers_items != null && equipment != null) {
				boolean equipped = false;
				for (final TriggerItem trigger_item : triggers_items) {
					if (equipment.contains(trigger_item.item_id)) {
						equipped = true;
						break;
					}
				}
				if (!equipped) continue;
			}

			// Animation check.
			if (trigger_hitsplat.animations != null) {
				boolean valid = false;
				for (final int animation : trigger_hitsplat.animations) {
					if (animation == this.animation) {
						valid = true;
						break;
					}
				}
				if (!valid) continue;
			}

			// Valid hitsplat, modify charges.
			decreaseCharges(trigger_hitsplat.discharges);
		}
	}

	public void onMenuOptionClicked(final MenuOptionClicked event) {

		if (event.getMenuAction() == MenuAction.GROUND_ITEM_THIRD_OPTION && event.getMenuOption().equals("Take"))
		{
			WorldPoint point = WorldPoint.fromScene(client, event.getParam0(), event.getParam1(), client.getPlane());
			lastPickUpAction = new PickupAction(event.getId(), point);
		}
		if (event.getMenuAction() == MenuAction.WIDGET_TARGET_ON_WIDGET && this.supportsWidgetOnWidget) {
			ItemContainer itemContainer = client.getItemContainer(InventoryID.INV);
			if (itemContainer == null)
				return;
			Widget widgetA = client.getSelectedWidget();
			if (widgetA == null)
				return;
			Item itemA = itemContainer.getItem(widgetA.getIndex());
			if (itemA == null) 
				return;
			int itemAId = itemA.getId();
			Widget widgetB = event.getWidget();
			if (widgetB == null)
				return;
			Item itemB = itemContainer.getItem(widgetB.getIndex());
			if (itemB == null) 
				return;
			int itemBId = itemB.getId();

			boolean usedItemOnMe = this.item_id == itemAId || this.item_id == itemBId;
			if (usedItemOnMe)
			{
				lastUseOnMeTick = client.getTickCount();
			}
		}

		final String menu_target = event.getMenuTarget().replaceAll("</?col.*?>", "");
		final String menu_option = event.getMenuOption();

		if (
			// Not menu.
			menu_target.length() == 0 ||
				// Item not in inventory nor equipment.
				!in_inventory && !in_equipment ||
				// Menu option not found.
				menu_option == null || menu_option.length() == 0
		) {
			return;
		}

		// Gametick changed, clear previous menu entries since they are no longer valid.
		if (gametick > gametick_before + 1) {
			gametick = 0; gametick_before = 0;
			menu_entries.clear();
		}

		// Save menu option and target for other triggers to use.
		menu_entries.add(new String[]{menu_target, menu_option});

		// No menu option triggers.
		if (triggers_menu_options == null) return;

		for (final TriggerMenuOption trigger_menu_option : triggers_menu_options) {
			if (
				!trigger_menu_option.option.equals(menu_option) ||
					trigger_menu_option.target != null && !trigger_menu_option.target.equals(menu_target)
			) continue;

			// Fixed charges.
			new Thread(() -> {
				try { Thread.sleep(600); } catch (final Exception ignored) {}

				if (trigger_menu_option.charges != null)
				{
					setCharges(trigger_menu_option.charges);
				}
				else
				{
					trigger_menu_option.consumer.accept(menu_target);
				}
			}).start();

			// Menu option used.
			return;
		}
	}

	public void resetCharges() {
		if (triggers_resets == null) return;

		// Send message about item charges being reset if player has it on them.
		if (in_equipment || in_inventory) {
			client_thread.invokeLater(() -> {
				chat_messages.queue(QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage("<colHIGHLIGHT>" + items.getItemComposition(item_id).getName() + " daily charges have been reset.")
					.build()
				);
			});
		}

		// Check for item resets.
		for (final TriggerReset trigger_reset : triggers_resets) {
			// Same item variations have different amount of charges.
			if (trigger_reset.item_id != null) {
				if (item_id == trigger_reset.item_id) {
					setCharges(trigger_reset.charges);
				}

				// All variants of the item reset to the same amount of charges.
			} else {
				setCharges(trigger_reset.charges);
			}
		}
	}

	private void loadChargesFromConfig() {
		if (config_key == null) 
			return;
		
		try {
			charges = Integer.parseInt(configs.getRSProfileConfiguration(GPPerHourConfig.GROUP, config_key));
			return;
		} catch (final Exception ignored) {}

		//if that didn't work try loading map
		try {
			Type mapType = new com.google.gson.reflect.TypeToken<Map<Integer, Float>>() {}.getType();
			itemQuantities = gson.fromJson(configs.getRSProfileConfiguration(GPPerHourConfig.GROUP, config_key), mapType);
			return;
		} catch (final Exception ignored) {}

	}

	public void setCharges(final int charges) {
		if (this.negative_full_charges != null && charges > this.negative_full_charges) return;

		this.charges = charges;
		onChargesUpdated();

		if (config_key != null) {
			setConfiguration(config_key, charges);
		}
	}

	private boolean itemQuantitiesNeedsSaving = false;

	private void onItemQuantitiesModified() {

		itemQuantitiesNeedsSaving = true;
	}

	private void saveItemQuantities()
	{
		itemQuantitiesNeedsSaving = false;
		executorService.execute(()->
		{
			if (config_key != null) {
				setConfiguration(config_key, gson.toJson(this.itemQuantities));
			}
		});
	}

	private void decreaseCharges(final int charges) {
		if (this.charges - charges < 0) return;
		setCharges(this.charges - charges);
	}

	public void increaseCharges(final int charges) {
		if (this.charges < 0) return;
		setCharges(this.charges + charges);
	}

	private void setConfiguration(final String key, @Nonnull final String value) {
		configs.setRSProfileConfiguration(GPPerHourConfig.GROUP, key, value);
	}

	private void setConfiguration(final String key, final int value) {
		configs.setRSProfileConfiguration(GPPerHourConfig.GROUP, key, value);
	}

	private void updateItemId(final int item_id) {
		this.item_id = item_id;
	}

	protected void onChargesUpdated() {}

	public void onGameTick(final GameTick ignored) {

		gametick++;
		if (itemQuantitiesNeedsSaving)
		{
			saveItemQuantities();
		}
	}

	private int itemsDifference(final Item[] items_before, final Item[] items_after) {
		final int items_before_count = (int) Arrays.stream(items_before).filter(item -> item.getId() != -1).count();
		final int items_after_count = (int) Arrays.stream(items_after).filter(item -> item.getId() != -1).count();

		return Math.abs(items_before_count - items_after_count);

	}

	private final static Map<String, Integer> nameToIdLookup = new HashMap<>();

	//only works on tradeable items
	protected Integer tryFindItemIdFromName(String name)
	{
		name = name.toLowerCase().trim();

		if (nameToIdLookup.containsKey(name))
		{
			return nameToIdLookup.get(name);
		}
		
		List<ItemPrice> results = items.search(name);
		if (results != null && !results.isEmpty())
		{
			for (ItemPrice result : results)
			{
				if (result.getName().toLowerCase().equals(name))
				{
					nameToIdLookup.put(name, result.getId());
					return result.getId();
				}
			}
		}
		return null;
	}
}



/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;

import javax.inject.Inject;

import com.gpperhour.GPPerHourConfig;
import com.gpperhour.itemcharges.items.S_KharedstMemoirs;
import com.gpperhour.itemcharges.items.U_AshSanctifier;
import com.gpperhour.itemcharges.items.U_BloodEssence;
import com.gpperhour.itemcharges.items.U_BottomlessCompostBucket;
import com.gpperhour.itemcharges.items.U_FishBarrel;
import com.gpperhour.itemcharges.items.U_CoalBag;
import com.gpperhour.itemcharges.items.U_GemBag;
import com.gpperhour.itemcharges.items.U_HerbSack;
import com.gpperhour.itemcharges.items.U_LogBasket;
import com.gpperhour.itemcharges.items.U_SeedBox;
import com.google.gson.Gson;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicChanged;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;



@Slf4j
public class ChargedItemManager {


	public static final int CHARGES_UNKNOWN = -1;
	public static final int CHARGES_UNLIMITED = -2;

	@Inject
	private Client client;

	@Inject
	private ClientThread client_thread;

	@Inject
	private ItemManager items;

	@Inject
	private ConfigManager configs;

	@Inject
	private GPPerHourConfig config;

	@Inject
	private ChatMessageManager chat_messages;

	@Inject
	private ScheduledExecutorService executorService;

	@Inject
	private Notifier notifier;

	@Inject
	private Gson gson;

	private ChargedItem[] chargedItems = new ChargedItem[0];

	public void loadConfigData() {
		chargedItems = new ChargedItem[]{
			new U_FishBarrel(client, client_thread, configs, items, chat_messages, notifier, gson, executorService),
			new U_LogBasket(client, client_thread, configs, items, chat_messages, notifier, gson, executorService),
			new S_KharedstMemoirs(client, client_thread, configs, items, chat_messages, notifier, gson, executorService),
			new U_BottomlessCompostBucket(client, client_thread, configs, items, chat_messages, notifier, gson, executorService),
			new U_AshSanctifier(client, client_thread, configs, items, chat_messages, notifier, gson, executorService),
			new U_BloodEssence(client, client_thread, configs, items, chat_messages, notifier, gson, executorService),
            new U_GemBag(client, client_thread, configs, items, chat_messages, notifier, gson, executorService),
            new U_CoalBag(client, client_thread, configs, items, chat_messages, notifier, gson, executorService),
			new U_HerbSack(client, client_thread, configs, items, chat_messages, notifier, gson, executorService),
			new U_SeedBox(client, client_thread, configs, items, chat_messages, notifier, gson, executorService),
		};
	}

	@Subscribe
	public void onItemDespawned(final ItemDespawned event)
	{
		log.debug("ITEM DESPAWNED | " + event.getItem().getId());

		for (final ChargedItem chargedItem : this.chargedItems) {
			chargedItem.onItemDespawned(event);
		}
	}

	@Subscribe
	public void onStatChanged(final StatChanged event)
	{
		log.debug("STAT CHANGED | " + event.getSkill());

		for (final ChargedItem chargedItem : this.chargedItems) {
			chargedItem.onStatChanged(event);
		}
	}

	@Subscribe
	public void onItemContainerChanged(final ItemContainerChanged event) {
		log.debug("ITEM CONTAINER | " + event.getContainerId());

		for (final ChargedItem chargedItem : this.chargedItems) {
			chargedItem.onItemContainersChanged(event);
		}
	}

	@Subscribe
	public void onChatMessage(final ChatMessage event) {
		Arrays.stream(chargedItems).forEach(chargedItem -> chargedItem.onChatMessage(event));
		log.debug(
			"MESSAGE | " +
				"type: " + event.getType().name() +
				", message: " + event.getMessage().replaceAll("</?col.*?>", "") +
				", sender: " + event.getSender()
		);
	}

	@Subscribe
	public void onAnimationChanged(final AnimationChanged event) {
		Arrays.stream(chargedItems).forEach(chargedItem -> chargedItem.onAnimationChanged(event));
		if (event.getActor() == client.getLocalPlayer()) {
			log.debug("ANIMATION | " +
				"id: " + event.getActor().getAnimation()
			);
		}
	}

	@Subscribe
	public void onGraphicChanged(final GraphicChanged event) {
		Arrays.stream(chargedItems).forEach(chargedItem -> chargedItem.onGraphicChanged(event));
		if (event.getActor() == client.getLocalPlayer()) {
			log.debug("GRAPHIC | " +
				"id: " + event.getActor().getGraphic()
			);
		}
	}

	// @Subscribe
	// public void onConfigChanged(final ConfigChanged event) {
	// 	Arrays.stream(chargedItems).forEach(chargedItem -> chargedItem.onConfigChanged(event));
	// 	if (event.getGroup().equals(config.GROUP)) {
	// 		log.debug("CONFIG | " +
	// 			"key: " + event.getKey() +
	// 			", old value: " + event.getOldValue() +
	// 			", new value: " + event.getNewValue()
	// 		);
	// 	}
	// }

	@Subscribe
	public void onHitsplatApplied(final HitsplatApplied event) {
		Arrays.stream(chargedItems).forEach(chargedItem -> chargedItem.onHitsplatApplied(event));
		log.debug("HITSPLAT | " +
			"actor: " + (event.getActor() == client.getLocalPlayer() ? "self" : "enemy") +
			", type: " + event.getHitsplat().getHitsplatType() +
			", amount:" + event.getHitsplat().getAmount() +
			", others = " + event.getHitsplat().isOthers() +
			", mine = " + event.getHitsplat().isMine()
		);
	}

	@Subscribe
	public void onWidgetLoaded(final WidgetLoaded event) {
		Arrays.stream(chargedItems).forEach(chargedItem -> chargedItem.onWidgetLoaded(event));
		log.debug("WIDGET | " +
			"group: " + event.getGroupId()
		);
	}

	@Subscribe
	public void onMenuOptionClicked(final MenuOptionClicked event) {
		Arrays.stream(chargedItems).forEach(chargedItem -> chargedItem.onMenuOptionClicked(event));
		log.debug("OPTION | " +
			"option: " + event.getMenuOption() +
			", target: " + event.getMenuTarget() +
			", action name: " + event.getMenuAction().name() +
			", action id: " + event.getMenuAction().getId()
		);
	}

	@Subscribe
	public void onGameTick(final GameTick gametick) {
		for (final ChargedItem chargedItem : this.chargedItems) {
			chargedItem.onGameTick(gametick);
		}
	}


	/// API for Plugin

	private  Map<Integer, Float> emptyMap = new HashMap<>();

	public boolean isChargeableItem(Integer itemId)
	{
		return getChargedItem(itemId) != null;
	}

	private ChargedItem getChargedItem(Integer itemId)
	{
		for (ChargedItem chargedItem : chargedItems) {
			//note that the item's item_id is constantly updated based on which variation is in your inventory/equipment
			if (chargedItem.item_id == itemId) {
				return chargedItem;
			}
		}
		return null;
	}

	public boolean hasChargeData(Integer itemId)
	{
		ChargedItem chargedItem = getChargedItem(itemId);
		if (chargedItem == null)
		{
			log.warn("Didn't find a charged item for this itemID, this shouldn't happen.");
			return false;
		}
		return chargedItem.hasChargeData();
	}

	public Map<Integer, Float> getItemQuantities(Integer itemId)
	{
		ChargedItem chargedItem = getChargedItem(itemId);
		if (chargedItem == null)
		{
			log.warn("Didn't find a charged item for this itemID, this shouldn't happen.");
			return emptyMap;
		}
		return chargedItem.getItemQuantities();
	}
}


/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, molo-pl <https://github.com/molo-pl>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.items;

import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.gpperhour.GPPerHourConfig;
import com.gpperhour.itemcharges.ChargedItem;
import com.gpperhour.itemcharges.ChargesItem;
import com.gpperhour.itemcharges.triggers.TriggerChatMessage;
import com.gpperhour.itemcharges.triggers.TriggerItem;
import com.gpperhour.itemcharges.triggers.TriggerItemContainer;
import com.gpperhour.itemcharges.triggers.TriggerMenuOption;
import com.google.common.collect.ImmutableMap;
import com.google.gson.Gson;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

@Slf4j
public class U_FishBarrel extends ChargedItem
{
	private final int FISH_BARREL_SIZE = 28;
	private static final String catchMessage = "^You catch (an?|some) ([a-zA-Z ]+)[.!]( It hardens as you handle it with your ice gloves\\.)?$";
	private static final Pattern catchPattern = Pattern.compile(catchMessage);
	private static final String checkRegex = "([0-9]+) x ([a-zA-Z ]+),? ?";
	private static final Pattern checkPattern = Pattern.compile(checkRegex);
	private Integer lastFishCaught = null;
	
	// maps the name of the fish as it appears in chat message to corresponding item ID
	private static final Map<String, Integer> FISH_TYPES_BY_NAME = ImmutableMap.<String, Integer>builder()
		// singular 'shrimp' may occur when fishing for Karambwanji
		.put("shrimp", ItemID.RAW_SHRIMP)
		.put("shrimps", ItemID.RAW_SHRIMP)
		.put("sardine", ItemID.RAW_SARDINE)
		.put("herring", ItemID.RAW_HERRING)
		.put("anchovies", ItemID.RAW_ANCHOVIES)
		.put("mackerel", ItemID.RAW_MACKEREL)
		.put("trout", ItemID.RAW_TROUT)
		.put("cod", ItemID.RAW_COD)
		.put("pike", ItemID.RAW_PIKE)
		.put("slimy swamp eel", ItemID.MORT_SLIMEY_EEL)
		.put("salmon", ItemID.RAW_SALMON)
		.put("tuna", ItemID.RAW_TUNA)
		.put("rainbow fish", ItemID.HUNTING_RAW_FISH_SPECIAL)
		.put("cave eel", ItemID.RAW_CAVE_EEL)
		.put("lobster", ItemID.RAW_LOBSTER)
		.put("bass", ItemID.RAW_BASS)
		.put("leaping trout", ItemID.BRUT_SPAWNING_TROUT)
		.put("swordfish", ItemID.RAW_SWORDFISH)
		.put("lava eel", ItemID.RAW_LAVA_EEL)
		.put("leaping salmon", ItemID.BRUT_SPAWNING_SALMON)
		.put("monkfish", ItemID.RAW_MONKFISH)
		.put("karambwan", ItemID.TBWT_RAW_KARAMBWAN)
		.put("leaping sturgeon", ItemID.BRUT_STURGEON)
		.put("shark", ItemID.RAW_SHARK)
		.put("infernal eel", ItemID.INFERNAL_EEL)
		.put("anglerfish", ItemID.RAW_ANGLERFISH)
		.put("dark crab", ItemID.RAW_DARK_CRAB)
		.put("sacred eel", ItemID.SNAKEBOSS_EEL)
		.build();

	public U_FishBarrel(
		final Client client,
		final ClientThread client_thread,
		final ConfigManager configs,
		final ItemManager items,
		final ChatMessageManager chat_messages,
		final Notifier notifier,
		final Gson gson,
		final ScheduledExecutorService executorService
	) {
		super(ChargesItem.FISH_BARREL, ItemID.FISH_BARREL_CLOSED, client, client_thread, configs, items, chat_messages, notifier, gson, executorService);

		this.config_key = GPPerHourConfig.fish_barrel;
		this.zero_charges_is_positive = true;
		this.triggers_items = new TriggerItem[]{
			new TriggerItem(ItemID.FISH_BARREL_CLOSED),
			new TriggerItem(ItemID.FISH_BARREL_OPEN),
			new TriggerItem(ItemID.FISH_SACK_BARREL_CLOSED),
			new TriggerItem(ItemID.FISH_SACK_BARREL_OPEN)
		};
		this.triggers_chat_messages = new TriggerChatMessage[]{
			new TriggerChatMessage("(Your|The) barrel is empty.").onItemClick().extraConsumer((message) ->
			{
				super.emptyOrClear();
			}),
			new TriggerChatMessage("(You catch .*)").extraConsumer(message -> {
				if ((item_id == ItemID.FISH_BARREL_OPEN || item_id == ItemID.FISH_SACK_BARREL_OPEN) && getItemCount() < FISH_BARREL_SIZE && super.hasChargeData()) {
					final Matcher matcher = catchPattern.matcher(message);
					if (matcher.matches())
					{
						final String fishName = matcher.group(2).toLowerCase();
						if (FISH_TYPES_BY_NAME.containsKey(fishName))
						{
							Integer fishId = FISH_TYPES_BY_NAME.get(fishName);
							lastFishCaught = fishId;
							super.addItems(fishId, 1f);
						}
					}
					else
					{
						log.error("no match found");
					}
				}
			}),
			//new TriggerChatMessage("The barrel is full. It may be emptied at a bank.").onItemClick().fixedCharges(FISH_BARREL_SIZE),
			new TriggerChatMessage("(.* enabled you to catch an extra fish.)").extraConsumer(message -> {
				if ((item_id == ItemID.FISH_BARREL_OPEN || item_id == ItemID.FISH_SACK_BARREL_OPEN) && getItemCount() < FISH_BARREL_SIZE && super.hasChargeData()) {
					
					if (lastFishCaught != null)
					{
						super.addItems(lastFishCaught, 1f);
					}
					else
					{
						log.error("last fish caught is null");
					}
				}
			}),
			new TriggerChatMessage("The barrel contains:").extraConsumer(message -> {
				
				super.emptyOrClear();
				final Matcher matcher = checkPattern.matcher(message);
				while (matcher.find())
				{
					try
					{
						int fishAmount = Integer.parseInt(matcher.group(1));
						String fishName = matcher.group(2).toLowerCase().replace("raw ", "");
						if (FISH_TYPES_BY_NAME.containsKey(fishName))
						{
							Integer fishId = FISH_TYPES_BY_NAME.get(fishName);
							super.addItems(fishId, (float) fishAmount);
						}
						else
						{
							log.error("no match found");
						}
					}
					catch (NumberFormatException e)
					{
						log.error("couldn't parse fish barrel check", e);
					}
				}
			}),
		};
		this.triggers_item_containers = new TriggerItemContainer[]{
			new TriggerItemContainer(InventoryID.INV).menuTarget("Open fish barrel").menuOption("Fill").addDifference(),
			new TriggerItemContainer(InventoryID.INV).menuTarget("Fish barrel").menuOption("Fill").addDifference(),
			new TriggerItemContainer(InventoryID.INV).menuTarget("Open fish sack barrel").menuOption("Fill").addDifference(),
			new TriggerItemContainer(InventoryID.INV).menuTarget("Fish sack barrel").menuOption("Fill").addDifference(),
		};
		this.triggers_menu_options = new TriggerMenuOption[]{
			new TriggerMenuOption("Open fish barrel", "Empty to bank").extraConsumer((message) -> { super.emptyOrClear(); }),
			new TriggerMenuOption("Fish barrel", "Empty to bank").extraConsumer((message) -> { super.emptyOrClear(); }),
			new TriggerMenuOption("Open fish sack barrel", "Empty to bank").extraConsumer((message) -> { super.emptyOrClear(); }),
			new TriggerMenuOption("Fish sack barrel", "Empty to bank").extraConsumer((message) -> { super.emptyOrClear(); }),
		};
		this.supportsWidgetOnWidget = true;
	}
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.items;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;

import com.gpperhour.GPPerHourConfig;
import com.gpperhour.itemcharges.ChargedItem;
import com.gpperhour.itemcharges.ChargesItem;
import com.gpperhour.itemcharges.triggers.TriggerChatMessage;
import com.gpperhour.itemcharges.triggers.TriggerItem;
import com.google.gson.Gson;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

@Slf4j
public class S_KharedstMemoirs extends ChargedItem {

    //avoid GC but don't confuse super class
    private final Map<Integer, Float> quantities = new HashMap<>();

    public S_KharedstMemoirs(
            final Client client,
            final ClientThread client_thread,
            final ConfigManager configs,
            final ItemManager items,
            final ChatMessageManager chat_messages,
            final Notifier notifier,
            final Gson gson,
            final ScheduledExecutorService executorService
    ) {
        super(ChargesItem.KHAREDSTS_MEMOIRS, ItemID.VEOS_KHAREDSTS_MEMOIRS, client, client_thread, configs, items, chat_messages, notifier, gson, executorService);
        this.config_key = GPPerHourConfig.kharedsts_memoirs;
        this.triggers_items = new TriggerItem[]{
                new TriggerItem(ItemID.VEOS_KHAREDSTS_MEMOIRS),
                new TriggerItem(ItemID.BOOK_OF_THE_DEAD)
        };
        this.triggers_chat_messages = new TriggerChatMessage[]{
                new TriggerChatMessage("(Kharedst's Memoirs?)|(The Book of the Dead) now has (?<charges>.+) (memories|memory) remaining."),
                new TriggerChatMessage("(Kharedst's Memoirs?)|(The Book of the Dead) holds no charges?.").fixedCharges(0),
                new TriggerChatMessage("On the inside of the cover a message is displayed in dark ink. It reads: (?<charges>.+) (memories|memory) remain."),
                new TriggerChatMessage("(Kharedst's Memoirs?)|(The Book of the Dead) now has (?<charges>.+) charges.")
        };
    }

    @Override
    protected  void onChargesUpdated()
    {
        quantities.clear();
        quantities.put(ItemID.LAWRUNE, (float) charges);
        quantities.put(ItemID.BODYRUNE, (float) charges);
        quantities.put(ItemID.MINDRUNE, (float) charges);
        quantities.put(ItemID.SOULRUNE, (float) charges);
    }

    @Override
    public Map<Integer, Float> getItemQuantities()
    {
        return quantities;
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.items;

import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.gpperhour.GPPerHourConfig;
import com.gpperhour.itemcharges.ChargedItem;
import com.gpperhour.itemcharges.ChargesItem;
import com.gpperhour.itemcharges.triggers.TriggerChatMessage;
import com.gpperhour.itemcharges.triggers.TriggerItem;
import com.gpperhour.itemcharges.triggers.TriggerItemContainer;
import com.google.gson.Gson;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

@Slf4j
public class U_HerbSack extends ChargedItem {
    private static final String pickupRegex = "^You put the (Grimy\\s+[A-Za-z\\s]+)\\s+herb into your herb sack\\.$";
    private static final Pattern pickupPattern = Pattern.compile(pickupRegex);
    private static final String checkRegex = "(\\d+)\\s*x\\s+(.*)";
    private static final Pattern checkPattern = Pattern.compile(checkRegex);

    public U_HerbSack(
            final Client client,
            final ClientThread client_thread,
            final ConfigManager configs,
            final ItemManager items,
            final ChatMessageManager chat_messages,
            final Notifier notifier,
            final Gson gson,
            final ScheduledExecutorService executorService
    ) {
        super(ChargesItem.HERB_SACK, ItemID.SLAYER_HERB_SACK, client, client_thread, configs, items, chat_messages, notifier, gson, executorService);

        this.config_key = GPPerHourConfig.herb_sack;
        this.zero_charges_is_positive = true;
        this.triggers_items = new TriggerItem[]{
                new TriggerItem(ItemID.SLAYER_HERB_SACK),
                new TriggerItem(ItemID.SLAYER_HERB_SACK_OPEN),
        };
        this.triggers_chat_messages = new TriggerChatMessage[]{
                new TriggerChatMessage("The herb sack is empty.").onItemClick().extraConsumer((message) -> super.emptyOrClear()),
                new TriggerChatMessage(pickupRegex).extraConsumer(message -> {
                    if (super.hasChargeData()) {
                        final Matcher matcher = pickupPattern.matcher(message);
                        if (matcher.matches()) {
                            final String itemName = matcher.group(1);
                            Integer itemId = tryFindItemIdFromName(itemName);
                            if (itemId != null) {
                                super.addItems(itemId, 1f);
                            }
                        } else {
                            log.error("no herb match found for message: " + message);
                        }
                    }
                }),
                //check
                new TriggerChatMessage("You look in your herb sack and see:").onItemClick().extraConsumer((message) -> super.emptyOrClear()),
                new TriggerChatMessage("x Grimy").onItemClick().extraConsumer(message -> {

                    final Matcher matcher = checkPattern.matcher(message);
                    while (matcher.find()) {
                        try {
                            int amount = Integer.parseInt(matcher.group(1));
                            String name = matcher.group(2);
                            Integer itemId = tryFindItemIdFromName(name);
                            if (itemId != null)
                                super.addItems(itemId, (float) amount);
                        } catch (NumberFormatException e) {
                            log.error("couldn't parse herb sack check", e);
                        }
                    }
                }),
        };
        this.triggers_item_containers = new TriggerItemContainer[]{
                new TriggerItemContainer(InventoryID.INV).menuTarget("Open herb sack").menuOption("Fill").addDifference(),
                new TriggerItemContainer(InventoryID.INV).menuTarget("Herb sack").menuOption("Fill").addDifference(),
                new TriggerItemContainer(InventoryID.INV).menuTarget("Open herb sack").menuOption("Empty").addDifference(),
                new TriggerItemContainer(InventoryID.INV).menuTarget("Herb sack").menuOption("Empty").addDifference(),
                //Empty into bank doesn't make a chat message (unless it's already empty)
                new TriggerItemContainer(InventoryID.BANK).menuTarget("Open herb sack").menuOption("Empty to bank").extraConsumer(super::emptyOrClear),
                new TriggerItemContainer(InventoryID.BANK).menuTarget("Herb sack").menuOption("Empty to bank").extraConsumer(super::emptyOrClear),
        };
        //for herb sack this only works for single herbs, if dialog pops up we don't capture it. too complicated...
        this.supportsWidgetOnWidget = true;
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.items;

import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.gpperhour.GPPerHourConfig;
import com.gpperhour.itemcharges.ChargedItem;
import com.gpperhour.itemcharges.ChargesItem;
import com.gpperhour.itemcharges.triggers.TriggerChatMessage;
import com.gpperhour.itemcharges.triggers.TriggerItem;
import com.google.gson.Gson;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

@Slf4j
public class U_SeedBox extends ChargedItem {
    private static final String checkRegex = "^(\\d+)\\s+x\\s+([A-Za-z\\s]+seed)\\.$";
    private static final Pattern checkPattern = Pattern.compile(checkRegex);
    private static final String pickupRegex = "^You put\\s+(\\d+)\\s+x\\s+([A-Za-z\\s]+seed)\\s+straight into your open seed box\\.$";
    private static final Pattern pickupPattern = Pattern.compile(pickupRegex);
    private static final String storeRegex = "^Stored\\s+(\\d+)\\s+x\\s+([A-Za-z\\s]+seed)\\s+in your seed box\\.$";
    private static final Pattern storePattern = Pattern.compile(storeRegex);
    private static final String removeRegex = "^Emptied\\s+(\\d+)\\s+x\\s+([A-Za-z\\s]+seed)\\s+to your inventory\\.$";
    private static final Pattern removePattern = Pattern.compile(removeRegex);


    public U_SeedBox(
            final Client client,
            final ClientThread client_thread,
            final ConfigManager configs,
            final ItemManager items,
            final ChatMessageManager chat_messages,
            final Notifier notifier,
            final Gson gson,
            final ScheduledExecutorService executorService
    ) {
        super(ChargesItem.SEED_BOX, ItemID.SEED_BOX, client, client_thread, configs, items, chat_messages, notifier, gson, executorService);

        this.config_key = GPPerHourConfig.seed_box;
        this.zero_charges_is_positive = true;
        this.triggers_items = new TriggerItem[]{
                new TriggerItem(ItemID.SEED_BOX),
                new TriggerItem(ItemID.SEED_BOX_OPEN),
        };
        this.triggers_chat_messages = new TriggerChatMessage[]{
                //Check
                new TriggerChatMessage("The seed box is empty.").onItemClick().extraConsumer((message) -> super.emptyOrClear()),
                //Empty into bank
                new TriggerChatMessage("Your seed box is now empty.").onItemClick().extraConsumer((message) -> super.emptyOrClear()),
                //check
                new TriggerChatMessage("The seed box contains:").onItemClick().extraConsumer((message) -> super.emptyOrClear()),
                new TriggerChatMessage(checkRegex).onItemClick().extraConsumer(message -> addMatches(checkPattern.matcher(message), false)),
                //Pickup
                new TriggerChatMessage(pickupRegex).extraConsumer(message -> addMatches(pickupPattern.matcher(message), false)),
                //Store
                new TriggerChatMessage(storeRegex).extraConsumer(message -> addMatches(storePattern.matcher(message), false)),
                //Remove
                new TriggerChatMessage(removeRegex).extraConsumer(message -> addMatches(removePattern.matcher(message), true)),
        };
    }

    private void addMatches(Matcher matcher, boolean remove)
    {   
        if (!super.hasChargeData())
            return;
        while (matcher.find()) {
            try {
                int amount = Integer.parseInt(matcher.group(1));
                String name = matcher.group(2);
                Integer itemId = tryFindItemIdFromName(name);
                if (itemId != null)
                    super.addItems(itemId, (float) (remove ? -amount : amount));
            } catch (NumberFormatException e) {
                log.error("couldn't parse seed box match", e);
            }
        }
    }
}
/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.items;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;

import com.gpperhour.GPPerHourConfig;
import com.gpperhour.itemcharges.ChargedItem;
import com.gpperhour.itemcharges.ChargesItem;
import com.gpperhour.itemcharges.triggers.TriggerChatMessage;
import com.gpperhour.itemcharges.triggers.TriggerItem;
import com.google.gson.Gson;

import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

public class U_BloodEssence extends ChargedItem {

    //avoid GC but don't confuse super class
    private final Map<Integer, Float> quantities = new HashMap<>();

    public U_BloodEssence(
            final Client client,
            final ClientThread client_thread,
            final ConfigManager configs,
            final ItemManager items,
            final ChatMessageManager chat_messages,
            final Notifier notifier,
            final Gson gson,
            final ScheduledExecutorService executorService
    ) {
        super(ChargesItem.BLOOD_ESSENCE, ItemID.BLOOD_ESSENCE_ACTIVE, client, client_thread, configs, items, chat_messages, notifier, gson, executorService);
        super.allow_chat_messages_when_not_present = true;
        this.config_key = GPPerHourConfig.blood_essence;
        this.triggers_items = new TriggerItem[]{
                new TriggerItem(ItemID.BLOOD_ESSENCE_ACTIVE),
        };
        this.triggers_chat_messages = new TriggerChatMessage[]{
                new TriggerChatMessage("Your blood essence has (?<charges>.+) charges? remaining"),
                new TriggerChatMessage("You manage to extract power from the Blood Essence and craft (?<charges>.+) extra runes?\\.").decreaseDynamically(),
                new TriggerChatMessage("You activate the blood essence.").fixedCharges(1000),
        };
    }

    @Override
    protected  void onChargesUpdated()
    {
        quantities.clear();
        quantities.put(ItemID.BLOOD_ESSENCE_INACTIVE, ((float) charges)/1000f);
    }

    @Override
    public Map<Integer, Float> getItemQuantities()
    {
        return quantities;
    }
}
/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.items;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;

import com.gpperhour.GPPerHourConfig;
import com.gpperhour.itemcharges.ChargedItem;
import com.gpperhour.itemcharges.ChargesItem;
import com.gpperhour.itemcharges.triggers.TriggerChatMessage;
import com.gpperhour.itemcharges.triggers.TriggerItem;
import com.gpperhour.itemcharges.triggers.TriggerXPDrop;
import com.google.gson.Gson;

import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

public class U_AshSanctifier extends ChargedItem {

    //avoid GC but don't confuse super class
    private final Map<Integer, Float> quantities = new HashMap<>();

    public U_AshSanctifier(
            final Client client,
            final ClientThread client_thread,
            final ConfigManager configs,
            final ItemManager items,
            final ChatMessageManager chat_messages,
            final Notifier notifier,
            final Gson gson,
            final ScheduledExecutorService executorService
    ) {
        super(ChargesItem.ASH_SANCTIFIER, ItemID.ASH_SANCTIFIER, client, client_thread, configs, items, chat_messages, notifier, gson, executorService);
        this.config_key = GPPerHourConfig.ash_sanctifier;
        this.triggers_items = new TriggerItem[]{
                new TriggerItem(ItemID.ASH_SANCTIFIER),
        };
        this.triggers_chat_messages = new TriggerChatMessage[]{
                new TriggerChatMessage("Your ash sanctifier has (?<charges>.+) charges? left."),
                new TriggerChatMessage("The ash sanctifier has (?<charges>.+) charges?.").onItemClick(),
        };
        this.triggers_xp_drops = new TriggerXPDrop[]{
                new TriggerXPDrop(Skill.PRAYER, 1),
        };
    }

    @Override
    protected  void onChargesUpdated()
    {
        quantities.clear();
        quantities.put(ItemID.DEATHRUNE, ((float) charges)/10f);
    }

    @Override
    public Map<Integer, Float> getItemQuantities()
    {
        return quantities;
    }
}
/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.items;

import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.gpperhour.GPPerHourConfig;
import com.gpperhour.itemcharges.ChargedItem;
import com.gpperhour.itemcharges.ChargesItem;
import com.gpperhour.itemcharges.triggers.TriggerChatMessage;
import com.gpperhour.itemcharges.triggers.TriggerItem;
import com.gpperhour.itemcharges.triggers.TriggerItemContainer;
import com.gpperhour.itemcharges.triggers.TriggerItemDespawn;
import com.google.gson.Gson;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.TileItem;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

@Slf4j
public class U_GemBag extends ChargedItem
{
    private final int CAPACITY = 60;
    private static final String pickpocketRegex = "The following stolen loot gets added to your gem bag: Uncut (.*) x (\\d+)";
    private static final Pattern pickpocketPattern = Pattern.compile(pickpocketRegex);
    private static final String checkRegex = "Sapphires: (\\d+) \\/ Emeralds: (\\d+) \\/ Rubies: (\\d+) Diamonds: (\\d+) \\/ Dragonstones: (\\d+)";
    private static final Pattern checkPattern = Pattern.compile(checkRegex);
    private static final String acquireRegex = "^(You just (found|mined) (a|an) (Sapphire|Ruby|Emerald|Diamond))";
    private static final Pattern acquirePattern = Pattern.compile(acquireRegex);

    public U_GemBag(
            final Client client,
            final ClientThread client_thread,
            final ConfigManager configs,
            final ItemManager items,
            final ChatMessageManager chat_messages,
            final Notifier notifier,
            final Gson gson,
            final ScheduledExecutorService executorService
    ) {
        super(ChargesItem.GEM_BAG, ItemID.GEM_BAG, client, client_thread, configs, items, chat_messages, notifier, gson, executorService);

        this.config_key = GPPerHourConfig.gem_bag;
        this.zero_charges_is_positive = true;
        this.triggers_items = new TriggerItem[]{
                new TriggerItem(ItemID.GEM_BAG),
                new TriggerItem(ItemID.GEM_BAG_OPEN, true),
        };
        this.trigger_item_despawn = new TriggerItemDespawn((TileItem tileItem) ->
        {
            if (tileItem.getId() == ItemID.UNCUT_SAPPHIRE ||
                tileItem.getId() == ItemID.UNCUT_EMERALD ||
                tileItem.getId() == ItemID.UNCUT_RUBY ||
                tileItem.getId() == ItemID.UNCUT_DIAMOND ||
                tileItem.getId() == ItemID.UNCUT_DRAGONSTONE)
            {
                addDespawnedGemIfHasCapacity(tileItem);
            }
        });
        this.triggers_chat_messages = new TriggerChatMessage[]{
            new TriggerChatMessage("The gem bag is now empty.").onItemClick().extraConsumer((message) -> { super.emptyOrClear(); }),
            //Gems that are 'mined' (at gem rocks) vs 'found' (while mining other things) don't print the "you put it into your gem bag" message, so use this instead for both cases.
            new TriggerChatMessage(acquireRegex).extraConsumer((message) -> { 
                if (!hasChargeData())
                    return;
                if (this.item_id != ItemID.GEM_BAG_OPEN)
                    return;
                final Matcher matcher = acquirePattern.matcher(message);
                while (matcher.find())
                {
                    try
                    {
                        String gemName = matcher.group(4);
                        int gemID;
                        if (gemName.equals("Sapphire"))
                            gemID = ItemID.UNCUT_SAPPHIRE;
                        else if (gemName.equals("Emerald"))
                            gemID = ItemID.UNCUT_EMERALD;
                        else if (gemName.equals("Ruby"))
                            gemID = ItemID.UNCUT_RUBY;
                        else if (gemName.equals("Diamond"))
                            gemID = ItemID.UNCUT_DIAMOND;
                        else
                            throw new Exception("Gem name not matched.");

                        if ((!super.itemQuantities.containsKey(gemID) || super.itemQuantities.get(gemID) < CAPACITY))
                        {
                            super.addItems(gemID, 1f);
                        }
                    }
                    catch (Exception e)
                    {
                        log.error("couldn't find group match in gem bag acquire: " + message, e);
                    }
                }
            }),
            //Pickpocketing vyres "The following stolen loot gets added to your gem bag: Uncut ruby  2."
            new TriggerChatMessage(pickpocketRegex).extraConsumer((message) -> { 
                if (!hasChargeData())
                    return;
                final Matcher matcher = pickpocketPattern.matcher(message);
                while (matcher.find())
                {
                    try
                    {
                        String gemName = matcher.group(1);
                        int gemID;
                        if (gemName.equals("sapphire"))
                            gemID = ItemID.UNCUT_SAPPHIRE;
                        else if (gemName.equals("emerald"))
                            gemID = ItemID.UNCUT_EMERALD;
                        else if (gemName.equals("ruby"))
                            gemID = ItemID.UNCUT_RUBY;
                        else if (gemName.equals("diamond"))
                            gemID = ItemID.UNCUT_DIAMOND;
                        else
                            throw new Exception("Gem name not matched.");

                        int amount = Integer.parseInt(matcher.group(2));
                        super.addItems(gemID, (float) amount);
                    }
                    catch (Exception e)
                    {
                        log.error("couldn't find group match in gem bag acquire: " + message, e);
                    }
                }
            }),
            new TriggerChatMessage("The gem bag is empty.").onItemClick().extraConsumer((message) -> { super.emptyOrClear(); }),
            new TriggerChatMessage(checkRegex).extraConsumer(message -> {

                super.emptyOrClear();
                final Matcher matcher = checkPattern.matcher(message);
                while (matcher.find())
                {
                    try
                    {
                        int sapphires = Integer.parseInt(matcher.group(1));
                        int emeralds = Integer.parseInt(matcher.group(2));
                        int rubies = Integer.parseInt(matcher.group(3));
                        int diamonds = Integer.parseInt(matcher.group(4));
                        int dragonstones = Integer.parseInt(matcher.group(5));

                        super.addItems(ItemID.UNCUT_SAPPHIRE, (float) sapphires);
                        super.addItems(ItemID.UNCUT_EMERALD, (float) emeralds);
                        super.addItems(ItemID.UNCUT_RUBY, (float) rubies);
                        super.addItems(ItemID.UNCUT_DIAMOND, (float) diamonds);
                        super.addItems(ItemID.UNCUT_DRAGONSTONE, (float) dragonstones);
                    }
                    catch (NumberFormatException e)
                    {
                        log.error("couldn't parse gem bag check: " + message, e);
                    }
                }
            }),
        };
        this.triggers_item_containers = new TriggerItemContainer[]{
            new TriggerItemContainer(InventoryID.INV).menuTarget("Open gem bag").menuOption("Fill").addDifference(),
            new TriggerItemContainer(InventoryID.INV).menuTarget("Gem bag").menuOption("Fill").addDifference(),
            //Empty into bank doesn't make a chat message (unless it's already empty)
            new TriggerItemContainer(InventoryID.BANK).menuTarget("Open gem bag").menuOption("Empty to bank").extraConsumer(() -> super.emptyOrClear()),
            new TriggerItemContainer(InventoryID.BANK).menuTarget("Gem bag").menuOption("Empty to bank").extraConsumer(() -> super.emptyOrClear()),
        };
        this.supportsWidgetOnWidget = true;
    }

    private void addDespawnedGemIfHasCapacity(TileItem tileItem)
    {
        if (tileItem.getQuantity() == 1
                && (!super.itemQuantities.containsKey(tileItem.getId()) || super.itemQuantities.get(tileItem.getId()) < CAPACITY))
        {
            super.addItems(tileItem.getId(), 1f);
        }
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.items;

import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.gpperhour.GPPerHourConfig;
import com.gpperhour.itemcharges.ChargedItem;
import com.gpperhour.itemcharges.ChargesItem;
import com.gpperhour.itemcharges.triggers.TriggerChatMessage;
import com.gpperhour.itemcharges.triggers.TriggerItem;
import com.gpperhour.itemcharges.triggers.TriggerItemContainer;
import com.google.gson.Gson;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

@Slf4j
public class U_LogBasket extends ChargedItem
{
	private final int CAPACITY = 28;
	private static final String logMessage = "^You get some ([a-zA-Z ]+)[.!]?$";
	private static final Pattern logPattern = Pattern.compile(logMessage);
	private static final String checkRegex = "([0-9]+) x ([a-zA-Z ]+),? ?";
	private static final Pattern checkPattern = Pattern.compile(checkRegex);
	private int lastNatureOfferingTickCount = 0;
	
	public U_LogBasket(
		final Client client,
		final ClientThread client_thread,
		final ConfigManager configs,
		final ItemManager items,
		final ChatMessageManager chat_messages,
		final Notifier notifier,
		final Gson gson,
		final ScheduledExecutorService executorService
	) {
		super(ChargesItem.LOG_BASKET, ItemID.LOG_BASKET_CLOSED, client, client_thread, configs, items, chat_messages, notifier, gson, executorService);

		this.config_key = GPPerHourConfig.log_basket;
		this.zero_charges_is_positive = true;
        this.triggers_items = new TriggerItem[]{
            new TriggerItem(ItemID.LOG_BASKET_CLOSED),
            new TriggerItem(ItemID.LOG_BASKET_OPEN),
        };
		this.triggers_chat_messages = new TriggerChatMessage[]{
            new TriggerChatMessage("(Your|The) basket is empty.").onItemClick().extraConsumer((message) -> { super.emptyOrClear(); }),
            new TriggerChatMessage("You empty your basket into the bank.").onItemClick().extraConsumer((message) -> { super.emptyOrClear(); }),
			new TriggerChatMessage("(You get some.* logs)").extraConsumer(message -> {
				if ((item_id == ItemID.LOG_BASKET_OPEN || item_id == ItemID.FORESTRY_BASKET_OPEN) && getItemCount() < CAPACITY && super.hasChargeData()) {
					final Matcher matcher = logPattern.matcher(message);
					if (matcher.matches())
					{
						final String logName = matcher.group(1);
						Integer itemId = tryFindItemIdFromName(logName);
						if (itemId != null)
						{
							super.addItems(itemId, 1f);
							if (getItemCount() < CAPACITY && lastNatureOfferingTickCount == client.getTickCount())
							{
								super.addItems(itemId, 1f);
							}
						}
					}
					else
					{
						log.error("no log match found for message: " + message);
					}
				}
			}),
			new TriggerChatMessage("(The nature offerings enabled you to chop an extra log.)").extraConsumer(message -> {
				
				lastNatureOfferingTickCount = client.getTickCount();
			}),
			new TriggerChatMessage("The basket contains:").extraConsumer(message -> {
				
				super.emptyOrClear();
				final Matcher matcher = checkPattern.matcher(message);
				while (matcher.find())
				{
					try
					{
						int amount = Integer.parseInt(matcher.group(1));
						String name = matcher.group(2);
						Integer itemId = tryFindItemIdFromName(name);
						if (itemId != null)
							super.addItems(itemId, (float) amount);
					}
					catch (NumberFormatException e)
					{
						log.error("couldn't parse log basket check", e);
					}
				}
			}),
		};
		this.triggers_item_containers = new TriggerItemContainer[]{
			new TriggerItemContainer(InventoryID.INV).menuTarget("Open log basket").menuOption("Fill").addDifference(),
			new TriggerItemContainer(InventoryID.INV).menuTarget("Log basket").menuOption("Fill").addDifference(),
		};
		this.supportsWidgetOnWidget = true;
	}
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, molo-pl <https://github.com/molo-pl>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.items;

import com.google.gson.Gson;
import com.gpperhour.GPPerHourConfig;
import com.gpperhour.itemcharges.ChargedItem;
import com.gpperhour.itemcharges.ChargesItem;
import com.gpperhour.itemcharges.triggers.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.TileItem;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class U_CoalBag extends ChargedItem
{
	private final int COAL_BAG_SIZE = 27;
    private static final String checkRegex = "^The coal bag (still |)contains (one|[0-9]+) ([a-zA-Z ]+)";
    private static final Pattern checkPattern = Pattern.compile(checkRegex);

	public U_CoalBag(
		final Client client,
		final ClientThread client_thread,
		final ConfigManager configs,
		final ItemManager items,
		final ChatMessageManager chat_messages,
		final Notifier notifier,
		final Gson gson,
		final ScheduledExecutorService executorService
	) {
		super(ChargesItem.COAL_BAG, ItemID.COAL_BAG, client, client_thread, configs, items, chat_messages, notifier, gson, executorService);

		this.config_key = GPPerHourConfig.coal_bag;
		this.zero_charges_is_positive = true;
		this.triggers_items = new TriggerItem[]{
			new TriggerItem(ItemID.COAL_BAG),
			new TriggerItem(ItemID.COAL_BAG_OPEN,true),
		};
		this.triggers_chat_messages = new TriggerChatMessage[]{
			new TriggerChatMessage("(Your|The) coal bag is (now |)empty.").onItemClick().extraConsumer((message) ->
			{
				super.emptyOrClear();
			}),
			new TriggerChatMessage("You manage to mine some coal.").extraConsumer(message -> {
				if ((item_id == ItemID.COAL_BAG_OPEN) && getItemCount() < COAL_BAG_SIZE && super.hasChargeData()) {
                    super.addItems(ItemID.COAL,1f);
				}
			}),
            new TriggerChatMessage("The coal bag (still |)contains").extraConsumer(message -> {
                super.emptyOrClear();
                final Matcher matcher = checkPattern.matcher(message);
                while (matcher.find())
                {
                    try
                    {
                        int coalAmount = 0;
                        if (matcher.group(2).equals("one")) {
                            coalAmount = 1;
                        } else {
                            coalAmount = Integer.parseInt(matcher.group(2));
                        }
                        super.addItems(ItemID.COAL, (float) coalAmount);
                    }
                    catch (NumberFormatException e)
                    {
                        log.error("couldn't parse coal bag check", e);
                    }
                }
            }),
		};
        this.trigger_item_despawn = new TriggerItemDespawn((TileItem tileItem) ->
        {
            if (tileItem.getId() == ItemID.COAL)
            {
                addDespawnedCoalIfHasCapacity(tileItem);
            }
        });
		this.supportsWidgetOnWidget = true;
	}

    private void addDespawnedCoalIfHasCapacity(TileItem tileItem)
    {
        if (tileItem.getQuantity() == 1
                && (!super.itemQuantities.containsKey(tileItem.getId()) || super.itemQuantities.get(tileItem.getId()) < COAL_BAG_SIZE))
        {
            super.addItems(tileItem.getId(), 1f);
        }
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, TicTac7x <https://github.com/TicTac7x>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.itemcharges.items;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;

import com.gpperhour.GPPerHourConfig;
import com.gpperhour.itemcharges.ChargedItem;
import com.gpperhour.itemcharges.ChargesItem;
import com.gpperhour.itemcharges.triggers.TriggerAnimation;
import com.gpperhour.itemcharges.triggers.TriggerChatMessage;
import com.gpperhour.itemcharges.triggers.TriggerItem;
import com.google.gson.Gson;

import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

public class U_BottomlessCompostBucket extends ChargedItem {

    //avoid GC but don't confuse super class
    private final Map<Integer, Float> quantities = new HashMap<>();

    public U_BottomlessCompostBucket(
            final Client client,
            final ClientThread client_thread,
            final ConfigManager configs,
            final ItemManager items,
            final ChatMessageManager chat_messages,
            final Notifier notifier,
            final Gson gson,
            final ScheduledExecutorService executorService
    ) {
        super(ChargesItem.BOTTOMLESS_COMPOST_BUCKET, ItemID.BOTTOMLESS_COMPOST_BUCKET_FILLED, client, client_thread, configs, items, chat_messages, notifier, gson, executorService);
        this.config_key = GPPerHourConfig.bottomless_compost_bucket;
        this.extra_config_keys = new String[]{"type"};
        this.triggers_items = new TriggerItem[]{
                new TriggerItem(ItemID.BOTTOMLESS_COMPOST_BUCKET).fixedCharges(0),
                new TriggerItem(ItemID.BOTTOMLESS_COMPOST_BUCKET_FILLED),
        };
        this.triggers_animations = new TriggerAnimation[]{
                new TriggerAnimation(8197).decreaseCharges(1),
                new TriggerAnimation(832).increaseCharges(2).onMenuOption("Take").unallowedItems(new int[]{ItemID.BUCKET_EMPTY, ItemID.DWARVEN_STOUT})
        };
        this.triggers_chat_messages = new TriggerChatMessage[]{
                new TriggerChatMessage("Your bottomless compost bucket has a single use of (?<type>.+) ?compost remaining.").fixedCharges(1),
                new TriggerChatMessage("Your bottomless compost bucket has (?<charges>.+) uses of (?<type>.+) ?compost remaining."),
                new TriggerChatMessage("Your bottomless compost bucket doesn't currently have any compost in it!(?<type>.*)").fixedCharges(0),
                new TriggerChatMessage("Your bottomless compost bucket is currently holding one use of (?<type>.+?) ?compost.").fixedCharges(1),
                new TriggerChatMessage("Your bottomless compost bucket is currently holding (?<charges>.+) uses of (?<type>.+?) ?compost."),
                new TriggerChatMessage("You discard the contents of your bottomless compost bucket.(?<type>.*)").fixedCharges(0),
                new TriggerChatMessage("You fill your bottomless compost bucket with .* buckets? of (?<type>.+?) ?compost. Your bottomless compost bucket now contains a total of (?<charges>.+) uses.")
        };
    }

    private String getCompostType() {
        return configs.getRSProfileConfiguration(GPPerHourConfig.GROUP, GPPerHourConfig.bottomless_compost_bucket_type);
    }

    @Override
    protected void onChargesUpdated()
    {
        quantities.clear();
        Integer itemId = null;
        String compostType = getCompostType();
        if (compostType == null)
        {
            return;
        }
        if (compostType.equals("ultra"))
        {
            itemId = ItemID.BUCKET_ULTRACOMPOST;
        }
        else if(compostType.equals("super"))
        {
            itemId = ItemID.BUCKET_SUPERCOMPOST;
        }
        else
        {
            itemId = ItemID.BUCKET_COMPOST;
        }
        quantities.put(itemId, ((float) charges)/2f);
    }

    @Override
    public Map<Integer, Float> getItemQuantities()
    {
        return quantities;
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, Seth <Sethtroll3@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import lombok.RequiredArgsConstructor;

import static net.runelite.api.ItemID.*;

//Remaps items with doses/charges to a fraction of their full item ID to keep the ledger clean
//IE: (Super Restore (2), 1) --> (Super Restore (4), 0.5)
//IE: (Games necklace (2), 1) --> (Games necklace (8), 0.25)
public class FractionalRemapper
{

    @RequiredArgsConstructor
    private static class RemapData
    {
        final Integer remappedId;
        final Float remappedQuantityMultiplier;
    }

    private static final Map<Integer, RemapData> remapData;

    //avoid GC
    private static final List<Integer> keySet = new LinkedList<>();

    public static void Remap(Map<Integer, Float> qtyMap)
    {
        keySet.clear();
        for (Integer integer : qtyMap.keySet())
        {
            keySet.add(integer);
        }

        for (Integer oldItemId : keySet)
        {
            if (remapData.containsKey(oldItemId))
            {
                RemapData data = remapData.get(oldItemId);
                float originalQty = qtyMap.get(oldItemId);
                float newQty = originalQty * data.remappedQuantityMultiplier;

                qtyMap.remove(oldItemId);
                qtyMap.merge(data.remappedId, newQty, Float::sum);
            }
        }
    }

    static
    {
        //Sourced from https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/itemcharges/ItemWithCharge.java
        remapData = new HashMap<>();

        /////////////////////// Rechargeable Jewelery ///////////////////////
        //These shouldn't really lose value as the charges deplete since the uncharged
        //version is only worth slightly less than the charged version.
        //But we still want them to only show up as one row in the ledger so we just make them
        //a tiny fraction less of the fully charged version

        //////// Skills necklace(6) /////////
        //Skills (6) = 12,241gp
        //Skills (0) = 11,914gp
        remapData.put(11970, new RemapData(11968, 1f));
        remapData.put(11105, new RemapData(11968, 1f));
        remapData.put(11107, new RemapData(11968, 1f));
        remapData.put(11109, new RemapData(11968, 1f));
        remapData.put(11111, new RemapData(11968, 1f));
        //Wealth (5) = 13,989gp
        //Wealth (0) = 11,903gp
        //////// Ring of wealth (i5) /////////
        remapData.put(20787, new RemapData(20786, 0.95f));
        remapData.put(20788, new RemapData(20786, 0.9f));
        remapData.put(20789, new RemapData(20786, 0.85f));
        remapData.put(20790, new RemapData(20786, 0.8f));
        //////// Ring of wealth (5) /////////
        remapData.put(11982, new RemapData(11980, 0.95f));
        remapData.put(11984, new RemapData(11980, 0.9f));
        remapData.put(11986, new RemapData(11980, 0.85f));
        remapData.put(11988, new RemapData(11980, 0.8f));
        //Glory (6) = 12,872gp
        //Glory (0) = 11,903gp
        //////// Amulet of glory (t6) /////////
        remapData.put(11966, new RemapData(11964, 1f));
        remapData.put(10354, new RemapData(11964, 1f));
        remapData.put(10356, new RemapData(11964, 1f));
        remapData.put(10358, new RemapData(11964, 1f));
        remapData.put(10360, new RemapData(11964, 1f));
        //////// Amulet of glory(6) /////////
        remapData.put(11976,new RemapData(11978, 1f));
        remapData.put(1712, new RemapData(11978, 1f));
        remapData.put(1710, new RemapData(11978, 1f));
        remapData.put(1708, new RemapData(11978, 1f));
        remapData.put(1706, new RemapData(11978, 1f));
        //Combat (6) = 12,436gp
        //Combat (0) = 12,370gp
        //////// Combat bracelet(6) /////////
        remapData.put(11974, new RemapData(11972, 1f));
        remapData.put(11118, new RemapData(11972, 1f));
        remapData.put(11120, new RemapData(11972, 1f));
        remapData.put(11122, new RemapData(11972, 1f));
        remapData.put(11124, new RemapData(11972, 1f));


        /////////////////////// Everything Else ///////////////////////


        //////// Menaphite Remedy(4) /////////
        remapData.put(27205, new RemapData(27202, 0.75f));
        remapData.put(27208, new RemapData(27202, 0.5f));
        remapData.put(27211, new RemapData(27202, 0.25f));
        //////// Goading(4) /////////
        remapData.put(30140, new RemapData(30137, 0.75f));
        remapData.put(30143, new RemapData(30137, 0.5f));
        remapData.put(30146, new RemapData(30137, 0.25f));
        //////// Prayer Regeneration(4) /////////
        remapData.put(30128, new RemapData(30125, 0.75f));
        remapData.put(30131, new RemapData(30125, 0.5f));
        remapData.put(30134, new RemapData(30125, 0.25f));
        //////// Extended Anti-venom+(4) /////////
        remapData.put(29827, new RemapData(29824, 0.75f));
        remapData.put(29830, new RemapData(29824, 0.5f));
        remapData.put(29833, new RemapData(29824, 0.25f));
        //////// Forgotten brew(4) /////////
        remapData.put(27632, new RemapData(27629, 0.75f));
        remapData.put(27635, new RemapData(27629, 0.5f));
        remapData.put(27638, new RemapData(27629, 0.25f));
        //////// Smelling salts (2) /////////
        remapData.put(27345, new RemapData(27343, 0.5f));
        //////// Silk dressing (2) /////////
        remapData.put(27325, new RemapData(27323, 0.5f));
        //////// Blessed crystal scarab (2) /////////
        remapData.put(27337, new RemapData(27335, 0.5f));
        //////// Ambrosia (2) /////////
        remapData.put(27349, new RemapData(27347, 0.5f));
        //////// Liquid adrenaline (2) /////////
        remapData.put(27341, new RemapData(27339, 0.5f));
        //////// Tears of elidinis (4) /////////
        remapData.put(27329, new RemapData(27327, 0.75f));
        remapData.put(27331, new RemapData(27327, 0.5f));
        remapData.put(27333, new RemapData(27327, 0.25f));
        //////// Nectar (4) /////////
        remapData.put(27317, new RemapData(27315, 0.75f));
        remapData.put(27319, new RemapData(27315, 0.5f));
        remapData.put(27321, new RemapData(27315, 0.25f));
        //////// Overload (+)(4) /////////
        remapData.put(20995, new RemapData(20996, 0.75f));
        remapData.put(20994, new RemapData(20996, 0.5f));
        remapData.put(20993, new RemapData(20996, 0.25f));
        //////// Overload (4) /////////
        remapData.put(20991, new RemapData(20992, 0.75f));
        remapData.put(20990, new RemapData(20992, 0.5f));
        remapData.put(20989, new RemapData(20992, 0.25f));
        //////// Overload (-)(4) /////////
        remapData.put(20987, new RemapData(20988, 0.75f));
        remapData.put(20986, new RemapData(20988, 0.5f));
        remapData.put(20985, new RemapData(20988, 0.25f));
        //////// Prayer enhance (+)(4) /////////
        remapData.put(20971, new RemapData(20972, 0.75f));
        remapData.put(20970, new RemapData(20972, 0.5f));
        remapData.put(20969, new RemapData(20972, 0.25f));
        //////// Prayer enhance (4) /////////
        remapData.put(20967, new RemapData(20968, 0.75f));
        remapData.put(20966, new RemapData(20968, 0.5f));
        remapData.put(20965, new RemapData(20968, 0.25f));
        //////// Prayer enhance (-)(4) /////////
        remapData.put(20963, new RemapData(20964, 0.75f));
        remapData.put(20962, new RemapData(20964, 0.5f));
        remapData.put(20961, new RemapData(20964, 0.25f));
        //////// Xeric's aid (+)(4) /////////
        remapData.put(20983, new RemapData(20984, 0.75f));
        remapData.put(20982, new RemapData(20984, 0.5f));
        remapData.put(20981, new RemapData(20984, 0.25f));
        //////// Xeric's aid (4) /////////
        remapData.put(20979, new RemapData(20980, 0.75f));
        remapData.put(20978, new RemapData(20980, 0.5f));
        remapData.put(20977, new RemapData(20980, 0.25f));
        //////// Xeric's aid (-)(4) /////////
        remapData.put(20975, new RemapData(20976, 0.75f));
        remapData.put(20974, new RemapData(20976, 0.5f));
        remapData.put(20973, new RemapData(20976, 0.25f));
        //////// Revitalisation (+)(4) /////////
        remapData.put(20959, new RemapData(20960, 0.75f));
        remapData.put(20958, new RemapData(20960, 0.5f));
        remapData.put(20957, new RemapData(20960, 0.25f));
        //////// Revitalisation potion (4) /////////
        remapData.put(20955, new RemapData(20956, 0.75f));
        remapData.put(20954, new RemapData(20956, 0.5f));
        remapData.put(20953, new RemapData(20956, 0.25f));
        //////// Revitalisation (-)(4) /////////
        remapData.put(20951, new RemapData(20952, 0.75f));
        remapData.put(20950, new RemapData(20952, 0.5f));
        remapData.put(20949, new RemapData(20952, 0.25f));
        //////// Twisted (+)(4) /////////
        remapData.put(20935, new RemapData(20936, 0.75f));
        remapData.put(20934, new RemapData(20936, 0.5f));
        remapData.put(20933, new RemapData(20936, 0.25f));
        //////// Twisted potion (4) /////////
        remapData.put(20931, new RemapData(20932, 0.75f));
        remapData.put(20930, new RemapData(20932, 0.5f));
        remapData.put(20929, new RemapData(20932, 0.25f));
        //////// Twisted (-)(4) /////////
        remapData.put(20927, new RemapData(20928, 0.75f));
        remapData.put(20926, new RemapData(20928, 0.5f));
        remapData.put(20925, new RemapData(20928, 0.25f));
        //////// Kodai (+)(4) /////////
        remapData.put(20947, new RemapData(20948, 0.75f));
        remapData.put(20946, new RemapData(20948, 0.5f));
        remapData.put(20945, new RemapData(20948, 0.25f));
        //////// Kodai potion (4) /////////
        remapData.put(20943, new RemapData(20944, 0.75f));
        remapData.put(20942, new RemapData(20944, 0.5f));
        remapData.put(20941, new RemapData(20944, 0.25f));
        //////// Kodai (-)(4) /////////
        remapData.put(20939, new RemapData(20940, 0.75f));
        remapData.put(20938, new RemapData(20940, 0.5f));
        remapData.put(20937, new RemapData(20940, 0.25f));
        //////// Elder (+)(4) /////////
        remapData.put(20923, new RemapData(20924, 0.75f));
        remapData.put(20922, new RemapData(20924, 0.5f));
        remapData.put(20921, new RemapData(20924, 0.25f));
        //////// Elder potion (4) /////////
        remapData.put(20919, new RemapData(20920, 0.75f));
        remapData.put(20918, new RemapData(20920, 0.5f));
        remapData.put(20917, new RemapData(20920, 0.25f));
        //////// Elder (-)(4) /////////
        remapData.put(20915, new RemapData(20916, 0.75f));
        remapData.put(20914, new RemapData(20916, 0.5f));
        remapData.put(20913, new RemapData(20916, 0.25f));
        //////// Zamorak brew(4) /////////
        remapData.put(189, new RemapData(2450, 0.75f));
        remapData.put(191, new RemapData(2450, 0.5f));
        remapData.put(193, new RemapData(2450, 0.25f));
        //////// Waterskin(4) /////////
        remapData.put(1825, new RemapData(1823, 0.75f));
        remapData.put(1827, new RemapData(1823, 0.5f));
        remapData.put(1829, new RemapData(1823, 0.25f));
        remapData.put(1831, new RemapData(1823, 0.0f));
        //////// Watering can(8) /////////
        remapData.put(5339, new RemapData(5340, 0.875f));
        remapData.put(5338, new RemapData(5340, 0.75f));
        remapData.put(5337, new RemapData(5340, 0.625f));
        remapData.put(5336, new RemapData(5340, 0.5f));
        remapData.put(5335, new RemapData(5340, 0.375f));
        remapData.put(5334, new RemapData(5340, 0.25f));
        remapData.put(5333, new RemapData(5340, 0.125f));
        remapData.put(5331, new RemapData(5340, 0.0f));
        //////// Teleport crystal (5) /////////
        remapData.put(6099, new RemapData(13102, 0.8f));
        remapData.put(6100, new RemapData(13102, 0.6f));
        remapData.put(6101, new RemapData(13102, 0.4f));
        remapData.put(6102, new RemapData(13102, 0.2f));
        //////// Super strength(4) /////////
        remapData.put(157, new RemapData(2440, 0.75f));
        remapData.put(159, new RemapData(2440, 0.5f));
        remapData.put(161, new RemapData(2440, 0.25f));
        //////// Super restore(4) /////////
        remapData.put(3026, new RemapData(3024, 0.75f));
        remapData.put(3028, new RemapData(3024, 0.5f));
        remapData.put(3030, new RemapData(3024, 0.25f));
        //////// Super ranging (4) /////////
        remapData.put(11723, new RemapData(11722, 0.75f));
        remapData.put(11724, new RemapData(11722, 0.5f));
        remapData.put(11725, new RemapData(11722, 0.25f));
        //////// Super magic potion (4) /////////
        remapData.put(11727, new RemapData(11726, 0.75f));
        remapData.put(11728, new RemapData(11726, 0.5f));
        remapData.put(11729, new RemapData(11726, 0.25f));
        //////// Super energy(4) /////////
        remapData.put(3018, new RemapData(3016, 0.75f));
        remapData.put(3020, new RemapData(3016, 0.5f));
        remapData.put(3022, new RemapData(3016, 0.25f));
        //////// Super defence(4) /////////
        remapData.put(163, new RemapData(2442, 0.75f));
        remapData.put(165, new RemapData(2442, 0.5f));
        remapData.put(167, new RemapData(2442, 0.25f));
        //////// Super combat potion(4) /////////
        remapData.put(12697, new RemapData(12695, 0.75f));
        remapData.put(12699, new RemapData(12695, 0.5f));
        remapData.put(12701, new RemapData(12695, 0.25f));
        //////// Super attack(4) /////////
        remapData.put(145, new RemapData(2436, 0.75f));
        remapData.put(147, new RemapData(2436, 0.5f));
        remapData.put(149, new RemapData(2436, 0.25f));
        //////// Super antifire potion(4) /////////
        remapData.put(21981, new RemapData(21978, 0.75f));
        remapData.put(21984, new RemapData(21978, 0.5f));
        remapData.put(21987, new RemapData(21978, 0.25f));
        //////// Superantipoison(4) /////////
        remapData.put(181, new RemapData(2448, 0.75f));
        remapData.put(183, new RemapData(2448, 0.5f));
        remapData.put(185, new RemapData(2448, 0.25f));
        //////// Strength potion(4) /////////
        remapData.put(115, new RemapData(113, 0.75f));
        remapData.put(117, new RemapData(113, 0.5f));
        remapData.put(119, new RemapData(113, 0.25f));
        //////// Stamina potion(4) /////////
        remapData.put(12627, new RemapData(12625, 0.75f));
        remapData.put(12629, new RemapData(12625, 0.5f));
        remapData.put(12631, new RemapData(12625, 0.25f));
        //////// Serum 208 (4) /////////
        remapData.put(3417, new RemapData(3416, 0.75f));
        remapData.put(3418, new RemapData(3416, 0.5f));
        remapData.put(3419, new RemapData(3416, 0.25f));
        //////// Serum 207 (4) /////////
        remapData.put(3410, new RemapData(3408, 0.75f));
        remapData.put(3412, new RemapData(3408, 0.5f));
        remapData.put(3414, new RemapData(3408, 0.25f));
        //////// Saradomin brew(4) /////////
        remapData.put(6687, new RemapData(6685, 0.75f));
        remapData.put(6689, new RemapData(6685, 0.5f));
        remapData.put(6691, new RemapData(6685, 0.25f));
        //////// Sanfew serum(4) /////////
        remapData.put(10927, new RemapData(10925, 0.75f));
        remapData.put(10929, new RemapData(10925, 0.5f));
        remapData.put(10931, new RemapData(10925, 0.25f));
        //////// Potatoes(10) /////////
        remapData.put(5436, new RemapData(5438, 0.9f));
        remapData.put(5434, new RemapData(5438, 0.8f));
        remapData.put(5432, new RemapData(5438, 0.7f));
        remapData.put(5430, new RemapData(5438, 0.6f));
        remapData.put(5428, new RemapData(5438, 0.5f));
        remapData.put(5426, new RemapData(5438, 0.4f));
        remapData.put(5424, new RemapData(5438, 0.3f));
        remapData.put(5422, new RemapData(5438, 0.2f));
        remapData.put(5420, new RemapData(5438, 0.1f));
        //////// Onions(10) /////////
        remapData.put(5456, new RemapData(5458, 0.9f));
        remapData.put(5454, new RemapData(5458, 0.8f));
        remapData.put(5452, new RemapData(5458, 0.7f));
        remapData.put(5450, new RemapData(5458, 0.6f));
        remapData.put(5448, new RemapData(5458, 0.5f));
        remapData.put(5446, new RemapData(5458, 0.4f));
        remapData.put(5444, new RemapData(5458, 0.3f));
        remapData.put(5442, new RemapData(5458, 0.2f));
        remapData.put(5440, new RemapData(5458, 0.1f));
        //////// Cabbages(10) /////////
        remapData.put(5476, new RemapData(5478, 0.9f));
        remapData.put(5474, new RemapData(5478, 0.8f));
        remapData.put(5472, new RemapData(5478, 0.7f));
        remapData.put(5470, new RemapData(5478, 0.6f));
        remapData.put(5468, new RemapData(5478, 0.5f));
        remapData.put(5466, new RemapData(5478, 0.4f));
        remapData.put(5464, new RemapData(5478, 0.3f));
        remapData.put(5462, new RemapData(5478, 0.2f));
        remapData.put(5460, new RemapData(5478, 0.1f));
        //////// Slayer ring (8) /////////
        remapData.put(11867, new RemapData(11866, 0.875f));
        remapData.put(11868, new RemapData(11866, 0.75f));
        remapData.put(11869, new RemapData(11866, 0.625f));
        remapData.put(11870, new RemapData(11866, 0.5f));
        remapData.put(11871, new RemapData(11866, 0.375f));
        remapData.put(11872, new RemapData(11866, 0.25f));
        remapData.put(11873, new RemapData(11866, 0.125f));
        //////// Ring of dueling(8) /////////
        remapData.put(2554, new RemapData(2552, 0.875f));
        remapData.put(2556, new RemapData(2552, 0.75f));
        remapData.put(2558, new RemapData(2552, 0.625f));
        remapData.put(2560, new RemapData(2552, 0.5f));
        remapData.put(2562, new RemapData(2552, 0.375f));
        remapData.put(2564, new RemapData(2552, 0.25f));
        remapData.put(2566, new RemapData(2552, 0.125f));
        //////// Ring of returning(5) /////////
        remapData.put(21132, new RemapData(21129, 0.8f));
        remapData.put(21134, new RemapData(21129, 0.6f));
        remapData.put(21136, new RemapData(21129, 0.4f));
        remapData.put(21138, new RemapData(21129, 0.2f));
        //////// Restore potion(4) /////////
        remapData.put(127, new RemapData(2430, 0.75f));
        remapData.put(129, new RemapData(2430, 0.5f));
        remapData.put(131, new RemapData(2430, 0.25f));
        //////// Relicym's balm(4) /////////
        remapData.put(4844, new RemapData(4842, 0.75f));
        remapData.put(4846, new RemapData(4842, 0.5f));
        remapData.put(4848, new RemapData(4842, 0.25f));
        //////// Ranging potion(4) /////////
        remapData.put(169, new RemapData(2444, 0.75f));
        remapData.put(171, new RemapData(2444, 0.5f));
        remapData.put(173, new RemapData(2444, 0.25f));
        //////// Prayer potion(4) /////////
        remapData.put(139, new RemapData(2434, 0.75f));
        remapData.put(141, new RemapData(2434, 0.5f));
        remapData.put(143, new RemapData(2434, 0.25f));
        //////// Necklace of passage(5) /////////
        remapData.put(21149, new RemapData(21146, 0.8f));
        remapData.put(21151, new RemapData(21146, 0.6f));
        remapData.put(21153, new RemapData(21146, 0.4f));
        remapData.put(21155, new RemapData(21146, 0.2f));
        //////// Overload (4) /////////
        remapData.put(11731, new RemapData(11730, 0.75f));
        remapData.put(11732, new RemapData(11730, 0.5f));
        remapData.put(11733, new RemapData(11730, 0.25f));
        //////// Magic essence(4) /////////
        remapData.put(9022, new RemapData(9021, 0.75f));
        remapData.put(9023, new RemapData(9021, 0.5f));
        remapData.put(9024, new RemapData(9021, 0.25f));
        //////// Magic potion(4) /////////
        remapData.put(3042, new RemapData(3040, 0.75f));
        remapData.put(3044, new RemapData(3040, 0.5f));
        remapData.put(3046, new RemapData(3040, 0.25f));
        //////// Imp-in-a-box(2) /////////
        remapData.put(10028, new RemapData(10027, 0.5f));
        //////// Hunter potion(4) /////////
        remapData.put(10000, new RemapData(9998, 0.75f));
        remapData.put(10002, new RemapData(9998, 0.5f));
        remapData.put(10004, new RemapData(9998, 0.25f));
        //////// Guthix balance(4) /////////
        remapData.put(7662, new RemapData(7660, 0.75f));
        remapData.put(7664, new RemapData(7660, 0.5f));
        remapData.put(7666, new RemapData(7660, 0.25f));
        //////// Guthix rest(4) /////////
        remapData.put(4419, new RemapData(4417, 0.75f));
        remapData.put(4421, new RemapData(4417, 0.5f));
        remapData.put(4423, new RemapData(4417, 0.25f));
        //////// Games necklace(8) /////////
        remapData.put(3855, new RemapData(3853, 0.875f));
        remapData.put(3857, new RemapData(3853, 0.75f));
        remapData.put(3859, new RemapData(3853, 0.625f));
        remapData.put(3861, new RemapData(3853, 0.5f));
        remapData.put(3863, new RemapData(3853, 0.375f));
        remapData.put(3865, new RemapData(3853, 0.25f));
        remapData.put(3867, new RemapData(3853, 0.125f));
        //////// Fungicide spray 10 /////////
        remapData.put(7422, new RemapData(7421, 0.9f));
        remapData.put(7423, new RemapData(7421, 0.8f));
        remapData.put(7424, new RemapData(7421, 0.7f));
        remapData.put(7425, new RemapData(7421, 0.6f));
        remapData.put(7426, new RemapData(7421, 0.5f));
        remapData.put(7427, new RemapData(7421, 0.4f));
        remapData.put(7428, new RemapData(7421, 0.3f));
        remapData.put(7429, new RemapData(7421, 0.2f));
        remapData.put(7430, new RemapData(7421, 0.1f));
        remapData.put(7431, new RemapData(7421, 0.0f));
        //////// Fishing potion(4) /////////
        remapData.put(151, new RemapData(2438, 0.75f));
        remapData.put(153, new RemapData(2438, 0.5f));
        remapData.put(155, new RemapData(2438, 0.25f));
        //////// Extended super antifire(4) /////////
        remapData.put(22212, new RemapData(22209, 0.75f));
        remapData.put(22215, new RemapData(22209, 0.5f));
        remapData.put(22218, new RemapData(22209, 0.25f));
        //////// Extended antifire(4) /////////
        remapData.put(11953, new RemapData(11951, 0.75f));
        remapData.put(11955, new RemapData(11951, 0.5f));
        remapData.put(11957, new RemapData(11951, 0.25f));
        //////// Energy potion(4) /////////
        remapData.put(3010, new RemapData(3008, 0.75f));
        remapData.put(3012, new RemapData(3008, 0.5f));
        remapData.put(3014, new RemapData(3008, 0.25f));
        //////// Enchanted lyre(5) /////////
        remapData.put(6127, new RemapData(13079, 0.8f));
        remapData.put(6126, new RemapData(13079, 0.6f));
        remapData.put(6125, new RemapData(13079, 0.4f));
        remapData.put(3691, new RemapData(13079, 0.2f));
        //////// Divine super strength potion(4) /////////
        remapData.put(23712, new RemapData(23709, 0.75f));
        remapData.put(23715, new RemapData(23709, 0.5f));
        remapData.put(23718, new RemapData(23709, 0.25f));
        //////// Divine super defence potion(4) /////////
        remapData.put(23724, new RemapData(23721, 0.75f));
        remapData.put(23727, new RemapData(23721, 0.5f));
        remapData.put(23730, new RemapData(23721, 0.25f));
        //////// Divine super combat potion(4) /////////
        remapData.put(23688, new RemapData(23685, 0.75f));
        remapData.put(23691, new RemapData(23685, 0.5f));
        remapData.put(23694, new RemapData(23685, 0.25f));
        //////// Divine super attack potion(4) /////////
        remapData.put(23700, new RemapData(23697, 0.75f));
        remapData.put(23703, new RemapData(23697, 0.5f));
        remapData.put(23706, new RemapData(23697, 0.25f));
        //////// Divine ranging potion(4) /////////
        remapData.put(23736, new RemapData(23733, 0.75f));
        remapData.put(23739, new RemapData(23733, 0.5f));
        remapData.put(23742, new RemapData(23733, 0.25f));
        //////// Divine magic potion(4) /////////
        remapData.put(23748, new RemapData(23745, 0.75f));
        remapData.put(23751, new RemapData(23745, 0.5f));
        remapData.put(23754, new RemapData(23745, 0.25f));
        //////// Divine battlemage potion(4) /////////
        remapData.put(24626, new RemapData(24623, 0.75f));
        remapData.put(24629, new RemapData(24623, 0.5f));
        remapData.put(24632, new RemapData(24623, 0.25f));
        //////// Divine bastion potion(4) /////////
        remapData.put(24638, new RemapData(24635, 0.75f));
        remapData.put(24641, new RemapData(24635, 0.5f));
        remapData.put(24644, new RemapData(24635, 0.25f));
        //////// Digsite pendant (5) /////////
        remapData.put(11193, new RemapData(11194, 0.8f));
        remapData.put(11192, new RemapData(11194, 0.6f));
        remapData.put(11191, new RemapData(11194, 0.4f));
        remapData.put(11190, new RemapData(11194, 0.2f));
        //////// Defence potion(4) /////////
        remapData.put(133, new RemapData(2432, 0.75f));
        remapData.put(135, new RemapData(2432, 0.5f));
        remapData.put(137, new RemapData(2432, 0.25f));
        //////// Compost potion(4) /////////
        remapData.put(6472, new RemapData(6470, 0.75f));
        remapData.put(6474, new RemapData(6470, 0.5f));
        remapData.put(6476, new RemapData(6470, 0.25f));
        //////// Combat potion(4) /////////
        remapData.put(9741, new RemapData(9739, 0.75f));
        remapData.put(9743, new RemapData(9739, 0.5f));
        remapData.put(9745, new RemapData(9739, 0.25f));
        //////// Burning amulet(5) /////////
        remapData.put(21169, new RemapData(21166, 0.8f));
        remapData.put(21171, new RemapData(21166, 0.6f));
        remapData.put(21173, new RemapData(21166, 0.4f));
        remapData.put(21175, new RemapData(21166, 0.2f));
        //////// Blighted super restore(4) /////////
        remapData.put(24601, new RemapData(24598, 0.75f));
        remapData.put(24603, new RemapData(24598, 0.5f));
        remapData.put(24605, new RemapData(24598, 0.25f));
        //////// Ogre bellows (3) /////////
        remapData.put(2873, new RemapData(2872, 0.6666667f));
        remapData.put(2874, new RemapData(2872, 0.33333334f));
        remapData.put(2871, new RemapData(2872, 0.0f));
        //////// Battlemage potion(4) /////////
        remapData.put(22452, new RemapData(22449, 0.75f));
        remapData.put(22455, new RemapData(22449, 0.5f));
        remapData.put(22458, new RemapData(22449, 0.25f));
        //////// Bastion potion(4) /////////
        remapData.put(22464, new RemapData(22461, 0.75f));
        remapData.put(22467, new RemapData(22461, 0.5f));
        remapData.put(22470, new RemapData(22461, 0.25f));
        //////// Tomatoes(5) /////////
        remapData.put(5966, new RemapData(5968, 0.8f));
        remapData.put(5964, new RemapData(5968, 0.6f));
        remapData.put(5962, new RemapData(5968, 0.4f));
        remapData.put(5960, new RemapData(5968, 0.2f));
        //////// Strawberries(5) /////////
        remapData.put(5404, new RemapData(5406, 0.8f));
        remapData.put(5402, new RemapData(5406, 0.6f));
        remapData.put(5400, new RemapData(5406, 0.4f));
        remapData.put(5398, new RemapData(5406, 0.2f));
        //////// Oranges(5) /////////
        remapData.put(5394, new RemapData(5396, 0.8f));
        remapData.put(5392, new RemapData(5396, 0.6f));
        remapData.put(5390, new RemapData(5396, 0.4f));
        remapData.put(5388, new RemapData(5396, 0.2f));
        //////// Bananas(5) /////////
        remapData.put(5414, new RemapData(5416, 0.8f));
        remapData.put(5412, new RemapData(5416, 0.6f));
        remapData.put(5410, new RemapData(5416, 0.4f));
        remapData.put(5408, new RemapData(5416, 0.2f));
        //////// Apples(5) /////////
        remapData.put(5384, new RemapData(5386, 0.8f));
        remapData.put(5382, new RemapData(5386, 0.6f));
        remapData.put(5380, new RemapData(5386, 0.4f));
        remapData.put(5378, new RemapData(5386, 0.2f));
        //////// Attack potion(4) /////////
        remapData.put(121, new RemapData(2428, 0.75f));
        remapData.put(123, new RemapData(2428, 0.5f));
        remapData.put(125, new RemapData(2428, 0.25f));
        //////// Anti-venom+(4) /////////
        remapData.put(12915, new RemapData(12913, 0.75f));
        remapData.put(12917, new RemapData(12913, 0.5f));
        remapData.put(12919, new RemapData(12913, 0.25f));
        //////// Anti-venom(4) /////////
        remapData.put(12907, new RemapData(12905, 0.75f));
        remapData.put(12909, new RemapData(12905, 0.5f));
        remapData.put(12911, new RemapData(12905, 0.25f));
        //////// Antifire potion(4) /////////
        remapData.put(2454, new RemapData(2452, 0.75f));
        remapData.put(2456, new RemapData(2452, 0.5f));
        remapData.put(2458, new RemapData(2452, 0.25f));
        //////// Ancient brew(4) /////////
        remapData.put(26342, new RemapData(26340, 0.75f));
        remapData.put(26344, new RemapData(26340, 0.5f));
        remapData.put(26346, new RemapData(26340, 0.25f));
        //////// Antidote++(4) /////////
        remapData.put(5954, new RemapData(5952, 0.75f));
        remapData.put(5956, new RemapData(5952, 0.5f));
        remapData.put(5958, new RemapData(5952, 0.25f));
        //////// Antidote+(4) /////////
        remapData.put(5945, new RemapData(5943, 0.75f));
        remapData.put(5947, new RemapData(5943, 0.5f));
        remapData.put(5949, new RemapData(5943, 0.25f));
        //////// Antipoison(4) /////////
        remapData.put(175, new RemapData(2446, 0.75f));
        remapData.put(177, new RemapData(2446, 0.5f));
        remapData.put(179, new RemapData(2446, 0.25f));
        //////// Agility potion(4) /////////
        remapData.put(3034, new RemapData(3032, 0.75f));
        remapData.put(3036, new RemapData(3032, 0.5f));
        remapData.put(3038, new RemapData(3032, 0.25f));
        //////// Absorption (4) /////////
        remapData.put(11735, new RemapData(11734, 0.75f));
        remapData.put(11736, new RemapData(11734, 0.5f));
        remapData.put(11737, new RemapData(11734, 0.25f));
        //////// Abyssal bracelet(5) /////////
        remapData.put(11097, new RemapData(11095, 0.8f));
        remapData.put(11099, new RemapData(11095, 0.6f));
        remapData.put(11101, new RemapData(11095, 0.4f));
        remapData.put(11103, new RemapData(11095, 0.2f));
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, nofatigue <https://github.com/nofatigue>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

import java.awt.*;
import java.text.NumberFormat;
import java.time.Instant;
import java.awt.image.BufferedImage;

import com.google.inject.Inject;

import static net.runelite.api.ScriptID.XPDROPS_SETDROPSIZE;
import static net.runelite.api.ScriptID.XPDROP_DISABLED;

@Slf4j
/*
	Implement gold drops.
	We do this by using the XPDrop mechanism, namely the Fake XPDrop script,
	which is intended to generate xp drops for maxed out skills.
	Fake XP Drops are composed of a skill sprite,
	and a text widget with a mod icon (<img=11> in text)
	So to create a gold drop, we create a fake xp drop, and interefere in the middle,
	and change the sprite and text to our liking.

	Flow is:

	1. create xp drop using runScript (see requestGoldDrop)
	2. getting in the middle of the drop, changing icon and text (see handleXpDrop)

	A more correct way to do this is probably by calling Item.GetImage with wanted
	coin quantity, which will give us correct coin icon and correct text,
	and simply drawing that image ourselfs somehow. Instead of using xp drop mechanism.
	*/
public class GoldDropManager extends Overlay {
	/*
	Free sprite ids for the gold icons.
	 */
	private static final int COINS_100_SPRITE_ID = -1337;
	private static final int COINS_250_SPRITE_ID = -1338;
	private static final int COINS_1000_SPRITE_ID = -1339;
	private static final int COINS_10000_SPRITE_ID = -1340;

	// Skill ordinal to send in the fake xp drop script.
	// doesn't matter which skill expect it's better not be attack/defense/magic to avoid collision with
	// XpDropPlugin which looks for those and might change text color
	private static final int XPDROP_SKILL = Skill.FISHING.ordinal();

	/*
	Singletons which will be provided at creation by the plugin
	 */
	private final ItemManager itemManager;
	private final Client client;
	private final GPPerHourConfig config;
	private final ConfigManager configManager;
	private final GPPerHourPlugin plugin;

	private boolean hasLoadedCoinsImages;
    private BufferedImage coinsImage100;
    private BufferedImage coinsImage250;
    private BufferedImage coinsImage1000;
    private BufferedImage coinsImage10000;

	/* var currentGoldDropValue will have
	the gold value of the current ongoing gold drop. 2 purposes:
	  1. to know the value later when we actually use it,
	  2. to know to catch the next fake xpdrop in onScriptPreFired
	*/
	private long currentGoldDropValue;

    @AllArgsConstructor
    public enum GoldDropDisplayMode {
        DISABLED                        ("Disabled"),
        VANILLA              			("Vanilla"),
        STATIC              			("Static");
    
        private final String configName;
        @Override
        public String toString() { return configName; }
    }

	@Inject
	GoldDropManager(Client client, GPPerHourPlugin plugin, ItemManager itemManager, GPPerHourConfig config, ConfigManager configManager)
	{
		this.client = client;
		this.plugin = plugin;
		this.itemManager = itemManager;
		this.config = config;
		this.configManager = configManager;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);

		prepareCoinSprite(10000, COINS_10000_SPRITE_ID);
		prepareCoinSprite(1000, COINS_1000_SPRITE_ID);
		prepareCoinSprite(250, COINS_250_SPRITE_ID);
		prepareCoinSprite(100, COINS_100_SPRITE_ID);

		currentGoldDropValue = 0L;

	}

	public void onScriptPreFired(ScriptPreFired scriptPreFired)
	{
        /*
        We check for scripts of type XPDROPS_SETDROPSIZE to interfere with the XPdrop
        and write our own values
         */

		// is this current script type?
		if (scriptPreFired.getScriptId() != XPDROPS_SETDROPSIZE)
		{
			return;
		}

		// Get xpdrop widget id using the stack
		// taken from XpDropPlugin!

		// This runs prior to the proc being invoked, so the arguments are still on the stack.
		// Grab the first argument to the script.
		final int[] intStack = client.getIntStack();
		final int intStackSize = client.getIntStackSize();

		final int widgetId = intStack[intStackSize - 4];

		// extract information from currentGoldDropValue
		boolean isThisGoldDrop =   (currentGoldDropValue != 0);
		long     goldDropValue =     currentGoldDropValue;

		// done with this gold drop anyway
		currentGoldDropValue = 0;

		handleXpDrop(widgetId, isThisGoldDrop, goldDropValue);

	}

	private void handleXpDrop(int xpDropWidgetId, boolean isThisGoldDrop, long goldDropValue)
	{
		final Widget xpDropWidget;
		final Widget dropTextWidget;

		Widget[] xpDropWidgetChildren;

		// get widget from ID
		xpDropWidget = client.getWidget(WidgetUtil.componentToInterface(xpDropWidgetId), WidgetUtil.componentToId(xpDropWidgetId));

		if (xpDropWidget == null)
		{
			log.error("xpDropWidget was null");
			return;
		}

		xpDropWidgetChildren = xpDropWidget.getChildren();

		if (xpDropWidgetChildren.length < 1)
		{
			log.error(String.format("Unexpected xpDropWidgets length! %d", xpDropWidgetChildren.length));
			return;
		}

		dropTextWidget = xpDropWidgetChildren[0];

		if (isThisGoldDrop)
		{
			final Widget dropSpriteWidget;

			if (xpDropWidgetChildren.length < 2)
			{
				log.error(String.format(
					"Unexpected xpDropWidgetChildren length for a gold drop! length! %d",
					xpDropWidgetChildren.length));
				return;
			}

			dropSpriteWidget = xpDropWidgetChildren[1];
			xpDropToGoldDrop(dropTextWidget, dropSpriteWidget, goldDropValue);
		}
		//don't need to do this if xp drop plugin is active since it will handle this and it doesn't overwrite prayer colors this way
		else if (config.goldDropsDisplayMode() == GoldDropDisplayMode.VANILLA && 
			!((Boolean) configManager.getConfiguration("runelite", "xpdropplugin", Boolean.class)))
		{
			// reset text color for all regular xpdrops
			resetXpDropTextColor(dropTextWidget);
		}
	}

	private void xpDropToGoldDrop(Widget dropTextWidget, Widget dropSpriteWidget, long goldDropValue)
	{
        /*
        Change xpdrop icon and text, to make a gold drop
         */
		dropTextWidget.setText(formatGoldDropText(goldDropValue));

		if (goldDropValue > 0)
		{
			dropTextWidget.setTextColor(config.goldDropsPositiveColor().getRGB());
			dropTextWidget.setOpacity(255 - config.goldDropsPositiveColor().getAlpha());
		}
		else
		{
			dropTextWidget.setTextColor(config.goldDropsNegativeColor().getRGB());
			dropTextWidget.setOpacity(255 - config.goldDropsNegativeColor().getAlpha());
		}

		int spriteId = 0;
		long absValue = Math.abs(goldDropValue);
		if (absValue >= 10000)
		{
			spriteId = COINS_10000_SPRITE_ID;
		}
		else if (absValue >= 1000)
		{
			spriteId = COINS_1000_SPRITE_ID;
		}
		else if (absValue >= 250)
		{
			spriteId = COINS_250_SPRITE_ID;
		}
		else
		{
			spriteId = COINS_100_SPRITE_ID;
		}

		// change skill sprite to coin sprite
		dropSpriteWidget.setSpriteId(spriteId);
	}

	private void prepareCoinSprite(int quantity, int spriteId)
	{
        /*
        Prepare coin sprites for use in the gold drops.
        It seems item icons are not available as sprites with id,
        so we convert in this function.
        */

		// get image object by coin item id
		AsyncBufferedImage coin_image_raw = itemManager.getImage(ItemID.COINS, quantity, false);

		Runnable r = () -> {
			final SpritePixels coin_sprite = ImageUtil.getImageSpritePixels(coin_image_raw, client);
			// register new coin sprite by overriding a free sprite id
			client.getSpriteOverrides().put(spriteId, coin_sprite);
		};

		coin_image_raw.onLoaded(r);
	}

	public void requestGoldDrop(long amount)
	{
		// Alternate way to display gold drops for people who use the customizable xp drops plugin
		if (this.config.goldDropsDisplayMode() == GoldDropDisplayMode.STATIC)
		{
			showStaticDrop(amount);
			return;
		}
		// save the value and mark an ongoing gold drop
		currentGoldDropValue = amount;

		///// Create a fake xp drop.
		// skill ordinal - we will replace the icon anyway

		// value - since we want to be able to pass negative numbers, we pass the value using
		// currentGoldDropValue instead of this argument, but still need to make sure the digits match for formatting

		if (amount < 0)
		{
			//force positive number, add extra digit to give room for minus sign on the left
			amount *= -10;
		}

		//Need to offset to the left by two digits to account for the fake xp drop red icon that we're getting rid of
		amount /= 100;
		//don't ever want a 0 drop (anything <100 will have too much space sadly, can potentially fix this by messing with the widget)
		if (amount == 0)
			amount = 1;

		client.runScript(XPDROP_DISABLED, XPDROP_SKILL, (int) amount);
	}

	private void resetXpDropTextColor(Widget xpDropTextWidget)
	{
		// taken from XpDropPlugin
		EnumComposition colorEnum = client.getEnum(EnumID.XPDROP_COLORS);
		int defaultColorId = client.getVarbitValue(VarbitID.XPDROPS_COLOUR);
		int color = colorEnum.getIntValue(defaultColorId);
		xpDropTextWidget.setTextColor(color);
		xpDropTextWidget.setOpacity(0);
	}

	boolean showingStaticGoldDrop = false;
	long currentStaticAmountToShow;
	long staticGoldDropDisplayTime;
	private static final int staticImageDimension = 24;

	private void showStaticDrop(long amount)
	{
		if (showingStaticGoldDrop)
		{
			currentStaticAmountToShow += amount;
		}
		else
		{
			currentStaticAmountToShow = amount;
		}

		showingStaticGoldDrop = true;
		staticGoldDropDisplayTime = Instant.now().toEpochMilli();
	}

	private InventoryWidgetData lastWidgetData;
	
	@Data
	private class InventoryWidgetData
	{
		public net.runelite.api.Point canvasLocation;
		public int width;
		public int height;
	}

	@Override
	public Dimension render(Graphics2D graphics) {
		
		Widget inventoryWidget = plugin.getInventoryWidget();
		boolean isInvHidden = inventoryWidget == null || inventoryWidget.isHidden();
		if (isInvHidden && lastWidgetData == null)
			return null;
		
		if (!isInvHidden)
		{
			if	(lastWidgetData == null)
				lastWidgetData = new InventoryWidgetData();
			
			lastWidgetData.canvasLocation = inventoryWidget.getCanvasLocation();
			lastWidgetData.width = inventoryWidget.getWidth();
			lastWidgetData.height = inventoryWidget.getHeight();
		}
		if (!showingStaticGoldDrop || currentStaticAmountToShow == 0)
		{
			return null;
		}

		long fadeOutTimeMillis = 3000;
		long timePassed = Instant.now().toEpochMilli() - staticGoldDropDisplayTime;
		float percentDone = ((float)timePassed) / ((float)fadeOutTimeMillis);
		if (percentDone > 1f)
		{
			showingStaticGoldDrop = false;
			return null;
		}

		int x = lastWidgetData.getCanvasLocation().getX() + 20 - lastWidgetData.width / 2;
		int y = lastWidgetData.getCanvasLocation().getY() + 20 - config.inventoryYOffset();
		String text = QuantityFormatter.quantityToStackSize(currentStaticAmountToShow);

		BufferedImage image = getCoinsImage((int) currentStaticAmountToShow);

		float alpha = clamp(2f-percentDone*2f, 0, 1f);
		Composite composite = graphics.getComposite();
		graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha));
		graphics.drawImage(image, x - staticImageDimension, y - staticImageDimension/2, null);
		graphics.setComposite(composite);

		Color textColor;
		if (currentStaticAmountToShow > 0)
			textColor = config.goldDropsPositiveColor();
		else
			textColor = config.goldDropsNegativeColor();
		graphics.setColor(new Color(textColor.getRed()/255f, textColor.getGreen()/255f, textColor.getBlue()/255f, (textColor.getAlpha()/255f) * alpha));
		graphics.drawString(text, x+1, y + graphics.getFontMetrics().getHeight()/2);

		return null;
	}



	private BufferedImage getCoinsImage(int quantity)
	{
		if(!hasLoadedCoinsImages)
			loadCoinsImages();

		long absValue = Math.abs(quantity);
		if (absValue >= 10000)
		{
			return coinsImage10000;
		}
		else if (absValue >= 1000)
		{
			return coinsImage1000;
		}
		else if (absValue >= 250)
		{
			return coinsImage250;
		}
		else
		{
			return coinsImage100;
		}
	}

    private void loadCoinsImages()
    {
        coinsImage100 = loadCoinsImage(100);
        coinsImage250 = loadCoinsImage(250);
        coinsImage1000 = loadCoinsImage(1000);
        coinsImage10000 = loadCoinsImage(10000);
		hasLoadedCoinsImages = true;
    }

    private BufferedImage loadCoinsImage(int quantity)
    {
		BufferedImage image = itemManager.getImage(ItemID.COINS, quantity, false);
		image = ImageUtil.resizeImage(image, staticImageDimension, staticImageDimension);
		return image;
    }



	private String formatGoldDropText(long goldDropValue)
	{
		return NumberFormat.getInstance().format(goldDropValue);
	}

    private static float clamp(float value, float min, float max) {
        if (value < min) {
            return min;
        } else if (value > max) {
            return max;
        } else {
            return value;
        }
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import java.awt.BorderLayout;
import java.awt.Color;

import javax.swing.JPanel;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;

import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

//The root side panel that can display either the active session or session history
class GPPerHourPanel extends PluginPanel
{
	private static final Color lineColor = ColorScheme.BRAND_ORANGE;

	// this panel will hold either the active session panel or the session history panel
	private final JPanel display = new JPanel();

	private final MaterialTabGroup tabGroup = new MaterialTabGroup(display);
	private final MaterialTab sessionHistoryTab;
	private final JPanel titlePanel = new JPanel();

	@Getter
	private final ActiveSessionPanel activeSessionPanel;
	@Getter
	private final SessionHistoryPanel sessionHistoryPanel;
	@Getter
	private boolean active;

	GPPerHourPanel(ActiveSessionPanel activeSessionPanel, SessionHistoryPanel sessionHistoryPanel)
	{
		super(false);

		this.activeSessionPanel = activeSessionPanel;
		this.sessionHistoryPanel = sessionHistoryPanel;

		buildTitlePanel();

		this.setLayout(new BorderLayout());
		this.setBackground(ColorScheme.DARK_GRAY_COLOR);
		this.setBorder(new EmptyBorder(10, 5, 10, 5));

		MaterialTab activeSessionTab = new MaterialTab("Active Session", tabGroup, activeSessionPanel);
		sessionHistoryTab = new MaterialTab("Session History", tabGroup, sessionHistoryPanel);

		tabGroup.setBorder(new EmptyBorder(5, 0, 0, 0));
		tabGroup.addTab(activeSessionTab);
		tabGroup.addTab(sessionHistoryTab);
		tabGroup.select(activeSessionTab); // selects the default selected tab

		JPanel centerPanel = new JPanel();
		centerPanel.setLayout(new BorderLayout());
		centerPanel.add(tabGroup, BorderLayout.NORTH);
		centerPanel.add(display, BorderLayout.CENTER);

		add(titlePanel, BorderLayout.NORTH);
		add(centerPanel, BorderLayout.CENTER);
	}

	@Override
	public void onActivate()
	{
		active = true;
	}

	@Override
	public void onDeactivate()
	{
		active = false;
	}

	private JPanel buildTitlePanel()
	{
		titlePanel.setBorder(
			new CompoundBorder(new EmptyBorder(5, 0, 5, 0), new MatteBorder(0, 0, 1, 0, lineColor)));
		titlePanel.setLayout(new BorderLayout());
		PluginErrorPanel errorPanel = new PluginErrorPanel();
		errorPanel.setBorder(new EmptyBorder(2, 0, 10, 0));
		errorPanel.setContent("GP Per Hour", "Tracks your GP/hr over various trips.");
		titlePanel.add(errorPanel, "Center");
		return titlePanel;
	}

	boolean isShowingActiveSession()
	{
		return activeSessionPanel.isShowing();
	}

	boolean isShowingSessionHistory()
	{
		return sessionHistoryPanel.isShowing();
	}

	void showActiveSession()
	{
		if (activeSessionPanel.isShowing())
		{
			return;
		}

		tabGroup.select(sessionHistoryTab);
		revalidate();
	}
}
/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import java.util.LinkedList;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.*;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;

import lombok.Data;
import lombok.RequiredArgsConstructor;

import java.awt.*;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.List;

@Slf4j
//Shows all the trips from your active session and some stats.
class ActiveSessionPanel extends PluginPanel
{
	private static final String HTML_LABEL_TEMPLATE = "<html><body style='color:%s'>%s<span style='color:white'>%s</span></body></html>";
	private static final String sessionNameLabelPlaceholder = "Session Stats";
	private static final String gpPerHourLabelPrefix = "GP/hr: ";
	private static final String netTotalLabelPrefix = "Net Total: ";
	private static final String totalGainsLabelPrefix = "Total Gains: ";
	private static final String totalLossesLabelPrefix = "Total Losses: ";
	private static final String sessionTimeLabelPrefix = "Session Time: ";
	private static final String tripCountLabelPrefix = "Trip Count: ";
	private static final String avgTripDurationLabelPrefix = "Avg Trip Duration: ";
	private static final Color tripActiveBorderColor = new Color(37, 107, 31);
	private static final Color borderColor = new Color(57, 57, 57);

	private final GPPerHourConfig config;
	private final GPPerHourPlugin plugin;
	private final ItemManager itemManager;
	private final ClientThread clientThread;
	private final SessionManager sessionManager;
	private final JPanel tripsPanel = new JPanel();
	GridBagConstraints constraints = new GridBagConstraints();

	// Panels
	private final JPanel sessionInfoPanel;
	private final List<TripPanelData> tripPanels = new LinkedList<>();

	ActiveSessionPanel(GPPerHourPlugin plugin, GPPerHourConfig config, ItemManager itemManager,
			ClientThread clientThread, SessionManager sessionManager)
	{
		this.plugin = plugin;
		this.config = config;
		this.itemManager = itemManager;
		this.clientThread = clientThread;
		this.sessionManager = sessionManager;
		this.sessionInfoPanel = new JPanel();
	}

	public  void resetSessionLootGrid()
	{
		if (sessionLootPanelData != null)
		{
			sessionLootPanelData.previousLedger  = null;
		}
	}

	void sidePanelInitializer()
	{
		this.setLayout(new BorderLayout());

		/* The main container, this holds the session info and trips */
		JPanel container = new JPanel();
		container.setLayout(new BorderLayout(0, 0));
		container.setBorder(new EmptyBorder(0, 0, 0, 0));
		container.setBackground(ColorScheme.DARK_GRAY_COLOR);

		tripsPanel.setLayout(new GridBagLayout());
		tripsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		constraints.gridx = 0;
		constraints.gridy = 0;

		/* This panel wraps the trips panel and guarantees the scrolling behaviour */
		JPanel wrapper = new JPanel(new BorderLayout());
		wrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		wrapper.add(tripsPanel, BorderLayout.NORTH);

		/* The trips wrapper, this scrolling panel wraps the results container */
		JScrollPane tripsWrapper = new JScrollPane(wrapper);
		tripsWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		tripsWrapper.getVerticalScrollBar().setPreferredSize(new Dimension(12, 0));
		tripsWrapper.getVerticalScrollBar().setBorder(new EmptyBorder(0, 5, 0, 0));
		tripsWrapper.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

		container.add(buildSessionInfoPanel(), BorderLayout.NORTH);
		container.add(tripsWrapper, BorderLayout.CENTER);

		add(container, BorderLayout.CENTER);

	}

	private JLabel startTrackingButton;
	private JLabel stopTrackingButton;
	private final JLabel sessionNameLabel = new JLabel(sessionNameLabelPlaceholder);
	private final JLabel gpPerHourLabel = new JLabel(htmlLabel(gpPerHourLabelPrefix, "N/A"));
	private final JLabel netTotalLabel = new JLabel(htmlLabel(netTotalLabelPrefix, "N/A"));
	private final JLabel totalGainsLabel = new JLabel(htmlLabel(totalGainsLabelPrefix, "N/A"));
	private final JLabel totalLossesLabel = new JLabel(htmlLabel(totalLossesLabelPrefix, "N/A"));
	private final JLabel sessionTimeLabel = new JLabel(htmlLabel(sessionTimeLabelPrefix, "N/A"));
	private final JLabel tripCountLabel = new JLabel(htmlLabel(tripCountLabelPrefix, "N/A"));
	private final JLabel avgTripDurationLabel = new JLabel(htmlLabel(avgTripDurationLabelPrefix, "N/A"));
	private final JLabel errorLabel = new JLabel("Error");
	private Component errorSpacing;
	private Component tripCountSpacing;
	private Component avgTripDurationSpacing;
	private final UI.LootPanelData sessionLootPanelData = new UI.LootPanelData();
	private boolean showSessionLootGrid = true;

	void setTripCountAndDurationVisible(boolean visible)
	{
		tripCountLabel.setVisible(visible);
		avgTripDurationLabel.setVisible(visible);
		tripCountSpacing.setVisible(visible);
		avgTripDurationSpacing.setVisible(visible);
	}

	private JPanel buildSessionInfoPanel()
	{
		sessionInfoPanel.setLayout(new BorderLayout(0, 10));
		sessionInfoPanel.setBorder(new EmptyBorder(0, 0, 4, 0));

		JPanel sessionInfoSection = new JPanel();
		sessionInfoSection.setLayout(new BoxLayout(sessionInfoSection, BoxLayout.Y_AXIS));
		sessionInfoSection.setBorder(new EmptyBorder(6, 5, 3, 0));
		int vGap = 6;

		sessionNameLabel.setFont(FontManager.getRunescapeBoldFont());

		sessionInfoSection.add(sessionNameLabel);
		UI.addVerticalRigidBox(sessionInfoSection, vGap);
		sessionInfoSection.add(gpPerHourLabel);
		UI.addVerticalRigidBox(sessionInfoSection, vGap);
		sessionInfoSection.add(netTotalLabel);
		UI.addVerticalRigidBox(sessionInfoSection, vGap);
		sessionInfoSection.add(totalGainsLabel);
		UI.addVerticalRigidBox(sessionInfoSection, vGap);
		sessionInfoSection.add(totalLossesLabel);
		UI.addVerticalRigidBox(sessionInfoSection, vGap);
		sessionInfoSection.add(tripCountLabel);
		tripCountSpacing = UI.addVerticalRigidBox(sessionInfoSection, vGap);
		sessionInfoSection.add(avgTripDurationLabel);
		avgTripDurationSpacing = UI.addVerticalRigidBox(sessionInfoSection, vGap);
		sessionInfoSection.add(sessionTimeLabel);
		//error
		errorSpacing = UI.addVerticalRigidBox(sessionInfoSection, vGap);
		errorLabel.setForeground(Color.red);
		sessionInfoSection.add(errorLabel);
		errorLabel.setVisible(false);
		errorSpacing.setVisible(false);
		

		//icon buttons
		JLabel newTripButton = UI.createIconButton(UI.SESSIONINFO_PLUS_ICON, UI.SESSIONINFO_PLUS_HOVER_ICON, "Create new trip", ()-> { clientThread.invokeLater(() -> {plugin.updatePluginState(true);});});
		startTrackingButton = UI.createIconButton(UI.SESSIONINFO_PLAY_ICON, UI.SESSIONINFO_PLAY_HOVER_ICON, "Start tracking new trips", ()-> { 
			config.setEnableSessionTracking(true);
			updateStopStartVisibility();
			this.updateTrips();

		});
		stopTrackingButton = UI.createIconButton(UI.SESSIONINFO_STOP_ICON, UI.SESSIONINFO_STOP_HOVER_ICON, "Stop tracking new trips", ()-> { 
			config.setEnableSessionTracking(false);
			updateStopStartVisibility();
			this.updateTrips();
		});
		updateStopStartVisibility();
		JLabel toggleSessionLootGridButton = UI.createIconButton(UI.SESSIONINFO_GRID_ICON, UI.SESSIONINFO_GRID_HOVER_ICON, "Toggle session loot grid", ()-> { showSessionLootGrid = !showSessionLootGrid; this.updateTrips();});
		JLabel refreshPricesButton = UI.createIconButton(UI.SESSIONINFO_REFRESH_ICON, UI.SESSIONINFO_REFRESH_HOVER_ICON, "Refresh prices", ()-> { clientThread.invokeLater(() -> {plugin.refreshPrices();});});
		JLabel deleteTripsButton = UI.createIconButton(UI.SESSIONINFO_TRASH_ICON, UI.SESSIONINFO_TRASH_HOVER_ICON, "Delete all completed trips", ()-> { 

			int confirm = JOptionPane.showConfirmDialog(this, "Are you sure you want to delete all completed trips?", "Warning",
						JOptionPane.OK_CANCEL_OPTION);
			if (confirm == 0)
			{
				sessionManager.deleteAllTrips();
				this.updateTrips();
			}
		});
		JLabel settingsButton = UI.createIconButton(UI.SESSIONINFO_GEAR_ICON, UI.SESSIONINFO_GEAR_HOVER_ICON, "Open configuration", ()-> { clientThread.invokeLater(() -> {plugin.openConfiguration();});});
		JLabel saveButton = UI.createIconButton(UI.SESSIONINFO_SAVE_ICON, UI.SESSIONINFO_SAVE_HOVER_ICON, "Save session", ()-> { 

			String name = JOptionPane.showInputDialog(this,
				"Enter the name of the session to save.\nThis will not delete the selected trips.",
				"Save Session",
				JOptionPane.PLAIN_MESSAGE);

			// cancel button was clicked
			if (name == null)
			{
				return;
			}
			if (name.isEmpty())
			{
				name = "Unnamed Session";
			}
			sessionManager.saveNewSession(name);
		});
		// JLabel debugButton = UI.createIconButton(UI.SESSIONINFO_WRENCH_ICON, UI.SESSIONINFO_WRENCH_HOVER_ICON, "Rebuild all trip panels", ()->
		// {
		// 	for (TripPanelData data : tripPanels)
		// 	{
		// 		this.tripsPanel.remove(data.masterPanel);
		// 	}
		// 	this.tripPanels.clear();
		// 	this.updateTrips();
		// });

		JPanel iconButtons = new JPanel(new FlowLayout(FlowLayout.CENTER, 8, 0));
		iconButtons.add(newTripButton);
		iconButtons.add(startTrackingButton);
		iconButtons.add(stopTrackingButton);
		iconButtons.add(saveButton);
		iconButtons.add(toggleSessionLootGridButton);
		iconButtons.add(refreshPricesButton);
		iconButtons.add(deleteTripsButton);
		iconButtons.add(settingsButton);
		// iconButtons.add(debugButton);

		sessionLootPanelData.lootPanel.setLayout(new BorderLayout());
		sessionLootPanelData.lootPanel.setBorder(new MatteBorder(1,1,1,1,borderColor));
		sessionInfoPanel.add(sessionInfoSection, BorderLayout.NORTH);
		sessionInfoPanel.add(iconButtons, BorderLayout.CENTER);
		sessionInfoPanel.add(sessionLootPanelData.lootPanel, BorderLayout.SOUTH);

		return sessionInfoPanel;
	}

	void updateStopStartVisibility()
	{
		startTrackingButton.setVisible(!config.getEnableSessionTracking());
		stopTrackingButton.setVisible(config.getEnableSessionTracking());
	}

	// avoid GC
	private final List<LedgerItem> emptyLedger = new LinkedList<>();

	void updateTrips()
	{
		Graphics graphics = getGraphics();
		if (graphics == null)
		{
			return;
		}
		Map<String, TripData> trips = sessionManager.getActiveTrips();

		List<TripData> runDataSorted = trips.values().stream()
				.sorted(Comparator.comparingLong(o -> o.runStartTime)).collect(Collectors.toList());

		int tripIndex = 0;
		previousLedger = null;
		previousRunData = null;
		repeatCount = 0;
		consecutiveRepeatCount = 0;
		combinedRuntime = 0;
		for (TripData runData : runDataSorted)
		{
			boolean validTrip = renderTrip(runData, tripIndex);
			if (!validTrip)
			{
				continue;
			}

			tripIndex++;
		}
		for (int i = (tripIndex - repeatCount); i < tripPanels.size(); ++i)
		{
			getPanelData(i).masterPanel.setVisible(false);
		}

		SessionStats stats = sessionManager.getActiveSessionStats();
		if (stats == null)
		{
			sessionNameLabel.setText(sessionNameLabelPlaceholder);
			gpPerHourLabel.setText(htmlLabel(gpPerHourLabelPrefix, "N/A"));
			netTotalLabel.setText(htmlLabel(netTotalLabelPrefix, "N/A"));
			totalGainsLabel.setText(htmlLabel(totalGainsLabelPrefix, "N/A"));
			totalLossesLabel.setText(htmlLabel(totalLossesLabelPrefix, "N/A"));
			sessionTimeLabel.setText(htmlLabel(sessionTimeLabelPrefix, "N/A"));
			tripCountLabel.setText(htmlLabel(tripCountLabelPrefix, "N/A"));
			avgTripDurationLabel.setText(htmlLabel(avgTripDurationLabelPrefix, "N/A"));
			if (showSessionLootGrid)
				UI.updateLootGrid(emptyLedger, sessionLootPanelData, itemManager, config, config.sessionLootGridMaxHeight());
			updateErrorPanel(false);
		} else
		{
			sessionNameLabel.setText(sessionNameLabelPlaceholder);
			gpPerHourLabel.setText(htmlLabel(gpPerHourLabelPrefix,
					UI.formatGp(UI.getGpPerHour(stats.getSessionRuntime(), stats.getNetTotal()),
							config.showExactGp()) + "/hr"));
			netTotalLabel.setText(
					htmlLabel(netTotalLabelPrefix, UI.formatGp(stats.getNetTotal(), config.showExactGp())));
			totalGainsLabel.setText(
					htmlLabel(totalGainsLabelPrefix, UI.formatGp(stats.getTotalGain(), config.showExactGp())));
			totalLossesLabel.setText(
					htmlLabel(totalLossesLabelPrefix, UI.formatGp(stats.getTotalLoss(), config.showExactGp())));
			sessionTimeLabel.setText(htmlLabel(sessionTimeLabelPrefix, UI.formatTime(stats.getSessionRuntime())));
			boolean showTripCountAndTime = stats.getTripCount() > 1;
			setTripCountAndDurationVisible(showTripCountAndTime);
			if(showTripCountAndTime)
			{
				tripCountLabel.setText(htmlLabel(tripCountLabelPrefix, Integer.toString(stats.getTripCount())));
				avgTripDurationLabel
						.setText(htmlLabel(avgTripDurationLabelPrefix, UI.formatTime(stats.getAvgTripDuration())));
			}
			if (showSessionLootGrid)
				UI.updateLootGrid(UI.sortLedger(GPPerHourPlugin.getProfitLossLedger(stats.getInitialQtys(), stats.getQtys())),
					sessionLootPanelData, itemManager, config, config.sessionLootGridMaxHeight());
			updateErrorPanel(true);
		}
		sessionLootPanelData.lootPanel.setVisible(showSessionLootGrid);
	}

	private void updateErrorPanel(boolean visible)
	{
		if (!visible || !needsCheck())
		{
			errorLabel.setVisible(false);
			errorSpacing.setVisible(false);
			return;
		}
		
		HashSet<String> items = plugin.getChargeableItemsNeedingCheck();
		StringBuilder builder = new StringBuilder();
		builder.append("<html><body>");
		for (String item : items)
		{
			builder.append("Check " + item + " to calibrate.<br>");
		}
		builder.append("</body></html>");
		errorLabel.setVisible(true);
		errorLabel.setText(builder.toString());
		errorSpacing.setVisible(true);
	}

	private boolean needsCheck()
	{
		return plugin.getChargeableItemsNeedingCheck().size() != 0;
	}

	//not always previous but rather the first of the identical ones
	TripData previousRunData = null;
	List<LedgerItem> previousLedger = null;
	int repeatCount = 0;
	int consecutiveRepeatCount = 0;
	long previousGpPerHour = 0;
	long combinedRuntime;

	boolean renderTrip(TripData runData, int tripIndex)
	{
		List<LedgerItem> ledger = GPPerHourPlugin.getProfitLossLedger(runData.initialItemQtys,
				runData.itemQtys);

		ledger = UI.sortLedger(ledger);

		if (!runData.isInProgress() && UI.ledgersMatch(ledger, previousLedger))
		{
			consecutiveRepeatCount++;
			repeatCount++;
			TripPanelData tpData = getPanelData(tripIndex - repeatCount);
			TripStats tripStats = getTripStats(ledger);
			int startIndex = tripIndex - consecutiveRepeatCount;
			int endIndex = tripIndex;
			long runtime =  runData.getRuntime();
			combinedRuntime += runtime;
			tpData.titleLabel.setText("Trips " + (startIndex + 1) + "-" + (endIndex + 1) + " (Identical)");
			tpData.durationLabel.setText(UI.formatTime(combinedRuntime));
			long gpPerHour = UI.getGpPerHour(runtime, tripStats.getNetTotal());
			//average it into previous
			gpPerHour = (long) (((previousGpPerHour * consecutiveRepeatCount) + gpPerHour) / ((float) consecutiveRepeatCount + 1));
			tpData.topLeftLabel
					.setText(htmlLabel("GP/hr: ", UI.formatGp(gpPerHour, false) + "/hr"));
			updateButtonMiddle(tpData, runData);
			tpData.deleteWrapper.addActionListener((event) -> sessionManager.deleteTrip(runData.identifier));
			updateButtonPause(tpData, runData);
			previousGpPerHour = gpPerHour;
			return true;
		}

		TripPanelData tpData = getPanelData(tripIndex - repeatCount);
		TripStats tripStats = getTripStats(ledger);
		tpData.setContentPanelBorder(
				sessionManager.isTimeInActiveSession(runData.runStartTime) ? tripActiveBorderColor : null);

		tpData.masterPanel.setVisible(true);
		long runtime = runData.getRuntime();
		combinedRuntime = runtime;

		FontMetrics fontMetrics = getGraphics().getFontMetrics(FontManager.getRunescapeSmallFont());
		tpData.bottomRightLabel
				.setText(htmlLabel("Losses: ", QuantityFormatter.quantityToStackSize(tripStats.totalLosses)));
		long gpPerHour = UI.getGpPerHour(runtime, tripStats.getNetTotal());
		tpData.topLeftLabel
				.setText(htmlLabel("GP/hr: ", UI.formatGp(gpPerHour, false) + "/hr"));
		tpData.bottomLeftLabel
				.setText(htmlLabel("Net Total: ", QuantityFormatter.quantityToStackSize(tripStats.netTotal)));
		tpData.topRightLabel.setText(htmlLabel("Gains: ", QuantityFormatter.quantityToStackSize(tripStats.totalGains)));
		tpData.topRightLabel
				.setBorder(new EmptyBorder(0, 535 - fontMetrics.stringWidth(tpData.topLeftLabel.getText()), 0, 0));
		String title = "Trip " + (tripIndex + 1);
		if (runData.isInProgress())
		{
			title += " (Active)";
		}
		tpData.titleLabel.setText(title);
		tpData.subtitleLabel.setText("Started " + UI.getTimeAgo(runData.runStartTime));
		tpData.durationLabel.setText(UI.formatTime(runtime));
		// buttons
		UI.clearListeners(tpData.buttonLeft);
		tpData.buttonLeft.setEnabled(!sessionManager.getActiveSessionStartId().equals(runData.identifier));
		tpData.buttonLeft.setText("Set Start");
		tpData.buttonLeft.setToolTipText("Set this trip as the start of the active session.");
		tpData.buttonLeft.addActionListener((event) ->
		{
			sessionManager.setSessionStart(runData.identifier);
			this.updateTrips();
		});
		updateButtonMiddle(tpData, runData);
		updateButtonRight(tpData, runData);
		updateButtonPause(tpData, runData);
		updatePopupMenu(tpData, runData);

		UI.updateLootGrid(ledger, tpData.lootPanelData, itemManager, config, 0);

		consecutiveRepeatCount = 0;
		previousLedger = ledger;
		previousRunData = runData;
		previousGpPerHour = gpPerHour;

		return true;
	}

	void updateButtonMiddle(TripPanelData tpData, TripData runData)
	{
		UI.clearListeners(tpData.buttonMiddle);
		tpData.buttonMiddle.setEnabled((sessionManager.getActiveSessionEndId() == null) ? !runData.isInProgress()
				: !sessionManager.getActiveSessionEndId().equals(runData.identifier));
		if (runData.isInProgress())
		{
			tpData.buttonMiddle.setText("Continue");
			tpData.buttonMiddle.setToolTipText("Include new trips in the active session.");
			tpData.buttonMiddle.addActionListener((event) ->
			{
				sessionManager.setSessionEnd(null);
				this.updateTrips();
			});
		}
		else
		{
			tpData.buttonMiddle.setText("Set End");
			tpData.buttonMiddle.setToolTipText("Set this trip as the end of the active session.");
			tpData.buttonMiddle.addActionListener((event) ->
			{
				sessionManager.setSessionEnd(runData.identifier);
				this.updateTrips();
			});
		}
	}

	void updateButtonRight(TripPanelData tpData, TripData runData)
	{
		UI.clearListeners(tpData.buttonRight);
		UI.clearListeners(tpData.deleteWrapper);
		tpData.buttonRight.setEnabled(!runData.isInProgress());
		tpData.buttonRight.setText("Delete");
		tpData.buttonRight.setToolTipText("Delete this trip.");
		tpData.buttonRight.addActionListener((event) ->
		{
			int confirm = JOptionPane.showConfirmDialog(this, "Are you sure you want to delete this trip?", "Warning",
			JOptionPane.OK_CANCEL_OPTION);

			if (confirm == 0)
			{
				sessionManager.deleteTrip(runData.identifier);
				for (java.awt.event.ActionListener listener : tpData.deleteWrapper.getActionListeners())
				{
					listener.actionPerformed(event);
				}
				this.updateTrips();
			}
		});
	}

	void updateButtonPause(TripPanelData tpData, TripData runData)
	{
		UI.clearListeners(tpData.pauseButton);
		boolean visible = runData.isInProgress();
		CardLayout cardLayout = (CardLayout) tpData.pauseButtonCardContainer.getLayout();
		cardLayout.show(tpData.pauseButtonCardContainer, visible ? "visible" : "hidden");
		if (visible)
		{
			tpData.pauseButton.setSelected(runData.isPaused);
			tpData.pauseButton.addActionListener((event) ->
			{
				runData.isPaused = tpData.pauseButton.isSelected();
				tpData.pauseButton.setSelected(runData.isPaused);
			});
		}
	}

	void updatePopupMenu(TripPanelData tpData, TripData runData)
	{
		UI.clearListeners(tpData.deleteTripsBeforeMenuItem);
		tpData.deleteTripsBeforeMenuItem.addActionListener((event) ->
		{
			sessionManager.deleteAllTripsBefore(runData.runStartTime);
			this.updateTrips();
		});
	}

	TripPanelData getPanelData(int index)
	{
		ensureTripPanelCount(index + 1);
		//render latest on top
		return tripPanels.get((tripPanels.size() - 1) - index);
	}

	// build out the pool
	void ensureTripPanelCount(int size)
	{
		while (tripPanels.size() < size)
		{
			constraints.gridy = tripPanels.size();
			TripPanelData data = buildTripPanel();
			this.tripsPanel.add(data.masterPanel, constraints);
			tripPanels.add(data);
		}
	}

	TripStats getTripStats(List<LedgerItem> ledger)
	{
		long gains = 0;
		long losses = 0;
		for (LedgerItem item : ledger)
		{
			long value = item.getCombinedValue();
			if (value > 0)
			{
				gains += value;
			} else
			{
				losses += value;
			}
		}
		long net = gains + losses;
		return new TripStats(gains, losses, net);
	}

	private class TripPanelData
	{
		// PluginErrorPanel titlePanel = new PluginErrorPanel();
		JLabel durationLabel = new JLabel("1:00:44");
		JLabel titleLabel = new JLabel("Trip X");
		JLabel subtitleLabel = new JLabel("Started X ago");
		JToggleButton pauseButton = new JToggleButton();
		JPanel pauseButtonCardContainer = new JPanel(new CardLayout());
		JMenuItem deleteTripsBeforeMenuItem = new JMenuItem("Delete Trips Below");

		JToggleButton lootHeaderButtonPanel = new JToggleButton();
		JLabel topLeftLabel = new JLabel(htmlLabel("Net Total: ", "N/A"));
		JLabel bottomLeftLabel = new JLabel(htmlLabel("GP/hr: ", "N/A"));
		JLabel topRightLabel = new JLabel(htmlLabel("Gains: ", "N/A"));
		JLabel bottomRightLabel = new JLabel(htmlLabel("Losses: ", "N/A"));
		JPanel masterPanel = new JPanel();
		JButton buttonLeft = new JButton("Left");
		JButton buttonMiddle = new JButton("Middle");
		JButton buttonRight = new JButton("Right");
		JPanel contentPanel = new JPanel();
		UI.LootPanelData lootPanelData = new UI.LootPanelData();
		//use this as our 'delete all' observer since it's a pain to do it in java
		JButton deleteWrapper = new JButton();

		void setContentPanelBorder(Color color)
		{
			if (color == null)
			{
				color = borderColor;
			}
			contentPanel.setBorder(new MatteBorder(1, 1, 1, 1, color));
		}
	}

	private TripPanelData buildTripPanel()
	{
		TripPanelData data = new TripPanelData();
		JToggleButton lootHeaderButtonPanel = data.lootHeaderButtonPanel;
		JToggleButton pauseButton = data.pauseButton;
		JLabel bottomLeftLabel = data.bottomLeftLabel;
		JLabel topLeftLabel = data.topLeftLabel;
		JLabel bottomRightLabel = data.bottomRightLabel;
		JLabel topRightLabel = data.topRightLabel;
		JPanel masterPanel = data.masterPanel;
		JButton buttonLeft = data.buttonLeft;
		JButton buttonMiddle = data.buttonMiddle;
		JButton buttonRight = data.buttonRight;
		JPanel contentPanel = data.contentPanel;
		JPanel lootPanel = data.lootPanelData.lootPanel;
		JPanel cardContainer = data.pauseButtonCardContainer;

		data.titleLabel.setForeground(Color.WHITE);
		data.titleLabel.setHorizontalAlignment(SwingConstants.CENTER);

		data.subtitleLabel.setFont(FontManager.getRunescapeSmallFont());
		data.subtitleLabel.setForeground(Color.GRAY);
		data.subtitleLabel.setHorizontalAlignment(SwingConstants.CENTER);

		//use card container so parent layout doesn't change when we hide it
		cardContainer.setOpaque(false);
		cardContainer.add(pauseButton, "visible");
		JPanel hiddenPanel = new JPanel();
		hiddenPanel.setOpaque(false);
		cardContainer.add(hiddenPanel, "hidden");

		JPanel titlePanel = new JPanel();
		titlePanel.setOpaque(false);
		titlePanel.setLayout(new BorderLayout());
		titlePanel.add(data.durationLabel, BorderLayout.WEST);
		titlePanel.add(data.titleLabel, BorderLayout.CENTER);
		titlePanel.add(cardContainer, BorderLayout.EAST);
		
		JPanel headerPanel = new JPanel();
		headerPanel.setOpaque(false);
		headerPanel.setLayout(new BorderLayout(0,5));
		headerPanel.setBorder(new EmptyBorder(10, 10, 3, 10));
		headerPanel.add(titlePanel, BorderLayout.NORTH);
		headerPanel.add(data.subtitleLabel, BorderLayout.CENTER);

		final JPopupMenu popupMenu = new JPopupMenu();
		popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
		popupMenu.add(data.deleteTripsBeforeMenuItem);
		headerPanel.setComponentPopupMenu(popupMenu);

		masterPanel.setLayout(new BorderLayout());
		masterPanel.setBorder(new EmptyBorder(5, 0, 0, 0));

		JPanel bottomInfo = new JPanel();
		JPanel topInfo = new JPanel();

		lootHeaderButtonPanel.setLayout(new GridLayout(2, 0, 0, 0));
		bottomInfo.setLayout(new GridLayout(0, 2, 0, 0));
		topInfo.setLayout(new BorderLayout());

		lootHeaderButtonPanel.setPreferredSize(new Dimension(200, 35));

		lootHeaderButtonPanel.setBorder(new EmptyBorder(4, 5, 0, 5));

		pauseButton.setIcon(UI.PAUSE_ICON);
		pauseButton.setSelectedIcon(UI.PLAY_ICON);
		pauseButton.setToolTipText("Pause time tracking for this trip.");
		pauseButton.setPreferredSize(new Dimension(20, 20));
		SwingUtil.removeButtonDecorations(pauseButton);

		bottomLeftLabel.setFont(FontManager.getRunescapeSmallFont());
		topLeftLabel.setFont(FontManager.getRunescapeSmallFont());
		bottomRightLabel.setFont(FontManager.getRunescapeSmallFont());
		topRightLabel.setFont(FontManager.getRunescapeSmallFont());

		SwingUtil.removeButtonDecorations(lootHeaderButtonPanel);
		lootHeaderButtonPanel.setRolloverEnabled(false);

		// lootHeaderButtonPanel.addActionListener(e -> collapseLoot());

		topLeftLabel.setForeground(Color.WHITE);

		topInfo.setBorder(new EmptyBorder(0, 0, 0, 0));

		topInfo.add(topLeftLabel, "West");

		topRightLabel.setBorder(new EmptyBorder(0, 48, 0, 0));

		topInfo.add(topRightLabel, "Center");
		bottomInfo.add(bottomLeftLabel);
		bottomInfo.add(bottomRightLabel);
		topInfo.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		bottomInfo.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		lootHeaderButtonPanel.add(topInfo, "North");
		lootHeaderButtonPanel.add(bottomInfo, "South");

		float fontSize = 16f;
		EmptyBorder buttonBorder = new EmptyBorder(2, 2, 2, 2);
		JPanel buttonPanel = new JPanel();
		buttonPanel.setLayout(new GridLayout(0, 3, 0, 0));
		buttonLeft.setBorder(buttonBorder);
		buttonLeft.setFont(buttonLeft.getFont().deriveFont(fontSize));
		buttonPanel.add(buttonLeft);
		buttonMiddle.setFont(buttonMiddle.getFont().deriveFont(fontSize));
		buttonMiddle.setBorder(buttonBorder);
		buttonPanel.add(buttonMiddle);
		buttonRight.setFont(buttonRight.getFont().deriveFont(fontSize));
		buttonPanel.add(buttonRight);
		buttonPanel.setPreferredSize(new Dimension(0, 30));

		lootPanel.setLayout(new BorderLayout());

		JPanel topPanel = new JPanel();
		topPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		topPanel.setLayout(new BorderLayout());
		topPanel.add(headerPanel, BorderLayout.NORTH);
		topPanel.add(lootHeaderButtonPanel, BorderLayout.SOUTH);

		contentPanel.setLayout(new BorderLayout());
		contentPanel.add(topPanel, BorderLayout.NORTH);
		contentPanel.add(lootPanel, BorderLayout.CENTER);
		contentPanel.add(buttonPanel, BorderLayout.SOUTH);
		contentPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		data.setContentPanelBorder(null);

		masterPanel.add(contentPanel, "North");

		return data;
	}

	static String htmlLabel(String key, String valueStr)
	{
		return String.format(HTML_LABEL_TEMPLATE, ColorUtil.toHexColor(ColorScheme.LIGHT_GRAY_COLOR), key, valueStr);
	}

	@RequiredArgsConstructor
	@Data
	private class TripStats
	{
		private final long totalGains;
		private final long totalLosses;
		private final long netTotal;
	}
}
/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, Eric Versteeg <https://github.com/erversteeg>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;

import javax.inject.Inject;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

@Slf4j
//Renders the overlay for your current trip above the inventory.
class ActiveTripOverlay extends Overlay
{
	private static final int TEXT_Y_OFFSET = 17;
	private static final int HORIZONTAL_PADDING = 10;
	private static final int imageSize = 15;
	static final int COINS = ItemID.COINS;

	private final Client client;
	private final GPPerHourPlugin plugin;
	private final GPPerHourConfig config;

	private final ItemManager itemManager;
	private final SpriteManager spriteManager;

	private long lastGpPerHour;
	private long lastGpPerHourUpdateTime;

	private BufferedImage redXImage;

	private boolean hasLoadedCoinsImages;
    private BufferedImage coinsImage100;
    private BufferedImage coinsImage250;
    private BufferedImage coinsImage1000;
    private BufferedImage coinsImage10000;
	private InventoryWidgetData lastWidgetData;

	@Data
	private class InventoryWidgetData
	{
		public net.runelite.api.Point canvasLocation;
		public int width;
		public int height;
	}

	@RequiredArgsConstructor
	class LedgerEntry
	{
		final String leftText;
		final Color leftColor;
		final String rightText;
		final Color rightColor;
		final boolean addGapBefore;
		boolean center;
		boolean addGapAfter;
	}
	
    @AllArgsConstructor
    public enum InventoryOverlayDisplayMode {
        TRIP_GP_PER_HOUR                    ("Trip GP/hr", false),
        TRIP_PROFIT              			("Trip Profit", false),
        SESSION_GP_PER_HOUR              	("Session GP/hr", true),
        SESSION_PROFIT              		("Session Profit", true),
        INVENTORY_TOTAL              		("Inventory Value", false);
    
        private final String configName;
        private final boolean sessionData;
        @Override
        public String toString() { return configName; }
    }

	@Inject
	private ActiveTripOverlay(Client client, GPPerHourPlugin plugin, GPPerHourConfig config, ItemManager itemManager, SpriteManager spriteManager)
	{
		super(plugin);
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);

		this.client = client;
		this.plugin = plugin;
		this.config = config;

		this.itemManager = itemManager;
		this.spriteManager = spriteManager;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.getRunData() == null)
			return null;

		Widget inventoryWidget = plugin.getInventoryWidget();
		boolean isInvHidden = inventoryWidget == null || inventoryWidget.isHidden();
		if (isInvHidden && (!config.alwaysShowTripOverlay() || lastWidgetData == null))
			return null;
		
		if (!isInvHidden)
		{
			if	(lastWidgetData == null)
				lastWidgetData = new InventoryWidgetData();
			
			lastWidgetData.canvasLocation = inventoryWidget.getCanvasLocation();
			lastWidgetData.width = inventoryWidget.getWidth();
			lastWidgetData.height = inventoryWidget.getHeight();
		}

		if (config.inventoryOverlayDisplayMode().sessionData)
		{
			renderActiveSessionTotal(graphics);
		}
		else
		{
			renderActiveTripTotal(graphics);
		}

		return null;
	}

	final int totalOverlayHeight = 20;

	private void renderActiveSessionTotal(Graphics2D graphics)
	{
		SessionStats sessionStats = plugin.getSessionManager().getActiveSessionStats();
		if (sessionStats == null)
		{
			String totalText = "0";
			if (config.inventoryOverlayDisplayMode() == InventoryOverlayDisplayMode.SESSION_GP_PER_HOUR)
				totalText += "/hr";
			renderTotal(config, graphics, plugin,
					0, totalText, null, totalOverlayHeight);
			return;
		}
		long total = sessionStats.getNetTotal();
		String totalText = UI.formatGp(total, config.showExactGp());

		if (config.inventoryOverlayDisplayMode() == InventoryOverlayDisplayMode.SESSION_GP_PER_HOUR)
		{
			total = getGpPerHour(sessionStats.getSessionRuntime(), total);
			totalText = UI.formatGp(total, config.showExactGp()) + "/hr";
		}

		String formattedRunTime = config.showRunTime() ? UI.formatTime(sessionStats.getSessionRuntime()) : null;
		String runTimeText = null;

		if (formattedRunTime != null)
		{
			runTimeText = " (" + formattedRunTime + ")";
		}

		renderTotal(config, graphics, plugin,
				total, totalText, runTimeText, totalOverlayHeight);
	}

	private void renderActiveTripTotal(Graphics2D graphics)
	{
		long total = plugin.getProfitGp();
		String totalText = UI.formatGp(total, config.showExactGp());

		if (config.inventoryOverlayDisplayMode() == InventoryOverlayDisplayMode.TRIP_GP_PER_HOUR
			 && plugin.getState() == RunState.RUN
			 && !plugin.getRunData().isBankDelay)
		{
			total = getGpPerHour(plugin.elapsedRunTime(), total);
			totalText = UI.formatGp(total, config.showExactGp()) + "/hr";
		}

		String formattedRunTime = getFormattedRunTime();
		String runTimeText = null;

		if (formattedRunTime != null)
		{
			runTimeText = " (" + formattedRunTime + ")";
		}

		if (plugin.getRunData().isBankDelay)
		{
			total = 0;
			
			if (config.inventoryOverlayDisplayMode() == InventoryOverlayDisplayMode.TRIP_GP_PER_HOUR)
				totalText = "0/hr";
			else if (config.inventoryOverlayDisplayMode() == InventoryOverlayDisplayMode.TRIP_PROFIT)
				totalText = "0";
			else
				totalText = UI.formatGp(plugin.getTotalGp(), config.showExactGp());
		}

		renderTotal(config, graphics, plugin,
				total, totalText, runTimeText, totalOverlayHeight);
	}



	private boolean needsCheck()
	{
		return plugin.getChargeableItemsNeedingCheck().size() != 0;
	}


    private void loadCoinsImages()
    {
        coinsImage100 = loadCoinsImage(100);
        coinsImage250 = loadCoinsImage(250);
        coinsImage1000 = loadCoinsImage(1000);
        coinsImage10000 = loadCoinsImage(10000);
		hasLoadedCoinsImages = true;
    }

    private BufferedImage loadCoinsImage(int quantity)
    {
		BufferedImage image = itemManager.getImage(ItemID.COINS, quantity, false);
		image = ImageUtil.resizeImage(image, imageSize, imageSize);
		return image;
    }

	private BufferedImage getCoinsImage(int quantity)
	{
		if(!hasLoadedCoinsImages)
			loadCoinsImages();

		long absValue = Math.abs(quantity);
		if (absValue >= 10000)
		{
			return coinsImage10000;
		}
		else if (absValue >= 1000)
		{
			return coinsImage1000;
		}
		else if (absValue >= 250)
		{
			return coinsImage250;
		}
		else
		{
			return coinsImage100;
		}
	}

	private BufferedImage getRedXImage()
	{
		if (redXImage == null)
		{
			redXImage = spriteManager.getSprite(SpriteID.WarningIcons.DISABLED, 0);
			redXImage = ImageUtil.resizeImage(redXImage, imageSize, imageSize);
		}
		return redXImage;
	}

	private void renderTotal(GPPerHourConfig config, Graphics2D graphics, GPPerHourPlugin plugin,
							 long total, String totalText,
							 String runTimeText, int height) {
		
		boolean showCoinStack = config.showCoinStack();
		boolean showCheckIcon = needsCheck();
		int numCoins;
		if (total > Integer.MAX_VALUE)
		{
			numCoins = Integer.MAX_VALUE;
		}
		else if (total < Integer.MIN_VALUE)
		{
			numCoins = Integer.MIN_VALUE;
		}
		else
		{
			numCoins = (int) total;
			if (numCoins == 0)
			{
				numCoins = 1000000;
			}
		}
		numCoins = Math.abs(numCoins);

		if ((total == 0 && !config.showOnEmpty()) || (plugin.getState() == RunState.BANK && !config.showWhileBanking())) {
			return;
		}

		graphics.setFont(FontManager.getRunescapeSmallFont());
		final int totalWidth = graphics.getFontMetrics().stringWidth(totalText);

		int fixedRunTimeWidth = 0;
		int actualRunTimeWidth = 0;
		int imageWidthWithPadding = 0;

		if (runTimeText != null && runTimeText.length() >= 2) {
			fixedRunTimeWidth = 5 * (runTimeText.length() - 2) + (3 * 2) + 5;
			actualRunTimeWidth = graphics.getFontMetrics().stringWidth(runTimeText);
		}

		if (showCoinStack)
		{
			imageWidthWithPadding = imageSize + 3;
		}
		if (showCheckIcon)
		{
			imageWidthWithPadding += imageSize + 3;
		}

		int width = totalWidth + fixedRunTimeWidth + imageWidthWithPadding + HORIZONTAL_PADDING * 2;

		int x = (lastWidgetData.getCanvasLocation().getX() + lastWidgetData.getWidth() / 2) - (width / 2);
		switch (config.horizontalAlignment())
		{
			case CENTER:
				break;

			case LEFT:
				x = lastWidgetData.getCanvasLocation().getX();
				break;

			case RIGHT:
				x = lastWidgetData.getCanvasLocation().getX() + lastWidgetData.getWidth() - width;
				break;
		}

		int xOffset = config.inventoryXOffset();
		if (config.isInventoryXOffsetNegative())
		{
			xOffset *= -1;
		}
		x += xOffset;

		int yOffset = config.inventoryYOffset();
		if (config.isInventoryYOffsetNegative())
		{
			yOffset *= -1;
		}
		int y = lastWidgetData.getCanvasLocation().getY() - height - yOffset;

		Color backgroundColor;
		Color borderColor;
		Color textColor;

		if (plugin.getState() == RunState.BANK || config.inventoryOverlayDisplayMode() == InventoryOverlayDisplayMode.INVENTORY_TOTAL) {
			backgroundColor = config.totalColor();
			borderColor = config.borderColor();
			textColor = config.textColor();
		}
		else if (total >= 0) {
			backgroundColor = config.profitColor();
			borderColor = config.profitBorderColor();
			textColor = config.profitTextColor();
		}
		else {
			backgroundColor = config.lossColor();
			borderColor = config.lossBorderColor();
			textColor = config.lossTextColor();
		}

		int cornerRadius = config.cornerRadius();
		if (!config.roundCorners())
		{
			cornerRadius = 0;
		}

		int containerAlpha = backgroundColor.getAlpha();

		if (containerAlpha > 0) {
			graphics.setColor(borderColor);
			graphics.drawRoundRect(x, y, width + 1, height + 1, cornerRadius, cornerRadius);
		}

		graphics.setColor(backgroundColor);

		graphics.fillRoundRect(x + 1, y + 1, width, height, cornerRadius, cornerRadius);

		TextComponent textComponent = new TextComponent();

		textComponent.setColor(textColor);
		textComponent.setText(totalText);
		textComponent.setPosition(new Point(x + HORIZONTAL_PADDING, y + TEXT_Y_OFFSET));
		textComponent.render(graphics);

		if (runTimeText != null)
		{
			textComponent = new TextComponent();

			textComponent.setColor(textColor);
			textComponent.setText(runTimeText);
			textComponent.setPosition(new Point((x + width) - HORIZONTAL_PADDING - actualRunTimeWidth - imageWidthWithPadding, y + TEXT_Y_OFFSET));
			textComponent.render(graphics);
		}

		if (showCoinStack)
		{
			int imageOffset = 4;
			if (showCheckIcon)
				imageOffset -= imageWidthWithPadding / 2;

			BufferedImage image = getCoinsImage(numCoins / 100);//divide by 100 to get more variation in coins image
			graphics.drawImage(image, (x + width) - HORIZONTAL_PADDING - imageSize + imageOffset, y + 3, null);
		}

		if (showCheckIcon)
		{
			int imageOffset = 4;

			BufferedImage redXImage = getRedXImage();
			graphics.drawImage(redXImage, (x + width) - HORIZONTAL_PADDING - imageSize + imageOffset, y + 3, null);
		}

		net.runelite.api.Point mouse = client.getMouseCanvasPosition();
		int mouseX = mouse.getX();
		int mouseY = mouse.getY();

		boolean isTripRunning = !config.inventoryOverlayDisplayMode().sessionData && plugin.getState() != RunState.BANK && !plugin.getRunData().isBankDelay;
		boolean isSessionRunning = config.inventoryOverlayDisplayMode().sessionData && plugin.getSessionManager().getActiveSessionStats() != null;

		RoundRectangle2D roundRectangle2D = new RoundRectangle2D.Double(x, y, width + 1, height + 1, cornerRadius, cornerRadius);
		if (roundRectangle2D.contains(mouseX, mouseY) && (isTripRunning || isSessionRunning) && config.showLedgerOnHover())
		{
			if (config.inventoryOverlayDisplayMode() == InventoryOverlayDisplayMode.INVENTORY_TOTAL)
			{
				renderLedger(graphics);
			}
			else
			{
				renderProfitLossLedger(graphics);
			}
		}
	}

	private void renderLedger(Graphics2D graphics)
	{
		FontMetrics fontMetrics = graphics.getFontMetrics();

		java.util.List<LedgerItem> ledger = plugin.getInventoryLedger().stream()
				.filter(item -> item.getQty() > (GPPerHourPlugin.roundAmount/2f)).collect(Collectors.toList());

		LinkedList<LedgerEntry> ledgerEntries = new LinkedList<>();
		ledgerEntries.add(createTitleEntry(false));
		if (ledger.isEmpty())
		{
			ledgerEntries.add(createEmptyEntry());
		}
		else
		{
			ledger = ledger.stream().sorted(Comparator.comparingLong(o ->
					-o.getCombinedValue())
			).collect(Collectors.toList());

			String [] descriptions = ledger.stream().map(item -> {
				String desc = item.getDescription();
				if (item.getQty() != 0 && Math.abs(item.getQty()) != 1 && !item.getDescription().contains("Coins"))
				{
					desc = UI.formatQuantity(item.getQty(), true) + " " + desc;
				}
				return desc;
			}).toArray(String[]::new);
			Long [] prices = ledger.stream().map(item -> item.getCombinedValue()).toArray(Long[]::new);

			if (descriptions.length == prices.length)
			{
				for (int i = 0; i < descriptions.length; i++)
				{
					String desc = descriptions[i];
					long price = prices[i];
					String rightText = formatNumber(price);
					Color leftColor = Color.decode("#FFF7E3");
					Color rightColor = price > 0 ? Color.GREEN : Color.WHITE;
					ledgerEntries.add(new LedgerEntry(desc, leftColor, rightText, rightColor, false));
				}
			}
			long total = ledger.stream().mapToLong(item -> item.getCombinedValue()).sum();
			ledgerEntries.add(new LedgerEntry("Total", Color.ORANGE, formatNumber(total), priceToColor(total), true));
		}
		boolean firstCharge = true;
		for (String itemName : plugin.getChargeableItemsNeedingCheck())
		{
			ledgerEntries.add(new LedgerEntry("Check " + itemName + " to calibrate.", Color.RED, "", Color.WHITE, firstCharge));
			firstCharge = false;
		}

		int maxRowW = 0;
		int sectionPadding = 5;
		int sectionPaddingTotal = 0;
		for(LedgerEntry entry : ledgerEntries)
		{
			int width = fontMetrics.stringWidth(entry.leftText) + fontMetrics.stringWidth(entry.rightText);
			if (width > maxRowW)
				maxRowW = width;
			if (entry.addGapBefore)
				sectionPaddingTotal += sectionPadding;
			if (entry.addGapAfter)
				sectionPaddingTotal += sectionPadding;
		}

		net.runelite.api.Point mouse = client.getMouseCanvasPosition();
		int mouseX = mouse.getX();
		int mouseY = mouse.getY();


		int rowW = maxRowW + 20 + HORIZONTAL_PADDING * 2;
		int rowH = fontMetrics.getHeight();

		int h = ledgerEntries.size() * rowH + TEXT_Y_OFFSET / 2 + sectionPaddingTotal + 2;

		int x = mouseX - rowW - 10;
		int y = mouseY - h / 2;

		int cornerRadius = 0;

		graphics.setColor(Color.decode("#1b1b1b"));
		graphics.fillRoundRect(x, y, rowW, h, cornerRadius, cornerRadius);

		int borderWidth = 1;

		graphics.setColor(Color.decode("#0b0b0b"));
		graphics.setStroke(new BasicStroke(borderWidth));
		graphics.drawRoundRect(x - borderWidth / 2, y - borderWidth / 2,
				rowW + borderWidth / 2, h + borderWidth / 2, cornerRadius, cornerRadius);

		renderLedgerEntries(ledgerEntries, x, y, rowW, rowH, sectionPadding, graphics);
	}

	private LedgerEntry createTitleEntry(boolean isSessionStats)
	{
		LedgerEntry titleEntry = new LedgerEntry(isSessionStats ? "Active Session Summary" : "Active Trip Summary", Color.WHITE, "", Color.WHITE, false);
		titleEntry.addGapAfter = true;
		titleEntry.center = true;
		return titleEntry;
	}

	private LedgerEntry createEmptyEntry()
	{
		LedgerEntry emptyEntry = new LedgerEntry("Ledger items will appear here.", Color.WHITE, "", Color.WHITE, false);
		return emptyEntry;
	}

	private void renderProfitLossLedger(Graphics2D graphics)
	{
		FontMetrics fontMetrics = graphics.getFontMetrics();

		List<LedgerItem> ledger = null;
		if (config.inventoryOverlayDisplayMode().sessionData)
		{
			SessionStats stats = plugin.getSessionManager().getActiveSessionStats();
			ledger = GPPerHourPlugin.getProfitLossLedger(stats.getInitialQtys(), stats.getQtys());
		}
		else
		{
			ledger = GPPerHourPlugin.getProfitLossLedger(plugin.getRunData().initialItemQtys, plugin.getRunData().itemQtys);
		}

		List<LedgerItem> gain = ledger.stream().filter(item -> item.getQty() > 0)
				.collect(Collectors.toList());

		List<LedgerItem> loss = ledger.stream().filter(item -> item.getQty() < 0)
				.collect(Collectors.toList());

		gain = gain.stream().sorted(Comparator.comparingLong(o -> -o.getCombinedValue())).collect(Collectors.toList());
		loss = loss.stream().sorted(Comparator.comparingLong(o -> -o.getCombinedValue())).collect(Collectors.toList());

		ledger = new LinkedList<>();
		ledger.addAll(gain);
		ledger.addAll(loss);

		LinkedList<LedgerEntry> ledgerEntries = new LinkedList<>();
		ledgerEntries.add(createTitleEntry(config.inventoryOverlayDisplayMode().sessionData));

		if (ledger.isEmpty())
		{
			ledgerEntries.add(createEmptyEntry());
		}
		else
		{
			String [] descriptions = ledger.stream().map(item -> {
				String desc = item.getDescription();
				if (item.getQty() != 0 && Math.abs(item.getQty()) != 1 && !item.getDescription().contains("Coins"))
				{
					desc = UI.formatQuantity(item.getQty(), true) + " " + desc;
				}
				return desc;
			}).toArray(String[]::new);
			Long [] prices = ledger.stream().map(item -> item.getCombinedValue()).toArray(Long[]::new);
	
			if (descriptions.length == prices.length)
			{
				String prevDesc = "";
				for (int i = 0; i < descriptions.length; i++)
				{
					Color leftColor = Color.decode("#FFF7E3");
					Color rightColor = Color.WHITE;
					boolean addGap = false;
					String desc = descriptions[i];
	
					if (i > 0 && prices[i - 1] >= 0 && prices[i] < 0 && !prevDesc.contains("Total"))
					{
						addGap = true;
					}
	
					prevDesc = desc;
	
					long price = prices[i];
					String formattedPrice = formatNumber(price);
					rightColor = priceToColor(price);
	
					ledgerEntries.add(new LedgerEntry(desc, leftColor, formattedPrice, rightColor, addGap));
				}
			}
	
			long totalGain = gain.stream().mapToLong(item ->  item.getCombinedValue()).sum();
			long totalLoss = loss.stream().mapToLong(item ->  item.getCombinedValue()).sum();
			long netTotal = ledger.stream().mapToLong(item -> item.getCombinedValue()).sum();
			ledgerEntries.add(new LedgerEntry("Total Gain", Color.YELLOW, formatNumber(totalGain), priceToColor(totalGain), true));
			ledgerEntries.add(new LedgerEntry("Total Loss", Color.YELLOW, formatNumber(totalLoss), priceToColor(totalLoss), false));
			ledgerEntries.add(new LedgerEntry("Net Total", Color.ORANGE, formatNumber(netTotal), priceToColor(netTotal), false));
	
			long runTime = plugin.elapsedRunTime();
			if (runTime != GPPerHourPlugin.NO_PROFIT_LOSS_TIME)
			{
				long gpPerHour = getGpPerHour(runTime, netTotal);
				String gpPerHourString = UI.formatGp(gpPerHour, config.showExactGp());
				ledgerEntries.add(new LedgerEntry("GP/hr", Color.ORANGE, gpPerHourString, priceToColor(gpPerHour), false));
			}
		}

		boolean firstCharge = true;
		for (String itemName : plugin.getChargeableItemsNeedingCheck())
		{
			ledgerEntries.add(new LedgerEntry("Check " + itemName + " to calibrate.", Color.RED, "", Color.WHITE, firstCharge));
			firstCharge = false;
		}

		int maxRowW = 0;
		int sectionPadding = 5;
		int sectionPaddingTotal = 0;
		for (LedgerEntry entry : ledgerEntries)
		{
			int width = fontMetrics.stringWidth(entry.leftText) + fontMetrics.stringWidth(entry.rightText);
			if (width > maxRowW)
				maxRowW = width;
			if (entry.addGapBefore)
				sectionPaddingTotal += sectionPadding;
			if (entry.addGapAfter)
				sectionPaddingTotal += sectionPadding;
		}

		net.runelite.api.Point mouse = client.getMouseCanvasPosition();
		int mouseX = mouse.getX();
		int mouseY = mouse.getY();

		int rowW = maxRowW + 20 + HORIZONTAL_PADDING * 2;
		int rowH = fontMetrics.getHeight();

		int h = ledgerEntries.size() * rowH + TEXT_Y_OFFSET / 2 + sectionPaddingTotal + 2;
		
		int x = mouseX - rowW - 10;
		int y = mouseY - h / 2;

		int cornerRadius = 0;

		graphics.setColor(Color.decode("#1b1b1b"));
		graphics.fillRoundRect(x, y, rowW, h, cornerRadius, cornerRadius);

		int borderWidth = 1;

		graphics.setColor(Color.decode("#0b0b0b"));
		graphics.setStroke(new BasicStroke(borderWidth));
		graphics.drawRoundRect(x - borderWidth / 2, y - borderWidth / 2,
				rowW + borderWidth / 2, h + borderWidth / 2, cornerRadius, cornerRadius);

		renderLedgerEntries(ledgerEntries, x, y, rowW, rowH, sectionPadding, graphics);
	}

	long getGpPerHour(long runTime, long total)
	{
		//dont want to update too often
		long timeNow = Instant.now().toEpochMilli();
		if (timeNow - lastGpPerHourUpdateTime < 1000)
		{
			return lastGpPerHour;
		}

		lastGpPerHourUpdateTime = timeNow;
		lastGpPerHour = UI.getGpPerHour(runTime, total);
		return lastGpPerHour;
	}

	String formatNumber(long number)
	{
		return QuantityFormatter.formatNumber(number);
	}

	Color priceToColor(long price)
	{
		if (price > 0)
		{
			return Color.GREEN;
		}
		else if (price < 0)
		{
			return Color.RED;
		}
		else
		{
			return Color.WHITE;
		}
	}

	private void renderLedgerEntries(LinkedList<LedgerEntry> ledgerEntries, int x, int y, int rowW, int rowH, int sectionPadding, Graphics2D graphics)
	{
		FontMetrics fontMetrics = graphics.getFontMetrics();
		int yPosition = TEXT_Y_OFFSET;
		for (LedgerEntry ledgerEntry: ledgerEntries)
		{
			if (ledgerEntry.addGapBefore)
				yPosition += sectionPadding;

			//only renders left text
			if (ledgerEntry.center)
			{
				String leftText = ledgerEntry.leftText;
				int textW = fontMetrics.stringWidth(leftText);
				int textX = x + rowW/2 - textW/2;
				int textY = y + yPosition;

				TextComponent textComponent = new TextComponent();
				textComponent.setColor(ledgerEntry.leftColor);
				textComponent.setText(leftText);
				textComponent.setPosition(new Point(textX, textY));
				textComponent.render(graphics);
			}
			else
			{
				int textX = x + HORIZONTAL_PADDING;
				int textY = y + yPosition;
	
				TextComponent textComponent = new TextComponent();
				textComponent.setColor(ledgerEntry.leftColor);
				textComponent.setText(ledgerEntry.leftText);
				textComponent.setPosition(new Point(textX, textY));
				textComponent.render(graphics);
				
				String rightText = ledgerEntry.rightText;
				int textW = fontMetrics.stringWidth(rightText);
				textX = x + rowW - HORIZONTAL_PADDING - textW;
	
				textComponent = new TextComponent();
				textComponent.setColor(ledgerEntry.rightColor);
				textComponent.setText(rightText);
				textComponent.setPosition(new Point(textX, textY));
				textComponent.render(graphics);
			}


			yPosition += rowH;

			if (ledgerEntry.addGapAfter)
				yPosition += sectionPadding;
		}
	}

	private String getFormattedRunTime()
	{
		if (!config.showRunTime())
			return null;

		long runTime = plugin.elapsedRunTime();

		if (runTime == GPPerHourPlugin.NO_PROFIT_LOSS_TIME)
		{
			return null;
		}

		return UI.formatTime(runTime);
	}
}

/*
 * Copyright (c) 2023, geheur <https://github.com/geheur>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.weaponcharges;

import com.google.inject.Inject;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import javax.annotation.Nullable;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.VarClientStr;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.KeyListener;
import net.runelite.client.util.Text;

// Things to test: clicks and keystrokes for click here to continue in NPC, PLAYER, SPRITE, and NPC DIALOG OPTIONS
// (all 5 options!).

/**
 * need to register it to the eventbus and keymanager for it to work.
 *
 * Not working: meslayer (I'm assuming, cause I don't know what meslayer actually is), sprite (partial).
 * double sprite dialog (e.g. removing fang from swamp trident).
 */
@Slf4j
public class DialogTracker implements KeyListener
{
	private static final int COMPONENT_ID_DIALOG_PLAYER_CLICK_HERE_TO_CONTINUE = 5;
	private static final int COMPONENT_ID_DIALOG_NPC_CLICK_HERE_TO_CONTINUE = 5;
	private static final int COMPONENT_ID_DIALOG_PLAYER_NAME = 4;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	private Consumer<DialogState> dialogStateChanged;
	private BiConsumer<DialogState, String> dialogOptionSelected;

	private DialogState lastDialogState = null;

	public void setStateChangedListener(Consumer<DialogState> listener) {
		dialogStateChanged = listener;
	}

	public void setOptionSelectedListener(BiConsumer<DialogState, String> listener) {
		dialogOptionSelected = listener;
	}

	/*
    It's possible to miss a click but I've only seen then when I'm moving the mouse as fast as I possibly can.
     */
	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		int widgetId = event.getParam1();
		int interfaceId = WidgetUtil.componentToInterface(widgetId);
		int componentId = WidgetUtil.componentToId(widgetId);
		if (widgetId == InterfaceID.Chatmenu.OPTIONS) {
			Widget widget = client.getWidget(InterfaceID.Chatmenu.OPTIONS);
			int dynamicChildIndex = event.getParam0();
			Widget[] dynamicChildren = widget.getDynamicChildren();
			Widget dynamicChild = dynamicChildren[dynamicChildIndex];
			if (dynamicChild == null)
			{
				log.debug("dynamic child option was null, index " + dynamicChildIndex + " total children: " + dynamicChildren.length);
				return; // not sure why this would happen.
			}
			optionSelected(lastDialogState, dynamicChild.getText());
		} else if (interfaceId == InterfaceID.CHAT_LEFT && componentId == COMPONENT_ID_DIALOG_NPC_CLICK_HERE_TO_CONTINUE) {
			optionSelected(lastDialogState, null);
		} else if (interfaceId == InterfaceID.CHAT_RIGHT && componentId == COMPONENT_ID_DIALOG_PLAYER_CLICK_HERE_TO_CONTINUE) {
			optionSelected(lastDialogState, null);
		} else if (interfaceId == InterfaceID.OBJECTBOX && componentId == 0) {
			optionSelected(lastDialogState, null);
		}
	}

	public DialogState getDialogState() {
		DialogState.DialogType type = getDialogType();

		DialogState state;
		switch (type) {
			case NPC:
			{
				Widget nameWidget = client.getWidget(InterfaceID.ChatLeft.NAME);
				Widget textWidget = client.getWidget(InterfaceID.ChatLeft.TEXT);

				String name = (nameWidget != null) ? nameWidget.getText() : null;
				String text = (textWidget != null) ? textWidget.getText() : null;

				state = DialogState.npc(name, text);
				break;
			}
			case PLAYER:
			{
				Widget nameWidget = client.getWidget(InterfaceID.CHAT_RIGHT, COMPONENT_ID_DIALOG_PLAYER_NAME);
				Widget textWidget = client.getWidget(InterfaceID.ChatRight.TEXT);

				String name = (nameWidget != null) ? nameWidget.getText() : null;
				String text = (textWidget != null) ? textWidget.getText() : null;

				state = DialogState.player(name, text);
				break;
			}
			case OPTIONS:
			{
				String text = null;

				Widget optionsWidget = client.getWidget(InterfaceID.Chatmenu.OPTIONS);
				List<String> options = null;
				if (optionsWidget != null) {
					options = new ArrayList<>();
					for (Widget child : optionsWidget.getDynamicChildren()) {
						if (child.getText() != null && !child.getText().isEmpty())
						{
							options.add(child.getText());
						}
					}
					text = options.remove(0); // remove "Select an Option".
				}

				state = DialogState.options(text, options);
				break;
			}
			case SPRITE:
			{
				Widget textWidget = client.getWidget(InterfaceID.Objectbox.TEXT);
				String text = (textWidget != null) ? textWidget.getText() : null;

				Widget itemWidget = client.getWidget(InterfaceID.Objectbox.ITEM);
				int itemId = (itemWidget != null) ? itemWidget.getItemId() : -1;

				state = DialogState.sprite(text, itemId);
				break;
			}
			case INPUT:
			{
				Widget titleWidget = client.getWidget(InterfaceID.Chatbox.MES_TEXT);
				String title = (titleWidget != null) ? titleWidget.getText() : null;
				String input = client.getVarcStrValue(VarClientStr.INPUT_TEXT);

				state = DialogState.input(title, input);
				break;
			}
			case NO_DIALOG:
			{
				state = DialogState.noDialog();
				break;
			}
			default:
				throw new IllegalStateException("Unexpected value: " + type);
		}

		return state;
	}

	private DialogState.DialogType getDialogType()
	{
		Widget npcDialog = client.getWidget(InterfaceID.CHAT_LEFT, 0);
		if (npcDialog != null && !npcDialog.isHidden())
		{
			return DialogState.DialogType.NPC;
		}

		Widget playerDialog = client.getWidget(InterfaceID.CHAT_RIGHT, 0);
		if (playerDialog != null && !playerDialog.isHidden())
		{
			return DialogState.DialogType.PLAYER;
		}

		Widget optionsDialog = client.getWidget(InterfaceID.CHATMENU, 0);
		if (optionsDialog != null && !optionsDialog.isHidden())
		{
			return DialogState.DialogType.OPTIONS;
		}

		Widget spriteDialog = client.getWidget(InterfaceID.OBJECTBOX, 0);
		if (spriteDialog != null && !spriteDialog.isHidden())
		{
			return DialogState.DialogType.SPRITE;
		}

		Widget inputDialog = client.getWidget(InterfaceID.Chatbox.MES_TEXT2);
		if (inputDialog != null && !inputDialog.isHidden())
		{
			return DialogState.DialogType.INPUT;
		}

		return DialogState.DialogType.NO_DIALOG;
	}

	@Subscribe
	public void onGameTick(GameTick gameTick) {
//        log.debug("Game tick: {}", client.getTickCount());
		optionSelected = false;

		DialogState dialogState = getDialogState();
		if (!Objects.equals(dialogState, lastDialogState)) {
			log.debug("dialog changed: {} previous: {} (game tick: {})", dialogState, lastDialogState, client.getTickCount());

			if (dialogStateChanged != null) dialogStateChanged.accept(dialogState);
		}
		lastDialogState = dialogState;
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired event)
	{
		if (event.getScriptId() == 2153)
		{
			Widget w = client.getWidget(InterfaceID.Chatmenu.OPTIONS);
			if (w != null && !w.isHidden())
			{
				for (int i = 0; i < w.getDynamicChildren().length; i++)
				{
					Widget dynamicChild = w.getDynamicChildren()[i];
					if ("Please wait...".equals(Text.removeTags(dynamicChild.getText()))) {
						String option = null;
						if (lastDialogState.type == DialogState.DialogType.OPTIONS) {
							if (lastDialogState.options != null) {
								if (lastDialogState.options.size() > i - 1) { // -1 because we skip "Select an Option".
									option = lastDialogState.options.get(i - 1); // -1 because we skip "Select an Option".
								}
							}
						}
						optionSelected(lastDialogState, option);
					}
				}
			}
			w = client.getWidget(InterfaceID.CHAT_LEFT, COMPONENT_ID_DIALOG_NPC_CLICK_HERE_TO_CONTINUE);
			if (w != null && !w.isHidden() && "Please wait...".equals(Text.removeTags(w.getText())))
			{
				optionSelected(lastDialogState, null);
			}
			w = client.getWidget(InterfaceID.CHAT_RIGHT, COMPONENT_ID_DIALOG_PLAYER_CLICK_HERE_TO_CONTINUE);
			if (w != null && !w.isHidden() && "Please wait...".equals(Text.removeTags(w.getText())))
			{
				optionSelected(lastDialogState, null);
			}
		} else if (event.getScriptId() == 2869) {
			Widget w = client.getWidget(InterfaceID.OBJECTBOX, 0);
			if (w != null && !w.isHidden())
			{
				Widget dynamicChild = w.getDynamicChildren()[2];
				if ("Please wait...".equals(Text.removeTags(dynamicChild.getText())))
				{
					optionSelected(lastDialogState, null);
				}
			}
		}
	}

	/**
	 * To prevent multiple selections from occuring in the same game tick. Only the first one should count.
	 */
	private boolean optionSelected = false;

	private void optionSelected(DialogState state, String option) {
		if (optionSelected) return;
		optionSelected = true;
		if (state.type == DialogState.DialogType.OPTIONS) {
			log.debug("option selected: \"" + option + "\" " + state);
		} else {
			log.debug("clicked here to continue: " + state);
		}
		if (dialogOptionSelected != null) dialogOptionSelected.accept(state, option);
	}

	public void reset()
	{
		lastDialogState = null;
	}

	@Override
	public void keyTyped(KeyEvent e)
	{
		// unused.
	}

	@Override
	public void keyPressed(KeyEvent e)
	{
		try
		{
			if (e.getKeyCode() == KeyEvent.VK_ENTER)
			{
				clientThread.invoke(() -> {
					String inputText = client.getVarcStrValue(VarClientStr.INPUT_TEXT);

					if (lastDialogState.type == DialogState.DialogType.INPUT)
					{
						optionSelected(lastDialogState, inputText);
					}
				});
			}
		} catch (RuntimeException ex) {
			// Exceptions thrown from here can prevent other keylisteners from receiving the key event.
			log.error("", ex);
		}
	}

	@Override
	public void keyReleased(KeyEvent e)
	{
		// unused.
	}

	@RequiredArgsConstructor
	public static class DialogState
	{
		enum DialogType
		{
			/**
			 * NO_DIALOG does NOT indicate the end of a dialog. For example you can end a dialog with an npc by doing something like checking a kharedst memoirs, without seeing the NO_DIALOG state inbetween.
			 */
			NO_DIALOG,
			PLAYER,
			NPC,
			OPTIONS,
			SPRITE,
			INPUT,
		}

		@NonNull
		final DialogTracker.DialogState.DialogType type;

		// Meaningful only when type is PLAYER or NPC or INPUT.
		@Nullable
		final String name;

		@Nullable
		final String text;

		@Nullable
		final Integer spriteDialogItemId;

		// Meaningful only when type is OPTIONS
		@Nullable
		final List<String> options;

		public static DialogState sprite(String text, int itemId) {
			return new DialogState(DialogType.SPRITE, null, text, itemId, null);
		}

		public static DialogState player(String name, String text) {
			return new DialogState(DialogType.PLAYER, name, text, null, null);
		}

		public static DialogState npc(String name, String text) {
			return new DialogState(DialogType.NPC, name, text, null, null);
		}

		public static DialogState options(String text, List<String> options) {
			return new DialogState(DialogType.OPTIONS, null, text, null, options);
		}

		public static DialogState options(String text, String... options) {
			return new DialogState(DialogType.OPTIONS, null, text, null, Arrays.asList(options));
		}

		public static DialogState input(String title, String input)
		{
			return new DialogState(DialogType.INPUT, title, input, null, null);
		}

		public static DialogState noDialog() {
			return new DialogState(DialogType.NO_DIALOG, null, null, null, null);
		}

		@Override
		public boolean equals(Object o)
		{
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			DialogState that = (DialogState) o;
			return type == that.type && Objects.equals(text, that.text) && Objects.equals(name, that.name) && Objects.equals(options, that.options);
		}

		@Override
		public int hashCode()
		{
			return Objects.hash(type, text, name, options);
		}

		@Override
		public String toString()
		{
			switch (type) {
				case NO_DIALOG:
					return "DialogState{" + type +
							"}";
				case PLAYER:
				case NPC:
					return "DialogState{" + type +
							", name='" + name + "'" +
							", text='" + text + "'" +
							"}";
				case SPRITE:
					return "DialogState{" + type +
							", text='" + text + "'" +
							", itemId=" + spriteDialogItemId +
							"}";
				case OPTIONS:
					return "DialogState{" + type +
							", text='" + text + "'" +
							", options=" + options +
							"}";
				case INPUT:
					return "DialogState{" + type +
							", title='" + name + "'" +
							", input='" + text + "'" +
							"}";
				default:
					throw new IllegalStateException();
			}
		}
	}
}
/*
 * Copyright (c) 2023, geheur <https://github.com/geheur>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.weaponcharges;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.ConfigManager;

@RequiredArgsConstructor
public class ChargesMessage
{
	@Getter
	private final Pattern pattern;
	private final matcherthing chargeLeft;

	@FunctionalInterface private interface matcherthing {
		Integer customHandler(Matcher matcher, ConfigManager configManager);
	}

	public ChargesMessage(Pattern pattern, Function<Matcher, Integer> chargeLeft2) {
		this(pattern, (matcher, configManager) -> chargeLeft2.apply(matcher));
	}

	public int getChargesLeft(Matcher matcher, ConfigManager configManager)
	{
		return chargeLeft.customHandler(matcher, configManager);
	}

	public static ChargesMessage staticChargeMessage(String s, int charges)
	{
		return new ChargesMessage(Pattern.compile(s), matcher -> charges);
	}

	public static ChargesMessage matcherGroupChargeMessage(String s, int group)
	{
		return new ChargesMessage(Pattern.compile(s), matcher -> {
			String chargeCountString = matcher.group(group);
			return parseCharges(chargeCountString);
		}
		);
	}

	private static int parseCharges(String chargeCountString)
	{
		if (chargeCountString.equals("one")) {
			return 1;
		}
		return Integer.parseInt(chargeCountString.replaceAll(",", ""));
	}

	@FunctionalInterface public interface CustomChargeMatcher {
		Integer customHandler(Matcher matcher, Integer chargeCount, ConfigManager configManager);
	}

	public static ChargesMessage matcherGroupChargeMessage(String s, int group, CustomChargeMatcher customMatcher)
	{
		return new ChargesMessage(Pattern.compile(s), (matcher, configManager) -> {
			String chargeCountString = matcher.group(group).replaceAll(",", "");
			int chargeCount = parseCharges(chargeCountString);
			return customMatcher.customHandler(matcher, chargeCount, configManager);
		}
		);
	}
}

/*
 * Copyright (c) 2023, geheur <https://github.com/geheur>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.weaponcharges;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public final class ChargesDialogHandler
{
	@FunctionalInterface
	public interface MatchHandler
	{
		void handleDialog(DialogStateMatcher.DialogStateMatchers matchers, DialogTracker.DialogState dialogState, String optionSelected, WeaponChargesManager manager);
	}

	private final DialogStateMatcher dialogStateMatcher;
	private final MatchHandler matchHandler;

	public boolean handleDialog(DialogTracker.DialogState dialogState, WeaponChargesManager manager)
	{
		DialogStateMatcher.DialogStateMatchers matchers = dialogStateMatcher.matchDialog(dialogState);
		boolean matched = matchers != null;
		if (matched)
		{
			matchHandler.handleDialog(matchers, dialogState, null, manager);
		}
		return matched;
	}

	public boolean handleDialogOptionSelected(DialogTracker.DialogState dialogState, String optionSelected, WeaponChargesManager manager)
	{
		DialogStateMatcher.DialogStateMatchers matchers = dialogStateMatcher.matchDialogOptionSelected(dialogState, optionSelected);
		boolean matched = matchers != null;
		if (matched)
		{
			matchHandler.handleDialog(matchers, dialogState, optionSelected, manager);
		}
		return matched;
	}

	public static MatchHandler genericSpriteDialogChargesMessage(boolean chargesAbsolute, int group) {
		return (matchers, dialogState, optionSelected, manager) -> {
			if (dialogState.spriteDialogItemId == null) throw new IllegalArgumentException("This handler is for sprite dialogs only.");

			String chargeCountString = matchers.getTextMatcher().group(group).replaceAll(",", "");
			int charges = Integer.parseInt(chargeCountString);
			ChargedWeapon chargedWeapon = ChargedWeapon.getChargedWeaponFromId(matchers.getSpriteDialogId());
			if (chargedWeapon != null)
			{
				if (chargesAbsolute)
				{
					manager.setCharges(chargedWeapon, charges);
				} else {
					manager.addCharges(chargedWeapon, charges, true);
				}
			}
		};
	}

	public static MatchHandler genericSpriteDialogUnchargeMessage()
	{
		return (matchers, dialogState, optionSelected, manager) -> {
			if (dialogState.spriteDialogItemId == null) throw new IllegalArgumentException("This handler is for sprite dialogs only.");

			ChargedWeapon chargedWeapon = ChargedWeapon.getChargedWeaponFromId(matchers.getSpriteDialogId());
			if (chargedWeapon != null)
			{
				manager.setCharges(chargedWeapon, 0);
			}
		};
	}

	public static MatchHandler genericSpriteDialogFullChargeMessage()
	{
		return (matchers, dialogState, optionSelected, manager) -> {
			if (dialogState.spriteDialogItemId == null) throw new IllegalArgumentException("This handler is for sprite dialogs only.");

			ChargedWeapon chargedWeapon = ChargedWeapon.getChargedWeaponFromId(matchers.getSpriteDialogId());
			if (chargedWeapon != null)
			{
				manager.setCharges(chargedWeapon, chargedWeapon.getRechargeAmount());
			}
		};
	}

	public static MatchHandler genericInputChargeMessage()
	{
		return genericInputChargeMessage(1);
	}

	public static MatchHandler genericInputChargeMessage(int multiplier)
	{
		return (matchers, dialogState, optionSelected, manager) -> {
			if (manager.lastUsedOnWeapon == null) return;

			String chargeCountString = matchers.getNameMatcher().group(1).replaceAll(",", "");
			int maxChargeCount = Integer.parseInt(chargeCountString);
			int chargesEntered;
			try
			{
				chargesEntered = Integer.parseInt(optionSelected.replaceAll("k", "000").replaceAll("m", "000000").replaceAll("b", "000000000"));
			} catch (NumberFormatException e) {
				// can happen if the input is empty for example.
				return;
			}

			if (chargesEntered > maxChargeCount) chargesEntered = maxChargeCount;

			manager.addCharges(manager.lastUsedOnWeapon, chargesEntered * multiplier, true);
		};
	}

	public static MatchHandler genericUnchargeDialog()
	{
		return (matchers, dialogState, optionSelected, manager) -> {
			manager.setCharges(manager.lastUnchargeClickedWeapon, 0, true);
		};
	}
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, geheur <https://github.com/geheur>, Sir Girion https://github.com/sirgirion
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.weaponcharges;

import com.gpperhour.GPPerHourConfig;
import java.awt.Color;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Hitsplat;
import net.runelite.api.HitsplatID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuAction;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.kit.KitType;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.util.Text;

@Slf4j
public class WeaponChargesManager
{
	@Data
	@AllArgsConstructor
	public class PickupAction
	{
		int itemId;
		WorldPoint worldPoint;
	}
	
	public static final String CONFIG_GROUP_NAME = GPPerHourConfig.GROUP;
	private static final int BLOWPIPE_ATTACK_ANIMATION = 5061;
	private static final int BLAZING_BLOWPIPE_ATTACK_ANIMATION = 10656;
	private static final int AMMO_SAVING_SETTING_VARBIT = 5697;

	// TODO rename. This is used for when an item is used on a weapon, when a weapon is used on an item, and when "pages" is clicked.
	ChargedWeapon lastUsedOnWeapon;
	ChargedWeapon lastUnchargeClickedWeapon;

	@Inject Client client;
	@Inject private ClientThread clientThread;
	@Inject private ChatboxPanelManager chatboxPanelManager;
	@Inject private ChatMessageManager chatMessageManager;
	@Inject private EventBus eventBus;
	@Inject private KeyManager keyManager;
	@Inject private DialogTracker dialogTracker;

	private boolean verboseLogging = false;
	private PickupAction lastPickUpAction;

	public void startUp()
	{
		lastLocalPlayerAnimationChangedGameTick = -1;
		lastLocalPlayerAnimationChanged = -1;
		dialogTracker.reset();
		eventBus.register(dialogTracker);
		keyManager.registerKeyListener(dialogTracker);
		dialogTracker.setStateChangedListener(this::dialogStateChanged);
		dialogTracker.setOptionSelectedListener(this::optionSelected);
	}

	public void shutDown()
	{
		eventBus.unregister(dialogTracker);
		keyManager.unregisterKeyListener(dialogTracker);
	}

	void dialogStateChanged(DialogTracker.DialogState dialogState)
	{
		// TODO if you can calculate the total charges available in the inventory you could get an accurate count on the "add how many charges" dialog, because max charges - max charges addable = current charges.

		for (ChargesDialogHandler nonUniqueDialogHandler : ChargedWeapon.getNonUniqueDialogHandlers())
		{
			nonUniqueDialogHandler.handleDialog(dialogState, this);
		}

		outer_loop:
		for (ChargedWeapon chargedWeapon : ChargedWeapon.values())
		{
			for (ChargesDialogHandler dialogHandler : chargedWeapon.getDialogHandlers())
			{
				if (dialogHandler.handleDialog(dialogState, this)) break outer_loop;
			}
		}
	}

	void optionSelected(DialogTracker.DialogState dialogState, String optionSelected)
	{
		// I don't think adding a single charge by using the items on the weapon is going to be trackable if the user
		// skips the sprite dialog.

		for (ChargesDialogHandler nonUniqueDialogHandler : ChargedWeapon.getNonUniqueDialogHandlers())
		{
			nonUniqueDialogHandler.handleDialogOptionSelected(dialogState, optionSelected, this);
		}

		outer_loop:
		for (ChargedWeapon chargedWeapon : ChargedWeapon.values())
		{
			for (ChargesDialogHandler dialogHandler : chargedWeapon.getDialogHandlers())
			{
				if (dialogHandler.handleDialogOptionSelected(dialogState, optionSelected, this)) break outer_loop;
			}
		}
	}


	private int lastDegradedHitsplatTick = -1000; // 1000 is far more than 91, so the serp helm will be able to have its degrading tracked on login rather than having to wait 90 ticks.

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied e) {

		Actor target = e.getActor();
		Hitsplat hitsplat = e.getHitsplat();

		int hitType = hitsplat.getHitsplatType();
		ChargedWeapon helm = getEquippedChargedWeapon(EquipmentInventorySlot.HEAD);
		if (helm == ChargedWeapon.SERPENTINE_HELM) {
			if (hitsplat.isMine()) { // Caused by or dealt to the local player.
				if (client.getTickCount() - lastDegradedHitsplatTick > 90) {
					addCharges(helm, -10, false);
					lastDegradedHitsplatTick = client.getTickCount();
					if (verboseLogging)
						client.addChatMessage(ChatMessageType.FRIENDSCHAT, "WeaponCharges", "Serpentine Helmet has Degraded!", "DEVMODE");
				}
			}
		}
		ChargedWeapon body = getEquippedChargedWeapon(EquipmentInventorySlot.BODY);
		ChargedWeapon legs = getEquippedChargedWeapon(EquipmentInventorySlot.LEGS);
		// >0 will filter out all unsuccessful hits and a small amount of successful hits
		if (target == client.getLocalPlayer() && hitType == HitsplatID.DAMAGE_ME && e.getHitsplat().getAmount() > 0) {
			if (helm == ChargedWeapon.CRYSTAL_HELM) {
				addCharges(helm, -1, false);
			}
			if (body == ChargedWeapon.CRYSTAL_BODY) {
				addCharges(body, -1, false);
			}
			if (legs == ChargedWeapon.CRYSTAL_LEGS) {
				addCharges(legs, -1, false);
			}
		}
		checkMeleeHitsplat(target, hitsplat);
	}

	//taken from thrall damage counter plugin AnimationData class
	private final Set<Integer> meleeAttackAnimations = Set.of(8056, 245,376,381,386,390,8288,8290,8289,9471,6118,393,0,395,400,401,406,407,414,419,422,423,428,429,440,1058,1060,1062,1378,1658,1665,1667,2066,2067,2078,2661,3297,3298,3852,4503,5865,7004,7045,7054,7055,7514,7515,7516,7638,7639,7640,7641,7642,7643,7644,7645,8145,9171,1203, 5439, 8640);
	private Hitsplat lastMeleeHitsplatApplied = null;

	private void checkMeleeHitsplat(Actor target, Hitsplat hitsplat)
	{
		//We inflicted damage to NPC (could be recoil, venge, thrall, or from a weapon)
		if (!hitsplat.isMine() || target == client.getLocalPlayer())
			return;
		
		//melee hitsplat always comes 1 tick after animation
		if (client.getTickCount() != lastLocalPlayerAnimationChangedGameTick + 1)
			return;

		if (!meleeAttackAnimations.contains(lastLocalPlayerAnimationChanged))
			return;

		// The weapon hitsplat is always last, after other hitsplats which occur on the same tick such as from
		// venge or thralls.
		lastMeleeHitsplatApplied = hitsplat;
	}

	// There are two lists to keep a list of checked weapons not just in the last tick, but in the last 2. I do this because
	// I'm paranoid that someone will somehow check an item without getting a check message, or the check message
	// does not match any regexes for some reason. This can cause the plugin to assign charges to the wrong weapon.
	private List<ChargedWeapon> lastWeaponChecked = new ArrayList<>();
	private List<ChargedWeapon> lastWeaponChecked2 = new ArrayList<>();

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if (event.getMenuAction() == MenuAction.GROUND_ITEM_THIRD_OPTION && event.getMenuOption().equals("Take"))
		{
			WorldPoint point = WorldPoint.fromScene(client, event.getParam0(), event.getParam1(), client.getPlane());
			lastPickUpAction = new PickupAction(event.getId(), point);
		}
		if (event.getMenuOption().equalsIgnoreCase("check")) {
			// TODO investigate shift-click.
			if (verboseLogging) log.info("clicked \"check\" on " + event.getMenuTarget());

			if (WidgetUtil.componentToInterface(event.getParam1()) == InterfaceID.WORNITEMS) { // item is equipped.
				int childId = WidgetUtil.componentToId(event.getParam1());
				if (childId == 18) {
					ChargedWeapon chargedWeapon = getEquippedChargedWeapon(EquipmentInventorySlot.WEAPON);
					if (chargedWeapon != null) lastWeaponChecked.add(chargedWeapon);
				} else if (childId == 20) {
					ChargedWeapon chargedWeapon = getEquippedChargedWeapon(EquipmentInventorySlot.SHIELD);
					if (chargedWeapon != null) lastWeaponChecked.add(chargedWeapon);
				}
			} else {
				for (ChargedWeapon chargedWeapon : ChargedWeapon.values())
				{
					if (chargedWeapon.getItemIds().contains(event.getItemId()) && chargedWeapon.getCheckChargesRegexes().isEmpty())
					{
						if (verboseLogging) log.info("adding last weapon checked to " + chargedWeapon);
						lastWeaponChecked.add(chargedWeapon);
						break;
					}
				}
			}
		} else if (event.getMenuOption().equalsIgnoreCase("uncharge")) {
			for (ChargedWeapon chargedWeapon : ChargedWeapon.values())
			{
				if (chargedWeapon.getItemIds().contains(event.getItemId()))
				{
					if (verboseLogging) log.info("setting lastUnchargeClickedWeapon to " + chargedWeapon);
					lastUnchargeClickedWeapon = chargedWeapon;
					break;
				}
			}
		} else if (event.getMenuOption().equalsIgnoreCase("unload") && isToxicBlowpipe(event.getItemId())) {
			checkBlowpipeUnload = client.getTickCount();
		} else if (event.getMenuOption().equalsIgnoreCase("pages")) {
			if (WidgetUtil.componentToInterface(event.getParam1()) == InterfaceID.WORNITEMS) { // item is equipped.
				lastUsedOnWeapon = getEquippedChargedWeapon(EquipmentInventorySlot.SHIELD);
			} else {
				lastUsedOnWeapon = ChargedWeapon.getChargedWeaponFromId(event.getItemId());
			}
			if (verboseLogging) log.info("pages checked. setting last used weapon to {}", lastUsedOnWeapon.toString());
		}

		checkWidgetOnWidget(event);
	}

	void checkWidgetOnWidget(MenuOptionClicked event)
	{
		if (event.getMenuAction() == MenuAction.WIDGET_TARGET_ON_WIDGET) {
			ItemContainer itemContainer = client.getItemContainer(InventoryID.INV);
			if (itemContainer == null)
			{
				return;
			}
			Widget selectedWidget = client.getSelectedWidget();
			if (selectedWidget == null)
			{
				return;
			}
			Item itemUsed = itemContainer.getItem(selectedWidget.getIndex());
			if (itemUsed == null) return;
			int itemUsedId = itemUsed.getId();
			Widget eventWidget = event.getWidget();
			if (eventWidget == null)
			{
				return;
			}
			Item itemUsedOn = itemContainer.getItem(eventWidget.getIndex());
			if (itemUsedOn == null) return;
			int itemUsedOnId = itemUsedOn.getId();
			lastUsedOnWeapon = ChargedWeapon.getChargedWeaponFromId(itemUsedId);
			if (lastUsedOnWeapon == null)
			{
				lastUsedOnWeapon = ChargedWeapon.getChargedWeaponFromId(itemUsedOnId);
				if (lastUsedOnWeapon != null)
				{
					if (verboseLogging) log.info("{}: used {} on {}", client.getTickCount(), itemUsedId, lastUsedOnWeapon);
					checkSingleCrystalShardUse(itemUsed, itemUsedId);
				} else {
					if (verboseLogging) log.info("{}: used {} on {}", client.getTickCount(), itemUsedId, itemUsedOnId);
				}
			} else {
				if (verboseLogging) log.info("{}: used {} on {}", client.getTickCount(), lastUsedOnWeapon, itemUsedOnId);
				checkSingleCrystalShardUse(itemUsedOn, itemUsedOnId);
			}
		}
	}

	private void checkSingleCrystalShardUse(Item itemUsed, int itemUsedId)
	{
		if (itemUsedId == ItemID.PRIF_CRYSTAL_SHARD && itemUsed.getQuantity() == 1 && ChargedWeapon.CRYSTAL_SHARD_RECHARGABLE_ITEMS.contains(lastUsedOnWeapon)) {
			checkSingleCrystalShardUse = client.getTickCount();
		}
	}

	private boolean hasToxicBlowpipeEquippedOrInInventory()
	{
		final ItemContainer itemContainer = client.getItemContainer(InventoryID.INV);
		if (itemContainer != null)
		{
			Item[] inventoryItems = itemContainer.getItems();
			for (Item item : inventoryItems)
			{
				if (isToxicBlowpipe(item.getId()))
				{
					return true;
				}
			}
		}
		final ItemContainer equipmentContainer = client.getItemContainer(InventoryID.WORN);
		if (equipmentContainer != null)
		{
			Item weapon = equipmentContainer.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
			if (weapon != null && isToxicBlowpipe(weapon.getId()))
			{
				return true;
			}
		}
		return false;
	}

	private boolean isToxicBlowpipe(int itemId)
	{
		return itemId == ItemID.TOXIC_BLOWPIPE_LOADED || itemId == ItemID.TOXIC_BLOWPIPE_LOADED_ORNAMENT;
	}

	private boolean hasBlowpipeData()
	{
		return (getDartsLeft() != null) && (getScalesLeft() != null) && (getDartType() != DartType.UNKNOWN);
	}

	@Subscribe
	public void onItemDespawned(ItemDespawned event)
	{
		//see if user has ammo saving enabled
		if (client.getVarbitValue(AMMO_SAVING_SETTING_VARBIT) != 1)
		{
			return;
		}

		//check has blowpipe data
		if (!hasBlowpipeData())
		{
			return;
		}

		//check item is correct dart
		int itemId = event.getItem().getId();
		if (itemId != getDartType().itemId)
		{
			return;
		}

		//check has blowpipe equipped or in inventory
		if (!hasToxicBlowpipeEquippedOrInInventory())
		{
			return;
		}

		if (lastPickUpAction == null)
		{
			return;
		}

		// not on same tile
		if (!event.getTile().getWorldLocation().equals(client.getLocalPlayer().getWorldLocation()))
		{
			return;
		}

		if (!event.getTile().getWorldLocation().equals(lastPickUpAction.getWorldPoint()))
		{
			return;
		}

		if (itemId != lastPickUpAction.getItemId())
		{
			return;
		}

		int quantity = event.getItem().getQuantity();
		addDartsLeft(quantity, false);
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
		if (itemContainerChanged.getContainerId() != InventoryID.INV) {
			return;
		}

		if (checkBlowpipeUnload == client.getTickCount() || checkBlowpipeUnload + 1 == client.getTickCount()) {
			setDartsLeft(0);
			setDartType(DartType.UNKNOWN);
		}

		if (checkSingleCrystalShardUse == client.getTickCount() || checkSingleCrystalShardUse + 1 == client.getTickCount()) {
			addCharges(lastUsedOnWeapon, 100, false);
		}
	}

	private final List<Runnable> delayChargeUpdateUntilAfterAnimations = new ArrayList<>();

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)
		{
			return;
		}

		String message = Text.removeTags(event.getMessage());

		for (ChargesMessage checkMessage : ChargedWeapon.getNonUniqueCheckChargesRegexes())
		{
			Matcher matcher = checkMessage.getPattern().matcher(message);
			if (matcher.find()) {
				ChargedWeapon chargedWeapon = removeLastWeaponChecked();
				// TODO possible to mess stuff up by checking a weapon immediately after the tome of water/fire dialog?
				if (chargedWeapon != null) {
					setCharges(chargedWeapon, checkMessage.getChargesLeft(matcher, configManager));
				} else if (lastUsedOnWeapon != null) {
					setCharges(lastUsedOnWeapon, checkMessage.getChargesLeft(matcher, configManager));
					if (verboseLogging) log.info("applying charges to last used-on weapon: {}", lastUsedOnWeapon);
				} else {
					log.warn("saw check message without having seen a charged weapon checked or used: \"" + message + "\"" );
				}
				break;
			}
		}

		for (ChargesMessage checkMessage : ChargedWeapon.getNonUniqueUpdateMessageChargesRegexes())
		{
			Matcher matcher = checkMessage.getPattern().matcher(message);
			if (matcher.find()) {
				int chargeCount = checkMessage.getChargesLeft(matcher, configManager);
				delayChargeUpdateUntilAfterAnimations.add(() -> {
					ChargedWeapon equippedWeapon = getEquippedChargedWeapon(EquipmentInventorySlot.WEAPON);
					if (equippedWeapon != null) {
						setCharges(equippedWeapon, chargeCount);
					} else {
						log.warn("saw charge update message without a weapon being equipped: \"" + message + "\"");
					}
				});
				break;
			}
		}

		outer_loop:
		for (ChargedWeapon chargedWeapon : ChargedWeapon.values())
		{
			if (chargedWeapon.getCheckChargesRegexes().isEmpty()) continue;

			for (ChargesMessage checkMessage : chargedWeapon.getCheckChargesRegexes())
			{
				Matcher matcher = checkMessage.getPattern().matcher(message);
				if (matcher.find()) {
					setCharges(chargedWeapon, checkMessage.getChargesLeft(matcher, configManager));
					break outer_loop;
				}
			}

			for (ChargesMessage checkMessage : chargedWeapon.getUpdateMessageChargesRegexes())
			{
				Matcher matcher = checkMessage.getPattern().matcher(message);
				if (matcher.find()) {
					delayChargeUpdateUntilAfterAnimations.add(() -> setCharges(chargedWeapon, checkMessage.getChargesLeft(matcher, configManager)));
					break outer_loop;
				}
			}
		}

		chatMessageBlowpipe(message);
	}

	private ChargedWeapon removeLastWeaponChecked()
	{
		return !lastWeaponChecked2.isEmpty() ? lastWeaponChecked2.remove(0) :
			!lastWeaponChecked.isEmpty() ? lastWeaponChecked.remove(0) :
				null;
	}

	private ChargedWeapon getEquippedChargedWeapon(EquipmentInventorySlot slot)
	{
		ItemContainer itemContainer = client.getItemContainer(InventoryID.WORN);
		if (itemContainer == null) return null;

		Item item = itemContainer.getItem(slot.getSlotIdx());
		if (item == null) return null;

		return ChargedWeapon.getChargedWeaponFromId(item.getId());
	}

	/* blowpipe:
	// checking:
	// 2021-08-29 14:22:09 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 1135: GAMEMESSAGE "Darts: <col=007f00>None</col>. Scales: <col=007f00>99 (0.6%)</col>."
	// 2021-09-05 13:55:04 [Client] INFO  com.weaponcharges.Devtools - 9: GAMEMESSAGE "Darts: <col=007f00>Adamant dart x 16,383</col>. Scales: <col=007f00>16,383 (100.0%)</col>."
	// 2021-09-05 13:55:26 [Client] INFO  com.weaponcharges.Devtools - 46: GAMEMESSAGE "Darts: <col=007f00>Adamant dart x 16,383</col>. Scales: <col=007f00>0 (0.0%)</col>."

	// adding charges either uses the check messages, or one of the following:
	// using scales on full blowpipe: 2021-09-05 13:48:26 [Client] INFO  com.weaponcharges.Devtools - 640: GAMEMESSAGE "The blowpipe can't hold any more scales."
	// using darts on full blowpipe: 2021-09-05 13:48:25 [Client] INFO  com.weaponcharges.Devtools - 638: GAMEMESSAGE "The blowpipe can't hold any more darts."

	// run out of darts: 2021-08-29 14:19:11 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 841: GAMEMESSAGE "Your blowpipe has run out of darts."
	// run out of scales: 2021-08-29 14:18:27 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 767: GAMEMESSAGE "Your blowpipe needs to be charged with Zulrah's scales."
	// run out of both: 2021-09-05 13:45:24 [Client] INFO  com.weaponcharges.Devtools - 336: GAMEMESSAGE "Your blowpipe has run out of scales and darts."

	// (attacking with no darts: 2021-09-05 13:43:43 [Client] INFO  com.weaponcharges.Devtools - 169: GAMEMESSAGE "Your blowpipe contains no darts."
	// (attacking with no darts or scales (trying to equip blowpipe without EITHER scales or darts in it produces the same message, lol) : 2021-09-05 13:45:43 [Client] INFO  com.weaponcharges.Devtools - 369: GAMEMESSAGE "Your blowpipe needs to be charged with Zulrah's scales and loaded with darts."
	// (attacking with no scales, same as run out of scales message): 2021-09-05 13:47:42 [Client] INFO  com.weaponcharges.Devtools - 566: GAMEMESSAGE "Your blowpipe needs to be charged with Zulrah's scales."

	// unload
	// unload with no darts: 2021-09-05 13:59:25 [Client] INFO  com.weaponcharges.Devtools - 443: GAMEMESSAGE "The blowpipe has no darts in it."
	// unload with darts has no chat message.

	// don't care because when you add charges after it always produces a chat message.
	// uncharge 2021-09-05 14:40:47 [Client] INFO  com.weaponcharges.Devtools - 481: dialog state changed: DialogState{DESTROY_ITEM, title='Are you sure you want to uncharge it?', itemId=12926, item_name='Toxic blowpipe', text='If you uncharge the blowpipe, all scales and darts will fall out.'}
	 */

	// check messages.
	private static final Pattern NO_DARTS_CHECK_PATTERN = Pattern.compile("Darts: None. Scales: ([\\d,]+) \\(\\d+[.]?\\d%\\).");
	private static final Pattern DARTS_AND_SCALE_CHECK_PATTERN = Pattern.compile("Darts: (\\S*)(?: dart)? x ([\\d,]+). Scales: ([\\d,]+) \\(\\d+[.]?\\d%\\).");
	private static final Pattern USE_SCALES_ON_FULL_BLOWPIPE_PATTERN = Pattern.compile("The blowpipe can't hold any more scales.");
	private static final Pattern USE_DARTS_ON_FULL_BLOWPIPE_PATTERN = Pattern.compile("The blowpipe can't hold any more darts.");
	private static final Pattern UNLOAD_EMPTY_BLOWPIPE_PATTERN = Pattern.compile("The blowpipe has no darts in it.");

	// update messages.
	private static final Pattern NO_DARTS_PATTERN = Pattern.compile("Your blowpipe has run out of darts.");
	private static final Pattern NO_SCALES_PATTERN = Pattern.compile("Your blowpipe needs to be charged with Zulrah's scales.");
	private static final Pattern NO_DARTS_OR_SCALES_PATTERN = Pattern.compile("Your blowpipe has run out of scales and darts.");
	private static final Pattern NO_DARTS_PATTERN_2 = Pattern.compile("Your blowpipe contains no darts.");
	private static final Pattern NO_DARTS_OR_SCALES_PATTERN_2 = Pattern.compile("Your blowpipe needs to be charged with Zulrah's scales and loaded with darts.");

	private void chatMessageBlowpipe(String chatMsg)
	{
		Matcher matcher = DARTS_AND_SCALE_CHECK_PATTERN.matcher(chatMsg);
		if (matcher.find())
		{
			setDartsLeft(Integer.parseInt(matcher.group(2).replace(",", "")));
			setScalesLeft(Integer.parseInt(matcher.group(3).replace(",", "")));
			setDartType(DartType.getDartTypeByName(matcher.group(1)));
		}

		matcher = NO_DARTS_CHECK_PATTERN.matcher(chatMsg);
		if (matcher.find())
		{
			setDartsLeft(0);
			setScalesLeft(Integer.parseInt(matcher.group(1).replace(",", "")));
			setDartType(DartType.UNKNOWN);
		}

		matcher = USE_SCALES_ON_FULL_BLOWPIPE_PATTERN.matcher(chatMsg);
		if (matcher.find()) {
			setScalesLeft(MAX_SCALES_BLOWPIPE);
		}

		matcher = USE_DARTS_ON_FULL_BLOWPIPE_PATTERN.matcher(chatMsg);
		if (matcher.find()) {
			setDartsLeft(MAX_DARTS);
		}

		matcher = UNLOAD_EMPTY_BLOWPIPE_PATTERN.matcher(chatMsg);
		if (matcher.find()) {
			setDartsLeft(0);
			setDartType(DartType.UNKNOWN);
		}

		matcher = NO_DARTS_PATTERN.matcher(chatMsg);
		if (matcher.find()) {
			delayChargeUpdateUntilAfterAnimations.add(() -> {
				setDartsLeft(0);
				setDartType(DartType.UNKNOWN);
			});
		}

		matcher = NO_SCALES_PATTERN.matcher(chatMsg);
		if (matcher.find())
		{
			delayChargeUpdateUntilAfterAnimations.add(() -> setScalesLeft(0));
		}

		matcher = NO_DARTS_OR_SCALES_PATTERN.matcher(chatMsg);
		if (matcher.find())
		{
			delayChargeUpdateUntilAfterAnimations.add(() -> {
				setScalesLeft(0);
				setDartsLeft(0);
				setDartType(DartType.UNKNOWN);
			});
		}

		matcher = NO_DARTS_PATTERN_2.matcher(chatMsg);
		if (matcher.find())
		{
			delayChargeUpdateUntilAfterAnimations.add(() -> {
				setDartsLeft(0);
				setDartType(DartType.UNKNOWN);
			});
		}

		matcher = NO_DARTS_OR_SCALES_PATTERN_2.matcher(chatMsg);
		if (matcher.find())
		{
			delayChargeUpdateUntilAfterAnimations.add(() -> {
				setScalesLeft(0);
				setDartsLeft(0);
				setDartType(DartType.UNKNOWN);
			});
		}
	}

	private boolean checkTomeOfFire = false;
	private boolean checkTomeOfWater = false;
	private int checkBlowpipeUnload = -100;
	private int checkSingleCrystalShardUse = -100;

	@Subscribe
	public void onClientTick(ClientTick clientTick)
	{
		if (checkTomeOfFire) {
			Player localPlayer = client.getLocalPlayer();
			if (
				localPlayer.hasSpotAnim(99) ||
					localPlayer.hasSpotAnim(126) ||
					localPlayer.hasSpotAnim(129) ||
					localPlayer.hasSpotAnim(155) ||
					localPlayer.hasSpotAnim(1464)
			) {
				addCharges(ChargedWeapon.TOME_OF_FIRE, -1, false);
			}
		}
		checkTomeOfFire = false;

		if (checkTomeOfWater) {
			Player localPlayer = client.getLocalPlayer();
			if (
					localPlayer.hasSpotAnim(177) || //bind/snare/entangle
					localPlayer.hasSpotAnim(102) || //curse spells
					localPlayer.hasSpotAnim(105) ||
					localPlayer.hasSpotAnim(108) ||
					localPlayer.hasSpotAnim(167) ||
					localPlayer.hasSpotAnim(170) ||
					localPlayer.hasSpotAnim(173) ||
					localPlayer.hasSpotAnim( 93) || //water spells
					localPlayer.hasSpotAnim(120) ||
					localPlayer.hasSpotAnim(135) ||
					localPlayer.hasSpotAnim(161) ||
					localPlayer.hasSpotAnim(1458)
			) {
				addCharges(ChargedWeapon.TOME_OF_WATER, -1, false);
			}
			checkTomeOfWater = false;
		}
	}

	private int lastLocalPlayerAnimationChangedGameTick = -1;
	// I record the animation id so that animation changing plugins that change the animation (e.g. weapon animation replacer) can't interfere.
	private int lastLocalPlayerAnimationChanged = -1;

	@Subscribe(priority = 10.0f) // I want to get ahead of those pesky animation modifying plugins.
	public void onAnimationChanged(AnimationChanged event)
	{
		final Actor actor = event.getActor();
		if (actor != client.getLocalPlayer()) return;

		lastLocalPlayerAnimationChangedGameTick = client.getTickCount();
		lastLocalPlayerAnimationChanged = actor.getAnimation();
	}

	private static final int TICKS_RAPID_PVM = 2;
	//	private static final int TICKS_RAPID_PVP = 3;
	private static final int TICKS_NORMAL_PVM = 3;
	//	private static final int TICKS_NORMAL_PVP = 4;
	public static final int MAX_SCALES_BLOWPIPE = 16383;
	public static final int MAX_DARTS = 16383;

	private int ticks = 0;
	private int ticksInAnimation;
	private int lastAnimationStart = 0;

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		//doesn't properly account for successful hits that roll 0 damage
		if (lastMeleeHitsplatApplied != null && lastMeleeHitsplatApplied.getAmount() > 0)
		{
			ChargedWeapon amulet = getEquippedChargedWeapon(EquipmentInventorySlot.AMULET);
			if (amulet == ChargedWeapon.BLOOD_FURY)
			{
				// assume scythe does three hits and all are successful if one is
				if (lastLocalPlayerAnimationChanged == 8056)
				{
					addCharges(amulet, -3, false);
				}
				else
				{
					addCharges(amulet, -1, false);
				}
			}
		}
		lastMeleeHitsplatApplied = null;
		// This delay is necessary because equipped items are updated after onAnimationChanged, so with items that share
		// a game message it will not be possible to tell which item the message is for.
		// The order must be: check messages, animation, charge update messages.
		// Runelite's order is: onChatMessage, onAnimationChanged, onGameTick.
		// charge update messages must also be delayed due to equipment slot info not being current in onChatMessage.
		if (lastLocalPlayerAnimationChangedGameTick == client.getTickCount()) 
			checkAnimation();

		if (lastLocalPlayerAnimationChanged == BLOWPIPE_ATTACK_ANIMATION || lastLocalPlayerAnimationChanged == BLAZING_BLOWPIPE_ATTACK_ANIMATION)
		{
			blowpipeOnGameTick();
		}

		if (!delayChargeUpdateUntilAfterAnimations.isEmpty()) {
			for (Runnable runnable : delayChargeUpdateUntilAfterAnimations)
			{
				runnable.run();
			}
			delayChargeUpdateUntilAfterAnimations.clear();
		}

		if (!lastWeaponChecked2.isEmpty()) {
			log.warn("checked weapons with no check message: " + lastWeaponChecked2);
		}
		lastWeaponChecked2.clear();
		lastWeaponChecked2 = lastWeaponChecked;
		lastWeaponChecked = new ArrayList<>();
	}

	private void blowpipeOnGameTick()
	{
		if (ticks == 0) {
			lastAnimationStart = client.getTickCount();
		} else {
			if (client.getTickCount() - lastAnimationStart > ticksInAnimation) {
				ticks = 0;
				lastAnimationStart = client.getTickCount();
			}
		}

		ticks++;
//		System.out.println(client.getTickCount() + " blowpipe: " + ticks + " " + ticksInAnimation);

		if (ticks == ticksInAnimation)
		{
//			System.out.println(client.getTickCount() + " blowpipe hits (animation update): " + ++blowpipeHits + " " + blowpipeHitsBySound);
			consumeBlowpipeCharges();
			ticks = 0;
		}
	}

	private void checkAnimation()
	{
		ItemContainer itemContainer = client.getItemContainer(InventoryID.WORN);
		if (itemContainer == null) return;

		Item weapon = itemContainer.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
		int weaponItemId = (weapon == null) ? -1 : weapon.getId();

		Item offhand = itemContainer.getItem(EquipmentInventorySlot.SHIELD.getSlotIdx());
		int offhandItemId = (offhand == null) ? -1 : offhand.getId();

		for (ChargedWeapon chargedWeapon : ChargedWeapon.values()) {
			if (
				(chargedWeapon.getItemIds().contains(weaponItemId) || chargedWeapon.getItemIds().contains(offhandItemId)) &&
					chargedWeapon.animationIds.contains(lastLocalPlayerAnimationChanged))
			{
				if (chargedWeapon == ChargedWeapon.TOME_OF_FIRE) {
					checkTomeOfFire = true;
				} else if (chargedWeapon == ChargedWeapon.TOME_OF_WATER) {
					checkTomeOfWater = true;
				} else {
					addCharges(chargedWeapon, -1, false);
				}
			}
		}
	}

	private void consumeBlowpipeCharges()
	{
		addDartsLeft(-1 * getAmmoLossChance(), false);
		addScalesLeft(-2/3f, false);
	}

	private float getAmmoLossChance()
	{
		int attractorEquippedId = client.getLocalPlayer().getPlayerComposition().getEquipmentId(KitType.CAPE);
		switch (attractorEquippedId) {
			case ItemID.ANMA_30_REWARD:
				return 0.4f;
			case ItemID.ANMA_50_REWARD:
			case ItemID.SKILLCAPE_MAX_ANMA:
				return 0.28f;
			case ItemID.SKILLCAPE_RANGING:
			case ItemID.SKILLCAPE_RANGING_TRIMMED:
			case ItemID.SKILLCAPE_MAX:
				return 0.28f;
			case ItemID.AVAS_ASSEMBLER:
			case ItemID.AVAS_ASSEMBLER_TROUVER:
			case ItemID.SKILLCAPE_MAX_ASSEMBLER:
			case ItemID.SKILLCAPE_MAX_ASSEMBLER_TROUVER:
			case ItemID.AVAS_ASSEMBLER_MASORI:
			case ItemID.AVAS_ASSEMBLER_MASORI_TROUVER:
			case ItemID.SKILLCAPE_MAX_ASSEMBLER_MASORI:
			case ItemID.SKILLCAPE_MAX_ASSEMBLER_MASORI_TROUVER:
			case ItemID.SKILLCAPE_MAX_DIZANAS:
			case ItemID.SKILLCAPE_MAX_DIZANAS_TROUVER:
			case ItemID.DIZANAS_QUIVER_UNCHARGED:
			case ItemID.DIZANAS_QUIVER_UNCHARGED_TROUVER:
			case ItemID.DIZANAS_QUIVER_CHARGED:
			case ItemID.DIZANAS_QUIVER_CHARGED_TROUVER:
			case ItemID.DIZANAS_QUIVER_INFINITE:
			case ItemID.DIZANAS_QUIVER_INFINITE_TROUVER:
				return 0.2f;
			default:
				// no ammo-saving thing equipped.
				return 1f;
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		if (event.getVarpId() == VarPlayerID.COM_MODE) {
			ticksInAnimation = event.getValue() == 1 ? TICKS_RAPID_PVM : TICKS_NORMAL_PVM;
		}
	}

	@Inject
	ConfigManager configManager;

	public Integer getCharges(ChargedWeapon weapon) {
		String configString = configManager.getRSProfileConfiguration(CONFIG_GROUP_NAME, weapon.configKeyName);
		if (configString == null) return null;
		return Integer.parseInt(configString);
	}

	public void setCharges(ChargedWeapon weapon, int charges) {
		setCharges(weapon, charges, true);
	}

	public void setCharges(ChargedWeapon weapon, int charges, boolean logChange) {
		configManager.setRSProfileConfiguration(CONFIG_GROUP_NAME, weapon.configKeyName, Math.max(charges, 0));
		if (verboseLogging)
		{
			log.info("set charges for " + weapon + " to " + charges);
		}
	}

	public void addCharges(ChargedWeapon weapon, int change, boolean logChange) {
		Integer charges = getCharges(weapon);
		if (verboseLogging)
		{
			log.info("Adding " + change + " charges to " + weapon.name + "which has " + charges + "charges.");
		}
		setCharges(weapon, (charges == null ? 0 : charges) + change, logChange);
	}

	public Float getDartsLeft()
	{
		String configString = configManager.getRSProfileConfiguration(CONFIG_GROUP_NAME, "blowpipeDarts");
		if (configString == null) return null;
		return Float.parseFloat(configString);
	}

	void setDartsLeft(float dartsLeft)
	{
		setDartsLeft(dartsLeft, true);
	}

	private void setDartsLeft(float dartsLeft, boolean logChange)
	{
		configManager.setRSProfileConfiguration(CONFIG_GROUP_NAME, "blowpipeDarts", dartsLeft);
		if (verboseLogging)
		{
			log.info("set darts left to " + dartsLeft);
		}
	}

	private void addDartsLeft(float change, boolean logChange) {
		Float dartsLeft = getDartsLeft();
		setDartsLeft((dartsLeft == null ? 0 : dartsLeft) + change, logChange);
	}

	public DartType getDartType()
	{
		String configString = configManager.getRSProfileConfiguration(CONFIG_GROUP_NAME, "blowpipeDartType");
		if (configString == null) return DartType.UNKNOWN;
		return DartType.valueOf(configString);
	}

	void setDartType(DartType dartType)
	{
		configManager.setRSProfileConfiguration(CONFIG_GROUP_NAME, "blowpipeDartType", dartType);
		if (verboseLogging)
			log.info("set dart type to " + dartType);
	}

	public Float getScalesLeft()
	{
		String configString = configManager.getRSProfileConfiguration(CONFIG_GROUP_NAME, "blowpipeScales");
		if (configString == null) return null;
		return Float.parseFloat(configString);
	}

	void setScalesLeft(float scalesLeft)
	{
		setScalesLeft(scalesLeft, true);
	}

	private void setScalesLeft(float scalesLeft, boolean logChange)
	{
		configManager.setRSProfileConfiguration(CONFIG_GROUP_NAME, "blowpipeScales", scalesLeft);
		if (verboseLogging)
		{
			log.info("set scales left to " + scalesLeft);
		}
	}

	private void addScalesLeft(float change, boolean logChange) {
		Float scalesLeft = getScalesLeft();
		setScalesLeft((scalesLeft == null ? 0 : scalesLeft) + change, logChange);
	}

	@RequiredArgsConstructor
	public enum DartType {
		UNKNOWN(-1, Color.LIGHT_GRAY, null),
		BRONZE(ItemID.BRONZE_DART, new Color(0x6e5727), "bronze"),
		IRON(ItemID.IRON_DART, new Color(0x52504c), "iron"),
		STEEL(ItemID.STEEL_DART, new Color(0x7a7873), "steel"),
		MITHRIL(ItemID.MITHRIL_DART, new Color(0x414f78), "mithril"),
		ADAMANT(ItemID.ADAMANT_DART, new Color(0x417852), "adamant"),
		RUNE(ItemID.RUNE_DART, new Color(0x67e0f5), "rune"),
		AMETHYST(ItemID.AMETHYST_DART, new Color(0xc87dd4), "amethyst"),
		DRAGON(ItemID.DRAGON_DART, new Color(0x3e7877), "dragon"),
		;

		public final int itemId;
		public final Color displayColor;
		public final String checkBlowpipeMessageName;

		public static DartType getDartTypeByName(String group)
		{
			group = group.toLowerCase();
			for (DartType dartType : DartType.values())
			{
				if (dartType.checkBlowpipeMessageName != null && dartType.checkBlowpipeMessageName.equals(group)) {
					return dartType;
				}
			}
			return null;
		}
	}

	/// API for Plugin

	private  Map<Integer, Float> emptyMap = new HashMap<>();

	public boolean isChargeableWeapon(Integer itemId)
	{
		for (ChargedWeapon chargedWeapon : ChargedWeapon.values()) {
			if (chargedWeapon.getItemIds().contains(itemId)) {
				return true;
			}
		}
		return false;
	}

	private ChargedWeapon getChargedWeapon(Integer itemId)
	{
		for (ChargedWeapon chargedWeapon : ChargedWeapon.values()) {
			if (chargedWeapon.getItemIds().contains(itemId)) {
				return chargedWeapon;
			}
		}
		return null;
	}

	public boolean hasChargeData(Integer itemId)
	{
		if (isToxicBlowpipe(itemId))
		{
			return hasBlowpipeData();
		}
		for (ChargedWeapon chargedWeapon : ChargedWeapon.values()) {
			if (chargedWeapon.getItemIds().contains(itemId)) {
				return getCharges(chargedWeapon) != null;
			}
		}
		log.warn("Didn't find a chargeable weapon for this itemID, this shouldn't happen.");
		return false;
	}

	//avoid GC
	private  Map<Integer, Float> blowpipeMap = new HashMap<>();

	public Map<Integer, Float> getChargeComponents(Integer itemId)
	{
		ChargedWeapon weapon = null;
		for (ChargedWeapon chargedWeapon : ChargedWeapon.values()) {
			if (chargedWeapon.getItemIds().contains(itemId)) {
				weapon = chargedWeapon;
				break;
			}
		}
		if (weapon == null)
		{
			log.warn("Weapon is NULL");
			return emptyMap;
		}
		//special case cause of how fucked the blowpipe is
		if (weapon == ChargedWeapon.TOXIC_BLOWPIPE)
		{
			blowpipeMap.clear();
			Float dartCount = getDartsLeft();
			Float scaleCount = getScalesLeft();
			DartType dartType = getDartType();
			blowpipeMap.put(dartType.itemId, dartCount);
			blowpipeMap.put(ItemID.SNAKEBOSS_SCALE, scaleCount);
			return blowpipeMap;
		}
		return weapon.getChargeComponents(getCharges(weapon), configManager);
	}
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, geheur <https://github.com/geheur>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.weaponcharges;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.regex.Pattern;

import com.gpperhour.GPPerHourConfig;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.util.Text;

@Getter
public enum ChargedWeapon
{
	// many weapons are handled specially in ways not found in this file.
	/*
	 * I think my minimum reqs should be: check message >1, periodic update, animation-based reduction, charge, uncharge.
	 */
	/* template for data collection:
		check (full, <full & >1, 1, 0/empty):
			full: TODO
			>1: TODO
			1: TODO
			empty: TODO

		periodic updates (periodic, empty):
			periodic: TODO
			empty: TODO
			attacking when empty: TODO

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			using items: TODO
			right-click options: TODO
			other: TODO

		removing (regular removal methods, dropping:
			regular: TODO
			dropping: TODO

		message overlap:
			TODO
	 */

	/* ibans
		check (full, <full & >1, 1, 0/empty):
			full: 2021-08-29 20:24:05 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 11707: GAMEMESSAGE "You have 2500 charges left on the staff."
			>1: 2021-08-29 18:56:25 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 5107: GAMEMESSAGE "You have 116 charges left on the staff."
			1: 2021-08-29 20:03:05 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 9622: GAMEMESSAGE "You have a charge left on the staff." TODO unimplemented.
			empty: 2021-08-29 20:03:14 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 9638: GAMEMESSAGE "You have no charges left on the staff." TODO unimplemented.

		periodic updates (periodic, empty):
			periodic: 2021-08-29 19:53:15 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 8651: GAMEMESSAGE "<col=ef1020>Your staff only has 100 charges left.</col>" TODO unimplemented.
				2021-08-29 19:57:43 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 9092: GAMEMESSAGE "<col=ef1020>Your staff only has 50 charges left.</col>"
				every 100 but also at 50.
			empty: 2021-08-29 20:03:11 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 9632: GAMEMESSAGE "<col=ef1020>Your staff has run out of charges.</col>" TODO unimplemented.
			attacking when empty: 2021-08-29 20:03:18 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 9644: GAMEMESSAGE "You need to recharge your staff to use this spell." TODO unimplemented.

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			well: 2021-08-29 20:14:23 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 10744: dialog state changed: NpcDialogState{SPRITE, text='You hold the staff above the well and feel the power of<br>Zamorak flow through you.', itemId=12658}. not skippable. TODO unimplemented.
			using items: none
			right-click options: none
			other: none

		removing:
			regular: impossible
			dropping: no charge loss

		message overlap:
			(u) and non-(u) probably both use the same messages. TODO
	 */
	IBANS_STAFF(new ChargedWeaponBuilder()
		.chargedItemIds(1409 /*IBANS_STAFF*/, 12658 /*IBANS_STAFF_U*/)
		.animationIds(708)
		.name("Iban's staff")
		.rechargeAmount(2500) /*120 for regular, 2500 for (u)*/ // TODO fix this for regular staff?
		.defaultLowChargeThreshold(250)
		.configKeyName("ibans_staff")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("You have ([\\d,]+) charges left on the staff.", 1),
			ChargesMessage.staticChargeMessage("You have a charge left on the staff.", 1),
			ChargesMessage.staticChargeMessage("You have no charges left on the staff.", 0)
		)
		.updateMessageChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage(Text.removeTags("<col=ef1020>Your staff only has ([\\d,]+) charges left.</col>"), 1),
			ChargesMessage.staticChargeMessage(Text.removeTags("<col=ef1020>Your staff has run out of charges.</col>"), 0),
			ChargesMessage.staticChargeMessage("You need to recharge your staff to use this spell.", 0)
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.sprite(Pattern.compile("You hold the staff above the well and feel the power of Zamorak flow through you."), null),
				ChargesDialogHandler.genericSpriteDialogFullChargeMessage()
			)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			//Ibans staff can be recharged for free at the well, or you can pay coins to the guy in West Ardougne.
			//For now assume users are recharging for free, in future consider exposing this as an option in config.
		})
	),
	WARPED_SCEPTRE(new ChargedWeaponBuilder()
			.chargedItemIds(28585 /*WARPED_SCEPTRE*/)
			.unchargedItemIds(28583 /*UNCHARGED_WARPED_SCEPTRE*/)
			.animationIds(10501)
			.name("Warped sceptre")
			.rechargeAmount(20_000)
			.configKeyName("warped_sceptre")
			.checkChargesRegexes(
					ChargesMessage.matcherGroupChargeMessage("Your warped sceptre has ([\\d,]+) charges remaining\\.", 1),
					ChargesMessage.staticChargeMessage("Your warped sceptre has 1 charge remaining\\.", 1),
					ChargesMessage.staticChargeMessage(Text.removeTags("<col=ff0000>Your warped sceptre has run out of charges!</col>"), 0)
			)
			.dialogHandlers(
					new ChargesDialogHandler(
							DialogStateMatcher.optionsOptionSelected(Pattern.compile("Fully uncharge your warped sceptre\\?"), null, Pattern.compile("Yes\\.")),
							ChargesDialogHandler.genericUnchargeDialog()
					),
					new ChargesDialogHandler(
							DialogStateMatcher.inputOptionSelected(Pattern.compile("How many charges do you want to add\\? \\(0 - ([\\d,]+)\\)"), null),
							ChargesDialogHandler.genericInputChargeMessage()
					),
					new ChargesDialogHandler(
							DialogStateMatcher.sprite(Pattern.compile("You add ([\\d,]+) charges? to your warped sceptre\\."), null),
							ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 1)
					),
					new ChargesDialogHandler(
							DialogStateMatcher.sprite(Pattern.compile("You add an additional ([\\d,]+) charges to your warped sceptre\\. It now has ([\\d,]+) charges in total\\."), null),
							ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 2)
					)
			)
			.updateChargeComponents((UpdateChargeComponentsParams params) ->
			{
				Integer charges = params.currentCharges;
				Map<Integer, Float> chargeComponents = params.chargeComponents;
	
				chargeComponents.put(ItemID.CHAOSRUNE, (float) charges * 2);
				chargeComponents.put(ItemID.EARTHRUNE, (float) charges * 5);
			})
	),

	/* Tridents
		Tridents all work the same way, afaik (only tested swap trident and partially seas trident).

		check:
			2022-05-04 12:37:05 [Client] INFO  com.weaponcharges.Devtools - 354: GAMEMESSAGE "Your Trident of the swamp (e) has 2,000 charges."
			2022-05-04 12:38:41 [Client] INFO  com.weaponcharges.Devtools - 514: GAMEMESSAGE "Your Trident of the swamp (e) has one charge."
			2022-05-04 12:40:27 [Client] INFO  com.weaponcharges.Devtools - 691: GAMEMESSAGE "Your Trident of the seas (e) has one charge."
			2022-05-04 12:40:36 [Client] INFO  com.weaponcharges.Devtools - 706: GAMEMESSAGE "Your Trident of the seas (e) has 1,001 charges."
			2022-05-04 07:08:09 [Client] INFO  com.weaponcharges.Devtools - 12: GAMEMESSAGE "Your Trident of the swamp has 6 charges."
			2022-05-04 07:09:59 [Client] INFO  com.weaponcharges.Devtools - 196: GAMEMESSAGE "Your Trident of the seas has one charge."
			2022-05-04 07:10:55 [Client] INFO  com.weaponcharges.Devtools - 288: GAMEMESSAGE "Your Trident of the seas has 2 charges."
			2022-05-04 07:13:15 [Client] INFO  com.weaponcharges.Devtools - 521: GAMEMESSAGE "Your Trident of the seas has 100 charges."

			// These are useless because the uncharged version has a different item id anyways.
			2022-05-04 12:36:51 [Client] INFO  com.weaponcharges.Devtools - 332: GAMEMESSAGE "Your Uncharged toxic trident (e) has no charges."
			2022-05-04 12:40:13 [Client] INFO  com.weaponcharges.Devtools - 667: GAMEMESSAGE "Your Uncharged trident (e) has no charges."

		periodic updates:
			2021-08-27 23:02:13 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - GAMEMESSAGE "<col=ef1020>Your trident only has 100 charges left!</col>"
		emptying by consuming charge:
			2021-08-27 22:59:08 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - GAMEMESSAGE "<col=ef1020>Your trident has run out of charges.</col>"
			attacking when empty: 2021-08-29 20:04:16 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 9740: GAMEMESSAGE "The weapon has no charges left. You need death runes, chaos runes, fire runes and Zulrah's scales to charge it." TODO unimplemented.

		adding:
			dialog, only non-skippable indication of charges added is the number the player inputs.
			2021-09-02 23:29:44 [AWT-EventQueue-0] INFO  com.weaponcharges.Devtools - 13154: option selected: "123" from NpcDialogState{INPUT, title='How many charges would you like to add? (0 - 2,477)', input='123'}
			(skippable) 2021-08-28 04:00:20 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - dialog state changed: NpcDialogState{SPRITE, text='You add a charge to the weapon.<br>New total: 2016'}
			The above message does not have a comma in the second number if the weapon is at max charges (tested with swamp trident, 2500).
			if adding only one charge because only 1 charge is in your inventory, or the item is 1 charge from full, it skips the dialog and goes straight to the skippable sprite dialog.
			2021-09-02 23:39:44 [Client] INFO  com.weaponcharges.Devtools - 14154: dialog state changed: NpcDialogState{SPRITE, text='You add 123 charges to the weapon.<br>New total: 246', itemId=12899}
			2021-08-29 18:08:48 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 368: dialog state changed: NpcDialogState{SPRITE, text='Your weapon is already fully charged.'}
			2021-08-29 18:13:57 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 882: dialog state changed: NpcDialogState{SPRITE, text='You uncharge your weapon.'}

		removing:
			dialog choice. the dialog that confirms the player's choice is skippable.
			seas trident: 2021-08-29 18:48:38 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 4334: dialog state changed: NpcDialogState{OPTIONS, text='You will NOT get the coins back.', options=[Okay, uncharge it., No, don't uncharge it.]}
			seas (e): presumably the same as seas.
			swamp trident: 2023-03-10 17:14:02 [Client] INFO  com.weaponcharges.Devtools - 2786: option selected: "Okay, uncharge it." from DialogState{OPTIONS, text='Really uncharge the Trident of the swamp?', options=[Okay, uncharge it., No, don't uncharge it.]}
			swamp (e): just adds " (e)" to it, according to a screenshot I recieved.
			dropping: 2021-08-29 19:03:59 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 5862: option selected: "Drop it." from NpcDialogState{OPTIONS, text='If you drop it, it will lose all its charges.', options=[Drop it., No, don't drop it.]} TODO unimplemented
				(the charge loss happens when you select "Drop it.".

		message overlap: all 4 tridents use the same messages except for the check messages.
	 */
	TRIDENT_OF_THE_SEAS(new ChargedWeaponBuilder()
		.chargedItemIds(11907 /*TRIDENT_OF_THE_SEAS*/)
		.unchargedItemIds(11908 /*UNCHARGED_TRIDENT*/)
		.animationIds(1167)
		.name("Trident of the seas")
		.rechargeAmount(2500)
		.configKeyName("trident_of_the_seas")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your Trident of the seas has ([\\d,]+) charges.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the seas has one charge.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the seas has no charges.", 0)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;

			chargeComponents.put(ItemID.DEATHRUNE, (float) charges);
			chargeComponents.put(ItemID.CHAOSRUNE, (float) charges);
			chargeComponents.put(ItemID.FIRERUNE, (float) charges * 5);
			chargeComponents.put(ItemID.COINS, (float) charges * 10);
		})
	),
	TRIDENT_OF_THE_SWAMP(new ChargedWeaponBuilder()
		.chargedItemIds(12899 /*TRIDENT_OF_THE_SWAMP*/)
		.unchargedItemIds(12900 /*UNCHARGED_TOXIC_TRIDENT*/)
		.animationIds(1167)
		.name("Trident of the swamp")
		.rechargeAmount(2500)
		.configKeyName("trident_of_the_swamp")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your Trident of the swamp has ([\\d,]+) charges.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the swamp has one charge.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the swamp has no charges.", 0)
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.optionsOptionSelected(Pattern.compile("Really uncharge the Trident of the swamp?"), null, Pattern.compile("Okay, uncharge it.")),
				ChargesDialogHandler.genericUnchargeDialog()
			)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;

			chargeComponents.put(ItemID.DEATHRUNE, (float) charges);
			chargeComponents.put(ItemID.CHAOSRUNE, (float) charges);
			chargeComponents.put(ItemID.FIRERUNE, (float) charges * 5);
			chargeComponents.put(ItemID.SNAKEBOSS_SCALE, (float) charges);
		})
	),
	TRIDENT_OF_THE_SEAS_E(new ChargedWeaponBuilder()
		.chargedItemIds(22288 /*TRIDENT_OF_THE_SEAS_E*/)
		.unchargedItemIds(22290 /*UNCHARGED_TRIDENT_E*/)
		.animationIds(1167)
		.name("Trident of the seas (e)")
		.rechargeAmount(10_000)
		.configKeyName("trident_of_the_seas_e")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your Trident of the seas \\(e\\) has ([\\d,]+) charges.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the seas \\(e\\) has one charge.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the seas \\(e\\) has no charges.", 0)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;

			chargeComponents.put(ItemID.DEATHRUNE, (float) charges);
			chargeComponents.put(ItemID.CHAOSRUNE, (float) charges);
			chargeComponents.put(ItemID.FIRERUNE, (float) charges * 5);
			chargeComponents.put(ItemID.COINS, (float) charges * 10);
		})
	),
	TRIDENT_OF_THE_SWAMP_E(new ChargedWeaponBuilder()
		.chargedItemIds(22292 /*TRIDENT_OF_THE_SWAMP_E*/)
		.unchargedItemIds(22294 /*UNCHARGED_TOXIC_TRIDENT_E*/)
		.animationIds(1167)
		.name("Trident of the swamp (e)")
		.rechargeAmount(10_000)
		.configKeyName("trident_of_the_swamp_e")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your Trident of the swamp \\(e\\) has ([\\d,]+) charges.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the swamp \\(e\\) has one charge.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the swamp \\(e\\) has no charges.", 0)
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.optionsOptionSelected(Pattern.compile("Really uncharge the Trident of the swamp (e)?"), null, Pattern.compile("Okay, uncharge it.")),
				ChargesDialogHandler.genericUnchargeDialog()
			)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;

			chargeComponents.put(ItemID.DEATHRUNE, (float) charges);
			chargeComponents.put(ItemID.CHAOSRUNE, (float) charges);
			chargeComponents.put(ItemID.FIRERUNE, (float) charges * 5);
			chargeComponents.put(ItemID.SNAKEBOSS_SCALE, (float) charges);
		})
	),
	//this can actually reach 20k charges if you combine two of them...
	ABYSSAL_TENTACLE(new ChargedWeaponBuilder()
		.chargedItemIds(12006 /*ABYSSAL_TENTACLE*/, 26484 /*ABYSSAL_TENTACLE_OR*/)
		.animationIds(1658)
		.name("Abyssal tentacle")
		.rechargeAmount(10_000)
		.configKeyName("abyssal_tentacle")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your abyssal tentacle can perform ([\\d,]+) more attacks.", 1)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;
			float whips = charges / 10000f;
			chargeComponents.put(ItemID.ABYSSAL_WHIP, whips);
		})
	),
	/* chally
		checking:
			full: unknown. TODO
			>1: 2021-08-29 18:38:45 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 3351: GAMEMESSAGE "Your crystal halberd has 278 charges remaining."
			1 charge: unknown. TODO
			0 charges: not possible, item degrades into seed.

		periodic updates:
			unknown TODO

		adding:
			using crystal shards on it. This does not have a game message. TODO unimplemented

		removing:
			attack/spec - 1 charge.
			reverting TODO unimplemented

		message overlap: none that I'm aware of.
	 */
	CRYSTAL_HALBERD(new ChargedWeaponBuilder()
		.chargedItemIds(23987 /*CRYSTAL_HALBERD*/)
		.unchargedItemIds() // TODO add proper empty halberd ID oh God help me
		.animationIds(428, 440, 1203)
		.name("Crystal halberd")
		.rechargeAmount(10_000/*TODO is this correct?*/)
		.defaultLowChargeThreshold(25)
		.configKeyName("crystal_halberd")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your crystal halberd has ([\\d,]+) charges remaining.", 1)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;
			//Assume cheapest cost per charge
			chargeComponents.put(ItemID.COINS, charges * 60f);

			//TODO: config for user to decide if they are using crystal shards vs paying ilfeen,
			// and see if i can find varbit for how many times ilfeen has recharged (since that affects cost per charge)
		})
	),

	/* Tome of fire:
		checking:
			// cannot check empty book, there is no such menu option.
			"Your tome currently holds 6,839 charges."
			"Your tome currently holds one charge."

		periodic updates:
			"Your Tome of Fire is now empty."

		adding:
			using pages on it, or using the "Pages" menu option and the associated dialog, auto-uses all and produces the same chat message as checking.

		removing:
			2021-08-26 16:35:43 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - GAMEMESSAGE "You remove a page from the book. Your tome currently holds 6,839 charges."
			2021-08-26 16:35:51 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - GAMEMESSAGE "You remove 2 pages from the book. Your tome currently holds 6,799 charges."
			2021-08-26 16:36:44 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - GAMEMESSAGE "You empty your book of pages."
			"You remove 299 pages from the book. Your tome currently holds one charge."

		message overlap: definitely overlaps with the tome of water.

		The tome of fire needs an additional check for fire spells being cast, which is done in onClientTick by checking for a gfx value.
	 */
	TOME_OF_FIRE(new ChargedWeaponBuilder()
		.chargedItemIds(20714 /*TOME_OF_FIRE*/)
		.unchargedItemIds(20716 /*TOME_OF_FIRE_EMPTY*/)
		.animationIds(711, 1162, 727, 1167, 7855)
		.name("Tome of fire")
		.rechargeAmount(20_000)
		.configKeyName("tome_of_fire")
		.updateMessageChargesRegexes(
			ChargesMessage.staticChargeMessage("Your Tome of Fire is now empty.", 0)
		)
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("You remove [\\S]+ pages? from the book. Your tome currently holds ([\\d,]+|one) charges?.", 1),
			ChargesMessage.matcherGroupChargeMessage("Your tome has been charged with (Burnt|Searing) Pages. It currently holds ([\\d,]+|one) charges?.", 2, (matcher, chargeCount, configManager) -> {
				configManager.setRSProfileConfiguration(GPPerHourConfig.GROUP, "tome_of_fire_page_type", matcher.group(1).contains("Searing") ? "searing" : "burnt");
				return chargeCount;
			})
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;
			float pages = charges / 20f;
			String tome_of_fire_page_type = params.configManager.getRSProfileConfiguration(GPPerHourConfig.GROUP, "tome_of_fire_page_type");
			//Default to burnt if migrating from previous version
			if (tome_of_fire_page_type == null)
				tome_of_fire_page_type = "burnt";
			boolean searing = tome_of_fire_page_type.equals("searing");
			chargeComponents.put(searing ? ItemID.WINT_SEARING_PAGE : ItemID.WINT_BURNT_PAGE, pages);
		})
	),
	/* Tome of water:
		checking:
			same as ToF

		periodic updates:
			"Your Tome of Water is now empty."

		adding:
		removing:
			same as ToF

		message overlap: definitely overlaps with the Tome of fire.

		The Tome of water needs an additional check for water and curse spells being cast, which is done in onClientTick by checking for a gfx value.
	 */
	TOME_OF_WATER(new ChargedWeaponBuilder()
		.chargedItemIds(25574 /*TOME_OF_WATER*/)
		.unchargedItemIds(25576 /*TOME_OF_WATER_EMPTY*/)
		.animationIds(1161 /*bind/snare/entangle*/, 1162 /*strike/bolt/blast*/, 1163 /*confuse*/, 1164 /*weaken*/, 1165 /*curse/vulnerability*/, 1167 /*wave*/, 1168 /*enfeeble*/, 1169 /*stun*/, 7855 /*surge*/)
		.name("Tome of water")
		.rechargeAmount(20_000)
		.configKeyName("tome_of_water")
		.updateMessageChargesRegexes(
			ChargesMessage.staticChargeMessage("Your Tome of Water is now empty.", 0)
		)
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("(You remove [\\S]+ pages? from the book. )?Your tome currently holds ([\\d,]+) charges.", 2),
			ChargesMessage.staticChargeMessage("(You remove [\\S]+ pages? from the book. )?Your tome currently holds one charge.", 1)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;
			float pages = charges / 20f;
			chargeComponents.put(ItemID.SOAKED_PAGE, pages);
		})
	),
	/* scythe
		check (full, <full & >1, 1, 0/empty):
			full: TODO
			>1: "Your Scythe of vitur has 19,529 charges remaining."
				2022-05-02 14:40:15 [Client] INFO  com.weaponcharges.Devtools - 3388: GAMEMESSAGE "Your Sanguine scythe of vitur has 2,056 charges remaining."
			1: TODO
			empty: TODO

		periodic updates (periodic, empty):
			periodic: TODO
			empty: TODO
			attacking when empty: TODO

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			using items: (input) "How many sets of 100 charges do you wish to apply? (Up to 173)" TODO
				receipt dialog: (sprite dialog, unknown id) "You apply 17,300 charges to your Scythe of vitur." TODO
			right-click options: TODO
			other: TODO

		removing (regular removal methods, dropping:
			regular: (sprite dialog, unknown id) "If you uncharge your scythe into the well, 17,300<br>charges will be added to the well." TODO
				receipt dialog: (sprite dialog, unknown id) "You uncharge your scythe into the well. It now<br>contains 173 sets of 100 charges." probably redundant.
			dropping: TODO

		message overlap:
			TODO
	 */
	SCYTHE_OF_VITUR(new ChargedWeaponBuilder()
		// TODO some kind of optional graphic to show when a scythe is uncharged? like a "(u)" that shows up on the item.
		.chargedItemIds(22325 /*SCYTHE_OF_VITUR*/, 25736 /*HOLY_SCYTHE_OF_VITUR*/, 25739 /*SANGUINE_SCYTHE_OF_VITUR*/)
		.unchargedItemIds(22486 /*SCYTHE_OF_VITUR_UNCHARGED*/, 25738 /*HOLY_SCYTHE_OF_VITUR_UNCHARGED*/, 25741 /*SANGUINE_SCYTHE_OF_VITUR_UNCHARGED*/)
		.animationIds(8056)
		.name("Scythe of vitur")
		.rechargeAmount(20_000)
		.configKeyName("scythe_of_vitur")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your (Sanguine s|Holy s|S)cythe of vitur has ([\\d,]+) charges remaining.", 2)
		)
		.updateMessageChargesRegexes( // TODO one of these would be really good.
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.inputOptionSelected(Pattern.compile("How many sets of 100 charges do you wish to apply\\? \\(Up to ([\\d,]+)\\)"), null),
				(matchers, dialogState, optionSelected, plugin) -> {
					String chargeCountString = matchers.getNameMatcher().group(1).replaceAll(",", "");
					int maxChargeCount = Integer.parseInt(chargeCountString);
					int chargesEntered;
					try {
						chargesEntered = Integer.parseInt(optionSelected.replaceAll("k", "000").replaceAll("m", "000000").replaceAll("b", "000000000"));
					} catch (NumberFormatException e) {
						// can happen if the input is empty for example.
						return;
					}

					if (chargesEntered > maxChargeCount) {
						chargesEntered = maxChargeCount;
					}

					plugin.addCharges(get_scythe_circumvent_illegal_self_reference(), chargesEntered * 100, true);
				}
			),
//			new ChargesDialogHandler(
//				DialogStateMatcher.sprite(Pattern.compile("You apply ([\\d,]+) charges to your (Sanguine s|Holy s|S)cythe of vitur."), null /* TODO find out what this should be */),
//				ChargesDialogHandler.genericSpriteDialogChargesMessage(false, 1)
//			),
			new ChargesDialogHandler(
				DialogStateMatcher.spriteOptionSelected(Pattern.compile("If you uncharge your scythe into the well, ([\\d,]+) charges will be added to the well."), null /* TODO find out what this should be */),
				ChargesDialogHandler.genericSpriteDialogUnchargeMessage()
			)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;
			float vials = charges / 100f;
			chargeComponents.put(ItemID.MYQ4_BLOOD_VIAL, vials);
			chargeComponents.put(ItemID.BLOODRUNE, charges * 3f);
		})
	),
	/* blood fury
		check (full, <full & >1, 1, 0/empty):
			full: "Your Amulet of blood fury will work for 30,000 more hits." TODO unimplemented, copied from screenshot
			>1: GAMEMESSAGE "Your Amulet of blood fury will work for 9,016 more hits." TODO unimplemented
			1: TODO
			empty: TODO

		periodic updates (periodic, empty):
			periodic: TODO
			empty: TODO
			attacking when empty: TODO

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			using items: TODO
			right-click options: TODO
			other: TODO
			TODO overcharge warning, different text?

		removing (regular removal methods, dropping:
			regular: TODO
			dropping: TODO

		message overlap:
			TODO

		How to track? either xp drop + hitsplats if it's possible to always see all of your own hitsplats, or xp drop + animation.
	 */
	BLOOD_FURY(new ChargedWeaponBuilder()
		.chargedItemIds(ItemID.BLOOD_AMULET)
		.name("Amulet of Blood Fury")
		.configKeyName("amulet_of_blood_fury")
		.updateMessageChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your Amulet of blood fury can perform ([\\d,]+) more hits.", 1)
		)
		.checkChargesRegexes(
			ChargesMessage.staticChargeMessage("You have successfully created an Amulet of blood fury.", 10_000),
			ChargesMessage.matcherGroupChargeMessage("Your Amulet of blood fury will work for ([\\d,]+) more hits.", 1)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;
			float shards = charges / 10_000f;
			chargeComponents.put(ItemID.BLOOD_SHARD, shards);
		})
	),
	//Venator Bow
	VENATOR_BOW(new ChargedWeaponBuilder()
		.chargedItemIds(ItemID.VENATOR_BOW)
		.unchargedItemIds(ItemID.VENATOR_BOW_UNCHARGED)
		.animationIds(9858)
		.name("Venator bow")
		.configKeyName("venator_bow")
		.updateMessageChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your Venator bow has ([\\d,]+) charges remaining.", 1)
		)
		.checkChargesRegexes(
			//Yep, same as the automatic message but with a lowercase 'v'.
			ChargesMessage.matcherGroupChargeMessage("Your venator bow has ([\\d,]+) charges remaining.", 1)
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.sprite(Pattern.compile("You use ([\\d,]+) ancient essence to charge your venator bow. It now has ([\\d,]+) charges."), null),
				ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 2)
			)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
				{ params.chargeComponents.put(ItemID.ANCIENT_ESSENCE, (float) params.currentCharges); })
	),
	/* sang staff
		check (full, <full & >1, 1, 0/empty):
			full: GAMEMESSAGE "Your Sanguinesti staff is already fully charged."
			>1: GAMEMESSAGE "Your Sanguinesti staff has 1,000 charges remaining."
				2022-05-02 14:40:16 [Client] INFO  com.weaponcharges.Devtools - 3390: GAMEMESSAGE "Your Holy sanguinesti staff has 144 charges remaining."
			1: GAMEMESSAGE "Your Sanguinesti staff has 1 charges remaining."
			empty: no option when uncharged

		periodic updates (periodic, empty):
			periodic: GAMEMESSAGE "Your Sanguinesti staff has 200 charges remaining."
			low: "<col=ef1020>Your Sanguinesti staff only has 100 charges left!</col>"
			empty: GAMEMESSAGE "Your Sanguinesti staff has run out of charges."
			attacking when empty: GAMEMESSAGE "Your sanguinesti staff has no charges! You need to charge it with blood runes."

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			using items:
			right-click options:
			DialogState{INPUT, title='How many charges do you want to apply? (Up to 1,033)', input='1'}
			DialogState{SPRITE, text='You apply 1 charges to your Sanguinesti staff.', itemId=22323}
			DialogState{SPRITE, text='You apply an additional 33 charges to your Sanguinesti<br>staff. It now has 1,033 charges in total.', itemId=22323}
			other:

		removing (regular removal methods, dropping:
			regular: DialogState{OPTIONS, text='Uncharge your staff for all its charges? (regaining 3 blood runes)', options=[Proceed., Cancel.]}
				receipt: DialogState{SPRITE, text='You uncharge your Sanguinesti staff, regaining 3 blood<br>runes in the process.', itemId=22481}
			dropping: not droppable while charged

		message overlap:
			none afaik
	 */
	SANGUINESTI_STAFF(new ChargedWeaponBuilder()
		.chargedItemIds(22323 /*SANGUINESTI_STAFF*/, 25731 /*HOLY_SANGUINESTI_STAFF*/)
		.unchargedItemIds(22481 /*SANGUINESTI_STAFF_UNCHARGED*/, 25733 /*HOLY_SANGUINESTI_STAFF_UNCHARGED*/)
		.animationIds(1167)
		.name("Sanguinesti staff")
		.rechargeAmount(20_000)
		.configKeyName("sanguinesti_staff")
		.checkChargesRegexes(
			ChargesMessage.staticChargeMessage("Your (Holy s|S)anguinesti staff is already fully charged.", 20000)
			// Some check messages omitted because they are the same as update messages.
		)
		.updateMessageChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your (Holy s|S)anguinesti staff has ([\\d,]+) charges remaining.", 2),
			ChargesMessage.matcherGroupChargeMessage(Text.removeTags("<col=ef1020>Your (Holy s|S)anguinesti staff only has ([\\d,]+) charges left!</col>"), 2),
			ChargesMessage.staticChargeMessage("Your (Holy s|S)anguinesti staff has run out of charges.", 0)
			// ChargesMessage.staticChargeMessage("Your sanguinesti staff has no charges! You need to charge it with blood runes.", 0) // (sic) sang is not capitalized. bug report sent to os team
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.optionsOptionSelected(Pattern.compile("Uncharge your staff for all its charges\\? \\(regaining [\\d,]+ blood runes\\)"), null, Pattern.compile("Proceed.")),
				ChargesDialogHandler.genericUnchargeDialog()
			),
			new ChargesDialogHandler(
				DialogStateMatcher.inputOptionSelected(Pattern.compile("How many charges do you want to apply\\? \\(Up to ([\\d,]+)\\)"), null),
				ChargesDialogHandler.genericInputChargeMessage()
			),
			new ChargesDialogHandler(
				DialogStateMatcher.sprite(Pattern.compile("You apply ([\\d,]+) charges to your (Holy s|S)anguinesti staff."), null),
				ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 1)
			),
			new ChargesDialogHandler(
				DialogStateMatcher.sprite(Pattern.compile("You apply an additional ([\\d,]+) charges to your (Holy s|S)anguinesti staff. It now has ([\\d,]+) charges in total."), null),
				ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 3)
			)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			params.chargeComponents.put(ItemID.BLOODRUNE, params.currentCharges * 3f);
		})
	),
	/* arclight
		check (full, <full & >1, 1, 0/empty):
			full: TODO
			>1: "Your arclight has 6397 charges left."
			1: TODO
			empty: TODO

		periodic updates (periodic, empty):
			periodic: TODO
			empty: TODO
			attacking when empty: TODO

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			using items: TODO
			right-click options: TODO
			other: TODO

		removing (regular removal methods, dropping:
			regular: TODO
			dropping: TODO

		message overlap:
			TODO
	 */
	ARCLIGHT(new ChargedWeaponBuilder()
		.chargedItemIds(19675 /*ARCLIGHT*/)
		.animationIds(386, 390)
		.name("Arclight")
		.rechargeAmount(10_000)
		.configKeyName("arclight")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your arclight has ([\\d,]+) charges left.", 1)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;
			float shards = charges / 333f;
			chargeComponents.put(ItemID.CATA_SHARD, shards);
		})
	),
	/* Ether Weapon common
		check (full, <full & >1, 1, 0/empty):
			<weapon> is chainmace, sceptre, or bow (THIS CHECK SECTION ONLY)
			full: "Your <weapon> has 16,000 charges left powering it."
			>1: "Your <weapon> has 666 charges left powering it."
			1: "Your <weapon> has 1 charge left powering it."
			empty: "Your <weapon> has 0 charges left powering it."

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			using items:
				GAMEMESSAGE "You require at least 1000 revenant ether to activate this weapon."
				GAMEMESSAGE "You use 1000 ether to activate the weapon."
				GAMEMESSAGE "You add a further 16,000 revenant ether to your weapon, giving it a total of 16,000 charges."
			right-click options: n/a
			other: n/a

		periodic updates (periodic, empty):
			periodic:
				GAMEMESSAGE "Your weapon has 1,000 charges remaining."
				GAMEMESSAGE "Your weapon has 500 charges remaining."
				GAMEMESSAGE "<col=ef1020>Your weapon only has 100 charges left.</col>"
				GAMEMESSAGE "<col=ef1020>Your weapon only has 50 charges left.</col>"
			empty: GAMEMESSAGE "<col=ef1020>Your weapon has run out of revenant ether.</col>"

		removing (regular removal methods, dropping:
			uncharge: widget doesn't show in the logger
				Are you sure you want to uncharge it?
				<Weapon> Yes No
				If you uncharge this weapon, all the revenant ether will be returned to your inventory.
			dropping: no drop option while charged
	 */

	/* Craw's bow
		attacking when empty: GAMEMESSAGE "There is not enough revenant ether left powering your bow."

		message overlap:
			see Ether Weapon common
	 */
	CRAWS(new ChargedWeaponBuilder()
		.chargedItemIds(22550 /*CRAWS_BOW*/)
		.unchargedItemIds(22547 /*CRAWS_BOW_U*/)
		.animationIds(426)
		.name("Craw's bow")
		.rechargeAmount(16_000)
		.configKeyName("craws_bow")
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
				{ params.chargeComponents.put(ItemID.WILD_CAVE_SHARD, (float) params.currentCharges); })
	),
	WEBWEAVER(new ChargedWeaponBuilder()
		.chargedItemIds(27655 /*WEBWEAVER_BOW*/)
		.unchargedItemIds(27652 /*WEBWEAVER_BOW_U*/)
		.name("Webweaver bow")
		.animationIds(426)
		.rechargeAmount(16_000)
		.configKeyName("webweaver_bow")
		.settingsConfigKey("craws_bow")
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
				{ params.chargeComponents.put(ItemID.WILD_CAVE_SHARD, (float) params.currentCharges); })
	),
	/* Vigorra's chainmace
		message overlap:
			see Ether Weapon common
	 */
	VIGGORAS(new ChargedWeaponBuilder()
		.chargedItemIds(22545 /*VIGGORAS_CHAINMACE*/)
		.unchargedItemIds(22542 /*VIGGORAS_CHAINMACE_U*/)
		.animationIds(245)
		.name("Viggora's chainmace")
		.rechargeAmount(16_000)
		.configKeyName("viggoras_chainmace")
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
				{ params.chargeComponents.put(ItemID.WILD_CAVE_SHARD, (float) params.currentCharges); })
	),
	URSINE (new ChargedWeaponBuilder()
		.chargedItemIds(27660 /*URSINE_CHAINMACE*/)
		.unchargedItemIds(27657 /*URSINE_CHAINMACE_U*/)
		.name("Ursine chainmace")
		.animationIds(245)
		.rechargeAmount(16_000)
		.configKeyName("ursine_chainmace")
		.settingsConfigKey("viggoras_chainmace")
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
				{ params.chargeComponents.put(ItemID.WILD_CAVE_SHARD, (float) params.currentCharges); })
	),
	/* Thammaron's sceptre
		message overlap:
			see Ether Weapon common
	 */
	THAMMARONS(new ChargedWeaponBuilder()
		.chargedItemIds(22555 /*THAMMARONS_SCEPTRE*/, 27788 /*THAMMARONS_SCEPTRE_A*/)
		.unchargedItemIds(22552 /*THAMMARONS_SCEPTRE_U*/, 27785 /*THAMMARONS_SCEPTRE_AU*/)
		.name("Thammaron's sceptre")
		.animationIds(1167,1978,1979,1162,1167,7855,811)
		.rechargeAmount(16_000)
		.configKeyName("thammarons_sceptre")
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
				{ params.chargeComponents.put(ItemID.WILD_CAVE_SHARD, (float) params.currentCharges); })
	),
	ACCURSED(new ChargedWeaponBuilder()
		.chargedItemIds(27665 /*ACCURSED_SCEPTRE*/, 27679 /*ACCURSED_SCEPTRE_A*/)
		.unchargedItemIds(27662 /*ACCURSED_SCEPTRE_U*/, 27676 /*ACCURSED_SCEPTRE_AU*/)
		.name("Accursed sceptre")
		//1178 1179 Ancient
		//1162,1167,7855,811 Standard
		// Support for charge count for autocasting spell, manual casting non-combat spell will still not be tracked
		.animationIds(1167,1978,1979,1162,1167,7855,811)
		.rechargeAmount(16_000)
		.configKeyName("accursed_sceptre")
		.settingsConfigKey("thammarons_sceptre")
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
				{ params.chargeComponents.put(ItemID.WILD_CAVE_SHARD, (float) params.currentCharges); })
	),
	/*
	check:
2022-06-12 20:17:48 [Client] INFO  com.weaponcharges.Devtools - 939: GAMEMESSAGE "Your crystal bow has 299 charges remaining."
	update:
		there may be no message; I didn't see one at 100 charges.
	 */
	CRYSTAL_BOW(new ChargedWeaponBuilder() // crystal bow, for ctrl-f
		.chargedItemIds(23983 /*CRYSTAL_BOW*/)
		.animationIds(426)
		.name("Crystal bow")
		.configKeyName("crystal_bow")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your crystal bow has ([\\d,]+) charges remaining.", 1)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;
			//Assume cheapest cost per charge
			chargeComponents.put(ItemID.COINS, charges * 72f);

			//TODO: config for user to decide if they are using crystal shards vs paying ilfeen,
			// and see if i can find varbit for how many times ilfeen has recharged (since that affects cost per charge)
		})
	),
	/*
	check:
2022-06-07 12:47:57 [Client] INFO  com.weaponcharges.Devtools - 76: GAMEMESSAGE "Your bow of Faerdhinen has 180 charges remaining."
	update:
2022-06-07 18:53:09 [Client] INFO  com.weaponcharges.Devtools - 3353: GAMEMESSAGE "<col=ff0000>Your bow of Faerdhinen has 100 charges remaining.</col>"
	 */
	BOW_OF_FAERDHINEN(new ChargedWeaponBuilder() // bofa bowfa, for ctrl-f :)
		.chargedItemIds(25865 /*BOW_OF_FAERDHINEN*/)
		.unchargedItemIds(25862 /*BOW_OF_FAERDHINEN_INACTIVE*/)
		.animationIds(426)
		.name("Bow of faerdhinen")
		.configKeyName("bow_of_faerdhinen")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your bow of Faerdhinen has ([\\d,]+) charges remaining.", 1)
		)
		.updateMessageChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage(Text.removeTags("<col=ff0000>Your bow of Faerdhinen has ([\\d,]+) charges remaining.</col>"), 1)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			float shards = charges / 100f;
			params.chargeComponents.put(ItemID.PRIF_CRYSTAL_SHARD, shards);
		})
	),
	/* 
	BLADE_OF_SAELDOR(new ChargedWeaponBuilder()
		.chargedItemIds(ItemID.BLADE_OF_SAELDOR)
		.unchargedItemIds(ItemID.BLADE_OF_SAELDOR_INACTIVE)
		.animationIds(386, 390)
		.name("Blade of saeldor")
		.configKeyName("blade_of_saeldor")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your Blade of Saeldor has ([\\d,]+) charges remaining.", 1)
		)
		.updateMessageChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage(Text.removeTags("<col=ff0000>Your Blade of Saeldor has ([\\d,]+) charges remaining.</col>"), 1)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			float shards = charges / 100f;
			params.chargeComponents.put(ItemID.CRYSTAL_SHARD, shards);
		})
	),*/
	/*
	crystal armor
	check:
2022-06-07 12:47:59 [Client] INFO  com.weaponcharges.Devtools - 78: GAMEMESSAGE "Your crystal helm has 1,011 charges remaining."
2022-06-07 12:47:59 [Client] INFO  com.weaponcharges.Devtools - 79: GAMEMESSAGE "Your crystal body has 996 charges remaining."
2022-06-07 12:48:00 [Client] INFO  com.weaponcharges.Devtools - 81: GAMEMESSAGE "Your crystal legs has 982 charges remaining."
	 */
	CRYSTAL_HELM(new ChargedWeaponBuilder()
		.chargedItemIds(23971 /*CRYSTAL_HELM*/, 27705 /*CRYSTAL_HELM_27705*/, 27717 /*CRYSTAL_HELM_27717*/, 27729 /*CRYSTAL_HELM_27729*/, 27741 /*CRYSTAL_HELM_27741*/, 27753 /*CRYSTAL_HELM_27753*/, 27765 /*CRYSTAL_HELM_27765*/, 27777 /*CRYSTAL_HELM_27777*/)
		.unchargedItemIds(23973 /*CRYSTAL_HELM_INACTIVE*/, 27707 /*CRYSTAL_HELM_INACTIVE_27707*/, 27719 /*CRYSTAL_HELM_INACTIVE_27719*/, 27731 /*CRYSTAL_HELM_INACTIVE_27731*/, 27743 /*CRYSTAL_HELM_INACTIVE_27743*/, 27755 /*CRYSTAL_HELM_INACTIVE_27755*/, 27767 /*CRYSTAL_HELM_INACTIVE_27767*/, 27779 /*CRYSTAL_HELM_INACTIVE_27779*/)
		.name("Crystal armour")
		.configKeyName("crystal_helm")
		.settingsConfigKey("crystal_armour")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your crystal helm has ([\\d,]+) charges remaining.", 1)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;
			float shards = charges / 100f;
			chargeComponents.put(ItemID.PRIF_CRYSTAL_SHARD, shards);
		})
	),
	CRYSTAL_BODY(new ChargedWeaponBuilder()
		.chargedItemIds(23975 /*CRYSTAL_BODY*/, 27697 /*CRYSTAL_BODY_27697*/, 27709 /*CRYSTAL_BODY_27709*/, 27721 /*CRYSTAL_BODY_27721*/, 27733 /*CRYSTAL_BODY_27733*/, 27745 /*CRYSTAL_BODY_27745*/, 27757 /*CRYSTAL_BODY_27757*/, 27769 /*CRYSTAL_BODY_27769*/)
		.unchargedItemIds(23977 /*CRYSTAL_BODY_INACTIVE*/, 27699 /*CRYSTAL_BODY_INACTIVE_27699*/, 27711 /*CRYSTAL_BODY_INACTIVE_27711*/, 27723 /*CRYSTAL_BODY_INACTIVE_27723*/, 27735 /*CRYSTAL_BODY_INACTIVE_27735*/, 27747 /*CRYSTAL_BODY_INACTIVE_27747*/, 27759 /*CRYSTAL_BODY_INACTIVE_27759*/, 27771 /*CRYSTAL_BODY_INACTIVE_27771*/)
		.name("Crystal armour")
		.configKeyName("crystal_body")
		.settingsConfigKey("crystal_armour")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your crystal body has ([\\d,]+) charges remaining.", 1)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;
			float shards = charges / 100f;
			chargeComponents.put(ItemID.PRIF_CRYSTAL_SHARD, shards);
		})
	),
	CRYSTAL_LEGS(new ChargedWeaponBuilder()
		.chargedItemIds(23979 /*CRYSTAL_LEGS*/, 27701 /*CRYSTAL_LEGS_27701*/, 27713 /*CRYSTAL_LEGS_27713*/, 27725 /*CRYSTAL_LEGS_27725*/, 27737 /*CRYSTAL_LEGS_27737*/, 27749 /*CRYSTAL_LEGS_27749*/, 27761 /*CRYSTAL_LEGS_27761*/, 27773 /*CRYSTAL_LEGS_27773*/)
		.unchargedItemIds(23981 /*CRYSTAL_LEGS_INACTIVE*/, 27703 /*CRYSTAL_LEGS_INACTIVE_27703*/, 27715 /*CRYSTAL_LEGS_INACTIVE_27715*/, 27727 /*CRYSTAL_LEGS_INACTIVE_27727*/, 27739 /*CRYSTAL_LEGS_INACTIVE_27739*/, 27751 /*CRYSTAL_LEGS_INACTIVE_27751*/, 27763 /*CRYSTAL_LEGS_INACTIVE_27763*/, 27775 /*CRYSTAL_LEGS_INACTIVE_27775*/)
		.name("Crystal armour")
		.configKeyName("crystal_legs")
		.settingsConfigKey("crystal_armour")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your crystal legs has ([\\d,]+) charges remaining.", 1)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;
			float shards = charges / 100f;
			chargeComponents.put(ItemID.PRIF_CRYSTAL_SHARD, shards);
		})
	),
	/* Serpentine Helmet:
	degradation mechanics:
		-10 Scales when taking or dealing damage, and it has been more than 90 ticks (i.e. minimum 91) since the last time scales were removed.
		- taking or dealing damage is generally approximated by hitsplats dealt to or dealt by the player.
			- ranged attacks cause the helmet to degrade sometimes before the hitsplat it seems. This is not taken into account by this plugin.
			- splashes do not degrade it.
			- unknown how enemy ranged attacks and splashes interact with this.
		- the 90-tick timer is shared by barrows items - e.g. you could avoid all scale loss by having barrows items equipped and unequipping the serp helm at the right time.

    notes:
        Number = ([\\d,]+)
        Percent = \\(\\d+[.]?\\d%\\)

    check (full, <full & >1, 1, 0/empty):
        full: 2022-06-20 15:31:21 [Client] INFO  com.weaponcharges.Devtools - 562: GAMEMESSAGE "Scales: <col=007f00>11,000 (100.0%)</col>"
        >1: 2022-06-20 15:32:14 [Client] INFO  com.weaponcharges.Devtools - 650: GAMEMESSAGE "Scales: <col=007f00>5 (0.1%)</col>"
        1: 2022-06-20 15:33:02 [Client] INFO  com.weaponcharges.Devtools - 730: GAMEMESSAGE "Scales: <col=007f00>1 (0.1%)</col>"
        empty: None

    periodic updates (periodic, empty):
        periodic: TODO
        empty: 2022-06-20 18:19:29 [Client] INFO  com.weaponcharges.Devtools - 8380: GAMEMESSAGE "Your serpentine helm has run out of Zulrah's scales."
        attacking when empty: TODO

    adding (adding by using items on the weapon, adding via right-click option, any other methods):
        using items: 2022-06-20 15:40:12 [Client] INFO  com.weaponcharges.Devtools - 1438: GAMEMESSAGE "Scales: <col=007f00>5 (0.1%)</col>"
        right-click options: None
        other: None

    removing (regular removal methods, dropping):
        regular: None
        dropping: None

    message overlap:
        TODO
	*/
	SERPENTINE_HELM(new ChargedWeaponBuilder()
		.chargedItemIds(12931 /*SERPENTINE_HELM*/, 13197 /*TANZANITE_HELM*/, 13199 /*MAGMA_HELM*/)
		.unchargedItemIds(12929 /*SERPENTINE_HELM_UNCHARGED*/, 13196 /*TANZANITE_HELM_UNCHARGED*/, 13198 /*MAGMA_HELM_UNCHARGED*/)
		.name("Serpentine helm")
		.rechargeAmount(11_000)
		.configKeyName("serpentine_helm")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage(Text.removeTags("^Scales: <col=007f00>([\\d,]+) (\\(\\d+[.]?\\d%\\))</col>$"), 1)
		)
		.updateMessageChargesRegexes(
			ChargesMessage.staticChargeMessage("Your serpentine helm has run out of Zulrah's scales.", 0),
			ChargesMessage.staticChargeMessage("Your tanzanite helm has run out of Zulrah's scales.", 0),
			ChargesMessage.staticChargeMessage("Your magma helm has run out of Zulrah's scales.", 0)
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.inputOptionSelected(Pattern.compile("How many scales would you like to use\\? \\(0 - ([\\d,]+)\\)"), null),
				ChargesDialogHandler.genericInputChargeMessage()
			)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
				{ params.chargeComponents.put(ItemID.SNAKEBOSS_SCALE, (float) params.currentCharges); })
	),
	/* Tumeken's shadow
		https://github.com/geheur/weapon-charges/issues/14 log here.
		check (full, <full & >1, 1, 0/empty):
			full:
			>1: GAMEMESSAGE "Tumeken's shadow has 99 charges remaining."
			1:
			empty: GAMEMESSAGE "Tumeken's Shadow has no charges! You need to charge it with soul runes and chaos runes." // TODO is this one actually from checking?

		periodic updates (periodic, empty):
			periodic: GAMEMESSAGE "Tumeken's shadow has 200 charges remaining."
			low: GAMEMESSAGE "<col=e00a19>Tumeken's shadow only has 100 charges left!</col>"
			empty: GAMEMESSAGE "Tumeken's shadow has run out of charges."

			TODO check used on item id to see if he used it on an uncharged staff.

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			using items:
234589: used 566 on 27277
234590: dialog state changed: DialogState{INPUT, title='How many charges do you want to apply? (Up to 994)', input=''}
234592: option selected: "201" from DialogState{INPUT, title='How many charges do you want to apply? (Up to 994)', input=''}
234592: dialog state changed: DialogState{NO_DIALOG}
234593: dialog state changed: DialogState{SPRITE, text='You apply 201 charges to your Tumeken's shadow.', itemId=27275}
234594: option selected: "null" from DialogState{SPRITE, text='You apply 201 charges to your Tumeken's shadow.', itemId=27275}
234595: dialog state changed: DialogState{NO_DIALOG}

234643: used 566 on 27275
234643: dialog state changed: DialogState{INPUT, title='How many charges do you want to apply? (Up to 793)', input=''}
234645: dialog state changed: DialogState{INPUT, title='How many charges do you want to apply? (Up to 793)', input='301'}
234646: option selected: "301" from DialogState{INPUT, title='How many charges do you want to apply? (Up to 793)', input='301'}
234646: dialog state changed: DialogState{SPRITE, text='You apply an additional 301 charges to your<br>Tumeken's shadow. It now has 498 charges in total.', itemId=27275}
234648: dialog state changed: DialogState{NO_DIALOG}

234692: dialog state changed: DialogState{SPRITE, text='You apply 1 charges to your Tumeken's shadow.', itemId=27275}
			right-click options:
			// TODO there is a "Charge" option but I haven't seen it used.
			other:

		removing (regular removal methods, dropping:
234582: dialog state changed: DialogState{OPTIONS, text='Uncharge all the charges from your staff?', options=[Proceed., Cancel.]}
234584: option selected: "Proceed." from DialogState{OPTIONS, text='Uncharge all the charges from your staff?', options=[Proceed., Cancel.]}
234584: dialog state changed: DialogState{SPRITE, text='You uncharge your Tumeken's shadow, regaining 198<br>soul runes and 495 chaos runes in the process.', itemId=27277}
234586: option selected: "null" from DialogState{SPRITE, text='You uncharge your Tumeken's shadow, regaining 198<br>soul runes and 495 chaos runes in the process.', itemId=27277}
234586: dialog state changed: DialogState{NO_DIALOG}
	 */
	TUMEKENS_SHADOW(new ChargedWeaponBuilder()
		.chargedItemIds(27275 /*TUMEKENS_SHADOW*/)
		.unchargedItemIds(27277 /*TUMEKENS_SHADOW_UNCHARGED*/)
		.animationIds(9493)
		.name("Tumeken's shadow")
		.rechargeAmount(20_000)
		.configKeyName("tumekens_shadow")
		.checkChargesRegexes(
			ChargesMessage.staticChargeMessage("Your Tumeken's shadow is already fully charged.", 20000) // I guessed this one.
			// Some check messages omitted because they are the same as update messages.
		)
		.updateMessageChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Tumeken's shadow has ([\\d,]+) charges remaining.", 1),
			ChargesMessage.matcherGroupChargeMessage(Text.removeTags("<col=e00a19>Tumeken's shadow only has ([\\d,]+) charges left!</col>"), 1),
			ChargesMessage.staticChargeMessage("Tumeken's shadow has run out of charges.", 0)
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.optionsOptionSelected(Pattern.compile("Uncharge all the charges from your staff?"), null, Pattern.compile("Proceed.")),
				ChargesDialogHandler.genericUnchargeDialog()
			),
			new ChargesDialogHandler(
				DialogStateMatcher.inputOptionSelected(Pattern.compile("How many charges do you want to apply\\? \\(Up to ([\\d,]+)\\)"), null),
				ChargesDialogHandler.genericInputChargeMessage()
			),
			new ChargesDialogHandler(
				DialogStateMatcher.sprite(Pattern.compile("You apply ([\\d,]+) charges to your Tumeken's shadow."), null),
				ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 1)
			),
			new ChargesDialogHandler(
				DialogStateMatcher.sprite(Pattern.compile("You apply an additional ([\\d,]+) charges to your Tumeken's shadow. It now has ([\\d,]+) charges in total."), null),
				ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 2)
			)
		)
		.updateChargeComponents((UpdateChargeComponentsParams params) ->
		{
			Integer charges = params.currentCharges;
			Map<Integer, Float> chargeComponents = params.chargeComponents;
			chargeComponents.put(ItemID.SOULRUNE, charges * 2f);
			chargeComponents.put(ItemID.CHAOSRUNE, charges * 5f);
		})
	),
	/**
	 * Only used to access settings. Lots of things in the blowpipe are handled specially because it holds two kinds of
	 * charges: darts and scales.
	 */
	TOXIC_BLOWPIPE(new ChargedWeaponBuilder()
		.chargedItemIds(ItemID.TOXIC_BLOWPIPE_LOADED, ItemID.TOXIC_BLOWPIPE_LOADED_ORNAMENT)
		.name("Toxic blowpipe")
		.settingsConfigKey("blowpipe")
	),
	;

	public static final List<ChargedWeapon> CRYSTAL_SHARD_RECHARGABLE_ITEMS = Arrays.asList(CRYSTAL_BOW, CRYSTAL_HELM, CRYSTAL_BODY, CRYSTAL_LEGS, BOW_OF_FAERDHINEN, CRYSTAL_HALBERD);

	@Getter
	private static final List<ChargesMessage> nonUniqueCheckChargesRegexes = Arrays.asList(
		// ether weapons
		ChargesMessage.matcherGroupChargeMessage("Your weapon has ([\\d,]+) charges.", 1),
		ChargesMessage.matcherGroupChargeMessage("Your bow has ([\\d,]+) charges? left powering it.", 1),
		ChargesMessage.matcherGroupChargeMessage("Your chainmace has ([\\d,]+) charges? left powering it.", 1),
		ChargesMessage.matcherGroupChargeMessage("Your sceptre has ([\\d,]+) charges? left powering it.", 1),
		//ChargesMessage.staticChargeMessage("You require at least 1000 revenant ether to activate this weapon.", 0),
		ChargesMessage.staticChargeMessage("You use 1000 ether to activate the weapon.", 0),
		ChargesMessage.matcherGroupChargeMessage("You add (a further )?([\\d,]+) revenant ether to your weapon, giving it a total of ([\\d,]+) charges?.", 3),
		// elemental tomes
		ChargesMessage.staticChargeMessage("You empty your book of pages.", 0)
	);
	@Getter
	private static final List<ChargesMessage> nonUniqueUpdateMessageChargesRegexes = Arrays.asList(
		// trident
		ChargesMessage.matcherGroupChargeMessage(Text.removeTags("<col=ef1020>Your trident only has ([\\d,]+) charges left!</col>"), 1),
		ChargesMessage.staticChargeMessage(Text.removeTags("<col=ef1020>Your trident has run out of charges.</col>"), 0),
		// ether weapons
		ChargesMessage.matcherGroupChargeMessage(Text.removeTags("<col=ef1020>Your weapon only has ([\\d,]+) charges left.</col>"), 1),
		ChargesMessage.staticChargeMessage(Text.removeTags("<col=ef1020>Your weapon has run out of revenant ether.</col>"), 0),
		ChargesMessage.staticChargeMessage("There is not enough revenant ether left powering your bow.", 0)
	);

	@Getter
	private static final List<ChargesDialogHandler> nonUniqueDialogHandlers = Arrays.asList(
		// trident
		new ChargesDialogHandler(
			DialogStateMatcher.sprite(Pattern.compile("You add [\\S]+ [\\S]+ to the weapon. New total: ([\\d,]+)"), null),
			ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 1)
		),
		new ChargesDialogHandler(
			DialogStateMatcher.sprite(Pattern.compile("Your weapon is already fully charged."), null),
			ChargesDialogHandler.genericSpriteDialogFullChargeMessage()
		),
		new ChargesDialogHandler( // This one is entirely redundant, I think. Haven't checked (e) tridents though wrt the message they show in the uncharging options dialog.
			DialogStateMatcher.sprite(Pattern.compile("You uncharge your weapon."), null),
			ChargesDialogHandler.genericSpriteDialogUnchargeMessage()
		),
		new ChargesDialogHandler(
			DialogStateMatcher.inputOptionSelected(Pattern.compile("How many charges would you like to add\\? \\(0 - ([\\d,]+)\\)"), null),
			ChargesDialogHandler.genericInputChargeMessage()
		),
		new ChargesDialogHandler(
			DialogStateMatcher.optionsOptionSelected(Pattern.compile("You will NOT get the coins back."), null, Pattern.compile("Okay, uncharge it.")),
			ChargesDialogHandler.genericUnchargeDialog()
		),
		new ChargesDialogHandler(
			DialogStateMatcher.optionsOptionSelected(Pattern.compile("If you drop it, it will lose all its charges."), null, Pattern.compile("Drop it.")),
			ChargesDialogHandler.genericUnchargeDialog()
		),
		// Crystal shard recharging.
//		2022-06-13 09:38:09 [Client] INFO  com.weaponcharges.Devtools - 25: dialog state changed: DialogState{INPUT, title='How many shards do you wish to add? (0 - 5)', input=''}
		new ChargesDialogHandler(
			DialogStateMatcher.inputOptionSelected(Pattern.compile("How many shards do you wish to add\\? \\(0 - ([\\d,]+)\\)"), null),
			ChargesDialogHandler.genericInputChargeMessage(100)
		)
	);

	//why does Consumer not take multiple arguments????
	private class UpdateChargeComponentsParams
	{
		Integer currentCharges;
		Map<Integer, Float> chargeComponents = new HashMap<>();
		ConfigManager configManager;
	}

	private static class ChargedWeaponBuilder {
		List<Integer> chargedItemIds = Collections.emptyList();
		public ChargedWeaponBuilder chargedItemIds(Integer... chargedItemIds) {
			this.chargedItemIds = Arrays.asList(chargedItemIds);
			return this;
		}
		List<Integer> unchargedItemIds = Collections.emptyList();
		public ChargedWeaponBuilder unchargedItemIds(Integer... unchargedItemIds) {
			this.unchargedItemIds = Arrays.asList(unchargedItemIds);
			return this;
		}
		List<Integer> animationIds = Collections.emptyList();
		public ChargedWeaponBuilder animationIds(Integer... animationIds) {
			this.animationIds = Arrays.asList(animationIds);
			return this;
		}
		String name = null;
		public ChargedWeaponBuilder name(String name) {
			this.name = name;
			return this;
		}
		Integer rechargeAmount;
		public ChargedWeaponBuilder rechargeAmount(Integer rechargeAmount) {
			this.rechargeAmount = rechargeAmount;
			return this;
		}
		String configKeyName;
		public ChargedWeaponBuilder configKeyName(String configKeyName) {
			this.configKeyName = configKeyName;
			return this;
		}
		String settingsConfigKey;
		/**
		 * If set, it is used in place of configKeyName when accessing config for the item (low charges and display when).
		 */
		public ChargedWeaponBuilder settingsConfigKey(String settingsConfigKey) {
			this.settingsConfigKey = settingsConfigKey;
			return this;
		}
		List<ChargesMessage> checkChargesRegexes = Collections.emptyList();
		public ChargedWeaponBuilder checkChargesRegexes(ChargesMessage... checkChargesRegexes) {
			this.checkChargesRegexes = Arrays.asList(checkChargesRegexes);
			return this;
		}
		List<ChargesMessage> updateMessageChargesRegexes = Collections.emptyList();
		public ChargedWeaponBuilder updateMessageChargesRegexes(ChargesMessage... updateMessageChargesRegexes) {
			this.updateMessageChargesRegexes = Arrays.asList(updateMessageChargesRegexes);
			return this;
		}
		List<ChargesDialogHandler> dialogHandlers = Collections.emptyList();
		public ChargedWeaponBuilder dialogHandlers(ChargesDialogHandler... dialogHandlers) {
			this.dialogHandlers = Arrays.asList(dialogHandlers);
			return this;
		}
		int defaultLowChargeThreshold = 500;
		public ChargedWeaponBuilder defaultLowChargeThreshold(int defaultLowChargeThreshold) {
			this.defaultLowChargeThreshold = defaultLowChargeThreshold;
			return this;
		}
		Consumer<UpdateChargeComponentsParams> updateChargeComponents = (params) -> {return;};
		public  ChargedWeaponBuilder updateChargeComponents(Consumer<UpdateChargeComponentsParams> consumer)
		{
			this.updateChargeComponents = consumer;
			return this;
		}
	}

	public final List<Integer> itemIds;
	public final List<Integer> unchargedIds;
	public final List<Integer> animationIds;
	public final String name;
	public final Integer rechargeAmount;
	public final int defaultLowChargeThreshold;
	public final String configKeyName;
	public final String settingsConfigKey;
	// check messages are those produced by menu actions like "Check". update messages are those produced by the weapon
	// being used (e.g. those that notify you it's empty, or has 100 charges left, etc.).
	// These must be kept separate because the check messages [seem to always] have the charges of the weapon before
	// any attacks the weapon is making that tick, while the update messages have the charges of the weapon after any
	// attacks it makes on that tick.
	private final List<ChargesMessage> checkChargesRegexes;
	private final List<ChargesMessage> updateMessageChargesRegexes;
	private final List<ChargesDialogHandler> dialogHandlers;
	private final Consumer<UpdateChargeComponentsParams> updateChargeComponents;
	private final UpdateChargeComponentsParams updateParams;

	ChargedWeapon(ChargedWeaponBuilder builder) {
		this.itemIds = builder.chargedItemIds;
		this.unchargedIds = builder.unchargedItemIds;
		this.animationIds = builder.animationIds;
		if (builder.name == null) throw new IllegalStateException("cannot have a null name for charged weapon.");
		this.name = builder.name;
		this.rechargeAmount = builder.rechargeAmount;
		this.defaultLowChargeThreshold = builder.defaultLowChargeThreshold;
		this.configKeyName = builder.configKeyName;
		this.settingsConfigKey = builder.settingsConfigKey == null ? builder.configKeyName : builder.settingsConfigKey;
		this.checkChargesRegexes = builder.checkChargesRegexes;
		this.updateMessageChargesRegexes = builder.updateMessageChargesRegexes;
		this.dialogHandlers = builder.dialogHandlers;
		this.updateChargeComponents = builder.updateChargeComponents;
		this.updateParams = new UpdateChargeComponentsParams();
	}

	public Map<Integer, Float> getChargeComponents(Integer charges, ConfigManager configManager)
	{
		this.updateParams.currentCharges = charges;
		this.updateParams.chargeComponents.clear();
		this.updateParams.configManager = configManager;
		this.updateChargeComponents.accept(updateParams);
		return this.updateParams.chargeComponents;
	}

	public static ChargedWeapon getChargedWeaponFromId(int itemId)
	{
		for (ChargedWeapon weapon : values())
		{
			if (weapon.getItemIds().contains(itemId) || weapon.getUnchargedIds().contains(itemId))
			{
				return weapon;
			}
		}

		return null;
	}

	private static ChargedWeapon get_scythe_circumvent_illegal_self_reference() {
		return SCYTHE_OF_VITUR;
	}
}

/*
 * Copyright (c) 2023, geheur <https://github.com/geheur>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour.weaponcharges;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Builder;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.util.Text;

@Getter
@Builder
public class DialogStateMatcher
{
	private final boolean isOptionSelected;
	private final DialogTracker.DialogState.DialogType type;

	private final Pattern nameMatch;
	private final Pattern textMatch;
	private final Integer spriteDialogId;
	private final List<Pattern> optionMatches;

	private final Pattern optionMatch;

	public static DialogStateMatcher sprite(Pattern textMatch, Integer itemId)
	{
		return sprite(textMatch, itemId, false);
	}

	public static DialogStateMatcher spriteOptionSelected(Pattern textMatch, Integer itemId)
	{
		return sprite(textMatch, itemId, true);
	}

	private static DialogStateMatcher sprite(Pattern textMatch, Integer itemId, boolean isOptionSelected)
	{
		return DialogStateMatcher.builder()
			.type(DialogTracker.DialogState.DialogType.SPRITE)
			.isOptionSelected(isOptionSelected)
			.textMatch(textMatch)
			.spriteDialogId(itemId)
			.build();
	}

	public static DialogStateMatcher player(Pattern textMatch, Pattern nameMatch)
	{
		return player(textMatch, nameMatch, false);
	}

	public static DialogStateMatcher playerOptionSelected(Pattern textMatch, Pattern nameMatch)
	{
		return player(textMatch, nameMatch, true);
	}

	private static DialogStateMatcher player(Pattern textMatch, Pattern nameMatch, boolean isOptionSelected)
	{
		return DialogStateMatcher.builder()
			.type(DialogTracker.DialogState.DialogType.PLAYER)
			.isOptionSelected(isOptionSelected)
			.nameMatch(nameMatch)
			.textMatch(textMatch)
			.build();
	}

	public static DialogStateMatcher npc(Pattern textMatch, Pattern nameMatch)
	{
		return npc(textMatch, nameMatch, false);
	}

	public static DialogStateMatcher npcOptionSelected(Pattern textMatch, Pattern nameMatch)
	{
		return npc(textMatch, nameMatch, true);
	}

	private static DialogStateMatcher npc(Pattern textMatch, Pattern nameMatch, boolean isOptionSelected)
	{
		return DialogStateMatcher.builder()
			.type(DialogTracker.DialogState.DialogType.NPC)
			.isOptionSelected(isOptionSelected)
			.nameMatch(nameMatch)
			.textMatch(textMatch)
			.build();
	}

	public static DialogStateMatcher options(Pattern textMatch, List<Pattern> optionsMatch)
	{
		return options(textMatch, optionsMatch, null, false);
	}

	public static DialogStateMatcher optionsOptionSelected(Pattern textMatch, List<Pattern> optionsMatch, Pattern optionSelectedMatch)
	{
		return options(textMatch, optionsMatch, optionSelectedMatch, true);
	}

	private static DialogStateMatcher options(Pattern textMatch, List<Pattern> optionsMatch, Pattern optionSelectedMatch, boolean isOptionSelected)
	{
		return DialogStateMatcher.builder()
			.type(DialogTracker.DialogState.DialogType.OPTIONS)
			.isOptionSelected(isOptionSelected)
			.textMatch(textMatch)
			.optionMatches(optionsMatch)
			.optionMatch(optionSelectedMatch)
			.build();
	}

	public static DialogStateMatcher input(Pattern textMatch)
	{
		return input(textMatch, null, false);
	}

	public static DialogStateMatcher inputOptionSelected(Pattern textMatch, Pattern optionSelectedMatcher)
	{
		return input(textMatch, optionSelectedMatcher, true);
	}

	private static DialogStateMatcher input(Pattern textMatch, Pattern optionSelectedMatcher, boolean isOptionSelected)
	{
		return DialogStateMatcher.builder()
			.type(DialogTracker.DialogState.DialogType.INPUT)
			.isOptionSelected(isOptionSelected)
			.nameMatch(textMatch)
			.build();
	}

	public DialogStateMatchers matchDialog(DialogTracker.DialogState dialogState)
	{
		return matchDialog(dialogState, false, null);
	}

	public DialogStateMatchers matchDialogOptionSelected(DialogTracker.DialogState dialogState, String isOptionSelected)
	{
		return matchDialog(dialogState, true, isOptionSelected);
	}

	private DialogStateMatchers matchDialog(DialogTracker.DialogState dialogState, boolean isOptionSelected, String optionSelected)
	{
		if (this.isOptionSelected != isOptionSelected)
		{
			return null;
		}
		if (this.getType() != dialogState.type)
		{
			return null;
		}
		if (this.getSpriteDialogId() != null && this.getSpriteDialogId() != dialogState.spriteDialogItemId)
		{
			return null;
		}

		Matcher nameMatcher = null;
		if (this.getNameMatch() != null)
		{
			if (dialogState.name == null)
			{
				return null; // argument should never be null, but let's be safe.
			}
			nameMatcher = this.getNameMatch().matcher(dialogState.name);
			if (!nameMatcher.find())
			{
				return null;
			}
		}

		Matcher textMatcher = null;
		String text = dialogState.text;
		text = Text.removeTags(text.replaceAll("<br>", " "));
		if (this.getTextMatch() != null)
		{
			if (text == null)
			{
				return null; // argument should never be null, but let's be safe.
			}
			textMatcher = this.getTextMatch().matcher(text);
			if (!textMatcher.find())
			{
				return null;
			}
		}

		List<Matcher> optionMatchers = new ArrayList<>();
		if (this.getOptionMatches() != null)
		{
			if (this.getOptionMatches().size() != dialogState.options.size())
			{
				return null;
			}
			for (int i = 0; i < this.getOptionMatches().size(); i++)
			{
				Pattern optionMatch = this.getOptionMatches().get(i);
				if (optionMatch == null)
				{
					optionMatchers.add(null);
					continue;
				}

				String option = dialogState.options.get(i);
				if (option == null)
				{
					return null;
				}
				Matcher optionMatcher = optionMatch.matcher(option);
				if (!optionMatcher.find())
				{
					return null;
				}
				optionMatchers.add(optionMatcher);
			}
		}

		Matcher optionMatcher = null;
		if (this.getOptionMatch() != null)
		{
			if (optionSelected == null)
			{
				return null; // argument should never be null, but let's be safe.
			}
			optionMatcher = this.getOptionMatch().matcher(optionSelected);
			if (!optionMatcher.find())
			{
				return null;
			}
		}

		return new DialogStateMatchers(nameMatcher, textMatcher, dialogState.spriteDialogItemId, optionMatchers, optionMatcher);
	}

	//		public static NpcDialogStateMatcher noDialog() {
//			return new NpcDialogStateMatcher(NpcDialogType.NO_DIALOG, null, null, null, null);
//		}
//
	@Getter
	@RequiredArgsConstructor
	public static final class DialogStateMatchers
	{
		private final Matcher nameMatcher;
		private final Matcher textMatcher;
		private final Integer spriteDialogId;
		private final List<Matcher> optionMatchers;

		private final Matcher optionMatch;
	}
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import java.awt.*;
import java.awt.event.ActionListener;
import java.text.NumberFormat;
import java.time.Instant;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import javax.swing.*;
import javax.swing.border.EmptyBorder;

import lombok.extern.slf4j.Slf4j;

import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.event.MouseAdapter;

import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

@Slf4j
//Some utility code for various functionality used by different classes.
public class UI {
    public static class LootPanelData {
        JPanel lootPanel = new JPanel();
        JComponent containerPanel;
        List<LedgerItem> previousLedger = new LinkedList<LedgerItem>();
    }

    public static final ImageIcon PAUSE_ICON;
    public static final ImageIcon PLAY_ICON;
    public static final ImageIcon SESSIONINFO_GEAR_ICON;
    public static final ImageIcon SESSIONINFO_REFRESH_ICON;
    public static final ImageIcon SESSIONINFO_WRENCH_ICON;
    public static final ImageIcon SESSIONINFO_STOP_ICON;
    public static final ImageIcon SESSIONINFO_PLAY_ICON;
    public static final ImageIcon SESSIONINFO_TRASH_ICON;
    public static final ImageIcon SESSIONINFO_SAVE_ICON;
    public static final ImageIcon SESSIONINFO_GEAR_HOVER_ICON;
    public static final ImageIcon SESSIONINFO_REFRESH_HOVER_ICON;
    public static final ImageIcon SESSIONINFO_WRENCH_HOVER_ICON;
    public static final ImageIcon SESSIONINFO_STOP_HOVER_ICON;
    public static final ImageIcon SESSIONINFO_PLAY_HOVER_ICON;
    public static final ImageIcon SESSIONINFO_TRASH_HOVER_ICON;
    public static final ImageIcon SESSIONINFO_SAVE_HOVER_ICON;
    public static final ImageIcon SESSIONINFO_INFO_ICON;
    public static final ImageIcon SESSIONINFO_INFO_HOVER_ICON;
    public static final ImageIcon SESSIONINFO_GRID_ICON;
    public static final ImageIcon SESSIONINFO_GRID_HOVER_ICON;
    public static final ImageIcon SESSIONINFO_PLUS_ICON;
    public static final ImageIcon SESSIONINFO_PLUS_HOVER_ICON;

    private static final String PROFIT_LOSS_TIME_FORMAT = "%01d:%02d:%02d";
    private static final String PROFIT_LOSS_TIME_NO_HOURS_FORMAT = "%01d:%02d";
    private static final NumberFormat englishFormat = NumberFormat.getInstance(Locale.ENGLISH);
    private static final Color redLootBackgroundColor = new Color(48, 15, 15);
    private static final Color greenLootBackgroundColor = new Color(21, 43, 16);
    private static final int ITEMS_PER_ROW = 5;
    private static final Dimension ITEM_SIZE = new Dimension(40, 40);

    private static final float roundMultiplier = 1f / GPPerHourPlugin.roundAmount;

    public static String formatQuantity(float quantity, boolean absolute) {
        if (absolute) {
            quantity = Math.abs(quantity);
        }
        quantity = Math.round(quantity * roundMultiplier) / roundMultiplier;
        String text = englishFormat.format(quantity);
        return text;
    }

    public static JLabel createIconButton(ImageIcon defaultIcon, ImageIcon hoverIcon, String tooltipText, Runnable onClick) {
        JLabel label = new JLabel(defaultIcon);
        label.setToolTipText(tooltipText);
        label.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (SwingUtilities.isLeftMouseButton(e)) {
                    onClick.run();
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                label.setIcon(hoverIcon);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                label.setIcon(defaultIcon);
            }
        });
        return label;
    }

    public static boolean ledgersMatch(List<LedgerItem> ledgerOne, List<LedgerItem> ledgerTwo) {
        if (ledgerOne == null || ledgerTwo == null) {
            return false;
        }
        if (ledgerOne.size() != ledgerTwo.size()) {
            return false;
        }
        for (int i = 0; i < ledgerOne.size(); ++i) {
            LedgerItem itemOne = ledgerOne.get(i);
            LedgerItem itemTwo = ledgerTwo.get(i);

            if (itemOne.getQty() != itemTwo.getQty()) {
                return false;
            }
            if (itemOne.getItemId() != itemTwo.getItemId()) {
                return false;
            }
            if (itemOne.getPrice() != itemTwo.getPrice()) {
                return false;
            }
        }

        return true;
    }

    public static String getTimeAgo(long timestamp) {
        long currentTime = Instant.now().toEpochMilli();
        long timeDiff = currentTime - timestamp;

        if (timeDiff < 0) {
            return "In the future";
        }

        long minutes = TimeUnit.MILLISECONDS.toMinutes(timeDiff) % 60;
        long hours = TimeUnit.MILLISECONDS.toHours(timeDiff);
        long days = TimeUnit.MILLISECONDS.toDays(timeDiff);

        if (days > 0) {
            return days + " day" + (days > 1 ? "s" : "") + " ago";
        } else if (hours > 0) {
            return hours + " hour" + (hours > 1 ? "s" : "") + " and " + minutes + " minute" + (minutes != 1 ? "s" : "") + " ago";
        } else if (minutes > 0) {
            return minutes + " minute" + (minutes > 1 ? "s" : "") + " ago";
        } else {
            return "less than a minute ago";
        }
    }

    public static void clearListeners(AbstractButton button) {
        ActionListener[] listeners = button.getActionListeners();
        for (ActionListener listener : listeners) {
            button.removeActionListener(listener);
        }
    }

    public static Component addVerticalRigidBox(Container container, int size) {
        return container.add(Box.createRigidArea(new Dimension(0, size)));
    }

    public static String formatTime(long millis) {
        long totalSecs = millis / 1000;
        long totalMins = totalSecs / 60;

        long hrs = totalMins / 60;
        long mins = totalMins % 60;
        long secs = totalSecs % 60;

        if (hrs > 0) {
            return String.format(PROFIT_LOSS_TIME_FORMAT, hrs, mins, secs);
        } else {
            return String.format(PROFIT_LOSS_TIME_NO_HOURS_FORMAT, mins, secs);
        }
    }

    public static List<LedgerItem> sortLedger(List<LedgerItem> ledger) {

        // sort by profit descending
        ledger = ledger.stream().sorted(Comparator.comparingLong(o -> -(o.getCombinedValue())))
                .collect(Collectors.toList());

        return ledger;
    }

    public static String buildToolTip(String name, String quantity, String price, String combinedValue) {
        return "<html>" + name + " x " + quantity
                + "<br/>Price: " + price
                + "<br/>Total: " + combinedValue + "</html>";
    }

    public static long getGpPerHour(long runTime, long total) {
        float hours = ((float) runTime) / 3600000f;
        long gpPerHour = (long) (total / hours);
        return gpPerHour;
    }

    public static String formatGp(long value, boolean showExact) {
        if (showExact) {
            return QuantityFormatter.formatNumber(value);
        } else {
            return QuantityFormatter.quantityToStackSize(value);
        }
    }

    public static String formatGp(double value, boolean showExact) {
        if (showExact || Math.abs(value) < 10d) {
            return QuantityFormatter.formatNumber(value);
        } else {
            return QuantityFormatter.quantityToStackSize(Math.round(value));
        }
    }

    static void updateLootGrid(List<LedgerItem> ledger, LootPanelData lootPanelData, ItemManager itemManager, GPPerHourConfig config, int heightLimit) {
        if (UI.ledgersMatch(ledger, lootPanelData.previousLedger)) {
            return;
        }
        lootPanelData.previousLedger = ledger;
        JPanel containerCurrent = new JPanel();
        int totalItems = ledger.size();

        // Calculates how many rows need to be display to fit all items
        final int rowCount = ((totalItems % ITEMS_PER_ROW == 0) ? 0 : 1) + totalItems / ITEMS_PER_ROW;
        containerCurrent.setLayout(new GridLayout(rowCount, ITEMS_PER_ROW, 1, 1));

        // Create stacked items from the item list, calculates total price and then
        // displays all the items in the UI.
        for (LedgerItem ledgerItem : ledger) {
            final JPanel slot = new JPanel();
            boolean wasGain = ledgerItem.getQty() > 0;
            slot.setLayout(new GridLayout(1, 1, 0, 0));
            slot.setBackground(wasGain ? greenLootBackgroundColor : redLootBackgroundColor);
            slot.setPreferredSize(ITEM_SIZE);

            final JLabel itemLabel = new JLabel();

            itemLabel.setToolTipText(UI.buildToolTip(ledgerItem.getDescription(),
                    UI.formatQuantity(ledgerItem.getQty(), false),
                    UI.formatGp(ledgerItem.getPrice(), config.showExactGp()),
                    UI.formatGp(ledgerItem.getCombinedValue(), config.showExactGp())));
            itemLabel.setVerticalAlignment(SwingConstants.CENTER);
            itemLabel.setHorizontalAlignment(SwingConstants.CENTER);

            AsyncBufferedImage itemImage = itemManager.getImage(ledgerItem.getItemId(),
                    (int) Math.ceil(Math.abs(ledgerItem.getQty())), Math.ceil(Math.abs(ledgerItem.getQty())) > 1);
            itemImage.addTo(itemLabel);

            slot.add(itemLabel);
            containerCurrent.add(slot);
        }
        if (totalItems < ITEMS_PER_ROW || totalItems % ITEMS_PER_ROW != 0) {
            int extraBoxes;
            if (totalItems % ITEMS_PER_ROW != 0 && totalItems >= ITEMS_PER_ROW) {
                int i = totalItems;
                while (i % ITEMS_PER_ROW != 0) {
                    i++;
                }
                extraBoxes = i - totalItems;
            } else {
                extraBoxes = ITEMS_PER_ROW - totalItems;
            }
            for (int i = 0; i < extraBoxes; i++) {
                final JPanel slot = new JPanel();
                slot.setLayout(new GridLayout(1, 1, 0, 0));
                slot.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                slot.setPreferredSize(ITEM_SIZE);

                containerCurrent.add(slot);
            }
        }


        if (lootPanelData.containerPanel != null)
            lootPanelData.lootPanel.remove(lootPanelData.containerPanel);
        if (heightLimit != 0)
        {
            // Wrap the panel in a JScrollPane
            JScrollPane scrollPane = new JScrollPane(containerCurrent);
            scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(12, 0));
            scrollPane.getVerticalScrollBar().setBorder(new EmptyBorder(0, 5, 0, 0));
            scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
            scrollPane.setMaximumSize(new Dimension(0, heightLimit));
            if (scrollPane.getPreferredSize().height > heightLimit)
                scrollPane.setPreferredSize(new Dimension(0, heightLimit));
            lootPanelData.containerPanel = scrollPane;
        }
        else
        {
            lootPanelData.containerPanel = containerCurrent;
        }
        lootPanelData.lootPanel.add(lootPanelData.containerPanel);
        lootPanelData.lootPanel.revalidate();
        lootPanelData.lootPanel.repaint();
    }

    static {
        BufferedImage pausePNG = ImageUtil.loadImageResource(GPPerHourPlugin.class, "/gpperhour-pause.png");
        BufferedImage playPNG = ImageUtil.loadImageResource(GPPerHourPlugin.class, "/gpperhour-play.png");

        PAUSE_ICON = new ImageIcon(pausePNG);
        PLAY_ICON = new ImageIcon(playPNG);

        //Session info tray
        final float hoverAlphaOffset = .53f;
        final BufferedImage importIcon = ImageUtil.loadImageResource(GPPerHourPlugin.class, "/gpperhour-session-gear.png");
        SESSIONINFO_GEAR_ICON = new ImageIcon(importIcon);
        SESSIONINFO_GEAR_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(importIcon, hoverAlphaOffset));
        final BufferedImage refreshIcon = ImageUtil.loadImageResource(GPPerHourPlugin.class, "/gpperhour-session-refresh.png");
        SESSIONINFO_REFRESH_ICON = new ImageIcon(refreshIcon);
        SESSIONINFO_REFRESH_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(refreshIcon, hoverAlphaOffset));
        final BufferedImage wrenchIcon = ImageUtil.loadImageResource(GPPerHourPlugin.class, "/gpperhour-session-wrench.png");
        SESSIONINFO_WRENCH_ICON = new ImageIcon(wrenchIcon);
        SESSIONINFO_WRENCH_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(wrenchIcon, hoverAlphaOffset));
        final BufferedImage stopIcon = ImageUtil.loadImageResource(GPPerHourPlugin.class, "/gpperhour-session-stop.png");
        SESSIONINFO_STOP_ICON = new ImageIcon(stopIcon);
        SESSIONINFO_STOP_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(stopIcon, hoverAlphaOffset));
        final BufferedImage playIcon = ImageUtil.loadImageResource(GPPerHourPlugin.class, "/gpperhour-session-play.png");
        SESSIONINFO_PLAY_ICON = new ImageIcon(playIcon);
        SESSIONINFO_PLAY_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(playIcon, hoverAlphaOffset));
        final BufferedImage trashIcon = ImageUtil.loadImageResource(GPPerHourPlugin.class, "/gpperhour-session-trash.png");
        SESSIONINFO_TRASH_ICON = new ImageIcon(trashIcon);
        SESSIONINFO_TRASH_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(trashIcon, hoverAlphaOffset));
        final BufferedImage saveIcon = ImageUtil.loadImageResource(GPPerHourPlugin.class, "/gpperhour-session-save.png");
        SESSIONINFO_SAVE_ICON = new ImageIcon(saveIcon);
        SESSIONINFO_SAVE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(saveIcon, hoverAlphaOffset));
        final BufferedImage infoIcon = ImageUtil.loadImageResource(GPPerHourPlugin.class, "/gpperhour-session-info.png");
        SESSIONINFO_INFO_ICON = new ImageIcon(infoIcon);
        SESSIONINFO_INFO_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(infoIcon, hoverAlphaOffset));
        final BufferedImage gridIcon = ImageUtil.loadImageResource(GPPerHourPlugin.class, "/gpperhour-session-grid.png");
        SESSIONINFO_GRID_ICON = new ImageIcon(gridIcon);
        SESSIONINFO_GRID_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(gridIcon, hoverAlphaOffset));
        final BufferedImage plusIcon = ImageUtil.loadImageResource(GPPerHourPlugin.class, "/gpperhour-session-plus.png");
        SESSIONINFO_PLUS_ICON = new ImageIcon(plusIcon);
        SESSIONINFO_PLUS_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(plusIcon, hoverAlphaOffset));
    }
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, Eric Versteeg <https://github.com/erversteeg>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;

import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ScheduledExecutorService;

import javax.inject.Inject;
import javax.swing.SwingUtilities;

import com.gpperhour.GoldDropManager.GoldDropDisplayMode;
import com.gpperhour.itemcharges.ChargedItemManager;
import com.gpperhour.weaponcharges.WeaponChargesManager;
import com.google.gson.Gson;
import com.google.inject.Provides;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuAction;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.*;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.OverlayMenuClicked;
import net.runelite.client.events.RuneScapeProfileChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.util.ImageUtil;

@PluginDescriptor(
	name = "GP Per Hour",
	description = "Track your gp/hr across various trips and save your sessions for later viewing.",
	tags = {
		"inventory",
		"total",
		"profit",
		"tracker",
		"loss",
		"gp",
		"per",
		"hour",
		"prices",
		"gold farming",
		"gp/hr"
	}
)

@Slf4j
public class GPPerHourPlugin extends Plugin
{
	private static final String plugin_version = "1.15";
	private static final String plugin_message = "" +
		"GP Per Hour " + plugin_version + ":<br>" +
				"* Add support for trouver rune pouch variants.";
	static final int COINS = ItemID.COINS;
	static final int NO_PROFIT_LOSS_TIME = -1;
	static final int RUNEPOUCH_ITEM_ID = ItemID.BH_RUNE_POUCH;
	static final int DIVINE_RUNEPOUCH_ITEM_ID = ItemID.DIVINE_RUNE_POUCH;
	static final int RUNEPOUCH_TROUVER_ITEM_ID = ItemID.BH_RUNE_POUCH_TROUVER;
	static final int DIVINE_RUNEPOUCH_TROUVER_ITEM_ID = ItemID.DIVINE_RUNE_POUCH_TROUVER;
	public static final float roundAmount = 0.01f;

    // static item prices so that when ItemManager updates, the Profit / Loss value doesn't all of a sudden change
    // this is cleared and repopulated at the start of each new run (after bank) and whenever new items hit the inventory
    private static final Map<Integer, Float> itemPrices = new HashMap<>();
	//so we can do name lookups on the swing thread
	private static final Map<Integer, String> itemNames = new HashMap<>();

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private ActiveTripOverlay tripOverlay;

	@Inject
	private WeaponChargesManager weaponChargesManager;

	@Inject
	private ChargedItemManager chargedItemManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	@Getter
	private Client client;

	@Inject
	private GPPerHourConfig config;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ItemManager itemManager;

	@Inject
	private LootingBagManager lootingBagManager;
	
	@Inject
	private EventBus eventBus;
	
	@Inject
	private ConfigManager configManager;
	
	@Inject
	private Gson gson;
	
    @Inject
    private ClientToolbar clientToolbar;
	
	@Inject
	private ChatMessageManager chat_messages;

	@Getter
	private SessionManager sessionManager;

	private GPPerHourPanel gpPerHourPanel;
	private ActiveSessionPanel activeSessionPanel;
	private SessionHistoryPanel sessionHistoryPanel;

	@Getter
	private TripData runData;

	@Inject
	private GoldDropManager goldDropManager;

	@Getter
	private TrackingMode mode = TrackingMode.TOTAL;

	@Getter
	private RunState state = RunState.NONE;
	@Getter
	private RunState previousState = RunState.NONE;

	@Getter @Setter
	private long totalGp = 0;
	private Long previousTotalGp = null;

	private long initialGp = 0;
	
    private BufferedImage icon;
    private NavigationButton navButton;
	private final Map<Integer, Float> inventoryQtyMap = new HashMap<>();
	private final Map<Integer, Float> equipmentQtyMap = new HashMap<>();
	private final Map<Integer, Float> rewardsQtyMap = new HashMap<>();
	private final HashSet<String> ignoredItems = new HashSet<>();
	private int depositInteractionTick;
	//if its been more than 30 ticks you probably cancelled your interaction
	private static final int interactionTickThreshold = 30;

	@Getter
	private Widget inventoryWidget;
	private ItemContainer inventoryItemContainer;
	private ItemContainer equipmentItemContainer;
	private boolean postNewRun = false;
	private long newRunTick = 0;
	private boolean expectingPutAnimation = false;

	// from ClueScrollPlugin
	private static final int[] RUNEPOUCH_AMOUNT_VARBITS = {
			VarbitID.RUNE_POUCH_QUANTITY_1, VarbitID.RUNE_POUCH_QUANTITY_2, VarbitID.RUNE_POUCH_QUANTITY_3, VarbitID.RUNE_POUCH_QUANTITY_4
	};
	private static final int[] RUNEPOUCH_RUNE_VARBITS = {
			VarbitID.RUNE_POUCH_TYPE_1, VarbitID.RUNE_POUCH_TYPE_2, VarbitID.RUNE_POUCH_TYPE_3, VarbitID.RUNE_POUCH_TYPE_4
	};
    @AllArgsConstructor
    public enum ValueMode {
        RUNELITE_VALUE        	("Runelite (Default)"),
        LOW_ALCHEMY_VALUE    	("Low Alchemy"),
        HIGH_ALCHEMY_VALUE     	("High Alchemy");
        private final String configName;
        @Override
        public String toString() { return configName; }
    }

	@Override
	protected void startUp() throws Exception
	{
		if (config.showTripOverlay())
			overlayManager.add(tripOverlay);
		if (config.goldDropsDisplayMode() == GoldDropDisplayMode.STATIC)
			overlayManager.add(goldDropManager);

		eventBus.register(lootingBagManager);
		eventBus.register(weaponChargesManager);
		eventBus.register(chargedItemManager);
		weaponChargesManager.startUp();
		
		sessionManager = new SessionManager(this, config, executor, gson);
		buildSidePanel();
		updatePanels();
		refreshIgnoredItems();
		checkLoadingState(true);

		//Migrate old settings
		if (config.goldDrops())
		{
			config.setGoldDropsDisplayMode(GoldDropDisplayMode.VANILLA);
			config.setGoldDrops(false);
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(tripOverlay);
		overlayManager.remove(goldDropManager);
		eventBus.unregister(lootingBagManager);
		eventBus.unregister(weaponChargesManager);
		eventBus.unregister(chargedItemManager);
		weaponChargesManager.shutDown();
		clientToolbar.removeNavigation(navButton);
		if (this.currentProfileKey != null)
		{
			writeSavedData(this.currentProfileKey);
		}
	}

	private String currentProfileKey;

	@Subscribe
	public void onRuneScapeProfileChanged(RuneScapeProfileChanged e)
	{
		checkLoadingState(false);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		String profileKey = configManager.getRSProfileKey();
		if (profileKey != null)
		{
			writeSavedData(profileKey);
		}

		if (gameStateChanged.getGameState() == GameState.LOGGED_IN)
		{
			showChangelog();
		}
	}

	private void showChangelog()
	{
		String currentVersion = configManager.getConfiguration(GPPerHourConfig.GROUP, GPPerHourConfig.version);
		if (currentVersion == null || !currentVersion.equals(plugin_version)) {
			configManager.setConfiguration(GPPerHourConfig.GROUP, GPPerHourConfig.version, plugin_version);
			chat_messages.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(plugin_message)
				.build()
			);
		}
	}

	private void checkLoadingState(boolean isStartingUp)
	{
		String profileKey = configManager.getRSProfileKey();

		if (profileKey != null)
		{
			//getting profile for first time
			if (this.currentProfileKey == null || isStartingUp)
			{
				loadData();
			}
			//profile switched
			else if (!profileKey.equals(this.currentProfileKey))
			{
				writeSavedData(this.currentProfileKey);
				loadData();
			}
		}
		//lost profile somehow
		else if (this.currentProfileKey != null)
		{
			writeSavedData(this.currentProfileKey);
		}

		this.currentProfileKey = profileKey;
	}

	private void loadData()
	{
		lootingBagManager.loadConfigData();
		chargedItemManager.loadConfigData();
		sessionManager.reloadSessions();
		sessionManager.deleteAllTrips();
		sessionManager.stopTracking();
		runData = getSavedData();
		sessionManager.startTracking();
		previousTotalGp = null;
	}

	void updatePanels()
	{
		if (gpPerHourPanel.isActive() && gpPerHourPanel.isShowingActiveSession())
		{
			SessionStats sessionStats = sessionManager.getActiveSessionStats();
			//ensure we load these after a restart
			if (sessionStats != null)
			{
				ensureSessionNameAndPriceLoaded(sessionStats);
			}
			SwingUtilities.invokeLater(() -> activeSessionPanel.updateTrips());
		}
		if (gpPerHourPanel.isActive() && gpPerHourPanel.isShowingSessionHistory() && sessionManager.sessionHistoryDirty)
		{
			//ensure we load these after a restart
			for (SessionStats sessionStats : sessionManager.sessionHistory)
			{
				ensureSessionNameAndPriceLoaded(sessionStats);
			}
			SwingUtilities.invokeLater(() -> sessionHistoryPanel.updateSessions());
			sessionManager.sessionHistoryDirty = false;
		}
	}

	void ensureSessionNameAndPriceLoaded(SessionStats sessionStats)
	{
		for(Integer intialItemId : sessionStats.getInitialQtys().keySet())
		{
			ensureNameAndPriceLoaded(intialItemId);
		}
		for(Integer itemId : sessionStats.getQtys().keySet())
		{
			ensureNameAndPriceLoaded(itemId);
		}
	}

	void ensureNameAndPriceLoaded(Integer itemId)
	{
		if (!GPPerHourPlugin.itemNames.containsKey(itemId))
		{
			ItemComposition composition = itemManager.getItemComposition(itemId);
			itemNames.put(itemId, composition.getName());
		}
		if (!GPPerHourPlugin.itemPrices.containsKey(itemId))
		{
			itemPrices.put(itemId, getPrice(itemId));
		}
	}

    private void buildSidePanel()
    {
        activeSessionPanel = new ActiveSessionPanel(this, config, itemManager, clientThread, sessionManager);
        activeSessionPanel.sidePanelInitializer();

		sessionHistoryPanel = new SessionHistoryPanel(this, config, itemManager, clientThread, sessionManager);

		gpPerHourPanel = new GPPerHourPanel(activeSessionPanel, sessionHistoryPanel);

        icon = ImageUtil.loadImageResource(getClass(), "/gpperhour-icon.png");
        navButton = buildNavButton();
		if (config.enableSessionPanel())
			clientToolbar.addNavigation(navButton);
    }

	@Subscribe(priority = -1)//run after xpdrop plugin to overwrite their colors
	public void onScriptPreFired(ScriptPreFired scriptPreFired)
	{
		goldDropManager.onScriptPreFired(scriptPreFired);
	}
	
    @Subscribe
    public void onGameTick(GameTick gameTick)
    {
		if (runData == null)
			return;
		updatePluginState(false);
		updatePanels();
		updateChargeableItemsNeedingCheck();
		
		if (this.state == RunState.RUN && !runData.isPaused)
		{
			runData.runtime +=  Constants.GAME_TICK_LENGTH;
		}

		checkTickProfit();
    }

	// If profit total changed generate gold drop (nice animation for showing gold earn or loss)
	void checkTickProfit()
	{
		boolean isRun = this.state == RunState.RUN;

		if (!isRun)
			return;
		if (runData.isBankDelay)
			return;

		if (previousTotalGp == null)
		{
			previousTotalGp = Long.valueOf(totalGp);
			return;
		}
        long tickProfit = (totalGp - previousTotalGp);
		previousTotalGp = Long.valueOf(totalGp);
		//avoid rounding issues with charges
		if (Math.abs(tickProfit) <= 1l)
			return;

		//unpause run automatically
		if (runData.isPaused && config.autoResumeTrip())
		{
			runData.isPaused = false;
		}
		if (config.goldDropsDisplayMode() != GoldDropDisplayMode.DISABLED && 
			Math.abs(tickProfit) >= config.goldDropThreshold() &&
			((tickProfit > 0) || !config.onlyShowPositiveGoldDrops()))
		{
			goldDropManager.requestGoldDrop(tickProfit);
		}
	}

	@Provides
	GPPerHourConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(GPPerHourConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals(GPPerHourConfig.GROUP))
		{
			if (event.getKey().equals(GPPerHourConfig.showTripOverlayKeyName))
			{
				if (config.showTripOverlay())
					overlayManager.add(tripOverlay);
				else
					overlayManager.remove(tripOverlay);
			}
			else if (event.getKey().equals(GPPerHourConfig.goldDropDisplayModeKey))
			{
				if (config.goldDropsDisplayMode() == GoldDropDisplayMode.STATIC)
					overlayManager.add(goldDropManager);
				else
					overlayManager.remove(goldDropManager);
			}
			else if (event.getKey().equals(GPPerHourConfig.enableSessionPanelKeyName))
			{
				if (config.enableSessionPanel())
					clientToolbar.addNavigation(navButton);
				else
					clientToolbar.removeNavigation(navButton);

				sessionManager.refreshSessionTracking();
			}
			else if (event.getKey().equals(GPPerHourConfig.enableSessionTrackingKeyName))
			{
				sessionManager.refreshSessionTracking();
			}
			else if (event.getKey().equals(GPPerHourConfig.sidePanelPositionKeyName))
			{
				clientToolbar.removeNavigation(navButton);
				//need to rebuild it for some reason (i think its a bug in core)
				navButton = buildNavButton();
				if (config.enableSessionPanel())
				{
					clientToolbar.addNavigation(navButton);
				}
			}
			else if (event.getKey().equals(GPPerHourConfig.ignoredItemsKey))
			{
				refreshIgnoredItems();
			}
			else if (event.getKey().equals(GPPerHourConfig.valueModeKey))
			{
				refreshPrices();
			}
			else if (event.getKey().equals(GPPerHourConfig.sessionLootGridMaxHeightKeyName))
			{
				if (activeSessionPanel != null)
				{
					activeSessionPanel.resetSessionLootGrid();
				}
			}
			else if (event.getKey().startsWith("tokkul"))
			{
				refreshPrice(ItemID.TZHAAR_TOKEN);
			}
			else if (event.getKey().startsWith("crystalShard"))
			{
				refreshPrice(ItemID.PRIF_CRYSTAL_SHARD);
			}
			else if (event.getKey().startsWith("crystalDust"))
			{
				refreshPrice(ItemID.PRIF_CRYSTAL_SHARD_CRUSHED);
			}
			else if (event.getKey().startsWith("mermaidsTear"))
			{
				refreshPrice(ItemID.FOSSIL_MERMAID_TEAR);
			}
			else if (event.getKey().startsWith("stardust"))
			{
				refreshPrice(ItemID.STAR_DUST);
			}
			else if (event.getKey().startsWith("unidentifiedMinerals"))
			{
				refreshPrice(ItemID.MGUILD_MINERALS);
			}
			else if (event.getKey().startsWith("goldenNugget"))
			{
				refreshPrice(ItemID.MOTHERLODE_NUGGET);
			}
			else if (event.getKey().startsWith("hallowedMark"))
			{
				refreshPrice(ItemID.HALLOWED_MARK);
			}
			else if (event.getKey().startsWith("abyssalPearls"))
			{
				refreshPrice(ItemID.ABYSSAL_PEARL);
			}
			else if (event.getKey().startsWith("brimstoneKey"))
			{
				refreshPrice(ItemID.KONAR_KEY);
			}
		}
	}

	private void refreshIgnoredItems()
	{
		ignoredItems.clear();

		String[] items = config.ignoredItems().split(",");
		for (int i=0;i<items.length;++i)
		{
			ignoredItems.add(items[i].trim().toLowerCase());
		}
	}

	private void refreshPrice(int itemID)
	{
		clientThread.invoke(()->{

			if (itemPrices.remove(itemID) != null)
			{
				getPrice(itemID);
			}
		});
	}

	private NavigationButton buildNavButton()
	{
		return NavigationButton.builder().tooltip("GP Per Hour").icon(icon).priority(config.sidePanelPosition()).panel(gpPerHourPanel).build();
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (event.getGroupId() == InterfaceID.MISC_COLLECTION)
		{
			ItemContainer rewardsItemContainer = client.getItemContainer(InventoryID.MISC_RESOURCES_COLLECTED);
			if (rewardsItemContainer != null)
			{
				refreshQtyMap(rewardsQtyMap, rewardsItemContainer);
				for (int itemId: rewardsQtyMap.keySet())
				{
					runData.bankedItemQtys.merge(itemId, rewardsQtyMap.get(itemId), Float::sum);
				}
			}
		}

		updatePluginState(false);
	}

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if ((event.getId() == ObjectID.BANK_DEPOSIT_BOX && event.getMenuAction() == MenuAction.WIDGET_TARGET_ON_GAME_OBJECT)
			|| (event.getId() == ObjectID.BANK_DEPOSIT_CHEST && event.getMenuAction() == MenuAction.WIDGET_TARGET_ON_GAME_OBJECT)
			|| event.getId() == ObjectID.GOTR_DEPOSITCHEST
			|| (event.getId() == ObjectID.TOA_POTTERY_BANKDEPOSIT && event.getMenuAction() == MenuAction.WIDGET_TARGET_ON_GAME_OBJECT))
		{
			//user clicked on one of these but they might get to it at some later tick.
			expectingPutAnimation = true;
			depositInteractionTick = client.getTickCount();
		}

		if ("Bank-all".equals(event.getMenuOption()))
		{
			int inventory = -1;
			switch (WidgetUtil.componentToInterface(event.getParam1()))
			{
				case InterfaceID.RAIDS_REWARDS:
					inventory = InventoryID.RAIDS_REWARDS;
					break;
				case InterfaceID.FOSSIL_DRIFTNET:
					inventory = InventoryID.MACRO_CERTER;
					break;
				case InterfaceID.COLOSSEUM_REWARD_CHEST_2:
					inventory = InventoryID.COLOSSEUM_REWARDS;
					break;
				case InterfaceID.PMOON_REWARD:
					inventory = InventoryID.PMOON_REWARDINV;
					break;
				case InterfaceID.TOA_CHESTS:
					inventory = InventoryID.TOA_CHESTS;
					break;
				case InterfaceID.TOB_CHESTS:
					inventory = InventoryID.TOB_CHESTS;
					break;
				case InterfaceID.TRAWLER_REWARD:
					inventory = InventoryID.TRAWLER_REWARDINV;
					break;
				case InterfaceID.WILDY_LOOT_CHEST:
					inventory = InventoryID.LOOT_INV_ACCESS;
					break;
			}
			if (inventory != -1)
			{
				ItemContainer rewardsItemContainer = client.getItemContainer(inventory);
				if (rewardsItemContainer != null)
				{
					refreshQtyMap(rewardsQtyMap, rewardsItemContainer);
					for (int itemId: rewardsQtyMap.keySet())
					{
						runData.bankedItemQtys.merge(itemId, rewardsQtyMap.get(itemId), Float::sum);
					}
					updatePluginState(false);
				}
			}
		}
	}
	
	@Subscribe
	public void onAnimationChanged(final AnimationChanged event) {
		
		if (!expectingPutAnimation || (client.getTickCount() - depositInteractionTick) > interactionTickThreshold)
		{
			return;
		}
		if (event.getActor() == client.getLocalPlayer()) {
			
			if (event.getActor().getAnimation() == 834 //put item
				|| event.getActor().getAnimation() == 9402)//deposit runes
			{
				updatePluginState(true);
				expectingPutAnimation = false;
			}
		}
	}

	boolean isBanking()
	{
		//Collect on bank
		//Don't want it to appear there but have it count as bank still
		Widget collectOnBank = client.getWidget(402, 2);
		if (collectOnBank != null && !collectOnBank.isHidden())
			return true;
		//Grand exchange can be open while inventory widget is closed, same functionality as above
		Widget grandExchange = client.getWidget(InterfaceID.GeOffers.UNIVERSE);
		if (grandExchange != null && !grandExchange.isHidden())
			return true;
		//tool leprechauns
		Widget toolLeprechaun = client.getWidget(125, 0);
		if (toolLeprechaun != null && !toolLeprechaun.isHidden())
			return true;


		if (inventoryWidget == null || inventoryWidget.getCanvasLocation().getX() < 0 || inventoryWidget.isHidden())
		{
			Widget [] altInventoryWidgets = new Widget[]
			{
				//Group Ironman Bank
				client.getWidget(725, 0),
				//Bank
				client.getWidget(InterfaceID.Bankside.ITEMS),
				//GE
				client.getWidget(InterfaceID.GeOffersSide.ITEMS),
				//Seed vault
				client.getWidget(InterfaceID.SeedVaultDeposit.INV),
				//Bank with equipment view open
				client.getWidget(InterfaceID.BANKSIDE, 4),
				//Bank with looting bag open
				client.getWidget(InterfaceID.BANKSIDE, 5),
				//Bank with rune pouch open
				client.getWidget(InterfaceID.BANKSIDE, 19),
				//Deposit box open
				client.getWidget(907, 0),
				//COX storage open
				client.getWidget(InterfaceID.RAIDS_STORAGE_SIDE, 1)
			};

			for (Widget altInventoryWidget: altInventoryWidgets)
			{
				inventoryWidget = altInventoryWidget;
				if (inventoryWidget != null && !inventoryWidget.isHidden())
				{
					return true;
				}
			}
		}
		return false;
	}
	
	void updatePluginState(boolean forceBanking)
	{
		if (runData == null)
			return;
		inventoryWidget = client.getWidget(InterfaceID.Inventory.ITEMS);

		inventoryItemContainer = client.getItemContainer(InventoryID.INV);
		equipmentItemContainer = client.getItemContainer(InventoryID.WORN);

		if (config.inventoryOverlayDisplayMode() == ActiveTripOverlay.InventoryOverlayDisplayMode.INVENTORY_TOTAL)
		{
			setMode(TrackingMode.TOTAL);
		}
		else
		{
			setMode(TrackingMode.PROFIT_LOSS);
		}

		boolean isBank = runData.isFirstRun || forceBanking || isBanking();

		if (isBank)
		{
			setState(RunState.BANK);
		}
		else
		{
			setState(RunState.RUN);
		}

		boolean newRun = getPreviousState() == RunState.BANK && getState() == RunState.RUN;
		
		getRunData().itemQtys.clear();
		long inventoryTotal = getInventoryTotal(false);
		long equipmentTotal = getEquipmentTotal(false);
		long rewardsTotal = getRewardsTotal();

		long totalGp = inventoryTotal;
		if (getState() == RunState.RUN && getMode() == TrackingMode.PROFIT_LOSS)
		{
			totalGp += equipmentTotal + rewardsTotal;
		}

		setTotalGp(totalGp);

		if (newRun)
		{
			onNewRun();

			postNewRun = true;
			newRunTick = client.getTickCount();
		}
		else if (getPreviousState() != RunState.BANK && getState() == RunState.BANK)
		{
			onBank();
		}

		// check post new run, need to wait one tick because if you withdraw something and close the bank right after it shows up one tick later
		if (postNewRun && (client.getTickCount() - newRunTick) > 0)
		{
			//make sure user didn't open the bank back up in those two ticks
			if (getState() == RunState.RUN)
			{
				postNewRun();
			}
			else
			{
				getRunData().isBankDelay = false;
			}
			postNewRun = false;
		}
	}

	void onNewRun()
	{
		runData.isBankDelay = true;
		runData.runStartTime = Instant.now().toEpochMilli();

		previousTotalGp = null;
	}

	// to handle same tick bank closing
	void postNewRun()
	{
		runData.initialItemQtys.clear();
		runData.bankedItemQtys.clear();
		runData.itemQtys.clear();

		getInventoryTotal(true);
		getEquipmentTotal(true);

		if (mode == TrackingMode.PROFIT_LOSS)
		{
			initialGp = getInitialGp();
		}
		else
		{
			initialGp = 0;
		}

		runData.isBankDelay = false;
		writeSavedData(this.currentProfileKey);

		sessionManager.onTripStarted(runData);
	}

	void onBank()
	{
		runData.runEndTime = Instant.now().toEpochMilli();
		if (!runData.isFirstRun)
		{
			sessionManager.onTripCompleted(runData);
		}
		runData = createRunData();
		initialGp = 0;
	}

	long getInventoryTotal(boolean isNewRun)
	{
		if (inventoryItemContainer == null)
		{
			return 0l;
		}

		double totalGp = 0;
		refreshQtyMap(inventoryQtyMap, inventoryItemContainer);
		
		for (Integer itemId: inventoryQtyMap.keySet())
		{
			float gePrice = getPrice(itemId);
			float itemQty = inventoryQtyMap.get(itemId);
			totalGp += (itemQty * gePrice);
			updateRunData(isNewRun, itemId, itemQty, gePrice);
		}

		return (long) totalGp;
	}

	long getRewardsTotal()
	{
		double totalGp = 0;

		for (Integer itemId: runData.bankedItemQtys.keySet())
		{
			float gePrice = getPrice(itemId);
			float itemQty = runData.bankedItemQtys.get(itemId);
			totalGp += (itemQty * gePrice);
			updateRunData(false, itemId, itemQty, gePrice);
		}

		return (long) totalGp;
	}

    public void openConfiguration() {
		// We don't have access to the ConfigPlugin so let's just emulate an overlay click
		this.eventBus.post(new OverlayMenuClicked(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, null, null), this.tripOverlay));
    }

	public void refreshPrices()
	{
		List<Integer> itemIds = new LinkedList<>(itemPrices.keySet());
		itemPrices.clear();
		for(Integer itemId : itemIds)
		{
			itemPrices.put(itemId, getPrice(itemId));
		}
	}

	private void addChargedWeaponComponents(Map<Integer, Float> qtyMap)
	{
		Map<Integer, Float> chargedWeaponComponents = getChargedWeaponComponentQtyMap(qtyMap.keySet());
		for (int itemId: chargedWeaponComponents.keySet()) {
			qtyMap.merge(itemId, chargedWeaponComponents.get(itemId), Float::sum);
		}
	}

	private void addChargedItemComponents(Map<Integer, Float> qtyMap)
	{
		Map<Integer, Float> chargedItemComponents = getChargedItemQtyMap(qtyMap.keySet());
		for (int itemId: chargedItemComponents.keySet()) {
			qtyMap.merge(itemId, chargedItemComponents.get(itemId), Float::sum);
		}
	}

	long getEquipmentTotal(boolean isNewRun)
	{
		refreshQtyMap(equipmentQtyMap, equipmentItemContainer);

		double eTotal = 0;
		for (int itemId: equipmentQtyMap.keySet())
		{
			float qty = equipmentQtyMap.get(itemId);
			float gePrice = getPrice(itemId);
			eTotal += (qty * gePrice);
			updateRunData(isNewRun, itemId, qty, gePrice);
		}

		return (long) eTotal;
	}

	//avoid GC
	private final Map<Integer, Float> chargedWeaponComponentQtyMap = new HashMap<>();
	private Map<Integer, Float> getChargedWeaponComponentQtyMap(Set<Integer> itemIdsToCheck)
	{
		chargedWeaponComponentQtyMap.clear();
		for (int itemId: itemIdsToCheck) {
			if (weaponChargesManager.isChargeableWeapon(itemId) && weaponChargesManager.hasChargeData(itemId))
			{
				Map<Integer, Float> chargeComponents = weaponChargesManager.getChargeComponents(itemId);
				for (Integer chargeComponentItemId: chargeComponents.keySet())
				{
					chargedWeaponComponentQtyMap.merge(chargeComponentItemId, chargeComponents.get(chargeComponentItemId), Float::sum);
				}
			}
		}
		return chargedWeaponComponentQtyMap;
	}

	//avoid GC
	private final Map<Integer, Float> chargedItemQtyMap = new HashMap<>();
	private Map<Integer, Float> getChargedItemQtyMap(Set<Integer> itemIdsToCheck)
	{
		chargedItemQtyMap.clear();
		for (int itemId: itemIdsToCheck) {
			if (chargedItemManager.isChargeableItem(itemId) && chargedItemManager.hasChargeData(itemId))
			{
				Map<Integer, Float> itemContents = chargedItemManager.getItemQuantities(itemId);
				for (Integer itemContentId: itemContents.keySet())
				{
					chargedItemQtyMap.merge(itemContentId, itemContents.get(itemContentId), Float::sum);
				}
			}
		}
		return chargedItemQtyMap;
	}

	List<LedgerItem> getInventoryLedger()
	{
		List<LedgerItem> ledgerItems = new LinkedList<>();

		if (inventoryItemContainer == null)
		{
			return new LinkedList<>();
		}

		refreshQtyMap(inventoryQtyMap, inventoryItemContainer);

		for (Integer itemId: inventoryQtyMap.keySet())
		{
			final ItemComposition itemComposition = itemManager.getItemComposition(itemId);

			String itemName = itemComposition.getName();

			Float qty = inventoryQtyMap.get(itemId);

			Float price = itemPrices.get(itemId);
			if (price == null)
			{
				price = 1f;
			}

			ledgerItems.add(new LedgerItem(itemName, qty, price, itemId));
		}

		return ledgerItems;
	}


	void refreshQtyMap(Map<Integer,Float> qtyMap, ItemContainer container)
	{
		qtyMap.clear();
		if (container==null)
		{
			return;
		}

		final Item[] containerItems = container.getItems();
		for (int i = 0; i < containerItems.length; ++i)
		{
			int itemId = containerItems[i].getId();
			if (itemId == -1)
				continue;

			ItemComposition itemComposition = itemManager.getItemComposition(itemId);
			String itemName = itemComposition.getName();
			boolean ignore = ignoredItems.contains(itemName.toLowerCase());
			if (ignore) { continue; }
				
			qtyMap.merge(itemId, (float) containerItems[i].getQuantity(), Float::sum);

			if (itemId == RUNEPOUCH_ITEM_ID || itemId == DIVINE_RUNEPOUCH_ITEM_ID || itemId == RUNEPOUCH_TROUVER_ITEM_ID || itemId == DIVINE_RUNEPOUCH_TROUVER_ITEM_ID)
			{
				addRunepouchContents(qtyMap);
			}
			else if(itemId == ItemID.LOOTING_BAG || itemId == ItemID.LOOTING_BAG_OPEN)
			{
				lootingBagManager.addLootingBagContents(qtyMap);
			}
		}
		addChargedWeaponComponents(qtyMap);
		addChargedItemComponents(qtyMap);
		FractionalRemapper.Remap(qtyMap);
	}

	@Getter
	private final HashSet<String> chargeableItemsNeedingCheck = new HashSet<>();

	void updateChargeableItemsNeedingCheck()
	{
		chargeableItemsNeedingCheck.clear();
		if (this.state == RunState.BANK)
			return;

		checkQtyMapForCheck(inventoryQtyMap.keySet());
		checkQtyMapForCheck(equipmentQtyMap.keySet());
	}

	void checkQtyMapForCheck(Set<Integer> keySet)
	{
		for (Integer itemId : keySet)
		{
			if ((itemId == ItemID.LOOTING_BAG || itemId == ItemID.LOOTING_BAG_OPEN) && lootingBagManager.needsCheck())
			{
				chargeableItemsNeedingCheck.add("looting bag");
			}
			else if (weaponChargesManager.isChargeableWeapon(itemId) && !weaponChargesManager.hasChargeData(itemId))
			{
				chargeableItemsNeedingCheck.add(itemManager.getItemComposition(itemId).getName().toLowerCase());
			} 
			else if (chargedItemManager.isChargeableItem(itemId) && !chargedItemManager.hasChargeData(itemId))
			{
				chargeableItemsNeedingCheck.add(itemManager.getItemComposition(itemId).getName().toLowerCase());
			} 
		}
	}

	static List<LedgerItem> getProfitLossLedger(Map<Integer, Float> initialQtys, Map<Integer, Float> qtys)
	{
		Map<Integer, Float> qtyDifferences = new HashMap<>(initialQtys.size());

		HashSet<Integer> combinedQtyKeys = new HashSet<>(initialQtys.size());
		combinedQtyKeys.addAll(qtys.keySet());
		combinedQtyKeys.addAll(initialQtys.keySet());

		for (Integer itemId: combinedQtyKeys)
		{
			Float initialQty = initialQtys.get(itemId);
			Float qty = qtys.get(itemId);

			if (initialQty == null)
			{
				initialQty = 0f;
			}

			if (qty == null)
			{
				qty = 0f;
			}

			qtyDifferences.put(itemId, qty - initialQty);
		}

		Map<String, LedgerItem> ledgerItems  = new HashMap<>(qtyDifferences.size());

		for (Integer itemId: qtyDifferences.keySet())
		{
			String name = itemNames.get(itemId);
			if (name == null)
			{
				continue;
			}
			Float price = itemPrices.get(itemId);
			if (price == null)
			{
				price = 1f;
			}

			Float qtyDifference = qtyDifferences.get(itemId);

			if (ledgerItems.containsKey(name))
			{
				ledgerItems.get(name).addQuantityDifference(qtyDifference);
			}
			else
			{
				if (price != 0)
				{
					ledgerItems.put(name, new LedgerItem(name, qtyDifference, price, itemId));
				}
			}
		}

		//filter out quantities less than round amount here!
		List<LedgerItem> ledgerItemsFiltered = new LinkedList<>();
		for (LedgerItem item : ledgerItems.values())
		{
			if (Math.abs(item.getQty()) > (roundAmount/2f))
			{
				ledgerItemsFiltered.add(item);
			}
		}

		return ledgerItemsFiltered;
	}

	// from ClueScrollPlugin
	private void addRunepouchContents(Map<Integer, Float> qtyMap)
	{
		EnumComposition runepouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);
		for (int i = 0; i < RUNEPOUCH_AMOUNT_VARBITS.length; i++)
		{
			int amount = client.getVarbitValue(RUNEPOUCH_AMOUNT_VARBITS[i]);
			if (amount <= 0)
			{
				continue;
			}

			int runeId = client.getVarbitValue(RUNEPOUCH_RUNE_VARBITS[i]);
			int itemId = runepouchEnum.getIntValue(runeId);
			ItemComposition itemComposition = itemManager.getItemComposition(itemId);
			String itemName = itemComposition.getName();
			boolean ignore = ignoredItems.contains(itemName.toLowerCase());
			if (runeId == 0 || ignore)
			{
				continue;
			}

			qtyMap.merge(itemId, (float) amount, Float::sum);
		}
	}

	void updateRunData(boolean isNewRun, int itemId, float itemQty, float gePrice)
	{
		if (itemId != COINS && !itemPrices.containsKey(itemId))
		{
			itemPrices.put(itemId, gePrice);
		}

		itemNames.put(itemId, itemManager.getItemComposition(itemId).getName());

		if (isNewRun)
		{
			if (runData.initialItemQtys.containsKey(itemId))
			{
				runData.initialItemQtys.put(itemId, runData.initialItemQtys.get(itemId) + itemQty);
			}
			else
			{
				runData.initialItemQtys.put(itemId, itemQty);
			}
		}

		if (runData.itemQtys.containsKey(itemId))
		{
			runData.itemQtys.put(itemId, runData.itemQtys.get(itemId) + itemQty);
		}
		else
		{
			runData.itemQtys.put(itemId, itemQty);
		}
	}

	float getPrice(int itemId)
	{
		if (itemId == COINS)
			return 1f;
		if (itemId == ItemID.PLATINUM)
			return 1000f;
		if (itemPrices.containsKey(itemId))
		{
			return itemPrices.get(itemId);
		}
		else
		{
			Float remappedValue = ValueRemapper.remapPrice(itemId, this, config);
			if (remappedValue != null)
			{
				return remappedValue;
			}
			else
			{
				if (config.valueMode() == ValueMode.RUNELITE_VALUE)
				{
					return itemManager.getItemPrice(itemId);
				}
				else 
				{
					ItemComposition itemDef = itemManager.getItemComposition(itemId);
					// Only check prices for things with store prices
					int itemPrice = itemDef.getPrice();
					if (itemPrice <= 0)
					{
						return 0;
					}
					//Low alch is always 0.4 of store price, high alch is always 0.6 of store price
					return (config.valueMode() == ValueMode.LOW_ALCHEMY_VALUE) ? (itemPrice * .4f) : (itemPrice * .6f);
				}
			}
		}
	}

	void writeSavedData(String profileKey)
	{
		if (runData == null || runData.isFirstRun)
			return;
		executor.execute(() ->
		{
			String json = gson.toJson(runData);
			configManager.setConfiguration(GPPerHourConfig.GROUP, profileKey, "inventory_total_data", json);
		});
	}

	private TripData getSavedData()
	{
		String json = readData( "inventory_total_data");
		TripData savedData = null;
		try 
		{
			savedData = gson.fromJson(json, TripData.class);
		}
		catch(Exception e)
		{
			log.error("Failed to load run data from json: " + json, e);
		}

		if (savedData == null)
		{
			TripData runData = createRunData();
			runData.isFirstRun = true;
			return runData;
		}
		return savedData;
	}

	private TripData createRunData()
	{
		TripData data = new TripData();
		data.identifier = UUID.randomUUID().toString();
		return data;
	}

	private LinkedList<String> getIgnoredItems() {
		return new LinkedList<>(
			Arrays.asList(
				config.ignoredItems().split("\\s*,\\s*")
			)
		);
	}

	long elapsedRunTime()
	{
		if (runData.runStartTime == 0)
		{
			return NO_PROFIT_LOSS_TIME;
		}

		return runData.getRuntime();
	}

	void setMode(TrackingMode mode)
	{
		this.mode = mode;

		switch(mode)
		{
			case TOTAL:
				initialGp = 0;
				break;
			case PROFIT_LOSS:
				initialGp = getInitialGp();
				break;
		}
	}

	long getInitialGp()
	{
		if (runData == null)
			return 0;
		double value = 0;
		for (java.util.Map.Entry<Integer, Float> entry : runData.initialItemQtys.entrySet())
		{
			value += getPrice(entry.getKey()) * entry.getValue();
		}
		return (long) value;
	}

	void setState(RunState state)
	{
		this.previousState = this.state;
		this.state = state;
	}

	public long getProfitGp()
	{
		return totalGp - initialGp;
	}

	void saveData(String key, String data)
	{
		configManager.setRSProfileConfiguration(GPPerHourConfig.GROUP, key, data);
	}

	String readData(String key)
	{
		return configManager.getRSProfileConfiguration(GPPerHourConfig.GROUP, key);
	}

	<T> void saveData(String key, T data)
	{
		configManager.setRSProfileConfiguration(GPPerHourConfig.GROUP, key, data);
	}

	void deleteData(String key)
	{
		configManager.unsetRSProfileConfiguration(GPPerHourConfig.GROUP, key);
	}
}

/*
 * Copyright (c) 2023, Eric Versteeg <https://github.com/erversteeg>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

public enum TripOverlayAlignment {
    CENTER,
    LEFT,
    RIGHT
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.Consumer;

import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.AbstractDocument;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DocumentFilter;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.FlatTextField;

@Slf4j
//Used for session history panel
public class EditableNameField extends JPanel
{
    private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
            BorderFactory.createMatteBorder(0, 0, 0, 0, ColorScheme.DARK_GRAY_COLOR),
            BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));

    private String name;
    private final JLabel save = new JLabel("Save");
    private final JLabel cancel = new JLabel("Cancel");
    private final JLabel edit = new JLabel("Edit Name");
    private final MouseAdapter flatTextFieldMouseAdapter;
    @Getter
    private final FlatTextField nameInput = new FlatTextField();
    private Consumer<String> onNameSaved;

    public void setData(String name, Consumer<String> callback)
    {
        if(!name.equals(this.name))
        {
            if (isEditing)
            {
                stopEditing();
            }
            this.name = name;
            nameInput.setText(name);
            updateSaveButtonDuringEditing();
        }
        this.onNameSaved = callback;
    }

    public EditableNameField(final SessionHistoryPanel panel, int maxLength,
            final Color panelColor, final MouseAdapter flatTextFieldMouseAdapter)
    {
        this.flatTextFieldMouseAdapter = flatTextFieldMouseAdapter;
        setLayout(new BorderLayout());

        setBackground(panelColor);
        setBorder(NAME_BOTTOM_BORDER);

        JPanel nameActions = new JPanel(new BorderLayout(3, 0));
        nameActions.setBorder(new EmptyBorder(0, 0, 0, 8));
        nameActions.setBackground(panelColor);

        // Limit character input
        AbstractDocument doc = (AbstractDocument) nameInput.getDocument();
        doc.setDocumentFilter(new DocumentFilter()
        {
            @Override
            public void insertString(FilterBypass fb, int offset, String str, AttributeSet a)
                    throws BadLocationException
            {
                if ((fb.getDocument().getLength() + str.length()) <= maxLength)
                {
                    super.insertString(fb, offset, str, a);
                }
            }

            // Replace handles pasting
            @Override
            public void replace(FilterBypass fb, int offset, int length, String str, AttributeSet a)
                    throws BadLocationException
            {
                if ((fb.getDocument().getLength() + str.length() - length) >= maxLength)
                {
                    // If the user pastes a huge amount of text, cut it out until the maximum length
                    // is achieved
                    int chars_available = maxLength - (fb.getDocument().getLength() - length);
                    int chars_to_cut = str.length() - chars_available;
                    str = str.substring(0, str.length() - chars_to_cut);
                }
                super.replace(fb, offset, length, str, a);
            }
        });

        // Add document listener to disable save button when the name isn't valid
        nameInput.getDocument().addDocumentListener(new DocumentListener()
        {
            @Override
            public void insertUpdate(DocumentEvent e)
            {
                updateSaveButtonDuringEditing();
            }

            @Override
            public void removeUpdate(DocumentEvent e)
            {
                updateSaveButtonDuringEditing();
            }

            @Override
            public void changedUpdate(DocumentEvent e)
            {
                updateSaveButtonDuringEditing();
            }
        });

        nameInput.getTextField().addMouseListener(flatTextFieldMouseAdapter);

        save.setVisible(false);
        save.setFont(FontManager.getRunescapeSmallFont());
        save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
        save.setBackground(panelColor);
        save.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                if (SwingUtilities.isLeftMouseButton(mouseEvent) && save.isEnabled())
                {
                    name = nameInput.getText();
                    onNameSaved.accept(name);

                    panel.redrawPanels(false);

                    stopEditing();
                }
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                if (!nameInput.getText().isEmpty())
                {
                    save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR.darker());
                } else
                {
                    save.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
                }
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                if (!nameInput.getText().isEmpty())
                {
                    save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
                } else
                {
                    save.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
                }
            }
        });

        cancel.setVisible(false);
        cancel.setFont(FontManager.getRunescapeSmallFont());
        cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
        cancel.setBackground(panelColor);
        cancel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                if (SwingUtilities.isLeftMouseButton(mouseEvent))
                {
                    nameInput.setText(name);
                    stopEditing();
                }
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR.darker());
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
            }
        });

        edit.setFont(FontManager.getRunescapeSmallFont());
        edit.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
        edit.setBackground(panelColor);
        edit.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                if (SwingUtilities.isLeftMouseButton(mouseEvent))
                {
                    startEditing();
                }
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                edit.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker().darker());
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                edit.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
            }
        });

        nameActions.add(save, BorderLayout.EAST);
        nameActions.add(cancel, BorderLayout.WEST);
        nameActions.add(edit, BorderLayout.CENTER);

        nameInput.setBorder(null);
        nameInput.setEditable(false);
        nameInput.setBackground(panelColor);
        nameInput.setPreferredSize(new Dimension(0, 24));
        nameInput.getTextField().setForeground(Color.WHITE);
        nameInput.getTextField().setBackground(panelColor);
        nameInput.getTextField().setBorder(new EmptyBorder(0, 6, 0, 0));
        nameInput.getTextField().setCaretPosition(0);

        final JPanel wrapper = new JPanel();
        wrapper.setBackground(panelColor);
        wrapper.setLayout(new BorderLayout());
        wrapper.setBorder(new EmptyBorder(3, 0, 3, 0));
        wrapper.add(nameInput, BorderLayout.CENTER);
        wrapper.add(nameActions, BorderLayout.EAST);
        add(wrapper, BorderLayout.CENTER);
    }

    private boolean isEditing = false;
    
    private void startEditing()
    {
        isEditing = true;
        // Remove the mouse listener so clicking it doesn't exit the edit screen
        nameInput.getTextField().removeMouseListener(flatTextFieldMouseAdapter);
        nameInput.setEditable(true);
        updateNameActions(true);
    }

    private void stopEditing()
    {
        isEditing = false;
        nameInput.getTextField().addMouseListener(flatTextFieldMouseAdapter);
        nameInput.getTextField().setCaretPosition(0);
        nameInput.setEditable(false);
        updateNameActions(false);
        requestFocusInWindow();
    }

    private void updateNameActions(boolean saveAndCancel)
    {
        save.setVisible(saveAndCancel);
        cancel.setVisible(saveAndCancel);
        edit.setVisible(!saveAndCancel);

        if (saveAndCancel)
        {
            nameInput.getTextField().requestFocusInWindow();
            nameInput.getTextField().selectAll();
        }
    }

    private void updateSaveButtonDuringEditing()
    {
        // If nothing has changed or name is invalid, disable the save button
        if (nameInput.getText().isEmpty() || nameInput.getText().equals(this.name))
        {
            save.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
            save.setEnabled(false);
        } else
        {
            save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
            save.setEnabled(true);
        }
    }

}

/*
 * Copyright (c) 2023, Eric Versteeg <https://github.com/erversteeg>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

//What state are we currenlty in?
public enum RunState {
    NONE,
    BANK,
    RUN
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

import java.awt.image.BufferedImage;
import java.util.Map;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
//Stores data from a 'session' which is a collection of 'trips'
class SessionStats
{
	String sessionID;
	String sessionName;
	private final long sessionSaveTime;
	private final long sessionRuntime;
	private final long totalGain;
	private final long totalLoss;
	private final long netTotal;
	private final int tripCount;
	private final long avgTripDuration;
	private final Map<Integer, Float> initialQtys;
	private final Map<Integer, Float> qtys;

	//ui state (this could probably be done without having view and model code merged but it would be a lot of work)
	transient boolean showDetails;
	transient BufferedImage coinsImage;
}

/*
 * Copyright (c) 2023, Eric Versteeg <https://github.com/erversteeg>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

//Only affects trip overlay and gold drops. Total shows inventory total, profit loss shows net total or gp/hr.
public enum TrackingMode {
    TOTAL,
    PROFIT_LOSS
}

/*
 * Copyright (c) 2023, Moshe Ben-Zacharia <https://github.com/MosheBenZacharia>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gpperhour;

//import static net.runelite.api.gameval.ItemID.*;

import java.util.HashMap;
import java.util.Map;

import lombok.AllArgsConstructor;
        import net.runelite.api.gameval.ItemID;

//Remaps the value of untradeable items to their commonly traded counterpart based on user config.
//Also remaps value of certain containers (hallowed sack, brimstone key, etc.) to their average value.
public class ValueRemapper {

    //Used for when a value maps 1:1 with another value
    private static final Map<Integer, Integer> directValueRemaps;

    static
    {
        directValueRemaps = new HashMap<>();

        //Seedling to sapling
        directValueRemaps.put(ItemID.PLANTPOT_ACORN, ItemID.PLANTPOT_OAK_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_WILLOW_SEED, ItemID.PLANTPOT_WILLOW_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_MAPLE_SEED, ItemID.PLANTPOT_MAPLE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_YEW_SEED, ItemID.PLANTPOT_YEW_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_MAGIC_TREE_SEED, ItemID.PLANTPOT_MAGIC_TREE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_REDWOOD_TREE_SEED, ItemID.PLANTPOT_REDWOOD_TREE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_SPIRIT_TREE_SEED, ItemID.PLANTPOT_SPIRIT_TREE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_CRYSTAL_TREE_SEED, ItemID.PLANTPOT_CRYSTAL_TREE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_APPLE_SEED, ItemID.PLANTPOT_APPLE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_BANANA_SEED, ItemID.PLANTPOT_BANANA_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_ORANGE_SEED, ItemID.PLANTPOT_ORANGE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_CURRY_SEED, ItemID.PLANTPOT_CURRY_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_PINEAPPLE_SEED, ItemID.PLANTPOT_PINEAPPLE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_PAPAYA_SEED, ItemID.PLANTPOT_PAPAYA_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_PALM_SEED, ItemID.PLANTPOT_PALM_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_DRAGONFRUIT_SEED, ItemID.PLANTPOT_DRAGONFRUIT_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_TEAK_SEED, ItemID.PLANTPOT_TEAK_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_MAHOGANY_SEED, ItemID.PLANTPOT_MAHOGANY_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_CALQUAT_SEED, ItemID.PLANTPOT_CALQUAT_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_CELASTRUS_TREE_SEED, ItemID.PLANTPOT_CELASTRUS_TREE_SAPLING);
        //Watered seedling to sapling
        directValueRemaps.put(ItemID.PLANTPOT_ACORN_WATERED, ItemID.PLANTPOT_OAK_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_WILLOW_SEED_WATERED, ItemID.PLANTPOT_WILLOW_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_MAPLE_SEED_WATERED, ItemID.PLANTPOT_MAPLE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_YEW_SEED_WATERED, ItemID.PLANTPOT_YEW_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_MAGIC_TREE_SEED_WATERED, ItemID.PLANTPOT_MAGIC_TREE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_REDWOOD_TREE_SEED_WATERED, ItemID.PLANTPOT_REDWOOD_TREE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_SPIRIT_TREE_SEED_WATERED, ItemID.PLANTPOT_SPIRIT_TREE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_CRYSTAL_TREE_SEED_WATERED, ItemID.PLANTPOT_CRYSTAL_TREE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_APPLE_SEED_WATERED, ItemID.PLANTPOT_APPLE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_BANANA_SEED_WATERED, ItemID.PLANTPOT_BANANA_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_ORANGE_SEED_WATERED, ItemID.PLANTPOT_ORANGE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_CURRY_SEED_WATERED, ItemID.PLANTPOT_CURRY_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_PINEAPPLE_SEED_WATERED, ItemID.PLANTPOT_PINEAPPLE_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_PAPAYA_SEED_WATERED, ItemID.PLANTPOT_PAPAYA_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_PALM_SEED_WATERED, ItemID.PLANTPOT_PALM_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_DRAGONFRUIT_SEED_WATERED, ItemID.PLANTPOT_DRAGONFRUIT_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_TEAK_SEED_WATERED, ItemID.PLANTPOT_TEAK_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_MAHOGANY_SEED_WATERED, ItemID.PLANTPOT_MAHOGANY_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_CALQUAT_SEED_WATERED, ItemID.PLANTPOT_CALQUAT_SAPLING);
        directValueRemaps.put(ItemID.PLANTPOT_CELASTRUS_TREE_SEED_WATERED, ItemID.PLANTPOT_CELASTRUS_TREE_SAPLING);
    }

    public static Float remapPrice(int itemId, GPPerHourPlugin plugin, GPPerHourConfig config)
    {
        if (directValueRemaps.containsKey(itemId))
        {
            return plugin.getPrice(directValueRemaps.get(itemId));
        }
        if (itemId == ItemID.KONAR_KEY)
        {
            if (config.brimstoneKeyValue() == BrimstoneKeyOverride.NO_VALUE)
            {
                return 0f;
            }
            //doesn't include fish because of how complex it is
            float value = 
                    (5f/60f)*100000f +// coins
                    (5f/60f)*plugin.getPrice(ItemID.UNCUT_DIAMOND)*30F +
                    (5f/60f)*plugin.getPrice(ItemID.UNCUT_RUBY)*30F +
                    (5f/60f)*plugin.getPrice(ItemID.COAL)*400F +
                    (4f/60f)*plugin.getPrice(ItemID.GOLD_ORE)*150F +
                    (4f/60f)*plugin.getPrice(ItemID.DRAGON_ARROWHEADS)*125F +
                    (3f/60f)*plugin.getPrice(ItemID.IRON_ORE)*425F +
                    (3f/60f)*plugin.getPrice(ItemID.RUNE_FULL_HELM)*3F +
                    (3f/60f)*plugin.getPrice(ItemID.RUNE_PLATELEGS)*1.5F +
                    (3f/60f)*plugin.getPrice(ItemID.RUNE_PLATEBODY)*1.5F +
                    (2f/60f)*plugin.getPrice(ItemID.RUNITE_ORE)*12.5F +
                    (2f/60f)*plugin.getPrice(ItemID.STEEL_BAR)*400F +
                    (2f/60f)*plugin.getPrice(ItemID.DRAGON_DART_TIP)*100F +
                    (2f/60f)*plugin.getPrice(ItemID.MAGIC_LOGS)*140F +
                    (1f/60f)*plugin.getPrice(ItemID.PALM_TREE_SEED)*3F +
                    (1f/60f)*plugin.getPrice(ItemID.MAGIC_TREE_SEED)*2.5F +
                    (1f/60f)*plugin.getPrice(ItemID.CELASTRUS_TREE_SEED)*3F +
                    (1f/60f)*plugin.getPrice(ItemID.DRAGONFRUIT_TREE_SEED)*3F +
                    (1f/60f)*plugin.getPrice(ItemID.REDWOOD_TREE_SEED)*1F +
                    (1f/60f)*plugin.getPrice(ItemID.TORSTOL_SEED)*4F +
                    (1f/60f)*plugin.getPrice(ItemID.SNAPDRAGON_SEED)*4F +
                    (1f/60f)*plugin.getPrice(ItemID.RANARR_SEED)*4F +
                    (1f/60f)*plugin.getPrice(ItemID.BLANKRUNE_HIGH)*4500F +
                    (1f/200f)*plugin.getPrice(ItemID.BRUT_DRAGON_SPEAR)*1F +
                    (1f/1000f)*plugin.getPrice(ItemID.MYSTIC_ROBE_TOP_DUSK)*1f +
                    (1f/1000f)*plugin.getPrice(ItemID.MYSTIC_ROBE_BOTTOM_DUSK)*1f +
                    (1f/1000f)*plugin.getPrice(ItemID.MYSTIC_GLOVES_DUSK)*1f +
                    (1f/1000f)*plugin.getPrice(ItemID.MYSTIC_BOOTS_DUSK)*1f +
                    (1f/1000f)*plugin.getPrice(ItemID.MYSTIC_HAT_DUSK)*1f;
            return value;
        }
        else if (itemId == ItemID.TZHAAR_TOKEN)
        {
            switch(config.tokkulValue())
            {
                case NO_VALUE:
                default:
                    return 0f;
                //overstock price for runes since they hit overstock quickly. overstock price same with/without gloves.
                case BUY_CHAOS_RUNE:
                    return plugin.getPrice(ItemID.CHAOSRUNE) / 9f;
                case BUY_DEATH_RUNE:
                    return plugin.getPrice(ItemID.DEATHRUNE) / 18f;
                case SELL_OBBY_CAPE:
                    return plugin.getPrice(ItemID.TZHAAR_CAPE_OBSIDIAN) / (config.tokkulKaramjaGloves() ? 78000f : 90000f);
                case SELL_TOKTZ_KET_XIL:
                    return plugin.getPrice(ItemID.TZHAAR_SPIKESHIELD) / (config.tokkulKaramjaGloves() ? 58500f : 67500f);
                case SELL_TOKTZ_MEJ_TAL:
                    return plugin.getPrice(ItemID.TZHAAR_STAFF) / (config.tokkulKaramjaGloves() ? 45500f : 52500f);
                case SELL_UNCUT_ONYX:
                    return plugin.getPrice(ItemID.UNCUT_ONYX) / (config.tokkulKaramjaGloves() ? 260000f : 300000f);
            }
        }
        else if (itemId == ItemID.PRIF_CRYSTAL_SHARD)
        {
            switch(config.crystalShardValue())
            {
                case NO_VALUE:
                default:
                    return 0f;
                case BUY_TELEPORT_SEED:
                    return plugin.getPrice(ItemID.PRIF_TELEPORT_SEED) / 150f;
                case SELL_BASTION:
                    return (plugin.getPrice(ItemID._4DOSEDIVINEBASTION) - plugin.getPrice(ItemID._4DOSEBASTION))/0.4f;
                case SELL_BATTLEMAGE:
                    return (plugin.getPrice(ItemID._4DOSEDIVINEBATTLEMAGE) - plugin.getPrice(ItemID._4DOSEBATTLEMAGE))/0.4f;
                case SELL_MAGIC:
                    return (plugin.getPrice(ItemID._4DOSEDIVINEMAGIC) - plugin.getPrice(ItemID._4DOSE1MAGIC))/0.4f;
                case SELL_RANGING:
                    return (plugin.getPrice(ItemID._4DOSEDIVINERANGE) - plugin.getPrice(ItemID._4DOSERANGERSPOTION))/0.4f;
                case SELL_SUPER_ATTACK:
                    return (plugin.getPrice(ItemID._4DOSEDIVINEATTACK) - plugin.getPrice(ItemID._4DOSE2ATTACK))/0.4f;
                case SELL_SUPER_COMBAT:
                    return (plugin.getPrice(ItemID._4DOSEDIVINECOMBAT) - plugin.getPrice(ItemID._4DOSE2COMBAT))/0.4f;
                case SELL_SUPER_DEFENCE:
                    return (plugin.getPrice(ItemID._4DOSEDIVINEDEFENCE) - plugin.getPrice(ItemID._4DOSE2DEFENSE))/0.4f;
                case SELL_SUPER_STRENGTH:
                    return (plugin.getPrice(ItemID._4DOSEDIVINESTRENGTH) - plugin.getPrice(ItemID._4DOSE2STRENGTH))/0.4f;
            }
        }
        else if (itemId == ItemID.PRIF_CRYSTAL_SHARD_CRUSHED)
        {
            switch(config.crystalDustValue())
            {
                case NO_VALUE:
                default:
                    return 0f;
                case SELL_BASTION:
                    return (plugin.getPrice(ItemID._4DOSEDIVINEBASTION) - plugin.getPrice(ItemID._4DOSEBASTION))/4f;
                case SELL_BATTLEMAGE:
                    return (plugin.getPrice(ItemID._4DOSEDIVINEBATTLEMAGE) - plugin.getPrice(ItemID._4DOSEBATTLEMAGE))/4f;
                case SELL_MAGIC:
                    return (plugin.getPrice(ItemID._4DOSEDIVINEMAGIC) - plugin.getPrice(ItemID._4DOSE1MAGIC))/4f;
                case SELL_RANGING:
                    return (plugin.getPrice(ItemID._4DOSEDIVINERANGE) - plugin.getPrice(ItemID._4DOSERANGERSPOTION))/4f;
                case SELL_SUPER_ATTACK:
                    return (plugin.getPrice(ItemID._4DOSEDIVINEATTACK) - plugin.getPrice(ItemID._4DOSE2ATTACK))/4f;
                case SELL_SUPER_COMBAT:
                    return (plugin.getPrice(ItemID._4DOSEDIVINECOMBAT) - plugin.getPrice(ItemID._4DOSE2COMBAT))/4f;
                case SELL_SUPER_DEFENCE:
                    return (plugin.getPrice(ItemID._4DOSEDIVINEDEFENCE) - plugin.getPrice(ItemID._4DOSE2DEFENSE))/4f;
                case SELL_SUPER_STRENGTH:
                    return (plugin.getPrice(ItemID._4DOSEDIVINESTRENGTH) - plugin.getPrice(ItemID._4DOSE2STRENGTH))/4f;
            }
        }
        else if (itemId == ItemID.FOSSIL_MERMAID_TEAR)
        {
            switch(config.mermaidsTearValue())
            {
                case NO_VALUE:
                default:
                    return 0f;
                case SELL_MERFOLK_TRIDENT:
                    return plugin.getPrice(ItemID.MERFOLK_TRIDENT)/400f;
            }
        }
        else if (itemId == ItemID.STAR_DUST)
        {
            switch(config.stardustValue())
            {
                case NO_VALUE:
                default:
                    return 0f;
                case SELL_SOFT_CLAY_PACK:
                    return plugin.getPrice(ItemID.PACK_SOFTCLAY)/150f;
                case SELL_BAG_FULL_OF_GEMS:
                    return plugin.getPrice(ItemID.REWARD_GEM_BAG)/300f;
            }
        }
        else if (itemId == ItemID.MGUILD_MINERALS)
        {
            switch(config.unidentifiedMineralsValue())
            {
                case NO_VALUE:
                default:
                    return 0f;
                case SELL_SOFT_CLAY_PACK:
                    return plugin.getPrice(ItemID.PACK_SOFTCLAY)/10f;
                case SELL_BAG_FULL_OF_GEMS:
                    return plugin.getPrice(ItemID.REWARD_GEM_BAG)/20f;
            }
        }
        else if (itemId == ItemID.MOTHERLODE_NUGGET)
        {
            switch(config.goldenNuggetValue())
            {
                case NO_VALUE:
                default:
                    return 0f;
                case SELL_SOFT_CLAY_PACK:
                    return plugin.getPrice(ItemID.PACK_SOFTCLAY)/10f;
                case SELL_BAG_FULL_OF_GEMS:
                    return plugin.getPrice(ItemID.REWARD_GEM_BAG)/40f;
            }
        }
        else if (itemId == ItemID.PACK_SOFTCLAY || itemId == ItemID.CERT_PACK_SOFTCLAY || itemId == ItemID.PACK_SOFTCLAY_GUILD || itemId == ItemID.STAR_PACK_SOFTCLAY)
        {
            return plugin.getPrice(ItemID.SOFTCLAY) * 100f;
        }
        else if (itemId == ItemID.REWARD_GEM_BAG || itemId == ItemID.REWARD_GEM_BAG_GUILD || itemId == ItemID.STAR_REWARD_GEM_BAG)
        {
            return  plugin.getPrice(ItemID.UNCUT_SAPPHIRE)*(40f / 2.003f) +
                    plugin.getPrice(ItemID.UNCUT_EMERALD)*(40f / 2.884f) +
                    plugin.getPrice(ItemID.UNCUT_RUBY)*(40f / 8.475f) +
                    plugin.getPrice(ItemID.UNCUT_DIAMOND)*(40f / 32.36f) +
                    plugin.getPrice(ItemID.UNCUT_DRAGONSTONE)*(40f / 161.3f) +
                    plugin.getPrice(ItemID.UNCUT_ONYX)*(40f / 100000000f);
        }
        else if (itemId == ItemID.ABYSSAL_PEARL)
        {
            switch(config.abyssalPearlsValue())
            {
                case NO_VALUE:
                default:
                    return 0f;
                case SELL_RING_OF_THE_ELEMENTS:
                    return plugin.getPrice(ItemID.RING_OF_ELEMENTS)/400f;
            }
        }
        else if (itemId == ItemID.HALLOWED_MARK)
        {
            switch(config.hallowedMarkValue())
            {
                case NO_VALUE:
                default:
                    return 0f;
                case SELL_HALLOWED_SACK:
                    return plugin.getPrice(ItemID.HALLOWED_SACK)/100f;
            }
        }
        else if (itemId == ItemID.HALLOWED_SACK)
        {
            return plugin.getPrice(ItemID.MONKROBETOP)*1f*.5f+
            plugin.getPrice(ItemID.MONKROBEBOTTOM)*1f*.5f+
            plugin.getPrice(ItemID.BLESSEDSTAR)*1f*.5f+
            plugin.getPrice(ItemID.AIRRUNE)*625f*.5f+
            plugin.getPrice(ItemID.FIRERUNE)*625f*.5f+
            plugin.getPrice(ItemID.CHAOSRUNE)*37.5f*.5f+
            plugin.getPrice(ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL)*100f*.5f+
            plugin.getPrice(ItemID._2DOSEPRAYERRESTORE)*1f*.5f+
            plugin.getPrice(ItemID.WHITELILLY)*1f*.5f+
            1f*2250f*.5f+//coins
            plugin.getPrice(ItemID.ADAMANT_2H_SWORD)*1f*.1f+
            plugin.getPrice(ItemID.ADAMANT_PLATEBODY)*1f*.1f+
            plugin.getPrice(ItemID.COSMICRUNE)*80f*.1f+
            plugin.getPrice(ItemID.DEATHRUNE)*80f*.1f+
            plugin.getPrice(ItemID.NATURERUNE)*80f*.1f+
            plugin.getPrice(ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE)*125f*.1f+
            plugin.getPrice(ItemID.MONKFISH)*2f*.1f+
            plugin.getPrice(ItemID._4DOSEPRAYERRESTORE)*1f*.1f+
            plugin.getPrice(ItemID.UNIDENTIFIED_RANARR)*1.5f*.1f+
            1f*10000f*.1f+//coins
            plugin.getPrice(ItemID.RUNE_2H_SWORD)*1f*.2f+
            plugin.getPrice(ItemID.RUNE_PLATEBODY)*1f*.2f+
            plugin.getPrice(ItemID.LAWRUNE)*200f*.2f+
            plugin.getPrice(ItemID.BLOODRUNE)*200f*.2f+
            plugin.getPrice(ItemID.SOULRUNE)*200f*.2f+
            plugin.getPrice(ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE)*200f*.2f+
            plugin.getPrice(ItemID.MONKFISH)*4f*.2f+
            plugin.getPrice(ItemID.SANFEW_SALVE_4_DOSE)*1.5f*.2f+
            plugin.getPrice(ItemID.RANARR_SEED)*1.5f*.2f+
            1f*20000f*.2f;//coins
        }
        else if(itemId == ItemID.GRANITE_CANNONBALL)
        {
            return plugin.getPrice(ItemID.MCANNONBALL);
        }
        else if (itemId == ItemID.MINNOW)
        {
            return plugin.getPrice(ItemID.RAW_SHARK)/40f;
        }

        return null;
    }

    @AllArgsConstructor
    public enum TokkulOverride {
        NO_VALUE("No Value (Default)"),
        BUY_CHAOS_RUNE      ("Chaos Rune (Buy)"),
        BUY_DEATH_RUNE      ("Death Rune (Buy)"),
        SELL_UNCUT_ONYX     ("Uncut Onyx (Sell)"),
        SELL_TOKTZ_MEJ_TAL  ("Toktz-mej-tal (Sell)"),
        SELL_TOKTZ_KET_XIL  ("Toktz-ket-xil (Sell)"),
        SELL_OBBY_CAPE      ("Obsidian cape (Sell)");
    
        private final String configName;
        @Override
        public String toString() { return configName; }
    }

    @AllArgsConstructor
    public enum CrystalShardOverride {
        NO_VALUE("No Value (Default)"),
        BUY_TELEPORT_SEED       ("Teleport Seed (Buy)"),
        SELL_SUPER_ATTACK       ("Super Attack (Sell)"),
        SELL_SUPER_STRENGTH     ("Super Strength (Sell)"),
        SELL_SUPER_DEFENCE      ("Super Defence (Sell)"),
        SELL_RANGING            ("Ranging (Sell)"),
        SELL_MAGIC              ("Magic (Sell)"),
        SELL_BASTION            ("Bastion (Sell)"),
        SELL_BATTLEMAGE         ("Battlemage (Sell)"),
        SELL_SUPER_COMBAT       ("Super Combat (Sell)");
    
        private final String configName;
        @Override
        public String toString() { return configName; }
    }

    @AllArgsConstructor
    public enum CrystalDustOverride {
        NO_VALUE("No Value (Default)"),
        SELL_SUPER_ATTACK       ("Super Attack (Sell)"),
        SELL_SUPER_STRENGTH     ("Super Strength (Sell)"),
        SELL_SUPER_DEFENCE      ("Super Defence (Sell)"),
        SELL_RANGING            ("Ranging (Sell)"),
        SELL_MAGIC              ("Magic (Sell)"),
        SELL_BASTION            ("Bastion (Sell)"),
        SELL_BATTLEMAGE         ("Battlemage (Sell)"),
        SELL_SUPER_COMBAT       ("Super Combat (Sell)");
    
        private final String configName;
        @Override
        public String toString() { return configName; }
    }

    @AllArgsConstructor
    public enum MermaidsTearOverride {
        NO_VALUE                    ("No Value (Default)"),
        SELL_MERFOLK_TRIDENT        ("Merfolk Trident");
    
        private final String configName;
        @Override
        public String toString() { return configName; }
    }

    @AllArgsConstructor
    public enum UnidentifiedMineralsOverride {
        NO_VALUE                        ("No Value (Default)"),
        SELL_SOFT_CLAY_PACK             ("Soft Clay Pack"),
        SELL_BAG_FULL_OF_GEMS           ("Bag Full of Gems");
    
        private final String configName;
        @Override
        public String toString() { return configName; }
    }

    @AllArgsConstructor
    public enum StardustOverride {
        NO_VALUE                        ("No Value (Default)"),
        SELL_SOFT_CLAY_PACK             ("Soft Clay Pack"),
        SELL_BAG_FULL_OF_GEMS           ("Bag Full of Gems");
    
        private final String configName;
        @Override
        public String toString() { return configName; }
    }

    @AllArgsConstructor
    public enum GoldenNuggetOverride {
        NO_VALUE                        ("No Value (Default)"),
        SELL_SOFT_CLAY_PACK             ("Soft Clay Pack"),
        SELL_BAG_FULL_OF_GEMS           ("Bag Full of Gems");
    
        private final String configName;
        @Override
        public String toString() { return configName; }
    }

    @AllArgsConstructor
    public enum HallowedMarkOverride {
        NO_VALUE                        ("No Value (Default)"),
        SELL_HALLOWED_SACK              ("Hallowed Sack");
    
        private final String configName;
        @Override
        public String toString() { return configName; }
    }

    @AllArgsConstructor
    public enum AbyssalPearlsOverride {
        NO_VALUE                        ("No Value (Default)"),
        SELL_RING_OF_THE_ELEMENTS       ("Ring of the Elements");
    
        private final String configName;
        @Override
        public String toString() { return configName; }
    }

    @AllArgsConstructor
    public enum BrimstoneKeyOverride {
        NO_VALUE                        ("No Value"),
        AVERAGE_VALUE                   ("Avg Value (Default)");
    
        private final String configName;
        @Override
        public String toString() { return configName; }
    }

}

package com.gpperhour;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class GPPerHourPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GPPerHourPlugin.class);
		RuneLite.main(args);
	}
}
