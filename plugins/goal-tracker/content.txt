package com.toofifty.goaltracker.services;

import com.toofifty.goaltracker.ItemCache;
import com.toofifty.goaltracker.models.enums.Status;
import com.toofifty.goaltracker.models.task.*;
import net.runelite.api.*;
import net.runelite.api.events.StatChanged;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class TaskUpdateServiceTest {
    @Mock
    private ItemCache itemCache;

    @Mock
    private Quest quest;

    @Mock
    private Client client;

    @Mock
    private StatChanged statChangedEvent;

    @InjectMocks
    TaskUpdateService service;

    @Test
    void update_shouldDynamicallyMapTasks() {
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        when(client.isClientThread()).thenReturn(true);
        when(client.getRealSkillLevel(Skill.ATTACK)).thenReturn(99);
        when(client.getSkillExperience(Skill.ATTACK)).thenReturn(1234);
        when(quest.getState(client)).thenReturn(QuestState.FINISHED);
        when(itemCache.getTotalQuantity(314)).thenReturn(100);

        assertTrue(service.update((Task) SkillLevelTask.builder().skill(Skill.ATTACK).level(90).build()));
        assertTrue(service.update((Task) SkillXpTask.builder().skill(Skill.ATTACK).xp(1234).build()));
        assertTrue(service.update((Task) QuestTask.builder().quest(quest).build()));
        assertTrue(service.update((Task) ItemTask.builder().itemId(314).acquired(0).quantity(100).build()));
    }

    @Test
    void update_shouldReturnFalseForUnsupportedTypes() {
        assertFalse(service.update(ManualTask.builder().build()));
    }

    @Test
    void update_skillLevelTask_shouldSupportLookingUpThePlayersLevel() {
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        when(client.getRealSkillLevel(Skill.ATTACK)).thenReturn(99);

        SkillLevelTask task = SkillLevelTask.builder().skill(Skill.ATTACK).level(90).build();

        assertTrue(service.update(task));
        assertEquals(Status.COMPLETED, task.getStatus());
    }

    @Test
    void update_skillLevelTask_shouldReturnFalseIfWeAreNotLoggedIn() {
        when(client.getGameState()).thenReturn(GameState.STARTING);

        SkillLevelTask task = SkillLevelTask.builder().skill(Skill.ATTACK).level(90).build();

        assertFalse(service.update(task));
    }

    @Test
    void update_skillLevelTask_shouldSupportStatChangedEvents() {
        when(statChangedEvent.getSkill()).thenReturn(Skill.ATTACK);
        when(statChangedEvent.getLevel()).thenReturn(99);

        SkillLevelTask task = SkillLevelTask.builder().skill(Skill.ATTACK).level(90).build();

        assertTrue(service.update(task, statChangedEvent));
        assertEquals(Status.COMPLETED, task.getStatus());
    }

    @Test
    void update_skillLevelTask_shouldIgnoreStatChangedEventsForTheWrongClass() {
        when(statChangedEvent.getSkill()).thenReturn(Skill.AGILITY);

        SkillLevelTask task = SkillLevelTask.builder().build();

        assertFalse(service.update(task, statChangedEvent));
    }

    @Test
    void update_skillLevelTask_shouldReturnTrueIfThePlayerLevelExceedsTheGoal() {
        SkillLevelTask task = SkillLevelTask.builder().skill(Skill.ATTACK).level(90).build();

        assertTrue(service.update(task, 99));
        assertEquals(Status.COMPLETED, task.getStatus());
    }

    @Test
    void update_skillLevelTask_shouldReturnFalseIfThePlayerLevelDoesNotExceedTheGoal() {
        SkillLevelTask task = SkillLevelTask.builder().skill(Skill.ATTACK).level(99).build();

        assertFalse(service.update(task, 90));
        assertEquals(Status.NOT_STARTED, task.getStatus());
    }

    @Test
    void update_skillXpTask_shouldSupportLookingUpThePlayersLevel() {
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        when(client.getSkillExperience(Skill.ATTACK)).thenReturn(1234);

        SkillXpTask task = SkillXpTask.builder().skill(Skill.ATTACK).xp(1234).build();

        assertTrue(service.update(task));
        assertEquals(Status.COMPLETED, task.getStatus());
    }

    @Test
    void update_skillXpTask_shouldReturnFalseIfWeAreNotLoggedIn() {
        when(client.getGameState()).thenReturn(GameState.STARTING);

        SkillXpTask task = SkillXpTask.builder().skill(Skill.ATTACK).xp(1234).build();

        assertFalse(service.update(task));
    }

    @Test
    void update_skillXpTask_shouldSupportStatChangedEvents() {
        when(statChangedEvent.getSkill()).thenReturn(Skill.ATTACK);
        when(statChangedEvent.getXp()).thenReturn(1234);

        SkillXpTask task = SkillXpTask.builder().skill(Skill.ATTACK).xp(1234).build();

        assertTrue(service.update(task, statChangedEvent));
        assertEquals(Status.COMPLETED, task.getStatus());
    }

    @Test
    void update_skillXpTask_shouldIgnoreStatChangedEventsForTheWrongSkill() {
        when(statChangedEvent.getSkill()).thenReturn(Skill.AGILITY);

        SkillXpTask task = SkillXpTask.builder().skill(Skill.ATTACK).xp(1234).build();

        assertFalse(service.update(task, statChangedEvent));
    }

    @Test
    void update_skillXpTask_shouldReturnTrueIfThePlayerXPExceedsTheGoal() {
        SkillXpTask task = SkillXpTask.builder().skill(Skill.ATTACK).xp(1234).build();

        assertTrue(service.update(task, 1234));
        assertEquals(Status.COMPLETED, task.getStatus());
    }

    @Test
    void update_skillXPTask_shouldReturnFalseIfThePlayerXPDoesNotExceedTheGoal() {
        SkillXpTask task = SkillXpTask.builder().skill(Skill.ATTACK).xp(1234).build();

        assertFalse(service.update(task, 1233));
        assertEquals(Status.NOT_STARTED, task.getStatus());
    }

    @Test
    void update_questTask_shouldReturnTrueIfTheQuestIsCompleted() {
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        when(client.isClientThread()).thenReturn(true);
        when(quest.getState(client)).thenReturn(QuestState.FINISHED);

        QuestTask task = QuestTask.builder().quest(quest).build();

        assertTrue(service.update(task));
        assertEquals(Status.COMPLETED, task.getStatus());
    }

    @Test
    void update_questTask_shouldReturnFalseIfTheQuestIsNotCompleted() {
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        when(client.isClientThread()).thenReturn(true);
        when(quest.getState(client)).thenReturn(QuestState.NOT_STARTED);

        QuestTask task = QuestTask.builder().quest(quest).build();

        assertFalse(service.update(task));
    }

    @Test
    void update_questTask_shouldReturnFalseIfThePlayerIsNotLoggedIn() {
        when(client.getGameState()).thenReturn(GameState.STARTING);

        QuestTask task = QuestTask.builder().build();

        assertFalse(service.update(task));
    }

    @Test
    void update_questTask_shouldReturnFalseIfNotClientThread() {
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        when(client.isClientThread()).thenReturn(false);

        QuestTask task = QuestTask.builder().build();

        assertFalse(service.update(task));
    }

    @Test
    void update_itemTask_shouldReturnTrueIfTheAcquiredItemsExceedsTheExpected() {
        when(itemCache.getTotalQuantity(314)).thenReturn(100);

        ItemTask task = ItemTask.builder().itemId(314).acquired(0).quantity(100).build();

        assertTrue(service.update(task));
        assertEquals(Status.COMPLETED, task.getStatus());
    }

    @Test
    void update_itemTask_shouldReturnTrueIfTheAcquiredItemsHasChanged() {
        when(itemCache.getTotalQuantity(314)).thenReturn(99);

        ItemTask task = ItemTask.builder().itemId(314).status(Status.IN_PROGRESS).acquired(1).quantity(100).build();

        assertTrue(service.update(task));
        assertEquals(Status.IN_PROGRESS, task.getStatus());
    }

    @Test
    void update_itemTask_shouldReturnFalseIfTheAcquiredItemsHasNotChanged() {
        when(itemCache.getTotalQuantity(314)).thenReturn(0);

        ItemTask task = ItemTask.builder().itemId(314).acquired(0).quantity(100).build();

        assertFalse(service.update(task));
        assertEquals(Status.NOT_STARTED, task.getStatus());
    }
}
package com.toofifty.goaltracker.services;

import com.toofifty.goaltracker.models.enums.Status;
import com.toofifty.goaltracker.models.task.*;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.util.AsyncBufferedImage;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import javax.swing.*;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
class TaskIconServiceTest {
    @Mock
    private ItemManager itemManager;

    @Mock
    private SkillIconManager skillIconManager;

    @Mock
    private Client client;

    @InjectMocks
    TaskIconService service;

    @Mock
    AsyncBufferedImage image;

    @BeforeEach
    public void init() {
        when(image.getScaledInstance(anyInt(), anyInt(), anyInt())).thenReturn(image);
    }

    @Test
    void get_shouldSupportManualTasks() {
        Task task = ManualTask.builder().status(Status.NOT_STARTED).build();

        assertEquals(TaskIconService.CROSS_MARK_ICON, service.get(task));
    }

    @Test
    void get_shouldSupportCompletedManualTasks() {
        Task task = ManualTask.builder().status(Status.COMPLETED).build();

        assertEquals(TaskIconService.CHECK_MARK_ICON, service.get(task));
    }

    @Test
    void get_shouldSupportNotStartedQuestTasks() {
        Task task = QuestTask.builder().status(Status.NOT_STARTED).build();

        assertEquals(TaskIconService.QUEST_ICON, service.get(task));
    }

    @Test
    void get_shouldSupportCompletedQuestTasks() {
        Task task = QuestTask.builder().status(Status.COMPLETED).build();

        assertEquals(TaskIconService.QUEST_COMPLETE_ICON, service.get(task));
    }

    @Test
    void get_shouldSupportSkillLevelTasks() {
        when(skillIconManager.getSkillImage(Skill.ATTACK)).thenReturn(image);

        Task task = SkillLevelTask.builder().skill(Skill.ATTACK).build();

        assertEquals(ImageIcon.class, service.get(task).getClass());
        verify(skillIconManager).getSkillImage(Skill.ATTACK);
    }

    @Test
    void get_shouldSupportSkillXPTasks() {
        when(skillIconManager.getSkillImage(Skill.ATTACK)).thenReturn(image);

        Task task = SkillXpTask.builder().skill(Skill.ATTACK).build();

        assertEquals(ImageIcon.class, service.get(task).getClass());
        verify(skillIconManager).getSkillImage(Skill.ATTACK);
    }

    @Test
    void get_shouldSupportItemTasks() {
        when(client.isClientThread()).thenReturn(true);
        when(itemManager.getImage(314)).thenReturn(image);

        Task task = ItemTask.builder().itemId(314).build();

        assertEquals(ImageIcon.class, service.get(task).getClass());
        verify(itemManager).getImage(314);
    }

    @Test
    void get_shouldSupportItemTasksNotBeingReady() {
        when(client.isClientThread()).thenReturn(false);
        when(itemManager.getImage(314)).thenReturn(image);

        Task task = ItemTask.builder().itemId(314).build();

        assertEquals(ImageIcon.class, service.get(task).getClass());
        verify(itemManager, never()).getImage(314);
    }
}
package com.toofifty.goaltracker;

import com.google.common.io.Resources;
import com.toofifty.goaltracker.models.enums.Status;
import com.toofifty.goaltracker.models.enums.TaskType;
import com.toofifty.goaltracker.models.Goal;
import com.toofifty.goaltracker.models.task.*;
import com.toofifty.goaltracker.utils.ReorderableList;
import net.runelite.api.Quest;
import net.runelite.api.Skill;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

//noinspection UnstableApiUsage
@SuppressWarnings("null")
public class GoalSerializerTest {
    GoalSerializer serializer = new GoalSerializer();

    @Test
    public void deserialize_should_parse_successfully() throws IOException {
        String json = Resources.toString(Resources.getResource("data.json"), Charset.defaultCharset());

        List<Goal> goals = serializer.deserialize(json);

        assertEquals(1, goals.size());
        assertEquals("My Goal", goals.get(0).getDescription());
        assertEquals(-1, goals.get(0).getDisplayOrder());
        assertEquals(1, goals.get(0).getTasks().size());

        assertEquals(ManualTask.class, goals.get(0).getTasks().get(0).getClass());

        ManualTask task = (ManualTask) goals.get(0).getTasks().get(0);

        assertEquals(TaskType.MANUAL, task.getType());
        assertEquals(Status.COMPLETED, task.getStatus());
        assertTrue(task.isNotified());
        assertTrue(task.isDone());
        assertEquals(0, task.getIndentLevel());
        assertEquals("Do all the things!", task.getDescription());
    }

    @Test
    public void deserialize_should_support_other_task_types() throws IOException {
        String json = Resources.toString(Resources.getResource("complex.json"), Charset.defaultCharset());

        List<Goal> goals = serializer.deserialize(json);

        assertEquals(1, goals.size());
        assertEquals("My Goal", goals.get(0).getDescription());
        assertEquals(-1, goals.get(0).getDisplayOrder());
        assertEquals(5, goals.get(0).getTasks().size());

        assertEquals(ManualTask.class, goals.get(0).getTasks().get(0).getClass());
        assertEquals(0, goals.get(0).getTasks().get(0).getIndentLevel());
        assertEquals(SkillLevelTask.class, goals.get(0).getTasks().get(1).getClass());
        assertEquals(1, goals.get(0).getTasks().get(1).getIndentLevel());

        SkillLevelTask skillLevelTask = (SkillLevelTask) goals.get(0).getTasks().get(1);

        assertEquals(99, skillLevelTask.getLevel());
        assertEquals(Skill.ATTACK, skillLevelTask.getSkill());
        assertEquals(1, skillLevelTask.getIndentLevel());

        assertEquals(SkillXpTask.class, goals.get(0).getTasks().get(2).getClass());

        SkillXpTask skillXpTask = (SkillXpTask) goals.get(0).getTasks().get(2);

        assertEquals(1234, skillXpTask.getXp());
        assertEquals(Skill.ATTACK, skillXpTask.getSkill());
        assertEquals(2, skillXpTask.getIndentLevel());

        assertEquals(QuestTask.class, goals.get(0).getTasks().get(3).getClass());

        QuestTask questTask = (QuestTask) goals.get(0).getTasks().get(3);

        assertEquals(Quest.ANIMAL_MAGNETISM, questTask.getQuest());
        assertEquals(1, questTask.getIndentLevel());

        assertEquals(ItemTask.class, goals.get(0).getTasks().get(4).getClass());

        ItemTask itemTask = (ItemTask) goals.get(0).getTasks().get(4);

        assertEquals(314, itemTask.getItemId());
        assertEquals(4, itemTask.getAcquired());
        assertEquals(10, itemTask.getQuantity());
        assertEquals("Feather", itemTask.getItemName());
        assertEquals(0, itemTask.getIndentLevel());
    }

    @Test
    public void serialize_should_convert_goals_to_json() throws IOException {
        //noinspection UnstableApiUsage
        String expectedJson = Resources.toString(Resources.getResource("data.json"), Charset.defaultCharset());

        List<Goal> goals = Arrays.asList(
            Goal.builder()
                .description("My Goal")
                .tasks(ReorderableList.from(Arrays.asList(
                    ManualTask.builder()
                        .description("Do all the things!")
                        .status(Status.COMPLETED)
                        .notified(true)
                        .indentLevel(0)
                        .build())))
                .build()
        );

        assertEquals(expectedJson, serializer.serialize(goals, true));
        
    }

    @Test
    public void serialize_should_support_other_task_types() throws IOException {
        //noinspection UnstableApiUsage
        String expectedJson = Resources.toString(Resources.getResource("complex.json"), Charset.defaultCharset());

        List<Goal> goals = Arrays.asList(
                Goal.builder()
                        .description("My Goal")
                        .tasks(ReorderableList.from(Arrays.asList(
                                ManualTask.builder()
                                        .description("Do all the things!")
                                        .status(Status.COMPLETED)
                                        .notified(true)
                                        .indentLevel(0)
                                        .build(),
                                SkillLevelTask.builder()
                                        .status(Status.IN_PROGRESS)
                                        .notified(false)
                                        .indentLevel(1)
                                        .level(99)
                                        .skill(Skill.ATTACK)
                                        .build(),
                                SkillXpTask.builder()
                                        .status(Status.NOT_STARTED)
                                        .notified(false)
                                        .indentLevel(2)
                                        .xp(1234)
                                        .skill(Skill.ATTACK)
                                        .build(),
                                QuestTask.builder()
                                        .status(Status.NOT_STARTED)
                                        .notified(false)
                                        .indentLevel(1)
                                        .quest(Quest.ANIMAL_MAGNETISM)
                                        .build(),
                                ItemTask.builder()
                                        .status(Status.NOT_STARTED)
                                        .notified(false)
                                        .indentLevel(0)
                                        .quantity(10)
                                        .acquired(4)
                                        .itemId(314)
                                        .itemName("Feather")
                                        .build()
                        ))).build()
        );

        assertEquals(expectedJson, serializer.serialize(goals, true));
    }
}
package com.toofifty.goaltracker.utils;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class ReorderableListTest {
    @Test
    void moveDown_shouldMoveDown() {
        ReorderableList<String> list = new ReorderableList<>();

        list.add("Welcome");
        list.add("to");
        list.add("RuneScape");

        list.moveDown("Welcome");

        assertEquals(3, list.size());
        assertEquals("to", list.get(0));
        assertEquals("Welcome", list.get(1));
        assertEquals("RuneScape", list.get(2));
    }

    @Test
    void moveUp_shouldMoveUp() {
        ReorderableList<String> list = new ReorderableList<>();

        list.add("Welcome");
        list.add("to");
        list.add("RuneScape");

        list.moveUp("RuneScape");

        assertEquals(3, list.size());
        assertEquals("Welcome", list.get(0));
        assertEquals("RuneScape", list.get(1));
        assertEquals("to", list.get(2));
    }

    @Test
    void moveToTop_shouldMoveToTheTop() {
        ReorderableList<String> list = new ReorderableList<>();

        list.add("Welcome");
        list.add("to");
        list.add("RuneScape");

        list.moveToTop("RuneScape");

        assertEquals(3, list.size());
        assertEquals("RuneScape", list.get(0));
        assertEquals("Welcome", list.get(1));
        assertEquals("to", list.get(2));
    }

    @Test
    void moveToBottom_shouldMoveToTheBottom() {
        ReorderableList<String> list = new ReorderableList<>();

        list.add("Welcome");
        list.add("to");
        list.add("RuneScape");

        list.moveToBottom("Welcome");

        assertEquals(3, list.size());
        assertEquals("to", list.get(0));
        assertEquals("RuneScape", list.get(1));
        assertEquals("Welcome", list.get(2));
    }

    @Test
    void isFirst_shouldReturnTrueIfFirst() {
        ReorderableList<String> list = new ReorderableList<>();

        list.add("Welcome");
        list.add("to");
        list.add("RuneScape");

        assertTrue(list.isFirst("Welcome"));
    }

    @Test
    void isFirst_shouldReturnFalseIfNotFirst() {
        ReorderableList<String> list = new ReorderableList<>();

        list.add("Welcome");
        list.add("to");
        list.add("RuneScape");

        assertFalse(list.isFirst("RuneScape"));
    }

    @Test
    void isLast_shouldReturnTrueIfLast() {
        ReorderableList<String> list = new ReorderableList<>();

        list.add("Welcome");
        list.add("to");
        list.add("RuneScape");

        assertTrue(list.isLast("RuneScape"));
    }

    @Test
    void isLast_shouldReturnFalseIfNotLast() {
        ReorderableList<String> list = new ReorderableList<>();

        list.add("Welcome");
        list.add("to");
        list.add("RuneScape");

        assertFalse(list.isLast("Welcome"));
    }

    @Test
    void getPreviousItem_shouldReturnPriorItem() {
        String expectedItem = "to";
        String item = "RuneScape";
        ReorderableList<String> list = new ReorderableList<>();

        list.add("Welcome");
        list.add(expectedItem);
        list.add(item);

        assertEquals(list.getPreviousItem(item), expectedItem);
    }

    @Test
    void from_shouldConvertAListToAReorderableList() {
        List<String> list = new ArrayList<>();

        list.add("Welcome");
        list.add("to");
        list.add("RuneScape");

        ReorderableList<String> reorderableList = ReorderableList.from(list);

        assertEquals(3, reorderableList.size());
        assertEquals("Welcome", reorderableList.get(0));
        assertEquals("to", reorderableList.get(1));
        assertEquals("RuneScape", reorderableList.get(2));
    }
}
package com.toofifty.goaltracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class GoalTrackerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GoalTrackerPlugin.class);
		RuneLite.main(args);
	}
}
package com.toofifty.goaltracker.models.task;

import com.toofifty.goaltracker.models.enums.Status;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class TaskTest {
    @Test
    void isDone_shouldBeFalseIfStatusIsNotStarted() {
        ManualTask task = ManualTask.builder().status(Status.NOT_STARTED).build();

        assertFalse(task.isDone());
    }

    @Test
    void isDone_shouldBeFalseIfStatusIsInProgress() {
        ManualTask task = ManualTask.builder().status(Status.IN_PROGRESS).build();

        assertFalse(task.isDone());
    }

    @Test
    void indent_shouldIndentIfNotFullyIndented() {
        ManualTask task = ManualTask.builder().status(Status.COMPLETED).build();

        task.indent();

        assertEquals(task.getIndentLevel(), 1);
    }

    @Test
    void indent_shouldNotIndentIfFullyIndented() {
        ManualTask task = ManualTask.builder().indentLevel(3).status(Status.COMPLETED).build();

        task.indent();

        assertEquals(task.getIndentLevel(), 3);
    }

    @Test
    void unindent_shouldUnindentIfIndented() {
        ManualTask task = ManualTask.builder().indentLevel(2).status(Status.COMPLETED).build();

        task.unindent();

        assertEquals(task.getIndentLevel(), 1);
    }

    @Test
    void unindent_shouldNotUnindentIfNotIndented() {
        ManualTask task = ManualTask.builder().status(Status.COMPLETED).build();

        task.unindent();

        assertEquals(task.getIndentLevel(), 0);
    }
}
package com.toofifty.goaltracker.models.task;

import com.toofifty.goaltracker.models.enums.TaskType;
import net.runelite.api.Skill;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class SkillLevelTaskTest {

    @Test
    void toString_shouldReturnTheLevelAndSkillName() {
        SkillLevelTask task = SkillLevelTask.builder().skill(Skill.ATTACK).level(99).build();

        assertEquals("99 Attack", task.toString());
    }

    @Test
    void getType_shouldReturnSkill() {
        SkillLevelTask task = SkillLevelTask.builder().build();

        assertEquals(TaskType.SKILL_LEVEL, task.getType());
    }
}
package com.toofifty.goaltracker.models.task;

import com.toofifty.goaltracker.models.enums.TaskType;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class ItemTaskTest {

    @Test
    void toString_shouldSupportItems() {
        ItemTask task = ItemTask.builder().quantity(1).itemName("Feather").build();

        assertEquals("Feather", task.toString());
    }

    @Test
    void toString_shouldSupportMultipleItems() {
        ItemTask task = ItemTask.builder().quantity(100).itemName("Feather").build();

        assertEquals("100 x Feather", task.toString());
    }

    @Test
    void toString_shouldSupportHavingSomeItemsAcquired() {
        ItemTask task = ItemTask.builder().acquired(50).quantity(100).itemName("Feather").build();

        assertEquals("50/100 x Feather", task.toString());
    }

    @Test
    void toString_shouldSupportTheAcquiredItemsExceedingTheQuantity() {
        ItemTask task = ItemTask.builder().acquired(150).quantity(100).itemName("Feather").build();

        assertEquals("100 x Feather", task.toString());
    }

    @Test
    void getType_shouldReturnItem() {
        ItemTask task = ItemTask.builder().build();

        assertEquals(TaskType.ITEM, task.getType());
    }
}
package com.toofifty.goaltracker.models.task;

import com.toofifty.goaltracker.models.enums.Status;
import com.toofifty.goaltracker.models.enums.TaskType;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class ManualTaskTest {

    @Test
    void toggle_shouldSupportCompletingTasks() {
        ManualTask task = ManualTask.builder().build();

        assertEquals(Status.NOT_STARTED, task.getStatus());

        task.toggle();

        assertEquals(Status.COMPLETED, task.getStatus());
    }

    @Test
    void toggle_supportResettingTasks() {
        ManualTask task = ManualTask.builder().status(Status.COMPLETED).build();

        assertEquals(Status.COMPLETED, task.getStatus());

        task.toggle();

        assertEquals(Status.NOT_STARTED, task.getStatus());
    }

    @Test
    void toString_shouldReturnTheDescription() {
        ManualTask task = ManualTask.builder().description("Do all the things!").build();

        assertEquals("Do all the things!", task.toString());
    }

    @Test
    void getType_shouldReturnManual() {
        ManualTask task = ManualTask.builder().build();

        assertEquals(TaskType.MANUAL, task.getType());
    }
}
package com.toofifty.goaltracker.models.task;

import com.toofifty.goaltracker.models.enums.TaskType;
import net.runelite.api.Quest;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class QuestTaskTest {

    @Test
    void toString_shouldReturnTheQuestName() {
        QuestTask task = QuestTask.builder().quest(Quest.ANIMAL_MAGNETISM).build();

        assertEquals(Quest.ANIMAL_MAGNETISM.getName(), task.toString());
    }

    @Test
    void getType_shouldReturnQuest() {
        QuestTask task = QuestTask.builder().build();

        assertEquals(TaskType.QUEST, task.getType());
    }
}
package com.toofifty.goaltracker.models.task;

import com.toofifty.goaltracker.models.enums.TaskType;
import net.runelite.api.Skill;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class SkillXpTaskTest {
    @Test
    void toString_shouldReturnTheXPAndSkillName() {
        SkillXpTask task = SkillXpTask.builder().skill(Skill.ATTACK).xp(1234).build();

        assertEquals("1234 Attack XP", task.toString());
    }

    @Test
    void getType_shouldReturnSkill() {
        SkillXpTask task = SkillXpTask.builder().build();

        assertEquals(TaskType.SKILL_XP, task.getType());
    }
}
package com.toofifty.goaltracker.models;

import com.toofifty.goaltracker.utils.ReorderableList;
import com.toofifty.goaltracker.models.enums.Status;
import com.toofifty.goaltracker.models.task.ItemTask;
import com.toofifty.goaltracker.models.task.ManualTask;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class GoalTest {
    @Test
    void isAnyStatus_shouldReturnTrueIfAllStatusesMatch() {
        Goal goal = Goal.builder().tasks(ReorderableList.from(ManualTask.builder().build())).build();

        assertTrue(goal.isAnyStatus(Status.NOT_STARTED));
    }

    @Test
    void isAnyStatus_shouldReturnTrueIfAnyTaskMatches() {
        Goal goal = Goal.builder().tasks(ReorderableList.from(
                ManualTask.builder().build(),
                ManualTask.builder().status(Status.COMPLETED).build()
        )).build();

        assertTrue(goal.isAnyStatus(Status.NOT_STARTED));
    }

    @Test
    void isAnyStatus_shouldReturnTrueIfAnyStatusesMatch() {
        Goal goal = Goal.builder().tasks(ReorderableList.from(
                ManualTask.builder().build(),
                ManualTask.builder().status(Status.COMPLETED).build()
        )).build();

        assertTrue(goal.isAnyStatus(Status.IN_PROGRESS, Status.COMPLETED));
    }

    @Test
    void isAnyStatus_shouldReturnFalseIfNoneOfTheStatusesMatch() {
        Goal goal = Goal.builder().tasks(ReorderableList.from(
                ManualTask.builder().build()
        )).build();

        assertFalse(goal.isAnyStatus(Status.IN_PROGRESS, Status.COMPLETED));
    }

    @Test
    void isStatus_shouldReturnTrueIfAllTasksMatchAGivenStatus() {
        Goal goal = Goal.builder().tasks(ReorderableList.from(ManualTask.builder().build())).build();

        assertTrue(goal.isStatus(Status.NOT_STARTED));
    }

    @Test
    void isStatus_shouldReturnFalseIfNoTasksMatchAGivenStatus() {
        Goal goal = Goal.builder().tasks(ReorderableList.from(ManualTask.builder().status(Status.COMPLETED).build())).build();

        assertFalse(goal.isStatus(Status.NOT_STARTED));
    }

    @Test
    void isStatus_shouldReturnFalseIfSomeTasksDoNotMatchAGivenStatus() {
        Goal goal = Goal.builder().tasks(ReorderableList.from(
                ManualTask.builder().build(),
                ManualTask.builder().status(Status.COMPLETED).build()
        )).build();

        assertFalse(goal.isStatus(Status.NOT_STARTED));
    }

    @Test
    void getStatus_shouldSupportNotBeingStarted() {
        Goal goal = Goal.builder().tasks(ReorderableList.from(ManualTask.builder().build())).build();

        assertEquals(Status.NOT_STARTED, goal.getStatus());
    }

    @Test
    void getStatus_shouldSupportBeingCompleted() {
        Goal goal = Goal.builder()
                .tasks(ReorderableList.from(ManualTask.builder().status(Status.COMPLETED).build()))
                .build();

        assertEquals(Status.COMPLETED, goal.getStatus());
    }

    @Test
    void getStatus_shouldSupportBeingInProgress() {
        Goal goal = Goal.builder()
                .tasks(ReorderableList.from(
                        ManualTask.builder().status(Status.COMPLETED).build(),
                        ManualTask.builder().status(Status.NOT_STARTED).build()
                ))
                .build();

        assertEquals(Status.IN_PROGRESS, goal.getStatus());
    }

    @Test
    void getStatus_shouldSupportPartialCompletionOfATask() {
        Goal goal = Goal.builder()
                .tasks(ReorderableList.from(
                        ItemTask.builder().status(Status.IN_PROGRESS).build()
                ))
                .build();

        assertEquals(Status.IN_PROGRESS, goal.getStatus());
    }

    @Test
    void getComplete_shouldReturnTheCompletedTasks() {
        Goal goal = Goal.builder()
                .tasks(ReorderableList.from(
                        ManualTask.builder().status(Status.COMPLETED).build(),
                        ManualTask.builder().status(Status.NOT_STARTED).build()
                ))
                .build();

        assertEquals(1, goal.getComplete().size());
    }
}
package com.toofifty.goaltracker.models.enums;

import net.runelite.api.QuestState;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class StatusTest {

    @Test
    void fromQuestState_shouldReturnCompletedForFinishedQuests() {
        assertEquals(Status.COMPLETED, Status.fromQuestState(QuestState.FINISHED));
    }

    @Test
    void fromQuestState_shouldReturnInProgressForInProgressQuests() {
        assertEquals(Status.IN_PROGRESS, Status.fromQuestState(QuestState.IN_PROGRESS));
    }

    @Test
    void fromQuestState_shouldReturnNotStartedForNotStartedQuests() {
        assertEquals(Status.NOT_STARTED, Status.fromQuestState(QuestState.NOT_STARTED));
    }

    @Test
    void isCompleted_shouldReturnTrueForCompleted() {
        assertTrue(Status.COMPLETED.isCompleted());
    }

    @Test
    void isCompleted_shouldReturnFalseForAnythingElse() {
        assertFalse(Status.NOT_STARTED.isCompleted());
    }

    @Test
    void isInProgress_shouldReturnTrueForInProgress() {
        assertTrue(Status.IN_PROGRESS.isInProgress());
    }

    @Test
    void isInProgress_shouldReturnFalseForAnythingElse() {
        assertFalse(Status.COMPLETED.isInProgress());
    }

    @Test
    void isNotStarted_shouldReturnTrueForNotStarted() {
        assertTrue(Status.NOT_STARTED.isNotStarted());
    }

    @Test
    void isNotStarted_shouldReturnFalseForAnythingElse() {
        assertFalse(Status.COMPLETED.isNotStarted());
    }

    @Test
    void toString_shouldReturnTheName() {
        assertEquals(Status.COMPLETED.getName(), Status.COMPLETED.toString());
    }
}
package com.toofifty.goaltracker.models.enums;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class TaskTypeTest {
    @Test
    void fromString_shouldConvertTheNameToTheEnum() {
        assertEquals(TaskType.MANUAL, TaskType.fromString(TaskType.MANUAL.getName()));
    }

    @Test
    void fromString_shouldThrowAnExceptionWhenUnknown() {
        assertThrows(IllegalStateException.class, () -> TaskType.fromString("oops!"));
    }

    @Test
    void toString_shouldReturnName() {
        assertEquals(TaskType.MANUAL.getName(), TaskType.MANUAL.toString());
    }
}
package com.toofifty.goaltracker.services;

import com.toofifty.goaltracker.GoalTrackerPlugin;
import com.toofifty.goaltracker.models.task.*;
import net.runelite.api.Client;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;

public class TaskIconService
{
    public static final ImageIcon CROSS_MARK_ICON;
    public static final ImageIcon CHECK_MARK_ICON;
    public static final ImageIcon QUEST_ICON;
    public static final ImageIcon QUEST_COMPLETE_ICON;
    public static final ImageIcon UNKNOWN_ICON;

    static {
        CROSS_MARK_ICON = new ImageIcon(
                ImageUtil.loadImageResource(GoalTrackerPlugin.class, "/cross_mark.png")
        );
        CHECK_MARK_ICON = new ImageIcon(
                ImageUtil.loadImageResource(GoalTrackerPlugin.class, "/check_mark.png")
        );
        QUEST_ICON = new ImageIcon(
                ImageUtil.loadImageResource(GoalTrackerPlugin.class, "/quest_icon.png")
        );
        QUEST_COMPLETE_ICON = new ImageIcon(
                ImageUtil.loadImageResource(GoalTrackerPlugin.class, "/quest_complete.png")
        );
        UNKNOWN_ICON = new ImageIcon(
                ImageUtil.loadImageResource(GoalTrackerPlugin.class, "/question_mark.png")
        );
    }

    @Inject
    private ItemManager itemManager;

    @Inject
    private SkillIconManager skillIconManager;

    @Inject
    private Client client;

    public ImageIcon get(Task task)
    {
        if (task instanceof ManualTask) {
            return get((ManualTask) task);
        }

        if (task instanceof QuestTask) {
            return get((QuestTask) task);
        }

        BufferedImage image = null;
        if (task instanceof SkillLevelTask) {
            image = get((SkillLevelTask) task);
        } else if (task instanceof SkillXpTask) {
            image = get((SkillXpTask) task);
        } else if (task instanceof ItemTask) {
            image = get((ItemTask) task);
        }

        if (image != null) {
            return new ImageIcon(image.getScaledInstance(16, 16, 32));
        }

        return UNKNOWN_ICON;
    }

    public ImageIcon get(ManualTask task)
    {
        return task.isDone() ? CHECK_MARK_ICON : CROSS_MARK_ICON;
    }

    public BufferedImage get(SkillLevelTask task)
    {
        return skillIconManager.getSkillImage(task.getSkill());
    }

    public BufferedImage get(SkillXpTask task)
    {
        return skillIconManager.getSkillImage(task.getSkill());
    }

    public ImageIcon get(QuestTask task)
    {
        return task.isDone() ? QUEST_COMPLETE_ICON : QUEST_ICON;
    }

    public BufferedImage get(ItemTask task)
    {
        if (task.getCachedIcon() == null && client.isClientThread()) {
            task.setCachedIcon(itemManager.getImage(task.getItemId()));
        }

        return task.getCachedIcon();
    }
}

package com.toofifty.goaltracker.services;

import com.toofifty.goaltracker.ItemCache;
import com.toofifty.goaltracker.models.enums.Status;
import com.toofifty.goaltracker.models.task.*;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.StatChanged;

import javax.inject.Inject;

public class TaskUpdateService
{
    @Inject
    private Client client;

    @Inject
    private ItemCache itemCache;

    public boolean update(Task task) {
        switch (task.getType()) {
            case SKILL_LEVEL: return this.update((SkillLevelTask) task);
            case SKILL_XP: return this.update((SkillXpTask) task);
            case QUEST: return this.update((QuestTask) task);
            case ITEM: return this.update((ItemTask) task);
            default: return false;
        }
    }

    /**
     * Returns true if an update has occurred
     * @param task the skill level task to validate
     */
    public boolean update(SkillLevelTask task)
    {
        if (client.getGameState() != GameState.LOGGED_IN) return false;

        return this.update(task, client.getRealSkillLevel(task.getSkill()));
    }

    /**
     * Returns true if an update has occurred
     * @param task the skill level task to validate
     * @param event the stat changed event this update is tied to
     */
    public boolean update(SkillLevelTask task, StatChanged event)
    {
        if (event.getSkill() != task.getSkill()) return false;

        return this.update(task, event.getLevel());
    }

    /**
     * Returns true if an update has occurred
     * @param task the skill level task to validate
     */
    public boolean update(SkillLevelTask task, int level)
    {
        Status oldStatus = task.getStatus();

        task.setStatus(
                level >= task.getLevel()
                        ? Status.COMPLETED
                        : Status.NOT_STARTED
        );

        return oldStatus != task.getStatus();
    }

    /**
     * Returns true if an update has occurred
     * @param task the skill level task to validate
     */
    public boolean update(SkillXpTask task)
    {
        if (client.getGameState() != GameState.LOGGED_IN) return false;

        return this.update(task, client.getSkillExperience(task.getSkill()));
    }

    /**
     * Returns true if an update has occurred
     * @param task the skill level task to validate
     * @param event the stat changed event this update is tied to
     */
    public boolean update(SkillXpTask task, StatChanged event)
    {
        if (event.getSkill() != task.getSkill()) return false;

        return this.update(task, event.getXp());
    }

    /**
     * Returns true if an update has occurred
     * @param task the skill xp task to validate
     */
    public boolean update(SkillXpTask task, int xp)
    {
        Status oldStatus = task.getStatus();

        task.setStatus(
                xp >= task.getXp()
                    ? Status.COMPLETED
                    : Status.NOT_STARTED
        );

        return oldStatus != task.getStatus();
    }

    /**
     * Returns true if an update has occurred
     * @param task the quest task to validate
     */
    public boolean update(QuestTask task)
    {
        if (client.getGameState() != GameState.LOGGED_IN || !client.isClientThread()) return false;

        Status oldStatus = task.getStatus();

        task.setStatus(Status.fromQuestState(task.getQuest().getState(client)));

        return oldStatus != task.getStatus();
    }

    /**
     * Returns true if an update has occurred
     * @param task the item task to validate
     */
    public boolean update(ItemTask task)
    {
        int oldAcquired = task.getAcquired();
        Status oldStatus = task.getStatus();

        task.setAcquired(Math.min(itemCache.getTotalQuantity(task.getItemId()), task.getQuantity()));

        task.setStatus(
            task.getAcquired() >= task.getQuantity()
                ? Status.COMPLETED
                : (task.getAcquired() > 0
                    ? Status.IN_PROGRESS
                    : Status.NOT_STARTED));

        return oldAcquired != task.getAcquired() || oldStatus != task.getStatus();
    }
}

package com.toofifty.goaltracker;

import com.toofifty.goaltracker.models.Goal;
import com.toofifty.goaltracker.models.enums.Status;
import com.toofifty.goaltracker.models.enums.TaskType;
import com.toofifty.goaltracker.models.task.Task;
import com.toofifty.goaltracker.utils.ReorderableList;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Singleton
public class GoalManager
{
    @Inject
    private GoalTrackerConfig config;

    @Inject
    private GoalSerializer goalSerializer;

    @Getter
    private final ReorderableList<Goal> goals = new ReorderableList<>();

    public Goal createGoal()
    {
        Goal goal = Goal.builder().build();
        goals.add(goal);
        return goal;
    }

    @SuppressWarnings("unchecked")
    public <T extends Task> List<T> getTasksByTypeAndAnyStatus(TaskType type, Status ...statuses)
    {
        List<T> tasks = new ArrayList<>();
        for (Goal goal : goals) {
            tasks.addAll((List<T>) goal.getTasks().stream()
                .filter((task) -> task.getType() == type && Arrays.stream(statuses).anyMatch((status) -> status == task.getStatus()))
                .collect(Collectors.toList())
            );
        }
        return tasks;
    }

    public <T extends Task> List<T> getIncompleteTasksByType(TaskType type) {
        return this.getTasksByTypeAndAnyStatus(type, Status.NOT_STARTED, Status.IN_PROGRESS);
    }

    public void save()
    {
        config.goalTrackerData(goalSerializer.serialize(goals));

        log.info("Saved " + goals.size() + " goals");
    }

    public void load()
    {
        try {
            this.goals.clear();
            this.goals.addAll(goalSerializer.deserialize(config.goalTrackerData()));

            log.info("Loaded " + this.goals.size() + " goals");
        } catch (Exception e) {
            log.error("Failed to load goals!");
        }
    }
}

package com.toofifty.goaltracker;

import com.google.inject.Provides;
import com.toofifty.goaltracker.models.enums.TaskType;
import com.toofifty.goaltracker.models.task.*;
import com.toofifty.goaltracker.services.TaskIconService;
import com.toofifty.goaltracker.services.TaskUpdateService;
import com.toofifty.goaltracker.ui.GoalTrackerPanel;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.SessionOpen;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.chatbox.ChatboxItemSearch;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.AsyncBufferedImage;

import javax.inject.Inject;
import java.util.List;
import java.util.stream.IntStream;

@Slf4j
@PluginDescriptor(name = "Goal Tracker", description = "Keep track of your goals and complete them automatically")
public class GoalTrackerPlugin extends Plugin
{
    public static final int[] PLAYER_INVENTORIES = {
        InventoryID.INVENTORY.getId(),
        InventoryID.EQUIPMENT.getId(),
        InventoryID.BANK.getId(),
        InventoryID.SEED_VAULT.getId(),
        InventoryID.GROUP_STORAGE.getId()
    };

    @Getter
    @Inject
    private Client client;

    @Getter
    @Inject
    private SkillIconManager skillIconManager;

    @Getter
    @Inject
    private ItemManager itemManager;

    @Getter
    @Inject
    private ChatboxItemSearch itemSearch;

    @Inject
    private ClientToolbar clientToolbar;

    @Getter
    @Inject
    private ClientThread clientThread;

    @Getter
    @Inject
    private ItemCache itemCache;

    @Inject
    private ChatMessageManager chatMessageManager;

    @Getter
    @Inject
    private GoalTrackerConfig config;

    @Getter
    @Inject
    private TaskUpdateService taskUpdateService;

    @Getter
    @Inject
    private TaskIconService taskIconService;

    @Getter
    @Inject
    private TaskUIStatusManager uiStatusManager;

    @Getter
    @Inject
    private GoalManager goalManager;

    @Inject
    private GoalTrackerPanel goalTrackerPanel;

    private NavigationButton uiNavigationButton;

    @Setter
    private boolean validateAll = true;

    @Override
    protected void startUp()
    {
        goalManager.load();
        itemCache.load();
        goalTrackerPanel.home();

        final AsyncBufferedImage icon = itemManager.getImage(ItemID.TODO_LIST);

        icon.onLoaded(() -> {
            uiNavigationButton = NavigationButton.builder()
                .tooltip("Goal Tracker")
                .icon(icon)
                .priority(7)
                .panel(goalTrackerPanel)
                .build();

            clientToolbar.addNavigation(uiNavigationButton);
        });

        goalTrackerPanel.onGoalUpdated((goal) -> goalManager.save());
        goalTrackerPanel.onTaskAdded((task) -> {
            if (taskUpdateService.update(task)) {
                if (task.getStatus().isCompleted()) {
                    notifyTask(task);
                }

                uiStatusManager.refresh(task);
            }

            goalManager.save();
        });
        goalTrackerPanel.onTaskUpdated((task) -> goalManager.save());
    }

    @Override
    protected void shutDown()
    {
        clientToolbar.removeNavigation(uiNavigationButton);
    }

    @Subscribe
    public void onSessionOpen(SessionOpen event)
    {
        goalManager.load();
    }

    @Subscribe
    public void onStatChanged(StatChanged event)
    {
        List<SkillLevelTask> skillLevelTasks = goalManager.getIncompleteTasksByType(TaskType.SKILL_LEVEL);
        for (SkillLevelTask task : skillLevelTasks) {
            if (!taskUpdateService.update(task, event)) continue;

            if (task.getStatus().isCompleted()) {
                notifyTask(task);
            }

            uiStatusManager.refresh(task);
            this.goalManager.save();
        }

        List<SkillXpTask> skillXpTasks = goalManager.getIncompleteTasksByType(TaskType.SKILL_XP);
        for (SkillXpTask task : skillXpTasks) {
            if (!taskUpdateService.update(task, event)) continue;

            if (task.getStatus().isCompleted()) {
                notifyTask(task);
            }

            uiStatusManager.refresh(task);
            this.goalManager.save();
        }
    }

    public void notifyTask(Task task)
    {
        if (client.getGameState() != GameState.LOGGED_IN || task.isNotified()) return;

        log.debug("Notify: [Goal Tracker] You have completed a task: " + task + "!");

        String message = "[Goal Tracker] You have completed a task: " + task + "!";
        String formattedMessage = new ChatMessageBuilder().append(ColorScheme.PROGRESS_COMPLETE_COLOR, message).build();
        chatMessageManager.queue(QueuedMessage.builder()
            .type(ChatMessageType.CONSOLE)
            .name("Goal Tracker")
            .runeLiteFormattedMessage(formattedMessage)
            .build());

        task.setNotified(true);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        if (client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        // redo the login check on the next game tick
        validateAll = true;
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        if (!validateAll) {
            return;
        }
        if (client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        validateAll = false;
        // perform a full refresh just once on login
        // onGameStateChanged reports incorrect quest statuses,
        // so this need to be done in this subscriber
        goalTrackerPanel.refresh();
    }

    @Subscribe
    public void onChatMessage(ChatMessage event)
    {
        if (event.getType() != ChatMessageType.GAMEMESSAGE || !event.getMessage().contains("Quest complete")) return;

        List<QuestTask> questTasks = goalManager.getIncompleteTasksByType(TaskType.QUEST);
        for (QuestTask task : questTasks) {
            if (!taskUpdateService.update(task)) continue;

            if (task.getStatus().isCompleted()) {
                notifyTask(task);
            }

            uiStatusManager.refresh(task);
            this.goalManager.save();
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if (IntStream.of(GoalTrackerPlugin.PLAYER_INVENTORIES).noneMatch((id) -> id == event.getContainerId())) return;

        itemCache.update(event.getContainerId(), event.getItemContainer().getItems());

        List<ItemTask> itemTasks = goalManager.getIncompleteTasksByType(TaskType.ITEM);
        for (ItemTask task : itemTasks) {
            if (!taskUpdateService.update(task)) continue;

            if (task.getStatus().isCompleted()) {
                notifyTask(task);
            }

            // always refresh item tasks, since the acquired
            // count could have changed
            uiStatusManager.refresh(task);
            this.goalManager.save();
        }
    }

    @Provides
    GoalTrackerConfig getGoalTrackerConfig(ConfigManager configManager)
    {
        return configManager.getConfig(GoalTrackerConfig.class);
    }
}

package com.toofifty.goaltracker;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.util.HashMap;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.client.game.ItemManager;

@Singleton
public class ItemCache
{
    private Map<Integer, Item[]> inventories;
    private Map<Integer, Integer> itemTotals;

    // mapping of itemIds to their noted counterparts, and vice versa
    // needs to be persisted to show correct quantities when not logged in
    private Map<Integer, Integer> itemNoteMap;

    @Inject
    private GoalTrackerConfig config;

    @Inject
    private Gson gson;

    @Inject
    private Client client;

    @Inject
    private ItemManager itemManager;

    public void save()
    {
        config.goalTrackerItemCache(gson.toJson(inventories));
        config.goalTrackerItemNoteMapCache(gson.toJson(itemNoteMap));
    }

    public void load()
    {
        Map<Integer, Item[]> savedInventories = gson
            .fromJson(config.goalTrackerItemCache(), new TypeToken<Map<Integer, Item[]>>()
            {
            }.getType());

        if (savedInventories != null) {
            inventories = savedInventories;
        } else {
            inventories = new HashMap<>();
        }

        Map<Integer, Integer> savedItemNoteMap = gson
            .fromJson(config.goalTrackerItemNoteMapCache(), new TypeToken<Map<Integer, Integer>>()
            {
            }.getType());

        if (savedItemNoteMap != null) {
            itemNoteMap = savedItemNoteMap;
        } else {
            itemNoteMap = new HashMap<>();
        }

        calculateItemTotals();
    }

    public void calculateItemTotals()
    {
        itemTotals = new HashMap<>();
        for (int inventory : inventories.keySet()) {
            for (Item item : inventories.get(inventory)) {
                itemTotals.put(item.getId(), itemTotals.getOrDefault(item.getId(), 0) + item.getQuantity());
            }
        }
    }

    public void update(int inventoryID, Item[] contents)
    {
        inventories.put(inventoryID, contents);

        calculateItemTotals();
    }

    public int getTotalQuantity(int itemId)
    {
        int notedItemId = getNotedId(itemId);

        if (notedItemId != -1) {
            return itemTotals.getOrDefault(itemId, 0) + itemTotals.getOrDefault(notedItemId, 0);
        }

        return itemTotals.getOrDefault(itemId, 0);
    }

    private int getNotedId(int itemId)
    {
        if (client.isClientThread() && !itemNoteMap.containsKey(itemId)) {
            itemNoteMap.put(itemId, itemManager.getItemComposition(itemId).getLinkedNoteId());
        }
        return itemNoteMap.getOrDefault(itemId, -1);
    }
}

package com.toofifty.goaltracker.utils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class ReorderableList<T> extends ArrayList<T>
{
    private void move(T item, int offset) {
        int i = this.indexOf(item);

        Collections.swap(this, i, i + offset);
    }

    public void moveUp(T item) {
        this.move(item, -1);
    }

    public void moveDown(T item) {
        this.move(item, 1);
    }

    public void moveToTop(T item)
    {
        this.remove(item);
        this.add(0, item);
    }

    public void moveToBottom(T item)
    {
        this.remove(item);
        this.add(item);
    }

    public Boolean isFirst(T item)
    {
        return !this.isEmpty() && this.get(0) == item;
    }

    public Boolean isLast(T item)
    {
        return !this.isEmpty() && this.get(this.size() - 1) == item;
    }

    public T getPreviousItem(T item)
    {
        return this.getPreviousItem(this.indexOf(item));
    }

    public T getPreviousItem(int index)
    {
        if (index <= 0) return null;
        else return this.get(index - 1);
    }

    public static <T> ReorderableList<T> from(List<T> items) {
        ReorderableList<T> list = new ReorderableList<>();
        list.addAll(items);
        return list;
    }

    @SafeVarargs
    public static <T> ReorderableList<T> from(T ...items) {
        return ReorderableList.from(Arrays.asList(items));
    }
}

package com.toofifty.goaltracker.utils;

import com.toofifty.goaltracker.models.enums.Status;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;
import java.util.Map;

public class Constants {
    public static final Map<Status, Color> STATUS_TO_COLOR = Map.of(
            Status.NOT_STARTED, ColorScheme.PROGRESS_ERROR_COLOR,
            Status.IN_PROGRESS, ColorScheme.PROGRESS_INPROGRESS_COLOR,
            Status.COMPLETED, ColorScheme.PROGRESS_COMPLETE_COLOR
    );
}

package com.toofifty.goaltracker;

import com.toofifty.goaltracker.models.Goal;
import com.toofifty.goaltracker.models.task.Task;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Singleton;
import javax.swing.*;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Singleton
public class TaskUIStatusManager
{
    private final Map<Task, Runnable> taskRefreshers = new HashMap<>();
    private final Map<Goal, Runnable> goalRefreshers = new HashMap<>();

    public void addRefresher(Task task, Runnable refresher)
    {
        taskRefreshers.put(task, refresher);
    }

    public void addRefresher(Goal goal, Runnable refresher)
    {
        goalRefreshers.put(goal, refresher);
    }

    public void refresh(Task task)
    {
        SwingUtilities.invokeLater(() -> {
            if (taskRefreshers.containsKey(task)) {
                taskRefreshers.get(task).run();
            } else {
                log.debug("Missing task refresher for " + task.hashCode());
                for (Task key : taskRefreshers.keySet()) {
                    log.debug("Has " + key.hashCode() + ". is same: " + (task.equals(key) ? "ye" : "no"));
                }
            }
        });
    }

    public void refresh(Goal goal)
    {
        SwingUtilities.invokeLater(() -> {
            if (goalRefreshers.containsKey(goal)) {
                goalRefreshers.get(goal).run();
            } else {
                log.debug("Missing goal refresher for " + goal.hashCode());
            }
        });
    }
}

package com.toofifty.goaltracker.ui;

import com.toofifty.goaltracker.GoalTrackerPlugin;
import com.toofifty.goaltracker.models.Goal;

import javax.swing.*;
import java.awt.*;

import static com.toofifty.goaltracker.utils.Constants.STATUS_TO_COLOR;

public class GoalItemContent extends JPanel implements Refreshable
{
    private final JLabel title = new JLabel();
    private final JLabel progress = new JLabel();

    private final Goal goal;

    GoalItemContent(GoalTrackerPlugin plugin, Goal goal)
    {
        super(new BorderLayout());
        this.goal = goal;

        add(title, BorderLayout.WEST);
        add(progress, BorderLayout.EAST);

        plugin.getUiStatusManager().addRefresher(goal, this::refresh);
    }

    @Override
    public void refresh()
    {
        Color color = STATUS_TO_COLOR.get(goal.getStatus());

        title.setText(goal.getDescription());
        title.setForeground(color);

        progress.setText(
            goal.getComplete().size() + "/" + goal.getTasks().size());
        progress.setForeground(color);
    }
}

package com.toofifty.goaltracker.ui;

public interface Refreshable
{
    /**
     * Update only the dynamic UI of this component
     */
    public void refresh();
}

package com.toofifty.goaltracker.ui;

import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

@FunctionalInterface
public interface SimpleDocumentListener extends DocumentListener
{
    @Override
    default void insertUpdate(DocumentEvent e)
    {
        update(e);
    }

    void update(DocumentEvent e);

    @Override
    default void removeUpdate(DocumentEvent e)
    {
        update(e);
    }

    @Override
    default void changedUpdate(DocumentEvent e)
    {
        update(e);
    }
}

package com.toofifty.goaltracker.ui;

import com.toofifty.goaltracker.GoalManager;
import com.toofifty.goaltracker.GoalTrackerPlugin;
import com.toofifty.goaltracker.models.Goal;
import com.toofifty.goaltracker.models.task.Task;
import com.toofifty.goaltracker.ui.components.ListItemPanel;
import com.toofifty.goaltracker.ui.components.ListPanel;
import com.toofifty.goaltracker.ui.components.TextButton;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.Objects;
import java.util.function.Consumer;

@Singleton
public class GoalTrackerPanel extends PluginPanel implements Refreshable
{
    private final JPanel mainPanel = new JPanel(new BorderLayout());
    private final ListPanel<Goal> goalListPanel;
    private final GoalTrackerPlugin plugin;
    private GoalPanel goalPanel;
    private Consumer<Goal> goalAddedListener;
    private Consumer<Goal> goalUpdatedListener;
    private Consumer<Task> taskAddedListener;
    private Consumer<Task> taskUpdatedListener;

    @Inject
    public GoalTrackerPanel(GoalTrackerPlugin plugin, GoalManager goalManager)
    {
        super(false);
        this.plugin = plugin;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(8, 8, 8, 8));

        JPanel titlePanel = new JPanel();
        titlePanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        titlePanel.setLayout(new BorderLayout());
        titlePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        titlePanel.add(
            new TextButton("+ Add goal",
                e -> {
                    Goal goal = goalManager.createGoal();
                    view(goal);

                    if (Objects.nonNull(this.goalAddedListener)) this.goalAddedListener.accept(goal);
                    if (Objects.nonNull(this.goalUpdatedListener)) this.goalUpdatedListener.accept(goal);
                }
            ).narrow(), BorderLayout.EAST);

        JLabel title = new JLabel();
        title.setText("Goal Tracker");
        title.setForeground(Color.WHITE);
        title.setFont(FontManager.getRunescapeBoldFont());
        titlePanel.add(title, BorderLayout.WEST);

        goalListPanel = new ListPanel<>(goalManager.getGoals(),
            (goal) -> {
                var panel = new ListItemPanel<>(goalManager.getGoals(), goal);

                panel.onClick(e -> this.view(goal));
                panel.add(new GoalItemContent(plugin, goal));

                return panel;
            }
        );
        goalListPanel.setGap(0);
        goalListPanel.setPlaceholder("Add a new goal using the button above");

        mainPanel.add(titlePanel, BorderLayout.NORTH);
        mainPanel.add(goalListPanel, BorderLayout.CENTER);

        home();
    }

    public void view(Goal goal)
    {
        removeAll();

        this.goalPanel = new GoalPanel(plugin, goal, this::home);

        this.goalPanel.onGoalUpdated(this.goalUpdatedListener);
        this.goalPanel.onTaskAdded(this.taskAddedListener);
        this.goalPanel.onTaskUpdated(this.taskUpdatedListener);

        add(this.goalPanel, BorderLayout.CENTER);
        this.goalPanel.refresh();

        revalidate();
        repaint();
    }

    public void home()
    {
        removeAll();
        add(mainPanel, BorderLayout.CENTER);
        goalListPanel.tryBuildList();
        goalListPanel.refresh();

        revalidate();
        repaint();

        this.goalPanel = null;
    }

    @Override
    public void refresh()
    {
        // refresh single-view goal
        for (Component component : getComponents()) {
            if (component instanceof Refreshable) {
                ((Refreshable) component).refresh();
            }
        }

        goalListPanel.refresh();
    }

    public void onGoalUpdated(Consumer<Goal> listener)
    {
        this.goalUpdatedListener = listener;

        this.goalListPanel.onUpdated(this.goalUpdatedListener);

        if (this.goalPanel != null) {
            this.goalPanel.onGoalUpdated(this.goalUpdatedListener);
        }
    }

    public void onTaskUpdated(Consumer<Task> listener)
    {
        this.taskUpdatedListener = listener;

        if (this.goalPanel != null) {
            this.goalPanel.onTaskUpdated(this.taskUpdatedListener);
        }
    }

    public void onTaskAdded(Consumer<Task> listener)
    {
        this.taskAddedListener = listener;

        if (this.goalPanel != null) {
            this.goalPanel.onTaskAdded(this.taskAddedListener);
        }
    }
}

package com.toofifty.goaltracker.ui;

import com.toofifty.goaltracker.GoalTrackerPlugin;
import com.toofifty.goaltracker.models.Goal;
import com.toofifty.goaltracker.models.task.Task;
import com.toofifty.goaltracker.ui.components.TextButton;
import com.toofifty.goaltracker.ui.inputs.ItemTaskInput;
import com.toofifty.goaltracker.ui.inputs.ManualTaskInput;
import com.toofifty.goaltracker.ui.inputs.QuestTaskInput;
import com.toofifty.goaltracker.ui.inputs.SkillLevelTaskInput;
import com.toofifty.goaltracker.ui.inputs.SkillXpTaskInput;
import java.awt.BorderLayout;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.util.function.Consumer;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;

public class NewTaskPanel extends JPanel
{
    private final TextButton moreOptionsButton;
    private final GoalTrackerPlugin plugin;
    private final Goal goal;

    private JPanel moreOptionsPanel;
    private Consumer<Task> listener;

    NewTaskPanel(GoalTrackerPlugin plugin, Goal goal)
    {
        super();
        this.plugin = plugin;
        this.goal = goal;

        setLayout(new GridBagLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridwidth = 1;
        constraints.gridy = 0;
        constraints.ipady = 8;

        add(new ManualTaskInput(plugin, goal).onSubmit((task) -> this.listener.accept(task)), constraints);
        constraints.gridy++;

        moreOptionsButton = new TextButton("+ More options");
        moreOptionsButton.setBorder(new EmptyBorder(4, 8, 0, 8));
        moreOptionsButton.onClick(e -> {
            if (moreOptionsPanel.isVisible()) {
                hideMoreOptions();
            } else {
                showMoreOptions();
            }
        });
        JPanel moreOptionsButtonPanel = new JPanel(new BorderLayout());
        moreOptionsButtonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        moreOptionsButtonPanel.add(moreOptionsButton, BorderLayout.WEST);

        add(moreOptionsButtonPanel, constraints);
        constraints.gridy++;

        createMoreOptionsPanel();
        add(moreOptionsPanel, constraints);
    }

    private void hideMoreOptions()
    {
        moreOptionsButton.setText("+ More options");
        moreOptionsButton.setMainColor(ColorScheme.PROGRESS_COMPLETE_COLOR);

        moreOptionsPanel.setVisible(false);
    }

    private void showMoreOptions()
    {
        moreOptionsButton.setText("- More options");
        moreOptionsButton.setMainColor(ColorScheme.PROGRESS_ERROR_COLOR);

        moreOptionsPanel.setVisible(true);
    }

    private void createMoreOptionsPanel()
    {
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridwidth = 1;
        constraints.gridy = 0;
        constraints.ipady = 8;

        moreOptionsPanel = new JPanel(new GridBagLayout());
        moreOptionsPanel.setVisible(false);
        moreOptionsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        moreOptionsPanel.add(new SkillLevelTaskInput(plugin, goal).onSubmit((task) -> this.listener.accept(task)), constraints);
        constraints.gridy++;

        moreOptionsPanel.add(new SkillXpTaskInput(plugin, goal).onSubmit((task) -> this.listener.accept(task)), constraints);
        constraints.gridy++;

        moreOptionsPanel.add(new QuestTaskInput(plugin, goal).onSubmit((task) -> this.listener.accept(task)), constraints);
        constraints.gridy++;

        moreOptionsPanel.add(new ItemTaskInput(plugin, goal).onSubmit((task) -> this.listener.accept(task)), constraints);
        constraints.gridy++;
    }

    public void onTaskAdded(Consumer<Task> listener)
    {
        this.listener = listener;
    }
}

package com.toofifty.goaltracker.ui.components;

import com.toofifty.goaltracker.ui.Refreshable;
import com.toofifty.goaltracker.utils.ReorderableList;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;

public class ListPanel<T> extends JScrollPane implements Refreshable
{
    private final JPanel listPanel = new JPanel(new GridBagLayout());

    private final ReorderableList<T> reorderableList;
    private final Function<T, ListItemPanel<T>> renderItem;

    private final Map<T, ListItemPanel<T>> itemPanelMap = new HashMap<>();

    private int gap = 2;
    private String placeholder = "Nothing interesting happens.";
    private Consumer<T> updatedListener;

    public ListPanel(
        ReorderableList<T> reorderableList,
        Function<T, ListItemPanel<T>> renderItem
    ) {
        super();
        this.reorderableList = reorderableList;
        this.renderItem = renderItem;

        setBorder(new EmptyBorder(10, 10, 10, 10));

        listPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel wrapperPanel = new JPanel(new BorderLayout());
        wrapperPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        wrapperPanel.add(listPanel, BorderLayout.NORTH);

        setBorder(new EmptyBorder(4, 4, 4 - gap, 4));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        getVerticalScrollBar().setPreferredSize(new Dimension(12, 0));
        getVerticalScrollBar().setBorder(new EmptyBorder(0, 4, 0, 0));

        setViewportView(wrapperPanel);

        setHorizontalScrollBarPolicy(HORIZONTAL_SCROLLBAR_NEVER);
        tryBuildList();
    }

    public void setGap(int gap)
    {
        this.gap = gap;
        setBorder(new EmptyBorder(4, 4, 4 - gap, 4));
        tryBuildList();
    }

    public void setPlaceholder(String placeholder)
    {
        this.placeholder = placeholder;
        tryBuildList();
    }

    private List<ListItemPanel<T>> buildItemPanels()
    {
        return reorderableList
            .stream()
            .map(this::buildItemPanel)
            .collect(Collectors.toList());
    }

    @Override
    public void refresh()
    {
        // refresh all children
        for (Component component : listPanel.getComponents()) {
            if (component instanceof Refreshable) {
                ((Refreshable) component).refresh();
            }
        }
    }

    private ListItemPanel<T> buildItemPanel(T item)
    {
        if (itemPanelMap.containsKey(item)) {
            return itemPanelMap.get(item);
        }

        ListItemPanel<T> itemPanel = renderItem.apply(item);

        itemPanel.onReordered((updatedItem) -> {
            tryBuildList();

            this.updatedListener.accept(updatedItem);
        });

        itemPanel.onRemoved((updatedItem) -> {
            tryBuildList();

            this.updatedListener.accept(updatedItem);
        });

        itemPanelMap.put(item, itemPanel);

        return itemPanel;
    }

    private GridBagConstraints getConstraints()
    {
        return getConstraints(0);
    }

    private GridBagConstraints getConstraints(int gridy)
    {
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridy = gridy;
        constraints.gridx = 0;
        constraints.insets = new Insets(0, 0, gap, 0);
        return constraints;
    }

    private void refreshChildMenus()
    {
        for (Component component : listPanel.getComponents()) {
            if (component instanceof ListItemPanel) {
                ((ListItemPanel<?>) component).refreshMenu();
            }
        }
    }

    /**
     * Build the initial list, if items are provided otherwise build a placeholder
     */
    public void tryBuildList()
    {
        if (reorderableList.isEmpty()) {
            listPanel.removeAll();

            JLabel placeholderLabel = new JLabel(placeholder);
            placeholderLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            JPanel placeholderPanel = new JPanel();
            placeholderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
            placeholderPanel.add(placeholderLabel);
            listPanel.add(placeholderPanel, getConstraints());
        } else {
            listPanel.removeAll();

            GridBagConstraints constraints = getConstraints();
            buildItemPanels().forEach(component -> {
                listPanel.add(component, constraints);
                constraints.gridy++;
            });
        }

        refreshChildMenus();
        revalidate();
    }

    public void onUpdated(Consumer<T> listener) {
        this.updatedListener = listener;
    }
}

package com.toofifty.goaltracker.ui.components;

import java.awt.Color;
import java.awt.Cursor;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.Consumer;
import javax.swing.JLabel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

public class TextButton extends JLabel
{
    private Color mainColor = ColorScheme.PROGRESS_COMPLETE_COLOR;

    public TextButton(String text, Color mainColor)
    {
        this(text);
        setMainColor(mainColor);
    }

    public TextButton(String text)
    {
        super(text);

        setFont(FontManager.getRunescapeSmallFont());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(new EmptyBorder(0, 8, 0, 8));
        setForeground(mainColor);
    }

    public TextButton setMainColor(Color mainColor)
    {
        this.mainColor = mainColor;
        setForeground(mainColor);
        return this;
    }

    public TextButton(String text, Consumer<MouseEvent> clickListener)
    {
        this(text);
        onClick(clickListener);
    }

    public TextButton onClick(Consumer<MouseEvent> clickListener)
    {
        addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent e)
            {
                clickListener.accept(e);
            }

            @Override
            public void mouseEntered(MouseEvent e)
            {
                setForeground(mainColor.darker());
                setCursor(new Cursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e)
            {
                setForeground(mainColor);
                setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            }
        });
        return this;
    }

    public TextButton narrow()
    {
        setBorder(new EmptyBorder(0, 2, 0, 2));
        return this;
    }
}

package com.toofifty.goaltracker.ui.components;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseListener;
import java.util.function.Consumer;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import lombok.Setter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.FlatTextField;

public class EditableInput extends JPanel
{

    private static final Border INPUT_BOTTOM_BORDER = new CompoundBorder(
        BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
        BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR)
    );

    private final FlatTextField inputField = new FlatTextField();
    private final TextButton save = new TextButton("Save").narrow();
    private final TextButton cancel = new TextButton("Cancel", ColorScheme.PROGRESS_ERROR_COLOR)
        .narrow();
    private final TextButton edit = new TextButton("Edit", ColorScheme.LIGHT_GRAY_COLOR).narrow();

    @Setter
    private Consumer<String> saveAction;

    private String localValue = "";

    public EditableInput(Consumer<String> saveAction)
    {
        this.saveAction = saveAction;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(INPUT_BOTTOM_BORDER);

        JPanel actions = new JPanel(new BorderLayout(3, 0));
        actions.setBorder(new EmptyBorder(0, 0, 0, 8));
        actions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        save.setVisible(false);
        save.onClick(e -> this.save());

        cancel.setVisible(false);
        cancel.onClick(e -> this.cancel());

        edit.onClick(e -> {
            inputField.setEditable(true);
            updateActions(true);
        });

        actions.add(save, BorderLayout.EAST);
        actions.add(cancel, BorderLayout.WEST);
        actions.add(edit, BorderLayout.CENTER);

        inputField.setText(localValue);
        inputField.setBorder(null);
        inputField.setEditable(false);
        inputField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        inputField.setPreferredSize(new Dimension(50, 24));
        inputField.getTextField().setForeground(Color.WHITE);
        inputField.getTextField().setBorder(new EmptyBorder(0, 8, 0, 0));
        inputField.addKeyListener(new KeyAdapter()
        {
            @Override
            public void keyPressed(KeyEvent e)
            {
                if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                    save();
                } else if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {
                    cancel();
                }
            }
        });

        add(inputField, BorderLayout.CENTER);
        add(actions, BorderLayout.EAST);
    }

    private void save()
    {
        localValue = inputField.getText();
        saveAction.accept(localValue);

        inputField.setEditable(false);
        updateActions(false);
        requestFocusInWindow();
    }

    private void cancel()
    {
        inputField.setEditable(false);
        inputField.setText(localValue);

        updateActions(false);
        requestFocusInWindow();
    }

    private void updateActions(boolean saveAndCancel)
    {
        save.setVisible(saveAndCancel);
        cancel.setVisible(saveAndCancel);
        edit.setVisible(!saveAndCancel);

        if (saveAndCancel) {
            inputField.getTextField().requestFocusInWindow();
            inputField.getTextField().selectAll();
        }
    }

    public void setValue(String value)
    {
        localValue = value;

        if (localValue == null) {
            localValue = "";
        }

        inputField.setText(localValue);
    }

    @Override
    public synchronized void addMouseListener(MouseListener l)
    {
        inputField.getTextField().addMouseListener(l);
    }
}

package com.toofifty.goaltracker.ui.components;

import com.toofifty.goaltracker.GoalTrackerPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.function.Function;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.ListCellRenderer;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicComboBoxUI;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

public class ComboBox<T> extends JComboBox<T>
{
    private Function<T, String> formatter = null;

    @SuppressWarnings("unchecked")
    public ComboBox(List<T> items)
    {
        this((T[]) items.toArray());
    }

    public ComboBox(T[] items)
    {
        super(items);

        setForeground(Color.WHITE);
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setFocusable(false);
        setRenderer(new ComboBoxListRenderer<>(formatter));
        setUI(new ComboBoxUI());
        setBorder(new EmptyBorder(0, 0, 0, 0));
    }

    public void setFormatter(Function<T, String> formatter)
    {
        this.formatter = formatter;
        setRenderer(new ComboBoxListRenderer<>(formatter));
    }
}

class ComboBoxUI extends BasicComboBoxUI
{
    private static final ImageIcon ARROW_UP;
    private static final ImageIcon ARROW_DOWN;

    static {
        final BufferedImage arrowUp = ImageUtil.loadImageResource(
            GoalTrackerPlugin.class, "/combo_arrow_up.png");
        ARROW_UP = new ImageIcon(arrowUp);

        final BufferedImage arrowDown = ImageUtil.loadImageResource(
            GoalTrackerPlugin.class, "/combo_arrow_down.png");
        ARROW_DOWN = new ImageIcon(arrowDown);
    }

    @Override
    protected JButton createArrowButton()
    {
        JButton button = new JButton();
        button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        button.setBorder(new EmptyBorder(4, 4, 4, 4));
        button.setBorderPainted(false);
        button.add(new JLabel(ARROW_DOWN));
        return button;
    }
}

class ComboBoxListRenderer<T> implements ListCellRenderer<T>
{
    private Function<T, String> formatter;

    ComboBoxListRenderer(Function<T, String> formatter)
    {
        this.formatter = formatter;
    }

    @Override
    public Component getListCellRendererComponent(
        JList<? extends T> list, T o, int index, boolean isSelected,
        boolean cellHasFocus)
    {
        JPanel container = new JPanel(new BorderLayout());

        container.setBorder(new EmptyBorder(0, 4, 0, 4));

        JLabel label = new JLabel();
        if (formatter != null) {
            label.setText(formatter.apply(o));
        } else {
            label.setText(
                o instanceof Enum ? Text.titleCase((Enum<?>) o) : o.toString());
        }
        container.add(label, BorderLayout.WEST);

        if (isSelected) {
            container.setBackground(ColorScheme.DARK_GRAY_COLOR);
            label.setForeground(Color.WHITE);
        }

        return container;
    }
}

package com.toofifty.goaltracker.ui.components;

import com.toofifty.goaltracker.utils.ReorderableList;
import com.toofifty.goaltracker.ui.Refreshable;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.Consumer;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;

public class ListItemPanel<T> extends JPanel implements Refreshable
{
    protected final JMenuItem moveUp = new JMenuItem("Move up");
    protected final JMenuItem moveDown = new JMenuItem("Move down");
    protected final JMenuItem moveToTop = new JMenuItem("Move to top");
    protected final JMenuItem moveToBottom = new JMenuItem("Move to bottom");
    protected final JMenuItem removeItem = new JMenuItem("Remove");
    protected final JPopupMenu popupMenu = new JPopupMenu();

    protected final ReorderableList<T> list;
    protected final T item;

    protected Consumer<T> reorderedListener;
    protected Consumer<T> removedListener;

    public ListItemPanel(ReorderableList<T> list, T item)
    {
        super(new BorderLayout());
        this.list = list;
        this.item = item;

        setBorder(new EmptyBorder(8, 8, 8, 8));
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        moveUp.addActionListener(e -> {
            list.moveUp(item);
            this.reorderedListener.accept(item);
        });

        moveDown.addActionListener(e -> {
            list.moveDown(item);
            this.reorderedListener.accept(item);
        });

        moveToTop.addActionListener(e -> {
            list.moveToTop(item);
            this.reorderedListener.accept(item);
        });

        moveToBottom.addActionListener(e -> {
            list.moveToBottom(item);
            this.reorderedListener.accept(item);
        });

        removeItem.addActionListener(e -> {
            list.remove(item);
            this.removedListener.accept(item);
        });

        popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));

        setComponentPopupMenu(popupMenu);
    }

    @Override
    public void setBackground(Color bg)
    {
        super.setBackground(bg);
        for (Component component : getComponents()) {
            component.setBackground(bg);
        }
    }

    @Override
    public void refresh()
    {
        refreshMenu();

        for (Component component : getComponents()) {
            if (component instanceof Refreshable) {
                ((Refreshable) component).refresh();
            }
        }
    }

    public void refreshMenu()
    {
        popupMenu.removeAll();
        if (!list.isFirst(item)) {
            popupMenu.add(moveUp);
        }
        if (!list.isLast(item)) {
            popupMenu.add(moveDown);
        }
        if (!list.isFirst(item)) {
            popupMenu.add(moveToTop);
        }
        if (!list.isLast(item)) {
            popupMenu.add(moveToBottom);
        }
        popupMenu.add(removeItem);
    }

    public ListItemPanel<T> add(Component comp)
    {
        super.add(comp, BorderLayout.CENTER);
        return this;
    }

    public void onClick(Consumer<MouseEvent> clickListener)
    {
        addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent e)
            {
                if (e.getButton() == MouseEvent.BUTTON1) {
                    clickListener.accept(e);
                }
            }

            @Override
            public void mouseEntered(MouseEvent e)
            {
                setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e)
            {
                setBackground(ColorScheme.DARK_GRAY_COLOR);
            }
        });
    }

    public void onRemoved(Consumer<T> removeListener) {
        this.removedListener = removeListener;
    }

    public void onReordered(Consumer<T> reorderListener) {
        this.reorderedListener = reorderListener;
    }
}

package com.toofifty.goaltracker.ui.components;

import com.toofifty.goaltracker.utils.ReorderableList;
import com.toofifty.goaltracker.models.task.Task;
import java.util.function.Consumer;
import javax.swing.JMenuItem;

public class ListTaskPanel extends ListItemPanel<Task>
{
    private final JMenuItem indentItem = new JMenuItem("Indent");
    private final JMenuItem unindentItem = new JMenuItem("Unindent");

    private Consumer<Task> indentedListener;
    private Consumer<Task> unindentedListener;

    public ListTaskPanel(ReorderableList<Task> list, Task item)
    {
        super(list, item);

        indentItem.addActionListener(e -> {
            // Indent all of the items children
            var index = list.indexOf(item);
            for (int i = index + 1; i < list.size(); i++) {
                var child = list.get(i);

                System.out.println(String.format("%s >= %s", item.getIndentLevel(), child.getIndentLevel()));
                // If a child is less indented then this item assume its a parent node and break
                if (item.getIndentLevel() >= child.getIndentLevel()) break;

                child.indent();
            }

            item.indent();
            this.indentedListener.accept(item);
        });

        unindentItem.addActionListener(e -> {
            // Unindent all of the items children
            var index = list.indexOf(item);
            for (int i = index + 1; i < list.size(); i++) {
                var child = list.get(i);

                System.out.println(String.format("%s >= %s", item.getIndentLevel(), child.getIndentLevel()));
                // If a child is less indented then this item assume its a parent node and break
                if (item.getIndentLevel() >= child.getIndentLevel()) break;

                child.unindent();;
            }

            item.unindent();
            this.unindentedListener.accept(item);
        });
    }

    @Override
    public void refreshMenu()
    {
        popupMenu.removeAll();
        if (!list.isFirst(item)) {
            popupMenu.add(moveUp);
        }
        if (!list.isLast(item)) {
            popupMenu.add(moveDown);
        }
        if (!list.isFirst(item)) {
            popupMenu.add(moveToTop);
        }
        if (!list.isLast(item)) {
            popupMenu.add(moveToBottom);
        }

        var previousItem = list.getPreviousItem(item);
        
        if (item.isNotFullyIndented() && previousItem != null && previousItem.getIndentLevel() >= item.getIndentLevel()) {
            popupMenu.add(indentItem);
        }

        if (item.isIndented()) {
            popupMenu.add(unindentItem);
        }

        popupMenu.add(removeItem);
    }

    public void onIndented(Consumer<Task> indentedListener) {
        this.indentedListener = indentedListener;
    }

    public void onUnindented(Consumer<Task> unindentedListener) {
        this.unindentedListener = unindentedListener;
    }
}

package com.toofifty.goaltracker.ui;

import com.toofifty.goaltracker.GoalTrackerPlugin;
import com.toofifty.goaltracker.models.task.Task;
import com.toofifty.goaltracker.services.TaskIconService;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

import static com.toofifty.goaltracker.utils.Constants.STATUS_TO_COLOR;

public class TaskItemContent extends JPanel implements Refreshable
{
    private final Task task;
    private final TaskIconService iconService;
    private final JLabel titleLabel = new JLabel();
    private final JLabel iconLabel = new JLabel();

    TaskItemContent(GoalTrackerPlugin plugin, Task task)
    {
        super(new BorderLayout());
        this.task = task;
        iconService = plugin.getTaskIconService();

        titleLabel.setPreferredSize(new Dimension(0, 24));
        add(titleLabel, BorderLayout.CENTER);

        JPanel iconWrapper = new JPanel(new BorderLayout());
        iconWrapper.setBorder(new EmptyBorder(4, 0, 0, 4));
        iconWrapper.add(iconLabel, BorderLayout.NORTH);
        add(iconWrapper, BorderLayout.WEST);

        plugin.getUiStatusManager().addRefresher(task, this::refresh);
    }

    @Override
    public void refresh()
    {
        titleLabel.setText(task.toString());
        titleLabel.setForeground(STATUS_TO_COLOR.get(task.getStatus()));

        int indent = 16 * task.getIndentLevel();
        iconLabel.setIcon(iconService.get(task));
        iconLabel.setBorder(new EmptyBorder(0, indent, 0, 0));

        revalidate();
    }

    @Override
    public void setBackground(Color bg)
    {
        super.setBackground(bg);
        for (Component component : getComponents()) {
            component.setBackground(bg);
        }
    }
}

package com.toofifty.goaltracker.ui.inputs;

import com.toofifty.goaltracker.GoalTrackerPlugin;
import com.toofifty.goaltracker.models.Goal;
import com.toofifty.goaltracker.models.task.ManualTask;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.FlatTextField;

import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

public class ManualTaskInput extends TaskInput<ManualTask>
{
    private final FlatTextField titleField;

    public ManualTaskInput(GoalTrackerPlugin plugin, Goal goal)
    {
        super(plugin, goal, "Quick add");

        titleField = new FlatTextField();
        titleField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        titleField.addKeyListener(new KeyAdapter()
        {
            @Override
            public void keyPressed(KeyEvent e)
            {
                if (e.getKeyCode() != KeyEvent.VK_ENTER) return;

                submit();
            }
        });

        getInputRow().add(titleField, BorderLayout.CENTER);
    }

    @Override
    protected void submit()
    {
        if (titleField.getText().isEmpty()) {
            return;
        }

        this.addTask(ManualTask.builder().description(titleField.getText()).build());
    }

    @Override
    protected void reset()
    {
        titleField.setText("");
        titleField.requestFocusInWindow();
    }
}

package com.toofifty.goaltracker.ui.inputs;

import com.toofifty.goaltracker.GoalTrackerPlugin;
import com.toofifty.goaltracker.models.Goal;
import com.toofifty.goaltracker.models.task.SkillLevelTask;
import com.toofifty.goaltracker.ui.SimpleDocumentListener;
import com.toofifty.goaltracker.ui.components.ComboBox;
import net.runelite.api.Skill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.FlatTextField;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.regex.Pattern;

public class SkillLevelTaskInput extends TaskInput<SkillLevelTask>
{

    private FlatTextField levelField;
    private String levelFieldValue = "99";

    private ComboBox<Skill> skillField;

    private Pattern numberPattern = Pattern.compile("^(?:\\d{1,2})?$");

    public SkillLevelTaskInput(GoalTrackerPlugin plugin, Goal goal)
    {
        super(plugin, goal, "Skill level");

        levelField = new FlatTextField();
        levelField.setBorder(new EmptyBorder(0, 8, 0, 8));
        levelField.getTextField().setHorizontalAlignment(SwingConstants.RIGHT);
        levelField.setText(levelFieldValue);
        levelField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        levelField.getDocument().addDocumentListener(
            (SimpleDocumentListener) e -> SwingUtilities.invokeLater(() -> {
                String value = levelField.getText();
                if (!numberPattern.matcher(value).find()) {
                    levelField.setText(levelFieldValue);
                    return;
                }
                levelFieldValue = value;
            }));
        levelField.setPreferredSize(new Dimension(92, PREFERRED_INPUT_HEIGHT));

        getInputRow().add(levelField, BorderLayout.CENTER);

        skillField = new ComboBox<>(Skill.values());

        getInputRow().add(skillField, BorderLayout.WEST);
    }

    @Override
    protected void submit()
    {
        if (levelField.getText().isEmpty()) {
            return;
        }

        addTask(SkillLevelTask.builder()
            .skill((Skill) skillField.getSelectedItem())
            .level(Integer.parseInt(levelField.getText()))
        .build());
    }

    @Override
    protected void reset()
    {
        levelFieldValue = "99";
        levelField.setText(levelFieldValue);

        skillField.setSelectedIndex(0);
    }
}

package com.toofifty.goaltracker.ui.inputs;

import com.toofifty.goaltracker.GoalTrackerPlugin;
import com.toofifty.goaltracker.models.Goal;
import com.toofifty.goaltracker.models.task.Task;
import com.toofifty.goaltracker.ui.components.TextButton;
import java.awt.BorderLayout;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.util.function.Consumer;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

public abstract class TaskInput<T extends Task> extends JPanel
{
    protected final int PREFERRED_INPUT_HEIGHT = 16;
    protected GoalTrackerPlugin plugin;
    private final Goal goal;
    @Getter
    private final JPanel inputRow;
    @Getter
    private Consumer<T> listener;

    TaskInput(GoalTrackerPlugin plugin, Goal goal, String title)
    {
        super(new GridBagLayout());
        this.plugin = plugin;
        this.goal = goal;

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridwidth = 1;
        constraints.gridy = 0;
        constraints.ipady = 8;

        JLabel titleLabel = new JLabel(title);
        titleLabel.setFont(FontManager.getRunescapeSmallFont());
        titleLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        titleLabel.setBorder(new EmptyBorder(2, 8, 0, 8));

        JPanel titleContainer = new JPanel(new BorderLayout());
        titleContainer.add(titleLabel, BorderLayout.WEST);

        add(titleContainer, constraints);
        constraints.gridy++;

        inputRow = new JPanel(new BorderLayout());
        inputRow.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        TextButton addButton = new TextButton("Add");
        addButton.onClick(e -> submit());

        inputRow.add(addButton, BorderLayout.EAST);

        add(inputRow, constraints);
        constraints.gridy++;
    }

    abstract protected void submit();

    public void addTask(T task)
    {
        goal.getTasks().add(task);
        this.listener.accept(task);
        this.reset();
    }

    abstract protected void reset();

    public TaskInput<T> onSubmit(Consumer<T> listener)
    {
        this.listener = listener;
        return this;
    }
}

package com.toofifty.goaltracker.ui.inputs;

import com.toofifty.goaltracker.GoalTrackerPlugin;
import com.toofifty.goaltracker.models.Goal;
import com.toofifty.goaltracker.models.task.QuestTask;
import com.toofifty.goaltracker.ui.components.ComboBox;
import net.runelite.api.Quest;

import java.awt.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class QuestTaskInput extends TaskInput<QuestTask>
{
    private final ComboBox<Quest> questField;

    public QuestTaskInput(GoalTrackerPlugin plugin, Goal goal)
    {
        super(plugin, goal, "Quest");

        List<Quest> quests = Arrays.asList(Quest.values());
        quests.sort(Comparator.comparing(
            (quest) -> quest.getName().replaceFirst("^(A|The) ", "")));
        questField = new ComboBox<>(quests);
        questField.setFormatter(Quest::getName);
        getInputRow().add(questField, BorderLayout.CENTER);
    }

    @Override
    protected void submit()
    {
        addTask(QuestTask.builder()
                .quest((Quest) questField.getSelectedItem())
        .build());
    }

    @Override
    protected void reset()
    {
        questField.setSelectedIndex(0);
    }
}

package com.toofifty.goaltracker.ui.inputs;

import com.toofifty.goaltracker.GoalTrackerPlugin;
import com.toofifty.goaltracker.models.Goal;
import com.toofifty.goaltracker.models.task.ItemTask;
import com.toofifty.goaltracker.ui.SimpleDocumentListener;
import com.toofifty.goaltracker.ui.components.TextButton;
import net.runelite.api.GameState;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.FlatTextField;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.regex.Pattern;

public class ItemTaskInput extends TaskInput<ItemTask>
{
    private final ItemManager itemManager;
    private final ClientThread clientThread;

    private final FlatTextField quantityField = new FlatTextField();
    private final TextButton searchItemButton = new TextButton("Search...");
    private final JLabel selectedItemLabel = new JLabel();
    private final JPanel selectedItemPanel = new JPanel(new BorderLayout());

    private final Pattern numberPattern = Pattern.compile("^(?:\\d+)?$");
    private final Pattern mPattern = Pattern.compile("^(?:\\d+m)?$", Pattern.CASE_INSENSITIVE);
    private final Pattern kPattern = Pattern.compile("^(?:\\d+k)?$", Pattern.CASE_INSENSITIVE);

    private String quantityFieldValue = "1";
    private ItemComposition selectedItem;

    public ItemTaskInput(GoalTrackerPlugin plugin, Goal goal)
    {
        super(plugin, goal, "Item");
        this.itemManager = plugin.getItemManager();
        this.clientThread = plugin.getClientThread();

        searchItemButton.onClick(e -> {
            if (plugin.getClient().getGameState() != GameState.LOGGED_IN) {
                JOptionPane.showMessageDialog(this,
                    "You must be logged in to choose items",
                    "UwU",
                    JOptionPane.ERROR_MESSAGE);
                return;
            }

            plugin.getItemSearch()
                .tooltipText("Choose an item")
                .onItemSelected(this::setSelectedItem)
                .build();
        });
        getInputRow().add(searchItemButton, BorderLayout.WEST);

        quantityField.setBorder(new EmptyBorder(0, 8, 0, 8));
        quantityField.getTextField().setHorizontalAlignment(SwingConstants.RIGHT);
        quantityField.setText(quantityFieldValue);
        quantityField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        quantityField.getDocument().addDocumentListener(
            (SimpleDocumentListener) e -> SwingUtilities.invokeLater(() -> {
                String value = quantityField.getText();

                if (mPattern.matcher(value).find()) {
                    value = value.replace("m", "000000");
                    quantityFieldValue = value;
                    quantityField.setText(quantityFieldValue);
                }

                if (kPattern.matcher(value).find()) {
                    value = value.replace("k", "000");
                    quantityFieldValue = value;
                    quantityField.setText(quantityFieldValue);
                }

                if (!numberPattern.matcher(value).find()) {
                    quantityField.setText(quantityFieldValue);
                    return;
                }

                quantityFieldValue = value;
            }));
        quantityField.setPreferredSize(new Dimension(92, PREFERRED_INPUT_HEIGHT));

        getInputRow().add(quantityField, BorderLayout.CENTER);

        selectedItemPanel.setBorder(new EmptyBorder(0, 8, 0, 8));
        selectedItemPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        selectedItemPanel.add(selectedItemLabel, BorderLayout.CENTER);
        TextButton clearItemButton = new TextButton("X")
                .setMainColor(ColorScheme.PROGRESS_ERROR_COLOR)
                .onClick((e) -> clearSelectedItem());
        selectedItemPanel.add(clearItemButton, BorderLayout.EAST);
    }

    private void setSelectedItem(Integer rawId)
    {
        clientThread.invokeLater(() -> {
            int id = itemManager.canonicalize(rawId);
            selectedItem = itemManager.getItemComposition(id);
            selectedItemLabel.setText(selectedItem.getName());

            getInputRow().remove(searchItemButton);
            getInputRow().add(selectedItemPanel, BorderLayout.WEST);

            revalidate();
            repaint();
        });
    }

    @Override
    protected void submit()
    {
        if (selectedItem == null || quantityField.getText().isEmpty()) {
            return;
        }

        this.addTask(ItemTask.builder()
            .itemId(selectedItem.getId())
            .itemName(selectedItem.getName())
            .quantity(Integer.parseInt(quantityField.getText()))
        .build());
    }

    @Override
    protected void reset()
    {
        clearSelectedItem();
        quantityFieldValue = "1";
        quantityField.setText(quantityFieldValue);
    }

    private void clearSelectedItem()
    {
        selectedItem = null;

        getInputRow().remove(selectedItemPanel);
        getInputRow().add(searchItemButton, BorderLayout.WEST);

        revalidate();
        repaint();
    }
}

package com.toofifty.goaltracker.ui.inputs;

import com.toofifty.goaltracker.GoalTrackerPlugin;
import com.toofifty.goaltracker.models.Goal;
import com.toofifty.goaltracker.models.task.SkillXpTask;
import com.toofifty.goaltracker.ui.SimpleDocumentListener;
import com.toofifty.goaltracker.ui.components.ComboBox;
import net.runelite.api.Skill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.FlatTextField;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.regex.Pattern;

public class SkillXpTaskInput extends TaskInput<SkillXpTask>
{
    private final FlatTextField xpField;
    private final ComboBox<Skill> skillField;
    private final Pattern numberPattern = Pattern.compile("^(?:\\d+)?$");
    private final Pattern mPattern = Pattern.compile("^(?:\\d+m)?$", Pattern.CASE_INSENSITIVE);
    private final Pattern kPattern = Pattern.compile("^(?:\\d+k)?$", Pattern.CASE_INSENSITIVE);
    private String xpFieldValue = "13034431";

    public SkillXpTaskInput(GoalTrackerPlugin plugin, Goal goal)
    {
        super(plugin, goal, "Skill XP");

        xpField = new FlatTextField();
        xpField.setBorder(new EmptyBorder(0, 8, 0, 8));
        xpField.getTextField().setHorizontalAlignment(SwingConstants.RIGHT);
        xpField.setText(xpFieldValue);
        xpField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        xpField.getDocument().addDocumentListener(
            (SimpleDocumentListener) e -> SwingUtilities.invokeLater(() -> {
                String value = xpField.getText();

                if (mPattern.matcher(value).find()) {
                    value = value.replace("m", "000000");
                    xpFieldValue = value;
                    xpField.setText(xpFieldValue);
                }

                if (kPattern.matcher(value).find()) {
                    value = value.replace("k", "000");
                    xpFieldValue = value;
                    xpField.setText(xpFieldValue);
                }

                if (!numberPattern.matcher(value).find()) {
                    xpField.setText(xpFieldValue);
                    return;
                }

                if (Integer.parseInt(value) > 200000000) {
                    xpField.setText("200000000");
                    value = "200000000";
                }

                xpFieldValue = value;
            }));
        xpField.setPreferredSize(new Dimension(92, PREFERRED_INPUT_HEIGHT));

        getInputRow().add(xpField, BorderLayout.CENTER);

        skillField = new ComboBox<>(Skill.values());

        getInputRow().add(skillField, BorderLayout.WEST);
    }

    @Override
    protected void submit()
    {
        if (xpField.getText().isEmpty()) {
            return;
        }

        addTask(SkillXpTask.builder()
            .skill((Skill) skillField.getSelectedItem())
            .xp(Integer.parseInt(xpField.getText()))
        .build());
    }

    @Override
    protected void reset()
    {
        xpFieldValue = "13034431";
        xpField.setText(xpFieldValue);

        skillField.setSelectedIndex(0);
    }
}

package com.toofifty.goaltracker.ui;

import com.toofifty.goaltracker.GoalTrackerPlugin;
import com.toofifty.goaltracker.models.Goal;
import com.toofifty.goaltracker.models.enums.TaskType;
import com.toofifty.goaltracker.models.task.ManualTask;
import com.toofifty.goaltracker.models.task.Task;
import com.toofifty.goaltracker.ui.components.EditableInput;
import com.toofifty.goaltracker.ui.components.ListPanel;
import com.toofifty.goaltracker.ui.components.ListTaskPanel;
import com.toofifty.goaltracker.ui.components.TextButton;
import java.awt.BorderLayout;
import java.util.Objects;
import java.util.function.Consumer;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;

public class GoalPanel extends JPanel implements Refreshable
{
    private final GoalTrackerPlugin plugin;
    private final Goal goal;

    private final EditableInput descriptionInput;
    private final ListPanel<Task> taskListPanel;
    private Consumer<Goal> goalUpdatedListener;
    private Consumer<Task> taskAddedListener;
    private Consumer<Task> taskUpdatedListener;

    GoalPanel(GoalTrackerPlugin plugin, Goal goal, Runnable closeListener)
    {
        super();
        this.plugin = plugin;
        this.goal = goal;

        setLayout(new BorderLayout());

        TextButton backButton = new TextButton("< Back", ColorScheme.PROGRESS_ERROR_COLOR);
        backButton.onClick((e) -> closeListener.run());

        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.add(backButton, BorderLayout.WEST);
        headerPanel.setBorder(new EmptyBorder(0, 0, 8, 0));
        add(headerPanel, BorderLayout.NORTH);

        descriptionInput = new EditableInput((value) -> {
            goal.setDescription(value);
            this.goalUpdatedListener.accept(goal);
        });
        headerPanel.add(descriptionInput, BorderLayout.CENTER);

        taskListPanel = new ListPanel<>(goal.getTasks(), (task) -> {
            ListTaskPanel taskPanel = new ListTaskPanel(goal.getTasks(), task);
            taskPanel.add(new TaskItemContent(plugin, task));
            taskPanel.setBorder(new EmptyBorder(2, 4, 2, 4));

            if (TaskType.MANUAL.equals(task.getType())) {
                ManualTask manualTask = (ManualTask) task;

                taskPanel.onClick(e -> {
                    manualTask.toggle();

                    if (task.getStatus().isCompleted()) {
                        plugin.notifyTask(task);
                    }

                    plugin.getUiStatusManager().refresh(task);
                    this.taskUpdatedListener.accept(manualTask);
                });
            }

            taskPanel.onIndented(e -> {
                this.goalUpdatedListener.accept(goal);
                plugin.getUiStatusManager().refresh(goal);
                this.refresh();
            });

            taskPanel.onUnindented(e -> {
                this.goalUpdatedListener.accept(goal);
                plugin.getUiStatusManager().refresh(goal);
                this.refresh();
            });

            return taskPanel;
        });
        taskListPanel.setGap(0);
        taskListPanel.setPlaceholder("No tasks added yet");
        add(taskListPanel, BorderLayout.CENTER);

        NewTaskPanel newTaskPanel = new NewTaskPanel(plugin, goal);
        newTaskPanel.onTaskAdded(this::updateFromNewTask);
        add(newTaskPanel, BorderLayout.SOUTH);
    }

    public void updateFromNewTask(Task task)
    {
        taskListPanel.tryBuildList();
        taskListPanel.refresh();
        plugin.setValidateAll(true);

        if (Objects.nonNull(this.taskAddedListener)) this.taskAddedListener.accept(task);
        if (Objects.nonNull(this.taskUpdatedListener)) this.taskUpdatedListener.accept(task);
    }

    @Override
    public void refresh()
    {
        descriptionInput.setValue(goal.getDescription());
        taskListPanel.refresh();
    }

    public void onGoalUpdated(Consumer<Goal> listener)
    {
        this.goalUpdatedListener = listener;
    }

    public void onTaskAdded(Consumer<Task> listener)
    {
        this.taskAddedListener = listener;

        taskListPanel.onUpdated(this.taskAddedListener);
    }

    public void onTaskUpdated(Consumer<Task> listener)
    {
        this.taskUpdatedListener = listener;

        taskListPanel.onUpdated(this.taskUpdatedListener);
    }
}

package com.toofifty.goaltracker;

import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.toofifty.goaltracker.adapters.QuestAdapter;
import com.toofifty.goaltracker.adapters.SkillAdapter;
import com.toofifty.goaltracker.adapters.TaskAdapter;
import com.toofifty.goaltracker.models.Goal;
import com.toofifty.goaltracker.models.task.Task;
import com.toofifty.goaltracker.utils.ReorderableList;
import net.runelite.api.Quest;
import net.runelite.api.Skill;

import java.util.List;

import javax.inject.Inject;

public class GoalSerializer
{	
    @Inject
	private Gson gson;

    public ReorderableList<Goal> deserialize(String serialized)
    {
        return ReorderableList.from(this.getBuilder().fromJson(serialized, Goal[].class));
    }

    public String serialize(List<Goal> goals)
    {
        return this.serialize(goals, false);
    }

    public String serialize(List<Goal> goals, boolean prettyPrinting)
    {
        return this.getBuilder(prettyPrinting).toJson(goals);
    }

    private Gson getBuilder() {
        return this.getBuilder(false);
    }

    private Gson getBuilder(boolean prettyPrinting) {
        var builder = gson.newBuilder()
            .setFieldNamingStrategy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
            .registerTypeAdapter(Task.class, new TaskAdapter())
            .registerTypeAdapter(Skill.class, new SkillAdapter())
            .registerTypeAdapter(Quest.class, new QuestAdapter());

        if (prettyPrinting) {
            builder.setPrettyPrinting();
        }

        return builder.create();
    }
}

package com.toofifty.goaltracker.adapters;

import com.google.gson.*;
import net.runelite.api.Skill;

import java.lang.reflect.Type;
import java.util.Arrays;

public class SkillAdapter implements JsonSerializer<Skill>, JsonDeserializer<Skill> {
    @Override
    public JsonElement serialize(Skill src, Type typeOfSrc, JsonSerializationContext context) {
        return context.serialize(src.getName());
    }

    @Override
    public Skill deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException  {
        return Arrays.stream(Skill.values()).filter((skill) -> skill.getName().equals(json.getAsString())).findFirst().orElse(null);
    }
}
package com.toofifty.goaltracker.adapters;

import com.google.gson.*;
import com.toofifty.goaltracker.models.enums.TaskType;
import com.toofifty.goaltracker.models.task.*;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Type;

@Slf4j
public class TaskAdapter implements JsonSerializer<Task>, JsonDeserializer<Task> {

    @Override
    public JsonElement serialize(Task src, Type typeOfSrc, JsonSerializationContext context) {
        JsonObject json = context.serialize(src).getAsJsonObject();
        json.addProperty("type", context.serialize(src.getType()).getAsString());
        return json;
    }

    @Override
    public Task deserialize(JsonElement json, Type typeOfT,
                               JsonDeserializationContext context) throws JsonParseException  {
        TaskType taskType = TaskType.fromString(json.getAsJsonObject().get("type").getAsString());
        switch (taskType) {
            case SKILL_XP:
                return context.deserialize(json, SkillXpTask.class);
            case ITEM:
                return context.deserialize(json, ItemTask.class);
            case MANUAL:
                return context.deserialize(json, ManualTask.class);
            case QUEST:
                return context.deserialize(json, QuestTask.class);
            case SKILL_LEVEL:
                return context.deserialize(json, SkillLevelTask.class);
            default:
                log.error("Unknown task type: " + taskType);
                return null;
        }
    }
}
package com.toofifty.goaltracker.adapters;

import com.google.gson.*;
import net.runelite.api.Quest;

import java.lang.reflect.Type;
import java.util.Arrays;

public class QuestAdapter implements JsonSerializer<Quest>, JsonDeserializer<Quest> {

    @Override
    public JsonElement serialize(Quest src, Type typeOfSrc, JsonSerializationContext context) {
        return context.serialize(src.getId());
    }

    @Override
    public Quest deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException  {
        return Arrays.stream(Quest.values()).filter((quest) -> quest.getId() == json.getAsInt()).findFirst().orElse(null);
    }
}
package com.toofifty.goaltracker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("goaltracker")
public interface GoalTrackerConfig extends Config
{
    @ConfigItem(keyName = "goalTrackerData", name = "", description = "", hidden = true)
    default String goalTrackerData()
    {
        return "";
    }

    @ConfigItem(keyName = "goalTrackerData", name = "", description = "", hidden = true)
    void goalTrackerData(String str);

    @ConfigItem(keyName = "goalTrackerItemCache", name = "", description = "", hidden = true)
    default String goalTrackerItemCache()
    {
        return "";
    }

    @ConfigItem(keyName = "goalTrackerItemCache", name = "", description = "", hidden = true)
    void goalTrackerItemCache(String str);

    @ConfigItem(keyName = "goalTrackerItemNoteMapCache", name = "", description = "", hidden = true)
    default String goalTrackerItemNoteMapCache()
    {
        return "";
    }

    @ConfigItem(keyName = "goalTrackerItemNoteMapCache", name = "", description = "", hidden = true)
    void goalTrackerItemNoteMapCache(String str);
}

package com.toofifty.goaltracker.models.task;

import com.toofifty.goaltracker.models.enums.Status;
import com.toofifty.goaltracker.models.enums.TaskType;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Setter
@Getter
@SuperBuilder
public class ManualTask extends Task
{
    private String description;

    public void toggle()
    {
        this.setStatus(this.getStatus().isNotStarted() ? Status.COMPLETED : Status.NOT_STARTED);
    }

    @Override
    public String toString()
    {
        return description;
    }

    @Override
    public TaskType getType()
    {
        return TaskType.MANUAL;
    }
}

package com.toofifty.goaltracker.models.task;

import com.google.gson.annotations.SerializedName;
import com.toofifty.goaltracker.models.enums.Status;
import com.toofifty.goaltracker.models.enums.TaskType;
import lombok.Builder;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Getter
@Setter
@SuperBuilder
public abstract class Task
{
    @Builder.Default
    @SerializedName("previous_result")
    private Status status = Status.NOT_STARTED;

    @Builder.Default
    @SerializedName("has_been_notified")
    private boolean notified = false;

    @Builder.Default
    @SerializedName("indent_level")
    private int indentLevel = 0;

    public boolean isDone() {
        return Status.COMPLETED.equals(this.status);
    }

    public void indent() {
        if (isFullyIndented()) return;

        indentLevel += 1;
    }

    public void unindent() {
        if (isNotIndented()) return;

        indentLevel -= 1;
    }

    public boolean isIndented() {
        return indentLevel > 0;
    }

    public boolean isNotIndented() {
        return !isIndented();
    }

    public boolean isFullyIndented() {
        return indentLevel == 3;
    }

    public boolean isNotFullyIndented() {
        return !isFullyIndented();
    }

    @Override
    abstract public String toString();

    abstract public TaskType getType();
}

package com.toofifty.goaltracker.models.task;

import com.toofifty.goaltracker.models.enums.TaskType;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.SuperBuilder;
import net.runelite.api.Skill;

@Getter
@Setter
@SuperBuilder
public class SkillXpTask extends Task
{
    private Skill skill;
    private int xp;

    @Override
    public String toString()
    {
        return String.format("%d %s XP", xp, skill.getName());
    }

    @Override
    public TaskType getType()
    {
        return TaskType.SKILL_XP;
    }
}

package com.toofifty.goaltracker.models.task;

import com.toofifty.goaltracker.models.enums.TaskType;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.SuperBuilder;
import net.runelite.api.Skill;

@Setter
@Getter
@SuperBuilder
public class SkillLevelTask extends Task
{
    private Skill skill;
    private int level;

    @Override
    public String toString()
    {
        return String.format("%s %s", level, skill.getName());
    }

    @Override
    public TaskType getType()
    {
        return TaskType.SKILL_LEVEL;
    }
}

package com.toofifty.goaltracker.models.task;

import com.toofifty.goaltracker.models.enums.TaskType;
import lombok.Builder;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

import java.awt.image.BufferedImage;

@Setter
@Getter
@SuperBuilder
public class ItemTask extends Task
{
    private transient BufferedImage cachedIcon;
    private int quantity;
    @Builder.Default
    private int acquired = 0;
    private int itemId;
    private String itemName;

    @Override
    public String toString()
    {
        if (quantity == 1) {
            return itemName;
        }

        if (acquired > 0 && acquired < quantity) {
            return String.format("%d/%d x %s", acquired, quantity, itemName);
        }

        return String.format("%d x %s", quantity, itemName);
    }

    @Override
    public TaskType getType()
    {
        return TaskType.ITEM;
    }
}

package com.toofifty.goaltracker.models.task;

import com.google.gson.annotations.SerializedName;
import com.toofifty.goaltracker.models.enums.TaskType;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.SuperBuilder;
import net.runelite.api.Quest;

@Getter
@Setter
@SuperBuilder
public class QuestTask extends Task
{
    @SerializedName("quest_id")
    private Quest quest;

    @Override
    public String toString()
    {
        return quest.getName();
    }

    @Override
    public TaskType getType()
    {
        return TaskType.QUEST;
    }
}

package com.toofifty.goaltracker.models;

import com.google.gson.annotations.SerializedName;
import com.toofifty.goaltracker.utils.ReorderableList;
import com.toofifty.goaltracker.models.enums.Status;
import com.toofifty.goaltracker.models.task.Task;
import lombok.Builder;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

@Setter
@Getter
@SuperBuilder
public class Goal
{
    @Builder.Default
    private String description = "New goal";

    @Builder.Default
    private int displayOrder = -1;

    @SerializedName("items")
    @Builder.Default
    private ReorderableList<Task> tasks = new ReorderableList<>();

    private List<Task> filterBy(Predicate<Task> predicate)
    {
        return this.getTasks().stream().filter(predicate).collect(Collectors.toList());
    }

    public boolean isStatus(Status status) {
        return this.getTasks().stream().allMatch((task) -> task.getStatus() == status);
    }

    public boolean isAnyStatus(Status ...statuses) {
        return this.getTasks().stream().anyMatch((task) -> Arrays.stream(statuses).anyMatch((status) -> status == task.getStatus()));
    }

    public List<Task> getComplete() {
        return this.filterBy(Task::isDone);
    }

    public Status getStatus() {
        if (this.isStatus(Status.COMPLETED)) {
            return Status.COMPLETED;
        }

        if (this.isAnyStatus(Status.IN_PROGRESS, Status.COMPLETED)) {
            return Status.IN_PROGRESS;
        }

        return Status.NOT_STARTED;
    }
}

package com.toofifty.goaltracker.models.enums;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.QuestState;

@Getter
@AllArgsConstructor
public enum Status
{
    @SerializedName("not_started")
    NOT_STARTED("not_started"),
    @SerializedName("in_progress")
    IN_PROGRESS("in_progress"),
    @SerializedName("completed")
    COMPLETED("completed");

    private final String name;

    public static Status fromQuestState(QuestState questState)
    {
        switch (questState) {
            case IN_PROGRESS:
                return Status.IN_PROGRESS;
            case FINISHED:
                return Status.COMPLETED;
            default:
                return Status.NOT_STARTED;
        }
    }

    public boolean isCompleted()
    {
        return this == COMPLETED;
    }

    public boolean isInProgress()
    {
        return this == IN_PROGRESS;
    }

    public boolean isNotStarted()
    {
        return this == NOT_STARTED;
    }

    @Override
    public String toString() {
        return this.name;
    }
}

package com.toofifty.goaltracker.models.enums;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum TaskType
{
    @SerializedName("manual")
    MANUAL("manual"),
    @SerializedName("skill_level")
    SKILL_LEVEL("skill_level"),
    @SerializedName("skill_xp")
    SKILL_XP("skill_xp"),
    @SerializedName("quest")
    QUEST("quest"),
    @SerializedName("item")
    ITEM("item");

    private final String name;

    public static TaskType fromString(String name)
    {
        for (TaskType type : TaskType.values()) {
            if (type.toString().equals(name)) {
                return type;
            }
        }
        throw new IllegalStateException("Invalid task type " + name);
    }

    @Override
    public String toString()
    {
        return this.name;
    }
}

