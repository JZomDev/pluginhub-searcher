package com.toofifty.xpmeter;

import static com.toofifty.xpmeter.Util.secondsToTicks;
import static com.toofifty.xpmeter.Util.ticksToSeconds;
import java.util.ArrayList;
import java.util.List;

public class Intervals
{
	/**
	 * Generate XP intervals based on the maximum XP
	 * displayed in the chart.
	 * Aims to have 1-3 intervals displayed at one time.
	 */
	public static List<Integer> getXpIntervals(int max)
	{
		var interval = 500_000;
		if (max < 10_000)
		{
			interval = 5_000;
		}
		else if (max < 25_000)
		{
			interval = 10_000;
		}
		else if (max < 100_000)
		{
			interval = 25_000;
		}
		else if (max < 200_000)
		{
			interval = 50_000;
		}
		else if (max < 500_000)
		{
			interval = 100_000;
		}
		else if (max < 1_000_000)
		{
			interval = 250_000;
		}

		final var xpIntervals = new ArrayList<Integer>();
		for (var i = 0; i < max; i += interval)
		{
			xpIntervals.add(i);
		}
		return xpIntervals;
	}

	/**
	 * Generate time intervals based on the time span
	 * displayed in the chart.
	 * Aims to have 4-8 intervals displayed at one time.
	 */
	public static List<Integer> getTimeIntervals(int startTick, int endTick)
	{
		final var span = ticksToSeconds(endTick - startTick);

		var interval = secondsToTicks(3600);
		if (span < 120) // 2min
		{
			interval = secondsToTicks(15);
		}
		else if (span < 240) // 4min
		{
			interval = secondsToTicks(30);
		}
		else if (span < 480) // 8min
		{
			interval = secondsToTicks(60);
		}
		else if (span < 1800) // 30min
		{
			interval = secondsToTicks(300);
		}
		else if (span < 3600) // 1h
		{
			interval = secondsToTicks(900);
		}
		else if (span < 7200) // 2h
		{
			interval = secondsToTicks(1800);
		}

		final var timeIntervals = new ArrayList<Integer>();

		// always add span start time
		timeIntervals.add(startTick);

		// generate all time intervals up to current tick
		// only keep if > spanStart
		for (var i = 0; i < endTick; i += interval)
		{
			if (i > startTick) timeIntervals.add(i);
		}

		// always add current time
		timeIntervals.add(endTick);

		return timeIntervals;
	}
}

package com.toofifty.xpmeter;

import java.awt.Color;
import lombok.AllArgsConstructor;
import net.runelite.api.Skill;

@AllArgsConstructor
public enum SkillColor
{
	// must match order of Skill enum

	ATTACK(new Color(145, 58, 42)),
	DEFENCE(new Color(119, 133, 196)),
	STRENGTH(new Color(57, 113, 78)),
	HITPOINTS(new Color(167, 57, 30)),
	RANGED(new Color(93, 111, 35)),
	PRAYER(new Color(192, 185, 185)),
	MAGIC(new Color(76, 77, 157)),
	COOKING(new Color(109, 53, 137)),
	WOODCUTTING(new Color(128, 110, 65)),
	FLETCHING(new Color(65, 101, 105)),
	FISHING(new Color(134, 172, 221)),
	FIREMAKING(new Color(198, 135, 44)),
	CRAFTING(new Color(115, 94, 71)),
	SMITHING(new Color(84, 84, 67)),
	MINING(new Color(81, 80, 65)),
	HERBLORE(new Color(60, 139, 22)),
	AGILITY(new Color(68, 68, 201)),
	THIEVING(new Color(109, 71, 99)),
	SLAYER(new Color(104, 95, 95)),
	FARMING(new Color(57, 89, 45)),
	RUNECRAFT(new Color(178, 178, 168)),
	HUNTER(new Color(128, 124, 103)),
	CONSTRUCTION(new Color(169, 159, 138)),
	SAILING(new Color(0, 71, 255));

	private final Color color;

	public static Color get(Skill skill)
	{
		return values()[skill.ordinal()].color;
	}
}

package com.toofifty.xpmeter;

import java.awt.Color;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum Theme
{
	RUNELITE(
		new Color(0, 0, 0, 32), // chartBackground
		null, // chartBorder
		null, // overlayBackground

		new Color(255, 255, 255, 128), // axisLabelColor
		false, // axisLabelShadow
		new Color(255, 255, 255, 32), // verticalMarkerColor
		new Color(0, 0, 0, 32), // horizontalMarkerColor
		true, // plotShadow

		null, // tooltipBorder
		new Color(0, 0, 0, 64), // tooltipBackground
		null, // tooltipTextColor
		true,  // tooltipTextShadow
		null, // rateOuterBorder
		null, // rateInnerBorder
		new Color(0, 0, 0, 64), // rateBackground
		null, // rateTextColor
		1, // ratePadding
		3 // rateMargin
	),
	TRANSPARENT(
		new Color(0, 0, 0, 32), // chartBackground
		null, // chartBorder
		new Color(0, 0, 0, 0), // overlayBackground

		new Color(255, 255, 255, 128), // axisLabelColor
		false, // axisLabelShadow
		new Color(255, 255, 255, 32), // verticalMarkerColor
		new Color(0, 0, 0, 32), // horizontalMarkerColor
		true, // plotShadow

		null, // tooltipBorder
		new Color(0, 0, 0, 128), // tooltipBackground
		null, // tooltipTextColor
		true, // tooltipTextShadow
		null, // rateOuterBorder
		null, // rateInnerBorder
		new Color(0, 0, 0, 128), // rateBackground
		null, // rateTextColor
		1, // ratePadding
		3 // rateMargin
	),
	OLD_SCHOOL(
		new Color(192, 176, 141, 255), // chartBackground
		new Color(45, 42, 35, 255), // chartBorder
		new Color(72, 63, 53, 255), // overlayBackground

		new Color(253, 151, 32, 255), // axisLabelColor
		true, // axisLabelShadow
		new Color(0, 0, 0, 64), // verticalMarkerColor
		new Color(0, 0, 0, 32), // horizontalMarkerColor
		false, // plotShadow

		Color.BLACK, // tooltipBorder
		new Color(253, 253, 160, 255), // tooltipBackground
		Color.BLACK,  // tooltipTextColor
		false, // tooltipTextShadow
		new Color(45, 42, 34, 255), // rateOuterBorder
		new Color(114, 100, 81, 255), // rateInnerBorder
		new Color(85, 76, 65, 255), // rateBackground
		new Color(255, 255, 0, 255), // rateTextColor
		3, // ratePadding
		3 // rateMargin
	);

	public final Color chartBackground;
	public final Color chartBorder;
	public final Color overlayBackground;

	public final Color axisLabelColor;
	public final boolean axisLabelShadow;
	public final Color verticalMarkerColor;
	public final Color horizonalMarkerColor;
	public final boolean plotShadow;

	public final Color tooltipBorder;
	public final Color tooltipBackground;
	public final Color tooltipTextColor;
	public final boolean tooltipTextShadow;

	public final Color rateOuterBorder;
	public final Color rateInnerBorder;
	public final Color rateBackground;
	public final Color rateTextColor;
	// x pad inside container
	public final int ratePadding;
	// x margin outside container
	public final int rateMargin;
}

package com.toofifty.xpmeter;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum TrackingMode
{
	CUMULATIVE("Cumulative"),
	SLIDING_WINDOW("Sliding window");

	private final String name;
}

package com.toofifty.xpmeter;

public class Util
{
	public static int ticksToSeconds(int ticks)
	{
		return (int) (ticks * 0.6d);
	}

	public static int secondsToTicks(int seconds)
	{
		return (int) ((double) seconds / 0.6d);
	}

	public static String ticksToTime(int ticks)
	{
		final var seconds = ticksToSeconds(ticks);
		final var minutes = (int) (seconds / 60d);
		final var hours = (int) (minutes / 60d);

		return hours > 0
			? String.format("%d:%02d:%02d", hours, minutes % 60, seconds % 60)
			: String.format("%02d:%02d", minutes % 60, seconds % 60);
	}

	public static String format(int number)
	{
		if (number < 100000)
		{
			return String.format("%,d", number);
		}

		if (number < 10000000)
		{
			return String.format("%,dK", number / 1000);
		}

		return String.format("%,dM", number / 1000000);
	}

	public static String shortFormat(int number)
	{
		if (number < 1000)
		{
			return "" + number;
		}

		if (number < 1_000_000)
		{
			return String.format("%,dK", number / 1000);
		}

		return String.format("%,dM", number / 1000000);
	}
}

package com.toofifty.xpmeter;

import com.google.common.collect.Lists;
import static com.toofifty.xpmeter.Util.secondsToTicks;
import static com.toofifty.xpmeter.Util.shortFormat;
import static com.toofifty.xpmeter.Util.ticksToTime;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.util.List;
import java.util.Map;
import java.util.Set;
import lombok.Setter;
import net.runelite.api.Skill;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;

public class XPChart extends XPChartBase implements LayoutableRenderableEntity
{
	public static final int MIN_WIDTH = 60;
	public static final int SKILL_ICON_WIDTH = 16;

	// padding

	private static final int TIME_LABEL_TPAD = 2;
	private static final int TIME_LABEL_SPACING = 4;
	private static final int XP_LABEL_RPAD = 2;
	private static final int STACKED_RATE_GAP = 3;

	private static final int XP_TOOLTIP_LPAD = 8;

	private static final Color PAUSE_MARKER_COLOR = new Color(0, 166, 255, 128);
	private static final Color LOGOUT_MARKER_COLOR = new Color(255, 68, 0, 128);
	private static final Color CURSOR_MARKER_COLOR = new Color(255, 255, 255, 128);

	@Setter private SkillIconManager skillIconManager;

	// incoming data

	@Setter private Map<Skill, List<Point>> skillXpHistories = null;

	/**
	 * Skill keys, sorted from the lowest current rate to highest
	 */
	@Setter private List<Skill> sortedSkills = null;
	@Setter private int maxXpPerHour = 0;
	@Setter private int currentTick = 0;
	@Setter private Set<Integer> pauses = null;
	@Setter private Set<Integer> logouts = null;

	@Setter private XPTracker.Performance performance;

	@Setter private Point mouse = null;

	// configs

	@Setter private int span = secondsToTicks(180);
	@Setter private int chartHeight = 60;
	@Setter private boolean showTimeLabels = true;
	@Setter private boolean showTimeMarkers = true;
	@Setter private boolean showXpLabels = true;
	@Setter private boolean showXpMarkers = true;
	@Setter private boolean showCurrentRates = true;
	@Setter private boolean stackCurrentRates = false;
	@Setter private boolean showSkillIcons = true;
	@Setter private boolean longFormatNumbers = false;
	@Setter private boolean showPerformance = false;
	@Setter private boolean showHoverTooltips = true;
	@Setter private boolean dimNonHoveredSkills = true;
	@Setter private boolean showAllHovers = false;
	@Setter private Theme theme = Theme.RUNELITE;

	// local data

	private Skill hoveredSkill = null;

	public boolean hasData()
	{
		return currentTick > 0 && maxXpPerHour > 0;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!hasData())
		{
			return new Dimension(0, 0);
		}

		// antialias off results in thicker looking lines,
		// and are better upscaled by xBR
		graphics.setRenderingHint(
			RenderingHints.KEY_ANTIALIASING,
			RenderingHints.VALUE_ANTIALIAS_OFF
		);

		final var dimension = super.render(graphics);

		setHeightScale(maxXpPerHour);
		setWidthMin(Math.max(currentTick - span, 0));
		setWidthMax(currentTick);

		// background
		setColor(theme.chartBackground);
		fillRect(0, 0, size.width, size.height);
		setColor(theme.chartBorder);
		drawRect(0, 0, size.width, size.height);

		drawXpLabels();
		drawTimeLabels();
		drawHistoryPlot();
		drawCurrentRates();
		drawPauses();
		drawPerformance();
		drawMouseOver();

		return dimension;
	}

	private void drawXpLabels()
	{
		final var xpIntervals = Intervals.getXpIntervals(maxXpPerHour);

		if (showXpLabels)
		{
			var lastY = 0;
			setColor(theme.axisLabelColor);
			// reverse so topmost labels have priority
			for (var xp : Lists.reverse(xpIntervals))
			{
				// no point rendering 0
				if (xp == 0) continue;

				final var label = shortFormat(xp);
				final var x = -width(label) - XP_LABEL_RPAD;
				final var y = mapY(xp, true) + fontHeight / 2;

				// do not draw overlapping xps
				if (y - fontHeight > lastY)
				{
					drawText(label, x, y, theme.axisLabelShadow);
					lastY = y;
				}
			}
		}

		if (showXpMarkers)
		{
			setColor(theme.horizonalMarkerColor);
			for (var xp : xpIntervals)
			{
				drawHMarker(mapY(xp, true));
			}
		}
	}

	private void drawTimeLabels()
	{
		final var timeIntervals = Intervals.getTimeIntervals(
			Math.max(currentTick - span, 0),
			currentTick
		);

		var originX = Integer.MIN_VALUE;

		// removing it now prevents the first marker
		// from showing even if showTimeLabels is false
		final var origin = timeIntervals.remove(0);
		final var y = size.height + fontHeight + TIME_LABEL_TPAD;

		if (showTimeLabels)
		{
			setColor(theme.axisLabelColor);
			{
				final var time = ticksToTime(origin);
				final var width = width(time);
				final var x = mapX(origin) - width / 2;

				drawText(time, x, y, theme.axisLabelShadow);

				originX = x + width + TIME_LABEL_SPACING;
			}

			var lastX = Integer.MAX_VALUE;
			// reverse so rightmost labels have priority
			for (var timeTick : Lists.reverse(timeIntervals))
			{
				final var time = ticksToTime(timeTick);
				final var width = width(time);
				final var x = mapX(timeTick) - width / 2;

				// do not draw overlapping times
				// (either on next time to the right, or origin)
				if (x + width < lastX && x > originX)
				{
					drawText(time, x, y, theme.axisLabelShadow);

					lastX = x - TIME_LABEL_SPACING;
				}
			}
		}

		if (showTimeMarkers)
		{
			setColor(theme.verticalMarkerColor);
			for (var timeTick : timeIntervals)
			{
				drawVMarker(mapX(timeTick));
			}
		}
	}

	private void drawCurrentRates()
	{
		if (!showCurrentRates && !showSkillIcons)
		{
			return;
		}

		final var baseX = size.width + theme.rateMargin;

		var lastY = size.height;
		for (var skill : sortedSkills)
		{
			final var skillColor = getSkillColor(skill);
			final var history = skillXpHistories.get(skill);
			final var last = history.get(history.size() - 1);

			if (last != null && last.getY() != 0)
			{
				final var rate = format(last.y);
				var y = mapY(last.y, true);
				var x = baseX;

				final var boxHeight = fontHeight + 2;

				// do not allow any rates to render under the chart
				if (y + boxHeight / 2 + STACKED_RATE_GAP > lastY)
				{
					y = lastY - boxHeight / 2 - STACKED_RATE_GAP;
				}

				if (stackCurrentRates && !showSkillIcons)
				{
					lastY = y - fontHeight / 2;
				}

				if (showSkillIcons)
				{
					final var icon = skillIconManager.getSkillImage(skill, true);

					if (y + icon.getHeight() / 2 > lastY)
					{
						y = lastY - icon.getHeight() / 2;
					}

					if (stackCurrentRates)
					{
						lastY = y - icon.getHeight() / 2;
					}

					x += icon.getWidth() + theme.rateMargin;
					drawImage(icon, baseX, y - icon.getHeight() / 2);
				}

				if (showCurrentRates)
				{
					final var padding = theme.ratePadding;
					x += padding;

					if (theme.rateOuterBorder != null)
					{
						setColor(theme.rateBackground);
						fillRoundRect(
							x - padding,
							y - boxHeight / 2,
							width(rate) + padding * 2,
							boxHeight,
							4
						);
						setColor(theme.rateInnerBorder);
						drawRoundRect(
							x - padding,
							y - boxHeight / 2,
							width(rate) + padding * 2,
							boxHeight,
							4
						);
						setColor(theme.rateOuterBorder);
						drawRoundRect(
							x - padding - 1,
							y - boxHeight / 2 - 1,
							width(rate) + padding * 2 + 2,
							boxHeight + 2,
							5
						);
						setColor(theme.rateTextColor);
					}
					else
					{
						setColor(theme.rateBackground);
						fillRoundRect(
							x - padding,
							y - boxHeight / 2,
							width(rate) + padding * 2,
							boxHeight,
							2
						);
						setColor(skillColor);
					}

					drawText(rate, x, y + fontHeight / 2, true);
				}
			}
		}
	}

	private void drawHistoryPlot()
	{
		for (var skill : sortedSkills)
		{
			setColor(getSkillColor(skill));
			var isFlatlining = false;

			Point prev = null;
			for (var point : skillXpHistories.get(skill))
			{
				final var x = mapX(point.x);
				final var y = mapY(point.y, true);

				// flat lining if xp = 0, and trying to draw at same y coord
				isFlatlining = prev != null && point.getY() == 0 && prev.y == y;

				if (prev != null && !isFlatlining)
				{
					drawLine(prev.x, prev.y, x, y, theme.plotShadow);
				}

				prev = new Point(x, y);
			}

			// draw to end of chart
			if (prev != null && !isFlatlining)
			{
				drawLine(prev.x, prev.y, size.width, prev.y, theme.plotShadow);
			}
		}
	}

	public void drawPauses()
	{
		setColor(PAUSE_MARKER_COLOR);
		for (var tick : pauses)
		{
			final var x = mapX(tick);
			if (x >= 0)
			{
				drawVMarker(x);
			}
		}

		setColor(LOGOUT_MARKER_COLOR);
		for (var tick : logouts)
		{
			final var x = mapX(tick);
			if (x >= 0)
			{
				drawVMarker(x);
			}
		}
	}

	private void drawPerformance()
	{
		if (!showPerformance)
		{
			return;
		}

		final var time = performance.getComputeTime() == 0 ? "<1" : "" + performance.getComputeTime();

		final var text = time + "ms "
			+ "Cached: " + performance.getCacheSize() + " "
			+ "Hits: " + performance.getCacheHits() + " "
			+ "Misses: " + performance.getCacheMisses() + " "
			+ "Resolution: " + performance.getRenderedResolution() + "s ";

		final var y = size.height + fontHeight + TIME_LABEL_TPAD + (showTimeLabels ? fontHeight + TIME_LABEL_TPAD : 0);

		if (performance.getComputeTime() > 30)
		{
			setColor(Color.RED);
		}
		else if (performance.getComputeTime() > 10)
		{
			setColor(Color.ORANGE);
		}
		else if (performance.getComputeTime() > 4)
		{
			setColor(Color.YELLOW);
		}
		else
		{
			setColor(theme.axisLabelColor);
		}

		drawText(text, 0, y, true);
	}

	public void drawMouseOver()
	{
		if (mouse == null || !showHoverTooltips)
		{
			hoveredSkill = null;
			return;
		}

		final var mx = mouse.x - offset.x;
		final var my = mouse.y - offset.y;

		if (mx < 0 || my < 0 || mx > size.width || my > size.height)
		{
			hoveredSkill = null;
			return;
		}

		// offset by half updateInterval to pseudo "round up"
		final var hoveredTick = unmapX(mx);
		final var x = mx + XP_TOOLTIP_LPAD;

		setColor(CURSOR_MARKER_COLOR);
		drawVMarker(mx);

		var closestY = Integer.MIN_VALUE;
		var closestXp = 0;
		Skill closestSkill = null;

		for (var skill : skillXpHistories.keySet())
		{
			final var history = skillXpHistories.get(skill);

			var closestDist = Integer.MAX_VALUE;
			Point closest = null;
			for (var dataPoint : history)
			{
				final var dist = Math.abs(dataPoint.x - hoveredTick);
				if (dist < closestDist)
				{
					closestDist = dist;
					closest = dataPoint;
				}
			}

			if (closest != null && closest.y != 0)
			{
				final var y = mapY(closest.y, true);
				if (Math.abs(y - mouse.y) < Math.abs(closestY - mouse.y))
				{
					closestY = y;
					closestXp = closest.y;
					closestSkill = skill;
				}

				if (!showAllHovers)
				{
					continue;
				}

				final var label = skill.getName() + ": " + format(closest.y) + "/hr";

				drawThemedTooltip(theme, x, y, label, getSkillColor(skill));
			}
		}

		hoveredSkill = closestSkill;

		if (!showAllHovers && closestSkill != null)
		{
			final var label = closestSkill.getName() + ": " + format(closestXp) + "/hr";

			drawThemedTooltip(theme, x, closestY, label, getSkillColor(closestSkill));
		}
	}

	@Override
	public Rectangle getBounds()
	{
		final var size = getPreferredSize();
		if (size == null)
		{
			// default size
			return new Rectangle(
				XPMeterOverlay.DEFAULT_WIDTH,
				chartHeight
			);
		}

		return new Rectangle(
			Math.max(size.width, MIN_WIDTH),
			Math.max(size.height, chartHeight)
		);
	}

	@Override
	protected int calculateLeftMargin()
	{
		var xpLabelWidth = 0;
		if (showXpLabels)
		{
			for (var xp : Intervals.getXpIntervals(maxXpPerHour))
			{
				final var width = width(shortFormat(xp)) + XP_LABEL_RPAD;
				if (width > xpLabelWidth)
				{
					xpLabelWidth = width;
				}
			}
		}

		// width of half "00:00" or "0:00:00"
		// (using actual origin time would cause the entire chart
		// to jiggle)
		final var originTimeWidth = showTimeLabels
			? width(ticksToTime(currentTick > 6000 ? 6000 : 0)) / 2
			: 0;

		return Math.max(xpLabelWidth, originTimeWidth);
	}

	@Override
	protected int calculateTopMargin()
	{
		// should not need a margin - chart will already be a little
		// taller than any graphics
		return 0;
	}

	@Override
	protected int calculateRightMargin()
	{
		// width of the largest current rate
		var currentRateWidth = 0;
		if (showCurrentRates || showSkillIcons)
		{
			for (var rates : skillXpHistories.values())
			{
				final var last = rates.get(rates.size() - 1);
				if (last == null)
				{
					continue;
				}

				final var text = format(last.y);
				var width = 0;

				if (showCurrentRates)
				{
					width += width(text) + theme.ratePadding * 2 + theme.rateMargin * 2;
				}

				if (showSkillIcons)
				{
					width += SKILL_ICON_WIDTH + theme.rateMargin;
				}

				if (width > currentRateWidth)
				{
					currentRateWidth = width;
				}
			}
		}

		// width of half current time
		final var currentTimeWidth = showTimeLabels
			? width(ticksToTime(currentTick)) / 2
			: 0;

		return Math.max(currentRateWidth, currentTimeWidth);
	}

	@Override
	protected int calculateBottomMargin()
	{
		return (showTimeLabels ? fontHeight : 0) + (showPerformance ? fontHeight + TIME_LABEL_TPAD : 0);
	}

	private Color getSkillColor(Skill skill)
	{
		final var color = SkillColor.get(skill);
		if (dimNonHoveredSkills && hoveredSkill != null && skill != hoveredSkill)
		{
			return Color.DARK_GRAY;
		}

		return color;
	}

	private String format(int number)
	{
		return longFormatNumbers ? Util.format(number) : Util.shortFormat(number);
	}
}

package com.toofifty.xpmeter;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;

/**
 * Generic base methods for drawing the XPChart and handling layout
 */
public abstract class XPChartBase implements LayoutableRenderableEntity
{
	@Getter @Setter
	private Dimension preferredSize;

	@Getter @Setter
	private Point preferredLocation;

	protected Graphics2D graphics;
	protected FontMetrics fontMetrics;
	protected int fontHeight;
	protected Rectangle size;
	protected Point offset;

	@Setter protected int heightScale;
	@Setter protected int widthMax;
	@Setter protected int widthMin;

	@Override
	public Dimension render(Graphics2D g)
	{
		graphics = g;
		fontMetrics = g.getFontMetrics();
		fontHeight = fontMetrics.getHeight();

		final var marginLeft = calculateLeftMargin();
		final var marginRight = calculateRightMargin();
		final var marginTop = calculateTopMargin();
		final var marginBottom = calculateBottomMargin();

		size = getBounds();
		final var loc = getPreferredLocation();
		offset = new Point(loc.x + marginLeft, loc.y + marginTop);

		return new Dimension(
			marginLeft + size.width + marginRight,
			marginTop + size.height + marginBottom
		);
	}

	protected void setColor(Color color)
	{
		graphics.setColor(color);
	}

	protected void drawText(String text, int x, int y, boolean shadow)
	{
		if (shadow)
		{
			final var color = graphics.getColor();
			graphics.setColor(Color.BLACK);
			graphics.drawString(text, offset.x + x + 1, offset.y + y + 1);
			graphics.setColor(color);
		}

		graphics.drawString(text, offset.x + x, offset.y + y);
	}

	protected void drawText(String text, int x, int y)
	{
		drawText(text, x, y, false);
	}

	protected void drawLine(int x1, int y1, int x2, int y2, boolean shadow)
	{
		if (shadow)
		{
			final var color = graphics.getColor();
			graphics.setColor(Color.BLACK);
			graphics.drawLine(
				offset.x + x1 + 1, offset.y + y1 + 1,
				offset.x + x2 + 1, offset.y + y2 + 1
			);
			graphics.setColor(color);
		}

		graphics.drawLine(
			offset.x + x1, offset.y + y1,
			offset.x + x2, offset.y + y2
		);
	}

	protected void drawLine(int x1, int y1, int x2, int y2)
	{
		drawLine(x1, y1, x2, y2, false);
	}

	protected void drawRect(int x, int y, int w, int h)
	{
		graphics.drawRect(offset.x + x, offset.y + y, w, h);
	}

	protected void drawRoundRect(int x, int y, int w, int h, int arc)
	{
		graphics.drawRoundRect(offset.x + x, offset.y + y, w, h, arc, arc);
	}

	protected void fillRect(int x, int y, int w, int h)
	{
		graphics.fillRect(offset.x + x, offset.y + y, w, h);
	}

	protected void fillRoundRect(int x, int y, int w, int h, int arc)
	{
		graphics.fillRoundRect(offset.x + x, offset.y + y, w, h, arc, arc);
	}

	protected void drawVMarker(int x)
	{
		drawLine(x, 0, x, size.height);
	}

	protected void drawHMarker(int y)
	{
		drawLine(0, y, size.width, y);
	}

	protected void drawImage(BufferedImage image, int x, int y)
	{
		graphics.drawImage(image, offset.x + x, offset.y + y, null);
	}

	protected void drawThemedTooltip(Theme theme, int x, int y, String label, Color skillColor)
	{
		if (theme.tooltipBorder != null)
		{
			setColor(theme.tooltipBackground);
			// extra height to avoid clipping gs and ys
			fillRect(x - 1, y - fontHeight / 2 - 1, width(label) + 2, fontHeight + 3);
			setColor(theme.tooltipBorder);
			drawRect(x - 1, y - fontHeight / 2 - 1, width(label) + 2, fontHeight + 3);
			setColor(theme.tooltipTextColor);
		}
		else
		{
			setColor(theme.tooltipBackground);
			fillRoundRect(x - 1, y - fontHeight / 2 - 1, width(label) + 2, fontHeight + 2, 2);
			setColor(skillColor);
		}

		drawText(label, x, y + fontHeight / 2, theme.tooltipTextShadow);
	}

	/**
	 * Map an absolute X coordinate (i.e. tick number) to a
	 * relative X coordinate in the chart
	 */
	protected int mapX(int x)
	{
		return (x - widthMin) * size.width / (widthMax - widthMin);
	}

	protected int unmapX(int x)
	{
		return x * (widthMax - widthMin) / size.width + widthMin;
	}

	/**
	 * Map a Y coordinate (i.e. xp rate) to a Y
	 * coordinate in the chart.
	 * Y coordinates are flipped here, as the rendering
	 * Y plane is upside down.
	 * Using topMargin will re-scale the value so there's
	 * an empty space of 1/2 fontHeight at the top.
	 */
	protected int mapY(int y, boolean topMargin)
	{
		var height = size.height;
		var yOffset = 0;

		if (topMargin)
		{
			height -= fontHeight / 2;
			yOffset += fontHeight / 2;
		}

		return yOffset + height - y * height / heightScale;
	}

	protected int width(String text)
	{
		return fontMetrics.stringWidth(text);
	}

	abstract int calculateLeftMargin();

	abstract int calculateTopMargin();

	abstract int calculateRightMargin();

	abstract int calculateBottomMargin();
}

package com.toofifty.xpmeter;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(XPMeterConfig.GROUP_NAME)
public interface XPMeterConfig extends Config
{
	String GROUP_NAME = "xp-meter";

	@ConfigSection(
		name = "Tracking",
		description = "XP tracking settings",
		position = 1
	)
	String tracking = "tracking";

	@ConfigItem(
		name = "Tracking mode",
		keyName = "trackingMode",
		description = "Method of calculating XP/hr",
		position = 1,
		section = tracking
	)
	default TrackingMode trackingMode()
	{
		return TrackingMode.SLIDING_WINDOW;
	}

	@ConfigItem(
		name = "Sliding window",
		keyName = "windowInterval",
		description = "Calculate XP/hr data points based on XP gain in the last X seconds",
		position = 2,
		section = tracking
	)
	@Units(Units.SECONDS)
	@Range(min = 1)
	default int windowInterval()
	{
		return 60;
	}

	@ConfigItem(
		name = "Resolution",
		keyName = "resolution",
		description = "How frequently the plot updates",
		position = 3,
		section = tracking
	)
	@Units(Units.SECONDS)
	@Range(min = 1)
	default int resolution()
	{
		return 5;
	}

	@ConfigSection(
		name = "Skills",
		description = "Skill filtering",
		position = 2,
		closedByDefault = true
	)
	String skills = "skills";

	@ConfigItem(
		name = "Attack",
		keyName = "trackAttack",
		description = "Track Attack",
		position = 1,
		section = skills
	)
	default boolean trackAttack()
	{
		return true;
	}

	@ConfigItem(
		name = "Defence",
		keyName = "trackDefence",
		description = "Track Defence",
		position = 2,
		section = skills
	)
	default boolean trackDefence()
	{
		return true;
	}

	@ConfigItem(
		name = "Strength",
		keyName = "trackStrength",
		description = "Track Strength",
		position = 3,
		section = skills
	)
	default boolean trackStrength()
	{
		return true;
	}

	@ConfigItem(
		name = "Hitpoints",
		keyName = "trackHitpoints",
		description = "Track Hitpoints",
		position = 4,
		section = skills
	)
	default boolean trackHitpoints()
	{
		return true;
	}

	@ConfigItem(
		name = "Ranged",
		keyName = "trackRanged",
		description = "Track Ranged",
		position = 5,
		section = skills
	)
	default boolean trackRanged()
	{
		return true;
	}

	@ConfigItem(
		name = "Prayer",
		keyName = "trackPrayer",
		description = "Track Prayer",
		position = 6,
		section = skills
	)
	default boolean trackPrayer()
	{
		return true;
	}

	@ConfigItem(
		name = "Magic",
		keyName = "trackMagic",
		description = "Track Magic",
		position = 7,
		section = skills
	)
	default boolean trackMagic()
	{
		return true;
	}

	@ConfigItem(
		name = "Cooking",
		keyName = "trackCooking",
		description = "Track Cooking",
		position = 8,
		section = skills
	)
	default boolean trackCooking()
	{
		return true;
	}

	@ConfigItem(
		name = "Woodcutting",
		keyName = "trackWoodcutting",
		description = "Track Woodcutting",
		position = 9,
		section = skills
	)
	default boolean trackWoodcutting()
	{
		return true;
	}

	@ConfigItem(
		name = "Fletching",
		keyName = "trackFletching",
		description = "Track Fletching",
		position = 10,
		section = skills
	)
	default boolean trackFletching()
	{
		return true;
	}

	@ConfigItem(
		name = "Fishing",
		keyName = "trackFishing",
		description = "Track Fishing",
		position = 11,
		section = skills
	)
	default boolean trackFishing()
	{
		return true;
	}

	@ConfigItem(
		name = "Firemaking",
		keyName = "trackFiremaking",
		description = "Track Firemaking",
		position = 12,
		section = skills
	)
	default boolean trackFiremaking()
	{
		return true;
	}

	@ConfigItem(
		name = "Crafting",
		keyName = "trackCrafting",
		description = "Track Crafting",
		position = 13,
		section = skills
	)
	default boolean trackCrafting()
	{
		return true;
	}

	@ConfigItem(
		name = "Smithing",
		keyName = "trackSmithing",
		description = "Track Smithing",
		position = 14,
		section = skills
	)
	default boolean trackSmithing()
	{
		return true;
	}

	@ConfigItem(
		name = "Mining",
		keyName = "trackMining",
		description = "Track Mining",
		position = 15,
		section = skills
	)
	default boolean trackMining()
	{
		return true;
	}

	@ConfigItem(
		name = "Herblore",
		keyName = "trackHerblore",
		description = "Track Herblore",
		position = 16,
		section = skills
	)
	default boolean trackHerblore()
	{
		return true;
	}

	@ConfigItem(
		name = "Agility",
		keyName = "trackAgility",
		description = "Track Agility",
		position = 17,
		section = skills
	)
	default boolean trackAgility()
	{
		return true;
	}

	@ConfigItem(
		name = "Thieving",
		keyName = "trackThieving",
		description = "Track Thieving",
		position = 18,
		section = skills
	)
	default boolean trackThieving()
	{
		return true;
	}

	@ConfigItem(
		name = "Slayer",
		keyName = "trackSlayer",
		description = "Track Slayer",
		position = 19,
		section = skills
	)
	default boolean trackSlayer()
	{
		return true;
	}

	@ConfigItem(
		name = "Farming",
		keyName = "trackFarming",
		description = "Track Farming",
		position = 20,
		section = skills
	)
	default boolean trackFarming()
	{
		return true;
	}

	@ConfigItem(
		name = "Runecraft",
		keyName = "trackRunecraft",
		description = "Track Runecraft",
		position = 21,
		section = skills
	)
	default boolean trackRunecraft()
	{
		return true;
	}

	@ConfigItem(
		name = "Hunter",
		keyName = "trackHunter",
		description = "Track Hunter",
		position = 22,
		section = skills
	)
	default boolean trackHunter()
	{
		return true;
	}

	@ConfigItem(
		name = "Construction",
		keyName = "trackConstruction",
		description = "Track Construction",
		position = 23,
		section = skills
	)
	default boolean trackConstruction()
	{
		return true;
	}

	@ConfigItem(
			name = "Sailing",
			keyName = "trackSailing",
			description = "Track Sailing",
			position = 24,
			section = skills
	)
	default boolean trackSailing()
	{
		return true;
	}

	@ConfigSection(
		name = "Display",
		description = "Display settings",
		position = 3
	)
	String display = "display";

	@ConfigItem(
		name = "Span",
		keyName = "span",
		description = "Show the last X seconds in the chart",
		position = 1,
		section = display
	)
	@Units(Units.SECONDS)
	@Range(min = 10)
	default int span()
	{
		return 180;
	}

	@ConfigItem(
		name = "Chart height",
		keyName = "chartHeight",
		description = "Adjust chart height",
		position = 2,
		section = display
	)
	@Range(min = 10,
		   max = 200)
	default int chartHeight()
	{
		return 60;
	}

	@ConfigItem(
		name = "Time labels",
		keyName = "showTimeLabels",
		description = "Show time labels on the X axis",
		section = display,
		position = 3
	)
	default boolean showTimeLabels()
	{
		return true;
	}

	@ConfigItem(
		name = "Time markers",
		keyName = "showTimeMarkers",
		description = "Show vertical time marker lines in the chart",
		section = display,
		position = 4
	)
	default boolean showTimeMarkers()
	{
		return true;
	}

	@ConfigItem(
		name = "XP labels",
		keyName = "showXpLabels",
		description = "Show XP labels on the Y axis",
		section = display,
		position = 5
	)
	default boolean showXpLabels()
	{
		return true;
	}

	@ConfigItem(
		name = "XP markers",
		keyName = "showXpMarkers",
		description = "Show horizontal XP marker lines in the chart",
		section = display,
		position = 6
	)
	default boolean showXpMarkers()
	{
		return true;
	}

	@ConfigItem(
		name = "Display current rates",
		keyName = "showCurrentRates",
		description = "Show current XP rates at the end of each line",
		section = display,
		position = 7
	)
	default boolean showCurrentRates()
	{
		return true;
	}

	@ConfigItem(
		name = "Stack rates",
		keyName = "stackCurrentRates",
		description = "Prevent rates from overlapping",
		section = display,
		position = 8
	)
	default boolean stackCurrentRates()
	{
		return false;
	}

	@ConfigItem(
		name = "Display skill icons",
		keyName = "showSkillIcons",
		description = "Show mini skill icons at the end of each line",
		section = display,
		position = 9
	)
	default boolean showSkillIcons()
	{
		return false;
	}

	@ConfigItem(
		name = "Long format numbers",
		keyName = "longFormatNumbers",
		description = "Show all rates in a longer format. e.g. 69,420 instead of 69K, or 1,200K instead of 1M",
		section = display,
		position = 10
	)
	default boolean longFormatNumbers()
	{
		return false;
	}

	@ConfigItem(
		name = "Theme",
		keyName = "theme",
		description = "Change the appearance of the overlay",
		section = display,
		position = 11
	)
	default Theme theme()
	{
		return Theme.RUNELITE;
	}

	@ConfigSection(
		name = "Interactivity",
		description = "Interactivity settings",
		position = 4
	)
	String interactivity = "interactivity";

	@ConfigItem(
		name = "Hover effects",
		keyName = "showHoverTooltips",
		description = "Show momentary XP rates when hovering over the chart",
		section = interactivity,
		position = 1
	)
	default boolean showHoverTooltips()
	{
		return true;
	}

	@ConfigItem(
		name = "Dim non-hovered skills",
		keyName = "dimNonHoveredSkills",
		description = "Dim other skills when hovering to make it easier to see the target skill's plot",
		section = interactivity,
		position = 2
	)
	default boolean dimNonHoveredSkills()
	{
		return false;
	}

	@ConfigItem(
		name = "Display all tooltips",
		keyName = "showAllHovers",
		description = "Toggle between showing 1 or all skills when hovering over the chart",
		section = interactivity,
		position = 3
	)
	default boolean showAllHovers()
	{
		return true;
	}

	@ConfigItem(
		name = "Scroll to zoom",
		keyName = "scrollZoom",
		description = "Hold Shift + scroll over the overlay to adjust the display span",
		section = interactivity,
		position = 4
	)
	default boolean scrollZoom()
	{
		return false;
	}

	@ConfigSection(
		name = "Debugging",
		description = "Developer tools for debugging",
		position = 99,
		closedByDefault = true
	)
	String debugging = "debugging";

	@ConfigItem(
		name = "Show performance",
		keyName = "showPerformance",
		description = "Show debugging performance metrics like compute time / cache info",
		section = debugging,
		position = 1
	)
	default boolean showPerformance()
	{
		return false;
	}

	@ConfigItem(
		name = "Disable cache",
		keyName = "disableCache",
		description = "Disables caching computed values. Disabling this can have a large performance impact.",
		section = debugging,
		position = 2
	)
	default boolean disableCache()
	{
		return false;
	}

	@ConfigItem(
		name = "Disable dynamic resolution",
		keyName = "disableDynamicResolution",
		description = "Disables resolution dynamically scaling to the width of the chart.",
		section = debugging,
		position = 3
	)
	default boolean disableDynamicResolution()
	{
		return false;
	}

	@ConfigItem(
		name = "Enable data import/export",
		keyName = "enableDataMenuOptions",
		description = "Enables data import and export tool options when shift + right-clicking the overlay",
		section = debugging,
		position = 4
	)
	default boolean enableDataMenuOptions()
	{
		return false;
	}

	@ConfigItem(
		name = "Session data",
		keyName = "sessionData",
		description = "Result of the last data export",
		section = debugging,
		position = 5
	)
	default String sessionData()
	{
		return "";
	}
}

package com.toofifty.xpmeter;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;

@Singleton
public class XPMeterOverlay extends OverlayPanel
{
	public static final int DEFAULT_WIDTH = 180;
	public static final int DEFAULT_HEIGHT = 60;

	@Inject private XPTracker tracker;
	@Inject private Client client;

	@Getter private final XPChart chart = new XPChart();
	@Getter private boolean isMouseOver = false;

	@Inject
	private XPMeterOverlay(SkillIconManager skillIconManager, XPMeterConfig config)
	{
		if (getPreferredSize() == null)
		{
			setPreferredSize(new Dimension(DEFAULT_WIDTH, DEFAULT_HEIGHT));
		}

		setPosition(OverlayPosition.TOP_LEFT);
		setMinimumSize(XPChart.MIN_WIDTH);
		setResettable(true);

		chart.setSkillIconManager(skillIconManager);

		addMenuEntry(
			MenuAction.RUNELITE_OVERLAY,
			"Reset",
			"XP Meter",
			e -> tracker.reset()
		);

		updateMenuEntries(config.enableDataMenuOptions());
	}

	public void updateMenuEntries(boolean enableDataMenuOptions)
	{
		removeMenuEntry(MenuAction.RUNELITE_OVERLAY, "Pause", "XP Meter");
		removeMenuEntry(MenuAction.RUNELITE_OVERLAY, "Unpause", "XP Meter");

		addMenuEntry(
			MenuAction.RUNELITE_OVERLAY,
			// tracker will be null on first call
			tracker != null && tracker.isPaused() ? "Unpause" : "Pause",
			"XP Meter",
			e -> {
				if (tracker.isPaused())
				{
					tracker.unpause();
				}
				else
				{
					tracker.pause();
				}

				updateMenuEntries(enableDataMenuOptions);
			}
		);

		removeMenuEntry(MenuAction.RUNELITE_OVERLAY, "Export data", "XP Meter");
		removeMenuEntry(MenuAction.RUNELITE_OVERLAY, "Restore data", "XP Meter");

		if (enableDataMenuOptions)
		{
			addMenuEntry(MenuAction.RUNELITE_OVERLAY, "Export data", "XP Meter");
			addMenuEntry(MenuAction.RUNELITE_OVERLAY, "Restore data", "XP Meter");
		}
	}

	public void setBackgroundColor(Color color)
	{
		setPreferredColor(color);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (chart.hasData())
		{
			panelComponent.getChildren().add(chart);
		}
		else
		{
			panelComponent.getChildren().add(
				LineComponent.builder()
					.left("XP Meter inactive")
					.build()
			);
		}

		// onMouseOver() is called each frame immediately after render,
		// so we can flick off the value for it to be re-set immediately
		// (if mouse is hovering)
		isMouseOver = false;

		return super.render(graphics);
	}

	@Override
	public void onMouseOver()
	{
		isMouseOver = true;

		final var bounds = getBounds();
		final var canvas = client.getMouseCanvasPosition();
		final var mouse = new Point(
			canvas.getX() - bounds.x,
			canvas.getY() - bounds.y
		);

		chart.setMouse(mouse);
	}
}

package com.toofifty.xpmeter;

import com.google.inject.Inject;
import com.google.inject.Provides;
import static com.toofifty.xpmeter.Util.secondsToTicks;
import java.util.HashSet;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.KeyCode;
import net.runelite.api.Skill;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.api.events.StatChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.OverlayMenuClicked;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
	name = "XP Meter",
	description = "Interactive XP/h Meter"
)
public class XPMeterPlugin extends Plugin
{
	@Inject private Client client;
	@Inject private OverlayManager overlayManager;
	@Inject private ConfigManager configManager;
	@Inject private RuneLiteConfig runeLiteConfig;

	@Inject private XPMeterConfig config;
	@Inject private XPTracker tracker;
	@Inject private XPMeterOverlay overlay;

	@Override
	protected void startUp()
	{
		overlayManager.add(overlay);
		syncConfig(null);
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(overlay);
	}

	@Subscribe
	public void onStatChanged(StatChanged event)
	{
		tracker.track(event.getSkill(), event.getXp());
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		if (tracker.isPaused())
		{
			return;
		}

		tracker.tick();
		// only update histories every Nth tick, otherwise the plotted
		// lines start to wobble (as the current tick changes, it calculates each
		// history point off-phase which means the values are different every tick)
		if (tracker.getCurrentTick() % secondsToTicks(config.resolution()) == 0)
		{
			update();
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() != GameState.LOGGED_IN
			&& event.getGameState() != GameState.LOADING
			&& tracker.isTracking())
		{
			tracker.trackLogout();
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals(XPMeterConfig.GROUP_NAME))
		{
			syncConfig(event.getKey());

			if (event.getKey().equals("enableDataMenuOptions"))
			{
				overlay.updateMenuEntries(config.enableDataMenuOptions());
			}
		}

		// listen to changes in runelite config's overlay color,
		// since setting the overlay color to "null" causes it to
		// become out of sync with the runelite setting
		if (event.getGroup().equals(RuneLiteConfig.GROUP_NAME)
			&& event.getKey().equals("overlayBackgroundColor"))
		{
			syncConfig(null);
		}
	}

	@Subscribe
	public void onOverlayMenuClicked(OverlayMenuClicked event)
	{
		if (event.getOverlay() == overlay)
		{
			if (event.getEntry().getOption().equals("Export data"))
			{
				configManager.setConfiguration(
					XPMeterConfig.GROUP_NAME,
					"sessionData",
					tracker.export()
				);
			}
			else if (event.getEntry().getOption().equals("Restore data"))
			{
				tracker.restore(config.sessionData());
			}
		}
	}

	@Subscribe
	public void onScriptCallbackEvent(ScriptCallbackEvent event)
	{
		if (!config.scrollZoom())
		{
			return;
		}

		if ("scrollWheelZoomIncrement".equals(event.getEventName())
			&& overlay.isMouseOver()
			&& client.isKeyPressed(KeyCode.KC_SHIFT))
		{
			final var intStack = client.getIntStack();

			updateScroll(intStack[1]);

			// this stops the client scroll - don't ask how
			intStack[2] = -intStack[1];
		}
	}

	/**
	 * Push config values into overlay, so they aren't
	 * read every frame
	 */
	private void syncConfig(String changedKey)
	{
		final var chart = overlay.getChart();

		chart.setSpan(secondsToTicks(config.span()));
		chart.setChartHeight(config.chartHeight());
		chart.setShowTimeLabels(config.showTimeLabels());
		chart.setShowTimeMarkers(config.showTimeMarkers());
		chart.setShowXpLabels(config.showXpLabels());
		chart.setShowXpMarkers(config.showXpMarkers());
		chart.setShowCurrentRates(config.showCurrentRates());
		chart.setStackCurrentRates(config.stackCurrentRates());
		chart.setShowSkillIcons(config.showSkillIcons());
		chart.setLongFormatNumbers(config.longFormatNumbers());
		chart.setShowPerformance(config.showPerformance());
		chart.setShowHoverTooltips(config.showHoverTooltips());
		chart.setDimNonHoveredSkills(config.dimNonHoveredSkills());
		chart.setShowAllHovers(config.showAllHovers());

		overlay.setBackgroundColor(
			config.theme().overlayBackground != null
				? config.theme().overlayBackground
				: runeLiteConfig.overlayBackgroundColor()
		);
		chart.setTheme(config.theme());

		if ("windowInterval".equals(changedKey)
			|| "trackingMode".equals(changedKey))
		{
			tracker.clearCache();
		}

		if (changedKey == null || changedKey.startsWith("track"))
		{
			final var enabledSkills = new HashSet<Skill>();
			for (var skill : Skill.values())
			{
				final var enabled = configManager.<Boolean>getConfiguration(
					XPMeterConfig.GROUP_NAME,
					"track" + skill.getName(),
					boolean.class
				);
				if (enabled)
				{
					enabledSkills.add(skill);
				}
			}
			tracker.setEnabledSkills(enabledSkills);

			if (changedKey != null)
			{
				// immediately show changes in skill filtering in
				// the chart
				update();
			}
		}

		if ("span".equals(changedKey))
		{
			// stops line segments overflowing the chart
			// before the next update tick
			update();
		}
	}

	private void update()
	{
		final var chart = overlay.getChart();

		chart.setSkillXpHistories(tracker.getAggregate(chart.getBounds().width));
		chart.setSortedSkills(tracker.getSortedSkills());
		chart.setMaxXpPerHour(tracker.getMaxXpPerHour());
		chart.setCurrentTick(tracker.getCurrentTick());
		chart.setPauses(tracker.getPauses());
		chart.setLogouts(tracker.getLogouts());
		chart.setPerformance(tracker.getPerformance());
	}

	private void updateScroll(int dir)
	{
		final var span = (int) (config.span() * Math.pow(1.2, dir));

		configManager.setConfiguration(
			XPMeterConfig.GROUP_NAME,
			"span",
			Math.max(span, 10)
		);
	}

	@Provides
	public XPMeterConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(XPMeterConfig.class);
	}
}

package com.toofifty.xpmeter;

import com.google.gson.Gson;
import com.google.gson.JsonParser;
import com.google.gson.annotations.Expose;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import static com.toofifty.xpmeter.Util.secondsToTicks;
import java.awt.Point;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Skill;

@Slf4j
@Singleton
public class XPTracker
{
	private static final int ONE_MINUTE = 100;
	private static final int ONE_HOUR = 60 * ONE_MINUTE;

	@Inject private XPMeterConfig config;
	@Inject private Gson gson;

	// data
	@Expose private final Map<Skill, List<XPGain>> xpGained = new HashMap<>();
	@Expose private final Map<Skill, Integer> lastXp = new HashMap<>();
	@Expose private final Map<Skill, Integer> startTicks = new HashMap<>();

	@Expose @Getter private int currentTick;
	@Expose @Getter private boolean paused;
	@Expose @Getter private final Set<Integer> pauses = new HashSet<>();
	@Expose @Getter private final Set<Integer> logouts = new HashSet<>();

	// transient
	@Setter private Set<Skill> enabledSkills;

	private final Map<Integer, Integer> cache = new HashMap<>();
	@Getter private List<Skill> sortedSkills;
	@Getter private int maxXpPerHour;

	private int cacheHits = 0;
	private int cacheMisses = 0;

	@Getter private Performance performance;

	public void track(Skill skill, int xp)
	{
		if (paused)
		{
			return;
		}

		if (lastXp.containsKey(skill))
		{
			if (!xpGained.containsKey(skill))
			{
				xpGained.put(skill, new ArrayList<>());
				startTicks.put(skill, currentTick);
			}

			final var diff = xp - lastXp.get(skill);
			if (diff != 0)
			{
				xpGained.get(skill).add(new XPGain(currentTick, diff));
			}
		}

		lastXp.put(skill, xp);
	}

	public boolean isTracking()
	{
		return !lastXp.isEmpty();
	}

	public Set<Skill> getTrackedSkills()
	{
		return xpGained.keySet().stream()
			.filter(skill -> enabledSkills.contains(skill))
			.collect(Collectors.toSet());
	}

	public int getXPPerHourAt(Skill skill, int tick, int windowInterval, TrackingMode trackingMode)
	{
		final var hash = Objects.hash(skill, tick, windowInterval, trackingMode);

		if (!cache.containsKey(hash) || config.disableCache())
		{
			final var xpGains = xpGained.getOrDefault(skill, List.of());
			final var interval = secondsToTicks(windowInterval);
			final var elapsed = tick - startTicks.getOrDefault(skill, 0);

			final var xpGained = xpGains.stream()
				.filter((XPGain xpGain) -> xpGain.tick <= tick && (
					trackingMode == TrackingMode.CUMULATIVE || xpGain.tick > (tick - interval)
				))
				.mapToInt(xpGain -> xpGain.xp)
				.sum();

			if (trackingMode == TrackingMode.CUMULATIVE)
			{
				cache.put(hash, xpGained * ONE_HOUR / Math.max(ONE_MINUTE, elapsed));
			}
			else
			{
				cache.put(hash, xpGained * ONE_HOUR / interval);
			}

			cacheMisses++;
		}
		else
		{
			cacheHits++;
		}

		return cache.get(hash);
	}

	public List<Point> getHistory(Skill skill, int resolution)
	{
		final var history = new ArrayList<Point>();
		final var startTick = Math.max(currentTick - secondsToTicks(config.span()), 0);
		final var windowInterval = config.windowInterval();
		final var trackingMode = config.trackingMode();
		for (int t = startTick; t < currentTick; t += secondsToTicks(resolution))
		{
			history.add(new Point(t, getXPPerHourAt(skill, t, windowInterval, trackingMode)));
		}

		return history;
	}

	public Map<Skill, List<Point>> getAggregate(int maxPixels)
	{
		cacheHits = 0;
		cacheMisses = 0;
		final var start = Instant.now();

		maxXpPerHour = 0;
		final var pixelResolution = config.disableDynamicResolution()
			? 1
			: config.span() / maxPixels;
		final var resolution = Math.max(config.resolution(), pixelResolution);
		final var skillHistories = new HashMap<Skill, List<Point>>();
		final var skillCurrentRates = new HashMap<Skill, Integer>();
		for (var skill : getTrackedSkills())
		{
			final var history = getHistory(skill, resolution);
			skillHistories.put(skill, history);

			final var last = history.get(history.size() - 1);
			skillCurrentRates.put(skill, last == null ? 0 : last.y);

			for (var point : history)
			{
				if (point.y > maxXpPerHour)
				{
					maxXpPerHour = point.y;
				}
			}
		}

		sortedSkills = skillCurrentRates.entrySet().stream()
			.sorted(Comparator.comparingInt(Map.Entry::getValue))
			.map(Map.Entry::getKey)
			.collect(Collectors.toList());

		final var time = Duration.between(start, Instant.now()).toMillis();
		performance = new Performance(time, cache.size(), cacheHits, cacheMisses, resolution);

		return skillHistories;
	}

	public void tick()
	{
		currentTick++;
	}

	public void reset()
	{
		xpGained.clear();
		startTicks.clear();
		cache.clear();
		pauses.clear();
		logouts.clear();
		currentTick = 0;
	}

	public void clearCache()
	{
		cache.clear();
	}

	public void pause()
	{
		paused = true;
		pauses.add(currentTick);
	}

	public void unpause()
	{
		paused = false;
	}

	public void trackLogout()
	{
		logouts.add(currentTick);
	}

	public String export()
	{
		return gson.newBuilder()
			.excludeFieldsWithoutExposeAnnotation()
			.create()
			.toJson(this);
	}

	public void restore(String json)
	{
		reset();
		var data = new JsonParser().parse(json).getAsJsonObject();

		for (var entry : data.get("xpGained").getAsJsonObject().entrySet())
		{
			var jsonGains = entry.getValue().getAsJsonArray();
			var gains = new ArrayList<XPGain>();
			for (var jsonGain : jsonGains)
			{
				var gain = jsonGain.getAsJsonObject();
				gains.add(new XPGain(gain.get("tick").getAsInt(), gain.get("xp").getAsInt()));
			}
			xpGained.put(Skill.valueOf(entry.getKey()), gains);
		}

		for (var entry : data.get("lastXp").getAsJsonObject().entrySet())
		{
			lastXp.put(Skill.valueOf(entry.getKey()), entry.getValue().getAsInt());
		}

		for (var entry : data.get("startTicks").getAsJsonObject().entrySet())
		{
			startTicks.put(Skill.valueOf(entry.getKey()), entry.getValue().getAsInt());
		}

		currentTick = data.get("currentTick").getAsInt();

		paused = data.get("paused").getAsBoolean();

		for (var logout : data.get("pauses").getAsJsonArray())
		{
			pauses.add(logout.getAsInt());
		}

		for (var logout : data.get("logouts").getAsJsonArray())
		{
			logouts.add(logout.getAsInt());
		}
	}

	@AllArgsConstructor
	static class XPGain
	{
		@Expose private int tick;
		@Expose private int xp;
	}

	@Getter
	@AllArgsConstructor
	static class Performance
	{
		private long computeTime;
		private int cacheSize;
		private int cacheHits;
		private int cacheMisses;
		private int renderedResolution;
	}
}

package com.xpmeter;

import com.toofifty.xpmeter.XPMeterPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class XPMeterPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(XPMeterPlugin.class);
		RuneLite.main(args);
	}
}
