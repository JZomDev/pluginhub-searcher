package com.projectilerage.runelite.partyplay;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PartyPlayPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PartyPlayPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * Copyright (c) 2018, PandahRS <https://github.com/PandahRS>
 * Copyright (c) 2020, Brooklyn <https://github.com/Broooklyn>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.projectilerage.runelite.partyplay;

import com.google.common.collect.ImmutableMap;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Skill;

import javax.annotation.Nullable;
import java.util.Map;

/*
Entire file copied from built-in Discord plugin. All credit goes to the creator(s).
*/

@AllArgsConstructor
@Getter
enum GameEventType
{

	IN_MENU("In Menu", -3, true, true, true, false, true),
	IN_GAME("In Game", -3, true, false, false, false, true),
	PLAYING_DEADMAN("Playing Deadman Mode", -3),
	PLAYING_PVP("Playing in a PVP world", -3),
	TRAINING_ATTACK(Skill.ATTACK),
	TRAINING_DEFENCE(Skill.DEFENCE),
	TRAINING_STRENGTH(Skill.STRENGTH),
	TRAINING_HITPOINTS(Skill.HITPOINTS, -1),
	TRAINING_SLAYER(Skill.SLAYER, 1),
	TRAINING_RANGED(Skill.RANGED),
	TRAINING_MAGIC(Skill.MAGIC),
	TRAINING_PRAYER(Skill.PRAYER),
	TRAINING_COOKING(Skill.COOKING),
	TRAINING_WOODCUTTING(Skill.WOODCUTTING),
	TRAINING_FLETCHING(Skill.FLETCHING),
	TRAINING_FISHING(Skill.FISHING, 1),
	TRAINING_FIREMAKING(Skill.FIREMAKING),
	TRAINING_CRAFTING(Skill.CRAFTING),
	TRAINING_SMITHING(Skill.SMITHING),
	TRAINING_MINING(Skill.MINING),
	TRAINING_HERBLORE(Skill.HERBLORE),
	TRAINING_AGILITY(Skill.AGILITY),
	TRAINING_THIEVING(Skill.THIEVING),
	TRAINING_FARMING(Skill.FARMING),
	TRAINING_RUNECRAFT(Skill.RUNECRAFT),
	TRAINING_HUNTER(Skill.HUNTER),
	TRAINING_CONSTRUCTION(Skill.CONSTRUCTION),

	// Bosses
	BOSS_ABYSSAL_SIRE("Abyssal Sire", AreaType.BOSSES, 11851, 11850, 12363, 12362),
	BOSS_CERBERUS("Cerberus", AreaType.BOSSES, 4883, 5140, 5395),
	BOSS_COMMANDER_ZILYANA("Commander Zilyana", AreaType.BOSSES, 11602),
	BOSS_CORP("Corporeal Beast", AreaType.BOSSES, 11842, 11844),
	BOSS_DKS("Dagannoth Kings", AreaType.BOSSES, 11588, 11589),
	BOSS_GENERAL_GRAARDOR("General Graardor", AreaType.BOSSES, 11347),
	BOSS_GIANT_MOLE("Giant Mole", AreaType.BOSSES, 6993, 6992),
	BOSS_GROTESQUE_GUARDIANS("Grotesque Guardians", AreaType.BOSSES, 6727),
	BOSS_HESPORI("Hespori", AreaType.BOSSES, 5021),
	BOSS_HYDRA("Alchemical Hydra", AreaType.BOSSES, 5536),
	BOSS_KQ("Kalphite Queen", AreaType.BOSSES, 13972),
	BOSS_KRAKEN("Kraken", AreaType.BOSSES, 9116),
	BOSS_KREEARRA("Kree'arra", AreaType.BOSSES, 11346),
	BOSS_KRIL_TSUTSAROTH("K'ril Tsutsaroth", AreaType.BOSSES, 11603),
	BOSS_NEX("Nex", AreaType.BOSSES, 11601),
	BOSS_NIGHTMARE("Nightmare of Ashihama", AreaType.BOSSES, 15515),
	BOSS_SARACHNIS("Sarachnis", AreaType.BOSSES, 7322),
	BOSS_SKOTIZO("Skotizo", AreaType.BOSSES, 6810),
	BOSS_SMOKE_DEVIL("Thermonuclear smoke devil", AreaType.BOSSES, 9363, 9619),
	BOSS_TEMPOROSS("Tempoross", AreaType.BOSSES, 12078),
	BOSS_VORKATH("Vorkath", AreaType.BOSSES, 9023),
	BOSS_WINTERTODT("Wintertodt", AreaType.BOSSES, 6462),
	BOSS_ZALCANO("Zalcano", AreaType.BOSSES, 12126),
	BOSS_ZULRAH("Zulrah", AreaType.BOSSES, 9007),

	// Cities
	CITY_AL_KHARID("Al Kharid" , AreaType.CITIES, 13105, 13106),
	CITY_ARCEUUS_HOUSE("Arceuus" , AreaType.CITIES, 6458, 6459, 6460, 6714, 6715),
	CITY_ARDOUGNE("Ardougne" , AreaType.CITIES, 9779, 9780, 10035, 10036, 10291, 10292, 10547, 10548),
	CITY_BANDIT_CAMP("Bandit Camp" , AreaType.CITIES, 12590),
	CITY_BARBARIAN_OUTPOST("Barbarian Outpost", AreaType.CITIES, 10039),
	CITY_BARBARIAN_VILLAGE("Barbarian Village" , AreaType.CITIES, 12341),
	CITY_BEDABIN_CAMP("Bedabin Camp" , AreaType.CITIES, 12591),
	CITY_BRIMHAVEN("Brimhaven" , AreaType.CITIES, 11057, 11058),
	CITY_BURGH_DE_ROTT("Burgh de Rott" , AreaType.CITIES, 13874, 13873, 14130, 14129),
	CITY_BURTHORPE("Burthorpe" , AreaType.CITIES, 11319, 11575),
	CITY_CANIFIS("Canifis" , AreaType.CITIES, 13878),
	CITY_CATHERBY("Catherby" , AreaType.CITIES, 11317, 11318, 11061),
	CITY_CORSAIR_COVE("Corsair Cove" , AreaType.CITIES, 10028, 10284),
	CITY_DARKMEYER("Darkmeyer", AreaType.CITIES, 14388, 14644),
	CITY_DORGESH_KAAN("Dorgesh-Kaan" , AreaType.CITIES, 10835, 10834),
	CITY_DRAYNOR("Draynor" , AreaType.CITIES, 12338, 12339),
	CITY_EDGEVILLE("Edgeville" , AreaType.CITIES, 12342),
	CITY_ENTRANA("Entrana" , AreaType.CITIES, 11060, 11316),
	CITY_ETCETERIA("Etceteria", AreaType.CITIES, 10300),
	CITY_FALADOR("Falador" , AreaType.CITIES, 11828, 11572, 11827, 12084),
	CITY_GUTANOTH("Gu'Tanoth" , AreaType.CITIES, 10031),
	CITY_GWENITH("Gwenith", AreaType.CITIES, 8757),
	CITY_HOSIDIUS_HOUSE("Hosidius" , AreaType.CITIES, 6710, 6711, 6712, 6455, 6456, 6966, 6967, 6968, 7221, 7223, 7224, 7478, 7479),
	CITY_JATIZSO("Jatizso" , AreaType.CITIES, 9531),
	CITY_KELDAGRIM("Keldagrim" , AreaType.CITIES, 11423, 11422, 11679, 11678),
	CITY_LANDS_END("Land's End", AreaType.CITIES, 5941),
	CITY_LLETYA("Lletya" , AreaType.CITIES, 9265, 11103),
	CITY_LOVAKENGJ_HOUSE("Lovakengj" , AreaType.CITIES, 5692, 5691, 5947, 6203, 6202, 5690, 5946),
	CITY_LUMBRIDGE("Lumbridge" , AreaType.CITIES, 12850),
	CITY_LUNAR_ISLE("Lunar Isle" , AreaType.CITIES, 8253, 8252, 8509, 8508),
	CITY_MARIM("Marim", AreaType.REGIONS, 11051),
	CITY_MEIYERDITCH("Meiyerditch" , AreaType.CITIES, 14132, 14387, 14386, 14385),
	CITY_MENAPHOS("Menaphos", AreaType.CITIES, 12843),
	CITY_MISCELLANIA("Miscellania" , AreaType.CITIES, 10044),
	CITY_MOR_UL_REK("Mor Ul Rek" , AreaType.CITIES, 9808, 9807, 10064, 10063),
	CITY_MORTTON("Mort'ton" , AreaType.CITIES, 13875),
	CITY_MOS_LE_HARMLESS("Mos Le'Harmless" , AreaType.CITIES, 14637, 14638, 14639, 14894, 14895, 15151, 15406, 15407),
	CITY_MOUNT_KARUULM("Mount Karuulm", AreaType.CITIES, 5179, 4923, 5180),
	CITY_MOUNTAIN_CAMP("Mountain Camp", AreaType.CITIES, 11065),
	CITY_MYNYDD("Mynydd", AreaType.CITIES, 8501),
	CITY_NARDAH("Nardah" , AreaType.CITIES, 13613),
	CITY_NEITIZNOT("Neitiznot" , AreaType.CITIES, 9275),
	CITY_PISCARILIUS_HOUSE("Port Piscarilius" , AreaType.CITIES, 6969, 6971, 7227, 6970, 7225, 7226),
	CITY_PISCATORIS("Piscatoris" , AreaType.CITIES, 9273),
	CITY_POLLNIVNEACH("Pollnivneach" , AreaType.CITIES, 13358),
	CITY_PORT_KHAZARD("Port Khazard" , AreaType.CITIES, 10545),
	CITY_PORT_PHASMATYS("Port Phasmatys" , AreaType.CITIES, 14646),
	CITY_PORT_SARIM("Port Sarim" , AreaType.CITIES, 12081, 12082),
	CITY_PRIFDDINAS("Prifddinas", AreaType.CITIES, 8499, 8500, 8755, 8756, 9011, 9012, 9013, 12894, 12895, 13150, 13151),
	CITY_RELLEKKA("Rellekka" , AreaType.CITIES, 10297, 10553),
	CITY_RIMMINGTON("Rimmington" , AreaType.CITIES, 11826, 11570),
	CITY_SEERS_VILLAGE("Seers' Village" , AreaType.CITIES, 10806),
	CITY_SHAYZIEN_HOUSE("Shayzien" , AreaType.CITIES, 5944, 5943, 6200, 6199, 5686, 5687, 5688, 5689, 5945),
	CITY_SHILO_VILLAGE("Shilo Village" , AreaType.CITIES, 11310),
	CITY_SLEPE("Slepe", AreaType.CITIES, 14643, 14899, 14900, 14901),
	CITY_SOPHANEM("Sophanem" , AreaType.CITIES, 13099),
	CITY_TAI_BWO_WANNAI("Tai Bwo Wannai" , AreaType.CITIES, 11056, 11055),
	CITY_TAVERLEY("Taverley" , AreaType.CITIES, 11574, 11573),
	CITY_TREE_GNOME_STRONGHOLD("Tree Gnome Stronghold" , AreaType.CITIES, 9525, 9526, 9782, 9781),
	CITY_TREE_GNOME_VILLAGE("Tree Gnome Village" , AreaType.CITIES, 10033),
	CITY_TROLL_STRONGHOLD("Troll Stronghold" , AreaType.CITIES, 11321, 11421),
	CITY_UZER("Uzer" , AreaType.CITIES, 13872),
	CITY_VARROCK("Varrock" , AreaType.CITIES, 12596, 12597, 12852, 12853, 12854, 13108, 13109, 13110),
	CITY_VER_SINHAZA("Ver Sinhaza", AreaType.CITIES, 14642),
	CITY_VOID_OUTPOST("Void Knights' Outpost", AreaType.CITIES, 10537),
	CITY_WEISS("Weiss", AreaType.CITIES, 11325, 11581),
	CITY_WITCHHAVEN("Witchaven" , AreaType.CITIES, 10803),
	CITY_YANILLE("Yanille" , AreaType.CITIES, 10288, 10032),
	CITY_ZANARIS("Zanaris" , AreaType.CITIES, 9285, 9541, 9540, 9797),
	CITY_ZULANDRA("Zul-Andra" , AreaType.CITIES, 8495, 8751),

	// Dungeons
	DUNGEON_ABANDONED_MINE("Abandoned Mine", AreaType.DUNGEONS, 13618, 13718, 11079, 11078, 11077, 10823, 10822, 10821),
	DUNGEON_AH_ZA_RHOON("Ah Za Rhoon", AreaType.DUNGEONS, 11666),
	DUNGEON_ANCIENT_CAVERN("Ancient Cavern", AreaType.DUNGEONS, 6483, 6995),
	DUNGEON_APE_ATOLL("Ape Atoll Dungeon", AreaType.DUNGEONS, 11150, 10894),
	DUNGEON_APE_ATOLL_BANANA_PLANTATION("Ape Atoll Banana Plantation", AreaType.DUNGEONS, 10895),
	DUNGEON_ARDY_BASEMENT("West Ardougne Basement", AreaType.DUNGEONS, 10135),
	DUNGEON_ARDY_SEWERS("Ardougne Sewers", AreaType.DUNGEONS, 10134, 10136, 10391, 10647),
	DUNGEON_ASGARNIAN_ICE_CAVES("Asgarnian Ice Caves", AreaType.DUNGEONS, 11925, 12181),
	DUNGEON_BERVIRIUS_TOMB("Tomb of Bervirius", AreaType.DUNGEONS, 11154),
	DUNGEON_BRIMHAVEN("Brimhaven Dungeon", AreaType.DUNGEONS, 10901, 10900, 10899, 10645, 10644, 10643),
	DUNGEON_BRINE_RAT_CAVERN("Brine Rat Cavern", AreaType.DUNGEONS, 10910),
	DUNGEON_CATACOMBS_OF_KOUREND("Catacombs of Kourend", AreaType.DUNGEONS, 6557, 6556, 6813, 6812),
	DUNGEON_CHAMPIONS_CHALLENGE("Champions' Challenge", AreaType.DUNGEONS, 12696),
	DUNGEON_CHAOS_DRUID_TOWER("Chaos Druid Tower", AreaType.DUNGEONS, 10392),
	DUNGEON_CHASM_OF_FIRE("Chasm of Fire", AreaType.DUNGEONS, 5789),
	DUNGEON_CHASM_OF_TEARS("Chasm of Tears", AreaType.DUNGEONS, 12948),
	DUNGEON_CHINCHOMPA("Chinchompa Hunting Ground", AreaType.DUNGEONS, 10129),
	DUNGEON_CLOCK_TOWER("Clock Tower Basement", AreaType.DUNGEONS, 10390),
	DUNGEON_CORSAIR_COVE("Corsair Cove Dungeon", AreaType.DUNGEONS, 8076, 8332),
	DUNGEON_CRABCLAW_CAVES("Crabclaw Caves", AreaType.DUNGEONS, 6553, 6809),
	DUNGEON_CRANDOR("Crandor Dungeon", AreaType.DUNGEONS, 11414),
	DUNGEON_CRASH_SITE_CAVERN("Crash Site Cavern", AreaType.DUNGEONS, 8280, 8536),
	DUNGEON_CRUMBLING_TOWER("Crumbling Tower", AreaType.DUNGEONS, 7827),
	DUNGEON_DAEYALT_ESSENCE_MINE("Daeyalt Essence Mine", AreaType.DUNGEONS, 14744),
	DUNGEON_DIGSITE("Digsite Dungeon", AreaType.DUNGEONS, 13464, 13465),
	DUNGEON_DORGESHKAAN("Dorgesh-Kaan South Dungeon", AreaType.DUNGEONS, 10833),
	DUNGEON_DORGESHUUN_MINES("Dorgeshuun Mines", AreaType.DUNGEONS, 12950, 13206),
	DUNGEON_DRAYNOR_SEWERS("Draynor Sewers", AreaType.DUNGEONS, 12439, 12438),
	DUNGEON_DWARVEN_MINES("Dwarven Mines", AreaType.DUNGEONS, 12185, 12184, 12183),
	DUNGEON_EAGLES_PEAK("Eagles' Peak Dungeon", AreaType.DUNGEONS, 8013),
	DUNGEON_ECTOFUNTUS("Ectofuntus", AreaType.DUNGEONS, 14746),
	DUNGEON_EDGEVILLE("Edgeville Dungeon", AreaType.DUNGEONS, 12441, 12442, 12443, 12698),
	DUNGEON_ELEMENTAL_WORKSHOP("Elemental Workshop", AreaType.DUNGEONS, 10906, 7760),
	DUNGEON_ELVEN_RABBIT_CAVE("Elven rabbit cave", AreaType.DUNGEONS, 13252),
	DUNGEON_ENAKHRAS_TEMPLE("Enakhra's Temple", AreaType.DUNGEONS, 12423),
	DUNGEON_EVIL_CHICKENS_LAIR("Evil Chicken's Lair", AreaType.DUNGEONS, 9796),
	DUNGEON_EXPERIMENT_CAVE("Experiment Cave", AreaType.DUNGEONS, 14235, 13979),
	DUNGEON_FEROX_ENCLAVE("Ferox Enclave Dungeon", AreaType.DUNGEONS, 12700),
	DUNGEON_FORTHOS("Forthos Dungeon", AreaType.DUNGEONS, 7323),
	DUNGEON_FREMENNIK_SLAYER("Fremennik Slayer Dungeon", AreaType.DUNGEONS, 10907, 10908, 11164),
	DUNGEON_GLARIALS_TOMB("Glarial's Tomb", AreaType.DUNGEONS, 10137),
	DUNGEON_GOBLIN_CAVE("Goblin Cave", AreaType.DUNGEONS, 10393),
	DUNGEON_GRAND_TREE_TUNNELS("Grand Tree Tunnels", AreaType.DUNGEONS, 9882),
	DUNGEON_HAM_HIDEOUT("H.A.M. Hideout", AreaType.DUNGEONS, 12694),
	DUNGEON_HAM_STORE_ROOM("H.A.M. Store room", AreaType.DUNGEONS, 10321),
	DUNGEON_HEROES_GUILD("Heroes' Guild Mine", AreaType.DUNGEONS, 11674),
	DUNGEON_IORWERTH("Iorwerth Dungeon", AreaType.DUNGEONS, 12737, 12738, 12993, 12994),
	DUNGEON_ISLE_OF_SOULS("Isle of Souls Dungeon", AreaType.DUNGEONS, 8593),
	DUNGEON_JATIZSO_MINES("Jatizso Mines", AreaType.DUNGEONS, 9631),
	DUNGEON_JIGGIG_BURIAL_TOMB("Jiggig Burial Tomb", AreaType.DUNGEONS, 9875, 9874),
	DUNGEON_JOGRE("Jogre Dungeon", AreaType.DUNGEONS, 11412),
	DUNGEON_KARAMJA("Karamja Dungeon", AreaType.DUNGEONS, 11413),
	DUNGEON_KARUULM("Karuulm Slayer Dungeon", AreaType.DUNGEONS, 5280, 5279, 5023, 5535, 5022, 4766, 4510, 4511, 4767, 4768, 4512),
	DUNGEON_KGP_HEADQUARTERS("KGP Headquarters", AreaType.DUNGEONS, 10658),
	DUNGEON_KRUK("Kruk's Dungeon", AreaType.DUNGEONS, 9358, 9359, 9360, 9615, 9616, 9871, 10125, 10126, 10127, 10128, 10381, 10382, 10383, 10384, 10637, 10638, 10639, 10640),
	DUNGEON_LEGENDS_GUILD("Legends' Guild Dungeon", AreaType.DUNGEONS, 10904),
	DUNGEON_LIGHTHOUSE("Lighthouse", AreaType.DUNGEONS, 10140),
	DUNGEON_LIZARDMAN_CAVES("Lizardman Caves", AreaType.DUNGEONS, 5275),
	DUNGEON_LIZARDMAN_TEMPLE("Lizardman Temple", AreaType.DUNGEONS, 5277),
	DUNGEON_LUMBRIDGE_SWAMP_CAVES("Lumbridge Swamp Caves", AreaType.DUNGEONS, 12693, 12949),
	DUNGEON_LUNAR_ISLE_MINE("Lunar Isle Mine", AreaType.DUNGEONS, 9377),
	DUNGEON_MANIACAL_HUNTER("Maniacal Monkey Hunter Area", AreaType.DUNGEONS, 11662),
	DUNGEON_MEIYERDITCH_MINE("Meiyerditch Mine", AreaType.DUNGEONS, 9544),
	DUNGEON_MISCELLANIA("Miscellania Dungeon", AreaType.DUNGEONS, 10144, 10400),
	DUNGEON_MOGRE_CAMP("Mogre Camp", AreaType.DUNGEONS, 11924),
	DUNGEON_MOS_LE_HARMLESS_CAVES("Mos Le'Harmless Caves", AreaType.DUNGEONS, 14994, 14995, 15251),
	DUNGEON_MOTHERLODE_MINE("Motherlode Mine", AreaType.DUNGEONS, 14679, 14680, 14681, 14935, 14936, 14937, 15191, 15192, 15193),
	DUNGEON_MOURNER_TUNNELS("Mourner Tunnels", AreaType.DUNGEONS, 7752, 8008),
	DUNGEON_MOUSE_HOLE("Mouse Hole", AreaType.DUNGEONS, 9046),
	DUNGEON_MYREDITCH_LABORATORIES("Myreditch Laboratories", AreaType.DUNGEONS, 14232, 14233, 14487, 14488),
	DUNGEON_MYREQUE("Myreque Hideout", AreaType.DUNGEONS, 13721, 13974, 13977, 13978),
	DUNGEON_MYTHS_GUILD("Myths' Guild Dungeon", AreaType.DUNGEONS, 7564, 7820, 7821),
	DUNGEON_OBSERVATORY("Observatory Dungeon", AreaType.DUNGEONS, 9362),
	DUNGEON_OGRE_ENCLAVE("Ogre Enclave", AreaType.DUNGEONS, 10387),
	DUNGEON_OURANIA("Ourania Cave", AreaType.DUNGEONS, 12119),
	DUNGEON_QUIDAMORTEM_CAVE("Quidamortem Cave", AreaType.DUNGEONS, 4763),
	DUNGEON_RASHILIYIAS_TOMB("Rashiliyta's Tomb", AreaType.DUNGEONS, 11668),
	DUNGEON_RUINS_OF_CAMDOZAAL("Ruins of Camdozaal", AreaType.DUNGEONS, 11609, 11610, 11611, 11865, 11866, 11867, 12121, 12122, 12123),
	DUNGEON_SALT_MINE("Salt Mine", AreaType.DUNGEONS, 11425),
	DUNGEON_SARADOMINSHRINE("Saradomin Shrine (Paterdomus)", AreaType.DUNGEONS, 13722),
	DUNGEON_SHADE_CATACOMBS("Shade Catacombs", AreaType.DUNGEONS, 13975),
	DUNGEON_SHADOW("Shadow Dungeon", AreaType.DUNGEONS, 10575, 10831),
	DUNGEON_SHAYZIEN_CRYPTS("Shayzien Crypts", AreaType.DUNGEONS, 6043),
	DUNGEON_SISTERHOOD_SANCTUARY("Sisterhood Sanctuary", AreaType.DUNGEONS, 14999, 15000, 15001, 15255, 15256, 15257, 15511, 15512, 15513),
	DUNGEON_SMOKE("Smoke Dungeon", AreaType.DUNGEONS, 12946, 13202),
	DUNGEON_SOPHANEM("Sophanem Dungeon", AreaType.DUNGEONS, 13200),
	DUNGEON_SOURHOG_CAVE("Sourhog Cave", AreaType.DUNGEONS, 12695),
	DUNGEON_STRONGHOLD_SECURITY("Stronghold of Security", AreaType.DUNGEONS, 7505, 8017, 8530, 9297),
	DUNGEON_STRONGHOLD_SLAYER("Stronghold Slayer Cave", AreaType.DUNGEONS, 9624, 9625, 9880, 9881),
	DUNGEON_TARNS_LAIR("Tarn's Lair", AreaType.DUNGEONS, 12616, 12615),
	DUNGEON_TAVERLEY("Taverley Dungeon", AreaType.DUNGEONS, 11416, 11417, 11671, 11672, 11673, 11928, 11929),
	DUNGEON_TEMPLE_OF_IKOV("Temple of Ikov", AreaType.DUNGEONS, 10649, 10905, 10650),
	DUNGEON_TEMPLE_OF_LIGHT("Temple of Light", AreaType.DUNGEONS, 7496),
	DUNGEON_TEMPLE_OF_MARIMBO("Temple of Marimbo", AreaType.DUNGEONS, 11151),
	DUNGEON_THE_WARRENS("The Warrens", AreaType.DUNGEONS, 7070, 7326),
	DUNGEON_TOLNA("Dungeon of Tolna", AreaType.DUNGEONS, 13209),
	DUNGEON_TOWER_OF_LIFE("Tower of Life Basement", AreaType.DUNGEONS, 12100),
	DUNGEON_TRAHAEARN_MINE("Trahaearn Mine", AreaType.DUNGEONS, 13250),
	DUNGEON_TUNNEL_OF_CHAOS("Tunnel of Chaos", AreaType.DUNGEONS, 12625),
	DUNGEON_UNDERGROUND_PASS("Underground Pass", AreaType.DUNGEONS, 9369, 9370),
	DUNGEON_VARROCKSEWERS("Varrock Sewers", AreaType.DUNGEONS, 12954, 13210),
	DUNGEON_VIYELDI_CAVES("Viyeldi Caves", AreaType.DUNGEONS, 9545, 11153),
	DUNGEON_WARRIORS_GUILD("Warriors' Guild Basement", AreaType.DUNGEONS, 11675),
	DUNGEON_WATER_RAVINE("Water Ravine", AreaType.DUNGEONS, 13461),
	DUNGEON_WATERBIRTH("Waterbirth Dungeon", AreaType.DUNGEONS, 9886, 10142, 7492, 7748),
	DUNGEON_WATERFALL("Waterfall Dungeon", AreaType.DUNGEONS, 10394),
	DUNGEON_WEREWOLF_AGILITY("Werewolf Agility Course", AreaType.DUNGEONS, 14234),
	DUNGEON_WHITE_WOLF_MOUNTAIN_CAVES("White Wolf Mountain Caves", AreaType.DUNGEONS, 11418, 11419),
	DUNGEON_WITCHAVEN_SHRINE("Witchhaven Shrine Dungeon", AreaType.DUNGEONS, 10903),
	DUNGEON_WIZARDS_TOWER("Wizards' Tower Basement", AreaType.DUNGEONS, 12437),
	DUNGEON_WOODCUTTING_GUILD("Woodcutting Guild Dungeon", AreaType.DUNGEONS, 6298),
	DUNGEON_WYVERN_CAVE("Wyvern Cave", AreaType.DUNGEONS, 14495, 14496),
	DUNGEON_YANILLE_AGILITY("Yanille Agility Dungeon", AreaType.DUNGEONS, 10388),

	// Minigames
	MG_ARDOUGNE_RAT_PITS("Ardougne Rat Pits", AreaType.MINIGAMES, 10646),
	MG_BARBARIAN_ASSAULT("Barbarian Assault", AreaType.MINIGAMES, 7508, 7509, 10322),
	MG_BARROWS("Barrows", AreaType.MINIGAMES, 14131, 14231),
	MG_BLAST_FURNACE("Blast Furnace", AreaType.MINIGAMES, 7757),
	MG_BRIMHAVEN_AGILITY_ARENA("Brimhaven Agility Arena", AreaType.MINIGAMES, 11157),
	MG_BURTHORPE_GAMES_ROOM("Burthorpe Games Room", AreaType.MINIGAMES, 8781),
	MG_CASTLE_WARS("Castle Wars", AreaType.MINIGAMES, 9520, 9620),
	MG_CLAN_WARS("Clan Wars", AreaType.MINIGAMES, 12621, 12622, 12623, 13130, 13131, 13133, 13134, 13135, 13386, 13387, 13390, 13641, 13642, 13643, 13644, 13645, 13646, 13647, 13899, 13900, 14155, 14156),
	MG_DUEL_ARENA("Duel Arena", AreaType.MINIGAMES, 13362, 13363),
	MG_FISHING_TRAWLER("Fishing Trawler", AreaType.MINIGAMES, 7499),
	MG_GAUNTLET("The Gauntlet", AreaType.MINIGAMES, 12127, 7512),
	MG_CORRUPTED_GAUNTLET("Corrupted Gauntlet", AreaType.MINIGAMES, 7768),
	MG_HALLOWED_SEPULCHRE("Hallowed Sepulchre", AreaType.MINIGAMES, 8797, 9051, 9052, 9053, 9054, 9309, 9563, 9565, 9821, 10074, 10075, 10077),
	MG_INFERNO("The Inferno", AreaType.MINIGAMES, 9043),
	MG_KELDAGRIM_RAT_PITS("Keldagrim Rat Pits", AreaType.MINIGAMES, 7753),
	MG_LAST_MAN_STANDING_DESERTED_ISLAND("LMS - Deserted Island", AreaType.MINIGAMES, 13658, 13659, 13660, 13914, 13915, 13916),
	MG_LAST_MAN_STANDING_WILD_VARROCK("LMS - Wild Varrock", AreaType.MINIGAMES, 13918, 13919, 13920, 14174, 14175, 14176, 14430, 14431, 14432),
	MG_MAGE_TRAINING_ARENA("Mage Training Arena", AreaType.MINIGAMES, 13462, 13463),
	MG_NIGHTMARE_ZONE("Nightmare Zone", AreaType.MINIGAMES, 9033),
	MG_PEST_CONTROL("Pest Control", AreaType.MINIGAMES, 10536),
	MG_PORT_SARIM_RAT_PITS("Port Sarim Rat Pits", AreaType.MINIGAMES, 11926),
	MG_PYRAMID_PLUNDER("Pyramid Plunder", AreaType.MINIGAMES, 7749),
	MG_ROGUES_DEN("Rogues' Den", AreaType.MINIGAMES, 11854, 11855, 12109, 12110, 12111),
	MG_SORCERESS_GARDEN("Sorceress's Garden", AreaType.MINIGAMES, 11605),
	MG_SOUL_WARS("Soul Wars", AreaType.MINIGAMES, 8493, 8748, 8749, 9005),
	MG_TEMPLE_TREKKING("Temple Trekking", AreaType.MINIGAMES, 8014, 8270, 8256, 8782, 9038, 9294, 9550, 9806),
	MG_TITHE_FARM("Tithe Farm", AreaType.MINIGAMES, 7222),
	MG_TROUBLE_BREWING("Trouble Brewing", AreaType.MINIGAMES, 15150),
	MG_TZHAAR_FIGHT_CAVES("Tzhaar Fight Caves", AreaType.MINIGAMES, 9551),
	MG_TZHAAR_FIGHT_PITS("Tzhaar Fight Pits", AreaType.MINIGAMES, 9552),
	MG_VARROCK_RAT_PITS("Varrock Rat Pits", AreaType.MINIGAMES, 11599),
	MG_VOLCANIC_MINE("Volcanic Mine", AreaType.MINIGAMES, 15263, 15262),

	// Raids
	RAIDS_CHAMBERS_OF_XERIC("Chambers of Xeric", AreaType.RAIDS, 12889, 13136, 13137, 13138, 13139, 13140, 13141, 13145, 13393, 13394, 13395, 13396, 13397, 13401),
	RAIDS_THEATRE_OF_BLOOD("Theatre of Blood", AreaType.RAIDS, 12611, 12612, 12613, 12867, 12869, 13122, 13123, 13125, 13379),

	// Other
	REGION_ABYSSAL_AREA("Abyssal Area", AreaType.REGIONS, 12108),
	REGION_ABYSSAL_NEXUS("Abyssal Nexus", AreaType.REGIONS, 12106),
	REGION_AGILITY_PYRAMID("Agility Pyramid", AreaType.REGIONS, 12105, 13356),
	REGION_AIR_ALTAR("Air Altar", AreaType.REGIONS, 11339),
	REGION_AL_KHARID_MINE("Al Kharid Mine", AreaType.REGIONS, 13107),
	REGION_APE_ATOLL("Ape Atoll" , AreaType.REGIONS, 10794, 10795, 10974, 11050),
	REGION_ARANDAR("Arandar", AreaType.REGIONS, 9266, 9267, 9523),
	REGION_ASGARNIA("Asgarnia", AreaType.REGIONS, 11825, 11829, 11830, 12085, 12086),
	REGION_BATTLEFIELD("Battlefield", AreaType.REGIONS, 10034),
	REGION_BATTLEFRONT("Battlefront", AreaType.REGIONS, 5433, 5434),
	REGION_BLAST_MINE("Blast Mine", AreaType.REGIONS, 5948),
	REGION_BODY_ALTAR("Body Altar", AreaType.REGIONS, 10059),
	REGION_CHAOS_ALTAR("Chaos Altar", AreaType.REGIONS, 9035),
	REGION_COSMIC_ALTAR("Cosmic Altar", AreaType.REGIONS, 8523),
	REGION_COSMIC_ENTITYS_PLANE("Cosmic Entity's Plane", AreaType.REGIONS, 8267),
	REGION_CRABCLAW_ISLE("Crabclaw Isle", AreaType.REGIONS, 6965),
	REGION_CRAFTING_GUILD("Crafting Guild", AreaType.REGIONS, 11571),
	REGION_CRANDOR("Crandor", AreaType.REGIONS, 11314, 11315),
	REGION_CRASH_ISLAND("Crash Island", AreaType.REGIONS, 11562),
	REGION_DARK_ALTAR("Dark Altar", AreaType.REGIONS, 6716),
	REGION_DEATH_ALTAR("Death Altar", AreaType.REGIONS, 8779),
	REGION_DEATH_PLATEAU("Death Plateau", AreaType.REGIONS, 11320),
	REGION_DENSE_ESSENCE("Dense Essence Mine", AreaType.REGIONS, 6972),
	REGION_DESERT_PLATEAU("Desert Plateau", AreaType.REGIONS, 13361, 13617),
	REGION_DIGSITE("Digsite", AreaType.REGIONS, 13365),
	REGION_DRAGONTOOTH("Dragontooth Island", AreaType.REGIONS, 15159),
	REGION_DRAYNOR_MANOR("Draynor Manor", AreaType.REGIONS, 12340),
	REGION_DRILL_SERGEANT("Drill Sergeant's Training Camp", AreaType.REGIONS, 12619),
	REGION_EAGLES_PEAK("Eagles' Peak", AreaType.REGIONS, 9270),
	REGION_EARTH_ALTAR("Earth Altar", AreaType.REGIONS, 10571),
	REGION_ENCHANTED_VALLEY("Enchanted Valley", AreaType.REGIONS, 12102),
	REGION_EVIL_TWIN("Evil Twin Crane Room", AreaType.REGIONS, 7504),
	REGION_EXAM_CENTRE("Exam Centre", AreaType.REGIONS, 13364),
	REGION_FALADOR_FARM("Falador Farm", AreaType.REGIONS, 12083),
	REGION_FARMING_GUILD("Farming Guild", AreaType.REGIONS, 4922),
	REGION_FELDIP_HILLS("Feldip Hills", AreaType.REGIONS, 9773, 9774, 10029, 10030, 10285, 10286, 10287, 10542, 10543),
	REGION_FENKENSTRAIN("Fenkenstrain's Castle", AreaType.REGIONS, 14135),
	REGION_FIGHT_ARENA("Fight Arena", AreaType.REGIONS, 10289),
	REGION_FIRE_ALTAR("Fire Altar", AreaType.REGIONS, 10315),
	REGION_FISHER_REALM("Fisher Realm", AreaType.REGIONS, 10569),
	REGION_FISHING_GUILD("Fishing Guild", AreaType.REGIONS, 10293),
	REGION_FISHING_PLATFORM("Fishing Platform", AreaType.REGIONS, 11059),
	REGION_FORSAKEN_TOWER("The Forsaken Tower", AreaType.REGIONS, 5435),
	REGION_FOSSIL_ISLAND("Fossil Island", AreaType.REGIONS, 14650, 14651, 14652, 14906, 14907, 14908, 15162, 15163, 15164),
	REGION_FREAKY_FORESTER("Freaky Forester's Clearing", AreaType.REGIONS, 10314),
	REGION_FREMENNIK("Fremennik Province", AreaType.REGIONS, 10296, 10552, 10808, 10809, 10810, 10811, 11064),
	REGION_FREMENNIK_ISLES("Fremennik Isles", AreaType.REGIONS, 9276, 9532),
	REGION_FROGLAND("Frogland", AreaType.REGIONS, 9802),
	REGION_GALVEK_SHIPWRECKS("Galvek Shipwrecks", AreaType.REGIONS, 6486, 6487, 6488, 6489, 6742, 6743, 6744, 6745),
	REGION_GORAKS_PLANE("Gorak's Plane", AreaType.REGIONS, 12115),
	REGION_GRAND_EXCHANGE("Grand Exchange", AreaType.REGIONS, 12598),
	REGION_GWD("God Wars Dungeon", AreaType.REGIONS, 11578),
	REGION_HARMONY("Harmony Island", AreaType.REGIONS, 15148),
	REGION_HAZELMERE("Hazelmere's Island", AreaType.REGIONS, 10544),
	REGION_ICE_PATH("Ice Path", AreaType.REGIONS, 11322, 11323),
	REGION_ICEBERG("Iceberg", AreaType.REGIONS, 10558, 10559),
	REGION_ICYENE_GRAVEYARD("Icyene Graveyard", AreaType.REGIONS, 14641, 14897, 14898),
	REGION_ISAFDAR("Isafdar", AreaType.REGIONS, 8497, 8753, 8754, 9009, 9010),
	REGION_ISLAND_OF_STONE("Island of Stone", AreaType.REGIONS, 9790),
	REGION_ISLE_OF_SOULS("Isle of Souls", AreaType.REGIONS, 8236, 8237, 8238, 8491, 8492, 8494, 8747, 8750, 9003, 9004, 9006, 9260, 9261, 9262),
	REGION_JIGGIG("Jiggig" , AreaType.REGIONS, 9775),
	REGION_KANDARIN("Kandarin", AreaType.REGIONS, 9268, 9269, 9014, 9263, 9264, 9519, 9524, 9527, 9776, 9783, 10037, 10290, 10294, 10546, 10551, 10805, 11062),
	REGION_KARAMJA("Karamja" , AreaType.REGIONS, 10801, 10802, 11054, 11311, 11312, 11313, 11566, 11567, 11568, 11569, 11822),
	REGION_KEBOS_LOWLANDS("Kebos Lowlands", AreaType.REGIONS, 4665, 4666, 4667, 4921, 5178),
	REGION_KEBOS_SWAMP("Kebos Swamp", AreaType.REGIONS, 4664, 4920, 5174, 5175, 5176, 5430, 5431),
	REGION_KHARAZI_JUNGLE("Kharazi Jungle", AreaType.REGIONS, 11053, 11309, 11565, 11821),
	REGION_KHARIDIAN_DESERT("Kharidian Desert", AreaType.REGIONS, 12587, 12844, 12845, 12846, 12847, 12848, 13100, 13101, 13102, 13103, 13104, 13357, 13359, 13360, 13614, 13615, 13616),
	REGION_KILLERWATT_PLANE("Killerwatt Plane", AreaType.REGIONS, 10577),
	REGION_KOUREND("Great Kourend", AreaType.REGIONS, 6201, 6457, 6713),
	REGION_KOUREND_WOODLAND("Kourend Woodland", AreaType.REGIONS, 5942, 6197, 6453),
	REGION_LAW_ALTAR("Law Altar", AreaType.REGIONS, 9803),
	REGION_LEGENDS_GUILD("Legends' Guild", AreaType.REGIONS, 10804),
	REGION_LIGHTHOUSE("Lighthouse", AreaType.REGIONS, 10040),
	REGION_LITHKREN("Lithkren", AreaType.REGIONS, 14142, 14398),
	REGION_LUMBRIDGE_SWAMP("Lumbridge Swamp", AreaType.REGIONS, 12593, 12849),
	REGION_MAX_ISLAND("Max Island", AreaType.REGIONS, 11063),
	REGION_MCGRUBORS_WOOD("McGrubor's Wood", AreaType.REGIONS, 10550),
	REGION_MIME_STAGE("Mime's Stage", AreaType.REGIONS, 8010),
	REGION_MIND_ALTAR("Mind Altar", AreaType.REGIONS, 11083),
	REGION_MISTHALIN("Misthalin", AreaType.REGIONS, 12594, 12595, 12851),
	REGION_MOLCH("Molch", AreaType.REGIONS, 5177),
	REGION_MOLCH_ISLAND("Molch Island", AreaType.REGIONS, 5432),
	REGION_MORYTANIA("Morytania", AreaType.REGIONS, 13619, 13620, 13621, 13622, 13876, 13877, 13879, 14133, 14134, 14389, 14390, 14391, 14645, 14647),
	REGION_MOUNT_QUIDAMORTEM("Mount Quidamortem", AreaType.REGIONS, 4662, 4663, 4918, 4919),
	REGION_MR_MORDAUTS_CLASSROOM("Mr. Mordaut's Classroom", AreaType.REGIONS, 7502),
	REGION_MUDSKIPPER("Mudskipper Point", AreaType.REGIONS, 11824),
	REGION_MYSTERIOUS_OLD_MAN_MAZE("Mysterious Old Man's Maze", AreaType.REGIONS, 11590, 11591, 11846, 11847),
	REGION_MYTHS_GUILD("Myths' Guild", AreaType.REGIONS, 9772),
	REGION_NATURE_ALTAR("Nature Altar", AreaType.REGIONS, 9547),
	REGION_NORTHERN_TUNDRAS("Northern Tundras", AreaType.REGIONS, 6204, 6205, 6717),
	REGION_OBSERVATORY("Observatory", AreaType.REGIONS, 9777),
	REGION_ODD_ONE_OUT("Odd One Out", AreaType.REGIONS, 7754),
	REGION_OTTOS_GROTTO("Otto's Grotto", AreaType.REGIONS, 10038),
	REGION_OURANIA_HUNTER("Ourania Hunter Area", AreaType.REGIONS, 9778),
	REGION_PIRATES_COVE("Pirates' Cove", AreaType.REGIONS, 8763),
	REGION_PISCATORIS_HUNTER_AREA("Piscatoris Hunter Area", AreaType.REGIONS, 9015, 9016, 9271, 9272, 9528),
	REGION_POH("Player Owned House", AreaType.REGIONS, 7513, 7514, 7769, 7770),
	REGION_POISON_WASTE("Poison Waste", AreaType.REGIONS, 8752, 9008),
	REGION_PORT_TYRAS("Port Tyras", AreaType.REGIONS, 8496),
	REGION_PURO_PURO("Puro Puro", AreaType.REGIONS, 10307),
	REGION_QUARRY("Quarry", AreaType.REGIONS, 12589),
	REGION_RANGING_GUILD("Ranging Guild", AreaType.REGIONS, 10549),
	REGION_RATCATCHERS_MANSION("Ratcatchers Mansion", AreaType.REGIONS, 11343),
	REGION_RUINS_OF_UNKAH("Ruins of Unkah", AreaType.REGIONS, 12588),
	REGION_RUNE_ESSENCE_MINE("Rune Essence Mine", AreaType.REGIONS, 11595),
	// The Beekeper, Pinball, and Gravedigger randoms share a region (7758), and although they are not technically ScapeRune, that name is most commonly
	// associated with random events, so those three have been denoted ScapeRune to avoid leaving multiple random event regions without an assigned name.
	REGION_SCAPERUNE("ScapeRune", AreaType.REGIONS, 10058, 7758, 8261),
	REGION_SEA_SPIRIT_DOCK("Sea Spirit Dock", AreaType.REGIONS, 12332),
	REGION_SHIP_YARD("Ship Yard", AreaType.REGIONS, 11823),
	REGION_SILVAREA("Silvarea", AreaType.REGIONS, 13366),
	REGION_SINCLAR_MANSION("Sinclair Mansion", AreaType.REGIONS, 10807),
	REGION_SLAYER_TOWER("Slayer Tower", AreaType.REGIONS, 13623, 13723),
	REGION_SOUL_ALTAR("Soul Altar", AreaType.REGIONS, 7228),
	REGION_TROLL_ARENA("Troll Arena", AreaType.REGIONS, 11576),
	REGION_TROLLHEIM("Trollheim", AreaType.REGIONS, 11577),
	REGION_TROLLWEISS_MTN("Trollweiss Mountain", AreaType.REGIONS, 11066, 11067, 11068),
	REGION_TUTORIAL_ISLAND("Tutorial Island", AreaType.REGIONS, 12079, 12080, 12335, 12336, 12436, 12592),
	REGION_UNDERWATER("Underwater", AreaType.REGIONS, 15008, 15264),
	REGION_WATER_ALTAR("Water Altar", AreaType.REGIONS, 10827),
	REGION_WATERBIRTH_ISLAND("Waterbirth Island", AreaType.REGIONS, 10042),
	REGION_WINTERTODT_CAMP("Wintertodt Camp", AreaType.REGIONS, 6461),
	REGION_WIZARDS_TOWER("Wizards' Tower", AreaType.REGIONS, 12337),
	REGION_WOODCUTTING_GUILD("Woodcutting Guild", AreaType.REGIONS, 6198, 6454),
	REGION_WRATH_ALTAR("Wrath Altar", AreaType.REGIONS, 9291);

	private static final Map<Integer, GameEventType> FROM_REGION;

	static
	{
		ImmutableMap.Builder<Integer, GameEventType> regionMapBuilder = new ImmutableMap.Builder<>();
		for (GameEventType gameEventType : GameEventType.values())
		{
			if (gameEventType.getRegionIds() == null)
			{
				continue;
			}

			for (int region : gameEventType.getRegionIds())
			{
				regionMapBuilder.put(region, gameEventType);
			}
		}
		FROM_REGION = regionMapBuilder.build();
	}

	@Nullable
	private String imageKey;

	@Nullable
	private String state;

	@Nullable
	private String details;

	private int priority;

	/**
	 * Marks this event as root event. (eg. event that should be used for total time tracking)
	 */
	private boolean root;

	/**
	 * Determines if event should clear other clearable events when triggered
	 */
	private boolean shouldClear;

	/**
	 * Determines if event should be processed when it timeouts based on action timeout
	 */
	private boolean shouldTimeout;

	/**
	 * Determines if event start time should be reset when processed
	 */
	private boolean shouldRestart;

	/**
	 * Determines if event should be cleared when processed
	 */
	private boolean shouldBeCleared = true;

	@Nullable
	private AreaType areaType;

	@Nullable
	private int[] regionIds;

	GameEventType(Skill skill)
	{
		this(skill, 0);
	}

	GameEventType(Skill skill, int priority)
	{
		this.details = training(skill);
		this.priority = priority;
		this.imageKey = imageKeyOf(skill);
		this.shouldTimeout = true;
		this.shouldBeCleared = false;
	}

	GameEventType(String areaName, AreaType areaType, int... regionIds)
	{
		this.state = exploring(areaType, areaName);
		this.priority = -2;
		this.areaType = areaType;
		this.regionIds = regionIds;
		this.shouldClear = true;
	}

	GameEventType(String state, int priority, boolean shouldClear, boolean shouldTimeout, boolean shouldRestart, boolean shouldBeCleared, boolean root)
	{
		this.state = state;
		this.priority = priority;
		this.shouldClear = shouldClear;
		this.shouldTimeout = shouldTimeout;
		this.shouldRestart = shouldRestart;
		this.shouldBeCleared = shouldBeCleared;
		this.root = root;
	}

	GameEventType(String state, int priority)
	{
		this(state, priority, true, false, false, true, false);
	}

	private static String training(final Skill skill)
	{
		return training(skill.getName());
	}

	private static String training(final String what)
	{
		return "Training: " + what;
	}

	private static String imageKeyOf(final Skill skill)
	{
		return imageKeyOf(skill.getName().toLowerCase());
	}

	private static String imageKeyOf(final String what)
	{
		return "icon_" + what;
	}

	private static String exploring(AreaType areaType, String areaName)
	{
		return areaName;
	}

	public static GameEventType fromSkill(final Skill skill)
	{
		switch (skill)
		{
			case ATTACK: return TRAINING_ATTACK;
			case DEFENCE: return TRAINING_DEFENCE;
			case STRENGTH: return TRAINING_STRENGTH;
			case RANGED: return TRAINING_RANGED;
			case PRAYER: return TRAINING_PRAYER;
			case MAGIC: return TRAINING_MAGIC;
			case COOKING: return TRAINING_COOKING;
			case WOODCUTTING: return TRAINING_WOODCUTTING;
			case FLETCHING: return TRAINING_FLETCHING;
			case FISHING: return TRAINING_FISHING;
			case FIREMAKING: return TRAINING_FIREMAKING;
			case CRAFTING: return TRAINING_CRAFTING;
			case SMITHING: return TRAINING_SMITHING;
			case MINING: return TRAINING_MINING;
			case HERBLORE: return TRAINING_HERBLORE;
			case AGILITY: return TRAINING_AGILITY;
			case THIEVING: return TRAINING_THIEVING;
			case SLAYER: return TRAINING_SLAYER;
			case FARMING: return TRAINING_FARMING;
			case RUNECRAFT: return TRAINING_RUNECRAFT;
			case HUNTER: return TRAINING_HUNTER;
			case CONSTRUCTION: return TRAINING_CONSTRUCTION;
			default: return null;
		}
	}

	public static GameEventType fromRegion(final int regionId)
	{
		return FROM_REGION.get(regionId);
	}
}

package com.projectilerage.runelite.partyplay;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import lombok.Getter;
import net.runelite.api.ItemID;

import javax.annotation.Nullable;
import java.util.List;
import java.util.Map;
import java.util.function.IntPredicate;

/*
    This whole file was copied from the built-in Slayer plugin.
    All credit goes to the creator(s) of that plugin.
 */
@Getter
enum SlayerTask
{
    //<editor-fold desc="Enums">
    ABERRANT_SPECTRES("Aberrant spectres", ItemID.ABERRANT_SPECTRE, "Spectre"),
    // Abyssal demon - 150 xp
    // Greater abyssal demon - 4200 xp
    // Abyssal sire - 450 xp
    // Reanimated abyssal - 31 xp
    // Ignore 50xp drops to avoid recording a kill from sire vents
    ABYSSAL_DEMONS("Abyssal demons", ItemID.ABYSSAL_DEMON, (xp) -> xp != 50),
    ABYSSAL_SIRE("Abyssal Sire", ItemID.ABYSSAL_ORPHAN, (xp) -> xp != 50),
    ADAMANT_DRAGONS("Adamant dragons", ItemID.ADAMANT_DRAGON_MASK),
    ALCHEMICAL_HYDRA("Alchemical Hydra", ItemID.IKKLE_HYDRA),
    ANKOU("Ankou", ItemID.ANKOU_MASK),
    AVIANSIES("Aviansies", ItemID.ENSOULED_AVIANSIE_HEAD),
    BANDITS("Bandits", ItemID.BANDIT, "Bandit", "Black Heather", "Donny the Lad", "Speedy Keith"),
    BANSHEES("Banshees", ItemID.BANSHEE),
    BARROWS_BROTHERS("Barrows Brothers", ItemID.KARILS_COIF),
    BASILISKS("Basilisks", ItemID.BASILISK),
    BATS("Bats", ItemID.GIRAL_BAT_2, "Death wing"),
    BEARS("Bears", ItemID.ENSOULED_BEAR_HEAD),
    BIRDS("Birds", ItemID.FEATHER, "Chicken", "Rooster", "Terrorbird", "Seagull", "Vulture", "Duck"),
    BLACK_DEMONS("Black demons", ItemID.BLACK_DEMON_MASK),
    BLACK_DRAGONS("Black dragons", ItemID.BLACK_DRAGON_MASK, "Baby black dragon"),
    BLACK_KNIGHTS("Black Knights", ItemID.BLACK_FULL_HELM, "Black Knight"),
    BLOODVELD("Bloodveld", ItemID.BLOODVELD),
    BLUE_DRAGONS("Blue dragons", ItemID.BLUE_DRAGON_MASK, "Baby blue dragon"),
    BRINE_RATS("Brine rats", ItemID.BRINE_RAT),
    BRONZE_DRAGONS("Bronze dragons", ItemID.BRONZE_DRAGON_MASK),
    CALLISTO("Callisto", ItemID.CALLISTO_CUB),
    CATABLEPON("Catablepon", ItemID.LEFT_SKULL_HALF),
    CAVE_BUGS("Cave bugs", ItemID.SWAMP_CAVE_BUG),
    CAVE_CRAWLERS("Cave crawlers", ItemID.CAVE_CRAWLER, "Chasm crawler"),
    CAVE_HORRORS("Cave horrors", ItemID.CAVE_HORROR, "Cave abomination"),
    CAVE_KRAKEN("Cave kraken", ItemID.CAVE_KRAKEN),
    CAVE_SLIMES("Cave slimes", ItemID.SWAMP_CAVE_SLIME),
    CERBERUS("Cerberus", ItemID.HELLPUPPY),
    CHAOS_DRUIDS("Chaos druids", ItemID.ELDER_CHAOS_HOOD, "Elder Chaos druid", "Chaos druid"),
    CHAOS_ELEMENTAL("Chaos Elemental", ItemID.PET_CHAOS_ELEMENTAL),
    CHAOS_FANATIC("Chaos Fanatic", ItemID.ANCIENT_STAFF),
    COCKATRICE("Cockatrice", ItemID.COCKATRICE, "Cockathrice"),
    COWS("Cows", ItemID.COW_MASK),
    CRAWLING_HANDS("Crawling hands", ItemID.CRAWLING_HAND, "Crushing hand"),
    CRAZY_ARCHAEOLOGIST("Crazy Archaeologists", ItemID.FEDORA, "Crazy Archaeologist"),
    CROCODILES("Crocodiles", ItemID.SWAMP_LIZARD),
    DAGANNOTH("Dagannoth", ItemID.DAGANNOTH),
    DAGANNOTH_KINGS("Dagannoth Kings", ItemID.PET_DAGANNOTH_PRIME),
    DARK_BEASTS("Dark beasts", ItemID.DARK_BEAST, "Night beast"),
    DARK_WARRIORS("Dark warriors", ItemID.BLACK_MED_HELM, "Dark warrior"),
    DERANGED_ARCHAEOLOGIST("Deranged Archaeologist", ItemID.ARCHAEOLOGISTS_DIARY),
    DOGS("Dogs", ItemID.GUARD_DOG, "Jackal"),
    DRAKES("Drakes", ItemID.DRAKE),
    DUST_DEVILS("Dust devils", ItemID.DUST_DEVIL, "Choke devil"),
    DWARVES("Dwarves", ItemID.DWARVEN_HELMET, "Dwarf", "Black Guard"),
    EARTH_WARRIORS("Earth warriors", ItemID.BRONZE_FULL_HELM_T),
    ELVES("Elves", ItemID.ELF, "Elf", "Iorwerth Warrior", "Iorwerth Archer"),
    ENTS("Ents", ItemID.NICE_TREE, "Ent"),
    FEVER_SPIDERS("Fever spiders", ItemID.FEVER_SPIDER),
    FIRE_GIANTS("Fire giants", ItemID.FIRE_BATTLESTAFF),
    FLESH_CRAWLERS("Fleshcrawlers", ItemID.ENSOULED_SCORPION_HEAD, "Flesh crawler"),
    FOSSIL_ISLAND_WYVERNS("Fossil island wyverns", ItemID.FOSSIL_ISLAND_WYVERN, "Ancient wyvern", "Long-tailed wyvern", "Spitting wyvern", "Taloned wyvern"),
    GARGOYLES("Gargoyles", ItemID.GARGOYLE, 9, ItemID.ROCK_HAMMER),
    GENERAL_GRAARDOR("General Graardor", ItemID.PET_GENERAL_GRAARDOR),
    GHOSTS("Ghosts", ItemID.GHOSTSPEAK_AMULET, "Death wing", "Tortured soul"),
    GHOULS("Ghouls", ItemID.ZOMBIE_HEAD),
    GIANT_MOLE("Giant Mole", ItemID.BABY_MOLE),
    GOBLINS("Goblins", ItemID.ENSOULED_GOBLIN_HEAD),
    GREATER_DEMONS("Greater demons", ItemID.GREATER_DEMON_MASK),
    GREEN_DRAGONS("Green dragons", ItemID.GREEN_DRAGON_MASK, "Baby green dragon", "Elvarg"),
    GROTESQUE_GUARDIANS("Grotesque Guardians", ItemID.MIDNIGHT, 0, ItemID.ROCK_HAMMER, "Dusk", "Dawn"),
    HARPIE_BUG_SWARMS("Harpie bug swarms", ItemID.SWARM),
    HELLHOUNDS("Hellhounds", ItemID.HELLHOUND),
    HILL_GIANTS("Hill giants", ItemID.ENSOULED_GIANT_HEAD, "Cyclops"),
    HOBGOBLINS("Hobgoblins", ItemID.HOBGOBLIN_GUARD),
    HYDRAS("Hydras", ItemID.HYDRA),
    ICEFIENDS("Icefiends", ItemID.ICE_DIAMOND),
    ICE_GIANTS("Ice giants", ItemID.ICE_DIAMOND),
    ICE_WARRIORS("Ice warriors", ItemID.MITHRIL_FULL_HELM_T, "Icelord"),
    INFERNAL_MAGES("Infernal mages", ItemID.INFERNAL_MAGE, "Malevolent mage"),
    IRON_DRAGONS("Iron dragons", ItemID.IRON_DRAGON_MASK),
    JAD("TzTok-Jad", ItemID.TZREKJAD, (xp) -> xp == 25250),
    JELLIES("Jellies", ItemID.JELLY, "Jelly"),
    JUNGLE_HORROR("Jungle horrors", ItemID.ENSOULED_HORROR_HEAD),
    KALPHITE("Kalphite", ItemID.KALPHITE_SOLDIER),
    KALPHITE_QUEEN("Kalphite Queen", ItemID.KALPHITE_PRINCESS),
    KILLERWATTS("Killerwatts", ItemID.KILLERWATT),
    KING_BLACK_DRAGON("King Black Dragon", ItemID.PRINCE_BLACK_DRAGON),
    KRAKEN("Cave Kraken Boss", ItemID.PET_KRAKEN, "Kraken"),
    KREEARRA("Kree'arra", ItemID.PET_KREEARRA),
    KRIL_TSUTSAROTH("K'ril Tsutsaroth", ItemID.PET_KRIL_TSUTSAROTH),
    KURASK("Kurask", ItemID.KURASK),
    LAVA_DRAGONS("Lava Dragons", ItemID.LAVA_SCALE, "Lava dragon"),
    LESSER_DEMONS("Lesser demons", ItemID.LESSER_DEMON_MASK),
    LIZARDMEN("Lizardmen", ItemID.LIZARDMAN_FANG, "Lizardman"),
    LIZARDS("Lizards", ItemID.DESERT_LIZARD, "Desert lizard", "Sulphur lizard", "Small lizard", "Lizard"),
    MAGIC_AXES("Magic axes", ItemID.IRON_BATTLEAXE, "Magic axe"),
    MAMMOTHS("Mammoths", ItemID.ATTACKER_HORN, "Mammoth"),
    MINIONS_OF_SCABARAS("Minions of scabaras", ItemID.GOLDEN_SCARAB, "Scarab swarm", "Locust rider", "Scarab mage"),
    MINOTAURS("Minotaurs", ItemID.ENSOULED_MINOTAUR_HEAD),
    MITHRIL_DRAGONS("Mithril dragons", ItemID.MITHRIL_DRAGON_MASK),
    MOGRES("Mogres", ItemID.MOGRE),
    MOLANISKS("Molanisks", ItemID.MOLANISK),
    MONKEYS("Monkeys", ItemID.ENSOULED_MONKEY_HEAD, "Tortured gorilla"),
    MOSS_GIANTS("Moss giants", ItemID.MOSSY_KEY),
    MUTATED_ZYGOMITES("Mutated zygomites", ItemID.MUTATED_ZYGOMITE, 7, ItemID.FUNGICIDE_SPRAY_0, "Zygomite", "Fungi"),
    NECHRYAEL("Nechryael", ItemID.NECHRYAEL, "Nechryarch"),
    OGRES("Ogres", ItemID.ENSOULED_OGRE_HEAD),
    OTHERWORLDLY_BEING("Otherworldly beings", ItemID.GHOSTLY_HOOD),
    PIRATES("Pirates", ItemID.PIRATE_HAT, "Pirate"),
    PYREFIENDS("Pyrefiends", ItemID.PYREFIEND, "Flaming pyrelord"),
    RATS("Rats", ItemID.RATS_TAIL),
    RED_DRAGONS("Red dragons", ItemID.BABY_RED_DRAGON, "Baby red dragon"),
    REVENANTS("Revenants", ItemID.BRACELET_OF_ETHEREUM, "Revenant imp", "Revenant goblin", "Revenant pyrefiend", "Revenant hobgoblin", "Revenant cyclops", "Revenant hellhound", "Revenant demon", "Revenant ork", "Revenant dark beast", "Revenant knight", "Revenant dragon"),
    ROCKSLUGS("Rockslugs", ItemID.ROCKSLUG, 4, ItemID.BAG_OF_SALT),
    ROGUES("Rogues", ItemID.ROGUE_MASK, "Rogue"),
    RUNE_DRAGONS("Rune dragons", ItemID.RUNE_DRAGON_MASK),
    SARACHNIS("Sarachnis", ItemID.SRARACHA),
    SCORPIA("Scorpia", ItemID.SCORPIAS_OFFSPRING),
    SCORPIONS("Scorpions", ItemID.ENSOULED_SCORPION_HEAD),
    SEA_SNAKES("Sea snakes", ItemID.SNAKE_CORPSE),
    SHADES("Shades", ItemID.SHADE_ROBE_TOP, "Loar Shadow", "Loar Shade", "Phrin Shadow", "Phrin Shade", "Riyl Shadow", "Riyl Shade", "Asyn Shadow", "Asyn Shade", "Fiyr Shadow", "Fiyr Shade"),
    SHADOW_WARRIORS("Shadow warriors", ItemID.BLACK_FULL_HELM),
    SKELETAL_WYVERNS("Skeletal wyverns", ItemID.SKELETAL_WYVERN),
    SKELETONS("Skeletons", ItemID.SKELETON_GUARD),
    SMOKE_DEVILS("Smoke devils", ItemID.SMOKE_DEVIL),
    SOURHOGS("Sourhogs", ItemID.SOURHOG_FOOT),
    SPIDERS("Spiders", ItemID.HUGE_SPIDER),
    SPIRITUAL_CREATURES("Spiritual creatures", ItemID.DRAGON_BOOTS, "Spiritual ranger", "Spiritual mage", "Spiritual warrior"),
    STEEL_DRAGONS("Steel dragons", ItemID.STEEL_DRAGON),
    SULPHUR_LIZARDS("Sulphur Lizards", ItemID.SULPHUR_LIZARD),
    SUQAHS("Suqahs", ItemID.SUQAH_TOOTH),
    TEMPLE_SPIDERS("Temple Spiders", ItemID.RED_SPIDERS_EGGS),
    TERROR_DOGS("Terror dogs", ItemID.TERROR_DOG),
    THERMONUCLEAR_SMOKE_DEVIL("Thermonuclear Smoke Devil", ItemID.PET_SMOKE_DEVIL),
    TROLLS("Trolls", ItemID.TROLL_GUARD, "Dad", "Arrg"),
    TUROTH("Turoth", ItemID.TUROTH),
    TZHAAR("Tzhaar", ItemID.ENSOULED_TZHAAR_HEAD),
    UNDEAD_DRUIDS("Undead Druids", ItemID.MASK_OF_RANUL),
    VAMPYRES("Vampyres", ItemID.STAKE, "Vyrewatch", "Vampire"),
    VENENATIS("Venenatis", ItemID.VENENATIS_SPIDERLING),
    VETION("Vet'ion", ItemID.VETION_JR),
    VORKATH("Vorkath", ItemID.VORKI),
    WALL_BEASTS("Wall beasts", ItemID.SWAMP_WALLBEAST),
    WATERFIENDS("Waterfiends", ItemID.WATER_ORB),
    WEREWOLVES("Werewolves", ItemID.WOLFBANE, "Werewolf"),
    WOLVES("Wolves", ItemID.GREY_WOLF_FUR, "Wolf"),
    WYRMS("Wyrms", ItemID.WYRM),
    ZILYANA("Commander Zilyana", ItemID.PET_ZILYANA),
    ZOMBIES("Zombies", ItemID.ZOMBIE_HEAD, "Undead"),
    ZUK("TzKal-Zuk", ItemID.TZREKZUK, (xp) -> xp == 101890),
    ZULRAH("Zulrah", ItemID.PET_SNAKELING);
    //</editor-fold>

    private static final Map<String, SlayerTask> tasks;
    static final List<String> LOCATIONS = ImmutableList.of(
            "", // no location is a valid location
            "Abyss",
            "Ancient Cavern",
            "Asgarnian Ice Dungeon",
            "Battlefront",
            "Brimhaven Dungeon",
            "Brine Rat Cavern",
            "Catacombs of Kourend",
            "Chasm of Fire",
            "Clan Wars",
            "Death Plateau",
            "Evil Chicken's Lair",
            "Fossil Island",
            "Forthos Dungeon",
            "Fremennik Slayer Dungeon",
            "God Wars Dungeon",
            "Iorwerth Dungeon",
            "Isle of Souls",
            "Jormungand's Prison",
            "Kalphite Lair",
            "Karuulm Slayer Dungeon",
            "Keldagrim",
            "Kraken Cove",
            "Lighthouse",
            "Lithkren Vault",
            "Lizardman Canyon",
            "Lizardman Settlement",
            "Meiyerditch Laboratories",
            "Molch",
            "Mount Quidamortem",
            "Mourner Tunnels",
            "Myths' Guild Dungeon",
            "Ogre Enclave",
            "Slayer Tower",
            "Smoke Devil Dungeon",
            "Smoke Dungeon",
            "Stronghold of Security",
            "Stronghold Slayer Dungeon",
            "task-only Kalphite Cave",
            "Taverley Dungeon",
            "Troll Stronghold",
            "Waterbirth Island",
            "Waterfall Dungeon",
            "Wilderness",
            "Witchaven Dungeon",
            "Zanaris"
    );

    private final String name;
    private final int itemSpriteId;
    private final String[] targetNames;
    private final int weaknessThreshold;
    private final int weaknessItem;
    @Nullable
    private final IntPredicate xpMatcher;

    static
    {
        ImmutableMap.Builder<String, SlayerTask> builder = new ImmutableMap.Builder<>();

        for (SlayerTask task : values())
        {
            builder.put(task.getName().toLowerCase(), task);
        }

        tasks = builder.build();
    }

    SlayerTask(String name, int itemSpriteId, String... targetNames)
    {
        Preconditions.checkArgument(itemSpriteId >= 0);
        this.name = name;
        this.itemSpriteId = itemSpriteId;
        this.weaknessThreshold = -1;
        this.weaknessItem = -1;
        this.targetNames = targetNames;
        this.xpMatcher = null;
    }

    SlayerTask(String name, int itemSpriteId, int weaknessThreshold, int weaknessItem, String... targetNames)
    {
        Preconditions.checkArgument(itemSpriteId >= 0);
        this.name = name;
        this.itemSpriteId = itemSpriteId;
        this.weaknessThreshold = weaknessThreshold;
        this.weaknessItem = weaknessItem;
        this.targetNames = targetNames;
        this.xpMatcher = null;
    }

    SlayerTask(String name, int itemSpriteId, IntPredicate xpMatcher)
    {
        Preconditions.checkArgument(itemSpriteId >= 0);
        this.name = name;
        this.itemSpriteId = itemSpriteId;
        this.weaknessThreshold = -1;
        this.weaknessItem = -1;
        this.targetNames = new String[0];
        this.xpMatcher = xpMatcher;
    }

    @Nullable
    static SlayerTask getTask(String taskName)
    {
        return tasks.get(taskName.toLowerCase());
    }
}


package com.projectilerage.runelite.partyplay;

import com.google.common.base.Strings;
import com.google.inject.Provides;
import com.projectilerage.runelite.partyplay.ui.components.DynamicInfoBoxComponent;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
//import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.StatChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.FontType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PartyChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.party.messages.StatusUpdate;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.party.PartyService;
import net.runelite.client.party.WSClient;
import net.runelite.client.party.events.UserJoin;
import net.runelite.client.party.events.UserPart;
import net.runelite.client.party.messages.UserSync;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.image.BufferedImage;
import java.time.temporal.ChronoUnit;
import java.util.*;

@PluginDescriptor(
        name = "Party Play",
        description = "Makes Runescape a little less single-player",
        tags = {"action", "activity", "status"}
)
@Slf4j
@Singleton
public class PartyPlayPlugin extends Plugin {
    @Inject
    private Client client;

    @Inject
    private InfoBoxManager infoBoxManager;

    @Inject
    private ConfigManager configManager;

    @Inject
    private ItemManager itemManager;

    @Inject
    private PartyPlayConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private PartyService partyService;

    @Inject
    private PartyOverlay partyOverlay;

    @Inject
    private PartyState state;

    @Inject
    private TooltipManager tooltipManager;

    @Inject
    private WSClient wsClient;

    private final Map<Skill, Integer> skillExp = new HashMap<>();

    @Getter(AccessLevel.PACKAGE)
    private final Map<Long, PartyStateInfo> partyStateInfoMap = Collections.synchronizedMap(new HashMap<>());

    private final Integer DEFAULT_SLAYER_ITEM = ItemID.SLAYER_HELMET;

    private GameEventType curArea;

    private boolean loginFlag;

    protected void startUp() throws Exception
    {
        wsClient.registerMessage(ActivityInfo.class);
        wsClient.registerMessage(SlayerInfo.class);
        state.reset();
        checkForGameStateUpdate();
        checkForAreaUpdate();
        overlayManager.add(partyOverlay);
    }

    protected void shutDown() throws Exception
    {
        overlayManager.remove(partyOverlay);
        wsClient.unregisterMessage(ActivityInfo.class);
        wsClient.unregisterMessage(SlayerInfo.class);
        state.reset();
        partyStateInfoMap.clear();
    }

    @Subscribe
    public void onUserJoin(final UserJoin event)
    {
        log.debug("onUserJoin: "  + partyService.getLocalMember());
        this.state.refresh();
        processSlayerConfig();
    }

    @Subscribe
    public void onUserSync(final UserSync event)
    {
        log.debug("onUserSync: " + partyService.getLocalMember());
        this.state.refresh();
        processSlayerConfig();
    }

    @Subscribe
    public void onUserPart(final UserPart event)
    {
        log.debug("onUserPart: " + partyService.getLocalMember());
        this.partyStateInfoMap.remove(event.getMemberId());
    }

    @Subscribe
    public void onPartyChanged(final PartyChanged event)
    {
        log.debug("onPartyChange: " + partyService.getLocalMember());
        this.partyStateInfoMap.clear();
        this.state.refresh();
        processSlayerConfig();
    }

    @Subscribe
    public void onConfigChanged(final ConfigChanged event) {
        if(event.getGroup().equals(PartyPlayConfig.GROUP)) {
            log.debug("Config changed; refreshing");
            this.state.refresh();
            processSlayerConfig();
        } else if(event.getGroup().equals("slayer")) {
            processSlayerConfig();
        }
    }

    @Provides
    public PartyPlayConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(PartyPlayConfig.class);
    }

    private String getLocalPlayerName() {
        String name = client.getLocalPlayer().getName();

        if(name != null) {
            return name;
        }

        return "Client Unknown";
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        switch (event.getGameState())
        {
            case LOGIN_SCREEN:
                this.state.reset();
                checkForGameStateUpdate();
                return;
            case LOGGING_IN:
                loginFlag = true;
                break;
            case LOGGED_IN:
                if (loginFlag)
                {
                    loginFlag = false;
                    this.state.reset();
                    processSlayerConfig();
                    checkForGameStateUpdate();
                }

                checkForAreaUpdate();
                break;
        }
    }

    private void checkForGameStateUpdate() {
        final boolean isLoggedIn = client.getGameState() == GameState.LOGGED_IN;

        if (config.showMainMenu() || isLoggedIn)
        {
            state.triggerEvent(isLoggedIn
                    ? GameEventType.IN_GAME
                    : GameEventType.IN_MENU);
        }
    }

    @Subscribe
    public void onStatusUpdate(StatusUpdate statusUpdate) {
        if(statusUpdate.getMemberId() == this.partyService.getLocalMember().getMemberId()) {
            log.debug("PPD:: onStatusUpdate: Setting " + Strings.nullToEmpty(statusUpdate.getCharacterName()));
            this.state.setLocalPlayerName(statusUpdate.getCharacterName());
        }
    }

    @Subscribe
    public void onStatChanged(StatChanged statChanged)
    {
        final Skill skill = statChanged.getSkill();
        final int exp = statChanged.getXp();
        final Integer previous = skillExp.put(skill, exp);

        if (previous == null || previous >= exp)
        {
            return;
        }

        GameEventType event = GameEventType.fromSkill(skill);

        if(event != null){
            this.state.triggerEvent(event);
        }
    }

    @Schedule(
            period = 1,
            unit = ChronoUnit.MINUTES
    )
    public void trimStateEvents() {
        this.state.checkForTimeout();
    }

    @Schedule(
            period = 10,
            unit = ChronoUnit.SECONDS
    )
    public void maybeCheckForAreaUpdate() {
        if(!GameState.LOGGED_IN.equals(client.getGameState())) {
            return;
        }

        int regionId = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation()).getRegionID();
        if(curArea == null || Arrays.stream(curArea.getRegionIds()).noneMatch((oldRegionId) -> oldRegionId == regionId)) {
            log.debug("Area Update Check");
            this.checkForAreaUpdate();
        }
    }

    private void checkForAreaUpdate()
    {
        if (client.getLocalPlayer() == null)
        {
            return;
        }

        final int playerRegionID = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation()).getRegionID();

        if (playerRegionID == 0)
        {
            return;
        }

        final EnumSet<WorldType> worldType = client.getWorldType();

        if (worldType.contains(WorldType.DEADMAN))
        {
            this.state.triggerEvent(GameEventType.PLAYING_DEADMAN);
        }
        else if (WorldType.isPvpWorld(worldType))
        {
            this.state.triggerEvent(GameEventType.PLAYING_PVP);
        }

        GameEventType gameEventType = GameEventType.fromRegion(playerRegionID);

        // NMZ uses the same region ID as KBD. KBD is always on plane 0 and NMZ is always above plane 0
        // Since KBD requires going through the wilderness there is no EventType for it
        if (GameEventType.MG_NIGHTMARE_ZONE == gameEventType
                && client.getLocalPlayer().getWorldLocation().getPlane() == 0)
        {
            gameEventType = null;
        }

        if(gameEventType == null)
        {
            // Unknown region, reset to default in-game
            log.debug("Triggering In Game Event: " + playerRegionID);
            this.state.triggerEvent(GameEventType.IN_GAME);
            return;
        }

        log.debug("Triggering Area Event: " + gameEventType.getState());
        this.curArea = gameEventType;
        this.state.triggerEvent(gameEventType);
    }

    @Subscribe
    public void onActivityInfo(final ActivityInfo event)
    {
        log.debug("PPD:: onActivityInfo");
        setActivityInfo(event);
    }

    ActivityInfo getActivityInfo(Long uuid) {
        PartyStateInfo partyStateInfo = partyStateInfoMap.get(uuid);

        return partyStateInfo != null ? partyStateInfo.getActivityInfo() : null;
    }

    void setActivityInfo(ActivityInfo activityInfo) {
        PartyStateInfo partyStateInfo = partyStateInfoMap.get(activityInfo.getMemberId());
        log.debug("PPD:: setActivityInfo");
        if (partyStateInfo != null) {
            partyStateInfo.setActivityInfo(activityInfo);
        } else {
            this.partyStateInfoMap.put(activityInfo.getMemberId(), new PartyStateInfo(activityInfo));
        }
    }

    public DynamicInfoBoxComponent getSlayerInfoBox(SlayerTask task) {
        if(task == null || task.getName() == null) {
            log.debug("PPD:: Slayer task null; Exiting Slayer InfoBox creation");
            return null;
        }

        int size = configManager.getConfiguration("runelite", "infoBoxSize", Integer.class);
        FontType font = configManager.getConfiguration("runelite", "infoboxFontType", FontType.class);
        boolean outline = configManager.getConfiguration("runelite", "infoBoxTextOutline", Boolean.class);

        int item = task.getItemSpriteId();
        BufferedImage rawImage = itemManager.getImage(item != 0 ? item : DEFAULT_SLAYER_ITEM);
        BufferedImage image =  ImageUtil.resizeImage(rawImage, size, size, true);
        DynamicInfoBoxComponent box = new DynamicInfoBoxComponent(client, tooltipManager);
        box.setImage(image);
        box.setFont(font.getFont());
        box.setOutline(outline);

        return box;
    }

    SlayerInfo getSlayerInfo(Long uuid) {
        PartyStateInfo partyStateInfo = partyStateInfoMap.get(uuid);

        return partyStateInfo != null ? partyStateInfo.getSlayerInfo() : null;
    }

    void setSlayerInfo(SlayerInfo slayerInfo) {
        PartyStateInfo partyStateInfo = partyStateInfoMap.get(slayerInfo.getMemberId());

        if (partyStateInfo != null) {
            partyStateInfo.setSlayerInfo(slayerInfo);
        } else if(slayerInfo.getSlayerTask() != null) {
            this.partyStateInfoMap.put(slayerInfo.getMemberId(), new PartyStateInfo(slayerInfo));
        }
    }

    @Subscribe
    void onSlayerInfo(final SlayerInfo slayerInfo) {
        setSlayerInfo(slayerInfo);
    }

    void processSlayerConfig() {
        if(partyService.getLocalMember() == null || !state.containsEventType(GameEventType.TRAINING_SLAYER) || !config.showSlayerActivity()) {
            log.debug("PPD:: Slayer Event Non-applicable; Clearing Slayer state");
            clearSlayerState();
            return;
        }

        String taskName = configManager.getRSProfileConfiguration("slayer", "taskName");
        String amount = configManager.getRSProfileConfiguration("slayer", "amount");

        if(Strings.isNullOrEmpty(taskName) || Strings.isNullOrEmpty(amount)) {
            log.debug("PPD:: Null Slayer Event");
            return;
        }

        if(Integer.parseInt(amount) == 0) {
            log.debug("PPD:: Task completed. Clearing state");
            clearSlayerState();
            return;
        }

        SlayerInfo slayerInfo = getSlayerInfo(partyService.getLocalMember().getMemberId());
        if(slayerInfo == null) {
            slayerInfo = new SlayerInfo();
            slayerInfo.setMemberId(partyService.getLocalMember().getMemberId());
        }

        String initialAmount = configManager.getRSProfileConfiguration("slayer", "initialAmount");
        String taskLocation = configManager.getRSProfileConfiguration("slayer", "taskLocation");

        log.debug("PPD:: Slayer task left: " + amount);
        slayerInfo.setAmount(Integer.parseInt(amount));

        if(slayerInfo.getSlayerTask() == null || !taskName.equals(slayerInfo.getSlayerTask().getName())) {
            log.debug("PPD:: Slayer task name: " + taskName);
            slayerInfo.setSlayerTask(SlayerTask.getTask(taskName));
        }

        if(!Strings.isNullOrEmpty(initialAmount)) {
            log.debug("PPD:: Slayer task start: " + initialAmount);
            slayerInfo.setInitialAmount(Integer.parseInt(initialAmount));
        }

        if(!Strings.isNullOrEmpty(taskLocation)) {
            log.debug("PPD:: Slayer task location: " + taskLocation);
            slayerInfo.setLocation(taskLocation);
        }

        setSlayerInfo(slayerInfo);
        partyService.send(slayerInfo);
    }

    void clearSlayerState() {
        if(partyService.getLocalMember() == null) {
            return;
        }

        long localId = partyService.getLocalMember().getMemberId();

        if (localId != 0) {
            PartyStateInfo partyStateInfo = partyStateInfoMap.get(localId);
            if(partyStateInfo != null && partyStateInfo.getSlayerInfo() != null) {
                log.debug("PPD:: Removing slayer state");
                SlayerInfo slayerInfo = partyStateInfo.getSlayerInfo();
                slayerInfo.reset();
                partyService.send(slayerInfo);
            }
        } else {
            log.debug("PPD:: Null Local Member; Can't clear Slayer state");
        }
    }

    /*@Subscribe
    public void onHitsplatApplied(HitsplatApplied hitsplatApplied) {
        if(hitsplatApplied.getActor().equals(client.getLocalPlayer())) {

        } else if (hitsplatApplied.getHitsplat().) {

        }
    }*/
}

/*
 * Copyright (c) 2018, PandahRS <https://github.com/PandahRS>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.projectilerage.runelite.partyplay;

/*
Entire file copied from built-in Discord plugin. All credit goes to the creator(s).
*/

enum AreaType
{
	BOSSES,
	CITIES,
	DUNGEONS,
	MINIGAMES,
	RAIDS,
	REGIONS
}

package com.projectilerage.runelite.partyplay;

import lombok.Data;

@Data
class PartyStateInfo {
    private ActivityInfo activityInfo;
    private SlayerInfo slayerInfo;

    PartyStateInfo(ActivityInfo activityInfo) {
        this.setActivityInfo(activityInfo);
    }

    PartyStateInfo(SlayerInfo slayerInfo) {
        this.setSlayerInfo(slayerInfo);
    }
}

/*
 * Copyright (c) 2019, Tomas Slusny <slusnucky@gmail.com>
 * Copyright (c) 2021, Jonathan Rousseau <https://github.com/JoRouss>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.projectilerage.runelite.partyplay;

import com.projectilerage.runelite.partyplay.ui.components.DynamicInfoBoxComponent;
import com.projectilerage.runelite.partyplay.ui.components.DynamicTextComponent;
import lombok.NonNull;
import net.runelite.api.MenuAction;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.party.PartyService;

import javax.inject.Inject;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

public class PartyOverlay extends OverlayPanel
{
    private final PartyPlayPlugin plugin;
    private final PartyState state;
    private final PartyService party;
    private final PartyPlayConfig config;

    private final Map<Long, SplitComponentWrapper>  splitMap = new HashMap<>();
    private final GameEventType longestEvent = GameEventType.REGION_DRILL_SERGEANT;

    private int width = 0;

    @Inject
    private PartyOverlay(final PartyPlayPlugin plugin, final PartyState state, final PartyService party, final PartyPlayConfig config)
    {
        super(plugin);
        this.plugin = plugin;
        this.state = state;
        this.party = party;
        this.config = config;
        this.setResizable(false);
        panelComponent.setBorder(new Rectangle());
        getMenuEntries().add(new OverlayMenuEntry(MenuAction.RUNELITE_OVERLAY, "Leave", "Party"));
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        final Map<Long, PartyStateInfo> partyDataMap = plugin.getPartyStateInfoMap();
        if (partyDataMap.isEmpty())
        {
            return new Dimension();
        }

        int width = graphics.getFontMetrics().stringWidth(longestEvent.getState());
        int height = graphics.getFontMetrics().getHeight() * 3;

        this.setPreferredSize(new Dimension(width, height));

        panelComponent.setBackgroundColor(null);

        synchronized (partyDataMap)
        {
            partyDataMap.forEach((uuid, stateInfo) ->
            {
                if(stateInfo == null || stateInfo.getActivityInfo() == null) {
                    return;
                }

                boolean isSelf = party.getLocalMember() != null && party.getLocalMember().getMemberId() == uuid;

                if (!config.includeSelf() && isSelf)
                {
                    return;
                }

               SplitComponentWrapper split = splitMap.get(uuid);

                if (split == null) {
                    split = new SplitComponentWrapper();
                    splitMap.put(uuid, split);
                }

                split.clearChildren();
                ActivityInfo activityInfo = stateInfo.getActivityInfo();

                final DynamicTextComponent name = DynamicTextComponent.builder()
                        .text(activityInfo.getUserId())
                        .color(config.recolorNames() ? ColorUtil.fromObject(activityInfo.getUserId()): Color.WHITE)
                        .build();
                split.firstPanel.getChildren().add(name);

                if(stateInfo.getActivityInfo().getActivity() != null) {
                    final DynamicTextComponent activity = DynamicTextComponent.builder()
                            .text(activityInfo.getActivity())
                            .color(ColorUtil.fromObject(activityInfo.getActivity()))
                            .build();
                    split.firstPanel.getChildren().add(activity);
                }

                if(stateInfo.getActivityInfo().getLocation() != null) {
                    final DynamicTextComponent location = DynamicTextComponent.builder()
                            .text(activityInfo.getLocation())
                            .color(ColorUtil.fromObject(activityInfo.getLocation()))
                            .build();
                    split.firstPanel.getChildren().add(location);
                }

                SlayerInfo slayerInfo = stateInfo.getSlayerInfo();

                if(slayerInfo != null && slayerInfo.getSlayerTask() != null && config.showSlayerActivity()) {
                    DynamicInfoBoxComponent box = plugin.getSlayerInfoBox(slayerInfo.getSlayerTask());

                    if(box != null) {
                        box.setText(Integer.toString(slayerInfo.getAmount()));
                        box.setBackgroundColor(null);
                        box.setTooltip(getSlayerTooltip(slayerInfo));
                        split.secondPanel.getChildren().add(box);
                    }
                }

                panelComponent.getChildren().add(split.split);
            });
        }

        return super.render(graphics);
    }

    static String getSlayerTooltip(@NonNull SlayerInfo slayerInfo) {
        String taskTooltip = ColorUtil.wrapWithColorTag("%s", new Color(157, 8, 8)) + "</br>";
        if (slayerInfo.getLocation() != null && !slayerInfo.getLocation().isEmpty())
        {
            taskTooltip += slayerInfo.getLocation() + "</br>";
        }

        if (slayerInfo.getInitialAmount() > 0)
        {
            taskTooltip += "</br>"
                    + ColorUtil.wrapWithColorTag("Start:", Color.YELLOW)
                    + " " + slayerInfo.getInitialAmount();
        }

        return String.format(taskTooltip, slayerInfo.getSlayerTask().getName());
    }
}

package com.projectilerage.runelite.partyplay;

import lombok.Data;
import lombok.EqualsAndHashCode;
import net.runelite.client.party.messages.PartyMemberMessage;

@Data
@EqualsAndHashCode(callSuper = false)
class SlayerInfo  extends PartyMemberMessage {
    private SlayerTask slayerTask;
    private String location;
    private int initialAmount;
    private int amount;

    void reset() {
        slayerTask = null;
        location = null;
        initialAmount = 0;
        amount = 0;
    }
}

package com.projectilerage.runelite.partyplay;

import com.projectilerage.runelite.partyplay.ui.components.DynamicPanelComponent;
import com.projectilerage.runelite.partyplay.ui.Padding;
import com.projectilerage.runelite.partyplay.ui.components.DynamicSplitComponent;
import net.runelite.client.ui.overlay.components.*;
import net.runelite.client.ui.overlay.components.ComponentOrientation;

import java.awt.*;

class SplitComponentWrapper {
    final DynamicSplitComponent split;
    final DynamicPanelComponent firstPanel;
    final DynamicPanelComponent secondPanel;

    SplitComponentWrapper() {
        split = DynamicSplitComponent.builder()
                .orientation(ComponentOrientation.HORIZONTAL)
                .preferredSize(new Dimension(ComponentConstants.STANDARD_WIDTH * 11, ComponentConstants.STANDARD_WIDTH * 15))
                .build();
        firstPanel = new DynamicPanelComponent();
        firstPanel.setGap(new Point(0, ComponentConstants.STANDARD_BORDER / 2));
        split.setFirst(firstPanel);
        secondPanel = new DynamicPanelComponent();
        secondPanel.setPadding(new Padding(0,0,10,0));
        secondPanel.setBackgroundColor(null);
        secondPanel.setOrientation(ComponentOrientation.HORIZONTAL);
        split.setSecond(secondPanel);
    }

    void clearChildren() {
        firstPanel.getChildren().clear();
        secondPanel.getChildren().clear();
    }
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * Copyright (c) 2021, Jonathan Rousseau <https://github.com/JoRouss>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.projectilerage.runelite.partyplay;

import com.google.common.base.Strings;
import com.google.common.collect.ComparisonChain;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.party.PartyMember;
import net.runelite.client.party.PartyService;
import net.runelite.client.party.WSClient;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Duration;
import java.time.Instant;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/*
 * This class contains fundamentals from built-in Discord plugin's design and implementation.
 * Much of the credit goes to the creator(s) of that plugin.
*/
@Slf4j
@Singleton
class PartyState
{
    @Data
    private static class EventWithTime
    {
        private final GameEventType type;
        private Instant start;
        private Instant updated;
    }

    private final List<EventWithTime> events = Collections.synchronizedList(new LinkedList<>());
    private final PartyPlayConfig config;
    private final PartyPlayPlugin plugin;
    private final PartyService partyService;
    private final String defaultLocalPlayerName = "<unknown>";
    private final WSClient wsClient;

    private PartyPresence lastPresence = null;
    private String localPlayerName = defaultLocalPlayerName;

    @Inject
    private PartyState(
            final PartyPlayConfig config,
            final PartyPlayPlugin plugin,
            final PartyService partyService,
            final WSClient wsClient
            )
    {
        this.config = config;
        this.plugin = plugin;
        this.partyService = partyService;
        this.wsClient = wsClient;
    }

    void setLocalPlayerName(String name) {
        boolean shouldUpdate = false;
        if(Strings.isNullOrEmpty(name)) {
            if(this.localPlayerName.equals(this.defaultLocalPlayerName)) {
                log.debug("PPD:: setLocalPlayerName.null");
                if (this.partyService.getLocalMember() != null) {
                    log.debug("PPD:: setLocalPlayerName.memberId");
                    this.localPlayerName = String.valueOf(this.partyService.getLocalMember().getMemberId());
                } else {
                    log.debug("PPD:: setLocalPlayerName.default");
                    this.localPlayerName = defaultLocalPlayerName;
                }

                shouldUpdate = true;
            }
        } else {
            log.debug("PPD:: setLocalPlayerName.name");
            this.localPlayerName = name;
            shouldUpdate = true;
        }

        if(shouldUpdate) {
            log.debug("PPD:: setLocalPlayerName.shouldUpdate");
            if(lastPresence != null) {
                log.debug("PPD:: setLocalPlayerName.lastPresence");
                this.maybeSharePresence(lastPresence);
            } else {
                log.debug("PPD:: setLocalPlayerName.updatePresenceWithLatestEvent");
                this.updatePresenceWithLatestEvent();
            }
        }
    }

    /**
     * Reset state.
     */
    void reset()
    {
        log.debug("Resetting");
        events.clear();
        lastPresence = null;
        plugin.clearSlayerState();
    }

    void refresh() {
        log.debug("Refreshing: \n\t" + partyService.getLocalMember() + "\n\t" + lastPresence);
        maybeSharePresence(lastPresence, true);
    }

    /**
     * Trigger new discord state update.
     *
     * @param eventType discord event type
     */
    void triggerEvent(final GameEventType eventType)
    {
        if(eventType == null) {
            log.error("Tried to pass null event type");
            log.error(Thread.currentThread().getStackTrace().toString());
            return;
        }

        final Optional<EventWithTime> foundEvent = events.stream().filter(e -> e.type == eventType).findFirst();
        final EventWithTime event;

        if (foundEvent.isPresent())
        {
            event = foundEvent.get();
        }
        else
        {
            event = new EventWithTime(eventType);
            event.setStart(Instant.now());
            events.add(event);
        }

        event.setUpdated(Instant.now());

        if (event.getType().isShouldClear())
        {
            log.debug("Clearing events");
            events.removeAll(events.parallelStream().filter(e -> e.getType() != eventType && e.getType().isShouldBeCleared()).collect(Collectors.toList()));
        }

        if (event.getType().isShouldRestart())
        {
            event.setStart(Instant.now());
        }

        events.sort((a, b) -> ComparisonChain.start()
                .compare(b.getType().getPriority(), a.getType().getPriority())
                .compare(b.getUpdated(), a.getUpdated())
                .result());

        updatePresenceWithLatestEvent();
    }

    private void updatePresenceWithLatestEvent()
    {
        if (events.isEmpty())
        {
            reset();
            return;
        }

        final EventWithTime event = events.get(0);

        String activity = null;
        String area = null;
        GameEventType activityEvent = null;
        GameEventType areaEvent = null;


        for (EventWithTime eventWithTime : events)
        {
            GameEventType eventType = eventWithTime.getType();

            if(activity == null) {
                if(eventType.getAreaType() == null) {
                    if(eventType.getState() != null) {
                        activity = eventType.getState();
                    } else {
                        activity = eventType.getDetails();
                    }

                    activityEvent = eventType;
                }
            }

            if(area == null) {
                if(eventType.getAreaType() != null) {
                    area = eventType.getState();
                    areaEvent = eventType;
                }
            }

            if(activity != null && area != null) {
                break;
            }
        }

        final PartyPresence presence = PartyPresence.builder()
                .activity(activity)
                .area(area)
                .activityEvent(activityEvent)
                .areaEvent(areaEvent)
                .build();

        maybeSharePresence(presence);
        lastPresence = presence;
    }

    private void maybeSharePresence(final PartyPresence presence) {
        maybeSharePresence(presence, false);
    }

    private void maybeSharePresence(final PartyPresence presence, boolean force)
    {
        if(presence == null) {
            return;
        }
        // This is to reduce amount of RPC calls
        if (force || !presence.equals(lastPresence) || !presence.getName().equals(this.localPlayerName))
        {
            PartyMember localMember = partyService.getLocalMember();
            if(localMember != null) {
                ActivityInfo.ActivityInfoBuilder infoBuild = ActivityInfo.builder();

                if(presence.getActivityEvent() == GameEventType.IN_MENU) {
                    if(config.showMainMenu()) {
                        infoBuild.activity(presence.getActivity());
                    }
                } else {
                    if(config.showSkillingActivity()) {
                        infoBuild.activity(presence.getActivity());
                    } else {
                        infoBuild.activity(GameEventType.IN_GAME.getState());
                    }
                }


                boolean showAreaType = false;

                if(presence.getAreaEvent() != null) {
                    switch(presence.getAreaEvent().getAreaType()) {
                        case RAIDS:
                            if(config.showRaidingActivity())
                                showAreaType = true;
                            break;
                        case BOSSES:
                            if(config.showBossActivity())
                                showAreaType = true;
                            break;
                        case CITIES:
                            if(config.showCityActivity())
                                showAreaType = true;
                            break;
                        case REGIONS:
                            if(config.showRegionsActivity())
                                showAreaType = true;
                            break;
                        case DUNGEONS:
                            if(config.showDungeonActivity())
                                showAreaType = true;
                            break;
                        case MINIGAMES:
                            if(config.showMinigameActivity())
                                showAreaType = true;
                            break;
                    }
                }

                if(showAreaType) {
                    infoBuild.location(presence.getArea());
                } else {
                    infoBuild.location("Gielinor");
                }

                String name = this.localPlayerName;
                infoBuild.userId(name);
                presence.setName(name);

                ActivityInfo info = infoBuild.build();
                info.setMemberId(localMember.getMemberId());
                partyService.send(info);
                plugin.setActivityInfo(info);
            }
        }
    }

    /**
     * Check for current state timeout and act upon it.
     */
    void checkForTimeout()
    {
        if (events.isEmpty())
        {
            log.debug("PPD:: Events is empty. Exiting timeouts check");
            return;
        }

        log.debug("PPD:: Checking for timeouts");

        final Duration actionTimeout = Duration.ofMinutes(config.actionTimeout());
        final Instant now = Instant.now();
        int initalLength = events.size();

        List<EventWithTime> eventsToRemove = events.parallelStream()
                // Find only events that should time out
                .filter(event -> event.getType().isShouldTimeout() && now.isAfter(event.getUpdated().plus(actionTimeout)))
                .collect(Collectors.toList());

        if(!eventsToRemove.isEmpty()) {
            events.removeAll(eventsToRemove);
            log.debug(events.size() - initalLength + " events removed. Updating");
            updatePresenceWithLatestEvent();
            if(eventsToRemove.parallelStream().anyMatch((event) -> event.getType() == GameEventType.TRAINING_SLAYER)) {
                log.debug("PPD:: Slayer event timed-out. Triggering slayer removal");
                plugin.clearSlayerState();
            }
        }
    }

    boolean containsEventType(GameEventType eventType) {
        return events.parallelStream().anyMatch((e) -> e.getType() == eventType);
    }
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.projectilerage.runelite.partyplay;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Units;

@ConfigGroup(PartyPlayConfig.GROUP)
public interface PartyPlayConfig extends Config
{
	String GROUP = "partyplay";

	@ConfigItem(
			keyName = "includeSelf",
			name = "Include yourself",
			description = "Shows yourself in the panel as part of the party",
			position = 1
	)
	default boolean includeSelf()
	{
		return false;
	}

	@ConfigItem(
			keyName = "recolorNames",
			name = "Recolor names",
			description = "Recolor party members names based on unique color hash",
			position = 2
	)
	default boolean recolorNames()
	{
		return true;
	}

	@ConfigItem(
		keyName = "actionTimeout",
		name = "Activity timeout",
		description = "Configures after how long of not updating activity will be reset (in minutes)",
		position = 3
	)
	@Units(Units.MINUTES)
	default int actionTimeout()
	{
		return 5;
	}

	@ConfigItem(
			keyName = "showSlayerActivity",
			name="Slayer",
			description = "Show/share slayer activity information e.g. Assigned monster + count",
			position = 4
	)
	default boolean showSlayerActivity() { return true; }

	@ConfigItem(
		keyName = "showMainMenu",
		name = "Main Menu",
		description = "Share status when in main menu",
		position = 5
	)
	default boolean showMainMenu()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showSkillActivity",
		name = "Skilling",
		description = "Show/share activity while training skills",
		position = 6
	)
	default boolean showSkillingActivity()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showBossActivity",
		name = "Bosses",
		description = "Show/share activity and location while at bosses",
		position = 7
	)
	default boolean showBossActivity()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showCityActivity",
		name = "Cities",
		description = "Show/share activity and location while in cities",
		position = 8
	)
	default boolean showCityActivity()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showDungeonActivity",
		name = "Dungeons",
		description = "Show/share activity and location while in dungeons",
		position = 9
	)
	default boolean showDungeonActivity()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showMinigameActivity",
		name = "Minigames",
		description = "Show/share activity and location while in minigames",
		position = 10
	)
	default boolean showMinigameActivity()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showRaidingActivity",
		name = "Raids",
		description = "Show/share activity and location while in Raids",
		position = 11
	)
	default boolean showRaidingActivity()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showRegionsActivity",
		name = "Regions",
		description = "Show/share activity and location while in other regions",
		position = 12
	)
	default boolean showRegionsActivity()
	{
		return true;
	}
}

package com.projectilerage.runelite.partyplay;

import lombok.Builder;
import lombok.Data;
import lombok.EqualsAndHashCode;
import net.runelite.client.party.messages.PartyMemberMessage;

@Data
@EqualsAndHashCode(callSuper = false)
@Builder
class ActivityInfo extends PartyMemberMessage
{
    private final String userId;
    private final String activity;
    private final String location;
}
package com.projectilerage.runelite.partyplay.ui;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.awt.*;

@Data
@AllArgsConstructor
public class Padding {
    private int top;
    private int bottom;
    private int left;
    private int right;

    Padding(Dimension dimension) {
        int indivHeight = dimension.height / 2;
        int indivWidth = dimension.width / 2;
        top = indivHeight;
        bottom = indivHeight;
        left = indivWidth;
        right = indivWidth;
    }

    public int getVertical() {
        return top + bottom;
    }

    public int getHorizontal() {
        return left + right;
    }
}

package com.projectilerage.runelite.partyplay.ui.components;

import lombok.Builder;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.config.FontType;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.TextComponent;

import java.awt.*;


@Builder
@Setter
public class DynamicTextComponent implements LayoutableRenderableEntity {
    private String text;

    @Builder.Default
    private Color color = Color.WHITE;

    @Builder.Default
    private Font font = FontType.REGULAR.getFont();

    @Builder.Default
    private Point preferredLocation = new Point();

    @Builder.Default
    private Dimension preferredSize = new Dimension(ComponentConstants.STANDARD_WIDTH, 0);

    @Builder.Default
    @Getter
    private final Rectangle bounds = new Rectangle();

    @Override
    public Dimension render(Graphics2D graphics)
    {
        final int baseX = preferredLocation.x;
        final int baseY = preferredLocation.y;
        final FontMetrics metrics = graphics.getFontMetrics(font);
        final TextComponent textComponent = new TextComponent();
        final int x = Math.max(baseX, baseX + ((preferredSize.width - metrics.stringWidth(text)) / 2));
        final int y = baseY + metrics.getHeight();

        textComponent.setFont(font);
        textComponent.setText(text);
        textComponent.setColor(color);
        textComponent.setPosition(new Point(x, y));
        final Dimension dimension = textComponent.render(graphics);

        bounds.setLocation(preferredLocation);
        bounds.setSize(new Dimension(dimension.width + (x - baseX) * 2, dimension.height));
        return bounds.getSize();
    }
}

package com.projectilerage.runelite.partyplay.ui.components;

import com.projectilerage.runelite.partyplay.ui.Padding;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.overlay.components.*;
import net.runelite.client.ui.overlay.components.ComponentOrientation;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class DynamicPanelComponent extends PanelComponent {
    @Getter
    private final Rectangle bounds = new Rectangle();

    @Setter
    private Padding padding = new Padding(0, 0, 0, 0);

    @Setter
    private Point preferredLocation = new Point();

    @Setter
    @Getter
    private Dimension preferredSize = new Dimension(ComponentConstants.STANDARD_WIDTH, 0);

    @Setter
    @Getter
    private Color backgroundColor = ComponentConstants.STANDARD_BACKGROUND_COLOR;

    @Getter
    private final List<LayoutableRenderableEntity> children = new ArrayList<>();

    @Setter
    private ComponentOrientation orientation = ComponentOrientation.VERTICAL;

    @Setter
    private Rectangle border = new Rectangle(
            ComponentConstants.STANDARD_BORDER,
            ComponentConstants.STANDARD_BORDER,
            ComponentConstants.STANDARD_BORDER,
            ComponentConstants.STANDARD_BORDER);

    @Setter
    private Point gap = new Point(0, 0);

    private final Dimension cachedDimensions = new Dimension();

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (children.isEmpty())
        {
            return new Dimension(0, 0);
        }

        int prefWidth = Math.max(preferredSize.width, this.cachedDimensions.width);
        int prefHeight = Math.max(preferredSize.height, this.cachedDimensions.height);

        // Render background
        if (backgroundColor != null)
        {
            final BackgroundComponent backgroundComponent = new BackgroundComponent();
            backgroundComponent.setRectangle(new Rectangle(preferredLocation, new Dimension(prefWidth, prefHeight)));
            backgroundComponent.setBackgroundColor(backgroundColor);
            backgroundComponent.render(graphics);
        }

        // Offset children
        final int baseX = preferredLocation.x + border.x + padding.getLeft();
        final int baseY = preferredLocation.y + border.y + padding.getTop();
        int totalHorizontalOffset = border.x + border.width + padding.getHorizontal();
        int totalVerticalOffset = border.y + border.height + padding.getVertical();
        int width = 0;
        int height = 0;
        int x = baseX;
        int y = baseY;

        // Create child preferred size
        final Dimension childPreferredSize = new Dimension(
                prefWidth - totalHorizontalOffset,
                prefHeight - totalVerticalOffset);

        // Calculate max width/height for infoboxes
        int totalHeight = 0;
        int totalWidth = 0;

        // Render all children
        for (final LayoutableRenderableEntity child : children)
        {
            // Correctly propagate child dimensions based on orientation and wrapping
            switch (orientation)
            {
                case VERTICAL:
                    child.setPreferredSize(new Dimension(childPreferredSize.width, 0));
                    break;
                case HORIZONTAL:
                    child.setPreferredSize(new Dimension(0, childPreferredSize.height));
                    break;
            }

            child.setPreferredLocation(new Point(x, y));
            final Dimension childDimension = child.render(graphics);

            if(orientation == ComponentOrientation.VERTICAL) {
                height += childDimension.height + gap.y;
                y = baseY + height;

                width = Math.max(childDimension.width, width);
            } else {
                width += childDimension.width + gap.x;
                x = baseX + width;

                height = Math.max(childDimension.height, height);
            }



            // Calculate total size
            totalWidth = Math.max(totalWidth, width);
            totalHeight = Math.max(totalHeight, height);
        }

        // Remove last child gap
        if (orientation == ComponentOrientation.HORIZONTAL)
        {
            totalWidth -= gap.x;
        }
        else // VERTICAL
        {
            totalHeight -= gap.y;
        }

        totalWidth += totalHorizontalOffset;
        totalHeight += totalVerticalOffset;

        // Cache children bounds
        this.cachedDimensions.setSize(totalWidth, totalHeight);
        // Calculate panel dimension

        // Cache bounds
        bounds.setLocation(preferredLocation);
        bounds.setSize(totalWidth, totalHeight);

        return bounds.getSize();
    }
}

package com.projectilerage.runelite.partyplay.ui.components;

import com.google.common.base.Strings;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.components.BackgroundComponent;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import java.awt.*;
import java.awt.image.BufferedImage;

@Setter
public class DynamicInfoBoxComponent implements LayoutableRenderableEntity
{
    private static final int DEFAULT_SIZE = 32;

    private final TooltipManager tooltipManager;
    private final Client client;

    @Getter
    private String tooltip;

    @Getter
    private final Rectangle bounds = new Rectangle();

    private Point preferredLocation = new Point();

    private Dimension preferredSize = new Dimension(DEFAULT_SIZE, DEFAULT_SIZE);

    private String text;

    private Color color = Color.WHITE;

    private Font font = FontManager.getDefaultFont();

    private boolean outline;

    private Color backgroundColor = ComponentConstants.STANDARD_BACKGROUND_COLOR;

    private BufferedImage image;

    public DynamicInfoBoxComponent(Client client, TooltipManager tooltipManager) {
        this.client = client;
        this.tooltipManager = tooltipManager;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (image == null)
        {
            return new Dimension();
        }

        graphics.setFont(getSize() < DEFAULT_SIZE ? FontManager.getRunescapeSmallFont() : font);
        final int baseX = preferredLocation.x;
        final int baseY = preferredLocation.y;
        final int width = Math.max(image.getWidth(), preferredSize.width);
        final int height = Math.max(image.getHeight(), preferredSize.height);
        final int calcX = Math.max(baseX, baseX + (width - image.getWidth(null)) / 2);
        final int calcY = Math.max(baseY, baseY + (height - image.getHeight(null)) / 2);

        final Rectangle bounds = new Rectangle(baseX, baseY, width, height);

        // Render background
        if(backgroundColor != null) {
            final BackgroundComponent backgroundComponent = new BackgroundComponent();
            backgroundComponent.setBackgroundColor(backgroundColor);
            backgroundComponent.setRectangle(bounds);
            backgroundComponent.render(graphics);
        }

        // Render image
        graphics.drawImage(
                image,
                calcX,
                calcY,
                null);

        // Render caption
        if (!Strings.isNullOrEmpty(text))
        {
            int y = calcY + image.getHeight();
            int x = (calcX + image.getWidth() / 2) - graphics.getFontMetrics().stringWidth(text) / 2;

            final TextComponent textComponent = new TextComponent();
            textComponent.setColor(color);
            textComponent.setOutline(outline);
            textComponent.setFont(graphics.getFont());
            textComponent.setText(text);
            textComponent.setPosition(new Point(x, y));
            textComponent.render(graphics);
        }

        this.bounds.setBounds(bounds);

        if(!Strings.isNullOrEmpty(tooltip)) {
            // Handle tooltips
            final Point mouse = new Point(client.getMouseCanvasPosition().getX(), client.getMouseCanvasPosition().getY());
            // Create intersection rectangle
            Rectangle intersectionRectangle = new Rectangle(getBounds());
            intersectionRectangle.translate(Math.abs(graphics.getClipBounds().x), Math.abs(graphics.getClipBounds().y));

            if (intersectionRectangle.contains(mouse))
            {
                tooltipManager.add(new Tooltip(tooltip));
            }
        }

        return bounds.getSize();
    }

    private int getSize()
    {
        return Math.max(preferredSize.width, preferredSize.height);
    }
}

package com.projectilerage.runelite.partyplay.ui.components;

import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;

import java.awt.*;

class PaddingComponent implements LayoutableRenderableEntity {
    @Setter
    private Dimension padding = new Dimension();

    @Setter
    private Point preferredLocation;

    @Setter
    private Dimension preferredSize;

    @Getter
    private Rectangle bounds;

    PaddingComponent(Dimension padding) {
        this.padding = padding;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        this.bounds = new Rectangle(preferredLocation, padding);
        return padding;
    }
}

package com.projectilerage.runelite.partyplay.ui.components;

import lombok.Builder;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.ComponentOrientation;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;

import java.awt.*;

@Setter
@Builder
public class DynamicSplitComponent implements LayoutableRenderableEntity
{
    @Getter
    private LayoutableRenderableEntity first;

    @Getter
    private LayoutableRenderableEntity second;

    @Builder.Default
    private Point preferredLocation = new Point();

    @Builder.Default
    private Dimension preferredSize = new Dimension(ComponentConstants.STANDARD_WIDTH, 0);

    @Builder.Default
    private ComponentOrientation orientation = ComponentOrientation.VERTICAL;

    @Builder.Default
    private Point gap = new Point(0, 0);

    @Builder.Default
    @Getter
    private final Rectangle bounds = new Rectangle();

    @Override
    public Dimension render(Graphics2D graphics)
    {
        first.setPreferredLocation(preferredLocation);
        first.setPreferredSize(preferredSize);

        final Dimension firstDimension = first.render(graphics);
        int x = 0, y = 0;

        if (orientation == net.runelite.client.ui.overlay.components.ComponentOrientation.VERTICAL)
        {
            y = firstDimension.height + gap.y;
            preferredSize.width = Math.max(firstDimension.width, preferredSize.width);
        }
        else
        {
            x = firstDimension.width + gap.x;
            preferredSize.height = Math.max(firstDimension.height, preferredSize.height);
        }

        second.setPreferredLocation(new Point(x + preferredLocation.x, y + preferredLocation.y));
        // Make the second component fit to whatever size is left after the first component is rendered
        second.setPreferredSize(new Dimension(preferredSize.width - x, preferredSize.height - y));

        // The total width/height need to be determined as they are now always the same as the
        // individual width/height (for example image width/height will just be the height of the image
        // and not the height of the area the image is in
        final Dimension secondDimension = second.render(graphics);
        int totalWidth, totalHeight;

        if (orientation == ComponentOrientation.VERTICAL)
        {
            totalWidth = Math.max(firstDimension.width, secondDimension.width);
            totalHeight = y + secondDimension.height;
        }
        else
        {
            totalHeight = Math.max(firstDimension.height, secondDimension.height);
            totalWidth = x + secondDimension.width;
        }

        final Dimension dimension = new Dimension(totalWidth, totalHeight);
        bounds.setLocation(preferredLocation);
        bounds.setSize(dimension);
        return dimension;
    }
}

package com.projectilerage.runelite.partyplay;

import lombok.*;

@Setter
@Getter
@Builder
@EqualsAndHashCode
class PartyPresence {
    private String name;

    private String activity;
    private String area;


    private GameEventType activityEvent;
    private GameEventType areaEvent;

}

