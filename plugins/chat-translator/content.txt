package com.chattranslator;

import lombok.Getter;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/**
 * A data holder for information extracted from the chat used for translation.
 *
 * @version January 2021
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 */
public class ChatLineData {

    /**
     * The RuneScape name of the player being translated
     */
    private String rsn;

    /**
     * The chat line text being translated.
     * -- GETTER --
     *

     */
    @Getter
    private final String chatLine;

    /**
     * Whether the chat line text was sent by the local player.
     */
    private final boolean isLocalPlayer;

    /**
     * Store chatline data
     *
     * @param rsn - the runescape name of the player who sent the message (or null)
     * @param chatLine - the text on the chatline
     * @param isLocalPlayer - whether the chatline came from the local player
     */
    public ChatLineData(@Nullable String rsn, @Nonnull String chatLine, boolean isLocalPlayer) {
        this.rsn = rsn;
        this.chatLine = chatLine;
        this.isLocalPlayer = isLocalPlayer;
    }

    /**
     * Return whether the message was (probably) sent by the system, not a player.
     *
     * @return true if the message was not sent by a player, false otherwise
     */
    public boolean isGameMessage() {
        return this.rsn == null;
    }

    /**
     * Return whether the message was sent by a player.
     *
     * @return true if the message was sent by a player, false otherwise
     */
    public boolean isSaidByPlayer() {
        return this.rsn != null;
    }

    /**
     * Return whether the message was sent by the local player.
     *
     * @return true if the message was sent by the local player, false otherwise
     */
    public boolean isSaidByLocalPlayer() {
        return this.isLocalPlayer;
    }

    /**
     * @return the runescape name of the player being translated
     */
    public @Nullable
    String getRSN() {
        return this.rsn;
    }

    /**
     * Fixes the RuneScape Name for messages exclusively in the Private Chat filter. These messages only appear to start with "From RSN: Message" or "To RSN: Message" only when the user is currently filtering the private chat.
     */
    public void fixRsnForPMFilter() {
        if (this.rsn.startsWith("To ")) {
            this.rsn = this.rsn.substring(3);
        } else if (this.rsn.startsWith("From ")) {
            this.rsn = this.rsn.substring(5);
        }
    }
}
package com.chattranslator;

import com.chattranslator.data.GetSupportedLanguagesResponseList;
import com.chattranslator.data.TranslateTextResponseList;
import com.chattranslator.ex.GoogleAPIException;
import com.chattranslator.ex.GoogleAuthenticationException;
import com.chattranslator.ex.GoogleException;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.nio.charset.StandardCharsets;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * A utility class to use the Google Translate API.
 *
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 * @version January 2021
 */
@Singleton
@Slf4j
public class ChatTranslator {

    /**
     * The configuration of the plugin.
     */
    @Inject
    private ChatTranslatorConfig config;

    /**
     * An HTTP Client to access the Google Translate API.
     */
    @Inject
    private OkHttpClient client;

    /**
     * The list of supported languages by Google Translate API.
     */
    private GetSupportedLanguagesResponseList supportedLanguages = null;

    /**
     * Whether the user is authenticated.
     * -- GETTER --
     *

     */
    @Getter
    private boolean authenticated = false;

    /**
     * Un-authenticate your credentials. This clears saved config and any session data used for chat translation.
     */
    public void unauthenticate() {
        config.apiKey(null); // Clear config
        this.authenticated = false;
    }

    /**
     * Authenticate using an API Key.
     *
     * @param apiKey - the data used for authentication
     * @throws GoogleAuthenticationException on authentication failure
     */
    public void authenticate(String apiKey) throws GoogleAuthenticationException {
        try {
            log.debug("Google Cloud Platform: Sending request for supported languages");
            final Request req = new Request.Builder()
                    .method("GET", null)
                    .url("https://translation.googleapis.com/language/translate/v2/languages?target=en&key=" + apiKey)
                    .build();

            Response response = client.newCall(req).execute();
            String responseSource = new String(response.body().bytes(), StandardCharsets.UTF_8);
            log.debug("Response:\n" + responseSource);
            log.debug("Google Cloud Platform: Received response");
            if (response.code() != 200) {
                throw new GoogleAuthenticationException("Google returned code " + response.code());
            }

            JsonParser parser = new JsonParser();
            JsonObject dom = parser.parse(responseSource).getAsJsonObject();
            JsonElement data = dom.get("data");
            this.supportedLanguages = GetSupportedLanguagesResponseList.fromJSON(data);
            log.debug("Supported languages:\n" +
                    Stream.of(supportedLanguages.languages)
                            .map(lang -> "\t" + lang.language + " - " + lang.name)
                            .collect(Collectors.joining("\n")));

            config.apiKey(apiKey);
            this.authenticated = true;
            log.info("Chat Translator authentication successful.");
        } catch (Exception e) {
            throw new GoogleAuthenticationException("Invalid Google Cloud Platform service account credentials", e);
        }
    }

    /**
     * Authenticate using previously saved configuration data.
     *
     * @throws GoogleAuthenticationException on authentication failure
     */
    public void authenticateFromConfig() throws GoogleAuthenticationException {
        if (this.config.apiKey() == null) {
            return;
        }
        authenticate(config.apiKey());
    }

    /**
     * Translate text from a source language to a target language.
     *
     * @param text           - the text to translate
     * @param sourceLanguage - the source language's code, e.g. 'en' (English)
     * @param targetLanguage - the target language' code, e.g. 'da' (Danish)
     * @return the translated text
     * @throws GoogleException on call failure
     */
    public TranslateTextResponseList translate(@Nonnull String text, @Nullable String sourceLanguage, @Nonnull String targetLanguage) throws GoogleException {
        if (!authenticated) {
            throw new GoogleAuthenticationException("You are not authenticated for Chat Translation.");
        }
        try {
            // Build request body
            JsonObject requestJson = new JsonObject();
            if (sourceLanguage != null) {
                requestJson.addProperty("source", sourceLanguage);
            }
            requestJson.addProperty("target", targetLanguage);
            requestJson.addProperty("q", text);
            log.debug("Request body: " + requestJson);
            RequestBody requestBody = RequestBody.create(
                    MediaType.parse("application/json"), requestJson.toString());

            // Build request
            log.debug("Google Cloud Platform: Sending request for translation");
            final Request req = new Request.Builder()
                    .method("POST", requestBody)
                    .header("Content-Type", "application/json")
                    .url("https://translation.googleapis.com/language/translate/v2?key=" + config.apiKey())
                    .build();

            Response response = client.newCall(req).execute();
            String responseSource = new String(response.body().bytes(), StandardCharsets.UTF_8);
            log.debug("Response:\n" + responseSource);
            log.debug("Google Cloud Platform: Received response");
            if (response.code() != 200) {
                throw new GoogleAuthenticationException("Google returned code " + response.code());
            }

            JsonParser parser = new JsonParser();
            JsonObject dom = parser.parse(responseSource).getAsJsonObject();
            JsonElement data = dom.get("data");

            TranslateTextResponseList translationList;
            if (sourceLanguage == null) {
                translationList = TranslateTextResponseList.fromJSONImplicit(data);
            } else {
                translationList = TranslateTextResponseList.fromJSONExplicit(data, sourceLanguage);
            }

            if (!translationList.isEmpty()) {
                log.debug("Translations returned:\n" +
                        Stream.of(translationList.translations)
                                .map(translation -> "\t" + translation.detectedSourceLanguage + " - " + translation.translatedText)
                                .collect(Collectors.joining("\n")));
            }
            return translationList;
        } catch (Exception e) {
            throw new GoogleAPIException("API call failed. Try again or re-authenticate.", e);
        }
    }

    /**
     * Returns a list of supported languages by the Google Translate API.
     *
     * @return a list of supported translation languages
     * @throws GoogleException on call failure
     */
    public GetSupportedLanguagesResponseList getSupportedLanguages() throws GoogleException {
        if (authenticated) {
            return this.supportedLanguages;
        } else {
            throw new GoogleAuthenticationException("You are not authenticated for Chat Translation.");
        }
    }
}

package com.chattranslator;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.awt.Color;

/**
 * Configuration for the {@link ChatTranslatorPlugin}.
 *
 * @version January 2021
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 */
@ConfigGroup("chattranslator")
public interface ChatTranslatorConfig extends Config {

    /*
        HIDDEN CONFIGURATION BEGINS HERE
     */
    /**
     * An API key for Google Cloud Platform which has access to the Google Translate API.
     *
     * @return a Google Cloud Platform API key
     */
    @ConfigItem(
            keyName = "apiKey",
            name = "API Key",
            description = "An API Key for Google Cloud Platform used to authenticate to the Google Translate API.",
            secret = true,
            hidden = true // change to false for easier debugging!
    )
    default String apiKey() {
        return null;
    }
    @ConfigItem(
            keyName = "apiKey",
            name = "API Key",
            description = "An API Key for Google Cloud Platform used to authenticate to the Google Translate API."
    )
    void apiKey(String str);
    @ConfigItem(
            keyName = "targetLangCode",
            name = "Target Language Code",
            description = "The language transcribed to as a corresponding 2 letter code, e.g. 'da' (Danish)",
            hidden = true // change to false for easier debugging!
    )
    default String lastTargetLanguageCode() {
        // Lala <3
        return "da";
    }
    @ConfigItem(
            keyName = "targetLangCode",
            name = "Target Language Code",
            description = "The language transcribed to as a corresponding 2 letter code, e.g. 'da' (Danish)"
    )
    void lastTargetLanguageCode(String languageCode);
    @ConfigItem(
            keyName = "targetLangName",
            name = "Target Language Name",
            description = "The language transcribed to",
            hidden = true // change to false for easier debugging!
    )
    default String lastTargetLanguageName() {
        // Lala <3
        return "Danish";
    }
    @ConfigItem(
            keyName = "targetLangName",
            name = "Target Language Name",
            description = "The language transcribed to"
    )
    void lastTargetLanguageName(String languageName);

    @ConfigItem(
            keyName = "sourceLangCode",
            name = "Source Language Code",
            description = "The language transcribed to as a corresponding 2 letter code, e.g. 'en' (English)",
            hidden = true // change to false for easier debugging!
    )
    default String lastSourceLanguageCode() {
        return "en";
    }
    @ConfigItem(
            keyName = "sourceLangCode",
            name = "Source Language Code",
            description = "The language transcribed to as a corresponding 2 letter code, e.g. 'en' (English)"
    )
    void lastSourceLanguageCode(String languageCode);
    @ConfigItem(
            keyName = "sourceLangName",
            name = "Source Language Name",
            description = "The language transcribed to",
            hidden = true // change to false for easier debugging!
    )
    default String lastSourceLanguageName() {
        return "English";
    }
    @ConfigItem(
            keyName = "sourceLangName",
            name = "Source Language Name",
            description = "The language transcribed to"
    )
    void lastSourceLanguageName(String languageName);


    /*
        VISIBLE CONFIGURATION STARTS HERE
     */

    // DISPLAY OPTIONS
    @ConfigSection(
            position = 1,
            name = "Translation",
            description = "How translation is performed"
    )
    String translateSection = "translateSection";
    @ConfigItem(
            keyName = "standardTranslate",
            name = "Standard translation",
            description = "Enables a right click option to translate chatlines from source to target language",
            section = "translateSection"
    )
    default boolean isStandardTranslationEnabled() {
        return true;
    }
    @ConfigItem(
            keyName = "reverseTranslate",
            name = "Reverse translation",
            description = "Enables a right click option to translate chatlines from target to source language",
            section = "translateSection",
            hidden = true // This feature is TODO
    )
    default boolean isReverseTranslationEnabled() {
        return false;
    }

    // DISPLAY OPTIONS
    @ConfigSection(
            position = 2,
            name = "Display",
            description = "Determines how translations are shown"
    )
    String displaySection = "displaySection";

    @ConfigItem(
            keyName = "previewChatInput",
            name = "Preview input translations",
            description = "In addition to translating to the chatbox, also show a preview of the translation in the chat input when translating unsent input",
            section = "displaySection"
    )
    default boolean isPreviewingChatInput() {
        return true;
    }
    @ConfigItem(
            keyName = "showDetectedLanguages",
            name = "Show source language",
            description = "Shows the source/detected language during translation",
            section = "displaySection"
    )
    default boolean isShowingDetectedLanguages() {
        return true;
    }
    @ConfigItem(
            keyName = "isTranslationHighlighted",
            name = "Highlight translated lines?",
            description = "Whether translated lines should be highlighted",
            section = "displaySection"
    )
    default boolean isTranslationHighlighted() {
        return true;
    }

    @ConfigItem(
            keyName = "sourceLangColor",
            name = "Source Language Color",
            description = "The hightlight color of the source language",
            section = "displaySection"
    )
    default Color sourceLangColor() {
        return new Color(0xff, 0xA4, 0x00);
    }

    @ConfigItem(
            keyName = "targetLangColor",
            name = "Target Language Color",
            description = "The hightlight color of the target language",
            section = "displaySection"
    )
    default Color targetLangColor() {
        return new Color(0xCE, 0x68, 0xFF);
    }
}

package com.chattranslator;

import lombok.Getter;
import net.runelite.client.util.ColorUtil;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/**
 * Used to store metadata passed for translation.
 *
 * @version January 2021
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 */
public class ChatTranslatorMenuEntry {

    /**
     * What the menu entry says when a valid source language and target language are specified.
     */
    private static final String EXPLICIT_TRANSLATION_FORMAT = "Translate from %s to %s";

    /**
     * What the menu entry says when a valid target language is specified.
     */
    private static final String IMPLICIT_TRANSLATION_FORMAT = "Translate to %s";

    /**
     * The plugin configuration
     */
    private final ChatTranslatorConfig config;

    /**
     * The code of the source language used, e.g. en
     */
    private @Nullable String sourceLanguageCode;
    /**
     * The name of the source language used, e.g. English
     */
    private @Nullable String sourceLanguageName;

    /**
     * The code of the target language used, e.g. da
     */
    private String targetLanguageCode;
    /**
     * The name of the target language used, e.g. Danish
     */
    private String targetLanguageName;

    /**
     * The data being used for translation in this menu option.
     * -- GETTER --
     *

     */
    @Getter
    private ChatLineData chatLineData;

    /**
     * Construct a translation menu entry.
     *
     * @param config - the plugin config
     */
    public ChatTranslatorMenuEntry(ChatTranslatorConfig config) {
        this.config = config;
        this.sourceLanguageCode = null;
        this.sourceLanguageName = null;
        this.targetLanguageCode = null;
        this.targetLanguageName = null;
        this.chatLineData = null;
    }

    /**
     * Set the data being used in translation for this menu entry.
     *
     * @param chatLineData - the data being used for translation
     */
    public void setChatLineData(ChatLineData chatLineData) {
        this.chatLineData = chatLineData;
    }

    /**
     * Set the source language. Null indicates auto-detect language.
     *
     * @param languageCode - the language's code to translate from, e.g. 'en'
     * @param languageName - the language's name to translate from, e.g. 'English'
     */
    public void setSourceLanguage(@Nullable String languageCode, @Nullable String languageName) {
        this.sourceLanguageCode = languageCode;
        this.sourceLanguageName = languageName;
    }

    /**
     * Set the target language for translation.
     *
     * @param languageCode - the language's code to translate from, e.g. 'da'
     * @param languageName - the language's name to translate from, e.g. 'Danish'
     */
    public void setTargetLanguage(@Nonnull String languageCode, @Nonnull String languageName) {
        this.targetLanguageCode = languageCode;
        this.targetLanguageName = languageName;
    }

    /**
     * @return the source language code, e.g. 'en' (English)
     */
    public @Nullable
    String getSourceLanguageCode() {
        return sourceLanguageCode;
    }

    /**
     * @return the target language code, e.g. 'da' (Danish)
     */
    public @Nonnull
    String getTargetLanguageCode() {
        return targetLanguageCode;
    }

    /**
     * Return the menu entry option text. Should say something such as "Translate English to Danish" or "Translate to Danish".
     *
     * @return the menu entry option text
     * @see #EXPLICIT_TRANSLATION_FORMAT
     * @see #IMPLICIT_TRANSLATION_FORMAT
     */
    public String getOption() {
        String menuOption;
        if (this.sourceLanguageCode == null) {
            String langName = this.targetLanguageName;
            if (config.isTranslationHighlighted()) {
                if (this.targetLanguageCode.equalsIgnoreCase(config.lastTargetLanguageCode())) {
                    langName = ColorUtil.wrapWithColorTag(langName, config.targetLangColor());
                } else if (this.targetLanguageCode.equalsIgnoreCase(config.lastSourceLanguageCode())) {
                    langName = ColorUtil.wrapWithColorTag(langName, config.sourceLangColor());
                }
            }
            menuOption = String.format(IMPLICIT_TRANSLATION_FORMAT, langName);
        } else {
            String sLangName = this.sourceLanguageName;
            String tLangName = this.targetLanguageName;
            if (config.isTranslationHighlighted()) {
                if (this.sourceLanguageCode.equalsIgnoreCase(config.lastTargetLanguageCode())) {
                    sLangName = ColorUtil.wrapWithColorTag(sLangName, config.targetLangColor());
                } else if (this.sourceLanguageCode.equalsIgnoreCase(config.lastSourceLanguageCode())) {
                    sLangName = ColorUtil.wrapWithColorTag(sLangName, config.sourceLangColor());
                }
                if (this.targetLanguageCode.equalsIgnoreCase(config.lastTargetLanguageCode())) {
                    tLangName = ColorUtil.wrapWithColorTag(tLangName, config.targetLangColor());
                } else if (this.targetLanguageCode.equalsIgnoreCase(config.lastSourceLanguageCode())) {
                    tLangName = ColorUtil.wrapWithColorTag(tLangName, config.sourceLangColor());
                }
            }
            menuOption = String.format(EXPLICIT_TRANSLATION_FORMAT, sLangName, tLangName);
        }
        return menuOption;
    }

}

package com.chattranslator;

import com.chattranslator.data.TranslateTextResponseList;
import com.chattranslator.data.TranslateTextResponseTranslation;
import com.chattranslator.ex.GoogleAPIException;
import com.chattranslator.ex.GoogleException;
import com.chattranslator.ui.ChatTranslatorPanel;
import com.google.inject.Provides;

import javax.annotation.Nullable;
import javax.inject.Inject;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.events.*;
import net.runelite.api.vars.InputType;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * A plugin to translate chat text.
 *
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 * @version January 2021
 */
@Slf4j
@PluginDescriptor(
        name = "Chat Translator",
        description = "Translate chat messages from OldSchool RuneScape",
        tags = {"chat", "translator", "translate", "language"}
)
public class ChatTranslatorPlugin extends Plugin {

    /**
     * The navigation button on the toolbar which brings up the Chat Translator panel.
     */
    private NavigationButton navButton;

    /**
     * A menu entry buffer decorated to store translation data.
     */
    private ChatTranslatorMenuEntry menuEntry = null;

    /**
     * A buffer used to preview an interactive translation in the chat input.
     */
    private String previewTranslation = null;
    private String lastPreviewText = null;

    /**
     * The user interface panel.
     * -- GETTER --
     *

     */
    @Getter
    @Inject
    private ChatTranslatorPanel panel;

    /**
     * The game client.
     */
    @Inject
    private Client client;

    /**
     * The client thread.
     */
    @Inject
    private ClientThread clientThread;

    /**
     * The translator for the plugin.
     */
    @Inject
    private ChatTranslator translator;

    /**
     * The runelite side toolbar.
     */
    @Inject
    private ClientToolbar clientToolbar;

    /**
     * The config for the plugin.
     */
    @Inject
    private ChatTranslatorConfig config;

    @Provides
    private ChatTranslatorConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(ChatTranslatorConfig.class);
    }

    @Override
    protected void startUp() throws Exception {
        //If we have credentials, attempt to authenticate now.
        if (this.config.apiKey() != null) {
            try {
                this.translator.authenticateFromConfig();
            } catch (GoogleException e) {
                log.warn("Authentication from config failed", e);
                this.translator.unauthenticate(); // Clear auth if auth fails.
            }
        }

        // Initialize the panel
        this.panel = injector.getInstance(ChatTranslatorPanel.class);
        if (this.translator.isAuthenticated()) {
            this.panel.bodyPanel.langPanel.enableOptions(this.translator.getSupportedLanguages());
            this.loadLastSettings();
        } else {
            this.panel.bodyPanel.langPanel.disableOptions();
        }

        // Add the panel nav button to the client toolbar
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/panel_icon.png");
        this.navButton = NavigationButton.builder()
                .tooltip("Chat Translator")
                .icon(icon)
                .priority(7)
                .panel(this.panel)
                .build();
        // Add the nav button to the toolbar, which navigates to the chat translator panel
        this.clientToolbar.addNavigation(this.navButton);
    }

    @Override
    protected void shutDown() {
        // Remove the nav button from the toolbar
        this.clientToolbar.removeNavigation(this.navButton);
    }

    public void loadLastSettings() {
        // Load the last source language and target language into the language panel
        this.panel.bodyPanel.langPanel.setSourceLanguage(this.config.lastSourceLanguageCode());
        this.panel.bodyPanel.langPanel.setTargetLanguage(this.config.lastTargetLanguageCode());
    }

    @Subscribe
    public void onMenuOpened(MenuOpened event) {
        if (!this.config.isStandardTranslationEnabled()) return;

        if (isHoveringChatBoxWidget()) {
            // If the user isn't hovering their chat buffer or a message, end here
            if (!isHoveringChatInputWidget() && !isHoveringChatLineWidget()) {
                this.menuEntry = null;
                return;
            }

            // Inject the translation menu entry
            this.menuEntry = new ChatTranslatorMenuEntry(config);
            ChatLineData chatData = null;
            if (isHoveringChatInputWidget()) {
                chatData = getLocalPlayerChatLineData();
                menuEntry.setChatLineData(chatData);
                menuEntry.setSourceLanguage(this.config.lastSourceLanguageCode(), this.config.lastSourceLanguageName());
                menuEntry.setTargetLanguage(this.config.lastTargetLanguageCode(), this.config.lastTargetLanguageName());
            } else if (isHoveringChatLineWidget()) {
                chatData = getHoveredChatLineData();
                menuEntry.setChatLineData(chatData);
                menuEntry.setTargetLanguage(this.config.lastSourceLanguageCode(), this.config.lastSourceLanguageName());
            }
            if (chatData == null || chatData.getChatLine().isEmpty()) {
                return;
            }
            client.getMenu().createMenuEntry(-1)
                .setType(MenuAction.RUNELITE)
                .setTarget("")
                .setOption(menuEntry.getOption());
        } else {
            this.menuEntry = null;
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event) {
        if (!translator.isAuthenticated()) {
            clientThread.invokeLater(() -> {
                client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
                        ColorUtil.wrapWithColorTag("Please authenticate using the side panel to use translation.", Color.RED), "");
                return;
            });
        }

        if (event.getMenuAction() == MenuAction.RUNELITE && event.getMenuOption().startsWith("Translate")) {
            new Thread(() -> {
                try {
                    log.info("Translating "
                            + (menuEntry.getSourceLanguageCode() == null ? "auto" : menuEntry.getSourceLanguageCode())
                            + " to "
                            + menuEntry.getTargetLanguageCode());
                    TranslateTextResponseList translationList = translator.translate(
                            menuEntry.getChatLineData().getChatLine(),
                            menuEntry.getSourceLanguageCode(),
                            menuEntry.getTargetLanguageCode());
                    if (translationList.isEmpty()) {
                        throw new GoogleAPIException("No translations found");
                    }
                    TranslateTextResponseTranslation translationResponse = translationList.getBestTranslation(config.lastTargetLanguageCode());
                    String translation = translationResponse.translatedText;
                    String fromLanguage = translationResponse.detectedSourceLanguage.toUpperCase();
                    String toLanguage = menuEntry.getTargetLanguageCode().toUpperCase();
                    log.info("Translation Complete."
                            + "\n\tBefore[" + fromLanguage + "]: '" + menuEntry.getChatLineData().getChatLine() + "'"
                            + "\n\tAfter[" + toLanguage + "]: '" + translation + "'");

                    clientThread.invokeLater(() -> {
                        // Copy items for translation formatting
                        String translationFormatted = translation;
                        String fromLanguageFormatted = fromLanguage;
                        String toLanguageFormatted = toLanguage;

                        // Preview the translation in chat input
                        if (this.config.isPreviewingChatInput() && menuEntry.getChatLineData().isSaidByLocalPlayer()) {
                            stagePreview(translationFormatted);
                        }

                        // Highlighting for chat box
                        if (config.isTranslationHighlighted()) {
                            // Color from language code
                            if (fromLanguageFormatted.equalsIgnoreCase(config.lastSourceLanguageCode())) {
                                fromLanguageFormatted = ColorUtil.wrapWithColorTag(fromLanguageFormatted, config.sourceLangColor());
                            } else if (fromLanguageFormatted.equalsIgnoreCase(config.lastTargetLanguageCode())) {
                                fromLanguageFormatted = ColorUtil.wrapWithColorTag(fromLanguageFormatted, config.targetLangColor());
                            }

                            // Color to language code
                            if (toLanguageFormatted.equalsIgnoreCase(config.lastSourceLanguageCode())) {
                                toLanguageFormatted = ColorUtil.wrapWithColorTag(toLanguageFormatted, config.sourceLangColor());
                                translationFormatted = ColorUtil.wrapWithColorTag(translationFormatted, config.sourceLangColor());
                            } else if (toLanguageFormatted.equalsIgnoreCase(config.lastTargetLanguageCode())) {
                                toLanguageFormatted = ColorUtil.wrapWithColorTag(toLanguageFormatted, config.targetLangColor());
                                translationFormatted = ColorUtil.wrapWithColorTag(translationFormatted, config.targetLangColor());
                            }
                        }

                        // Send translation message
                        ChatMessageType messageFilter = getVisibleChatMessageType();
                        switch (messageFilter) {
                            case PUBLICCHAT:
                                sendTranslationToPublicChat(fromLanguageFormatted, toLanguageFormatted, translationFormatted, menuEntry);
                                break;
                            case FRIENDSCHAT:
                                sendTranslationToFriendsChat(fromLanguageFormatted, toLanguageFormatted, translationFormatted, menuEntry);
                                break;
                            case TRADE:
                                sendTranslationToTradeChat(fromLanguageFormatted, toLanguageFormatted, translationFormatted, menuEntry);
                                break;
                            case PRIVATECHAT:
                                if (menuEntry.getChatLineData().isSaidByPlayer()) {
                                    if (menuEntry.getChatLineData().getRSN().startsWith("To ")) {
                                        menuEntry.getChatLineData().fixRsnForPMFilter(); // Change "From <rsn>" to "<rsn>" - This is specific to the Private Chat filter.
                                        sendTranslationToPrivateChatOut(fromLanguageFormatted, toLanguageFormatted, translationFormatted, menuEntry);
                                        break;
                                    } else if (menuEntry.getChatLineData().getRSN().startsWith("From ")) {
                                        menuEntry.getChatLineData().fixRsnForPMFilter(); // Change "From <rsn>" to "<rsn>" - This is specific to the Private Chat filter.
                                        sendTranslationToPrivateChat(fromLanguageFormatted, toLanguageFormatted, translationFormatted, menuEntry);
                                        break;
                                    }
                                }
                                sendTranslationToPrivateChat(fromLanguageFormatted, toLanguageFormatted, translationFormatted, menuEntry);
                                break;
                            case GAMEMESSAGE:
                            default:
                                sendTranslationToGameChat(fromLanguageFormatted, toLanguageFormatted, translationFormatted, menuEntry);
                                break;
                        }
                    });

                } catch (Exception e) {
                    log.error("Translation exception: ", e);
                    client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Translation Error: " + e.getMessage(), "");
                }
            }).start();
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged) {
        if (configChanged.getKey().equals("previewChatInput")) {
            if (!config.isPreviewingChatInput()) {
                stopPreview();
            }
        }
    }

    @Subscribe
    public void onVarClientStrChanged(VarClientStrChanged varClientStrChanged) {
        // Return if the user does not want to preview chat
        if (!config.isPreviewingChatInput()) return;

        // Return if there is nothing to preview
        if (this.previewTranslation == null) return;

        // Update the preview
        if (varClientStrChanged.getIndex() == VarClientStr.CHATBOX_TYPED_TEXT) {
            String userInput = client.getVarcStrValue(VarClientStr.CHATBOX_TYPED_TEXT);

            // Conditions to cancel a preview when typing:
            // 1 : User sends the chatline
            // 2 : User hits backspace when the chatline is already empty
            if (!this.lastPreviewText.isEmpty() && userInput.isEmpty()) {
                clientThread.invokeLater(this::stopPreview);
                return;
            }
            // 3 : User input length is longer than the translation length
            if (userInput.length() > previewTranslation.length()) {
                clientThread.invokeLater(this::stopPreview);
                return;
            }
            // 4 : The last several characters in a row entered do not match the translation
            final int incorrectMax = 5;
            if (userInput.length() >= incorrectMax && previewTranslation.length() >= incorrectMax) {
                int incorrect = 0;
                for (int i = 0; i < incorrectMax; i++) {
                    char correct = Character.toLowerCase(previewTranslation.charAt(userInput.length() - i - 1));
                    char user = Character.toLowerCase(userInput.charAt(userInput.length() - i - 1));
                    if (user != correct) {
                        incorrect++;
                    }
                }
                if (incorrect == incorrectMax) {
                    clientThread.invokeLater(this::stopPreview);
                    return;
                }
            }

            this.lastPreviewText = userInput;
            clientThread.invokeLater(() -> writeChatInput(getChatInputPreviewText()));
        }

    }

    /**
     * Helper method to determine if the user is hovering over a widget.
     *
     * @param widget - the widget to mouse test
     * @return true if the user is hovering over the given widget, false otherwise
     */
    private boolean isMouseOverWidget(Widget widget) {
        Point mousePosition = this.client.getMouseCanvasPosition();
        return widget.getBounds().contains(mousePosition.getX(), mousePosition.getY());
    }

    /**
     * Helper method to determine if the user is hovering over the chat box.
     *
     * @return true if the user is hovering over the chat box, false otherwise
     */
    private boolean isHoveringChatBoxWidget() {
        Widget chatBoxWidget = this.client.getWidget(ComponentID.CHATBOX_FRAME);
        if (chatBoxWidget == null) return false;
        return isMouseOverWidget(chatBoxWidget);
    }

    /**
     * Helper method to determine if the user is hovering over their own chat input.
     *
     * @return true if the user is hovering over their own chat input, false otherwise
     */
    private boolean isHoveringChatInputWidget() {
        Widget chatInputWidget = this.client.getWidget(ComponentID.CHATBOX_INPUT);
        if (chatInputWidget == null) return false;
        return isMouseOverWidget(chatInputWidget);
    }

    /**
     * Helper method to determine if the user is hovering over a chat line in the chat box.
     *
     * @return true if the user is hovering over a message in the chat box, false otherwise
     */
    private boolean isHoveringChatLineWidget() {
        Widget chatLinesWidget = this.client.getWidget(ComponentID.CHATBOX_MESSAGE_LINES);
        if (chatLinesWidget == null) return false;
        return isMouseOverWidget(chatLinesWidget);
    }

    /**
     * Helper method to return the chat line data from the message underneath the mouse
     *
     * @return chat line data from the message underneath the mouse, or null on error
     */
    private @Nullable
    ChatLineData getHoveredChatLineData() {
        try {
            Widget chatBox = this.client.getWidget(ComponentID.CHATBOX_MESSAGE_LINES);
            // This magic will get all the chat lines in the chat box and filter it down to the chat line hovered over
            // by the mouse and then remove all formatting and join the "username:" widget text to the " message" widget text.
            String chatLine = Stream.of(chatBox.getChildren())
                    .filter(widget -> !widget.isHidden())
                    .filter(widget -> widget.getId() < ComponentID.CHATBOX_FIRST_MESSAGE)
                    .filter(widget -> {
                        int mouseY = this.client.getMouseCanvasPosition().getY();
                        return (mouseY >= widget.getBounds().getMinY() && mouseY <= widget.getBounds().getMaxY());
                    })
                    .map(Widget::getText)
                    .map(Text::removeTags)
                    .collect(Collectors.joining(" "));

            // Regex matcher buffer
            Matcher matcher;

            // Remove Friends Chat heading, i.e. '[Friends Chat] Nuzzler: Hey' -> 'Nuzzler: Hey'
            Pattern fcPattern = Pattern.compile("^\\[.+\\] ");
            matcher = fcPattern.matcher(chatLine);
            if (matcher.find()) {
                String fc = matcher.group();
                chatLine = chatLine.replace(fc, ""); // Remove FC heading
            }

            // Capture username
            Pattern rsnPattern = Pattern.compile("^.+: ");
            String username = null;
            matcher = rsnPattern.matcher(chatLine);
            if (matcher.find()) {
                username = matcher.group();
                chatLine = chatLine.replace(username, ""); // Remove FC heading
                username = username.substring(0, username.length() - 2); // Remove the ': ' at the end
            }

            return new ChatLineData(username, chatLine, false);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Helper method to return the chat line data in the local player's chat input
     *
     * @return chat line data from the local player, or null on error
     */
    private @Nullable
    ChatLineData getLocalPlayerChatLineData() {
        try {
            String rsn = this.client.getLocalPlayer().getName();
            String chatInput = client.getVarcStrValue(VarClientStr.CHATBOX_TYPED_TEXT);
            return new ChatLineData(rsn, chatInput, true);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Helper method to return a {@link ChatMessageType} that the player will see, even in their given filter.
     * For example, if the player is currently filtering to 'Trade' chat, we return {@link ChatMessageType#TRADE}.
     * This helps send a translation where the player can see it.
     *
     * @return a {@link ChatMessageType} to reach the player in their given filter
     */
    private ChatMessageType getVisibleChatMessageType() {
        try {
            Widget chatBox = this.client.getWidget(ComponentID.CHATBOX_BUTTONS);

            List<Widget> chatBuckets = Stream.of(chatBox.getStaticChildren())
                    .map(Widget::getStaticChildren)
                    .flatMap(Arrays::stream)
                    .map(Widget::getStaticChildren)
                    .flatMap(Arrays::stream)
                    .filter(widget -> !widget.isHidden())
                    .filter(widget -> widget.getSpriteId() == 1022)
                    .collect(Collectors.toList());

            if (!chatBuckets.isEmpty()) {
                Widget activePebble = chatBuckets.get(0);
                Widget tabPebble = activePebble.getParent().getParent();
                if (this.client.getWidget(ComponentID.CHATBOX_TAB_CLAN).equals(tabPebble)) {
                    return ChatMessageType.FRIENDSCHAT;
                } else if (this.client.getWidget(ComponentID.CHATBOX_TAB_PRIVATE).equals(tabPebble)) {
                    return ChatMessageType.PRIVATECHAT;
                } else if (this.client.getWidget(ComponentID.CHATBOX_TAB_PUBLIC).equals(tabPebble)) {
                    return ChatMessageType.PUBLICCHAT;
                } else if (this.client.getWidget(ComponentID.CHATBOX_TAB_TRADE).equals(tabPebble)) {
                    return ChatMessageType.TRADE;
                }
            }
        } catch (Exception e) {
            // Do nothing
        }
        // Default to a game message
        return ChatMessageType.GAMEMESSAGE;
    }

    /**
     * Helper method to stage a translation preview for the user. This must be called from the client thread.
     *
     * @param translation - the translation to preview for the user in their chat input
     */
    private void stagePreview(String translation) {
        try {
            //  Clear the chat input
            int inputType = client.getVarbitValue(VarClientInt.INPUT_TYPE);
            if (inputType == InputType.NONE.getType()) {
                // Clear the chat input in preparation for chat preview
                client.setVarcStrValue(VarClientStr.CHATBOX_TYPED_TEXT, "");
                client.runScript(ScriptID.CHAT_PROMPT_INIT);
            } else {
                // User is typing in private chat or in a dialog, etc.
                // The preview cannot be done
                return;
            }

            // Stage the preview
            this.previewTranslation = translation;
            this.lastPreviewText = "";

            writeChatInput(getChatInputPreviewText());
            log.debug("Started translation preview of '" + translation + "'");
        } catch (Exception e) {
            log.error("Translation could not be staged", e);
        }
    }

    /**
     * Helper method to cancel the translation preview for the user. This must be called from the client thread.
     */
    private void stopPreview() {
        try {
            // Clear preview
            this.previewTranslation = null;
            this.lastPreviewText = null;

            // Return back to the normal state
            String chatInput = client.getVarcStrValue(VarClientStr.CHATBOX_TYPED_TEXT);
            final Color defaultTextColor = new Color(0x90, 0x90, 0xff);
            writeChatInput(ColorUtil.wrapWithColorTag(chatInput, defaultTextColor));
            log.debug("Stopped translation preview.");
        } catch (Exception e) {
            log.error("Translation could not be cancelled", e);
        }
    }

    /**
     * Helper method to put raw chat data into the chat input widget.
     * For example, if the desired text is "Lala", similar to the following will be returned:
     * <pre>
     *     Username: Lala<col=default>*</col>
     * </pre>
     *
     * @param text - the desired chat content to be inserted into the chat input widget
     */
    private void writeChatInput(String text) {
        try {
            // Replace the visible chatline input with a preview
            Widget chatBuffer = client.getWidget(ComponentID.CHATBOX_INPUT);

            StringBuilder rawChatInput = new StringBuilder();
            rawChatInput.append(client.getLocalPlayer().getName());
            rawChatInput.append(": ");
            rawChatInput.append(text);
            final Color defaultTextColor = new Color(0x90, 0x90, 0xff);
            rawChatInput.append(ColorUtil.wrapWithColorTag("*", defaultTextColor)); // The asterisk at the end

            chatBuffer.setText(rawChatInput.toString());
        } catch (Exception e) {
            log.error("Could not write chat input", e);
        }
    }


    /**
     * Helper method to return the raw chat data of the current preview.
     * For example, if the desired preview text is "Hej" (Hello), and the user has inputted "hZ", similar to the following will be returned:
     * <pre>{@code
     *     <col=green>h</col><col=red>Z</col><col=grey>j</col>
     * }</pre>
     * Where green is the correct color, red is the incorrect color, and grey is a not-typed character color.
     *
     * @return the raw chat data for a preview of the current translation attempt
     */
    private @Nullable
    String getChatInputPreviewText() {
        try {
            String userInput = client.getVarcStrValue(VarClientStr.CHATBOX_TYPED_TEXT);

            StringBuilder translationPreviewColoring = new StringBuilder();
            for (int i = 0; i < previewTranslation.length(); i++) {
                char correct = previewTranslation.charAt(i);

                if (i < userInput.length()) {
                    // User typed a character at this index
                    char user = userInput.charAt(i);
                    if (Character.toLowerCase(user) == Character.toLowerCase(correct)) {
                        // With highlighting
                        if (this.config.isTranslationHighlighted()) {
                            translationPreviewColoring.append(ColorUtil.wrapWithColorTag(Character.toString(user), config.targetLangColor()));
                        } else {
                            final Color defaultTextColor = new Color(0x90, 0x90, 0xff);
                            translationPreviewColoring.append(ColorUtil.wrapWithColorTag(Character.toString(user), defaultTextColor));
                        }
                    } else {
                        translationPreviewColoring.append(ColorUtil.wrapWithColorTag(Character.toString(user), Color.RED));
                    }
                } else {
                    // User did not type a character at this index
                    translationPreviewColoring.append(ColorUtil.wrapWithColorTag(Character.toString(correct), Color.GRAY));
                }
            }

            return translationPreviewColoring.toString();
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Helper method to send a translation message to public chat. This is done because a user is filtering that chat and we want them to see the translation under the same filter.
     */
    private void sendTranslationToPublicChat(String fromLanguageCode, String toLanguageCode, String translation, ChatTranslatorMenuEntry menuEntry) {
        client.addChatMessage(ChatMessageType.PUBLICCHAT,
                "[" + (this.config.isShowingDetectedLanguages() ? fromLanguageCode + "->" + toLanguageCode : toLanguageCode) + "] "
                        + (menuEntry.getChatLineData().isSaidByPlayer() ? menuEntry.getChatLineData().getRSN() : "GAME"),
                "</col>" + translation,
                "xx");
    }

    /**
     * Helper method to send a translation message to private chat. This is done because a user is filtering that chat and we want them to see the translation under the same filter.
     */
    private void sendTranslationToPrivateChat(String fromLanguageCode, String toLanguageCode, String translation, ChatTranslatorMenuEntry menuEntry) {
        client.addChatMessage(ChatMessageType.PRIVATECHAT,
                (menuEntry.getChatLineData().isSaidByPlayer() ? menuEntry.getChatLineData().getRSN() : "GAME"),
                "</col>[" + (this.config.isShowingDetectedLanguages() ? fromLanguageCode + "->" + toLanguageCode : toLanguageCode) + "] " + translation,
                "");
    }

    /**
     * Helper method to send a translation message to public chat as the user. This is done because a user is filtering that chat and we want them to see the translation under the same filter.
     */
    private void sendTranslationToPrivateChatOut(String fromLanguageCode, String toLanguageCode, String translation, ChatTranslatorMenuEntry menuEntry) {
        client.addChatMessage(ChatMessageType.PRIVATECHATOUT,
                (menuEntry.getChatLineData().isSaidByPlayer() ? menuEntry.getChatLineData().getRSN() : "GAME"),
                "</col>[" + (this.config.isShowingDetectedLanguages() ? fromLanguageCode + "->" + toLanguageCode : toLanguageCode) + "] " + translation, "");
    }

    /**
     * Helper method to send a translation message to trade chat. This is done because a user is filtering that chat and we want them to see the translation under the same filter.
     */
    private void sendTranslationToTradeChat(String fromLanguageCode, String toLanguageCode, String translation, ChatTranslatorMenuEntry menuEntry) {
        client.addChatMessage(ChatMessageType.TRADE,
                "",
                "[" + (this.config.isShowingDetectedLanguages() ? fromLanguageCode + "->" + toLanguageCode : toLanguageCode) + "]" + (menuEntry.getChatLineData().isSaidByLocalPlayer() ? " " + menuEntry.getChatLineData().getRSN() + ": " : ": ") + translation,
                "");
    }

    /**
     * Helper method to send a translation message to friends chat. This is done because a user is filtering that chat and we want them to see the translation under the same filter.
     */
    private void sendTranslationToFriendsChat(String fromLanguageCode, String toLanguageCode, String translation, ChatTranslatorMenuEntry menuEntry) {
        client.addChatMessage(ChatMessageType.FRIENDSCHAT,
                (menuEntry.getChatLineData().isGameMessage() ? "GAME" : menuEntry.getChatLineData().getRSN()),
                "</col>" + translation,
                "</col>" + (this.config.isShowingDetectedLanguages() ? fromLanguageCode + "->" + toLanguageCode : toLanguageCode));
    }

    /**
     * Helper method to send a translation message to game chat. This is the default.
     */
    private void sendTranslationToGameChat(String fromLanguageCode, String toLanguageCode, String translation, ChatTranslatorMenuEntry menuEntry) {
        client.addChatMessage(ChatMessageType.GAMEMESSAGE,
                "",
                "[" + (this.config.isShowingDetectedLanguages() ? fromLanguageCode + "->" + toLanguageCode : toLanguageCode) + "] "
                        + (menuEntry.getChatLineData().isSaidByPlayer() ? menuEntry.getChatLineData().getRSN() + ": " : "")
                        + translation,
                "");
    }

    /*
        Lala + Spencer forever.
     */
}

package com.chattranslator.data;

import com.google.gson.*;

import javax.annotation.Nullable;

/**
 * A single supported language response corresponds to information related to one supported language.
 *
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 * @version January 2021
 * @see <a href="https://cloud.google.com/translate/docs/reference/rest/v2/languages#getsupportedlanguagesresponselanguage">https://cloud.google.com/translate/docs/reference/rest/v2/languages#getsupportedlanguagesresponselanguage</a>
 */
public class GetSupportedLanguagesResponseLanguage {

    /**
     * Supported language code, generally consisting of its ISO 639-1 identifier. (E.g. 'en', 'ja'). In certain cases, BCP-47 codes including language + region identifiers are returned (e.g. 'zh-TW' and 'zh-CH').
     */
    public final String language;

    /**
     * Human readable name of the language localized to the target language.
     */
    public final String name;

    /**
     * Initialize a single supported language.
     *
     * @param language the supported language code
     * @param name     the human readable name of the language
     */
    private GetSupportedLanguagesResponseLanguage(final String language, final String name) {
        this.language = language;
        this.name = name;
    }

    /**
     * Parse a JSON source to receive this object.
     *
     * @param json the JSON source of this object, e.g.
     *             <pre>{"language": string, "name": string,}</pre>
     * @return an instance of this class on successful parsing
     */
    public @Nullable
    static GetSupportedLanguagesResponseLanguage fromJSON(final JsonElement json) {
        try {
            JsonObject jsonObject = json.getAsJsonObject();
            String language = jsonObject.get("language").getAsString();
            String name = jsonObject.get("name").getAsString();

            return new GetSupportedLanguagesResponseLanguage(language, name);
        } catch (Exception e) {
            return null;
        }
    }
}

package com.chattranslator.data;

import com.google.gson.*;

import java.util.Objects;
import java.util.stream.IntStream;

/**
 * A response list contains a list of separate supported language responses.
 *
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 * @version January 2021
 * @see <a href="https://cloud.google.com/translate/docs/reference/rest/v2/languages#getsupportedlanguagesresponselist">https://cloud.google.com/translate/docs/reference/rest/v2/languages#getsupportedlanguagesresponselist</a>
 */
public class GetSupportedLanguagesResponseList {

    /**
     * The set of supported languages.
     */
    public final GetSupportedLanguagesResponseLanguage[] languages;

    /**
     * Initialize a list of supported languages.
     *
     * @param languages the supported languages
     */
    private GetSupportedLanguagesResponseList(final GetSupportedLanguagesResponseLanguage[] languages) {
        this.languages = languages;
    }

    /**
     * Parse a JSON source to receive this object.
     *
     * @param json the JSON source of this object, e.g.
     *             <pre>{"languages": [{object(GetSupportedLanguagesResponseLanguage)}],}</pre>
     * @return an instance of this class on successful parsing
     */
    public static GetSupportedLanguagesResponseList fromJSON(final JsonElement json) {
        JsonObject jsonObject = json.getAsJsonObject();
        JsonArray languages = jsonObject.getAsJsonArray("languages");

        GetSupportedLanguagesResponseLanguage[] response = IntStream
                .range(0, languages.size())
                .mapToObj(languages::get)
                .map(GetSupportedLanguagesResponseLanguage::fromJSON)
                .filter(Objects::nonNull)
                .toArray(GetSupportedLanguagesResponseLanguage[]::new);

        return new GetSupportedLanguagesResponseList(response);
    }
}

package com.chattranslator.data;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import lombok.extern.slf4j.Slf4j;

import javax.annotation.Nullable;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * A response list contains a list of separate supported language responses.
 *
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 * @version January 2021
 * @see <a href="https://cloud.google.com/translate/docs/reference/rest/v2/translate#translatetextresponselist">https://cloud.google.com/translate/docs/reference/rest/v2/translate#translatetextresponselist</a>
 */
@Slf4j
public class TranslateTextResponseList {

    /**
     * The list of language translation responses. This list contains a language translation response for each query (q) sent in the language translation request.
     */
    public final TranslateTextResponseTranslation[] translations;

    /**
     * Initialize a list of translations.
     *
     * @param translations the transaltions
     */
    private TranslateTextResponseList(final TranslateTextResponseTranslation[] translations) {
        this.translations = translations;
    }

    /**
     * @return true if this translation list is empty, false otherwise
     */
    public boolean isEmpty() {
        return this.translations.length == 0;
    }


    /**
     * Return the best translation possible.
     *
     * @param language the preferred language to match, or null
     * @return the most applicable translation, or null, if no translations exist
     */
    public TranslateTextResponseTranslation getBestTranslation(@Nullable String language) {
        // 99% of the time we only have 1 translation or we don't know how to choose the best translation
        if (translations.length == 1 || language == null) {
            log.debug("Translation found");
            return translations[0];
        }

        // Attempt to find the perfect translation match
        Optional<TranslateTextResponseTranslation> perfectMatch = Stream.of(translations)
                .filter(translation -> translation.detectedSourceLanguage != null)
                .filter(translation -> translation.detectedSourceLanguage.equalsIgnoreCase(language))
                .findFirst();

        if (perfectMatch.isPresent()) {
            // Return the perfect match
            log.debug("Translation found");
            return perfectMatch.get();
        } else {
            // Return any translation, so it might as well be the first
            log.debug("Translation not matched - using any");
            return translations[0];
        }
    }

    /**
     * Parse a JSON source to receive this object.
     *
     * @param json the JSON source of this object, e.g.
     *             <pre>{"translations": [array(TranslateTextResponseTranslation)]}</pre>
     * @return an instance of this class on successful parsing
     * @throws Exception on parse failure
     */
    public static TranslateTextResponseList fromJSONExplicit(final JsonElement json, String sourceLanguage) throws Exception {
        JsonObject jsonObject = json.getAsJsonObject();
        JsonArray translations = jsonObject.getAsJsonArray("translations");
        log.info("translations: " + translations.size());

        if (translations.size() != 1) {
            return fromJSONImplicit(json);
        }

        TranslateTextResponseTranslation[] response = new TranslateTextResponseTranslation[1];
        response[0] = TranslateTextResponseTranslation.fromJSONExplicit(translations.get(0), sourceLanguage);

        return new TranslateTextResponseList(response);
    }

    /**
     * Parse a JSON source to receive this object.
     *
     * @param json the JSON source of this object, e.g.
     *             <pre>{"translations": [array(TranslateTextResponseTranslation)],}</pre>
     * @return an instance of this class on successful parsing
     */
    public static TranslateTextResponseList fromJSONImplicit(final JsonElement json) {
        JsonObject jsonObject = json.getAsJsonObject();
        JsonArray translations = jsonObject.getAsJsonArray("translations");

        TranslateTextResponseTranslation[] response = IntStream
                .range(0, translations.size())
                .mapToObj(translations::get)
                .map(TranslateTextResponseTranslation::fromJSONImplicit)
                .filter(Objects::nonNull)
                .toArray(TranslateTextResponseTranslation[]::new);

        return new TranslateTextResponseList(response);
    }

}

package com.chattranslator.data;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import org.apache.commons.text.StringEscapeUtils;

import javax.annotation.Nullable;

/**
 * A list of translation results for the requested text.
 *
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 * @version January 2021
 * @see <a href="https://cloud.google.com/translate/docs/reference/rest/v2/translate#translatetextresponsetranslation">https://cloud.google.com/translate/docs/reference/rest/v2/translate#translatetextresponsetranslation</a>
 */
public class TranslateTextResponseTranslation {

    /**
     * The source language of the initial request, detected automatically, if no source language was passed within the initial request. If the source language was passed, auto-detection of the language will not occur and this field will be omitted.
     */
    public final String detectedSourceLanguage;

    /**
     * Text translated into the target language.
     */
    public final String translatedText;

    private TranslateTextResponseTranslation(String detectedSourceLanguage, String translatedText) {
        this.detectedSourceLanguage = detectedSourceLanguage;
        this.translatedText = translatedText;
    }

    /**
     * Parse a JSON source to receive this object with an implicitly detected source language.
     *
     * @param json the JSON source of this object, e.g.
     *             <pre>{"detectedSourceLanguage": string,"translatedText": string,}</pre>
     * @return an instance of this class on successful parsing
     */
    public @Nullable
    static TranslateTextResponseTranslation fromJSONImplicit(final JsonElement json) {
        try {
            JsonObject jsonObject = json.getAsJsonObject();
            String translatedText = StringEscapeUtils.unescapeHtml4(jsonObject.get("translatedText").getAsString());
            if (jsonObject.has("detectedSourceLanguage")) {
                String detectedSourceLanguage = jsonObject.get("detectedSourceLanguage").getAsString();
                return new TranslateTextResponseTranslation(detectedSourceLanguage, translatedText);
            } else {
                return new TranslateTextResponseTranslation("?", translatedText);
            }
        } catch (Exception e ) {
            return null;
        }
    }

    /**
     * Parse a JSON source to receive this object with an explicitly provided source language.
     *
     * @param json the JSON source of this object, e.g.
     *             <pre>{"detectedSourceLanguage": string,}</pre>
     * @return an instance of this class on successful parsing
     */
    public @Nullable
    static TranslateTextResponseTranslation fromJSONExplicit(JsonElement json, String sourceLanguage) {
        try {
            JsonObject jsonObject = json.getAsJsonObject();
            String translatedText = StringEscapeUtils.unescapeHtml4(jsonObject.get("translatedText").getAsString());
            return new TranslateTextResponseTranslation(sourceLanguage, translatedText);
        } catch (Exception e ) {
            return null;
        }
    }
}

package com.chattranslator.ex;

/**
 * An exception generated from a failed API call to Google Cloud Platform.
 *
 * @version January 2021
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 */
public class GoogleAPIException extends GoogleException {
    public GoogleAPIException(String errorMessage, Throwable err) {
        super(errorMessage, err);
    }
    public GoogleAPIException(String errorMessage) {
        super(errorMessage);
    }
}

package com.chattranslator.ex;

/**
 * An exception generated from invalid authentication to Google Cloud Platform.
 *
 * @version January 2021
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 */
public class GoogleAuthenticationException extends GoogleException {
    public GoogleAuthenticationException(String errorMessage, Throwable err) {
        super(errorMessage, err);
    }
    public GoogleAuthenticationException(String errorMessage) {
        super(errorMessage);
    }
}

package com.chattranslator.ex;

/**
 * A generic exception which occurred from bad interaction to Google Cloud Platform.
 *
 * @version January 2021
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 */
public class GoogleException extends Exception {
    public GoogleException(String errorMessage, Throwable err) {
        super(errorMessage, err);
    }
    public GoogleException(String errorMessage) {
        super(errorMessage);
    }
}

package com.chattranslator.ui;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import java.awt.*;
import java.awt.image.BufferedImage;

/**
 * The requesting dialog for an API key used by the {@link ChatTranslatorAuthenticateButton}. This allows the user to submit
 * their Google Translate API key for authentication.
 *
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 * @version January 2021
 */
public class ChatTranslatorAPIKeyDialog extends JFrame {

    /**
     * The dialog frame icons. Swing chooses the proper frame icon depending on the OS.
     */
    private static final List<Image> FRAME_ICONS = new LinkedList<>();

    /**
     * The text field which the user interacts with.
     */
    private JTextField keyTextField;

    /**
     * Construct the API Key Dialog.
     *
     * @param authButton - the auth button which spawns this dialog used for call back
     */
    public ChatTranslatorAPIKeyDialog(ChatTranslatorAuthenticateButton authButton) {
        super();

        // Set frame properties
        this.setTitle("Enter an API Key");
        this.setLayout(new BorderLayout());
        this.setDefaultCloseOperation(WindowConstants.HIDE_ON_CLOSE);
        this.setLocationRelativeTo(null); // Centers on screen
        this.setResizable(false);

        // Set frame icons
        final BufferedImage icon128 = ImageUtil.loadImageResource(ChatTranslatorAPIKeyDialog.class, "/frame_icons/auth_128.png");
        final BufferedImage icon64 = ImageUtil.loadImageResource(ChatTranslatorAPIKeyDialog.class, "/frame_icons/auth_64.png");
        final BufferedImage icon32 = ImageUtil.loadImageResource(ChatTranslatorAPIKeyDialog.class, "/frame_icons/auth_32.png");
        final BufferedImage icon16 = ImageUtil.loadImageResource(ChatTranslatorAPIKeyDialog.class, "/frame_icons/auth_16.png");
        Collections.addAll(FRAME_ICONS, icon128, icon64, icon32, icon16);
        this.setIconImages(FRAME_ICONS);

        // Create content pane
        JPanel content = new JPanel();
        content.setBorder(new EmptyBorder(10, 10, 10, 10));
        content.setBackground(ColorScheme.DARK_GRAY_COLOR);
        content.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 0)); // Left to right

        // Add "Chat Translator" to the top left
        JLabel title = new JLabel();
        title.setText("API Key:");
        title.setForeground(Color.WHITE);
        content.add(title, BorderLayout.WEST);

        // Add Text field to the top right
        JPasswordField keyTextField = new JPasswordField();
        keyTextField.setHorizontalAlignment(JTextField.CENTER);
        keyTextField.setSelectedTextColor(Color.RED);
        keyTextField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        keyTextField.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
        keyTextField.setMinimumSize(new Dimension(300, 30));
        keyTextField.setPreferredSize(new Dimension(300, 30));
        keyTextField.setMaximumSize(new Dimension(300, 30));
        this.keyTextField = keyTextField;
        content.add(this.keyTextField, BorderLayout.EAST);

        // Add donate button to the top right
        JButton submitButton = new JButton();
        submitButton.setMinimumSize(new Dimension(300, 30));
        submitButton.setPreferredSize(new Dimension(300, 30));
        submitButton.setMaximumSize(new Dimension(300, 30));
        SwingUtil.removeButtonDecorations(submitButton);
        submitButton.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));
        submitButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        submitButton.setForeground(Color.WHITE);
        submitButton.setText("Submit");
        submitButton.setUI(new BasicButtonUI());
        submitButton.addActionListener(e -> {
            // Call authentication
            new Thread(authButton).start();
            this.setVisible(false);
        });
        submitButton.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                submitButton.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
            }

            public void mouseExited(java.awt.event.MouseEvent evt) {
                submitButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }
        });

        this.add(content, BorderLayout.CENTER);
        this.add(submitButton, BorderLayout.SOUTH);
        this.pack();
    }

    /**
     * Focus the text field for the API key.
     */
    public void focusTextField() {
        super.requestFocus();
        this.keyTextField.requestFocus();
    }

    /**
     * Clear the API key text field.
     */
    public void clearApiKey() {
        this.keyTextField.setText("");
    }

    /**
     * Retrieve the API key in the text field provided by the user.
     */
    public String getApiKey() {
        return this.keyTextField.getText().trim();
    }

}

package com.chattranslator.ui;

import com.chattranslator.ChatTranslator;
import com.chattranslator.ChatTranslatorPlugin;
import com.chattranslator.ex.GoogleException;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.SwingUtil;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.plaf.basic.BasicButtonUI;
import java.awt.*;

/**
 * The authentication button for the Chat Translator. This allows the user to pick their Google Translate API API key and reflects the status of their authentication.
 *
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 * @version January 2021
 */
public class ChatTranslatorAuthenticateButton extends JButton implements Runnable {

    private static final String AUTH_TEXT = "Authenticate";
    private static final String UNAUTH_TEXT = "Unauthenticate";
    private static final String AUTH_TOOLTIP = "Enter your API key to authenticate.";
    private static final String UNAUTH_TOOLTIP = "Unauthenticate your account.";
    private static final Color BUTTON_COLOR = ColorScheme.DARKER_GRAY_COLOR;
    private static final Color BUTTON_HOVER_COLOR = ColorScheme.DARKER_GRAY_HOVER_COLOR;

    private static final String LOADING_TEXT = "Authenticating...";
    private static final Color LOADING_COLOR = ColorScheme.PROGRESS_INPROGRESS_COLOR;

    private static final String ERROR_TEXT = "Failed Authentication";
    private static final Color ERROR_COLOR = ColorScheme.PROGRESS_ERROR_COLOR;

    private static final String SUCCESS_TEXT = "Authenticated";
    private static final Color SUCCESS_COLOR = ColorScheme.PROGRESS_COMPLETE_COLOR;

    /**
     * The chat translator.
     */
    private final ChatTranslator translator;

    /**
     * The plugin itself.
     */
    private final ChatTranslatorPlugin plugin;

    /**
     * The text the button should return to on mouse exit.
     */
    private String buttonReturnText;

    /**
     * The color the button should return to on mouse exit.
     */
    private Color buttonReturnColor;

    /**
     * The dialog which requests an API key from the user.
     */
    private final ChatTranslatorAPIKeyDialog apiKeyDialog;

    /**
     * Construct the authenticate button.
     *
     * @param translator - the translator
     * @param plugin     - the plugin
     */
    @Inject
    public ChatTranslatorAuthenticateButton(ChatTranslator translator, ChatTranslatorPlugin plugin) {
        super();
        this.translator = translator;
        this.plugin = plugin;
        this.apiKeyDialog = new ChatTranslatorAPIKeyDialog(this);

        SwingUtil.removeButtonDecorations(this);
        this.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));
        this.setForeground(Color.WHITE);
        this.setUI(new BasicButtonUI());

        // Set initial state
        if (this.translator.isAuthenticated()) {
            this.setBackground(SUCCESS_COLOR);
            this.setText(SUCCESS_TEXT);
            this.setToolTipText(UNAUTH_TOOLTIP);
        } else {
            this.setBackground(BUTTON_COLOR);
            this.setText(AUTH_TEXT);
            this.setToolTipText(AUTH_TOOLTIP);
        }

        // Determine what happens when the user clicks the button
        this.addActionListener(e -> {
            if (this.translator.isAuthenticated()) {
                // User clicked to unauthenticate.
                this.translator.unauthenticate();
//                this.plugin.getPanel().hideLanguagePanel();
                this.plugin.getPanel().disableLanguagePanel();
                buttonReturnColor = BUTTON_COLOR;
                this.setBackground(BUTTON_HOVER_COLOR); // User clicked it, so they're still hovering
                this.setText(buttonReturnText = AUTH_TEXT);
                this.setToolTipText(AUTH_TOOLTIP);
            } else {
                // User clicked to upload credentials
                this.apiKeyDialog.setVisible(true);
                this.apiKeyDialog.focusTextField();
            }
        });

        // Determine what happens when the user hovers/exits the button
        this.addMouseListener(new java.awt.event.MouseAdapter() {
            // Button Hover effects
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                if (isEnabled()) {
                    buttonReturnText = getText();
                    buttonReturnColor = getBackground();
                    setBackground(BUTTON_HOVER_COLOR);
                    if (translator.isAuthenticated()) {
                        setText(UNAUTH_TEXT);
                    } else {
                        setText(AUTH_TEXT);
                    }

                }
            }

            public void mouseExited(java.awt.event.MouseEvent evt) {
                if (isEnabled()) {
                    setBackground(buttonReturnColor);
                    setText(buttonReturnText);
                }
            }
        });
        this.setPreferredSize(new Dimension(200, 30));
        this.setMinimumSize(new Dimension(200, 30));
        this.setMaximumSize(new Dimension(200, 30));
        this.setAlignmentX(Component.CENTER_ALIGNMENT);
    }

    // Authentication via the button will be threaded
    @Override
    public void run() {
        // Retrieve auth key and dispose
        String authKey = this.apiKeyDialog.getApiKey();
        this.apiKeyDialog.clearApiKey();

        // Performs authentication attempt
        this.setEnabled(false);
        this.plugin.getPanel().disableLanguagePanel();
        // Show progress
        this.setBackground(LOADING_COLOR);
        this.setText(LOADING_TEXT);
        // Auth here
        boolean result;
        try {
            translator.authenticate(authKey);
            this.plugin.getPanel().showLanguagePanel();
            this.plugin.getPanel().enableLanguagePanel(translator.getSupportedLanguages());
            this.plugin.loadLastSettings();
            result = true;
        } catch (GoogleException e) {
            result = false;
        }
        if (result) { // Check the result
            this.setBackground(SUCCESS_COLOR);
            this.setText(SUCCESS_TEXT);
            this.setToolTipText(UNAUTH_TOOLTIP);
        } else {
            this.setBackground(ERROR_COLOR);
            this.setText(ERROR_TEXT);
            this.plugin.getPanel().disableLanguagePanel();
        }
        buttonReturnText = getText();
        buttonReturnColor = getBackground();
        this.setEnabled(true);
    }
}

package com.chattranslator.ui;

import com.chattranslator.ChatTranslatorPlugin;
import com.google.inject.Inject;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import java.awt.*;
import java.awt.image.BufferedImage;

/**
 * The authentication panel for the Chat Translator. This holds instructions and authentication.
 *
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 * @version January 2021
 */
public class ChatTranslatorAuthPanel extends PluginPanel {

    /**
     * The help icon which links to instructions.
     */
    private static final ImageIcon HELP_ICON;

    static {
        final BufferedImage helpIcon = ImageUtil.loadImageResource(ChatTranslatorPlugin.class, "/help.png");
        HELP_ICON = new ImageIcon(ImageUtil.resizeImage(helpIcon, 16, 16));
    }

    /**
     * The authentication button.
     */
    public final ChatTranslatorAuthenticateButton authenticateButton;

    /**
     * Construct the authentication panel.
     *
     * @param authenticateButton - the child authentication button
     */
    @Inject
    public ChatTranslatorAuthPanel(ChatTranslatorAuthenticateButton authenticateButton) {
        super();
        this.authenticateButton = authenticateButton;

        // Border insets
        setBorder(new EmptyBorder(0, 0, 0, 0));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        // Create the instructions horizontal box
        final JPanel instructionHBox = new JPanel();
        BoxLayout hBoxLayout = new BoxLayout(instructionHBox, BoxLayout.X_AXIS); // Left to right
        instructionHBox.setLayout(hBoxLayout);

        // Create instructions label
        JLabel instructions = new JLabel();
        instructions.setForeground(Color.GRAY);
        instructions.setText("<html><body style ='text-align:left'><h1 style='text-align:center'>Instructions</h1>"
                + "<p>You will need access to the Google Translate API under Google Cloud Platform. "
                + "Once you have an API key, press the button below to authenticate and start the plugin."
                + "</p><br><p>For step-by-step instructions, click the help icon to the left."
                + "</p></body></html>");

        // Create instructions help icon button
        JButton helpIcon = new JButton();
        SwingUtil.removeButtonDecorations(helpIcon);
        helpIcon.setIcon(HELP_ICON);
        helpIcon.setToolTipText("Step-by-step instructions for this plugin");
        helpIcon.setBackground(ColorScheme.DARK_GRAY_COLOR);
        helpIcon.setUI(new BasicButtonUI());
        helpIcon.addActionListener((ev) -> LinkBrowser.browse("https://github.com/simbleau/chat-translator#setup"));
        helpIcon.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                helpIcon.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
            }

            public void mouseExited(java.awt.event.MouseEvent evt) {
                helpIcon.setBackground(ColorScheme.DARK_GRAY_COLOR);
            }
        });
        helpIcon.setPreferredSize(new Dimension(30, 30));
        helpIcon.setMinimumSize(new Dimension(30, 30));
        helpIcon.setMaximumSize(new Dimension(30, 30));
        helpIcon.setAlignmentY(Component.CENTER_ALIGNMENT);

        // Assemble instructions
        instructionHBox.add(helpIcon);
        instructionHBox.add(Box.createRigidArea(new Dimension(5, 0)));
        instructionHBox.add(instructions);

        // Fill content pane
        this.add(instructionHBox);
        this.add(Box.createRigidArea(new Dimension(0, 10)));
        this.add(this.authenticateButton);
    }
}

package com.chattranslator.ui;

import com.google.inject.Inject;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;

/**
 * The body panel for the Chat Translator. This holds the entire body content of the panel.
 *
 * @version January 2021
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 */
public class ChatTranslatorBodyPanel extends PluginPanel {

    /**
     * The panel which allows the user to authenticate.
     */
    public final ChatTranslatorAuthPanel authPanel;

    /**
     * The panel which allows the user to configure language translation options.
     */
    public final ChatTranslatorLanguagePanel langPanel;

    /**
     * Construct the body panel.
     *
     * @param authPanel - the child authentication panel
     * @param langPanel - the child language panel
     */
    @Inject
    public ChatTranslatorBodyPanel(ChatTranslatorAuthPanel authPanel, ChatTranslatorLanguagePanel langPanel) {
        super();
        this.authPanel = authPanel;
        this.langPanel = langPanel;

        // General style
        setBorder(new EmptyBorder(0, 6, 6, 6));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        // Wrapper pane
        final JPanel vBox = new JPanel();
        BoxLayout vBoxLayout = new BoxLayout(vBox, BoxLayout.Y_AXIS); //Top to bottom
        vBox.setLayout(vBoxLayout);
        final JScrollPane scrollPane = new JScrollPane(vBox);
        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);

        // Assembly
        vBox.add(this.authPanel);
        vBox.add(this.langPanel);

        // Fill body with contents
        add(scrollPane, BorderLayout.CENTER);
    }

}

package com.chattranslator.ui;

import com.chattranslator.ChatTranslatorPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import java.awt.*;
import java.awt.image.BufferedImage;

/**
 * The header panel for the Chat Translator. This holds the name of the plugin and a kind donation button to buy the author a coffee.
 *
 * @version January 2021
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 */
public class ChatTranslatorHeaderPanel  extends PluginPanel {

    /**
     * The BuyMeACoffee donation button for kind souls.
     */
    private static final ImageIcon DONATE_BUTTON;
    static
    {
        final BufferedImage donateIcon = ImageUtil.loadImageResource(ChatTranslatorPlugin.class, "/donate.png");
        DONATE_BUTTON = new ImageIcon(ImageUtil.resizeImage(donateIcon, 20, 20));

    }

    /**
     * Construct the header panel.
     */
    public ChatTranslatorHeaderPanel() {
        super();
        // Border insets
        this.setBorder(new EmptyBorder(10, 10, 10, 10));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        this.setLayout(new BorderLayout());

        // Add "Chat Translator" to the top left
        JLabel title = new JLabel();
        title.setText("Chat Translator");
        title.setForeground(Color.WHITE);
        this.add(title, BorderLayout.WEST);

        // Add donate button to the top right
        JButton donateIcon = new JButton();
        SwingUtil.removeButtonDecorations(donateIcon);
        donateIcon.setIcon(DONATE_BUTTON);
        donateIcon.setToolTipText("Please consider tipping the developer if you find this plugin useful.");
        donateIcon.setBackground(ColorScheme.DARK_GRAY_COLOR);
        donateIcon.setUI(new BasicButtonUI());
        donateIcon.addActionListener((ev) -> LinkBrowser.browse("https://www.buymeacoffee.com/simbleau"));
        donateIcon.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                donateIcon.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
            }

            public void mouseExited(java.awt.event.MouseEvent evt) {
                donateIcon.setBackground(ColorScheme.DARK_GRAY_COLOR);
            }
        });
        this.add(donateIcon, BorderLayout.EAST);
    }
}

package com.chattranslator.ui;

import com.chattranslator.ChatTranslatorConfig;
import com.chattranslator.data.GetSupportedLanguagesResponseLanguage;
import com.chattranslator.data.GetSupportedLanguagesResponseList;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import java.util.List;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ItemEvent;
import java.util.stream.Stream;

/**
 * The language panel for the Chat Translator. This holds options for the user to change their source and target language currently.
 *
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 * @version January 2021
 */
@Slf4j
public class ChatTranslatorLanguagePanel extends PluginPanel {

    /**
     * The plugin configuration.
     */
    private final ChatTranslatorConfig config;

    /**
     * The source language combo box.
     */
    private final JComboBox<LanguageComboItem> sourceLanguageComboBox;

    /**
     * The target language combo box.
     */
    private final JComboBox<LanguageComboItem> targetLanguageComboBox;

    /**
     * Construct the language options panel.
     *
     * @param config - the plugin configuration
     */
    @Inject
    public ChatTranslatorLanguagePanel(ChatTranslatorConfig config) {
        super();
        this.config = config;

        // Border insets
        setBorder(new EmptyBorder(0, 0, 0, 0));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new FlowLayout(FlowLayout.CENTER, 5, 10));

        // Create the source language horizontal box
        final JPanel sourceHBox = new JPanel();
        sourceHBox.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 0)); // Left to right

        // Create instructions label
        JLabel sourceLangLabel = new JLabel();
        sourceLangLabel.setForeground(Color.WHITE);
        sourceLangLabel.setText("Source Language: ");

        // Create language options combo box
        sourceLanguageComboBox = new JComboBox<>();
        sourceLanguageComboBox.setPreferredSize(new Dimension(100, 20));
        sourceLanguageComboBox.setMinimumSize(new Dimension(100, 20));
        sourceLanguageComboBox.setMaximumSize(new Dimension(100, 20));

        // Assemble HBox for Source Language
        sourceHBox.add(sourceLangLabel);
        sourceHBox.add(this.sourceLanguageComboBox);

        // Create the target language horizontal box
        final JPanel targetHBox = new JPanel();
        targetHBox.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 0)); // Left to right

        // Create instructions label
        JLabel targetLangLabel = new JLabel();
        targetLangLabel.setForeground(Color.WHITE);
        targetLangLabel.setText("Target Language: ");

        // Create language options combo box
        targetLanguageComboBox = new JComboBox<>();
        targetLanguageComboBox.setPreferredSize(new Dimension(100, 20));
        targetLanguageComboBox.setMinimumSize(new Dimension(100, 20));
        targetLanguageComboBox.setMaximumSize(new Dimension(100, 20));

        // Assemble HBox for Source Language
        targetHBox.add(targetLangLabel);
        targetHBox.add(this.targetLanguageComboBox);

        // Fill content pane
        this.add(sourceHBox);
        this.add(targetHBox);
    }

    /**
     * Disable the source and target combo boxes.
     */
    public void disableOptions() {
        this.sourceLanguageComboBox.removeAllItems();
        this.targetLanguageComboBox.removeAllItems();
        this.sourceLanguageComboBox.setEnabled(false);
        this.targetLanguageComboBox.setEnabled(false);
    }

    /**
     * Load a list of Google Translate API languages into and enable the source/target combo boxes.
     *
     * @param languages - a list of Google Translate API supported languages
     */
    public void enableOptions(GetSupportedLanguagesResponseList languages) {
        // Avoid events while loading
        Stream.of(sourceLanguageComboBox.getItemListeners()).forEach(sourceLanguageComboBox::removeItemListener);
        Stream.of(targetLanguageComboBox.getItemListeners()).forEach(targetLanguageComboBox::removeItemListener);

        this.sourceLanguageComboBox.removeAllItems();
        this.targetLanguageComboBox.removeAllItems();
        for (GetSupportedLanguagesResponseLanguage lang : languages.languages) {
            LanguageComboItem wrapper = new LanguageComboItem(lang);
            this.sourceLanguageComboBox.addItem(wrapper);
            this.targetLanguageComboBox.addItem(wrapper);
        }

        // Start listening for config changes the user makes
        sourceLanguageComboBox.addItemListener(e -> {
            if (e.getStateChange() == ItemEvent.SELECTED) {
                if (e.getItem() instanceof LanguageComboItem) {
                    GetSupportedLanguagesResponseLanguage sourceLang = ((LanguageComboItem) e.getItem()).language;
                    log.info("Selected source language: " + sourceLang.name);
                    this.config.lastSourceLanguageCode(sourceLang.language);
                    this.config.lastSourceLanguageName(sourceLang.name);
                    log.info("Saved source language: " + sourceLang.language);
                }
            }
        });
        targetLanguageComboBox.addItemListener(e -> {
            if (e.getStateChange() == ItemEvent.SELECTED) {
                if (e.getItem() instanceof LanguageComboItem) {
                    GetSupportedLanguagesResponseLanguage targetLang = ((LanguageComboItem) e.getItem()).language;
                    log.info("Selected target language: " + targetLang.name);
                    this.config.lastTargetLanguageCode(targetLang.language);
                    this.config.lastTargetLanguageName(targetLang.name);
                    log.info("Saved target language: " + targetLang.language);
                }
            }
        });

        this.sourceLanguageComboBox.setEnabled(true);
        this.targetLanguageComboBox.setEnabled(true);
    }

    /**
     * Load a language code into the source language combo box.
     *
     * @param languageCode - the language code, e.g. 'en' (English)
     */
    public void setSourceLanguage(String languageCode) {
        this.setLanguage(languageCode, this.sourceLanguageComboBox);
    }

    /**
     * Load a language code into the target language combo box.
     *
     * @param languageCode - the language code, e.g. 'da' (Danish)
     */
    public void setTargetLanguage(String languageCode) {
        this.setLanguage(languageCode, this.targetLanguageComboBox);
    }

    /**
     * Helper method to load a language code into a combo box.
     *
     * @param languageCode - the language code to load in, e.g. 'en' (English)
     * @param comboBox     - the language combo box
     */
    private void setLanguage(String languageCode, JComboBox<LanguageComboItem> comboBox) {
        if (languageCode == null) {
            log.warn("Could not load null language.");
            return;
        }

        boolean loaded = false;
        for (int i = 0; i < comboBox.getItemCount(); i++) {
            LanguageComboItem item = comboBox.getItemAt(i);
            GetSupportedLanguagesResponseLanguage lang = item.language;
            if (lang.language.equalsIgnoreCase(languageCode)) {
                comboBox.setSelectedItem(item);
                loaded = true;
                break;
            }
        }
        if (!loaded) {
            log.warn("Could not load language: '" + languageCode + "', as it was not found in " + comboBox.getItemCount() + " entries.");
        }
    }

    /**
     * An combo box item which stores a Language from Google's API
     */
    static class LanguageComboItem {
        private final GetSupportedLanguagesResponseLanguage language;

        public LanguageComboItem(GetSupportedLanguagesResponseLanguage language) {
            this.language = language;
        }

        @Override
        public String toString() {
            return this.language.name;
        }
    }
}

package com.chattranslator.ui;

import com.chattranslator.data.GetSupportedLanguagesResponseList;
import com.google.inject.Inject;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.swing.border.EmptyBorder;
import java.awt.*;

/**
 * The root plugin panel for the Chat Translator.
 *
 * @version January 2021
 * @author <a href="https://spencer.imbleau.com">Spencer Imbleau</a>
 */
public class ChatTranslatorPanel extends PluginPanel {

    /**
     * The header content panel. This holds the title and BuyMeACoffee button.
     */
    public final ChatTranslatorHeaderPanel headerPanel;

    /**
     * The body content panel.
     */
    public final ChatTranslatorBodyPanel bodyPanel;

    /**
     * Construct the plugin panel.
     *
     * @param headerPanel - the child header panel
     * @param bodyPanel - the child body panel
     */
    @Inject
    public ChatTranslatorPanel(ChatTranslatorHeaderPanel headerPanel ,ChatTranslatorBodyPanel bodyPanel) {
        super(false);
        this.headerPanel = headerPanel;
        this.bodyPanel = bodyPanel;

        //Insets
        setBorder(new EmptyBorder(0,0,0,0));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        // Add header
        add(this.headerPanel, BorderLayout.NORTH);

        // Add content
        add(this.bodyPanel, BorderLayout.CENTER);
    }

    /**
     * Show the language options panel.
     */
    public void showLanguagePanel() {
        this.bodyPanel.langPanel.setVisible(true);
    }

    /**
     * Hide the language options panel.
     */
    public void hideLanguagePanel() {
        this.bodyPanel.langPanel.setVisible(false);
    }

    /**
     * Enable the language options panel and load in the usable languages.
     *
     * @param languages - the supported languages for translation
     */
    public void enableLanguagePanel(GetSupportedLanguagesResponseList languages) {
        this.bodyPanel.langPanel.enableOptions(languages);
    }

    /**
     * Disable the language options panel.
     */
    public void disableLanguagePanel() {
        this.bodyPanel.langPanel.disableOptions();
    }

}

package com.chattranslator;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ChatTranslatorPluginTest {

    @SuppressWarnings("unchecked")
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(ChatTranslatorPlugin.class);
        RuneLite.main(args);
    }
}
