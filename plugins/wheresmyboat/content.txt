package com.wheresmyboat;

import java.util.ArrayList;

import net.runelite.api.Client;
import net.runelite.api.gameval.DBTableID;
import net.runelite.api.gameval.VarbitID;

import com.wheresmyboat.enums.BoatType;
import com.wheresmyboat.enums.Port;

import lombok.Getter;

public class Boat {
	protected int boatID;
	protected Client client;

	@Getter	private String boatName;
	@Getter	private Port port;
	@Getter private BoatType boatType;
	@Getter private float health;

	@Getter	private int portId;

	private boolean owned;

	private int name1_vb;
	private int name2_vb;
	private int name3_vb;
	private int port_vb;
	private int hp_vb;
	private int maxhp_vb;
	private int owned_vb;
	private int type_vb;
	
	public Boat(Client client, int boatID) {
		this.boatID = boatID;
		this.client = client;

		switch (boatID) {
			case 1:
				name1_vb = VarbitID.SAILING_BOAT_1_NAME_1;
				name2_vb = VarbitID.SAILING_BOAT_1_NAME_2;
				name3_vb = VarbitID.SAILING_BOAT_1_NAME_3;
				port_vb = VarbitID.SAILING_BOAT_1_PORT;
				hp_vb = VarbitID.SAILING_BOAT_1_STORED_HP;
				maxhp_vb = VarbitID.SAILING_BOAT_1_STORED_MAXHP;
				owned_vb = VarbitID.SAILING_BOAT_1_OWNED;
				type_vb = VarbitID.SAILING_BOAT_1_TYPE;
				break;
			case 2:
				name1_vb = VarbitID.SAILING_BOAT_2_NAME_1;
				name2_vb = VarbitID.SAILING_BOAT_2_NAME_2;
				name3_vb = VarbitID.SAILING_BOAT_2_NAME_3;
				port_vb = VarbitID.SAILING_BOAT_2_PORT;
				hp_vb = VarbitID.SAILING_BOAT_2_STORED_HP;
				maxhp_vb = VarbitID.SAILING_BOAT_2_STORED_MAXHP;
				owned_vb = VarbitID.SAILING_BOAT_2_OWNED;
				type_vb = VarbitID.SAILING_BOAT_2_TYPE;
				break;
			case 3:
				name1_vb = VarbitID.SAILING_BOAT_3_NAME_1;
				name2_vb = VarbitID.SAILING_BOAT_3_NAME_2;
				name3_vb = VarbitID.SAILING_BOAT_3_NAME_3;
				port_vb = VarbitID.SAILING_BOAT_3_PORT;
				hp_vb = VarbitID.SAILING_BOAT_3_STORED_HP;
				maxhp_vb = VarbitID.SAILING_BOAT_3_STORED_MAXHP;
				owned_vb = VarbitID.SAILING_BOAT_3_OWNED;
				type_vb = VarbitID.SAILING_BOAT_3_TYPE;
				break;
			case 4:
				name1_vb = VarbitID.SAILING_BOAT_4_NAME_1;
				name2_vb = VarbitID.SAILING_BOAT_4_NAME_2;
				name3_vb = VarbitID.SAILING_BOAT_4_NAME_3;
				port_vb = VarbitID.SAILING_BOAT_4_PORT;
				hp_vb = VarbitID.SAILING_BOAT_4_STORED_HP;
				maxhp_vb = VarbitID.SAILING_BOAT_4_STORED_MAXHP;
				owned_vb = VarbitID.SAILING_BOAT_4_OWNED;
				type_vb = VarbitID.SAILING_BOAT_4_TYPE;
				break;
			case 5:
				name1_vb = VarbitID.SAILING_BOAT_5_NAME_1;
				name2_vb = VarbitID.SAILING_BOAT_5_NAME_2;
				name3_vb = VarbitID.SAILING_BOAT_5_NAME_3;
				port_vb = VarbitID.SAILING_BOAT_5_PORT;
				hp_vb = VarbitID.SAILING_BOAT_5_STORED_HP;
				maxhp_vb = VarbitID.SAILING_BOAT_5_STORED_MAXHP;
				owned_vb = VarbitID.SAILING_BOAT_5_OWNED;
				type_vb = VarbitID.SAILING_BOAT_5_TYPE;
				break;
			default:
				break;
		}

		updateName();
		updatePort();
		updateOwned();
		updateType();
	}

	public boolean isOwned() {
		return this.owned;
	}

	public void updateHealth() {
		int hp = client.getVarbitValue(hp_vb);
		int maxhp = client.getVarbitValue(maxhp_vb);

		if (maxhp > 0) {
			health = (float) hp / (float) maxhp;
		}
		else {
			health = 1; // might need to store the last hp ourselves
		}
	}

	public void updateType() {
		boatType = BoatType.fromId(client.getVarbitValue(type_vb));
	}

	public void updateOwned() {
		// not sure why the owned varbit isn't reliable but hey-ho!
		if (client.getVarbitValue(owned_vb) > 0 || client.getVarbitValue(port_vb) > 0 || client.getVarbitValue(name2_vb) > 0) {
			this.owned = true;
		}
		else {
			this.owned = false;
		}
	}

	public void updatePort() {
		int portbit = client.getVarbitValue(port_vb);

		this.portId = portbit;
		this.port = Port.getPort(portbit);
	}

	public void updateName() {
		int name1bit = client.getVarbitValue(name1_vb);
		int name2bit = client.getVarbitValue(name2_vb);
		int name3bit = client.getVarbitValue(name3_vb);
		
		// if none of the names are set we don't own the ship yet
		if ((name1bit + name2bit + name3bit) == 0) {
			boatName = "Boat "+boatID;
			return;
		}

		// get indices
		name1bit--;
		name2bit--;
		name3bit--;
		
		int option_col = DBTableID.SailingBoatNameOptions.COL_OPTION;

		ArrayList<String> names = new ArrayList<String>();

		if (name1bit > 0) {
			Object[] prefix_opts = client.getDBTableField(DBTableID.SailingBoatNameOptions.Row.SAILING_BOAT_NAME_PREFIX_OPTIONS, option_col, 0);

			String name1 = (String) prefix_opts[name1bit];
			if (name1 != null && name1.length() > 0) names.add(name1);
		}

		if (name2bit > 0) {
			Object[] desc_opts = client.getDBTableField(DBTableID.SailingBoatNameOptions.Row.SAILING_BOAT_NAME_DESCRIPTOR_OPTIONS, option_col, 0);

			String name2 = (String) desc_opts[name2bit];
			if (name2 != null && name2.length() > 0) names.add(name2);
		}

		if (name3bit > 0) {
			Object[] noun_opts = client.getDBTableField(DBTableID.SailingBoatNameOptions.Row.SAILING_BOAT_NAME_NOUN_OPTIONS, option_col, 0);
			
			String name3 = (String) noun_opts[name3bit];
			if (name3 != null && name3.length() > 0) names.add(name3);
		}
		
		boatName = String.join(" ", names);
	}
}
package com.wheresmyboat.enums;

import lombok.Getter;

@Getter
public enum BoatType
{
	RAFT(8110,0,"Raft",7111),
	SKIFF(8111,1,"Sloop",7112),
	SLOOP(8112,2,"Sloop",7113),
	TUTORIAL(8113,3,"Will and Anne's boat",7112)
	;
	private final int dbRow;
	private final int id;
	private final String name;
	private final int spriteID;

	BoatType(int dbRow, int id, String name, int spriteID)
	{
		this.dbRow = dbRow;
		this.id = id;
		this.name = name;
		this.spriteID = spriteID;
	}

	static
	{
		// init
	}

	public static BoatType fromDBRow(int dbRow) {
		for (BoatType p : BoatType.values()) {
			if (p.dbRow == dbRow) {
				return p;
			}
		}
		return null;
	}

	public static BoatType fromId(int id) {
		for (BoatType p : BoatType.values()) {
			if (p.id == id) {
				return p;
			}
		}
		return null;
	}

	@Override
	public String toString()
	{
		return name;
	}
}
/*
 * Copyright (c) 2025, nucleon <https://github.com/nucleon>
 * Copyright (c) 2025, Cooper Morris <https://github.com/coopermor>
 * Copyright (c) 2025, AtchRBX <https://github.com/AtchRBX>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.wheresmyboat.enums;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
public enum Port
{
	PORT_SARIM(0,"Port Sarim", 1, new WorldPoint(3050, 3192, 0),7115),
	THE_PANDEMONIUM(1,"The Pandemonium", 1, new WorldPoint(3069, 2986, 0),7116),
	LANDS_END(2,"Land's End", 5, new WorldPoint(1506, 3402, 0),7117),
	MUSA_POINT(3,"Musa Point", 10, new WorldPoint(2960, 3147, 0),7118),
	HOSIDIUS(4,"Hosidius", 5, new WorldPoint(1726, 3452, 0),7119),
	RIMMINGTON(5,"Rimmington", 18, new WorldPoint(2905, 3226, 0),7120),
	CATHERBY(6,"Catherby", 20, new WorldPoint(2796, 3412, 0),7121),
	PORT_PISCARILLIUS(7,"Port Piscarillius", 15, new WorldPoint(1845, 3687, 0),7122),
	BRIMHAVEN(8,"Brimhaven", 25, new WorldPoint(2757, 3229, 0),7123),
	ARDOUGNE(9,"Ardougne", 28, new WorldPoint(2671, 3265, 0),7124),
	PORT_KHAZARD(10,"Port Khazard", 30, new WorldPoint(2685, 3161, 0),7125),
	WITCHAVEN(11,"Witchaven", 34, new WorldPoint(2746, 3304, 0),7126),
	ENTRANA(12,"Entrana", 36, new WorldPoint(2878, 3335, 0),7127),
	CIVITAS_ILLA_FORTIS(13,"Civitas illa Fortis", 38, new WorldPoint(1774, 3141, 0),7128),
	CORSAIR_COVE(14,"Corsair Cove", 40, new WorldPoint(2579, 2843, 0),7129),
	CAIRN_ISLE(15,"Cairn Isle", 42, new WorldPoint(2749, 2951, 0),7130),
	SUNSET_COAST(16,"Sunset Coast", 44, new WorldPoint(1511, 2975, 0),7131),
	THE_SUMMER_SHORE(17,"The Summer Shore", 45, new WorldPoint(3174, 2367, 0),7132),
	ALDARIN(18,"Aldarin", 46, new WorldPoint(1452, 2970, 0),7133),
	RUINS_OF_UNKAH(19,"Ruins of Unkah", 48, new WorldPoint(3143, 2824, 0),7134),
	VOID_KNIGHTS_OUTPOST(20,"Void Knights' Outpost", 50, new WorldPoint(2651, 2678, 0),7135),
	PORT_ROBERTS(21,"Port Roberts", 50, new WorldPoint(1860, 3306, 0),7136),
	RED_ROCK(22,"Red Rock",52,new WorldPoint(2752,2496,0),7137),
	RELLEKKA(23,"Rellekka", 62, new WorldPoint(2630, 3705, 0),7138),
	ETCETERIA(24,"Etceteria", 65, new WorldPoint(2611, 3840, 0),7139),
	PORT_TYRAS(25,"Port Tyras", 66, new WorldPoint(2144, 3120, 0),7140),
	DEEPFIN_POINT(26,"Deepfin Point", 67, new WorldPoint(1923, 2758, 0),7141),
	JATIZSO(27,"Jatizso", 68, new WorldPoint(2412, 3780, 0),7142),
	NETIZNOT(28,"Netiznot", 68, new WorldPoint(2308, 3783, 0),7143),
	PRIFDDINAS(29,"Prifddinas", 70, new WorldPoint(2158, 3324, 0),7144),
	PISCATORIS(30,"Piscatoris", 75, new WorldPoint(2303, 3690, 0),7145),
	LUNAR_ISLE(31,"Lunar Isle", 76, new WorldPoint(2151, 3880, 0),7146),
	ISLE_OF_SOULS(32,"Isle of Souls", 55, new WorldPoint(2282, 2823, 0),7147),
	WATERBIRTH_ISLAND(33,"Waterbirth Island", 74, new WorldPoint(2543, 3765, 0),7148),
	WEISS(34,"Weiss", 80, new WorldPoint(2860, 3972, 0),7149),
	DOGNOSE_ISLAND(35,"Dognose Island", 40, new WorldPoint(3061, 2639, 0),7150),
	REMOTE_ISLAND(36,"Remote Island", 45, new WorldPoint(2971, 2603, 0),7151),
	THE_LITTLE_PEARL(37,"The Little Pearl", 45, new WorldPoint(3354, 2216, 0),7152),
	THE_ONYX_CREST(38,"The Onyx Crest", 47, new WorldPoint(2997, 2288, 0),7153),
	LAST_LIGHT(39,"Last Light",52,new WorldPoint(2850,2331,0),7154),
	CHARRED_ISLAND(40,"Charred Island", 60, new WorldPoint(2660, 2395, 0),7155),
	VATRACHOS_ISLAND(41,"Vatrachos Island", 46, new WorldPoint(1872, 2985, 0),7156),
	ANGLERS_RETREAT(42,"Anglers' Retreat", 51, new WorldPoint(2467, 2721, 0),7157),
	MINOTAURS_REST(43,"Minotaurs' Rest", 54, new WorldPoint(1958, 3117, 0),7158),
	ISLE_OF_BONES(44,"Isle of Bones", 56, new WorldPoint(2532, 2531, 0),7159),
	TEAR_OF_THE_SOUL(45,"Tear of the Soul", 61, new WorldPoint(2318, 2774, 0),7160),
	WINTUMBER_ISLAND(46,"Wintumber Island", 63, new WorldPoint(2058, 2606, 0),7161),
	THE_CROWN_JEWEL(47,"The Crown Jewel", 64, new WorldPoint(1765, 2659, 0),7162),
	RAINBOWS_END(48,"Rainbow's End", 69, new WorldPoint(2344, 2270, 0),7163),
	SUNBLEAK_ISLAND(49,"Sunbleak Island", 72, new WorldPoint(2189, 2327, 0),7164),
	SHIMMERING_ATOLL(50,"Shimmering Atoll", 49, new WorldPoint(1557, 2771, 0),7165),
	LAGUNA_AURORAE(51,"Laguna Aurorae", 58, new WorldPoint(1202, 2733, 0),7166),
	CHINCHOMPA_ISLAND(52,"Chinchompa Island", 42, new WorldPoint(1892, 3429, 0),7167),
	LLEDRITH_ISLAND(53,"Lledrith Island", 66, new WorldPoint(2097, 3188, 0),7168),
	YNYSDAIL(54,"Ynysdail", 73, new WorldPoint(2222, 3466, 0),7169),
	BUCCANEERS_HAVEN(55,"Buccaneers' Haven", 76, new WorldPoint(2080, 3690, 0),7170),
	DRUMSTICK_ISLE(56,"Drumstick Isle", 79, new WorldPoint(2150, 3530, 0),7171),
	BRITTLE_ISLE(57,"Brittle Isle", 81, new WorldPoint(1954, 4056, 0),7172),
	GRIMSTONE(58,"Grimstone", 87, new WorldPoint(2927, 4056, 0),7173),
	;

	private final int id;
	private final String name;
	private final Integer sailingLevelRequired;
	private final WorldPoint navigationLocation;
	private final int spriteID;

	Port(int portId, String name, Integer sailingLevelRequired, WorldPoint navigationLocation, int spriteID)
	{
		this.id = portId;
		this.name = name;
		this.sailingLevelRequired = sailingLevelRequired;
		this.navigationLocation = navigationLocation;
		this.spriteID = spriteID;
	}

	static
	{
		// init
	}

	public static Port getPort(int portId) {
		for (Port p : Port.values()) {
			if (p.id == portId) {
				return p;
			}
		}
		return null;
	}

	@Override
	public String toString()
	{
		return name;
	}
}
package com.wheresmyboat;

import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.FontID;
import net.runelite.client.callback.ClientThread;
import net.runelite.api.GameState;
import net.runelite.api.ScriptID;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetType;
import net.runelite.api.gameval.DBTableID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;

import com.google.inject.Provides;

import com.wheresmyboat.enums.BoatType;
import com.wheresmyboat.enums.Port;

@Slf4j
@PluginDescriptor(
	name = "Dude, Where's My Boat?"
)
public class WheresMyBoat extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private WheresMyBoatConfig config;

	@Inject
	private WorldMapPointManager worldMapPointManager;

	private Boat[] boats;

	@Override
	protected void startUp() throws Exception
	{
		log.debug("Starting DWMB...");

		boats = new Boat[5];

		clientThread.invoke(() -> {
			if(client.getGameState() == GameState.LOGGED_IN) {
				for (int i = 0; i < 5; i++) {
					Boat boat = new Boat(client,i+1);
					boats[i] = boat;
				}
			}
		});
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if(gameStateChanged.getGameState() == GameState.LOGGED_IN) {
			for (int i = 0; i < 5; i++) {
				Boat boat = new Boat(client,i+1);
				boats[i] = boat;
			}
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.debug("Stopped DWMB.");
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged varbitChanged)
	{
		int id = varbitChanged.getVarbitId();

		//update name
		if (id == VarbitID.SAILING_BOAT_1_NAME_1 || id == VarbitID.SAILING_BOAT_1_NAME_2 || id == VarbitID.SAILING_BOAT_1_NAME_3)
			boats[0].updateName();
		if (id == VarbitID.SAILING_BOAT_2_NAME_1 || id == VarbitID.SAILING_BOAT_2_NAME_2 || id == VarbitID.SAILING_BOAT_2_NAME_3)
			boats[1].updateName();
		if (id == VarbitID.SAILING_BOAT_3_NAME_1 || id == VarbitID.SAILING_BOAT_3_NAME_2 || id == VarbitID.SAILING_BOAT_3_NAME_3)
			boats[2].updateName();
		if (id == VarbitID.SAILING_BOAT_4_NAME_1 || id == VarbitID.SAILING_BOAT_4_NAME_2 || id == VarbitID.SAILING_BOAT_4_NAME_3)
			boats[3].updateName();
		if (id == VarbitID.SAILING_BOAT_5_NAME_1 || id == VarbitID.SAILING_BOAT_5_NAME_2 || id == VarbitID.SAILING_BOAT_5_NAME_3)
			boats[4].updateName();

		// update port
		if (id == VarbitID.SAILING_BOAT_1_PORT)
			boats[0].updatePort();
		if (id == VarbitID.SAILING_BOAT_2_PORT)
			boats[1].updatePort();
		if (id == VarbitID.SAILING_BOAT_3_PORT)
			boats[2].updatePort();
		if (id == VarbitID.SAILING_BOAT_4_PORT)
			boats[3].updatePort();
		if (id == VarbitID.SAILING_BOAT_5_PORT)
			boats[4].updatePort();

		// update health
		if (id == VarbitID.SAILING_BOAT_1_STORED_HP || id == VarbitID.SAILING_BOAT_1_STORED_MAXHP)
			boats[0].updateHealth();
		if (id == VarbitID.SAILING_BOAT_2_STORED_HP || id == VarbitID.SAILING_BOAT_2_STORED_MAXHP)
			boats[1].updateHealth();
		if (id == VarbitID.SAILING_BOAT_3_STORED_HP || id == VarbitID.SAILING_BOAT_3_STORED_MAXHP)
			boats[2].updateHealth();
		if (id == VarbitID.SAILING_BOAT_4_STORED_HP || id == VarbitID.SAILING_BOAT_4_STORED_MAXHP)
			boats[3].updateHealth();
		if (id == VarbitID.SAILING_BOAT_5_STORED_HP || id == VarbitID.SAILING_BOAT_5_STORED_MAXHP)
			boats[4].updateHealth();

		// update ownership
		if (id == VarbitID.SAILING_BOAT_1_OWNED)
			boats[0].updateOwned();
		if (id == VarbitID.SAILING_BOAT_2_OWNED)
			boats[1].updateOwned();
		if (id == VarbitID.SAILING_BOAT_3_OWNED)
			boats[2].updateOwned();
		if (id == VarbitID.SAILING_BOAT_4_OWNED)
			boats[3].updateOwned();
		if (id == VarbitID.SAILING_BOAT_5_OWNED)
			boats[4].updateOwned();

		// update type
		if (id == VarbitID.SAILING_BOAT_1_TYPE)
			boats[0].updateType();
		if (id == VarbitID.SAILING_BOAT_2_TYPE)
			boats[1].updateType();
		if (id == VarbitID.SAILING_BOAT_3_TYPE)
			boats[2].updateType();
		if (id == VarbitID.SAILING_BOAT_4_TYPE)
			boats[3].updateType();
		if (id == VarbitID.SAILING_BOAT_5_TYPE)
			boats[4].updateType();

		updateSailingPanel();
	}

	private void updateMapIcons() {
		worldMapPointManager.removeIf(BoatWorldMapPoint.class::isInstance);
		
		if (config.worldMarkersEnabled()) {
			for (int i = 0; i < 5; i++) {
				Boat boat = boats[i];
				if (boat == null || !boat.isOwned()) continue;

				Port port = boat.getPort();
				if (port != null) {
					worldMapPointManager.add(new BoatWorldMapPoint(i,boat.getBoatName(),port.getNavigationLocation(),config));
				}
			}
		}
	}

	private void updateSailingPanel() {
		if (!config.sailingPanelEnabled()) return;

		int panelState = client.getVarbitValue(VarbitID.SAILING_SIDEPANEL_TABS); // if we not on the facilities tab don't update it
		if (panelState != 0) return;

		int hasBoarded = client.getVarbitValue(VarbitID.SAILING_BOARDED_BOAT); // if we on a boat don't update it
		if (hasBoarded != 0) return;

		Widget titleWidget = client.getWidget(InterfaceID.SailingSidepanel.TAB_TITLE);
		if (titleWidget == null) return;

		Widget titleLabel = titleWidget.getChild(0);
		titleLabel.setText("Docked Ships");

		Widget facilitiesWidget = client.getWidget(InterfaceID.SailingSidepanel.FACILITIES_CONTENT);
		if (facilitiesWidget == null) return;

		facilitiesWidget.deleteAllChildren();

		for (int i = 0; i < 5; i++) {
			Boat boat = boats[i];
			if (boat == null) {
				continue;
			}

			String boatName = boat.getBoatName();
			String portName = Integer.toString(boat.getPortId());

			int boatColor = 0xff981f;
			int portColor = 0x77eebb;

			int portSpriteID = 2851;
			int typeSpriteID = 7077;

			boolean isOwned = boat.isOwned();
			
			if (isOwned) {
				Port port = boat.getPort();
				if (port != null) {
					portName = port.toString();
					portSpriteID = port.getSpriteID();
				}
				else {
					// no enum found for port so we use dbtables to fill in the details. won't show up on the world map but better than nothing!
					var portRows = client.getDBRowsByValue(DBTableID.SailingDock.ID,DBTableID.SailingDock.COL_DOCK_ID,0,boat.getPortId());

					if (!portRows.isEmpty()) {
						int dbRow = portRows.get(0);
						portName = (String) client.getDBTableField(dbRow,DBTableID.SailingDock.COL_NICE_NAME, 0)[0];
						portSpriteID = (int) client.getDBTableField(dbRow,DBTableID.SailingDock.COL_DOCK_SPRITE_SMALL, 0)[0];
					}
				}

				BoatType boatType = boat.getBoatType();
				if (boatType != null) {
					typeSpriteID = boatType.getSpriteID();
				}
			}
			else {
				portName = "Not Owned";
				portColor = 0x91bea9;
			}
			
			//int health = (int) (boat.getHealth()*100);

			int layerWidth = facilitiesWidget.getWidth();

			Widget boatLayer = facilitiesWidget.createChild(WidgetType.LAYER);
			boatLayer.setName("FACILITIES_BOAT_ITEM");
			boatLayer.setSize(layerWidth, 30);
			boatLayer.setPos(0,i*30);
			boatLayer.revalidate();

			int PADDING_X = 23;

			Widget boatLabel = boatLayer.createChild(WidgetType.TEXT);
			boatLabel.setPos(PADDING_X,2);
			boatLabel.setOriginalHeight(12);
			boatLabel.setOriginalWidth(layerWidth-20);
			boatLabel.setTextShadowed(true);
			boatLabel.setText(boatName);
			boatLabel.setFontId(FontID.PLAIN_11);
			boatLabel.setTextColor(boatColor);
			boatLabel.revalidate();

			Widget typeIcon = boatLayer.createChild(WidgetType.GRAPHIC);
			typeIcon.setPos(0,3);
			typeIcon.setSize(20,20);
			typeIcon.setSpriteId(typeSpriteID);
			typeIcon.revalidate();

			if (isOwned) {
				Widget portIcon = boatLayer.createChild(WidgetType.GRAPHIC);
				portIcon.setPos(0,4);
				portIcon.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT);
				portIcon.setSize(18,18);
				portIcon.setSpriteId(portSpriteID);
				portIcon.revalidate();
			}

			Widget portLabel = boatLayer.createChild(WidgetType.TEXT);
			portLabel.setPos(PADDING_X,15);
			portLabel.setOriginalHeight(12);
			portLabel.setOriginalWidth(layerWidth-20);
			portLabel.setTextShadowed(true);
			portLabel.setText(portName);
			portLabel.setFontId(FontID.PLAIN_11);
			portLabel.setTextColor(portColor);
			portLabel.revalidate();

			Widget divider = boatLayer.createChild(WidgetType.LINE);
			divider.setOriginalHeight(0);
			divider.setOriginalWidth(layerWidth);
			divider.setPos(0,29);
			divider.setTextColor(0x666666);
			divider.revalidate();
		}
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired scriptPostFired)
	{
		int id = scriptPostFired.getScriptId();

		if (id == 8712) {
			updateSailingPanel();
		}
		if (id == ScriptID.WORLDMAP_LOADMAP) {
			updateMapIcons();
		}
	}

	@Provides
	WheresMyBoatConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(WheresMyBoatConfig.class);
	}
}

package com.wheresmyboat;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("wheresmyboat")
public interface WheresMyBoatConfig extends Config
{
	
	@ConfigSection(
		name = "Sailing Panel",
		description = "Settings for the Sailing Panel display",
		position = 1
	)
	String sailingPanel = "sailingPanel";

	@ConfigItem(
		keyName = "sailingPanelEnabled",
		name = "Sailing Panel Display",
		description = "Show where your ships are docked in the Sailing Panel when not on a ship.",
		section = "sailingPanel"
	)
	default boolean sailingPanelEnabled()
	{
		return true;
	}

	@ConfigSection(
		name = "World Markers",
		description = "Settings for World Map display",
		position = 1
	)
	String worldMarkers = "worldMarkers";

	@ConfigItem(
		keyName = "worldMarkersEnabled",
		position = 0,
		name = "Ship Markers",
		description = "Show where your ships are docked on the World Map.",
		section = "worldMarkers"
	)
	default boolean worldMarkersEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "snapToEdge",
		position = 1,
		name = "Snap to Edge",
		description = "Snap Ship Markers to map edge.",
		section = "worldMarkers"
	)
	default boolean snapToEdge()
	{
		return false;
	}

	//

	@ConfigItem(
		keyName = "boat1hp",
		name = "",
		description = "",
		hidden = true
	)
	default int boat1hp() {
		return 1;
	}
}

package com.wheresmyboat;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;

import org.apache.commons.text.WordUtils;

import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;
import net.runelite.client.util.ImageUtil;

class BoatWorldMapPoint extends WorldMapPoint
{
	private final BufferedImage clueScrollWorldImage;
	private final Point clueScrollWorldImagePoint;

	BoatWorldMapPoint(int boatNum, String boatName, final WorldPoint worldPoint, WheresMyBoatConfig config)
	{
		super(worldPoint, null);

		final Font shipFont = FontManager.getDefaultFont().deriveFont(1,8);

		BufferedImage imgSrc = ImageUtil.loadImageResource(getClass(), "/boatmarker.png");
		
		int width = imgSrc.getWidth();

		int srcHeight = imgSrc.getHeight();
		int height = srcHeight + 8;

		clueScrollWorldImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
		Graphics2D graphics = clueScrollWorldImage.createGraphics();

		Color hueCol = Color.getHSBColor(boatNum / 5.0f,1.0f,1f);

		graphics.drawImage(imgSrc, 0, 8, width, srcHeight, null);

		graphics.setColor(hueCol);
		graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, 0.5f));

		graphics.fillRect(0,0,width,height);

		// draw the initials

		String inits = WordUtils.initials(boatName);

		FontRenderContext frc = graphics.getFontRenderContext();
        TextLayout tl = new TextLayout(inits, shipFont, frc);
        Shape shape = tl.getOutline(null);

		Rectangle txtBounds = shape.getBounds();

		AffineTransform transform = graphics.getTransform();
        transform.translate(width/2 - txtBounds.getWidth()/2, txtBounds.getHeight()+1);
        graphics.transform(transform);
		
		graphics.setComposite(AlphaComposite.Src);

		graphics.setColor(new Color(0.0f,0.0f,0.0f,0.75f));
        graphics.setStroke(new BasicStroke(2f));
        graphics.draw(shape);
        graphics.setColor(Color.white);
        graphics.fill(shape);

		graphics.dispose();

		// set up the actual marker

		clueScrollWorldImagePoint = new Point(
			width / 2 + boatNum*2, // staggered by boatNum so they don't overlap each other too hard
			height + 10 + boatNum*2
		);

		if (config.snapToEdge()) {
			this.setSnapToEdge(true);
			this.setJumpOnClick(true);
		}
		
		this.setName(boatName);
		this.setImage(clueScrollWorldImage);
		this.setImagePoint(clueScrollWorldImagePoint);
	}
}
package com.wheresmyboat;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class WheresMyBoatTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(WheresMyBoat.class);
		RuneLite.main(args);
	}
}
