package com.profittracker;

import com.google.gson.Gson;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;

import net.runelite.api.events.*;

import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.RuneScapeProfileChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.game.chatbox.ChatboxTextInput;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.api.events.VarbitChanged;

import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@PluginDescriptor(
        name = "Profit Tracker",
        description = "Tracks profit according to the value of your items.",
        tags = {"overlay"}
)
public class ProfitTrackerPlugin extends Plugin
{
    ProfitTrackerGoldDrops goldDropsObject;
    ProfitTrackerInventoryValue inventoryValueObject;

    // the profit will be calculated against this value
    private long prevInventoryValue;
    // Holds session data for the current account
    private ProfitTrackerRecord accountRecord;
    private String previousAccount;
    // Collection of items that was last used to calculate value, includes inventory and equipment
    private long totalProfit;

    private long startTickMillis;
    private long activeTicks;

    private boolean skipTickForProfitCalculation;
    private boolean inventoryValueChanged;
    private boolean bankValueChanged;
    private boolean grandExchangeValueChanged;
    private boolean inProfitTrackSession;
    private boolean runePouchContentsChanged;
    // State boolean for when a widget we do not fully track is currently opened, such as the leprechaun tool store
    private boolean untrackedStorageOpened;
    // Remembers the state of bank interface
    private boolean bankOpened;
    // Remembers the state of grand exchange
    private boolean grandExchangeOpened;
    // Set when using a deposit menu option. Used to create a depositing deficit for the next time you open bank
    // This ensures using a deposit box doesn't spam coin drops, but also doesn't get out of sync when the race
    // condition with menu options and container changes causes some anyway
    private boolean depositingItem;
    // State of a deposit box being open, used to avoid tracking profit changes when just sending to the bank
    private boolean depositBoxOpened;
    // Tracks the last widget we care about that closed, like bank, GE, other storage
    private int closingWidgetId;
    // Tracks when an event causes an item to be stored to an untracked location, like using an item on a tackle box
    private boolean depositingUntrackedItem;

    private final int[] RUNE_POUCH_VARBITS = {
            VarbitID.RUNE_POUCH_QUANTITY_1,
            VarbitID.RUNE_POUCH_QUANTITY_2,
            VarbitID.RUNE_POUCH_QUANTITY_3,
            VarbitID.RUNE_POUCH_QUANTITY_4,
            VarbitID.RUNE_POUCH_TYPE_1,
            VarbitID.RUNE_POUCH_TYPE_2,
            VarbitID.RUNE_POUCH_TYPE_3,
            VarbitID.RUNE_POUCH_TYPE_4
    };

    @Inject
    private Client client;

    @Inject
    private ProfitTrackerConfig config;

    @Inject
    private ItemManager itemManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private ProfitTrackerOverlay overlay;

    @Inject
    private ConfigManager configManager;

    @Inject
    private Gson gson;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ChatboxPanelManager chatboxPanelManager;

    @Override
    protected void startUp() throws Exception
    {
        // Add the inventory overlay
        overlayManager.add(overlay);

        goldDropsObject = new ProfitTrackerGoldDrops(client, itemManager, config);

        inventoryValueObject = new ProfitTrackerInventoryValue(client, itemManager, config);

        initializeVariables();
    }

    private void initializeVariables()
    {
        inventoryValueObject.setOffers(null);

        // profit begins at 0 of course
        totalProfit = 0;

        // this will be filled with actual information in startProfitTrackingSession
        startTickMillis = 0;
        activeTicks = 0;

        // skip profit calculation for first tick, to initialize first inventory value
        skipTickForProfitCalculation = true;

        inventoryValueChanged = false;

        bankValueChanged = false;

        grandExchangeValueChanged = false;

        inProfitTrackSession = false;

        runePouchContentsChanged = false;

        depositingItem = false;
    }

    private void startProfitTrackingSession()
    {
        /*
        Start tracking profit from now on
         */

        initializeVariables();

        // initialize timer
        startTickMillis = System.currentTimeMillis();

        activeTicks = 0;

        overlay.updateStartTimeMillies(startTickMillis);

        overlay.updateActiveTicks(activeTicks);

        overlay.updateProfitValue(totalProfit);

        overlay.startSession();

        inProfitTrackSession = true;
    }

    public void resetSession(boolean hardReset){
        initializeVariables();
        startProfitTrackingSession();
        inventoryValueChanged = true;
        if (accountRecord != null) {
            accountRecord.reset(configManager, hardReset);
            accountRecord.save(gson);
            overlay.updateBankStatus(accountRecord);
        }
    }

    /**
     * Creates an entry for the current login if needed.
     * Hooks up the possessions collection for repeat use for the current login.
     */
    private void checkAccount()
    {
        String accountIdentifier = ProfitTrackerRecord.getAccountRecordKey(client);
        if (accountIdentifier == null) {
            return;
        }
        boolean changedAccounts = previousAccount != null && ! previousAccount.contentEquals(accountIdentifier);

        if (previousAccount != null && changedAccounts) {
            // Changed account, save the items we know about
            accountRecord.save(gson);
            accountRecord = null;
        }

        if (accountRecord == null) {
            // Check for existing record
            ProfitTrackerRecord record = ProfitTrackerRecord.load(client, configManager, gson);
            if (! config.rememberProfit() && record != null) {
                record.reset(configManager, true);
            }

            if (record == null) {
                // Create a new one if not found
                accountRecord = new ProfitTrackerRecord(client);
            } else {
                accountRecord = record;
            }
        }

        totalProfit = accountRecord.profitAccumulated;
        activeTicks = accountRecord.ticksOnline;
        startTickMillis = accountRecord.startTickMillies;

        overlay.updateProfitValue(totalProfit);
        overlay.updateStartTimeMillies(startTickMillis);
        overlay.updateActiveTicks(activeTicks);

        overlay.updateBankStatus(accountRecord);

        previousAccount = accountIdentifier;
    }

    @Subscribe
    public void onRuneScapeProfileChanged(RuneScapeProfileChanged e)
    {
        checkAccount();
    }

    @Override
    protected void shutDown() throws Exception
    {
        // Remove the inventory overlay
        overlayManager.remove(overlay);
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) throws Exception
    {
        /*
        Main plugin logic here

        1. If inventory changed,
            - calculate profit (inventory value difference)
            - generate gold drop (nice animation for showing gold earn or loss)

        2. Calculate profit rate and update in overlay

        */

        long tickProfit;

        if (!inProfitTrackSession)
        {
            if (accountRecord != null){
                overlay.startSession();
                inProfitTrackSession = true;
                inventoryValueChanged = true;
                // Active ticks will only be 0 if toggling the plugin
                if (activeTicks == 0) {
                    resetSession(true);
                }
            } else {
                return;
            }
        }

        if (accountRecord.name == null && client.getGameState() == GameState.LOGGED_IN) {
            accountRecord.name = client.getLocalPlayer().getName();
        }

        activeTicks += 1;
        accountRecord.ticksOnline = activeTicks;
        overlay.updateActiveTicks(activeTicks);

        if (inventoryValueChanged || runePouchContentsChanged || bankValueChanged || grandExchangeValueChanged)
        {
            tickProfit = calculateProfit();

            // Generate gold drop only based on instantaneous profit, to avoid scaring users during GE adjustment ticks
            if (config.goldDrops() && tickProfit != 0)
            {
                goldDropsObject.requestGoldDrop(tickProfit);
            }

            totalProfit += tickProfit;

            if (tickProfit != 0) {
                // This causes total profit to only update when we profit off something.
                // While this may cause temporary inaccuracy when GE prices change, it prevents excessive calculations
                // every time an item is moved, equipped, deposited, etc.
                totalProfit = inventoryValueObject.calculateItemValue(accountRecord.itemDifferenceAccumulated);
            }

            accountRecord.profitAccumulated = totalProfit;
            overlay.updateProfitValue(totalProfit);

            inventoryValueChanged = false;
            bankValueChanged = false;
            runePouchContentsChanged = false;
            grandExchangeValueChanged = false;
            depositingItem = false;
        }
        resetWidgetClosedVariables();
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event)
    {
        boolean isStorage = true;
        switch (event.getGroupId()) {
            case InterfaceID.BANKMAIN:
                // Bank contents will be null if the bank has no items when first logging in
                if (inventoryValueObject.getBankContents() == null && accountRecord.currentPossessions.bankItems == null) {
                    accountRecord.updateBankItems(new Item[0]);
                    overlay.updateBankStatus(accountRecord);
                }
                bankOpened = true;
                break;
            case InterfaceID.GE_COLLECT:
            case InterfaceID.GE_OFFERS:
                inventoryValueObject.setOffers(client.getGrandExchangeOffers());
                grandExchangeOpened = true;
                break;
            case InterfaceID.BANK_DEPOSIT_IMP:
            case InterfaceID.BANK_DEPOSITBOX:
                depositBoxOpened = true;
                break;
            case InterfaceID.HUNTSMANS_KIT:
            case InterfaceID.SEED_VAULT:
            case InterfaceID.TACKLE_BOX_MAIN:
            case InterfaceID.FARMING_TOOLS:
                untrackedStorageOpened = true;
                break;
            default:
                isStorage = false;
                break;
        }
        if (isStorage) {
            // If a user is flipping through multiple storages tick after tick, and moving items in/out
            // tracking can get complicated.
            // So we reset immediately to avoid longer term desyncs, like jumping between GE and bank
            resetWidgetClosedVariables();
        }
    }

    @Subscribe
    public void onWidgetClosed(WidgetClosed event)
    {
        // Widget closes immediately, but items can still transfer between containers the next tick
        // So actually flagging them is done at the end of the next tick, we just set a variable here to look for later
        switch (event.getGroupId()) {
            case InterfaceID.BANKMAIN:
            case InterfaceID.HUNTSMANS_KIT:
            case InterfaceID.SEED_VAULT:
            case InterfaceID.TACKLE_BOX_MAIN:
            case InterfaceID.FARMING_TOOLS:
            case InterfaceID.GE_COLLECT:
            case InterfaceID.GE_OFFERS:
            case InterfaceID.BANK_DEPOSIT_IMP:
            case InterfaceID.BANK_DEPOSITBOX:
                closingWidgetId = event.getGroupId();
                break;
        }
    }

    /**
     * Clears the associated variable for the last opened storage widget
     * Should be called with closingWidgetId
     */
    private void resetWidgetClosedVariables(){
        if (closingWidgetId != 0) {
            switch (closingWidgetId) {
                case InterfaceID.BANKMAIN:
                    bankOpened = false;
                    break;
                case InterfaceID.HUNTSMANS_KIT:
                case InterfaceID.SEED_VAULT:
                case InterfaceID.TACKLE_BOX_MAIN:
                case InterfaceID.FARMING_TOOLS:
                    untrackedStorageOpened = false;
                    break;
                case InterfaceID.GE_COLLECT:
                case InterfaceID.GE_OFFERS:
                    grandExchangeOpened = false;
                    break;
                case InterfaceID.BANK_DEPOSIT_IMP:
                case InterfaceID.BANK_DEPOSITBOX:
                    depositBoxOpened = false;
                    break;
            }
            closingWidgetId = 0;
        }
    }

    private long calculateProfit()
    {
        /*
        Calculate and return the profit for this tick
        if skipTickForProfitCalculation is set, meaning this tick was bank / deposit
        so return 0
         */
        ProfitTrackerPossessions newPossessions = new ProfitTrackerPossessions();
        newPossessions.grandExchangeItems = null;
        long newProfit = 0;
        Item[] possessionDifference = null;

        // calculate current inventory value
        newPossessions.inventoryItems = inventoryValueObject.getInventoryAndEquipmentContents();
        newPossessions.bankItems = inventoryValueObject.getBankContents();
        if (grandExchangeValueChanged) {
            newPossessions.grandExchangeItems = inventoryValueObject.getGrandExchangeContents();
        }
        accountRecord.currentPossessions.fillNullItems(newPossessions);
        newPossessions.fillNullItems(accountRecord.currentPossessions);
        Item[] newItems = newPossessions.getItems();

        if (!skipTickForProfitCalculation && accountRecord.currentPossessions.inventoryItems != null && newItems != null)
        {
            // calculate new profit
            possessionDifference = inventoryValueObject.getItemCollectionDifference(accountRecord.currentPossessions.getItems(), newItems, config.estimateUntradeables());
            newProfit = inventoryValueObject.calculateItemValue(possessionDifference);

            log.debug("Calculated " + newProfit + " profit for " + (possessionDifference.length) + " item changes.");
        }
        else
        {
            /* first time calculation / banking / equipping */
            log.debug("Skipping profit calculation!");

            skipTickForProfitCalculation = false;
        }

        Item[] rawPossessionDifference = new Item[0];
        if (accountRecord.currentPossessions.getItems() != null) {
            rawPossessionDifference = ProfitTrackerInventoryValue.getItemCollectionDifference(accountRecord.currentPossessions.getItems(), newItems);
        }
        if (rawPossessionDifference.length > 0) {
            // This block generally checks for possessions changing when they shouldn't be, often when closing storage the same tick as withdraw/depositing
            // Otherwise, just records the last change seen
            boolean bankingItemsWithoutWidget = (bankOpened || depositingItem || depositBoxOpened) && inventoryValueObject.getBankContents() == null && !untrackedStorageOpened;
            // If bank/deposit box/depositing flag, any lost items are in bank, any gained items came from bank
            if (bankingItemsWithoutWidget) {
                depositingItem = false;
                Item[] bankChange = ProfitTrackerInventoryValue.getItemCollectionDifference(rawPossessionDifference, new Item[0]);
                if (accountRecord.currentPossessions.bankItems != null) {
                    newPossessions.bankItems = ProfitTrackerInventoryValue.getItemCollectionSum(accountRecord.currentPossessions.bankItems, bankChange);
                } else {
                    // Bank yet to be opened, can't deposit anything, as then it would be like it originally had almost nothing
                    accountRecord.updateItems(newPossessions, overlay);
                    return 0;
                }
            }
            // If ge opened, gained items pull from ge, items banked will cause temporary desync
            if (grandExchangeOpened && !grandExchangeValueChanged) {
                Item[] grandExchangeChange = ProfitTrackerInventoryValue.getItemCollectionDifference(rawPossessionDifference, new Item[0]);
                newPossessions.grandExchangeItems = ProfitTrackerInventoryValue.getItemCollectionSum(accountRecord.currentPossessions.grandExchangeItems, grandExchangeChange);
            }
            // If untracked storage, move lost items to untracked storage, add gained items to old record
            if (untrackedStorageOpened || depositingUntrackedItem) {
                depositingUntrackedItem = false;
                Item[] untrackedStorageChange = ProfitTrackerInventoryValue.getItemCollectionDifference(rawPossessionDifference, new Item[0]);
                newPossessions.untrackedStorageItems = ProfitTrackerInventoryValue.getItemCollectionSum(newPossessions.untrackedStorageItems, untrackedStorageChange);
                // If we go into the negatives, that means untrackedStorage originally had more items in it
                Item[] missingItems = ProfitTrackerInventoryValue.getItemCollectionGain(ProfitTrackerInventoryValue.getItemCollectionDifference(newPossessions.untrackedStorageItems, new Item[0]));
                // Ensure starting possessions has at least as many as were withdrawn
                accountRecord.startingPossessions.untrackedStorageItems = ProfitTrackerInventoryValue.getItemCollectionSum(accountRecord.startingPossessions.untrackedStorageItems, missingItems);
                accountRecord.currentPossessions.untrackedStorageItems = ProfitTrackerInventoryValue.getItemCollectionSum(accountRecord.currentPossessions.untrackedStorageItems, missingItems);
                newPossessions.untrackedStorageItems = ProfitTrackerInventoryValue.getItemCollectionSum(newPossessions.untrackedStorageItems, missingItems);
            }

            newItems = newPossessions.getItems();
            // This should always be empty in the event of a storage being opened
            rawPossessionDifference = ProfitTrackerInventoryValue.getItemCollectionDifference(accountRecord.currentPossessions.getItems(), newItems);
            if (rawPossessionDifference.length > 0) {
                accountRecord.lastPossessionChange = rawPossessionDifference;
                accountRecord.itemDifferenceAccumulated = ProfitTrackerInventoryValue.getItemCollectionSum(accountRecord.itemDifferenceAccumulated, rawPossessionDifference);
            } else {
                newProfit = 0;
            }
        }

        // update prevInventoryValue for future calculations anyway!
        //prevInventoryValue = newInventoryValue;
        accountRecord.updateItems(newPossessions, overlay);

        return newProfit;
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        /*
        this event tells us when inventory has changed
        and when banking/equipment event occurred this tick
         */
        log.debug("onItemContainerChanged container id: " + event.getContainerId());

        int containerId = event.getContainerId();

        if (containerId == InventoryID.INV ||
            containerId == InventoryID.WORN) {
            // Inventory has changed - need calculate profit in onGameTick
            inventoryValueChanged = true;
        }

        if (containerId == InventoryID.BANK) {
            bankValueChanged = true;
        }

        // No container event occurs for the GE collection item containers, but inventory does
        if (grandExchangeOpened && closingWidgetId != InterfaceID.GE_OFFERS && closingWidgetId != InterfaceID.GE_COLLECT) {
            inventoryValueObject.setOffers(client.getGrandExchangeOffers());
            grandExchangeValueChanged = true;
        }
    }

    @Subscribe
    public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged event)
    {
        if (grandExchangeOpened && closingWidgetId != InterfaceID.GE_OFFERS && closingWidgetId != InterfaceID.GE_COLLECT){
            inventoryValueObject.setOffers(client.getGrandExchangeOffers());
            grandExchangeValueChanged = true;
        }
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event)
    {
        if (Arrays.stream(RUNE_POUCH_VARBITS).anyMatch(vb -> event.getVarbitId() == vb)){
            runePouchContentsChanged = true;
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event) {
        /* for ignoring deposit in deposit box */
        log.debug(String.format("Click! ID: %d ,menuOption: %s, menuTarget: %s",
                  event.getId(), event.getMenuOption(), event.getMenuTarget()));
        String menuOption = event.getMenuOption();

        String[] containerMenuOptions = {"Deposit-"};
        for (String containerMenuOption : containerMenuOptions) {
            if (menuOption.startsWith(containerMenuOption)) {
                // Backup catch for various bank interfaces to deposit items
                // Event object does not seem to provide information that would otherwise tell us it's a bank
                // Still, it is possible to have game tick happen before a container changes to reflect menu option,
                // which can cause unexpected profit/loss, particularly when clicking a lot in a deposit box.
                depositingItem = true;
                break;
            }
        }

        String[] collectionMenuOptions = {"Collect to bank", "Bank"};
        for (String collectionMenuOption : collectionMenuOptions) {
            if (menuOption.startsWith(collectionMenuOption) && grandExchangeOpened) {
                depositingItem = true;
                break;
            }
        }

        // Imp in a box acts like a deposit box, both via interface, and use interaction
        if (menuOption.startsWith("Use") && event.getMenuTarget().contains("Imp-in-a-box(")){
            depositingItem = true;
        }

        // Container items
        // Ignore profit changes for items that act as storage only
        switch (event.getItemId()) {
            case ItemID.RCU_POUCH_COLOSSAL: // Fill, empty | fill, empty | essence must be taken out to use
            case ItemID.RCU_POUCH_GIANT:
            case ItemID.RCU_POUCH_LARGE:
            case ItemID.RCU_POUCH_MEDIUM:
            case ItemID.RCU_POUCH_SMALL:

            case ItemID.HUNTSMANS_KIT: // Fill, Empty, view(custom storage interface)
            case ItemID.TACKLE_BOX: // View, ??
                switch (menuOption.toLowerCase()) {
                    // These items act as long term storage, and are more like banks
                    // Items are not used directly from them either
                    case "empty":
                    case "fill":
                    case "use":
                        log.debug("Ignoring storage item interaction.");
                        // Ignore manual changes to container items as the items have not been lost
                        depositingUntrackedItem = true;
                }
        }

        // Half-volatile storage
        // Items that can change from pure storage to volatile storage by opening
        switch (event.getItemId()) {
            case ItemID.FISH_SACK_BARREL_CLOSED:
            case ItemID.FISH_BARREL_CLOSED: //Fill, open | empty
            case ItemID.GEM_BAG: //Fill, empty, open | empty
            case ItemID.SLAYER_HERB_SACK: // Fill, empty, open | empty

            case ItemID.SEED_BOX: // Fill, Empty, Check, Open

            case ItemID.HG_MEATPOUCH_SMALL: // Fill, Empty
            case ItemID.HG_MEATPOUCH_LARGE: // Fill, Empty
            case ItemID.HG_FURPOUCH_SMALL: // Fill, Empty
            case ItemID.HG_FURPOUCH_MED: // Fill, Empty
            case ItemID.HG_FURPOUCH_LARGE: // Fill, Empty
                switch (menuOption.toLowerCase()) {
                    // These items act as long term storage, and are more like banks
                    // Items are not used directly from them either
                    case "empty":
                    case "fill":
                    case "use":
                        skipTickForProfitCalculation = false;
                }
        }

        // If items can be used directly from the storage container, count the profit as otherwise we might not see
        // them get used, including interface only withdraws
        switch (event.getItemId()) {
            case ItemID.PLANK_SACK: // Fill, empty | use (dumps into inventory)
                // Items can be used directly from sack
                // Filling sack requires inventory as intermediate

            case ItemID.COAL_BAG: // Fill, empty, open | fill, empty
                //Coal can be directly used from the sack, and be filled directly from bank

                // case ItemID.BASKET: //Fill, remove-one, empty | fill | basket turns into different name like "Bananas(#)"
                //Empty sack
            case ItemID.XBOWS_BOLT_POUCH: //Open(remove interface) | | bolts can be worn via armor interface extra ammo slot
                //Rune pouch // Covered by withdraw interface

            case ItemID.FLAMTAER_BAG: // Fill, empty | empty (dumps into inventory) | items can be used directly from sack
            case ItemID.BOOKOFSCROLLS_CHARGED: // Interface with remove option | items can be used from book via activate and teleport
            case ItemID.BOOKOFSCROLLS_EMPTY: // Interface with remove option | items can be used from book via activate and teleport
            case ItemID.GNOMISH_FIRELIGHTER: // Check, uncharge | Firelighter charges used directly from box when burning logs
            case ItemID.FAVOUR_KEY_RING: //Add keys via use on ring | remove via remove interface

            case ItemID.LOG_BASKET_CLOSED: // Fill, Check(dialog based withdraw), Close/Open | Empty
            case ItemID.FORESTRY_KIT: // View(kit has withdraw interface), Fill | Use(dumps to bank) | rations used directly from kit
            case ItemID.FORESTRY_BASKET_CLOSED: // Fill, view(kit has withdraw interface/basket has none) | use (dumps to bank) | rations used directly from kit

            case ItemID.MM_SECONDARY_POUCH: // Fill, open, empty, use, check | Use (dumps to bank)
                switch (menuOption.toLowerCase()) {
                    // Interacting with these things pulls items from volatile unrecorded space
                    // Coal bag could be filled from bank to use in smithing, or filled from mining
                    // Price needs to be recorded while banking or otherwise
                    case "empty":
                    case "fill":
                    case "use":
                        // Ensure item containers
                        skipTickForProfitCalculation = false;
                }
        }

        // If items can be placed directly into the container, skipping inventory, track profit to not miss emptying
        switch (event.getItemId()) {
            case ItemID.FISH_SACK_BARREL_OPEN:
            case ItemID.FISH_BARREL_OPEN:

            //Coffins can only be emptied via configure, which doesn't report an ItemId we can see for emptying
            case ItemID.SHADES_COFFIN_BRONZE: // Fill, configure, open
            case ItemID.SHADES_COFFIN_BLACK:
            case ItemID.SHADES_COFFIN_STEEL:
            case ItemID.SHADES_COFFIN_SILVER:
            case ItemID.SHADES_COFFIN_GOLD:

            case ItemID.SHADES_COFFIN_BRONZE_OPEN:
            case ItemID.SHADES_COFFIN_BLACK_OPEN:
            case ItemID.SHADES_COFFIN_STEEL_OPEN:
            case ItemID.SHADES_COFFIN_SILVER_OPEN:
            case ItemID.SHADES_COFFIN_GOLD_OPEN: // Fill, configure, close

            case ItemID.GEM_BAG_OPEN: // Fill, Empty
            case ItemID.COAL_BAG_OPEN: // Fill, Empty

            case ItemID.SLAYER_HERB_SACK_OPEN:
            case ItemID.SEED_BOX_OPEN: //Fill, Empty, Check, Close

            case ItemID.LOG_BASKET_OPEN:
            case ItemID.FORESTRY_BASKET_OPEN:

            case ItemID.HG_MEATPOUCH_SMALL_OPEN: // Fill, Empty
            case ItemID.HG_MEATPOUCH_LARGE_OPEN: // Fill, Empty
            case ItemID.HG_FURPOUCH_SMALL_OPEN: // Fill, Empty
            case ItemID.HG_FURPOUCH_MED_OPEN: // Fill, Empty
            case ItemID.HG_FURPOUCH_LARGE_OPEN: // Fill, Empty

            case ItemID.LOOTING_BAG: // Open, Deposit(store interface) | view (deposit interface) | Commonly opened and closed

            case ItemID.MM_SECONDARY_POUCH_OPEN: // Reagent pouch
                switch (menuOption.toLowerCase()) {
                    // Interacting with these things pulls items from volatile unrecorded space
                    // Coal bag could be filled from bank to use in smithing, or filled from mining
                    // Price needs to be recorded while banking or otherwise
                    case "empty":
                    case "fill":
                    case "use":
                        // Ensure item containers
                        skipTickForProfitCalculation = false;
                }
        }
    }

    @Provides
    ProfitTrackerConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(ProfitTrackerConfig.class);
    }

    @Subscribe
    public void onScriptPreFired(ScriptPreFired scriptPreFired)
    {
        goldDropsObject.onScriptPreFired(scriptPreFired);
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event)
    {
        goldDropsObject.onScriptPostFired(event);
    }

    @Subscribe
    public void onClientShutdown(ClientShutdown event)
    {
        accountRecord.save(gson);
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged)
    {
        // Allows hot swapping between price calculation methods non-destructively
        if (configChanged.getGroup().equals(ProfitTrackerConfig.GROUP)) {
            clientThread.invoke(this::updateProfitUI);
            clientThread.invoke(() -> {
                if (config.goldDrops()) {
                    String[] goldDropVisuals = {"color", "style", "drop"};
                    for (String containerMenuOption : goldDropVisuals) {
                        if (configChanged.getKey().toLowerCase().contains(containerMenuOption)) {
                            // Visual indicator to user when they mess with settings, so they can see
                            goldDropsObject.requestGoldDrop(0);
                            break;
                        }
                    }
                }
            });
        }
    }

    private void updateProfitUI(){
        if (accountRecord != null) {
            totalProfit = inventoryValueObject.calculateItemValue(accountRecord.itemDifferenceAccumulated);
            accountRecord.profitAccumulated = totalProfit;
            overlay.updateProfitValue(totalProfit);
        }
    }

    public void adjustProfit()
    {
        String lastChange = accountRecord.lastPossessionChange != null ? Long.toString(-inventoryValueObject.calculateItemValue(accountRecord.lastPossessionChange)) : "";
        ChatboxTextInput chatInput = chatboxPanelManager.openTextInput("Adjust profit")
                .value(lastChange);
        chatInput
                .onChanged((input) -> {
                    // Ensure numeric while user is typing
                    Pattern pattern = Pattern.compile("-?\\d*[kmb]?", Pattern.CASE_INSENSITIVE);
                    Matcher matcher = pattern.matcher(input);
                    matcher.find();
                    chatInput.value(matcher.toMatchResult().group(0));
                })
                .onDone((input) -> {
                    // Support values like 10k
                    input = input.toLowerCase().replace("b", "000000000");
                    input = input.replace("m", "000000");
                    input = input.replace("k", "000");
                    int adjustment = Integer.parseInt(input);
                    Item[] coinsAdjustment = new Item[] {new Item(ItemID.COINS, adjustment)};
                    accountRecord.itemDifferenceAccumulated = ProfitTrackerInventoryValue.getItemCollectionSum(accountRecord.itemDifferenceAccumulated, coinsAdjustment);
                    accountRecord.profitAccumulated += adjustment;
                    accountRecord.lastPossessionChange = coinsAdjustment;
                    clientThread.invoke(() -> {
                        updateProfitUI();
                        goldDropsObject.requestGoldDrop(adjustment);
                    });
                })
                .build();
    }
}
package com.profittracker;
import net.runelite.api.Item;
import static com.profittracker.ProfitTrackerInventoryValue.getItemCollectionSum;

/**
 * Data structure for holding information about a players possessions
 * Should be associated with a particular player, or account type like Leagues/Standard/Beta
 */
public class ProfitTrackerPossessions {
    public Item[] inventoryItems;
    public Item[] bankItems;
    public Item[] grandExchangeItems;
    /**
     * Items stored in various storage that we don't actually have hooks to look into
     * Items are stored here if one of those storages is opened, and an item is lost
     * Items should also be stored in the original possessions if withdrawn and not previously known to be present
     */
    public Item[] untrackedStorageItems;

    public Item[] getItems(){
        Item[] storedItems = getItemCollectionSum(bankItems, grandExchangeItems);
        storedItems = getItemCollectionSum(untrackedStorageItems, storedItems);
        return getItemCollectionSum(inventoryItems, storedItems);
    }

    /**
     * If any collection is null, it will instead use the items from the given possessions
     */
    public void fillNullItems(ProfitTrackerPossessions knownPossessions){
        if (inventoryItems == null){
            inventoryItems = knownPossessions.inventoryItems;
        }
        if (bankItems == null){
            bankItems = knownPossessions.bankItems;
        }
        if (grandExchangeItems == null){
            grandExchangeItems = knownPossessions.grandExchangeItems;
        }
        if (untrackedStorageItems == null){
            untrackedStorageItems = knownPossessions.untrackedStorageItems;
        }
    }
}
package com.profittracker;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.*;

import static net.runelite.api.ScriptID.XPDROPS_SETDROPSIZE;
import static net.runelite.api.ScriptID.XPDROP_DISABLED;

@Slf4j
public class ProfitTrackerGoldDrops {
    /*
       Implement gold drops.
       We do this by using the XPDrop mechanism, namely the Fake XPDrop script,
       which is intended to generate xp drops for maxed out skills.
       Fake XP Drops are composed of a skill sprite,
        and a text widget with a mod icon (<img=11> in text)
       So to create a gold drop, we create a fake xp drop, and interfere in the middle,
       and change the sprite and text to our liking.

       Flow is:

       1. create xp drop using runScript (see requestGoldDrop)
       2. getting in the middle of the drop, changing icon and text (see handleXpDrop)

       A more correct way to do this is probably by calling Item.GetImage with wanted
       coin quantity, which will give us correct coin icon and correct text,
       and simply drawing that image ourselves somehow. Instead of using xp drop mechanism.
     */

    // Values for each variant of coin sprite, used to help set up and access dynamic coin sprites
    private static final int[] COINS_SPRITES = {
            1,
            2,
            3,
            4,
            5,
            25,
            100,
            250,
            1000,
            10000
    };
    /*
    Free sprite id for the gold icons.
     */
    private static final int COINS_SPRITE_ID_START = -1337;

    // Skill ordinal to send in the fake xp drop script.
    // doesn't matter which skill expect it's better not be attack/defense/magic to avoid collision with
    // XpDropPlugin which looks for those and might change text color
    private static final int XPDROP_SKILL = Skill.FISHING.ordinal();

    /*
    Singletons which will be provided at creation by the plugin
     */
    private final ItemManager itemManager;
    private final Client client;
    @Inject
    private ProfitTrackerConfig config;

    /* var currentGoldDropValue will have
    the gold value of the current ongoing gold drop. 2 purposes:
      1. to know the value later when we actually use it,
      2. to know to catch the next fake xpdrop in onScriptPreFired
    */
    private long currentGoldDropValue;
    private boolean doingGoldDrop;

    // Keeps track of the last gold drop widget, for the purpose of later modification
    // Specifically needed to ensure visibility for incompatible plugins like "Customize XP Drops"
    private Widget lastDropWidget;

    ProfitTrackerGoldDrops(Client client, ItemManager itemManager, ProfitTrackerConfig config)
    {
        this.client = client;
        this.itemManager = itemManager;
        this.config = config;

        prepareCoinSprite();

        currentGoldDropValue = 0L;
        doingGoldDrop = false;
    }

    /**
     * We check for scripts of type XPDROPS_SETDROPSIZE to interfere with the XPdrop
     * and write our own values
     */
    public void onScriptPreFired(ScriptPreFired scriptPreFired)
    {
        // is this current script type?
        if (scriptPreFired.getScriptId() != XPDROPS_SETDROPSIZE)
        {
            return;
        }

        // Get xpdrop widget id using the stack
        // taken from XpDropPlugin!

        // This runs prior to the proc being invoked, so the arguments are still on the stack.
        // Grab the first argument to the script.
        final int[] intStack = client.getIntStack();
        final int intStackSize = client.getIntStackSize();

        final int widgetId = intStack[intStackSize - 4];

        // extract information from currentGoldDropValue
        long goldDropValue = currentGoldDropValue;

        handleXpDrop(widgetId, doingGoldDrop, goldDropValue);

        // done with this gold drop anyway
        currentGoldDropValue = 0;
        doingGoldDrop = false;
    }

    /**
     * Ensures the last gold xpDrop has not been hidden
     */
    public void onScriptPostFired(ScriptPostFired event)
    {
        if (event.getScriptId() == ScriptID.XPDROPS_SETDROPSIZE)
        {
            if (lastDropWidget != null)
            {
                if (config.unhideGoldDrops()) {
                    lastDropWidget.setHidden(false);
                }
                Widget dropTextWidget = lastDropWidget.getChildren()[0];
                Widget dropSpriteWidget = lastDropWidget.getChildren()[1];
                if (config.colorGoldDrops())
                {
                    if (dropTextWidget.getText().startsWith("-"))
                    {
                        dropTextWidget.setTextColor(config.colorOnLoss().getRGB());
                    } else {
                        dropTextWidget.setTextColor(config.colorOnProfit().getRGB());
                    }
                }

                Graphics graphics = client.getCanvas().getGraphics();
                int stringWidth = graphics.getFontMetrics().stringWidth(dropTextWidget.getText());
                // Shift sprite position next to text
                dropSpriteWidget.setOriginalX(stringWidth);
                dropSpriteWidget.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT);
                dropSpriteWidget.revalidate();

                lastDropWidget = null;
            }
        }
    }

    private void handleXpDrop(int xpDropWidgetId, boolean isThisGoldDrop, long goldDropValue)
    {
        final Widget xpDropWidget;
        final Widget dropTextWidget;

        Widget[] xpDropWidgetChildren;

        // get widget from ID
        xpDropWidget = client.getWidget(InterfaceID.XP_DROPS, xpDropWidgetId & 0xFFFF);

        if (xpDropWidget == null)
        {
            log.error("xpDropWidget was null");
            return;
        }

        xpDropWidgetChildren = xpDropWidget.getChildren();

        if (xpDropWidgetChildren.length < 1)
        {
            log.error(String.format("Unexpected xpDropWidgets length! %d", xpDropWidgetChildren.length));
            return;
        }

        dropTextWidget = xpDropWidgetChildren[0];

        if (isThisGoldDrop)
        {
            lastDropWidget = xpDropWidget;
            final Widget dropSpriteWidget;

            if (xpDropWidgetChildren.length < 2)
            {
                log.error(String.format(
                        "Unexpected xpDropWidgetChildren length for a gold drop! length! %d",
                        xpDropWidgetChildren.length));
                return;
            }

            dropSpriteWidget = xpDropWidgetChildren[1];

            xpDropToGoldDrop(dropTextWidget, dropSpriteWidget, goldDropValue);
        }
    }

    private void xpDropToGoldDrop(Widget dropTextWidget, Widget dropSpriteWidget, long goldDropValue)
    {
        /*
        Change xpdrop icon and text, to make a gold drop
         */

        if (config.shortDrops() || goldDropValue == 0) {
            // 0 value gold drops are produced by config changes to help the user see their changes
            dropTextWidget.setText(formatGoldDropText(goldDropValue));
        } else {
            // Remove disabled icon from string
            String formattedValue = dropTextWidget.getText();
            formattedValue = formattedValue.substring(formattedValue.indexOf("> ") + 2);
            // Restore negative symbol
            dropTextWidget.setText((goldDropValue < 0 ? "-" : "") + formattedValue);
        }

        // change skill sprite to coin sprite
        if (config.iconStyle() == ProfitTrackerIconType.DYNAMIC){
            for (int spriteIndex = 1; spriteIndex < COINS_SPRITES.length; spriteIndex++){
                if (Math.abs(goldDropValue) < COINS_SPRITES[spriteIndex]){
                    dropSpriteWidget.setSpriteId(COINS_SPRITE_ID_START - spriteIndex + 1);
                    break;
                } else if (spriteIndex == COINS_SPRITES.length - 1) {
                    dropSpriteWidget.setSpriteId(COINS_SPRITE_ID_START - spriteIndex);
                }
            }
        } else {
            dropSpriteWidget.setSpriteId(COINS_SPRITE_ID_START - config.iconStyle().ordinal() + 1);
        }
    }

    private void prepareCoinSprite()
    {
        /*
        Prepare coin sprites for use in the gold drops.
        It seems item icons are not available as sprites with id,
        so we convert in this function.

        */

        //Create a sprite for each coin type
        for (int spriteIndex = 0; spriteIndex < COINS_SPRITES.length; spriteIndex++){
            AsyncBufferedImage coin_image_raw;

            // get image object by coin item id
            coin_image_raw = itemManager.getImage(ItemID.COINS, COINS_SPRITES[spriteIndex], false);

            // since getImage returns an AsyncBufferedImage, which is not loaded initially,
            // we schedule sprite conversion and sprite override for when the image is actually loaded
            int finalSpriteIndex = spriteIndex;
            coin_image_raw.onLoaded(() -> {
                final SpritePixels coin_sprite;

                // convert image to sprite
                coin_sprite = ImageUtil.getImageSpritePixels(coin_image_raw, client);

                // register new coin sprite by overriding a free sprite id
                client.getSpriteOverrides().put(COINS_SPRITE_ID_START - finalSpriteIndex, coin_sprite);
            });
        }
    }

    public void requestGoldDrop(long amount)
    {
        /*
        We create gold drops by faking a fake xp drop :)
         */

        log.debug(String.format("goldDrop: %d", amount));

        // save the value and mark an ongoing gold drop
        currentGoldDropValue = amount;
        doingGoldDrop = true;

        String formattedAmount = formatGoldDropText(currentGoldDropValue);

        // Create a fake xp drop. the 2 last arguments don't matter:
        // 1. skill ordinal - we will replace the icon anyway
        // 2. value - since we want to be able to pass negative numbers, we pass the value using
        // currentGoldDropValue instead of this argument
        // Otherwise, the value here is what would be displayed by other plugins that don't account
        // for our widget changes.
        client.runScript(XPDROP_DISABLED, XPDROP_SKILL, (int) Math.abs(currentGoldDropValue != 0 ? currentGoldDropValue : 1));
    }

    private String formatGoldDropText(long goldDropValue)
    {
        // Format gold value to fit in xp drop to avoid being cut off by gold sprite
        // 999
        // 1.0K
        // 20K
        // 300K
        // 1.0M

        float goldValueRep = goldDropValue;
        String suffix;
        boolean useDecimal = false;
        if (Math.abs(goldDropValue) < 1000L) { // 1-999
            return Long.toString(goldDropValue);
        }
        else if (Math.abs(goldDropValue) < 10000L) // 1,000-9,999
        {
            goldValueRep = (goldDropValue / 1000.0F);
            suffix = "K";
            useDecimal = true;
        }
        else if (Math.abs(goldDropValue) < 1000000L) // 10,000-999,999
        {
            goldValueRep = (goldDropValue / 1000.0F);
            suffix = "K";
        }
        else if (Math.abs(goldDropValue) < 10000000L) // 1,000,000-9,999,999
        {
            goldValueRep = (goldDropValue / 1000000.0F);
            suffix = "M";
            useDecimal = true;
        }
        else if (Math.abs(goldDropValue) < 1000000000L) // 10,000,000-999,999,999
        {
            goldValueRep = (goldDropValue / 1000000.0F);
            suffix = "M";
        }
        else if (Math.abs(goldDropValue) < 1000000000000L) // 1,000,000,000+
        {
            goldValueRep = (goldDropValue / 1000000000.0F);
            suffix = "B";
            useDecimal = true;
        }
        else
        {
            return "ALOT";
        }
        double resultValue = Long.signum(goldDropValue) * Math.floor(Math.abs(goldValueRep) * 10) / 10;
        if(useDecimal)
        {
            return String.format("%.1f%s", resultValue, suffix);
        } else {
            return String.format("%.0f%s", resultValue, suffix);
        }
    }
}

package com.profittracker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.awt.Color;

/**
 * The ProfitTrackerConfig class is used to provide user preferences to the ProfitTrackerPlugin.
 */
@ConfigGroup(ProfitTrackerConfig.GROUP)
public interface ProfitTrackerConfig extends Config
{
    String GROUP = "ptconfig";

    @ConfigSection(
            name = "Visual",
            description = "Settings for what the plugin features look like.",
            position =  0,
            closedByDefault = false
    )
    String VISUAL_SETTINGS = "Visual";

    @ConfigSection(
            name = "Behavior",
            description = "Settings for plugin behavior.",
            position =  1,
            closedByDefault = false
    )
    String BEHAVIOR_SETTINGS = "Behavior";

    @ConfigSection(
            name = "Calculation",
            description = "Settings for price calculation.",
            position =  2,
            closedByDefault = false
    )
    String CALCULATION_SETTINGS = "Calculation";

    @ConfigItem(
            keyName = "goldDrops",
            name = "Show value changes (gold drops)",
            description = "Show each profit increase or decrease.",
            section = VISUAL_SETTINGS,
            position = 0
    )
    default boolean goldDrops()
    {
        return true;
    }

    @ConfigItem(
            keyName = "unhideGoldDrops",
            name = "Unhide value changes",
            description = "Prevents other plugins from hiding value changes if they are enabled.",
            section = VISUAL_SETTINGS,
            position = 1
    )
    default boolean unhideGoldDrops()
    {
        return true;
    }

    @ConfigItem(
            keyName = "rememberProfit",
            name = "Remember profit",
            description = "Profit will be remembered between application closes.",
            section = BEHAVIOR_SETTINGS
    )
    default boolean rememberProfit()
    {
        return true;
    }

    @ConfigItem(
            keyName = "shortDrops",
            name = "Shorten drop numbers",
            description = "Shorten drop numbers like 1.2K instead of 1,223, or 10M instead of 10,000,000.",
            section = VISUAL_SETTINGS,
            position = 3
    )
    default boolean shortDrops()
    {
        return true;
    }

    @ConfigItem(
            keyName = "iconStyle",
            name = "Icon style",
            description = "Dynamically adjust the coin icon based on the drop value, or select a specific icon.",
            section = VISUAL_SETTINGS,
            position = 2
    )
    default ProfitTrackerIconType iconStyle()
    {
        return ProfitTrackerIconType.DYNAMIC;
    }

    @ConfigItem(
            keyName = "estimateUntradeables",
            name = "Estimate untradeable item values",
            description = "Some untradeable items will utilize equivalent values of the best items they can convert into.",
            section = CALCULATION_SETTINGS,
            position = 1
    )
    default boolean estimateUntradeables()
    {
        return true;
    }

    @ConfigItem(
            keyName = "onlineOnlyRate",
            name = "Online only rate",
            description = "Show profit rate only for time spent logged in.",
            position =  2,
            section = CALCULATION_SETTINGS
    )
    default boolean onlineOnlyRate()
    {
        return false;
    }

    @ConfigItem(
            keyName = "valueMode",
            name = "Value",
            description = "Method used to estimate the value of items.",
            section = CALCULATION_SETTINGS,
            position = 0
    )
    default ProfitTrackerPriceType valueMode()
    {
        return ProfitTrackerPriceType.GE;
    }

    @ConfigItem(
            keyName = "colorGoldDrops",
            name = "Color drop text",
            description = "Change the text color of produced gold drops.",
            section = VISUAL_SETTINGS,
            position = 4
    )
    default boolean colorGoldDrops()
    {
        return false;
    }

    @ConfigItem(
            keyName = "colorOnProfit",
            name = "Profit color",
            description = "Color of gold drop when positive.",
            section = VISUAL_SETTINGS,
            position = 5
    )
    default Color colorOnProfit()
    {
        return Color.GREEN;
    }

    @ConfigItem(
            keyName = "colorOnLoss",
            name = "Loss color",
            description = "Color of gold drop when negative.",
            section = VISUAL_SETTINGS,
            position = 6
    )
    default Color colorOnLoss()
    {
        return Color.RED;
    }
}


package com.profittracker;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;

import java.text.DecimalFormat;
import java.util.Arrays;
import java.util.Collections;

/**
 * The ProfitTrackerOverlay class is used to display profit values for the user
 */
public class ProfitTrackerOverlay extends Overlay {
    private long profitValue;
    private long startTimeMillies;
    private long activeTicks;
    private long lastTickMillies;
    private boolean inProfitTrackSession;
    private boolean hasBankData;
    private String lastTimeDisplay;
    private long lastProfitValue;
    private int lastWidth;

    private final ProfitTrackerConfig ptConfig;
    private final ProfitTrackerPlugin ptPlugin;
    private final PanelComponent panelComponent = new PanelComponent();

    private static final String RESET_MENU_OPTION = "Reset";
    private static final String ADJUST_MENU_OPTION = "Adjust";
    private static final int MILLISECONDS_PER_TICK = 600;

    public static String FormatIntegerWithCommas(long value) {
        DecimalFormat df = new DecimalFormat("###,###,###");
        return df.format(value);
    }
    @Inject
    private TooltipManager tooltipManager;
    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private ProfitTrackerOverlay(ProfitTrackerConfig config, ProfitTrackerPlugin trackerPlugin)
    {
        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
        profitValue = 0L;
        ptConfig = config;
        startTimeMillies = 0;
        activeTicks = 0;
        lastTickMillies = 0;
        inProfitTrackSession = false;
        hasBankData = false;
        ptPlugin = trackerPlugin;
        this.addMenuEntry(MenuAction.RUNELITE_OVERLAY, RESET_MENU_OPTION, "Profit Tracker", menuEntry ->
                {
                    ptPlugin.resetSession(false);
                    profitValue = 0;
                });
        this.addMenuEntry(MenuAction.RUNELITE_OVERLAY, ADJUST_MENU_OPTION, "Profit Tracker", menuEntry ->
        {
            clientThread.invoke(ptPlugin::adjustProfit);
        });


    }

    /**
     * Render the item value overlay.
     * @param graphics the 2D graphics
     * @return the value of {@link PanelComponent#render(Graphics2D)} from this panel implementation.
     */
    @Override
    public Dimension render(Graphics2D graphics) {
        String titleText = "Profit Tracker:";
        long millisecondsElapsed;
        long profitRateValue;
        String timeText;

        if (startTimeMillies > 0)
        {
            if (ptConfig.onlineOnlyRate()){
                millisecondsElapsed = (long)(Math.max(0, activeTicks - 1)  * MILLISECONDS_PER_TICK);
                //Add duration since last tick to ensure timer pacing isn't uneven
                if (lastTickMillies != 0 && inProfitTrackSession){
                    millisecondsElapsed += System.currentTimeMillis() - lastTickMillies;
                }
            } else {
                millisecondsElapsed = (System.currentTimeMillis() - startTimeMillies);
            }
        }
        else
        {
            // there was never any session
            millisecondsElapsed = 0;
        }

        timeText = formatTimeIntervalFromMs(millisecondsElapsed, false);
        // Rate limit profit update to avoid extremely high profit being difficult to read
        // Also reduces visual noise
        if (! timeText.equals(lastTimeDisplay) || lastProfitValue == 0) {
            profitRateValue = calculateProfitHourly(millisecondsElapsed, profitValue);
            lastProfitValue = profitRateValue;
        } else {
            profitRateValue = lastProfitValue;
        }
        lastTimeDisplay = timeText;

        // Not sure how this can occur, but it was recommended to do so
        panelComponent.getChildren().clear();

        // Build overlay title
        panelComponent.getChildren().add(TitleComponent.builder()
                .text(titleText)
                .color(hasBankData ? Color.GREEN : Color.YELLOW)
                .build());

        if (!inProfitTrackSession)
        {
            // not in session
            // this should not happen if in game, but we can have it just in case
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("Error")
                    .color(Color.RED)
                    .build());
        }

        // Show tooltip warning on mouse hover if user hasn't opened bank yet
        Point mousePoint = new Point(client.getMouseCanvasPosition().getX(),client.getMouseCanvasPosition().getY());
        if(this.getBounds().contains(mousePoint) && ! hasBankData)
        {
            String tooltipString =
                    "Open bank first to ensure accurate tracking.</br>" +
                    "Otherwise, GE offer interaction or emptying containers from deposit boxes may be incorrect.";

            tooltipManager.add(new Tooltip(tooltipString));
        }

        String formattedProfit = String.format("%,d",profitValue);
        String formattedRate = String.format("%,d",profitRateValue) + "K/H";
        int titleWidth = graphics.getFontMetrics().stringWidth(titleText) + 40;
        int profitWidth = graphics.getFontMetrics().stringWidth("Profit:    " + formattedProfit);
        int rateWidth = graphics.getFontMetrics().stringWidth("Rate:    " + formattedRate);
        // Only allow width to grow, to avoid jitters at high values
        lastWidth = Collections.max(Arrays.asList(lastWidth, titleWidth, profitWidth, rateWidth));

        // Set the size of the overlay (width)
        panelComponent.setPreferredSize(new Dimension(
                lastWidth,
                0));

        // elapsed time
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Time:")
                .right(timeText)
                .build());

        // Profit
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Profit:")
                .right(formattedProfit)
                .build());

        // Profit Rate
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Rate:")
                .right(formattedRate)
                .build());

        return panelComponent.render(graphics);
    }

    /**
     * Updates profit value display
     * @param newValue the value to update the profitValue's {{@link #panelComponent}} with.
     */
    public void updateProfitValue(final long newValue) {
        SwingUtilities.invokeLater(() ->
                {
                    profitValue = newValue;
                    // Value reset to ensure rate is shown immediately, instead of waiting for next time increment
                    lastProfitValue = 0;
                }
        );
    }


    /**
     * Updates startTimeMillies display
     */
    public void updateStartTimeMillies(final long newValue) {
        SwingUtilities.invokeLater(() ->
                {
                    startTimeMillies = newValue;
                    lastTickMillies = System.currentTimeMillis();
                }
        );
    }

    public void updateActiveTicks(final long newValue) {
        SwingUtilities.invokeLater(() ->
                {
                    activeTicks = newValue;
                    lastTickMillies = System.currentTimeMillis();
                }
        );
    }

    public void startSession()
    {
        SwingUtilities.invokeLater(() ->
                {
                    inProfitTrackSession = true;
                    lastWidth = 0;
                }
        );
    }

    public void updateBankStatus(ProfitTrackerRecord accountRecord)
    {
        SwingUtilities.invokeLater(() ->
                hasBankData = accountRecord.currentPossessions.bankItems != null
        );
    }

    private static String formatTimeIntervalFromMs(final long totalMsElapsed, boolean showMilliseconds)
    {
        /*
        elapsed seconds to format HH:MM:SS
         */
        final long ms = totalMsElapsed % 1000;
        final long sec = totalMsElapsed / 1000 % 60;
        final long min = (totalMsElapsed / 60000) % 60;
        final long hr = totalMsElapsed / 3600000;

        if (showMilliseconds) {
            return String.format("%02d:%02d:%02d.%03d", hr, min, sec, ms);
        } else {
            return String.format("%02d:%02d:%02d", hr, min, sec);
        }
    }

    static long calculateProfitHourly(long millisecondsElapsed, long profit)
    {
        long averageProfitThousandForHour;
        double averageProfitPerMillisecond;

        if (millisecondsElapsed > 0)
        {
            averageProfitPerMillisecond = (double)profit / millisecondsElapsed;
        }
        else
        {
            // can't divide by zero, not enough time has passed
            averageProfitPerMillisecond = 0;
        }

        averageProfitThousandForHour = (long)(averageProfitPerMillisecond * 3600);

        return averageProfitThousandForHour;
    }
}

package com.profittracker;

public enum ProfitTrackerIconType {
    DYNAMIC,
    COINS_1,
    COINS_2,
    COINS_3,
    COINS_4,
    COINS_5,
    COINS_25,
    COINS_100,
    COINS_250,
    COINS_1000,
    COINS_10000
}
package com.profittracker;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.game.ItemManager;
import org.apache.commons.lang3.ArrayUtils;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.gameval.InventoryID;

import javax.inject.Inject;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.LongStream;

@Slf4j
public class ProfitTrackerInventoryValue {
    /*
    Provide functional methods for calculating inventory value
     */
    /*
    Singletons which will be provided at creation by the plugin
     */

    static final int EMPTY_SLOT_ITEMID = -1;

    private final int[] RUNE_POUCH_ITEM_IDS = {
            ItemID.BH_RUNE_POUCH,
            ItemID.BH_RUNE_POUCH_TROUVER,
            ItemID.DIVINE_RUNE_POUCH,
            ItemID.DIVINE_RUNE_POUCH_TROUVER
    };

    private final int[] RUNE_POUCH_AMOUNT_VARBITS = {
            VarbitID.RUNE_POUCH_QUANTITY_1,
            VarbitID.RUNE_POUCH_QUANTITY_2,
            VarbitID.RUNE_POUCH_QUANTITY_3,
            VarbitID.RUNE_POUCH_QUANTITY_4
    };

    private final int[] RUNE_POUCH_RUNE_VARBITS = {
            VarbitID.RUNE_POUCH_TYPE_1,
            VarbitID.RUNE_POUCH_TYPE_2,
            VarbitID.RUNE_POUCH_TYPE_3,
            VarbitID.RUNE_POUCH_TYPE_4
    };

    private final int[] COLLECTION_BOX_INVENTORY_IDS = {
            InventoryID.TRADINGPOST_SELL_0,
            InventoryID.TRADINGPOST_SELL_1,
            InventoryID.TRADINGPOST_SELL_2,
            InventoryID.TRADINGPOST_SELL_3,
            InventoryID.TRADINGPOST_SELL_4,
            InventoryID.TRADINGPOST_SELL_5,
            InventoryID.GE_COLLECT_6,
            InventoryID.GE_COLLECT_7
    };

    private static final double GE_TAX = 0.02;

    private final ItemManager itemManager;
    private final Client client;
    @Inject
    private ProfitTrackerConfig config;
    private GrandExchangeOfferData[] offers = new GrandExchangeOfferData[8];
    private Item[] collectionBoxItems = new Item[0];

    /**
     * Data storage for GE offers as the normal object always maintains a reference,
     * and we need to be able to compare changes that have occurred
     */
    private static class GrandExchangeOfferData{
        int quantitySold;
        int id;
        int totalQuantity;
        int price;
        int spent;
        GrandExchangeOfferState state;

        public GrandExchangeOfferData(GrandExchangeOffer offer){
            this.quantitySold = offer.getQuantitySold();
            this.id = offer.getItemId();
            this.totalQuantity = offer.getTotalQuantity();
            this.price = offer.getPrice();
            this.spent = offer.getSpent();
            this.state = offer.getState();
        }
    }

    public ProfitTrackerInventoryValue( Client client, ItemManager itemManager, ProfitTrackerConfig config) {
        this.client = client;
        this.itemManager = itemManager;
        this.config = config;
    }

    public void setOffers(GrandExchangeOffer[] offers){
        if (offers == null){
            this.offers = new GrandExchangeOfferData[8];
            this.collectionBoxItems = new Item[0];
            return;
        }
        for (int index = 0; index < offers.length; index++){
            this.offers[index] = new GrandExchangeOfferData(offers[index]);
        }
        this.collectionBoxItems = getCollectionBoxContents();
    }

    private long calculateItemValue(Item item) {
        /*
        Calculate GE value of single item
         */

        int itemId = item.getId();

        if (itemId < -1)
        {
            // unexpected
            log.debug("Bad item id!" + itemId);
            return 0;

        }

        if (itemId == EMPTY_SLOT_ITEMID)
        {
            return 0;
        }

        if (Arrays.stream(RUNE_POUCH_ITEM_IDS).anyMatch(pouchID -> itemId == pouchID))
        {
            log.debug(String.format("calculateItemValue itemId = %d (Rune pouch variant)", itemId));
            return item.getQuantity() * calculateRunePouchValue();
        }

        log.debug(String.format("calculateItemValue itemId = %d", itemId));

        // multiply quantity  by GE value
        return (long) item.getQuantity() * (getItemValue(itemId));
    }

    /**
     * Returns the value of an item, based on the plugin configs value mode. (GE, high alch, shop, etc.)
     */
    private int getItemValue(int itemID){
        switch (config.valueMode()){
            case GE_TAXED:
                return (int) Math.ceil(itemManager.getItemPrice(itemID) * (1 - GE_TAX));
            case LOW_ALCH:
                return (int) (itemManager.getItemComposition(itemID).getPrice() * ProfitTrackerShopValues.COMMON_LOW_ALCH);
            case SHOP_SPECIAL:
                return (int) (itemManager.getItemComposition(itemID).getPrice() * ProfitTrackerShopValues.SPECIAL_55);
            case HIGH_ALCH:
                return (int) (itemManager.getItemComposition(itemID).getPrice() * ProfitTrackerShopValues.SPECIAL_60_HIGH_ALCH);
            case SHOP_OVERSTOCK:
                return (int) (itemManager.getItemComposition(itemID).getPrice() * ProfitTrackerShopValues.MINIMUM_PRICE);
            case GE:
            default:
                return itemManager.getItemPrice(itemID);
        }
    }

    public long calculateContainerValue(int containerID)
    {
        /*
        calculate total inventory value
         */

        ItemContainer container = client.getItemContainer(containerID);

        if (container == null)
        {
            return 0;
        }

        Item[] items = container.getItems();

        return calculateItemValue(items);
    }

    /**
     * Calculates the value of an array of items
     */
    public long calculateItemValue(Item[] items) {
        if (config.estimateUntradeables()){
            items = replaceUntradeables(items);
        }
        return Arrays.stream(items).flatMapToLong(item ->
                LongStream.of(calculateItemValue(item))
        ).sum();
    }

    public long calculateInventoryValue()
    {
        /*
        calculate total inventory value
         */

        return calculateContainerValue(InventoryID.INV);

    }

    public long calculateEquipmentValue()
    {
        /*
        calculate total equipment value
         */
        return calculateContainerValue(InventoryID.WORN);
    }

    public long calculateRunePouchValue()
    {
        long runePouchValue = 0;
        EnumComposition runePouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);

        for (int i = 0; i < RUNE_POUCH_AMOUNT_VARBITS.length; i++)
        {
            runePouchValue += calculateRuneValue(
                    client.getVarbitValue(RUNE_POUCH_RUNE_VARBITS[i]),
                    client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS[i]),
                    runePouchEnum
            );
        }

        return runePouchValue;
    }

    public long calculateRuneValue(int runeId, int runeQuantity, EnumComposition runePouchEnum)
    {
        if (runeQuantity == 0){
            return 0;
        }
        log.debug(String.format("calculateRuneValue runeId = %d", runeId));
        return (long)(getItemValue(runePouchEnum.getIntValue(runeId))) * runeQuantity;
    }

    public long calculateInventoryAndEquipmentValue()
    {
        /*
        calculate total inventory + equipment value
         */

        return calculateInventoryValue() + calculateEquipmentValue();
    }

    /**
     * Gets all items on the player, or null if inventory or equipment is null
     * @return Array of items from inventory and equipment containers
     */
    public Item[] getInventoryAndEquipmentContents(){
        ItemContainer inventoryContainer = client.getItemContainer(InventoryID.INV);
        ItemContainer equipmentContainer = client.getItemContainer(InventoryID.WORN);
        Item[] inventoryItems = new Item[0];
        Item[] equipmentItems = new Item[0];

        if (inventoryContainer != null){
            inventoryItems = inventoryContainer.getItems();
        }
        if (equipmentContainer != null){
            equipmentItems = equipmentContainer.getItems();
        }

        Item[] personItems = ArrayUtils.addAll(inventoryItems, equipmentItems);
        // Expand to have runes from pouch as individual items
        return expandContainers(personItems);
    }

    public Item[] getBankContents(){
        ItemContainer bankContainer = client.getItemContainer(InventoryID.BANK);

        if (bankContainer == null)
        {
            return null;
        }
        return expandContainers(bankContainer.getItems());
    }

    public Item[] getGrandExchangeContents(){
        ArrayList<Item> items = new ArrayList<> ();
        //Unclear why, but without an intermediate storage for this variable, just doing items.add(new ...) caused improper quantities
        Item coins;
        for (GrandExchangeOfferData offer : offers) {
            if (offer == null) {
                items.add(new Item(-1, 0));
                continue;
            }
            switch (offer.state) {
                case BOUGHT:
                case BUYING:
                    coins = new Item(ItemID.COINS, offer.price * (offer.totalQuantity - offer.quantitySold)); //Gold left to spend
                    items.add(coins);
                    break;
                case SOLD:
                case SELLING:
                    items.add(new Item(offer.id, offer.totalQuantity - offer.quantitySold)); //Items left to sell
                    break;
                case CANCELLED_BUY:
                case CANCELLED_SELL:
                    //All pending value in the offer will be moved to the collection item container
                    break;
                case EMPTY:
                default:
                    items.add(new Item(-1, 0));
                    break;
            }
        }
        return ArrayUtils.addAll(items.toArray(new Item[0]), collectionBoxItems);
    }

    /**
     * Gets all items sitting in the collection box for GE offers.
     * Can only access this data when the interface is open, avoid calling from something like onGrandExchangeOfferChanged
     * which can happen at any time.
     */
    private Item[] getCollectionBoxContents(){
        Item[] items = new Item[0];
        for (int collectionBoxInventoryId : COLLECTION_BOX_INVENTORY_IDS) {
            ItemContainer collectionBox = client.getItemContainer(collectionBoxInventoryId);
            if (collectionBox != null) {
                items = ArrayUtils.addAll(items, collectionBox.getItems());
            }
        }
        return items;
    }

    private Item[] expandContainers(Item[] items){
        Item[] extraItems = new Item[0];
        for (int i = 0; i < items.length; i++){
            final int lambdaId = items[i].getId(); // Compiler complains without this
            if (Arrays.stream(RUNE_POUCH_ITEM_IDS).anyMatch(pouchID -> lambdaId == pouchID)){
                extraItems = ArrayUtils.addAll(extraItems,getRunePouchItems());
                items[i] = new Item(-1,0); // Get rid of pouch
                break; //TODO Other containers
            }
        }
        return ArrayUtils.addAll(items,extraItems);
    }

    /**
     * Replaces various untradeable items with items they can be converted into, or coin values of those items
     */
    public Item[] replaceUntradeables(Item[] items){
        Item[] extraItems = new Item[0];
        Item[] resultItems = items.clone();
        for (int i = 0; i < resultItems.length; i++){
            boolean replaceItem = true;
            switch (resultItems[i].getId()){
                case ItemID.MINNOW:
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.RAW_SHARK,resultItems[i].getQuantity() / 40));
                    break;
                //Mark of grace for amylase crystals seems to be covered already by the GE value checker
                case ItemID.VARLAMORE_WYRM_AGILITY_TERMITE:
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.AMYLASE,resultItems[i].getQuantity()));
                    break;
                case ItemID.AGILITYARENA_TICKET: //Old agility arena ticket for pirate's hook
                case ItemID.AGILITYARENA_VOUCHER: //Brimhaven voucher for pirate's hook
                    long hookValue = calculateItemValue(new Item(ItemID.PIRATEHOOK, 1));
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * hookValue / 800)));
                    break;
                case ItemID.STAR_DUST:
                case ItemID.STAR_DUST_25:
                case ItemID.STAR_DUST_75:
                case ItemID.STAR_DUST_125:
                case ItemID.STAR_DUST_175:
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.SOFTCLAY,resultItems[i].getQuantity() * 2 / 3));
                    break;
                case ItemID.MOTHERLODE_NUGGET:
                case ItemID.MGUILD_MINERALS:
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.SOFTCLAY,resultItems[i].getQuantity() * 10));
                    break;
                case ItemID.FORESTRY_CURRENCY: //Anima bark for felling axe handle
                    long handleValue = calculateItemValue(new Item(ItemID.FORESTRY_2H_AXE_HANDLE, 1)) - calculateItemValue(new Item(ItemID.OAK_LOGS, 500));
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * handleValue / 10000)));
                    break;
                case ItemID.PRIF_CRYSTAL_SHARD: //Crystal shard high alch
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,resultItems[i].getQuantity() * 6000));
                    break;
                case ItemID.PRIF_CRYSTAL_SHARD_CRUSHED:
                    // Profit from making divine super combat, used for crystal shards/dust
                    long potionProfit = calculateItemValue(new Item(ItemID._4DOSEDIVINECOMBAT, 1)) - calculateItemValue(new Item(ItemID._4DOSE2COMBAT,1));
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * potionProfit / 4)));
                    break;
                case ItemID.TZHAAR_TOKEN: //Tokkul for onyx
                    long onyxValue = calculateItemValue(new Item(ItemID.ONYX, 1));
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * onyxValue / 300000)));
                    break;
                case ItemID.ABYSSAL_PEARL: //Abyssal pearls for ring of the elements
                    long roteValue = calculateItemValue(new Item(ItemID.RING_OF_ELEMENTS, 1));
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * roteValue / 400)));
                    break;
                case ItemID.VILLAGE_TRADE_STICKS: //Trading sticks for gout tubers
                    long tuberValue = calculateItemValue(new Item(ItemID.VILLAGE_RARE_TUBER, 1));
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * tuberValue / 120)));
                    break;
                case ItemID.FOSSIL_MERMAID_TEAR: //Mermaid tears for merfolk trident
                    long tridentValue = calculateItemValue(new Item(ItemID.MERFOLK_TRIDENT, 1));
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * tridentValue / 400)));
                    break;
                case ItemID.KONAR_KEY: //Brimstone key high alch
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * 48000)));
                    break;
                case ItemID.BIRD_EGG_BLUE: //Bird eggs can be traded in for seed nests
                case ItemID.BIRD_EGG_RED:
                case ItemID.BIRD_EGG_GREEN:
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.BIRD_NEST_EMPTY,resultItems[i].getQuantity()));
                    break;
                case ItemID.BIRD_NEST_EGG_BLUE:
                case ItemID.BIRD_NEST_EGG_RED:
                case ItemID.BIRD_NEST_EGG_GREEN:
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.BIRD_NEST_EMPTY,resultItems[i].getQuantity() * 2));
                    break;
                case ItemID.MAGIC_IMP_BOX_FULL:
                case ItemID.MAGIC_IMP_BOX_HALF:
                    //Replace un-tradeable magic imp boxes with regular ones for value check
                    //Otherwise using them and opening the bank would cause confusing small profits
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.MAGIC_IMP_BOX,resultItems[i].getQuantity()));
                    break;
                case ItemID.FORESTRY_BASKET_CLOSED:
                case ItemID.FORESTRY_BASKET_OPEN:
                    //Forestry basket can be dismantled to return log brace at no cost
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.FORESTRY_STURDY_HARNESS,resultItems[i].getQuantity()));
                    break;
                //TODO Seedlings: Have unwatered seedlings turn into the seed + pot, and the watered versions into saplings
                default:
                    replaceItem = false;
                    break;
            }
            if (replaceItem) {
                resultItems[i] = new Item(-1,0);
            }
        }
        return ArrayUtils.addAll(resultItems,extraItems);
    }

    private Item[] getRunePouchItems(){
        List<Item> runes = new ArrayList<>();
        EnumComposition runePouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);

        for (int i = 0; i < RUNE_POUCH_AMOUNT_VARBITS.length; i++)
        {
            int itemID = runePouchEnum.getIntValue(client.getVarbitValue(RUNE_POUCH_RUNE_VARBITS[i]));
            runes.add(new Item(itemID,client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS[i])));
        }

        return runes.toArray(new Item[0]);
    }

    /**
     * Converts the given item array into a map
     * @return Map of item ID -> QTY
     */
    private static Map<Integer, Integer> mapItemArray(Item[] items){
        return Arrays.stream(items)
                .collect(Collectors.toMap(Item::getId, Item::getQuantity, Integer::sum));
    }

    public Item[] getItemCollectionDifference(Item[] originalItems, Item[] newItems, boolean replaceUntradeables){
        if (replaceUntradeables){
            //Replace untradeables with their equivalent items.
            //The replaceUntradeables function is inaccurate for very small amounts, so we need to perform it over the source
            //with larger quantities instead of over the result difference between collections which generally is just 1 item.
            //For example, a single stardust = 2/3rds of a soft clay, which is smaller than 1, and so its quantity is truncated by the Item object.
            originalItems = replaceUntradeables(originalItems);
            newItems = replaceUntradeables(newItems);
        }
        return getItemCollectionDifference(originalItems, newItems);
    }

    /**
     * Compares the two arrays, returning an array of item differences
     * For example, dropping a shark would be an array of 1 shark item, with quantity -1
     * @return Array of items with quantity set to the difference
     */
    public static Item[] getItemCollectionDifference(Item[] originalItems, Item[] newItems){
        Map<Integer, Integer> originalItemList = mapItemArray(originalItems);
        Map<Integer, Integer> newItemList = mapItemArray(newItems);
        //Subtract old quantities from new to get difference
        originalItemList.forEach((id, quantity) -> newItemList.merge(id, -quantity,(a,b)-> {
            int sum = a + b;
            //Returning null if merge removes the entry
            return sum != 0 ? sum : null;
        }));

        //Convert back to item array
        List<Item> itemDifference = new ArrayList<>();
        newItemList.forEach((id, quantity) -> itemDifference.add(new Item(id, quantity)));

        return itemDifference.toArray(new Item[0]);
    }

    /**
     * Returns an item array which is the sum of two other item arrays, adjusting quantities as needed
     * Null collections are not added
     * If both collections are null, returns null
     */
    public static Item[] getItemCollectionSum(Item[] items1, Item[] items2){
        if (items1 == null || items2 == null){
            if (items1 != null) {
                return items1;
            }
            return items2;
        }
        Map<Integer, Integer> firstItems = mapItemArray(items1);
        Map<Integer, Integer> secondItems = mapItemArray(items2);
        firstItems.forEach((id, quantity) -> secondItems.merge(id, quantity,(a,b)-> {
            int sum = a + b;
            //Returning null if merge removes the entry
            return sum != 0 ? sum : null;
        }));

        //Convert back to item array
        List<Item> itemSum = new ArrayList<>();
        secondItems.forEach((id, quantity) -> itemSum.add(new Item(id, quantity)));

        return itemSum.toArray(new Item[0]);
    }

    public static Item[] getItemCollectionGain(Item[] itemDifferences){
        List<Item> itemGain = new ArrayList<>();
        mapItemArray(itemDifferences).forEach((id, quantity) -> {
            if (quantity > 0){
                itemGain.add(new Item(id, quantity));
            }
        });
        return itemGain.toArray(new Item[0]);
    }

    /**
     * Returns a more readable string representation of the given item array. Function purely for debugging purposes.
     */
    public String printItemCollection(Item[] items){
        StringBuilder outputString = new StringBuilder();
        for (Item item : items) {
            outputString.append(itemManager.getItemComposition(item.getId()).getName() + ", " + item.getQuantity() + "\r\n");
        }
        return outputString.toString();
    }
}

package com.profittracker;

//See https://oldschool.runescape.wiki/w/General_store
public class ProfitTrackerShopValues {
    public static final double RASOLO = 0.05;
    public static final double MINIMUM_PRICE = 0.1; //Lowest the price can supposedly drop when overstocking a shop
    public static final double CANIFIS = 0.1;
    public static final double STAN = 0.15;
    public static final double DWARVEN = 0.3;
    public static final double COMMON_LOW_ALCH = 0.4; //Most general stores
    public static final double SPECIAL_50 = 0.5; //At least 4 different shops
    public static final double SPECIAL_55 = 0.55; //At least 8 different shops
    public static final double SPECIAL_60_HIGH_ALCH = 0.6; //At least 4 different shops
}

package com.profittracker;

public enum ProfitTrackerPriceType {
    GE("Grand Exchange"),
    GE_TAXED("Grand Exchange (2% Tax)"), //98% rounded up
    HIGH_ALCH("High Alchemy / Shop 60%"), //60%, wildy shop, rogues den
    SHOP_SPECIAL("Shop 55%"), //55%, west ardy, pollnivneach, legends' guild general stores, moon clan, lighthouse
    LOW_ALCH("Low Alchemy / Shop 40%"), //40%, regular general stores
    SHOP_OVERSTOCK("Shop 10% (Overstocked)"); //10%

    private final String name;

    ProfitTrackerPriceType(String s) {
        name = s;
    }

    @Override
    public String toString()
    {
        return name;
    }
}

package com.profittracker;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.client.RuneLite;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfileType;

import java.io.File;
import java.nio.file.Files;

/**
 * Long term data storage for individual account profiles
 */
public class ProfitTrackerRecord {
    public String name;
    public RuneScapeProfileType rsProfileType;
    public long hash;
    public long startTickMillies;
    public long ticksOnline;
    public long profitAccumulated;
    public ProfitTrackerPossessions startingPossessions;
    public ProfitTrackerPossessions currentPossessions;
    public Item[] lastPossessionChange;
    /**
     * A sum of all item changes observed. Ideally the same as the difference between starting and current possessions.
     * Can change if the user decides to adjust manually.
     */
    public Item[] itemDifferenceAccumulated = new Item[0];

    public static final File RECORD_DIRECTORY = new File(RuneLite.RUNELITE_DIR, "profit-tracker");

    public ProfitTrackerRecord(Client client){
        hash = client.getAccountHash();
        rsProfileType = RuneScapeProfileType.getCurrent(client);
        startTickMillies = System.currentTimeMillis();
        ticksOnline = 0;
        profitAccumulated = 0;
        startingPossessions = new ProfitTrackerPossessions();
        currentPossessions = new ProfitTrackerPossessions();
        lastPossessionChange = null;
    }

    /**
     * Clears record data. Current possessions are not cleared, unless a hard reset is performed.
     * This is to allow resetting without having to open bank/ge again to learn items.
     * Hard resets are needed to avoid users turning off the plugin, gaining items, then enabling it,
     * and instantly getting profit when opening bank or GE.
     */
    public void reset(ConfigManager configManager, boolean hardReset) {
        startTickMillies = System.currentTimeMillis();
        ticksOnline = 0;
        profitAccumulated = 0;
        startingPossessions = new ProfitTrackerPossessions();
        if (hardReset) {
            currentPossessions = new ProfitTrackerPossessions();
        }
        lastPossessionChange = null;
        itemDifferenceAccumulated = new Item[0];
    }

    public void updateItems(ProfitTrackerPossessions newPossessions, ProfitTrackerOverlay overlay){
        this.updateInventoryItems(newPossessions.inventoryItems);
        if (newPossessions.bankItems != null) {
            this.updateBankItems(newPossessions.bankItems);
            overlay.updateBankStatus(this);
        }
        if (newPossessions.grandExchangeItems != null) {
            this.updateGrandExchangeItems(newPossessions.grandExchangeItems);
        }
        this.updateUntrackedItems(newPossessions.untrackedStorageItems);
    }

    public void updateInventoryItems(Item[] items){
        if (startingPossessions.inventoryItems == null) {
            startingPossessions.inventoryItems = items;
        }
        currentPossessions.inventoryItems = items;
    }

    public void updateBankItems(Item[] items){
        if (startingPossessions.bankItems == null) {
            startingPossessions.bankItems = items;
        }
        currentPossessions.bankItems = items;
    }

    public void updateGrandExchangeItems(Item[] items){
        if (startingPossessions.grandExchangeItems == null) {
            startingPossessions.grandExchangeItems = items;
        }
        currentPossessions.grandExchangeItems = items;
    }

    public void updateUntrackedItems(Item[] items){
        if (startingPossessions.untrackedStorageItems == null) {
            startingPossessions.untrackedStorageItems = items;
        }
        currentPossessions.untrackedStorageItems = items;
    }

    public String getAccountRecordKey(){
        return createAccountRecordKey(this.hash,this.rsProfileType.name());
    }

    private static String createAccountRecordKey(long accountHash, String rsProfileType) {
        if (accountHash == -1) {
            // Not logged in
            return null;
        }
        // Account for special worlds where a player with the same name might have different possessions
        // For example, a speedrunning world has MEMBER and SPEEDRUNNING types
        String accountIdentifier = Long.toString(accountHash) + "_" + rsProfileType;
        return "record_" + accountIdentifier;
    }

    public static String getAccountRecordKey(Client client){
        return createAccountRecordKey(client.getAccountHash(), RuneScapeProfileType.getCurrent(client).name());
    }

    private static File getAccountRecordFile(Client client){
        return new File(RECORD_DIRECTORY, getAccountRecordKey(client) + ".json");
    }

    private File getAccountRecordFile(){
        return new File(RECORD_DIRECTORY, getAccountRecordKey() + ".json");
    }

    /**
     * Loads the current accounts record from its expected file location
     * Returns null if anything fails
     */
    public static ProfitTrackerRecord load(Client client, ConfigManager configManager, Gson gson){
        String json;
        try {
            json = new String(Files.readAllBytes(getAccountRecordFile(client).toPath()));
        } catch(Exception e) {
            return null;
        }
        try {
            return gson.fromJson(json, ProfitTrackerRecord.class);
        } catch(Exception e) {
            // Likely failed to read, maybe the data was corrupted, or manually modified
            return null;
        }
    }

    /**
     * Saves the current account data into a json file by the name of the account hash + rs profile type
     */
    public void save(Gson gson){
        String json = gson.toJson(this);

        File accountFile = getAccountRecordFile();
        try {
            tryCreateRecordFolder();
            Files.write(accountFile.toPath(), json.getBytes());
        } catch(Exception ignored) {
        }
    }

    /**
     * Removes stored data for this item, for when users don't want to track across sessions
     */
    public void clear(ConfigManager configManager, ProfitTrackerConfig config){
        configManager.unsetConfiguration(ProfitTrackerConfig.GROUP,configManager.getRSProfileKey(),getAccountRecordKey());
    }

    private void tryCreateRecordFolder() {
        if (!RECORD_DIRECTORY.exists())
        {
            RECORD_DIRECTORY.mkdir();
        }
    }
}


package com.profittracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ProfitTrackerTest
{
    public static void main(String[] args) throws Exception
    {
        ExternalPluginManager.loadBuiltin(ProfitTrackerPlugin.class);
        RuneLite.main(args);
    }
}

