package com.profittracker;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;

import net.runelite.api.events.*;

import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.api.events.VarbitChanged;
import org.apache.commons.lang3.ArrayUtils;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@PluginDescriptor(
        name = "Profit Tracker",
        description = "Tracks profit according to the GE value of your items.",
        tags = {"overlay"}
)
public class ProfitTrackerPlugin extends Plugin
{
    ProfitTrackerGoldDrops goldDropsObject;
    ProfitTrackerInventoryValue inventoryValueObject;

    // the profit will be calculated against this value
    private long prevInventoryValue;
    private Map<String, ProfitTrackerPossessions> accountPossessions;
    private ProfitTrackerPossessions previousPossessions;
    private String previousAccount;
    // Collection of items that was last used to calculate value, includes inventory and equipment
    private long totalProfit;

    private long startTickMillis;
    private long activeTicks;

    private boolean skipTickForProfitCalculation;
    private boolean inventoryValueChanged;
    private boolean bankValueChanged;
    private boolean grandExchangeValueChanged;
    private boolean inProfitTrackSession;
    private boolean runePouchContentsChanged;
    // Remembers if the bank was open last tick, because tick perfect bank close reports changes late
    private boolean bankJustClosed;
    // Remembers if untracked storage was open last tick, as tick perfect close reports changes late
    private boolean storageJustClosed;
    // State boolean for when a widget we do not fully track is currently opened, such as the leprechaun tool store
    private boolean untrackedStorageOpened;
    // Remembers the state of grand exchange
    private boolean grandExchangeOpened;
    // Set when using a deposit menu option. Used to create a depositing deficit for the next time you open bank
    // This ensures using a deposit box doesn't spam coin drops, but also doesn't get out of sync when the race
    // condition with menu options and container changes causes some anyway
    private boolean depositingItem;
    // State of a deposit box being open, used to avoid tracking profit changes when just sending to the bank
    private boolean depositBoxOpened;
    private long depositDeficit;
    private final int[] RUNE_POUCH_VARBITS = {
            VarbitID.RUNE_POUCH_QUANTITY_1,
            VarbitID.RUNE_POUCH_QUANTITY_2,
            VarbitID.RUNE_POUCH_QUANTITY_3,
            VarbitID.RUNE_POUCH_QUANTITY_4,
            VarbitID.RUNE_POUCH_TYPE_1,
            VarbitID.RUNE_POUCH_TYPE_2,
            VarbitID.RUNE_POUCH_TYPE_3,
            VarbitID.RUNE_POUCH_TYPE_4
    };

    @Inject
    private Client client;

    @Inject
    private ProfitTrackerConfig config;

    @Inject
    private ItemManager itemManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private ProfitTrackerOverlay overlay;

    @Override
    protected void startUp() throws Exception
    {
        // Add the inventory overlay
        overlayManager.add(overlay);

        goldDropsObject = new ProfitTrackerGoldDrops(client, itemManager, config);

        inventoryValueObject = new ProfitTrackerInventoryValue(client, itemManager, config);

        initializeVariables();

        // start tracking only if plugin was re-started mid-game
        if (client.getGameState() == GameState.LOGGED_IN)
        {
            startProfitTrackingSession();
        }

    }

    private void initializeVariables()
    {
        accountPossessions = new HashMap<>();
        previousPossessions = null;
        previousAccount = null;
        inventoryValueObject.setOffers(null);

        // profit begins at 0 of course
        totalProfit = 0;

        // this will be filled with actual information in startProfitTrackingSession
        startTickMillis = 0;
        activeTicks = 0;

        // skip profit calculation for first tick, to initialize first inventory value
        skipTickForProfitCalculation = true;

        inventoryValueChanged = false;

        bankValueChanged = false;

        grandExchangeValueChanged = false;

        inProfitTrackSession = false;

        runePouchContentsChanged = false;

        bankJustClosed = false;

        depositingItem = false;

        depositDeficit = 0;
    }

    private void startProfitTrackingSession()
    {
        /*
        Start tracking profit from now on
         */

        initializeVariables();

        // initialize timer
        startTickMillis = System.currentTimeMillis();

        overlay.updateStartTimeMillies(startTickMillis);

        overlay.updateActiveTicks(activeTicks);

        overlay.startSession();

        inProfitTrackSession = true;
    }

    public void resetSession(){
        initializeVariables();
        startProfitTrackingSession();
        inventoryValueChanged = true;
    }

    /**
     * Creates an entry for the current login if needed.
     * Hooks up the possessions collection for repeat use for the current login.
     */
    private void checkAccount()
    {
        //Account for special worlds where a player with the same name might have different possessions
        //For example, a speedrunning world has MEMBER and SPEEDRUNNING types
        StringBuilder accountIdentifier = new StringBuilder(client.getLocalPlayer().getName());
        WorldType[] worldTypes = client.getWorldType().toArray(new WorldType[0]);
        for (WorldType worldType : worldTypes) {
            accountIdentifier.append(worldType.name());
        }

        accountPossessions.putIfAbsent(accountIdentifier.toString(),new ProfitTrackerPossessions());
        previousPossessions = accountPossessions.get(accountIdentifier.toString());

        if (previousAccount == null || ! previousAccount.contentEquals(accountIdentifier)) {
            if (client.getGameState() == GameState.LOGGED_IN && grandExchangeOpened)
            {
                inventoryValueObject.setOffers(client.getGrandExchangeOffers());
                previousPossessions.grandExchangeItems = inventoryValueObject.getGrandExchangeContents();
            } else {
                previousPossessions.grandExchangeItems = null;
            }
        }

        overlay.setBankStatus(previousPossessions.bankItems != null);

        previousAccount = accountIdentifier.toString();
    }

    @Override
    protected void shutDown() throws Exception
    {
        // Remove the inventory overlay
        overlayManager.remove(overlay);

    }

    @Subscribe
    public void onGameTick(GameTick gameTick) throws Exception
    {
        /*
        Main plugin logic here

        1. If inventory changed,
            - calculate profit (inventory value difference)
            - generate gold drop (nice animation for showing gold earn or loss)

        2. Calculate profit rate and update in overlay

        */

        long tickProfit;

        if (!inProfitTrackSession)
        {
            if (config.autoStart()){
                startUp();
                inventoryValueChanged = true;
            } else {
                return;
            }
        }

        checkAccount();
        activeTicks += 1;
        overlay.updateActiveTicks(activeTicks);

        if (inventoryValueChanged || runePouchContentsChanged || bankValueChanged || grandExchangeValueChanged)
        {
            // Interacting with bank
            // itemContainerChanged does not report bank change if closed on same tick
            if (storageJustClosed || untrackedStorageOpened) {
                skipTickForProfitCalculation = true;
            }

            tickProfit = calculateTickProfit();

            // accumulate profit
            if (depositingItem || depositBoxOpened || bankJustClosed){
                // Track a deficit for deposits because of deposit box problems
                // Include bank last tick close just to prevent confusing xp drops, even though they re-sync on open
                depositDeficit += tickProfit;
                depositingItem = false;
                tickProfit = 0;
            }

            // Resync with untracked changes from using deposit box
            if (bankValueChanged) {
                tickProfit += depositDeficit;
                depositDeficit = 0;
            }

            totalProfit += tickProfit;
            overlay.updateProfitValue(totalProfit);

            // generate gold drop
            if (config.goldDrops() && tickProfit != 0)
            {
                goldDropsObject.requestGoldDrop(tickProfit);
            }

            inventoryValueChanged = false;
            bankValueChanged = false;
            runePouchContentsChanged = false;
            grandExchangeValueChanged = false;
        }
        bankJustClosed = false;
        storageJustClosed = false;
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event)
    {
        switch (event.getGroupId()) {
            case InterfaceID.GE_COLLECT:
            case InterfaceID.GE_OFFERS:
                inventoryValueObject.setOffers(client.getGrandExchangeOffers());
                if (previousPossessions.grandExchangeItems == null) {
                    previousPossessions.grandExchangeItems = inventoryValueObject.getGrandExchangeContents();
                }
                grandExchangeOpened = true;
                break;
            case InterfaceID.BANK_DEPOSIT_IMP:
            case InterfaceID.BANK_DEPOSITBOX:
                depositBoxOpened = true;
                break;
            case InterfaceID.FARMING_TOOLS:
                untrackedStorageOpened = true;
                break;
        }
    }

    @Subscribe
    public void onWidgetClosed(WidgetClosed event)
    {
        switch (event.getGroupId()) {
            case InterfaceID.BANKMAIN:
                bankJustClosed = true;
                break;
            //Catch untracked storage closing, as tick perfect close can cause onItemContainerChanged to not see the change
            case InterfaceID.HUNTSMANS_KIT:
            case InterfaceID.SEED_VAULT:
            case InterfaceID.TACKLE_BOX_MAIN:
                storageJustClosed = true;
                break;
            case InterfaceID.GE_COLLECT:
            case InterfaceID.GE_OFFERS:
                grandExchangeOpened = false;
                break;
            case InterfaceID.BANK_DEPOSIT_IMP:
            case InterfaceID.BANK_DEPOSITBOX:
                depositBoxOpened = false;
                // Negates problems with closing box and depositing same tick
                depositingItem = true;
                break;
            case InterfaceID.FARMING_TOOLS:
                untrackedStorageOpened = false;
                storageJustClosed = true;
                break;
        }
    }

    private long calculateTickProfit()
    {
        /*
        Calculate and return the profit for this tick
        if skipTickForProfitCalculation is set, meaning this tick was bank / deposit
        so return 0
         */
        Item[] newInventoryItems;
        Item[] newBankItems;
        Item[] newGrandExchangeItems = null;
        long newProfit;
        Item[] possessionDifference;
        Item[] bankDifference;
        Item[] grandExchangeDifference;

        // calculate current inventory value
        newInventoryItems = inventoryValueObject.getInventoryAndEquipmentContents();
        newBankItems = inventoryValueObject.getBankContents();
        if (grandExchangeValueChanged) {
            newGrandExchangeItems = inventoryValueObject.getGrandExchangeContents();
        }

        if (!skipTickForProfitCalculation && previousPossessions.inventoryItems != null && newInventoryItems != null)
        {
            // calculate new profit
            possessionDifference = inventoryValueObject.getItemCollectionDifference(previousPossessions.inventoryItems,newInventoryItems);
            newProfit = inventoryValueObject.calculateItemValue(possessionDifference);
            if (previousPossessions.bankItems != null && newBankItems != null) {
                bankDifference = inventoryValueObject.getItemCollectionDifference(previousPossessions.bankItems,newBankItems);
                // Profit is recalculated on all items instead of summed just in case item values could change between calculations
                possessionDifference = ArrayUtils.addAll(possessionDifference,bankDifference);
                newProfit = inventoryValueObject.calculateItemValue(possessionDifference);
            }
            if (previousPossessions.grandExchangeItems != null && newGrandExchangeItems != null) {
                grandExchangeDifference = inventoryValueObject.getItemCollectionDifference(previousPossessions.grandExchangeItems,newGrandExchangeItems);
                possessionDifference = ArrayUtils.addAll(possessionDifference,grandExchangeDifference);
                newProfit = inventoryValueObject.calculateItemValue(possessionDifference);
            }

            log.debug("Calculated " + newProfit + " profit for " + (possessionDifference.length) + " item changes.");
        }
        else
        {
            /* first time calculation / banking / equipping */
            log.debug("Skipping profit calculation!");

            skipTickForProfitCalculation = false;

            // no profit this tick
            newProfit = 0;
        }

        // update prevInventoryValue for future calculations anyway!
        //prevInventoryValue = newInventoryValue;
        previousPossessions.inventoryItems = newInventoryItems;
        if (newBankItems != null) {
            if (previousPossessions.bankItems == null) {
                // If user hasn't opened bank yet, the deficit doesn't help us resync
                depositDeficit = 0;
            }
            previousPossessions.bankItems = newBankItems;
        }
        if (newGrandExchangeItems != null) {
            previousPossessions.grandExchangeItems = newGrandExchangeItems;
        }

        return newProfit;
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        /*
        this event tells us when inventory has changed
        and when banking/equipment event occurred this tick
         */
        log.debug("onItemContainerChanged container id: " + event.getContainerId());

        int containerId = event.getContainerId();

        if (containerId == InventoryID.INV ||
            containerId == InventoryID.WORN) {
            // Inventory has changed - need calculate profit in onGameTick
            inventoryValueChanged = true;
        }

        if (containerId == InventoryID.BANK) {
            bankValueChanged = true;
        }

        // In these events, inventory WILL be changed, but we DON'T want to calculate profit!
        switch (containerId){
            case InventoryID.HUNTSMANS_KIT:
            case InventoryID.SEED_VAULT:
            case InventoryID.TACKLE_BOX:
                skipTickForProfitCalculation = true;
        }

        // No container event occurs for the GE collection item containers, but inventory does
        if (grandExchangeOpened) {
            grandExchangeValueChanged = true;
        }
    }

    @Subscribe
    public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged event)
    {
        if (grandExchangeOpened){
            inventoryValueObject.setOffers(client.getGrandExchangeOffers());
            grandExchangeValueChanged = true;
        }
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event)
    {
        if (Arrays.stream(RUNE_POUCH_VARBITS).anyMatch(vb -> event.getVarbitId() == vb)){
            runePouchContentsChanged = true;
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event) {
        /* for ignoring deposit in deposit box */
        log.debug(String.format("Click! ID: %d ,menuOption: %s, menuTarget: %s",
                  event.getId(), event.getMenuOption(), event.getMenuTarget()));
        String menuOption = event.getMenuOption();

        String[] containerMenuOptions = {"Deposit-"};
        for (String containerMenuOption : containerMenuOptions) {
            if (menuOption.startsWith(containerMenuOption)) {
                // Backup catch for various bank interfaces to deposit items
                // Event object does not seem to provide information that would otherwise tell us it's a bank
                // Still, it is possible to have game tick happen before a container changes to reflect menu option,
                // which can cause unexpected profit/loss, particularly when clicking a lot in a deposit box.
                depositingItem = true;
                break;
            }
        }

        String[] collectionMenuOptions = {"Collect to bank", "Bank"};
        for (String collectionMenuOption : collectionMenuOptions) {
            if (menuOption.startsWith(collectionMenuOption) && grandExchangeOpened) {
                depositingItem = true;
                break;
            }
        }

        // Imp in a box acts like a deposit box, both via interface, and use interaction
        if (menuOption.startsWith("Use") && event.getMenuTarget().contains("Imp-in-a-box(")){
            depositingItem = true;
        }

        // Container items
        // Ignore profit changes for items that act as storage only
        switch (event.getItemId()) {
            case ItemID.RCU_POUCH_COLOSSAL: // Fill, empty | fill, empty | essence must be taken out to use
            case ItemID.RCU_POUCH_GIANT:
            case ItemID.RCU_POUCH_LARGE:
            case ItemID.RCU_POUCH_MEDIUM:
            case ItemID.RCU_POUCH_SMALL:

            case ItemID.HUNTSMANS_KIT: // Fill, Empty, view(custom storage interface)
            case ItemID.TACKLE_BOX: // View, ??
                switch (menuOption.toLowerCase()) {
                    // These items act as long term storage, and are more like banks
                    // Items are not used directly from them either
                    case "empty":
                    case "fill":
                    case "use":
                        log.debug("Ignoring storage item interaction.");
                        // Ignore manual changes to container items as the items have not been lost
                        skipTickForProfitCalculation = true;
                }
        }

        // Half-volatile storage
        // Items that can change from pure storage to volatile storage by opening
        switch (event.getItemId()) {
            case ItemID.FISH_SACK_BARREL_CLOSED:
            case ItemID.FISH_BARREL_CLOSED: //Fill, open | empty
            case ItemID.GEM_BAG: //Fill, empty, open | empty
            case ItemID.SLAYER_HERB_SACK: // Fill, empty, open | empty

            case ItemID.SEED_BOX: // Fill, Empty, Check, Open

            case ItemID.HG_MEATPOUCH_SMALL: // Fill, Empty
            case ItemID.HG_MEATPOUCH_LARGE: // Fill, Empty
            case ItemID.HG_FURPOUCH_SMALL: // Fill, Empty
            case ItemID.HG_FURPOUCH_MED: // Fill, Empty
            case ItemID.HG_FURPOUCH_LARGE: // Fill, Empty
                switch (menuOption.toLowerCase()) {
                    // These items act as long term storage, and are more like banks
                    // Items are not used directly from them either
                    case "empty":
                    case "fill":
                    case "use":
                        // Ignore manual changes to container items as the items have not been lost
                        skipTickForProfitCalculation = false;
                }
        }

        // If items can be used directly from the storage container, count the profit as otherwise we might not see
        // them get used, including interface only withdraws
        switch (event.getItemId()) {
            case ItemID.PLANK_SACK: // Fill, empty | use (dumps into inventory)
                // Items can be used directly from sack
                // Filling sack requires inventory as intermediate

            case ItemID.COAL_BAG: // Fill, empty, open | fill, empty
                //Coal can be directly used from the sack, and be filled directly from bank

                // case ItemID.BASKET: //Fill, remove-one, empty | fill | basket turns into different name like "Bananas(#)"
                //Empty sack
            case ItemID.XBOWS_BOLT_POUCH: //Open(remove interface) | | bolts can be worn via armor interface extra ammo slot
                //Rune pouch // Covered by withdraw interface

            case ItemID.FLAMTAER_BAG: // Fill, empty | empty (dumps into inventory) | items can be used directly from sack
            case ItemID.BOOKOFSCROLLS_CHARGED: // Interface with remove option | items can be used from book via activate and teleport
            case ItemID.BOOKOFSCROLLS_EMPTY: // Interface with remove option | items can be used from book via activate and teleport
            case ItemID.GNOMISH_FIRELIGHTER: // Check, uncharge | Firelighter charges used directly from box when burning logs
            case ItemID.FAVOUR_KEY_RING: //Add keys via use on ring | remove via remove interface

            case ItemID.LOG_BASKET_CLOSED: // Fill, Check(dialog based withdraw), Close/Open | Empty
            case ItemID.FORESTRY_KIT: // View(kit has withdraw interface), Fill | Use(dumps to bank) | rations used directly from kit
            case ItemID.FORESTRY_BASKET_CLOSED: // Fill, view(kit has withdraw interface/basket has none) | use (dumps to bank) | rations used directly from kit

            case ItemID.MM_SECONDARY_POUCH: // Fill, open, empty, use, check | Use (dumps to bank)
                switch (menuOption.toLowerCase()) {
                    // Interacting with these things pulls items from volatile unrecorded space
                    // Coal bag could be filled from bank to use in smithing, or filled from mining
                    // Price needs to be recorded while banking or otherwise
                    case "empty":
                    case "fill":
                    case "use":
                        // Ensure item containers
                        skipTickForProfitCalculation = false;
                }
        }

        // If items can be placed directly into the container, skipping inventory, track profit to not miss emptying
        switch (event.getItemId()) {
            case ItemID.FISH_SACK_BARREL_OPEN:
            case ItemID.FISH_BARREL_OPEN:

            //Coffins can only be emptied via configure, which doesn't report an ItemId we can see for emptying
            case ItemID.SHADES_COFFIN_BRONZE: // Fill, configure, open
            case ItemID.SHADES_COFFIN_BLACK:
            case ItemID.SHADES_COFFIN_STEEL:
            case ItemID.SHADES_COFFIN_SILVER:
            case ItemID.SHADES_COFFIN_GOLD:

            case ItemID.SHADES_COFFIN_BRONZE_OPEN:
            case ItemID.SHADES_COFFIN_BLACK_OPEN:
            case ItemID.SHADES_COFFIN_STEEL_OPEN:
            case ItemID.SHADES_COFFIN_SILVER_OPEN:
            case ItemID.SHADES_COFFIN_GOLD_OPEN: // Fill, configure, close

            case ItemID.GEM_BAG_OPEN: // Fill, Empty
            case ItemID.COAL_BAG_OPEN: // Fill, Empty

            case ItemID.SLAYER_HERB_SACK_OPEN:
            case ItemID.SEED_BOX_OPEN: //Fill, Empty, Check, Close

            case ItemID.LOG_BASKET_OPEN:
            case ItemID.FORESTRY_BASKET_OPEN:

            case ItemID.HG_MEATPOUCH_SMALL_OPEN: // Fill, Empty
            case ItemID.HG_MEATPOUCH_LARGE_OPEN: // Fill, Empty
            case ItemID.HG_FURPOUCH_SMALL_OPEN: // Fill, Empty
            case ItemID.HG_FURPOUCH_MED_OPEN: // Fill, Empty
            case ItemID.HG_FURPOUCH_LARGE_OPEN: // Fill, Empty

            case ItemID.LOOTING_BAG: // Open, Deposit(store interface) | view (deposit interface) | Commonly opened and closed

            case ItemID.MM_SECONDARY_POUCH_OPEN: // Reagent pouch
                switch (menuOption.toLowerCase()) {
                    // Interacting with these things pulls items from volatile unrecorded space
                    // Coal bag could be filled from bank to use in smithing, or filled from mining
                    // Price needs to be recorded while banking or otherwise
                    case "empty":
                    case "fill":
                    case "use":
                        // Ensure item containers
                        skipTickForProfitCalculation = false;
                }
        }
    }

    @Provides
    ProfitTrackerConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(ProfitTrackerConfig.class);
    }


    @Subscribe
    public void onScriptPreFired(ScriptPreFired scriptPreFired)
    {
        goldDropsObject.onScriptPreFired(scriptPreFired);
    }
}

package com.profittracker;
import net.runelite.api.Item;

/**
 * Data structure for holding information about a players possessions
 * Should be associated with a particular player, or account type like Leagues/Standard/Beta
 */
public class ProfitTrackerPossessions {
    public Item[] inventoryItems;
    public Item[] bankItems;
    public Item[] grandExchangeItems;
}
package com.profittracker;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.*;

import static net.runelite.api.ScriptID.XPDROPS_SETDROPSIZE;
import static net.runelite.api.ScriptID.XPDROP_DISABLED;

@Slf4j
public class ProfitTrackerGoldDrops {
    /*
       Implement gold drops.
       We do this by using the XPDrop mechanism, namely the Fake XPDrop script,
       which is intended to generate xp drops for maxed out skills.
       Fake XP Drops are composed of a skill sprite,
        and a text widget with a mod icon (<img=11> in text)
       So to create a gold drop, we create a fake xp drop, and interfere in the middle,
       and change the sprite and text to our liking.

       Flow is:

       1. create xp drop using runScript (see requestGoldDrop)
       2. getting in the middle of the drop, changing icon and text (see handleXpDrop)

       A more correct way to do this is probably by calling Item.GetImage with wanted
       coin quantity, which will give us correct coin icon and correct text,
       and simply drawing that image ourselves somehow. Instead of using xp drop mechanism.
     */

    // Values for each variant of coin sprite, used to help set up and access dynamic coin sprites
    private static final int[] COINS_SPRITES = {
            1,
            2,
            3,
            4,
            5,
            25,
            100,
            250,
            1000,
            10000
    };
    /*
    Free sprite id for the gold icons.
     */
    private static final int COINS_SPRITE_ID_START = -1337;

    // Skill ordinal to send in the fake xp drop script.
    // doesn't matter which skill expect it's better not be attack/defense/magic to avoid collision with
    // XpDropPlugin which looks for those and might change text color
    private static final int XPDROP_SKILL = Skill.FISHING.ordinal();

    // Value to send in the fake xp drop script. Doesn't matter at all
    // since we don't use this value, but we use currentGoldDropValue
    private static final int XPDROP_VALUE = 6;

    /*
    Singletons which will be provided at creation by the plugin
     */
    private final ItemManager itemManager;
    private final Client client;
    @Inject
    private ProfitTrackerConfig config;

    /* var currentGoldDropValue will have
    the gold value of the current ongoing gold drop. 2 purposes:
      1. to know the value later when we actually use it,
      2. to know to catch the next fake xpdrop in onScriptPreFired
    */
    private long currentGoldDropValue;

    ProfitTrackerGoldDrops(Client client, ItemManager itemManager, ProfitTrackerConfig config)
    {
        this.client = client;
        this.itemManager = itemManager;
        this.config = config;

        prepareCoinSprite();

        currentGoldDropValue = 0L;

    }

    public void onScriptPreFired(ScriptPreFired scriptPreFired)
    {
        /*
        We check for scripts of type XPDROPS_SETDROPSIZE to interfere with the XPdrop
        and write our own values
         */

        // is this current script type?
        if (scriptPreFired.getScriptId() != XPDROPS_SETDROPSIZE)
        {
            return;
        }

        // Get xpdrop widget id using the stack
        // taken from XpDropPlugin!

        // This runs prior to the proc being invoked, so the arguments are still on the stack.
        // Grab the first argument to the script.
        final int[] intStack = client.getIntStack();
        final int intStackSize = client.getIntStackSize();

        final int widgetId = intStack[intStackSize - 4];

        // extract information from currentGoldDropValue
        boolean isThisGoldDrop =   (currentGoldDropValue != 0);
        long     goldDropValue =     currentGoldDropValue;

        // done with this gold drop anyway
        currentGoldDropValue = 0;

        handleXpDrop(widgetId, isThisGoldDrop, goldDropValue);

    }

    private void handleXpDrop(int xpDropWidgetId, boolean isThisGoldDrop, long goldDropValue)
    {
        final Widget xpDropWidget;
        final Widget dropTextWidget;

        Widget[] xpDropWidgetChildren;

        // get widget from ID
        xpDropWidget = client.getWidget(InterfaceID.XP_DROPS, xpDropWidgetId & 0xFFFF);

        if (xpDropWidget == null)
        {
            log.error("xpDropWidget was null");
            return;
        }

        xpDropWidgetChildren = xpDropWidget.getChildren();

        if (xpDropWidgetChildren.length < 1)
        {
            log.error(String.format("Unexpected xpDropWidgets length! %d", xpDropWidgetChildren.length));
            return;
        }

        dropTextWidget = xpDropWidgetChildren[0];

        if (isThisGoldDrop)
        {
            final Widget dropSpriteWidget;

            if (xpDropWidgetChildren.length < 2)
            {
                log.error(String.format(
                        "Unexpected xpDropWidgetChildren length for a gold drop! length! %d",
                        xpDropWidgetChildren.length));
                return;
            }

            dropSpriteWidget = xpDropWidgetChildren[1];

            xpDropToGoldDrop(dropTextWidget, dropSpriteWidget, goldDropValue);
        }
        else
        {
            // reset text color for all regular xpdrops
            resetXpDropTextColor(dropTextWidget);
        }
    }

    private void xpDropToGoldDrop(Widget dropTextWidget, Widget dropSpriteWidget, long goldDropValue)
    {
        /*
        Change xpdrop icon and text, to make a gold drop
         */

        if (config.shortDrops()) {
            dropTextWidget.setText(formatGoldDropText(goldDropValue));
        } else {
            // Remove disabled icon from string
            String formattedValue = dropTextWidget.getText();
            formattedValue = formattedValue.substring(formattedValue.indexOf("> ") + 2);
            // Restore negative symbol
            dropTextWidget.setText((goldDropValue < 0 ? "-" : "") + formattedValue);
        }

        if (goldDropValue > 0)
        {
            // green text for profit
            dropTextWidget.setTextColor(Color.GREEN.getRGB());
        }
        else
        {
            // red for loss
            dropTextWidget.setTextColor(Color.RED.getRGB());
        }

        // change skill sprite to coin sprite
        if (config.iconStyle() == ProfitTrackerIconType.DYNAMIC){
            for (int spriteIndex = 0; spriteIndex < COINS_SPRITES.length; spriteIndex++){
                if (Math.abs(goldDropValue) < COINS_SPRITES[spriteIndex]){
                    dropSpriteWidget.setSpriteId(COINS_SPRITE_ID_START - spriteIndex + 1);
                    break;
                } else if (spriteIndex == COINS_SPRITES.length - 1) {
                    dropSpriteWidget.setSpriteId(COINS_SPRITE_ID_START - spriteIndex);
                }
            }
        } else {
            dropSpriteWidget.setSpriteId(COINS_SPRITE_ID_START - config.iconStyle().ordinal() + 1);
        }
    }

    private void prepareCoinSprite()
    {
        /*
        Prepare coin sprites for use in the gold drops.
        It seems item icons are not available as sprites with id,
        so we convert in this function.

        */

        //Create a sprite for each coin type
        for (int spriteIndex = 0; spriteIndex < COINS_SPRITES.length; spriteIndex++){
            AsyncBufferedImage coin_image_raw;

            // get image object by coin item id
            coin_image_raw = itemManager.getImage(ItemID.COINS, COINS_SPRITES[spriteIndex], false);

            // since getImage returns an AsyncBufferedImage, which is not loaded initially,
            // we schedule sprite conversion and sprite override for when the image is actually loaded
            int finalSpriteIndex = spriteIndex;
            coin_image_raw.onLoaded(() -> {
                final SpritePixels coin_sprite;

                // convert image to sprite
                coin_sprite = ImageUtil.getImageSpritePixels(coin_image_raw, client);

                // register new coin sprite by overriding a free sprite id
                client.getSpriteOverrides().put(COINS_SPRITE_ID_START - finalSpriteIndex, coin_sprite);
            });
        }
    }

    public void requestGoldDrop(long amount)
    {
        /*
        We create gold drops by faking a fake xp drop :)
         */

        log.debug(String.format("goldDrop: %d", amount));

        // save the value and mark an ongoing gold drop
        currentGoldDropValue = amount;

        // Create a fake xp drop. the 2 last arguments don't matter:
        // 1. skill ordinal - we will replace the icon anyway
        // 2. value - since we want to be able to pass negative numbers, we pass the value using
        // currentGoldDropValue instead of this argument
        String formattedAmount = formatGoldDropText(currentGoldDropValue);

        if (config.shortDrops()) {
            /*
            Modifying the value of xpdrops later can cause substantial dead space between the text and sprite.
            Passing a value into the runScript for xpdrops will set the sprite position based on the text sent
            taking up more/less space. The particular character also makes minor adjustments, as the rendering is
            not a monospace font. This could be eliminated if we can figure out how to reposition the sprite, or
            eliminate the invisible error icon that causes the dead space, and get the rendered drop to recalculate
            sprite position based on our custom text.
             */
            int sizeAdjustingValue = 1;
            sizeAdjustingValue = formattedAmount.length() > 3 ? 6 : sizeAdjustingValue;
            sizeAdjustingValue = formattedAmount.length() > 4 ? 60 : sizeAdjustingValue;
            sizeAdjustingValue = formattedAmount.length() > 4 && formattedAmount.contains(".") ? 10 : sizeAdjustingValue;
            sizeAdjustingValue = formattedAmount.length() == 4 && !formattedAmount.contains(".") ? 11 : sizeAdjustingValue;
            client.runScript(XPDROP_DISABLED, XPDROP_SKILL, sizeAdjustingValue);
        }
        else
        {
            client.runScript(XPDROP_DISABLED, XPDROP_SKILL, (int) Math.abs(currentGoldDropValue));
        }
    }

    private void resetXpDropTextColor(Widget xpDropTextWidget)
    {
        // taken from XpDropPlugin
        EnumComposition colorEnum = client.getEnum(EnumID.XPDROP_COLORS);
        int defaultColorId = client.getVarbitValue(VarbitID.XPDROPS_COLOUR);
        int color = colorEnum.getIntValue(defaultColorId);
        xpDropTextWidget.setTextColor(color);
    }

    private String formatGoldDropText(long goldDropValue)
    {
        // Format gold value to fit in xp drop to avoid being cut off by gold sprite
        // 999
        // 1.0K
        // 20K
        // 300K
        // 1.0M

        float goldValueRep = goldDropValue;
        String suffix;
        boolean useDecimal = false;
        if (Math.abs(goldDropValue) < 1000L) { // 1-999
            return Long.toString(goldDropValue);
        }
        else if (Math.abs(goldDropValue) < 10000L) // 1,000-9,999
        {
            goldValueRep = (goldDropValue / 1000.0F);
            suffix = "K";
            useDecimal = true;
        }
        else if (Math.abs(goldDropValue) < 1000000L) // 10,000-999,999
        {
            goldValueRep = (goldDropValue / 1000.0F);
            suffix = "K";
        }
        else if (Math.abs(goldDropValue) < 10000000L) // 1,000,000-9,999,999
        {
            goldValueRep = (goldDropValue / 1000000.0F);
            suffix = "M";
            useDecimal = true;
        }
        else if (Math.abs(goldDropValue) < 1000000000L) // 10,000,000-999,999,999
        {
            goldValueRep = (goldDropValue / 1000000.0F);
            suffix = "M";
        }
        else if (Math.abs(goldDropValue) < 1000000000000L) // 1,000,000,000+
        {
            goldValueRep = (goldDropValue / 1000000000.0F);
            suffix = "B";
            useDecimal = true;
        }
        else
        {
            return "ALOT";
        }
        double resultValue = Long.signum(goldDropValue) * Math.floor(Math.abs(goldValueRep) * 10) / 10;
        if(useDecimal)
        {
            return String.format("%.1f%s", resultValue, suffix);
        } else {
            return String.format("%.0f%s", resultValue, suffix);
        }
    }
}

package com.profittracker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

/**
 * The ProfitTrackerConfig class is used to provide user preferences to the ProfitTrackerPlugin.
 */
@ConfigGroup("ptconfig")
public interface ProfitTrackerConfig extends Config
{

    @ConfigSection(
            name = "Visual",
            description = "Settings for what the plugin features look like.",
            position =  0,
            closedByDefault = false
    )
    String visualSettings = "Visual";

    @ConfigSection(
            name = "Behavior",
            description = "Settings for calculation behavior.",
            position =  1,
            closedByDefault = false
    )
    String behaviorSettings = "Behavior";

    @ConfigItem(
            keyName = "goldDrops",
            name = "Show value changes (gold drops)",
            description = "Show each profit increase or decrease.",
            section = visualSettings
    )
    default boolean goldDrops()
    {
        return true;
    }

    @ConfigItem(
            keyName = "autoStart",
            name = "Automatically start tracking",
            description = "Automatically begin tracking profit on session start.",
            section = behaviorSettings
    )
    default boolean autoStart()
    {
        return true;
    }

    @ConfigItem(
            keyName = "shortDrops",
            name = "Shorten drop numbers",
            description = "Shorten drop numbers like 1.2K instead of 1,223, or 10M instead of 10,000,000.",
            section = visualSettings
    )
    default boolean shortDrops()
    {
        return true;
    }

    @ConfigItem(
            keyName = "iconStyle",
            name = "Icon style",
            description = "Dynamically adjust the coin icon based on the drop value, or select a specific icon.",
            section = visualSettings
    )
    default ProfitTrackerIconType iconStyle()
    {
        return ProfitTrackerIconType.DYNAMIC;
    }

    @ConfigItem(
            keyName = "estimateUntradeables",
            name = "Estimate untradeable item values",
            description = "Some untradeable items will utilize equivalent values of the best items they can convert into.",
            section = behaviorSettings
    )
    default boolean estimateUntradeables()
    {
        return true;
    }

    @ConfigItem(
            keyName = "onlineOnlyRate",
            name = "Online only rate",
            description = "Show profit rate only for time spent logged in.",
            section = visualSettings
    )
    default boolean onlineOnlyRate()
    {
        return false;
    }
}


package com.profittracker;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;

import java.text.DecimalFormat;
/**
 * The ProfitTrackerOverlay class is used to display profit values for the user
 */
public class ProfitTrackerOverlay extends Overlay {
    private long profitValue;
    private long startTimeMillies;
    private long activeTicks;
    private long lastTickMillies;
    private boolean inProfitTrackSession;
    private boolean hasBankData;

    private final ProfitTrackerConfig ptConfig;
    private final ProfitTrackerPlugin ptPlugin;
    private final PanelComponent panelComponent = new PanelComponent();

    private static final String RESET_MENU_OPTION = "Reset";
    private static final int MILLISECONDS_PER_TICK = 600;

    public static String FormatIntegerWithCommas(long value) {
        DecimalFormat df = new DecimalFormat("###,###,###");
        return df.format(value);
    }
    @Inject
    private TooltipManager tooltipManager;
    @Inject
    private Client client;
    @Inject
    private ProfitTrackerOverlay(ProfitTrackerConfig config, ProfitTrackerPlugin trackerPlugin)
    {
        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
        profitValue = 0L;
        ptConfig = config;
        startTimeMillies = 0;
        activeTicks = 0;
        lastTickMillies = 0;
        inProfitTrackSession = false;
        hasBankData = false;
        ptPlugin = trackerPlugin;
        this.addMenuEntry(MenuAction.RUNELITE_OVERLAY, RESET_MENU_OPTION, "Profit Tracker",menuEntry ->
                {
                    ptPlugin.resetSession();
                    profitValue = 0;
                });
    }

    /**
     * Render the item value overlay.
     * @param graphics the 2D graphics
     * @return the value of {@link PanelComponent#render(Graphics2D)} from this panel implementation.
     */
    @Override
    public Dimension render(Graphics2D graphics) {
        String titleText = "Profit Tracker:";
        long millisecondsElapsed;
        long profitRateValue;

        if (startTimeMillies > 0)
        {
            if (ptConfig.onlineOnlyRate()){
                millisecondsElapsed = (long)(Math.max(0, activeTicks - 1)  * MILLISECONDS_PER_TICK);
                //Add duration since last tick to ensure timer pacing isn't uneven
                if (lastTickMillies != 0){
                    millisecondsElapsed += System.currentTimeMillis() - lastTickMillies;
                }
            } else {
                millisecondsElapsed = (System.currentTimeMillis() - startTimeMillies);
            }
        }
        else
        {
            // there was never any session
            millisecondsElapsed = 0;
        }

        profitRateValue = calculateProfitHourly(millisecondsElapsed, profitValue);

        // Not sure how this can occur, but it was recommended to do so
        panelComponent.getChildren().clear();

        // Build overlay title
        panelComponent.getChildren().add(TitleComponent.builder()
                .text(titleText)
                .color(hasBankData ? Color.GREEN : Color.YELLOW)
                .build());

        if (!inProfitTrackSession)
        {
            // not in session
            // notify user to reset plugin in order to start
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("Reset plugin to start")
                    .color(Color.RED)
                    .build());

        }

        // Show tooltip warning on mouse hover if user hasn't opened bank yet
        Point mousePoint = new Point(client.getMouseCanvasPosition().getX(),client.getMouseCanvasPosition().getY());
        if(this.getBounds().contains(mousePoint) && ! hasBankData)
        {
            String tooltipString =
                    "Open bank first to ensure accurate tracking.</br>" +
                    "Otherwise, GE offer interaction or emptying containers from deposit boxes may be incorrect.";

            tooltipManager.add(new Tooltip(tooltipString));
        }

        // Set the size of the overlay (width)
        panelComponent.setPreferredSize(new Dimension(
                graphics.getFontMetrics().stringWidth(titleText) + 40,
                0));

        // elapsed time
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Time:")
                .right(formatTimeIntervalFromMs(millisecondsElapsed, false))
                .build());

        // Profit
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Profit:")
                .right(FormatIntegerWithCommas(profitValue))
                .build());

        // Profit Rate
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Rate:")
                .right(profitRateValue + "K/H")
                .build());

        return panelComponent.render(graphics);
    }

    /**
     * Updates profit value display
     * @param newValue the value to update the profitValue's {{@link #panelComponent}} with.
     */
    public void updateProfitValue(final long newValue) {
        SwingUtilities.invokeLater(() ->
            profitValue = newValue
        );
    }


    /**
     * Updates startTimeMillies display
     */
    public void updateStartTimeMillies(final long newValue) {
        SwingUtilities.invokeLater(() ->
                startTimeMillies = newValue
        );
    }

    public void updateActiveTicks(final long newValue) {
        SwingUtilities.invokeLater(() ->
                {
                    activeTicks = newValue;
                    lastTickMillies = System.currentTimeMillis();
                }
        );
    }

    public void startSession()
    {
        SwingUtilities.invokeLater(() ->
                inProfitTrackSession = true
        );
    }

    public void setBankStatus(boolean bankReady)
    {
        SwingUtilities.invokeLater(() ->
                hasBankData = bankReady
        );
    }

    private static String formatTimeIntervalFromMs(final long totalMsElapsed, boolean showMilliseconds)
    {
        /*
        elapsed seconds to format HH:MM:SS
         */
        final long ms = totalMsElapsed % 1000;
        final long sec = totalMsElapsed / 1000 % 60;
        final long min = (totalMsElapsed / 60000) % 60;
        final long hr = totalMsElapsed / 3600000;

        if (showMilliseconds) {
            return String.format("%02d:%02d:%02d.%03d", hr, min, sec, ms);
        } else {
            return String.format("%02d:%02d:%02d", hr, min, sec);
        }
    }

    static long calculateProfitHourly(long millisecondsElapsed, long profit)
    {
        long averageProfitThousandForHour;
        double averageProfitPerMillisecond;

        if (millisecondsElapsed > 0)
        {
            averageProfitPerMillisecond = (double)profit / millisecondsElapsed;
        }
        else
        {
            // can't divide by zero, not enough time has passed
            averageProfitPerMillisecond = 0;
        }

        averageProfitThousandForHour = (long)(averageProfitPerMillisecond * 3600);

        return averageProfitThousandForHour;
    }
}

package com.profittracker;

public enum ProfitTrackerIconType {
    DYNAMIC,
    COINS_1,
    COINS_2,
    COINS_3,
    COINS_4,
    COINS_5,
    COINS_25,
    COINS_100,
    COINS_250,
    COINS_1000,
    COINS_10000
}
package com.profittracker;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.game.ItemManager;
import org.apache.commons.lang3.ArrayUtils;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.gameval.InventoryID;

import javax.inject.Inject;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.LongStream;

@Slf4j
public class ProfitTrackerInventoryValue {
    /*
    Provide functional methods for calculating inventory value
     */
    /*
    Singletons which will be provided at creation by the plugin
     */

    static final int EMPTY_SLOT_ITEMID = -1;

    private final int[] RUNE_POUCH_ITEM_IDS = {
            ItemID.BH_RUNE_POUCH,
            ItemID.BH_RUNE_POUCH_TROUVER,
            ItemID.DIVINE_RUNE_POUCH,
            ItemID.DIVINE_RUNE_POUCH_TROUVER
    };

    private final int[] RUNE_POUCH_AMOUNT_VARBITS = {
            VarbitID.RUNE_POUCH_QUANTITY_1,
            VarbitID.RUNE_POUCH_QUANTITY_2,
            VarbitID.RUNE_POUCH_QUANTITY_3,
            VarbitID.RUNE_POUCH_QUANTITY_4
    };

    private final int[] RUNE_POUCH_RUNE_VARBITS = {
            VarbitID.RUNE_POUCH_TYPE_1,
            VarbitID.RUNE_POUCH_TYPE_2,
            VarbitID.RUNE_POUCH_TYPE_3,
            VarbitID.RUNE_POUCH_TYPE_4
    };

    private final int[] COLLECTION_BOX_INVENTORY_IDS = {
            InventoryID.TRADINGPOST_SELL_0,
            InventoryID.TRADINGPOST_SELL_1,
            InventoryID.TRADINGPOST_SELL_2,
            InventoryID.TRADINGPOST_SELL_3,
            InventoryID.TRADINGPOST_SELL_4,
            InventoryID.TRADINGPOST_SELL_5,
            InventoryID.GE_COLLECT_6,
            InventoryID.GE_COLLECT_7
    };

    private final ItemManager itemManager;
    private final Client client;
    @Inject
    private ProfitTrackerConfig config;
    private GrandExchangeOfferData[] offers = new GrandExchangeOfferData[8];

    /**
     * Data storage for GE offers as the normal object always maintains a reference,
     * and we need to be able to compare changes that have occurred
     */
    private static class GrandExchangeOfferData{
        int quantitySold;
        int id;
        int totalQuantity;
        int price;
        int spent;
        GrandExchangeOfferState state;

        public GrandExchangeOfferData(GrandExchangeOffer offer){
            this.quantitySold = offer.getQuantitySold();
            this.id = offer.getItemId();
            this.totalQuantity = offer.getTotalQuantity();
            this.price = offer.getPrice();
            this.spent = offer.getSpent();
            this.state = offer.getState();
        }
    }

    public ProfitTrackerInventoryValue( Client client, ItemManager itemManager, ProfitTrackerConfig config) {
        this.client = client;
        this.itemManager = itemManager;
        this.config = config;
    }

    public void setOffers(GrandExchangeOffer[] offers){
        if (offers == null){
            this.offers = new GrandExchangeOfferData[8];
            return;
        }
        for (int index = 0; index < offers.length; index++){
            this.offers[index] = new GrandExchangeOfferData(offers[index]);
        }
    }

    private long calculateItemValue(Item item) {
        /*
        Calculate GE value of single item
         */

        int itemId = item.getId();

        if (itemId < -1)
        {
            // unexpected
            log.debug("Bad item id!" + itemId);
            return 0;

        }

        if (itemId == EMPTY_SLOT_ITEMID)
        {
            return 0;
        }

        if (Arrays.stream(RUNE_POUCH_ITEM_IDS).anyMatch(pouchID -> itemId == pouchID))
        {
            log.debug(String.format("calculateItemValue itemId = %d (Rune pouch variant)", itemId));
            return item.getQuantity() * calculateRunePouchValue();
        }

        log.debug(String.format("calculateItemValue itemId = %d", itemId));

        // multiply quantity  by GE value
        return (long) item.getQuantity() * (itemManager.getItemPrice(itemId));
    }

    public long calculateContainerValue(int containerID)
    {
        /*
        calculate total inventory value
         */

        ItemContainer container = client.getItemContainer(containerID);

        if (container == null)
        {
            return 0;
        }

        Item[] items = container.getItems();

        return calculateItemValue(items);
    }

    /**
     * Calculates the value of an array of items
     */
    public long calculateItemValue(Item[] items) {
        if (config.estimateUntradeables()){
            items = replaceUntradeables(items);
        }
        return Arrays.stream(items).flatMapToLong(item ->
                LongStream.of(calculateItemValue(item))
        ).sum();
    }

    public long calculateInventoryValue()
    {
        /*
        calculate total inventory value
         */

        return calculateContainerValue(InventoryID.INV);

    }

    public long calculateEquipmentValue()
    {
        /*
        calculate total equipment value
         */
        return calculateContainerValue(InventoryID.WORN);
    }

    public long calculateRunePouchValue()
    {
        long runePouchValue = 0;
        EnumComposition runePouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);

        for (int i = 0; i < RUNE_POUCH_AMOUNT_VARBITS.length; i++)
        {
            runePouchValue += calculateRuneValue(
                    client.getVarbitValue(RUNE_POUCH_RUNE_VARBITS[i]),
                    client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS[i]),
                    runePouchEnum
            );
        }

        return runePouchValue;
    }

    public long calculateRuneValue(int runeId, int runeQuantity, EnumComposition runePouchEnum)
    {
        if (runeQuantity == 0){
            return 0;
        }
        log.debug(String.format("calculateRuneValue runeId = %d", runeId));
        return (long)(itemManager.getItemPrice(runePouchEnum.getIntValue(runeId))) * runeQuantity;
    }

    public long calculateInventoryAndEquipmentValue()
    {
        /*
        calculate total inventory + equipment value
         */

        return calculateInventoryValue() + calculateEquipmentValue();
    }

    /**
     * Gets all items on the player, or null if inventory or equipment is null
     * @return Array of items from inventory and equipment containers
     */
    public Item[] getInventoryAndEquipmentContents(){
        ItemContainer inventoryContainer = client.getItemContainer(InventoryID.INV);
        ItemContainer equipmentContainer = client.getItemContainer(InventoryID.WORN);

        if (inventoryContainer == null || equipmentContainer == null)
        {
            return null;
        }

        Item[] inventoryItems = inventoryContainer.getItems();
        Item[] equipmentItems = equipmentContainer.getItems();
        Item[] personItems = ArrayUtils.addAll(inventoryItems,equipmentItems);
        // Expand to have runes from pouch as individual items
        return expandContainers(personItems);
    }

    public Item[] getBankContents(){
        ItemContainer bankContainer = client.getItemContainer(InventoryID.BANK);

        if (bankContainer == null)
        {
            return null;
        }
        return expandContainers(bankContainer.getItems());
    }

    public Item[] getGrandExchangeContents(){
        ArrayList<Item> items = new ArrayList<> ();
        //Unclear why, but without an intermediate storage for this variable, just doing items.add(new ...) caused improper quantities
        Item coins;
        for (GrandExchangeOfferData offer : offers) {
            if (offer == null) {
                items.add(new Item(-1, 0));
                continue;
            }
            switch (offer.state) {
                case BOUGHT:
                case BUYING:
                    coins = new Item(ItemID.COINS, offer.price * (offer.totalQuantity - offer.quantitySold)); //Gold left to spend
                    items.add(coins);
                    break;
                case SOLD:
                case SELLING:
                    items.add(new Item(offer.id, offer.totalQuantity - offer.quantitySold)); //Items left to sell
                    break;
                case CANCELLED_BUY:
                case CANCELLED_SELL:
                    //All pending value in the offer will be moved to the collection item container
                    break;
                case EMPTY:
                default:
                    items.add(new Item(-1, 0));
                    break;
            }
        }
        return ArrayUtils.addAll(items.toArray(new Item[0]), getCollectionBoxContents());
    }

    /**
     * Gets all items sitting in the collection box for GE offers.
     * Can only access this data when the interface is open, avoid calling from something like onGrandExchangeOfferChanged
     * which can happen at any time.
     */
    private Item[] getCollectionBoxContents(){
        Item[] items = new Item[0];
        for (int collectionBoxInventoryId : COLLECTION_BOX_INVENTORY_IDS) {
            ItemContainer collectionBox = client.getItemContainer(collectionBoxInventoryId);
            if (collectionBox != null) {
                items = ArrayUtils.addAll(items, collectionBox.getItems());
            }
        }
        return items;
    }

    private Item[] expandContainers(Item[] items){
        Item[] extraItems = new Item[0];
        for (int i = 0; i < items.length; i++){
            final int lambdaId = items[i].getId(); // Compiler complains without this
            if (Arrays.stream(RUNE_POUCH_ITEM_IDS).anyMatch(pouchID -> lambdaId == pouchID)){
                extraItems = ArrayUtils.addAll(extraItems,getRunePouchItems());
                items[i] = new Item(-1,0); // Get rid of pouch
                break; //TODO Other containers
            }
        }
        return ArrayUtils.addAll(items,extraItems);
    }

    /**
     * Replaces various untradeable items with items they can be converted into, or coin values of those items
     */
    private Item[] replaceUntradeables(Item[] items){
        Item[] extraItems = new Item[0];
        Item[] resultItems = items.clone();
        for (int i = 0; i < resultItems.length; i++){
            boolean replaceItem = true;
            switch (resultItems[i].getId()){
                case ItemID.MINNOW:
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.RAW_SHARK,resultItems[i].getQuantity() / 40));
                    break;
                //Mark of grace for amylase crystals seems to be covered already by the GE value checker
                case ItemID.VARLAMORE_WYRM_AGILITY_TERMITE:
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.AMYLASE,resultItems[i].getQuantity()));
                    break;
                case ItemID.AGILITYARENA_TICKET: //Old agility arena ticket for pirate's hook
                case ItemID.AGILITYARENA_VOUCHER: //Brimhaven voucher for pirate's hook
                    long hookValue = calculateItemValue(new Item(ItemID.PIRATEHOOK, 1));
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * hookValue / 800)));
                    break;
                case ItemID.STAR_DUST:
                case ItemID.STAR_DUST_25:
                case ItemID.STAR_DUST_75:
                case ItemID.STAR_DUST_125:
                case ItemID.STAR_DUST_175:
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.SOFTCLAY,resultItems[i].getQuantity() * 2 / 3));
                    break;
                case ItemID.MOTHERLODE_NUGGET:
                case ItemID.MGUILD_MINERALS:
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.SOFTCLAY,resultItems[i].getQuantity() * 10));
                    break;
                case ItemID.FORESTRY_CURRENCY: //Anima bark for felling axe handle
                    long handleValue = calculateItemValue(new Item(ItemID.FORESTRY_2H_AXE_HANDLE, 1)) - calculateItemValue(new Item(ItemID.OAK_LOGS, 500));
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * handleValue / 10000)));
                    break;
                case ItemID.PRIF_CRYSTAL_SHARD: //Crystal shard high alch
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,resultItems[i].getQuantity() * 6000));
                    break;
                case ItemID.PRIF_CRYSTAL_SHARD_CRUSHED:
                    // Profit from making divine super combat, used for crystal shards/dust
                    long potionProfit = calculateItemValue(new Item(ItemID._4DOSEDIVINECOMBAT, 1)) - calculateItemValue(new Item(ItemID._4DOSE2COMBAT,1));
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * potionProfit / 4)));
                    break;
                case ItemID.TZHAAR_TOKEN: //Tokkul for onyx
                    long onyxValue = calculateItemValue(new Item(ItemID.ONYX, 1));
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * onyxValue / 300000)));
                    break;
                case ItemID.ABYSSAL_PEARL: //Abyssal pearls for ring of the elements
                    long roteValue = calculateItemValue(new Item(ItemID.RING_OF_ELEMENTS, 1));
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * roteValue / 400)));
                    break;
                case ItemID.VILLAGE_TRADE_STICKS: //Trading sticks for gout tubers
                    long tuberValue = calculateItemValue(new Item(ItemID.VILLAGE_RARE_TUBER, 1));
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * tuberValue / 120)));
                    break;
                case ItemID.FOSSIL_MERMAID_TEAR: //Mermaid tears for merfolk trident
                    long tridentValue = calculateItemValue(new Item(ItemID.MERFOLK_TRIDENT, 1));
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * tridentValue / 400)));
                    break;
                case ItemID.KONAR_KEY: //Brimstone key high alch
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.COINS,(int)(resultItems[i].getQuantity() * 48000)));
                    break;
                case ItemID.BIRD_EGG_BLUE: //Bird eggs can be traded in for seed nests
                case ItemID.BIRD_EGG_RED:
                case ItemID.BIRD_EGG_GREEN:
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.BIRD_NEST_EMPTY,resultItems[i].getQuantity()));
                    break;
                case ItemID.BIRD_NEST_EGG_BLUE:
                case ItemID.BIRD_NEST_EGG_RED:
                case ItemID.BIRD_NEST_EGG_GREEN:
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.BIRD_NEST_EMPTY,resultItems[i].getQuantity() * 2));
                    break;
                case ItemID.MAGIC_IMP_BOX_FULL:
                case ItemID.MAGIC_IMP_BOX_HALF:
                    //Replace un-tradeable magic imp boxes with regular ones for value check
                    //Otherwise using them and opening the bank would cause confusing small profits
                    extraItems = ArrayUtils.add(extraItems,new Item(ItemID.MAGIC_IMP_BOX,resultItems[i].getQuantity()));
                    break;
                //TODO Seedlings: Have unwatered seedlings turn into the seed + pot, and the watered versions into saplings
                default:
                    replaceItem = false;
                    break;
            }
            if (replaceItem) {
                resultItems[i] = new Item(-1,0);
            }
        }
        return ArrayUtils.addAll(resultItems,extraItems);
    }

    private Item[] getRunePouchItems(){
        List<Item> runes = new ArrayList<>();
        EnumComposition runePouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);

        for (int i = 0; i < RUNE_POUCH_AMOUNT_VARBITS.length; i++)
        {
            int itemID = runePouchEnum.getIntValue(client.getVarbitValue(RUNE_POUCH_RUNE_VARBITS[i]));
            runes.add(new Item(itemID,client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS[i])));
        }

        return runes.toArray(new Item[0]);
    }

    /**
     * Converts the given item array into a map
     * @return Map of item ID -> QTY
     */
    private Map<Integer, Integer> mapItemArray(Item[] items){
        return Arrays.stream(items)
                .filter((item) -> item.getQuantity() > 0)
                .collect(Collectors.toMap(Item::getId, Item::getQuantity, Integer::sum));
    }

    /**
     * Compares the two arrays, returning an array of item differences
     * For example, dropping a shark would be an array of 1 shark item, with quantity -1
     * @return Array of items with quantity set to the difference
     */
    public Item[] getItemCollectionDifference(Item[] originalItems, Item[] newItems){
        if (config.estimateUntradeables()){
            //Replace untradeables with their equivalent items.
            //The replaceUntradeables function is inaccurate for very small amounts, so we need to perform it over the source
            //with larger quantities instead of over the result difference between collections which generally is just 1 item.
            //For example, a single stardust = 2/3rds of a soft clay, which is smaller than 1, and so its quantity is truncated by the Item object.
            originalItems = replaceUntradeables(originalItems);
            newItems = replaceUntradeables(newItems);
        }
        Map<Integer, Integer> originalItemList = mapItemArray(originalItems);
        Map<Integer, Integer> newItemList = mapItemArray(newItems);
        //Subtract old quantities from new to get difference
        originalItemList.forEach((id, quantity) -> newItemList.merge(id, -quantity,(a,b)-> {
            int sum = a + b;
            //Returning null for merge removes the entry
            return sum != 0 ? sum : null;
        }));

        //Convert back to item array
        List<Item> itemDifference = new ArrayList<>();
        newItemList.forEach((id, quantity) -> itemDifference.add(new Item(id,quantity)));

        return itemDifference.toArray(new Item[0]);
    }
}


package com.profittracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ProfitTrackerTest
{
    public static void main(String[] args) throws Exception
    {
        ExternalPluginManager.loadBuiltin(ProfitTrackerPlugin.class);
        RuneLite.main(args);
    }
}

