package com.profittracker;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;

import net.runelite.api.events.*;

import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.api.events.VarbitChanged;
import org.apache.commons.lang3.ArrayUtils;

import java.util.Arrays;

@Slf4j
@PluginDescriptor(
        name = "Profit Tracker"
)
public class ProfitTrackerPlugin extends Plugin
{
    ProfitTrackerGoldDrops goldDropsObject;
    ProfitTrackerInventoryValue inventoryValueObject;

    // the profit will be calculated against this value
    private long prevInventoryValue;
    // Collection of items that was last used to calculate value, includes inventory and equipment
    private Item[] prevInventoryItems;
    private Item[] prevBankItems;
    private long totalProfit;

    private long startTickMillis;

    private boolean skipTickForProfitCalculation;
    private boolean inventoryValueChanged;
    private boolean bankValueChanged;
    private boolean inProfitTrackSession;
    private boolean runePouchContentsChanged;
    // Remembers if the bank was open last tick, because tick perfect bank close reports changes late
    private boolean bankJustClosed;
    // Set when using a deposit menu option. Used to create a depositing deficit for the next time you open bank
    // This ensures using a deposit box doesn't spam coin drops, but also doesn't get out of sync when the race
    // condition with menu options and container changes causes some anyways
    private boolean depositingItem;
    private int depositDeficit;
    private int[] RUNE_POUCH_VARBITS = {
            Varbits.RUNE_POUCH_AMOUNT1,
            Varbits.RUNE_POUCH_AMOUNT2,
            Varbits.RUNE_POUCH_AMOUNT3,
            Varbits.RUNE_POUCH_AMOUNT4,
            Varbits.RUNE_POUCH_RUNE1,
            Varbits.RUNE_POUCH_RUNE2,
            Varbits.RUNE_POUCH_RUNE3,
            Varbits.RUNE_POUCH_RUNE4
    };

    @Inject
    private Client client;

    @Inject
    private ProfitTrackerConfig config;

    @Inject
    private ItemManager itemManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private ProfitTrackerOverlay overlay;

    @Override
    protected void startUp() throws Exception
    {
        // Add the inventory overlay
        overlayManager.add(overlay);

        goldDropsObject = new ProfitTrackerGoldDrops(client, itemManager);

        inventoryValueObject = new ProfitTrackerInventoryValue(client, itemManager);

        initializeVariables();

        // start tracking only if plugin was re-started mid game
        if (client.getGameState() == GameState.LOGGED_IN)
        {
            startProfitTrackingSession();
        }

    }

    private void initializeVariables()
    {
        prevInventoryItems = null;
        prevBankItems = null;

        // profit begins at 0 of course
        totalProfit = 0;

        // this will be filled with actual information in startProfitTrackingSession
        startTickMillis = 0;

        // skip profit calculation for first tick, to initialize first inventory value
        skipTickForProfitCalculation = true;

        inventoryValueChanged = false;

        bankValueChanged = false;

        inProfitTrackSession = false;

        runePouchContentsChanged = false;

        bankJustClosed = false;

        depositingItem = false;

        depositDeficit = 0;
    }

    private void startProfitTrackingSession()
    {
        /*
        Start tracking profit from now on
         */

        initializeVariables();

        // initialize timer
        startTickMillis = System.currentTimeMillis();

        overlay.updateStartTimeMillies(startTickMillis);

        overlay.startSession();

        inProfitTrackSession = true;
    }

    @Override
    protected void shutDown() throws Exception
    {
        // Remove the inventory overlay
        overlayManager.remove(overlay);

    }

    @Subscribe
    public void onGameTick(GameTick gameTick) throws Exception
    {
        /*
        Main plugin logic here

        1. If inventory changed,
            - calculate profit (inventory value difference)
            - generate gold drop (nice animation for showing gold earn or loss)

        2. Calculate profit rate and update in overlay

        */

        long tickProfit;

        if (!inProfitTrackSession)
        {
            if (config.autoStart()){
                startUp();
                inventoryValueChanged = true;
            } else {
                return;
            }
        }

        boolean skipOnce = false;
        if (bankJustClosed) {
            // Interacting with bank
            // itemContainerChanged does not report bank change if closed on same tick
            skipOnce = true;
        }
        bankJustClosed = false;

        if (inventoryValueChanged || runePouchContentsChanged || bankValueChanged)
        {
            if (skipOnce) {
                skipTickForProfitCalculation = true;
            }
            tickProfit = calculateTickProfit();

            // accumulate profit
            if (depositingItem){
                // Track a deficit for deposits because of deposit box problems
                depositDeficit += tickProfit;
                depositingItem = false;
                tickProfit = 0;
            }

            // Resync with untracked changes from using deposit box
            if (bankValueChanged) {
                tickProfit += depositDeficit;
                depositDeficit = 0;
            }

            totalProfit += tickProfit;
            overlay.updateProfitValue(totalProfit);

            // generate gold drop
            if (config.goldDrops() && tickProfit != 0)
            {
                goldDropsObject.requestGoldDrop(tickProfit);
            }

            inventoryValueChanged = false;
            bankValueChanged = false;
            runePouchContentsChanged = false;
        }
    }

    @Subscribe
    public void onWidgetClosed(WidgetClosed event)
    {
        //Catch untracked storage closing, as tick perfect close can cause onItemContainerChanged to not see the change
        if (event.getGroupId() == 871 || //Huntsman's kit
            event.getGroupId() == InterfaceID.SEED_VAULT) { // Seed vault
            bankJustClosed = true;
        }
    }


    private long calculateTickProfit()
    {
        /*
        Calculate and return the profit for this tick
        if skipTickForProfitCalculation is set, meaning this tick was bank / deposit
        so return 0

         */
        long newInventoryValue;
        Item[] newInventoryItems;
        Item[] newBankItems;
        long newProfit;
        Item[] inventoryDifference;
        Item[] bankDifference = new Item[0];

        // calculate current inventory value
        //newInventoryValue = inventoryValueObject.calculateInventoryAndEquipmentValue();
        newInventoryItems = inventoryValueObject.getInventoryAndEquipmentContents();
        newBankItems = inventoryValueObject.getBankContents();

        if (!skipTickForProfitCalculation && prevInventoryItems != null)
        {
            // calculate new profit
            // newProfit = newInventoryValue - prevInventoryValue;
            inventoryDifference = inventoryValueObject.getItemCollectionDifference(prevInventoryItems,newInventoryItems);
            newProfit = inventoryValueObject.calculateItemValue(inventoryDifference);
            if (prevBankItems != null && newBankItems != null) {
                bankDifference = inventoryValueObject.getItemCollectionDifference(prevBankItems,newBankItems);
                // Profit is recalculated on all items instead of summed just in case item values could change between calculations
                Item[] inventoryAndBankDifference = ArrayUtils.addAll(inventoryDifference,bankDifference);
                newProfit = inventoryValueObject.calculateItemValue(inventoryAndBankDifference);
            }

            log.debug("Calculated " + newProfit + " profit for " + (inventoryDifference.length + bankDifference.length) + " item changes.");
        }
        else
        {
            /* first time calculation / banking / equipping */
            log.debug("Skipping profit calculation!");

            skipTickForProfitCalculation = false;

            // no profit this tick
            newProfit = 0;
        }

        // update prevInventoryValue for future calculations anyway!
        //prevInventoryValue = newInventoryValue;
        prevInventoryItems = newInventoryItems;
        if (newBankItems != null) {
            if (prevBankItems == null) {
                // If user hasn't opened bank yet, the deficit doesn't help us resync
                depositDeficit = 0;
            }
            prevBankItems = newBankItems;
        }

        return newProfit;
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        /*
        this event tells us when inventory has changed
        and when banking/equipment event occured this tick
         */
        log.debug("onItemContainerChanged container id: " + event.getContainerId());

        int containerId = event.getContainerId();

        if( containerId == InventoryID.INVENTORY.getId() ||
            containerId == InventoryID.EQUIPMENT.getId()) {
            // inventory has changed - need calculate profit in onGameTick
            inventoryValueChanged = true;
        }

        if( containerId == InventoryID.BANK.getId()) {
            bankValueChanged = true;
        }

        // In these events, inventory WILL be changed, but we DON'T want to calculate profit!
        if( containerId == 855 || // Huntsman's kit
            containerId == InventoryID.SEED_VAULT.getId()) { // Seed vault
            skipTickForProfitCalculation = true;
        }
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event)
    {
        if (Arrays.stream(RUNE_POUCH_VARBITS).anyMatch(vb -> event.getVarbitId() == vb)){
            runePouchContentsChanged = true;
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event) {
        /* for ignoring deposit in deposit box */
        log.debug(String.format("Click! ID: %d ,menuOption: %s, menuTarget: %s",
                  event.getId(), event.getMenuOption(), event.getMenuTarget()));
        String menuOption = event.getMenuOption();

        String containerMenuOptions[] = {"Deposit-"};
        for (int i = 0; i < containerMenuOptions.length; i++){
            if (menuOption.startsWith(containerMenuOptions[i])){
                // Backup catch for various bank interfaces to deposit items
                // Event object does not seem to provide information that would otherwise tell us it's a bank
                // Still, it is possible to have game tick happen before a container changes to reflect menu option,
                // which can cause unexpected profit/loss, particularly when clicking a lot in a deposit box.
                depositingItem = true;
                break;
            }
        }

        // Container items
        // Ignore profit changes for items that act as storage only
        switch (event.getItemId()) {
            case ItemID.COLOSSAL_POUCH: // Fill, empty | fill, empty | essence must be taken out to use
            case ItemID.GIANT_POUCH:
            case ItemID.LARGE_POUCH:
            case ItemID.MEDIUM_POUCH:
            case ItemID.SMALL_POUCH:

            case ItemID.HUNTSMANS_KIT: // Fill, Empty, view(custom storage interface)
            case ItemID.TACKLE_BOX: // View, ??
                switch (menuOption.toLowerCase()) {
                    // These items act as long term storage, and are more like banks
                    // Items are not used directly from them either
                    case "empty":
                    case "fill":
                    case "use":
                        log.debug("Ignoring storage item interaction.");
                        // Ignore manual changes to container items as the items have not been lost
                        skipTickForProfitCalculation = true;
                }
        }

        // Half-volatile storage
        // Items that can change from pure storage to volatile storage by opening
        switch (event.getItemId()) {
            case ItemID.FISH_SACK_BARREL:
            case ItemID.FISH_BARREL: //Fill, open | empty

            case ItemID.GEM_BAG_12020: //Fill, empty, open | empty
            case ItemID.HERB_SACK: // Fill, empty, open | empty

            case ItemID.SEED_BOX: // Open

            case ItemID.SMALL_MEAT_POUCH: // Fill, Empty
            case ItemID.LARGE_MEAT_POUCH: // Fill, Empty
            case ItemID.SMALL_FUR_POUCH: // Fill, Empty
            case ItemID.MEDIUM_FUR_POUCH: // Fill, Empty
            case ItemID.LARGE_FUR_POUCH: // Fill, Empty
                switch (menuOption.toLowerCase()) {
                    // These items act as long term storage, and are more like banks
                    // Items are not used directly from them either
                    case "empty":
                    case "fill":
                    case "use":
                        // Ignore manual changes to container items as the items have not been lost
                        skipTickForProfitCalculation = false;
                }
        }

        // If items can be used directly from the storage container, count the profit as otherwise we might not see
        // them get used, including interface only withdraws
        switch (event.getItemId()) {
            case ItemID.PLANK_SACK: // Fill, empty | use (dumps into inventory)
                // Items can be used directly from sack
                // Filling sack requires inventory as intermediate

            case ItemID.COAL_BAG: // Fill, empty, open | fill, empty
                //Coal can be directly used from the sack, and be filled directly from bank

                // case ItemID.BASKET: //Fill, remove-one, empty | fill | basket turns into different name like "Bananas(#)"
                //Empty sack
            case ItemID.BOLT_POUCH: //Open(remove interface) | | bolts can be worn via armor interface extra ammo slot
                //Rune pouch // Covered by withdraw interface

            case ItemID.FLAMTAER_BAG: // Fill, empty | empty (dumps into inventory) | items can be used directly from sack
            case ItemID.MASTER_SCROLL_BOOK: // Interface with remove option | items can be used from book via activate and teleport
            case ItemID.GNOMISH_FIRELIGHTER: // Check, uncharge | Firelighter charges used directly from box when burning logs
            case ItemID.STEEL_KEY_RING: //Add keys via use on ring | remove via remove interface

            case ItemID.LOG_BASKET: // Fill, Check(dialog based withdraw), Close/Open | Empty
            case ItemID.FORESTRY_KIT: // View(kit has withdraw interface), Fill | Use(dumps to bank) | rations used directly from kit
            case ItemID.FORESTRY_BASKET: // Fill, view(kit has withdraw interface/basket has none) | use (dumps to bank) | rations used directly from kit

            case ItemID.REAGENT_POUCH: // Fill, open, empty, use, check | Use (dumps to bank)
                switch (menuOption.toLowerCase()) {
                    // Interacting with these things pulls items from volatile unrecorded space
                    // Coal bag could be filled from bank to use in smithing, or filled from mining
                    // Price needs to be recorded while banking or otherwise
                    case "empty":
                    case "fill":
                    case "use":
                        // Ensure item containers
                        skipTickForProfitCalculation = false;
                }
        }

        // If items can be placed directly into the container, skipping inventory, track profit to not miss emptying
        switch (event.getItemId()) {
            case ItemID.OPEN_FISH_SACK_BARREL:
            case ItemID.OPEN_FISH_BARREL:

            //Coffins can only be emptied via configure, which doesn't report an ItemId we can see for emptying
            case ItemID.BRONZE_COFFIN: // Fill, configure, open
            case ItemID.BLACK_COFFIN:
            case ItemID.STEEL_COFFIN:
            case ItemID.SILVER_COFFIN:
            case ItemID.GOLD_COFFIN:

            case ItemID.OPEN_BRONZE_COFFIN:
            case ItemID.OPEN_BLACK_COFFIN:
            case ItemID.OPEN_STEEL_COFFIN:
            case ItemID.OPEN_SILVER_COFFIN:
            case ItemID.OPEN_GOLD_COFFIN: // Fill, configure, close

            case ItemID.OPEN_GEM_BAG: // Fill, Empty
            case ItemID.OPEN_COAL_BAG: // Fill, Empty

            case ItemID.OPEN_HERB_SACK:
            case ItemID.OPEN_SEED_BOX:

            case ItemID.OPEN_LOG_BASKET:
            case ItemID.OPEN_FORESTRY_BASKET:

            case ItemID.SMALL_MEAT_POUCH_OPEN: // Fill, Empty
            case ItemID.LARGE_MEAT_POUCH_OPEN: // Fill, Empty
            case ItemID.SMALL_FUR_POUCH_OPEN: // Fill, Empty
            case ItemID.MEDIUM_FUR_POUCH_OPEN: // Fill, Empty
            case ItemID.LARGE_FUR_POUCH_OPEN: // Fill, Empty

            case ItemID.LOOTING_BAG: // Open, Deposit(store interface) | view (deposit interface) | Commonly opened and closed

            case ItemID.OPEN_REAGENT_POUCH:
                switch (menuOption.toLowerCase()) {
                    // Interacting with these things pulls items from volatile unrecorded space
                    // Coal bag could be filled from bank to use in smithing, or filled from mining
                    // Price needs to be recorded while banking or otherwise
                    case "empty":
                    case "fill":
                    case "use":
                        // Ensure item containers
                        skipTickForProfitCalculation = false;
                }
        }
    }

    @Provides
    ProfitTrackerConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(ProfitTrackerConfig.class);
    }


    @Subscribe
    public void onScriptPreFired(ScriptPreFired scriptPreFired)
    {
        goldDropsObject.onScriptPreFired(scriptPreFired);
    }
}

package com.profittracker;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;

import java.awt.*;

import static net.runelite.api.ScriptID.XPDROPS_SETDROPSIZE;
import static net.runelite.api.ScriptID.XPDROP_DISABLED;

@Slf4j
public class ProfitTrackerGoldDrops {
    /*
       Implement gold drops.
       We do this by using the XPDrop mechanism, namely the Fake XPDrop script,
       which is intended to generate xp drops for maxed out skills.
       Fake XP Drops are composed of a skill sprite,
        and a text widget with a mod icon (<img=11> in text)
       So to create a gold drop, we create a fake xp drop, and interefere in the middle,
       and change the sprite and text to our liking.

       Flow is:

       1. create xp drop using runScript (see requestGoldDrop)
       2. getting in the middle of the drop, changing icon and text (see handleXpDrop)

       A more correct way to do this is probably by calling Item.GetImage with wanted
       coin quantity, which will give us correct coin icon and correct text,
       and simply drawing that image ourselfs somehow. Instead of using xp drop mechanism.
     */

    /*
    Free sprite id for the gold icons.
     */
    private static final int COINS_SPRITE_ID = -1337;

    // Skill ordinal to send in the fake xp drop script.
    // doesn't matter which skill expect it's better not be attack/defense/magic to avoid collision with
    // XpDropPlugin which looks for those and might change text color
    private static final int XPDROP_SKILL = Skill.FISHING.ordinal();

    // Value to send in the fake xp drop script. Doesn't matter at all
    // since we don't use this value, but we use currentGoldDropValue
    private static final int XPDROP_VALUE = 6;

    /*
    Singletons which will be provided at creation by the plugin
     */
    private final ItemManager itemManager;
    private final Client client;

    /* var currentGoldDropValue will have
    the gold value of the current ongoing gold drop. 2 purposes:
      1. to know the value later when we actually use it,
      2. to know to catch the next fake xpdrop in onScriptPreFired
    */
    private long currentGoldDropValue;

    ProfitTrackerGoldDrops(Client client, ItemManager itemManager)
    {
        this.client = client;
        this.itemManager = itemManager;

        prepareCoinSprite();

        currentGoldDropValue = 0L;

    }

    public void onScriptPreFired(ScriptPreFired scriptPreFired)
    {
        /*
        We check for scripts of type XPDROPS_SETDROPSIZE to interfere with the XPdrop
        and write our own values
         */

        // is this current script type?
        if (scriptPreFired.getScriptId() != XPDROPS_SETDROPSIZE)
        {
            return;
        }

        // Get xpdrop widget id using the stack
        // taken from XpDropPlugin!

        // This runs prior to the proc being invoked, so the arguments are still on the stack.
        // Grab the first argument to the script.
        final int[] intStack = client.getIntStack();
        final int intStackSize = client.getIntStackSize();

        final int widgetId = intStack[intStackSize - 4];

        // extract information from currentGoldDropValue
        boolean isThisGoldDrop =   (currentGoldDropValue != 0);
        long     goldDropValue =     currentGoldDropValue;

        // done with this gold drop anyway
        currentGoldDropValue = 0;

        handleXpDrop(widgetId, isThisGoldDrop, goldDropValue);

    }

    private void handleXpDrop(int xpDropWidgetId, boolean isThisGoldDrop, long goldDropValue)
    {
        final Widget xpDropWidget;
        final Widget dropTextWidget;

        Widget[] xpDropWidgetChildren;

        // get widget from ID
        xpDropWidget = client.getWidget(InterfaceID.EXPERIENCE_TRACKER, xpDropWidgetId & 0xFFFF);

        if (xpDropWidget == null)
        {
            log.error("xpDropWidget was null");
            return;
        }

        xpDropWidgetChildren = xpDropWidget.getChildren();

        if (xpDropWidgetChildren.length < 1)
        {
            log.error(String.format("Unexpected xpDropWidgets length! %d", xpDropWidgetChildren.length));
            return;
        }

        dropTextWidget = xpDropWidgetChildren[0];

        if (isThisGoldDrop)
        {
            final Widget dropSpriteWidget;

            if (xpDropWidgetChildren.length < 2)
            {
                log.error(String.format(
                        "Unexpected xpDropWidgetChildren length for a gold drop! length! %d",
                        xpDropWidgetChildren.length));
                return;
            }

            dropSpriteWidget = xpDropWidgetChildren[1];

            xpDropToGoldDrop(dropTextWidget, dropSpriteWidget, goldDropValue);
        }
        else
        {
            // reset text color for all regular xpdrops
            resetXpDropTextColor(dropTextWidget);
        }


    }
    private void xpDropToGoldDrop(Widget dropTextWidget, Widget dropSpriteWidget, long goldDropValue)
    {
        /*
        Change xpdrop icon and text, to make a gold drop
         */


        dropTextWidget.setText(formatGoldDropText(goldDropValue));

        if (goldDropValue > 0)
        {
            // green text for profit
            dropTextWidget.setTextColor(Color.GREEN.getRGB());
        }
        else
        {
            // red for loss
            dropTextWidget.setTextColor(Color.RED.getRGB());
        }

        // change skill sprite to coin sprite
        dropSpriteWidget.setSpriteId(COINS_SPRITE_ID);

    }

    private void prepareCoinSprite()
    {
        /*
        Prepare coin sprites for use in the gold drops.
        It seems item icons are not available as sprites with id,
        so we convert in this function.

        */

        AsyncBufferedImage coin_image_raw;

        // get image object by coin item id
        coin_image_raw = itemManager.getImage(ItemID.COINS_995, 10000, false);

        // since getImage returns an AsyncBufferedImage, which is not loaded initially,
        // we schedule sprite conversion and sprite override for when the image is actually loaded
        coin_image_raw.onLoaded(() -> {
            final SpritePixels coin_sprite;

            // convert image to sprite
            coin_sprite = ImageUtil.getImageSpritePixels(coin_image_raw, client);

            // register new coin sprite by overriding a free sprite id
            client.getSpriteOverrides().put(COINS_SPRITE_ID, coin_sprite);
        });

    }

    public void requestGoldDrop(long amount)
    {
        /*
        We create gold drops by faking a fake xp drop :)
         */

        log.debug(String.format("goldDrop: %d", amount));

        // save the value and mark an ongoing gold drop
        currentGoldDropValue = amount;

        // Create a fake xp drop. the 2 last arguments don't matter:
        // 1. skill ordinal - we will replace the icon anyway
        // 2. value - since we want to be able to pass negative numbers, we pass the value using
        // currentGoldDropValue instead of this argument

        client.runScript(XPDROP_DISABLED, XPDROP_SKILL, XPDROP_VALUE);

    }

    private void resetXpDropTextColor(Widget xpDropTextWidget)
    {
        // taken from XpDropPlugin
        EnumComposition colorEnum = client.getEnum(EnumID.XPDROP_COLORS);
        int defaultColorId = client.getVarbitValue(Varbits.EXPERIENCE_DROP_COLOR);
        int color = colorEnum.getIntValue(defaultColorId);
        xpDropTextWidget.setTextColor(color);
    }

    private String formatGoldDropText(long goldDropValue)
    {
        // Format gold value to fit in xp drop to avoid being cutoff by gold sprite
        // 999
        // 1.0K
        // 20K
        // 300K
        // 1.0M

        float goldValueRep = goldDropValue;
        String suffix = "";
        boolean useDecimal = false;
        if (Math.abs(goldDropValue) < 1000L) { // 1-999
            return Long.toString(goldDropValue);
        }
        else if (Math.abs(goldDropValue) < 10000L) // 1,000-9,999
        {
            goldValueRep = (goldDropValue / 1000.0F);
            suffix = "K";
            useDecimal = true;
        }
        else if (Math.abs(goldDropValue) < 1000000L) // 10,000-999,999
        {
            goldValueRep = (goldDropValue / 1000.0F);
            suffix = "K";
        }
        else if (Math.abs(goldDropValue) < 10000000L) // 1,000,000-9,999,999
        {
            goldValueRep = (goldDropValue / 1000000.0F);
            suffix = "M";
            useDecimal = true;
        }
        else if (Math.abs(goldDropValue) < 1000000000L) // 10,000,000-999,999,999
        {
            goldValueRep = (goldDropValue / 1000000.0F);
            suffix = "M";
        }
        else if (Math.abs(goldDropValue) < 1000000000000L) // 1,000,000,000+
        {
            goldValueRep = (goldDropValue / 1000000000.0F);
            suffix = "B";
            useDecimal = true;
        }
        else
        {
            return "ALOT";
        }
        if(useDecimal)
        {
            return String.format("%.1f%s", Math.floor(goldValueRep * 10) / 10, suffix);
        }else{
            return String.format("%.0f%s", Math.floor(goldValueRep * 10) / 10, suffix);
        }
    }
}

package com.profittracker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

/**
 * The ProfitTrackerConfig class is used to provide user preferences to the ProfitTrackerPlugin.
 */
@ConfigGroup("ptconfig")
public interface ProfitTrackerConfig extends Config
{

    @ConfigItem(
            keyName = "goldDrops",
            name = "Show value changes (gold drops) ",
            description = "Show each profit increase or decrease"
    )
    default boolean goldDrops()
    {
        return true;
    }

    @ConfigItem(
            keyName = "autoStart",
            name = "Automatically start tracking",
            description = "Automatically begin tracking profit on session start."
    )
    default boolean autoStart()
    {
        return true;
    }
}


package com.profittracker;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;

import java.text.DecimalFormat;
/**
 * The ProfitTrackerOverlay class is used to display profit values for the user
 */
public class ProfitTrackerOverlay extends Overlay {
    private long profitValue;
    private long startTimeMillies;
    private boolean inProfitTrackSession;

    private final ProfitTrackerConfig ptConfig;
    private final PanelComponent panelComponent = new PanelComponent();

    public static String FormatIntegerWithCommas(long value) {
        DecimalFormat df = new DecimalFormat("###,###,###");
        return df.format(value);
    }
    @Inject
    private ProfitTrackerOverlay(ProfitTrackerConfig config)
    {
        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
        profitValue = 0L;
        ptConfig = config;
        startTimeMillies = 0;
        inProfitTrackSession = false;
    }

    /**
     * Render the item value overlay.
     * @param graphics the 2D graphics
     * @return the value of {@link PanelComponent#render(Graphics2D)} from this panel implementation.
     */
    @Override
    public Dimension render(Graphics2D graphics) {
        String titleText = "Profit Tracker:";
        long secondsElapsed;
        long profitRateValue;

        if (startTimeMillies > 0)
        {
            secondsElapsed = (System.currentTimeMillis() - startTimeMillies) / 1000;
        }
        else
        {
            // there was never any session
            secondsElapsed = 0;
        }

        profitRateValue = calculateProfitHourly(secondsElapsed, profitValue);

        // Not sure how this can occur, but it was recommended to do so
        panelComponent.getChildren().clear();

        // Build overlay title
        panelComponent.getChildren().add(TitleComponent.builder()
                .text(titleText)
                .color(Color.GREEN)
                .build());

        if (!inProfitTrackSession)
        {
            // not in session
            // notify user to reset plugin in order to start
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("Reset plugin to start")
                    .color(Color.RED)
                    .build());

        }

        // Set the size of the overlay (width)
        panelComponent.setPreferredSize(new Dimension(
                graphics.getFontMetrics().stringWidth(titleText) + 40,
                0));

        // elapsed time
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Time:")
                .right(formatTimeIntervalFromSec(secondsElapsed))
                .build());

        // Profit
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Profit:")
                .right(FormatIntegerWithCommas(profitValue))
                .build());

        // Profit Rate
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Rate:")
                .right(profitRateValue + "K/H")
                .build());

        return panelComponent.render(graphics);
    }

    /**
     * Updates profit value display
     * @param newValue the value to update the profitValue's {{@link #panelComponent}} with.
     */
    public void updateProfitValue(final long newValue) {
        SwingUtilities.invokeLater(() ->
            profitValue = newValue
        );
    }


    /**
     * Updates startTimeMillies display
     */
    public void updateStartTimeMillies(final long newValue) {
        SwingUtilities.invokeLater(() ->
                startTimeMillies = newValue
        );
    }

    public void startSession()
    {
        SwingUtilities.invokeLater(() ->
                inProfitTrackSession = true
        );
    }

    private static String formatTimeIntervalFromSec(final long totalSecElapsed)
    {
        /*
        elapsed seconds to format HH:MM:SS
         */
        final long sec = totalSecElapsed % 60;
        final long min = (totalSecElapsed / 60) % 60;
        final long hr = totalSecElapsed / 3600;

        return String.format("%02d:%02d:%02d", hr, min, sec);
    }

    static long calculateProfitHourly(long secondsElapsed, long profit)
    {
        long averageProfitThousandForHour;
        long averageProfitForSecond;

        if (secondsElapsed > 0)
        {
            averageProfitForSecond = (profit) / secondsElapsed;
        }
        else
        {
            // can't divide by zero, not enough time has passed
            averageProfitForSecond = 0;
        }

        averageProfitThousandForHour = averageProfitForSecond * 3600 / 1000;

        return averageProfitThousandForHour;
    }
}

package com.profittracker;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.game.ItemManager;
import org.apache.commons.lang3.ArrayUtils;

import java.util.*;
import java.util.stream.LongStream;

@Slf4j
public class ProfitTrackerInventoryValue {
    /*
    Provide functional methods for calculating inventory value
     */
    /*
    Singletons which will be provided at creation by the plugin
     */

    static final int EMPTY_SLOT_ITEMID = -1;

    private final int[] RUNE_POUCH_ITEM_IDS = {
            ItemID.RUNE_POUCH,
            ItemID.RUNE_POUCH_L,
            ItemID.DIVINE_RUNE_POUCH,
            ItemID.DIVINE_RUNE_POUCH_L
    };

    private final int[] RUNE_POUCH_AMOUNT_VARBITS = {
            Varbits.RUNE_POUCH_AMOUNT1,
            Varbits.RUNE_POUCH_AMOUNT2,
            Varbits.RUNE_POUCH_AMOUNT3,
            Varbits.RUNE_POUCH_AMOUNT4
    };

    private final int[] RUNE_POUCH_RUNE_VARBITS = {
            Varbits.RUNE_POUCH_RUNE1,
            Varbits.RUNE_POUCH_RUNE2,
            Varbits.RUNE_POUCH_RUNE3,
            Varbits.RUNE_POUCH_RUNE4
    };

    private final ItemManager itemManager;
    private final Client client;

    public ProfitTrackerInventoryValue( Client client, ItemManager itemManager) {
        this.client = client;
        this.itemManager = itemManager;
    }

    private long calculateItemValue(Item item) {
        /*
        Calculate GE value of single item
         */

        int itemId = item.getId();

        if (itemId < -1)
        {
            // unexpected
            log.debug("Bad item id!" + itemId);
            return 0;

        }

        if (itemId == EMPTY_SLOT_ITEMID)
        {
            return 0;
        }

        if (Arrays.stream(RUNE_POUCH_ITEM_IDS).anyMatch(pouchID -> itemId == pouchID))
        {
            log.debug(String.format("calculateItemValue itemId = %d (Rune pouch variant)", itemId));
            return item.getQuantity() * calculateRunePouchValue();
        }

        log.debug(String.format("calculateItemValue itemId = %d", itemId));

        // multiply quantity  by GE value
        return item.getQuantity() * (itemManager.getItemPrice(itemId));
    }

    public long calculateContainerValue(InventoryID ContainerID)
    {
        /*
        calculate total inventory value
         */

        long newInventoryValue;

        ItemContainer container = client.getItemContainer(ContainerID);

        if (container == null)
        {
            return 0;
        }

        Item[] items = container.getItems();

        return calculateItemValue(items);
    }

    /**
     * Calculates the value of an array of items
     * @param items
     * @return
     */
    public long calculateItemValue(Item[] items) {
        return Arrays.stream(items).flatMapToLong(item ->
                LongStream.of(calculateItemValue(item))
        ).sum();
    }

    public long calculateInventoryValue()
    {
        /*
        calculate total inventory value
         */

        return calculateContainerValue(InventoryID.INVENTORY);

    }

    public long calculateEquipmentValue()
    {
        /*
        calculate total equipment value
         */
        return calculateContainerValue(InventoryID.EQUIPMENT);
    }

    public long calculateRunePouchValue()
    {
        long runePouchValue = 0;
        EnumComposition runePouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);

        for (int i = 0; i < RUNE_POUCH_AMOUNT_VARBITS.length; i++)
        {
            runePouchValue += calculateRuneValue(
                    client.getVarbitValue(RUNE_POUCH_RUNE_VARBITS[i]),
                    client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS[i]),
                    runePouchEnum
            );
        }

        return runePouchValue;
    }

    public long calculateRuneValue(int runeId, int runeQuantity, EnumComposition runePouchEnum)
    {
        if (runeQuantity == 0){
            return 0;
        }
        log.debug(String.format("calculateRuneValue runeId = %d", runeId));
        return itemManager.getItemPrice(runePouchEnum.getIntValue(runeId)) * runeQuantity;
    }

    public long calculateInventoryAndEquipmentValue()
    {
        /*
        calculate total inventory + equipment value
         */

        return calculateInventoryValue() + calculateEquipmentValue();
    }

    /**
     * Gets all items on the player, or null if inventory or equipment is null
     * @return Array of items from inventory and equipment containers
     */
    public Item[] getInventoryAndEquipmentContents(){
        ItemContainer inventoryContainer = client.getItemContainer(InventoryID.INVENTORY);
        ItemContainer equipmentContainer = client.getItemContainer(InventoryID.EQUIPMENT);


        if (inventoryContainer == null || equipmentContainer == null)
        {
            return null;
        }

        Item[] inventoryItems = inventoryContainer.getItems();
        Item[] equipmentItems = equipmentContainer.getItems();
        Item[] personItems = ArrayUtils.addAll(inventoryItems,equipmentItems);
        // Expand to have runes from pouch as individual items
        return expandContainers(personItems);
    }

    public Item[] getBankContents(){
        ItemContainer bankContainer = client.getItemContainer(InventoryID.BANK);

        if (bankContainer == null)
        {
            return null;
        }
        return expandContainers(bankContainer.getItems());
    }

    private Item[] expandContainers(Item[] items){
        Item[] extraItems = new Item[0];
        for (int i = 0; i < items.length; i++){
            final int lambdaId = items[i].getId(); // Compiler complains without this
            if (Arrays.stream(RUNE_POUCH_ITEM_IDS).anyMatch(pouchID -> lambdaId == pouchID)){
                extraItems = ArrayUtils.addAll(extraItems,getRunePouchItems());
                items[i] = new Item(-1,0); // Get rid of pouch
                break; //TODO Other containers
            }
        }
        return ArrayUtils.addAll(items,extraItems);
    }

    private Item[] getRunePouchItems(){
        List<Item> runes = new ArrayList<>();
        EnumComposition runePouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);

        for (int i = 0; i < RUNE_POUCH_AMOUNT_VARBITS.length; i++)
        {
            int itemID = runePouchEnum.getIntValue(client.getVarbitValue(RUNE_POUCH_RUNE_VARBITS[i]));
            runes.add(new Item(itemID,client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS[i])));
        }

        return runes.toArray(new Item[0]);
    }

    /**
     * Compares the two arrays, returning an array of item differences
     * For example, dropping a shark would be an array of 1 shark item, with quantity -1
     * @param originalItems
     * @param newItems
     * @return
     */
    public Item[] getItemCollectionDifference(Item[] originalItems, Item[] newItems){
        //Iterate over each item, finding any instances of its existence from before
        Item[] negativeItems = originalItems.clone();
        for (int i = 0; i < originalItems.length; i++){
            negativeItems[i] = new Item(originalItems[i].getId(),-originalItems[i].getQuantity());
        }
        Item[] itemIntermediateDifference = ArrayUtils.addAll(negativeItems,newItems);

        //Create a nicer looking item list with only the actual changes
        HashMap<Integer, Integer> itemDifferenceHash = new HashMap<>();

        for (int i = 0; i < itemIntermediateDifference.length; i++){
            int itemID = itemIntermediateDifference[i].getId();
            itemDifferenceHash.putIfAbsent(itemID, 0);
            itemDifferenceHash.put(itemID, itemDifferenceHash.get(itemID) + itemIntermediateDifference[i].getQuantity());
        }

        Iterator mapIt = itemDifferenceHash.entrySet().iterator();
        while (mapIt.hasNext()){
            Map.Entry pair = (Map.Entry)mapIt.next();
            if ((Integer)(pair.getValue()) == 0){
                mapIt.remove();
            }
        }
        List<Item> itemDifference = new ArrayList<>();
        mapIt = itemDifferenceHash.entrySet().iterator();
        while (mapIt.hasNext()){
            Map.Entry pair = (Map.Entry)mapIt.next();
            itemDifference.add(new Item((Integer)pair.getKey(),(Integer)pair.getValue()));
        }

        return itemDifference.toArray(new Item[0]);
    }
}


package com.profittracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ProfitTrackerTest
{
    public static void main(String[] args) throws Exception
    {
        ExternalPluginManager.loadBuiltin(ProfitTrackerPlugin.class);
        RuneLite.main(args);
    }
}

