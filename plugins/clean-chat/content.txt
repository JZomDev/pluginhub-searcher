package com.github.ldavid432.cleanchat;

import static com.github.ldavid432.cleanchat.CleanChatUtil.getTextLength;
import static com.github.ldavid432.cleanchat.CleanChatUtil.getTextLineCount;
import com.github.ldavid432.cleanchat.data.ChannelNameRemoval;
import static java.lang.Math.max;
import java.util.function.Consumer;
import java.util.stream.Stream;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.widgets.Widget;

@Getter
@RequiredArgsConstructor
class ChatWidgetGroup
{
	private final Widget channel;
	private final Widget rank;
	private final Widget name;
	private final Widget message;
	private final Widget clickBox;

	@Setter
	private ChannelNameRemoval channelType = null;

	private int indentSpaces = 0;

	public void onAllWidgets(Consumer<Widget> action)
	{
		Stream.of(channel, rank, name, message).forEach(action);
	}

	public void onNonChannelWidgets(Consumer<Widget> action)
	{
		Stream.of(rank, name, message).forEach(action);
	}

	public void place(final int y) {
		onAllWidgets(widget -> {
			widget.setOriginalY(y);
			widget.revalidate();
		});

		getClickBox().setOriginalY(y);
		getClickBox().setHidden(false);
		getClickBox().revalidate();
	}

	public void calculateHeight()
	{
		if (!getMessage().getText().isEmpty() && getMessage().getWidth() > 0)
		{
			int numLines = getTextLineCount(getMessage().getText(), getMessage().getWidth(), indentSpaces);
			int height = numLines * 14; // Height of each line is always 14
			getMessage().setOriginalHeight(height);
			getMessage().revalidate();

			getClickBox().setOriginalHeight(height);
			getClickBox().revalidate();
		}
	}

	public void indent(CleanChatChannelsConfig config, String matchedChannelName, String widgetChannelText)
	{
		int startOfChannel = widgetChannelText.indexOf("[" + matchedChannelName + "]");
		int endOfChannel = startOfChannel + matchedChannelName.length() + 2;

		int indentWidth = 0;

		int channelWidth = 0;
		int prefixWidth = 0;

		// TODO: See if there's something that we are missing when measuring so we can avoid adding all these hardcoded offsets
		// Don't need to mess with indentation on messages we don't edit
		// TODO: Potentially handle other message types indent?
		if (getChannelType() != null)
		{
			switch (config.indentationMode())
			{
				// Intentionally fallthrough
				case START:
					String prefix = widgetChannelText.substring(0, startOfChannel);
					prefixWidth = getTextLength(prefix);
					indentWidth += prefixWidth;

					if (getChannelType().isEnabled(config))
					{
						if (getChannelType() == ChannelNameRemoval.FRIENDS_CHAT)
						{
							indentWidth += 1;
						}
						else
						{
							indentWidth -= 2;
						}

					}
				case CHANNEL:
					if (!getChannelType().isEnabled(config))
					{
						String channel = widgetChannelText.substring(startOfChannel, endOfChannel);
						channelWidth = getTextLength(channel);
						indentWidth += channelWidth;

						if (getChannelType() != ChannelNameRemoval.FRIENDS_CHAT)
						{
							indentWidth += 1;
						}
						else
						{
							indentWidth += 4;
						}

					}
				case NAME:
					int nameWidth = 0;
					// FC puts name + channel into the channel widget
					if (getChannelType() == ChannelNameRemoval.FRIENDS_CHAT)
					{
						// TODO: Can we switch back to getTextLength here?
						// For some reason the fc channel width is the entire length of the chatbox so we can't use getWidth
						int prefixChanelNameWidth = getMessage().getOriginalX() - getChannel().getOriginalX();
						nameWidth = prefixChanelNameWidth - prefixWidth - channelWidth;
					}
					else
					{
						if (!getName().getText().isEmpty() && !getName().isHidden())
						{
							nameWidth = getName().getWidth();
						}
					}

					if (!getRank().isHidden())
					{
						nameWidth += getRank().getWidth();
					}

					indentWidth += nameWidth;

					if (indentWidth > 0 && getChannelType() != ChannelNameRemoval.FRIENDS_CHAT)
					{
						indentWidth += 4;
					}
					else if (getChannelType() == ChannelNameRemoval.FRIENDS_CHAT)
					{
						indentWidth -= 4;
					}
				case MESSAGE:
					// Already set by default
			}
		}

		if (indentWidth > 0) {
			indentSpaces = max(0, indentWidth / 3);
		} else {
			indentSpaces = 0;
		}

		if (indentSpaces > 0)
		{
			// Using spaces to keep the first line at the initial position (+/-2 pixels)
			getMessage().setText(" ".repeat(indentSpaces) + getMessage().getText());
			getMessage().setOriginalX(getMessage().getOriginalX() - indentWidth);
			getMessage().setOriginalWidth(getMessage().getOriginalWidth() + indentWidth);
			getMessage().revalidate();
		}
	}

	// TODO: Only pass in regex and get the matched string from regex - or use regex before this call and pass in the results
	public void removeFromChannel(String text, String textRegex)
	{
		int removedWidth = getTextLength(text);

		String newText = getChannel().getText()
			// Account for color tags when removing name
			// TODO: Target the channel name more precisely, this should do for now to avoid targeting timestamps in brackets
			.replaceFirst(textRegex, "");

		// Remove trailing spaces - probably only happens with timestamps turned on
		if (newText.endsWith(" "))
		{
			newText = newText.substring(0, newText.length() - 1);
			removedWidth += getTextLength(" ");
		}

		// Remove double spaces - mainly found in friends chat since it has sender + username
		if (newText.contains("  "))
		{
			newText = newText.replaceFirst(" {2}", " ");
			removedWidth += getTextLength(" ");
		}

		getChannel().setText(newText);

		// Shift widgets X left if channel was removed
		int finalRemovedWidth = removedWidth;
		onNonChannelWidgets(widget -> {
			widget.setOriginalX(widget.getOriginalX() - finalRemovedWidth);
			widget.revalidate();
		});

		// Expand the width of messages if channel was removed
		getMessage().setOriginalWidth(getMessage().getOriginalWidth() + removedWidth);
		getMessage().revalidate();

		// Reduce channel width if it was removed
		getChannel().setOriginalWidth(getChannel().getOriginalWidth() - removedWidth);
		getChannel().revalidate();
	}

	public void block()
	{
		onAllWidgets(widget -> {
			widget.setHidden(true);
			widget.setOriginalY(0);
		});

		getClickBox().setHidden(true);
		getClickBox().setOriginalY(0);
	}

}

package com.github.ldavid432.cleanchat.data;

import com.github.ldavid432.cleanchat.CleanChatChannelsConfig;
import static com.github.ldavid432.cleanchat.CleanChatUtil.CLAN_INSTRUCTION_MESSAGE;
import java.util.function.Function;
import lombok.AllArgsConstructor;
import net.runelite.client.util.Text;

@AllArgsConstructor
public enum ChatBlock
{
	CLAN_INSTRUCTION(
		CleanChatChannelsConfig::removeClanInstruction,
		CLAN_INSTRUCTION_MESSAGE
	),
	GUEST_CLAN_INSTRUCTION(
		CleanChatChannelsConfig::removeGuestClanInstruction,
		// "You are now a guest of x" is also included in this message, they are separated by a <br>
		"To talk, start each line of chat with /// or /gc"
	),
	GUEST_CLAN_RECONNECTING(
		CleanChatChannelsConfig::removeGuestClanReconnecting,
		"Attempting to reconnect to guest channel automatically..."
	),
	GROUP_IRON_INSTRUCTION(
		CleanChatChannelsConfig::removeGroupIronInstruction,
		"To talk in your Ironman Group's channel"
	),
	FRIENDS_CHAT_INSTRUCTION(
		CleanChatChannelsConfig::removeFriendsChatStartup,
		"To talk, start each line of chat with the / symbol."
	),
	FRIENDS_CHAT_ATTEMPTING(
		CleanChatChannelsConfig::removeFriendsAttempting,
		"Attempting to join chat-channel..."
	),
	FRIENDS_CHAT_NOW_TALKING(
		CleanChatChannelsConfig::removeFriendsNowTalking,
		"Now talking in chat-channel"
	),
	WELCOME(
		CleanChatChannelsConfig::removeWelcome,
		"Welcome to Old School RuneScape."
	),
	;

	public boolean isEnabled(CleanChatChannelsConfig config)
	{
		return isEnabled.apply(config);
	}

	public boolean appliesTo(CleanChatChannelsConfig config, String message)
	{
		return isEnabled(config) && Text.removeTags(message).contains(this.message);
	}

	private final Function<CleanChatChannelsConfig, Boolean> isEnabled;
	private final String message;
}

package com.github.ldavid432.cleanchat.data;

import com.github.ldavid432.cleanchat.ChannelNameManager;
import com.github.ldavid432.cleanchat.CleanChatChannelsConfig;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Function;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum ChannelNameRemoval
{
	CLAN(CleanChatChannelsConfig::removeClanName, ChannelNameManager::getClanNames),
	GUEST_CLAN(CleanChatChannelsConfig::removeGuestClanName, ChannelNameManager::getGuestClanNames),
	FRIENDS_CHAT(CleanChatChannelsConfig::removeFriendsChatName, ChannelNameManager::getFriendsChatNames),
	GROUP_IRON(
		CleanChatChannelsConfig::removeGroupIronName,
		ChannelNameManager::getGroupIronNames,
		(config, tab) -> config.removeGroupIronFromClan() && tab == ChatTab.CLAN
	);

	public List<String> getNames(ChannelNameManager channelNameManager)
	{
		return getNames.apply(channelNameManager);
	}

	public boolean isEnabled(CleanChatChannelsConfig config)
	{
		return isEnabled.apply(config);
	}

	public boolean isTabBlocked(CleanChatChannelsConfig config, ChatTab tab)
	{
		return isTabBlocked.apply(config, tab);
	}

	private final Function<CleanChatChannelsConfig, Boolean> isEnabled;
	private final Function<ChannelNameManager, List<String>> getNames;
	private final BiFunction<CleanChatChannelsConfig, ChatTab, Boolean> isTabBlocked;

	ChannelNameRemoval(Function<CleanChatChannelsConfig, Boolean> isEnabled, Function<ChannelNameManager, List<String>> getNames) {
		this(isEnabled, getNames, (c, t) -> false);
	}
}

package com.github.ldavid432.cleanchat.data;

public enum IndentMode
{
	MESSAGE,
	NAME,
	CHANNEL,
	START
}

package com.github.ldavid432.cleanchat.data;

import java.util.Arrays;
import lombok.AllArgsConstructor;
import lombok.Getter;

// Enum 5620 https://abextm.github.io/cache2/#/viewer/enum/5620
@AllArgsConstructor
public enum ChatTab
{
	ALL(0),
	GAME(1),
	PUBLIC(2),
	PRIVATE(3),
	CHANNEL(4),
	CLAN(5),
	TRADE(6),
	CLOSED(1337);

	@Getter
	private final int value;

	public static ChatTab of(int value)
	{
		return Arrays.stream(values())
			.filter(channel -> channel.getValue() == value)
			.findFirst()
			.orElse(ChatTab.ALL);
	}
}

package com.github.ldavid432.cleanchat;

import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.Text;

@Slf4j
public class CleanChatUtil
{
	public static final String CLAN_INSTRUCTION_MESSAGE = "To talk in your clan's channel, start each line of chat with // or /c.";
	public static final int GUEST_CLAN = -1;
	public static final int SCRIPT_REBUILD_CHATBOX = 84;
	// Scripts 32-36 are all about scrolling in different ways
	public static final int SCRIPT_SCROLLBAR_MIN = 32;
	public static final int SCRIPT_SCROLLBAR_MAX = 36;
	public static final int VARC_INT_CHAT_TAB = 41;
	public static final int MAX_CHANNEL_LIST_SIZE = 128;
	private static final Pattern IMG_TAG_REGEXP = Pattern.compile("<img=[^>]*>");

	public static String sanitizeName(String string)
	{
		return Text.removeTags(string).replace('\u00A0', ' ');
	}

	// Sizes sourced from: https://github.com/JamesShelton140/aqp-finder
	private static final Map<Character, Integer> CHAR_SIZE_MAP = Map.<Character, Integer>ofEntries(
		// Upper case
		Map.entry('A', 6), Map.entry('B', 5), Map.entry('C', 5), Map.entry('D', 5), Map.entry('E', 4), Map.entry('F', 4), Map.entry('G', 6), Map.entry('H', 5), Map.entry('I', 1), Map.entry('J', 5), Map.entry('K', 5), Map.entry('L', 4), Map.entry('M', 7), Map.entry('N', 6), Map.entry('O', 6), Map.entry('P', 5), Map.entry('Q', 6), Map.entry('R', 5), Map.entry('S', 5), Map.entry('T', 3), Map.entry('U', 6), Map.entry('V', 5), Map.entry('W', 7), Map.entry('X', 5), Map.entry('Y', 5), Map.entry('Z', 5),
		// Lower case
		Map.entry('a', 5), Map.entry('b', 5), Map.entry('c', 4), Map.entry('d', 5), Map.entry('e', 5), Map.entry('f', 4), Map.entry('g', 5), Map.entry('h', 5), Map.entry('i', 1), Map.entry('j', 4), Map.entry('k', 4), Map.entry('l', 1), Map.entry('m', 7), Map.entry('n', 5), Map.entry('o', 5), Map.entry('p', 5), Map.entry('q', 5), Map.entry('r', 3), Map.entry('s', 5), Map.entry('t', 3), Map.entry('u', 5), Map.entry('v', 5), Map.entry('w', 5), Map.entry('x', 5), Map.entry('y', 5), Map.entry('z', 5),
		// Numbers
		Map.entry('0', 6), Map.entry('1', 4), Map.entry('2', 6), Map.entry('3', 5), Map.entry('4', 5), Map.entry('5', 5), Map.entry('6', 6), Map.entry('7', 5), Map.entry('8', 6), Map.entry('9', 6),
		// Symbols
		Map.entry(' ', 1), Map.entry(':', 1), Map.entry(';', 2), Map.entry('"', 3), Map.entry('@', 11), Map.entry('!', 1), Map.entry('.', 1), Map.entry('\'', 2), Map.entry(',', 2), Map.entry('(', 2), Map.entry(')', 2), Map.entry('+', 5), Map.entry('-', 4), Map.entry('=', 6), Map.entry('?', 6), Map.entry('*', 7), Map.entry('/', 4), Map.entry('\\', 4), Map.entry('$', 6), Map.entry('£', 8), Map.entry('^', 6), Map.entry('{', 3), Map.entry('}', 3), Map.entry('[', 3), Map.entry(']', 3), Map.entry('&', 9), Map.entry('#', 11), Map.entry('°', 4), Map.entry('<', 5), Map.entry('>', 5), Map.entry('%', 9), Map.entry('_', 7), Map.entry('|', 1),
		// NBSP
		Map.entry('\u00A0', 1));

	public static int getTextLength(String text)
	{
		return Text.removeFormattingTags(text).replace("<lt>", "<").replace("<gt>", ">")
			.chars()
			.mapToObj(ch -> (char) ch)
			.map(key -> {
				if (!CHAR_SIZE_MAP.containsKey(key))
				{
					log.debug("Couldn't get length of {}", key);
				}
				return CHAR_SIZE_MAP.getOrDefault(key, 5) + 2;
			})
			.reduce(0, Integer::sum) + getChatIconsWidth(text);
	}

	private static int getChatIconsWidth(String text)
	{
		int imgCount = Math.toIntExact(IMG_TAG_REGEXP.matcher(text).results().count());
		return imgCount * 13; // 11 + 2
	}

	// Mimics 'paraheight' cs2 instruction
	public static int getTextLineCount(String text, int width, int indentSpaces)
	{
		// Positive lookahead ?= makes it so that the delimiter is included in the split strings
		Iterator<String> iterator = List.of(text.split("(?=(<br>)|([ \u00A0]))")).iterator();

		int numLines = 0;
		StringBuilder currentLine = new StringBuilder();

		while (iterator.hasNext())
		{
			String next = iterator.next();

			int currentWidth = getTextLength(currentLine.toString());

			if (currentWidth < width)
			{
				// Start of the line
				if (currentLine.toString().isEmpty())
				{
					currentLine.append(next);
				}
				// Adding a line break (from game messages) - player messages get escaped as <lt>br<gt>
				else if (next.startsWith("<br>"))
				{
					numLines++;
					currentLine = new StringBuilder(next);
				}
				// Adding the next chunk
				else if (currentWidth + getTextLength(next) <= width)
				{
					currentLine.append(next);
				}
				// Adding the next chunk after the initial indent
				// `currentWidth + getTextLength(next) > width` is implied
				// add 1 to indentSpaces so that we include the next chunk after the indent on the first line
				else if (numLines == 0 && currentLine.length() <= indentSpaces + 1)
				{
					currentLine.append(next);
				}
				// Width too big, go to next line
				else
				{
					numLines++;
					currentLine = new StringBuilder(next);
				}
			}
			// Width immediately too big, go to next line (this is probably a chunk that will get cut off)
			else
			{
				numLines++;
				currentLine = new StringBuilder(next);
			}
		}
		numLines++;

		return numLines;
	}

}

package com.github.ldavid432.cleanchat;

import static com.github.ldavid432.cleanchat.CleanChatUtil.CLAN_INSTRUCTION_MESSAGE;
import static com.github.ldavid432.cleanchat.CleanChatUtil.SCRIPT_REBUILD_CHATBOX;
import static com.github.ldavid432.cleanchat.CleanChatUtil.SCRIPT_SCROLLBAR_MAX;
import static com.github.ldavid432.cleanchat.CleanChatUtil.SCRIPT_SCROLLBAR_MIN;
import static com.github.ldavid432.cleanchat.CleanChatUtil.VARC_INT_CHAT_TAB;
import static com.github.ldavid432.cleanchat.CleanChatUtil.sanitizeName;
import com.github.ldavid432.cleanchat.data.ChannelNameRemoval;
import com.github.ldavid432.cleanchat.data.ChatBlock;
import com.github.ldavid432.cleanchat.data.ChatTab;
import static java.lang.Math.max;
import static java.lang.Math.min;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import static net.runelite.api.widgets.WidgetPositionMode.ABSOLUTE_CENTER;
import static net.runelite.api.widgets.WidgetPositionMode.ABSOLUTE_TOP;
import static net.runelite.api.widgets.WidgetSizeMode.ABSOLUTE;
import static net.runelite.api.widgets.WidgetSizeMode.MINUS;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

/**
 * <ul>
 *     <li>Removes channel name from chat widgets</li>
 *     <li>Blocks certain channel messages</li>
 *     <li>Indents multi-line messages</li>
 *     <li>Adjusts message height based on name removal and indentation</li>
 * </ul>
 */
@Slf4j
public class ChannelNameReplacer
{
	@Inject
	private CleanChatChannelsConfig config;

	@Inject
	private ChannelNameManager channelNameManager;

	@Inject
	private Client client;

	private int lastScrollDiff = -1;
	private int lastChatTab = ChatTab.CLOSED.getValue();
	private boolean chatboxScrolled = false;

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.HOPPING || event.getGameState() == GameState.LOGIN_SCREEN)
		{
			// Reset scroll
			lastScrollDiff = -1;
			chatboxScrolled = false;
		}
	}

	@Subscribe
	public void onScriptPreFired(ScriptPreFired event)
	{
		if (event.getScriptId() >= SCRIPT_SCROLLBAR_MIN && event.getScriptId() <= SCRIPT_SCROLLBAR_MAX)
		{
			Object[] args = event.getScriptEvent().getArguments();
			chatboxScrolled = args.length >= 2 && (int) args[1] == InterfaceID.Chatbox.CHATSCROLLBAR;
		}
	}

	/*
	Most chats appear in this format as dynamic children on the chatbox scroll area:
		// bottom chat line
		[0] = username
		[1] = chat message
		[2] = timestamp + channel name (timestamp only if that plugin is on, but is pretty common so should definitely account for it)
		[3] = rank icon
		// Next chat line
		[4] = next username
		etc...

	However, some are special:

	Friends chats:
		[0] = channel + username
		[1] = chat message
		[2] = nothing
		[3] = rank icon

	Friends game messages:
		[0] = timestamp + message
		[1] = nothing (except for the 'now talking...' message specifically which has the CLAN chat join message here...)
		[2] = nothing
		[3] = nothing

	GIM broadcasts:
		[0] = channel
		[1] = chat message
		[2] = nothing
		[3] = nothing

	Console message:
		[0] = timestamp + message
		[1] = nothing
		[2] = nothing
		[3] = nothing

	GIM or Clan broadcast after world hopping (before you have reconnected to the channel):
		[0] = nothing
		[1] = message
		[2] = nothing
		[3] = nothing

	Clan instruction message (?) after world hopping:
		[0] = message
		[1] = Did you know? tip
		[2] = nothing
		[3] = nothing

	These appear in the children array in this order even if the individual items aren't rendered
	 ex: Username is hidden for broadcasts, rank icon is hidden for public chat */
	@Subscribe
	public void onScriptPostFired(ScriptPostFired event)
	{
		if (event.getScriptId() == SCRIPT_REBUILD_CHATBOX)
		{
			checkReplacements();
		}
		else if (event.getScriptId() >= SCRIPT_SCROLLBAR_MIN && event.getScriptId() <= SCRIPT_SCROLLBAR_MAX && chatboxScrolled)
		{
			chatboxScrolled = false;

			Widget chatbox = client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
			if (chatbox != null)
			{
				lastScrollDiff = chatbox.getScrollHeight() - chatbox.getScrollY();
				client.setVarcIntValue(7, chatbox.getScrollHeight() - lastScrollDiff);
			}
		}
	}

	public void checkReplacements()
	{
		// FriendsChatManager is null at the first FriendsChatChanged after login so we have to add this check later
		channelNameManager.updateFriendsChatName();

		Widget chatbox = client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
		ChatTab selectedChatTab = ChatTab.of(client.getVarcIntValue(VARC_INT_CHAT_TAB));

		if (chatbox != null && selectedChatTab != ChatTab.CLOSED)
		{
			Widget[] chatWidgets = chatbox.getDynamicChildren().clone();
			Widget[] clickboxWidgets = chatbox.getStaticChildren().clone();

			AtomicInteger removedCount = new AtomicInteger();

			// TODO: Make i = 0
			// TODO: See if we can avoid looping through every single widget even if there is no text there
			// for (int i = 2; i < chats.length; i += 4)
			List<ChatWidgetGroup> displayedChats = Stream.iterate(
					2,
					i -> i < chatWidgets.length,
					i -> i + 4
				)
				.map(i -> {
					int rankWidgetIndex = i + 1; //    [3]
					int messageWidgetIndex = i - 1; // [1]
					int nameWidgetIndex = i - 2; //    [0]

					Widget channelWidget = chatWidgets[i];
					if (channelWidget.getText().isEmpty())
					{
						// Channel is not at [2]. This is either a message with channel at [0] or a message without a channel

						if (!chatWidgets[i - 2].getText().isEmpty())
						{
							// Channel is at [0], this is a special message, adjust indices accordingly

							Widget messageWidget = chatWidgets[i - 1];
							// For some reason the fc now talking message specifically, has the CLAN chat join message here...
							if (messageWidget.getText().isEmpty() || Text.removeTags(messageWidget.getText()).equals(CLAN_INSTRUCTION_MESSAGE))
							{
								// Friends chat message

								messageWidgetIndex = i - 2; // [0]
								// Empty widget in this case, but still good to handle it
								nameWidgetIndex = i - 1; //    [1]
							}
							else
							{
								// Other special message

								channelWidget = chatWidgets[i - 2]; // [0]
								// Empty widget in this case, but still good to handle it
								nameWidgetIndex = i; //                [2]
							}
						}
						else if (chatWidgets[messageWidgetIndex].getText().isEmpty())
						{
							return null;
						}
						else
						{
							// Clan/GIM broadcast after world hopping - just use default setup since we mainly care about the message in this case
						}
					}

					return new ChatWidgetGroup(channelWidget, chatWidgets[rankWidgetIndex], chatWidgets[nameWidgetIndex], chatWidgets[messageWidgetIndex], clickboxWidgets[(i - 2) / 4]);
				})
				.filter(Objects::nonNull)
				.filter(group -> {
					boolean blockChat = Stream.of(ChatBlock.values()).anyMatch(block -> block.appliesTo(config, group.getMessage().getText()));

					if (!blockChat && !group.getChannel().getText().isEmpty())
					{
						// If the text is not blank we *should* be guaranteed a match
						for (ChannelNameRemoval channelRemoval : ChannelNameRemoval.values())
						{
							String widgetChannelName = sanitizeName(group.getChannel().getText());
							String matchedChannelName = channelRemoval.getNames(channelNameManager).stream()
								.map(CleanChatUtil::sanitizeName)
								.filter(channel -> widgetChannelName.contains("[" + channel + "]"))
								.findFirst()
								.orElse(null);

							if (matchedChannelName != null)
							{
								group.setChannelType(channelRemoval);

								blockChat = channelRemoval.isTabBlocked(config, selectedChatTab);

								if (!blockChat && channelRemoval.isEnabled(config))
								{
									group.removeFromChannel(
										"[" + matchedChannelName + "]",
										//language=RegExp
										"\\[[^]\\[]*" + matchedChannelName + ".*]"
									);
								}

								if (!blockChat)
								{
									group.indent(config, matchedChannelName, widgetChannelName);
								}

								break;
							}
						}
					}

					// Totally bizarre situation where after hopping the clan instruction becomes the name and the previous 'did you know?' becomes the message
					//  channel=nothing, name=clan instruction, message=did you know? ...
					if (!blockChat && ChatBlock.CLAN_INSTRUCTION.appliesTo(config, group.getName().getText())) {
						blockChat = true;
					}

					if (blockChat)
					{
						group.block();
						removedCount.getAndIncrement();
					}

					return !blockChat;
				})
				// Calculate height last
				.peek(ChatWidgetGroup::calculateHeight)
				.collect(Collectors.toList());

			log.debug("Showing {} chat messages out of {}", displayedChats.size(), displayedChats.size() + removedCount.get());

			Collections.reverse(displayedChats);

			// Calculate this after editing messages
			int totalHeight = displayedChats.stream()
				.map(group -> group.getMessage().getHeight())
				.reduce(0, Integer::sum);

			// If we only have a few messages we want to place them at the bottom (chatbox.getHeight()) instead of the top (0).
			//  If placing from the bottom, add padding first
			int y = totalHeight >= chatbox.getHeight() ? 0 : chatbox.getHeight() - totalHeight - 2;

			// Place widgets vertically
			for (ChatWidgetGroup group : displayedChats)
			{
				group.place(y);

				y += group.getMessage().getHeight();
			}

			// If placing at the top, add padding last
			if (totalHeight >= chatbox.getHeight())
			{
				y += 2;
			}

			y = max(y, chatbox.getHeight());

			chatbox.setScrollHeight(y);
			chatbox.revalidateScroll();

			// Replacing this script with Java allows us to avoid a clientThread.invokeLater as well as adjust the logic since we are modifying the true scroll height
			scrollbar_resize(chatbox);

			// Store this since rebuildchatbox changes the scroll position before we can
			lastScrollDiff = chatbox.getScrollHeight() - chatbox.getScrollY();
		} else {
			// chat closed - reset scroll
			lastScrollDiff = -1;
			chatboxScrolled = false;
		}
		lastChatTab = selectedChatTab.getValue();
	}

	// Script 72
	private void scrollbar_resize(Widget scrollArea)
	{
		Widget scrollBarContainer = client.getWidget(InterfaceID.Chatbox.CHATSCROLLBAR);

		int scrollAreaHeight = scrollArea.getScrollHeight();
		if (scrollAreaHeight <= 0)
		{
			scrollAreaHeight = scrollArea.getHeight();
		}

		int scrollBarHeight;
		if (scrollAreaHeight > 0)
		{
			scrollBarHeight = (scrollBarContainer.getHeight() - 32) * scrollArea.getHeight() / scrollAreaHeight;
		}
		else
		{
			scrollBarHeight = scrollBarContainer.getHeight() - 32;
		}
		if (scrollBarHeight < 10)
		{
			scrollBarHeight = 10;
		}

		Widget scrollBar = scrollBarContainer.getChild(1);
		if (scrollBar != null)
		{
			scrollBar.setSize(0, scrollBarHeight, MINUS, ABSOLUTE);
			scrollBar.revalidate();

			scrollbar_vertical_doscroll(scrollBarContainer, scrollArea, scrollBar);

			scrollBarContainer.revalidateScroll();
			scrollArea.revalidateScroll();
		}
	}

	// Script 37
	private void scrollbar_vertical_doscroll(Widget scrollBarContainer, Widget scrollArea, Widget scrollBar)
	{
		int int2;
		if (lastChatTab != ChatTab.CLOSED.getValue() && lastScrollDiff != -1)
		{
			// Custom logic to restore our scroll values since rebuildchatbox will override them
			int2 = max(scrollArea.getScrollHeight() - lastScrollDiff, 0);
		}
		else if(scrollArea.getHeight() < 0)
		{
			// For some reason scrollArea.getHeight is negative after the first login so we just default to 0
			int2 = 0;
			// The scrollHeight is also wrong after first login so just default to the base height
			scrollArea.setScrollHeight(114);
		}
		else
		{
			// Original script logic
			int2 = scrollArea.getScrollY();
			int int3 = max(scrollArea.getScrollHeight() - scrollArea.getHeight(), 1);
			int2 = max(min(int2, int3), 0);
		}
		scrollArea.setScrollY(int2);
		scrollArea.revalidateScroll();
		client.setVarcIntValue(7, scrollArea.getScrollY());

		scrollbar_vertical_setdragger(scrollBarContainer, scrollArea, scrollBar);
	}

	// Script 740
	private void scrollbar_vertical_setdragger(Widget scrollBarContainer, Widget scrollArea, Widget scrollBar)
	{
		int int2 = max(scrollArea.getScrollHeight() - scrollArea.getHeight(), 1);
		int int3 = scrollBarContainer.getHeight() - 32 - scrollBar.getHeight();

		int scrollBarPos = max(16 + int3 * scrollArea.getScrollY() / int2, 16);
		scrollBar.setPos(0, scrollBarPos, ABSOLUTE_CENTER, ABSOLUTE_TOP);
		scrollBar.revalidate();

		Widget scrollbarElementTop = scrollBarContainer.getChild(2);
		if (scrollbarElementTop != null)
		{
			scrollbarElementTop.setPos(0, scrollBar.getOriginalY(), ABSOLUTE_CENTER, ABSOLUTE_TOP);
			scrollbarElementTop.revalidate();
		}

		Widget scrollbarElementBottom = scrollBarContainer.getChild(3);
		if (scrollbarElementBottom != null)
		{
			scrollbarElementBottom.setPos(0, scrollBar.getOriginalY() + scrollBar.getHeight() - 5, ABSOLUTE_CENTER, ABSOLUTE_TOP);
			scrollbarElementBottom.revalidate();
		}
	}

}

package com.github.ldavid432.cleanchat;

import static com.github.ldavid432.cleanchat.CleanChatChannelsConfig.CURRENT_VERSION;
import static com.github.ldavid432.cleanchat.CleanChatChannelsConfig.HIDE_SCROLLBAR_KEY;
import com.google.inject.Provides;
import java.awt.Color;
import java.util.Objects;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.util.ColorUtil;

@Slf4j
@PluginDescriptor(
	name = "Clean Chat",
	description = "Hide clan name and more to clean your chat channels, includes GIM, friends, and clan chats",
	tags = {"clean", "chat", "clan", "friends", "gim", "group", "iron", "ironman", "channel"}
)
public class CleanChatChannelsPlugin extends Plugin
{

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private CleanChatChannelsConfig config;

	@Inject
	private ChannelNameManager channelNameManager;

	@Inject
	private ChannelNameReplacer channelNameReplacer;

	@Inject
	private EventBus eventBus;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Provides
	CleanChatChannelsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CleanChatChannelsConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		eventBus.register(channelNameReplacer);
		eventBus.register(channelNameManager);
		channelNameManager.startup();

		if (client.getGameState() == GameState.LOGGED_IN)
		{
			log.debug("Plugin enabled. Refreshing chat.");
			client.refreshChat();
		} else if (client.getGameState() != GameState.LOGGED_IN && config.getLastSeenVersion() < CURRENT_VERSION) {
			int lastSeenVersion = config.getLastSeenVersion();
			config.setLstSeenVersion(CURRENT_VERSION);
			// Since last seen version wasn't in 1.0 checking for only it will trigger for everyone who installs the plugin.
			//  By only triggering this during startup and while not logged in we can "better" attempt to determine if this is a previous install or not.
			//  Still not totally accurate but better than nothing.
			if (lastSeenVersion < 1) {
				chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage(
						ColorUtil.wrapWithColorTag(
							"Clean Chat has been updated to 2.0! This update is mainly a major rework to the plugin internals. " +
								"If you run into any issues please report them on the GitHub.",
							Color.RED
						)
					)
					.build());
			}
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		eventBus.unregister(channelNameReplacer);
		eventBus.unregister(channelNameManager);
		channelNameManager.shutdown();

		// Remove all our shenanigans
		log.debug("Plugin disabled. Refreshing chat.");
		client.refreshChat();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (Objects.equals(event.getGroup(), CleanChatChannelsConfig.GROUP))
		{
			log.debug("Config changed. Refreshing chat.");
			client.refreshChat();

			if (Objects.equals(event.getKey(), HIDE_SCROLLBAR_KEY))
			{
				clientThread.invoke(this::handleScrollbarVisibility);
			}
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (event.getGroupId() == InterfaceID.CHATBOX)
		{
			handleScrollbarVisibility();
		}
	}

	private void handleScrollbarVisibility()
	{
		Widget chatbox = client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
		Widget scrollBarContainer = client.getWidget(InterfaceID.Chatbox.CHATSCROLLBAR);
		if (chatbox != null && scrollBarContainer != null) {
			scrollBarContainer.setHidden(config.hideScrollbar());

			// width mode is MINUS, so we if we want to match the parent width we use 0
			if (config.hideScrollbar()) {
				chatbox.setOriginalWidth(0);
			} else {
				chatbox.setOriginalWidth(16);
			}
			chatbox.revalidate();

			client.refreshChat();
		}
	}

}

package com.github.ldavid432.cleanchat;

import static com.github.ldavid432.cleanchat.CleanChatChannelsConfig.GROUP;
import com.github.ldavid432.cleanchat.data.IndentMode;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup(GROUP)
public interface CleanChatChannelsConfig extends Config
{
	String GROUP = "cleanchat";
	String HIDE_SCROLLBAR_KEY = "hideScrollbar";
	int CURRENT_VERSION = 2;

	@ConfigItem(
		keyName = "lastSeenVersion",
		name = "",
		description = "",
		hidden = true
	)
	default int getLastSeenVersion()
	{
		return -1;
	}

	@ConfigItem(
		keyName = "lastSeenVersion",
		name = "",
		description = ""
	)
	void setLstSeenVersion(int lastSeenVersion);

	@ConfigItem(
		keyName = "removeWelcome",
		name = "Remove welcome message",
		description = "Remove 'Welcome to RuneScape' message",
		position = 0
	)
	default boolean removeWelcome()
	{
		return true;
	}

	@ConfigItem(
		keyName = "lineBreakIndentationMode",
		name = "Indent Mode",
		description = "Adjust the starting indent for the 2nd (and further) lines in multi-line messages (only in chat channels)<br>" +
			"Message - Default, start directly under the first line<br>" +
			"Name - Start under the username<br>" +
			"Channel - Start under the channel name and after the timestamp. If channel removal is on, acts like Name<br>" +
			"Start - Start at the start of the chat box<br>" +
			"Note: Turning this on may make multi-line messages shift one or two pixels to the right",
		position = 1
	)
	default IndentMode indentationMode()
	{
		return IndentMode.MESSAGE;
	}

	@ConfigItem(
		keyName = HIDE_SCROLLBAR_KEY,
		name = "Hide Scrollbar",
		description = "Hide the chatbox scrollbar. You can still scroll with the mouse wheel like normal.",
		position = 2
	)
	default boolean hideScrollbar()
	{
		return false;
	}

	@ConfigSection(
		name = "Clan Chat",
		description = "Configure clan chat",
		position = 10
	)
	String clanSection = "clanSection";

	@ConfigItem(
		keyName = "removeClanInstruction",
		name = "Remove startup message",
		description = "Remove message telling you how to chat in your clan channel",
		section = clanSection,
		position = 0
	)
	default boolean removeClanInstruction()
	{
		return true;
	}

	@ConfigItem(
		keyName = "removeClanName",
		name = "Remove clan name",
		description = "Remove clan name from clan chat messages",
		section = clanSection,
		position = 1
	)
	default boolean removeClanName()
	{
		return false;
	}

	@ConfigSection(
		name = "Guest Clan Chat",
		description = "Configure guest clan chat",
		position = 15
	)
	String guestClanSection = "guestClanSection";

	@ConfigItem(
		keyName = "removeGuestClanInstruction",
		name = "Remove startup message",
		description = "Remove message telling you how to chat in your guest clan channel",
		section = guestClanSection,
		position = 0
	)
	default boolean removeGuestClanInstruction()
	{
		return true;
	}

	@ConfigItem(
		keyName = "removeGuestClanReconnecting",
		name = "Remove reconnecting message",
		description = "Remove 'Attempting to reconnect...' message in your guest clan channel",
		section = guestClanSection,
		position = 1
	)
	default boolean removeGuestClanReconnecting()
	{
		return false;
	}

	@ConfigItem(
		keyName = "removeGuestClanName",
		name = "Remove guest clan name",
		description = "Remove guest clan name from guest clan chat messages",
		section = guestClanSection,
		position = 2
	)
	default boolean removeGuestClanName()
	{
		return false;
	}

	@ConfigSection(
		name = "Group Iron Chat",
		description = "Configure group iron chat",
		position = 20
	)
	String ironSection = "ironSection";

	@ConfigItem(
		keyName = "removeGroupIronInstruction",
		name = "Remove startup message",
		description = "Remove message telling you how to chat in your GIM channel",
		section = ironSection,
		position = 0
	)
	default boolean removeGroupIronInstruction()
	{
		return true;
	}

	@ConfigItem(
		keyName = "removeGroupIronName",
		name = "Remove GIM name",
		description = "Remove GIM name from GIM chat messages",
		section = ironSection,
		position = 1
	)
	default boolean removeGroupIronName()
	{
		return false;
	}

	@ConfigItem(
		keyName = "moveGroupIronBroadcasts",
		name = "Move GIM broadcasts",
		description = "Remove GIM broadcasts from the clan chat tab, only display them in the group tab",
		section = ironSection,
		position = 2
	)
	default boolean removeGroupIronFromClan()
	{
		return true;
	}

	@ConfigSection(
		name = "Friends Chat",
		description = "Configure friends chat",
		position = 30
	)
	String friendsSection = "friendsSection";

	@ConfigItem(
		keyName = "removeFriendsChatInstruction",
		name = "Remove startup message",
		description = "Remove message telling you how to chat in your friends channel",
		section = friendsSection,
		position = 0
	)
	default boolean removeFriendsChatStartup()
	{
		return true;
	}

	@ConfigItem(
		keyName = "removeFriendsChatName",
		name = "Remove friends chat name",
		description = "Remove friends chat name from friends chat channel messages",
		section = friendsSection,
		position = 1
	)
	default boolean removeFriendsChatName()
	{
		return false;
	}

	@ConfigItem(
		keyName = "removeFriendsAttempting",
		name = "Remove 'attempting to join'",
		description = "Remove 'Attempting to join...' message from friends chat channel",
		section = friendsSection,
		position = 2
	)
	default boolean removeFriendsAttempting()
	{
		return false;
	}

	@ConfigItem(
		keyName = "removeFriendsNowTalking",
		name = "Remove 'now talking in'",
		description = "Remove 'Now talking in chat-channel...' message from friends chat channel",
		section = friendsSection,
		position = 3
	)
	default boolean removeFriendsNowTalking()
	{
		return false;
	}
}

package com.github.ldavid432.cleanchat;

import static com.github.ldavid432.cleanchat.CleanChatUtil.MAX_CHANNEL_LIST_SIZE;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.GameState;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanID;
import net.runelite.api.events.ClanChannelChanged;
import net.runelite.api.events.FriendsChatChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

/**
 * Tracks current and previous chat channel names for use in the ChatChannelReplacer
 */
@Slf4j
@Singleton
public class ChannelNameManager
{

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	// Store these as a collection so that even if you leave a channel the chats will still be "cleaned"
	@Getter
	private final List<String> clanNames = new ArrayList<>();
	@Getter
	private final List<String> guestClanNames = new ArrayList<>();
	@Getter
	private final List<String> friendsChatNames = new ArrayList<>();
	@Getter
	private final List<String> groupIronNames = new ArrayList<>();

	public void startup()
	{
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			clientThread.invokeLater(() -> {
				updateFriendsChatName();

				ClanChannel clanChannel = client.getClanChannel(ClanID.CLAN);
				if (clanChannel != null)
				{
					addName(clanNames, clanChannel.getName());
				}

				ClanChannel groupIronChannel = client.getClanChannel(ClanID.GROUP_IRONMAN);
				if (groupIronChannel != null)
				{
					addName(groupIronNames, groupIronChannel.getName());
				}

				ClanChannel guestClanChannel = client.getGuestClanChannel();
				if (guestClanChannel != null)
				{
					addName(guestClanNames, guestClanChannel.getName());
				}
			});
		}
	}

	public void shutdown() {
		clanNames.clear();
		groupIronNames.clear();
		guestClanNames.clear();
		friendsChatNames.clear();
	}

	@Subscribe
	public void onClanChannelChanged(ClanChannelChanged event)
	{
		String channelName = event.getClanChannel() != null ? event.getClanChannel().getName() : null;

		if (channelName == null)
		{
			return;
		}

		switch (event.getClanId())
		{
			case CleanChatUtil.GUEST_CLAN:
				addName(guestClanNames, channelName);
				break;
			case ClanID.CLAN:
				addName(clanNames, channelName);
				break;
			case ClanID.GROUP_IRONMAN:
				addName(groupIronNames, channelName);
				break;
		}
	}

	@Subscribe
	public void onFriendsChatChanged(FriendsChatChanged event)
	{
		if (event.isJoined())
		{
			updateFriendsChatName();
		}
	}

	public void updateFriendsChatName()
	{
		FriendsChatManager friendsChatManager = client.getFriendsChatManager();
		// This is null at the first FriendsChatChanged after login
		if (friendsChatManager != null)
		{
			addName(friendsChatNames, friendsChatManager.getName());
		}
	}

	private void addName(List<String> nameList, String name)
	{
		if (nameList.contains(name) || name == null)
		{
			return;
		}

		if (nameList.size() == MAX_CHANNEL_LIST_SIZE)
		{
			nameList.remove(0);
		}

		nameList.add(name);
	}
}

package com.github.ldavid432;

import com.github.ldavid432.cleanchat.CleanChatChannelsPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CleanChatTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CleanChatChannelsPlugin.class);
		RuneLite.main(args);
	}
}

