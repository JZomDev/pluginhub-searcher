package com.worldheatmap;

import java.awt.*;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;

import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.io.File;
import java.io.IOException;

@Slf4j
public class WorldHeatmapPanel extends PluginPanel {

    private final WorldHeatmapPlugin plugin;
    private JLabel playerIDLabel;

    private JLabel totalMemoryUsageLabel;

    Map<HeatmapNew.HeatmapType, JPanel> heatmapPanels = new HashMap<>();
    Map<HeatmapNew.HeatmapType, JLabel> heatmapTotalValueLabels = new HashMap<>();
	Map<HeatmapNew.HeatmapType, JLabel> heatmapTileCountLabels = new HashMap<>();
    Map<HeatmapNew.HeatmapType, JLabel> heatmapPanelLabels = new HashMap<>();
    Map<HeatmapNew.HeatmapType, JButton> writeHeatmapImageButtons = new HashMap<>();
    Map<HeatmapNew.HeatmapType, JButton> clearHeatmapButtons = new HashMap<>();
	Map<HeatmapNew.HeatmapType, Integer> memoryUsageEstimates = new HashMap<>();
	protected long timeOfLastMemoryEstimate = -1;

    public WorldHeatmapPanel(WorldHeatmapPlugin plugin) {
        this.plugin = plugin;
        rebuild();
    }

    protected void rebuild() {
        removeAll();
        Font buttonFont = new Font("Runescape", Font.BOLD, 18);
        Font sectionLabelFont = new Font("Runescape", Font.BOLD, 18);

        //Main Panel
        int vGap = 5;
        int hGap = 5;
        JPanel mainPanel = new JPanel(new GridLayout(0, 1, hGap, vGap));
        mainPanel.setBorder(new EmptyBorder(vGap, hGap, vGap, hGap));
        mainPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        add(mainPanel);

        //Player ID label
        if (plugin.currentLocalAccountHash == 0 || plugin.currentLocalAccountHash == -1){
            playerIDLabel = new JLabel("Player ID: unknown");
        }
        else{
            playerIDLabel = new JLabel("Player ID: " + plugin.currentLocalAccountHash);
        }
        playerIDLabel.setHorizontalAlignment(SwingConstants.CENTER);
        mainPanel.add(playerIDLabel);

        // Total Memory Usage estimate label
        int estimatedMemoryUsage = 0;
        for (HeatmapNew heatmap : plugin.heatmaps.values()) {
            estimatedMemoryUsage += heatmap.estimateSize();
        }
		if (estimatedMemoryUsage == 0) {
			totalMemoryUsageLabel = new JLabel("Estimated Memory Usage: 0MB");
		}
		else {
			totalMemoryUsageLabel = new JLabel("Estimated Memory Usage: " + String.format("%.2f", estimatedMemoryUsage / 1024. / 1024) +  "MB");
		}
        totalMemoryUsageLabel.setHorizontalAlignment(SwingConstants.CENTER);
        mainPanel.add(totalMemoryUsageLabel);

        //'Open Heatmaps Folder' button
        JButton openHeatmapFolderButton = getOpenHeatmapFolderButton(buttonFont);
        mainPanel.add(openHeatmapFolderButton);

        //'Visit Global Heatmap Website' button
        JButton visitGlobalHeatmapButton = getGlobalHeatmapButton(buttonFont);
        mainPanel.add(visitGlobalHeatmapButton);

        // Create the panels/buttons for each loaded Heatmap type
        for (HeatmapNew.HeatmapType heatmapType : HeatmapNew.HeatmapType.values()) {
            // Do not create panels for disabled heatmaps
            if (!plugin.isHeatmapEnabled(heatmapType)) {
                continue;
            }
            //Panel
            JPanel heatmapPanel = new JPanel(new GridLayout(0, 1, hGap, vGap));
            heatmapPanel.setBorder(new EmptyBorder(vGap, hGap, vGap, hGap));
            heatmapPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            heatmapPanels.put(heatmapType, heatmapPanel);

            //Label
            JLabel heatmapLabel = new JLabel(heatmapType.toString());
            heatmapPanelLabels.put(heatmapType, heatmapLabel);
            heatmapLabel.setFont(sectionLabelFont);
            heatmapLabel.setForeground(Color.WHITE);
            heatmapLabel.setHorizontalAlignment(SwingConstants.CENTER);
            if (plugin.heatmaps.get(heatmapType) != null){
                heatmapLabel.setToolTipText("Estimated memory usage: " + String.format("%.2f", plugin.heatmaps.get(heatmapType).estimateSize() / 1024. / 1024) + "MB");
            }
            else {
                heatmapLabel.setToolTipText("Estimated memory usage: 0MB");
            }

            heatmapPanel.add(heatmapLabel);

            //'Write Heatmap Image' button
            JButton writeHeatmapImageButton = new JButton("Write Heatmap Image");
            writeHeatmapImageButton.setFont(buttonFont);
            writeHeatmapImageButton.addActionListener(e -> writeHeatmapImage(heatmapType, plugin.config.isWriteFullImageEnabled()));
            writeHeatmapImageButtons.put(heatmapType, writeHeatmapImageButton);
            heatmapPanel.add(writeHeatmapImageButton);

            //'Restart Heatmap' button
            JButton clearHeatmapButton = getClearHeatmapButton(heatmapType, buttonFont, heatmapPanel);
            clearHeatmapButtons.put(heatmapType, clearHeatmapButton);
            heatmapPanel.add(clearHeatmapButton);

            // Total value and Tile count labels panel
			JPanel labelsPanel = new JPanel(new GridLayout(1, 2, hGap, vGap));
			labelsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

			// Total value label
			String totalToolTipText = "Total value of all tiles in the heatmap";
			JLabel heatmapTotalValueLabel = new JLabel("Total: 0");
			heatmapTotalValueLabel.setHorizontalAlignment(SwingConstants.CENTER);
			heatmapTotalValueLabel.setToolTipText("Total value of all tiles in the heatmap");
			heatmapTotalValueLabels.put(heatmapType, heatmapTotalValueLabel);
			labelsPanel.add(heatmapTotalValueLabel);

			// Tile count label
			String countToolTipText = "Count of tiles in the heatmap";
			JLabel heatmapTileCountLabel = new JLabel("Count: 0");
			heatmapTileCountLabel.setHorizontalAlignment(SwingConstants.CENTER);
			heatmapTileCountLabel.setToolTipText(countToolTipText);
			heatmapTileCountLabels.put(heatmapType, heatmapTileCountLabel);
			labelsPanel.add(heatmapTileCountLabel);

			heatmapPanel.add(labelsPanel);

            add(heatmapPanel);
        }
    }

    private JButton getClearHeatmapButton(HeatmapNew.HeatmapType heatmapType, Font buttonFont, JPanel heatmapPanel) {
        JButton clearHeatmapButton = new JButton("Restart Heatmap");
        clearHeatmapButton.setFont(buttonFont);
        clearHeatmapButton.addActionListener(e -> {
            final int result = JOptionPane.showOptionDialog(heatmapPanel,
                    "<html>Art thou sure you want to restart your " + heatmapType + " heatmap? The data will be lost.</html>",
                    "Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                    null, new String[]{"Yes", "No"}, "No");

            if (result == JOptionPane.YES_OPTION) {
                clearHeatmap(heatmapType);
            }
        });
        return clearHeatmapButton;
    }

    private JButton getOpenHeatmapFolderButton(Font buttonFont) {
        JButton openHeatmapFolderButton = new JButton("Open Heatmaps Folder");
        openHeatmapFolderButton.setFont(buttonFont);
        openHeatmapFolderButton.addActionListener(e -> {
            try {
                openHeatmapsFolder();
            } catch (IOException exception) {
                log.error("Error: Exception thrown whilst opening worldheatmap folder: {}", exception.getMessage());
            }
        });
        return openHeatmapFolderButton;
    }

    /**
     * Get the button to visit the global heatmap website at osrsworldheatmap.com
     * @param buttonFont
     * @return
     */
    private static JButton getGlobalHeatmapButton(Font buttonFont) {
        JButton visitGlobalHeatmapButton = new JButton("Global Heatmap Website");
        visitGlobalHeatmapButton.setFont(buttonFont);
        visitGlobalHeatmapButton.addActionListener(e -> {
            try {
                // Try Desktop.browse first (might not work on Linux)
                String url = "https://www.osrsworldheatmap.com";
                if (Desktop.isDesktopSupported()) {
                    Desktop desktop = Desktop.getDesktop();
                    if (desktop.isSupported(Desktop.Action.BROWSE)) {
                        desktop.browse(new URI(url));
                        return;
                    }
                }
                boolean isLinux = System.getProperty("os.name").toLowerCase().contains("linux");
                if (isLinux) {
                    // Fallback to Runtime.exec or ProcessBuilder
                    String[] browsers = {"xdg-open", "firefox", "google-chrome"};
                    for (String browser : browsers) {
                        try {
                            new ProcessBuilder(browser, url).start();
                            return; // Stop if we successfully open the URL
                        } catch (IOException ignored) {
                        }
                    }
                }
                log.error("Unable to open browser, please visit {} manually", url);
            } catch (Exception exception) {
                log.error("Error: Exception thrown whilst opening browser: {}", exception.getMessage());
            }
        });
        return visitGlobalHeatmapButton;
    }

    protected void updatePlayerID() {
        this.plugin.currentLocalAccountHash = plugin.currentLocalAccountHash;
        if (this.plugin.currentLocalAccountHash == -1 || this.plugin.currentLocalAccountHash == 0) {
            playerIDLabel = new JLabel("Player ID: unavailable");
        } else {
            playerIDLabel.setText("Player ID: " + this.plugin.currentLocalAccountHash);
        }
        updateUI();
    }

    protected void updateCounts() {
        for (HeatmapNew.HeatmapType heatmapType : plugin.heatmaps.keySet()) {
            if (heatmapTotalValueLabels.get(heatmapType) != null) {
                heatmapTotalValueLabels.get(heatmapType).setText("Total: " + plugin.heatmaps.get(heatmapType).getTotalValue());
            }
			if (heatmapTileCountLabels.get(heatmapType) != null) {
				heatmapTileCountLabels.get(heatmapType).setText("Count: " + plugin.heatmaps.get(heatmapType).getTileCount());
			}
        }
        updateUI();
    }

	/**
	 * Update the memory usage label and the tooltip of each heatmap panel label
	 */
    protected void updateMemoryUsageLabels() {
		// Only update the memory usage label every minute
		// because it is a relatively expensive operation
		if (System.currentTimeMillis() - timeOfLastMemoryEstimate < 60_000 || timeOfLastMemoryEstimate == -1) {
			timeOfLastMemoryEstimate = System.currentTimeMillis();
			int totalEstimatedMemoryUsage = 0;
			for (HeatmapNew heatmap : plugin.heatmaps.values()) {
				int estimatedMemoryUsage = heatmap.estimateSize();
				memoryUsageEstimates.put(heatmap.getHeatmapType(), estimatedMemoryUsage);
				totalEstimatedMemoryUsage += estimatedMemoryUsage;
			}
			totalMemoryUsageLabel.setText("Estimated Memory Usage: " + String.format("%.2f", totalEstimatedMemoryUsage / 1024. / 1024) +  "MB");
		}

		// Update the tooltips of the heatmap panel labels
		for (Map.Entry<HeatmapNew.HeatmapType, JLabel> entry : heatmapPanelLabels.entrySet()) {
			JLabel label = entry.getValue();
			HeatmapNew.HeatmapType heatmapType = entry.getKey();
			HeatmapNew heatmap = plugin.heatmaps.get(heatmapType);
			if (label == null || heatmapType == null) {
				continue;
			}
			if (heatmap == null) {
				label.setToolTipText("Estimated memory usage: 0MB (heatmap not loaded)");
			}
			else {
				int gameTimeSeconds = (int)(heatmap.getGameTimeTicks() * 0.6);
				String gameTimeFormatted = String.format("%02d:%02d:%02d", gameTimeSeconds / 3600, (gameTimeSeconds % 3600) / 60, gameTimeSeconds % 60);
				label.setToolTipText("Estimated memory usage: " + String.format("%.2f", memoryUsageEstimates.get(heatmapType) / 1024. / 1024) + "MB"
					+ "\n"
					+ "Heatmap age: " + gameTimeFormatted);
			}
		}

        updateUI();
    }

    private void writeHeatmapImage(HeatmapNew.HeatmapType heatmapType, boolean isFullMapImage) {
		HeatmapNew heatmap = plugin.heatmaps.get(heatmapType);
        // Save all heatmap data
        plugin.executor.execute(plugin::saveHeatmapsFile);
        // Write the specified heatmap image
		File imageFile = HeatmapFileManager.getNewImageFile(plugin.currentLocalAccountHash, heatmapType, heatmap.getSeasonalType());
        plugin.executor.execute(() -> HeatmapImage.writeHeatmapImage(heatmap, imageFile, isFullMapImage, plugin.config.isBlueMapEnabled(), plugin.config.heatmapAlpha(), plugin.config.heatmapSensitivity(), plugin.config.speedMemoryTradeoff(), new WorldHeatmapPlugin.HeatmapProgressListener(plugin, heatmapType)));
    }

    private void clearHeatmap(HeatmapNew.HeatmapType heatmapType) {
		log.info("Clearing heatmap: {}", heatmapType);

		// Update the latest heatmap data file
		plugin.executor.execute(plugin::saveHeatmapsFile);

        // Replace the heatmap with a new one
		plugin.executor.execute(() -> {
			plugin.heatmaps.put(heatmapType, new HeatmapNew(heatmapType, plugin.currentLocalAccountHash, plugin.currentPlayerAccountType, plugin.currentSeasonalType, plugin.currentPlayerCombatLevel));
		});

        // Start a new .heatmaps data file, so the pre-clearing data is not lost
		plugin.executor.execute(plugin::saveNewHeatmapsFile);
    }

    private void openHeatmapsFolder() throws IOException {
        if (!plugin.WORLD_HEATMAP_DIR.exists()) {
            if (!plugin.WORLD_HEATMAP_DIR.mkdirs()) {
                log.error("Error: was not able to create worldheatmap folder");
            }
        }
        Desktop.getDesktop().open(plugin.WORLD_HEATMAP_DIR);
    }

    void setEnabledHeatmapButtons(boolean onOff) {
        // Disable write heatmap image buttons
        for (JButton writeButton : writeHeatmapImageButtons.values()) {
            writeButton.setEnabled(onOff);
        }
        // Disable clear heatmap buttons
        for (JButton clearButton : clearHeatmapButtons.values()) {
            clearButton.setEnabled(onOff);
        }
    }

}

package com.worldheatmap;

import com.google.inject.Provides;

import java.awt.*;
import java.io.*;
import java.time.Instant;
import java.util.*;
import java.util.List;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import javax.imageio.ImageWriter;
import javax.imageio.event.IIOWriteProgressListener;
import javax.inject.Inject;
import javax.swing.*;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.ItemStack;
import net.runelite.client.game.WorldService;
import net.runelite.client.hiscore.HiscoreManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.api.Varbits;
import net.runelite.http.api.worlds.World;

import java.awt.image.BufferedImage;
import java.util.concurrent.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import net.runelite.client.game.ItemManager;

import static net.runelite.client.RuneLite.RUNELITE_DIR;
import net.runelite.http.api.worlds.WorldResult;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

@Slf4j
@PluginDescriptor(
        name = "World Heatmap"
)
public class WorldHeatmapPlugin extends Plugin {
    private int lastX = 0;
    private int lastY = 0;
	private int lastZ = 0;
	protected GameState previousGameState, previousPreviousGameState = GameState.UNKNOWN;
    protected long currentLocalAccountHash;
	protected String currentSeasonalType;
    protected int currentPlayerAccountType;
    protected int currentPlayerCombatLevel;
    protected final File WORLD_HEATMAP_DIR = new File(RUNELITE_DIR.toString(), "worldheatmap");
    protected Map<HeatmapNew.HeatmapType, HeatmapNew> heatmaps = new HashMap<>();
    private NavigationButton toolbarButton;
    protected WorldHeatmapPanel panel;
    private final ArrayList<Integer> randomEventNPCIDs = new ArrayList<>(Arrays.asList(NpcID.BEE_KEEPER_6747,
            NpcID.CAPT_ARNAV,
            NpcID.DRUNKEN_DWARF,
            NpcID.FLIPPA_6744,
            NpcID.GILES,
            NpcID.GILES_5441,
            NpcID.MILES,
            NpcID.MILES_5440,
            NpcID.NILES,
            NpcID.NILES_5439,
            NpcID.PILLORY_GUARD,
            NpcID.POSTIE_PETE_6738,
            NpcID.RICK_TURPENTINE,
            NpcID.RICK_TURPENTINE_376,
            NpcID.SERGEANT_DAMIEN_6743,
            NpcID.FREAKY_FORESTER_6748,
            NpcID.FROG_5429,
            NpcID.GENIE,
            NpcID.GENIE_327,
            NpcID.DR_JEKYLL,
            NpcID.DR_JEKYLL_314,
            NpcID.EVIL_BOB,
            NpcID.EVIL_BOB_6754,
            NpcID.LEO_6746,
            NpcID.MYSTERIOUS_OLD_MAN_6751,
            NpcID.MYSTERIOUS_OLD_MAN_6750,
            NpcID.MYSTERIOUS_OLD_MAN_6752,
            NpcID.MYSTERIOUS_OLD_MAN_6753,
            NpcID.QUIZ_MASTER_6755,
            NpcID.DUNCE_6749,
            NpcID.SANDWICH_LADY,
            NpcID.STRANGE_PLANT));
    Map<Integer, Instant> timeLastSeenBobTheCatPerWorld = new HashMap<>();
    @Inject
    ItemManager itemManager;
    private int[] previousXP = new int[Skill.values().length];
    protected String currentPlayerName;
	private CompletableFuture<Void> loading = new CompletableFuture<>();
	private boolean isLoading;
	private HeatmapFileManager heatmapFileManager;

	@Inject
    private Client client;

    @Inject
    protected ScheduledExecutorService executor;

    @Inject
    WorldHeatmapConfig config;

	@Inject
	OkHttpClient okHttpClient;

    @Inject
    private ClientToolbar clientToolbar;

	@Inject
	private WorldService worldService;

	@Inject
	protected ClientThread clientThread;

	@Inject
	protected ConfigManager configManager;

	@Inject
	protected ChatMessageManager chatMessageManager;

	@Inject
	protected HiscoreManager hiscoreManager;

	@Provides
    WorldHeatmapConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(WorldHeatmapConfig.class);
    }

	protected void loadHeatmaps() {
		isLoading = true;
		// Make sure player metadata is loaded and up to date
		assert currentLocalAccountHash != 0 && currentLocalAccountHash != -1;
		assert currentPlayerName != null && !currentPlayerName.isBlank();
		assert currentPlayerCombatLevel >= 3;
		assert currentPlayerAccountType >= 0 && currentPlayerAccountType <= 10;
		assert currentSeasonalType != null;

		// First, perform any necessary fixes to the heatmaps
		heatmapFileManager.fixHeatmapsFiles(currentLocalAccountHash, currentPlayerName);

        log.info("Loading most recent {}heatmaps under user ID {}...", currentSeasonalType.isBlank() ? "" : currentSeasonalType + " ", currentLocalAccountHash);
        File latestHeatmapsFile = heatmapFileManager.getLatestFile(currentLocalAccountHash, currentSeasonalType);

        // Load all heatmaps from the file
        if (latestHeatmapsFile != null && latestHeatmapsFile.exists()) {
			try {
				heatmaps = heatmapFileManager.readHeatmapsFromFile(latestHeatmapsFile, getEnabledHeatmapTypes());
			}
			catch (FileNotFoundException e) {
				throw new RuntimeException(e);
			}
			for (HeatmapNew heatmap : heatmaps.values()){
				// Set metadata for each heatmap in case they were wrong or missing
                heatmap.setUserID(currentLocalAccountHash);
                heatmap.setAccountType(currentPlayerAccountType);
                heatmap.setCurrentCombatLevel(currentPlayerCombatLevel);
				heatmap.setSeasonalType(currentSeasonalType);
            }
        }

        initializeMissingHeatmaps(heatmaps);
        panel.setEnabledHeatmapButtons(true);
		// Initialize previousXP values
		for (Skill skill : Skill.values()) {
			previousXP[skill.ordinal()] = client.getSkillExperience(skill);
		}
		panel.setEnabledHeatmapButtons(true);
		loading.complete(null);
		isLoading = false;
    }

    @Override
    protected void startUp() {
        panel = new WorldHeatmapPanel(this);
        panel.rebuild();
		heatmapFileManager = new HeatmapFileManager(this, hiscoreManager, okHttpClient, worldService);
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/WorldHeatmap.png");
        toolbarButton = NavigationButton.builder()
                .tooltip("World Heatmap")
                .icon(icon)
                .priority(5)
                .panel(panel)
                .build();
        clientToolbar.addNavigation(toolbarButton);
        panel.setEnabledHeatmapButtons(false);
		clientThread.invoke(this::displayUpdateMessage);

		if (client.getGameState() == GameState.LOGGED_IN) {
			loading = new CompletableFuture<>();
		}
    }

	/**
	 * Displays a message to the user about the latest update.
	 * Only displays the message once per update.
	 */
	private void displayUpdateMessage() {
		String noticeKey = "shownNoticeV1.6.0";
		if (configManager.getConfiguration("worldheatmap", noticeKey) == null) {
			// Send a message in game chat
			final String message = new ChatMessageBuilder()
				.img(11863)
				.append(Color.decode("#00a12b"), "World Heatmap has been updated to 1.6.0! We would love your help in crowdsourcing data for " +
					"the global heatmap by opting-in in the config. Also, if you've played Leagues V, please log into " +
					"a Leagues V world again before it ends, if possible, in order for an automatic fix to occur.")
				.build();
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(message)
				.build());
			configManager.setConfiguration("worldheatmap", noticeKey, "shown");
		}
	}

    @Override
    protected void shutDown() {
        if (heatmaps != null && !heatmaps.isEmpty()) {
			panel.setEnabledHeatmapButtons(false);
			executor.execute(this::saveHeatmapsFile);
			executor.execute(() -> heatmaps = new HashMap<>());
        }
        clientToolbar.removeNavigation(toolbarButton);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
		GameState gameState = gameStateChanged.getGameState();

		boolean justLoggedIn = gameState == GameState.LOGGED_IN &&
			previousGameState == GameState.LOADING &&
			previousPreviousGameState == GameState.LOGGING_IN;
		boolean justHopped = gameState == GameState.LOGGED_IN &&
			previousGameState == GameState.LOADING &&
			previousPreviousGameState == GameState.HOPPING;

		// This is when to load the heatmaps
		if (justLoggedIn || justHopped) {
			// Schedule the loading of the heatmap files
			loading = new CompletableFuture<>();
		}

		// This is when to save & unload the heatmaps
		boolean heatmapsLoaded = heatmaps != null && !heatmaps.isEmpty();
        if (heatmapsLoaded &&
			gameState == GameState.HOPPING ||
			gameState == GameState.LOGIN_SCREEN) {
			panel.setEnabledHeatmapButtons(false);
			executor.execute(this::saveHeatmapsFile);
			executor.execute(this::reinitializeVariables);
			executor.execute(() -> heatmaps = new HashMap<>());
		}

		previousPreviousGameState = previousGameState;
		previousGameState = gameState;
    }

	private void reinitializeVariables()
	{
		lastX = 0;
		lastY = 0;
		previousXP = new int[Skill.values().length];
		timeLastSeenBobTheCatPerWorld = new HashMap<>();
		loading = new CompletableFuture<>();
	}

	@Subscribe
	public void onAccountHashChanged(AccountHashChanged event) {
		currentLocalAccountHash = client.getAccountHash();
		SwingUtilities.invokeLater(panel::updatePlayerID);
	}

	@Subscribe
	public void onWorldChanged(WorldChanged event) {
		updateSeasonalType();
	}

	public void updateSeasonalType() {
		String seasonalType;
		boolean isSeasonal = client.getWorldType().contains(WorldType.SEASONAL) ||
			client.getWorldType().contains(WorldType.BETA_WORLD) ||
			client.getWorldType().contains(WorldType.TOURNAMENT_WORLD);
		if (isSeasonal) {
			WorldResult worlds = worldService.getWorlds();
			assert worlds != null;
			World world = worlds.findWorld(client.getWorld());
			assert world != null;
			String worldActivity = world.getActivity();
			if (worldActivity != null && !worldActivity.isBlank()) {
				seasonalType = worldActivity.split(" - ")[0].replaceAll("\\s", "_").toUpperCase();
			}
			else {
				seasonalType = "UNKNOWN_SEASONAL";
			}
		}
		else {
			seasonalType = "";
		}
		currentSeasonalType = seasonalType;
		loading.complete(null);
	}

	@Subscribe
	public void onPlayerChanged(PlayerChanged event) {
		if (event.getPlayer() == client.getLocalPlayer() && client.getLocalPlayer() != null) {
			updatePlayerMetadata();
		}
	}

	public void updatePlayerMetadata() {
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null) {
			return;
		}
		currentPlayerName = localPlayer.getName();
		currentPlayerCombatLevel = localPlayer.getCombatLevel();
		currentPlayerAccountType = client.getVarbitValue(Varbits.ACCOUNT_TYPE);
	}

    @Subscribe
    public void onGameTick(GameTick gameTick) {
		// Start loading them heatmaps if not already
		if (!loading.isDone() && !isLoading) {
			currentLocalAccountHash = client.getAccountHash();
			SwingUtilities.invokeLater(panel::updatePlayerID);
			updatePlayerMetadata();
			updateSeasonalType();
			executor.execute(this::loadHeatmaps);
		}
		// The following code requires the heatmap files to have been loaded
		if (!loading.isDone() || heatmaps == null || heatmaps.isEmpty()) {
			return;
		}

        // Increment game time ticks of each heatmap
        for (HeatmapNew.HeatmapType type : heatmaps.keySet()) {
            heatmaps.get(type).incrementGameTimeTicks();
        }

        WorldPoint currentCoords = client.getLocalPlayer().getWorldLocation();
        int currentX = currentCoords.getX();
        int currentY = currentCoords.getY();
		int currentZ = currentCoords.getPlane();
        boolean playerMovedSinceLastTick = (currentX != lastX || currentY != lastY || currentZ != lastZ);

        /* When running, players cover more than one tile per tick, which creates spotty paths.
         * We fix this by drawing a line between the current coordinates and the previous coordinates,
         * but we have to be sure that the player indeed ran from point A to point B, differentiating the movement from teleportation.
         * Since it's too hard to check if the player is actually running, we'll just check if the distance covered since last tick
         * was less than 4 tiles
         */
        int diagDistance = diagonalDistance(new Point(lastX, lastY), new Point(currentX, currentY));
        if (diagDistance <= 3 && currentZ == lastZ) {
            // Gets all the tiles between last position and new position
            for (Point tile : getPointsBetween(new Point(lastX, lastY), new Point(currentX, currentY))) {
                // TYPE_A
                if (playerMovedSinceLastTick && config.isHeatmapTypeAEnabled() && heatmaps.get(HeatmapNew.HeatmapType.TYPE_A) != null) {
                    heatmaps.get(HeatmapNew.HeatmapType.TYPE_A).increment(tile.getX(), tile.getY(), currentZ);
                }

                // TYPE_B
                if (config.isHeatmapTypeBEnabled() && heatmaps.get(HeatmapNew.HeatmapType.TYPE_B) != null) {
                    heatmaps.get(HeatmapNew.HeatmapType.TYPE_B).increment(tile.getX(), tile.getY(), currentZ);
                }
            }
        }

        // TELEPORT_PATHS
        if (config.isHeatmapTeleportPathsEnabled() &&
			heatmaps.get(HeatmapNew.HeatmapType.TELEPORT_PATHS) != null &&
			diagDistance > 15 &&
			isInOverworld(new Point(lastX, lastY)) &&
			isInOverworld(new Point(currentX, currentY)) && //we don't draw lines between the overworld and caves etc.
			currentZ == lastZ)
        {
            if (config.isHeatmapTeleportPathsEnabled()) {
                for (Point tile : getPointsBetween(new Point(lastX, lastY), new Point(currentX, currentY))) {
                    heatmaps.get(HeatmapNew.HeatmapType.TELEPORT_PATHS).increment(tile.getX(), tile.getY(), currentZ);
                }
            }
        }

        // TELEPORTED_TO and TELEPORTED_FROM
		// We do count teleports between different planes for these, since in the overworld, the planes are (x, y)
		// aligned, and unlike TELEPORT_PATHS, we wouldn't have to draw a line between planes
        if (diagDistance > 15 &&
			isInOverworld(new Point(lastX, lastY)) &&
			isInOverworld(new Point(currentX, currentY))) //we only track teleports between overworld tiles
        {
            if (config.isHeatmapTeleportedToEnabled() && heatmaps.get(HeatmapNew.HeatmapType.TELEPORTED_TO) != null) {
                heatmaps.get(HeatmapNew.HeatmapType.TELEPORTED_TO).increment(currentX, currentY, currentZ);
            }
            if (config.isHeatmapTeleportedFromEnabled() && heatmaps.get(HeatmapNew.HeatmapType.TELEPORTED_FROM) != null) {
                heatmaps.get(HeatmapNew.HeatmapType.TELEPORTED_FROM).increment(lastX, lastY, lastZ);
            }
        }

        // Routines
		executor.execute(this::backupRoutine);
		executor.execute(this::autosaveRoutine);
		executor.execute(this::uploadHeatmapRoutine);

        // Update panel step counter
        SwingUtilities.invokeLater(panel::updateCounts);

        // Update memory usage + heatmap age tooltips
		SwingUtilities.invokeLater(panel::updateMemoryUsageLabels);

        // Update last coords
        lastX = currentX;
        lastY = currentY;
		lastZ = currentZ;
    }

    @Subscribe
    public void onActorDeath(ActorDeath actorDeath) {
        if (actorDeath.getActor() instanceof Player) {
            Player deadPlayer = (Player) actorDeath.getActor();
            if (deadPlayer.getId() == client.getLocalPlayer().getId()) {
                // DEATHS
                if (config.isHeatmapDeathsEnabled()) {
					WorldPoint loc = deadPlayer.getWorldLocation();
                    heatmaps.get(HeatmapNew.HeatmapType.DEATHS).increment(loc.getX(), loc.getY(), loc.getPlane());
                }
            }
        } else if (actorDeath.getActor() instanceof NPC) {
			NPC deadNPC = (NPC) actorDeath.getActor();
            if (heatmaps.get(HeatmapNew.HeatmapType.NPC_DEATHS) != null && config.isHeatmapNPCDeathsEnabled()) {
                // NPC_DEATHS
				WorldPoint loc = deadNPC.getWorldLocation();
                heatmaps.get(HeatmapNew.HeatmapType.NPC_DEATHS).increment(loc.getX(), loc.getY(), loc.getPlane());
            }
        }
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied hitsplatApplied) {
        if (hitsplatApplied.getHitsplat().getAmount() == 0) {
            return;
        }
        // DAMAGE_GIVEN
        if (hitsplatApplied.getHitsplat().getHitsplatType() == net.runelite.api.HitsplatID.DAMAGE_ME && hitsplatApplied.getActor() instanceof NPC) {
            NPC actor = (NPC) hitsplatApplied.getActor();
            if (config.isHeatmapDamageGivenEnabled()) {
				WorldPoint loc = actor.getWorldLocation();
                heatmaps.get(HeatmapNew.HeatmapType.DAMAGE_GIVEN).increment(loc.getX(), loc.getY(), loc.getPlane(), hitsplatApplied.getHitsplat().getAmount());
            }
        }

        // DAMAGE_TAKEN
        if (hitsplatApplied.getHitsplat().getHitsplatType() == HitsplatID.DAMAGE_ME && hitsplatApplied.getActor() instanceof Player) {
            Player actor = (Player) hitsplatApplied.getActor();
            if (actor.getId() == client.getLocalPlayer().getId()) {
                if (config.isHeatmapDamageTakenEnabled()) {
					WorldPoint loc = actor.getWorldLocation();
                    heatmaps.get(HeatmapNew.HeatmapType.DAMAGE_TAKEN).increment(loc.getX(), loc.getY(), loc.getPlane(), hitsplatApplied.getHitsplat().getAmount());
                }
            }
        }
    }

    @Subscribe
    public void onChatMessage(ChatMessage chatMessage) {
        if (client.getLocalPlayer() == null || client.getLocalPlayer().getName() == null) {
            return;
        }
        if (chatMessage.getType() == ChatMessageType.PUBLICCHAT) {
            // PLACES_SPOKEN_AT
            if (config.isHeatmapPlacesSpokenAtEnabled() && heatmaps.get(HeatmapNew.HeatmapType.PLACES_SPOKEN_AT) != null) {
				WorldPoint loc = client.getLocalPlayer().getWorldLocation();
                heatmaps.get(HeatmapNew.HeatmapType.PLACES_SPOKEN_AT).increment(loc.getX(), loc.getY(), loc.getPlane());
            }
        }
    }

    @Subscribe
    public void onStatChanged(StatChanged statChanged) {
        // NOTE: this happens 23 times when you log in, and at such time, the heatmaps haven't been loaded in, so you can't call .get() on them
        // Get difference between previous and current XP
        int skillIndex = statChanged.getSkill().ordinal();
        int xpDifference = client.getSkillExperience(statChanged.getSkill()) - previousXP[skillIndex];

        // Update previous XP
        previousXP[skillIndex] = client.getSkillExperience(statChanged.getSkill());

        // XP_GAINED
        if (config.isHeatmapXPGainedEnabled() && heatmaps.get(HeatmapNew.HeatmapType.XP_GAINED) != null) {
			WorldPoint loc = client.getLocalPlayer().getWorldLocation();
            heatmaps.get(HeatmapNew.HeatmapType.XP_GAINED).increment(loc.getX(), loc.getY(), loc.getPlane(), xpDifference);
        }
    }

    @Subscribe
    public void onNpcSpawned(final NpcSpawned npcSpawned) {
        // Currently it counts all random event spawns, not just random events meant for the local player
        if (randomEventNPCIDs.contains(npcSpawned.getNpc().getId())) {
            // RANDOM_EVENT_SPAWNS
            if (config.isHeatmapRandomEventSpawnsEnabled() && heatmaps.get(HeatmapNew.HeatmapType.RANDOM_EVENT_SPAWNS) != null) {
				WorldPoint loc = npcSpawned.getNpc().getWorldLocation();
                heatmaps.get(HeatmapNew.HeatmapType.RANDOM_EVENT_SPAWNS).increment(loc.getX(), loc.getY(), loc.getPlane());
            }
        }

        // BOB_THE_CAT_SIGHTING
        if (config.isHeatmapBobTheCatSightingEnabled() && npcSpawned.getNpc().getId() == NpcID.BOB_8034) {
            // Only count Bob the Cat sightings once per hour per world
            if (timeLastSeenBobTheCatPerWorld.get(client.getWorld()) == null || Instant.now().isAfter(timeLastSeenBobTheCatPerWorld.get(client.getWorld()).plusSeconds(3600))) {
                if (heatmaps.get(HeatmapNew.HeatmapType.BOB_THE_CAT_SIGHTING) != null) {
					WorldPoint loc = npcSpawned.getNpc().getWorldLocation();
                    heatmaps.get(HeatmapNew.HeatmapType.BOB_THE_CAT_SIGHTING).increment(loc.getX(), loc.getY(), loc.getPlane());
                    timeLastSeenBobTheCatPerWorld.put(client.getWorld(), Instant.now());
                }
            }
        }
    }

    @Subscribe
    public void onNpcLootReceived(final NpcLootReceived npcLootReceived) {
        // LOOT_VALUE
        if (config.isHeatmapLootValueEnabled()) {
            for (ItemStack itemStack : npcLootReceived.getItems()) {
                WorldPoint location = npcLootReceived.getNpc().getWorldLocation();
                int x = location.getX();
                int y = location.getY();
				int z = location.getPlane();

                int totalValue = itemStack.getQuantity() * itemManager.getItemPrice(itemStack.getId());
                if (heatmaps.get(HeatmapNew.HeatmapType.LOOT_VALUE) != null) {
                    heatmaps.get(HeatmapNew.HeatmapType.LOOT_VALUE).increment(x, y, z, totalValue);
                }
            }
        }
    }

    /**
     * Autosave the heatmap file and/or write the 'TYPE_A' and 'TYPE_B' heatmap images if it is the correct time to so
     */
    private void autosaveRoutine() {
        // Determine if autosave should happen
		final int AUTOSAVE_FREQUENCY = 3000; // Autosave every 30 minutes of game time
        if (heatmaps.keySet().isEmpty()) {
            return;
        }
        int highestGameTimeTicks = 0;
        for (HeatmapNew.HeatmapType type : heatmaps.keySet()) {
            if (heatmaps.get(type).getGameTimeTicks() > highestGameTimeTicks) {
                highestGameTimeTicks = heatmaps.get(type).getGameTimeTicks();
            }
        }
        boolean shouldWriteImages = config.typeABImageAutosave() &&
			highestGameTimeTicks % config.typeABImageAutosaveFrequency() == 0 &&
			highestGameTimeTicks != 0;
		boolean shouldAutosaveFiles = highestGameTimeTicks % AUTOSAVE_FREQUENCY == 0 && highestGameTimeTicks != 0;

        // Autosave the heatmap file if it is the correct time to do so, or if image is about to be written
        if (shouldAutosaveFiles || shouldWriteImages) {
			executor.execute(this::saveHeatmapsFile);
        }

        // Autosave the 'TYPE_A' and 'TYPE_B' heatmap images if it is the correct time to do so
        if (shouldWriteImages) {
            File typeAImageFile = heatmapFileManager.getNewImageFile(currentLocalAccountHash, HeatmapNew.HeatmapType.TYPE_A, currentSeasonalType);
            File typeBImageFile = heatmapFileManager.getNewImageFile(currentLocalAccountHash, HeatmapNew.HeatmapType.TYPE_B, currentSeasonalType);

            // Write the image files
            if (config.isHeatmapTypeAEnabled()) {
                executor.execute(() -> HeatmapImage.writeHeatmapImage(heatmaps.get(HeatmapNew.HeatmapType.TYPE_A), typeAImageFile, false, config.isBlueMapEnabled(), config.heatmapAlpha(), config.heatmapSensitivity(), config.speedMemoryTradeoff(), new HeatmapProgressListener(this, HeatmapNew.HeatmapType.TYPE_A)));
            }
            if (config.isHeatmapTypeBEnabled()) {
                executor.execute(() -> HeatmapImage.writeHeatmapImage(heatmaps.get(HeatmapNew.HeatmapType.TYPE_B), typeBImageFile, false, config.isBlueMapEnabled(), config.heatmapAlpha(), config.heatmapSensitivity(), config.speedMemoryTradeoff(), new HeatmapProgressListener(this, HeatmapNew.HeatmapType.TYPE_B)));
            }
        }
    }

    /**
     * Backs up the heatmap file if it is the correct time to do so according to the backup frequency
     */
    private void backupRoutine() {
        // Determine if a backup should be made
        if (heatmaps.keySet().isEmpty()){
            return;
        }
        int highestGameTimeTicks = 0;
        for (HeatmapNew.HeatmapType type : heatmaps.keySet()) {
            if (heatmaps.get(type).getGameTimeTicks() > highestGameTimeTicks) {
                highestGameTimeTicks = heatmaps.get(type).getGameTimeTicks();
            }
        }

        // Make new backup
        if (highestGameTimeTicks % config.heatmapBackupFrequency() == 0 && highestGameTimeTicks != 0) {
            executor.execute(this::saveNewHeatmapsFile);
        }
    }

    /**
     * Updates the most recent heatmap file with the latest data, renaming it after the current date and time.
	 * If a most recent file does not exist, it will create a new file.
     */
    protected void saveHeatmapsFile() {
		if (getEnabledHeatmaps() == null || getEnabledHeatmaps().isEmpty()) {
			return;
		}

		String seasonalType = getEnabledHeatmaps().iterator().next().getSeasonalType();
		long localAccountHash = getEnabledHeatmaps().iterator().next().getUserID();
		File latestFile = heatmapFileManager.getLatestFile(localAccountHash, seasonalType);

		// If there is no latest file, create a new file
		if (latestFile == null || !latestFile.exists()) {
			saveNewHeatmapsFile();
			return;
		}

		heatmapFileManager.writeHeatmapsToFile(getEnabledHeatmaps(), latestFile);

		// Rename the latest file to be the current date and time, unless dated into the future
		File newFile = heatmapFileManager.getCurrentFile(localAccountHash, seasonalType);
		if (!latestFile.renameTo(newFile)) {
			log.error("Failed to rename latest heatmap file {} to {}", latestFile.getName(), newFile.getName());
		}
    }

    /**
     * Saves the heatmaps to a new dated file, carrying over disabled/unprovided heatmaps from the most recently dated heatmaps file
     */
    protected void saveNewHeatmapsFile() {
		String seasonalType = getEnabledHeatmaps().iterator().next().getSeasonalType();
		long localAccountHash = getEnabledHeatmaps().iterator().next().getUserID();

        // Write heatmaps to new file, carrying over disabled/unprovided heatmaps from previous heatmaps file
        File latestFile = heatmapFileManager.getLatestFile(localAccountHash, seasonalType);
        File newFile = heatmapFileManager.getNewFile(localAccountHash, seasonalType);
        heatmapFileManager.writeHeatmapsToFile(getEnabledHeatmaps(), newFile, latestFile);
    }

    // Credit to https:// www.redblobgames.com/grids/line-drawing.html for where I figured out how to make the following linear interpolation functions

    /**
     * Returns the list of discrete coordinates on the path between p0 and p1, as an array of Points
     *
     * @param p0 Point A
     * @param p1 Point B
     * @return Array of coordinates
     */
    private Point[] getPointsBetween(Point p0, Point p1) {
        if (p0.equals(p1)) {
            return new Point[]{p1};
        }
        int N = diagonalDistance(p0, p1);
        Point[] points = new Point[N];
        for (int step = 1; step <= N; step++) {
            float t = step / (float) N;
            points[step - 1] = roundPoint(lerp_point(p0, p1, t));
        }
        return points;
    }

    /**
     * Returns the "diagonal distance" (the maximum of the horizontal and vertical distance) between two points
     *
     * @param p0 Point A
     * @param p1 Point B
     * @return The diagonal distance
     */
    private int diagonalDistance(Point p0, Point p1) {
        int dx = Math.abs(p1.getX() - p0.getX());
        int dy = Math.abs(p1.getY() - p0.getY());
        return Math.max(dx, dy);
    }

    /**
     * Rounds a floating point coordinate to its nearest integer coordinate.
     *
     * @param point The point to round
     * @return Coordinates
     */
    private Point roundPoint(float[] point) {
        return new Point(Math.round(point[0]), Math.round(point[1]));
    }

    /**
     * Returns the floating point 2D coordinate that is t-percent of the way between p0 and p1
     *
     * @param p0 Point A
     * @param p1 Point B
     * @param t  Percent distance
     * @return Coordinate that is t% of the way from A to B
     */
    private float[] lerp_point(Point p0, Point p1, float t) {
        return new float[]{lerp(p0.getX(), p1.getX(), t), lerp(p0.getY(), p1.getY(), t)};
    }

    /**
     * Returns the floating point number that is t-percent of the way between p0 and p1.
     *
     * @param p0 Point A
     * @param p1 Point B
     * @param t  Percent distance
     * @return Point that is t-percent of the way from A to B
     */
    private float lerp(int p0, int p1, float t) {
        return p0 + (p1 - p0) * t;
    }

    public boolean isInOverworld(Point point) {
        return point.getY() < Constants.OVERWORLD_MAX_Y && point.getY() > 2500 && point.getX() >= 1024 && point.getX() < 3960;
    }

    /**
     * Initializes any enabled Heatmap types in the given Map of Heatmaps that weren't loaded
     *
     * @param heatmaps HashMap of HeatmapNew objects
     */
    public void initializeMissingHeatmaps(Map<HeatmapNew.HeatmapType, HeatmapNew> heatmaps) {
        // Get the heatmaps that are enabled but were not loaded
        ArrayList<HeatmapNew.HeatmapType> missingTypes = new ArrayList<>();
        for (HeatmapNew.HeatmapType type : HeatmapNew.HeatmapType.values()) {
            if (isHeatmapEnabled(type) && (!heatmaps.containsKey(type) || heatmaps.get(type) == null)) {
                missingTypes.add(type);
            }
        }
        if (missingTypes.isEmpty())
            return;

        List<String> missingTypesNames = new ArrayList<>();
        for (HeatmapNew.HeatmapType type : missingTypes) {
            missingTypesNames.add(type.toString());
        }
        log.info("Initializing missing heatmaps: {}", String.join(", ", missingTypesNames));
        for (HeatmapNew.HeatmapType type : missingTypes) {
            heatmaps.put(type, new HeatmapNew(type, currentLocalAccountHash, currentPlayerAccountType, currentSeasonalType, currentPlayerCombatLevel));
        }
    }

    Collection<HeatmapNew> getEnabledHeatmaps() {
        return heatmaps.values().stream().filter(heatmap -> isHeatmapEnabled(heatmap.getHeatmapType())).collect(Collectors.toList());
    }

    Collection<HeatmapNew.HeatmapType> getEnabledHeatmapTypes() {
        List<HeatmapNew.HeatmapType> enabledTypes = new ArrayList<>();
        for (HeatmapNew.HeatmapType type : HeatmapNew.HeatmapType.values()) {
            if (isHeatmapEnabled(type)) {
                enabledTypes.add(type);
            }
        }
        return enabledTypes;
    }

    boolean isHeatmapEnabled(HeatmapNew.HeatmapType type) {
        Map<HeatmapNew.HeatmapType, Supplier> heatmapTypeSupplierMap = new HashMap<>();
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.TYPE_A, config::isHeatmapTypeAEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.TYPE_B, config::isHeatmapTypeBEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.XP_GAINED, config::isHeatmapXPGainedEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.TELEPORT_PATHS, config::isHeatmapTeleportPathsEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.TELEPORTED_TO, config::isHeatmapTeleportedToEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.TELEPORTED_FROM, config::isHeatmapTeleportedFromEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.LOOT_VALUE, config::isHeatmapLootValueEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.PLACES_SPOKEN_AT, config::isHeatmapPlacesSpokenAtEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.RANDOM_EVENT_SPAWNS, config::isHeatmapRandomEventSpawnsEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.DEATHS, config::isHeatmapDeathsEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.NPC_DEATHS, config::isHeatmapNPCDeathsEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.BOB_THE_CAT_SIGHTING, config::isHeatmapBobTheCatSightingEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.DAMAGE_TAKEN, config::isHeatmapDamageTakenEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.DAMAGE_GIVEN, config::isHeatmapDamageGivenEnabled);
        return (boolean) heatmapTypeSupplierMap.getOrDefault(type, () -> false).get();
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals("worldheatmap") || event.getNewValue() == null) {
            return;
        }
        Map<String, HeatmapNew.HeatmapType> configNameToHeatmapType = new HashMap<>();
        configNameToHeatmapType.put("isHeatmapTypeAEnabled", HeatmapNew.HeatmapType.TYPE_A);
        configNameToHeatmapType.put("isHeatmapTypeBEnabled", HeatmapNew.HeatmapType.TYPE_B);
        configNameToHeatmapType.put("isHeatmapXPGainedEnabled", HeatmapNew.HeatmapType.XP_GAINED);
        configNameToHeatmapType.put("isHeatmapTeleportPathsEnabled", HeatmapNew.HeatmapType.TELEPORT_PATHS);
        configNameToHeatmapType.put("isHeatmapTeleportedToEnabled", HeatmapNew.HeatmapType.TELEPORTED_TO);
        configNameToHeatmapType.put("isHeatmapTeleportedFromEnabled", HeatmapNew.HeatmapType.TELEPORTED_FROM);
        configNameToHeatmapType.put("isHeatmapLootValueEnabled", HeatmapNew.HeatmapType.LOOT_VALUE);
        configNameToHeatmapType.put("isHeatmapPlacesSpokenAtEnabled", HeatmapNew.HeatmapType.PLACES_SPOKEN_AT);
        configNameToHeatmapType.put("isHeatmapRandomEventSpawnsEnabled", HeatmapNew.HeatmapType.RANDOM_EVENT_SPAWNS);
        configNameToHeatmapType.put("isHeatmapDeathsEnabled", HeatmapNew.HeatmapType.DEATHS);
        configNameToHeatmapType.put("isHeatmapNPCDeathsEnabled", HeatmapNew.HeatmapType.NPC_DEATHS);
        configNameToHeatmapType.put("isHeatmapBobTheCatSightingEnabled", HeatmapNew.HeatmapType.BOB_THE_CAT_SIGHTING);
        configNameToHeatmapType.put("isHeatmapDamageTakenEnabled", HeatmapNew.HeatmapType.DAMAGE_TAKEN);
        configNameToHeatmapType.put("isHeatmapDamageGivenEnabled", HeatmapNew.HeatmapType.DAMAGE_GIVEN);

        HeatmapNew.HeatmapType toggledHeatmapType = configNameToHeatmapType.get(event.getKey());
        if (toggledHeatmapType != null) {
            boolean isEnabled = event.getNewValue().equals("true");
            executor.execute(() -> handleHeatmapToggled(isEnabled, toggledHeatmapType));
        }
    }

    /**
     * Saves heatmap to file when enabled, and reads heatmap from file when enabled.
     * @param isHeatmapEnabled Whether the heatmap is enabled
     * @param heatmapType The type of heatmap
     */
    private void handleHeatmapToggled(boolean isHeatmapEnabled, HeatmapNew.HeatmapType heatmapType){
        if (isHeatmapEnabled) {
            log.debug("Enabling {} heatmap...", heatmapType);
            HeatmapNew heatmap = null;
            // Load the heatmap from the file if it exists
			File heatmapsFile = heatmapFileManager.getLatestFile(currentLocalAccountHash, currentSeasonalType);
            if (heatmapsFile != null && heatmapsFile.exists()) {
                try {
                    heatmap = heatmapFileManager.readHeatmapsFromFile(heatmapsFile, Collections.singletonList(heatmapType)).get(heatmapType);
                    heatmap.setUserID(currentLocalAccountHash);
                    heatmap.setAccountType(currentPlayerAccountType);
                    heatmap.setCurrentCombatLevel(currentPlayerCombatLevel);
					heatmap.setSeasonalType(currentSeasonalType);
                } catch (FileNotFoundException e) {
                    throw new RuntimeException(e);
                }
            }
            if (heatmap != null) {
                heatmaps.put(heatmapType, heatmap);
            }
        } else {
            log.debug("Disabling {} heatmap...", heatmapType);
            saveHeatmapsFile();
            heatmaps.remove(heatmapType);
        }

        panel.rebuild();
    }

    private void uploadHeatmapRoutine() {
        int uploadFrequency = 36_000; // Every 6 hours of game time

        if (!config.isUploadEnabled()){
            return;
        }

		// Determine if it is time to upload the heatmaps
		int highestGameTimeTicks = 0;
        for (HeatmapNew.HeatmapType type : heatmaps.keySet()) {
            if (isHeatmapEnabled(type)) {
                // Check if it's time to upload each heatmap based on the upload frequencies
				int gameTimeTicks = heatmaps.get(type).getGameTimeTicks();
                highestGameTimeTicks = Math.max(highestGameTimeTicks, gameTimeTicks);
            }
        }
		boolean shouldUpload = highestGameTimeTicks % uploadFrequency == 0 && highestGameTimeTicks != 0;

        // Upload the heatmaps
        if (shouldUpload && uploadHeatmaps()){
            log.info("Heatmaps uploaded successfully");
        }
    }

	/**
	 * Serializes heatmap as CSV, zips it, and then uploads it to HEATMAP_SITE_API_ENDPOINT using OkHttpClient.
	 * @return
	 */
	private boolean uploadHeatmaps() {
		if (heatmaps.isEmpty()) {
			return false;
		}

		String HEATMAP_SITE_API_ENDPOINT = "https://osrsworldheatmap.com/api/upload-csv/";
		try {
			// Zip the CSV
			ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
			try (ZipOutputStream zipOutputStream = new ZipOutputStream(byteArrayOutputStream)) {
				for (HeatmapNew heatmap : heatmaps.values()) {
					ZipEntry zipEntry = new ZipEntry(heatmap.getHeatmapType() + "_HEATMAP.csv");
					zipOutputStream.putNextEntry(zipEntry);
					OutputStreamWriter osw = new OutputStreamWriter(zipOutputStream);
					heatmap.toCSV(osw);
					osw.flush();
					zipOutputStream.closeEntry();
				}
			}

			// Prepare the request body
			RequestBody requestBody = RequestBody.create(
				MediaType.parse("application/zip"),
				byteArrayOutputStream.toByteArray()
			);

			// Build the request
			Request request = new Request.Builder()
				.url(HEATMAP_SITE_API_ENDPOINT)
				.post(requestBody)
				.build();

			// Execute the request
			try (Response response = okHttpClient.newCall(request).execute()) {
				if (response.isSuccessful()) {
					return true;
				} else {
					log.error("Failed to upload heatmaps: HTTP {} {}", response.code(), response.message());
				}
			}
		} catch (IOException e) {
			log.error("Error uploading heatmap to " + HEATMAP_SITE_API_ENDPOINT, e);
		}

		log.error("Failed to upload heatmaps");
		return false;
	}


	static class HeatmapProgressListener implements IIOWriteProgressListener {
        private final WorldHeatmapPlugin worldHeatmapPlugin;
        Color originalColor;
        HeatmapNew.HeatmapType heatmapType;

        WorldHeatmapPanel panel;

        public HeatmapProgressListener(WorldHeatmapPlugin worldHeatmapPlugin, HeatmapNew.HeatmapType heatmapType) {
            super();
            this.worldHeatmapPlugin = worldHeatmapPlugin;
            this.heatmapType = heatmapType;
            this.panel = worldHeatmapPlugin.panel;
            if (panel.writeHeatmapImageButtons.get(heatmapType) != null) {
                originalColor = panel.writeHeatmapImageButtons.get(heatmapType).getForeground();
            }
        }

        @Override
        public void imageStarted(ImageWriter source, int imageIndex) {
            panel.setEnabledHeatmapButtons(false);
            panel.writeHeatmapImageButtons.get(heatmapType).setText("Writing... 0%");
        }

        @Override
        public void imageProgress(ImageWriter source, float percentageDone) {
            panel.writeHeatmapImageButtons.get(heatmapType).setText(String.format("Writing... %.2f%%", percentageDone));
        }

        @Override
        public void imageComplete(ImageWriter source) {
            panel.setEnabledHeatmapButtons(true); // Had to do this early so that the color change would be visible
            panel.writeHeatmapImageButtons.get(heatmapType).setForeground(Color.GREEN);
            panel.writeHeatmapImageButtons.get(heatmapType).setText("Done");
            worldHeatmapPlugin.executor.schedule(() -> {
                SwingUtilities.invokeLater(() -> {
                    panel.writeHeatmapImageButtons.get(heatmapType).setText("Write Heatmap Image");
                    panel.writeHeatmapImageButtons.get(heatmapType).setForeground(originalColor);
                });
            }, 2L, TimeUnit.SECONDS);
        }

        @Override
        public void thumbnailStarted(ImageWriter source, int imageIndex, int thumbnailIndex) {
        }

        @Override
        public void thumbnailProgress(ImageWriter source, float percentageDone) {
        }

        @Override
        public void thumbnailComplete(ImageWriter source) {
        }

        @Override
        public void writeAborted(ImageWriter source) {
            panel.setEnabledHeatmapButtons(true); // Had to do this early so that the color change would be visible
            panel.writeHeatmapImageButtons.get(heatmapType).setForeground(Color.RED);
            panel.writeHeatmapImageButtons.get(heatmapType).setText("Error");
            worldHeatmapPlugin.executor.schedule(() -> {
                SwingUtilities.invokeLater(() -> {
                    panel.writeHeatmapImageButtons.get(heatmapType).setText("Write Heatmap Image");
                    panel.writeHeatmapImageButtons.get(heatmapType).setForeground(originalColor);
                });
            }, 2L, TimeUnit.SECONDS);
        }
    }
}

package com.worldheatmap;

import net.runelite.client.config.*;

@ConfigGroup(WorldHeatmapConfig.GROUP)
public interface WorldHeatmapConfig extends Config {
    String GROUP = "worldheatmap";

    @ConfigSection(
            name = "Main Settings",
            description = "Settings for main plugin functionality",
            position = 0
    )
    String settings = "settings";

    @ConfigItem(
            keyName = "isUploadEnabled",
            name = "Contribute to the global heatmap",
            position = 0,
            description = "Enable automatic uploading of anonymized heatmap data to contribute to the global heatmap at osrsworldheatmap.com.",
            section = settings,
			warning = "This will upload your anonymized data to the global heatmap at https://osrsworldheatmap.com, a 3rd party website not controlled or verified by the RuneLite Developers. Individual heatmap data is only displayed in aggregate with all global data, and no personally identifying metadata is stored."
    )
    default boolean isUploadEnabled() {
        return false;
    }

    @Range(
            min = 100
    )
    @ConfigItem(
            keyName = "ImageAutosaveFrequency",
            name = "Type A&B image autosave frequency",
            position = 1,
            description = "Determines how often (in number of steps) to automatically save both the 'Type A' and 'Type B' world heatmap TIF images. Default value of 36000 ticks (6 hours)",
            section = settings
    )
    default int typeABImageAutosaveFrequency() {
        return 36000;
    }

    @ConfigItem(
            keyName = "ImageAutosave",
            name = "Type A&B image autosave",
            position = 2,
            description = "Determines whether to automatically save both the 'Type A' and 'Type B' world heatmap TIF images.",
            section = settings
    )
    default boolean typeABImageAutosave() {
        return false;
    }

    @Range(
            min = 100
    )
    @ConfigItem(
            keyName = "HeatmapBackupFrequency",
            name = "Data backup frequency",
            position = 3,
            description = "Determines how often (in ticks of game time) to make a new backup of the heatmap data, in the Heatmap 'Results/Backups' folder (don't set this field too low or there will be too many backups piling up). Default value 36000 ticks (6 hours). Minimum value 100.",
            section = settings
    )
    default int heatmapBackupFrequency() {
        return 36000;
    }

    @Range(
            min = 0,
            max = 1
    )
    @ConfigItem(
            keyName = "HeatmapAlpha",
            name = "Heatmap colour alpha",
            position = 4,
            description = "The opacity of the heatmap colours drawn over the world map image",
            section = settings
    )
    default double heatmapAlpha() {
        return 1.0;
    }

    @Range(
            min = 1,
            max = 6
    )
    @ConfigItem(
            keyName = "heatmapSensitivity",
            name = "Heatmap curve sensitivity",
            position = 5,
            description = "Increasing this makes the heatmap's colour gradient more sensitive to step counts.",
            section = settings
    )
    default int heatmapSensitivity() {
        return 4;
    }

    @Range(
            max = 8
    )
    @ConfigItem(
            keyName = "speedMemoryTradeoff",
            name = "Speed-memory tradeoff",
            position = 6,
            description = "Corresponds to the vertical size of chunks used in writing the heatmap image. Higher values = faster image writing, but increases memory usage. Try lowering this value if the plugin is crashing whilst writing images.",
            section = settings
    )
    default int speedMemoryTradeoff() {
        return 4;
    }

    @ConfigItem(
            keyName = "writeFullMapImage",
            name = "Write full world map image (SLOW)",
            position = 7,
            description = "Warning: This takes much longer than writing just the overworld image. If checked, this will write the full world map image (including underground/non-overworld areas). Does not apply to image autosaves.",
            section = settings
    )
    default boolean isWriteFullImageEnabled() {
        return false;
    }

	@ConfigItem(
			keyName = "isBlueMapEnabled",
			name = "Blue map",
			position = 8,
			description = "If enabled, the world map will be coloured blue instead of grayscale.",
			section = settings
	)
	default boolean isBlueMapEnabled() {
		return true;
	}

    @ConfigSection(
            name = "Per-Heatmap On/Off",
            description = "Enabling/disabling individual heatmaps",
            position = 1
    )
    String heatmapsOnOff = "heatmapsOnOff";

    @ConfigItem(
            keyName = "isHeatmapTypeAEnabled",
            name = "TYPE_A",
            position = 0,
            description = "Increments a tile each time you walk over it",
            section = heatmapsOnOff
    )
    default boolean isHeatmapTypeAEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapTypeBEnabled",
            name = "TYPE_B",
            position = 1,
            description = "Increments a tile each tick you stand on it",
            section = heatmapsOnOff
    )
    default boolean isHeatmapTypeBEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapXPGainedEnabled",
            name = "XP_GAINED",
            position = 2,
            description = "Records the total number of XP gained in each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapXPGainedEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapTeleportPathsEnabled",
            name = "TELEPORT_PATHS",
            position = 3,
            description = "Records the paths taken when teleporting",
            section = heatmapsOnOff
    )
    default boolean isHeatmapTeleportPathsEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapTeleportedToEnabled",
            name = "TELEPORTED_TO",
            position = 4,
            description = "Records the locations teleported to",
            section = heatmapsOnOff
    )
    default boolean isHeatmapTeleportedToEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapTeleportedFromEnabled",
            name = "TELEPORTED_FROM",
            position = 5,
            description = "Records the locations teleported from",
            section = heatmapsOnOff
    )
    default boolean isHeatmapTeleportedFromEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapLootValueEnabled",
            name = "LOOT_VALUE",
            position = 6,
            description = "Records the total value of loot spawned on each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapLootValueEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapPlacesSpokenAtEnabled",
            name = "PLACES_SPOKEN_AT",
            position = 7,
            description = "Records the number of times you've spoken in public chat at each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapPlacesSpokenAtEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapRandomEventSpawnsEnabled",
            name = "RANDOM_EVENT_SPAWNS",
            position = 8,
            description = "Records the number of witnessed random event spawns on each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapRandomEventSpawnsEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapDeathsEnabled",
            name = "DEATHS",
            position = 9,
            description = "Records the number of times you've died on each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapDeathsEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapNPCDeathsEnabled",
            name = "NPC_DEATHS",
            position = 10,
            description = "Records the number of NPC deaths you've witnesssed on each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapNPCDeathsEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapBobTheCatSightingEnabled",
            name = "BOB_THE_CAT_SIGHTING",
            position = 11,
            description = "Records the tiles on which you've found Bob the Cat (this is regular bob, not evil bob)",
            section = heatmapsOnOff
    )
    default boolean isHeatmapBobTheCatSightingEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapDamageTakenEnabled",
            name = "DAMAGE_TAKEN",
            position = 12,
            description = "Records the total you've damage taken on each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapDamageTakenEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapDamageGivenEnabled",
            name = "DAMAGE_GIVEN",
            position = 13,
            description = "Records the total damage you've dealt whilst standing on each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapDamageGivenEnabled() {
        return true;
    }

}

package com.worldheatmap;

import java.io.*;
import java.util.*;
import java.util.Map.Entry;
import java.util.zip.InflaterInputStream;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;

@Slf4j
public class HeatmapNew
{
	@Getter
	private final HashMap<WorldPoint, Integer> heatmapHashMap;
	@Getter
	private final static int heatmapVersion = 102;
	@Getter @Setter
	private transient int versionReadFrom = -1;
	@Getter
	private long totalValue = 0;
	@Getter
	private int tileCount = 0;
	@Getter @Setter
	private int gameTimeTicks = 0;
	private static final int
		HEATMAP_WIDTH = 2752,       //never change these
		HEATMAP_HEIGHT = 1664,      //never change these
		HEATMAP_OFFSET_X = -1152,   //never change these
		HEATMAP_OFFSET_Y = -2496;   //never change these (for backwards compatibility)

	public static HeatmapNew fromCSV(HeatmapType curType, BufferedReader reader) throws IOException
	{
		// Read them field variables
		String[] fieldNames = reader.readLine().split(",", -1);
		String[] fieldValues = reader.readLine().split(",", -1);
		Map<String, String> fieldMap = new HashMap<>();
		for (int i = 0; i < fieldNames.length; i++) {
			fieldMap.put(fieldNames[i], fieldValues[i]);
		}
		long userID = Long.parseLong(fieldMap.getOrDefault("userID", "-1"));
		int heatmapVersion = Integer.parseInt(fieldMap.getOrDefault("heatmapVersion", "-1"));
		String allegedHeatmapType = fieldMap.get("heatmapType");
		int gameTimeTicks = Integer.parseInt(fieldMap.getOrDefault("gameTimeTicks", "-1"));
		// The following fields exist only in version 101 and later
		int accountType = Integer.parseInt(fieldMap.getOrDefault("accountType", "-1"));;
		int currentCombatLevel = Integer.parseInt(fieldMap.getOrDefault("currentCombatLevel", "-1"));
		// The following fields exist only in version 102 and later
		String seasonalType = fieldMap.getOrDefault("seasonalType", null);

		// Get HeatmapType from field value if legit
		HeatmapNew.HeatmapType heatmapType;
		try {
			heatmapType = HeatmapNew.HeatmapType.valueOf(allegedHeatmapType);
		}
		catch (IllegalArgumentException e) {
			log.debug("Heatmap type '{}' is not a valid Heatmap type (at least in this program version). Ignoring...", allegedHeatmapType);
			throw new IOException("Invalid Heatmap type");
		}

		// Make ze Heatmap and set metadata
		HeatmapNew heatmap = new HeatmapNew();
		heatmap.setUserID(userID);
		heatmap.setVersionReadFrom(heatmapVersion);
		heatmap.setHeatmapType(heatmapType);
		heatmap.setGameTimeTicks(gameTimeTicks);
		heatmap.setAccountType(accountType);
		heatmap.setCurrentCombatLevel(currentCombatLevel);
		heatmap.setSeasonalType(seasonalType);

		// Read and load the tile values
		final int[] errorCount = {0}; // Number of parsing errors occurred during read
		reader.lines().forEach(s -> {
			String[] tile = s.split(",");
			try {
				if (tile.length == 3) {
					// x, y, val (pre-V1.6.1)
					heatmap.set(Integer.parseInt(tile[0]), Integer.parseInt(tile[1]), 0, Integer.parseInt(tile[2]));
				}
				else if (tile.length == 4) {
					// x, y, z, val
					heatmap.set(Integer.parseInt(tile[0]), Integer.parseInt(tile[1]), Integer.parseInt(tile[2]), Integer.parseInt(tile[3]));
				}
				else {
					log.error("Invalid line in heatmap file: {}", s);
					errorCount[0]++;
				}
			} catch (NumberFormatException e) {
				errorCount[0]++;
			}
		});
		if (errorCount[0] != 0) {
			log.error("{} errors occurred during {} heatmap file read.", errorCount[0], heatmapType);
		}

		return heatmap;
	}

	public enum HeatmapType
	{TYPE_A, TYPE_B, XP_GAINED, TELEPORT_PATHS, TELEPORTED_TO, TELEPORTED_FROM, LOOT_VALUE, PLACES_SPOKEN_AT, RANDOM_EVENT_SPAWNS, DEATHS, NPC_DEATHS, BOB_THE_CAT_SIGHTING, DAMAGE_TAKEN, DAMAGE_GIVEN, UNKNOWN}
	@Getter @Setter
	private long userID = -1;
	@Getter @Setter
	private int accountType = -1;
	@Getter @Setter
	private HeatmapType heatmapType;
	@Getter @Setter
	private int currentCombatLevel = -1;
	@Getter @Setter
	private String seasonalType;

	/**
	 * Constructor for HeatmapNew object with no arguments.
	 */
	public HeatmapNew()
	{
		this.heatmapType = HeatmapType.UNKNOWN;
		this.heatmapHashMap = new HashMap<>();
	}

	/**
	 * Constructor for HeatmapNew object with userID and accountType.
	 * @param heatmapType
	 * @param userID
	 * @param accountType
	 */
	public HeatmapNew(HeatmapType heatmapType, long userID, int accountType, String seasonalType, int currentCombatLevel)
	{
		this.heatmapType = heatmapType;
		this.heatmapHashMap = new HashMap<>();
		this.userID = userID;
		this.accountType = accountType;
		this.seasonalType = seasonalType;
		this.currentCombatLevel = currentCombatLevel;
	}

	/**
	 * Converter for backwards compatibility with the old, retarded method of storing heatmap data
	 * @param oldStyle
	 * @return
	 */
	public static HeatmapNew convertOldHeatmapToNew(Heatmap oldStyle)
	{
		HeatmapNew newStyle = new HeatmapNew();
		for (int x = 0; x < HEATMAP_WIDTH; x++)
		{
			for (int y = 0; y < HEATMAP_HEIGHT; y++)
			{
				if (oldStyle.heatmapCoordsGet(x, y) != 0)
				{
					newStyle.set(x - HEATMAP_OFFSET_X, y - HEATMAP_OFFSET_Y, 0, oldStyle.heatmapCoordsGet(x, y));
				}
			}
		}
		return newStyle;
	}

	/**
	 * Loads, converts, and returns .heatmap file of legacy style as a HeatmapNew.
	 * If the file isn't actually a legacy .heatmap file, throws an exception.
	 * @param heatmapFile The .heatmap file
	 * @return HeatmapNew object
	 */
	static HeatmapNew readLegacyV1HeatmapFile(File heatmapFile) {
		try (FileInputStream fis = new FileInputStream(heatmapFile);
			 InflaterInputStream iis = new InflaterInputStream(fis);
			 ObjectInputStream ois = new ObjectInputStream(iis)) {
			Heatmap heatmap = (Heatmap) ois.readObject();
			HeatmapNew result = convertOldHeatmapToNew(heatmap);
			return result;
		} catch (Exception e) {
			log.error("Exception occurred while reading legacy heatmap file '{}'", heatmapFile.getName());
			throw new RuntimeException(e);
		}
	}

	protected Set<Entry<WorldPoint, Integer>> getEntrySet()
	{
		return heatmapHashMap.entrySet();
	}

	public void incrementGameTimeTicks()
	{
		this.gameTimeTicks++;
	}

	/**
	 * Increments the heatmap's value at the given location by the amount specified
	 *
	 * @param x      Original RuneScape x-coord
	 * @param y      Original RuneScape y-coord
	 * @param amount Amount to increment the value by
	 */
	protected void increment(int x, int y, int z, int amount)
	{
		set(x, y, z, get(x, y, z) + amount);
	}

	/**
	 * Increments the heatmap's value at the given location by 1
	 *
	 * @param x Original RuneScape x-coord
	 * @param y Original RuneScape y-coord
	 */
	protected void increment(int x, int y, int z)
	{
		set(x, y, z, get(x, y, z) + 1);
	}

	/**
	 * Sets the heatmap's value at the given location to the given value. If the value is 0, the tile is removed from the heatmap. If the value is negative, nothing happens.
	 *
	 * @param newValue New value
	 * @param x        Original RuneScape x-coord
	 * @param y        Original RuneScape y-coord
	 */
	protected void set(int x, int y, int z, int newValue)
	{
		// We don't keep track of negative values
		if (newValue < 0)
		{
			return;
		}

		//Set it & retrieve previous value
		Integer oldValue = heatmapHashMap.put(new WorldPoint(x, y, z), newValue);

		//Update numTilesVisited
		if (oldValue == null && newValue > 0)
		{
			tileCount++;
		}
		else if (oldValue != null && newValue == 0)
		{
			tileCount--;
		}

		//Update total value
		if (oldValue == null)
		{
			totalValue += newValue;
		}
		else
		{
			totalValue += (newValue - oldValue);
		}

		// For not keeping track of unstepped-on tiles
		if (newValue == 0)
		{
			heatmapHashMap.remove(new WorldPoint(x, y, z));
		}
	}

	/**
	 * Returns the estimated total memory usage of the heatmap, in bytes, assuming 64 bit JVM and 8-byte alignment. Relatively expensive to run because it has to iterate through the entire hashmap.
	 * @return size in bytes
	 */
	public int estimateSize(){
		int estSize = 0;
		// Get count of values above and below 128
		for (Entry<WorldPoint, Integer> e : getEntrySet())
		{
			int nodeSize = 16 + 8 + 8 + 4 + 4; //16 bytes for Node  object, 8 and 8 for the key and value references, 4 for the hash value, then extra 4 for 8-byte alignment
			int pointSize = 16 + 4 + 4 + 4; //16 bytes for WorldPoint object header, then 4 for each of the three int coords
			int integerSize = (e.getValue() < 128 ? 8 : 16 + 4 + 4); //8 bytes for just header of pooled Integer, or 12 bytes for non-pooled Integer header plus inner int plus 4 bytes for 8-byte alignment
			estSize += nodeSize + pointSize + integerSize;
		}
		return estSize;
	}

	/**
	 * Returns the heatmap's value at the given game world location. If the tile has not been stepped on, returns 0.
	 *
	 * @param x Heatmap-style x-coord
	 * @param y Heatmap-style y-coord
	 */
	protected int get(int x, int y, int z)
	{
		return heatmapHashMap.getOrDefault(new WorldPoint(x, y, z), 0);
	}

	/**
	 * Serializes the provided heatmap data to the specified OutputStream in CSV format.
	 */
	protected void toCSV(OutputStreamWriter bos) throws IOException
	{
		// Write them field variables
		bos.write("userID,heatmapVersion,heatmapType,gameTimeTicks,accountType,currentCombatLevel,seasonalType\n");
		bos.write(this.getUserID() +
			"," + getHeatmapVersion() +
			"," + this.getHeatmapType() +
			"," + this.getGameTimeTicks() +
			"," + this.getAccountType() +
			"," + this.getCurrentCombatLevel() +
			"," + this.getSeasonalType() + "\n");

		// Write the tile values
		for (Entry<WorldPoint, Integer> e : this.getEntrySet()) {
			int x = e.getKey().getX();
			int y = e.getKey().getY();
			int z = e.getKey().getPlane();
			int stepVal = e.getValue();
			bos.write(x + "," + y + "," + z + "," + stepVal + "\n");
		}
	}

}
package com.worldheatmap;

import java.io.Serializable;

public class Heatmap implements Serializable {

    private final int WIDTH, HEIGHT, HEATMAP_OFFSET_X, HEATMAP_OFFSET_Y;
    protected final static int TYPE_A = 0, TYPE_B = 1;
    private int[][] heatmap;
    private int stepCount;

    public Heatmap(int WIDTH, int HEIGHT, int HEATMAP_OFFSET_X, int HEATMAP_OFFSET_Y){
        this.WIDTH = WIDTH;
        this.HEIGHT = HEIGHT;
        this.HEATMAP_OFFSET_Y = HEATMAP_OFFSET_Y;
        this.HEATMAP_OFFSET_X = HEATMAP_OFFSET_X;
        stepCount = 0;
        createHeatmap();
    }

    private void createHeatmap(){
        heatmap = new int[WIDTH][HEIGHT];
    }

    protected boolean isInBounds(int x, int y){
        return (x + HEATMAP_OFFSET_X < WIDTH && y + HEATMAP_OFFSET_Y < HEIGHT);
    }

    /**
     * Sets the heatmap's value at the given location to the given value
     * @param val New value
     * @param x Original RuneScape x-coord
     * @param y Original RuneScape y-coord
     */
    protected void set(int val, int x, int y){
        int convertedX = x + HEATMAP_OFFSET_X;	//These offsets are to reconcile the matrix 'heatmap' being much smaller than the game coordinate domain (which is much larger than the explorable area)
        int convertedY = y + HEATMAP_OFFSET_Y;
        heatmap[convertedX][convertedY] = val;
    }

    /**
     * Returns the heatmap's value at the given location
     * @param x Original RuneScape x-coord
     * @param y Original RuneScape y-coord
     */
    protected int get(int x, int y){
        int convertedX = x + HEATMAP_OFFSET_X;	//These offsets are to reconcile the matrix 'heatmap' being much smaller than the game coordinate domain (which is much larger than the explorable area)
        int convertedY = y + HEATMAP_OFFSET_Y;
        return heatmap[convertedX][convertedY];
    }

    /**
     * Returns the heatmap's value at the given location according to the internal coordinate style (it's offset from the RuneScape coordinates)
     * @param x Heatmap-style x-coord
     * @param y Heatmap-style y-coord
     */
    protected int heatmapCoordsGet(int x, int y){
        return heatmap[x][y];
    }

    /**
     * Increments the heatmap's value at the given location by 1
     * @param x Original RuneScape x-coord
     * @param y Original RuneScape y-coord
     */
    protected void increment(int x, int y) {
        set(get(x, y) + 1, x, y);
        stepCount++;
    }

    protected int getStepCount(){
        return stepCount;
    }

    /**
     * @return int array holding {maxVal, maxX, maxY} where the latter two are the coordinate at which the max value exists
     */
    protected int[] getMaxVal(){
        int maxVal = 0, maxX = 0, maxY = 0;
        for (int y = 0; y < HEIGHT; y++)
            for (int x = 0; x < WIDTH; x++)
                if (heatmapCoordsGet(x, y) > maxVal) {
                    maxVal = heatmapCoordsGet(x, y);
                    maxX = x;
                    maxY = y;
                }
        return new int[]{maxVal, maxX, maxY};
    }

    /**
     * @return int array holding {minVal, minX, minY} where the latter two are the coordinate at which the minimum NON-ZERO value exists
     */
    protected int[] getMinVal(){
        int minVal = Integer.MAX_VALUE, minX = 0, minY = 0;
        for (int y = 0; y < HEIGHT; y++)
            for (int x = 0; x < WIDTH; x++)
                if (heatmapCoordsGet(x, y) != 0 && heatmapCoordsGet(x, y) < minVal) {
                    minVal = heatmapCoordsGet(x, y);
                    minX = x;
                    minY = y;
                }
        if (minVal > Integer.MAX_VALUE - 100)
            return new int[]{0, 0, 0};
        else
            return new int[]{minVal, minX, minY};
    }
}

package com.worldheatmap;

import java.awt.Color;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Transparency;
import java.awt.color.ColorSpace;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.ComponentColorModel;
import java.awt.image.ComponentSampleModel;
import java.awt.image.DataBuffer;
import java.awt.image.Raster;
import java.awt.image.RenderedImage;
import java.awt.image.SampleModel;
import java.awt.image.WritableRaster;
import java.io.*;
import java.net.URL;
import java.util.*;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import javax.imageio.*;
import javax.imageio.event.IIOWriteProgressListener;
import javax.imageio.stream.ImageInputStream;
import javax.imageio.stream.ImageOutputStream;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;

/**
 * Class which calculates osrs heatmap image data on demand
 */
@Slf4j
public class HeatmapImage implements RenderedImage
{
	private final ImageReader worldMapImageReader;
	private final ColorModel colorModel = new ComponentColorModel(ColorSpace.getInstance(ColorSpace.CS_sRGB), false, false, Transparency.OPAQUE, DataBuffer.TYPE_BYTE);

	// A queue that holds the heatmap coordinates along
	// with their values, to be sorted by coordinate left-to-right top-to-bottom
	private static LinkedList<Map.Entry<Point, Integer>> sortedHeatmapTiles;
	private final float heatmapTransparency;
	private final int heatmapSensitivity;
	private final int numXTiles = 1;
	private final int numYTiles;
	private int heatmapMinVal;
	private int heatmapMaxVal;
	int PIXEL_OFFSET_X;
	int PIXEL_OFFSET_Y;

	/**
	 * @param worldMapImageReader osrs_world_map.png
	 * @param numYTiles           Image width must be evenly divisible by numYTiles
	 */
	public HeatmapImage(HeatmapNew heatmap, ImageReader worldMapImageReader, int numYTiles, float transparency, int sensitivity, int pixelOffsetX, int pixelOffsetY)
	{
		this.worldMapImageReader = worldMapImageReader;
		this.numYTiles = numYTiles;
		this.heatmapTransparency = transparency;
		this.heatmapSensitivity = sensitivity;
		this.PIXEL_OFFSET_X = pixelOffsetX;
		this.PIXEL_OFFSET_Y = pixelOffsetY;
		initializeProcessingVariables(heatmap);
		try
		{
			if (worldMapImageReader.getHeight(0) % numYTiles != 0)
			{
                log.debug("WARNING: Image height {} is not evenly divisible by the number of Y tiles, {}.", worldMapImageReader.getHeight(0), numYTiles);
			}
		}
		catch (IOException e)
		{
			throw new RuntimeException(e);
		}
	}

	/**
	 * Calculates the tile height based on the config setting
	 *
	 * @param configSetting The config setting
	 * @return The tile height
	 */
	static int calculateTileHeight(int configSetting, boolean isFullMap) {
		// NOTE: these should be adjusted if the world map image's size is ever changed
		// They should evenly divide the image height or else the image will be cut off
		// Also I think they have to be multiples of 16 or something for the TIF format?
		// I forgor. it seems to be working fine though
		if (isFullMap){
			return new int[]{32, 64, 89, 178, 356, 712, 1424, 2848, 5696}[configSetting];
		}
		else{
			return new int[]{32, 64, 125, 150, 300, 600, 1600, 3200, 6400}[configSetting];
		}
	}

	protected static void writeHeatmapImage(HeatmapNew heatmap, File imageFileOut, boolean isFullMapImage, boolean isBlue, double heatmapTransparency, int heatmapSensitivity, int speedMemoryTradeoff, @Nullable IIOWriteProgressListener progressListener)
	{
		log.info("Saving {} image to disk...", imageFileOut);
		long startTime = System.nanoTime();
		if (!imageFileOut.getName().endsWith(".tif"))
		{
			imageFileOut = new File(imageFileOut.getName() + ".tif");
		}

		if (imageFileOut.getParentFile().mkdirs())
		{
			log.debug("Created directory for image file: {}", imageFileOut.getParentFile());
		}

		if (heatmapTransparency < 0)
		{
			heatmapTransparency = 0;
		}
		else if (heatmapTransparency > 1)
		{
			heatmapTransparency = 1;
		}

		String worldMapImageURL = String.format("https://raw.githubusercontent.com/GrandTheftWalrus/gtw-runelite-stuff/main/osrs_world_map%s%s.png", isFullMapImage ? "_full" : "", isBlue ? "_blue" : "");

		// Prepare the image reader
		try (InputStream inputStream = new URL(worldMapImageURL).openStream();
			 ImageInputStream worldMapImageInputStream = ImageIO.createImageInputStream(Objects.requireNonNull(inputStream, "Resource didn't exist: '" + worldMapImageURL + "'")))
		{
			ImageReader reader = ImageIO.getImageReadersByFormatName("PNG").next();
			reader.setInput(worldMapImageInputStream, true);

			// Prepare the image writer
			try (FileOutputStream fos = new FileOutputStream(imageFileOut);
				 BufferedOutputStream bos = new BufferedOutputStream(fos);
				 ImageOutputStream ios = ImageIO.createImageOutputStream(bos))
			{
				ImageWriter writer = ImageIO.getImageWritersByFormatName("tif").next();
				writer.setOutput(ios);
				final int tileWidth = reader.getWidth(0);
				final int tileHeight = calculateTileHeight(speedMemoryTradeoff, isFullMapImage);
				final int N = reader.getHeight(0) / tileHeight;

				// Make progress listener majigger
				if (progressListener != null)
				{
					writer.addIIOWriteProgressListener(progressListener);
				}

				// Prepare writing parameters
				ImageWriteParam writeParam = writer.getDefaultWriteParam();
				writeParam.setTilingMode(ImageWriteParam.MODE_EXPLICIT);
				writeParam.setTiling(tileWidth, tileHeight, 0, 0);
				writeParam.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
				writeParam.setCompressionType("Deflate");
				writeParam.setCompressionQuality(0);

				// Write heatmap image
				RenderedImage heatmapImage;
				// Get latest offset values from git repo
				URL offsetsURL = new URL("https://raw.githubusercontent.com/GrandTheftWalrus/gtw-runelite-stuff/main/offsets.csv");
				Scanner scanner = new Scanner(offsetsURL.openStream());
				scanner.next(); // Skip the headers
				scanner.useDelimiter(",");
				int fullMapOffsetX = Integer.parseInt(scanner.next().trim());
				int fullMapOffsetY = Integer.parseInt(scanner.next().trim());
				int overworldMapOffsetX = Integer.parseInt(scanner.next().trim());
				int overworldMapOffsetY = Integer.parseInt(scanner.next().trim());
				scanner.close();

				if (isFullMapImage)
				{
					heatmapImage = new HeatmapImage(heatmap, reader, N, (float) heatmapTransparency, heatmapSensitivity, fullMapOffsetX, fullMapOffsetY);
				}
				else
				{
					heatmapImage = new HeatmapImage(heatmap, reader, N, (float) heatmapTransparency, heatmapSensitivity, overworldMapOffsetX, overworldMapOffsetY);
				}
				writer.write(null, new IIOImage(heatmapImage, null, null), writeParam);
				reader.dispose();
				writer.dispose();
			}
			log.info("Finished writing {} image to disk after {} ms", imageFileOut, (System.nanoTime() - startTime) / 1_000_000);
		}
		catch (OutOfMemoryError e)
		{
			log.error("OutOfMemoryError thrown whilst creating and/or writing image file. " +
				"If you're not able to fix the issue by lowering the memory usage settings " +
				"(if they exist in this version of the plugin) then perhaps consider submitting" +
				"an Issue on the GitHub");
		}
		catch (Exception e)
		{
			log.error("Exception thrown whilst creating and/or writing image file: ", e);
		}
	}

	@Override
	public Vector<RenderedImage> getSources()
	{
		return null;
	}

	@Override
	public Object getProperty(String name)
	{
		return null;
	}

	@Override
	public String[] getPropertyNames()
	{
		return new String[0];
	}

	@Override
	public ColorModel getColorModel()
	{
		return colorModel;
	}

	@Override
	public SampleModel getSampleModel()
	{
		return new ComponentSampleModel(DataBuffer.TYPE_BYTE, getWidth(), getHeight(), 1, 1, new int[]{0, 0, 0});
	}

	@Override
	public int getWidth()
	{
		try
		{
			return worldMapImageReader.getWidth(0);
		}
		catch (IOException e)
		{
			throw new RuntimeException(e);
		}
	}

	/**
	 * Calculates the min and max values of the heatmap within the overworld
	 *
	 * @param heatmap The heatmap
	 * @return An array of length 2, where the first element is the max value and the second element is the min value
	 */
	private int[] calculateMaxMinValues(HeatmapNew heatmap)
	{
		int maxVal = 0;
		int minVal = Integer.MAX_VALUE;
		if (heatmap.getEntrySet().isEmpty())
		{
			return new int[]{0, 0};
		}
		for (Map.Entry<WorldPoint, Integer> tile : heatmap.getEntrySet())
		{
			Point point = new Point(tile.getKey().getX(), tile.getKey().getY());
			if (isGameTileInImageBounds(point))
			{
				if (tile.getValue() > maxVal)
				{
					maxVal = tile.getValue();
				}
				if (tile.getValue() < minVal)
				{
					minVal = tile.getValue();
				}
			}
		}
		return new int[]{maxVal, minVal};
	}

	public boolean isGameTileInImageBounds(Point point)
	{
		Point pixelLocation = gameCoordsToImageCoords(point);
		return pixelLocation.x >= 0 && pixelLocation.x < getWidth() && pixelLocation.y >= 0 && pixelLocation.y < getHeight();
	}

	@Override
	public int getHeight()
	{
		try
		{
			return worldMapImageReader.getHeight(0);
		}
		catch (IOException e)
		{
			throw new RuntimeException(e);
		}
	}

	@Override
	public int getMinX()
	{
		return 0;
	}

	@Override
	public int getMinY()
	{
		return 0;
	}

	@Override
	public int getNumXTiles()
	{
		return numXTiles;
	}

	@Override
	public int getNumYTiles()
	{
		return numYTiles;
	}

	@Override
	public int getMinTileX()
	{
		return 0;
	}

	@Override
	public int getMinTileY()
	{
		return 0;
	}

	@Override
	public int getTileWidth()
	{
		return getWidth() / numXTiles;
	}

	@Override
	public int getTileHeight()
	{
		return getHeight() / numYTiles;
	}

	@Override
	public int getTileGridXOffset()
	{
		return 0;
	}

	@Override
	public int getTileGridYOffset()
	{
		return 0;
	}

	@Override
	public Raster getTile(int tileX, int tileY)
	{
		int x = tileX * getTileWidth();
		int y = tileY * getTileHeight();
		return getData(new Rectangle(x, y, getTileWidth(), getTileHeight()));
	}

	@Override
	public Raster getData()
	{
		return getData(new Rectangle(0, 0, getWidth(), getHeight()));
	}

	@Override
	public Raster getData(Rectangle rect)
	{
		ImageReadParam readParam = worldMapImageReader.getDefaultReadParam();
		readParam.setSourceRegion(rect);
		try
		{
			// Reads only the specified rect from osrs_world_map.png into memory
			BufferedImage bi = worldMapImageReader.read(0, readParam);
			processImageRegion(bi, rect);
			return bi.getData();
		}
		catch (IOException e)
		{
			throw new RuntimeException(e);
		}
	}

	@Override
	public WritableRaster copyData(WritableRaster raster)
	{
		return null;
	}

	/**
	 * Assumes that the image will be processed in natural reading order pixel-wise (left-to-right, top-to-bottom) otherwise it won't work.
	 * Make sure that initializeProcessingParameters() has been run before running this
	 *
	 * @param imageRegion The image region to be drawn on
	 * @param region      The x,y,width,height coordinates of where the imageRegion came from in the whole image
	 */
	public void processImageRegion(BufferedImage imageRegion, Rectangle region)
	{
		// Run them heatmap tiles through the ol' rigamarole
		// For each pixel in current image region
		while (!sortedHeatmapTiles.isEmpty())
		{
			Map.Entry<Point, Integer> gameTile = sortedHeatmapTiles.poll();
			Point tilePixel = gameTile.getKey(); // tilePixel is the upper-left coordinate of the 4x4 pixel square that this tile covers
			tilePixel = gameCoordsToImageCoords(tilePixel);
			boolean isInImageBounds = (tilePixel.x >= 0 && tilePixel.y >= 0 && tilePixel.x < getWidth() && tilePixel.y < getHeight());
			int tileValue = gameTile.getValue();

			boolean pixelIsBeforeRegion = (compareNaturalReadingOrder(tilePixel.x, tilePixel.y, region.x, region.y) < 0);
			boolean pixelIsAfterRegion = (compareNaturalReadingOrder(tilePixel.x, tilePixel.y, region.x + region.width, region.y + region.height) > 0);
			// If current tile is after bottom right edge of current image region in reading order
			if (pixelIsAfterRegion)
			{
				// put it back in the front of the queue and return
				sortedHeatmapTiles.addFirst(gameTile);
				return;
			}
			// If current tile is before upper left edge of current image region, or is out of bounds, or hasn't been stepped on, skip this tile
			if (pixelIsBeforeRegion || !isInImageBounds || tileValue == 0)
			{
				continue;
			}
			// Else continue

			// Calculate color
			double currHue = calculateHue(tileValue, heatmapSensitivity, heatmapMinVal, heatmapMaxVal);
			// Reassign the new RGB values to the corresponding 9 pixels (each tile covers 3x3 image pixels)
			for (int x_offset = 0; x_offset < 4; x_offset++)
			{
				for (int y_offset = 0; y_offset < 4; y_offset++)
				{
					int curX = tilePixel.x - region.x + x_offset;
					int curY = tilePixel.y - region.y + y_offset;
					if (curY >= imageRegion.getHeight())
					{
						// put it back in the front of the queue and return
						sortedHeatmapTiles.addFirst(gameTile);
						return;
					}
					else if (curX >= imageRegion.getWidth()){
						// Skip this pixel
						continue;
					}
					int srcRGB = imageRegion.getRGB(curX, curY);
					int r = (srcRGB >> 16) & 0xFF;
					int g = (srcRGB >> 8) & 0xFF;
					int b = (srcRGB) & 0xFF;
					float brightness = Color.RGBtoHSB(r, g, b, null)[2] * (1 - heatmapTransparency) + heatmapTransparency;
					// convert HSB to RGB with the calculated Hue, with Saturation=1
					int currRGB = Color.HSBtoRGB((float) currHue, 1, brightness);
					imageRegion.setRGB(curX, curY, currRGB);
				}
			}
		}
	}

	private double calculateHue(int tileValue, int heatmapSensitivity, int minVal, int maxVal)
	{
		double nthRoot = 1 + (heatmapSensitivity - 1.0) / 2;
		int logBase = 4;
		double minHue = 1 / 3.0;
		double maxHue = 0.0;
		double currHue = (float) ((Math.log(tileValue) / Math.log(logBase)) / (Math.log(maxVal + 1 - minVal) / Math.log(logBase)));
		currHue = Math.pow(currHue, 1.0 / nthRoot);
		currHue = (float) (minHue + (currHue * (maxHue - minHue))); // Assign a hue based on normalized step value (values [0, 1] are mapped linearly to hues of [0, 0.333] aka green then yellow, then red)
		return currHue;
	}

	private int compareNaturalReadingOrder(int x1, int y1, int x2, int y2)
	{
		// This should return the difference in the row-major order of the two points
		int rowMajor1 = y1 * getWidth() + x1;
		int rowMajor2 = y2 * getWidth() + x2;
		return rowMajor1 - rowMajor2;
	}

	private void initializeProcessingVariables(HeatmapNew heatmap)
	{
		// Get min/max values within writeable region to be written
		int[] maxMin = calculateMaxMinValues(heatmap);
		heatmapMaxVal = maxMin[0];
		heatmapMinVal = maxMin[1];

		// Create sorted heatmap tiles array (sorted left-to-right top-to-bottom)
		// Converting Points to WorldPoints
		sortedHeatmapTiles = heatmap.getEntrySet().stream()
			.filter(e -> e.getKey().getPlane() == 0) // Keep only plane 0 overworld tiles
			.map(e -> new AbstractMap.SimpleEntry<>(new Point(e.getKey().getX(), e.getKey().getY()), e.getValue()))
			.sorted((tile1, tile2) -> {
				Point coords1 = tile1.getKey();
				Point coords2 = tile2.getKey();
				return compareNaturalReadingOrder(coords1.x, -coords1.y, coords2.x, -coords2.y);
			}).collect(Collectors.toCollection(LinkedList::new));
	}

	/**
	 * @param gameCoord True gameworld coordinate
	 * @return The upper-left of the 9-pixel square location on the image osrs_world_map.png that this game coordinate responds to (1 game coordinate = 3x3 pixels). If it is out of bounds, then (-1, -1) is returned
	 */
	public Point gameCoordsToImageCoords(Point gameCoord)
	{
		final int IMAGE_WIDTH = getWidth();
		final int IMAGE_HEIGHT = getHeight();
		gameCoord = remapGameTiles(gameCoord);
		Point pixelLocation = new Point(4 * gameCoord.x + PIXEL_OFFSET_X, IMAGE_HEIGHT - (4 * gameCoord.y) + PIXEL_OFFSET_Y);
		if (pixelLocation.x < 0 || pixelLocation.y < 0 || pixelLocation.x > IMAGE_WIDTH || pixelLocation.y > IMAGE_HEIGHT)
		{
			return new Point(-1, -1);
		}
		else
		{
			return pixelLocation;
		}
	}

	/**
	 * This function remaps game tiles, so for example steps made in Prifdinnas which is actually located outside the overworld will be remapped to Prifdinnas's overworld location
	 *
	 * @param point Old location
	 * @return New location
	 */
	private static Point remapGameTiles(Point point)
	{
		// Prifdinnas
		Rectangle prifdinnas = new Rectangle(3391, 5952, 255, 255);
		if (prifdinnas.contains(point))
		{
			return new Point(point.x - 1024, point.y - 2752);
		}

		return point;
	}
}
package com.worldheatmap;

import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;

import net.runelite.api.ChatMessageType;
import static net.runelite.client.RuneLite.RUNELITE_DIR;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.game.WorldService;
import net.runelite.client.hiscore.HiscoreEndpoint;
import net.runelite.client.hiscore.HiscoreManager;
import net.runelite.client.hiscore.HiscoreResult;
import net.runelite.http.api.worlds.WorldResult;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

@Slf4j
public class HeatmapFileManager
{
    protected final static String HEATMAP_EXTENSION = ".heatmaps";
    protected final static File WORLD_HEATMAP_DIR = new File(RUNELITE_DIR.toString(), "worldheatmap");
    protected final static File HEATMAP_FILES_DIR = Paths.get(WORLD_HEATMAP_DIR.toString(), "Heatmap Files").toFile();
    protected final static File HEATMAP_IMAGE_DIR = Paths.get(WORLD_HEATMAP_DIR.toString(), "Heatmap Images").toFile();
	protected final static ZonedDateTime startOfLeaguesV = ZonedDateTime.of(LocalDateTime.of(2024, 11, 27, 12, 0), ZoneId.of("GMT"));
	protected final static ZonedDateTime endOfLeaguesV = ZonedDateTime.of(LocalDateTime.of(2025, 1, 23, 0, 0), ZoneId.of("GMT"));
	protected final static DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm");
	private final WorldHeatmapPlugin plugin;
	private final HiscoreManager hiscoreManager;
	private final Map<String,  HiscoreResult> hiscoreResults = new HashMap<>();
	private final WorldHeatmapConfig config;
	private final OkHttpClient okHttpClient;
	private final WorldService worldService;

	public HeatmapFileManager(WorldHeatmapPlugin plugin, HiscoreManager hiscoreManager, OkHttpClient okHttpClient, WorldService worldService){
		this.plugin = plugin;
		this.hiscoreManager = hiscoreManager;
		this.config = plugin.config;
		this.okHttpClient = okHttpClient;
		this.worldService = worldService;

	}

	/**
	 * Return a File in the correct directory, either named after the current time or the latest file in the directory,
	 * whichever comes last. If they are equal, returns a new file named mustReturnNewFile minutes later than the
	 * latest file. If mustReturnNewFile is zero, then it returns the latest file.
	 * Doesn't actually create the file, just a File object.
	 * @param userId
	 * @param seasonalType
	 * @return
	 */
	private File getFile(long userId, String seasonalType, boolean mustReturnNewFile) {
		boolean isSeasonal = !seasonalType.isBlank();
		File userIdDir = new File(HEATMAP_FILES_DIR, userId + (isSeasonal ? "_" + seasonalType : ""));
		// Find the most recent file
		File latestFile = getLatestFile(userId, seasonalType);

		// Parse its date
		LocalDateTime dateOfLatestFile = null;
		if (latestFile != null && latestFile.exists()) {
			String name = latestFile.getName();
			int pos = name.lastIndexOf(HEATMAP_EXTENSION);
			name = name.substring(0, pos);
			dateOfLatestFile = LocalDateTime.parse(name, dateFormat);
		}

		LocalDateTime timeToUse;
		LocalDateTime now = LocalDateTime.now().truncatedTo(ChronoUnit.MINUTES);
		if (dateOfLatestFile == null || now.isAfter(dateOfLatestFile)) {
			timeToUse = now;
		}
		else {
			timeToUse = dateOfLatestFile.plus(Duration.ofMinutes(mustReturnNewFile ? 1 : 0));
		}
		String fileName = timeToUse.format(dateFormat) + HEATMAP_EXTENSION;

		return new File(userIdDir, fileName);
	}

	/**
	 * Returns a new heatmaps File named after the current time, or one minute past the latest file, whichever comes last.
	 * Doesn't actually create the file, just a File object.
	 * @param userId The user ID
	 * @param seasonalType The seasonal type, or empty string if not seasonal
	 * @return The new heatmaps File
	 */
    public File getNewFile(long userId, String seasonalType) {
		return getFile(userId, seasonalType, true);
    }

	/**
	 * Returns a new heatmaps File named after the current time, or the latest heatmaps File if it's dated into the future
	 * This is generally for updating the name of modified files.
	 * Doesn't actually create the file, just a File object.
	 * @param userId
	 * @param seasonalType
	 * @return
	 */
	public File getCurrentFile(long userId, String seasonalType) {
		return getFile(userId, seasonalType, false);
	}

	/**
	 * Returns a File named after the current date and time, even if it already exists.
	 * @param userId The user ID
	 * @param type The heatmap type
	 * @param seasonalType The seasonal type, or null if not seasonal
	 * @return
	 */
    public static File getNewImageFile(long userId, HeatmapNew.HeatmapType type, String seasonalType) {
		boolean isSeasonal = !seasonalType.isBlank();
        String dateString = formatDate(LocalDateTime.now());
        File userIdDir = new File(HEATMAP_IMAGE_DIR, Long.toString(userId) + (isSeasonal ? "_" + seasonalType : ""));

        return new File(userIdDir, type + "_" + dateString + ".tif");
    }

    /**
     * Returns the .heatmaps file in the given directory whose filename is the most recent parseable date string.
     * Returns null if no such file exists.
	 * @param accountHash the user ID/account hash
	 * @param seasonalType the seasonal type, or null if not seasonal
     * @return the file with the most recent date in its filename, or null if no such file exists
     */
    public File getLatestFile(long accountHash, String seasonalType) {
		boolean isSeasonal = !seasonalType.isBlank();
		// currentDir may be normal or seasonal
        File currentDir = new File(HEATMAP_FILES_DIR, accountHash + (isSeasonal ? "_" + seasonalType : ""));
		return getLatestFile(currentDir);
	}

	/**
	 * Returns the .heatmaps file in the given directory whose filename is the most recent parseable date string.
	 * @param path the directory to search
	 * @return the file with the most recent date in its filename, or null if no such file exists
	 */
	private File getLatestFile(File path) {
		// If the latest file is found, return it
		File[] files = getSortedFiles(path);
		if (files.length == 0) {
			return null;
		}
		return files[0];
	}

	/**
	 * Runs fixes on the user's heatmaps files, if necessary, for backwards compatability.
	 * @param accountHash the user ID/account hash
	 * @param username the player's username
	 */
	protected void fixHeatmapsFiles(long accountHash, String username) {
		File normalDir = new File(HEATMAP_FILES_DIR, Long.toString(accountHash));
		File leaguesVDir = new File(HEATMAP_FILES_DIR, accountHash + "_LEAGUES_V");

		// Modernize any legacy heatmap files, stashing them in the regular directory
		// (since they won't have seasonal type encoded)
		carryOverV1_0Files(username, accountHash, normalDir);
		carryOverV1_2Files(accountHash, normalDir);

		// Perform V1.6 file naming scheme fix on normal directory if necessary
		fileNamingSchemeFix(normalDir);

		// Check if Leagues V decontamination is needed, and perform if so
		leaguesDecontaminationFix(normalDir, leaguesVDir, username);
	}

	private boolean userIsOnSeasonalHiscores(String username)
	{

		// If already looked up and found, return true
		if (hiscoreResults.get(username) != null)
		{
			return true;
		}

		try
		{
			hiscoreResults.put(username, hiscoreManager.lookup(username, HiscoreEndpoint.SEASONAL));
		}
		catch (IOException e)
		{
			log.error("Error looking up user on Leagues hiscores: {}", e.toString());
			return false;
		}

		return hiscoreResults.get(username) != null;
	}

	/**
	 * Detects V1.2 heatmaps files, moves them to the new location, and renames them after their date modified.
	 *
	 * @param accountHash The user ID/account hash
	 * @param newDir      The new directory to move the files to
	 */
	private void carryOverV1_2Files(long accountHash, File newDir) {
		File oldFile = new File(HEATMAP_FILES_DIR, accountHash + HEATMAP_EXTENSION);
		if (oldFile.exists()) {
			// Move the old file to the new location, naming it after its date modified
			long epochMillis = oldFile.lastModified();
			ZonedDateTime lastModified = Instant.ofEpochMilli(epochMillis).atZone(ZoneId.systemDefault());
			String newName = dateFormat.format(lastModified);
			File newFile = new File(newDir, newName + HEATMAP_EXTENSION);

			// Move the file by rewriting it, to update its version
			try {
				log.info("Moving heatmaps file from legacy (V1.2) location {} to new location {}", oldFile, newFile);
				HashMap<HeatmapNew.HeatmapType, HeatmapNew> heatmaps = readHeatmapsFromFile(oldFile, List.of(HeatmapNew.HeatmapType.values()), false);
				// Update the account hash cuz we have it available
				heatmaps.values().forEach(h -> {
					h.setUserID(accountHash);
					h.setSeasonalType("");
				});
				writeHeatmapsToFile(heatmaps.values(), newFile, false);

				// Delete the old file
				Files.delete(oldFile.toPath());

				// Set its date modified to what it was before
				newFile.setLastModified(epochMillis);

				// If the moved file is the latest one in the folder,
				// make a second copy of the moved file, named one minute later,
				// so we can keep the other one as an updated backup
				if (getLatestFile(newDir) == newFile) {
					File newFile2 = new File(newDir, dateFormat.format(lastModified.plusMinutes(1)) + HEATMAP_EXTENSION);
					Files.copy(newFile.toPath(), newFile2.toPath());
					newFile2.setLastModified(lastModified.plusMinutes(1).toInstant().toEpochMilli());
				}
			} catch (IOException e) {
				log.error("Moving heatmaps file from legacy (V1.2) location failed");
			}

		}

		// If the file doesn't exist, return null
	}

	/**
	 * Returns V1.0 heatmap files if they exist, after having converted them to the new format and moving them to the new location.
	 * Also keeps an '.old' copy of the old files
	 * Also renames the old 'Backups' directory to 'Backups.old' if it exists
	 *
	 * @param currentPlayerName The player name
	 * @param newDir            The new directory to move the files to
	 */
	private void carryOverV1_0Files(String currentPlayerName, long accountHash, File newDir) {
		// Check if TYPE_A V1.0 file exists, and if it does, convert it to the new format
		// rename the old file to .old, and write the new file
		File typeAFile = new File(HEATMAP_FILES_DIR.toString(), currentPlayerName + "_TypeA.heatmap");
		HeatmapNew typeAHeatmap = new HeatmapNew(HeatmapNew.HeatmapType.TYPE_A, -1, -1, null, -1);
		ZonedDateTime typeAModified = null;
		boolean typeAExisted = false;
		if (typeAFile.exists()) {
			log.info("Found legacy Type A heatmap file for user {}. Converting to new format and moving to proper directory...", currentPlayerName);
			typeAExisted = true;
			// Get date modified
			typeAModified = ZonedDateTime.of(LocalDateTime.ofInstant(Instant.ofEpochMilli(typeAFile.lastModified()), ZoneId.systemDefault()), ZoneId.systemDefault());

			// Load and convert the legacy heatmap file
			typeAHeatmap = HeatmapNew.readLegacyV1HeatmapFile(typeAFile);
			typeAHeatmap.setUserID(accountHash);
			typeAHeatmap.setSeasonalType("");
			typeAHeatmap.setHeatmapType(HeatmapNew.HeatmapType.TYPE_A);

			// Append '.old' to legacy file name
			File dotOldTypeA = new File(typeAFile + ".old");
			typeAFile.renameTo(dotOldTypeA);
		}

		// Repeat for Type B
		File typeBFile = new File(HEATMAP_FILES_DIR.toString(), currentPlayerName + "_TypeB.heatmap");
		HeatmapNew typeBHeatmap = new HeatmapNew(HeatmapNew.HeatmapType.TYPE_B, -1, -1, null, -1);
		ZonedDateTime typeBModified = null;
		boolean typeBExisted = false;
		if (typeBFile.exists()) {
			log.info("Found legacy Type B heatmap file for user {}. Converting to new format and moving to proper directory...", currentPlayerName);
			typeBExisted = true;
			// Get date modified
			typeBModified = ZonedDateTime.of(LocalDateTime.ofInstant(Instant.ofEpochMilli(typeBFile.lastModified()), ZoneId.systemDefault()), ZoneId.systemDefault());

			// Load, rename, and rewrite the legacy heatmap file to the proper location
			typeBHeatmap = HeatmapNew.readLegacyV1HeatmapFile(typeBFile);
			typeBHeatmap.setUserID(accountHash);
			typeBHeatmap.setSeasonalType("");
			typeBHeatmap.setHeatmapType(HeatmapNew.HeatmapType.TYPE_B);

			// Make '.old' copy
			File dotOldTypeB = new File(typeBFile + ".old");
			typeBFile.renameTo(dotOldTypeB);
		}

		// Append .old to Paths.get(HEATMAP_FILES_DIR, "Backups") folder if it exists
		File backupDir = Paths.get(HEATMAP_FILES_DIR.toString(), "Backups").toFile();
		if (backupDir.exists()) {
			File oldBackupDir = new File(backupDir.toString() + ".old");
			backupDir.renameTo(oldBackupDir);
		}

		// If either one existed, write them to a new file
		if (typeAExisted || typeBExisted) {
			// Set the new file's date modified to the latest of the two legacy files
			ZonedDateTime latestModified;
			if (typeAModified == null) {
				latestModified = typeBModified;
			}
			else if (typeBModified == null) {
				latestModified = typeAModified;
			}
			else {
				latestModified = typeAModified.isAfter(typeBModified) ? typeAModified : typeBModified;
			}

			File newFile = new File(newDir, dateFormat.format(latestModified) + HEATMAP_EXTENSION);
			this.writeHeatmapsToFile(List.of(typeAHeatmap, typeBHeatmap), newFile);
			newFile.setLastModified(latestModified.toInstant().toEpochMilli());

			// If the new file is the latest one in the folder,
			// Make a second copy of the moved file, named one minute later
			// so we can keep the other one as an updated backup
			if (getLatestFile(newDir) == newFile) {
				File newFile2 = new File(newDir, dateFormat.format(latestModified.plusMinutes(1)) + HEATMAP_EXTENSION);
				try {
					Files.copy(newFile.toPath(), newFile2.toPath());
					newFile2.setLastModified(latestModified.plusMinutes(1).toInstant().toEpochMilli());
				} catch (IOException e) {
					log.error("Failed to make extra copy of converted legacy shmeatmap file: {}", e.toString());
				}
			}
		}
	}

	/**
	 * The following is a fix for the realization that leagues (and all other world-based game modes)
	 * were being permanently mixed with regular heatmaps. This fix moves all post-leagues V
	 * heatmap files into a "LEAGUES_V" directory, and rolls back normal heatmaps to a state before the
	 * leagues contamination, on the criteria that the user is on the Leagues V hiscores, has any "normal"
	 * heatmaps dated during Leagues V, and has no Leagues V dir (aka this process hasn't run yet).
	 * It also creates a text file explaining the situation.
	 * The criteria for possible contamination
	 * @param normalDir the directory containing the regular heatmaps
	 * @param leaguesVDir the directory to move the contaminated heatmaps to
	 */
	private void leaguesDecontaminationFix(File normalDir, File leaguesVDir, String username) {
		if (username == null || username.isBlank()) {
			return;
		}

		// Run check to see if Leagues VI has started yet,
		// in which case we should no longer be running the fix for Leagues V data
		// (otherwise it'll break a bunch of stuff)
		if (isLeaguesVIStarted()) {
			return;
		}

		if (leaguesVDir.exists() || !normalDir.exists() || ! userIsOnSeasonalHiscores(username)){
			return;
		}

		// Check if they have any files dated during Leagues V
		boolean hasPossiblyContaminatedFiles = false;
		for (File file : getSortedFiles(normalDir)){
			String name = file.getName();
			int pos = name.lastIndexOf(".");
			name = name.substring(0, pos);
			ZonedDateTime fileDate = ZonedDateTime.of(LocalDateTime.parse(name, dateFormat), ZoneId.systemDefault());
			if (fileDate.isAfter(startOfLeaguesV) && fileDate.isBefore(endOfLeaguesV)){
				hasPossiblyContaminatedFiles = true;
				break;
			}
		}

		if (!hasPossiblyContaminatedFiles){
			return;
		}

		log.info("User {} has potentially contaminated heatmaps, moving to Leagues V directory and rolling back...", username);

		// Create seasonal directory
		if (!leaguesVDir.mkdirs()) {
			log.error("Failed to create seasonal heatmaps directory");
			return;
		}

		// Move potentially contaminated files from the normal heatmap directory to the seasonal directory;
		int filesMoved = Arrays.asList(getSortedFiles(normalDir)).parallelStream().mapToInt(originFile -> {
			String name = originFile.getName();
			int pos = name.lastIndexOf(".");
			name = name.substring(0, pos);
			ZonedDateTime fileDate = ZonedDateTime.of(LocalDateTime.parse(name, dateFormat), ZoneId.systemDefault());
			// Move everything dated after the start of Leagues V to the leagues folder
			if (fileDate.isAfter(startOfLeaguesV)) {
				try {
					// Move it to the seasonal directory, updating its metadata
					log.info("File {} is contaminated by Leagues V, moving to Leagues V directory", originFile.getName());
					HashMap<HeatmapNew.HeatmapType, HeatmapNew> heatmaps = readHeatmapsFromFile(originFile, List.of(HeatmapNew.HeatmapType.values()), false);
					heatmaps.values().forEach(h -> h.setSeasonalType("LEAGUES_V"));
					File destinationFile = new File(leaguesVDir, originFile.getName());
					writeHeatmapsToFile(heatmaps.values(), destinationFile, false);

					// Set the last modified time to what it was before
					destinationFile.setLastModified(originFile.lastModified());

					// Delete the original file
					try {
						Files.delete(originFile.toPath());
					}
					catch (IOException e) {
						log.error("Failed to delete original heatmap file {} after moving to Leagues V directory: {}", originFile.getName(), e.toString());
					}
					return 1;
				}
				catch (IOException e)
				{
					log.error("Failed to move file to seasonal directory and/or update its metadata: {}", e.toString());
				}
			}
			return 0;
		}).sum();

		// Make a copy of the latest remaining file in the normal directory, named one minute later
		// so we can keep the other one as an untouched backup
		File latestFile = getLatestFile(normalDir);
		if (latestFile != null) {
			try {
				long epochMillis = latestFile.lastModified();
				// Convert from UTC to local time
				ZonedDateTime lastModified = Instant.ofEpochMilli(epochMillis).atZone(ZoneId.systemDefault());
				File newFile = new File(normalDir, dateFormat.format(lastModified.plusMinutes(1)) + HEATMAP_EXTENSION);
				Files.copy(latestFile.toPath(), newFile.toPath());
				newFile.setLastModified(lastModified.plusMinutes(1).toInstant().toEpochMilli());
			} catch (IOException e) {
				log.error("Failed to make extra copy of latest remaining heatmap file: {}", e.toString());
			}
		}

		if (filesMoved > 0) {
			// Print a notice in the in-game chatbox
			plugin.clientThread.invoke(this::displayLeaguesVNotice);

			// Create a text file explaining the situation, for if/when the user eventually investigates
			String today = formatDate(LocalDateTime.now());
			File leaguesExplanationFile = new File(leaguesVDir, today + "_leagues_incident.txt");
			try {
				Files.write(leaguesExplanationFile.toPath(), (
					"This directory contains heatmaps that are possibly contaminated by Leagues V data.\n" +
						"Version 1.5.1 of the plugin didn't keep separate heatmaps for Leagues/seasonal\n" +
						"accounts and regular accounts because I didn't realize that each player's\n" +
						"Leagues/seasonal account would have the same Account ID code\n" +
						"(regular/ironman/group ironman etc.) as their regular account. So, data being\n" +
						"uploaded to the website https://osrsworldheatmap.com was looking kinda suspicious\n" +
						"such as how TELEPORTED_TO had a bunch of entries that would normally be impossible\n" +
						"for regular accounts. The only way to fix it, that I could think of, was to\n" +
						"designate the potentially contaminated .heatmaps files (i.e. the ones dated after the start \n" +
						"of Leagues V) of anyone who has a record on the Leagues V hiscores, and has any heatmap saves\n" +
						"dated during Leagues V, as a leagues heatmap (which is why you're seeing this), which\n" +
						"effectively rolls-back any regular heatmaps to the latest existing pre-leagues backup.\n" +
						"That way, the personal data that players spent a long time collecting wouldn't be\n" +
						"lost, whilst somewhat unmucking the global heatmap. In the future I'm  thinking that \n" +
						"I'll add a feature to the website where you can open a local\n" +
						".heatmaps file for visualization, so you can more easily take a gander at your old\n" +
						"data in this folder. I'll probably make a Leagues V category on the global heatmap, too.\n" +
						"If you have any questions or concerns, please contact me somehow or make an issue on\n" +
						"the GitHub page for the plugin: https://github.com/GrandTheftWalrus/RuneLite-World-Heatmap\n"+
						"\n" +
						"P.S. If you're absolutely certain that you didn't play Leagues V until a certain date\n" +
						"post-release, then I gueeeeesss you could move the allegedly unaffected .heatmap files from\n" +
						"this folder back to the regular folder if you see this message before too late \uD83E\uDD28 but\n" +
						"you better be certain or else you'll be contaminating the global heatmap if you're opted-in\n" +
						"to contributing to it. If you're not opted-in, then go ahead.\n"
				).getBytes());
			} catch (IOException e) {
				log.error("Failed to write leagues explanation file: {}", e.toString());
			}
		}

		// Upload the final leagues heatmap to the website, if opted-in
		if (filesMoved > 0 && config.isUploadEnabled()) {
			try {
				String HEATMAP_SITE_API_ENDPOINT = "https://osrsworldheatmap.com/api/upload-csv/";
				File latestLeaguesHeatmap = getLatestFile(leaguesVDir);
				byte[] leaguesHeatmapBytes = new byte[0];
				try {
					assert latestLeaguesHeatmap != null;
					leaguesHeatmapBytes = Files.readAllBytes(latestLeaguesHeatmap.toPath());
				} catch (IOException e) {
					log.error("Failed to read latest Leagues V heatmap file for upload: {}", e.toString());
				}

				if (leaguesHeatmapBytes.length == 0) {
					return;
				}

				// Prepare the request body
				RequestBody requestBody = RequestBody.create(
					MediaType.parse("application/zip"),
					leaguesHeatmapBytes
				);

				// Build the request
				Request request = new Request.Builder()
					.url(HEATMAP_SITE_API_ENDPOINT)
					.post(requestBody)
					.build();

				// Execute the request
				try (Response response = okHttpClient.newCall(request).execute()) {
					if (response.isSuccessful()) {
						log.info("Uploaded final Leagues V heatmaps to global heatmap");
					} else {
						log.error("Failed to upload Leagues V heatmaps: HTTP {} {}", response.code(), response.message());
					}
				}
			} catch (Exception e) {
				log.error("Failed to upload heatmaps: {}", e.toString());
			}
		}
	}

	private boolean isLeaguesVIStarted()
	{
		boolean isLeaguesVIStarted = true;
		StringBuilder sb = new StringBuilder();
		WorldResult worlds = worldService.getWorlds();
		if (worlds != null) {
			worlds.getWorlds().forEach(world ->
				sb.append(world.getActivity().toLowerCase() + " ")
			);
		}
		if (sb.indexOf("leagues") == -1){
			// In case this code fails to run due to a race condition or sum,
			// isLeaguesVIStartedYet defaults to true
			// I had to write this method weirdly in order for it to default
			// to true
			isLeaguesVIStarted = false;
		}

		return isLeaguesVIStarted;
	}

	private static String formatDate(LocalDateTime dateTime) {
		return dateTime.format(dateFormat);
	}

    /**
	 * Returns an array of files in the given directory whose filenames are parseable date strings, sorted by date.
	 * @param path the directory to search
	 * @return an array of files with parseable dates in their filenames, sorted by date (most recent first)
     */
	private File[] getSortedFiles(File path) {
		File[] files = path.listFiles(File::isFile);
		if (files == null || files.length == 0) {
			return new File[0];
		}

		files = Arrays.stream(files)
			.filter(file -> {
				String name = file.getName();
				int pos = name.lastIndexOf(".heatmaps");
				if (pos == -1) {
					return false;
				}
				name = name.substring(0, pos);
				try {
					LocalDateTime.parse(name, dateFormat);
					return true;
				} catch (Exception e) {
					return false;
				}
			})
			.toArray(File[]::new);

		Arrays.sort(files, (f1, f2) -> {
			try {
				String n1 = f1.getName();
				String n2 = f2.getName();
				int pos1 = n1.lastIndexOf(".heatmaps");
				int pos2 = n2.lastIndexOf(".heatmaps");
				n1 = n1.substring(0, pos1);
				n2 = n2.substring(0, pos2);

				LocalDateTime d1 = LocalDateTime.parse(n1, dateFormat);
				LocalDateTime d2 = LocalDateTime.parse(n2, dateFormat);
				return d2.compareTo(d1);
			} catch (Exception e) {
				return 0;
			}
		});

		return files;
	}

	protected void writeHeatmapsToFile(Collection<HeatmapNew> heatmapsToWrite, File heatmapsFile, @Nullable File previousHeatmapsFile) {
		writeHeatmapsToFile(heatmapsToWrite, heatmapsFile, previousHeatmapsFile, true);
	}

	protected void writeHeatmapsToFile(Collection<HeatmapNew> heatmapsToWrite, File heatmapsFile) {
		writeHeatmapsToFile(heatmapsToWrite, heatmapsFile, null, true);
	}

	/**
	 * Writes the provided heatmap data to the specified .heatmaps file. If the file already exists, it will be updated,
	 * and unprovided heatmaps already in the file will remain.
	 * @param heatmapsToWrite The heatmaps to write
	 * @param heatmapsFile The .heatmaps file
	 */
	protected void writeHeatmapsToFile(Collection<HeatmapNew> heatmapsToWrite, File heatmapsFile, boolean verbose) {
		writeHeatmapsToFile(heatmapsToWrite, heatmapsFile, null, verbose);
	}

	/**
	 * Writes the provided heatmap data to the specified .heatmaps file. Unprovided heatmaps are carried over from the file previousHeatmapsFile, if it has them.
	 * If heatmapsFile already exists, existing unprovided heatmaps will be kept. Heatmaps in previousHeatmapsFile take precedence over heatmaps in heatmapsFile
	 * if heatmapsFile already exists.
	 * @param heatmapsToWrite The heatmaps to write
	 * @param heatmapsFile The .heatmaps file
	 * @param previousHeatmapsFile The previous .heatmaps file.
	 */
	protected void writeHeatmapsToFile(Collection<HeatmapNew> heatmapsToWrite, File heatmapsFile, @Nullable File previousHeatmapsFile, boolean verbose) {
		// Preamble
		if (verbose) {
			log.info("Saving heatmaps to file '{}'...", heatmapsFile.getName());
		}

		long startTime = System.nanoTime();
		StringBuilder loggingOutput = new StringBuilder("Heatmap types saved: ");

		// Make the directory path if it doesn't exist
		if (!Files.exists(Paths.get(heatmapsFile.getParent()))) {
			if (!new File(heatmapsFile.getParent()).mkdirs()) {
				log.error("Could not create the directory for the heatmap file");
			}
		}

		// Copy previousHeatmapsFile to heatmapsFile (if it exists)
		// in order to carry over unprovided heatmaps before updating
		if (previousHeatmapsFile != null && previousHeatmapsFile.exists()) {
			try {
				Files.copy(previousHeatmapsFile.toPath(), heatmapsFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
			} catch (IOException e) {
				log.error("Error copying latest heatmaps file to new location");
				return;
			}
		}

		// Zip reading params
		Map<String, String> env = new HashMap<>();
		env.put("create", "true");
		URI uri = URI.create("jar:" + heatmapsFile.toURI());

		for (HeatmapNew heatmap : heatmapsToWrite) {
			// Write the heatmap file, overwriting zip entries that already exist
			try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {
				Path zipEntryFile = fs.getPath("/" + heatmap.getHeatmapType().toString() + "_HEATMAP.csv");
				try (OutputStreamWriter osw = new OutputStreamWriter(Files.newOutputStream(zipEntryFile), StandardCharsets.UTF_8)) {
					heatmap.toCSV(osw);
					osw.flush(); // Not sure if this is necessary
				}
			} catch (IOException e) {
                log.error("World Heatmap was not able to save heatmap type '{}' to file '{}'", heatmap.getHeatmapType(), heatmapsFile.getName());
				e.printStackTrace();
				return;
			}
			loggingOutput.append(heatmap.getHeatmapType() + " (" + heatmap.getTileCount() + " tiles), ");
		}

		if (verbose) {
			log.info(loggingOutput.toString());
			log.info("Finished writing '{}' heatmap file to disk after {} ms", heatmapsFile.getName(), (System.nanoTime() - startTime) / 1_000_000);
		}
	}

	/**
	 * Loads the specified heatmap types from the given .heatmaps file.
	 *
	 * @param heatmapsFile The .heatmaps file
	 * @param types        The heatmap types to load
	 * @return HashMap of HeatmapNew objects
	 * @throws FileNotFoundException If the file does not exist
	 */
	HashMap<HeatmapNew.HeatmapType, HeatmapNew> readHeatmapsFromFile(File heatmapsFile, Collection<HeatmapNew.HeatmapType> types) throws FileNotFoundException {
		return readHeatmapsFromFile(heatmapsFile, types, true);
	}

	/**
	 * Loads the specified heatmap types from the given .heatmaps file.
	 *
	 * @param heatmapsFile The .heatmaps file
	 * @param types        The heatmap types to load
	 * @param verbose      Whether to log the heatmap types loaded
	 * @return HashMap of HeatmapNew objects
	 * @throws FileNotFoundException If the file does not exist
	 */
	HashMap<HeatmapNew.HeatmapType, HeatmapNew> readHeatmapsFromFile(File heatmapsFile, Collection<HeatmapNew.HeatmapType> types, boolean verbose) throws FileNotFoundException {
		Map<String, String> env = new HashMap<>();
		env.put("create", "true");
		URI uri = URI.create("jar:" + heatmapsFile.toURI());
		try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {
			HashMap<HeatmapNew.HeatmapType, HeatmapNew> heatmapsRead = new HashMap<>();
			StringBuilder loggingOutput = new StringBuilder();
			loggingOutput.append("Heatmap types loaded: ");

			for (HeatmapNew.HeatmapType curType : types) {
				Path curHeatmapPath = fs.getPath("/" + curType.toString() + "_HEATMAP.csv");
				if (!Files.exists(curHeatmapPath)) {
					continue;
				}
				try (InputStreamReader isr = new InputStreamReader(Files.newInputStream(curHeatmapPath), StandardCharsets.UTF_8);
					 BufferedReader reader = new BufferedReader(isr)) {
					HeatmapNew heatmap = HeatmapNew.fromCSV(curType, reader);
					heatmapsRead.put(heatmap.getHeatmapType(), heatmap);
					loggingOutput.append(heatmap.getHeatmapType() + " (" + heatmap.getTileCount() + " tiles), ");
				} catch (IOException e) {
                    log.error("Error reading {} heatmap from .heatmaps entry '{}'", curType, curHeatmapPath);
				}
			}
			if (verbose) {
				log.info(loggingOutput.toString());
			}
			return heatmapsRead;
		} catch (FileNotFoundException e) {
			throw e;
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * V1.6.0 fix for file naming scheme. Checks the latest heatmap version in the directory, and if it's version 101 or
	 * earlier, renames the files after their dates modified.
	 * @param directory The directory to fix
	 */
	protected void fileNamingSchemeFix(File directory) {
		// Get latest .heatmaps file in the directory
		File latestHeatmap = getLatestFile(directory);
		if (latestHeatmap == null) {
			return;
		}

		// Find the latest heatmap version of the latest .heatmaps file
		long latestVersion = -1;
		try {
			Map<HeatmapNew.HeatmapType, HeatmapNew> heatmaps = readHeatmapsFromFile(latestHeatmap, List.of(HeatmapNew.HeatmapType.values()), false);
			for (HeatmapNew heatmap : heatmaps.values()) {
				if (heatmap.getVersionReadFrom() > latestVersion) {
					latestVersion = heatmap.getVersionReadFrom();
				}
			}
		}
		catch (FileNotFoundException e) {
			throw new RuntimeException(e);
		}

		// Rename the files if necessary
		if (latestVersion <= 101) {
			log.info("Performing naming scheme fix on .heatmaps files in directory '{}'...", directory.getName());
			List<File> heatmapFiles = new ArrayList<>();
			for (File file : Objects.requireNonNull(directory.listFiles())) {
				if (file.getName().endsWith(".heatmaps")) {
					heatmapFiles.add(file);
				}
			}

			// Sort the files by parseable date descending
			heatmapFiles.sort((f1, f2) -> {
				String name1 = f1.getName().split("\\.")[0];
				String name2 = f2.getName().split("\\.")[0];
				LocalDateTime f1Date = LocalDateTime.parse(name1, dateFormat);
				LocalDateTime f2Date = LocalDateTime.parse(name2, dateFormat);
				return f2Date.compareTo(f1Date);
			});

			// Cycle through them, renaming them after their date modified
			for (File file : heatmapFiles) {
				long epochMillis = file.lastModified();

				// Convert to ZonedDateTime in the local time zone
				ZonedDateTime lastModified = Instant.ofEpochMilli(epochMillis).atZone(ZoneId.systemDefault());

				// Format the new name
				String newName = dateFormat.format(lastModified);
				File newFile = new File(directory, newName + ".heatmaps");

				// Rename the file
				if (file.renameTo(newFile)) {
					log.info("Renamed {} to {}", file.getName(), newFile.getName());

					// Set its date modified to what it was before
					if (!newFile.setLastModified(epochMillis)){
						log.error("Could not set last modified time of file '{}' back to what it was", newFile.getName());
					}
				}
				else {
					log.error("Could not rename file '{}' to '{}'", file.getName(), newFile.getName());
				}
			}
		}
	}

	/**
	 * Displays a message to the user about the latest update.
	 * Only displays the message once per update.
	 */
	private void displayLeaguesVNotice() {
		String noticeKey = "leaguesVDecontaminationNotice";
		if (plugin.configManager.getConfiguration("worldheatmap", noticeKey) == null) {
			// Send a message in game chat
			final String message = new ChatMessageBuilder()
				.append(Color.decode("#a100a1"), "An automatic fix has been applied to your World Heatmap data in " +
					"order to separate Leagues V data from regular account data. Open your heatmaps folder via " +
					"the side panel and check out the Leagues V folder for more information.")
				.build();
			plugin.chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(message)
				.build());
			plugin.configManager.setConfiguration("worldheatmap", noticeKey, "shown");
		}
	}
}

package com.worldheatmap;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class WorldHeatmapTest
{
	public static void main(String[] args) throws Exception
	{
		//noinspection unchecked
		ExternalPluginManager.loadBuiltin(WorldHeatmapPlugin.class);
		RuneLite.main(args);
	}
}
