package com.worldheatmap;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class WorldHeatmapTest
{
	public static void main(String[] args) throws Exception
	{
		//noinspection unchecked
		ExternalPluginManager.loadBuiltin(WorldHeatmapPlugin.class);
		RuneLite.main(args);
	}
}
package com.worldheatmap;

import java.awt.Color;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Transparency;
import java.awt.color.ColorSpace;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.ComponentColorModel;
import java.awt.image.ComponentSampleModel;
import java.awt.image.DataBuffer;
import java.awt.image.Raster;
import java.awt.image.RenderedImage;
import java.awt.image.SampleModel;
import java.awt.image.WritableRaster;
import java.io.*;
import java.net.URL;
import java.util.*;
import javax.annotation.Nullable;
import javax.imageio.*;
import javax.imageio.event.IIOWriteProgressListener;
import javax.imageio.stream.ImageInputStream;
import javax.imageio.stream.ImageOutputStream;

import lombok.extern.slf4j.Slf4j;

/**
 * Class which calculates osrs heatmap image data on demand
 */
@Slf4j
public class HeatmapImage implements RenderedImage
{
	private final ImageReader worldMapImageReader;
	private final ColorModel colorModel = new ComponentColorModel(ColorSpace.getInstance(ColorSpace.CS_sRGB), false, false, Transparency.OPAQUE, DataBuffer.TYPE_BYTE);

	// A queue that holds the heatmap coordinates along
	// with their values, to be sorted by coordinate left-to-right top-to-bottom
	private static LinkedList<Map.Entry<Point, Integer>> sortedHeatmapTiles;
	private final float heatmapTransparency;
	private final int heatmapSensitivity;
	private final int numXTiles = 1;
	private final int numYTiles;
	private int heatmapMinVal;
	private int heatmapMaxVal;
	int PIXEL_OFFSET_X;
	int PIXEL_OFFSET_Y;

	/**
	 * @param worldMapImageReader osrs_world_map.png
	 * @param numYTiles           Image width must be evenly divisible by numYTiles
	 */
	public HeatmapImage(HeatmapNew heatmap, ImageReader worldMapImageReader, int numYTiles, float transparency, int sensitivity, int pixelOffsetX, int pixelOffsetY)
	{
		this.worldMapImageReader = worldMapImageReader;
		this.numYTiles = numYTiles;
		this.heatmapTransparency = transparency;
		this.heatmapSensitivity = sensitivity;
		this.PIXEL_OFFSET_X = pixelOffsetX;
		this.PIXEL_OFFSET_Y = pixelOffsetY;
		initializeProcessingVariables(heatmap);
		try
		{
			if (worldMapImageReader.getHeight(0) % numYTiles != 0)
			{
                log.debug("WARNING: Image height {} is not evenly divisible by the number of Y tiles, {}.", worldMapImageReader.getHeight(0), numYTiles);
			}
		}
		catch (IOException e)
		{
			throw new RuntimeException(e);
		}
	}

	/**
	 * Calculates the tile height based on the config setting
	 *
	 * @param configSetting The config setting
	 * @return The tile height
	 */
	static int calculateTileHeight(int configSetting, boolean isFullMap) {
		// NOTE: these should be adjusted if the world map image's size is ever changed
		// They should evenly divide the image height or else the image will be cut off
		// Also I think they have to be multiples of 16 or something for the TIF format?
		// I forgor. it seems to be working fine though
		if (isFullMap){
			return new int[]{32, 64, 89, 178, 356, 712, 1424, 2848, 5696}[configSetting];
		}
		else{
			return new int[]{32, 64, 125, 150, 300, 600, 1600, 3200, 6400}[configSetting];
		}
	}

	protected static void writeHeatmapImage(HeatmapNew heatmap, File imageFileOut, boolean isFullMapImage, double heatmapTransparency, int heatmapSensitivity, int speedMemoryTradeoff, @Nullable IIOWriteProgressListener progressListener) {
        log.debug("Saving {} image to disk...", imageFileOut);
		long startTime = System.nanoTime();
		if (!imageFileOut.getName().endsWith(".tif")) {
			imageFileOut = new File(imageFileOut.getName() + ".tif");
		}

		if (imageFileOut.getParentFile().mkdirs()){
            log.debug("Created directory for image file: {}", imageFileOut.getParentFile());
		}

		if (heatmapTransparency < 0) {
			heatmapTransparency = 0;
		} else if (heatmapTransparency > 1) {
			heatmapTransparency = 1;
		}

		String worldMapImageURL;
		if (isFullMapImage) {
			worldMapImageURL = "https://raw.githubusercontent.com/GrandTheftWalrus/gtw-runelite-stuff/main/osrs_world_map_full.png";
		} else {
			worldMapImageURL = "https://raw.githubusercontent.com/GrandTheftWalrus/gtw-runelite-stuff/main/osrs_world_map.png";
		}

		// Prepare the image reader
		try (InputStream inputStream = new URL(worldMapImageURL).openStream();
			 ImageInputStream worldMapImageInputStream = ImageIO.createImageInputStream(Objects.requireNonNull(inputStream, "Resource didn't exist: '" + worldMapImageURL + "'"))) {
			ImageReader reader = ImageIO.getImageReadersByFormatName("PNG").next();
			reader.setInput(worldMapImageInputStream, true);

			// Prepare the image writer
			try (FileOutputStream fos = new FileOutputStream(imageFileOut);
				 BufferedOutputStream bos = new BufferedOutputStream(fos);
				 ImageOutputStream ios = ImageIO.createImageOutputStream(bos)) {
				ImageWriter writer = ImageIO.getImageWritersByFormatName("tif").next();
				writer.setOutput(ios);
				final int tileWidth = reader.getWidth(0);
				final int tileHeight = calculateTileHeight(speedMemoryTradeoff, isFullMapImage);
				final int N = reader.getHeight(0) / tileHeight;

				// Make progress listener majigger
				if (progressListener != null){
					writer.addIIOWriteProgressListener(progressListener);
				}

				// Prepare writing parameters
				ImageWriteParam writeParam = writer.getDefaultWriteParam();
				writeParam.setTilingMode(ImageWriteParam.MODE_EXPLICIT);
				writeParam.setTiling(tileWidth, tileHeight, 0, 0);
				writeParam.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
				writeParam.setCompressionType("Deflate");
				writeParam.setCompressionQuality(0);

				// Write heatmap image
				RenderedImage heatmapImage;
				// Get latest offset values from git repo
				URL offsetsURL = new URL("https://raw.githubusercontent.com/GrandTheftWalrus/gtw-runelite-stuff/main/offsets.csv");
				Scanner scanner = new Scanner(offsetsURL.openStream());
				scanner.next(); // Skip the headers
				scanner.useDelimiter(",");
				int fullMapOffsetX = Integer.parseInt(scanner.next().trim());
				int fullMapOffsetY = Integer.parseInt(scanner.next().trim());
				int overworldMapOffsetX = Integer.parseInt(scanner.next().trim());
				int overworldMapOffsetY = Integer.parseInt(scanner.next().trim());
				scanner.close();

				if (isFullMapImage) {
					heatmapImage = new HeatmapImage(heatmap, reader, N, (float) heatmapTransparency, heatmapSensitivity, fullMapOffsetX, fullMapOffsetY);
				} else {
					heatmapImage = new HeatmapImage(heatmap, reader, N, (float) heatmapTransparency, heatmapSensitivity, overworldMapOffsetX, overworldMapOffsetY);
				}
				writer.write(null, new IIOImage(heatmapImage, null, null), writeParam);
				reader.dispose();
				writer.dispose();
			}
            log.debug("Finished writing {} image to disk after {} ms", imageFileOut, (System.nanoTime() - startTime) / 1_000_000);
		} catch (OutOfMemoryError e) {
			log.error("OutOfMemoryError thrown whilst creating and/or writing image file. " +
					"If you're not able to fix the issue by lowering the memory usage settings " +
					"(if they exist in this version of the plugin) then perhaps consider submitting" +
					"an Issue on the GitHub");
		} catch (Exception e) {
			log.error("Exception thrown whilst creating and/or writing image file");
		}
	}

	@Override
	public Vector<RenderedImage> getSources()
	{
		return null;
	}

	@Override
	public Object getProperty(String name)
	{
		return null;
	}

	@Override
	public String[] getPropertyNames()
	{
		return new String[0];
	}

	@Override
	public ColorModel getColorModel()
	{
		return colorModel;
	}

	@Override
	public SampleModel getSampleModel()
	{
		return new ComponentSampleModel(DataBuffer.TYPE_BYTE, getWidth(), getHeight(), 1, 1, new int[]{0, 0, 0});
	}

	@Override
	public int getWidth()
	{
		try
		{
			return worldMapImageReader.getWidth(0);
		}
		catch (IOException e)
		{
			throw new RuntimeException(e);
		}
	}

	/**
	 * Calculates the min and max values of the heatmap within the overworld
	 *
	 * @param heatmap The heatmap
	 * @return An array of length 2, where the first element is the max value and the second element is the min value
	 */
	private int[] calculateMaxMinValues(HeatmapNew heatmap)
	{
		int maxVal = 0;
		int minVal = Integer.MAX_VALUE;
		if (heatmap.getEntrySet().isEmpty())
		{
			return new int[]{0, 0};
		}
		for (Map.Entry<Point, Integer> tile : heatmap.getEntrySet())
		{
			if (isGameTileInImageBounds(tile.getKey()))
			{
				if (tile.getValue() > maxVal)
				{
					maxVal = tile.getValue();
				}
				if (tile.getValue() < minVal)
				{
					minVal = tile.getValue();
				}
			}
		}
		return new int[]{maxVal, minVal};
	}

	public boolean isGameTileInImageBounds(Point point)
	{
		Point pixelLocation = gameCoordsToImageCoords(point);
		return pixelLocation.x >= 0 && pixelLocation.x < getWidth() && pixelLocation.y >= 0 && pixelLocation.y < getHeight();
	}

	@Override
	public int getHeight()
	{
		try
		{
			return worldMapImageReader.getHeight(0);
		}
		catch (IOException e)
		{
			throw new RuntimeException(e);
		}
	}

	@Override
	public int getMinX()
	{
		return 0;
	}

	@Override
	public int getMinY()
	{
		return 0;
	}

	@Override
	public int getNumXTiles()
	{
		return numXTiles;
	}

	@Override
	public int getNumYTiles()
	{
		return numYTiles;
	}

	@Override
	public int getMinTileX()
	{
		return 0;
	}

	@Override
	public int getMinTileY()
	{
		return 0;
	}

	@Override
	public int getTileWidth()
	{
		return getWidth() / numXTiles;
	}

	@Override
	public int getTileHeight()
	{
		return getHeight() / numYTiles;
	}

	@Override
	public int getTileGridXOffset()
	{
		return 0;
	}

	@Override
	public int getTileGridYOffset()
	{
		return 0;
	}

	@Override
	public Raster getTile(int tileX, int tileY)
	{
		int x = tileX * getTileWidth();
		int y = tileY * getTileHeight();
		return getData(new Rectangle(x, y, getTileWidth(), getTileHeight()));
	}

	@Override
	public Raster getData()
	{
		return getData(new Rectangle(0, 0, getWidth(), getHeight()));
	}

	@Override
	public Raster getData(Rectangle rect)
	{
		ImageReadParam readParam = worldMapImageReader.getDefaultReadParam();
		readParam.setSourceRegion(rect);
		try
		{
			// Reads only the specified rect from osrs_world_map.png into memory
			BufferedImage bi = worldMapImageReader.read(0, readParam);
			processImageRegion(bi, rect);
			return bi.getData();
		}
		catch (IOException e)
		{
			throw new RuntimeException(e);
		}
	}

	@Override
	public WritableRaster copyData(WritableRaster raster)
	{
		return null;
	}

	/**
	 * Assumes that the image will be processed in natural reading order pixel-wise (left-to-right, top-to-bottom) otherwise it won't work.
	 * Make sure that initializeProcessingParameters() has been run before running this
	 *
	 * @param imageRegion The image region to be drawn on
	 * @param region      The x,y,width,height coordinates of where the imageRegion came from in the whole image
	 */
	public void processImageRegion(BufferedImage imageRegion, Rectangle region)
	{
		// Run them heatmap tiles through the ol' rigamarole
		// For each pixel in current image region
		while (!sortedHeatmapTiles.isEmpty())
		{
			Map.Entry<Point, Integer> gameTile = sortedHeatmapTiles.poll();
			Point tilePixel = gameTile.getKey(); // tilePixel is the upper-left coordinate of the 4x4 pixel square that this tile covers
			tilePixel = gameCoordsToImageCoords(tilePixel);
			boolean isInImageBounds = (tilePixel.x >= 0 && tilePixel.y >= 0 && tilePixel.x < getWidth() && tilePixel.y < getHeight());
			int tileValue = gameTile.getValue();

			boolean pixelIsBeforeRegion = (compareNaturalReadingOrder(tilePixel.x, tilePixel.y, region.x, region.y) < 0);
			boolean pixelIsAfterRegion = (compareNaturalReadingOrder(tilePixel.x, tilePixel.y, region.x + region.width, region.y + region.height) > 0);
			// If current tile is after bottom right edge of current image region in reading order
			if (pixelIsAfterRegion)
			{
				// put it back in the front of the queue and return
				sortedHeatmapTiles.addFirst(gameTile);
				return;
			}
			// If current tile is before upper left edge of current image region, or is out of bounds, or hasn't been stepped on, skip this tile
			if (pixelIsBeforeRegion || !isInImageBounds || tileValue == 0)
			{
				continue;
			}
			// Else continue

			// Calculate color
			double currHue = calculateHue(tileValue, heatmapSensitivity, heatmapMinVal, heatmapMaxVal);
			// Reassign the new RGB values to the corresponding 9 pixels (each tile covers 3x3 image pixels)
			for (int x_offset = 0; x_offset < 4; x_offset++)
			{
				for (int y_offset = 0; y_offset < 4; y_offset++)
				{
					int curX = tilePixel.x - region.x + x_offset;
					int curY = tilePixel.y - region.y + y_offset;
					if (curY >= imageRegion.getHeight())
					{
						// put it back in the front of the queue and return
						sortedHeatmapTiles.addFirst(gameTile);
						return;
					}
					else if (curX >= imageRegion.getWidth()){
						// Skip this pixel
						continue;
					}
					int srcRGB = imageRegion.getRGB(curX, curY);
					int r = (srcRGB >> 16) & 0xFF;
					int g = (srcRGB >> 8) & 0xFF;
					int b = (srcRGB) & 0xFF;
					float brightness = Color.RGBtoHSB(r, g, b, null)[2] * (1 - heatmapTransparency) + heatmapTransparency;
					// convert HSB to RGB with the calculated Hue, with Saturation=1
					int currRGB = Color.HSBtoRGB((float) currHue, 1, brightness);
					imageRegion.setRGB(curX, curY, currRGB);
				}
			}
		}
	}

	private double calculateHue(int tileValue, int heatmapSensitivity, int minVal, int maxVal)
	{
		double nthRoot = 1 + (heatmapSensitivity - 1.0) / 2;
		int logBase = 4;
		double minHue = 1 / 3.0;
		double maxHue = 0.0;
		double currHue = (float) ((Math.log(tileValue) / Math.log(logBase)) / (Math.log(maxVal + 1 - minVal) / Math.log(logBase)));
		currHue = Math.pow(currHue, 1.0 / nthRoot);
		currHue = (float) (minHue + (currHue * (maxHue - minHue))); // Assign a hue based on normalized step value (values [0, 1] are mapped linearly to hues of [0, 0.333] aka green then yellow, then red)
		return currHue;
	}

	private int compareNaturalReadingOrder(int x1, int y1, int x2, int y2)
	{
		// This should return the difference in the row-major order of the two points
		int rowMajor1 = y1 * getWidth() + x1;
		int rowMajor2 = y2 * getWidth() + x2;
		return rowMajor1 - rowMajor2;
	}

	private void initializeProcessingVariables(HeatmapNew heatmap)
	{
		// Get min/max values within writeable region to be written
		int[] maxMin = calculateMaxMinValues(heatmap);
		heatmapMaxVal = maxMin[0];
		heatmapMinVal = maxMin[1];

		// Create sorted heatmap tiles array (sorted left-to-right top-to-bottom)
		sortedHeatmapTiles = new LinkedList<>(heatmap.getEntrySet());
		sortedHeatmapTiles.sort((tile1, tile2) -> {
			Point coords1 = tile1.getKey();
			Point coords2 = tile2.getKey();
			return compareNaturalReadingOrder(coords1.x, -coords1.y, coords2.x, -coords2.y);
		});
	}

	/**
	 * @param gameCoord True gameworld coordinate
	 * @return The upper-left of the 9-pixel square location on the image osrs_world_map.png that this game coordinate responds to (1 game coordinate = 3x3 pixels). If it is out of bounds, then (-1, -1) is returned
	 */
	public Point gameCoordsToImageCoords(Point gameCoord)
	{
		final int IMAGE_WIDTH = getWidth();
		final int IMAGE_HEIGHT = getHeight();
		gameCoord = remapGameTiles(gameCoord);
		Point pixelLocation = new Point(4 * gameCoord.x + PIXEL_OFFSET_X, IMAGE_HEIGHT - (4 * gameCoord.y) + PIXEL_OFFSET_Y);
		if (pixelLocation.x < 0 || pixelLocation.y < 0 || pixelLocation.x > IMAGE_WIDTH || pixelLocation.y > IMAGE_HEIGHT)
		{
			return new Point(-1, -1);
		}
		else
		{
			return pixelLocation;
		}
	}

	/**
	 * This function remaps game tiles, so for example steps made in Prifdinnas which is actually located outside the overworld will be remapped to Prifdinnas's overworld location
	 *
	 * @param point Old location
	 * @return New location
	 */
	private static Point remapGameTiles(Point point)
	{
		// Prifdinnas
		Rectangle prifdinnas = new Rectangle(3391, 5952, 255, 255);
		if (prifdinnas.contains(point))
		{
			return new Point(point.x - 1024, point.y - 2752);
		}

		return point;
	}
}
package com.worldheatmap;

import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

@Slf4j
public class HeatmapFile {
    protected final static String HEATMAP_EXTENSION = ".heatmaps";
    protected final static File WORLD_HEATMAP_DIR = new File(RUNELITE_DIR.toString(), "worldheatmap");
    protected final static File HEATMAP_FILES_DIR = Paths.get(WORLD_HEATMAP_DIR.toString(), "Heatmap Files").toFile();
    protected final static File HEATMAP_IMAGE_DIR = Paths.get(WORLD_HEATMAP_DIR.toString(), "Heatmap Images").toFile();
    protected final static SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd_hh-mm");
    
    /**
     * Return a new File in the correct directory and filename according to userId and time. Doesn't actually create the file, just a File object.
     * @return The new File
     */
    public static File getCurrentHeatmapFile(long userId) {
        String name = formatDate(new Date());
        File userIdDir = new File(HEATMAP_FILES_DIR, Long.toString(userId));

        return new File(userIdDir, name + HEATMAP_EXTENSION);
    }

    public static File getCurrentImageFile(long userId, HeatmapNew.HeatmapType type) {
        String name = formatDate(new Date());
        File userIdDir = new File(HEATMAP_IMAGE_DIR, Long.toString(userId));

        return new File(userIdDir, name + "_" + type + ".tif");
    }

    /**
     * Get the File that contains the latest heatmaps based on the filename being a date.
     * Returns null if no such file exists.
     * @return the youngest heatmaps file.
     */
    public static File getLatestHeatmapFile(long userId) {
        File userIdDir = new File(HEATMAP_FILES_DIR, Long.toString(userId));
        File mostRecent = getMostRecentFile(userIdDir);

        // Check legacy location if latest file not found
        if (mostRecent == null) {

            File legacyHeatmapsFile = new File(HEATMAP_FILES_DIR, userId + HEATMAP_EXTENSION);
            if (!legacyHeatmapsFile.exists()) {
                return null;
            }

            // Move the old file to the new location
            File destination = getCurrentHeatmapFile(userId);
            if (!destination.mkdirs()) {
                log.info("Couldn't make dirs to move heatmaps file from legacy (V2) location. Aborting move operation, but returning the file.");
                return legacyHeatmapsFile;
            }
            try {
                log.info("Moving heatmaps file from legacy (V2) location {} to new location {}", legacyHeatmapsFile, destination);
                Files.move(legacyHeatmapsFile.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING);
            } catch (IOException e) {
                log.info("Moving heatmaps file from legacy (V2) location failed:");
                log.info(e.toString());
                return legacyHeatmapsFile;
            }

            mostRecent = destination;
        }
        return mostRecent;
    }

    private static String formatDate(Date date) {
        return dateFormat.format(date);
    }

    /**
     * Returns the file in the given directory whose filename is the most recent parseable date string.
     * If no such file is found, returns null.
     * @param path the directory to search
     * @return the file with the most recent date in its filename, or null if no such file exists
     */
    private static File getMostRecentFile(File path) {

        File[] files = path.listFiles(File::isFile);
        if (files == null || files.length == 0) {
            // Return null if the heatmaps directory is empty, doesn't exist, or isn't a directory
            return null;
        }

        // Remove files from the list `files` if they're not parseable by dateFormat
        // so that unrelated files in the directory don't cause an exception
        files = Arrays.stream(files).filter(f -> {
            String n = f.getName();
            int pos = n.lastIndexOf(".");
            n = n.substring(0,pos);
            try {
                dateFormat.parse(n);
                return true;
            } catch (ParseException e) {
                return false;
            }
        }).toArray(File[]::new);

        Arrays.sort(files, (f1, f2) -> {
            try {
                String n1 = f1.getName();
                String n2 = f2.getName();
                int pos1 = n1.lastIndexOf(".");
                int pos2 = n2.lastIndexOf(".");
                n1 = n1.substring(0,pos1);
                n2 = n2.substring(0,pos2);

                Date d1 = dateFormat.parse(n1);
                Date d2 = dateFormat.parse(n2);
                return d2.compareTo(d1);

            } catch (ParseException e) {
                return 0;
            }
        });

        return files[0];
    }
}

package com.worldheatmap;

import java.awt.*;
import java.util.HashMap;
import java.util.Map;
import java.util.List;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.io.File;
import java.io.IOException;

@Slf4j
public class WorldHeatmapPanel extends PluginPanel {

    private final WorldHeatmapPlugin plugin;
    private JLabel playerIDLabel;

    private JLabel memoryUsageLabel;

    Map<HeatmapNew.HeatmapType, JPanel> heatmapPanels = new HashMap<>();
    Map<HeatmapNew.HeatmapType, JLabel> heatmapTotalValueLabels = new HashMap<>();
    Map<HeatmapNew.HeatmapType, JLabel> heatmapPanelLabels = new HashMap<>();
    Map<HeatmapNew.HeatmapType, JButton> writeHeatmapImageButtons = new HashMap<>();
    Map<HeatmapNew.HeatmapType, JButton> clearHeatmapButtons = new HashMap<>();
    protected long mostRecentLocalUserID;

    public WorldHeatmapPanel(WorldHeatmapPlugin plugin) {
        this.plugin = plugin;
        rebuild();
    }

    protected void rebuild() {
        removeAll();
        Font buttonFont = new Font("Runescape", Font.BOLD, 18);
        Font sectionLabelFont = new Font("Runescape", Font.BOLD, 18);

        //Main Panel
        int vGap = 5;
        int hGap = 5;
        JPanel mainPanel = new JPanel(new GridLayout(0, 1, hGap, vGap));
        mainPanel.setBorder(new EmptyBorder(vGap, hGap, vGap, hGap));
        mainPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        //Player ID label
        if (mostRecentLocalUserID == 0 || mostRecentLocalUserID == -1){
            playerIDLabel = new JLabel("Player ID: unknown");
        }
        else{
            playerIDLabel = new JLabel("Player ID: " + mostRecentLocalUserID);
        }
        playerIDLabel.setHorizontalAlignment(SwingConstants.CENTER);
        mainPanel.add(playerIDLabel);

        // Total Memory Usage estimate label
        int estimatedMemoryUsage = 0;
        for (HeatmapNew heatmap : plugin.heatmaps.values()) {
            estimatedMemoryUsage += HeatmapNew.estimateSize(heatmap);
        }
        memoryUsageLabel = new JLabel("Estimated Memory Usage: " + String.format("%.2f", estimatedMemoryUsage / 1024. / 1024) +  "MB");
        memoryUsageLabel.setHorizontalAlignment(SwingConstants.CENTER);
        mainPanel.add(memoryUsageLabel);

        //'Open Heatmaps Folder' button
        JButton openHeatmapFolderButton = new JButton("Open Heatmaps Folder");
        openHeatmapFolderButton.setFont(buttonFont);
        openHeatmapFolderButton.addActionListener(e -> {
            try {
                openHeatmapsFolder();
            } catch (IOException exception) {
                log.error("Error: Exception thrown whilst opening worldheatmap folder: " + exception.getMessage());
            }
        });
        mainPanel.add(openHeatmapFolderButton);
        add(mainPanel);

        // Create the panels/buttons for each loaded Heatmap type
        for (HeatmapNew.HeatmapType heatmapType : HeatmapNew.HeatmapType.values()) {
            // Do not create panels for disabled heatmaps
            if (!plugin.isHeatmapEnabled(heatmapType)) {
                continue;
            }
            //Panel
            JPanel heatmapPanel = new JPanel(new GridLayout(0, 1, hGap, vGap));
            heatmapPanel.setBorder(new EmptyBorder(vGap, hGap, vGap, hGap));
            heatmapPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            heatmapPanels.put(heatmapType, heatmapPanel);

            //Label
            JLabel heatmapLabel = new JLabel(heatmapType.toString());
            heatmapPanelLabels.put(heatmapType, heatmapLabel);
            heatmapLabel.setFont(sectionLabelFont);
            heatmapLabel.setForeground(Color.WHITE);
            heatmapLabel.setHorizontalAlignment(SwingConstants.CENTER);
            if (plugin.heatmaps.get(heatmapType) != null){
                heatmapLabel.setToolTipText("Estimated memory usage: " + String.format("%.2f", HeatmapNew.estimateSize(plugin.heatmaps.get(heatmapType)) / 1024. / 1024) + "MB");
            }
            else {
                heatmapLabel.setToolTipText("Estimated memory usage: 0MB");
            }

            heatmapPanel.add(heatmapLabel);

            //'Write Heatmap Image' button
            JButton writeHeatmapImageButton = new JButton("Write Heatmap Image");
            writeHeatmapImageButton.setFont(buttonFont);
            writeHeatmapImageButton.addActionListener(e -> writeHeatmapImage(heatmapType, plugin.config.isWriteFullImageEnabled()));
            writeHeatmapImageButtons.put(heatmapType, writeHeatmapImageButton);
            heatmapPanel.add(writeHeatmapImageButton);

            //'Restart Heatmap' button
            JButton clearHeatmapButton = new JButton("Restart Heatmap");
            clearHeatmapButton.setFont(buttonFont);
            clearHeatmapButton.addActionListener(e -> {
                final int result = JOptionPane.showOptionDialog(heatmapPanel,
                        "<html>Art thou sure you want to restart your " + heatmapType + " heatmap? The data will be lost.</html>",
                        "Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                        null, new String[]{"Yes", "No"}, "No");

                if (result == JOptionPane.YES_OPTION) {
                    clearHeatmap(heatmapType);
                }
            });
            clearHeatmapButtons.put(heatmapType, clearHeatmapButton);
            heatmapPanel.add(clearHeatmapButton);

            // Total value label
            JLabel heatmapTotalValueLabel = new JLabel("Total value: 0");
            heatmapTotalValueLabel.setHorizontalAlignment(SwingConstants.CENTER);
            heatmapTotalValueLabels.put(heatmapType, heatmapTotalValueLabel);
            heatmapPanel.add(heatmapTotalValueLabel);

            add(heatmapPanel);
        }
    }

    protected void updatePlayerID() {
        this.mostRecentLocalUserID = plugin.mostRecentLocalUserID;
        if (this.mostRecentLocalUserID == -1 || this.mostRecentLocalUserID == 0) {
            playerIDLabel = new JLabel("Player ID: unavailable");
        } else {
            playerIDLabel.setText("Player ID: " + this.mostRecentLocalUserID);
        }
        updateUI();
    }

    protected void updateCounts() {
        for (HeatmapNew.HeatmapType heatmapType : plugin.heatmaps.keySet()) {
            if (heatmapTotalValueLabels.get(heatmapType) != null) {
                heatmapTotalValueLabels.get(heatmapType).setText("Total value: " + plugin.heatmaps.get(heatmapType).getTotalValue());
            }
        }
        updateUI();
    }

    protected void updateMemoryUsages() {
        int estimatedTotalMemoryUsage = 0;
        for (HeatmapNew heatmap : plugin.heatmaps.values()) {
            estimatedTotalMemoryUsage += HeatmapNew.estimateSize(heatmap);
            memoryUsageLabel.setText("Estimated Memory Usage: " + String.format("%.2f", estimatedTotalMemoryUsage / 1024. / 1024) +  "MB");
            if (heatmapPanelLabels.get(heatmap.getHeatmapType()) != null) {
                heatmapPanelLabels.get(heatmap.getHeatmapType()).setToolTipText("Estimated memory usage: " + String.format("%.2f", HeatmapNew.estimateSize(heatmap) / 1024. / 1024) + "MB");
            }
        }
        updateUI();
    }

    private void writeHeatmapImage(HeatmapNew.HeatmapType heatmapType, boolean isFullMapImage) {
        // Save all heatmap data
        File latestFile = HeatmapFile.getLatestHeatmapFile(mostRecentLocalUserID);
        File newFile = HeatmapFile.getCurrentHeatmapFile(mostRecentLocalUserID);
        File heatmapFile = latestFile != null ? latestFile : newFile;
        File imageFile = HeatmapFile.getCurrentImageFile(mostRecentLocalUserID, heatmapType);
        plugin.worldHeatmapPluginExecutor.execute(() -> HeatmapNew.writeHeatmapsToFile(plugin.getEnabledHeatmaps(), heatmapFile, null));
        // Write the specified heatmap image
        HeatmapNew heatmap = plugin.heatmaps.get(heatmapType);
        plugin.worldHeatmapPluginExecutor.execute(() -> HeatmapImage.writeHeatmapImage(heatmap, imageFile, isFullMapImage, plugin.config.heatmapAlpha(), plugin.config.heatmapSensitivity(), plugin.config.speedMemoryTradeoff(), new WorldHeatmapPlugin.HeatmapProgressListener(plugin, heatmapType)));
    }

    private void clearHeatmap(HeatmapNew.HeatmapType heatmapType) {
        // Replace the heatmap with a new one
        plugin.heatmaps.put(heatmapType, new HeatmapNew(heatmapType, plugin.mostRecentLocalUserID));
        List<HeatmapNew> heatmap = List.of(plugin.heatmaps.get(heatmapType));

        // Write new .heatmaps data file, so the current (now old) one can be kept as a backup
        File latestHeatmapFile = HeatmapFile.getLatestHeatmapFile(mostRecentLocalUserID);
        File newHeatmapFile = HeatmapFile.getCurrentHeatmapFile(mostRecentLocalUserID);
        plugin.worldHeatmapPluginExecutor.execute(() -> HeatmapNew.writeHeatmapsToFile(heatmap, newHeatmapFile, latestHeatmapFile));
    }

    private void openHeatmapsFolder() throws IOException {
        if (!plugin.WORLD_HEATMAP_DIR.exists()) {
            if (!plugin.WORLD_HEATMAP_DIR.mkdirs()) {
                log.error("Error: was not able to create worldheatmap folder");
            }
        }
        Desktop.getDesktop().open(plugin.WORLD_HEATMAP_DIR);
    }

    void setEnabledHeatmapButtons(boolean onOff) {
        // Disable write heatmap image buttons
        for (JButton writeButton : writeHeatmapImageButtons.values()) {
            writeButton.setEnabled(onOff);
        }
        // Disable clear heatmap buttons
        for (JButton clearButton : clearHeatmapButtons.values()) {
            clearButton.setEnabled(onOff);
        }
    }

}

package com.worldheatmap;

import java.io.Serializable;

public class Heatmap implements Serializable {

    private final int WIDTH, HEIGHT, HEATMAP_OFFSET_X, HEATMAP_OFFSET_Y;
    protected final static int TYPE_A = 0, TYPE_B = 1;
    private int[][] heatmap;
    private int stepCount;

    public Heatmap(int WIDTH, int HEIGHT, int HEATMAP_OFFSET_X, int HEATMAP_OFFSET_Y){
        this.WIDTH = WIDTH;
        this.HEIGHT = HEIGHT;
        this.HEATMAP_OFFSET_Y = HEATMAP_OFFSET_Y;
        this.HEATMAP_OFFSET_X = HEATMAP_OFFSET_X;
        stepCount = 0;
        createHeatmap();
    }

    private void createHeatmap(){
        heatmap = new int[WIDTH][HEIGHT];
    }

    protected boolean isInBounds(int x, int y){
        return (x + HEATMAP_OFFSET_X < WIDTH && y + HEATMAP_OFFSET_Y < HEIGHT);
    }

    /**
     * Sets the heatmap's value at the given location to the given value
     * @param val New value
     * @param x Original RuneScape x-coord
     * @param y Original RuneScape y-coord
     */
    protected void set(int val, int x, int y){
        int convertedX = x + HEATMAP_OFFSET_X;	//These offsets are to reconcile the matrix 'heatmap' being much smaller than the game coordinate domain (which is much larger than the explorable area)
        int convertedY = y + HEATMAP_OFFSET_Y;
        heatmap[convertedX][convertedY] = val;
    }

    /**
     * Returns the heatmap's value at the given location
     * @param x Original RuneScape x-coord
     * @param y Original RuneScape y-coord
     */
    protected int get(int x, int y){
        int convertedX = x + HEATMAP_OFFSET_X;	//These offsets are to reconcile the matrix 'heatmap' being much smaller than the game coordinate domain (which is much larger than the explorable area)
        int convertedY = y + HEATMAP_OFFSET_Y;
        return heatmap[convertedX][convertedY];
    }

    /**
     * Returns the heatmap's value at the given location according to the internal coordinate style (it's offset from the RuneScape coordinates)
     * @param x Heatmap-style x-coord
     * @param y Heatmap-style y-coord
     */
    protected int heatmapCoordsGet(int x, int y){
        return heatmap[x][y];
    }

    /**
     * Increments the heatmap's value at the given location by 1
     * @param x Original RuneScape x-coord
     * @param y Original RuneScape y-coord
     */
    protected void increment(int x, int y) {
        set(get(x, y) + 1, x, y);
        stepCount++;
    }

    protected int getStepCount(){
        return stepCount;
    }

    /**
     * @return int array holding {maxVal, maxX, maxY} where the latter two are the coordinate at which the max value exists
     */
    protected int[] getMaxVal(){
        int maxVal = 0, maxX = 0, maxY = 0;
        for (int y = 0; y < HEIGHT; y++)
            for (int x = 0; x < WIDTH; x++)
                if (heatmapCoordsGet(x, y) > maxVal) {
                    maxVal = heatmapCoordsGet(x, y);
                    maxX = x;
                    maxY = y;
                }
        return new int[]{maxVal, maxX, maxY};
    }

    /**
     * @return int array holding {minVal, minX, minY} where the latter two are the coordinate at which the minimum NON-ZERO value exists
     */
    protected int[] getMinVal(){
        int minVal = Integer.MAX_VALUE, minX = 0, minY = 0;
        for (int y = 0; y < HEIGHT; y++)
            for (int x = 0; x < WIDTH; x++)
                if (heatmapCoordsGet(x, y) != 0 && heatmapCoordsGet(x, y) < minVal) {
                    minVal = heatmapCoordsGet(x, y);
                    minX = x;
                    minY = y;
                }
        if (minVal > Integer.MAX_VALUE - 100)
            return new int[]{0, 0, 0};
        else
            return new int[]{minVal, minX, minY};
    }
}

package com.worldheatmap;

import java.awt.Point;
import java.io.*;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.Map.Entry;
import java.util.zip.InflaterInputStream;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.annotation.Nullable;

@Slf4j
public class HeatmapNew
{
	@Getter
	private final HashMap<Point, Integer> heatmapHashMap;
	@Getter
	private static final int heatmapVersion = 100;
	@Getter
	private long totalValue = 0;
	@Getter
	private int numTilesVisited = 0;
	@Getter @Setter
	private int gameTimeTicks = 0;
	private int[] maxVal = {1, 0, 0}, minVal = {1, 0, 0}; // {val, x, y}
	private static final int
		HEATMAP_WIDTH = 2752,       //never change these
		HEATMAP_HEIGHT = 1664,      //never change these
		HEATMAP_OFFSET_X = -1152,   //never change these
		HEATMAP_OFFSET_Y = -2496;   //never change these (for backwards compatibility)
	@Getter
	private long userID = -1;

	/**
	 * Loads, converts, and returns .heatmap file of legacy style as a HeatmapNew.
	 * If the file isn't actually a legacy .heatmap file, throws an exception.
	 * @param heatmapFile The .heatmap file
	 * @return HeatmapNew object
	 */
	static HeatmapNew readLegacyV1HeatmapFile(File heatmapFile, long mostRecentLocalUserID) {
		try (FileInputStream fis = new FileInputStream(heatmapFile);
			 InflaterInputStream iis = new InflaterInputStream(fis);
			 ObjectInputStream ois = new ObjectInputStream(iis)) {
			Heatmap heatmap = (Heatmap) ois.readObject();
			long startTime = System.nanoTime();
			HeatmapNew result = convertOldHeatmapToNew(heatmap, mostRecentLocalUserID);
			return result;
		} catch (Exception e) {
			log.error("Exception occurred while reading legacy heatmap file '{}'", heatmapFile.getName());
			throw new RuntimeException(e);
		}
	}

	public enum HeatmapType
		{TYPE_A, TYPE_B, XP_GAINED, TELEPORT_PATHS, TELEPORTED_TO, TELEPORTED_FROM, LOOT_VALUE, PLACES_SPOKEN_AT, RANDOM_EVENT_SPAWNS, DEATHS, NPC_DEATHS, BOB_THE_CAT_SIGHTING, DAMAGE_TAKEN, DAMAGE_GIVEN, UNKNOWN}
	@Getter @Setter
	private HeatmapType heatmapType;

	public HeatmapNew(HeatmapType heatmapType)
	{
		this.heatmapType = heatmapType;
		this.heatmapHashMap = new HashMap<>();
	}

	public HeatmapNew(HeatmapType heatmapType, long userID)
	{
		this.heatmapType = heatmapType;
		this.heatmapHashMap = new HashMap<>();
		this.userID = userID;
	}

	public static HeatmapNew convertOldHeatmapToNew(Heatmap oldStyle, long userId)
	{
		return convertOldHeatmapToNew(oldStyle, HeatmapType.UNKNOWN, userId);
	}

	// The following horse shit is for backwards compatibility with the old, retarded method of storing heatmap data
	public static HeatmapNew convertOldHeatmapToNew(Heatmap oldStyle, HeatmapType type, long userId)
	{
		HeatmapNew newStyle = new HeatmapNew(type, userId);
		for (int x = 0; x < HEATMAP_WIDTH; x++)
		{
			for (int y = 0; y < HEATMAP_HEIGHT; y++)
			{
				if (oldStyle.heatmapCoordsGet(x, y) != 0)
				{
					newStyle.set(x - HEATMAP_OFFSET_X, y - HEATMAP_OFFSET_Y, oldStyle.heatmapCoordsGet(x, y));
				}
			}
		}
		return newStyle;
	}

	protected Set<Entry<Point, Integer>> getEntrySet()
	{
		return heatmapHashMap.entrySet();
	}

	public void incrementGameTimeTicks()
	{
		this.gameTimeTicks++;
	}

	/**
	 * Increments the heatmap's value at the given location by the amount specified
	 *
	 * @param x      Original RuneScape x-coord
	 * @param y      Original RuneScape y-coord
	 * @param amount Amount to increment the value by
	 */
	protected void increment(int x, int y, int amount)
	{
		set(x, y, get(x, y) + amount);
	}

	/**
	 * Increments the heatmap's value at the given location by 1
	 *
	 * @param x Original RuneScape x-coord
	 * @param y Original RuneScape y-coord
	 */
	protected void increment(int x, int y)
	{
		set(x, y, get(x, y) + 1);
	}

	/**
	 * Sets the heatmap's value at the given location to the given value. If the value is 0, the tile is removed from the heatmap. If the value is negative, nothing happens.
	 *
	 * @param newValue New value
	 * @param x        Original RuneScape x-coord
	 * @param y        Original RuneScape y-coord
	 */
	protected void set(int x, int y, int newValue)
	{
		//We don't keep track of unstepped-on tiles
		if (newValue < 0)
		{
			return;
		}

		//Set it & retrieve previous value
		Integer oldValue = heatmapHashMap.put(new Point(x, y), newValue);

		//Update numTilesVisited
		if (oldValue == null && newValue > 0)
		{
			numTilesVisited++;
		}
		else if (oldValue != null && newValue == 0)
		{
			numTilesVisited--;
		}

		//Update total value
		if (oldValue == null)
		{
			totalValue += newValue;
		}
		else
		{
			totalValue += (newValue - oldValue);
		}

		//Error checking for not keeping track of unstepped-on tiles
		if (newValue == 0)
		{
			heatmapHashMap.remove(new Point(x, y));
			// If the removed tile was the most stepped on, then we have
			// no choice but to recalculate the new most stepped on tile
			if (x == maxVal[1] && y == maxVal[2])
			{
				int[] newMax = {1, 0, 0};
				for (Entry<Point, Integer> e : heatmapHashMap.entrySet())
				{
					if (newMax[0] >= e.getValue())
					{
						newMax[0] = e.getValue();
						newMax[1] = e.getKey().x;
						newMax[2] = e.getKey().y;
					}
				}
				maxVal = newMax;
			}
			// It's super unlikely that a removed tile will have been the least
			// stepped on, so I'm just not even gon bother writing error checking for it lul
			return;
		}

		//Update min/max vals
		if (newValue > maxVal[0])
		{
			maxVal = new int[]{newValue, x, y};
		}
		if (newValue <= minVal[0])
		{
			minVal = new int[]{newValue, x, y};
		}
	}

	/**
	 * Returns the estimated total memory usage of the heatmap, in bytes, assuming 64 bit JVM and 8-byte alignment. Relatively expensive to run because it has to iterate through the entire hashmap.
	 * @return size in bytes
	 */
	public static int estimateSize(HeatmapNew heatmap){
		int estSize = 0;
		// Get count of values above and below 128
		for (Entry<Point, Integer> e : heatmap.getEntrySet())
		{
			int nodeSize = 16 + 8 + 8 + 4 + 4; //16 bytes for Node  object, 8 and 8 for the key and value references, 4 for the hash value, then extra 4 for 8-byte alignment
			int pointSize = 16 + 4 + 4; //16 bytes for Point object header, then 8 for each of the two int coords
			int integerSize = (e.getValue() < 128 ? 8 : 16 + 4 + 4); //8 bytes for just header of pooled Integer, or 12 bytes for non-pooled Integer header plus inner int plus 4 bytes for 8-byte alignment
			estSize += nodeSize + pointSize + integerSize;
		}
		return estSize;
	}

	/**
	 * Returns the heatmap's value at the given game world location. If the tile has not been stepped on, returns 0.
	 *
	 * @param x Heatmap-style x-coord
	 * @param y Heatmap-style y-coord
	 */
	protected int get(int x, int y)
	{
		return heatmapHashMap.getOrDefault(new Point(x, y), 0);
	}

	/**
	 * @return int array holding {maxVal, maxX, maxY} where the latter two are the coordinate at which the max value exists
	 */
	protected int[] getMaxVal()
	{
		return maxVal;
	}

	/**
	 * @return int array holding {minVal, minX, minY} where the latter two are the coordinate at which the minimum NON-ZERO value exists
	 */
	protected int[] getMinVal()
	{
		return minVal;
	}

	/**
	 * Writes the provided heatmap data to the specified .heatmaps file. Unprovided heatmaps are carried over from the file previousHeatmapsFile, if it has them.
	 */
	protected static void writeHeatmapsToFile(Collection<HeatmapNew> heatmapsToWrite, File heatmapsFile, @Nullable File previousHeatmapsFile) {
		// Preamble
		log.debug("Saving heatmaps to file '{}'...", heatmapsFile.getName());
		long startTime = System.nanoTime();
		StringBuilder loggingOutput = new StringBuilder("Heatmap types saved: ");

		// Make the directory path if it doesn't exist
		if (!Files.exists(Paths.get(heatmapsFile.getParent()))) {
			if (!new File(heatmapsFile.getParent()).mkdirs()) {
				log.error("Could not create the directory for the heatmap file");
			}
		}

		// Copy previousHeatmapsFile to heatmapsFile (if it exists)
		// in order to carry over unprovided heatmaps before updating
		if (previousHeatmapsFile != null && previousHeatmapsFile.exists()) {
			try {
				Files.copy(previousHeatmapsFile.toPath(), heatmapsFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
			} catch (IOException e) {
				log.error("Error copying latest heatmaps file to new location");
				return;
			}
		}

		// Zip reading params
		Map<String, String> env = new HashMap<>();
		env.put("create", "true");
		URI uri = URI.create("jar:" + heatmapsFile.toURI());

		for (HeatmapNew heatmap : heatmapsToWrite) {
			// Write the heatmap file
			try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {
				Path zipEntryFile = fs.getPath("/" + heatmap.getHeatmapType().toString() + "_HEATMAP.csv");
				try (OutputStreamWriter osw = new OutputStreamWriter(Files.newOutputStream(zipEntryFile), StandardCharsets.UTF_8)) {
					// Write them field variables
					osw.write("userID,heatmapVersion,heatmapType,totalValue,numTilesVisited,maxVal,maxValX,maxValY,minVal,minValX,minValY,gameTimeTicks\n");
					osw.write(heatmap.getUserID() +
							"," + getHeatmapVersion() +
							"," + heatmap.getHeatmapType() +
							"," + heatmap.getTotalValue() +
							"," + heatmap.getNumTilesVisited() +
							"," + heatmap.getMaxVal()[0] +
							"," + heatmap.getMaxVal()[1] +
							"," + heatmap.getMaxVal()[2] +
							"," + heatmap.getMinVal()[0] +
							"," + heatmap.getMinVal()[1] +
							"," + heatmap.getMinVal()[2] +
							"," + heatmap.getGameTimeTicks() + "\n");
					// Write the tile values
					for (Entry<Point, Integer> e : heatmap.getEntrySet()) {
						int x = e.getKey().x;
						int y = e.getKey().y;
						int stepVal = e.getValue();
						osw.write(x + "," + y + "," + stepVal + "\n");
					}
					osw.flush();
				}

			} catch (IOException e) {
                log.error("World Heatmap was not able to save heatmap type '{}' to file '{}'", heatmap.getHeatmapType(), heatmapsFile.getName());
				e.printStackTrace();
				return;
			}
			loggingOutput.append(heatmap.getHeatmapType() + " (" + heatmap.getNumTilesVisited() + " tiles), ");
		}

		log.debug(loggingOutput.toString());
        log.debug("Finished writing '{}' heatmap file to disk after {} ms", heatmapsFile.getName(), (System.nanoTime() - startTime) / 1_000_000);
	}

	/**
	 * Loads the specified heatmap types from the given .heatmaps file.
	 *
	 * @param heatmapsFile The .heatmaps file
	 * @param types        The heatmap types to load
	 * @return HashMap of HeatmapNew objects
	 * @throws FileNotFoundException If the file does not exist
	 */
	static HashMap<HeatmapType, HeatmapNew> readHeatmapsFromFile(File heatmapsFile, Collection<HeatmapType> types) throws FileNotFoundException {
		Map<String, String> env = new HashMap<>();
		env.put("create", "true");
		URI uri = URI.create("jar:" + heatmapsFile.toURI());
		try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {
			HashMap<HeatmapType, HeatmapNew> heatmapsRead = new HashMap<>();
			StringBuilder loggingOutput = new StringBuilder();
			loggingOutput.append("Heatmap types loaded: ");

			for (HeatmapType curType : types) {
				Path curHeatmapPath = fs.getPath("/" + curType.toString() + "_HEATMAP.csv");
				if (!Files.exists(curHeatmapPath)) {
					continue;
				}
				try (InputStreamReader isr = new InputStreamReader(Files.newInputStream(curHeatmapPath), StandardCharsets.UTF_8);
					 BufferedReader reader = new BufferedReader(isr)) {
					// Read them field variables
					String[] fieldNames = reader.readLine().split(",");
					String[] fieldValues = reader.readLine().split(",");
					long userID = (fieldValues[0].isEmpty() ? -1 : Long.parseLong(fieldValues[0]));
					String heatmapTypeString = fieldValues[2];
					int totalValue = (fieldValues[3].isEmpty() ? -1 : Integer.parseInt(fieldValues[3]));
					int numTilesVisited = (fieldValues[4].isEmpty() ? -1 : Integer.parseInt(fieldValues[4]));
					int maxVal = (fieldValues[5].isEmpty() ? -1 : Integer.parseInt(fieldValues[5]));
					int maxValX = (fieldValues[6].isEmpty() ? -1 : Integer.parseInt(fieldValues[6]));
					int maxValY = (fieldValues[7].isEmpty() ? -1 : Integer.parseInt(fieldValues[7]));
					int minVal = (fieldValues[8].isEmpty() ? -1 : Integer.parseInt(fieldValues[8]));
					int minValX = (fieldValues[9].isEmpty() ? -1 : Integer.parseInt(fieldValues[9]));
					int minValY = (fieldValues[10].isEmpty() ? -1 : Integer.parseInt(fieldValues[10]));
					int gameTimeTicks = (fieldValues[11].isEmpty() ? -1 : Integer.parseInt(fieldValues[11]));

					// Get HeatmapType from field value if legit
					HeatmapType recognizedHeatmapType;
					if (Arrays.stream(HeatmapType.values()).noneMatch(type -> type.toString().equals(heatmapTypeString))) {
                        log.debug("Heatmap type '{}' from ZipEntry '{}' is not a valid Heatmap type (at least in this program version). Ignoring...", heatmapTypeString, curHeatmapPath);
						// Stop reading and go to next Heatmap type
						continue;
					} else {
						recognizedHeatmapType = HeatmapType.valueOf(heatmapTypeString);
					}

					// Make ze Heatmap
					HeatmapNew heatmap = new HeatmapNew(recognizedHeatmapType, userID);
					// Add le metadata to it
					heatmap.setGameTimeTicks(gameTimeTicks);

					// Read and load the tile values
					final int[] errorCount = {0}; // Number of parsing errors occurred during read
					reader.lines().forEach(s -> {
						String[] tile = s.split(",");
						try {
							heatmap.set(Integer.parseInt(tile[0]), Integer.parseInt(tile[1]), Integer.parseInt(tile[2]));
						} catch (NumberFormatException e) {
							errorCount[0]++;
						}
					});
					if (errorCount[0] != 0) {
                        log.error("{} errors occurred during {} heatmap file read.", errorCount[0], recognizedHeatmapType);
					}
					loggingOutput.append(recognizedHeatmapType + " (" + numTilesVisited + " tiles), ");
					heatmapsRead.put(recognizedHeatmapType, heatmap);
				} catch (IOException e) {
                    log.error("Error reading {} heatmap from .heatmaps entry '{}'", curType, curHeatmapPath);
				}
			}
			log.debug(loggingOutput.toString());
			return heatmapsRead;
		} catch (FileNotFoundException e) {
			throw e;
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
}
package com.worldheatmap;

import com.google.inject.Provides;

import java.awt.*;
import java.awt.Point;
import java.io.*;
import java.nio.file.*;
import java.time.Instant;
import java.util.*;
import java.util.List;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import javax.imageio.ImageWriter;
import javax.imageio.event.IIOWriteProgressListener;
import javax.inject.Inject;
import javax.swing.*;

import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.ClientToolbar;

import java.awt.image.BufferedImage;
import java.util.concurrent.*;

import net.runelite.client.game.ItemManager;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

@Slf4j
@PluginDescriptor(
        name = "World Heatmap"
)
public class WorldHeatmapPlugin extends Plugin {
    private static final int HEATMAP_AUTOSAVE_FREQUENCY = 3000; // How often to autosave the .heatmap file (in ticks)
    private int lastX = 0;
    private int lastY = 0;
    protected long mostRecentLocalUserID;
    private boolean shouldLoadHeatmaps;
    protected final File WORLD_HEATMAP_DIR = new File(RUNELITE_DIR.toString(), "worldheatmap");
    protected final File HEATMAP_FILES_DIR = Paths.get(WORLD_HEATMAP_DIR.toString(), "Heatmap Files").toFile();
    protected Map<HeatmapNew.HeatmapType, HeatmapNew> heatmaps = new HashMap<>();
    private NavigationButton toolbarButton;
    protected WorldHeatmapPanel panel;
    private final ArrayList<Integer> randomEventNPCIDs = new ArrayList<>(Arrays.asList(NpcID.BEE_KEEPER_6747,
            NpcID.CAPT_ARNAV,
            NpcID.DRUNKEN_DWARF,
            NpcID.FLIPPA_6744,
            NpcID.GILES,
            NpcID.GILES_5441,
            NpcID.MILES,
            NpcID.MILES_5440,
            NpcID.NILES,
            NpcID.NILES_5439,
            NpcID.PILLORY_GUARD,
            NpcID.POSTIE_PETE_6738,
            NpcID.RICK_TURPENTINE,
            NpcID.RICK_TURPENTINE_376,
            NpcID.SERGEANT_DAMIEN_6743,
            NpcID.FREAKY_FORESTER_6748,
            NpcID.FROG_5429,
            NpcID.GENIE,
            NpcID.GENIE_327,
            NpcID.DR_JEKYLL,
            NpcID.DR_JEKYLL_314,
            NpcID.EVIL_BOB,
            NpcID.EVIL_BOB_6754,
            NpcID.LEO_6746,
            NpcID.MYSTERIOUS_OLD_MAN_6751,
            NpcID.MYSTERIOUS_OLD_MAN_6750,
            NpcID.MYSTERIOUS_OLD_MAN_6752,
            NpcID.MYSTERIOUS_OLD_MAN_6753,
            NpcID.QUIZ_MASTER_6755,
            NpcID.DUNCE_6749,
            NpcID.SANDWICH_LADY,
            NpcID.STRANGE_PLANT));
    Map<Integer, Instant> timeLastSeenBobTheCatPerWorld = new HashMap<>();
    @Inject
    ItemManager itemManager;
    private final int[] previousXP = new int[Skill.values().length];
    protected String mostRecentLocalUserName;
    private Future<?> loadHeatmapsFuture;

    @Inject
    private Client client;

    @Inject
    protected ScheduledExecutorService worldHeatmapPluginExecutor;

    @Inject
    WorldHeatmapConfig config;

    @Inject
    private ClientToolbar clientToolbar;

    @Provides
    WorldHeatmapConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(WorldHeatmapConfig.class);
    }

    @SneakyThrows
    protected void loadHeatmaps() {
        log.debug("Loading most recent heatmaps under user ID {}...", mostRecentLocalUserID);
        File latestHeatmapsFile = HeatmapFile.getLatestHeatmapFile(mostRecentLocalUserID);

        // Load all heatmaps from the file
        if (latestHeatmapsFile != null && latestHeatmapsFile.exists()) {
            heatmaps = HeatmapNew.readHeatmapsFromFile(latestHeatmapsFile, getEnabledHeatmapTypes());
        }

        handleLegacyV1HeatmapFiles();

        initializeMissingHeatmaps(heatmaps, mostRecentLocalUserID);
        panel.setEnabledHeatmapButtons(true);
    }

    /**
     * Handles loading of legacy V1 heatmap files by converting them to the new format, saving the new files, and renaming the old files to '.old'
     */
    private void handleLegacyV1HeatmapFiles() {
        File filepathTypeAUsername = new File(HEATMAP_FILES_DIR.toString(), mostRecentLocalUserName + "_TypeA.heatmap");
        if (filepathTypeAUsername.exists()) {
            // Load and convert the legacy heatmap file
            HeatmapNew legacyHeatmapTypeA = HeatmapNew.readLegacyV1HeatmapFile(filepathTypeAUsername, mostRecentLocalUserID);
            // Define the heatmap type as TYPE_A
            legacyHeatmapTypeA.setHeatmapType(HeatmapNew.HeatmapType.TYPE_A);
            // Check if a Type A heatmap has already been loaded
            boolean typeAAlreadyLoaded = heatmaps.get(HeatmapNew.HeatmapType.TYPE_A) != null;
            if (!typeAAlreadyLoaded){
                // Load heatmap from legacy file
                log.info("Loading Type A legacy (V1) heatmap file for user ID {}...", mostRecentLocalUserID);
                heatmaps.put(HeatmapNew.HeatmapType.TYPE_A, legacyHeatmapTypeA);
                // Save as new file type
                saveNewHeatmapsFile();
            }
            // Append '.old' to legacy file name
            File oldFile = new File(filepathTypeAUsername + ".old");
            filepathTypeAUsername.renameTo(oldFile);
        }

        // Repeat for Type B
        File filepathTypeBUsername = new File(HEATMAP_FILES_DIR.toString(), mostRecentLocalUserName + "_TypeB.heatmap");
        if (filepathTypeBUsername.exists()) {
            HeatmapNew legacyHeatmapTypeB = HeatmapNew.readLegacyV1HeatmapFile(filepathTypeBUsername, mostRecentLocalUserID);
            legacyHeatmapTypeB.setHeatmapType(HeatmapNew.HeatmapType.TYPE_B);
            boolean newerTypeBExists = heatmaps.get(HeatmapNew.HeatmapType.TYPE_B) != null;
            if (!newerTypeBExists){
                // Load heatmap from legacy file
                log.info("Loading Type B legacy (V1) heatmap file for user ID {}...", mostRecentLocalUserID);
                heatmaps.put(HeatmapNew.HeatmapType.TYPE_B, legacyHeatmapTypeB);
                // Save as new file type
                saveNewHeatmapsFile();
            }
            // Append '.old' to legacy file name
            File oldFile = new File(filepathTypeBUsername + ".old");
            filepathTypeBUsername.renameTo(oldFile);
        }

        // Append .old to Paths.get(HEATMAP_FILES_DIR, "Backups") folder if it exists
        File backupDir = Paths.get(HEATMAP_FILES_DIR.toString(), "Backups").toFile();
        if (backupDir.exists()) {
            File oldBackupDir = new File(backupDir.toString() + ".old");
            backupDir.renameTo(oldBackupDir);
        }
    }

    @Override
    protected void startUp() {
        shouldLoadHeatmaps = true;
        loadHeatmapsFuture = null;
        panel = new WorldHeatmapPanel(this);
        panel.rebuild();
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/WorldHeatmap.png");
        toolbarButton = NavigationButton.builder()
                .tooltip("World Heatmap")
                .icon(icon)
                .priority(5)
                .panel(panel)
                .build();
        clientToolbar.addNavigation(toolbarButton);
        panel.setEnabledHeatmapButtons(false);
    }

    @Override
    protected void shutDown() {
        if (loadHeatmapsFuture != null && loadHeatmapsFuture.isDone()) {
            saveCurrentHeatmapsFile();
        }
        clientToolbar.removeNavigation(toolbarButton);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (gameStateChanged.getGameState() == GameState.LOGGING_IN) {
            shouldLoadHeatmaps = true;
            loadHeatmapsFuture = null;
        }

        // If you're at the login screen and heatmaps have already been loaded (implying that you were previously logged in, but now you're logged out)
        if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN && loadHeatmapsFuture != null && loadHeatmapsFuture.isDone()) {
            saveCurrentHeatmapsFile();
            loadHeatmapsFuture = null;
        }
        if (gameStateChanged.getGameState() != GameState.LOGGED_IN) {
            // Disable write heatmap image buttons
            panel.setEnabledHeatmapButtons(false);
        }
        if (gameStateChanged.getGameState() == GameState.LOGGED_IN) {
            // Enable write heatmap image buttons
            panel.setEnabledHeatmapButtons(true);
        }
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        if (client.getAccountHash() == -1) {
            return;
        }
        // If the player has changed, update the player ID
        if (mostRecentLocalUserID != client.getAccountHash()) {
            mostRecentLocalUserName = client.getLocalPlayer().getName();
            mostRecentLocalUserID = client.getAccountHash();
        }
        if (panel.mostRecentLocalUserID != mostRecentLocalUserID) {
            SwingUtilities.invokeLater(panel::updatePlayerID);
        }

        // Load the heatmaps from disk if needed
        if (shouldLoadHeatmaps && client.getGameState().equals(GameState.LOGGED_IN)) {
            // Populate previousXP array with current XP values
            for (Skill skill : Skill.values()) {
                previousXP[skill.ordinal()] = client.getSkillExperience(skill);
            }

            // Schedule the loading of the heatmap files
            shouldLoadHeatmaps = false;
            loadHeatmapsFuture = worldHeatmapPluginExecutor.submit(this::loadHeatmaps);
        }
        // The following code requires the heatmap files to have been loaded
        if (loadHeatmapsFuture != null && !loadHeatmapsFuture.isDone()) {
            return;
        }

        // Increment game time ticks of each heatmap
        for (HeatmapNew.HeatmapType type : heatmaps.keySet()) {
            heatmaps.get(type).incrementGameTimeTicks();
        }

        WorldPoint currentCoords = client.getLocalPlayer().getWorldLocation();
        int currentX = currentCoords.getX();
        int currentY = currentCoords.getY();
        boolean playerMovedSinceLastTick = (currentX != lastX || currentY != lastY);

        /* When running, players cover more than one tile per tick, which creates spotty paths.
         * We fix this by drawing a line between the current coordinates and the previous coordinates,
         * but we have to be sure that the player indeed ran from point A to point B, differentiating the movement from teleportation.
         * Since it's too hard to check if the player is actually running, we'll just check if the distance covered since last tick
         * was less than 5 tiles
         */
        int diagDistance = diagonalDistance(new Point(lastX, lastY), new Point(currentX, currentY));
        if (diagDistance <= 3) {
            // Gets all the tiles between last position and new position
            for (Point tile : getPointsBetween(new Point(lastX, lastY), new Point(currentX, currentY))) {
                // TYPE_A
                if (playerMovedSinceLastTick && config.isHeatmapTypeAEnabled()) {
                    heatmaps.get(HeatmapNew.HeatmapType.TYPE_A).increment(tile.x, tile.y);
                }

                // TYPE_B
                if (config.isHeatmapTypeBEnabled()) {
                    heatmaps.get(HeatmapNew.HeatmapType.TYPE_B).increment(tile.x, tile.y);
                }
            }
        }

        // TELEPORT_PATHS
        if (config.isHeatmapTeleportPathsEnabled() && diagDistance > 15 && isInOverworld(new Point(lastX, lastY)) && isInOverworld(new Point(currentX, currentY))) //we don't draw lines between the overworld and caves etc.
        {
            if (config.isHeatmapTeleportPathsEnabled()) {
                for (Point tile : getPointsBetween(new Point(lastX, lastY), new Point(currentX, currentY))) {
                    heatmaps.get(HeatmapNew.HeatmapType.TELEPORT_PATHS).increment(tile.x, tile.y);
                }
            }
        }

        // TELEPORTED_TO and TELEPORTED_FROM
        if (diagDistance > 15 && isInOverworld(new Point(lastX, lastY)) && isInOverworld(new Point(currentX, currentY))) //we only track teleports between overworld tiles
        {
            if (config.isHeatmapTeleportedToEnabled()) {
                heatmaps.get(HeatmapNew.HeatmapType.TELEPORTED_TO).increment(currentX, currentY);
            }
            if (config.isHeatmapTeleportedFromEnabled()) {
                heatmaps.get(HeatmapNew.HeatmapType.TELEPORTED_FROM).increment(lastX, lastY);
            }
        }

        // Backup/autosave routines
        backupRoutine();
        autosaveRoutine();

        // Update panel step counter
        SwingUtilities.invokeLater(panel::updateCounts);

        // Update memory usage label/tooltips every 10 ticks
        if (client.getTickCount() % 10 == 0) {
            SwingUtilities.invokeLater(panel::updateMemoryUsages);
        }

        // Update last coords
        lastX = currentX;
        lastY = currentY;
    }

    @Subscribe
    public void onActorDeath(ActorDeath actorDeath) {
        if (actorDeath.getActor() instanceof Player) {
            Player actor = (Player) actorDeath.getActor();
            if (actor.getId() == client.getLocalPlayer().getId()) {
                // DEATHS
                if (config.isHeatmapDeathsEnabled()) {
                    heatmaps.get(HeatmapNew.HeatmapType.DEATHS).increment(actor.getWorldLocation().getX(), actor.getWorldLocation().getY());
                }
            }
        } else if (actorDeath.getActor() instanceof NPC) {
            if (heatmaps.get(HeatmapNew.HeatmapType.NPC_DEATHS) != null && config.isHeatmapNPCDeathsEnabled()) {
                // NPC_DEATHS
                heatmaps.get(HeatmapNew.HeatmapType.NPC_DEATHS).increment(actorDeath.getActor().getWorldLocation().getX(), actorDeath.getActor().getWorldLocation().getY());
            }
        }
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied hitsplatApplied) {
        if (hitsplatApplied.getHitsplat().getAmount() == 0) {
            return;
        }
        // DAMAGE_GIVEN
        if (hitsplatApplied.getHitsplat().getHitsplatType() == net.runelite.api.HitsplatID.DAMAGE_ME && hitsplatApplied.getActor() instanceof NPC) {
            NPC actor = (NPC) hitsplatApplied.getActor();
            if (config.isHeatmapDamageGivenEnabled()) {
                heatmaps.get(HeatmapNew.HeatmapType.DAMAGE_GIVEN).increment(actor.getWorldLocation().getX(), actor.getWorldLocation().getY(), hitsplatApplied.getHitsplat().getAmount());
            }
        }

        // DAMAGE_TAKEN
        if (hitsplatApplied.getHitsplat().getHitsplatType() == HitsplatID.DAMAGE_ME && hitsplatApplied.getActor() instanceof Player) {
            Player actor = (Player) hitsplatApplied.getActor();
            if (actor.getId() == client.getLocalPlayer().getId()) {
                if (config.isHeatmapDamageTakenEnabled()) {
                    heatmaps.get(HeatmapNew.HeatmapType.DAMAGE_TAKEN).increment(actor.getWorldLocation().getX(), actor.getWorldLocation().getY(), hitsplatApplied.getHitsplat().getAmount());
                }
            }
        }
    }

    @Subscribe
    public void onChatMessage(ChatMessage chatMessage) {
        if (client.getLocalPlayer() == null || client.getLocalPlayer().getName() == null) {
            return;
        }
        if (chatMessage.getType() == ChatMessageType.PUBLICCHAT && chatMessage.getName().contains(client.getLocalPlayer().getName())) {
            // PLACES_SPOKEN_AT
            if (config.isHeatmapPlacesSpokenAtEnabled() && heatmaps.get(HeatmapNew.HeatmapType.PLACES_SPOKEN_AT) != null) {
                heatmaps.get(HeatmapNew.HeatmapType.PLACES_SPOKEN_AT).increment(client.getLocalPlayer().getWorldLocation().getX(), client.getLocalPlayer().getWorldLocation().getY());
            }
        }
    }

    @Subscribe
    public void onStatChanged(StatChanged statChanged) {
        // NOTE: this happens 23 times when you log in, and at such time, the heatmaps haven't been loaded in, so you can't call .get() on them
        // Get difference between previous and current XP
        int skillIndex = statChanged.getSkill().ordinal();
        int xpDifference = client.getSkillExperience(statChanged.getSkill()) - previousXP[skillIndex];

        // Update previous XP
        previousXP[skillIndex] = client.getSkillExperience(statChanged.getSkill());

        // XP_GAINED
        if (config.isHeatmapXPGainedEnabled() && heatmaps.get(HeatmapNew.HeatmapType.XP_GAINED) != null) {
            heatmaps.get(HeatmapNew.HeatmapType.XP_GAINED).increment(client.getLocalPlayer().getWorldLocation().getX(), client.getLocalPlayer().getWorldLocation().getY(), xpDifference);
        }
    }

    @Subscribe
    public void onNpcSpawned(final NpcSpawned npcSpawned) {
        // Currently it counts all random event spawns, not just random events meant for the local player
        if (randomEventNPCIDs.contains(npcSpawned.getNpc().getId())) {
            // RANDOM_EVENT_SPAWNS
            if (config.isHeatmapRandomEventSpawnsEnabled() && heatmaps.get(HeatmapNew.HeatmapType.RANDOM_EVENT_SPAWNS) != null) {
                heatmaps.get(HeatmapNew.HeatmapType.RANDOM_EVENT_SPAWNS).increment(npcSpawned.getNpc().getWorldLocation().getX(), npcSpawned.getNpc().getWorldLocation().getY());
            }
        }

        // BOB_THE_CAT_SIGHTING
        if (config.isHeatmapBobTheCatSightingEnabled() && npcSpawned.getNpc().getId() == NpcID.BOB_8034) {
            // Only count Bob the Cat sightings once per hour at most
            if (timeLastSeenBobTheCatPerWorld.get(client.getWorld()) == null || Instant.now().isAfter(timeLastSeenBobTheCatPerWorld.get(client.getWorld()).plusSeconds(3600))) {
                if (heatmaps.get(HeatmapNew.HeatmapType.BOB_THE_CAT_SIGHTING) != null) {
                    heatmaps.get(HeatmapNew.HeatmapType.BOB_THE_CAT_SIGHTING).increment(npcSpawned.getNpc().getWorldLocation().getX(), npcSpawned.getNpc().getWorldLocation().getY());
                    timeLastSeenBobTheCatPerWorld.put(client.getWorld(), Instant.now());
                }
            }
        }
    }

    @Subscribe
    public void onNpcLootReceived(final NpcLootReceived npcLootReceived) {
        // LOOT_VALUE
        if (config.isHeatmapLootValueEnabled()) {
            for (ItemStack itemStack : npcLootReceived.getItems()) {
                WorldPoint location = npcLootReceived.getNpc().getWorldLocation();
                int x = location.getX();
                int y = location.getY();

                int totalValue = itemStack.getQuantity() * itemManager.getItemPrice(itemStack.getId());
                if (heatmaps.get(HeatmapNew.HeatmapType.LOOT_VALUE) != null) {
                    heatmaps.get(HeatmapNew.HeatmapType.LOOT_VALUE).increment(x, y, totalValue);
                }
            }
        }
    }

    /**
     * Autosave the heatmap file and/or write the 'TYPE_A' and 'TYPE_B' heatmap images if it is the correct time to so
     */
    private void autosaveRoutine() {
        // Determine if autosave should happen
        if (heatmaps.keySet().isEmpty()){
            return;
        }
        int highestGameTimeTicks = 0;
        for (HeatmapNew.HeatmapType type : heatmaps.keySet()) {
            if (heatmaps.get(type).getGameTimeTicks() > highestGameTimeTicks) {
                highestGameTimeTicks = heatmaps.get(type).getGameTimeTicks();
            }
        }
        boolean shouldAutosaveFiles = highestGameTimeTicks % WorldHeatmapPlugin.HEATMAP_AUTOSAVE_FREQUENCY == 0;
        boolean shouldWriteImages = config.typeABImageAutosave() && highestGameTimeTicks % config.typeABImageAutosaveFrequency() == 0;

        // Autosave the heatmap file if it is the correct time to do so, or if image is about to be written
        if (shouldAutosaveFiles || shouldWriteImages) {
            saveCurrentHeatmapsFile();
        }

        // Autosave the 'TYPE_A' and 'TYPE_B' heatmap images if it is the correct time to do so
        if (shouldWriteImages) {
            File typeAImageFile = HeatmapFile.getCurrentImageFile(mostRecentLocalUserID, HeatmapNew.HeatmapType.TYPE_A);
            File typeBImageFile = HeatmapFile.getCurrentImageFile(mostRecentLocalUserID, HeatmapNew.HeatmapType.TYPE_B);

            // Write the image files
            if (config.isHeatmapTypeAEnabled()) {
                worldHeatmapPluginExecutor.execute(() -> HeatmapImage.writeHeatmapImage(heatmaps.get(HeatmapNew.HeatmapType.TYPE_A), typeAImageFile, false, config.heatmapAlpha(), config.heatmapSensitivity(), config.speedMemoryTradeoff(), new HeatmapProgressListener(this, HeatmapNew.HeatmapType.TYPE_A)));
            }
            if (config.isHeatmapTypeBEnabled()) {
                worldHeatmapPluginExecutor.execute(() -> HeatmapImage.writeHeatmapImage(heatmaps.get(HeatmapNew.HeatmapType.TYPE_B), typeBImageFile, false, config.heatmapAlpha(), config.heatmapSensitivity(), config.speedMemoryTradeoff(), new HeatmapProgressListener(this, HeatmapNew.HeatmapType.TYPE_B)));
            }
        }
    }

    /**
     * Backs up the heatmap file if it is the correct time to do so according to the backup frequency
     */
    private void backupRoutine() {
        // Determine if a backup should be made
        if (heatmaps.keySet().isEmpty()){
            return;
        }
        int highestGameTimeTicks = 0;
        for (HeatmapNew.HeatmapType type : heatmaps.keySet()) {
            if (heatmaps.get(type).getGameTimeTicks() > highestGameTimeTicks) {
                highestGameTimeTicks = heatmaps.get(type).getGameTimeTicks();
            }
        }

        // Make backup
        if (highestGameTimeTicks % config.heatmapBackupFrequency() == 0) {
            saveNewHeatmapsFile();
        }
    }

    /**
     * Updates the most recent heatmap file with the latest data. If the most recent file does not exist, it will create a new file.
     */
    private void saveCurrentHeatmapsFile() {
        File heatmapsFile = HeatmapFile.getLatestHeatmapFile(mostRecentLocalUserID);
        if (heatmapsFile == null) {
            heatmapsFile = HeatmapFile.getCurrentHeatmapFile(mostRecentLocalUserID);
        }
        File finalHeatmapsFile = heatmapsFile;
        worldHeatmapPluginExecutor.execute(() -> HeatmapNew.writeHeatmapsToFile(getEnabledHeatmaps(), finalHeatmapsFile, null));
    }

    /**
     * Saves the heatmaps to a new dated file, carrying over disabled/unprovided heatmaps from the most recently dated heatmaps file
     */
    private void saveNewHeatmapsFile() {
        // Write heatmaps to new file, carrying over disabled/unprovided heatmaps from previous heatmaps file
        File latestHeatmapsFile = HeatmapFile.getLatestHeatmapFile(mostRecentLocalUserID);
        File newHeatmapsFile = HeatmapFile.getCurrentHeatmapFile(mostRecentLocalUserID);
        log.debug("Backing up heatmaps to file: {}", latestHeatmapsFile);
        worldHeatmapPluginExecutor.execute(() -> HeatmapNew.writeHeatmapsToFile(getEnabledHeatmaps(), newHeatmapsFile, latestHeatmapsFile));
    }

    // Credit to https:// www.redblobgames.com/grids/line-drawing.html for where I figured out how to make the following linear interpolation functions

    /**
     * Returns the list of discrete coordinates on the path between p0 and p1, as an array of Points
     *
     * @param p0 Point A
     * @param p1 Point B
     * @return Array of coordinates
     */
    private Point[] getPointsBetween(Point p0, Point p1) {
        if (p0.equals(p1)) {
            return new Point[]{p1};
        }
        int N = diagonalDistance(p0, p1);
        Point[] points = new Point[N];
        for (int step = 1; step <= N; step++) {
            float t = step / (float) N;
            points[step - 1] = roundPoint(lerp_point(p0, p1, t));
        }
        return points;
    }

    /**
     * Returns the "diagonal distance" (the maximum of the horizontal and vertical distance) between two points
     *
     * @param p0 Point A
     * @param p1 Point B
     * @return The diagonal distance
     */
    private int diagonalDistance(Point p0, Point p1) {
        int dx = Math.abs(p1.x - p0.x);
        int dy = Math.abs(p1.y - p0.y);
        return Math.max(dx, dy);
    }

    /**
     * Rounds a floating point coordinate to its nearest integer coordinate.
     *
     * @param point The point to round
     * @return Coordinates
     */
    private Point roundPoint(float[] point) {
        return new Point(Math.round(point[0]), Math.round(point[1]));
    }

    /**
     * Returns the floating point 2D coordinate that is t-percent of the way between p0 and p1
     *
     * @param p0 Point A
     * @param p1 Point B
     * @param t  Percent distance
     * @return Coordinate that is t% of the way from A to B
     */
    private float[] lerp_point(Point p0, Point p1, float t) {
        return new float[]{lerp(p0.x, p1.x, t), lerp(p0.y, p1.y, t)};
    }

    /**
     * Returns the floating point number that is t-percent of the way between p0 and p1.
     *
     * @param p0 Point A
     * @param p1 Point B
     * @param t  Percent distance
     * @return Point that is t-percent of the way from A to B
     */
    private float lerp(int p0, int p1, float t) {
        return p0 + (p1 - p0) * t;
    }

    public boolean isInOverworld(Point point) {
        return point.y < Constants.OVERWORLD_MAX_Y && point.y > 2500 && point.x >= 1024 && point.x < 3960;
    }

    /**
     * Initializes any enabled Heatmap types in the given Map of Heatmaps that weren't loaded
     *
     * @param heatmaps HashMap of HeatmapNew objects
     * @param userID   The user ID
     */
    public void initializeMissingHeatmaps(Map<HeatmapNew.HeatmapType, HeatmapNew> heatmaps, long userID) {
        log.debug("Initializing missing heatmaps...");
        // Get the heatmaps that are enabled but were not loaded
        ArrayList<HeatmapNew.HeatmapType> missingTypes = new ArrayList<>();
        for (HeatmapNew.HeatmapType type : HeatmapNew.HeatmapType.values()) {
            if (isHeatmapEnabled(type) && (!heatmaps.containsKey(type) || heatmaps.get(type) == null)) {
                missingTypes.add(type);
            }
        }
        if (missingTypes.isEmpty())
            return;

        List<String> missingTypesNames = new ArrayList<>();
        for (HeatmapNew.HeatmapType type : missingTypes) {
            missingTypesNames.add(type.toString());
        }
        log.debug("Initializing the following types: " + String.join(", ", missingTypesNames));
        for (HeatmapNew.HeatmapType type : missingTypes) {
            heatmaps.put(type, new HeatmapNew(type, userID));
        }
    }

    Collection<HeatmapNew> getEnabledHeatmaps() {
        return heatmaps.values().stream().filter(heatmap -> isHeatmapEnabled(heatmap.getHeatmapType())).collect(Collectors.toList());
    }

    Collection<HeatmapNew.HeatmapType> getEnabledHeatmapTypes() {
        List<HeatmapNew.HeatmapType> enabledTypes = new ArrayList<>();
        for (HeatmapNew.HeatmapType type : HeatmapNew.HeatmapType.values()) {
            if (isHeatmapEnabled(type)) {
                enabledTypes.add(type);
            }
        }
        return enabledTypes;
    }

    boolean isHeatmapEnabled(HeatmapNew.HeatmapType type) {
        Map<HeatmapNew.HeatmapType, Supplier> heatmapTypeSupplierMap = new HashMap<>();
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.TYPE_A, config::isHeatmapTypeAEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.TYPE_B, config::isHeatmapTypeBEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.XP_GAINED, config::isHeatmapXPGainedEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.TELEPORT_PATHS, config::isHeatmapTeleportPathsEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.TELEPORTED_TO, config::isHeatmapTeleportedToEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.TELEPORTED_FROM, config::isHeatmapTeleportedFromEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.LOOT_VALUE, config::isHeatmapLootValueEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.PLACES_SPOKEN_AT, config::isHeatmapPlacesSpokenAtEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.RANDOM_EVENT_SPAWNS, config::isHeatmapRandomEventSpawnsEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.DEATHS, config::isHeatmapDeathsEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.NPC_DEATHS, config::isHeatmapNPCDeathsEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.BOB_THE_CAT_SIGHTING, config::isHeatmapBobTheCatSightingEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.DAMAGE_TAKEN, config::isHeatmapDamageTakenEnabled);
        heatmapTypeSupplierMap.put(HeatmapNew.HeatmapType.DAMAGE_GIVEN, config::isHeatmapDamageGivenEnabled);
        return (boolean) heatmapTypeSupplierMap.getOrDefault(type, () -> false).get();
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals("worldheatmap")) {
            return;
        }
        Map<String, HeatmapNew.HeatmapType> configNameToHeatmapType = new HashMap<>();
        configNameToHeatmapType.put("isHeatmapTypeAEnabled", HeatmapNew.HeatmapType.TYPE_A);
        configNameToHeatmapType.put("isHeatmapTypeBEnabled", HeatmapNew.HeatmapType.TYPE_B);
        configNameToHeatmapType.put("isHeatmapXPGainedEnabled", HeatmapNew.HeatmapType.XP_GAINED);
        configNameToHeatmapType.put("isHeatmapTeleportPathsEnabled", HeatmapNew.HeatmapType.TELEPORT_PATHS);
        configNameToHeatmapType.put("isHeatmapTeleportedToEnabled", HeatmapNew.HeatmapType.TELEPORTED_TO);
        configNameToHeatmapType.put("isHeatmapTeleportedFromEnabled", HeatmapNew.HeatmapType.TELEPORTED_FROM);
        configNameToHeatmapType.put("isHeatmapLootValueEnabled", HeatmapNew.HeatmapType.LOOT_VALUE);
        configNameToHeatmapType.put("isHeatmapPlacesSpokenAtEnabled", HeatmapNew.HeatmapType.PLACES_SPOKEN_AT);
        configNameToHeatmapType.put("isHeatmapRandomEventSpawnsEnabled", HeatmapNew.HeatmapType.RANDOM_EVENT_SPAWNS);
        configNameToHeatmapType.put("isHeatmapDeathsEnabled", HeatmapNew.HeatmapType.DEATHS);
        configNameToHeatmapType.put("isHeatmapNPCDeathsEnabled", HeatmapNew.HeatmapType.NPC_DEATHS);
        configNameToHeatmapType.put("isHeatmapBobTheCatSightingEnabled", HeatmapNew.HeatmapType.BOB_THE_CAT_SIGHTING);
        configNameToHeatmapType.put("isHeatmapDamageTakenEnabled", HeatmapNew.HeatmapType.DAMAGE_TAKEN);
        configNameToHeatmapType.put("isHeatmapDamageGivenEnabled", HeatmapNew.HeatmapType.DAMAGE_GIVEN);

        HeatmapNew.HeatmapType toggledHeatmapType = configNameToHeatmapType.get(event.getKey());
        if (toggledHeatmapType != null) {
            boolean isEnabled = event.getNewValue() != null && event.getNewValue().equals("true");
            handleHeatmapConfigChanged(isEnabled, toggledHeatmapType);
        }
    }

    /**
     * Saves heatmap to file when enabled, and reads heatmap from file when enabled.
     * @param isHeatmapEnabled Whether the heatmap is enabled
     * @param heatmapType The type of heatmap
     */
    private void handleHeatmapConfigChanged(boolean isHeatmapEnabled, HeatmapNew.HeatmapType heatmapType){
        File heatmapsFile = HeatmapFile.getLatestHeatmapFile(mostRecentLocalUserID);

        if (isHeatmapEnabled) {
            log.debug("Enabling {} heatmap...", heatmapType);
            HeatmapNew heatmap = null;
            // Load the heatmap from the file if it exists
            if (heatmapsFile != null && heatmapsFile.exists()) {
                try {
                    heatmap = HeatmapNew.readHeatmapsFromFile(heatmapsFile, Collections.singletonList(heatmapType)).get(heatmapType);
                } catch (FileNotFoundException e) {
                    throw new RuntimeException(e);
                }
            }
            if (heatmap != null) {
                heatmaps.put(heatmapType, heatmap);
            }
        } else {
            log.debug("Disabling {} heatmap...", heatmapType);
            if (heatmapsFile == null){
                heatmapsFile = HeatmapFile.getCurrentHeatmapFile(mostRecentLocalUserID);
            }
            HeatmapNew.writeHeatmapsToFile(List.of(heatmaps.get(heatmapType)), heatmapsFile, null);
            heatmaps.remove(heatmapType);
        }
        initializeMissingHeatmaps(heatmaps, mostRecentLocalUserID);
        panel.rebuild();
    }

    static class HeatmapProgressListener implements IIOWriteProgressListener {
        private final WorldHeatmapPlugin worldHeatmapPlugin;
        Color originalColor;
        HeatmapNew.HeatmapType heatmapType;

        WorldHeatmapPanel panel;

        public HeatmapProgressListener(WorldHeatmapPlugin worldHeatmapPlugin, HeatmapNew.HeatmapType heatmapType) {
            super();
            this.worldHeatmapPlugin = worldHeatmapPlugin;
            this.heatmapType = heatmapType;
            this.panel = worldHeatmapPlugin.panel;
            if (panel.writeHeatmapImageButtons.get(heatmapType) != null) {
                originalColor = panel.writeHeatmapImageButtons.get(heatmapType).getForeground();
            }
        }

        @Override
        public void imageStarted(ImageWriter source, int imageIndex) {
            panel.setEnabledHeatmapButtons(false);
            panel.writeHeatmapImageButtons.get(heatmapType).setForeground(Color.GREEN);
            panel.writeHeatmapImageButtons.get(heatmapType).setText("Writing... 0%");
        }

        @Override
        public void imageProgress(ImageWriter source, float percentageDone) {
            panel.writeHeatmapImageButtons.get(heatmapType).setForeground(Color.GREEN);
            panel.writeHeatmapImageButtons.get(heatmapType).setText(String.format("Writing... %.2f%%", percentageDone));
        }

        @Override
        public void imageComplete(ImageWriter source) {
            panel.writeHeatmapImageButtons.get(heatmapType).setText("Done");
            worldHeatmapPlugin.worldHeatmapPluginExecutor.schedule(() -> {
                panel.writeHeatmapImageButtons.get(heatmapType).setText("Write Heatmap Image");
                panel.writeHeatmapImageButtons.get(heatmapType).setForeground(originalColor);
                panel.writeHeatmapImageButtons.get(heatmapType).revalidate();
                panel.writeHeatmapImageButtons.get(heatmapType).repaint();
                panel.setEnabledHeatmapButtons(true);
            }, 2L, TimeUnit.SECONDS);
        }

        @Override
        public void thumbnailStarted(ImageWriter source, int imageIndex, int thumbnailIndex) {
        }

        @Override
        public void thumbnailProgress(ImageWriter source, float percentageDone) {
        }

        @Override
        public void thumbnailComplete(ImageWriter source) {
        }

        @Override
        public void writeAborted(ImageWriter source) {
        }
    }
}

package com.worldheatmap;

import net.runelite.client.config.*;

@ConfigGroup(WorldHeatmapConfig.GROUP)
public interface WorldHeatmapConfig extends Config {
    String GROUP = "worldheatmap";

    @ConfigSection(
            name = "Main Settings",
            description = "Settings for main plugin functionality",
            position = 0
    )
    String settings = "settings";

    @Range(
            min = 100
    )
    @ConfigItem(
            keyName = "ImageAutosaveFrequency",
            name = "Type A&B image autosave frequency",
            position = 0,
            description = "Determines how often (in number of steps) to automatically save both the 'Type A' and 'Type B' world heatmap TIF images. Default value of 36000 ticks (6 hours)",
            section = settings
    )
    default int typeABImageAutosaveFrequency() {
        return 36000;
    }

    @ConfigItem(
            keyName = "ImageAutosave",
            name = "Type A&B image autosave",
            position = 1,
            description = "Determines whether to automatically save both the 'Type A' and 'Type B' world heatmap TIF images.",
            section = settings
    )
    default boolean typeABImageAutosave() {
        return false;
    }

    @Range(
            min = 100
    )
    @ConfigItem(
            keyName = "HeatmapBackupFrequency",
            name = "Data backup frequency",
            position = 2,
            description = "Determines how often (in ticks of game time) to make a new backup of the heatmap data, in the Heatmap 'Results/Backups' folder (don't set this field too low or there will be too many backups piling up). Default value 36000 ticks (6 hours). Minimum value 50.",
            section = settings
    )
    default int heatmapBackupFrequency() {
        return 36000;
    }

    @Range(
            min = 0,
            max = 1
    )
    @ConfigItem(
            keyName = "HeatmapAlpha",
            name = "Heatmap colour alpha",
            position = 3,
            description = "The opacity of the heatmap colours drawn over the world map image",
            section = settings
    )
    default double heatmapAlpha() {
        return 0.65;
    }

    @Range(
            min = 1,
            max = 6
    )
    @ConfigItem(
            keyName = "heatmapSensitivity",
            name = "Heatmap curve sensitivity",
            position = 4,
            description = "Increasing this makes the heatmap's colour gradient more sensitive to step counts.",
            section = settings
    )
    default int heatmapSensitivity() {
        return 4;
    }

    @Range(
            max = 8
    )
    @ConfigItem(
            keyName = "speedMemoryTradeoff",
            name = "Speed-memory tradeoff",
            position = 5,
            description = "Corresponds to the vertical size of chunks used in writing the heatmap image. Higher values = faster image writing, but increases memory usage. Try lowering this value if the plugin is crashing whilst writing images.",
            section = settings
    )
    default int speedMemoryTradeoff() {
        return 4;
    }

    @ConfigItem(
            keyName = "writeFullMapImage",
            name = "Write full world map image (SLOW)",
            position = 7,
            description = "Warning: This takes much longer than writing just the overworld image. If checked, this will write the full world map image (including underground/non-overworld areas). Does not apply to image autosaves.",
            section = settings
    )
    default boolean isWriteFullImageEnabled() {
        return false;
    }

    @ConfigSection(
            name = "Per-Heatmap On/Off",
            description = "Enabling/disabling individual heatmaps",
            position = 1
    )
    String heatmapsOnOff = "heatmapsOnOff";

    @ConfigItem(
            keyName = "isHeatmapTypeAEnabled",
            name = "TYPE_A",
            position = 0,
            description = "Increments a tile each time you walk over it",
            section = heatmapsOnOff
    )
    default boolean isHeatmapTypeAEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapTypeBEnabled",
            name = "TYPE_B",
            position = 1,
            description = "Increments a tile each tick you stand on it",
            section = heatmapsOnOff
    )
    default boolean isHeatmapTypeBEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapXPGainedEnabled",
            name = "XP_GAINED",
            position = 2,
            description = "Records the total number of XP gained in each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapXPGainedEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapTeleportPathsEnabled",
            name = "TELEPORT_PATHS",
            position = 3,
            description = "Records the paths taken when teleporting",
            section = heatmapsOnOff
    )
    default boolean isHeatmapTeleportPathsEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapTelportedToEnabled",
            name = "TELEPORTED_TO",
            position = 4,
            description = "Records the locations teleported to",
            section = heatmapsOnOff
    )
    default boolean isHeatmapTeleportedToEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapTeleportedFromEnabled",
            name = "TELEPORTED_FROM",
            position = 5,
            description = "Records the locations teleported from",
            section = heatmapsOnOff
    )
    default boolean isHeatmapTeleportedFromEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapLootValueEnabled",
            name = "LOOT_VALUE",
            position = 6,
            description = "Records the total value of loot spawned on each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapLootValueEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapPlacesSpokenAtEnabled",
            name = "PLACES_SPOKEN_AT",
            position = 7,
            description = "Records the number of times you've spoken in public chat at each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapPlacesSpokenAtEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapRandomEventSpawnsEnabled",
            name = "RANDOM_EVENT_SPAWNS",
            position = 8,
            description = "Records the number of witnessed random event spawns on each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapRandomEventSpawnsEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapDeathsEnabled",
            name = "DEATHS",
            position = 9,
            description = "Records the number of times you've died on each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapDeathsEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapNPCDeathsEnabled",
            name = "NPC_DEATHS",
            position = 10,
            description = "Records the number of NPC deaths you've witnesssed on each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapNPCDeathsEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapBobTheCatSightingEnabled",
            name = "BOB_THE_CAT_SIGHTING",
            position = 11,
            description = "Records the tiles on which you've found Bob the Cat (this is regular bob, not evil bob)",
            section = heatmapsOnOff
    )
    default boolean isHeatmapBobTheCatSightingEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapDamageTakenEnabled",
            name = "DAMAGE_TAKEN",
            position = 12,
            description = "Records the total you've damage taken on each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapDamageTakenEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "isHeatmapDamageGivenEnabled",
            name = "DAMAGE_GIVEN",
            position = 13,
            description = "Records the total damage you've dealt whilst standing on each tile",
            section = heatmapsOnOff
    )
    default boolean isHeatmapDamageGivenEnabled() {
        return true;
    }

}

