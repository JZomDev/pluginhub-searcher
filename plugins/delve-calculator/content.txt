package com.speaax;

import net.runelite.client.config.*;

@ConfigGroup("delvecalculator")
public interface DelveCalculatorConfig extends Config
{
    // --- General Settings ---
    @ConfigSection(
            name = "General",
            description = "General panel visibility settings",
            position = 0,
            closedByDefault = false
    )
    String generalSettings = "generalSettings";

    @ConfigItem(
            keyName = "alwaysShowPanel",
            name = "Show Everywhere",
            description = "Keeps the panel icon visible at all times. If off, it will only appear when specific conditions below are met.",
            section = generalSettings,
            position = 1
    )
    default boolean alwaysShowPanel()
    {
        return true;
    }


    // --- Region Settings ---
    @ConfigSection(
            name = "Region Settings",
            description = "Make the panel appear when you are in the Delve region.",
            position = 1
    )
    String regionSettings = "regionSettings";

    @ConfigItem(
            keyName = "showInRegion",
            name = "Show in Region",
            description = "Shows the panel icon when you are inside the Delve region.",
            section = regionSettings,
            position = 2
    )
    default boolean showInRegion()
    {
        return false;
    }

    @ConfigItem(
            keyName = "autoOpenInRegion",
            name = "Auto Open in Region",
            description = "Automatically open the panel when a new Region session begins.",
            section = regionSettings,
            position = 3
    )
    default boolean autoOpenInRegion()
    {
        return false;
    }

    @ConfigItem(
            keyName = "regionTimeout",
            name = "Region Session Timeout",
            description = "Session timer in minutes. The icon remains visible during this time, even if you leave to bank.",
            section = regionSettings,
            position = 4
    )
    @Units(Units.MINUTES)
    default int regionTimeout()
    {
        return 10;
    }


    // --- Scoreboard Settings ---
    @ConfigSection(
            name = "Scoreboard Settings",
            description = "Make the panel appear when the Delve scoreboard is open.",
            position = 2
    )
    String scoreboardSettings = "scoreboardSettings";

    @ConfigItem(
            keyName = "showOnScoreboard",
            name = "Show on Scoreboard",
            description = "Shows the panel icon when the Delve scoreboard is open.",
            section = scoreboardSettings,
            position = 5
    )
    default boolean showOnScoreboard()
    {
        return false;
    }

    @ConfigItem(
            keyName = "autoOpenOnScoreboard",
            name = "Auto Open on Scoreboard",
            description = "Automatically open the panel when you open the Delve scoreboard.",
            section = scoreboardSettings,
            position = 6
    )
    default boolean autoOpenOnScoreboard()
    {
        return true;
    }

    // --- Reward Display Settings ---
    @ConfigSection(
            name = "Reward Display",
            description = "Configure how each reward is displayed and if it's included in the 'Any' unique calculation.",
            position = 3,
            closedByDefault = false
    )
    String rewardSettings = "rewardSettings";

    enum RewardDisplayMode
    {
        SHOW,  // Displayed normally and included in 'Any' calculation.
        GREY,  // Displayed but greyed out; NOT included in 'Any' calculation.
        HIDE   // Not displayed; NOT included in 'Any' calculation.
    }

    @ConfigItem(
            keyName = "mokhaiotlClothDisplay",
            name = "Mokhaiotl's Cloth",
            description = "How to display the Mokhaiotl's Cloth reward. 'Grey' or 'Hide' will exclude it from the 'Any' unique calculation.",
            section = rewardSettings,
            position = 7
    )
    default RewardDisplayMode mokhaiotlClothDisplay() { return RewardDisplayMode.SHOW; }

    @ConfigItem(
            keyName = "eyeOfAyakDisplay",
            name = "Eye of Ayak",
            description = "How to display the Eye of Ayak reward. 'Grey' or 'Hide' will exclude it from the 'Any' unique calculation.",
            section = rewardSettings,
            position = 8
    )
    default RewardDisplayMode eyeOfAyakDisplay() { return RewardDisplayMode.SHOW; }

    @ConfigItem(
            keyName = "avernicTreadsDisplay",
            name = "Avernic Treads",
            description = "How to display the Avernic Treads reward. 'Grey' or 'Hide' will exclude it from the 'Any' unique calculation.",
            section = rewardSettings,
            position = 9
    )
    default RewardDisplayMode avernicTreadsDisplay() { return RewardDisplayMode.SHOW; }

    @ConfigItem(
            keyName = "domDisplay",
            name = "Dom",
            description = "How to display the D.O.M. reward. 'Grey' or 'Hide' will exclude it from the 'Any' unique calculation.",
            section = rewardSettings,
            position = 10
    )
    default RewardDisplayMode domDisplay() { return RewardDisplayMode.SHOW; }

    // --- Hidden Data ---
    @ConfigItem(
            keyName = "killCountData",
            name = "",
            description = "",
            hidden = true
    )
    default String killCountData() { return ""; }

    @ConfigItem(
            keyName = "killCountData",
            name = "",
            description = ""
    )
    void killCountData(String data);
}
package com.speaax;

import com.google.gson.Gson;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.config.ConfigManager;
import com.google.inject.Provides;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

@Slf4j
@PluginDescriptor(
	name = "Delve Calculator",
	description = "Calculates expected unique drops",
	tags = {"delve", "calculator", "drops", "rates", "doom"}
)
public class DelveCalculatorPlugin extends Plugin
{
	@Inject private Client client;
	@Inject private ClientThread clientThread;
	@Inject private DelveCalculatorConfig config;
	@Inject private Gson gson;
	@Inject private ClientToolbar clientToolbar;
	@Getter @Inject private ItemManager itemManager;

	private DelveCalculatorPanel panel;
	private NavigationButton navButton;
	private Timer sessionTimeoutTimer;
	private boolean panelVisible = false;
	private Instant lastRegionEntryTime = null;

	// Widget group ID
	private static final int WIDGET_GROUP = 920;
	private static final int[] DELVE_REGION_IDS = {5269, 13668, 14180};
	private static final Map<Integer, DropRates> DROP_RATES_BY_LEVEL = new HashMap<>();

	static {
		//DROP_RATES_BY_LEVEL.put(x... where x is delve level and 9 is everything from 9 and above
		DROP_RATES_BY_LEVEL.put(2, new DropRates(1.0/2500, 1.0/2500, 0, 0, 0, 0));
		DROP_RATES_BY_LEVEL.put(3, new DropRates(1.0/1000, 1.0/2000, 1.0/2000, 0, 0, 0));
		DROP_RATES_BY_LEVEL.put(4, new DropRates(1.0/450, 1.0/1350, 1.0/1350, 1.0/1350, 0, 0));
		DROP_RATES_BY_LEVEL.put(5, new DropRates(1.0/270, 1.0/810, 1.0/810, 1.0/810, 0, 0));
		DROP_RATES_BY_LEVEL.put(6, new DropRates(1.0/255, 1.0/765, 1.0/765, 1.0/765, 1.0/1000, 0));
		DROP_RATES_BY_LEVEL.put(7, new DropRates(1.0/240, 1.0/720, 1.0/720, 1.0/720, 1.0/750, 0));
		DROP_RATES_BY_LEVEL.put(8, new DropRates(1.0/210, 1.0/630, 1.0/630, 1.0/630, 1.0/500, 0));
		DROP_RATES_BY_LEVEL.put(9, new DropRates(1.0/180, 1.0/540, 1.0/540, 1.0/540, 1.0/250, 0));
	}

	@Provides
	DelveCalculatorConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(DelveCalculatorConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		panel = new DelveCalculatorPanel(this, config, gson);
		BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");

		navButton = NavigationButton.builder()
				.tooltip("Delve Calculator")
				.icon(icon)
				.priority(5)
				.panel(panel)
				.build();

		sessionTimeoutTimer = new Timer(0, e -> updatePanelVisibility());
		sessionTimeoutTimer.setRepeats(false);

		clientToolbar.addNavigation(navButton);
		panelVisible = true;
		updatePanelVisibility();
	}

	@Override
	protected void shutDown() throws Exception
	{
		sessionTimeoutTimer.stop();
		SwingUtilities.invokeLater(() -> clientToolbar.removeNavigation(navButton));
		navButton = null;
		panel = null;
		lastRegionEntryTime = null;
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() == ChatMessageType.GAMEMESSAGE)
		{
			String message = event.getMessage();

			// Check for delve completion messages
			// Format: "Delve level: 4 duration: 1:45. Personal best: 1:27"
			// Format: "Delve level: 8+ (11) duration: 1:10.20. Personal best: 1:10.20"
			if (message.contains("Delve level:") && message.contains("duration:"))
			{
				// Extract delve level from the message
				String[] parts = message.split(" ");
				for (int i = 0; i < parts.length; i++)
				{
					if (parts[i].equals("level:") && i + 1 < parts.length)
					{
						String levelText = parts[i + 1];

						// Check if it's level 8+ (special case)
						if (levelText.equals("8+"))
						{
							log.debug("Delve completed! Level: 8+");
							panel.incrementWavesPast8();
							break;
						}
						else
						{
							// Regular level (1-8)
							try
							{
								int level = Integer.parseInt(levelText);
								if (level >= 1 && level <= 8)
								{
									log.debug("Delve completed! Level: {}", level);
									panel.incrementFloorKills(level);
									break;
								}
								else
								{
									log.debug("Invalid delve level: {}", level);
								}
							}
							catch (NumberFormatException e)
							{
								log.debug("Failed to parse delve level from message: {}", message);
							}
						}
					}
				}
			}
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals("delvecalculator"))
		{
			updatePanelVisibility();

			if (panel != null)
			{
				panel.updateAllUI();
			}
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (event.getGroupId() == WIDGET_GROUP)
		{
			clientThread.invokeLater(this::updateKillCounts);
			updatePanelVisibility();
			if (config.autoOpenOnScoreboard())
			{
				togglePanel(true, true);
			}
		}
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event)
	{
		if (event.getGroupId() == WIDGET_GROUP)
		{
			updatePanelVisibility();
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() == GameState.LOGGED_IN || gameStateChanged.getGameState() == GameState.LOADING)
		{
			clientThread.invokeLater(() -> {
				checkRegionAutoOpen();
				updatePanelVisibility();
			});
		}
	}

	/**
	 * This method specifically checks if a new region session is starting,
	 * and if so, triggers the auto-open.
	 */
	private void checkRegionAutoOpen()
	{
		boolean sessionActive = lastRegionEntryTime != null &&
				Duration.between(lastRegionEntryTime, Instant.now()).toMinutes() < config.regionTimeout();

		// If we are in the region, but a session wasn't previously active, it's a new session.
		if (config.showInRegion() && isInDelveRegion() && !sessionActive)
		{
			lastRegionEntryTime = Instant.now();
			togglePanel(true, config.autoOpenInRegion());
		}
	}

	/**
	 * The main logic hub. Determines if the panel icon should be visible based on all config settings.
	 */
	private void updatePanelVisibility()
	{
		sessionTimeoutTimer.stop();

		boolean shouldBeVisible = shouldShowPanel();
		togglePanel(shouldBeVisible, false); // This check never auto-opens.

		// If a session is active, ensure the timer is running to check for its expiration.
		if (lastRegionEntryTime != null)
		{
			long minutesSinceEntry = Duration.between(lastRegionEntryTime, Instant.now()).toMinutes();
			if (minutesSinceEntry < config.regionTimeout())
			{
				long minutesRemaining = config.regionTimeout() - minutesSinceEntry;
				sessionTimeoutTimer.setInitialDelay((int) TimeUnit.MINUTES.toMillis(minutesRemaining));
				sessionTimeoutTimer.start();
			}
			else
			{
				// Session has expired, clear the timestamp
				lastRegionEntryTime = null;
			}
		}
	}

	/**
	 * Determines if the panel icon should be visible by checking all configured conditions.
	 * @return true if any condition for visibility is met.
	 */
	private boolean shouldShowPanel()
	{
		// Condition 1: "Always Show" is enabled.
		if (config.alwaysShowPanel())
		{
			return true;
		}

		// Condition 2: "Show in Region" is enabled AND a session is active.
		boolean sessionActive = lastRegionEntryTime != null &&
				Duration.between(lastRegionEntryTime, Instant.now()).toMinutes() < config.regionTimeout();
		if (config.showInRegion() && sessionActive)
		{
			return true;
		}

		// Condition 3: "Show on Scoreboard" is enabled AND the scoreboard is visible.
		if (config.showOnScoreboard() && isScoreboardVisible())
		{
			return true;
		}

		return false; // No conditions met.
	}

	/**
	 * Handles the session-based logic for the REGION display mode.
	 */
	private void handleRegionSession()
	{
		boolean inRegion = isInDelveRegion();
		boolean sessionActive = lastRegionEntryTime != null &&
				Duration.between(lastRegionEntryTime, Instant.now()).toMinutes() < config.regionTimeout();

		if (inRegion)
		{
			if (!sessionActive)
			{
				lastRegionEntryTime = Instant.now();
				// Use the specific config for region auto-opening
				togglePanel(true, config.autoOpenInRegion());
			}
			else
			{
				togglePanel(true, false);
			}
		}
		else // Not in the region
		{
			if (!sessionActive)
			{
				lastRegionEntryTime = null;
				togglePanel(false, false);
				return;
			}
		}

		if (lastRegionEntryTime != null)
		{
			long minutesSinceEntry = Duration.between(lastRegionEntryTime, Instant.now()).toMinutes();
			long minutesRemaining = config.regionTimeout() - minutesSinceEntry;

			if (minutesRemaining > 0)
			{
				sessionTimeoutTimer.setInitialDelay((int) TimeUnit.MINUTES.toMillis(minutesRemaining));
				sessionTimeoutTimer.start();
			}
			else
			{
				updatePanelVisibility(); // Re-run logic if timer is already supposed to be expired
			}
		}
	}

	private boolean isInDelveRegion()
	{
		if (client.getGameState() != GameState.LOGGED_IN) return false;
		return Arrays.stream(client.getMapRegions()).anyMatch(
				regionId -> Arrays.stream(DELVE_REGION_IDS).anyMatch(delveId -> delveId == regionId)
		);
	}

	private boolean isScoreboardVisible()
	{
		Widget scoreboardWidget = client.getWidget(WIDGET_GROUP, 0);
		return scoreboardWidget != null && !scoreboardWidget.isHidden();
	}

	private void togglePanel(boolean show, boolean autoOpen)
	{
		SwingUtilities.invokeLater(() -> {
			if (show)
			{
				if (!panelVisible)
				{
					clientToolbar.addNavigation(navButton);
					panelVisible = true;
				}

				if (autoOpen)
				{
					SwingUtilities.invokeLater(() -> clientToolbar.openPanel(navButton));
				}
			}
			else
			{
				// This is the key fix: always remove the button if it should be hidden,
				// regardless of what our boolean thought its state was.
				clientToolbar.removeNavigation(navButton);
				panelVisible = false;
			}
		});
	}


	// Static method to get drop rates for external access
	public static Map<Integer, DropRates> getDropRates()
	{
		return DROP_RATES_BY_LEVEL;
	}

	private void updateKillCounts()
	{
		Map<Integer, Integer> levelKills = new HashMap<>();
		int wavesPast8 = 0;

		log.debug("Starting updateKillCounts - reading from widget group {}", WIDGET_GROUP);

		// Simple approach: read from child ID 46 to 70 with 3 increments
		// This covers Level 1 (46) through Level 8+ (70)
		for (int i = 0; i < 9; i++) // 9 levels: 1-8 + 8+
		{
			int childId = 46 + (i * 3);
			Widget widget = client.getWidget(WIDGET_GROUP, childId);

			log.debug("Reading widget {} for level {}: {}", childId, i + 1, widget != null ? widget.getText() : "null");

			if (widget != null && widget.getText() != null && !widget.getText().isEmpty())
			{
				String text = widget.getText().trim();

				try
				{
					// Extract just the number from the text
					String numberText = text.replaceAll("[^0-9]", "");
					if (!numberText.isEmpty())
					{
						int kills = Integer.parseInt(numberText);
						if (i == 8)
						{
							// This is Level 8+
							wavesPast8 = kills;
							log.debug("Level 8+ (waves past 8): {}", kills);
						}
						else
						{
							// This is a regular level (1-8)
							levelKills.put(i + 1, kills);
							log.debug("Level {}: {}", i + 1, kills);
						}
					}
					else
					{
						// No numeric data found
						if (i == 8)
						{
							wavesPast8 = 0;
							log.debug("Level 8+ (waves past 8): 0 (no numeric data)");
						}
						else
						{
							levelKills.put(i + 1, 0);
							log.debug("Level {}: 0 (no numeric data)", i + 1);
						}
					}
				}
				catch (NumberFormatException e)
				{
					if (i == 8)
					{
						wavesPast8 = 0;
						log.debug("Level 8+ (waves past 8): 0 (parse error)");
					}
					else
					{
						levelKills.put(i + 1, 0);
						log.debug("Level {}: 0 (parse error)", i + 1);
					}
				}
			}
			else
			{
				if (i == 8)
				{
					wavesPast8 = 0;
					log.debug("Level 8+ (waves past 8): 0 (widget null/empty)");
				}
				else
				{
					levelKills.put(i + 1, 0);
					log.debug("Level {}: 0 (widget null/empty)", i + 1);
				}
			}
		}

		log.debug("Final levelKills map: {}", levelKills);
		log.debug("Final wavesPast8: {}", wavesPast8);

		// Update the panel with new data
		if (panel != null)
		{
			log.debug("Calling panel.updateData with {} levels and {} waves past 8", levelKills.size(), wavesPast8);
			panel.updateData(levelKills, wavesPast8);
		}
		else
		{
			log.debug("Panel is null, cannot update data");
		}
	}

	// Helper class to store drop rates for each level
	public static class DropRates
	{
		public final double overallChance;
		public final double mokhaiotlCloth;
		public final double eyeOfAyak;
		public final double avernicTreads;
		public final double dom;
		public final double cumulativeChance;

		public DropRates(double overall, double mokhaiotl, double eye, double avernic, double dom, double cumulative)
		{
			this.overallChance = overall;
			this.mokhaiotlCloth = mokhaiotl;
			this.eyeOfAyak = eye;
			this.avernicTreads = avernic;
			this.dom = dom;
			this.cumulativeChance = cumulative;
		}
	}
}

package com.speaax;

import lombok.Data;
import java.util.Map;

/**
 * This class is a simple data container used for serializing and deserializing
 * the kill counts with Gson. It holds all the data that needs to be saved.
 */
@Data
public class DelveCalculatorData
{
    private Map<Integer, Integer> levelKills;
    private int wavesPast8;
}
package com.speaax;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;

@Slf4j
public class DelveCalculatorPanel extends PluginPanel
{
	private final ItemManager itemManager;
	private final DelveCalculatorConfig config;
	private final Gson gson;

	private final JLabel totalKillsLabel;
	private final JPanel progressPanel;
	private final JPanel noDataSectionPanel;

	private final Map<Integer, JLabel> levelValueLabels = new HashMap<>();
	private final Map<String, JPanel> itemPanels = new HashMap<>(); // To store and manage each reward panel

	private Map<Integer, Integer> currentLevelKills = new HashMap<>();
	private int currentWavesPast8 = 0;

	public DelveCalculatorPanel(DelveCalculatorPlugin plugin, DelveCalculatorConfig config, Gson gson)
	{
		this.itemManager = plugin.getItemManager();
		this.config = config;
		this.gson = gson;

		setBorder(new EmptyBorder(10, 10, 10, 10));
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setLayout(new BorderLayout());

		JPanel contentPanel = new JPanel();
		contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
		contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Title
		JLabel titleLabel = new JLabel("Delve Calculator");
		titleLabel.setFont(FontManager.getRunescapeBoldFont().deriveFont(24.0f));
		titleLabel.setForeground(Color.YELLOW);
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setBorder(new EmptyBorder(0, 0, 10, 0));

		// Kill Counts Panel
		JPanel killCountsPanel = new JPanel();
		killCountsPanel.setLayout(new BoxLayout(killCountsPanel, BoxLayout.Y_AXIS));
		killCountsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		killCountsPanel.setBorder(new EmptyBorder(5, 5, 5, 5));

		JPanel totalKillsPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
		totalKillsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		JLabel totalKillsLabelText = new JLabel("Total Levels: ");
		totalKillsLabelText.setForeground(Color.YELLOW);
		totalKillsLabelText.setFont(FontManager.getRunescapeBoldFont());
		totalKillsLabel = new JLabel("0");
		totalKillsLabel.setForeground(Color.WHITE);
		totalKillsLabel.setFont(FontManager.getRunescapeBoldFont());
		totalKillsPanel.add(totalKillsLabelText);
		totalKillsPanel.add(totalKillsLabel);
		killCountsPanel.add(totalKillsPanel);
		killCountsPanel.add(Box.createVerticalStrut(5));

		JPanel levelsPanel = new JPanel(new GridLayout(10, 1, 5, 2));
		levelsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		for (int i = 1; i <= 8; i++) {
			JPanel levelPanel = createLevelPanel("Level " + i + ": ");
			levelValueLabels.put(i, (JLabel) levelPanel.getComponent(1));
			levelsPanel.add(levelPanel);
		}
		JPanel levelPlusPanel = createLevelPanel("Level +: ");
		levelValueLabels.put(9, (JLabel) levelPlusPanel.getComponent(1));
		levelsPanel.add(levelPlusPanel);
		killCountsPanel.add(levelsPanel);

		// Progress and No Data Panels
		progressPanel = createProgressPanel();
		noDataSectionPanel = createNoDataSection();

		// Add components to main panel
		add(titleLabel, BorderLayout.NORTH);
		contentPanel.add(killCountsPanel);
		contentPanel.add(Box.createVerticalStrut(10));
		contentPanel.add(progressPanel);
		contentPanel.add(Box.createVerticalStrut(10));
		contentPanel.add(noDataSectionPanel);
		add(contentPanel, BorderLayout.CENTER);

		loadData();
		updateAllUI();
	}


	private void loadData()
	{
		String json = config.killCountData();
		if (json == null || json.isEmpty()) return;

		try
		{
			java.lang.reflect.Type type = new TypeToken<DelveCalculatorData>() {}.getType();
			DelveCalculatorData data = gson.fromJson(json, type);

			if (data != null)
			{
				this.currentLevelKills = data.getLevelKills() != null ? data.getLevelKills() : new HashMap<>();
				this.currentWavesPast8 = data.getWavesPast8();
			}
		}
		catch (Exception e) { log.debug("Error loading Delve Calculator data", e); }
	}

	private void saveData()
	{
		DelveCalculatorData data = new DelveCalculatorData();
		data.setLevelKills(currentLevelKills);
		data.setWavesPast8(currentWavesPast8);

		String json = gson.toJson(data);
		config.killCountData(json);
	}

	public void incrementFloorKills(int floor)
	{
		if (floor >= 1 && floor <= 8)
		{
			currentLevelKills.merge(floor, 1, Integer::sum);
			saveData();
			SwingUtilities.invokeLater(this::updateAllUI);
		}
	}

	public void incrementWavesPast8()
	{
		currentWavesPast8++;
		saveData();
		SwingUtilities.invokeLater(this::updateAllUI);
	}

	public void updateData(Map<Integer, Integer> levelKills, int wavesPast8)
	{
		this.currentLevelKills = new HashMap<>(levelKills);
		this.currentWavesPast8 = wavesPast8;
		saveData();
		SwingUtilities.invokeLater(this::updateAllUI);
	}

	public void updateAllUI()
	{
		int totalKills = currentLevelKills.values().stream().mapToInt(Integer::intValue).sum() + currentWavesPast8;
		totalKillsLabel.setText(String.valueOf(totalKills));

		for (int i = 1; i <= 8; i++)
		{
			levelValueLabels.get(i).setText(String.valueOf(currentLevelKills.getOrDefault(i, 0)));
		}
		levelValueLabels.get(9).setText(String.valueOf(currentWavesPast8));

		updateProgressBars();

		boolean hasData = totalKills > 0;
		noDataSectionPanel.setVisible(!hasData);
	}
	private JPanel createProgressPanel()
	{
		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.setBorder(new EmptyBorder(5, 5, 5, 5));

		JLabel headerLabel = new JLabel("Expected Drops:");
		headerLabel.setForeground(Color.YELLOW);
		headerLabel.setFont(FontManager.getRunescapeBoldFont());
		headerLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

		panel.add(headerLabel);
		panel.add(Box.createVerticalStrut(5));

		// Create and store each panel
		itemPanels.put("Any Item", addAnyItemProgressBar(panel));
		itemPanels.put("Mokhaiotl Cloth", addProgressBar(panel, "Mokhaiotl Cloth", ItemID.MOKHAIOTL_CLOTH));
		itemPanels.put("Eye of Ayak", addProgressBar(panel, "Eye of Ayak", ItemID.EYE_OF_AYAK));
		itemPanels.put("Avernic Treads", addProgressBar(panel, "Avernic Treads", ItemID.AVERNIC_TREADS));
		itemPanels.put("Dom", addProgressBar(panel, "Dom", ItemID.DOMPET));

		return panel;
	}
	private JPanel createLevelPanel(String labelText)
	{
		JPanel levelPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		levelPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JLabel levelLabel = new JLabel(labelText);
		levelLabel.setForeground(Color.YELLOW);
		levelLabel.setFont(FontManager.getRunescapeFont());

		JLabel levelValue = new JLabel("0");
		levelValue.setForeground(Color.WHITE);
		levelValue.setFont(FontManager.getRunescapeFont());

		levelPanel.add(levelLabel);
		levelPanel.add(levelValue);

		return levelPanel;
	}
	private JPanel addProgressBar(JPanel parent, String itemName, int itemId)
	{
		JPanel itemPanel = new JPanel(new BorderLayout(5, 0));
		itemPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		itemPanel.setBorder(new EmptyBorder(2, 0, 2, 0));

		ImageIcon icon = new ImageIcon(itemManager.getImage(itemId));
		JLabel iconLabel = new JLabel(icon);
		iconLabel.setPreferredSize(new Dimension(32, 32));

		JProgressBar progressBar = createProgressBar();
		JLabel expectedLabel = createExpectedLabel();

		// Store components for easy access
		itemPanel.putClientProperty("originalIcon", icon);
		itemPanel.putClientProperty("iconLabel", iconLabel);
		itemPanel.putClientProperty("progressBar", progressBar);
		itemPanel.putClientProperty("expectedLabel", expectedLabel);
		itemPanel.putClientProperty("itemName", itemName);

		itemPanel.add(iconLabel, BorderLayout.WEST);
		itemPanel.add(progressBar, BorderLayout.CENTER);
		itemPanel.add(expectedLabel, BorderLayout.EAST);

		parent.add(itemPanel);
		return itemPanel;
	}
	private JPanel addAnyItemProgressBar(JPanel parent)
	{
		JPanel anyItemPanel = new JPanel(new BorderLayout(5, 0));
		anyItemPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		anyItemPanel.setBorder(new EmptyBorder(2, 0, 2, 0));

		JPanel iconPanel = new JPanel(new GridBagLayout());
		iconPanel.setPreferredSize(new Dimension(32, 32));
		iconPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		JLabel iconLabel = new JLabel("Any");
		iconLabel.setForeground(Color.YELLOW);
		iconLabel.setFont(FontManager.getRunescapeFont());
		iconPanel.add(iconLabel);

		JProgressBar progressBar = createProgressBar();
		JLabel expectedLabel = createExpectedLabel();

		anyItemPanel.putClientProperty("progressBar", progressBar);
		anyItemPanel.putClientProperty("expectedLabel", expectedLabel);
		anyItemPanel.putClientProperty("itemName", "Any Item");

		anyItemPanel.add(iconPanel, BorderLayout.WEST);
		anyItemPanel.add(progressBar, BorderLayout.CENTER);
		anyItemPanel.add(expectedLabel, BorderLayout.EAST);

		parent.add(anyItemPanel);
		return anyItemPanel;
	}
	private JProgressBar createProgressBar()
	{
		JProgressBar progressBar = new JProgressBar(0, 100);
		progressBar.setValue(0);
		progressBar.setStringPainted(true);
		progressBar.setString("0.0%");
		progressBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		progressBar.setBorder(BorderFactory.createLineBorder(ColorScheme.LIGHT_GRAY_COLOR, 1));
		return progressBar;
	}
	private JLabel createExpectedLabel()
	{
		JLabel expectedLabel = new JLabel("0");
		expectedLabel.setForeground(Color.WHITE);
		expectedLabel.setFont(FontManager.getRunescapeFont());
		expectedLabel.setBorder(new EmptyBorder(0, 5, 0, 0));
		expectedLabel.setHorizontalAlignment(SwingConstants.CENTER);
		return expectedLabel;
	}
	private void updateProgressBars()
	{
		Map<String, Double> itemProgress = calculateItemProgress();
		Map<String, DelveCalculatorConfig.RewardDisplayMode> displayModes = getDisplayModes();

		for (Map.Entry<String, JPanel> entry : itemPanels.entrySet())
		{
			String itemName = entry.getKey();
			JPanel itemPanel = entry.getValue();
			DelveCalculatorConfig.RewardDisplayMode mode = displayModes.getOrDefault(itemName, DelveCalculatorConfig.RewardDisplayMode.SHOW);

			// Handle visibility
			if (mode == DelveCalculatorConfig.RewardDisplayMode.HIDE)
			{
				itemPanel.setVisible(false);
				continue;
			}
			itemPanel.setVisible(true);

			// Get components
			JProgressBar progressBar = (JProgressBar) itemPanel.getClientProperty("progressBar");
			JLabel expectedLabel = (JLabel) itemPanel.getClientProperty("expectedLabel");
			JLabel iconLabel = (JLabel) itemPanel.getClientProperty("iconLabel");

			// Update progress values
			double progress = itemProgress.getOrDefault(itemName, 0.0);
			double expectedItems = Math.floor(progress);
			double progressTowardsNextItem = (progress - expectedItems) * 100;
			int barValue = (int) progressTowardsNextItem;

			expectedLabel.setText(String.valueOf((int)expectedItems));
			progressBar.setValue(barValue);
			progressBar.setString(String.format("%.1f%%", progressTowardsNextItem));

			// Handle display mode styling
			if (mode == DelveCalculatorConfig.RewardDisplayMode.GREY)
			{
				progressBar.setForeground(Color.GRAY);
				expectedLabel.setForeground(Color.GRAY);
				if (iconLabel != null) // "Any" panel has no iconLabel property with an image
				{
					ImageIcon originalIcon = (ImageIcon) itemPanel.getClientProperty("originalIcon");
					if (originalIcon != null)
					{
						// Create and set a greyscale version of the icon
						BufferedImage greyImage = ImageUtil.grayscaleImage(ImageUtil.bufferedImageFromImage(originalIcon.getImage()));
						iconLabel.setIcon(new ImageIcon(greyImage));
					}
				}
			}
			else // SHOW mode
			{
				progressBar.setForeground(calculateProgressColor(barValue));
				expectedLabel.setForeground(Color.WHITE);
				if (iconLabel != null)
				{
					// Restore the original colored icon
					iconLabel.setIcon((ImageIcon) itemPanel.getClientProperty("originalIcon"));
				}
			}
		}
	}

	private Map<String, DelveCalculatorConfig.RewardDisplayMode> getDisplayModes()
	{
		Map<String, DelveCalculatorConfig.RewardDisplayMode> modes = new HashMap<>();
		modes.put("Any Item", DelveCalculatorConfig.RewardDisplayMode.SHOW);
		modes.put("Mokhaiotl Cloth", config.mokhaiotlClothDisplay());
		modes.put("Eye of Ayak", config.eyeOfAyakDisplay());
		modes.put("Avernic Treads", config.avernicTreadsDisplay());
		modes.put("Dom", config.domDisplay());
		return modes;
	}

	private Map<String, Double> calculateItemProgress()
	{
		Map<String, Double> progress = new HashMap<>();

		double mokhaiotlClothProgress = 0;
		double eyeOfAyakProgress = 0;
		double avernicTreadsProgress = 0;
		double domProgress = 0;

		for (Map.Entry<Integer, DelveCalculatorPlugin.DropRates> entry : DelveCalculatorPlugin.getDropRates().entrySet()) {
			int level = entry.getKey();
			DelveCalculatorPlugin.DropRates rates = entry.getValue();
			int kills = (level == 9) ? currentWavesPast8 : currentLevelKills.getOrDefault(level, 0);

			mokhaiotlClothProgress += kills * rates.mokhaiotlCloth;
			eyeOfAyakProgress += kills * rates.eyeOfAyak;
			avernicTreadsProgress += kills * rates.avernicTreads;
			domProgress += kills * rates.dom;
		}

		progress.put("Mokhaiotl Cloth", mokhaiotlClothProgress);
		progress.put("Eye of Ayak", eyeOfAyakProgress);
		progress.put("Avernic Treads", avernicTreadsProgress);
		progress.put("Dom", domProgress);

		// Calculate "Any Item" progress based on which items are set to SHOW
		double anyItemProgress = 0;
		if (config.mokhaiotlClothDisplay() == DelveCalculatorConfig.RewardDisplayMode.SHOW) anyItemProgress += mokhaiotlClothProgress;
		if (config.eyeOfAyakDisplay() == DelveCalculatorConfig.RewardDisplayMode.SHOW) anyItemProgress += eyeOfAyakProgress;
		if (config.avernicTreadsDisplay() == DelveCalculatorConfig.RewardDisplayMode.SHOW) anyItemProgress += avernicTreadsProgress;
		if (config.domDisplay() == DelveCalculatorConfig.RewardDisplayMode.SHOW) anyItemProgress += domProgress;

		progress.put("Any Item", anyItemProgress);

		return progress;
	}
	private Color calculateProgressColor(int barValue)
	{
		// Simple red-to-green gradient
		if (barValue <= 50) return new Color(255, (int) (255 * (barValue / 50.0f)), 0);
		else return new Color((int) (255 * (1.0f - (barValue - 50) / 50.0f)), 255, 0);
	}
	private JPanel createNoDataSection()
	{
		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.setBorder(new EmptyBorder(10, 10, 10, 10));

		JLabel noDataLabel = new JLabel("No data, read scoreboard outside the bossroom");
		noDataLabel.setForeground(Color.ORANGE);
		noDataLabel.setFont(FontManager.getRunescapeFont());
		noDataLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		panel.add(noDataLabel);
		panel.setVisible(false);

		return panel;
	}
}
package com.speaax;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DelveCalculatorPlugin.class);
		RuneLite.main(args);
	}
}
