package com.speaax;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("delvecalculator")
public interface DelveCalculatorConfig extends Config
{
    @ConfigItem(
            keyName = "killCountData",
            name = "",
            description = "",
            hidden = true
    )
    default String killCountData()
    {
        return "";
    }
    @ConfigItem(
            keyName = "killCountData",
            name = "",
            description = ""
    )
    void killCountData(String data);
}
package com.speaax;

import com.google.gson.Gson;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.config.ConfigManager;
import com.google.inject.Provides;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@PluginDescriptor(
	name = "Delve Calculator",
	description = "Calculates expected unique drops",
	tags = {"delve", "calculator", "drops", "rates", "doom"}
)
public class DelveCalculatorPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private DelveCalculatorConfig config;

	@Inject
	private Gson gson;

	@Inject
	private ClientToolbar clientToolbar;

	@Getter
	@Inject
	private ItemManager itemManager;

	private DelveCalculatorPanel panel;
	private NavigationButton navButton;

	// Widget group ID
	private static final int WIDGET_GROUP = 920;

	// Drop rate data based on the table you provided
	private static final Map<Integer, DropRates> DROP_RATES_BY_LEVEL = new HashMap<>();

	static {
		// Delve level 2
		DROP_RATES_BY_LEVEL.put(2, new DropRates(
			1.0/2500, 1.0/2500, 0, 0, 0, 0
		));
		
		// Delve level 3
		DROP_RATES_BY_LEVEL.put(3, new DropRates(
			1.0/1000, 1.0/2000, 1.0/2000, 0, 0, 0
		));
		
		// Delve level 4
		DROP_RATES_BY_LEVEL.put(4, new DropRates(
			1.0/450, 1.0/1350, 1.0/1350, 1.0/1350, 0, 0
		));
		
		// Delve level 5
		DROP_RATES_BY_LEVEL.put(5, new DropRates(
			1.0/270, 1.0/810, 1.0/810, 1.0/810, 0, 0
		));
		
		// Delve level 6
		DROP_RATES_BY_LEVEL.put(6, new DropRates(
			1.0/255, 1.0/765, 1.0/765, 1.0/765, 1.0/1000, 0
		));
		
		// Delve level 7
		DROP_RATES_BY_LEVEL.put(7, new DropRates(
			1.0/240, 1.0/720, 1.0/720, 1.0/720, 1.0/750, 0
		));
		
		// Delve level 8
		DROP_RATES_BY_LEVEL.put(8, new DropRates(
			1.0/210, 1.0/630, 1.0/630, 1.0/630, 1.0/500, 0
		));
		
		// Delve level 9+
		DROP_RATES_BY_LEVEL.put(9, new DropRates(
			1.0/180, 1.0/540, 1.0/540, 1.0/540, 1.0/250, 0
		));
	}

	@Provides
	DelveCalculatorConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(DelveCalculatorConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		panel = new DelveCalculatorPanel(this, config, gson);

		BufferedImage icon = null;
		try
		{
			icon = ImageUtil.loadImageResource(getClass(), "/icon.png");
		}
		catch (Exception e)
		{
			log.debug("Failed to load plugin icon", e);
		}
		
		navButton = NavigationButton.builder()
			.tooltip("Delve Calculator")
			.icon(icon)
			.priority(5)
			.panel(panel)
			.build();
		
		clientToolbar.addNavigation(navButton);
		

	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(navButton);
		navButton = null;
		panel = null;
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() == ChatMessageType.GAMEMESSAGE)
		{
			String message = event.getMessage();
			
			// Check for delve completion messages
			// Format: "Delve level: 4 duration: 1:45. Personal best: 1:27"
			// Format: "Delve level: 8+ (11) duration: 1:10.20. Personal best: 1:10.20"
			if (message.contains("Delve level:") && message.contains("duration:"))
			{
				// Extract delve level from the message
				String[] parts = message.split(" ");
				for (int i = 0; i < parts.length; i++)
				{
					if (parts[i].equals("level:") && i + 1 < parts.length)
					{
						String levelText = parts[i + 1];
						
						// Check if it's level 8+ (special case)
						if (levelText.equals("8+"))
						{
							log.debug("Delve completed! Level: 8+");
							panel.incrementWavesPast8();
							break;
						}
						else
						{
							// Regular level (1-8)
							try
							{
								int level = Integer.parseInt(levelText);
								if (level >= 1 && level <= 8)
								{
									log.debug("Delve completed! Level: {}", level);
									panel.incrementFloorKills(level);
									break;
								}
								else
								{
									log.debug("Invalid delve level: {}", level);
								}
							}
							catch (NumberFormatException e)
							{
								log.debug("Failed to parse delve level from message: {}", message);
							}
						}
					}
				}
			}
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (event.getGroupId() == WIDGET_GROUP)
		{
			// Use ClientThread instead of Timer for safer execution
			clientThread.invokeLater(this::updateKillCounts);
		}
	}

	// Static method to get drop rates for external access
	public static Map<Integer, DropRates> getDropRates()
	{
		return DROP_RATES_BY_LEVEL;
	}

	private void updateKillCounts()
	{
		Map<Integer, Integer> levelKills = new HashMap<>();
		int wavesPast8 = 0;

		log.debug("Starting updateKillCounts - reading from widget group {}", WIDGET_GROUP);

		// Simple approach: read from child ID 46 to 70 with 3 increments
		// This covers Level 1 (46) through Level 8+ (70)
		for (int i = 0; i < 9; i++) // 9 levels: 1-8 + 8+
		{
			int childId = 46 + (i * 3);
			Widget widget = client.getWidget(WIDGET_GROUP, childId);

			log.debug("Reading widget {} for level {}: {}", childId, i + 1, widget != null ? widget.getText() : "null");
			
			if (widget != null && widget.getText() != null && !widget.getText().isEmpty())
			{
				String text = widget.getText().trim();
				
				try
				{
					// Extract just the number from the text
					String numberText = text.replaceAll("[^0-9]", "");
					if (!numberText.isEmpty())
					{
						int kills = Integer.parseInt(numberText);
						if (i == 8)
						{
							// This is Level 8+
							wavesPast8 = kills;
							log.debug("Level 8+ (waves past 8): {}", kills);
						}
						else
						{
							// This is a regular level (1-8)
							levelKills.put(i + 1, kills);
							log.debug("Level {}: {}", i + 1, kills);
						}
					}
					else
					{
						// No numeric data found
						if (i == 8)
						{
							wavesPast8 = 0;
							log.debug("Level 8+ (waves past 8): 0 (no numeric data)");
						}
						else
						{
							levelKills.put(i + 1, 0);
							log.debug("Level {}: 0 (no numeric data)", i + 1);
						}
					}
				}
				catch (NumberFormatException e)
				{
					if (i == 8)
					{
						wavesPast8 = 0;
						log.debug("Level 8+ (waves past 8): 0 (parse error)");
					}
					else
					{
						levelKills.put(i + 1, 0);
						log.debug("Level {}: 0 (parse error)", i + 1);
					}
				}
			}
			else
			{
				if (i == 8)
				{
					wavesPast8 = 0;
					log.debug("Level 8+ (waves past 8): 0 (widget null/empty)");
				}
				else
				{
					levelKills.put(i + 1, 0);
					log.debug("Level {}: 0 (widget null/empty)", i + 1);
				}
			}
		}

		log.debug("Final levelKills map: {}", levelKills);
		log.debug("Final wavesPast8: {}", wavesPast8);

		// Update the panel with new data
		if (panel != null)
		{
			log.debug("Calling panel.updateData with {} levels and {} waves past 8", levelKills.size(), wavesPast8);
			panel.updateData(levelKills, wavesPast8);
		}
		else
		{
			log.debug("Panel is null, cannot update data");
		}
	}

	// Helper class to store drop rates for each level
	public static class DropRates
	{
		public final double overallChance;
		public final double mokhaiotlCloth;
		public final double eyeOfAyak;
		public final double avernicTreads;
		public final double dom;
		public final double cumulativeChance;

		public DropRates(double overall, double mokhaiotl, double eye, double avernic, double dom, double cumulative)
		{
			this.overallChance = overall;
			this.mokhaiotlCloth = mokhaiotl;
			this.eyeOfAyak = eye;
			this.avernicTreads = avernic;
			this.dom = dom;
			this.cumulativeChance = cumulative;
		}
	}
}

package com.speaax;

import lombok.Data;
import java.util.Map;

/**
 * This class is a simple data container used for serializing and deserializing
 * the kill counts with Gson. It holds all the data that needs to be saved.
 */
@Data
public class DelveCalculatorData
{
    private Map<Integer, Integer> levelKills;
    private int wavesPast8;
}
package com.speaax;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

@Slf4j
public class DelveCalculatorPanel extends PluginPanel
{
	private final ItemManager itemManager;
	private final DelveCalculatorConfig config;
	private final Gson gson;

	private final JLabel totalKillsLabel;
	private final JPanel progressPanel;
	private final JPanel noDataSectionPanel;

	private final Map<Integer, JLabel> levelValueLabels = new HashMap<>();

	private Map<Integer, Integer> currentLevelKills = new HashMap<>();
	private int currentWavesPast8 = 0;

	public DelveCalculatorPanel(DelveCalculatorPlugin plugin, DelveCalculatorConfig config, Gson gson)
	{
		this.itemManager = plugin.getItemManager();
		this.config = config;
		this.gson = gson;

		setBorder(new EmptyBorder(10, 10, 10, 10));
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setLayout(new BorderLayout());

		JPanel contentPanel = new JPanel();
		contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
		contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Title
		JLabel titleLabel = new JLabel("Delve Calculator");
		titleLabel.setFont(FontManager.getRunescapeBoldFont().deriveFont(24.0f));
		titleLabel.setForeground(Color.YELLOW);
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setBorder(new EmptyBorder(0, 0, 10, 0));

		// Kill Counts Panel
		JPanel killCountsPanel = new JPanel();
		killCountsPanel.setLayout(new BoxLayout(killCountsPanel, BoxLayout.Y_AXIS));
		killCountsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		killCountsPanel.setBorder(new EmptyBorder(5, 5, 5, 5));

		JPanel totalKillsPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
		totalKillsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		JLabel totalKillsLabelText = new JLabel("Total Levels: ");
		totalKillsLabelText.setForeground(Color.YELLOW);
		totalKillsLabelText.setFont(FontManager.getRunescapeBoldFont());
		totalKillsLabel = new JLabel("0");
		totalKillsLabel.setForeground(Color.WHITE);
		totalKillsLabel.setFont(FontManager.getRunescapeBoldFont());
		totalKillsPanel.add(totalKillsLabelText);
		totalKillsPanel.add(totalKillsLabel);
		killCountsPanel.add(totalKillsPanel);
		killCountsPanel.add(Box.createVerticalStrut(5));

		JPanel levelsPanel = new JPanel(new GridLayout(10, 1, 5, 2));
		levelsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		for (int i = 1; i <= 8; i++) {
			JPanel levelPanel = createLevelPanel("Level " + i + ": ");
			levelValueLabels.put(i, (JLabel) levelPanel.getComponent(1));
			levelsPanel.add(levelPanel);
		}
		JPanel levelPlusPanel = createLevelPanel("Level +: ");
		levelValueLabels.put(9, (JLabel) levelPlusPanel.getComponent(1));
		levelsPanel.add(levelPlusPanel);
		killCountsPanel.add(levelsPanel);

		// Progress and No Data Panels
		progressPanel = createProgressPanel();
		noDataSectionPanel = createNoDataSection();

		// Add components to main panel
		add(titleLabel, BorderLayout.NORTH);
		contentPanel.add(killCountsPanel);
		contentPanel.add(Box.createVerticalStrut(10));
		contentPanel.add(progressPanel);
		contentPanel.add(Box.createVerticalStrut(10));
		contentPanel.add(noDataSectionPanel);
		add(contentPanel, BorderLayout.CENTER);

		loadData();
		updateAllUI();
	}


	private void loadData()
	{
		String json = config.killCountData();
		if (json == null || json.isEmpty())
		{
			return;
		}

		try
		{
			java.lang.reflect.Type type = new TypeToken<DelveCalculatorData>() {}.getType();
			DelveCalculatorData data = gson.fromJson(json, type);

			if (data != null)
			{
				this.currentLevelKills = data.getLevelKills() != null ? data.getLevelKills() : new HashMap<>();
				this.currentWavesPast8 = data.getWavesPast8();
			}
		}
		catch (Exception e)
		{
			log.debug("Error loading Delve Calculator data", e);
		}
	}

	private void saveData()
	{
		DelveCalculatorData data = new DelveCalculatorData();
		data.setLevelKills(currentLevelKills);
		data.setWavesPast8(currentWavesPast8);

		String json = gson.toJson(data);
		config.killCountData(json);
	}

	public void incrementFloorKills(int floor)
	{
		if (floor >= 1 && floor <= 8)
		{
			currentLevelKills.merge(floor, 1, Integer::sum);
			saveData();
			SwingUtilities.invokeLater(this::updateAllUI);
		}
	}

	public void incrementWavesPast8()
	{
		currentWavesPast8++;
		saveData();
		SwingUtilities.invokeLater(this::updateAllUI);
	}

	public void updateData(Map<Integer, Integer> levelKills, int wavesPast8)
	{
		this.currentLevelKills = new HashMap<>(levelKills);
		this.currentWavesPast8 = wavesPast8;
		saveData();
		SwingUtilities.invokeLater(this::updateAllUI);
	}

	private void updateAllUI()
	{
		int totalKills = currentLevelKills.values().stream().mapToInt(Integer::intValue).sum() + currentWavesPast8;
		totalKillsLabel.setText(String.valueOf(totalKills));

		for (int i = 1; i <= 8; i++)
		{
			levelValueLabels.get(i).setText(String.valueOf(currentLevelKills.getOrDefault(i, 0)));
		}
		levelValueLabels.get(9).setText(String.valueOf(currentWavesPast8));

		updateProgressBars();

		boolean hasData = totalKills > 0;
		noDataSectionPanel.setVisible(!hasData);
	}
	private JPanel createProgressPanel()
	{
		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.setBorder(new EmptyBorder(5, 5, 5, 5));

		JLabel headerLabel = new JLabel("Expected Drops:");
		headerLabel.setForeground(Color.YELLOW);
		headerLabel.setFont(FontManager.getRunescapeBoldFont());
		headerLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

		panel.add(headerLabel);
		panel.add(Box.createVerticalStrut(5));

		addAnyItemProgressBar(panel);
		addProgressBar(panel, "Mokhaiotl Cloth", ItemID.MOKHAIOTL_CLOTH);
		addProgressBar(panel, "Eye of Ayak", ItemID.EYE_OF_AYAK);
		addProgressBar(panel, "Avernic Treads", ItemID.AVERNIC_TREADS);
		addProgressBar(panel, "Dom", ItemID.DOMPET);

		return panel;
	}
	private JPanel createLevelPanel(String labelText)
	{
		JPanel levelPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		levelPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JLabel levelLabel = new JLabel(labelText);
		levelLabel.setForeground(Color.YELLOW);
		levelLabel.setFont(FontManager.getRunescapeFont());

		JLabel levelValue = new JLabel("0");
		levelValue.setForeground(Color.WHITE);
		levelValue.setFont(FontManager.getRunescapeFont());

		levelPanel.add(levelLabel);
		levelPanel.add(levelValue);

		return levelPanel;
	}
	private void addProgressBar(JPanel parent, String itemName, int itemId)
	{
		JPanel itemPanel = new JPanel(new BorderLayout(5, 0));
		itemPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		itemPanel.setBorder(new EmptyBorder(2, 0, 2, 0));

		JLabel iconLabel = new JLabel(new ImageIcon(itemManager.getImage(itemId)));
		iconLabel.setPreferredSize(new Dimension(32, 32));

		JProgressBar progressBar = createProgressBar();
		JLabel expectedLabel = createExpectedLabel();

		itemPanel.putClientProperty("progressBar", progressBar);
		itemPanel.putClientProperty("expectedLabel", expectedLabel);
		itemPanel.putClientProperty("itemName", itemName);

		itemPanel.add(iconLabel, BorderLayout.WEST);
		itemPanel.add(progressBar, BorderLayout.CENTER);
		itemPanel.add(expectedLabel, BorderLayout.EAST);

		parent.add(itemPanel);
	}
	private void addAnyItemProgressBar(JPanel parent)
	{
		JPanel anyItemPanel = new JPanel(new BorderLayout(5, 0));
		anyItemPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		anyItemPanel.setBorder(new EmptyBorder(2, 0, 2, 0));

		JPanel iconPanel = new JPanel(new GridBagLayout());
		iconPanel.setPreferredSize(new Dimension(32, 32));
		iconPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		JLabel iconLabel = new JLabel("Any");
		iconLabel.setForeground(Color.YELLOW);
		iconLabel.setFont(FontManager.getRunescapeFont());
		iconPanel.add(iconLabel);

		JProgressBar progressBar = createProgressBar();
		JLabel expectedLabel = createExpectedLabel();

		anyItemPanel.putClientProperty("progressBar", progressBar);
		anyItemPanel.putClientProperty("expectedLabel", expectedLabel);
		anyItemPanel.putClientProperty("itemName", "Any Item");

		anyItemPanel.add(iconPanel, BorderLayout.WEST);
		anyItemPanel.add(progressBar, BorderLayout.CENTER);
		anyItemPanel.add(expectedLabel, BorderLayout.EAST);

		parent.add(anyItemPanel);
	}
	private JProgressBar createProgressBar()
	{
		JProgressBar progressBar = new JProgressBar(0, 100);
		progressBar.setValue(0);
		progressBar.setStringPainted(true);
		progressBar.setString("0.0%");
		progressBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		progressBar.setBorder(BorderFactory.createLineBorder(ColorScheme.LIGHT_GRAY_COLOR, 1));
		return progressBar;
	}
	private JLabel createExpectedLabel()
	{
		JLabel expectedLabel = new JLabel("0");
		expectedLabel.setForeground(Color.WHITE);
		expectedLabel.setFont(FontManager.getRunescapeFont());
		expectedLabel.setBorder(new EmptyBorder(0, 5, 0, 0));
		expectedLabel.setHorizontalAlignment(SwingConstants.CENTER);
		return expectedLabel;
	}
	private void updateProgressBars()
	{
		Map<String, Double> itemProgress = calculateItemProgress();

		for (Component comp : progressPanel.getComponents())
		{
			if (comp instanceof JPanel)
			{
				JPanel itemPanel = (JPanel) comp;
				String itemName = (String) itemPanel.getClientProperty("itemName");
				JProgressBar progressBar = (JProgressBar) itemPanel.getClientProperty("progressBar");
				JLabel expectedLabel = (JLabel) itemPanel.getClientProperty("expectedLabel");

				if (itemName != null && progressBar != null && expectedLabel != null)
				{
					double progress = itemProgress.getOrDefault(itemName, 0.0);

					double expectedItems = Math.floor(progress);
					expectedLabel.setText(String.valueOf((int)expectedItems));

					double progressTowardsNextItem = (progress - expectedItems) * 100;
					int barValue = (int) progressTowardsNextItem;

					progressBar.setValue(barValue);
					progressBar.setString(String.format("%.1f%%", progressTowardsNextItem));
					progressBar.setForeground(calculateProgressColor(barValue));
				}
			}
		}
	}
	private Map<String, Double> calculateItemProgress()
	{
		Map<String, Double> progress = new HashMap<>();

		double mokhaiotlClothProgress = 0;
		double eyeOfAyakProgress = 0;
		double avernicTreadsProgress = 0;
		double domProgress = 0;

		for (Map.Entry<Integer, DelveCalculatorPlugin.DropRates> entry : DelveCalculatorPlugin.getDropRates().entrySet()) {
			int level = entry.getKey();
			DelveCalculatorPlugin.DropRates rates = entry.getValue();
			int kills = (level == 9) ? currentWavesPast8 : currentLevelKills.getOrDefault(level, 0);

			mokhaiotlClothProgress += kills * rates.mokhaiotlCloth;
			eyeOfAyakProgress += kills * rates.eyeOfAyak;
			avernicTreadsProgress += kills * rates.avernicTreads;
			domProgress += kills * rates.dom;
		}

		progress.put("Mokhaiotl Cloth", mokhaiotlClothProgress);
		progress.put("Eye of Ayak", eyeOfAyakProgress);
		progress.put("Avernic Treads", avernicTreadsProgress);
		progress.put("Dom", domProgress);
		progress.put("Any Item", mokhaiotlClothProgress + eyeOfAyakProgress + avernicTreadsProgress + domProgress);

		return progress;
	}
	private Color calculateProgressColor(int barValue)
	{
		if (barValue <= 50)
		{
			return new Color(255, (int) (255 * (barValue / 50.0f)), 0);
		}
		else
		{
			return new Color((int) (255 * (1.0f - (barValue - 50) / 50.0f)), 255, 0);
		}
	}
	private JPanel createNoDataSection()
	{
		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.setBorder(new EmptyBorder(10, 10, 10, 10));

		JLabel noDataLabel = new JLabel("No data, read scoreboard outside the bossroom");
		noDataLabel.setForeground(Color.ORANGE);
		noDataLabel.setFont(FontManager.getRunescapeFont());
		noDataLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		panel.add(noDataLabel);
		panel.setVisible(false);

		return panel;
	}
}
package com.speaax;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DelveCalculatorPlugin.class);
		RuneLite.main(args);
	}
}
