package com.speaax;

import net.runelite.client.config.*;

@ConfigGroup("delvecalculator")
public interface DelveCalculatorConfig extends Config
{
    // --- General Settings ---
    @ConfigSection(
            name = "General",
            description = "General panel visibility settings",
            position = 0,
            closedByDefault = false
    )
    String generalSettings = "generalSettings";

    @ConfigItem(
            keyName = "alwaysShowPanel",
            name = "Show Icon Everywhere",
            description = "Keeps the panel icon visible at all times. If off, it will only appear when specific conditions below are met.",
            section = generalSettings,
            position = 1
    )
    default boolean alwaysShowPanel()
    {
        return true;
    }


    // --- Region Settings ---
    @ConfigSection(
            name = "Region Settings",
            description = "Make the panel appear when you are in the Delve region.",
            position = 1
    )
    String regionSettings = "regionSettings";

    @ConfigItem(
            keyName = "showInRegion",
            name = "Show Icon in Region",
            description = "Shows the panel icon when you are inside the Delve region.",
            section = regionSettings,
            position = 2
    )
    default boolean showInRegion()
    {
        return false;
    }

    @ConfigItem(
            keyName = "autoOpenInRegion",
            name = "Auto Open in Region",
            description = "Automatically open the panel when a new Region session begins.",
            section = regionSettings,
            position = 3
    )
    default boolean autoOpenInRegion()
    {
        return false;
    }

    @ConfigItem(
            keyName = "regionTimeout",
            name = "Hide plugin after",
            description = "<html>Session timer in minutes. This timer starts once you leave the region." +
                    "<br>" +
                    "The icon remains visible during this time while outside the region, nice for banking." +
                    "<br><br>" +
                    "If the panel is open when the timer runs out, it will hide once the side panel is closed, and the game loads (running/teleporting etc).</html>",
            section = regionSettings,
            position = 4
    )
    @Units(Units.MINUTES)
    default int regionTimeout()
    {
        return 10;
    }


    // --- Scoreboard Settings ---
    @ConfigSection(
            name = "Scoreboard Settings",
            description = "Make the panel appear when the Delve scoreboard is open.",
            position = 2
    )
    String scoreboardSettings = "scoreboardSettings";

    @ConfigItem(
            keyName = "showOnScoreboard",
            name = "Show Icon on Scoreboard",
            description = "Shows the panel icon when the Delve scoreboard is open.",
            section = scoreboardSettings,
            position = 5
    )
    default boolean showOnScoreboard()
    {
        return false;
    }

    @ConfigItem(
            keyName = "autoOpenOnScoreboard",
            name = "Auto Open on Scoreboard",
            description = "Automatically open the panel when you open the Delve scoreboard.",
            section = scoreboardSettings,
            position = 6
    )
    default boolean autoOpenOnScoreboard()
    {
        return true;
    }

    // --- Reward Display Settings ---
    @ConfigSection(
            name = "Reward Display",
            description = "Configure how each reward is displayed and if it's included in the 'Any' unique calculation.",
            position = 3,
            closedByDefault = false
    )
    String rewardSettings = "rewardSettings";

    enum RewardDisplayMode
    {
        SHOW,  // Displayed normally and included in 'Any' calculation.
        GREY,  // Displayed but greyed out; NOT included in 'Any' calculation.
        HIDE   // Not displayed; NOT included in 'Any' calculation.
    }

    @ConfigItem(
            keyName = "mokhaiotlClothDisplay",
            name = "Mokhaiotl's Cloth",
            description = "How to display the Mokhaiotl's Cloth reward. 'Grey' or 'Hide' will exclude it from the 'Any' unique calculation.",
            section = rewardSettings,
            position = 7
    )
    default RewardDisplayMode mokhaiotlClothDisplay() { return RewardDisplayMode.SHOW; }

    @ConfigItem(
            keyName = "eyeOfAyakDisplay",
            name = "Eye of Ayak",
            description = "How to display the Eye of Ayak reward. 'Grey' or 'Hide' will exclude it from the 'Any' unique calculation.",
            section = rewardSettings,
            position = 8
    )
    default RewardDisplayMode eyeOfAyakDisplay() { return RewardDisplayMode.SHOW; }

    @ConfigItem(
            keyName = "avernicTreadsDisplay",
            name = "Avernic Treads",
            description = "How to display the Avernic Treads reward. 'Grey' or 'Hide' will exclude it from the 'Any' unique calculation.",
            section = rewardSettings,
            position = 9
    )
    default RewardDisplayMode avernicTreadsDisplay() { return RewardDisplayMode.SHOW; }

    @ConfigItem(
            keyName = "domDisplay",
            name = "Dom",
            description = "How to display the D.O.M. reward. 'Grey' or 'Hide' will exclude it from the 'Any' unique calculation.",
            section = rewardSettings,
            position = 10
    )
    default RewardDisplayMode domDisplay() { return RewardDisplayMode.SHOW; }

    // --- Hidden Data ---
    @ConfigItem(
            keyName = "killCountData",
            name = "",
            description = "",
            hidden = true
    )
    default String killCountData() { return ""; }

    @ConfigItem(
            keyName = "killCountData",
            name = "",
            description = ""
    )
    void killCountData(String data);

    @ConfigItem(
            keyName = "activeViewTab",
            name = "Active View Tab",
            description = "The last selected view tab.",
            hidden = true
    )
    default String activeViewTab() { return "ALL"; }

    @ConfigItem(keyName = "activeViewTab", name = "", description = "")
    void activeViewTab(String tab);

    @ConfigItem(
            keyName = "activeModeTab",
            name = "Active Mode Tab",
            description = "The last selected mode tab.",
            hidden = true
    )
    default String activeModeTab() { return "EXPECTED"; }

    @ConfigItem(keyName = "activeModeTab", name = "", description = "")
    void activeModeTab(String mode);
}
package com.speaax;

import com.google.gson.Gson;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.ScriptID;
import net.runelite.api.WorldType;
import net.runelite.api.events.*;
import net.runelite.api.ItemID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.util.Text;
import com.google.inject.Provides;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
	name = "Delve Calculator",
	description = "Calculates expected unique drops",
	tags = {"delve", "calculator", "drops", "rates", "doom"}
)
public class DelveCalculatorPlugin extends Plugin
{
	@Inject private Client client;
	@Inject @Getter private ClientThread clientThread;
	@Inject private DelveCalculatorConfig config;
	@Inject private Gson gson;
	@Inject private ClientToolbar clientToolbar;
	@Getter @Inject private ItemManager itemManager;

	private DelveCalculatorPanel panel;
	private NavigationButton navButton;
	private Timer sessionTimeoutTimer;
	private boolean panelVisible = false;
	private Instant lastRegionEntryTime = null;
	private boolean inDelveRegion = false;

	private final Map<String, DelveCalculatorData.DelveProfile> sessionProfiles = new HashMap<>();

	public DelveCalculatorData.DelveProfile getSessionProfile(String mode)
	{
		return sessionProfiles.computeIfAbsent(mode, k -> new DelveCalculatorData.DelveProfile("Session", false));
	}

	private static final int WIDGET_GROUP_SCOREBOARD = 920;
	private static final int WIDGET_GROUP_COLLECTION_LOG = 621;
	private static final int WIDGET_COLLECTION_LOG_ITEMS = 37;

	// Loot Interface Constants
	private static final int WIDGET_GROUP_LOOT = 919;
	private static final int WIDGET_LOOT_CLAIM_HEADER = 8;
	private static final int WIDGET_LOOT_CONTENTS = 19;

	private static final int[] DELVE_REGION_IDS = {5269, 13668, 14180};
	private static final Map<Integer, DropRates> DROP_RATES_BY_LEVEL = new HashMap<>();
	private static final Map<String, Integer> UNIQUE_DROPS = new HashMap<>();

	static {
		DROP_RATES_BY_LEVEL.put(2, new DropRates(1.0/2500, 1.0/2500, 0, 0, 0));
		DROP_RATES_BY_LEVEL.put(3, new DropRates(1.0/1000, 1.0/2000, 1.0/2000, 0, 0));
		DROP_RATES_BY_LEVEL.put(4, new DropRates(1.0/450, 1.0/1350, 1.0/1350, 1.0/1350, 0));
		DROP_RATES_BY_LEVEL.put(5, new DropRates(1.0/270, 1.0/810, 1.0/810, 1.0/810, 0));
		DROP_RATES_BY_LEVEL.put(6, new DropRates(1.0/255, 1.0/765, 1.0/765, 1.0/765, 1.0/1000));
		DROP_RATES_BY_LEVEL.put(7, new DropRates(1.0/240, 1.0/720, 1.0/720, 1.0/720, 1.0/750));
		DROP_RATES_BY_LEVEL.put(8, new DropRates(1.0/210, 1.0/630, 1.0/630, 1.0/630, 1.0/500));
		DROP_RATES_BY_LEVEL.put(9, new DropRates(1.0/180, 1.0/540, 1.0/540, 1.0/540, 1.0/250));

		UNIQUE_DROPS.put("Mokhaiotl cloth", ItemID.MOKHAIOTL_CLOTH);
		UNIQUE_DROPS.put("Eye of ayak (uncharged)", ItemID.EYE_OF_AYAK_UNCHARGED);
		UNIQUE_DROPS.put("Avernic treads", ItemID.AVERNIC_TREADS);
		UNIQUE_DROPS.put("Dom", ItemID.DOM);
	}

	@Provides
	DelveCalculatorConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(DelveCalculatorConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		panel = new DelveCalculatorPanel(this, config, gson);
		BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");

		navButton = NavigationButton.builder()
				.tooltip("Delve Calculator")
				.icon(icon)
				.priority(5)
				.panel(panel)
				.build();

		sessionTimeoutTimer = new Timer(0, e -> updatePanelVisibility());
		sessionTimeoutTimer.setRepeats(false);

		clientToolbar.addNavigation(navButton);
		panelVisible = true;
		updatePanelVisibility();
	}

	@Override
	protected void shutDown() throws Exception
	{
		if (sessionTimeoutTimer != null) {
			sessionTimeoutTimer.stop();
		}
		
		if (navButton != null) {
			clientToolbar.removeNavigation(navButton);
			navButton = null;
		}
		
		if (panel != null) {
			panel = null;
		}
		
		lastRegionEntryTime = null;
	}

	public String getCurrentGameMode()
	{
		if (client == null) return "STANDARD";
		EnumSet<WorldType> types = client.getWorldType();
		if (types == null || types.isEmpty()) return "STANDARD";

		// Sort and join all active world types to create a unique future-proof key
		return types.stream()
				.map(Enum::name)
				.sorted()
				.collect(Collectors.joining("_"));
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() == ChatMessageType.GAMEMESSAGE || event.getType() == ChatMessageType.SPAM)
		{
			String message = Text.removeTags(event.getMessage());
			if (message.contains("Delve level:") && message.contains("duration:"))
			{
				handleDelveCompletion(message);
			}
		}
	}

	private void handleDelveCompletion(String message)
	{
		String[] parts = message.split(" ");
		for (int i = 0; i < parts.length; i++)
		{
			if (parts[i].equals("level:") && i + 1 < parts.length)
			{
				String levelText = parts[i + 1];
				String gameMode = getCurrentGameMode();
				if (levelText.equals("8+"))
				{
					if (panel != null) panel.incrementWavesPast8(gameMode);
					break;
				}
				else
				{
					try
					{
						int level = Integer.parseInt(levelText);
						if (level >= 1 && level <= 8)
						{
						if (level >= 1 && level <= 8)
						{
							if (panel != null) panel.incrementFloorKills(gameMode, level);
							break;
						}
						}
					}
					catch (NumberFormatException ignored) {}
				}
			}
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals("delvecalculator"))
		{
			updatePanelVisibility();
			if (panel != null) panel.updateAllUI();
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (event.getGroupId() == WIDGET_GROUP_SCOREBOARD)
		{
			clientThread.invokeLater(this::updateKillCounts);
			updatePanelVisibility();
			if (config.autoOpenOnScoreboard()) togglePanel(true, true);
		}
		if (event.getGroupId() == WIDGET_GROUP_LOOT)
		{
			clientThread.invokeLater(this::scanLootInterface);
		}
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event)
	{
		if (event.getGroupId() == WIDGET_GROUP_SCOREBOARD) updatePanelVisibility();
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired event)
	{
		// COLLECTION_LOG_SEND_CATEGORY (1212) or COLLECTION_DRAW_LIST
		if (event.getScriptId() == 1212 || event.getScriptId() == ScriptID.COLLECTION_DRAW_LIST)
		{
			clientThread.invokeLater(this::syncCollectionLog);
		}
	}


	private void syncCollectionLog()
	{
		Widget itemsContainer = client.getWidget(WIDGET_GROUP_COLLECTION_LOG, WIDGET_COLLECTION_LOG_ITEMS);
		if (itemsContainer == null || itemsContainer.isHidden()) return;

		Widget[] children = itemsContainer.getChildren();
		if (children == null) return;

		Map<Integer, Integer> foundDrops = new HashMap<>();
		boolean isDelvePage = false;
		for (Widget child : children)
		{
			int itemId = child.getItemId();
			int quantity = child.getItemQuantity();
			if (child.getOpacity() > 0) quantity = 0;

			String name = itemManager.getItemComposition(itemId).getName();
			if (name == null) continue;

			for (Map.Entry<String, Integer> entry : UNIQUE_DROPS.entrySet()) {
				if (entry.getKey().equalsIgnoreCase(name)) {
					isDelvePage = true;
					foundDrops.put(entry.getValue(), quantity);
				}
			}
		}
		if (isDelvePage && panel != null)
		{
			panel.syncCollectionLogData(getCurrentGameMode(), foundDrops);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() != GameState.LOGGED_IN) return;
		clientThread.invokeLater(() -> {
			boolean wasInDelveRegion = inDelveRegion;
			inDelveRegion = isInDelveRegion();
			if (panel != null) panel.switchGameMode(getCurrentGameMode());
			if (inDelveRegion && !wasInDelveRegion)
			{
				if (sessionTimeoutTimer != null) sessionTimeoutTimer.stop();
				lastRegionEntryTime = Instant.now();
				togglePanel(true, config.autoOpenInRegion());
			}
			else if (!inDelveRegion && wasInDelveRegion)
			{
				if (sessionTimeoutTimer != null) {
					sessionTimeoutTimer.setInitialDelay((int) TimeUnit.MINUTES.toMillis(config.regionTimeout()));
					sessionTimeoutTimer.start();
				}
			}
			updatePanelVisibility();
		});
	}

	private void updatePanelVisibility()
	{
		boolean shouldBeVisible = shouldShowPanel();
		togglePanel(shouldBeVisible, false);
	}

	private boolean shouldShowPanel()
	{
		if (config.alwaysShowPanel()) return true;
		if (config.showOnScoreboard() && isScoreboardVisible()) return true;
		if (config.showInRegion() && inDelveRegion) return true;
		if (config.showInRegion() && sessionTimeoutTimer != null && sessionTimeoutTimer.isRunning()) return true;
		return false;
	}

	private boolean isInDelveRegion()
	{
		if (client.getGameState() != GameState.LOGGED_IN) return false;
		return Arrays.stream(client.getMapRegions()).anyMatch(
				regionId -> Arrays.stream(DELVE_REGION_IDS).anyMatch(delveId -> delveId == regionId)
		);
	}

	private boolean isScoreboardVisible()
	{
		Widget scoreboardWidget = client.getWidget(WIDGET_GROUP_SCOREBOARD, 0);
		return scoreboardWidget != null && !scoreboardWidget.isHidden();
	}

	private void togglePanel(boolean show, boolean autoOpen)
	{
		SwingUtilities.invokeLater(() -> {
			if (show)
			{
				if (navButton == null) return;
				if (!panelVisible)
				{
					clientToolbar.addNavigation(navButton);
					panelVisible = true;
				}
				if (autoOpen)
				{
					clientToolbar.openPanel(navButton);
				}
			}
			else
			{
				if (navButton == null) return;
				if (navButton.getPanel() != null && navButton.getPanel().isShowing()) return;
				clientToolbar.removeNavigation(navButton);
				panelVisible = false;
			}
		});
	}

	public static Map<Integer, DropRates> getDropRates()
	{
		return DROP_RATES_BY_LEVEL;
	}

	public static Map<String, Integer> getUniqueDropsMap()
	{
		return UNIQUE_DROPS;
	}

	private void updateKillCounts()
	{
		Map<Integer, Integer> levelKills = new HashMap<>();
		int wavesPast8 = 0;
		for (int i = 0; i < 9; i++)
		{
			int childId = 46 + (i * 3);
			Widget widget = client.getWidget(WIDGET_GROUP_SCOREBOARD, childId);
			if (widget != null && widget.getText() != null && !widget.getText().isEmpty())
			{
				String text = widget.getText().trim();
				try
				{
					String numberText = text.replaceAll("[^0-9]", "");
					if (!numberText.isEmpty())
					{
						int kills = Integer.parseInt(numberText);
						if (i == 8) wavesPast8 = kills;
						else levelKills.put(i + 1, kills);
					}
				}
				catch (NumberFormatException ignored) {}
			}
		}
		if (panel != null)
		{
			panel.syncOverallData(getCurrentGameMode(), levelKills, wavesPast8);
		}
	}

	private void scanLootInterface()
	{
		Widget lootInterface = client.getWidget(WIDGET_GROUP_LOOT, WIDGET_LOOT_CONTENTS);
		Widget claimHeader = client.getWidget(WIDGET_GROUP_LOOT, WIDGET_LOOT_CLAIM_HEADER);
		if (lootInterface == null || lootInterface.isHidden() || claimHeader == null || claimHeader.isHidden()) return;

		Widget[] children = lootInterface.getChildren();
		if (children == null) return;

		for (Widget item : children)
		{
			int itemId = item.getItemId();
			if (itemId <= -1) continue;
			String name = itemManager.getItemComposition(itemId).getName();
			if (name == null) continue;
			for (Map.Entry<String, Integer> entry : UNIQUE_DROPS.entrySet())
			{
				if (entry.getKey().equalsIgnoreCase(name))
				{
					handleDropLogic(getCurrentGameMode(), entry.getValue());
				}
			}
		}
	}

	private void handleDropLogic(String gameMode, int itemId)
	{
		if (panel != null) panel.recordDrop(gameMode, itemId);
	}

	public static class DropRates
	{
		public final double overallChance;
		public final double mokhaiotlCloth;
		public final double eyeOfAyak;
		public final double avernicTreads;
		public final double dom;

		public DropRates(double overall, double mokhaiotl, double eye, double avernic, double dom)
		{
			this.overallChance = overall;
			this.mokhaiotlCloth = mokhaiotl;
			this.eyeOfAyak = eye;
			this.avernicTreads = avernic;
			this.dom = dom;
		}
	}
}

package com.speaax;

import lombok.Data;
import java.util.HashMap;
import java.util.Map;

/**
 * This class is a simple data container used for serializing and deserializing
 * the kill counts with Gson. It holds all the data that needs to be saved.
 */
@Data
public class DelveCalculatorData
{
    private Map<String, DelveProfile> profiles = new HashMap<>();

    @Data
    public static class DelveProfile
    {
        private String name;
        private Map<Integer, Integer> levelKills = new HashMap<>();
        private int wavesPast8;
        private Map<Integer, Integer> obtainedUniques = new HashMap<>();

        public DelveProfile() {}

        public DelveProfile(String name, boolean initialize)
        {
            this.name = name;
        }

        public void addKills(int level, int count)
        {
            levelKills.merge(level, count, Integer::sum);
        }

        public void addWave8()
        {
            wavesPast8++;
        }

        public void addDrop(int itemId)
        {
            obtainedUniques.merge(itemId, 1, Integer::sum);
        }
    }
}
package com.speaax;

import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

@Slf4j
public class DelveCalculatorPanel extends PluginPanel
{
	// Key used for Manual data storage in JSON: e.g. "STANDARD:MANUAL"
	private String getManualProfileKey()
	{
		return currentGameMode + ":MANUAL";
	}

	private final DelveCalculatorPlugin plugin;
	private final ItemManager itemManager;
	private final DelveCalculatorConfig config;
	private final Gson gson;

	private final JLabel totalKillsLabel;
	private final JPanel progressPanel;
	private final JPanel noDataSectionPanel;
	private final MaterialTabGroup viewTabGroup = new MaterialTabGroup();
	private final MaterialTabGroup modeTabGroup = new MaterialTabGroup();

	private final Map<Integer, JLabel> levelValueLabels = new HashMap<>();
	private final Map<String, ProgressRow> progressRows = new HashMap<>();
	private final List<MaterialTab> modeTabs = new ArrayList<>();

	private static class ProgressRow
	{
		CustomProgressBar progressBar;
		JLabel expectedLabel;
		JLabel iconLabel;
		ImageIcon originalIcon;
	}

	public static class CustomProgressBar extends JPanel
	{
		private int value = 0;
		private int maximum = 100;
		private String text = "";
		private Color foreground = new Color(0, 200, 0); // Default Green
		private Double luckValue = null; // If set, draws center-split bar
		private Double maxLuck = null;

		public CustomProgressBar()
		{
			setBackground(ColorScheme.DARKER_GRAY_COLOR);
			setBorder(BorderFactory.createLineBorder(ColorScheme.LIGHT_GRAY_COLOR, 1));
			setPreferredSize(new Dimension(-1, 32));
		}

		public void setValue(int value) { this.value = value; repaint(); }
		public void setMaximum(int maximum) { this.maximum = maximum; repaint(); }
		public void setString(String text) { this.text = text; repaint(); }
		@Override
		public void setForeground(Color fg) { this.foreground = fg; repaint(); }
		
		public void setLuckMode(Double luck, Double maxLuck) {
			this.luckValue = luck;
			this.maxLuck = maxLuck;
			repaint();
		}

		public void setNormalMode() {
			this.luckValue = null;
			this.maxLuck = null;
			repaint();
		}

		@Override
		protected void paintComponent(Graphics g)
		{
			super.paintComponent(g);
			if (!(g instanceof Graphics2D)) return;

			Graphics2D g2 = (Graphics2D) g;
			int width = getWidth();
			int height = getHeight();

			// 1. Draw Bar
			g2.setColor(foreground);
			
			if (luckValue != null && maxLuck != null)
			{
				// Received Mode: Center split
				int centerX = width / 2;
				int barWidth = (int) ((Math.abs(luckValue) / maxLuck) * (width / 2.0));
				barWidth = Math.min(barWidth, width / 2);

				if (luckValue > 0) {
					g2.fillRect(centerX, 0, barWidth, height);
				} else if (luckValue < 0) {
					g2.fillRect(centerX - barWidth, 0, barWidth, height);
				}

				// Center Line
				g2.setColor(Color.LIGHT_GRAY);
				g2.drawLine(centerX, 0, centerX, height);
			}
			else
			{
				// Expected Mode: Left to Right
				int barWidth = (int) (width * ((double) value / maximum));
				g2.fillRect(0, 0, barWidth, height);
			}

			// 2. Draw Text (Smart Placement)
			if (text != null && !text.isEmpty())
			{
				g2.setFont(FontManager.getRunescapeFont());
				g2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
				
				FontMetrics metrics = g2.getFontMetrics();
				int textWidth = metrics.stringWidth(text);
				int textY = (height + metrics.getAscent() - metrics.getDescent()) / 2;
				int textX;

				if (luckValue != null)
				{
					// RECEIVED MODE: Smart Placement
					// If Luck > 0 (Green bar on Right) -> Text on Left (Empty)
					// If Luck < 0 (Red bar on Left) -> Text on Right (Empty)
					if (luckValue > 0)
					{
						textX = (width / 2) - textWidth - 5; // Left of center
					}
					else if (luckValue < 0)
					{
						textX = (width / 2) + 5; // Right of center
					}
					else
					{
						textX = (width - textWidth) / 2; // Center
					}
				}
				else
				{
					// EXPECTED MODE: Center
					textX = (width - textWidth) / 2;
				}

				// Draw Main Text (White) - No outlines, no backgrounds
				g2.setColor(Color.WHITE);
				g2.drawString(text, textX, textY);
			}
		}
	}

	private DelveCalculatorData data = new DelveCalculatorData();
	private String currentGameMode = "STANDARD";
	private ViewTab currentView = ViewTab.ALL;
	private ModeTab currentMode = ModeTab.EXPECTED;

	private final JPanel manualResetPanel;

	public enum ViewTab { ALL, SESSION, MANUAL }
	public enum ModeTab { EXPECTED, RECEIVED }

	public DelveCalculatorPanel(DelveCalculatorPlugin plugin, DelveCalculatorConfig config, Gson gson)
	{
		this.plugin = plugin;
		this.itemManager = plugin.getItemManager();
		this.config = config;
		this.gson = gson;
		this.currentGameMode = plugin.getCurrentGameMode();

		setBorder(new EmptyBorder(10, 10, 10, 10));
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setLayout(new BorderLayout());

		JPanel contentPanel = new JPanel();
		contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
		contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Title
		JLabel titleLabel = new JLabel("Delve Calculator");
		titleLabel.setFont(FontManager.getRunescapeBoldFont().deriveFont(24.0f));
		titleLabel.setForeground(Color.YELLOW);
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setBorder(new EmptyBorder(0, 0, 10, 0));

		// Main Tabs (All, Session, Manual) and Help Icon
		JPanel mainHeader = new JPanel(new BorderLayout());
		mainHeader.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		mainHeader.setBorder(new EmptyBorder(0, 0, 10, 0));
		
		addTab(viewTabGroup, "All", () -> setView(ViewTab.ALL));
		addTab(viewTabGroup, "Session", () -> setView(ViewTab.SESSION));
		addTab(viewTabGroup, "Manual", () -> setView(ViewTab.MANUAL));
		mainHeader.add(viewTabGroup, BorderLayout.CENTER);

		JLabel viewHelpLabel = createCircularHelpLabel();
		viewHelpLabel.setToolTipText("<html>" +
				"<b>All:</b> All-time data mirrored from the in-game scoreboard.<br>" +
				"<b>Session:</b> Data tracked since opening the client.<br>" +
				"<b>Manual:</b> Custom data pool that can be reset at any time.</html>");
		
		JPanel viewHelpContainer = new JPanel(new GridBagLayout());
		viewHelpContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		viewHelpContainer.setBorder(new EmptyBorder(0, 0, 0, 5));
		viewHelpContainer.add(viewHelpLabel);
		mainHeader.add(viewHelpContainer, BorderLayout.EAST);

		// Kill Counts Panel
		JPanel killCountsPanel = new JPanel();
		killCountsPanel.setLayout(new BoxLayout(killCountsPanel, BoxLayout.Y_AXIS));
		killCountsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		killCountsPanel.setBorder(new EmptyBorder(5, 5, 5, 5));

		JPanel totalKillsPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 0));
		totalKillsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		JLabel totalKillsLabelText = new JLabel("Total Levels: ");
		totalKillsLabelText.setForeground(Color.YELLOW);
		totalKillsLabelText.setFont(FontManager.getRunescapeBoldFont());
		totalKillsLabel = new JLabel("0");
		totalKillsLabel.setForeground(Color.WHITE);
		totalKillsLabel.setFont(FontManager.getRunescapeBoldFont());
		totalKillsPanel.add(totalKillsLabelText);
		totalKillsPanel.add(totalKillsLabel);
		killCountsPanel.add(totalKillsPanel);
		killCountsPanel.add(Box.createVerticalStrut(5));

		JPanel levelsPanel = new JPanel(new GridLayout(9, 1, 5, 2));
		levelsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		for (int i = 1; i <= 8; i++) {
			JPanel levelPanel = createLevelPanel("Level " + i + ": ");
			levelValueLabels.put(i, (JLabel) levelPanel.getComponent(1));
			levelsPanel.add(levelPanel);
		}
		JPanel levelPlusPanel = createLevelPanel("Level +: ");
		levelValueLabels.put(9, (JLabel) levelPlusPanel.getComponent(1));
		levelsPanel.add(levelPlusPanel);
		killCountsPanel.add(levelsPanel);

		// Sub Tabs (Expected vs Received) and Help Icon
		JPanel modeHeader = new JPanel(new BorderLayout());
		modeHeader.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		addTab(modeTabGroup, "Expected", () -> setMode(ModeTab.EXPECTED));
		addTab(modeTabGroup, "Received", () -> setMode(ModeTab.RECEIVED));
		modeHeader.add(modeTabGroup, BorderLayout.CENTER);

		JLabel helpLabel = createCircularHelpLabel();
		helpLabel.setToolTipText("<html>" +
				"<b>Expected Tab:</b><br>" +
				"<u>Bar</u>: Progress toward the next statistical drop.<br>" +
				"<u>Number</u>: Total drops you are expected to have.<br><br>" +
				"<b>Received Tab:</b><br>" +
				"<u>Bar</u>: Your 'luck' (Actual drops vs. Expectations).<br>" +
				"<u>Number</u>: Total drops you have actually received.</html>");
		
		JPanel helpContainer = new JPanel(new GridBagLayout());
		helpContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		helpContainer.setBorder(new EmptyBorder(0, 0, 0, 5));
		helpContainer.add(helpLabel);
		modeHeader.add(helpContainer, BorderLayout.EAST);

		// Progress and No Data Panels
		progressPanel = createProgressPanel();
		noDataSectionPanel = createNoDataSection();

		// Reward Section (Tabs + Progress)
		JPanel rewardSection = new JPanel();
		rewardSection.setLayout(new BoxLayout(rewardSection, BoxLayout.Y_AXIS));
		rewardSection.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		rewardSection.add(modeHeader);
		rewardSection.add(progressPanel);

		// Manual Reset Button
		manualResetPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		manualResetPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		JButton resetButton = new JButton("Reset Manual Data");
		resetButton.setBackground(new Color(150, 0, 0)); // Dark red
		resetButton.setForeground(Color.WHITE);
		resetButton.setFont(FontManager.getRunescapeFont());
		resetButton.addActionListener(e -> confirmResetManualData());
		manualResetPanel.add(resetButton);
		manualResetPanel.setVisible(false);

		// Add components to main panel
		add(titleLabel, BorderLayout.NORTH);
		contentPanel.add(mainHeader);
		contentPanel.add(killCountsPanel);
		contentPanel.add(Box.createVerticalStrut(10));

		contentPanel.add(rewardSection);
		contentPanel.add(Box.createVerticalStrut(10));
		contentPanel.add(noDataSectionPanel);
		contentPanel.add(manualResetPanel);
		
		add(contentPanel, BorderLayout.CENTER);

		// Load initial tab states
		try {
			this.currentView = ViewTab.valueOf(config.activeViewTab());
		} catch (Exception e) { this.currentView = ViewTab.ALL; }
		try {
			this.currentMode = ModeTab.valueOf(config.activeModeTab());
		} catch (Exception e) { this.currentMode = ModeTab.EXPECTED; }

		viewTabGroup.select(viewTabGroup.getTab(currentView.ordinal()));
		modeTabGroup.select(modeTabGroup.getTab(currentMode.ordinal()));

		loadData();
		updateAllUI();
	}

	private void addTab(MaterialTabGroup group, String title, Runnable onSelect)
	{
		MaterialTab tab = new MaterialTab(title, group, null);
		tab.setOnSelectEvent(() -> {
			if (onSelect != null) onSelect.run();
			return true;
		});
		group.addTab(tab);
		if (group == modeTabGroup) modeTabs.add(tab);
	}

	private void setView(ViewTab view)
	{
		this.currentView = view;
		config.activeViewTab(view.name());
		if (totalKillsLabel != null) updateAllUI();
	}

	private void setMode(ModeTab mode)
	{
		this.currentMode = mode;
		config.activeModeTab(mode.name());
		
		// Highlight selected tab in yellow
		for (int i = 0; i < modeTabs.size(); i++)
		{
			MaterialTab tab = modeTabs.get(i);
			if (i == mode.ordinal())
			{
				tab.setForeground(Color.YELLOW);
			}
			else
			{
				tab.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
			}
		}

		if (totalKillsLabel != null) updateAllUI();
	}

	private void loadData()
	{
		String json = config.killCountData();
		if (json == null || json.isEmpty()) return;
		try {
			this.data = gson.fromJson(json, DelveCalculatorData.class);
			if (this.data == null) this.data = new DelveCalculatorData();
		} catch (Exception e) { log.debug("Error loading data", e); }
	}

	private void saveData()
	{
		config.killCountData(gson.toJson(data));
	}

	public void switchGameMode(String mode)
	{
		this.currentGameMode = mode;
		SwingUtilities.invokeLater(this::updateAllUI);
	}

	// Unified update method for All, Manual, and Session profiles
	private void updateProfiles(Consumer<DelveCalculatorData.DelveProfile> action)
	{
		// 1. All (Persistent Code)
		DelveCalculatorData.DelveProfile allProfile = data.getProfiles().computeIfAbsent(currentGameMode, k -> new DelveCalculatorData.DelveProfile(currentGameMode, true));
		action.accept(allProfile);

		// 2. Manual (Persistent Code : MANUAL)
		DelveCalculatorData.DelveProfile manualProfile = data.getProfiles().computeIfAbsent(getManualProfileKey(), k -> new DelveCalculatorData.DelveProfile("Manual", true));
		action.accept(manualProfile);

		// 3. Session (InMemory)
		DelveCalculatorData.DelveProfile sessionProfile = plugin.getSessionProfile(currentGameMode);
		action.accept(sessionProfile);

		saveData();
		SwingUtilities.invokeLater(this::updateAllUI);
	}

	public void incrementFloorKills(String mode, int floor)
	{
		// Ensure we are operating on the correct mode context
		if (!mode.equals(currentGameMode)) return; 
		updateProfiles(p -> p.addKills(floor, 1));
	}

	public void incrementWavesPast8(String mode)
	{
		// Ensure we are operating on the correct mode context
		if (!mode.equals(currentGameMode)) return;
		updateProfiles(DelveCalculatorData.DelveProfile::addWave8);
	}

	public void recordDrop(String mode, int itemId)
	{
		// Ensure we are operating on the correct mode context
		if (!mode.equals(currentGameMode)) return;
		updateProfiles(p -> p.addDrop(itemId));
	}

	public void syncOverallData(String mode, Map<Integer, Integer> levelKills, int wavesPast8)
	{
		DelveCalculatorData.DelveProfile profile = data.getProfiles().computeIfAbsent(mode, k -> new DelveCalculatorData.DelveProfile(mode, true));
		profile.getLevelKills().putAll(levelKills);
		profile.setWavesPast8(wavesPast8);
		saveData();
		SwingUtilities.invokeLater(this::updateAllUI);
	}

	public void syncCollectionLogData(String mode, Map<Integer, Integer> foundDrops)
	{
		DelveCalculatorData.DelveProfile profile = data.getProfiles().computeIfAbsent(mode, k -> new DelveCalculatorData.DelveProfile(mode, true));
		profile.getObtainedUniques().putAll(foundDrops);
		saveData();
		SwingUtilities.invokeLater(this::updateAllUI);
	}

	public void updateAllUI()
	{
		if (totalKillsLabel == null) return;

		DelveCalculatorData.DelveProfile profile = getActiveProfile();
		int totalKills = profile.getLevelKills().values().stream().mapToInt(Integer::intValue).sum() + profile.getWavesPast8();
		totalKillsLabel.setText(String.valueOf(totalKills));

		for (int i = 1; i <= 8; i++)
		{
			JLabel label = levelValueLabels.get(i);
			if (label != null) label.setText(String.valueOf(profile.getLevelKills().getOrDefault(i, 0)));
		}
		JLabel plusLabel = levelValueLabels.get(9);
		if (plusLabel != null) plusLabel.setText(String.valueOf(profile.getWavesPast8()));

		updateProgressBars(profile);

		boolean hasData = totalKills > 0;
		manualResetPanel.setVisible(currentView == ViewTab.MANUAL);
		noDataSectionPanel.setVisible(!hasData && currentView == ViewTab.ALL);
	}

	private DelveCalculatorData.DelveProfile getActiveProfile()
	{
		if (currentView == ViewTab.SESSION) return plugin.getSessionProfile(currentGameMode);
		if (currentView == ViewTab.MANUAL) return data.getProfiles().computeIfAbsent(getManualProfileKey(), k -> new DelveCalculatorData.DelveProfile("Manual", true));
		return data.getProfiles().computeIfAbsent(currentGameMode, k -> new DelveCalculatorData.DelveProfile(currentGameMode, true));
	}

	private void updateProgressBars(DelveCalculatorData.DelveProfile profile)
	{
		Map<String, Double> itemProgress = calculateItemProgress(profile);
		Map<String, DelveCalculatorConfig.RewardDisplayMode> displayModes = getDisplayModes();

		for (Map.Entry<String, ProgressRow> entry : progressRows.entrySet())
		{
			String itemName = entry.getKey();
			ProgressRow row = entry.getValue();
			DelveCalculatorConfig.RewardDisplayMode displayMode = displayModes.getOrDefault(itemName, DelveCalculatorConfig.RewardDisplayMode.SHOW);

			boolean visible = displayMode != DelveCalculatorConfig.RewardDisplayMode.HIDE;
			row.iconLabel.setVisible(visible);
			row.progressBar.setVisible(visible);
			row.expectedLabel.setVisible(visible);

			if (!visible) continue;

			CustomProgressBar progressBar = row.progressBar;
			JLabel label = row.expectedLabel;
			JLabel iconLabel = row.iconLabel;

			label.setVisible(true);

			double expected = itemProgress.getOrDefault(itemName, 0.0);
			int actual = getActualDrops(profile, itemName);

			if (currentMode == ModeTab.EXPECTED)
			{
				double progress = expected % 1.0;
				
				progressBar.setNormalMode();
				progressBar.setMaximum(100);
				progressBar.setValue((int) (progress * 100));
				
				// Reverted: Percentage on bar, Integer count on right
				progressBar.setString(String.format("%.1f%%", progress * 100));
				progressBar.setToolTipText(null);
				
				label.setText(String.valueOf((int) expected));
				progressBar.setForeground(calculateProgressColor((int)(progress * 100)));
			}
			else // RECEIVED
			{
				double luck = actual - expected;
				
				// Calculate max luck for relative scaling
				double maxLuck = 0;
				for (String name : progressRows.keySet()) {
					if (displayModes.getOrDefault(name, DelveCalculatorConfig.RewardDisplayMode.SHOW) != DelveCalculatorConfig.RewardDisplayMode.HIDE) {
						double itemExp = itemProgress.getOrDefault(name, 0.0);
						int itemAct = getActualDrops(profile, name);
						maxLuck = Math.max(maxLuck, Math.abs(itemAct - itemExp));
					}
				}
				// Ensure maxLuck is at least 1.0 to avoid division by zero or tiny bars
				maxLuck = Math.max(maxLuck, 1.0);

				progressBar.setLuckMode(luck, maxLuck);
				
				// Reverted: Luck value on bar, Actual count on right
				progressBar.setString(String.format("%+.2f", luck));
				progressBar.setToolTipText(null);
				
				label.setText(String.valueOf(actual));
				
				// Scaling and coloring
				if (luck > 0)
				{
					progressBar.setForeground(new Color(0, 100, 0)); // Even Darker Green
				}
				else if (luck < 0)
				{
					// Gradient from Yellow (0) to Red (-1)
					// Use darker colors: Yellow ~ (150, 150, 0), Red ~ (150, 0, 0)
					float ratio = (float) Math.min(Math.abs(luck), 1.0);
					int red = 150;
					int green = (int) (150 * (1.0 - ratio));
					progressBar.setForeground(new Color(red, green, 0));
				}
				else
				{
					progressBar.setForeground(Color.GRAY);
				}
			}

			if (displayMode == DelveCalculatorConfig.RewardDisplayMode.GREY)
			{
				progressBar.setForeground(Color.GRAY);
				label.setForeground(Color.GRAY);
				if (iconLabel != null && row.originalIcon != null) {
					iconLabel.setIcon(new ImageIcon(ImageUtil.grayscaleImage(ImageUtil.bufferedImageFromImage(row.originalIcon.getImage()))));
				}
			}
			else
			{
				label.setForeground(Color.WHITE);
				if (iconLabel != null) iconLabel.setIcon(row.originalIcon);
			}
		}
	}

	private int getActualDrops(DelveCalculatorData.DelveProfile profile, String itemName)
	{
		if (itemName.equals("Any Item")) return profile.getObtainedUniques().values().stream().mapToInt(Integer::intValue).sum();
		Integer itemId = DelveCalculatorPlugin.getUniqueDropsMap().get(itemName);
		return (itemId != null) ? profile.getObtainedUniques().getOrDefault(itemId, 0) : 0;
	}

	private Map<String, Double> calculateItemProgress(DelveCalculatorData.DelveProfile profile)
	{
		Map<String, Double> progress = new HashMap<>();
		double mokhaiotl = 0, eye = 0, avernic = 0, dom = 0;

		for (Map.Entry<Integer, DelveCalculatorPlugin.DropRates> entry : DelveCalculatorPlugin.getDropRates().entrySet())
		{
			int level = entry.getKey();
			DelveCalculatorPlugin.DropRates rates = entry.getValue();
			int kills = (level == 9) ? profile.getWavesPast8() : profile.getLevelKills().getOrDefault(level, 0);

			mokhaiotl += kills * rates.mokhaiotlCloth;
			eye += kills * rates.eyeOfAyak;
			avernic += kills * rates.avernicTreads;
			dom += kills * rates.dom;
		}

		progress.put("Mokhaiotl cloth", mokhaiotl);
		progress.put("Eye of ayak (uncharged)", eye);
		progress.put("Avernic treads", avernic);
		progress.put("Dom", dom);

		double any = 0;
		if (config.mokhaiotlClothDisplay() == DelveCalculatorConfig.RewardDisplayMode.SHOW) any += mokhaiotl;
		if (config.eyeOfAyakDisplay() == DelveCalculatorConfig.RewardDisplayMode.SHOW) any += eye;
		if (config.avernicTreadsDisplay() == DelveCalculatorConfig.RewardDisplayMode.SHOW) any += avernic;
		if (config.domDisplay() == DelveCalculatorConfig.RewardDisplayMode.SHOW) any += dom;
		progress.put("Any Item", any);

		return progress;
	}

	private Map<String, DelveCalculatorConfig.RewardDisplayMode> getDisplayModes()
	{
		Map<String, DelveCalculatorConfig.RewardDisplayMode> modes = new HashMap<>();
		modes.put("Any Item", DelveCalculatorConfig.RewardDisplayMode.SHOW);
		modes.put("Mokhaiotl cloth", config.mokhaiotlClothDisplay());
		modes.put("Eye of ayak (uncharged)", config.eyeOfAyakDisplay());
		modes.put("Avernic treads", config.avernicTreadsDisplay());
		modes.put("Dom", config.domDisplay());
		return modes;
	}

	private Color calculateProgressColor(int barValue)
	{
		// Even Darker colors for white text contrast
		// Max brightness ~100 instead of 180 (original 255)
		if (barValue <= 50) return new Color(100, (int) (100 * (barValue / 50.0f)), 0);
		else return new Color((int) (100 * (1.0f - (barValue - 50) / 50.0f)), 100, 0);
	}

	private JPanel createProgressPanel()
	{
		JPanel panel = new JPanel(new GridBagLayout());
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.setBorder(new EmptyBorder(5, 5, 5, 5));

		int row = 0;
		addAnyItemProgressBar(panel, row++);
		addProgressBar(panel, "Mokhaiotl cloth", ItemID.MOKHAIOTL_CLOTH, row++);
		addProgressBar(panel, "Eye of ayak (uncharged)", ItemID.EYE_OF_AYAK_UNCHARGED, row++);
		addProgressBar(panel, "Avernic treads", ItemID.AVERNIC_TREADS, row++);
		addProgressBar(panel, "Dom", ItemID.DOM, row++);

		return panel;
	}

	private JPanel createLevelPanel(String labelText)
	{
		JPanel levelPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		levelPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		JLabel levelLabel = new JLabel(labelText);
		levelLabel.setPreferredSize(new Dimension(52, 16));
		levelLabel.setForeground(Color.YELLOW);
		levelLabel.setFont(FontManager.getRunescapeFont());
		JLabel levelValue = new JLabel("0");
		levelValue.setForeground(Color.WHITE);
		levelValue.setFont(FontManager.getRunescapeFont());
		levelPanel.add(levelLabel);
		levelPanel.add(levelValue);
		return levelPanel;
	}

	private void addProgressBar(JPanel parent, String itemName, int itemId, int row)
	{
		GridBagConstraints c = new GridBagConstraints();
		c.insets = new Insets(2, 0, 2, 0);

		ImageIcon icon = new ImageIcon(itemManager.getImage(itemId));
		JLabel iconLabel = new JLabel(icon);
		iconLabel.setPreferredSize(new Dimension(32, 32));
		c.gridx = 0;
		c.gridy = row;
		c.anchor = GridBagConstraints.WEST;
		parent.add(iconLabel, c);

		CustomProgressBar progressBar = new CustomProgressBar();
		c.gridx = 1;
		c.fill = GridBagConstraints.HORIZONTAL;
		c.weightx = 1.0;
		c.insets = new Insets(2, 5, 2, 5);
		parent.add(progressBar, c);

		JLabel expectedLabel = createExpectedLabel();
		c.gridx = 2;
		c.fill = GridBagConstraints.NONE;
		c.weightx = 0;
		c.anchor = GridBagConstraints.WEST;
		c.insets = new Insets(2, 0, 2, 0);
		parent.add(expectedLabel, c);

		ProgressRow progressRow = new ProgressRow();
		progressRow.iconLabel = iconLabel;
		progressRow.progressBar = progressBar;
		progressRow.expectedLabel = expectedLabel;
		progressRow.originalIcon = icon;
		progressRows.put(itemName, progressRow);
	}

	private void addAnyItemProgressBar(JPanel parent, int row)
	{
		GridBagConstraints c = new GridBagConstraints();
		c.insets = new Insets(2, 0, 2, 0);

		JPanel iconPanel = new JPanel(new GridBagLayout());
		iconPanel.setPreferredSize(new Dimension(32, 32));
		iconPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		JLabel iconLabelText = new JLabel("Any");
		iconLabelText.setForeground(Color.YELLOW);
		iconLabelText.setFont(FontManager.getRunescapeFont());
		iconPanel.add(iconLabelText);
		c.gridx = 0;
		c.gridy = row;
		c.anchor = GridBagConstraints.WEST;
		parent.add(iconPanel, c);

		CustomProgressBar progressBar = new CustomProgressBar();
		c.gridx = 1;
		c.fill = GridBagConstraints.HORIZONTAL;
		c.weightx = 1.0;
		c.insets = new Insets(2, 5, 2, 5);
		parent.add(progressBar, c);

		JLabel expectedLabel = createExpectedLabel();
		c.gridx = 2;
		c.fill = GridBagConstraints.NONE;
		c.weightx = 0;
		c.anchor = GridBagConstraints.WEST;
		c.insets = new Insets(2, 0, 2, 0);
		parent.add(expectedLabel, c);

		ProgressRow progressRow = new ProgressRow();
		progressRow.iconLabel = null; // Special case for Any
		progressRow.progressBar = progressBar;
		progressRow.expectedLabel = expectedLabel;
		progressRow.originalIcon = null;
		progressRows.put("Any Item", progressRow);
		
		// Map iconPanel to iconLabel for visibility toggling
		progressRow.iconLabel = iconLabelText; 
	}


	private JLabel createExpectedLabel()
	{
		JLabel expectedLabel = new JLabel("0");
		expectedLabel.setForeground(Color.WHITE);
		expectedLabel.setFont(FontManager.getRunescapeFont());
		expectedLabel.setBorder(new EmptyBorder(0, 5, 0, 0));
		expectedLabel.setHorizontalAlignment(SwingConstants.LEFT);
		return expectedLabel;
	}

	private JLabel createCircularHelpLabel()
	{
		JLabel label = new JLabel("?") {
			@Override
			protected void paintComponent(Graphics g) {
				Graphics2D g2 = (Graphics2D) g.create();
				g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
				g2.setColor(getForeground());
				g2.drawOval(2, 2, getWidth() - 5, getHeight() - 5);
				g2.dispose();
				super.paintComponent(g);
			}
		};
		label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		label.setFont(FontManager.getRunescapeSmallFont());
		label.setHorizontalAlignment(SwingConstants.CENTER);
		label.setPreferredSize(new Dimension(20, 20));
		return label;
	}

	private JPanel createNoDataSection()
	{
		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.setBorder(new EmptyBorder(10, 10, 10, 10));
		JLabel noDataLabel = new JLabel("No data, read scoreboard outside the bossroom");
		noDataLabel.setForeground(Color.ORANGE);
		noDataLabel.setFont(FontManager.getRunescapeFont());
		noDataLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		panel.add(noDataLabel);
		panel.setVisible(false);
		return panel;
	}

	private void confirmResetManualData()
	{
		int option = JOptionPane.showOptionDialog(
				this,
				"This will ONLY reset the data in the Manual tab. Proceed?",
				"Reset Manual Data",
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE,
				null,
				new Object[]{"Reset", "Cancel"},
				"Cancel"
		);

		if (option == JOptionPane.YES_OPTION)
		{
			DelveCalculatorData.DelveProfile manualProfile = data.getProfiles().get(getManualProfileKey());
			if (manualProfile != null)
			{
				manualProfile.getLevelKills().clear();
				manualProfile.setWavesPast8(0);
				manualProfile.getObtainedUniques().clear();
				saveData();
				updateAllUI();
			}
		}
	}
}
package com.speaax;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DelveCalculatorPlugin.class);
		RuneLite.main(args);
	}
}
