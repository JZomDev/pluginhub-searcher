package me.clogged;

import okhttp3.*;

import javax.inject.Inject;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.util.ArrayList;
import java.util.List;

public class CloggedApiClient {
    private static final String COLLECTION_LOG_API_HOST = "api.clogged.me";
    private static final String COLLECTION_LOG_USER_AGENT = "Runelite clogged/" + CloggedConfig.PLUGIN_VERSION;
    private static final MediaType COLLECTION_LOG_MEDIA_TYPE = MediaType.parse("application/json; charset=utf-8");

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private CloggedConfig config;

    public void updateUserCollectionLog(String requestBodyJson, Callback callback) {
        HttpUrl url = buildUrl();

        if (requestBodyJson == null || requestBodyJson.isEmpty()) {
            throw new IllegalArgumentException("Request body cannot be null or empty");
        }

        try {
            RequestBody requestBody = RequestBody.create(COLLECTION_LOG_MEDIA_TYPE, requestBodyJson);
            Request request = createRequestBuilder(url)
                    .post(requestBody)
                    .build();

            apiRequest(request, callback);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid request body", e);
        } catch (Exception e) {
            throw new RuntimeException("Failed to send API request", e);
        }
    }

    public void getUserCollectionLog(String username, int subCategoryId, Callback callback) {
        List<String> pathSegments = new ArrayList<>();
        pathSegments.add("get");
        pathSegments.add(username);
        pathSegments.add(String.valueOf(subCategoryId));
        HttpUrl url = buildUrl(pathSegments);

        Request request = createRequestBuilder(url)
                .get()
                .build();

        apiRequest(request, callback);
    }


    private Request.Builder createRequestBuilder(HttpUrl url)
    {
        return new Request.Builder()
                .header("User-Agent", COLLECTION_LOG_USER_AGENT)
                .url(url);
    }

    private void apiRequest(Request request, Callback callback)
    {
        getOkHttpClient().newCall(request).enqueue(callback);
    }

    private OkHttpClient getOkHttpClient() {
        if (config.proxyEnabled()) {
            if (config.proxyHost() == null || config.proxyHost().isEmpty()) {
                throw new IllegalArgumentException("Proxy host cannot be null or empty");
            }
            if (config.proxyPort() <= 0) {
                throw new IllegalArgumentException("Proxy port must be a positive integer");
            }

            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(config.proxyHost(), config.proxyPort()));
            if (config.proxyUsername() != null && !config.proxyUsername().isEmpty()) {
                String proxyUsername = config.proxyUsername();
                String proxyPassword = config.proxyPassword() != null ? config.proxyPassword() : "";
                Authenticator proxyAuthenticator = (route, response) -> {
                    String credential = Credentials.basic(proxyUsername, proxyPassword);
                    return response.request().newBuilder()
                            .header("Proxy-Authorization", credential)
                            .build();
                };
                return okHttpClient.newBuilder()
                        .proxy(proxy)
                        .proxyAuthenticator(proxyAuthenticator)
                        .build();
            }

            return okHttpClient.newBuilder()
                    .proxy(proxy)
                    .build();
        }

        return okHttpClient;
    }

    private HttpUrl buildUrl() {
        return new HttpUrl.Builder()
                .scheme("https")
                .host(COLLECTION_LOG_API_HOST)
                .addPathSegment("api")
                .addPathSegment("clog")
                .addPathSegment("update")
                .build();
    }

    private HttpUrl buildUrl(List<String> pathSegments) {
        HttpUrl.Builder urlBuilder = new HttpUrl.Builder()
                .scheme("https")
                .host(COLLECTION_LOG_API_HOST)
                .addPathSegment("api")
                .addPathSegment("clog");

        for (String segment : pathSegments) {
            urlBuilder.addPathSegment(segment);
        }

        return urlBuilder.build();
    }
}

package me.clogged.helpers;

import org.apache.commons.text.WordUtils;

public class AliasHelper {

    // Transforms the alias from ClogAlias to the full name of the boss to be used to retrieve the KC
    public static String KCAlias(String boss) {
        String lowerBoss = boss.toLowerCase();
        switch (lowerBoss) {
            // Brimhaven Agility Arena
            case "brimhaven agility arena":
                return "Agility Arena";

            // Ape Atoll Agility Course
            case "monkey backpacks":
                return "Ape Atoll Agility";

            // Barbarian Outpost
            case "barbarian assault":
                return "Barbarian Outpost";

            // dks
            case "prime":
                return "Dagannoth Prime";
            case "rex":
                return "Dagannoth Rex";
            case "supreme":
                return "Dagannoth Supreme";

            // hunter rumour variants
            case "hunter guild":
                return "Hunter Rumours";

            // lunar chest variants
            case "moons of peril":
                return "Lunar Chest";

            // sol heredit
            case "fortis colosseum":
                return "Sol Heredit";

            case "the inferno":
                return "TzKal-Zuk";

            case "the fight caves":
                return "TzTok-Jad";

            default:
                return WordUtils.capitalize(boss); // Assuming WordUtils is available
        }
    }

    // Transforms common aliases into the full name of the boss
    public static String ClogAlias(String query) {
        switch (query.toLowerCase()) {
            // Bosses Tab
            case "sire":
                return "Abyssal Sire";

            case "hydra":
                return "Alchemical Hydra";

            case "raxx":
            case "rax":
            case "spiderbro":
            case "rarku's best friend":
                return "Araxxor";

            case "barrows":
                return "Barrows Chests";

            case "byro":
                return "Bryophyta";

            case "artio":
            case "art":
            case "cal":
            case "callisto":
                return "Callisto and Artio";

            case "cerb":
                return "Cerberus";

            case "chaos ele":
                return "Chaos Elemental";

            case "sara":
            case "saradomin":
            case "zilyana":
            case "zily":
                return "Commander Zilyana";

            case "corp":
                return "Corporeal Beast";

            case "crazy arch":
                return "Crazy Archaeologist";

            case "kings":
            case "dks":
                return "Dagannoth Kings";

            case "duke":
            case "succ":
            case "succelus":
            case "ugly":
            case "succellus":
            case "duke succellus":
                return "Duke Sucellus";

            case "jad":
            case "fight caves":
            case "fc":
                return "The Fight Caves";

            case "colosseum":
            case "sol":
            case "sol heredit":
            case "fortis":
                return "Fortis Colosseum";

            case "gaunt":
            case "gauntlet":
            case "cgaunt":
            case "cgauntlet":
            case "the corrupted gauntlet":
            case "cg":
                return "The Gauntlet";

            case "bando":
            case "bandos":
            case "graardor":
                return "General Graardor";

            case "mole":
            case "paul":
            case "faux":
                return "Giant Mole";

            case "dusk":
            case "dawn":
            case "gargs":
            case "ggs":
            case "gg":
                return "Grotesque Guardians";

            case "farming guild":
            case "hesp":
                return "Hespori";

            case "huey":
                return "Hueycoatl";

            case "zuk":
            case "inferno":
                return "The Inferno";

            case "kq":
                return "Kalphite Queen";

            case "kbd":
                return "King Black Dragon";

            case "arma":
            case "kree":
            case "kreearra":
            case "armadyl":
                return "Kree'arra";

            case "kril":
            case "kril trutsaroth":
            case "zammy":
            case "zamorak":
                return "K'ril Tsutsaroth";

            case "cave kraken":
                return "Kraken";

            case "leviathan":
            case "levi":
            case "lev":
                return "The Leviathan";

            case "moons":
                return "Moons of Peril";

            case "nightmare":
            case "nm":
            case "tnm":
            case "nmare":
            case "pnm":
            case "phosani":
            case "phosanis":
            case "phosani nm":
            case "phosani nightmare":
            case "phosanis nightmare":
                return "The Nightmare";

            case "hill giant":
            case "mammal":
            case "mr mammal":
                return "Obor";

            case "mus":
            case "muspah":
            case "pm":
            case "the grumbler":
                return "Phantom Muspah";

            case "royal titan":
            case "royal titans":
            case "titans":
                return "Royal Titans";

            case "saracha":
            case "sarac":
            case "saracnis":
                return "Sarachnis";

            case "scorpa":
                return "Scorpia";

            case "scur":
            case "scurius":
            case "rat":
                return "Scurrius";

            case "skotizos":
            case "totems":
            case "totem":
                return "Skotizo";

            case "tempoross":
            case "temp":
                return "Tempoross";

            case "smoke devil":
            case "smoke devils":
            case "thermy":
            case "thermey":
                return "Thermonuclear Smoke Devil";

            case "vard":
            case "vardo":
                return "Vardorvis";

            case "calv":
            case "calvarion":
            case "calvar ion":
            case "calvar'ion":
            case "vetion":
            case "vet ion":
            case "vet'ion":
            case "veti":
                return "Vet'ion and Calvar'ion";

            case "spin":
            case "spindel":
            case "vene":
            case "venenatis":
                return "Venenatis and Spindel";

            case "vork":
            case "vorki":
                return "Vorkath";

            case "whisperer":
            case "whisp":
            case "wisp":
                return "The Whisperer";

            case "wt":
                return "Wintertodt";

            case "zalc":
                return "Zalcano";

            case "zul":
            case "profit snake":
            case "bjs":
                return "Zulrah";

            // Raids Tab
            case "cox":
            case "xeric":
            case "chambers":
            case "olm":
            case "raids":
            case "cox cm":
            case "xeric cm":
            case "chambers cm":
            case "olm cm":
            case "raids cm":
            case "chambers of xeric - challenge mode":
                return "Chambers of Xeric";

            case "tob":
            case "theatre":
            case "verzik":
            case "verzik vitur":
            case "raids 2":
            case "theatre of blood: story mode":
            case "tob sm":
            case "tob story mode":
            case "tob story":
            case "theatre of blood: entry mode":
            case "tob em":
            case "tob entry mode":
            case "tob entry":
            case "theatre of blood: hard mode":
            case "tob cm":
            case "tob hm":
            case "tob hard mode":
            case "tob hard":
            case "hmt":
                return "Theatre of Blood";

            case "toa":
            case "tomb":
            case "tombs":
            case "raids 3":
            case "tomb of amascut":
                return "Tombs of Amascut";

            // Clues Tab
            case "begs":
            case "beg clues":
            case "beginners":
            case "beginner clues":
            case "beginner clue":
            case "clues beg":
            case "clues beginner":
            case "clue beg":
            case "clue beginner":
                return "Beginner Treasure Trails";

            case "easy clues":
            case "easy clue":
            case "easies":
            case "clues easy":
            case "clue easy":
                return "Easy Treasure Trails";

            case "meds":
            case "med":
            case "mediums":
            case "medium clues":
            case "medium clue":
            case "clues med":
            case "clues medium":
            case "clue med":
            case "clue medium":
                return "Medium Treasure Trails";

            case "hards":
            case "hard clues":
            case "hard clue":
            case "clue hard":
            case "clues hard":
                return "Hard Treasure Trails";

            case "masters":
            case "master clues":
            case "master clue":
            case "clue master":
            case "clues master":
                return "Master Treasure Trails";

            case "elites":
            case "elite clues":
            case "elite clue":
            case "clue elite":
            case "clues elite":
                return "Elite Treasure Trails";

            case "hards rare":
            case "hard clues rare":
            case "hard clue rare":
            case "hards rares":
            case "hard clues rares":
            case "hard clue rares":
            case "rare hards":
            case "rare hard":
                return "Hard Treasure Trails (Rare)";

            case "elites rare":
            case "elite clues rare":
            case "elite clue rare":
            case "elites rares":
            case "elite clues rares":
            case "elite clue rares":
            case "rare elite":
            case "rare elites":
                return "Elite Treasure Trails (Rare)";

            case "master treasure trails rare":
            case "masters rare":
            case "master clues rare":
            case "master clue rare":
            case "master treasure trails rares":
            case "masters rares":
            case "master clues rares":
            case "master clue rares":
            case "rare master":
            case "rare masters":
                return "Master Treasure Trails (Rare)";

            case "shared rewards":
            case "shared clue":
            case "shared clues":
            case "shared":
                return "Shared Treasure Trail Rewards";

            // Minigames Tab
            case "ba":
            case "barb":
                return "Barbarian Assault";

            case "brimhaven agility":
            case "brimhaven":
            case "brim agility":
            case "brim":
                return "Brimhaven Agility Arena";

            case "cw":
            case "cwars":
                return "Castle Wars";

            case "trawler":
                return "Fishing Trawler";

            case "giants foundry":
            case "foundry":
            case "gf":
                return "Giants' Foundry";

            case "gnome":
            case "restaurant":
                return "Gnome Restaurant";

            case "guardian of the rift":
            case "gotr":
            case "grift":
            case "grifting":
            case "guardians":
            case "runetodt":
                return "Guardians of the Rift";

            case "hs":
            case "sepc":
            case "sepulchre":
                return "Hallowed Sepulchre";

            case "lms":
                return "Last Man Standing";

            case "mta":
            case "magic arena":
                return "Magic Training Arena";

            case "mah homes":
            case "mahogany home":
            case "mh":
            case "homes":
            case "mahogany":
                return "Mahogany Homes";

            case "pc":
                return "Pest Control";

            case "rogues den":
            case "rogue den":
            case "rogues":
            case "rogue":
                return "Rogues' Den";

            case "shades of mortton":
            case "shade of mortton":
            case "shades":
            case "shade":
            case "mort ton":
            case "mortton":
                return "Shades of Mort'ton";

            case "soul war":
            case "sw":
                return "Soul Wars";

            case "trekking":
            case "temple trek":
                return "Temple Trekking";

            case "tithe":
                return "Tithe Farm";

            case "brewing":
                return "Trouble Brewing";

            case "vm":
            case "volc mine":
                return "Volcanic Mine";

            // Other Tab
            case "aerial fish":
            case "aerial":
                return "Aerial Fishing";

            case "all pets":
            case "pets":
            case "pet":
                return "All Pets";

            case "champions challenge":
            case "champion challenge":
            case "champion scrolls":
            case "champ scrolls":
                return "Champion's Challenge";

            case "chaos druid":
            case "elder druids":
            case "elder druid":
            case "elder":
                return "Chaos Druids";

            case "chompy":
            case "chompies":
            case "bird hunting":
                return "Chompy Bird Hunting";

            case "tower of life":
                return "Creature Creation";

            case "defenders":
            case "defender":
                return "Cyclopes";

            case "fossil island note":
            case "fossil island":
                return "Fossil Island Notes";

            case "gloughs experiments":
            case "gloughs experiment":
            case "glough experiments":
            case "glough experiment":
            case "demonics":
            case "demonic gorilla":
            case "demonic gorillas":
                return "Glough's Experiments";

            case "rumors":
            case "rumor":
            case "hunter rumor":
            case "hunter guild":
                return "Hunter Guild";

            case "monkey backpacks":
            case "monkey backpack":
            case "ape atoll":
            case "backpack":
            case "backpacks":
                return "Monkey Backpacks";

            case "motherlode mine":
            case "motherlode":
            case "mlm":
            case "mm":
                return "Motherlode Mine";

            case "my notes":
            case "notes":
            case "note":
                return "My Notes";

            case "random event":
            case "random":
            case "randoms":
                return "Random Events";

            case "revs":
                return "Revenants";

            case "rooftop":
            case "rooftops":
            case "agility":
            case "graceful":
                return "Rooftop Agility";

            case "shayzien":
                return "Shayzien Armour";

            case "shooting star":
            case "star mining":
            case "ss":
            case "stars":
                return "Shooting Stars";

            case "skilling pet":
            case "skill pets":
            case "skill pet":
            case "pets skill":
            case "pet skill":
            case "pets skilling":
            case "pet skilling":
                return "Skilling Pets";

            case "slay":
                return "Slayer";

            case "tz haar":
            case "tz":
            case "tzh":
                return "TzHaar";

            case "misc":
                return "Miscellaneous";

            default:
                return query;
        }
    }
}

package me.clogged;

import com.google.gson.Gson;
import com.google.inject.Provides;

import javax.inject.Inject;

import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import me.clogged.data.*;
import me.clogged.data.config.DisplayMethod;
import me.clogged.data.config.SyncMethod;
import me.clogged.helpers.AliasHelper;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

import okhttp3.*;

import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
        name = "Clogged.me",
        description = "Sync your collection log with Clogged.me and view other players' logs"
)
public class CloggedPlugin extends Plugin {
    private static final String COLLECTION_LOG_COMMAND_STRING = "!clog";
    private static final int CLOG_CONTAINER_WIDGET_ID = 40697943;
    private static final int CLOG_SEARCH_WIDGET_ID = 40697932;
    private static final int COLLECTION_LOG_SCRIPT_ID = 4100;
    private static final int TICKS_TO_WAIT_AFTER_LOAD = 2;

    private final CollectionLogStructure collectionLogStructure = new CollectionLogStructure();
    private final UserCollectionLog userCollectionLog = new UserCollectionLog();
    private final Map<Integer, Integer> loadedCollectionLogIcons = new HashMap<>();

    private int ticksToWait = 0;
    private int collectionLogScriptFiredTick = -1;
    private boolean structureCreated = false;
    private boolean collectionLogInterfaceOpenedAndSynced = false;

    @Inject private Client client;
    @Inject private CloggedConfig config;
    @Inject private ChatMessageManager chatMessageManager;
    @Inject private ChatCommandManager chatCommandManager;
    @Inject private ClientThread clientThread;
    @Inject private Gson gson;
    @Inject private ItemManager itemManager;
    @Inject private ConfigManager configManager;
    @Inject private CloggedApiClient cloggedApiClient;

    @Override
    protected void startUp() throws Exception {
        chatCommandManager.registerCommandAsync(COLLECTION_LOG_COMMAND_STRING, this::handleChatMessage);
    }

    @Override
    protected void shutDown() throws Exception {
        chatCommandManager.unregisterCommand(COLLECTION_LOG_COMMAND_STRING);
    }

    @Provides
    CloggedConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(CloggedConfig.class);
    }

    // Event Handling

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (!structureCreated && gameStateChanged.getGameState() == GameState.LOGGED_IN) {
            clientThread.invokeLater(this::createCollectionLogStructure);
        }
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded widgetLoaded) {
        if (!isSyncEnabled() || config.syncMethod() == SyncMethod.MANUAL) {
            return;
        }

        if (widgetLoaded.getGroupId() == InterfaceID.COLLECTION && !collectionLogInterfaceOpenedAndSynced) {
            ticksToWait = TICKS_TO_WAIT_AFTER_LOAD;
        }
    }

    @Subscribe
    public void onWidgetClosed(WidgetClosed widgetClosed) {
        if (widgetClosed.getGroupId() == InterfaceID.COLLECTION) {
            ticksToWait = 0;
            collectionLogInterfaceOpenedAndSynced = false;
        }
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        if (!isSyncEnabled()) {
            return;
        }

        // Wait for ticks after the collection log interface is opened
        if (ticksToWait > 0) {
            if (--ticksToWait == 0) {
                clientThread.invokeLater(this::updateUserCollectionLog);
            }
        }

        checkForCollectionLogScriptFired();
    }

    @Subscribe
    public void onScriptPreFired(ScriptPreFired preFired) {
        // Script 4100 is fired when the search interface in the collection log is opened
        if (preFired.getScriptId() == COLLECTION_LOG_SCRIPT_ID && !collectionLogInterfaceOpenedAndSynced) {
            recordScriptFiredTick();
            processScriptArguments(preFired.getScriptEvent().getArguments());
        }
    }

    private void recordScriptFiredTick() {
        collectionLogScriptFiredTick = client.getTickCount();
    }

    private void checkForCollectionLogScriptFired() {
        if (collectionLogScriptFiredTick != -1 && collectionLogScriptFiredTick + 2 > client.getTickCount() && !collectionLogInterfaceOpenedAndSynced) {
            collectionLogScriptFiredTick = -1;
            collectionLogInterfaceOpenedAndSynced = true;
            syncCollectionLog();
        }
    }

    private void processScriptArguments(Object[] args) {
        int itemId = (int) args[1];
        if (itemId > 0) {
            try {
                CollectionLogItem item = collectionLogStructure.findItemById(itemId);
                userCollectionLog.markItemAsObtained(item.getSubCategoryId(), itemId);
            } catch (NullPointerException e) {
                log.warn("Item ID {} not found in collection log structure", itemId);
            }
        }
    }

    // Chat Command Handling

    private void handleChatMessage(ChatMessage chatMessage, String message) {
        if (message.length() == COLLECTION_LOG_COMMAND_STRING.length()) {
            return;
        }

        String commandArg = message.substring(COLLECTION_LOG_COMMAND_STRING.length() + 1);

        if (commandArg.equals("sync")) {
            clientThread.invoke(this::updateUserCollectionLog);
        } else {
            handleSubCategoryLookup(chatMessage, commandArg);
        }
    }

    private void handleSubCategoryLookup(ChatMessage chatMessage, String commandArg) {
        clientThread.invoke(() -> {
            if (!config.enableLookup()) {
                showLookupDisabledMessage();
                return;
            }

            if (config.proxyEnabled() && (config.proxyHost() == null || config.proxyHost().isEmpty() || config.proxyPort() <= 0)) {
                showProxySettingsIncompleteMessage();
                return;
            }

            SubCategory subCategory = collectionLogStructure.findSubCategoryByName(AliasHelper.ClogAlias(commandArg));
            if (subCategory == null) {
                return;
            }

            String username = Text.sanitize(chatMessage.getName());
            if (chatMessage.getType().equals(ChatMessageType.PRIVATECHATOUT))
            {
                username = client.getLocalPlayer().getName();
            }

            int subCategoryId = subCategory.getId();
            cloggedApiClient.getUserCollectionLog(username, subCategoryId, createLookupCallback(subCategoryId, chatMessage));
        });
    }

    private Callback createLookupCallback(int subCategoryId, ChatMessage chatMessage) {
        return new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.error("Failed to get user collection log: {}", e.getMessage());
                showLookupFailedMessage();
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                if (!response.isSuccessful()) {
                    response.close();
                    return;
                }

                assert response.body() != null;
                String responseBody = response.body().string();
                CollectionLogLookupResponse lookupResponse = gson.fromJson(responseBody, CollectionLogLookupResponse.class);

                clientThread.invoke(() -> {
                    String replacementMessage = buildReplacementMessage(lookupResponse, subCategoryId);
                    updateChatMessage(chatMessage, replacementMessage);
                });
            }
        };
    }

    private void updateChatMessage(ChatMessage chatMessage, String text) {
        chatMessage.getMessageNode().setValue(text);
        client.refreshChat();
    }

    // Collection Log Management

    private void createCollectionLogStructure() {
        Map<String, Category> categories = createCategories();
        Map<String, Integer> collectionLogCategoriesMap = createCategoryEnumMap();

        populateCategoriesFromEnums(categories, collectionLogCategoriesMap);

        // Add all categories to the structure
        for (Category category : categories.values()) {
            collectionLogStructure.addCategory(category);
        }
        structureCreated = true;
    }

    private Map<String, Category> createCategories() {
        return Map.of(
                "bosses", new Category("Bosses"),
                "raids", new Category("Raids"),
                "clues", new Category("Clues"),
                "minigames", new Category("Minigames"),
                "other", new Category("Other")
        );
    }

    private Map<String, Integer> createCategoryEnumMap() {
        return Map.of(
                "bosses", 2103,
                "raids", 2104,
                "clues", 2105,
                "minigames", 2106,
                "other", 2107
        );
    }

    private void populateCategoriesFromEnums(Map<String, Category> categories, Map<String, Integer> enumMap) {
        for (Map.Entry<String, Integer> entry : enumMap.entrySet()) {
            String categoryName = entry.getKey();
            int enumId = entry.getValue();
            Category category = categories.get(categoryName);

            int[] subcategoryIds = client.getEnum(enumId).getIntVals();
            for (int subcategoryId : subcategoryIds) {
                SubCategory subCategory = createSubCategoryFromStruct(subcategoryId);
                category.addSubCategory(subCategory);
            }
        }
    }

    private SubCategory createSubCategoryFromStruct(int subcategoryId) {
        StructComposition subcategoryStruct = client.getStructComposition(subcategoryId);
        String subcategoryName = subcategoryStruct.getStringValue(689);
        int[] items = client.getEnum(subcategoryStruct.getIntValue(690)).getIntVals();

        SubCategory subCategory = new SubCategory(
                subcategoryName,
                subcategoryId,
                new HashSet<>(),
                getSummedKcForBoss(subcategoryName)
        );

        for (int itemId : items) {
            CollectionLogItem item = new CollectionLogItem(
                    itemId,
                    client.getItemDefinition(itemId).getName(),
                    subcategoryId
            );
            subCategory.addItem(item);
        }

        // For whatever reason, these two item ids in the enum do not match
        // Special handling for Mahogany Homes
        if (subcategoryId == 1689) {
            subCategory.addItem(new CollectionLogItem(25629, "Plank sack", subcategoryId));
        }

        // Special handling for Motherlode Mine
        if (subcategoryId == 530) {
            subCategory.addItem(new CollectionLogItem(25627, "Coal bag", subcategoryId));
        }

        return subCategory;
    }

    private void updateUserCollectionLog() {
        if (!isSyncEnabled()) {
            showSyncingDisabledMessage();
            return;
        }

        Widget collectionLogContainer = client.getWidget(CLOG_CONTAINER_WIDGET_ID);
        if (collectionLogContainer == null) {
            showCollectionLogClosedMessage();
            return;
        }

        // Trigger search to load all items
        client.menuAction(-1, CLOG_SEARCH_WIDGET_ID, MenuAction.CC_OP, 1, -1, "Search", null);
        client.runScript(2240);
    }

    private void updateSubcategoryKcs() {
        for (Category category : collectionLogStructure.getCategories().values()) {
            for (SubCategory subCategory : category.getSubCategories().values()) {
                int kc = getSummedKcForBoss(subCategory.getName());
                if (kc < 1) {
                    continue;
                }

                subCategory.setKc(kc);
            }
        }
    }

    private void syncCollectionLog() {
        showSyncingMessage();
        updateSubcategoryKcs();
        String userDataJson = createUserCollectionLogJson();
        cloggedApiClient.updateUserCollectionLog(userDataJson, createUploadCallback());
    }

    private String createUserCollectionLogJson() {
        Map<String, Object> userDataMap = new HashMap<>();
        userDataMap.put("username", client.getLocalPlayer().getName());
        userDataMap.put("accountHash", client.getAccountHash());
        userDataMap.put("collectedIds", userCollectionLog.getSubCategoryItemIds());
        userDataMap.put("categories", collectionLogStructure.getCategoryJson());
        return gson.toJson(userDataMap);
    }

    private Callback createUploadCallback() {
        return new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.error("Unable to upload data to Clogged.me: {}", e.getMessage());
                showSyncFailedMessage();
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) {
                response.close();
                showSyncSuccessMessage();
            }
        };
    }

    // UI and Message Helpers

    private void showSyncingDisabledMessage() {
        chatMessageManager.queue(QueuedMessage.builder()
                .type(ChatMessageType.GAMEMESSAGE)
                .runeLiteFormattedMessage("Clogged: Syncing is disabled in the plugin options.")
                .build());
    }

    private void showLookupDisabledMessage() {
        chatMessageManager.queue(QueuedMessage.builder()
                .type(ChatMessageType.GAMEMESSAGE)
                .runeLiteFormattedMessage("Clogged: Lookups are disabled in the plugin options.")
                .build());
    }

    private void showProxySettingsIncompleteMessage() {
        chatMessageManager.queue(QueuedMessage.builder()
                .type(ChatMessageType.GAMEMESSAGE)
                .runeLiteFormattedMessage("Clogged: Use proxy is enabled but proxy settings are incomplete. Please check the plugin settings.")
                .build());
    }

    private void showCollectionLogClosedMessage() {
        chatMessageManager.queue(QueuedMessage.builder()
                .type(ChatMessageType.GAMEMESSAGE)
                .runeLiteFormattedMessage("Clogged: The collection log interface must be open to sync.")
                .build());
    }

    private void showSyncingMessage() {
        chatMessageManager.queue(QueuedMessage.builder()
                .type(ChatMessageType.GAMEMESSAGE)
                .runeLiteFormattedMessage("Clogged: Syncing collection log...")
                .build());
    }

    private void showSyncSuccessMessage() {
        chatMessageManager.queue(QueuedMessage.builder()
                .type(ChatMessageType.GAMEMESSAGE)
                .runeLiteFormattedMessage("Clogged: Collection log synced successfully.")
                .build());
    }

    private void showSyncFailedMessage() {
        chatMessageManager.queue(QueuedMessage.builder()
                .type(ChatMessageType.GAMEMESSAGE)
                .runeLiteFormattedMessage("Clogged: Failed to sync collection log. Try again or reach out to Advistane on Discord.")
                .build());
    }

    private void showLookupFailedMessage() {
        chatMessageManager.queue(QueuedMessage.builder()
                .type(ChatMessageType.GAMEMESSAGE)
                .runeLiteFormattedMessage("Clogged: Failed to lookup collection log. Try again or reach out to Advistane on Discord.")
                .build());
    }

    private String buildReplacementMessage(CollectionLogLookupResponse response, int subCategoryId) {
        int kc = response.getKc();
        SubCategory subCategory = collectionLogStructure.findSubCategoryById(subCategoryId);

        List<CollectionLogItem> obtainedItems = getObtainedItems(response);
        if (obtainedItems.isEmpty()) {
            return "No items found for input";
        }

        StringBuilder messageBuilder = new StringBuilder();
        messageBuilder.append(subCategory.getName());

        if (kc > 0) {
            messageBuilder.append(" (").append(kc).append(" KC)");
        }
        messageBuilder.append(": ");

        if (config.displayMethod() == DisplayMethod.ICON) {
            loadClogIcons(obtainedItems);
        }

        appendItems(messageBuilder, obtainedItems);
        return messageBuilder.toString();
    }

    private List<CollectionLogItem> getObtainedItems(CollectionLogLookupResponse response) {
        List<CollectionLogItem> obtainedItems = new ArrayList<>();
        for (int itemId : response.getItems()) {
            CollectionLogItem item = collectionLogStructure.findItemById(itemId);
            if (item != null) {
                obtainedItems.add(item);
            }
        }
        return obtainedItems;
    }

    // Appends items to the message builder based on the display method
    private void appendItems(StringBuilder builder, List<CollectionLogItem> items) {
        for (CollectionLogItem item : items) {
            if (config.displayMethod() == DisplayMethod.TEXT) {
                builder.append(item.getName()).append(", ");
                continue;
            }

            try {
                String itemString = "<img=" + loadedCollectionLogIcons.get(item.getId()) + "> ";
                builder.append(itemString);
            } catch (NullPointerException e) {
                log.warn("Failed to load icon for item ID: {}", item.getId());
                builder.append(item.getName()).append(", ");
            }
        }

        // Remove the last comma and space
        if (config.displayMethod() == DisplayMethod.TEXT) {
            builder.setLength(builder.length() - 2);
        }
    }

    // Icon Management

    private void loadClogIcons(List<CollectionLogItem> collectionLogItems) {
        if (collectionLogItems.isEmpty()) {
            return;
        }

        List<CollectionLogItem> itemsToLoad = filterItemsToLoad(collectionLogItems);
        if (itemsToLoad.isEmpty()) {
            return;
        }

        final IndexedSprite[] modIcons = client.getModIcons();
        final IndexedSprite[] newModIcons = Arrays.copyOf(modIcons, modIcons.length + itemsToLoad.size());
        int modIconIdx = modIcons.length;

        for (int i = 0; i < itemsToLoad.size(); i++) {
            final CollectionLogItem item = itemsToLoad.get(i);
            final IndexedSprite sprite = createSpriteForItem(item.getId());
            final int spriteIndex = modIconIdx + i;

            newModIcons[spriteIndex] = sprite;
            loadedCollectionLogIcons.put(item.getId(), spriteIndex);
        }

        client.setModIcons(newModIcons);
    }

    private List<CollectionLogItem> filterItemsToLoad(List<CollectionLogItem> collectionLogItems) {
        return collectionLogItems.stream()
                .filter(item -> !loadedCollectionLogIcons.containsKey(item.getId()))
                .collect(Collectors.toList());
    }

    private IndexedSprite createSpriteForItem(int itemId) {
        final ItemComposition itemComposition = itemManager.getItemComposition(itemId);
        final BufferedImage image = ImageUtil.resizeImage(itemManager.getImage(itemComposition.getId()), 18, 15);
        return ImageUtil.getImageIndexedSprite(image, client);
    }

    private boolean isSyncEnabled() {
        return config.enableSync();
    }

    // Since the collection log doesn't separate bosses into their own subcategories, sum the kc of them
    private int getSummedKcForBoss(String boss) {
        switch (boss) {
            case "Daggonoth Kings":
                return getSimpleKcForBoss("Rex") + getSimpleKcForBoss("Prime") + getSimpleKcForBoss("Supreme");
            case "Callisto and Artio":
                return getSimpleKcForBoss("Callisto") + getSimpleKcForBoss("Artio");
            case "Chambers of Xeric":
                return getSimpleKcForBoss("Chambers of Xeric") + getSimpleKcForBoss("Chambers of Xeric challenge mode");
            case "Vet'ion and Calvar'ion":
                return getSimpleKcForBoss("Vet'ion") + getSimpleKcForBoss("Calvar'ion");
            case "Venenatis and Spindel":
                return getSimpleKcForBoss("Venenatis") + getSimpleKcForBoss("Spindel");
            case "The Gauntlet":
                return getSimpleKcForBoss("Gauntlet") + getSimpleKcForBoss("Corrupted Gauntlet");
            case "The Leviathan":
                return getSimpleKcForBoss("Leviathan") + getSimpleKcForBoss("Leviathan (awakened)");
            case "Vardovis":
                return getSimpleKcForBoss("Vardovis") + getSimpleKcForBoss("Vardovis (awakened)");
            case "The Whisperer":
                return getSimpleKcForBoss("Whisperer") + getSimpleKcForBoss("Whisperer (awakened)");
            case "The Nightmare":
                return getSimpleKcForBoss("Nightmare") + getSimpleKcForBoss("Phosani's Nightmare");
            case "Theatre of Blood":
                return getSimpleKcForBoss("Theatre of Blood") + getSimpleKcForBoss("Theatre of Blood Hard Mode") + getSimpleKcForBoss("Theatre of Blood Entry Mode");
            case "Tombs of Amascut":
                return getSimpleKcForBoss("Tombs of Amascut") + getSimpleKcForBoss("Tombs of Amascut Entry Mode") + getSimpleKcForBoss("Tombs of Amascut Expert Mode");
            default:
                return getSimpleKcForBoss(boss);
        }
    }

    private int getSimpleKcForBoss(String boss) {
        Integer killCount = configManager.getRSProfileConfiguration("killcount", AliasHelper.KCAlias(boss).toLowerCase(), int.class);
        return killCount != null ? killCount : -1;
    }
}
package me.clogged.data;

import lombok.Getter;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

// Represents a top-level category (e.g., "Bosses", "Raids")
@Getter
public class Category {
    private final String name;
    private final Map<String, SubCategory> subCategories; // Map subcategory name to SubCategory object

    public Category(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Category name cannot be null or empty.");
        }
        this.name = name.trim();
        this.subCategories = new HashMap<>();
    }

    public void addSubCategory(SubCategory subCategory) {
        if (subCategory == null) {
            throw new IllegalArgumentException("SubCategory cannot be null.");
        }

        this.subCategories.put(subCategory.getName(), subCategory);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Category category = (Category) o;
        return Objects.equals(name, category.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }

    @Override
    public String toString() {
        return "Category{" +
                "name='" + name + '\'' +
                ", subCategoryCount=" + subCategories.size() +
                '}';
    }
}

package me.clogged.data;

import lombok.Getter;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

// Represents a subcategory within a category (e.g., "Barrows Chests", "Cerberus")
@Getter
public class SubCategory {
    private final String name;
    private final Set<CollectionLogItem> items; // The unique items that belong to this subcategory
    private int kc; // Kill count for this subcategory, if applicable
    private final int id; // Unique ID for the subcategory

    public SubCategory(String name, int id, Set<CollectionLogItem> items) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("SubCategory name cannot be null or empty.");
        }
        this.name = name.trim();
        this.id = id;
        this.items = new HashSet<>(items); // Use a copy to avoid external modifications
    }

    public SubCategory(String name, int id, Set<CollectionLogItem> items, int kc) {
        this(name, id, items);
        this.kc = kc;
    }

    public void addItem(CollectionLogItem item) {
        if (item == null) {
            throw new IllegalArgumentException("Item cannot be null.");
        }
        this.items.add(item);
    }

    public void setKc(int kc) {
        if (kc < 0) {
            this.kc = -1;
            return;
        }

        this.kc = kc;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SubCategory that = (SubCategory) o;
        return Objects.equals(name, that.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }

    @Override
    public String toString() {
        return "SubCategory{" +
                "name='" + name + '\'' +
                ", itemCount=" + items.size() +
                '}';
    }
}

package me.clogged.data;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

// Represents a user's progress in the collection log
// This tracks which specific items a user has obtained.
public class UserCollectionLog {
    private final Map<Integer, Set<Integer>> subCategoryItemIds; // Map subcategory ID to a set of item IDs

    public UserCollectionLog() {
        this.subCategoryItemIds = new HashMap<>();
    }

    public Map<Integer, Set<Integer>> getSubCategoryItemIds() {
        return new HashMap<>(subCategoryItemIds); // Return a defensive copy
    }

    public void markItemAsObtained(int subcategoryId, int itemId) {
        if (itemId <= 0) {
            throw new IllegalArgumentException("Item ID must be positive.");
        }

        this.subCategoryItemIds.computeIfAbsent(subcategoryId, k -> new HashSet<>()).add(itemId);
    }
}

package me.clogged.data.config;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum DisplayMethod {
    TEXT("Text"),
    ICON("Icons");

    private final String name;

    @Override
    public String toString() {
        return name;
    }
}

package me.clogged.data.config;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum SyncMethod {
    MANUAL("Manual"),
    AUTO("Automatic");

    private final String name;

    @Override
    public String toString() {
        return name;
    }
}

package me.clogged.data;

import lombok.Getter;

import java.util.Objects;

// Represents a single unique item in the collection log
@Getter
public class CollectionLogItem {
    private final int id; // Unique ID for the item
    private final String name;
    private final int subCategoryId;

    public CollectionLogItem(int id, String name, int subCategory) {
        if (id <= 0) {
            throw new IllegalArgumentException("Item ID must be positive.");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Item name cannot be null or empty.");
        }
        this.id = id;
        this.name = name.trim();
        this.subCategoryId = subCategory;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        CollectionLogItem item = (CollectionLogItem) o;
        return id == item.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "Item{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}

package me.clogged.data;

import lombok.Getter;

import java.util.List;

@Getter
public class CollectionLogLookupResponse {
    private int kc;
    private List<Integer> items;

}

package me.clogged.data;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import lombok.Getter;

import java.util.HashMap;
import java.util.Map;

// Represents the entire static collection log structure
// This defines ALL possible items in the log, organized by category and subcategory.
public class CollectionLogStructure {
    @Getter
    private final Map<String, Category> categories; // Map category name to Category object
    private final Map<Integer, CollectionLogItem> itemByIdMap; // Map item ID directly to Item object for quick lookup

    public CollectionLogStructure() {
        this.categories = new HashMap<>();
        this.itemByIdMap = new HashMap<>();
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("CollectionLogStructure:\n");
        sb.append("Total Categories: ").append(categories.size()).append("\n");
        sb.append("Total Items: ").append(itemByIdMap.size()).append("\n");
        sb.append("Categories:\n");
        for (Map.Entry<String, Category> entry : categories.entrySet()) {
            sb.append("  - ").append(entry.getKey()).append(":\n");
            for (SubCategory subCategory : entry.getValue().getSubCategories().values()) {
                sb.append("    * ").append(subCategory.getName()).append(": ").append(subCategory.getKc()).append(":\n");
                for (CollectionLogItem item : subCategory.getItems()) {
                    sb.append("      - ").append(item.getId()).append(": ").append(item.getName()).append("\n");
                }
            }
        }
        return sb.toString();
    }

    public void addCategory(Category category) {
        if (category == null) {
            throw new IllegalArgumentException("Category cannot be null.");
        }
        // Add the category
        this.categories.put(category.getName(), category);

        // Add all items within this category and its subcategories to the flat item map
        for (SubCategory subCategory : category.getSubCategories().values()) {
            for (CollectionLogItem item : subCategory.getItems()) {
                if (!this.itemByIdMap.containsKey(item.getId())) {
                    this.itemByIdMap.put(item.getId(), item);
                }
            }
        }
    }

    public CollectionLogItem findItemById(int itemId) {
        return this.itemByIdMap.get(itemId);
    }

    public SubCategory findSubCategoryByName(String subCategoryName) {
        for (Category category : categories.values()) {
            for (SubCategory subCategory : category.getSubCategories().values()) {
                if (subCategory.getName().equalsIgnoreCase(subCategoryName)) {
                    return subCategory;
                }
            }
        }
        return null; // Not found
    }

    public SubCategory findSubCategoryById(int subCategoryId) {
        for (Category category : categories.values()) {
            for (SubCategory subCategory : category.getSubCategories().values()) {
                if (subCategory.getId() == subCategoryId) {
                    return subCategory;
                }
            }
        }
        return null; // Not found
    }

    public JsonArray getCategoryJson() {
        JsonArray categoriesArray = new JsonArray();

        for (Map.Entry<String, Category> categoryEntry : categories.entrySet()) {
            JsonObject categoryObject = new JsonObject();
            categoryObject.addProperty("categoryName", categoryEntry.getKey());

            JsonArray subCategoriesArray = getJsonElements(categoryEntry);

            categoryObject.add("subCategories", subCategoriesArray);
            categoriesArray.add(categoryObject);
        }

        return categoriesArray;
    }

    private static JsonArray getJsonElements(Map.Entry<String, Category> categoryEntry) {
        JsonArray subCategoriesArray = new JsonArray();
        for (SubCategory subCategory : categoryEntry.getValue().getSubCategories().values()) {
            JsonObject subCategoryObject = new JsonObject();
            subCategoryObject.addProperty("subcategoryName", subCategory.getName());
            subCategoryObject.addProperty("subcategoryId", subCategory.getId()); // Assuming SubCategory has an `id` field
            subCategoryObject.addProperty("kc", subCategory.getKc());
            subCategoriesArray.add(subCategoryObject);
        }
        return subCategoriesArray;
    }
}


package me.clogged;

import me.clogged.data.config.DisplayMethod;
import me.clogged.data.config.SyncMethod;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("clogged")
public interface CloggedConfig extends Config
{
	String PLUGIN_VERSION = "1.0.0";

	@ConfigItem(
		keyName = "enableSync",
		name = "Enable sync with Clogged.me",
		description = "This will sync your collection log with Clogged.me",
		position = 1
	)
	default boolean enableSync()
	{
		return false;
	}

	@ConfigItem(
			keyName = "enableLookup",
			name = "Enable lookups with Clogged.me",
			description = "This will allow you to view collection logs from other players.<br>This does not sync your log with Clogged.me.",
			position = 2
	)
	default boolean enableLookup()
	{
		return false;
	}

	@ConfigItem(
		keyName = "syncMethod",
		name = "Sync method",
		description = "Manual: Must type '!clog sync' with collection log interface open.<br>" +
			"Automatic: Syncs whenever the collection log interface is open (might cause strange behavior for a split second when opening).",
		position = 3
	)
	default SyncMethod syncMethod()
	{
		return SyncMethod.MANUAL;
	}

	@ConfigItem(
			keyName = "displayMethod",
			name = "Display method",
			description = "Text: Collection log items will be displayed as text.<br>" +
					"Icons: Collection log items will be displayed as icons.",
			position = 4
	)

	default DisplayMethod displayMethod()
	{
		return DisplayMethod.TEXT;
	}

	@ConfigSection(
			name = "Proxy Settings",
			description = "Proxy settings for Clogged.me API",
			position = 5,
			closedByDefault = true
	)
	String proxySettingsSection = "proxySettingsSection";

	@ConfigItem(
			keyName = "proxyEnabled",
			name = "Enable proxy",
			description = "Clogged.me does not store nor associate your IP address with your account or client in any way.<br>" +
					"With that being said, enabling this will use the specified proxy settings to connect to the Clogged.me API.<br>" +
					"Only enable this if you know what you're doing.",
			section = proxySettingsSection,
			position = 6
	)
	default boolean proxyEnabled()
	{
		return false;
	}

	@ConfigItem(
			keyName = "proxyHost",
			name = "Proxy Host",
			description = "The host of the proxy server.",
			section = proxySettingsSection,
			position = 7
	)
	default String proxyHost()
	{
		return "";
	}

	@ConfigItem(
			keyName = "proxyPort",
			name = "Proxy Port",
			description = "The port of the proxy server.",
			section = proxySettingsSection,
			position = 8
	)
	default int proxyPort()
	{
		return 0;
	}

	@ConfigItem(
			keyName = "proxyUsername",
			name = "Proxy Username",
			description = "The username for the proxy server.",
			section = proxySettingsSection,
			position = 9
	)
	default String proxyUsername()
	{
		return "";
	}

	@ConfigItem(
			keyName = "proxyPassword",
			name = "Proxy Password",
			description = "The password for the proxy server.",
			section = proxySettingsSection,
			position = 10
	)
	default String proxyPassword()
	{
		return "";
	}
}

package me.clogged;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CloggedPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CloggedPlugin.class);
		RuneLite.main(args);
	}
}
