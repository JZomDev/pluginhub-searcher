/*
 * Copyright (c) 2020, Ryan W. O'Hara <ryan@ryanwohara.com>, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.irc;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ChatMessageType;
import net.runelite.client.config.*;


@ConfigGroup("irc")
public interface IrcConfig extends Config
{
    @ConfigSection(
            name = "Connection",
            description = "Connection settings",
            position = 0
    )
    String connectionSettings = "connectionSettings";

    @ConfigItem(
            keyName = "server",
            name = "Server",
            description = "Server to use to directly connect.",
            position = 0,
            section = connectionSettings
    )
    default Server server() {
        return Server.USA;
    };

    @Getter
    @RequiredArgsConstructor
    enum Server {
        USA("Fiery (West-USA)", "fiery.ca.us.swiftirc.net"),
        UK("London (UK)", "tardis.en.uk.swiftirc.net");

        private final String name;
        private final String hostname;
    }

    @ConfigItem(
            keyName = "username",
            name = "Username",
            description = ";use the chat like this.",
            position = 1,
            section = connectionSettings
    )
    String username();

    @ConfigItem(
            keyName = "password",
            name = "Password (Optional) (not Jagex)",
            description = "NickServ password (Optional) (NEVER your RS password!)",
            position = 2,
            secret = true,
            section = connectionSettings
    )
    String password();

    @ConfigItem(
            keyName = "channel",
            name = "Channel(s)",
            description = "Channel(s) to join, comma separated",
            position = 3,
            section = connectionSettings
    )
    default String channel()
    {
        return "#rshelp";
    }

    @ConfigItem(
            keyName = "channelPassword",
            name = "Channel Password",
            description = "Password to enter channel. (Optional)",
            position = 4,
            secret = true,
            section = connectionSettings
    )
    default String channelPassword()
    {
        return "";
    }

    @ConfigSection(
            name = "General",
            description = "General settings",
            position = 1
    )
    String generalSettings = "generalSettings";

    @ConfigItem(
            keyName = "prefix",
            name = "Prefix",
            description = ";chat with this character like this.",
            position = 0,
            section = generalSettings
    )
    default String prefix() { return ";"; }

    @ConfigItem(
            keyName = "activeChannelOnly",
            name = "Active Channel Only",
            description = "Only show the active IRC channel in the OSRS chat box.",
            position = 1,
            section = generalSettings
    )
    default boolean activeChannelOnly() { return false; }

    @ConfigItem(
            keyName = "backTickNavigation",
            name = "Backtick Channel Navigation",
            description = "Use ` and shift+` to navigate channels",
            position = 2,
            section = generalSettings
    )
    default boolean backTickNavigation() { return true; }

    @ConfigItem(
            keyName = "pageUpDownNavigation",
            name = "Page Up/Down Channel Navigation",
            description = "Use PageUp/PageDn and shift+PageUp/shift+PageDn to navigate channels",
            position = 3,
            section = generalSettings
    )
    default boolean pageUpDownNavigation() { return true; }

    @ConfigItem(
            keyName = "autofocusOnNewTab",
            name = "Autofocus on New Tab",
            description = "If you receive a PM/notice or join a new channel, it will become your focus. Initial channel join will always focus regardless of this setting.",
            position = 4,
            section = generalSettings
    )
    default boolean autofocusOnNewTab() { return false; }

    @ConfigItem(
            keyName = "filterServerNotices",
            name = "Server Notice Tab",
            description = "Receiving a server notice will open a new dedicated tab for it.",
            position = 5,
            section = generalSettings
    )
    default boolean filterServerNotices() { return false; }

    @Getter
    @RequiredArgsConstructor
    enum Chatbox {
        FRIENDSCHAT(ChatMessageType.FRIENDSCHAT),
        CLAN_CHAT(ChatMessageType.CLAN_CHAT);

        private final ChatMessageType type;
    }

    @ConfigItem(
            keyName = "chatboxType",
            name = "Chatbox Type",
            description = "Which type of chatbox will be used in-game.",
            position = 6,
            section = generalSettings
    )
    default Chatbox getChatboxType() { return Chatbox.FRIENDSCHAT; }

    @Getter
    @RequiredArgsConstructor
    enum MessageDisplay {
        Status("Show only in status window."),
        Current("Show only in current window."),
        Private("Show only in a private window with the sender.");

        private final String description;
    }

    @ConfigItem(
            keyName = "filterNotices",
            name = "Notice Window",
            description = "Adjust how to treat the display of notices.",
            position = 7,
            section = generalSettings
    )
    default MessageDisplay filterNotices() { return MessageDisplay.Current; }


    @ConfigItem(
            keyName = "filterPMs",
            name = "PM Window",
            description = "Adjust how to treat the display of PMs.",
            position = 8,
            section = generalSettings
    )
    default MessageDisplay filterPMs() { return MessageDisplay.Current; }

    @ConfigItem(
            keyName = "hideConnectionMessages",
            name = "Hide Join/Part/Quit/Kick",
            description = "Hides connection status messages like joins, parts, quits, and kicks from channel windows.",
            position = 9,
            section = generalSettings
    )
    default boolean hideConnectionMessages() { return false; }

    @ConfigSection(
            name = "Overlay",
            description = "In-game overlay",
            position = 2
    )
    String overlaySettings = "overlaySettings";

    @ConfigItem(
            keyName = "overlayEnabled",
            name = "Enable In-Game Overlay",
            description = "Show the IRC overlay inside the game",
            position = 0,
            section = overlaySettings
    )
    default boolean overlayEnabled() { return true; }

    @ConfigItem(
            keyName = "overlayDynamic",
            name = "Overlay the Chat Box",
            description = "Toggle between a chatbox overlay or an alt+click & drag overlay.",
            position = 1,
            section = overlaySettings
    )
    default boolean overlayDynamic() { return true; }

    @ConfigItem(
            keyName = "overlayMaxWidth",
            name = "Overlay Max Width",
            description = "Max width of the overlay",
            position = 2,
            section = overlaySettings
    )
    default int overlayMaxWidth() { return 500; }

    @ConfigSection(
            name = "Side Panel",
            description = "Side panel settings",
            position = 3
    )
    String sidePanelSettings = "sidePanelSettings";

    @ConfigItem(
            keyName = "sidePanel",
            name = "Enabled",
            description = "Enable the side panel",
            position = 0,
            section = sidePanelSettings
    )
    default boolean sidePanel() { return true;}

    @ConfigItem(
            keyName = "timestamp",
            name = "Timestamp",
            description = "Enable the timestamp",
            position = 1,
            section = sidePanelSettings
    )
    default boolean timestamp() { return true;}

    @ConfigItem(
            keyName = "hoverPreviewImages",
            name = "Hover-Preview Image Links",
            description = "Display an image just by hovering over the link (WARNING: could leak your IP without clicking)",
            position = 2,
            section = sidePanelSettings
    )
    default boolean hoverPreviewImages() { return false; }

    @ConfigItem(
            keyName = "colorizedNicks",
            name = "Colorized Nicks",
            description = "Add color to nicks.",
            position = 3,
            section = sidePanelSettings
    )
    default boolean colorizedNicks() { return true; }

    @Range(
            min = 0
    )
    @ConfigItem(
            keyName = "panelPriority",
            name = "Position in Sidebar",
            description = "Control where the panel appears in the sidebar of RuneLite",
            position = 4,
            section = sidePanelSettings
    )
    default int getPanelPriority() { return 10; }

    @Range(
            min = 0
    )
    @ConfigItem(
            keyName = "maxScrollback",
            name = "Maximum Scrollback per Channel",
            description = "Restrict the scrollback per channel to avoid lag",
            position = 5,
            section = sidePanelSettings
    )
    default int getMaxScrollback() { return 100; }

    @ConfigItem(
            keyName = "fontFamily",
            name = "Font Family",
            description = "Font family to use everywhere.",
            position = 6,
            hidden = true,
            section = sidePanelSettings
    )
    default String fontFamily() { return "SansSerif"; }

    @ConfigItem(
            keyName = "fontSize",
            name = "Font Size",
            description = "Font size to use everywhere.",
            position = 7,
            hidden = true,
            section = sidePanelSettings
    )
    default Integer fontSize() { return 12; }
}
package com.irc;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

@Slf4j
public class PreviewManager {
    private final OkHttpClient okHttpClient;
    private static final int MAX_PREVIEW_WIDTH = 500;
    private static final int MAX_PREVIEW_HEIGHT = 500;
    private Popup currentImagePreview;
    private CompletableFuture<?> imagePreviewFuture;
    private final Timer debounceTimer;
    private Point pendingPoint;
    private String pendingUrl;
    private final IrcPanel.ChannelPane channelPane;
    private static final Pattern IMAGE_URL_PATTERN = Pattern.compile("\\.(png|jpe?g|bmp)(\\?.*)?$", Pattern.CASE_INSENSITIVE);
    private final Cache<String, byte[]> imageCache;

    public PreviewManager(IrcPanel.ChannelPane channelPane, OkHttpClient okHttpClient) {
        this.channelPane = channelPane;
        this.debounceTimer = new Timer(100, e -> queueShowPreview());
        this.debounceTimer.setRepeats(false);
        this.imageCache = CacheBuilder.newBuilder()
                .maximumSize(50)
                .expireAfterWrite(5, TimeUnit.MINUTES)
                .build();
        this.okHttpClient = okHttpClient;
    }

    public void requestShow(Point mousePoint, String url) {
        cancelPreview();
        this.pendingPoint = mousePoint;
        this.pendingUrl = url;
        debounceTimer.restart();
    }

    private void queueShowPreview() {
        if (pendingPoint != null && pendingUrl != null && channelPane.isShowing()) {
            showImagePreview(this.pendingPoint, this.pendingUrl);
        }
    }

    public void cancelPreview() {
        debounceTimer.stop();
        pendingPoint = null;
        pendingUrl = null;
        hideImagePreview();
    }

    public boolean isImageUrl(String url) {
        return IMAGE_URL_PATTERN.matcher(url).find();
    }

    public void showImagePreview(Point mousePoint, String imageUrl) {
        cancelPreviewManager();
        this.pendingPoint = mousePoint;

        if (imagePreviewFuture != null && !imagePreviewFuture.isDone()) {
            imagePreviewFuture.cancel(true);
        }

        imagePreviewFuture = CompletableFuture.runAsync(() -> {
            try {
                handleStaticImagePreview(imageUrl);
            } catch (Exception e) {
                log.warn("Failed to create image preview for {}", imageUrl, e);
            }
        });
    }

    private void handleStaticImagePreview(String imageUrl) throws IOException {
        if (okHttpClient == null) {
            log.warn("No OkHttp connection available");
            return;
        }

        byte[] imageBytes = imageCache.getIfPresent(imageUrl);

        if (imageBytes == null || imageBytes.length == 0) {
            log.debug("Cache miss for {}, fetching from network.", imageUrl);

            String encodedUrl = URLEncoder.encode(imageUrl, StandardCharsets.UTF_8);

            // CloudFlare worker to protect users from IP grabbers
            String url = "https://image-proxy.cold-pine-9570.workers.dev/?url=" + encodedUrl;
            // Discord doesn't support CloudFlare workers :(
            if (imageUrl.startsWith("https://cdn.discordapp.com/")) {
                url = imageUrl;
            }

            Request request = new Request.Builder().url(url).build();
            okHttpClient.newCall(request).enqueue(new Callback() {
                @Override
                public void onFailure(Call call, IOException e) {
                    e.printStackTrace();
                }

                @Override
                public void onResponse(Call call, Response response) throws IOException {
                    if (!response.isSuccessful()) {
                        log.warn("Failed to fetch image preview for {}", imageUrl);
                        return;
                    }

                    if (response.code() != 200) {
                        log.warn("Failed to fetch image: {} returned status {}", imageUrl, response.code());
                        return;
                    }

                    String contentType = response.header("Content-Type");
                    if (contentType == null || !contentType.toLowerCase().startsWith("image/")) {
                        log.warn("Invalid content-type for {}: {}", imageUrl, contentType);
                        return;
                    }

                    if (response.body() == null) {
                        log.warn("Empty body for: {}", imageUrl);
                        return;
                    }

                    try (InputStream in = response.body().byteStream();
                         ByteArrayOutputStream baos = new ByteArrayOutputStream()) {

                        byte[] buffer = new byte[4096];
                        int n;
                        while ((n = in.read(buffer)) != -1) {
                            baos.write(buffer, 0, n);
                        }
                        byte[] imageBytes = baos.toByteArray();
                        imageCache.put(imageUrl, imageBytes);
                        response.close();

                        showPreview(imageUrl, imageBytes);
                    }
                }
            });
        } else {
            log.debug("Cache hit for {}", imageUrl);
            showPreview(imageUrl, imageBytes);
        }
    }

    private void showPreview(String imageUrl, byte[] imageBytes) throws IOException {
        if (imageBytes != null) {
            BufferedImage originalImage = ImageIO.read(new ByteArrayInputStream(imageBytes));
            if (originalImage == null) {
                log.warn("Could not decode image from URL: {}", imageUrl);
                imageCache.invalidate(imageUrl);
                return;
            }

            ImageIcon imageIcon = new ImageIcon(scaleImage(originalImage));

            JLabel preview = new JLabel(imageIcon);
            preview.addMouseListener(new MouseAdapter() {
                @Override
                public void mouseExited(MouseEvent e) {
                    cancelPreviewManager();
                }
            });
            SwingUtilities.invokeLater(() -> displayPopup(this.pendingPoint, preview));
        }
    }

    private BufferedImage scaleImage(BufferedImage originalImage) {
        double scale = Math.min(1.0, Math.min(
                (double) MAX_PREVIEW_WIDTH / originalImage.getWidth(),
                (double) MAX_PREVIEW_HEIGHT / originalImage.getHeight()
        ));

        int scaledWidth = (int) (originalImage.getWidth() * scale);
        int scaledHeight = (int) (originalImage.getHeight() * scale);

        BufferedImage scaledImage = new BufferedImage(scaledWidth, scaledHeight, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = scaledImage.createGraphics();
        g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        g2d.drawImage(originalImage, 0, 0, scaledWidth, scaledHeight, null);
        g2d.dispose();
        return scaledImage;
    }

    private void displayPopup(Point location, JComponent content) {
        try {
            cancelPreviewManager();
            if (!channelPane.isShowing()) {
                return;
            }

            Window topLevelWindow = SwingUtilities.getWindowAncestor(channelPane);
            if (topLevelWindow == null) return;

            if (location == null) {
                log.warn("Mouse location is null");
                return;
            }
            SwingUtilities.convertPointToScreen(location, channelPane);

            Dimension contentSize = content.getPreferredSize();
            Rectangle screenBounds = topLevelWindow.getGraphicsConfiguration().getBounds();

            // Adjust Y coordinate
            if (location.y + contentSize.height > screenBounds.y + screenBounds.height) {
                Point componentOnScreen = channelPane.getLocationOnScreen();
                int yAbove = componentOnScreen.y + location.y - contentSize.height;

                if (yAbove >= screenBounds.y) {
                    location.y = yAbove;
                } else {
                    location.y = screenBounds.y + screenBounds.height - contentSize.height;
                }
            }

            if (location.x + contentSize.width > screenBounds.x + screenBounds.width) {
                location.x = screenBounds.x + screenBounds.width - contentSize.width;
            }

            if (location.y < screenBounds.y) {
                location.y = screenBounds.y;
            }
            if (location.x < screenBounds.x) {
                location.x = screenBounds.x;
            }

            content.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));
            content.setOpaque(true);

            currentImagePreview = PopupFactory.getSharedInstance().getPopup(channelPane, content, location.x, location.y);
            currentImagePreview.show();
        } catch (Exception e) {
            log.warn("Could not display popup", e);
        }
    }

    void hideImagePreview() {
        if (imagePreviewFuture != null && !imagePreviewFuture.isDone()) {
            imagePreviewFuture.cancel(true);
            imagePreviewFuture = null;
        }
        if (currentImagePreview != null) {
            currentImagePreview.hide();
            currentImagePreview = null;
        }
    }

    void cancelPreviewManager() {
        cancelPreview();
    }
}
package com.irc.emoji;

import java.util.*;

public class EmojiManager {
    private static final Map<String, Emoji> EMOJI_BY_UNICODE = new HashMap<>();
    private static final Map<String, Emoji> EMOJI_BY_ALIAS = new HashMap<>();
    private static final List<Emoji> ALL_EMOJIS = new ArrayList<>();
    private static EmojiTrie EMOJI_TRIE;
    private static boolean initialized = false;

    static void initialize(Map<String, Emoji> emojiByUnicode, Map<String, Emoji> emojiByAlias, List<Emoji> allEmojis) {
        if (initialized) {
            return;
        }

        EMOJI_BY_UNICODE.clear();
        EMOJI_BY_UNICODE.putAll(emojiByUnicode);

        EMOJI_BY_ALIAS.clear();
        EMOJI_BY_ALIAS.putAll(emojiByAlias);

        ALL_EMOJIS.clear();
        ALL_EMOJIS.addAll(allEmojis);

        EMOJI_TRIE = new EmojiTrie(ALL_EMOJIS);

        initialized = true;
    }

    public static Emoji getByUnicode(String unicode) {
        if (unicode == null) return null;
        return EMOJI_TRIE.getEmoji(unicode);
    }

    public static int getEmojiEndPos(char[] text, int startPos) {
        if (!initialized) {
            throw new IllegalStateException("EmojiManager has not been initialized. Call initialize() first.");
        }

        int best = -1;
        for (int j = startPos + 1; j <= text.length; j++) {
            EmojiTrie.Matches status = EMOJI_TRIE.isEmoji(text, startPos, j);
            if (status.exactMatch()) {
                best = j;
            } else if (status.impossibleMatch()) {
                return best;
            }
        }
        return best;
    }
}
package com.irc.emoji;

import java.util.Collections;
import java.util.List;

public class Emoji {
    private final String unicode;
    private final List<String> aliases;
    private final boolean supportsFitzpatrick;

    public Emoji(String unicode, List<String> aliases, boolean supportsFitzpatrick) {
        this.unicode = unicode;
        this.aliases = Collections.unmodifiableList(aliases);
        this.supportsFitzpatrick = supportsFitzpatrick;
    }

    public String getUnicode() {
        return unicode;
    }

    public List<String> getAliases() {
        return aliases;
    }

    public boolean supportsFitzpatrick() {
        return supportsFitzpatrick;
    }

    public String getUnicode(Fitzpatrick fitzpatrick) {
        if (!supportsFitzpatrick) {
            throw new UnsupportedOperationException("This emoji doesn't support Fitzpatrick modifiers");
        }
        return fitzpatrick == null ? unicode : unicode + fitzpatrick.unicode;
    }
}
package com.irc.emoji;

import java.util.ArrayList;
import java.util.List;

public class EmojiParser {
    public enum FitzpatrickAction {
        PARSE, REMOVE, IGNORE
    }

    public static String parseToAliases(String input) {
        return parseToAliases(input, FitzpatrickAction.PARSE);
    }

    public static String parseToAliases(String input, FitzpatrickAction fitzpatrickAction) {
        if (input == null || input.isEmpty()) return input;

        int prev = 0;
        StringBuilder sb = new StringBuilder(input.length());
        List<UnicodeCandidate> candidates = getUnicodeCandidates(input);

        for (UnicodeCandidate candidate : candidates) {
            sb.append(input, prev, candidate.getEmojiStartIndex());

            String replacement;
            switch (fitzpatrickAction) {
                case PARSE:
                    if (candidate.hasFitzpatrick()) {
                        replacement = ":" +
                                candidate.getEmoji().getAliases().get(0) +
                                "|" +
                                candidate.getFitzpatrickType() +
                                ":";
                    } else {
                        replacement = ":" + candidate.getEmoji().getAliases().get(0) + ":";
                    }
                    break;
                case REMOVE:
                    replacement = ":" + candidate.getEmoji().getAliases().get(0) + ":";
                    break;
                case IGNORE:
                default:
                    replacement = ":" +
                            candidate.getEmoji().getAliases().get(0) +
                            ":" +
                            candidate.getFitzpatrickUnicode();
                    break;
            }

            sb.append(replacement);
            prev = candidate.getFitzpatrickEndIndex();
        }

        return sb.append(input.substring(prev)).toString();
    }

    /**
     * Generates a list of UnicodeCandidate found in the input string.
     */
    protected static List<UnicodeCandidate> getUnicodeCandidates(String input) {
        char[] inputCharArray = input.toCharArray();
        List<UnicodeCandidate> candidates = new ArrayList<>();
        UnicodeCandidate next;

        for (int i = 0; (next = getNextUnicodeCandidate(inputCharArray, i)) != null;
             i = next.getFitzpatrickEndIndex()) {
            candidates.add(next);
        }

        return candidates;
    }

    /**
     * Finds the next UnicodeCandidate after a given starting index
     */
    protected static UnicodeCandidate getNextUnicodeCandidate(char[] chars, int start) {
        for (int i = start; i < chars.length; i++) {
            int emojiEnd = EmojiManager.getEmojiEndPos(chars, i);

            if (emojiEnd != -1) {
                Emoji emoji = EmojiManager.getByUnicode(new String(chars, i, emojiEnd - i));
                String fitzpatrickString = (emojiEnd + 2 <= chars.length) ?
                        new String(chars, emojiEnd, 2) :
                        null;
                return new UnicodeCandidate(emoji, fitzpatrickString, i);
            }
        }

        return null;
    }

    public static class UnicodeCandidate {
        private final Emoji emoji;
        private final Fitzpatrick fitzpatrick;
        private final int startIndex;

        private UnicodeCandidate(Emoji emoji, String fitzpatrick, int startIndex) {
            this.emoji = emoji;
            this.fitzpatrick = Fitzpatrick.fromUnicode(fitzpatrick);
            this.startIndex = startIndex;
        }

        public Emoji getEmoji() {
            return emoji;
        }

        public boolean hasFitzpatrick() {
            return getFitzpatrick() != null;
        }

        public Fitzpatrick getFitzpatrick() {
            return fitzpatrick;
        }

        public String getFitzpatrickType() {
            return hasFitzpatrick() ? fitzpatrick.name().toLowerCase() : "";
        }

        public String getFitzpatrickUnicode() {
            return hasFitzpatrick() ? fitzpatrick.unicode : "";
        }

        public int getEmojiStartIndex() {
            return startIndex;
        }

        public int getEmojiEndIndex() {
            return startIndex + emoji.getUnicode().length();
        }

        public int getFitzpatrickEndIndex() {
            return getEmojiEndIndex() + (fitzpatrick != null ? 2 : 0);
        }
    }
}
package com.irc.emoji;

public enum Fitzpatrick {
    TYPE_1_2("\uD83C\uDFFB"),
    TYPE_3("\uD83C\uDFFC"),
    TYPE_4("\uD83C\uDFFD"),
    TYPE_5("\uD83C\uDFFE"),
    TYPE_6("\uD83C\uDFFF");

    public final String unicode;

    Fitzpatrick(String unicode) {
        this.unicode = unicode;
    }

    public static Fitzpatrick fromUnicode(String unicode) {
        if (unicode == null) return null;
        for (Fitzpatrick f : values()) {
            if (f.unicode.equals(unicode)) {
                return f;
            }
        }
        return null;
    }
}
package com.irc.emoji;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

public class EmojiTrie {
    private final Node root = new Node();
    final int maxDepth;

    public EmojiTrie(Collection<Emoji> emojis) {
        int maxDepth = 0;
        for (Emoji emoji : emojis) {
            Node tree = root;
            char[] chars = emoji.getUnicode().toCharArray();
            maxDepth = Math.max(maxDepth, chars.length);
            for (char c : chars) {
                if (!tree.hasChild(c)) {
                    tree.addChild(c);
                }
                tree = tree.getChild(c);
            }
            tree.setEmoji(emoji);
        }
        this.maxDepth = maxDepth;
    }

    /**
     * Checks if sequence of chars contain an emoji.
     */
    public Matches isEmoji(char[] sequence) {
        return isEmoji(sequence, 0, sequence.length);
    }

    /**
     * Checks if the sequence of chars within the given bound indices contain an emoji.
     */
    public Matches isEmoji(char[] sequence, int start, int end) {
        if (start < 0 || start > end || end > sequence.length) {
            throw new ArrayIndexOutOfBoundsException(
                    "start " + start + ", end " + end + ", length " + sequence.length);
        }
        if (sequence == null) {
            return Matches.POSSIBLY;
        }
        Node tree = root;
        for (int i = start; i < end; i++) {
            if (!tree.hasChild(sequence[i])) {
                return Matches.IMPOSSIBLE;
            }
            tree = tree.getChild(sequence[i]);
        }
        return tree.isEndOfEmoji() ? Matches.EXACTLY : Matches.POSSIBLY;
    }

    /**
     * Finds Emoji instance from emoji unicode
     */
    public Emoji getEmoji(String unicode) {
        return getEmoji(unicode.toCharArray(), 0, unicode.length());
    }

    /**
     * Finds Emoji instance from emoji unicode chars.
     */
    public Emoji getEmoji(char[] sequence, int start, int end) {
        if (start < 0 || start > end || end > sequence.length) {
            throw new ArrayIndexOutOfBoundsException(
                    "start " + start + ", end " + end + ", length " + sequence.length);
        }
        Node tree = root;
        for (int i = start; i < end; i++) {
            if (!tree.hasChild(sequence[i])) {
                return null;
            }
            tree = tree.getChild(sequence[i]);
        }
        return tree.getEmoji();
    }

    public enum Matches {
        EXACTLY, POSSIBLY, IMPOSSIBLE;

        public boolean exactMatch() {
            return this == EXACTLY;
        }

        public boolean impossibleMatch() {
            return this == IMPOSSIBLE;
        }
    }

    private class Node {
        private Map<Character, Node> children = new HashMap<>();
        private Emoji emoji;

        private void setEmoji(Emoji emoji) {
            this.emoji = emoji;
        }

        private Emoji getEmoji() {
            return emoji;
        }

        private boolean hasChild(char child) {
            return children.containsKey(child);
        }

        private void addChild(char child) {
            children.put(child, new Node());
        }

        private Node getChild(char child) {
            return children.get(child);
        }

        private boolean isEndOfEmoji() {
            return emoji != null;
        }
    }
}
package com.irc.emoji;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Slf4j
@Singleton
public class EmojiService {
    private static final String EMOJI_JSON_PATH = "/emojis.json";

    private final Gson gson;

    @Inject
    public EmojiService(Gson gson) {
        this.gson = gson;
    }

    public void initialize() {
        try {
            log.debug("Initializing emoji data");
            loadEmojis();
            log.debug("Successfully initialized emoji data");
        } catch (Exception e) {
            log.error("Failed to initialize emoji data", e);
            throw new RuntimeException("Failed to initialize emoji data", e);
        }
    }

    private void loadEmojis() throws Exception {
        Map<String, Emoji> emojiByUnicode = new HashMap<>();
        Map<String, Emoji> emojiByAlias = new HashMap<>();
        List<Emoji> allEmojis = new ArrayList<>();

        try (InputStream is = EmojiManager.class.getResourceAsStream(EMOJI_JSON_PATH)) {
            if (is == null) {
                throw new RuntimeException("Could not find resource: " + EMOJI_JSON_PATH);
            }

            try (Reader reader = new InputStreamReader(is, StandardCharsets.UTF_8)) {
                JsonArray emojiArray = gson.fromJson(reader, JsonArray.class);

                if (emojiArray == null) {
                    throw new RuntimeException("Failed to parse emoji JSON or file is empty");
                }

                for (int i = 0; i < emojiArray.size(); i++) {
                    JsonObject emojiJson = emojiArray.get(i).getAsJsonObject();
                    if (!emojiJson.has("emoji")) continue;

                    String unicode = emojiJson.get("emoji").getAsString();
                    boolean supportsFitzpatrick = emojiJson.has("supports_fitzpatrick") ?
                            emojiJson.get("supports_fitzpatrick").getAsBoolean() : false;

                    List<String> aliases = new ArrayList<>();
                    if (emojiJson.has("aliases")) {
                        JsonArray aliasesJson = emojiJson.getAsJsonArray("aliases");
                        for (int j = 0; j < aliasesJson.size(); j++) {
                            aliases.add(aliasesJson.get(j).getAsString());
                        }
                    }

                    Emoji emoji = new Emoji(unicode, aliases, supportsFitzpatrick);
                    emojiByUnicode.put(unicode, emoji);
                    allEmojis.add(emoji);

                    for (String alias : aliases) {
                        emojiByAlias.put(alias, emoji);
                    }
                }
            }
        }

        EmojiManager.initialize(emojiByUnicode, emojiByAlias, allEmojis);
    }
}
package com.irc;

import com.google.inject.Provides;
import com.irc.emoji.EmojiParser;
import com.irc.emoji.EmojiService;
import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarClientID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.Text;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import java.awt.Window;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.time.Instant;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@PluginDescriptor(
        name = "Global Chat (IRC)",
        description = "Integrates IRC with the OSRS chatbox"
)
@Slf4j
public class IrcPlugin extends Plugin {
    @Inject
    private IrcConfig config;
    @Inject
    private Client client;
    @Inject
    private ChatMessageManager chatMessageManager;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private ClientToolbar clientToolbar;
    @Inject
    private KeyManager keyManager;
    @Inject
    private IrcOverlay overlay;
    @Nullable
    private IrcAdapter ircAdapter;
    private IrcPanel panel;
    private String currentNick;
    @Inject
    private EmojiService emojiService;

    private static final Pattern VALID_WINKS = Pattern.compile("^;([opdOPD)(<>]|[-_];)");
    private static final Pattern STRIP_STYLES = Pattern.compile("\u0002|\u0003(\\d\\d?(,\\d\\d)?)?|\u001D|\u0015|\u000F");

    private final Map<String, String> channelPasswords = new HashMap<>();

    @Override
    protected void startUp() {
        setupPanel();
        if (config.sidePanel()) {
            clientToolbar.addNavigation(panel.getNavigationButton());
        }

        SwingUtilities.invokeLater(() -> {
            Window window = SwingUtilities.getWindowAncestor(panel);
            if (window != null) {
                window.addWindowFocusListener(new WindowAdapter() {
                    @Override
                    public void windowLostFocus(WindowEvent e) {
                        if (panel != null) {
                            panel.hideAllPreviews();
                        }
                    }
                });
                window.addWindowListener(new WindowAdapter() {
                    @Override
                    public void windowDeactivated(WindowEvent e) {
                        if (panel != null) {
                            panel.hideAllPreviews();
                        }
                    }

                    @Override
                    public void windowIconified(WindowEvent e) {
                        if (panel != null) {
                            panel.hideAllPreviews();
                        }
                    }
                });
                window.addComponentListener(new ComponentAdapter() {
                    @Override
                    public void componentMoved(ComponentEvent e) {
                        if (panel != null) {
                            panel.hideAllPreviews();
                        }
                    }
                });
                window.addMouseListener(new MouseAdapter() {
                    @Override
                    public void mouseExited(MouseEvent e) {
                        if (panel != null) {
                            if (!window.getBounds().contains(e.getLocationOnScreen())) {
                                panel.hideAllPreviews();
                            }
                        }
                    }
                });
                window.addMouseWheelListener(e -> {
                    if (panel != null) {
                        panel.hideAllPreviews();
                    }
                });
            }
        });
        overlay = new IrcOverlay(client, panel, config, keyManager);
        overlayManager.add(overlay);
        emojiService.initialize();
        connectToIrc();
        joinDefaultChannel();
    }

    @Override
    protected void shutDown() {
        if (panel != null) {
            clientToolbar.removeNavigation(panel.getNavigationButton());
            panel = null;
        }
        if (ircAdapter != null) {
            ircAdapter.disconnect("Plugin shutting down");
            ircAdapter = null;
        }
        if (overlayManager != null) {
            overlay.shutdown();
            overlayManager.remove(overlay);
            overlay = null;
        }
        channelPasswords.clear();
    }

    @Provides
    IrcConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(IrcConfig.class);
    }

    private void connectToIrc() {
        if (Strings.isNullOrEmpty(config.username())) {
            currentNick = "RLGuest" + (int) (Math.random() * 9999 + 1);
        } else {
            currentNick = config.username().replace(" ", "_");
        }

        ircAdapter = new IrcAdapter();
        ircAdapter.initialize(config, this::processMessage, panel, currentNick);
        ircAdapter.connect();
    }

    private void setupPanel() {
        panel = injector.getInstance(IrcPanel.class);
        panel.init(
                this::handleMessageSend,
                this::handleChannelJoin,
                this::handleChannelLeave,
                this::handleReconnect
        );
        panel.initializeGui();
    }

    private void joinDefaultChannel() {
        String channel;
        if (config.channel().isEmpty()) {
            channel = "#rshelp";
        } else {
            channel = config.channel().toLowerCase();
            if (!channel.startsWith("#")) {
                channel = "#" + channel;
            }
        }
        joinChannel(channel, config.channelPassword());
    }

    private void handleMessageSend(String channel, String message) {
        if (message.startsWith("/") ||
                (message.startsWith(config.prefix())
                        && message.length() > config.prefix().length())) {
            handleCommand(message);
        } else {
            sendMessage(channel, message);
        }
    }

    private void handleCommand(String command) {
        if (ircAdapter == null || panel == null) return;

        String[] parts = command.split(" ", 2);
        String cmd = parts[0].toLowerCase().substring(1);
        String arg = parts.length > 1 ? parts[1].trim() : "";

        switch (cmd) {
            case "join":
                if (!arg.isEmpty()) {
                    String chan = arg.split(" ")[0];
                    String password = arg.split(" ").length > 1 ? arg.split(" ")[1] : "";
                    joinChannel(chan.startsWith("#") ? chan : "#" + chan, password);
                }
                break;

            case "c":
            case "close":
            case "leave":
            case "part":
                closePane(arg);
                break;

            case "quit":
                if (arg.isEmpty()) {
                    ircAdapter.disconnect("Quitting the plugin");
                } else {
                    ircAdapter.disconnect(arg);
                }
                break;

            case "go":
                if (!arg.isEmpty()) {
                    for (String channel : panel.getChannelPanes().keySet()) {
                        if (channel.contains(arg)) {
                            panel.setFocusedChannel(channel);
                            break;
                        }
                    }
                }
                break;

            case "msg":
            case "query":
                String[] msgParts = arg.split(" ", 2);
                if (msgParts.length == 2) {
                    String target = msgParts[0];
                    String msg = msgParts[1];

                    SwingUtilities.invokeLater(() -> panel.addChannel(target));
                    sendMessage(target, msg);
                }
                if (panel != null && msgParts.length > 0) {
                    panel.addChannel(msgParts[0]);
                }
                break;

            case "me":
                if (!arg.isEmpty()) {
                    sendAction(panel.getCurrentChannel(), arg);
                }
                break;

            case "notice":
                String[] noticeParts = arg.split(" ", 2);
                if (noticeParts.length == 2) {
                    String target = noticeParts[0];
                    String noticeMsg = noticeParts[1];
                    ircAdapter.sendNotice(target, noticeMsg);
                }
                break;

            case "whois":
                if (!arg.isEmpty()) {
                    ircAdapter.sendRawLine("WHOIS " + arg);
                }
                break;

            case "away":
                if (arg.isEmpty()) {
                    ircAdapter.sendRawLine("AWAY");
                } else {
                    ircAdapter.sendRawLine("AWAY :" + arg);
                }
                break;

            case "names":
                if (panel.getCurrentChannel().startsWith("#")) {
                    ircAdapter.sendRawLine("NAMES " + panel.getCurrentChannel());
                }
                break;

            case "nick":
                if (!arg.isEmpty() && arg.split(" ").length == 1) {
                    ircAdapter.setNick(arg);
                }
                break;

            case "id":
                if (!arg.isEmpty()) {
                    ircAdapter.getClient().sendMessage("NickServ", "identify " + arg);
                }
                break;

            case "ns":
                if (!arg.isEmpty()) {
                    sendMessage("NickServ", arg);
                }
                break;

            case "cs":
                if (!arg.isEmpty()) {
                    sendMessage("ChanServ", arg);
                }
                break;

            case "bs":
                if (!arg.isEmpty()) {
                    sendMessage("BotServ", arg);
                }
                break;

            case "ms":
                if (!arg.isEmpty()) {
                    sendMessage("MemoServ", arg);
                }
                break;

            case "hs":
                if (!arg.isEmpty()) {
                    sendMessage("HostServ", arg);
                }
                break;

            case "mode":
                if (!arg.isEmpty()) {
                    mode(arg);
                } else {
                    mode("");
                }
                break;

            case "umode":
            case "umode2":
                if (!arg.isEmpty()) {
                    ircAdapter.sendRawLine("MODE " + currentNick + " :" + arg);
                } else {
                    ircAdapter.sendRawLine("MODE " + currentNick);
                }
                break;

            case "topic":
                if (!arg.isEmpty()) {
                    ircAdapter.sendRawLine("TOPIC " + panel.getCurrentChannel() + " :" + arg);
                } else {
                    ircAdapter.sendRawLine("TOPIC " + panel.getCurrentChannel());
                }
                break;

            case "clear":
                panel.clearCurrentPane();
                break;

            case "help":
                showCommandHelp();
                break;

            default:
                processMessage(new IrcMessage(
                        "System",
                        "System",
                        "Unknown command: " + cmd,
                        IrcMessage.MessageType.SYSTEM,
                        Instant.now()
                ));
                break;
        }
    }

    private void mode(String mode) {
        if (ircAdapter == null || panel == null) return;

        String[] split = mode.split(" ");

        if (mode.startsWith("#")) {
            ircAdapter.sendRawLine("MODE " + mode);
        } else if (split.length > 0) {
            ircAdapter.sendRawLine("MODE " + panel.getCurrentChannel() + " " + mode);
        } else {
            ircAdapter.sendRawLine("MODE " + panel.getCurrentChannel());
        }
    }

    private void showCommandHelp() {
        String[] helpLines = {
                "Available commands:",
                "/away [message] - Set or remove away status",
                "/go <channel> - Focus on this channel (uses regex)",
                "/join <#channel> - Join a channel",
                "/part [#channel] - Leave a channel (aliased as /leave)",
                "/me <action> - Send action message",
                "/mode [#channel] [+modes|-modes] - Modify channel modes",
                "/msg <nick> <message> - Send private message",
                "/notice <nick> <message> - Send notice",
                "/topic [#channel] [topic] - View or set the channel topic",
                "/umode [+modes|-modes] - Modify user modes",
                "/whois <nick> - Query user information",
                "/bs <message> - Talk to BotServ",
                "/cs <message> - Talk to ChanServ",
                "/hs <message> - Talk to HostServ",
                "/ms <message> - Talk to MemoServ",
                "/ns <message> - Talk to NickServ",
                "/id <password - Log in to NickServ without logging it"
        };

        for (String line : helpLines) {
            processMessage(new IrcMessage(
                    "System",
                    "System",
                    line,
                    IrcMessage.MessageType.SYSTEM,
                    Instant.now()
            ));
        }
    }

    private void joinChannel(String channels, String password) {
        for (String channel : channels.split(",")) {
            if (ircAdapter == null) return;
            if (password != null && !password.isEmpty()) {
                channelPasswords.put(channel.toLowerCase(), password);
            }
            ircAdapter.joinChannel(channel, password);
        }
    }

    private void closePane(String argument) {
        if (panel == null) return;

        String currentChannel = panel.getCurrentChannel();
        if ("System".equalsIgnoreCase(currentChannel) && (argument.isEmpty() || !argument.split(" ", 2)[0].startsWith("#"))) {
            return;
        }

        String[] parts = argument.split(" ", 2);

        String target = parts[0];
        String reason = parts.length > 1 ? parts[1] : null;

        if (argument.isEmpty()) {
            if (currentChannel.startsWith("#")) {
                leaveChannel(currentChannel);
            } else {
                SwingUtilities.invokeLater(() -> panel.removeChannel(currentChannel));
            }
        } else if (target.startsWith("#")) {
            if (reason != null) {
                leaveChannel(target, reason);
            } else {
                leaveChannel(target);
            }
        } else if (panel.isPane(target)) {
            SwingUtilities.invokeLater(() -> panel.removeChannel(target));
        } else {
            if (currentChannel.startsWith("#")) {
                leaveChannel(currentChannel, argument);
            }
        }
    }

    private void leaveChannel(String channel) {
        if (ircAdapter == null) return;

        if (channel.startsWith("#")) {
            ircAdapter.leaveChannel(channel);
            channelPasswords.remove(channel.toLowerCase());
            panel.removeChannel(channel);
        }

        if (panel != null) {
            SwingUtilities.invokeLater(() -> panel.removeChannel(channel));
        }
    }

    private void leaveChannel(String channel, String reason) {
        if (ircAdapter == null) return;

        if (channel.startsWith("#")) {
            ircAdapter.leaveChannel(channel, reason);
            channelPasswords.remove(channel.toLowerCase());
            panel.removeChannel(channel);
        }

        if (panel != null) {
            SwingUtilities.invokeLater(() -> panel.removeChannel(channel));
        }
    }

    private void handleChannelJoin(String channel, String password) {
        joinChannel(channel, password);
    }

    private void handleChannelLeave(String channel) {
        leaveChannel(channel);
    }

    private void handleReconnect(Boolean ignored) {
        if (ircAdapter == null || panel == null) return;
        ircAdapter.disconnect("Reloading, brb");
        connectToIrc();
        for (String channel : panel.getChannelNames()) {
            if (channel.startsWith("#")) {
                String password = channelPasswords.getOrDefault(channel.toLowerCase(), "");
                handleChannelJoin(channel, password);
            }
        }
    }

    private void sendMessage(String target, String message) {
        if (ircAdapter == null) return;
        ircAdapter.sendMessage(target, message);
    }

    private void sendAction(String target, String message) {
        if (ircAdapter == null) return;
        ircAdapter.sendAction(target, message);
    }

    private String stripStyles(String message) {
        return STRIP_STYLES.matcher(message).replaceAll("");
    }

    private void processMessage(IrcMessage message) {
        IrcMessage.MessageType[] chatBoxEvents = {IrcMessage.MessageType.QUIT, IrcMessage.MessageType.NICK_CHANGE};

        if (panel != null) {
            if (!panel.getChannelNames().contains(message.getChannel())) {
                for (String channel : panel.getChannelNames()) {
                    if (channel.equalsIgnoreCase(message.getChannel())) {
                        panel.renameChannel(channel, message.getChannel());
                    }
                }
            }
        }

        if (client.getGameState() == GameState.LOGGED_IN) {
            boolean activeChannelCondition = panel == null || panel.getCurrentChannel().equals(message.getChannel());
            boolean isSystemEvent = message.getChannel().equals("System") && Arrays.binarySearch(chatBoxEvents, message.getType()) > -1;

            if (!config.activeChannelOnly() || (config.activeChannelOnly() && (activeChannelCondition || isSystemEvent))) {
                chatMessageManager.queue(QueuedMessage.builder()
                        .type(config.getChatboxType().getType())
                        .sender(message.getChannel())
                        .name(message.getSender())
                        .runeLiteFormattedMessage(
                                new ChatMessageBuilder()
                                        .append(ChatColorType.NORMAL)
                                        .append(EmojiParser.parseToAliases(
                                                stripStyles(message.getContent())
                                        ))
                                        .build())
                        .timestamp((int) (message.getTimestamp().getEpochSecond()))
                        .build());
            }
        }

        if (panel != null) {
            SwingUtilities.invokeLater(() -> panel.addMessage(message));
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged) {
        if (!configChanged.getGroup().equals("irc")) {
            return;
        }

        if ("sidePanel".equals(configChanged.getKey())) {
            if (panel != null) {
                clientToolbar.removeNavigation(panel.getNavigationButton());
                if (config.sidePanel()) {
                    clientToolbar.addNavigation(panel.getNavigationButton());
                }
            }
        } else if ("panelPriority".equals(configChanged.getKey())) {
            if (panel != null) {
                clientToolbar.removeNavigation(panel.getNavigationButton());
                if (config.sidePanel()) {
                    clientToolbar.addNavigation(panel.generateNavigationButton());
                }
            }
        } else if ("overlayEnabled".equals(configChanged.getKey())) {
            if (overlay != null) {
                overlay.setEnabled(config.overlayEnabled());
            }
        } else if ("overlayDynamic".equals(configChanged.getKey())) {
            if (overlay != null) {
                overlayManager.remove(overlay);
                overlay = new IrcOverlay(client, panel, config, keyManager);
                overlayManager.add(overlay);
            }
        }
    }

    @Subscribe
    public void onScriptCallbackEvent(ScriptCallbackEvent event) {
        if (!"chatDefaultReturn".equals(event.getEventName()) || ircAdapter == null) {
            return;
        }

        String message = client.getVarcStrValue(VarClientID.CHATINPUT);
        Matcher matcher = VALID_WINKS.matcher(message);

        if (message.startsWith(config.prefix()) && !matcher.matches()) {
            final int[] intStack = client.getIntStack();
            int intStackCount = client.getIntStackSize();
            intStack[intStackCount - 3] = 1;

            String currentChannel = panel != null ? panel.getCurrentChannel() : this.config.channel();
            handleMessageSend(currentChannel, message.substring(1));
        }
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded entry) {
        // Only target chat message widgets
        if (entry.getType() != MenuAction.CC_OP.getId() && entry.getType() != MenuAction.CC_OP_LOW_PRIORITY.getId()) {
            return;
        }

        final int groupId = WidgetUtil.componentToInterface(entry.getActionParam1());
        final int childId = WidgetUtil.componentToId(entry.getActionParam1());

        // Make sure we're in the chatbox
        if (groupId != InterfaceID.CHATBOX) {
            return;
        }

        if (!entry.getOption().equals("Report")) {
            return;
        }

        final Widget widget = client.getWidget(groupId, childId);
        if (widget == null) {
            return;
        }

        final Widget parent = widget.getParent();
        if (parent == null || InterfaceID.Chatbox.SCROLLAREA != parent.getId()) {
            return;
        }

        // Get child id of first chat message static child so we can subtract this offset to link to dynamic child
        final int first = WidgetUtil.componentToId(InterfaceID.Chatbox.LINE0);

        // Convert current message static widget id to dynamic widget id of message node with message contents
        final int dynamicChildId = (childId - first) * 4 + 1;

        // Extract message contents from the specific widget being right-clicked
        final Widget messageContents = parent.getChild(dynamicChildId);
        if (messageContents == null) {
            return;
        }

        String currentMessage = messageContents.getText();
        if (currentMessage == null) {
            return;
        }

        // Remove formatting tags and check for URLs in this specific message
        String cleanMessage = Text.removeTags(currentMessage);
        List<String> urls = extractUrls(cleanMessage);

        if (!urls.isEmpty()) {
            // Add menu entries for each URL found in this specific message
            for (int i = 0; i < urls.size(); i++) {
                final String url = urls.get(i);

                client.createMenuEntry(1)
                        .setOption("Open URL: " + url.substring(0, Math.min(25, url.length())) + (url.length() > 25 ? "..." : ""))
                        .setTarget(entry.getTarget())
                        .setType(MenuAction.RUNELITE)
                        .onClick(e -> LinkBrowser.browse(url));
            }
        }
    }

    private List<String> extractUrls(String message) {
        List<String> urls = new ArrayList<>();
        Matcher matcher = IrcPanel.VALID_LINK.matcher(message);

        while (matcher.find()) {
            String url = matcher.group().trim();
            // Ensure URLs have proper protocol
            if (!url.startsWith("http://") && !url.startsWith("https://")) {
                if (url.startsWith("www.")) {
                    url = "https://" + url;
                } else {
                    url = "https://" + url;
                }
            }
            urls.add(url);
        }

        return urls;
    }
}
package com.irc;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import java.awt.*;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Consumer;

/**
 * Adapter class to bridge between SimpleIrcClient
 */
@Slf4j
public class IrcAdapter {
    @Getter
    private SimpleIrcClient client;
    private String currentNick;
    private final Map<String, Set<String>> channelUsers = new HashMap<>();
    private Consumer<IrcMessage> messageConsumer;
    private IrcConfig config;
    private IrcPanel panel;

    public IrcAdapter() {
        client = new SimpleIrcClient();
    }

    /**
     * Initialize the client with the provided config
     */
    public void initialize(IrcConfig config, Consumer<IrcMessage> messageConsumer, IrcPanel panel, String currentNick) {
        this.messageConsumer = messageConsumer;
        this.currentNick = currentNick;
        this.config = config;
        this.panel = panel;

        client = new SimpleIrcClient()
                .server(config.server().getHostname(), 6697, true)
                .credentials(currentNick, "runelite", currentNick);

        if (config.password() != null && !config.password().isEmpty()) {
            client.password(config.password());
        }

        setupEventHandlers();
    }

    /**
     * Connect to the IRC server
     */
    public void connect() {
        client.connect();
    }

    /**
     * Disconnect from the IRC server
     */
    public void disconnect(String reason) {
        client.disconnect(reason);
    }
    public void disconnect() {
        client.disconnect();
    }

    /**
     * Join a channel
     */
    public void joinChannel(String channel, String password) {
        client.executeWhenRegistered(() -> client.joinChannel(channel, password));
    }

    /**
     * Leave a channel
     */
    public void leaveChannel(String channel) {
        client.leaveChannel(channel);
    }

    /**
     * Leave a channel with a reason
     */
    public void leaveChannel(String channel, String reason) {
        client.leaveChannel(channel, reason);
    }

    /**
     * Send a message to a target (channel or user)
     */
    public void sendMessage(String target, String message) {
        client.sendMessage(target, message);
        processMessage(new IrcMessage(
                target,
                currentNick,
                message,
                IrcMessage.MessageType.PRIVATE,
                Instant.now()
        ));
    }

    /**
     * Send an action (/me) to a target
     */
    public void sendAction(String target, String action) {
        client.sendAction(target, action);
        processMessage(new IrcMessage(
                target,
                "* " + currentNick,
                action,
                IrcMessage.MessageType.PRIVATE,
                Instant.now()
        ));
    }

    /**
     * Send a notice to a target
     */
    public void sendNotice(String target, String message) {
        client.sendNotice(target, message);
        processMessage(new IrcMessage(
                "System",
                currentNick,
                "Notice to " + target + ": " + message,
                IrcMessage.MessageType.SYSTEM,
                Instant.now()
        ));
    }

    /**
     * Change nickname
     */
    public void setNick(String nick) {
        client.setNick(nick);
    }

    /**
     * Send a raw IRC command
     */
    public void sendRawLine(String command) {
        client.sendRawLine(command);
    }

    /**
     * Get the current nickname
     */
    public String getNick() {
        return currentNick;
    }

    /**
     * Process and forward incoming messages to the plugin
     */
    private void processMessage(IrcMessage message) {
        if (messageConsumer != null) {
            messageConsumer.accept(message);
        }
    }

    /**
     * Set up event handlers for the SimpleIrcClient
     */
    private void setupEventHandlers() {
        client.addEventListener(event -> {
            String target = event.getTarget();
            String source = event.getSource();

            switch (event.getType()) {
                case CONNECT:
                    processMessage(new IrcMessage("System", "System", "Connected to IRC server, registering...", IrcMessage.MessageType.SYSTEM, Instant.now()));
                    break;

                case REGISTERED:
                    processMessage(new IrcMessage("System", "System", "Registration complete - ready for commands", IrcMessage.MessageType.SYSTEM, Instant.now()));
                    processMessage(new IrcMessage("System", "System", "Welcome to IRC! To chat in the current channel, use '" + config.prefix() + "' followed by your message in the game chatbox.", IrcMessage.MessageType.SYSTEM, Instant.now()));
                    processMessage(new IrcMessage("System", "System", "For a list of commands, type '/help' in the side panel input box.", IrcMessage.MessageType.SYSTEM, Instant.now()));
                    if (config.password() != null && !config.password().isEmpty()) {
                        client.sendMessage("NickServ", "id " + config.password());
                    }
                    break;

                case DISCONNECT:
                    processMessage(new IrcMessage("System", "System", "Disconnected from IRC", IrcMessage.MessageType.SYSTEM, Instant.now()));
                    for (String channel : client.getChannels()) {
                        processMessage(new IrcMessage(channel, "System", "Disconnected from IRC", IrcMessage.MessageType.SYSTEM, Instant.now()));
                    }
                    break;

                case MESSAGE:
                    if (Objects.equals(target, source)) {
                        switch (config.filterPMs()) {
                            case Current:
                                source = "[PM] " + source;
                                target = panel != null ? panel.getCurrentChannel() : "System";
                                break;
                            case Status:
                                source = "[PM] " + source;
                                target = "System";
                                break;
                            case Private:
                                target = event.getSource();
                                break;
                        }
                    }
                    processMessage(new IrcMessage(target, source, event.getMessage(), IrcMessage.MessageType.CHAT, Instant.now()));
                    break;

                case ACTION:
                    processMessage(new IrcMessage(event.getTarget(), "* " + event.getSource(), event.getMessage(), IrcMessage.MessageType.CHAT, Instant.now()));
                    break;

                case JOIN:
                    if (!config.hideConnectionMessages()) {
                        processMessage(new IrcMessage(
                                event.getTarget(),
                                "*",
                                event.getSource() + " has joined.",
                                IrcMessage.MessageType.JOIN,
                                Instant.now()
                        ));
                    }
                    break;

                case PART:
                    if (!config.hideConnectionMessages()) {
                        processMessage(new IrcMessage(event.getTarget(), event.getSource() + " parted", (event.getMessage() != null ? event.getMessage() : " "), IrcMessage.MessageType.PART, Instant.now()));
                    }
                    break;

                case QUIT:
                    if (!config.hideConnectionMessages() && event.getAdditionalData() != null && !event.getAdditionalData().isEmpty()) {
                        String[] channels = event.getAdditionalData().split(",");
                        for (String channel : channels) {
                            processMessage(new IrcMessage(channel, event.getSource() + " quit", event.getMessage() != null ? event.getMessage() : " ", IrcMessage.MessageType.QUIT, Instant.now()));
                        }
                    }
                    break;

                case NICK_CHANGE:
                    String oldNick = event.getSource();
                    String newNick = event.getMessage();

                    if (oldNick.equals(currentNick)) {
                        currentNick = newNick;
                    }

                    if (panel != null && panel.isPane(oldNick)) {
                        SwingUtilities.invokeLater(() -> panel.renameChannel(oldNick, newNick));
                    }

                    if (event.getAdditionalData() != null) {
                        String[] channels = event.getAdditionalData().split(",");
                        for (String channel : channels) {
                            if (channel != null && !channel.isEmpty()) {
                                processMessage(new IrcMessage(channel, oldNick + " is now known as", newNick, IrcMessage.MessageType.NICK_CHANGE, Instant.now()));
                            }
                        }
                    }
                    break;

                case KICK:
                    if (!config.hideConnectionMessages()) {
                        String[] kickParts = event.getMessage().split(" ", 2);
                        String kickedUser = kickParts[0];
                        String kickReason = kickParts.length > 1 ? kickParts[1] : "";
                        processMessage(new IrcMessage(event.getTarget(), event.getSource() + " kicked " + kickedUser, kickReason, IrcMessage.MessageType.KICK, Instant.now()));
                    }
                    break;

                case SERVER_NOTICE:
                case NOTICE:
                    if (source != null && source.endsWith(".SwiftIRC.net")) {
                        if (!config.filterServerNotices()) {
                            target = "System";
                        } else {
                            target = source;
                        }
                    } else {
                        source = "[N] " + source;
                        switch (config.filterNotices()) {
                            case Current:
                                target = panel != null ? panel.getCurrentChannel() : "System";
                                break;
                            case Status:
                                target = "System";
                                break;
                            case Private:
                                target = source;
                                break;
                        }
                    }
                    processMessage(new IrcMessage(target, source, event.getMessage(), IrcMessage.MessageType.NOTICE, Instant.now()));
                    break;

                case CHANNEL_MODE:
                    processMessage(new IrcMessage(event.getTarget(), event.getSource(), event.getMessage(), IrcMessage.MessageType.MODE, Instant.now()));
                    break;

                case USER_MODE:
                    processMessage(new IrcMessage("System", currentNick, event.getMessage(), IrcMessage.MessageType.MODE, Instant.now()));
                    break;

                case TOPIC:
                    processMessage(new IrcMessage(event.getTarget(), "* Topic", event.getMessage(), IrcMessage.MessageType.TOPIC, Instant.now()));
                    break;

                case NAMES:
                    processMessage(new IrcMessage(event.getTarget(), "Users", event.getMessage(), IrcMessage.MessageType.JOIN, Instant.now()));
                    break;

                case NICK_IN_USE:
                    currentNick += "_";
                    processMessage(new IrcMessage("System", "System", "Nickname is already in use. Trying: " + currentNick, IrcMessage.MessageType.SYSTEM, Instant.now()));
                    sendRawLine("NICK " + currentNick);
                    break;

                case BAD_CHANNEL_KEY:
                    String badChannel = event.getTarget();
                    processMessage(new IrcMessage("System", "System", "Cannot join " + badChannel + ": " + event.getMessage(), IrcMessage.MessageType.SYSTEM, Instant.now()));
                    SwingUtilities.invokeLater(() -> {
                        Component parent = panel != null ? panel : null;
                        String password = JOptionPane.showInputDialog(parent, "Enter password for " + badChannel + ":", "Channel Key Required", JOptionPane.QUESTION_MESSAGE);
                        if (password != null && !password.isEmpty()) {
                            joinChannel(badChannel, password);
                        }
                    });
                    break;

                case WHOIS_REPLY:
                    processMessage(new IrcMessage("System", "WHOIS", event.getMessage(), IrcMessage.MessageType.SYSTEM, Instant.now()));
                    break;

                case ERROR:
                    processMessage(new IrcMessage("System", "Error", event.getMessage() != null ? event.getMessage() : "Unknown error", IrcMessage.MessageType.SYSTEM, Instant.now()));
                    disconnect();
                    break;

                case TOPIC_INFO:
                    processMessage(new IrcMessage(event.getTarget(), event.getSource(), event.getMessage(), IrcMessage.MessageType.TOPIC, Instant.now()));
                    break;
            }
        });
    }
}
package com.irc;

import com.google.inject.Provides;
import com.irc.emoji.EmojiParser;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.ui.ClientUI;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.Timer;
import javax.swing.event.HyperlinkEvent;
import javax.swing.plaf.basic.BasicTabbedPaneUI;
import java.awt.*;
import java.awt.event.*;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.apache.commons.text.StringEscapeUtils.escapeHtml4;

@Slf4j
public class IrcPanel extends PluginPanel {
    @Inject
    private IrcConfig config;
    @Inject
    private ConfigManager configManager;
    @Inject
    private ClientUI clientUI;
    @Inject
    private OkHttpClient okHttpClient;

    private JTabbedPane tabbedPane;
    public JTextField inputField;
    @Getter
    private Map<String, ChannelPane> channelPanes;
    @Getter
    private NavigationButton navigationButton;

    private BiConsumer<String, String> onMessageSend;
    private BiConsumer<String, String> onChannelJoin;
    private Consumer<String> onChannelLeave;
    private Consumer<Boolean> onReconnect;
    private Font font;

    public final Map<String, Boolean> unreadMessages = new LinkedHashMap<>();
    private String focusedChannel;
    private static final String SYSTEM_TAB = "System";

    private final JComboBox<String> bufferDropdown = getBufferComboBox();
    private final JTextPane displayPane = new JTextPane();

    public ArrayList<String> getChannelNames() {
        return new ArrayList<>(getChannelPanes().keySet());
    }

    public static final Pattern VALID_LINK = Pattern.compile("(https?://([\\w-]+\\.)+[\\w-]+([\\w-;:,./?%&=]*))");

    private void initializeFlashTimer() {
        // Change color for different flash
        Timer flashTimer = new Timer(500, e -> {
            String currentTab = getCurrentChannel();
            for (int i = 0; i < tabbedPane.getTabCount(); i++) {
                String tabTitle = tabbedPane.getTitleAt(i);
                if (!SYSTEM_TAB.equals(tabTitle) && unreadMessages.getOrDefault(tabTitle, false) && !tabTitle.equals(currentTab)) {
                    tabbedPane.setForegroundAt(i, new Color(135, 206, 250)); // Change color for different flash
                } else if (!SYSTEM_TAB.equals(tabTitle) && !unreadMessages.getOrDefault(tabTitle, false)) {
                    tabbedPane.setForegroundAt(i, Color.white);
                }
            }
        });
        flashTimer.start();
    }

    public void initializeGui() {
        setLayout(new BorderLayout());
        font = new Font(config.fontFamily(), Font.PLAIN, config.fontSize());
        tabbedPane = new JTabbedPane();
        tabbedPane.setPreferredSize(new Dimension(300, 400));
        tabbedPane.setUI(new BasicTabbedPaneUI() {
            @Override
            protected int calculateTabAreaHeight(int tabPlacement, int runCount, int maxTabHeight) {
                return 0;
            }
        });
        inputField = new JTextField();
        inputField.setFont(font);
        channelPanes = new LinkedHashMap<>();

        addComponentListener(new ComponentAdapter() {
            @Override
            public void componentHidden(ComponentEvent e) {
                hideAllPreviews();
            }
        });

        JPanel controlPanel = new JPanel();
        controlPanel.setLayout(new BoxLayout(controlPanel, BoxLayout.Y_AXIS));
        JPanel row1 = new JPanel(new FlowLayout(FlowLayout.LEFT));
        JPanel row2 = new JPanel(new FlowLayout(FlowLayout.RIGHT));

        JButton addButton = new JButton("+");
        JButton removeButton = new JButton("-");
        JButton reloadButton = new JButton();
        try {
            Image img = ImageUtil.loadImageResource(getClass(), "reload.png");
            reloadButton.setIcon(new ImageIcon(img));
        } catch (Exception ignored) {
            reloadButton.setText("R");
        }
        Dimension standard = new Dimension(25, 25);
        addButton.setPreferredSize(standard);
        removeButton.setPreferredSize(standard);
        reloadButton.setPreferredSize(standard);
        final JComboBox<String> fontComboBox = getFontComboBox();


        JFrame frame = new JFrame("Buffers");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(500, 300);

        displayPane.setEditable(false);

        int index = 0;
        for (Map.Entry<String, ChannelPane> channel : channelPanes.entrySet()) {
            if (index == 0) {
                displayPane.setDocument(channel.getValue().getStyledDocument()); // show first one
            }
            index++;
        }
        bufferDropdown.addActionListener(this::actionPerformed);

        frame.setLayout(new BorderLayout());
        frame.add(bufferDropdown, BorderLayout.NORTH);
        frame.add(new JScrollPane(displayPane), BorderLayout.CENTER);

        addButton.addActionListener(e -> promptAddChannel());
        removeButton.addActionListener(e -> promptRemoveChannel());
        reloadButton.addActionListener(e -> onReconnect.accept(true));
        row1.add(reloadButton);
        row1.add(addButton);
        row1.add(removeButton);
        row1.add(fontComboBox);
        row2.add(bufferDropdown);
        controlPanel.add(row1);
        controlPanel.add(row2);
        Action originalPasteAction = inputField.getActionMap().get("paste");
        Action customPasteAction = new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                originalPasteAction.actionPerformed(e);
                String text = inputField.getText();
                inputField.setText(convertModernEmojis(text));
            }
        };
        inputField.getActionMap().put("paste", customPasteAction);
        setupShortcuts();
        inputField.addActionListener(e -> {
            String message = inputField.getText();
            if (!message.isEmpty() && onMessageSend != null) {
                onMessageSend.accept(getCurrentChannel(), message);
                inputField.setText("");
            }
        });
        add(controlPanel, BorderLayout.NORTH);
        add(tabbedPane, BorderLayout.CENTER);
        add(inputField, BorderLayout.SOUTH);
        navigationButton = generateNavigationButton();
        SwingUtilities.invokeLater(() -> addChannel("System"));
        tabbedPane.addChangeListener(e -> {
            String newChannel = getCurrentChannel();
            if (newChannel != null && unreadMessages.containsKey(newChannel)) {
                unreadMessages.put(newChannel, false);
                int selectedIndex = tabbedPane.getSelectedIndex();
                if (selectedIndex != -1) {
                    tabbedPane.setForegroundAt(selectedIndex, Color.WHITE);
                }
            }
        });
        initializeFlashTimer();
    }

    public void cycleChannel() {
        List<String> channels = this.getChannelNames();
        if (channels.isEmpty()) return;

        String current = this.getCurrentChannel();
        int index = channels.indexOf(current);
        index = (index + 1) % channels.size();
        this.setFocusedChannel(channels.get(index));
    }

    public void cycleChannelBackwards() {
        List<String> channels = this.getChannelNames();
        if (channels.isEmpty()) return;

        String current = this.getCurrentChannel();
        int index = channels.indexOf(current);
        index = (index - 1 < 0 ? channels.size() - 1 : (index - 1) % channels.size());
        this.setFocusedChannel(channels.get(index));
    }

    private JComboBox<String> getFontComboBox() {
        final JComboBox<String> fontComboBox = getStringFontComboBox();
        fontComboBox.setRenderer(new DefaultListCellRenderer() {
            @Override
            public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
                JLabel label = (JLabel) super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
                Font font = new Font(value.toString(), Font.PLAIN, config.fontSize());
                label.setFont(font);
                return label;
            }
        });

        bufferDropdown.setBackground(Color.DARK_GRAY);
        bufferDropdown.setForeground(Color.WHITE);

        return fontComboBox;
    }

    private JComboBox<String> getBufferComboBox() {
        final JComboBox<String> bufferComboBox = getStringJComboBox();

        bufferComboBox.addMouseWheelListener(e -> {
            if (e.getScrollType() == MouseWheelEvent.WHEEL_UNIT_SCROLL) {
                int direction = e.getWheelRotation(); // +1 down, -1 up
                int index = bufferComboBox.getSelectedIndex();

                if (direction > 0 && index < bufferComboBox.getItemCount() - 1) {
                    this.cycleChannel();
                } else if (direction < 0 && index > 0) {
                    this.cycleChannelBackwards();
                }
            }
        });

        return bufferComboBox;
    }

    private JComboBox<String> getStringJComboBox() {
        final JComboBox<String> bufferComboBox = new JComboBox<>();

        bufferComboBox.setRenderer(new DefaultListCellRenderer() {
            @Override
            public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
                JLabel label = (JLabel) super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);

                if (unreadMessages.getOrDefault(value.toString(), false)) {
                    label.setForeground(new Color(135, 206, 250)); // Change color for different flash
                } else {
                    label.setForeground(Color.white);
                }

                return label;
            }
        });
        return bufferComboBox;
    }

    public void hideAllPreviews() {
        if (channelPanes != null) {
            for (ChannelPane pane : channelPanes.values()) {
                pane.cancelPreviewManager();
            }
        }
    }

    public NavigationButton generateNavigationButton() {
        navigationButton = NavigationButton.builder()
                .tooltip("IRC")
                .icon(ImageUtil.loadImageResource(getClass(), "icon.png"))
                .priority(config.getPanelPriority())
                .panel(this)
                .build();
        return navigationButton;
    }

    public void setFocusedChannel(String channel) {
        if (channel != null && unreadMessages.containsKey(channel)) {
            int i = 0;
            int index = 0;
            for (Map.Entry<String, ChannelPane> entry : channelPanes.entrySet()) {
                if (entry.getKey().equals(channel)) {
                    index = i;
                    break;
                }
                i++;
            }

            unreadMessages.put(channel, false);
            tabbedPane.setForegroundAt(index, Color.WHITE);
            tabbedPane.setSelectedIndex(index);
            bufferDropdown.setSelectedIndex(index);

            this.focusedChannel = channel;
        }
    }

    private JComboBox<String> getStringFontComboBox() {
        String[] fonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();
        final JComboBox<String> fontComboBox = new JComboBox<>(fonts);
        int selectedIndex = Arrays.asList(fonts).indexOf(config.fontFamily());
        if (selectedIndex < 0) {
            selectedIndex = 0;
            font = new Font(fonts[0], Font.PLAIN, config.fontSize());
        }
        fontComboBox.setSelectedIndex(selectedIndex);
        fontComboBox.setPreferredSize(new Dimension(110, 25));
        fontComboBox.addActionListener(e -> {
            if (fontComboBox.getSelectedItem() != null) {
                String selected = fontComboBox.getSelectedItem().toString();
                configManager.setConfiguration("irc", "fontFamily", selected);
                updateFont();
            }
        });
        return fontComboBox;
    }

    private void updateFont() {
        font = new Font(config.fontFamily(), Font.PLAIN, config.fontSize());
        inputField.setFont(font);
        for (ChannelPane channelPane : channelPanes.values()) {
            channelPane.setFont(font);
        }
    }

    @Provides
    IrcConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(IrcConfig.class);
    }

    public void init(BiConsumer<String, String> messageSendCallback, BiConsumer<String, String> channelJoinCallback, Consumer<String> channelLeaveCallback, Consumer<Boolean> onReconnect) {
        this.onMessageSend = messageSendCallback;
        this.onChannelJoin = channelJoinCallback;
        this.onChannelLeave = channelLeaveCallback;
        this.onReconnect = onReconnect;
    }

    public String getCurrentChannel() {
        int index = tabbedPane.getSelectedIndex();
        return index != -1 ? tabbedPane.getTitleAt(index) : "System";
    }

    public void clearCurrentPane() {
        int index = tabbedPane.getSelectedIndex();
        String channel = index != -1 ? tabbedPane.getTitleAt(index) : "System";
        ChannelPane pane = channelPanes.get(channel);
        if (pane != null) {
            pane.clear();
        }
    }

    public boolean isPane(String name) {
        return tabbedPane.indexOfTab(name) != -1;
    }

    public void addChannel(String channel) {
        if (channelPanes.containsKey(channel)) return;
        ChannelPane pane = new ChannelPane(font, config, okHttpClient);
        bufferDropdown.addItem(channel);

        JScrollPane scrollPane = new JScrollPane(pane);
        scrollPane.getVerticalScrollBar().addAdjustmentListener(e -> pane.cancelPreviewManager());

        channelPanes.put(channel, pane);
        unreadMessages.put(channel, false);
        tabbedPane.addTab(channel, new JScrollPane(pane));
        if (config.autofocusOnNewTab() || channel.equals(config.channel()) || channelPanes.size() == 2) {
            tabbedPane.setSelectedIndex(tabbedPane.getTabCount() - 1);
            this.setFocusedChannel(channel);
        }
    }

    public void removeChannel(String channel) {
        if (!channelPanes.containsKey(channel) || channel.equals("System")) return;
        int index = tabbedPane.indexOfTab(channel);
        if (index == -1) return;
        tabbedPane.removeTabAt(index);
        channelPanes.remove(channel);
        unreadMessages.remove(channel);
        bufferDropdown.removeItem(channel);
    }

    public void addMessage(IrcMessage message) {
        ChannelPane pane = channelPanes.get(message.getChannel());
        if (pane == null) {
            addChannel(message.getChannel());
            pane = channelPanes.get(message.getChannel());
        }
        if (!message.getChannel().equals(focusedChannel)) {
            unreadMessages.put(message.getChannel(), true);
        }
        pane.appendMessage(message, config);
    }

    private void promptAddChannel() {
        String channel = JOptionPane.showInputDialog(this, "Enter channel name:");
        if (channel == null || channel.trim().isEmpty()) return;
        String password = JOptionPane.showInputDialog(this, "Enter channel password (optional):");
        if (!channel.startsWith("#")) {
            channel = "#" + channel;
        }
        if (onChannelJoin != null) {
            onChannelJoin.accept(channel, password);
        }
    }

    public void renameChannel(String oldName, String newName) {
        if (!channelPanes.containsKey(oldName) || channelPanes.containsKey(newName)) {
            return;
        }
        int index = tabbedPane.indexOfTab(oldName);
        if (index == -1) {
            return;
        }
        ChannelPane pane = channelPanes.remove(oldName);
        Boolean unread = unreadMessages.remove(oldName);
        channelPanes.put(newName, pane);
        unreadMessages.put(newName, unread != null && unread);
        tabbedPane.setTitleAt(index, newName);
        if (oldName.equals(focusedChannel)) {
            focusedChannel = newName;
        }
    }

    private void promptRemoveChannel() {
        String channel = getCurrentChannel();
        if (!channel.equals("System")) {
            int result = JOptionPane.showConfirmDialog(this, "Close " + channel + "?", "Confirm", JOptionPane.YES_NO_OPTION);
            if (result == JOptionPane.YES_OPTION && onChannelLeave != null) {
                onChannelLeave.accept(channel);
            }
        }
    }

    private void actionPerformed(ActionEvent e) {
        int idx = bufferDropdown.getSelectedIndex();
        int i = 0;
        for (Map.Entry<String, ChannelPane> channel : channelPanes.entrySet()) {
            if (i == idx) {
                displayPane.setDocument(channel.getValue().getStyledDocument());
                this.setFocusedChannel(channel.getKey());
                break;
            }

            i++;
        }
        hideAllPreviews();
    }


    public static class ChannelPane extends JTextPane {
        private final IrcConfig config;
        private ArrayList<String> messageLog;
        private static final Pattern UNDERLINE = Pattern.compile("\u001F([^\u001F\u000F]+)[\u001F\u000F]?");
        private static final Pattern ITALIC = Pattern.compile("\u001D([^\u001D\u000F]+)[\u001D\u000F]?");
        private static final Pattern BOLD = Pattern.compile("\u0002([^\u0002\u000F]+)[\u0002\u000F]?");
        private static final Pattern COLORS = Pattern.compile("(?:\u0003\\d\\d?(?:,\\d\\d?)?\\s*)?\u000F?\u0003(\\d\\d?)(?:,\\d\\d?)?([^\u0003\u000F]+)\u000F?");
        private static final Pattern STRIP_CODES = Pattern.compile("\u0002|\u0003(\\d\\d?(?:,\\d\\d)?)?|\u001D|\u0015|\u000F");
        private final PreviewManager previewManager;

        ChannelPane(Font font, IrcConfig config, OkHttpClient okHttpClient) {
            this.config = config;
            this.previewManager = new PreviewManager(this, okHttpClient);
            setContentType("text/html");
            setFont(font);
            setEditable(false);
            messageLog = new ArrayList<>();

            addHyperlinkListener(e -> {
                if (e.getURL() != null) {
                    String url = e.getURL().toString();
                    if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
                        try {
                            LinkBrowser.browse(e.getURL().toURI().toString());
                        } catch (Exception ignored) {
                        }
                    } else if (e.getEventType() == HyperlinkEvent.EventType.ENTERED) {
                        if (this.config.hoverPreviewImages() && previewManager.isImageUrl(url)) {
                            MouseEvent mouseEvent = (e.getInputEvent() instanceof MouseEvent)
                                    ? (MouseEvent) e.getInputEvent()
                                    : null;

                            if (mouseEvent != null) {
                                previewManager.requestShow(mouseEvent.getPoint(), url);
                            }
                        }
                    } else if (e.getEventType() == HyperlinkEvent.EventType.EXITED) {
                        previewManager.cancelPreview();
                    }
                }
            });
        }

        void appendMessage(IrcMessage message, IrcConfig config) {
            String formattedMessage = formatPanelMessage(message, config);
            messageLog.add(formattedMessage);
            if (messageLog.size() > config.getMaxScrollback()) {
                messageLog.remove(0);
            }
            SwingUtilities.invokeLater(() -> {
                setText("<html><body style='color:" + ColorUtil.toHexColor(ColorScheme.TEXT_COLOR) + ";'>" + String.join("", messageLog) + "</body></html>");
                setCaretPosition(getDocument().getLength());
            });
        }

        private String formatPanelMessage(IrcMessage message, IrcConfig config) {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss").withZone(ZoneId.systemDefault());
            String timeStamp = "";
            if (config.timestamp()) {
                timeStamp = "[" + formatter.format(message.getTimestamp()) + "] ";
            }
            String color;
            switch (message.getType()) {
                case SYSTEM:
                case NICK_CHANGE:
                case KICK:
                case MODE:
                    color = ColorUtil.toHexColor(ColorScheme.BRAND_ORANGE);
                    break;
                case JOIN:
                    color = ColorUtil.toHexColor(ColorScheme.PROGRESS_INPROGRESS_COLOR);
                    break;
                case PART:
                case QUIT:
                    color = ColorUtil.toHexColor(ColorScheme.PROGRESS_ERROR_COLOR);
                    break;
                case TOPIC:
                    color = ColorUtil.toHexColor(ColorScheme.TEXT_COLOR);
                    break;
                default:
                    color = ColorUtil.toHexColor(ColorScheme.LIGHT_GRAY_COLOR);
            }
            String sender = escapeHtml4(message.getSender());
            if (config.colorizedNicks()) {
                String[] viableColorIds = new String[]{"02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13"};
                String colorId = viableColorIds[Math.abs(sender.hashCode()) % viableColorIds.length];
                String senderColor = htmlColorById(colorId);
                sender = String.format("<font style=\"color:%s\">%s</font>", senderColor, sender);
            }
            return String.format("<div style='color: %s'>%s%s: %s</div>", color, timeStamp, sender, formatMessage(message.getContent()));
        }

        private String formatMessage(String message) {
            String msg = formatColorCodes(escapeHtml4(message));
            Matcher matcher = VALID_LINK.matcher(msg);
            return convertModernEmojis(matcher.replaceAll("<a href=\"$1\">$1</a>"));
        }

        private String formatColorCodes(String message) {
            Matcher underline_matcher = UNDERLINE.matcher(message);
            message = underline_matcher.replaceAll("<u>$1</u>");
            Matcher italic_matcher = ITALIC.matcher(message);
            message = italic_matcher.replaceAll("<i>$1</i>");
            Matcher bold_matcher = BOLD.matcher(message);
            message = bold_matcher.replaceAll("<b>$1</b>");
            Matcher color_matcher = COLORS.matcher(message);
            StringBuffer sb = new StringBuffer();
            while (color_matcher.find()) {
                color_matcher.appendReplacement(sb, "<font color=\"" + htmlColorById(color_matcher.group(1)) + "\">" + Matcher.quoteReplacement(color_matcher.group(2)) + "</font>");
            }
            color_matcher.appendTail(sb);
            return STRIP_CODES.matcher(sb.toString()).replaceAll("");
        }

        private String htmlColorById(String id) {
            switch (id) {
                case "00":
                case "0":
                    return "white";
                case "01":
                case "1":
                    return "black";
                case "02":
                case "2":
                    return "#000080";
                case "03":
                case "3":
                    return "#008000";
                case "04":
                case "4":
                    return "#FF0000";
                case "05":
                case "5":
                    return "#800000";
                case "06":
                case "6":
                    return "#800080";
                case "07":
                case "7":
                    return "#FFA500";
                case "08":
                case "8":
                    return "#FFFF00";
                case "09":
                case "9":
                    return "#00FF00";
                case "10":
                    return "#008080";
                case "11":
                    return "#00FFFF";
                case "12":
                    return "#0000FF";
                case "13":
                    return "#FF00FF";
                case "14":
                    return "#808080";
                case "15":
                    return "#C0C0C0";
                default:
                    return "black";
            }
        }

        public void clear() {
            this.setText("");
            messageLog = new ArrayList<>();
        }

        public void cancelPreviewManager() {
            this.previewManager.cancelPreviewManager();
        }
    }

    private static final Pattern MODERN_EMOJI_PATTERN = Pattern.compile("[" + "\uD83E\uDD70-\uD83E\uDDFF" +
            "\uD83E\uDE00-\uD83E\uDEFF" +
            "\uD83E\uDF00-\uD83E\uDFFF" +
            "\uD83E\uDD00-\uD83E\uDD6F" +
            "\uD83E\uDEC0-\uD83E\uDECF" + "\uD83E\uDED0-\uD83E\uDEFF" +
            "\uD83E\uDF00-\uD83E\uDF2F" +
            "\uD83E\uDF30-\uD83E\uDF5F" +
            "\uD83E\uDF60-\uD83E\uDF8F" +
            "\uFE0F" +
            "]" + "|\uD83C[\uDFFB-\uDFFF]" +
            "|\uD83E[\uDDB0-\uDDBF]"
    );

    public static String convertModernEmojis(String text) {
        if (text == null) return "";
        Matcher matcher = MODERN_EMOJI_PATTERN.matcher(text);
        if (!matcher.find()) {
            return text;
        }
        matcher.reset();
        StringBuffer sb = new StringBuffer();
        while (matcher.find()) {
            String modernEmoji = matcher.group();
            String replacement = EmojiParser.parseToAliases(modernEmoji, EmojiParser.FitzpatrickAction.PARSE);
            matcher.appendReplacement(sb, Matcher.quoteReplacement(replacement));
        }
        matcher.appendTail(sb);
        return sb.toString();
    }

    private enum IrcShortcut {
        COLOR(KeyStroke.getKeyStroke(KeyEvent.VK_K, Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()), "\u0003", "insertColorCode"),
        BOLD(KeyStroke.getKeyStroke(KeyEvent.VK_B, Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()), "\u0002", "insertBold"),
        ITALIC(KeyStroke.getKeyStroke(KeyEvent.VK_I, Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()), "\u001D", "insertItalic"),
        UNDERLINE(KeyStroke.getKeyStroke(KeyEvent.VK_U, Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()), "\u001F", "insertUnderline");

        private final KeyStroke keyStroke;
        private final String insertText;
        private final String actionKey;

        IrcShortcut(KeyStroke keyStroke, String insertText, String actionKey) {
            this.keyStroke = keyStroke;
            this.insertText = insertText;
            this.actionKey = actionKey;
        }
    }

    private class TextInsertAction extends AbstractAction {
        private final String textToInsert;

        TextInsertAction(String textToInsert) {
            this.textToInsert = textToInsert;
        }

        @Override
        public void actionPerformed(ActionEvent e) {
            String currentText = inputField.getText();
            int caretPosition = inputField.getCaretPosition();
            String newText;
            int newCaretPosition;
            if (inputField.getSelectedText() != null) {
                int selStart = inputField.getSelectionStart();
                int selEnd = inputField.getSelectionEnd();
                String selectedText = inputField.getSelectedText();
                newText = currentText.substring(0, selStart) + textToInsert + selectedText + textToInsert + currentText.substring(selEnd);
                newCaretPosition = selEnd + (textToInsert.length() * 2);
            } else {
                newText = currentText.substring(0, caretPosition) + textToInsert + currentText.substring(caretPosition);
                newCaretPosition = caretPosition + textToInsert.length();
            }
            inputField.setText(newText);
            inputField.setCaretPosition(newCaretPosition);
        }
    }

    private void setupShortcuts() {
        InputMap inputMap = inputField.getInputMap(JComponent.WHEN_FOCUSED);
        ActionMap actionMap = inputField.getActionMap();
        for (IrcShortcut shortcut : IrcShortcut.values()) {
            inputMap.put(shortcut.keyStroke, shortcut.actionKey);
            actionMap.put(shortcut.actionKey, new TextInsertAction(shortcut.insertText));
        }
    }
}
package com.irc;

import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarClientID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.KeyListener;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Inject;
import java.awt.*;
import java.awt.event.KeyEvent;

@Slf4j
public class IrcOverlay extends Overlay implements KeyListener {
    private final Client client;
    private final IrcPanel panel;

    final int tabHeight = 12;
    final int tabSpacing = 2; // space between tabs
    final int padding = 8;

    @Setter
    private boolean enabled;
    private final IrcConfig config;
    private final KeyManager keyManager;

    @Inject
    public IrcOverlay(Client client, IrcPanel panel, IrcConfig config, KeyManager keyManager) {
        this.client = client;
        this.panel = panel;
        this.config = config;
        this.enabled = config.overlayEnabled();
        this.keyManager = keyManager;

        updatePosition();

        keyManager.registerKeyListener(this);
    }

    public void shutdown() {
        keyManager.unregisterKeyListener(this);
    }

    private boolean isHidden(int component) {
        Widget w = client.getWidget(component);
        return w == null || w.isSelfHidden();
    }

    boolean isDialogOpen() {
        // Most chat dialogs with numerical input are added without the chatbox or its key listener being removed,
        // so chatboxFocused() is true. The chatbox onkey script uses the following logic to ignore key presses,
        // so we will use it too to not remap F-keys.
        return isHidden(InterfaceID.Chatbox.MES_LAYER_HIDE) || isHidden(InterfaceID.Chatbox.CHATDISPLAY)
                // We want to block F-key remapping in the bank pin interface too, so it does not interfere with the
                // Keyboard Bankpin feature of the Bank plugin
                || !isHidden(InterfaceID.BankpinKeypad.UNIVERSE);
    }

    boolean isOptionsDialogOpen() {
        return client.getWidget(InterfaceID.Chatmenu.OPTIONS) != null;
    }

    private static final int CHATBOX_GROUP = 162;
    private static final int CHATBOX_MESSAGES_CHILD = 0;
    private static final int CHATAREA = InterfaceID.Chatbox.CHATAREA;

    public void updatePosition() {
        if (config.overlayDynamic()) {
            setPosition(OverlayPosition.DYNAMIC);
        } else {
            setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
        }

        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!enabled || panel == null || isDialogOpen() || isOptionsDialogOpen())
            return null;

        Widget chatboxMessages = client.getWidget(CHATBOX_GROUP, CHATBOX_MESSAGES_CHILD);
        Widget chatarea = client.getWidget(CHATAREA);
        if (chatboxMessages == null || chatboxMessages.isHidden() || chatarea == null || chatarea.isHidden())
            return null;

        net.runelite.api.Point loc = chatboxMessages.getCanvasLocation();
        int x = loc.getX() + padding;
        int y = loc.getY() + padding;
        int scrollbarWidth = 16;
        int width = chatboxMessages.getWidth() - scrollbarWidth - padding * 2; // additional padding
        if (width > config.overlayMaxWidth()) {
            width = config.overlayMaxWidth();
        }
        int height = tabHeight;

        // background
        graphics.setColor(ColorScheme.DARKER_GRAY_COLOR);
        if (!config.overlayDynamic()) {
            x = 0;
            y = 0;
        }

        graphics.fillRect(x, y, width, height);

        // tabs
        java.util.List<String> channels = panel.getChannelNames();
        int activeTabIndex = Math.max(0, channels.indexOf(panel.getCurrentChannel()));

        int xOffset = 0;
        int yOffset = 0;
        for (int i = 0; i < channels.size(); i++) {
            boolean isActive = i == activeTabIndex;
            String channel = channels.get(i);
            boolean isUnread = panel.unreadMessages.get(channel);

            FontMetrics fm = graphics.getFontMetrics();
            int tabWidth = fm.stringWidth(channel) + padding * 2 - tabSpacing; // 8px padding each side

            // stop drawing if tab exceeds width
            if (xOffset + tabWidth > width) {
                yOffset += height;
                xOffset = 0;
            }

            // tab background
            graphics.setColor(isActive ? ColorScheme.BRAND_ORANGE : ColorScheme.DARKER_GRAY_COLOR.darker());
            graphics.fillRect(x + xOffset, y + yOffset, tabWidth, height);

            // channel name
            graphics.setColor(isActive ? Color.WHITE : isUnread ? ColorScheme.BRAND_ORANGE.brighter() : ColorScheme.BRAND_ORANGE.darker());
            graphics.drawString(channel, x + xOffset + padding, y + yOffset + height);

            xOffset += tabWidth + tabSpacing;
        }

        return new Dimension(width, height);
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (panel == null || panel.getChannelPanes() == null) return;

        if (e.getKeyCode() == KeyEvent.VK_PAGE_UP && this.config.pageUpDownNavigation()) {
            panel.cycleChannelBackwards();
            e.consume();
        } else if (e.getKeyCode() == KeyEvent.VK_PAGE_DOWN && this.config.pageUpDownNavigation()) {
            panel.cycleChannel();
            e.consume();
        } else if (this.config.backTickNavigation()) {
            if (e.getKeyCode() == KeyEvent.VK_BACK_QUOTE && (e.getModifiersEx() & KeyEvent.SHIFT_DOWN_MASK) != 0) {
                panel.cycleChannelBackwards();
                e.consume();
            } else if (e.getKeyCode() == KeyEvent.VK_BACK_QUOTE) {
                panel.cycleChannel();
                e.consume();
            }
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {
        // Unnecessary
    }

    @Override
    public void keyReleased(KeyEvent e) {
        // Unnecessary
    }

    @Override
    public boolean isEnabledOnLoginScreen()
    {
        return true;
    }

}

package com.irc;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class SimpleIrcClient {
    private static final Pattern MESSAGE_PATTERN =
            Pattern.compile("^(?:[:@](\\S+) )?(\\S+)(?: ((?:[^:\\s]\\S* ?)*))?(?: ?:(.*))?$");
    private static final Pattern USER_PREFIXES = Pattern.compile("^[~&@%+].+");
    private static final Pattern NUMERIC = Pattern.compile("^[0-9]+$");

    private Socket socket;
    private BufferedWriter writer;
    private BufferedReader reader;
    private final ExecutorService executor = Executors.newFixedThreadPool(2);
    private final List<IrcEventListener> listeners = new CopyOnWriteArrayList<>();

    @Getter
    private String nick;
    private String username;
    private String realName;
    private String password;
    @Getter
    private final Set<String> channels = new HashSet<>();
    private final Map<String, Set<String>> channelUsers = new HashMap<>();

    private String host;
    private int port;
    private boolean secure;
    private boolean connected = false;
    private volatile boolean shuttingDown = false;

    public SimpleIrcClient server(String host, int port, boolean secure) {
        this.host = host;
        this.port = port;
        this.secure = secure;
        return this;
    }

    public SimpleIrcClient credentials(String nick, String username, String realName) {
        this.nick = nick;
        this.username = username;
        this.realName = realName;
        return this;
    }

    public void password(String password) {
        this.password = password;
    }

    public void connect() {
        shuttingDown = false;
        executor.submit(() -> {
            try {
                if (secure) {
                    createSecureConnection();
                } else {
                    socket = new Socket(host, port);
                }

                writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), StandardCharsets.UTF_8));
                reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8));

                if (password != null && !password.isEmpty()) {
                    sendRawLine("PASS " + password);
                }
                sendRawLine("NICK " + nick);
                sendRawLine("USER " + username + " 0 * :" + realName);

                connected = true;
                fireEvent(new IrcEvent(IrcEvent.Type.CONNECT, null, null, null, null));

                String line;
                try {
                    while (!shuttingDown && (line = reader.readLine()) != null) {
                        processLine(line);
                    }

                    if (!shuttingDown) disconnect();
                } catch (IOException e) {
                    if (!shuttingDown) {
                        log.error("Error reading from IRC server", e);
                        fireEvent(new IrcEvent(IrcEvent.Type.ERROR, null, null, null, e.getMessage()));
                    }
                }
            } catch (Exception e) {
                if (!shuttingDown) {
                    log.error("Error in IRC connection", e);
                    fireEvent(new IrcEvent(IrcEvent.Type.ERROR, null, null, null, e.getMessage()));
                }
            } finally {
                if (!shuttingDown) {
                    disconnect();
                }
            }
        });
    }

    private void createSecureConnection() throws IOException {
        SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();
        SSLSocket sslSocket = (SSLSocket) factory.createSocket(host, port);
        sslSocket.setEnabledProtocols(sslSocket.getSupportedProtocols());
        sslSocket.startHandshake();
        sslSocket.setSoTimeout(240000);
        socket = sslSocket;
    }

    public void disconnect() {
        disconnect("");
    }

    public void disconnect(String reason) {
        if (shuttingDown || !connected) return;

        shuttingDown = true;
        try {
            if (writer != null) {
                try {
                    sendRawLine("QUIT :" + (reason.isEmpty() ? "Disconnecting" : reason));
                    writer.flush();
                    writer.close();
                } catch (IOException ignored) {
                }
            }
            if (reader != null) try {
                reader.close();
            } catch (IOException ignored) {
            }
            if (socket != null) try {
                socket.close();
            } catch (IOException ignored) {
            }
        } finally {
            connected = false;
            fireEvent(new IrcEvent(IrcEvent.Type.DISCONNECT, null, null, null, null));
        }
    }

    public void joinChannel(String channel, String password) {
        if (connected) {
            String command = "JOIN " + channel;
            if (password != null && !password.isEmpty()) {
                command += " " + password;
            }
            sendRawLine(command);
            channels.add(channel);

        }
    }

    public void leaveChannel(String channel) {
        leaveChannel(channel, null);
    }

    public void leaveChannel(String channel, String reason) {
        if (connected && channels.contains(channel)) {
            String command = "PART " + channel;
            if (reason != null && !reason.isEmpty()) {
                command += " :" + reason;
            }
            sendRawLine(command);
            channels.remove(channel);
            channelUsers.remove(channel);
        }
    }

    public void sendMessage(String target, String message) {
        if (connected) {
            sendRawLine("PRIVMSG " + target + " :" + message);
        }
    }

    public void sendAction(String target, String action) {
        if (connected) {
            sendRawLine("PRIVMSG " + target + " :\u0001ACTION " + action + "\u0001");
        }
    }

    public void sendNotice(String target, String message) {
        if (connected) {
            sendRawLine("NOTICE " + target + " :" + message);
        }
    }

    public void setNick(String newNick) {
        if (connected) {
            sendRawLine("NICK " + newNick);
        }
    }

    public synchronized void sendRawLine(String line) {
        if (writer == null) return;
        try {
            writer.write(line + "\r\n");
            writer.flush();
        } catch (IOException e) {
            log.error("Error sending IRC message", e);
        }
    }

    private void processLine(String line) {
        Matcher matcher = MESSAGE_PATTERN.matcher(line);

        if (matcher.matches()) {
            String sourceRaw = matcher.group(1);
            String command = matcher.group(2);
            String paramsRaw = matcher.group(3);
            String trailing = matcher.group(4);

            String source = sourceRaw != null ? sourceRaw : "";
            List<String> params = new ArrayList<>();

            if (paramsRaw != null) {
                for (String param : paramsRaw.split(" ")) {
                    if (!param.isEmpty()) {
                        params.add(param);
                    }
                }
            }

            if (trailing != null) {
                params.add(trailing);
            }

            if (command.equals("PING")) {
                sendRawLine("PONG " + (params.isEmpty() ? "" : params.get(0)));
                return;
            } else if (command.equals("443")) {
                fireEvent(new IrcEvent(IrcEvent.Type.NICK_IN_USE, null, null, params.get(1), null));
            }

            processCommand(source, command, params);
        }
    }

    private void processCommand(String source, String command, List<String> params) {
        String sourceNick = extractNick(source);

        switch (command.toUpperCase()) {
            case "PRIVMSG":
                if (params.size() >= 2) {
                    String target = params.get(0);
                    String message = params.get(1);

                    if (message.startsWith("\u0001") && message.endsWith("\u0001")) {
                        handleCtcp(source, target, message);
                    } else {
                        String messageChannel = target.startsWith("#") ? target : sourceNick;
                        fireEvent(new IrcEvent(IrcEvent.Type.MESSAGE, sourceNick, messageChannel, message, null));
                    }
                }
                break;

            case "JOIN":
                if (!params.isEmpty()) {
                    String channel = params.get(0);
                    fireEvent(new IrcEvent(IrcEvent.Type.JOIN, sourceNick, channel, null, null));
                    channelUsers.computeIfAbsent(channel, k -> new HashSet<>()).add(sourceNick);
                }
                break;

            case "PART":
                if (!params.isEmpty()) {
                    String channel = params.get(0);
                    String reason = params.size() > 1 ? params.get(1) : "";

                    if (!sourceNick.equals(nick)) {
                        fireEvent(new IrcEvent(IrcEvent.Type.PART, sourceNick, channel, reason, null));
                    }
                    if (channelUsers.containsKey(channel)) {
                        channelUsers.get(channel).remove(sourceNick);
                    }
                }
                break;

            case "QUIT":
                String quitMessage = params.isEmpty() ? "" : params.get(0);

                List<String> userChannels = new ArrayList<>();
                for (Map.Entry<String, Set<String>> entry : channelUsers.entrySet()) {
                    if (entry.getValue().contains(sourceNick)) {
                        userChannels.add(entry.getKey());
                    }
                }
                fireEvent(new IrcEvent(IrcEvent.Type.QUIT, sourceNick, null, quitMessage, String.join(",", userChannels)));
                for (Set<String> users : channelUsers.values()) {
                    users.remove(sourceNick);
                }
                break;

            case "NICK":
                if (!params.isEmpty()) {
                    String newNick = params.get(0);
                    if (sourceNick.equals(this.nick)) {
                        this.nick = newNick;
                    }

                    userChannels = new ArrayList<>();
                    for (Map.Entry<String, Set<String>> entry : channelUsers.entrySet()) {
                        if (entry.getValue().contains(sourceNick)) {
                            userChannels.add(entry.getKey());
                        }
                    }
                    fireEvent(new IrcEvent(IrcEvent.Type.NICK_CHANGE, sourceNick, null, newNick, String.join(",", userChannels)));
                    for (Set<String> users : channelUsers.values()) {
                        if (users.remove(sourceNick)) {
                            users.add(newNick);
                        }
                    }
                }
                break;

            case "KICK":
                if (params.size() >= 2) {
                    String channel = params.get(0);
                    String kickedUser = params.get(1);
                    String kickMessage = params.size() > 2 ? params.get(2) : "";

                    fireEvent(new IrcEvent(IrcEvent.Type.KICK, sourceNick, channel, kickedUser + " " + kickMessage, null));
                    if (channelUsers.containsKey(channel)) {
                        channelUsers.get(channel).remove(kickedUser);
                    }
                }
                break;

            case "NOTICE":
                if (params.size() >= 2) {
                    String target = params.get(0);
                    String message = params.get(1);
                    if (source.contains("!")) {
                        fireEvent(new IrcEvent(IrcEvent.Type.NOTICE, sourceNick, target, message, null));
                    } else {
                        fireEvent(new IrcEvent(IrcEvent.Type.SERVER_NOTICE, source, null, message, null));
                    }
                }
                break;

            case "MODE":
                if (params.size() >= 2) {
                    String target = params.get(0);
                    StringBuilder modeString = new StringBuilder();
                    for (int i = 1; i < params.size(); i++) {
                        modeString.append(" ").append(params.get(i));
                    }

                    if (target.startsWith("#")) {
                        fireEvent(new IrcEvent(IrcEvent.Type.CHANNEL_MODE, "* " + sourceNick + " sets mode(s)", target, modeString.toString().trim(), null));
                    } else {
                        fireEvent(new IrcEvent(IrcEvent.Type.USER_MODE, sourceNick, target, modeString.toString().trim(), null));
                    }
                }
                break;

            case "TOPIC":
                if (params.size() >= 2) {
                    String channel = params.get(0);
                    String topic = params.get(1);
                    fireEvent(new IrcEvent(IrcEvent.Type.TOPIC, sourceNick, channel, topic, null));
                }
                break;

            default:
                if (NUMERIC.matcher(command).matches()) {
                    int numeric = Integer.parseInt(command);
                    handleNumeric(numeric, source, params);
                }
                break;
        }
    }

    private void handleCtcp(String source, String target, String message) {
        String ctcp = message.substring(1, message.length() - 1);
        String[] parts = ctcp.split(" ", 2);
        String command = parts[0].toUpperCase();
        String param = parts.length > 1 ? parts[1] : "";
        String sourceNick = extractNick(source);

        switch (command) {
            case "ACTION":
                String actionChannel = target.startsWith("#") ? target : sourceNick;
                fireEvent(new IrcEvent(IrcEvent.Type.ACTION, sourceNick, actionChannel, param, null));
                break;
            case "VERSION":
                sendRawLine("NOTICE " + sourceNick + " :\u0001VERSION RuneLite IRC Plugin\u0001");
                break;
            case "PING":
                sendRawLine("NOTICE " + sourceNick + " :\u0001PING " + param + "\u0001");
                break;
        }
    }

    private void handleNumeric(int numeric, String source, List<String> params) {
        switch (numeric) {
            case 1:
                connected = true;
                fireEvent(new IrcEvent(IrcEvent.Type.REGISTERED, null, null, null, null));
                break;
            case 301:
                if (params.size() >= 3)
                    fireEvent(new IrcEvent(IrcEvent.Type.WHOIS_REPLY, "System", params.get(1), String.format("%s is away: %s", params.get(1), params.get(2)), null));
                break;
            case 311:
                if (params.size() >= 5)
                    fireEvent(new IrcEvent(IrcEvent.Type.WHOIS_REPLY, "System", params.get(1), String.format("%s is %s@%s (%s)", params.get(1), params.get(2), params.get(3), params.get(5)), null));
                break;
            case 312:
                if (params.size() >= 4)
                    fireEvent(new IrcEvent(IrcEvent.Type.WHOIS_REPLY, "System", params.get(1), String.format("%s is connected to %s (%s)", params.get(1), params.get(2), params.get(3)), null));
                break;
            case 313:
                if (params.size() >= 2)
                    fireEvent(new IrcEvent(IrcEvent.Type.WHOIS_REPLY, "System", params.get(1), params.get(1) + " is an IRC operator", null));
                break;
            case 317:
                if (params.size() >= 3)
                    fireEvent(new IrcEvent(IrcEvent.Type.WHOIS_REPLY, "System", params.get(1), String.format("%s has been idle for %s seconds", params.get(1), params.get(2)), null));
                break;
            case 318:
                if (params.size() >= 2)
                    fireEvent(new IrcEvent(IrcEvent.Type.WHOIS_REPLY, "System", params.get(1), "End of WHOIS for " + params.get(1), null));
                break;
            case 319:
                if (params.size() >= 3)
                    fireEvent(new IrcEvent(IrcEvent.Type.WHOIS_REPLY, "System", params.get(1), String.format("%s is on channels: %s", params.get(1), params.get(2)), null));
                break;
            case 324:
                if (params.size() >= 2) {
                    String target = params.get(1);
                    StringBuilder message = new StringBuilder();
                    for (int i = 2; i < params.size(); i++) message.append(" ").append(params.get(i));
                    fireEvent(new IrcEvent(IrcEvent.Type.CHANNEL_MODE, "* Modes", target, message.toString().trim(), null));
                }
                break;
            case 332:
                if (params.size() >= 3)
                    fireEvent(new IrcEvent(IrcEvent.Type.TOPIC, "System", params.get(1), params.get(2), null));
                break;
            case 333:
                if (params.size() >= 4)
                    fireEvent(new IrcEvent(IrcEvent.Type.TOPIC_INFO, "* Topic set by", params.get(1), params.get(2), null));
                break;
            case 353:
                if (params.size() >= 4) {
                    String channel = params.get(2);
                    String[] users = params.get(3).split(" ");
                    Set<String> channelUserSet = channelUsers.computeIfAbsent(channel, k -> new HashSet<>());
                    for (String user : users) {
                        if (!user.isEmpty())
                            channelUserSet.add(USER_PREFIXES.matcher(user).matches() ? user.substring(1) : user);
                    }
                    fireEvent(new IrcEvent(IrcEvent.Type.NAMES, null, channel, String.join(" ", users), null));
                }
                break;
            case 433:
                if (params.size() >= 2)
                    fireEvent(new IrcEvent(IrcEvent.Type.NICK_IN_USE, null, null, params.get(1), null));
                break;
            case 475:
                if (params.size() >= 2)
                    fireEvent(new IrcEvent(IrcEvent.Type.BAD_CHANNEL_KEY, null, params.get(1), params.get(2), null));
                break;
        }
    }

    private String extractNick(String source) {
        if (source == null || source.isEmpty()) return "";
        int exclamation = source.indexOf('!');
        return exclamation > 0 ? source.substring(0, exclamation) : source;
    }

    public void addEventListener(IrcEventListener listener) {
        listeners.add(listener);
    }

    public void removeEventListener(IrcEventListener listener) {
        listeners.remove(listener);
    }

    private final List<Runnable> pendingCommands = new CopyOnWriteArrayList<>();

    /**
     * Queue a command to be executed once fully registered with the server
     */
    public void executeWhenRegistered(Runnable command) {
        if (connected) {
            command.run();
        } else {
            pendingCommands.add(command);
        }
    }

    private void fireEvent(IrcEvent event) {
        if (event.getType() == IrcEvent.Type.REGISTERED) {
            for (Runnable command : pendingCommands) {
                command.run();
            }
            pendingCommands.clear();
        }

        for (IrcEventListener listener : listeners) {
            listener.onEvent(event);
        }
    }

    public interface IrcEventListener {
        void onEvent(IrcEvent event);
    }

    @Getter
    public static class IrcEvent {
        public enum Type {
            CONNECT, DISCONNECT, REGISTERED, MESSAGE, ACTION, JOIN, PART, QUIT,
            NICK_CHANGE, KICK, NOTICE, SERVER_NOTICE, CHANNEL_MODE, USER_MODE,
            TOPIC, NAMES, NICK_IN_USE, ERROR, TOPIC_INFO, BAD_CHANNEL_KEY, WHOIS_REPLY
        }

        private final Type type;
        private final String source;
        private final String target;
        private final String message;
        private final String additionalData;

        public IrcEvent(Type type, String source, String target, String message, String additionalData) {
            this.type = type;
            this.source = source;
            this.target = target;
            this.message = message;
            this.additionalData = additionalData;
        }
    }
}
package com.irc;

import lombok.Value;
import java.time.Instant;

@Value
public class IrcMessage {
    String channel;
    String sender;
    String content;
    MessageType type;
    Instant timestamp;

    enum MessageType {
        CHAT, SYSTEM, JOIN, PART, QUIT, NICK_CHANGE, PRIVATE, NOTICE, KICK, TOPIC, MODE
    }
}
package com.example;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import com.irc.IrcPlugin;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(IrcPlugin.class);
		RuneLite.main(args);
	}
}
