/*
 * Copyright (c) 2020, Ryan W. O'Hara <ryan@ryanwohara.com>, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.irc;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ChatMessageType;
import net.runelite.client.config.*;


@ConfigGroup("irc")
public interface IrcConfig extends Config
{
    @ConfigSection(
            name = "Connection",
            description = "Connection settings",
            position = 0,
            closedByDefault = true
    )
    String connectionSettings = "connectionSettings";

    @ConfigItem(
            keyName = "server",
            name = "Server",
            description = "Server to use to directly connect.",
            position = 0,
            section = connectionSettings
    )
    default Server server() {
        return Server.USA;
    };

    @Getter
    @RequiredArgsConstructor
    enum Server {
        USA("Fiery (West-USA)", "fiery.ca.us.swiftirc.net"),
        UK("London (UK)", "tardis.en.uk.swiftirc.net");

        private final String name;
        private final String hostname;
    }

    @ConfigItem(
            keyName = "username",
            name = "Username",
            description = ";use the chat like this.",
            position = 1,
            section = connectionSettings
    )
    String username();

    @ConfigItem(
            keyName = "password",
            name = "Password (Optional) (not Jagex)",
            description = "NickServ password (Optional) (NEVER your RS password!)",
            position = 2,
            secret = true,
            section = connectionSettings
    )
    String password();

    @ConfigItem(
            keyName = "channel",
            name = "Channel",
            description = "Channel to join",
            position = 3,
            section = connectionSettings
    )
    default String channel()
    {
        return "#rshelp";
    }

    @ConfigItem(
            keyName = "channelPassword",
            name = "Channel Password",
            description = "Password to enter channel. (Optional)",
            position = 4,
            secret = true,
            section = connectionSettings
    )
    default String channelPassword()
    {
        return "";
    }

    @ConfigSection(
            name = "General",
            description = "General settings",
            position = 1,
            closedByDefault = false
    )
    String generalSettings = "generalSettings";

    @ConfigItem(
            keyName = "prefix",
            name = "Prefix",
            description = ";chat with this character like this.",
            position = 0,
            section = generalSettings
    )
    default String prefix() { return ";"; }

    @ConfigItem(
            keyName = "activeChannelOnly",
            name = "Active Channel Only",
            description = "Only show the active IRC channel in the OSRS chat box.",
            position = 1,
            section = generalSettings
    )
    default boolean activeChannelOnly() { return false; }

    @ConfigItem(
            keyName = "autofocusOnNewTab",
            name = "Autofocus on New Tab",
            description = "If you receive a PM/notice or join a new channel, it will become your focus. Initial channel join will always focus regardless of this setting.",
            position = 3,
            section = generalSettings
    )
    default boolean autofocusOnNewTab() { return false; }

    @ConfigItem(
            keyName = "filterServerNotices",
            name = "Server Notice Tab",
            description = "Receiving a server notice will open a new dedicated tab for it.",
            position = 4,
            section = generalSettings
    )
    default boolean filterServerNotices() { return false; }

    @Getter
    @RequiredArgsConstructor
    enum Chatbox {
        FRIENDSCHAT(ChatMessageType.FRIENDSCHAT),
        CLAN_CHAT(ChatMessageType.CLAN_CHAT);

        private final ChatMessageType type;
    }

    @ConfigItem(
            keyName = "chatboxType",
            name = "Chatbox Type",
            description = "Which type of chatbox will be used in-game.",
            position = 5,
            section = generalSettings
    )
    default Chatbox getChatboxType() { return Chatbox.FRIENDSCHAT; }

    @Getter
    @RequiredArgsConstructor
    enum MessageDisplay {
        Status("Show only in status window."),
        Current("Show only in current window."),
        Private("Show only in a private window with the sender.");

        private final String description;
    }

    @ConfigItem(
            keyName = "filterNotices",
            name = "Notice Window",
            description = "Adjust how to treat the display of notices.",
            position = 5,
            section = generalSettings
    )
    default MessageDisplay filterNotices() { return MessageDisplay.Current; }


    @ConfigItem(
            keyName = "filterPMs",
            name = "PM Window",
            description = "Adjust how to treat the display of PMs.",
            position = 6,
            section = generalSettings
    )
    default MessageDisplay filterPMs() { return MessageDisplay.Current; }

    @ConfigSection(
            name = "Side Panel",
            description = "Side panel settings",
            position = 2,
            closedByDefault = true
    )
    String sidePanelSettings = "sidePanelSettings";

    @ConfigItem(
            keyName = "sidePanel",
            name = "Enabled",
            description = "Enable the side panel",
            position = 0,
            section = sidePanelSettings
    )
    default boolean sidePanel() { return true;}

    @ConfigItem(
            keyName = "timestamp",
            name = "Timestamp",
            description = "Enable the timestamp",
            position = 1,
            section = sidePanelSettings
    )
    default boolean timestamp() { return true;}

// Commenting this out until I can improve the UX of it
//
//    @ConfigItem(
//            keyName = "hoverPreviewImages",
//            name = "Hover-Preview Image Links",
//            description = "Display an image just by hovering over the link (WARNING: could leak your IP without clicking)",
//            position = 2,
//            section = sidePanelSettings
//    )
//    default boolean hoverPreviewImages() { return false; }

    @ConfigItem(
            keyName = "colorizedNicks",
            name = "Colorized Nicks",
            description = "Add color to nicks.",
            position = 3,
            section = sidePanelSettings
    )
    default boolean colorizedNicks() { return true; }

    @Range(
            min = 0
    )
    @ConfigItem(
            keyName = "panelPriority",
            name = "Position in Sidebar",
            description = "Control where the panel appears in the sidebar of RuneLite",
            position = 4,
            section = sidePanelSettings
    )
    default int getPanelPriority() { return 10; }

    @Range(
            min = 0
    )
    @ConfigItem(
            keyName = "maxScrollback",
            name = "Maximum Scrollback per Channel",
            description = "Restrict the scrollback per channel to avoid lag",
            position = 5,
            section = sidePanelSettings
    )
    default int getMaxScrollback() { return 100; }

    @ConfigItem(
            keyName = "fontFamily",
            name = "Font Family",
            description = "Font family to use everywhere.",
            position = 6,
            hidden = true,
            section = sidePanelSettings
    )
    default String fontFamily() { return "SansSerif"; }

    @ConfigItem(
            keyName = "fontSize",
            name = "Font Size",
            description = "Font size to use everywhere.",
            position = 7,
            hidden = true,
            section = sidePanelSettings
    )
    default Integer fontSize() { return 12; }
}
package com.irc.emoji;

import java.util.*;

public class EmojiManager {
    private static final Map<String, Emoji> EMOJI_BY_UNICODE = new HashMap<>();
    private static final Map<String, Emoji> EMOJI_BY_ALIAS = new HashMap<>();
    private static final List<Emoji> ALL_EMOJIS = new ArrayList<>();
    private static EmojiTrie EMOJI_TRIE;
    private static boolean initialized = false;

    static void initialize(Map<String, Emoji> emojiByUnicode, Map<String, Emoji> emojiByAlias, List<Emoji> allEmojis) {
        if (initialized) {
            return;
        }

        EMOJI_BY_UNICODE.clear();
        EMOJI_BY_UNICODE.putAll(emojiByUnicode);

        EMOJI_BY_ALIAS.clear();
        EMOJI_BY_ALIAS.putAll(emojiByAlias);

        ALL_EMOJIS.clear();
        ALL_EMOJIS.addAll(allEmojis);

        EMOJI_TRIE = new EmojiTrie(ALL_EMOJIS);

        initialized = true;
    }

    public static Emoji getByUnicode(String unicode) {
        if (unicode == null) return null;
        return EMOJI_TRIE.getEmoji(unicode);
    }

    public static int getEmojiEndPos(char[] text, int startPos) {
        if (!initialized) {
            throw new IllegalStateException("EmojiManager has not been initialized. Call initialize() first.");
        }

        int best = -1;
        for (int j = startPos + 1; j <= text.length; j++) {
            EmojiTrie.Matches status = EMOJI_TRIE.isEmoji(text, startPos, j);
            if (status.exactMatch()) {
                best = j;
            } else if (status.impossibleMatch()) {
                return best;
            }
        }
        return best;
    }
}
package com.irc.emoji;

import java.util.Collections;
import java.util.List;

public class Emoji {
    private final String unicode;
    private final List<String> aliases;
    private final boolean supportsFitzpatrick;

    public Emoji(String unicode, List<String> aliases, boolean supportsFitzpatrick) {
        this.unicode = unicode;
        this.aliases = Collections.unmodifiableList(aliases);
        this.supportsFitzpatrick = supportsFitzpatrick;
    }

    public String getUnicode() {
        return unicode;
    }

    public List<String> getAliases() {
        return aliases;
    }

    public boolean supportsFitzpatrick() {
        return supportsFitzpatrick;
    }

    public String getUnicode(Fitzpatrick fitzpatrick) {
        if (!supportsFitzpatrick) {
            throw new UnsupportedOperationException("This emoji doesn't support Fitzpatrick modifiers");
        }
        return fitzpatrick == null ? unicode : unicode + fitzpatrick.unicode;
    }
}
package com.irc.emoji;

import java.util.ArrayList;
import java.util.List;

public class EmojiParser {
    public enum FitzpatrickAction {
        PARSE, REMOVE, IGNORE
    }

    public static String parseToAliases(String input) {
        return parseToAliases(input, FitzpatrickAction.PARSE);
    }

    public static String parseToAliases(String input, FitzpatrickAction fitzpatrickAction) {
        if (input == null || input.isEmpty()) return input;

        int prev = 0;
        StringBuilder sb = new StringBuilder(input.length());
        List<UnicodeCandidate> candidates = getUnicodeCandidates(input);

        for (UnicodeCandidate candidate : candidates) {
            sb.append(input, prev, candidate.getEmojiStartIndex());

            String replacement;
            switch (fitzpatrickAction) {
                case PARSE:
                    if (candidate.hasFitzpatrick()) {
                        replacement = ":" +
                                candidate.getEmoji().getAliases().get(0) +
                                "|" +
                                candidate.getFitzpatrickType() +
                                ":";
                    } else {
                        replacement = ":" + candidate.getEmoji().getAliases().get(0) + ":";
                    }
                    break;
                case REMOVE:
                    replacement = ":" + candidate.getEmoji().getAliases().get(0) + ":";
                    break;
                case IGNORE:
                default:
                    replacement = ":" +
                            candidate.getEmoji().getAliases().get(0) +
                            ":" +
                            candidate.getFitzpatrickUnicode();
                    break;
            }

            sb.append(replacement);
            prev = candidate.getFitzpatrickEndIndex();
        }

        return sb.append(input.substring(prev)).toString();
    }

    /**
     * Generates a list of UnicodeCandidate found in the input string.
     */
    protected static List<UnicodeCandidate> getUnicodeCandidates(String input) {
        char[] inputCharArray = input.toCharArray();
        List<UnicodeCandidate> candidates = new ArrayList<>();
        UnicodeCandidate next;

        for (int i = 0; (next = getNextUnicodeCandidate(inputCharArray, i)) != null;
             i = next.getFitzpatrickEndIndex()) {
            candidates.add(next);
        }

        return candidates;
    }

    /**
     * Finds the next UnicodeCandidate after a given starting index
     */
    protected static UnicodeCandidate getNextUnicodeCandidate(char[] chars, int start) {
        for (int i = start; i < chars.length; i++) {
            int emojiEnd = EmojiManager.getEmojiEndPos(chars, i);

            if (emojiEnd != -1) {
                Emoji emoji = EmojiManager.getByUnicode(new String(chars, i, emojiEnd - i));
                String fitzpatrickString = (emojiEnd + 2 <= chars.length) ?
                        new String(chars, emojiEnd, 2) :
                        null;
                return new UnicodeCandidate(emoji, fitzpatrickString, i);
            }
        }

        return null;
    }

    public static class UnicodeCandidate {
        private final Emoji emoji;
        private final Fitzpatrick fitzpatrick;
        private final int startIndex;

        private UnicodeCandidate(Emoji emoji, String fitzpatrick, int startIndex) {
            this.emoji = emoji;
            this.fitzpatrick = Fitzpatrick.fromUnicode(fitzpatrick);
            this.startIndex = startIndex;
        }

        public Emoji getEmoji() {
            return emoji;
        }

        public boolean hasFitzpatrick() {
            return getFitzpatrick() != null;
        }

        public Fitzpatrick getFitzpatrick() {
            return fitzpatrick;
        }

        public String getFitzpatrickType() {
            return hasFitzpatrick() ? fitzpatrick.name().toLowerCase() : "";
        }

        public String getFitzpatrickUnicode() {
            return hasFitzpatrick() ? fitzpatrick.unicode : "";
        }

        public int getEmojiStartIndex() {
            return startIndex;
        }

        public int getEmojiEndIndex() {
            return startIndex + emoji.getUnicode().length();
        }

        public int getFitzpatrickEndIndex() {
            return getEmojiEndIndex() + (fitzpatrick != null ? 2 : 0);
        }
    }
}
package com.irc.emoji;

public enum Fitzpatrick {
    TYPE_1_2("\uD83C\uDFFB"),
    TYPE_3("\uD83C\uDFFC"),
    TYPE_4("\uD83C\uDFFD"),
    TYPE_5("\uD83C\uDFFE"),
    TYPE_6("\uD83C\uDFFF");

    public final String unicode;

    Fitzpatrick(String unicode) {
        this.unicode = unicode;
    }

    public static Fitzpatrick fromUnicode(String unicode) {
        if (unicode == null) return null;
        for (Fitzpatrick f : values()) {
            if (f.unicode.equals(unicode)) {
                return f;
            }
        }
        return null;
    }
}
package com.irc.emoji;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

public class EmojiTrie {
    private final Node root = new Node();
    final int maxDepth;

    public EmojiTrie(Collection<Emoji> emojis) {
        int maxDepth = 0;
        for (Emoji emoji : emojis) {
            Node tree = root;
            char[] chars = emoji.getUnicode().toCharArray();
            maxDepth = Math.max(maxDepth, chars.length);
            for (char c : chars) {
                if (!tree.hasChild(c)) {
                    tree.addChild(c);
                }
                tree = tree.getChild(c);
            }
            tree.setEmoji(emoji);
        }
        this.maxDepth = maxDepth;
    }

    /**
     * Checks if sequence of chars contain an emoji.
     */
    public Matches isEmoji(char[] sequence) {
        return isEmoji(sequence, 0, sequence.length);
    }

    /**
     * Checks if the sequence of chars within the given bound indices contain an emoji.
     */
    public Matches isEmoji(char[] sequence, int start, int end) {
        if (start < 0 || start > end || end > sequence.length) {
            throw new ArrayIndexOutOfBoundsException(
                    "start " + start + ", end " + end + ", length " + sequence.length);
        }
        if (sequence == null) {
            return Matches.POSSIBLY;
        }
        Node tree = root;
        for (int i = start; i < end; i++) {
            if (!tree.hasChild(sequence[i])) {
                return Matches.IMPOSSIBLE;
            }
            tree = tree.getChild(sequence[i]);
        }
        return tree.isEndOfEmoji() ? Matches.EXACTLY : Matches.POSSIBLY;
    }

    /**
     * Finds Emoji instance from emoji unicode
     */
    public Emoji getEmoji(String unicode) {
        return getEmoji(unicode.toCharArray(), 0, unicode.length());
    }

    /**
     * Finds Emoji instance from emoji unicode chars.
     */
    public Emoji getEmoji(char[] sequence, int start, int end) {
        if (start < 0 || start > end || end > sequence.length) {
            throw new ArrayIndexOutOfBoundsException(
                    "start " + start + ", end " + end + ", length " + sequence.length);
        }
        Node tree = root;
        for (int i = start; i < end; i++) {
            if (!tree.hasChild(sequence[i])) {
                return null;
            }
            tree = tree.getChild(sequence[i]);
        }
        return tree.getEmoji();
    }

    public enum Matches {
        EXACTLY, POSSIBLY, IMPOSSIBLE;

        public boolean exactMatch() {
            return this == EXACTLY;
        }

        public boolean impossibleMatch() {
            return this == IMPOSSIBLE;
        }
    }

    private class Node {
        private Map<Character, Node> children = new HashMap<>();
        private Emoji emoji;

        private void setEmoji(Emoji emoji) {
            this.emoji = emoji;
        }

        private Emoji getEmoji() {
            return emoji;
        }

        private boolean hasChild(char child) {
            return children.containsKey(child);
        }

        private void addChild(char child) {
            children.put(child, new Node());
        }

        private Node getChild(char child) {
            return children.get(child);
        }

        private boolean isEndOfEmoji() {
            return emoji != null;
        }
    }
}
package com.irc.emoji;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Slf4j
@Singleton
public class EmojiService {
    private static final String EMOJI_JSON_PATH = "/emojis.json";

    private final Gson gson;

    @Inject
    public EmojiService(Gson gson) {
        this.gson = gson;
    }

    public void initialize() {
        try {
            log.debug("Initializing emoji data");
            loadEmojis();
            log.debug("Successfully initialized emoji data");
        } catch (Exception e) {
            log.error("Failed to initialize emoji data", e);
            throw new RuntimeException("Failed to initialize emoji data", e);
        }
    }

    private void loadEmojis() throws Exception {
        Map<String, Emoji> emojiByUnicode = new HashMap<>();
        Map<String, Emoji> emojiByAlias = new HashMap<>();
        List<Emoji> allEmojis = new ArrayList<>();

        try (InputStream is = EmojiManager.class.getResourceAsStream(EMOJI_JSON_PATH)) {
            if (is == null) {
                throw new RuntimeException("Could not find resource: " + EMOJI_JSON_PATH);
            }

            try (Reader reader = new InputStreamReader(is, StandardCharsets.UTF_8)) {
                JsonArray emojiArray = gson.fromJson(reader, JsonArray.class);

                if (emojiArray == null) {
                    throw new RuntimeException("Failed to parse emoji JSON or file is empty");
                }

                for (int i = 0; i < emojiArray.size(); i++) {
                    JsonObject emojiJson = emojiArray.get(i).getAsJsonObject();
                    if (!emojiJson.has("emoji")) continue;

                    String unicode = emojiJson.get("emoji").getAsString();
                    boolean supportsFitzpatrick = emojiJson.has("supports_fitzpatrick") ?
                            emojiJson.get("supports_fitzpatrick").getAsBoolean() : false;

                    List<String> aliases = new ArrayList<>();
                    if (emojiJson.has("aliases")) {
                        JsonArray aliasesJson = emojiJson.getAsJsonArray("aliases");
                        for (int j = 0; j < aliasesJson.size(); j++) {
                            aliases.add(aliasesJson.get(j).getAsString());
                        }
                    }

                    Emoji emoji = new Emoji(unicode, aliases, supportsFitzpatrick);
                    emojiByUnicode.put(unicode, emoji);
                    allEmojis.add(emoji);

                    for (String alias : aliases) {
                        emojiByAlias.put(alias, emoji);
                    }
                }
            }
        }

        EmojiManager.initialize(emojiByUnicode, emojiByAlias, allEmojis);
    }
}
package com.irc;

import com.google.inject.Provides;
import com.irc.emoji.EmojiParser;
import com.irc.emoji.EmojiService;
import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.VarClientStr;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import java.time.Instant;
import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@PluginDescriptor(
        name = "IRC",
        description = "Integrates IRC with the OSRS chatbox"
)
@Slf4j
public class IrcPlugin extends Plugin {
    @Inject
    private IrcConfig config;
    @Inject
    private net.runelite.api.Client client;
    @Inject
    private ChatMessageManager chatMessageManager;
    @Inject
    private ClientToolbar clientToolbar;

    @Nullable
    private IrcAdapter ircAdapter;
    private IrcPanel panel;
    private String currentNick;
    @Inject
    private EmojiService emojiService;

    private static final Pattern VALID_WINKS = Pattern.compile("^.[opdOPD)(]");
    private static final Pattern STRIP_STYLES = Pattern.compile("\u0002|\u0003(\\d\\d?(,\\d\\d)?)?|\u001D|\u0015|\u000F");

    @Override
    protected void startUp() {
        if (config.sidePanel()) {
            setupPanel();
        }
        emojiService.initialize();

        connectToIrc();

        // Join default channel after connection
        joinDefaultChannel();
    }

    @Override
    protected void shutDown() {
        if (panel != null) {
            if (config.sidePanel()) {
                clientToolbar.removeNavigation(panel.getNavigationButton());
            }
            panel = null;
        }
        if (ircAdapter != null) {
            ircAdapter.disconnect("Plugin shutting down");
            ircAdapter = null;
        }
    }

    @Provides
    IrcConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(IrcConfig.class);
    }

    private void connectToIrc() {
        if (Strings.isNullOrEmpty(config.username())) {
            currentNick = "RLGuest" + (int) (Math.random() * 9999 + 1);
        } else {
            currentNick = config.username().replace(" ", "_");
        }

        ircAdapter = new IrcAdapter();
        ircAdapter.initialize(config, this::processMessage, panel, currentNick);
        ircAdapter.connect();
    }

    private void setupPanel() {
        panel = injector.getInstance(IrcPanel.class);
        panel.init(
                this::handleMessageSend,
                this::handleChannelJoin,
                this::handleChannelLeave,
                this::handleReconnect
        );

        panel.initializeGui();

        if (config.sidePanel()) {
            clientToolbar.addNavigation(panel.getNavigationButton());
        }
    }

    private void joinDefaultChannel() {
        String channel;
        if (config.channel().isEmpty()) {
            channel = "#rshelp";
        } else {
            channel = config.channel().toLowerCase();
            if (!channel.startsWith("#")) {
                channel = "#" + channel;
            }
        }
        joinChannel(channel, config.channelPassword());
    }

    private void handleMessageSend(String channel, String message) {
        if (message.startsWith("/") ||
                (message.startsWith(config.prefix())
                        && message.length() > config.prefix().length())) {
            handleCommand(message);
        } else {
            sendMessage(channel, message);
        }
    }

    private void handleCommand(String command) {
        if (ircAdapter == null) return;

        String[] parts = command.split(" ", 2);
        String cmd = parts[0].toLowerCase().substring(1);
        String arg = parts.length > 1 ? parts[1].trim() : "";

        switch (cmd) {
            case "join":
                if (!arg.isEmpty()) {
                    String chan = arg.split(" ")[0];
                    String password = arg.split(" ").length > 1 ? arg.split(" ")[1] : "";
                    joinChannel(chan.startsWith("#") ? chan : "#" + chan, password);
                }
                break;

            case "c":
            case "close":
            case "leave":
            case "part":
                if (arg.isEmpty()) {
                    closePane("");
                } else {
                    closePane(arg);
                }
                break;

            case "quit":
                if (arg.isEmpty()) {
                    ircAdapter.disconnect("Quitting the plugin");
                } else {
                    ircAdapter.disconnect(arg);
                }
                break;

            case "go":
                if (!arg.isEmpty()) {
                    for (String channel : panel.getChannelPanes().keySet()) {
                        if (channel.contains(arg)) {
                            panel.setFocusedChannel(channel);
                            break;
                        }
                    }
                }
                break;

            case "msg":
            case "query":
                String[] msgParts = arg.split(" ", 2);
                if (msgParts.length == 2) {
                    String target = msgParts[0];
                    String msg = msgParts[1];

                    if (panel != null) {
                        SwingUtilities.invokeLater(() -> panel.addChannel(target));
                    }

                    sendMessage(target, msg);
                }
                if (panel != null && msgParts.length > 0) {
                    panel.addChannel(msgParts[0]);
                }
                break;

            case "me":
                if (!arg.isEmpty()) {
                    sendAction(panel.getCurrentChannel(), arg);
                }
                break;

            case "notice":
                String[] noticeParts = arg.split(" ", 2);
                if (noticeParts.length == 2) {
                    String target = noticeParts[0];
                    String noticeMsg = noticeParts[1];
                    ircAdapter.sendNotice(target, noticeMsg);
                }
                break;

            case "whois":
                if (!arg.isEmpty()) {
                    ircAdapter.sendRawLine("WHOIS " + arg);
                }
                break;

            case "away":
                if (arg.isEmpty()) {
                    ircAdapter.sendRawLine("AWAY"); // Remove away status
                } else {
                    ircAdapter.sendRawLine("AWAY :" + arg);
                }
                break;

            case "names":
                if (panel.getCurrentChannel().startsWith("#")) {
                    ircAdapter.sendRawLine("NAMES " + panel.getCurrentChannel());
                }
                break;

            case "nick":
                if (!arg.isEmpty() && arg.split(" ").length == 1) {
                    ircAdapter.setNick(arg);
                    currentNick = arg;
                }
                break;

            case "ns":
                if (!arg.isEmpty()) {
                    sendMessage("NickServ", arg);
                }
                break;

            case "cs":
                if (!arg.isEmpty()) {
                    sendMessage("ChanServ", arg);
                }
                break;

            case "bs":
                if (!arg.isEmpty()) {
                    sendMessage("BotServ", arg);
                }
                break;

            case "ms":
                if (!arg.isEmpty()) {
                    sendMessage("MemoServ", arg);
                }
                break;

            case "hs":
                if (!arg.isEmpty()) {
                    sendMessage("HostServ", arg);
                }
                break;

            case "mode":
                if (!arg.isEmpty()) {
                    mode(arg);
                } else {
                    mode("");
                }
                break;

            case "umode":
            case "umode2":
                if (!arg.isEmpty()) {
                    ircAdapter.sendRawLine("MODE " + currentNick + " :" + arg);
                } else {
                    ircAdapter.sendRawLine("MODE " + currentNick);
                }
                break;

            case "topic":
                if (!arg.isEmpty()) {
                    ircAdapter.sendRawLine("TOPIC " + panel.getCurrentChannel() + " :" + arg);
                } else {
                    ircAdapter.sendRawLine("TOPIC " + panel.getCurrentChannel());
                }
                break;

            case "clear":
                panel.clearCurrentPane();
                break;

            case "help":
                showCommandHelp();
                break;

            default:
                processMessage(new IrcMessage(
                        "System",
                        "System",
                        "Unknown command: " + cmd,
                        IrcMessage.MessageType.SYSTEM,
                        Instant.now()
                ));
                break;
        }
    }

    private void mode(String mode) {
        if (ircAdapter == null) return;

        String[] split = mode.split(" ");

        if (mode.startsWith("#")) {
            ircAdapter.sendRawLine("MODE " + mode);
        } else if (split.length > 0) {
            ircAdapter.sendRawLine("MODE " + panel.getCurrentChannel() + " " + mode);
        } else {
            ircAdapter.sendRawLine("MODE " + panel.getCurrentChannel());
        }
    }

    private void showCommandHelp() {
        String[] helpLines = {
                "Available commands:",
                "/away [message] - Set or remove away status",
                "/go <channel> - Focus on this channel (uses regex)",
                "/join <#channel> - Join a channel",
                "/leave [#channel] - Leave a channel",
                "/me <action> - Send action message",
                "/mode [#channel] [+modes|-modes] - Modify channel modes",
                "/msg <nick> <message> - Send private message",
                "/notice <nick> <message> - Send notice",
                "/topic [#channel] [topic] - View or set the channel topic",
                "/umode [+modes|-modes] - Modify user modes",
                "/whois <nick> - Query user information",
                "/bs <message> - Talk to BotServ",
                "/cs <message> - Talk to ChanServ",
                "/hs <message> - Talk to HostServ",
                "/ms <message> - Talk to MemoServ",
                "/ns <message> - Talk to NickServ"
        };

        for (String line : helpLines) {
            processMessage(new IrcMessage(
                    "System",
                    "System",
                    line,
                    IrcMessage.MessageType.SYSTEM,
                    Instant.now()
            ));
        }
    }

    private void joinChannel(String channel, String password) {
        if (ircAdapter == null) return;

        ircAdapter.joinChannel(channel, password);
    }

    private void closePane(String name) {
        if (panel == null) return;

        String[] split = name.split(" ", 2);

        if (split.length == 0 || name.isEmpty()) {
            if (panel.getCurrentChannel().startsWith("#")) {
                leaveChannel(panel.getCurrentChannel());
            } else if (!panel.getCurrentChannel().equals("System")) {
                SwingUtilities.invokeLater(() -> panel.removeChannel(panel.getCurrentChannel()));
            }
        } else if (split.length == 1) {
            if (!name.equals("System") && panel.isPane(name)) {
                SwingUtilities.invokeLater(() -> panel.removeChannel(name));
            }

            if (name.startsWith("#")) {
                leaveChannel(name);
            } else if (!panel.isPane(name) && panel.getCurrentChannel().startsWith("#")) {
                leaveChannel(panel.getCurrentChannel(), split[0]);
            }
        } else {
            if (name.startsWith("#")) {
                leaveChannel(split[0], split[1]);
                SwingUtilities.invokeLater(() -> panel.removeChannel(split[0]));
            } else if (panel.isPane(split[0])) {
                SwingUtilities.invokeLater(() -> panel.removeChannel(split[0]));
            } else if (!panel.isPane(split[0])) {
                String active = panel.getCurrentChannel();
                SwingUtilities.invokeLater(() -> panel.removeChannel(active));
                if (active.startsWith("#")) {
                    leaveChannel(active, name);
                }
            }
        }
    }

    private void leaveChannel(String channel) {
        if (ircAdapter == null) return;

        if (channel.startsWith("#")) {
            ircAdapter.leaveChannel(channel);
        }

        if (panel != null) {
            SwingUtilities.invokeLater(() -> panel.removeChannel(channel));
        }
    }

    private void leaveChannel(String channel, String reason) {
        if (ircAdapter == null) return;

        ircAdapter.leaveChannel(channel, reason);

        if (panel != null) {
            SwingUtilities.invokeLater(() -> panel.removeChannel(channel));
        }
    }

    private void handleChannelJoin(String channel, String password) {
        joinChannel(channel, password);
    }

    private void handleChannelLeave(String channel) {
        leaveChannel(channel);
    }

    private void handleReconnect(Boolean ignored) {
        if (ircAdapter == null) return;

        ircAdapter.disconnect("Reloading, brb");

        connectToIrc();

        for (String channel : panel.getChannelNames()) {
            handleChannelJoin(channel, "");
        }
    }

    private void sendMessage(String target, String message) {
        if (ircAdapter == null) return;

        ircAdapter.sendMessage(target, message);
    }

    private void sendAction(String target, String message) {
        if (ircAdapter == null) return;

        ircAdapter.sendAction(target, message);
    }

    private String stripStyles(String message) {
        return STRIP_STYLES.matcher(message).replaceAll("");
    }

    private void processMessage(IrcMessage message) {
        if (panel == null) return;

        IrcMessage.MessageType[] chatBoxEvents = {IrcMessage.MessageType.QUIT, IrcMessage.MessageType.NICK_CHANGE};

        if (!panel.getChannelNames().contains(message.getChannel())) {
            for (String channel : panel.getChannelNames()) {
                if (channel.equalsIgnoreCase(message.getChannel())) {
                    panel.renameChannel(channel, message.getChannel());
                }
            }
        }

        if (client.getGameState() == GameState.LOGGED_IN
                && ((config.activeChannelOnly()
                && (panel.getCurrentChannel().equals(message.getChannel())
                || (message.getChannel().equals("System") && Arrays.binarySearch(chatBoxEvents, message.getType()) > -1)))
                || !config.activeChannelOnly())) {
            chatMessageManager.queue(QueuedMessage.builder()
                    .type(config.getChatboxType().getType())
                    .sender(message.getChannel())
                    .name(message.getSender())
                    .runeLiteFormattedMessage(
                            new ChatMessageBuilder()
                                    .append(ChatColorType.NORMAL)
                                    .append(EmojiParser.parseToAliases(
                                            stripStyles(message.getContent())
                                    ))
                                    .build())
                    .timestamp((int) (message.getTimestamp().getEpochSecond()))
                    .build());
        }

        if (panel != null) {
            SwingUtilities.invokeLater(() -> panel.addMessage(message));
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged) {
        if (!configChanged.getGroup().equals("irc") || configChanged.getKey().equals("fontFamily") || configChanged.getKey().equals("fontSize")) {
            return;
        }

        try {
            stopIrcPanel();
        } catch (Exception ignored) {
        }

        if (config.sidePanel()) {
            clientToolbar.addNavigation(panel.generateNavigationButton());
        }
    }

    private void stopIrcPanel() {
        clientToolbar.removeNavigation(panel.getNavigationButton());
    }

    @Subscribe
    public void onScriptCallbackEvent(ScriptCallbackEvent event) {
        if (!"chatDefaultReturn".equals(event.getEventName()) || ircAdapter == null) {
            return;
        }

        String message = client.getVarcStrValue(VarClientStr.CHATBOX_TYPED_TEXT);

        Matcher matcher = VALID_WINKS.matcher(message);

        if (message.startsWith(config.prefix())
                && !matcher.matches()) {
            final int[] intStack = client.getIntStack();
            int intStackCount = client.getIntStackSize();
            intStack[intStackCount - 3] = 1;

            handleMessageSend(panel.getCurrentChannel(), message.substring(1));
        }
    }
}
package com.irc;

import lombok.extern.slf4j.Slf4j;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Consumer;

/**
 * Adapter class to bridge between SimpleIrcClient
 */
@Slf4j
public class IrcAdapter {
    private SimpleIrcClient client;
    private String currentNick;
    private final Map<String, Set<String>> channelUsers = new HashMap<>();
    private Consumer<IrcMessage> messageConsumer;
    private IrcConfig config;
    private IrcPanel panel;


    public IrcAdapter() {
        client = new SimpleIrcClient();
    }

    /**
     * Initialize the client with the provided config
     */
    public void initialize(IrcConfig config, Consumer<IrcMessage> messageConsumer, IrcPanel panel, String currentNick) {
        this.messageConsumer = messageConsumer;
        this.currentNick = currentNick;
        this.config = config;
        this.panel = panel;

        client = new SimpleIrcClient()
                .server(config.server().getHostname(), 6697, true)
                .credentials(currentNick, "runelite", currentNick);

        if (config.password() != null && !config.password().isEmpty()) {
            client.password(config.password());
        }

        setupEventHandlers();
    }

    /**
     * Connect to the IRC server
     */
    public void connect() {
        client.connect();
    }

    /**
     * Disconnect from the IRC server
     */
    public void disconnect(String reason) {
        client.disconnect(reason);
    }

    /**
     * Join a channel
     */
    public void joinChannel(String channel, String password) {
        // Use executeWhenRegistered to ensure we're properly connected to the server
        client.executeWhenRegistered(() -> client.joinChannel(channel, password));
    }

    /**
     * Leave a channel
     */
    public void leaveChannel(String channel) {
        client.leaveChannel(channel);
    }

    /**
     * Leave a channel with a reason
     */
    public void leaveChannel(String channel, String reason) {
        client.leaveChannel(channel, reason);
    }

    /**
     * Send a message to a target (channel or user)
     */
    public void sendMessage(String target, String message) {
        client.sendMessage(target, message);

        // Create a message for the local display
        processMessage(new IrcMessage(
                target,
                currentNick,
                message,
                IrcMessage.MessageType.PRIVATE,
                Instant.now()
        ));
    }

    /**
     * Send an action (/me) to a target
     */
    public void sendAction(String target, String action) {
        client.sendAction(target, action);

        // Create a message for the local display
        processMessage(new IrcMessage(
                target,
                "* " + currentNick,
                action,
                IrcMessage.MessageType.PRIVATE,
                Instant.now()
        ));
    }

    /**
     * Send a notice to a target
     */
    public void sendNotice(String target, String message) {
        client.sendNotice(target, message);

        // Create a message for the local display
        processMessage(new IrcMessage(
                "System",
                currentNick,
                "Notice to " + target + ": " + message,
                IrcMessage.MessageType.SYSTEM,
                Instant.now()
        ));
    }

    /**
     * Change nickname
     */
    public void setNick(String nick) {
        client.setNick(nick);
        this.currentNick = nick;
    }

    /**
     * Send a raw IRC command
     */
    public void sendRawLine(String command) {
        client.sendRawLine(command);
    }

    /**
     * Get the current nickname
     */
    public String getNick() {
        return currentNick;
    }

    /**
     * Process and forward incoming messages to the plugin
     */
    private void processMessage(IrcMessage message) {
        if (messageConsumer != null) {
            messageConsumer.accept(message);
        }
    }

    /**
     * Set up event handlers for the SimpleIrcClient
     */
    private void setupEventHandlers() {
        client.addEventListener(event -> {
            String target = event.getTarget();
            String source = event.getSource();

            switch (event.getType()) {
                case CONNECT:
                    processMessage(new IrcMessage(
                            "System",
                            "System",
                            "Connected to IRC server, registering...",
                            IrcMessage.MessageType.SYSTEM,
                            Instant.now()
                    ));
                    break;

                case REGISTERED:
                    processMessage(new IrcMessage(
                            "System",
                            "System",
                            "Registration complete - ready for commands",
                            IrcMessage.MessageType.SYSTEM,
                            Instant.now()
                    ));

                    if (config.password() != null && !config.password().isEmpty()) {
                        client.sendMessage("NickServ", "id " + config.password());
                    }
                    break;

                case DISCONNECT:
                    processMessage(new IrcMessage(
                            "System",
                            "System",
                            "Disconnected from IRC",
                            IrcMessage.MessageType.SYSTEM,
                            Instant.now()
                    ));

                    for (String channel : client.getChannels()) {
                        processMessage(new IrcMessage(
                                channel,
                                "System",
                                "Disconnected from IRC",
                                IrcMessage.MessageType.SYSTEM,
                                Instant.now()
                        ));
                    }
                    break;

                case MESSAGE:
                    if (Objects.equals(target, source)) {
                        switch (config.filterPMs()) {
                            case Current:
                                source = "[PM] " + source;
                                target = panel.getCurrentChannel();
                                break;
                            case Status:
                                source = "[PM] " + source;
                                target = "System";
                                break;
                            case Private:
                                target = event.getSource();
                                break;
                        }
                    }
                    processMessage(new IrcMessage(
                            target,
                            source,
                            event.getMessage(),
                            IrcMessage.MessageType.CHAT,
                            Instant.now()
                    ));
                    break;

                case ACTION:
                    processMessage(new IrcMessage(
                            event.getTarget(),
                            "* " + event.getSource(),
                            event.getMessage(),
                            IrcMessage.MessageType.CHAT,
                            Instant.now()
                    ));
                    break;

                case JOIN:
                    processMessage(new IrcMessage(
                            event.getTarget(),
                            event.getSource() + " joined",
                            " ",
                            IrcMessage.MessageType.JOIN,
                            Instant.now()
                    ));
                    break;

                case PART:
                    processMessage(new IrcMessage(
                            event.getTarget(),
                            event.getSource() + " parted",
                            (event.getMessage() != null ? event.getMessage() : " "),
                            IrcMessage.MessageType.PART,
                            Instant.now()
                    ));
                    break;

                case QUIT:
                    if (event.getAdditionalData() != null && !event.getAdditionalData().isEmpty()) {
                        String[] channels = event.getAdditionalData().split(",");
                        for (String channel : channels) {
                            processMessage(new IrcMessage(
                                    channel,
                                    event.getSource() + " quit",
                                    event.getMessage() != null ? event.getMessage() : " ",
                                    IrcMessage.MessageType.QUIT,
                                    Instant.now()
                            ));
                        }
                    }
                    break;

                case NICK_CHANGE:
                    String oldNick = event.getSource();
                    String newNick = event.getMessage();

                    if (oldNick.equals(currentNick)) {
                        currentNick = newNick;
                    }

                    String[] channels = event.getAdditionalData().split(",");
                    for (String channel : channels) {
                        processMessage(new IrcMessage(
                                channel,
                                oldNick + " is now known as",
                                newNick,
                                IrcMessage.MessageType.NICK_CHANGE,
                                Instant.now()
                        ));
                    }
                    break;

                case KICK:
                    String[] kickParts = event.getMessage().split(" ", 2);
                    String kickedUser = kickParts[0];
                    String kickReason = kickParts.length > 1 ? kickParts[1] : "";

                    processMessage(new IrcMessage(
                            event.getTarget(),
                            event.getSource() + " kicked " + kickedUser,
                            kickReason,
                            IrcMessage.MessageType.KICK,
                            Instant.now()
                    ));
                    break;

                case SERVER_NOTICE:
                case NOTICE:
                    if (source.endsWith(".SwiftIRC.net")) {
                        if (!config.filterServerNotices()) {
                            target = "System";
                        } else {
                            target = source;
                        }
                    } else {
                        source = "[N] " + source;

                        switch (config.filterNotices()) {
                            case Current:
                                target = panel.getCurrentChannel();
                                break;
                            case Status:
                                target = "System";
                                break;
                            case Private:
                                target = source;
                            default:
                                break;
                        }
                    }

                    processMessage(new IrcMessage(
                            target,
                            source,
                            event.getMessage(),
                            IrcMessage.MessageType.NOTICE,
                            Instant.now()
                    ));
                    break;

                case CHANNEL_MODE:
                    processMessage(new IrcMessage(
                            event.getTarget(),
                            event.getSource(),
                            event.getMessage(),
                            IrcMessage.MessageType.MODE,
                            Instant.now()
                    ));
                    break;

                case USER_MODE:
                    processMessage(new IrcMessage(
                            "System",
                            currentNick,
                            event.getMessage(),
                            IrcMessage.MessageType.MODE,
                            Instant.now()
                    ));
                    break;

                case TOPIC:
                    processMessage(new IrcMessage(
                            event.getTarget(),
                            "* Topic",
                            event.getMessage(),
                            IrcMessage.MessageType.TOPIC,
                            Instant.now()
                    ));
                    break;

                case NAMES:
                    processMessage(new IrcMessage(
                            event.getTarget(),
                            "Users",
                            event.getMessage(),
                            IrcMessage.MessageType.JOIN,
                            Instant.now()
                    ));
                    break;

                case NICK_IN_USE:
                    String fallbackNick = event.getMessage() + "_";
                    currentNick += "_";

                    processMessage(new IrcMessage(
                            "System",
                            "System",
                            "Nickname is already in use. Trying: " + fallbackNick,
                            IrcMessage.MessageType.SYSTEM,
                            Instant.now()
                    ));
                    break;

                case ERROR:
                    processMessage(new IrcMessage(
                            "System",
                            "Error",
                            event.getMessage() != null ? event.getMessage() : "Unknown error",
                            IrcMessage.MessageType.SYSTEM,
                            Instant.now()
                    ));
                    break;

                case TOPIC_INFO:
                    processMessage(new IrcMessage(
                            event.getTarget(), // channel
                            event.getSource(), // who set the topic
                            event.getMessage(), // the message about who set it
                            IrcMessage.MessageType.TOPIC, // reuse the same message type as regular topic
                            Instant.now()
                    ));
                    break;
            }
        });
    }
}
package com.irc;

import com.google.inject.Provides;
import com.irc.emoji.EmojiParser;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.PluginPanel;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.Timer;
import javax.swing.event.HyperlinkEvent;

import net.runelite.client.util.ImageUtil;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.LinkBrowser;

import static org.apache.commons.text.StringEscapeUtils.escapeHtml4;

@Slf4j
public class IrcPanel extends PluginPanel {
    @Inject
    private IrcConfig config;
    @Inject
    private ConfigManager configManager;

    private JTabbedPane tabbedPane;
    private JTextField inputField;
    @Getter
    private Map<String, ChannelPane> channelPanes;
    @Getter
    private NavigationButton navigationButton;

    private BiConsumer<String, String> onMessageSend;
    private BiConsumer<String, String> onChannelJoin;
    private Consumer<String> onChannelLeave;
    private Consumer<Boolean> onReconnect;
    private Font font;

    private final Map<String, Boolean> unreadMessages = new LinkedHashMap<>();
    private String focusedChannel;
    private static final String SYSTEM_TAB = "System";

    public ArrayList<String> getChannelNames() {
        return new ArrayList<>(channelPanes.keySet());
    }

    private void initializeFlashTimer() {
        // Change color for different flash
        Timer flashTimer = new Timer(500, e -> {
            String currentTab = getCurrentChannel();
            for (int i = 0; i < tabbedPane.getTabCount(); i++) {
                String tabTitle = tabbedPane.getTitleAt(i);
                if (!SYSTEM_TAB.equals(tabTitle) && unreadMessages.getOrDefault(tabTitle, false) && !tabTitle.equals(currentTab)) {
                    tabbedPane.setForegroundAt(i, new Color(135, 206, 250)); // Change color for different flash
                } else if (!SYSTEM_TAB.equals(tabTitle) && !unreadMessages.getOrDefault(tabTitle, false)) {
                    tabbedPane.setForegroundAt(i, Color.white);
                }
            }
        });
        flashTimer.start();
    }

    public void initializeGui() {
        setLayout(new BorderLayout());

        font = new Font(config.fontFamily(), Font.PLAIN, config.fontSize());

        tabbedPane = new JTabbedPane();
        tabbedPane.setPreferredSize(new Dimension(300, 425));
        inputField = new JTextField();
        inputField.setFont(font);
        channelPanes = new LinkedHashMap<>();

        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 5));

        JButton addButton = new JButton("+");
        JButton removeButton = new JButton("-");
        JButton reloadButton = new JButton();
        try {
            Image img = ImageUtil.loadImageResource(getClass(), "reload.png");
            reloadButton.setIcon(new ImageIcon(img));
        } catch (Exception ignored) {
            reloadButton.setText("R");
        }

        Dimension standard = new Dimension(25, 25);
        addButton.setPreferredSize(standard);
        removeButton.setPreferredSize(standard);
        reloadButton.setPreferredSize(standard);

        final JComboBox<String> fontComboBox = getStringJComboBox();

        addButton.addActionListener(e -> promptAddChannel());
        removeButton.addActionListener(e -> promptRemoveChannel());
        reloadButton.addActionListener(e -> onReconnect.accept(true));

        controlPanel.add(reloadButton);
        controlPanel.add(addButton);
        controlPanel.add(removeButton);
        controlPanel.add(fontComboBox);

        Action originalPasteAction = inputField.getActionMap().get("paste");
        Action customPasteAction = new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                originalPasteAction.actionPerformed(e);
                String text = inputField.getText();
                inputField.setText(convertModernEmojis(text));
            }
        };
        inputField.getActionMap().put("paste", customPasteAction);

        setupShortcuts();

        inputField.addActionListener(e -> {
            String message = inputField.getText();
            if (!message.isEmpty() && onMessageSend != null) {
                onMessageSend.accept(getCurrentChannel(), message);
                inputField.setText("");
            }
        });

        add(controlPanel, BorderLayout.NORTH);
        add(tabbedPane, BorderLayout.CENTER);
        add(inputField, BorderLayout.SOUTH);

        navigationButton = generateNavigationButton();

        SwingUtilities.invokeLater(() -> addChannel("System"));

        tabbedPane.addChangeListener(e -> {
            String newChannel = getCurrentChannel();
            if (unreadMessages.containsKey(newChannel)) {
                unreadMessages.put(newChannel, false);
                tabbedPane.setBackgroundAt(tabbedPane.getSelectedIndex(), null);
                tabbedPane.setForegroundAt(tabbedPane.getSelectedIndex(), null);
            }
            this.setFocusedChannel(newChannel);
        });

        initializeFlashTimer();
    }

    public NavigationButton generateNavigationButton() {
        navigationButton = NavigationButton.builder().tooltip("IRC").icon(ImageUtil.loadImageResource(getClass(), "icon.png")).priority(config.getPanelPriority()).panel(this).build();

        return navigationButton;
    }

    public void setFocusedChannel(String channel) {
        this.focusedChannel = channel;

        tabbedPane.setSelectedIndex(tabbedPane.indexOfTab(channel));
    }

    private JComboBox<String> getStringJComboBox() {
        String[] fonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();
        final JComboBox<String> fontComboBox = new JComboBox<>(fonts);

        int selectedIndex = Arrays.asList(fonts).indexOf(config.fontFamily());
        if (selectedIndex < 0) {
            ++selectedIndex;

            font = new Font(fonts[0], Font.PLAIN, config.fontSize());
        }

        fontComboBox.setSelectedIndex(selectedIndex);
        fontComboBox.setPreferredSize(new Dimension(110, 25));
        fontComboBox.addActionListener(e -> {
            if (fontComboBox.getSelectedItem() != null) {
                String selected = fontComboBox.getSelectedItem().toString();

                configManager.setConfiguration("irc", "fontFamily", selected);

                updateFont();
            }
        });

        return fontComboBox;
    }

    private void updateFont() {
        font = new Font(config.fontFamily(), Font.PLAIN, config.fontSize());

        inputField.setFont(font);

        for (ChannelPane channelPane : channelPanes.values()) {
            channelPane.setFont(font);
        }
    }

    @Provides
    IrcConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(IrcConfig.class);
    }

    public void init(BiConsumer<String, String> messageSendCallback, BiConsumer<String, String> channelJoinCallback, Consumer<String> channelLeaveCallback, Consumer<Boolean> onReconnect) {
        this.onMessageSend = messageSendCallback;
        this.onChannelJoin = channelJoinCallback;
        this.onChannelLeave = channelLeaveCallback;
        this.onReconnect = onReconnect;
    }

    public String getCurrentChannel() {
        int index = tabbedPane.getSelectedIndex();
        return index != -1 ? tabbedPane.getTitleAt(index) : "System";
    }

    public void clearCurrentPane() {
        int index = tabbedPane.getSelectedIndex();
        String channel = index != -1 ? tabbedPane.getTitleAt(index) : "System";
        ChannelPane pane = channelPanes.get(channel);
        if (pane != null) {
            pane.clear();
        }
    }

    public boolean isPane(String name) {
        return tabbedPane.indexOfTab(name) != -1;
    }

    public void addChannel(String channel) {
        if (channelPanes.containsKey(channel)) return;

        ChannelPane pane = new ChannelPane(font, config);
        channelPanes.put(channel, pane);
        unreadMessages.put(channel, false);
        tabbedPane.addTab(channel, new JScrollPane(pane));
        if (config.autofocusOnNewTab() || channel.equals(config.channel())) {
            tabbedPane.setSelectedIndex(tabbedPane.getTabCount() - 1);
        }
    }

    public void removeChannel(String channel) {
        if (!channelPanes.containsKey(channel) || channel.equals("System")) return;

        int index = tabbedPane.indexOfTab(channel);
        if (index == -1) return;

        tabbedPane.removeTabAt(index);
        channelPanes.remove(channel);
        unreadMessages.remove(channel);
    }

    public void addMessage(IrcMessage message) {
        ChannelPane pane = channelPanes.get(message.getChannel());
        if (pane == null) {
            addChannel(message.getChannel());
            pane = channelPanes.get(message.getChannel());
        }
        if (!message.getChannel().equals(focusedChannel)) {
            unreadMessages.put(message.getChannel(), true);
        }
        pane.appendMessage(message, config);
    }

    private void promptAddChannel() {
        String channel = JOptionPane.showInputDialog(this, "Enter channel name:");
        if (channel == null) return;

        String password = JOptionPane.showInputDialog(this, "Enter channel password (optional):");

        if (channel != null && !channel.trim().isEmpty()) {
            if (!channel.startsWith("#")) {
                channel = "#" + channel;
            }
            if (onChannelJoin != null) {
                onChannelJoin.accept(channel, password);
            }
        }
    }

    public void renameChannel(String old, String newName) {
        int index = getChannelNames().indexOf(old);
        if (index == -1) return;

        ChannelPane pane = getChannelPanes().get(old);
        if (pane == null) return;

        int focusedIndex = getChannelNames().indexOf(focusedChannel);
        if (focusedIndex == -1) return;

        pane.setName(newName);

        channelPanes.remove(old);
        channelPanes.put(newName, pane);

        Boolean unread = unreadMessages.get(old);
        if (unread == null) unread = false;

        unreadMessages.remove(old);
        unreadMessages.put(newName, unread);

        tabbedPane.remove(index);
        tabbedPane.addTab(newName, pane);
        tabbedPane.setSelectedIndex(focusedIndex);
    }

    private void promptRemoveChannel() {
        String channel = getCurrentChannel();
        if (!channel.equals("System")) {
            int result = JOptionPane.showConfirmDialog(this, "Close " + channel + "?", "Confirm", JOptionPane.YES_NO_OPTION);
            if (result == JOptionPane.YES_OPTION && onChannelLeave != null) {
                onChannelLeave.accept(channel);
            }
        }
    }

    private static class ChannelPane extends JTextPane {
        private ArrayList<String> messageLog;
        private static final Pattern IMAGE_URL_PATTERN = Pattern.compile("\\.(png|jpe?g|gif|bmp)(\\?.*)?$", Pattern.CASE_INSENSITIVE);
        private static final Pattern UNDERLINE = Pattern.compile("\u001F([^\u001F\u000F]+)[\u001F\u000F]?");
        private static final Pattern ITALIC = Pattern.compile("\u001D([^\u001D\u000F]+)[\u001D\u000F]?");
        private static final Pattern BOLD = Pattern.compile("\u0002([^\u0002\u000F]+)[\u0002\u000F]?");
        private static final Pattern VALID_LINK = Pattern.compile("(https?://([\\w-]+\\.)+[\\w-]+([\\w-;:,./?%&=]*))");
        private static final Pattern COLORS = Pattern.compile("(?:\u0003\\d\\d?(?:,\\d\\d?)?\\s*)?\u000F?\u0003(\\d\\d?)(?:,\\d\\d?)?([^\u0003\u000F]+)\u000F?");
        private static final Pattern STRIP_CODES = Pattern.compile("\u0002|\u0003(\\d\\d?(,\\d\\d)?)?|\u001D|\u0015|\u000F");
//        private static final int MAX_PREVIEW_WIDTH = 500;
//        private static final int MAX_PREVIEW_HEIGHT = 500;
//        private Popup currentImagePreview;

        ChannelPane(Font font, IrcConfig config) {
            setContentType("text/html");
            setFont(font);
            setEditable(false);
            messageLog = new ArrayList<>();

            addHyperlinkListener(e -> {
                if (e.getURL() != null) {
                    String url = e.getURL().toString();

                    if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
                        try {
                            LinkBrowser.browse(e.getURL().toURI().toString());
                        } catch (Exception ignored) {
                        }
// This feature is currently disabled until the UX can improve
//                    } else if (e.getEventType() == HyperlinkEvent.EventType.ENTERED) {
//                        if (config.hoverPreviewImages() && isImageUrl(url)) {
//                            showImagePreview(e.getSourceElement(), url);
//                        }
//                    } else if (e.getEventType() == HyperlinkEvent.EventType.EXITED) {
//                        hideImagePreview();
                    }
                }
            });
        }

        private boolean isImageUrl(String url) {
            return IMAGE_URL_PATTERN.matcher(url).find();
        }

// This feature is disabled until the UX can improve
//
//        private void showImagePreview(Object source, String imageUrl) {
//            hideImagePreview();
//
//            CompletableFuture.runAsync(() -> {
//                HttpURLConnection connection = null;
//                try {
//                    URL url = new URL(imageUrl);
//                    connection = (HttpURLConnection) url.openConnection();
//
//                    connection.setRequestProperty("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
//                    connection.setRequestProperty("Accept", "image/apng,image/svg+xml,image/*,*/*;q=0.8");
//                    connection.setRequestProperty("Accept-Language", "en-US,en;q=0.9");
//                    connection.setRequestProperty("Sec-Fetch-Dest", "image");
//                    connection.setRequestProperty("Sec-Fetch-Mode", "no-cors");
//                    connection.setRequestProperty("Sec-Fetch-Site", "cross-site");
//
//                    connection.setConnectTimeout(5000);
//                    connection.setReadTimeout(5000);
//
//                    // Follow redirects
//                    connection.setInstanceFollowRedirects(true);
//
//                    BufferedImage originalImage = ImageIO.read(connection.getInputStream());
//                    if (originalImage == null) {
//                        return;
//                    }
//
//                    // Scale image while maintaining aspect ratio
//                    double scale = Math.min(
//                            (double) MAX_PREVIEW_WIDTH / originalImage.getWidth(),
//                            (double) MAX_PREVIEW_HEIGHT / originalImage.getHeight()
//                    );
//
//                    int scaledWidth = (int) (originalImage.getWidth() * scale);
//                    int scaledHeight = (int) (originalImage.getHeight() * scale);
//
//                    BufferedImage scaledImage = new BufferedImage(scaledWidth, scaledHeight, BufferedImage.TYPE_INT_ARGB);
//                    Graphics2D g2d = scaledImage.createGraphics();
//                    g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
//                    g2d.drawImage(originalImage, 0, 0, scaledWidth, scaledHeight, null);
//                    g2d.dispose();
//
//                    SwingUtilities.invokeLater(() -> {
//                        try {
//                            if (source instanceof Element) {
//                                hideImagePreview();
//
//                                Rectangle bounds = getElementBounds((Element) source);
//
//                                Point location = new Point(
//                                        bounds.x,
//                                        bounds.y + bounds.height
//                                );
//                                SwingUtilities.convertPointToScreen(location, ChannelPane.this);
//
//                                JLabel imageLabel = new JLabel(new ImageIcon(scaledImage));
//                                imageLabel.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));
//                                imageLabel.setBackground(new Color(32, 32, 32));
//                                imageLabel.setOpaque(true);
//
//                                currentImagePreview = PopupFactory.getSharedInstance().getPopup(
//                                        ChannelPane.this,
//                                        imageLabel,
//                                        location.x,
//                                        location.y
//                                );
//                                currentImagePreview.show();
//                            }
//                        } catch (Exception ignored) {
//                        }
//                    });
//                } catch (Exception ignored) {
//                } finally {
//                    if (connection != null) {
//                        connection.disconnect();
//                    }
//                }
//            });
//        }
//
//        private Rectangle getElementBounds(Element element) {
//            try {
//                Rectangle result = getUI().modelToView2D(this, element. getStartOffset(), Position.Bias.Forward).getBounds();
//                Rectangle endRect = getUI().modelToView2D(this, element.getEndOffset(), Position.Bias.Backward).getBounds();
//                result.add(endRect);
//                return result;
//            } catch (Exception ex) {
//                return new Rectangle(0, 0, 0, 0);
//            }
//        }
//
//        private void hideImagePreview() {
//            if (currentImagePreview != null) {
//                currentImagePreview.hide();
//                currentImagePreview = null;
//            }
//        }

        void appendMessage(IrcMessage message, IrcConfig config) {
            String formattedMessage = formatPanelMessage(message, config);
            messageLog.add(formattedMessage);

            if (messageLog.size() > config.getMaxScrollback()) {
                messageLog.remove(0);
            }

            SwingUtilities.invokeLater(() -> {
                setText("<html><body style='color:" + ColorUtil.toHexColor(ColorScheme.TEXT_COLOR) + ";'>" + String.join("\n", messageLog) + "</body></html>");
                setCaretPosition(getDocument().getLength());
            });
        }

        private String formatPanelMessage(IrcMessage message, IrcConfig config) {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss").withZone(ZoneId.systemDefault());
            String timeStamp = "";
            if (config.timestamp()) {
                timeStamp = "[" + formatter.format(message.getTimestamp()) + "] ";
            }

            String color;
            switch (message.getType()) {
                case SYSTEM:
                case NICK_CHANGE:
                case KICK:
                case MODE:
                    color = ColorUtil.toHexColor(ColorScheme.BRAND_ORANGE);
                    break;
                case JOIN:
                    color = ColorUtil.toHexColor(ColorScheme.PROGRESS_INPROGRESS_COLOR);
                    break;
                case PART:
                case QUIT:
                    color = ColorUtil.toHexColor(ColorScheme.PROGRESS_ERROR_COLOR);
                    break;
                case TOPIC:
                    color = ColorUtil.toHexColor(ColorScheme.TEXT_COLOR);
                    break;
                default:
                    color = ColorUtil.toHexColor(ColorScheme.LIGHT_GRAY_COLOR);
            }

            String sender = escapeHtml4(message.getSender());

            if (config.colorizedNicks()) {
                String[] viableColorIds = new String[]{"02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15"};
                String colorId = viableColorIds[asciiSum(sender) % viableColorIds.length];
                String senderColor = htmlColorById(colorId);

                sender = String.format("<font style=\"color:%s\">%s</font>", senderColor, sender);
            }

            return String.format("<div style='color: %s'>%s%s:&nbsp;%s</div>", color, timeStamp, sender, formatMessage(message.getContent()));
        }

        private int asciiSum(String input) {
            if (input == null) return 0;

            int sum = 0;

            for (int i = 0; i < input.length(); i++) {
                sum += input.charAt(i);
            }

            return sum;
        }

        private String formatMessage(String message) {
            String msg = formatColorCodes(escapeHtml4(message));

            Matcher matcher = VALID_LINK.matcher(msg);

            return convertModernEmojis(matcher.replaceAll("<a href=\"$1\">$1</a>"));
        }

        private String formatColorCodes(String message) {
            Matcher underline_matcher = UNDERLINE.matcher(message);
            message = underline_matcher.replaceAll("<u>$1</u>");

            Matcher italic_matcher = ITALIC.matcher(message);
            message = italic_matcher.replaceAll("<i>$1</i>");

            Matcher bold_matcher = BOLD.matcher(message);
            message = bold_matcher.replaceAll("<b>$1</b>");

            Matcher color_matcher = COLORS.matcher(message);


            StringBuilder sb = new StringBuilder();
            while (color_matcher.find()) {
                color_matcher.appendReplacement(sb, "<font color=\"" + htmlColorById(color_matcher.group(1)) + "\">" + Matcher.quoteReplacement(color_matcher.group(2)) + "</font>");
            }
            color_matcher.appendTail(sb);

            return STRIP_CODES.matcher(sb.toString()).replaceAll("");
        }

        private String htmlColorById(String id) {
            String color = "black";

            switch (id) {
                case "00":
                case "0":
                    color = "white";
                    break;
                case "01":
                case "1":
                    color = "black";
                    break;
                case "02":
                case "2":
                    color = "00008B";
                    break;
                case "03":
                case "3":
                    color = "green";
                    break;
                case "04":
                case "4":
                    color = "red";
                    break;
                case "05":
                case "5":
                    color = "800000";
                    break;
                case "06":
                case "6":
                    color = "purple";
                    break;
                case "07":
                case "7":
                    color = "orange";
                    break;
                case "08":
                case "8":
                    color = "yellow";
                    break;
                case "09":
                case "9":
                    color = "DFFF00";
                    break;
                case "10":
                    color = "008b8b";
                    break;
                case "11":
                    color = "00FFFF";
                    break;
                case "12":
                    color = "blue";
                    break;
                case "13":
                    color = "FFC0CB";
                    break;
                case "14":
                    color = "gray";
                    break;
                case "15":
                    color = "d3d3d3";
                    break;
            }

            return color;
        }

        public void clear() {
            this.setText("");
            messageLog = new ArrayList<>();
        }
    }

    private static final Pattern MODERN_EMOJI_PATTERN = Pattern.compile("[" + "\uD83E\uDD70-\uD83E\uDDFF" + // Unicode 10.0
            "\uD83E\uDE00-\uD83E\uDEFF" + // Unicode 11.0
            "\uD83E\uDF00-\uD83E\uDFFF" + // Unicode 12.0+
            "\uD83E\uDD00-\uD83E\uDD6F" + // Unicode 13.0
            "\uD83E\uDEC0-\uD83E\uDECF" + "\uD83E\uDED0-\uD83E\uDEFF" + // Unicode 14.0
            "\uD83E\uDF00-\uD83E\uDF2F" + // Unicode 15.0
            "\uD83E\uDF30-\uD83E\uDF5F" + // Unicode 16.0
            "\uD83E\uDF60-\uD83E\uDF8F" + // Unicode 17.0
            "\uFE0F" +                    // Variation selector
            "]" + "|\uD83C[\uDFFB-\uDFFF]" +            // Skin tone modifiers
            "|\uD83E[\uDDB0-\uDDBF]"              // Hairstyle modifiers
    );

    public static String convertModernEmojis(String text) {
        StringBuilder result = new StringBuilder();
        Matcher matcher = MODERN_EMOJI_PATTERN.matcher(text);

        while (matcher.find()) {
            String modernEmoji = matcher.group();
            String replacement = EmojiParser.parseToAliases(modernEmoji, EmojiParser.FitzpatrickAction.PARSE);
            matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));
        }
        matcher.appendTail(result);

        return result.toString();
    }

    private enum IrcShortcut {
        COLOR(KeyStroke.getKeyStroke(KeyEvent.VK_K, Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()), "\u0003", "insertColorCode", "Insert color code"),

        BOLD(KeyStroke.getKeyStroke(KeyEvent.VK_B, Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()), "\u0002", "insertBold", "Insert bold formatting"),

        ITALIC(KeyStroke.getKeyStroke(KeyEvent.VK_I, Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()), "\u001D", "insertItalic", "Insert italic formatting"),

        UNDERLINE(KeyStroke.getKeyStroke(KeyEvent.VK_U, Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx()), "\u001F", "insertUnderline", "Insert underline formatting");

        private final KeyStroke keyStroke;
        private final String insertText;
        private final String actionKey;

        IrcShortcut(KeyStroke keyStroke, String insertText, String actionKey, String description) {
            this.keyStroke = keyStroke;
            this.insertText = insertText;
            this.actionKey = actionKey;
        }
    }

    private class TextInsertAction extends AbstractAction {
        private final String textToInsert;

        TextInsertAction(String textToInsert) {
            this.textToInsert = textToInsert;
        }

        @Override
        public void actionPerformed(ActionEvent e) {
            String currentText = inputField.getText();
            int caretPosition = inputField.getCaretPosition();

            String newText;
            int newCaretPosition;

            if (inputField.getSelectedText() != null) {
                int selStart = inputField.getSelectionStart();
                int selEnd = inputField.getSelectionEnd();
                String selectedText = inputField.getSelectedText();

                newText = currentText.substring(0, selStart) + textToInsert + selectedText + textToInsert + currentText.substring(selEnd);

                newCaretPosition = selEnd + (textToInsert.length() * 2);
            } else {
                newText = currentText.substring(0, caretPosition) + textToInsert + currentText.substring(caretPosition);

                newCaretPosition = caretPosition + textToInsert.length();
            }

            inputField.setText(newText);
            inputField.setCaretPosition(newCaretPosition);
        }
    }

    private void setupShortcuts() {
        InputMap inputMap = inputField.getInputMap(JComponent.WHEN_FOCUSED);
        ActionMap actionMap = inputField.getActionMap();

        for (IrcShortcut shortcut : IrcShortcut.values()) {
            inputMap.put(shortcut.keyStroke, shortcut.actionKey);
            actionMap.put(shortcut.actionKey, new TextInsertAction(shortcut.insertText));
        }
    }
}
package com.irc;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class SimpleIrcClient {
    private static final Pattern MESSAGE_PATTERN =
            Pattern.compile("^(?:[:@]([^\\s]+) )?([^\\s]+)(?: ((?:[^:\\s][^\\s]* ?)*))?(?: ?:(.*))?$");
    private static final Pattern USER_PREFIXES = Pattern.compile("^[~&@%+].+");
    private static final Pattern NUMERIC = Pattern.compile("^[0-9]+$");

    private Socket socket;
    private BufferedWriter writer;
    private BufferedReader reader;
    private final ExecutorService executor = Executors.newFixedThreadPool(2);
    private final List<IrcEventListener> listeners = new CopyOnWriteArrayList<>();

    @Getter
    private String nick;
    private String username;
    private String realName;
    private String password;
    @Getter
    private final Set<String> channels = new HashSet<>();
    private final Map<String, Set<String>> channelUsers = new HashMap<>();

    private String host;
    private int port;
    private boolean secure;
    private boolean connected = false;
    private volatile boolean shuttingDown = false;

    public SimpleIrcClient server(String host, int port, boolean secure) {
        this.host = host;
        this.port = port;
        this.secure = secure;
        return this;
    }

    public SimpleIrcClient credentials(String nick, String username, String realName) {
        this.nick = nick;
        this.username = username;
        this.realName = realName;
        return this;
    }

    public void password(String password) {
        this.password = password;
    }

    public void connect() {
        shuttingDown = false;
        executor.submit(() -> {
            try {
                if (secure) {
                    createSecureConnection();
                } else {
                    socket = new Socket(host, port);
                }

                writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), StandardCharsets.UTF_8));
                reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8));

                // Register connection
                if (password != null && !password.isEmpty()) {
                    sendRawLine("PASS " + password);
                }
                sendRawLine("NICK " + nick);
                sendRawLine("USER " + username + " 0 * :" + realName);

                connected = true;
                fireEvent(new IrcEvent(IrcEvent.Type.CONNECT, null, null, null, null));

                String line;
                try {
                    while (!shuttingDown && (line = reader.readLine()) != null) {
                        processLine(line);
                    }
                } catch (IOException e) {
                    if (!shuttingDown) {
                        log.error("Error reading from IRC server", e);
                        fireEvent(new IrcEvent(IrcEvent.Type.ERROR, null, null, null, e.getMessage()));
                    }
                }
            } catch (Exception e) {
                if (!shuttingDown) {
                    log.error("Error in IRC connection", e);
                    fireEvent(new IrcEvent(IrcEvent.Type.ERROR, null, null, null, e.getMessage()));
                }
            } finally {
                if (!shuttingDown) {
                    disconnect();
                }
            }
        });
    }

    private void createSecureConnection() throws IOException {
        try {
            SSLSocketFactory factory = (SSLSocketFactory) SSLSocketFactory.getDefault();
            SSLSocket sslSocket = (SSLSocket) factory.createSocket(host, port);

            sslSocket.setEnabledProtocols(sslSocket.getSupportedProtocols());

            sslSocket.startHandshake();
            socket = sslSocket;
        } catch (Exception e) {
            log.error("SSL/TLS certificate validation failed - connection rejected for security", e);
        }
    }

    public void disconnect() {
        disconnect("");
    }

    public void disconnect(String reason) {
        if (!connected) return;

        try {
            if (reason.isEmpty()) {
                reason = "Disconnecting";
            }

            shuttingDown = true;

            if (writer != null) {
                try {
                    sendRawLine("QUIT :" + reason);
                    writer.close();
                } catch (IOException ignored) {
                }
            }

            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException ignored) {
                }
            }

            if (socket != null) {
                try {
                    socket.close();
                } catch (IOException ignored) {
                }
            }
        } finally {
            connected = false;
            fireEvent(new IrcEvent(IrcEvent.Type.DISCONNECT, null, null, null, null));
        }
    }

    public void joinChannel(String channel, String password) {
        if (connected) {
            String command = "JOIN " + channel;
            if (password != null && !password.isEmpty()) {
                command += " " + password;
            }
            sendRawLine(command);
            channels.add(channel);
        }
    }

    public void leaveChannel(String channel) {
        leaveChannel(channel, null);
    }

    public void leaveChannel(String channel, String reason) {
        if (connected && channels.contains(channel)) {
            String command = "PART " + channel;
            if (reason != null && !reason.isEmpty()) {
                command += " :" + reason;
            }
            sendRawLine(command);
            channels.remove(channel);
            channelUsers.remove(channel);
        }
    }

    public void sendMessage(String target, String message) {
        if (connected) {
            sendRawLine("PRIVMSG " + target + " :" + message);
        }
    }

    public void sendAction(String target, String action) {
        if (connected) {
            sendRawLine("PRIVMSG " + target + " :\u0001ACTION " + action + "\u0001");
        }
    }

    public void sendNotice(String target, String message) {
        if (connected) {
            sendRawLine("NOTICE " + target + " :" + message);
        }
    }

    public void setNick(String newNick) {
        if (connected) {
            sendRawLine("NICK " + newNick);
            this.nick = newNick;
        }
    }

    public synchronized void sendRawLine(String line) {
        try {
            if (writer != null) {
                writer.write(line + "\r\n");
                writer.flush();
            }
        } catch (IOException e) {
            log.error("Error sending IRC message", e);
        }
    }

    private void processLine(String line) {
        Matcher matcher = MESSAGE_PATTERN.matcher(line);

        if (matcher.matches()) {
            String sourceRaw = matcher.group(1);
            String command = matcher.group(2);
            String paramsRaw = matcher.group(3);
            String trailing = matcher.group(4);

            String source = sourceRaw != null ? sourceRaw : "";
            List<String> params = new ArrayList<>();

            if (paramsRaw != null) {
                for (String param : paramsRaw.split(" ")) {
                    if (!param.isEmpty()) {
                        params.add(param);
                    }
                }
            }

            if (trailing != null) {
                params.add(trailing);
            }

            // Handle ping to keep connection alive
            if (command.equals("PING")) {
                sendRawLine("PONG " + (params.isEmpty() ? "" : params.get(0)));
                return;
            }

            // Parse command for events
            processCommand(source, command, params);
        }
    }

    private void processCommand(String source, String command, List<String> params) {
        String sourceNick = extractNick(source);

        switch (command.toUpperCase()) {
            case "PRIVMSG":
                if (params.size() >= 2) {
                    String target = params.get(0);
                    String message = params.get(1);

                    // Handle CTCPs
                    if (message.startsWith("\u0001") && message.endsWith("\u0001")) {
                        handleCtcp(source, target, message);
                    } else {
                        // Regular message - channel or private
                        String messageChannel = target.startsWith("#") ? target : sourceNick;
                        fireEvent(new IrcEvent(IrcEvent.Type.MESSAGE, sourceNick, messageChannel, message, null));
                    }
                }
                break;

            case "JOIN":
                if (!params.isEmpty()) {
                    String channel = params.get(0);
                    fireEvent(new IrcEvent(IrcEvent.Type.JOIN, sourceNick, channel, null, null));

                    // Add to channel users
                    channelUsers.computeIfAbsent(channel, k -> new HashSet<>()).add(sourceNick);
                }
                break;

            case "PART":
                if (!params.isEmpty()) {
                    String channel = params.get(0);
                    String reason = params.size() > 1 ? params.get(1) : "";

                    if (!sourceNick.equals(nick)) {
                        fireEvent(new IrcEvent(IrcEvent.Type.PART, sourceNick, channel, reason, null));
                    }

                    // Remove from channel users
                    if (channelUsers.containsKey(channel)) {
                        channelUsers.get(channel).remove(sourceNick);
                    }
                }
                break;

            case "QUIT":
                String quitMessage = params.isEmpty() ? "" : params.get(0);

                List<String> userChannels = new ArrayList<>();
                for (Map.Entry<String, Set<String>> entry : channelUsers.entrySet()) {
                    if (entry.getValue().contains(sourceNick)) {
                        userChannels.add(entry.getKey());
                    }
                }

                fireEvent(new IrcEvent(
                        IrcEvent.Type.QUIT,
                        sourceNick,
                        null,
                        quitMessage,
                        String.join(",", userChannels)
                ));

                // Remove from all channels
                for (Set<String> users : channelUsers.values()) {
                    users.remove(sourceNick);
                }
                break;

            case "NICK":
                if (!params.isEmpty()) {
                    String newNick = params.get(0);

                    userChannels = new ArrayList<>();
                    for (Map.Entry<String, Set<String>> entry : channelUsers.entrySet()) {
                        if (entry.getValue().contains(sourceNick)) {
                            userChannels.add(entry.getKey());
                        }
                    }

                    fireEvent(new IrcEvent(IrcEvent.Type.NICK_CHANGE, sourceNick, null, newNick, String.join(",", userChannels)));

                    // Update nickname in channel users
                    for (Set<String> users : channelUsers.values()) {
                        if (users.remove(sourceNick)) {
                            users.add(newNick);
                        }
                    }
                }
                break;

            case "KICK":
                if (params.size() >= 2) {
                    String channel = params.get(0);
                    String kickedUser = params.get(1);
                    String kickMessage = params.size() > 2 ? params.get(2) : "";

                    fireEvent(new IrcEvent(IrcEvent.Type.KICK, sourceNick, channel,
                            kickedUser + " " + kickMessage, null));

                    // Remove from channel users
                    if (channelUsers.containsKey(channel)) {
                        channelUsers.get(channel).remove(kickedUser);
                    }
                }
                break;

            case "NOTICE":
                if (params.size() >= 2) {
                    String target = params.get(0);
                    String message = params.get(1);

                    // Determine if this is a server notice or a user notice
                    if (source.contains("!")) {
                        // User notice
                        fireEvent(new IrcEvent(IrcEvent.Type.NOTICE, sourceNick, target, message, null));
                    } else {
                        // Server notice
                        fireEvent(new IrcEvent(IrcEvent.Type.SERVER_NOTICE, source, null, message, null));
                    }
                }
                break;

            case "MODE":
                if (params.size() >= 2) {
                    String target = params.get(0);
                    StringBuilder modeString = new StringBuilder();
                    for (String param : params) {
                        if (params.indexOf(param) > 0) {
                            modeString.append(" ").append(param);
                        }
                    }

                    if (target.startsWith("#")) {
                        // Channel mode
                        fireEvent(new IrcEvent(IrcEvent.Type.CHANNEL_MODE, "* " + sourceNick + " sets mode(s)", target, modeString.toString(), null));
                    } else {
                        // User mode
                        fireEvent(new IrcEvent(IrcEvent.Type.USER_MODE, sourceNick, target, modeString.toString(), null));
                    }
                }
                break;

            case "TOPIC":
                if (params.size() >= 2) {
                    String channel = params.get(0);
                    String topic = params.get(1);
                    fireEvent(new IrcEvent(IrcEvent.Type.TOPIC, sourceNick, channel, topic, null));
                }
                break;

            // Numeric replies
            default:
                Matcher matcher = NUMERIC.matcher(command);
                if (matcher.matches()) {
                    int numeric = Integer.parseInt(command);
                    handleNumeric(numeric, params);
                }
                break;
        }
    }

    private void handleCtcp(String source, String target, String message) {
        String ctcp = message.substring(1, message.length() - 1);
        String[] parts = ctcp.split(" ", 2);
        String command = parts[0].toUpperCase();
        String param = parts.length > 1 ? parts[1] : "";
        String sourceNick = extractNick(source);

        switch (command) {
            case "ACTION":
                // This is a /me command
                String actionChannel = target.startsWith("#") ? target : sourceNick;
                fireEvent(new IrcEvent(IrcEvent.Type.ACTION, sourceNick, actionChannel, param, null));
                break;

            case "VERSION":
                // Auto-respond to VERSION requests
                sendRawLine("NOTICE " + sourceNick + " :\u0001VERSION RuneLite IRC Plugin\u0001");
                break;

            case "PING":
                // Auto-respond to PING requests
                sendRawLine("NOTICE " + sourceNick + " :\u0001PING " + param + "\u0001");
                break;
        }
    }

    private void handleNumeric(int numeric, List<String> params) {
        switch (numeric) {
            case 1: // RPL_WELCOME - This means we're fully registered with the server
                connected = true; // Mark as truly connected and ready
                fireEvent(new IrcEvent(IrcEvent.Type.REGISTERED, null, null, null, null));
                break;

            case 324: // Channel modes
                if (params.size() >= 2) {
                    String target = params.get(1);
                    StringBuilder message = new StringBuilder();
                    for (String param : params) {
                        if (params.indexOf(param) > 1) {
                            message.append(" ").append(param);
                        }
                    }

                    fireEvent(new IrcEvent(IrcEvent.Type.CHANNEL_MODE, "* Modes", target, message.toString(), null));
                }
                break;

            case 332: // RPL_TOPIC - Topic message
                if (params.size() >= 3) {
                    String channel = params.get(1);
                    String topic = params.get(2);
                    fireEvent(new IrcEvent(IrcEvent.Type.TOPIC, "System", channel, topic, null));
                }
                break;

            case 333: // RPL_TOPICWHOTIME - Topic setter info
                if (params.size() >= 4) {
                    String channel = params.get(1);
                    String setter = params.get(2);
                    // You might want to format this timestamp
                    long timestamp = Long.parseLong(params.get(3));
                    fireEvent(new IrcEvent(IrcEvent.Type.TOPIC_INFO, "* Topic set by", channel,
                            setter, null));
                }
                break;

            case 353: // RPL_NAMREPLY - Channel user list
                if (params.size() >= 4) {
                    String channel = params.get(2);
                    String[] users = params.get(3).split(" ");

                    Set<String> channelUserSet = channelUsers.computeIfAbsent(channel, k -> new HashSet<>());
                    for (String user : users) {
                        if (!user.isEmpty()) {
                            // Strip mode prefixes (@, +, etc.)
                            Matcher matcher = USER_PREFIXES.matcher(user);
                            if (matcher.matches()) {
                                user = user.substring(1);
                            }
                            channelUserSet.add(user);
                        }
                    }

                    fireEvent(new IrcEvent(IrcEvent.Type.NAMES, null, channel, String.join(" ", users), null));
                }
                break;

            case 433: // ERR_NICKNAMEINUSE
                if (params.size() >= 2) {
                    String takenNick = params.get(1);
                    fireEvent(new IrcEvent(IrcEvent.Type.NICK_IN_USE, null, null, takenNick, null));

                    // Auto-append underscore to nick
                    setNick(takenNick + "_");
                    nick += "_";
                }
                break;
        }
    }

    private String extractNick(String source) {
        if (source == null || source.isEmpty()) {
            return "";
        }
        int exclamation = source.indexOf('!');
        return exclamation > 0 ? source.substring(0, exclamation) : source;
    }

    public void addEventListener(IrcEventListener listener) {
        listeners.add(listener);
    }

    public void removeEventListener(IrcEventListener listener) {
        listeners.remove(listener);
    }

    private final List<Runnable> pendingCommands = new CopyOnWriteArrayList<>();

    /**
     * Queue a command to be executed once fully registered with the server
     */
    public void executeWhenRegistered(Runnable command) {
        if (connected) {
            command.run();
        } else {
            pendingCommands.add(command);
        }
    }

    private void fireEvent(IrcEvent event) {
        // If we just got registered, execute any pending commands
        if (event.getType() == IrcEvent.Type.REGISTERED) {
            // Execute all pending commands that were waiting for registration
            for (Runnable command : pendingCommands) {
                command.run();
            }
            pendingCommands.clear();
        }

        for (IrcEventListener listener : listeners) {
            listener.onEvent(event);
        }
    }

    // Event handling interface
    public interface IrcEventListener {
        void onEvent(IrcEvent event);
    }

    // Event class for all IRC events
    @Getter
    public static class IrcEvent {
        public enum Type {
            CONNECT, DISCONNECT, REGISTERED, MESSAGE, ACTION, JOIN, PART, QUIT,
            NICK_CHANGE, KICK, NOTICE, SERVER_NOTICE, CHANNEL_MODE, USER_MODE,
            TOPIC, NAMES, NICK_IN_USE, ERROR, TOPIC_INFO
        }

        private final Type type;
        private final String source;
        private final String target;
        private final String message;
        private final String additionalData;

        public IrcEvent(Type type, String source, String target, String message, String additionalData) {
            this.type = type;
            this.source = source;
            this.target = target;
            this.message = message;
            this.additionalData = additionalData;
        }
    }
}
package com.irc;

import lombok.Value;
import java.time.Instant;

@Value
public class IrcMessage {
    String channel;
    String sender;
    String content;
    MessageType type;
    Instant timestamp;

    enum MessageType {
        CHAT, SYSTEM, JOIN, PART, QUIT, NICK_CHANGE, PRIVATE, NOTICE, KICK, TOPIC, MODE
    }
}
package com.example;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import com.irc.IrcPlugin;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(IrcPlugin.class);
		RuneLite.main(args);
	}
}
