package com.dklights;

import java.time.Duration;
import java.time.Instant;
import java.util.regex.Matcher;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;

@Slf4j
public class DKLightsStatsTracker
{

	@Getter
	private int lampsFixed = 0;
	@Getter
	private int lampsPerHr = 0;
	@Getter
	private int totalLampsFixed = 0;

	private Instant start;

	public DKLightsStatsTracker()
	{
	}

	public void incrementLampsFixed()
	{
		++lampsFixed;

		if (start == null)
		{
			start = Instant.now();
		}

		Duration elapsed = Duration.between(start, Instant.now());
		long elapsedMs = elapsed.toMillis();

		if (lampsFixed >= 3 && elapsedMs > 0)
		{
			lampsPerHr = (int) ((double) lampsFixed * Duration.ofHours(1).toMillis() / elapsedMs);
		}
	}

	public void onChatMessage(ChatMessage chatMessage)
	{
		ChatMessageType chatMessageType = chatMessage.getType();
		String message = chatMessage.getMessage();

		if (chatMessageType == ChatMessageType.SPAM
				&& message.contains(DKLightsConstants.TOTAL_LAMPS_FIXED_CHAT_MESSAGE))
		{
			updateTotalLampsFixed(message);
		}
	}

	public void updateTotalLampsFixed(String message)
	{
		Matcher matcher = DKLightsConstants.TOTAL_LAMPS_PATTERN.matcher(message);

		if (matcher.find())
		{
			try
			{
				String numberStr = matcher.group(1).replace(",", "");
				int number = Integer.parseInt(numberStr);

				if (number > 0 && number > this.totalLampsFixed)
				{
					this.totalLampsFixed = number;
				}
			}
			catch (NumberFormatException e)
			{
				log.warn("Failed to parse number from chat message: {}", matcher.group(1));
			}
		}
	}

	public void resetSession()
	{
		lampsFixed = 0;
		lampsPerHr = 0;
		start = null;
	}
}

package com.dklights.pathfinder;

import java.util.BitSet;
import java.util.Locale;
import lombok.Getter;
import static net.runelite.api.Constants.REGION_SIZE;

public class FlagMap
{
	private static final byte FLAG_COUNT = 2;
	private final BitSet flags;
	@Getter
	private final byte planeCount;
	private final int minX;
	private final int minY;

	public FlagMap(int minX, int minY, byte planeCount)
	{
		this.minX = minX;
		this.minY = minY;
		this.planeCount = planeCount;
		flags = new BitSet(REGION_SIZE * REGION_SIZE * planeCount * FLAG_COUNT);
	}

	public FlagMap(int minX, int minY, byte[] bytes)
	{
		this.minX = minX;
		this.minY = minY;
		flags = BitSet.valueOf(bytes);
		int scale = REGION_SIZE * REGION_SIZE * FLAG_COUNT;
		this.planeCount = (byte) ((flags.size() + scale - 1) / scale);
	}

	public byte[] toBytes()
	{
		return flags.toByteArray();
	}

	public boolean get(int x, int y, int z, int flag)
	{
		if (x < minX || x >= (minX + REGION_SIZE) || y < minY || y >= (minY + REGION_SIZE) || z < 0 || z >= planeCount)
		{
			return false;
		}

		return flags.get(index(x, y, z, flag));
	}

	public void set(int x, int y, int z, int flag, boolean value)
	{
		flags.set(index(x, y, z, flag), value);
	}

	private int index(int x, int y, int z, int flag)
	{
		if (x < minX || x >= (minX + REGION_SIZE) || y < minY || y >= (minY + REGION_SIZE) || z < 0 || z >= planeCount
				|| flag < 0 || flag >= FLAG_COUNT)
		{
			throw new IndexOutOfBoundsException(String.format(Locale.ENGLISH,
					"[%d,%d,%d,%d] when extents are [>=%d,>=%d,>=%d,>=%d] - [<=%d,<=%d,<%d,<%d]", x, y, z, flag, minX,
					minY, 0, 0, minX + REGION_SIZE - 1, minY + REGION_SIZE - 1, planeCount, FLAG_COUNT));
		}

		return (z * REGION_SIZE * REGION_SIZE + (y - minY) * REGION_SIZE + (x - minX)) * FLAG_COUNT + flag;
	}
}
package com.dklights.pathfinder;

import lombok.Data;
import net.runelite.api.coords.WorldPoint;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@Data
public class Node implements Comparable<Node>
{
	private final WorldPoint worldPoint;
	private Node parent;
	private float gCost; // Distance from start
	private float hCost; // Distance to target (heuristic)
	private float fCost; // Total cost (g + h)

	public Node(WorldPoint worldPoint)
	{
		this.worldPoint = worldPoint;
		this.gCost = Float.MAX_VALUE;
		this.hCost = 0;
		this.fCost = Float.MAX_VALUE;
	}

	public List<WorldPoint> getPath()
	{
		List<WorldPoint> path = new ArrayList<>();
		Node current = this;

		while (current != null)
		{
			path.add(current.worldPoint);
			current = current.parent;
		}

		Collections.reverse(path);
		return path;
	}

	@Override
	public int compareTo(Node other)
	{
		return Float.compare(this.fCost, other.fCost);
	}

	@Override
	public boolean equals(Object obj)
	{
		if (this == obj)
			return true;
		if (obj == null || getClass() != obj.getClass())
			return false;
		Node node = (Node) obj;
		return worldPoint.equals(node.worldPoint);
	}

	@Override
	public int hashCode()
	{
		return worldPoint.hashCode();
	}
}
package com.dklights.pathfinder;

import java.io.IOException;
import java.io.InputStream;
import java.io.UncheckedIOException;
import java.util.HashMap;
import java.util.Map;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

import static net.runelite.api.Constants.REGION_SIZE;

public class SplitFlagMap
{
	@Getter
	private static RegionExtent regionExtents;

	@Getter
	private final byte[] regionMapPlaneCounts;
	private final FlagMap[] regionMaps;
	private final int widthInclusive;

	public SplitFlagMap(Map<Integer, byte[]> compressedRegions)
	{
		widthInclusive = regionExtents.getWidth() + 1;
		final int heightInclusive = regionExtents.getHeight() + 1;
		regionMaps = new FlagMap[widthInclusive * heightInclusive];
		regionMapPlaneCounts = new byte[regionMaps.length];

		for (Map.Entry<Integer, byte[]> entry : compressedRegions.entrySet())
		{
			final int pos = entry.getKey();
			final int x = unpackX(pos);
			final int y = unpackY(pos);
			final int index = getIndex(x, y);
			FlagMap flagMap = new FlagMap(x * REGION_SIZE, y * REGION_SIZE, entry.getValue());
			regionMaps[index] = flagMap;
			regionMapPlaneCounts[index] = flagMap.getPlaneCount();
		}
	}

	public boolean get(int x, int y, int z, int flag)
	{
		final int index = getIndex(x / REGION_SIZE, y / REGION_SIZE);
		if (index < 0 || index >= regionMaps.length || regionMaps[index] == null)
		{
			return false;
		}

		return regionMaps[index].get(x, y, z, flag);
	}

	private int getIndex(int regionX, int regionY)
	{
		return (regionX - regionExtents.getMinX()) + (regionY - regionExtents.getMinY()) * widthInclusive;
	}

	public static int unpackX(int position)
	{
		return position & 0xFFFF;
	}

	public static int unpackY(int position)
	{
		return (position >> 16) & 0xFFFF;
	}

	public static int packPosition(int x, int y)
	{
		return (x & 0xFFFF) | ((y & 0xFFFF) << 16);
	}

	public static SplitFlagMap loadFromResources()
	{
		Map<Integer, byte[]> compressedRegions = new HashMap<>();
		String[] regionFiles =
		{ "42_82", "42_83" };

		int minX = 42, minY = 82, maxX = 42, maxY = 83;

		for (String regionFile : regionFiles)
		{
			try (InputStream in = SplitFlagMap.class.getResourceAsStream("/collision_maps/" + regionFile))
			{
				if (in == null)
				{
					throw new IOException("Collision map file not found: " + regionFile);
				}

				String[] n = regionFile.split("_");
				final int x = Integer.parseInt(n[0]);
				final int y = Integer.parseInt(n[1]);
				compressedRegions.put(packPosition(x, y), in.readAllBytes());
			}
			catch (IOException e)
			{
				throw new UncheckedIOException(e);
			}
		}

		regionExtents = new RegionExtent(minX, minY, maxX, maxY);
		return new SplitFlagMap(compressedRegions);
	}

	@RequiredArgsConstructor
	@Getter
	public static class RegionExtent
	{
		public final int minX, minY, maxX, maxY;

		public int getWidth()
		{
			return maxX - minX;
		}

		public int getHeight()
		{
			return maxY - minY;
		}
	}
}
package com.dklights.pathfinder;

import java.util.ArrayList;
import java.util.List;
import net.runelite.api.coords.WorldPoint;
import com.dklights.enums.Transport;
import com.dklights.enums.Direction;

public class CollisionMap
{

	private static final java.util.List<Direction> ORDINAL_VALUES = java.util.Arrays.asList(Direction.values());

	private final SplitFlagMap collisionData;

	public byte[] getPlanes()
	{
		return collisionData.getRegionMapPlaneCounts();
	}

	public CollisionMap(SplitFlagMap collisionData)
	{
		this.collisionData = collisionData;
	}

	private boolean get(int x, int y, int z, int flag)
	{
		return collisionData.get(x, y, z, flag);
	}

	public boolean n(int x, int y, int z)
	{
		return get(x, y, z, 0);
	}

	public boolean s(int x, int y, int z)
	{
		return n(x, y - 1, z);
	}

	public boolean e(int x, int y, int z)
	{
		return get(x, y, z, 1);
	}

	public boolean w(int x, int y, int z)
	{
		return e(x - 1, y, z);
	}

	private boolean ne(int x, int y, int z)
	{
		return n(x, y, z) && e(x, y + 1, z) && e(x, y, z) && n(x + 1, y, z);
	}

	private boolean nw(int x, int y, int z)
	{
		return n(x, y, z) && w(x, y + 1, z) && w(x, y, z) && n(x - 1, y, z);
	}

	private boolean se(int x, int y, int z)
	{
		return s(x, y, z) && e(x, y - 1, z) && e(x, y, z) && s(x + 1, y, z);
	}

	private boolean sw(int x, int y, int z)
	{
		return s(x, y, z) && w(x, y - 1, z) && w(x, y, z) && s(x - 1, y, z);
	}

	public boolean isBlocked(int x, int y, int z)
	{
		return !n(x, y, z) && !s(x, y, z) && !e(x, y, z) && !w(x, y, z);
	}

	public String getCollisionFlags(WorldPoint point)
	{
		int x = point.getX();
		int y = point.getY();
		int z = point.getPlane();
		return "N: " + n(x, y, z) + ", S: " + s(x, y, z) + ", E: " + e(x, y, z) + ", W: " + w(x, y, z);
	}

	public List<Node> getValidNeighbors(Node node, java.util.Map<WorldPoint, java.util.List<Transport>> transports)
	{
		List<Node> neighbors = new ArrayList<>();
		WorldPoint p = node.getWorldPoint();
		final int x = p.getX();
		final int y = p.getY();
		final int z = p.getPlane();

		boolean[] traversable = new boolean[8];

		traversable[0] = w(x, y, z); // WEST
		traversable[1] = e(x, y, z); // EAST
		traversable[2] = s(x, y, z); // SOUTH
		traversable[3] = n(x, y, z); // NORTH
		traversable[4] = sw(x, y, z); // SOUTH_WEST
		traversable[5] = se(x, y, z); // SOUTH_EAST
		traversable[6] = nw(x, y, z); // NORTH_WEST
		traversable[7] = ne(x, y, z); // NORTH_EAST

		for (int i = 0; i < traversable.length; i++)
		{
			if (traversable[i])
			{
				Direction d = ORDINAL_VALUES.get(i);
				int newX = x + d.getX();
				int newY = y + d.getY();
				neighbors.add(new Node(new WorldPoint(newX, newY, z)));
			}
		}

		if (transports != null && transports.containsKey(p))
		{
			for (Transport transport : transports.get(p))
			{
				neighbors.add(new Node(transport.getDestination()));
			}
		}

		return neighbors;
	}
}
package com.dklights.pathfinder;

import java.util.Arrays;

/**
 * A minimal, growable list implementation for primitive {@code int} values.
 * <p>
 * This class avoids boxing overhead present in {@link java.util.List Integer}
 * collections by storing values in a backing {@code int[]} that grows as
 * needed. It purposefully implements only the operations required by the
 * pathfinding logic in this plugin; it is <strong>not</strong> a dropâ€‘in
 * replacement for {@link java.util.ArrayList}.
 * <p>
 * The growth policy increases capacity by 50% (similar to {@code ArrayList})
 * when the existing array is exhausted. Capacity never shrinks.
 */
public class PrimitiveIntList
{
	private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

	private int[] elementData;
	private int size;

	/**
	 * Creates a new list with the specified initial capacity.
	 *
	 * @param initialCapacity the initial length of the backing array (must be
	 *                        {@code >= 0}).
	 * @param initialize      if {@code true}, the {@link #size} is set equal to
	 *                        {@code initialCapacity}, effectively pre-filling the
	 *                        logical list with zeroes. If {@code false}, the list
	 *                        is created empty.
	 * @throws IllegalArgumentException if {@code initialCapacity < 0}.
	 */
	public PrimitiveIntList(int initialCapacity, boolean initialize)
	{
		if (initialCapacity < 0)
		{
			throw new IllegalArgumentException("Illegal capacity: " + initialCapacity);
		}
		this.elementData = new int[initialCapacity];
		if (initialize)
		{
			size = initialCapacity;
		}
	}

	/**
	 * Creates an empty list with the given backing array capacity.
	 *
	 * @param initialCapacity initial length of the internal array (must be
	 *                        {@code >= 0}).
	 */
	public PrimitiveIntList(int initialCapacity)
	{
		this(initialCapacity, false);
	}

	/**
	 * Creates an empty list with a default initial capacity of 10.
	 */
	public PrimitiveIntList()
	{
		this(10);
	}

	/**
	 * Ensures that the backing array can store at least {@code minCapacity}
	 * elements. If the current capacity is already sufficient the call is a no-op.
	 *
	 * @param minCapacity the desired minimum capacity (ignored if {@code <= 0}).
	 */
	public void ensureCapacity(int minCapacity)
	{
		if (minCapacity > 0)
		{
			ensureCapacityInternal(minCapacity);
		}
	}

	private void ensureCapacityInternal(int minCapacity)
	{
		if (minCapacity - elementData.length > 0)
		{
			grow(minCapacity);
		}
	}

	private void grow(int minCapacity)
	{
		int oldCapacity = elementData.length;
		int newCapacity = oldCapacity + (oldCapacity >> 1);
		if (newCapacity - minCapacity < 0)
		{
			newCapacity = minCapacity;
		}
		if (newCapacity - MAX_ARRAY_SIZE > 0)
		{
			newCapacity = hugeCapacity(minCapacity);
		}
		elementData = Arrays.copyOf(elementData, newCapacity);
	}

	private static int hugeCapacity(int minCapacity)
	{
		if (minCapacity < 0)
		{ // overflow
			throw new OutOfMemoryError();
		}
		return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;
	}

	/**
	 * Returns the number of elements that have been added to (or initialized in)
	 * this list.
	 *
	 * @return current element count (always {@code >= 0}).
	 */
	public int size()
	{
		return size;
	}

	/**
	 * Indicates whether the list currently holds zero elements.
	 *
	 * @return {@code true} if {@link #size()} is zero; {@code false} otherwise.
	 */
	public boolean isEmpty()
	{
		return size == 0;
	}

	/**
	 * Tests whether the specified primitive value exists in the list.
	 *
	 * @param e the value to search for.
	 * @return {@code true} if the value occurs at least once; {@code false}
	 *         otherwise.
	 */
	public boolean contains(int e)
	{
		return indexOf(e) >= 0;
	}

	/**
	 * Returns the index of the first occurrence of the given value, or {@code -1}
	 * if absent.
	 *
	 * @param e the value to locate.
	 * @return zero-based index of the value, or {@code -1} if not found.
	 */
	public int indexOf(int e)
	{
		for (int i = 0; i < size; i++)
		{
			if (e == elementData[i])
			{
				return i;
			}
		}
		return -1;
	}

	/**
	 * Retrieves the value at the specified index.
	 *
	 * @param index zero-based position of the element to return.
	 * @return the value stored at {@code index}.
	 * @throws IndexOutOfBoundsException if {@code index < 0 || index >= size}.
	 */
	public int get(int index)
	{
		rangeCheck(index);
		return elementData[index];
	}

	/**
	 * Replaces the value at the specified index.
	 *
	 * @param index   zero-based position of the element to overwrite.
	 * @param element the new value.
	 * @return the previous value stored at {@code index}.
	 * @throws IndexOutOfBoundsException if {@code index < 0 || index >= size}.
	 */
	public int set(int index, int element)
	{
		rangeCheck(index);
		int oldValue = elementData[index];
		elementData[index] = element;
		return oldValue;
	}

	/**
	 * Appends a value to the end of the list, growing the backing array if
	 * required.
	 *
	 * @param e value to append.
	 * @return always {@code true}
	 */
	public boolean add(int e)
	{
		ensureCapacityInternal(size + 1);
		elementData[size++] = e;
		return true;
	}

	/**
	 * Inserts a value at the specified index, shifting subsequent elements one
	 * position to the right.
	 *
	 * @param index   zero-based insertion point (may be equal to {@link #size()} to
	 *                append).
	 * @param element the value to insert.
	 * @throws IndexOutOfBoundsException if {@code index < 0 || index > size}.
	 */
	public void add(int index, int element)
	{
		rangeCheckForAdd(index);
		ensureCapacityInternal(size + 1);
		System.arraycopy(elementData, index, elementData, index + 1, size - index);
		elementData[index] = element;
		size++;
	}

	/**
	 * Removes the value at the specified index and compacts the list.
	 *
	 * @param index zero-based index of the element to remove.
	 * @return the removed value.
	 * @throws IndexOutOfBoundsException if {@code index < 0 || index >= size}.
	 */
	public int removeAt(int index)
	{
		rangeCheck(index);
		int oldValue = elementData[index];
		int numMoved = size - index - 1;
		if (numMoved > 0)
		{
			System.arraycopy(elementData, index + 1, elementData, index, numMoved);
		}
		elementData[--size] = 0;
		return oldValue;
	}

	/**
	 * Removes the first occurrence of the specified value, if present.
	 *
	 * @param e value to remove.
	 * @return {@code true} if a value was removed; {@code false} otherwise.
	 */
	public boolean remove(int e)
	{
		for (int i = 0; i < size; i++)
		{
			if (e == elementData[i])
			{
				fastRemove(i);
				return true;
			}
		}
		return false;
	}

	private void fastRemove(int index)
	{
		int numMoved = size - index - 1;
		if (numMoved > 0)
		{
			System.arraycopy(elementData, index + 1, elementData, index, numMoved);
		}
		elementData[--size] = 0;
	}

	/**
	 * Removes all elements from the list and resets {@link #size()} to zero. The
	 * backing array is retained for reuse.
	 */
	public void clear()
	{
		for (int i = 0; i < size; i++)
		{
			elementData[i] = 0;
		}
		size = 0;
	}

	private void rangeCheck(int index)
	{
		if (index >= size)
		{
			throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
		}
	}

	private void rangeCheckForAdd(int index)
	{
		if (index > size || index < 0)
		{
			throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
		}
	}
}
package com.dklights.pathfinder;

import com.dklights.enums.Transport;

import lombok.extern.slf4j.Slf4j;

import com.dklights.enums.Direction;
import com.dklights.enums.Lamp;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Set;

import net.runelite.api.coords.WorldPoint;

@Slf4j
public class Pathfinder
{
	private static final int MAX_ITERATIONS = 10000;
	private static final int MAX_PATH_LENGTH = 512;

	private final CollisionMap collisionMap;
	private final Map<WorldPoint, List<Transport>> transports;

	public Pathfinder() throws IOException
	{
		SplitFlagMap map = SplitFlagMap.loadFromResources();
		this.collisionMap = new CollisionMap(map);
		this.transports = new HashMap<>();

		for (Transport transport : Transport.values())
		{
			transports.computeIfAbsent(transport.getOrigin(), k -> new ArrayList<>()).add(transport);
		}
	}

	public List<WorldPoint> findNearestPath(WorldPoint start, Set<WorldPoint> targets,
			Map<Lamp, Set<Direction>> lampWallCache)
	{
		if (start == null || targets == null || targets.isEmpty())
		{
			return new ArrayList<>();
		}

		if (targets.contains(start))
		{
			List<WorldPoint> path = new ArrayList<>();
			path.add(start);
			return path;
		}

		Set<WorldPoint> reachableTargets = new HashSet<>();
		Map<WorldPoint, WorldPoint> adjacentToTargetMap = new HashMap<>();

		for (WorldPoint target : targets)
		{
			Lamp targetLamp = getLampFromWorldPoint(target);
			if (targetLamp == null)
				continue;

			Set<Direction> walledDirections = lampWallCache.getOrDefault(targetLamp, Collections.emptySet());

			for (Direction direction : Direction.getCardinalDirections())
			{
				if (walledDirections.contains(direction))
				{
					continue;
				}

				WorldPoint adjacent = new WorldPoint(target.getX() + direction.getX(), target.getY() + direction.getY(),
						target.getPlane());

				if (!getNeighbors(new Node(adjacent)).isEmpty())
				{
					reachableTargets.add(adjacent);
					adjacentToTargetMap.put(adjacent, target);
				}
			}
		}

		if (reachableTargets.isEmpty())
		{
			log.debug("Could not find any reachable tiles adjacent to targets.");
			return new ArrayList<>();
		}

		Queue<WorldPoint> queue = new ArrayDeque<>();
		Set<WorldPoint> visited = new HashSet<>();
		Map<WorldPoint, WorldPoint> parentMap = new HashMap<>();

		queue.add(start);
		visited.add(start);

		int iterations = 0;

		while (!queue.isEmpty() && iterations < MAX_ITERATIONS)
		{
			iterations++;
			WorldPoint current = queue.poll();

			if (reachableTargets.contains(current))
			{
				return reconstructPath(parentMap, start, current);
			}

			List<Node> neighborNodes = collisionMap.getValidNeighbors(new Node(current), transports);

			for (Node neighborNode : neighborNodes)
			{
				WorldPoint neighborPoint = neighborNode.getWorldPoint();

				if (visited.add(neighborPoint))
				{
					parentMap.put(neighborPoint, current);
					queue.add(neighborPoint);
				}
			}
		}

		if (iterations >= MAX_ITERATIONS)
		{
			log.debug("findNearestPath hit MAX_ITERATIONS ({})", MAX_ITERATIONS);
		}

		return new ArrayList<>();
	}

	private List<WorldPoint> reconstructPath(Map<WorldPoint, WorldPoint> parentMap, WorldPoint start, WorldPoint end)
	{
		List<WorldPoint> path = new ArrayList<>();
		WorldPoint current = end;

		while (current != null && !current.equals(start))
		{
			path.add(current);
			current = parentMap.get(current);
		}

		if (current != null && current.equals(start))
		{
			path.add(start);
		}

		Collections.reverse(path);

		if (path.isEmpty() || !path.get(0).equals(start))
		{
			return new ArrayList<>();
		}

		return path;
	}

	private Lamp getLampFromWorldPoint(WorldPoint worldPoint)
	{
		for (Lamp lamp : Lamp.values())
		{
			if (lamp.getWorldPoint().equals(worldPoint))
			{
				return lamp;
			}
		}
		return null;
	}

	public List<WorldPoint> findPath(WorldPoint start, WorldPoint end)
	{
		return findPathInternal(start, end, MAX_ITERATIONS);
	}

	public boolean isTransportLocation(WorldPoint point)
	{
		return transports.containsKey(point);
	}

	public List<Transport> getTransportsAt(WorldPoint point)
	{
		return transports.getOrDefault(point, new ArrayList<>());
	}

	private List<WorldPoint> findPathInternal(WorldPoint start, WorldPoint end, int maxIterations)
	{
		if (start == null || end == null)
		{
			return new ArrayList<>();
		}

		if (start.equals(end))
		{
			List<WorldPoint> path = new ArrayList<>();
			path.add(start);
			return path;
		}

		int roughDistance = Math.abs(start.getX() - end.getX()) + Math.abs(start.getY() - end.getY());
		if (roughDistance > MAX_PATH_LENGTH)
		{
			log.debug("Pathfinding rejected - too far apart: " + roughDistance + " > " + MAX_PATH_LENGTH);
			return new ArrayList<>();
		}

		boolean crossPlane = start.getPlane() != end.getPlane();

		WorldPoint bestTarget = null;
		int closestDistance = Integer.MAX_VALUE;

		if (!crossPlane)
		{
			for (Direction direction : Direction.getCardinalDirections())
			{
				WorldPoint nearby = new WorldPoint(end.getX() + direction.getX(), end.getY() + direction.getY(),
						end.getPlane());

				List<Node> nearbyNeighbors = getNeighbors(new Node(nearby));
				if (!nearbyNeighbors.isEmpty())
				{
					boolean hasValidConnection = false;

					for (Node neighbor : nearbyNeighbors)
					{
						WorldPoint neighborPoint = neighbor.getWorldPoint();
						if (neighborPoint.getPlane() == nearby.getPlane())
						{
							int distanceFromStart = Math.abs(start.getX() - neighborPoint.getX())
									+ Math.abs(start.getY() - neighborPoint.getY());
							int nearbyDistanceFromStart = Math.abs(start.getX() - nearby.getX())
									+ Math.abs(start.getY() - nearby.getY());

							if (distanceFromStart <= nearbyDistanceFromStart + 2)
							{
								hasValidConnection = true;
								break;
							}
						}
					}

					if (hasValidConnection)
					{
						int distance = Math.abs(start.getX() - nearby.getX()) + Math.abs(start.getY() - nearby.getY());
						if (distance < closestDistance)
						{
							closestDistance = distance;
							bestTarget = nearby;
						}
					}
				}
			}

			if (bestTarget != null)
			{
				end = bestTarget;
			}
			else
			{
				log.debug("DEBUG: No walkable directions found for lamp at " + end);
				return new ArrayList<>();
			}
		}

		PriorityQueue<Node> openSet = new PriorityQueue<>();
		Set<WorldPoint> closedSet = new HashSet<>();
		int iterations = 0;

		Node startNode = new Node(start);
		startNode.setGCost(0);
		startNode.setHCost(calculateHeuristic(start, end));
		startNode.setFCost(startNode.getHCost());
		openSet.add(startNode);

		while (!openSet.isEmpty() && iterations < maxIterations)
		{
			iterations++;

			Node currentNode = openSet.poll();

			if (currentNode.getWorldPoint().equals(end))
			{
				List<WorldPoint> path = currentNode.getPath();
				if (path.size() > MAX_PATH_LENGTH)
				{
					return new ArrayList<>();
				}
				return path;
			}

			if (crossPlane && currentNode.getWorldPoint().getPlane() == end.getPlane())
			{
				int dx = Math.abs(currentNode.getWorldPoint().getX() - end.getX());
				int dy = Math.abs(currentNode.getWorldPoint().getY() - end.getY());
				if (dx <= 1 && dy <= 1)
				{
					List<WorldPoint> path = currentNode.getPath();
					if (path.size() > MAX_PATH_LENGTH)
					{
						return new ArrayList<>();
					}
					return path;
				}
			}

			if (!crossPlane && currentNode.getGCost() <= 3)
			{
				int directDistance = Math.abs(currentNode.getWorldPoint().getX() - end.getX())
						+ Math.abs(currentNode.getWorldPoint().getY() - end.getY());
				if (directDistance <= 1)
				{
					List<Node> currentNeighbors = getNeighbors(currentNode);
					boolean canReachTarget = false;
					for (Node neighbor : currentNeighbors)
					{
						if (neighbor.getWorldPoint().equals(end))
						{
							canReachTarget = true;
							break;
						}
					}

					if (canReachTarget)
					{
						List<WorldPoint> path = currentNode.getPath();
						path.add(end);
						return path;
					}
				}
			}

			closedSet.add(currentNode.getWorldPoint());

			for (Node neighbor : getNeighbors(currentNode))
			{
				if (closedSet.contains(neighbor.getWorldPoint()))
				{
					continue;
				}

				float transportCost = 1;
				if (transports.containsKey(currentNode.getWorldPoint()))
				{
					for (Transport transport : transports.get(currentNode.getWorldPoint()))
					{
						if (transport.getDestination().getPlane() == end.getPlane())
						{
							transportCost = Math.max(transport.getDuration() * 0.9f, 1);
						}
						else
						{
							transportCost = Math.max(transport.getDuration(), 2);
						}
						break;
					}
				}
				else
				{
					WorldPoint current = currentNode.getWorldPoint();
					WorldPoint next = neighbor.getWorldPoint();
					int dx = Math.abs(next.getX() - current.getX());
					int dy = Math.abs(next.getY() - current.getY());

					if (dx == 1 && dy == 1)
					{
						transportCost += 0.01;
					}

					if (current.getPlane() != end.getPlane())
					{
						int closestTransportDistance = Integer.MAX_VALUE;
						for (Map.Entry<WorldPoint, List<Transport>> entry : transports.entrySet())
						{
							WorldPoint transportLoc = entry.getKey();
							if (transportLoc.getPlane() == current.getPlane())
							{
								for (Transport transport : entry.getValue())
								{
									if (transport.getDestination().getPlane() == end.getPlane())
									{
										int tDist = Math.max(Math.abs(current.getX() - transportLoc.getX()),
												Math.abs(current.getY() - transportLoc.getY()));
										closestTransportDistance = Math.min(closestTransportDistance, tDist);
									}
								}
							}
						}

						if (closestTransportDistance != Integer.MAX_VALUE)
						{
							int nextClosestTransportDistance = Integer.MAX_VALUE;
							for (Map.Entry<WorldPoint, List<Transport>> entry : transports.entrySet())
							{
								WorldPoint transportLoc = entry.getKey();
								if (transportLoc.getPlane() == next.getPlane())
								{
									for (Transport transport : entry.getValue())
									{
										if (transport.getDestination().getPlane() == end.getPlane())
										{
											int tDist = Math.max(Math.abs(next.getX() - transportLoc.getX()),
													Math.abs(next.getY() - transportLoc.getY()));
											nextClosestTransportDistance = Math.min(nextClosestTransportDistance,
													tDist);
										}
									}
								}
							}

							if (nextClosestTransportDistance > closestTransportDistance)
							{
								transportCost += 0.1;
							}
						}
					}
				}
				float tentativeGCost = currentNode.getGCost() + transportCost;

				if (tentativeGCost > MAX_PATH_LENGTH)
				{
					continue;
				}

				if (tentativeGCost < neighbor.getGCost() || !openSet.contains(neighbor))
				{
					neighbor.setGCost(tentativeGCost);
					neighbor.setHCost(calculateHeuristic(neighbor.getWorldPoint(), end));
					neighbor.setFCost(neighbor.getGCost() + neighbor.getHCost());
					neighbor.setParent(currentNode);

					if (!openSet.contains(neighbor))
					{
						openSet.add(neighbor);
					}
				}
			}
		}

		if (iterations >= maxIterations)
		{
			log.debug("DEBUG: Pathfinding hit MAX_ITERATIONS (" + maxIterations + ")");
		}
		else
		{
			log.debug("DEBUG: Pathfinding failed - openSet empty after " + iterations + " iterations");
		}
		return new ArrayList<>();
	}

	private List<Node> getNeighbors(Node node)
	{
		List<Node> neighbors = collisionMap.getValidNeighbors(node, transports);
		return neighbors;
	}

	private int calculateHeuristic(WorldPoint from, WorldPoint to)
	{
		int dx = Math.abs(from.getX() - to.getX());
		int dy = Math.abs(from.getY() - to.getY());

		int chebyshevDistance = Math.max(dx, dy);

		if (from.getPlane() != to.getPlane())
		{
			int minTransportDistance = Integer.MAX_VALUE;
			boolean foundRelevantTransport = false;

			for (Map.Entry<WorldPoint, List<Transport>> entry : transports.entrySet())
			{
				WorldPoint transportLocation = entry.getKey();

				for (Transport transport : entry.getValue())
				{
					if (transport.getDestination().getPlane() == to.getPlane()
							|| transport.getOrigin().getPlane() == from.getPlane())
					{

						int transportDx = Math.abs(from.getX() - transportLocation.getX());
						int transportDy = Math.abs(from.getY() - transportLocation.getY());
						int distanceToTransport = Math.max(transportDx, transportDy);

						int destDx = Math.abs(transport.getDestination().getX() - to.getX());
						int destDy = Math.abs(transport.getDestination().getY() - to.getY());
						int distanceFromTransport = Math.max(destDx, destDy);

						int totalEstimatedDistance = distanceToTransport + distanceFromTransport;

						if (totalEstimatedDistance < minTransportDistance)
						{
							minTransportDistance = totalEstimatedDistance;
							foundRelevantTransport = true;
						}
					}
				}
			}

			if (foundRelevantTransport)
			{
				return minTransportDistance;
			}
		}

		return chebyshevDistance;
	}
}
package com.dklights.pathfinder;

import net.runelite.api.Client;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import static net.runelite.api.Constants.CHUNK_SIZE;
import static net.runelite.api.Perspective.LOCAL_COORD_BITS;

/**
 * Utility functions for packing, unpacking, and transforming {@link WorldPoint}
 * coordinates as compact {@code int} values.
 * <p>
 * A packed world point encodes {@code x}, {@code y}, and {@code plane} into a
 * single 32-bit integer using:
 * 
 * <pre>
 * bits 0..14   : x (15 bits)
 * bits 15..29  : y (15 bits)
 * bits 30..31  : plane (2 bits)
 * </pre>
 * 
 * This representation allows efficient storage and hashing of coordinates
 * within the pathfinding data structures.
 */
public class WorldPointUtil
{
	public static final int UNDEFINED = -1;

	/**
	 * Packs a {@link WorldPoint} into a compact {@code int} encoding.
	 *
	 * @param point world point (may be {@code null}).
	 * @return packed integer value, or {@link #UNDEFINED} if {@code point} is
	 *         {@code null}.
	 */
	public static int packWorldPoint(WorldPoint point)
	{
		if (point == null)
		{
			return -1;
		}
		return packWorldPoint(point.getX(), point.getY(), point.getPlane());
	}

	/**
	 * Packs the provided coordinate triple into a single {@code int}. First 15 bits
	 * are {@code x}, next 15 bits are {@code y}, final 2 bits are the plane. Values
	 * are masked into range; overflow bits are discarded.
	 *
	 * @param x     world x (0..32767 effectively supported).
	 * @param y     world y (0..32767 effectively supported).
	 * @param plane plane (0..3).
	 * @return packed integer representation.
	 */
	public static int packWorldPoint(int x, int y, int plane)
	{
		return (x & 0x7FFF) | ((y & 0x7FFF) << 15) | ((plane & 0x3) << 30);
	}

	/**
	 * Unpacks a packed world point into a new {@link WorldPoint} instance.
	 *
	 * @param packedPoint packed coordinate.
	 * @return decoded {@link WorldPoint}.
	 */
	public static WorldPoint unpackWorldPoint(int packedPoint)
	{
		final int x = unpackWorldX(packedPoint);
		final int y = unpackWorldY(packedPoint);
		final int plane = unpackWorldPlane(packedPoint);
		return new WorldPoint(x, y, plane);
	}

	/**
	 * Extracts the x component from a packed world point.
	 * 
	 * @param packedPoint packed coordinate.
	 * @return x value.
	 */
	public static int unpackWorldX(int packedPoint)
	{
		return packedPoint & 0x7FFF;
	}

	/**
	 * Extracts the y component from a packed world point.
	 * 
	 * @param packedPoint packed coordinate.
	 * @return y value.
	 */
	public static int unpackWorldY(int packedPoint)
	{
		return (packedPoint >> 15) & 0x7FFF;
	}

	/**
	 * Extracts the plane component from a packed world point.
	 * 
	 * @param packedPoint packed coordinate.
	 * @return plane value (0..3).
	 */
	public static int unpackWorldPlane(int packedPoint)
	{
		return (packedPoint >> 30) & 0x3;
	}

	/**
	 * Offsets a packed world point by {@code (dx, dy)} on the same plane.
	 *
	 * @param packedPoint base packed point.
	 * @param dx          delta x to add.
	 * @param dy          delta y to add.
	 * @return packed point after applying deltas.
	 */
	public static int dxdy(int packedPoint, int dx, int dy)
	{
		int x = unpackWorldX(packedPoint);
		int y = unpackWorldY(packedPoint);
		int z = unpackWorldPlane(packedPoint);
		return packWorldPoint(x + dx, y + dy, z);
	}

	/**
	 * Computes the distance between two packed points using Chebyshev metric
	 * (diagonal = 1).
	 */
	public static int distanceBetween(int previousPacked, int currentPacked)
	{
		return distanceBetween(previousPacked, currentPacked, 1);
	}

	/**
	 * Computes the 2D distance (ignoring plane) between two packed points using
	 * Chebyshev metric (diagonal = 1).
	 */
	public static int distanceBetween2D(int previousPacked, int currentPacked)
	{
		return distanceBetween2D(previousPacked, currentPacked, 1);
	}

	/**
	 * Computes distance between two packed points with selectable distance metric.
	 *
	 * @param previousPacked first packed point.
	 * @param currentPacked  second packed point.
	 * @param diagonal       {@code 1} for Chebyshev (max), {@code 2} for Manhattan
	 *                       (sum). Any other value returns
	 *                       {@code Integer.MAX_VALUE}.
	 * @return distance or {@code Integer.MAX_VALUE} if plane differs or metric is
	 *         unsupported.
	 */
	public static int distanceBetween(int previousPacked, int currentPacked, int diagonal)
	{
		final int previousX = WorldPointUtil.unpackWorldX(previousPacked);
		final int previousY = WorldPointUtil.unpackWorldY(previousPacked);
		final int previousZ = WorldPointUtil.unpackWorldPlane(previousPacked);
		final int currentX = WorldPointUtil.unpackWorldX(currentPacked);
		final int currentY = WorldPointUtil.unpackWorldY(currentPacked);
		final int currentZ = WorldPointUtil.unpackWorldPlane(currentPacked);
		return distanceBetween(previousX, previousY, previousZ, currentX, currentY, currentZ, diagonal);
	}

	/**
	 * Computes 2D distance (ignoring plane) between two packed points with
	 * selectable metric.
	 * 
	 * @see #distanceBetween(int, int, int, int, int, int, int)
	 */
	public static int distanceBetween2D(int previousPacked, int currentPacked, int diagonal)
	{
		final int previousX = WorldPointUtil.unpackWorldX(previousPacked);
		final int previousY = WorldPointUtil.unpackWorldY(previousPacked);
		final int currentX = WorldPointUtil.unpackWorldX(currentPacked);
		final int currentY = WorldPointUtil.unpackWorldY(currentPacked);
		return distanceBetween2D(previousX, previousY, currentX, currentY, diagonal);
	}

	/**
	 * Computes distance between two coordinates with selectable metric; returns
	 * {@code Integer.MAX_VALUE} if planes differ.
	 *
	 * @param previousX x of first point.
	 * @param previousY y of first point.
	 * @param previousZ plane of first point.
	 * @param currentX  x of second point.
	 * @param currentY  y of second point.
	 * @param currentZ  plane of second point.
	 * @param diagonal  metric selector ({@code 1}=Chebyshev, {@code 2}=Manhattan).
	 * @return distance or {@code Integer.MAX_VALUE} if planes differ or unsupported
	 *         metric.
	 */
	public static int distanceBetween(int previousX, int previousY, int previousZ, int currentX, int currentY,
			int currentZ, int diagonal)
	{
		final int dz = Math.abs(previousZ - currentZ);

		if (dz != 0)
		{
			return Integer.MAX_VALUE;
		}

		return distanceBetween2D(previousX, previousY, currentX, currentY, diagonal);
	}

	/**
	 * Computes a 2D distance using either Chebyshev or Manhattan metric.
	 *
	 * @param previousX x of first point.
	 * @param previousY y of first point.
	 * @param currentX  x of second point.
	 * @param currentY  y of second point.
	 * @param diagonal  metric selector ({@code 1}=Chebyshev, {@code 2}=Manhattan).
	 * @return distance or {@code Integer.MAX_VALUE} for unsupported metric.
	 */
	public static int distanceBetween2D(int previousX, int previousY, int currentX, int currentY, int diagonal)
	{
		final int dx = Math.abs(previousX - currentX);
		final int dy = Math.abs(previousY - currentY);

		if (diagonal == 1)
		{
			return Math.max(dx, dy);
		}
		else if (diagonal == 2)
		{
			return dx + dy;
		}

		return Integer.MAX_VALUE;
	}

	/**
	 * Convenience overload using Chebyshev distance between two
	 * {@link WorldPoint}s.
	 */
	public static int distanceBetween(WorldPoint previous, WorldPoint current)
	{
		return distanceBetween(previous, current, 1);
	}

	/**
	 * Distance between two {@link WorldPoint}s with selectable metric.
	 * 
	 * @see #distanceBetween(int, int, int, int, int, int, int)
	 */
	public static int distanceBetween(WorldPoint previous, WorldPoint current, int diagonal)
	{
		return distanceBetween(previous.getX(), previous.getY(), previous.getPlane(), current.getX(), current.getY(),
				current.getPlane(), diagonal);
	}

	/**
	 * Distance from a packed point to a {@link WorldArea} using Chebyshev metric,
	 * respecting plane. Returns {@code Integer.MAX_VALUE} if the plane differs.
	 */
	public static int distanceToArea(int packedPoint, WorldArea area)
	{
		final int plane = unpackWorldPlane(packedPoint);
		if (area.getPlane() != plane)
		{
			return Integer.MAX_VALUE;
		}
		return distanceToArea2D(packedPoint, area);
	}

	/**
	 * 2D distance (Chebyshev) from a packed point to a {@link WorldArea} ignoring
	 * plane, equivalent to {@link WorldArea#distanceTo(WorldPoint)} semantics in
	 * 2D.
	 */
	public static int distanceToArea2D(int packedPoint, WorldArea area)
	{
		final int y = unpackWorldY(packedPoint);
		final int x = unpackWorldX(packedPoint);
		final int areaMaxX = area.getX() + area.getWidth() - 1;
		final int areaMaxY = area.getY() + area.getHeight() - 1;
		final int dx = Math.max(Math.max(area.getX() - x, 0), x - areaMaxX);
		final int dy = Math.max(Math.max(area.getY() - y, 0), y - areaMaxY);

		return Math.max(dx, dy);
	}

	private static int rotate(int originalX, int originalY, int z, int rotation)
	{
		int chunkX = originalX & ~(CHUNK_SIZE - 1);
		int chunkY = originalY & ~(CHUNK_SIZE - 1);
		int x = originalX & (CHUNK_SIZE - 1);
		int y = originalY & (CHUNK_SIZE - 1);
		switch (rotation)
		{
		case 1:
			return packWorldPoint(chunkX + y, chunkY + (CHUNK_SIZE - 1 - x), z);
		case 2:
			return packWorldPoint(chunkX + (CHUNK_SIZE - 1 - x), chunkY + (CHUNK_SIZE - 1 - y), z);
		case 3:
			return packWorldPoint(chunkX + (CHUNK_SIZE - 1 - y), chunkY + x, z);
		}
		return packWorldPoint(originalX, originalY, z);
	}

	/**
	 * Converts an instanced {@link LocalPoint} to its corresponding packed world
	 * point coordinate, resolving the underlying template chunk mapping and
	 * rotation.
	 *
	 * @param client     RuneLite client.
	 * @param localPoint local scene coordinate.
	 * @return packed world point.
	 */
	public static int fromLocalInstance(Client client, LocalPoint localPoint)
	{
		WorldView worldView = client.getWorldView(localPoint.getWorldView());
		int plane = worldView.getPlane();

		if (!worldView.isInstance())
		{
			return packWorldPoint((localPoint.getX() >> LOCAL_COORD_BITS) + worldView.getBaseX(),
					(localPoint.getY() >> LOCAL_COORD_BITS) + worldView.getBaseY(), plane);
		}

		int[][][] instanceTemplateChunks = worldView.getInstanceTemplateChunks();

		// get position in the scene
		int sceneX = localPoint.getSceneX();
		int sceneY = localPoint.getSceneY();

		// get chunk from scene
		int chunkX = sceneX / CHUNK_SIZE;
		int chunkY = sceneY / CHUNK_SIZE;

		// get the template chunk for the chunk
		int templateChunk = instanceTemplateChunks[plane][chunkX][chunkY];

		int rotation = templateChunk >> 1 & 0x3;
		int templateChunkY = (templateChunk >> 3 & 0x7FF) * CHUNK_SIZE;
		int templateChunkX = (templateChunk >> 14 & 0x3FF) * CHUNK_SIZE;
		int templateChunkPlane = templateChunk >> 24 & 0x3;

		// calculate world point of the template
		int x = templateChunkX + (sceneX & (CHUNK_SIZE - 1));
		int y = templateChunkY + (sceneY & (CHUNK_SIZE - 1));

		// create and rotate point back to 0, to match with template
		return rotate(x, y, templateChunkPlane, 4 - rotation);
	}

	/**
	 * Converts a packed world point to one or more packed world points representing
	 * its locations within an instanced map (e.g., dungeons or raids). If the
	 * current top-level world is not instanced, the result contains exactly the
	 * original point.
	 *
	 * @param client      RuneLite client.
	 * @param packedPoint packed world coordinate.
	 * @return list of packed coordinates valid in the current instance.
	 */
	public static PrimitiveIntList toLocalInstance(Client client, int packedPoint)
	{
		WorldView worldView = client.getTopLevelWorldView();

		PrimitiveIntList worldPoints = new PrimitiveIntList();
		if (!worldView.isInstance())
		{
			worldPoints.add(packedPoint);
			return worldPoints;
		}

		int baseX = worldView.getBaseX();
		int baseY = worldView.getBaseY();
		int worldPointX = unpackWorldX(packedPoint);
		int worldPointY = unpackWorldY(packedPoint);
		int worldPointPlane = unpackWorldPlane(packedPoint);

		int[][][] instanceTemplateChunks = worldView.getInstanceTemplateChunks();

		// find instance chunks using the template point. there might be more than one.
		for (int z = 0; z < instanceTemplateChunks.length; z++)
		{
			for (int x = 0; x < instanceTemplateChunks[z].length; ++x)
			{
				for (int y = 0; y < instanceTemplateChunks[z][x].length; ++y)
				{
					int chunkData = instanceTemplateChunks[z][x][y];
					int rotation = chunkData >> 1 & 0x3;
					int templateChunkY = (chunkData >> 3 & 0x7FF) * CHUNK_SIZE;
					int templateChunkX = (chunkData >> 14 & 0x3FF) * CHUNK_SIZE;
					int plane = chunkData >> 24 & 0x3;
					if (worldPointX >= templateChunkX && worldPointX < templateChunkX + CHUNK_SIZE
							&& worldPointY >= templateChunkY && worldPointY < templateChunkY + CHUNK_SIZE
							&& plane == worldPointPlane)
					{
						worldPoints.add(rotate(baseX + x * CHUNK_SIZE + (worldPointX & (CHUNK_SIZE - 1)),
								baseY + y * CHUNK_SIZE + (worldPointY & (CHUNK_SIZE - 1)), z, rotation));
					}
				}
			}
		}
		return worldPoints;
	}

	private static boolean isInScene(WorldView worldView, int packedPoint)
	{
		int x = unpackWorldX(packedPoint);
		int y = unpackWorldY(packedPoint);

		int baseX = worldView.getBaseX();
		int baseY = worldView.getBaseY();

		int maxX = baseX + worldView.getSizeX();
		int maxY = baseY + worldView.getSizeY();

		return x >= baseX && x < maxX && y >= baseY && y < maxY;
	}

	/**
	 * Converts a packed world point into a {@link LocalPoint} relative to the
	 * top-level world view if it resides in the currently loaded scene and on the
	 * same plane; returns {@code null} otherwise.
	 *
	 * @param client      RuneLite client.
	 * @param packedPoint packed world point.
	 * @return {@link LocalPoint} or {@code null} if out of scene or plane.
	 */
	public static LocalPoint toLocalPoint(Client client, int packedPoint)
	{
		WorldView worldView = client.getTopLevelWorldView();

		if (worldView.getPlane() != unpackWorldPlane(packedPoint))
		{
			return null;
		}

		if (!isInScene(worldView, packedPoint))
		{
			return null;
		}

		return new LocalPoint(
				(unpackWorldX(packedPoint) - worldView.getBaseX() << LOCAL_COORD_BITS) + (1 << LOCAL_COORD_BITS - 1),
				(unpackWorldY(packedPoint) - worldView.getBaseY() << LOCAL_COORD_BITS) + (1 << LOCAL_COORD_BITS - 1),
				worldView.getId());
	}
}
package com.dklights;

import com.google.common.collect.ImmutableSet;
import net.runelite.api.coords.WorldPoint;
import java.util.Set;
import java.util.regex.Pattern;

public final class DKLightsConstants 
{
    private DKLightsConstants() {}

    public static final int NAV_BUTTON_PRIORITY = 7;
    public static final int DORGESHKAAN_LAMPS_VARBIT = 4038;
    public static final int WIRE_RESPAWN_TICKS = 8;
    public static final int INVENTORY_ID = 93;

    // Icon image path
    public static final String ICON_IMAGE_PATH = "/light_orb_32x32.png";

    // Chat messages and patterns
    public static final String NEARBY_LAMP_CHAT_MESSAGE = "There is another broken lamp nearby";
    public static final String TOTAL_LAMPS_FIXED_CHAT_MESSAGE = "You replace the orb. Total lights fixed: ";
    public static final Pattern NEARBY_LAMP_PATTERN = Pattern.compile("There is another broken lamp nearby, (\\w+(?:\\s\\w+)?) of here (\\w+(?:\\s\\w+)*)\\.");
    public static final Pattern TOTAL_LAMPS_PATTERN = Pattern.compile("You replace the orb\\. Total lights fixed: (?:<col=[^>]*>)?([0-9,]+)");

    // Coordinates
    public static final int WORLD_MAP_LINE = 5312; // Y
    public static final int DK_WEST_VALUE = 2688; // X
    public static final int DK_EAST_VALUE = 2751; // X
    public static final int DK_NORTH_VALUE = 5375; // Y
    public static final int DK_SOUTH_VALUE = 5248; // Y

    public static final WorldPoint MAP_NORTH_WEST_CORNER = new WorldPoint(2688, 5375, 0);
    public static final WorldPoint MAP_SOUTH_EAST_CORNER = new WorldPoint(2751, 5248, 0);

    // Object IDs
    public static final int TELEPORT_SPHERE_ID = 10972;
    public static final int LIGHT_BULB_EMPTY = 10980;
    public static final int LIGHT_BULB_WORKING = 10973;
    public static final int WIRE_MACHINE_ACTIVE = 22730;
    public static final int WIRE_MACHINE_INACTIVE = 22731;

    public static final Set<Integer> WIRE_MACHINE_IDS = ImmutableSet.of(
            WIRE_MACHINE_ACTIVE,
            WIRE_MACHINE_INACTIVE
    );

    public static final Set<Integer> DOOR_IDS = ImmutableSet.of(
            22914,
            22921
    );

public static final Set<Integer> STAIR_IDS_UP = ImmutableSet.of(
            22931,
            22934,
            22937,
            22939,
            22941
    );
    
public static final Set<Integer> STAIR_IDS_DOWN = ImmutableSet.of(
            22932,
            22933,
            22935,
            22936,
            22938,
            22940,
            22942
    );
    
    public static final Set<Integer> STAIR_IDS = ImmutableSet.<Integer>builder()
            .addAll(STAIR_IDS_UP)
            .addAll(STAIR_IDS_DOWN)
            .build();
    
    // Bank location in Dorgesh-Kaan
    public static final WorldPoint WIRE_MACHINE_LOCATION = new WorldPoint(2716, 5274, 0);
    public static final WorldPoint BANK_LOCATION = new WorldPoint(2702, 5349, 0);
}

/*
 * Copyright (c) 2020, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.dklights;

import com.dklights.enums.InventoryState;
import com.dklights.overlay.DKLightsOverlay;
import com.dklights.overlay.StatsOverlay;
import com.dklights.overlay.TeleportOverlay;
import com.dklights.overlay.LegacyOverlay;
import com.dklights.pathfinder.Pathfinder;
import com.google.inject.Provides;
import java.io.IOException;
import java.time.Instant;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.inject.Inject;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.WallObjectDespawned;
import net.runelite.api.events.WallObjectSpawned;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
	name = "Dorgesh-Kaan Lights"
)
public class DKLightsPlugin extends Plugin
{

	@Inject
	@Getter
	private Client client;

	@Inject
	@Getter
	private DKLightsConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private DKLightsOverlay overlay;

	@Inject
	private TeleportOverlay teleportOverlay;

	@Inject
	private StatsOverlay statsOverlay;

	@Inject
	private LegacyOverlay legacyOverlay;

    @Getter
	private DKLightsNavigationManager navigationManager;
	@Getter
	private DKLightsStatsTracker statsTracker;
	@Getter
	private DKLightsStateManager stateManager;

	private ExecutorService pathfindingExecutor;

	@Getter
	private Pathfinder pathfinder;

	@Getter
	private Instant lastTickInstant = Instant.now();

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(overlay);
		overlayManager.add(teleportOverlay);
		overlayManager.add(statsOverlay);
		overlayManager.add(legacyOverlay);

		statsTracker = new DKLightsStatsTracker();
		stateManager = new DKLightsStateManager(client, statsTracker);

		pathfindingExecutor = Executors.newSingleThreadExecutor(r ->
		{
			Thread t = new Thread(r, "DKLights-Pathfinder");
			t.setDaemon(true);
			return t;
		});

		try
		{
			pathfinder = new Pathfinder();
		}
		catch (IOException e)
		{
			log.error("Failed to load pathfinder collision data", e);
			return;
		}

		navigationManager = new DKLightsNavigationManager(client, config, pathfinder, pathfindingExecutor);

	}

	@Override
	protected void shutDown() throws Exception
	{
		log.info("Dorgesh-Kaan Lamps stopped!");
		overlayManager.remove(overlay);
		overlayManager.remove(teleportOverlay);
		overlayManager.remove(statsOverlay);
		overlayManager.remove(legacyOverlay);

		navigationManager.shutDown();

		if (stateManager != null)
		{
			stateManager.shutDown();
		}
		if (navigationManager != null)
		{
			navigationManager.shutDown();
		}
		if (pathfindingExecutor != null)
		{
			pathfindingExecutor.shutdown();
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		stateManager.onGameObjectSpawned(event.getGameObject());
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned event)
	{
		stateManager.onGameObjectDespawned(event.getGameObject());
	}

	@Subscribe
	public void onWallObjectSpawned(WallObjectSpawned event)
	{
		stateManager.onWallObjectSpawned(event.getWallObject());
	}

	@Subscribe
	public void onWallObjectDespawned(WallObjectDespawned event)
	{
		stateManager.onWallObjectDespawned(event.getWallObject());
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		stateManager.onGameStateChanged(gameStateChanged.getGameState());
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		stateManager.onChatMessage(chatMessage);
		statsTracker.onChatMessage(chatMessage);
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		lastTickInstant = Instant.now();

		if (client.getLocalPlayer() == null)
		{
			return;
		}

		stateManager.onGameTick();

		if (stateManager.getCurrentArea() == null)
		{
			if (navigationManager != null)
			{
				navigationManager.clearPathAndTarget();
			}
			client.clearHintArrow();
			return;
		}

		InventoryState inventoryState = InventoryState.NO_LIGHT_BULBS.getInventoryState(client);
		WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

		navigationManager.update(stateManager.getLampStatuses(), stateManager.getLampWallCache(), inventoryState,
				playerLocation, stateManager.getWireMachine());

		client.clearHintArrow();
	}

	@Provides
	DKLightsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(DKLightsConfig.class);
	}
}


package com.dklights.enums;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Area
{
	P0_N("North Ground Floor"),
	P0_S("South Ground Floor"),
	P1_N("North Second Floor"),
	P1_S("South Second Floor"),
	P2_N("North Third Floor"),
	P2_S("South Third Floor");

	private final String name;

	public Area getOpposite()
	{
		switch (this)
		{
		case P0_N:
			return P0_S;
		case P0_S:
			return P0_N;
		case P1_N:
			return P1_S;
		case P1_S:
			return P1_N;
		case P2_N:
			return P2_S;
		case P2_S:
			return P2_N;
		default:
			return null;
		}
	}

    public final String getName() {
        return name;
    }
}

package com.dklights.enums;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum TargetType
{
	NONE("None"),
	LAMP("Lamp"),
	BANK("Bank"),
	WIRING_MACHINE("Wiring machine");

	private final String displayName;
}

package com.dklights.enums;

public enum DisplayFloorType
{
	NONE,
	CURRENT_FLOOR,
	ALL_FLOORS
}

package com.dklights.enums;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.coords.WorldPoint;

@Getter
@RequiredArgsConstructor
public enum Transport
{
	TRANSPORT_22931_2705_5363_0(new WorldPoint(2705, 5363, 0), new WorldPoint(2705, 5366, 1), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22931_2706_5363_0(new WorldPoint(2706, 5363, 0), new WorldPoint(2705, 5366, 1), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22933_2705_5366_1(new WorldPoint(2705, 5366, 1), new WorldPoint(2705, 5363, 0), "Climb-down", "Stairs",
			22933, 1),
	TRANSPORT_22933_2706_5366_1(new WorldPoint(2706, 5366, 1), new WorldPoint(2705, 5363, 0), "Climb-down", "Stairs",
			22933, 1),
	TRANSPORT_22939_2720_5358_0(new WorldPoint(2720, 5358, 0), new WorldPoint(2720, 5361, 1), "Climb-up", "Stairs",
			22939, 1),
	TRANSPORT_22939_2721_5358_0(new WorldPoint(2721, 5358, 0), new WorldPoint(2720, 5361, 1), "Climb-up", "Stairs",
			22939, 1),
	TRANSPORT_22940_2720_5361_1(new WorldPoint(2720, 5361, 1), new WorldPoint(2720, 5358, 0), "Climb-down", "Stairs",
			22940, 1),
	TRANSPORT_22940_2721_5361_1(new WorldPoint(2721, 5361, 1), new WorldPoint(2720, 5358, 0), "Climb-down", "Stairs",
			22940, 1),
	TRANSPORT_22945_2747_5374_0(new WorldPoint(2747, 5374, 0), new WorldPoint(3317, 9603, 0), "Open", "Bone door",
			22945, 1),
	TRANSPORT_22945_2748_5374_0(new WorldPoint(2748, 5374, 0), new WorldPoint(3317, 9603, 0), "Open", "Bone door",
			22945, 1),
	TRANSPORT_6919_3317_9602_0(new WorldPoint(3317, 9602, 0), new WorldPoint(2747, 5374, 0), "Open", "Door", 6919, 1),
	TRANSPORT_6919_3318_9602_0(new WorldPoint(3318, 9602, 0), new WorldPoint(2748, 5374, 0), "Open", "Door", 6919, 1),
	TRANSPORT_22931_2736_5352_0(new WorldPoint(2736, 5352, 0), new WorldPoint(2733, 5351, 1), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22931_2736_5351_0(new WorldPoint(2736, 5351, 0), new WorldPoint(2733, 5351, 1), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22933_2733_5351_1(new WorldPoint(2733, 5351, 1), new WorldPoint(2736, 5351, 0), "Climb-down", "Stairs",
			22933, 1),
	TRANSPORT_22933_2733_5352_1(new WorldPoint(2733, 5352, 1), new WorldPoint(2736, 5351, 0), "Climb-down", "Stairs",
			22933, 1),
	TRANSPORT_22937_2727_5347_0(new WorldPoint(2727, 5347, 0), new WorldPoint(2731, 5346, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22937_2727_5346_0(new WorldPoint(2727, 5346, 0), new WorldPoint(2731, 5346, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22938_2731_5346_1(new WorldPoint(2731, 5346, 1), new WorldPoint(2727, 5346, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22938_2731_5347_1(new WorldPoint(2731, 5347, 1), new WorldPoint(2727, 5346, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22934_2694_5328_0(new WorldPoint(2694, 5328, 0), new WorldPoint(2694, 5328, 1), "Climb-up", "Ladder",
			22934, 2),
	TRANSPORT_22936_2694_5328_1(new WorldPoint(2694, 5328, 1), new WorldPoint(2694, 5328, 0), "Climb-down", "Ladder",
			22936, 2),
	TRANSPORT_22937_2705_5327_0(new WorldPoint(2705, 5327, 0), new WorldPoint(2701, 5327, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22937_2705_5328_0(new WorldPoint(2705, 5328, 0), new WorldPoint(2701, 5327, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22938_2701_5327_1(new WorldPoint(2701, 5327, 1), new WorldPoint(2705, 5327, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22938_2701_5328_1(new WorldPoint(2701, 5328, 1), new WorldPoint(2705, 5327, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22934_2738_5325_0(new WorldPoint(2738, 5325, 0), new WorldPoint(2738, 5325, 1), "Climb-up", "Ladder",
			22934, 2),
	TRANSPORT_22936_2738_5325_1(new WorldPoint(2738, 5325, 1), new WorldPoint(2738, 5325, 0), "Climb-down", "Ladder",
			22936, 2),
	TRANSPORT_22937_2705_5305_0(new WorldPoint(2705, 5305, 0), new WorldPoint(2701, 5305, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22937_2705_5306_0(new WorldPoint(2705, 5306, 0), new WorldPoint(2701, 5305, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22938_2701_5305_1(new WorldPoint(2701, 5305, 1), new WorldPoint(2705, 5305, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22938_2701_5306_1(new WorldPoint(2701, 5306, 1), new WorldPoint(2705, 5305, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22937_2730_5306_0(new WorldPoint(2730, 5306, 0), new WorldPoint(2734, 5306, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22937_2730_5307_0(new WorldPoint(2730, 5307, 0), new WorldPoint(2734, 5306, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22938_2734_5306_1(new WorldPoint(2734, 5306, 1), new WorldPoint(2730, 5306, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22938_2734_5307_1(new WorldPoint(2734, 5307, 1), new WorldPoint(2730, 5306, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22937_2729_5304_0(new WorldPoint(2729, 5304, 0), new WorldPoint(2729, 5300, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22937_2730_5304_0(new WorldPoint(2730, 5304, 0), new WorldPoint(2729, 5300, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22938_2729_5300_1(new WorldPoint(2729, 5300, 1), new WorldPoint(2729, 5304, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22938_2730_5300_1(new WorldPoint(2730, 5300, 1), new WorldPoint(2729, 5304, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22937_2713_5293_0(new WorldPoint(2713, 5293, 0), new WorldPoint(2709, 5293, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22937_2713_5294_0(new WorldPoint(2713, 5294, 0), new WorldPoint(2709, 5293, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22938_2709_5293_1(new WorldPoint(2709, 5293, 1), new WorldPoint(2713, 5293, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22938_2709_5294_1(new WorldPoint(2709, 5294, 1), new WorldPoint(2713, 5293, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22937_2721_5292_0(new WorldPoint(2721, 5292, 0), new WorldPoint(2725, 5292, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22937_2721_5293_0(new WorldPoint(2721, 5293, 0), new WorldPoint(2725, 5292, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22938_2725_5292_1(new WorldPoint(2725, 5292, 1), new WorldPoint(2721, 5292, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22938_2725_5293_1(new WorldPoint(2725, 5293, 1), new WorldPoint(2721, 5292, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22937_2713_5285_0(new WorldPoint(2713, 5285, 0), new WorldPoint(2713, 5281, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22937_2714_5285_0(new WorldPoint(2714, 5285, 0), new WorldPoint(2713, 5281, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22938_2713_5281_1(new WorldPoint(2713, 5281, 1), new WorldPoint(2713, 5285, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22938_2714_5281_1(new WorldPoint(2714, 5281, 1), new WorldPoint(2713, 5285, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22937_2713_5277_0(new WorldPoint(2713, 5277, 0), new WorldPoint(2713, 5281, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22937_2714_5277_0(new WorldPoint(2714, 5277, 0), new WorldPoint(2713, 5281, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22938_2713_5281_1_TO_2713_5277_0(new WorldPoint(2713, 5281, 1), new WorldPoint(2713, 5277, 0),
			"Climb-down", "Stairs", 22938, 1),
	TRANSPORT_22938_2714_5281_1_TO_2713_5277_0(new WorldPoint(2714, 5281, 1), new WorldPoint(2713, 5277, 0),
			"Climb-down", "Stairs", 22938, 1),
	TRANSPORT_22934_2708_5275_0(new WorldPoint(2708, 5275, 0), new WorldPoint(2708, 5275, 1), "Climb-up", "Ladder",
			22934, 2),
	TRANSPORT_22936_2708_5275_1(new WorldPoint(2708, 5275, 1), new WorldPoint(2708, 5275, 0), "Climb-down", "Ladder",
			22936, 2),
	TRANSPORT_22937_2722_5276_0(new WorldPoint(2722, 5276, 0), new WorldPoint(2722, 5272, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22937_2723_5276_0(new WorldPoint(2723, 5276, 0), new WorldPoint(2722, 5272, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22938_2722_5272_1(new WorldPoint(2722, 5272, 1), new WorldPoint(2722, 5276, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22938_2723_5272_1(new WorldPoint(2723, 5272, 1), new WorldPoint(2722, 5276, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22931_2733_5275_0(new WorldPoint(2733, 5275, 0), new WorldPoint(2733, 5278, 1), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22931_2734_5275_0(new WorldPoint(2734, 5275, 0), new WorldPoint(2733, 5278, 1), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22932_2733_5278_1(new WorldPoint(2733, 5278, 1), new WorldPoint(2733, 5275, 0), "Climb-down", "Stairs",
			22932, 1),
	TRANSPORT_22932_2734_5278_1(new WorldPoint(2734, 5278, 1), new WorldPoint(2733, 5275, 0), "Climb-down", "Stairs",
			22932, 1),
	TRANSPORT_22937_2738_5277_0(new WorldPoint(2738, 5277, 0), new WorldPoint(2738, 5281, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22937_2739_5277_0(new WorldPoint(2739, 5277, 0), new WorldPoint(2738, 5281, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22938_2738_5281_1(new WorldPoint(2738, 5281, 1), new WorldPoint(2738, 5277, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22938_2739_5281_1(new WorldPoint(2739, 5281, 1), new WorldPoint(2738, 5277, 0), "Climb-down", "Stairs",
			22938, 1),
	TRANSPORT_22937_2722_5268_0(new WorldPoint(2722, 5268, 0), new WorldPoint(2722, 5272, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22937_2723_5268_0(new WorldPoint(2723, 5268, 0), new WorldPoint(2722, 5272, 1), "Climb-up", "Stairs",
			22937, 1),
	TRANSPORT_22938_2722_5272_1_TO_2722_5268_0(new WorldPoint(2722, 5272, 1), new WorldPoint(2722, 5268, 0),
			"Climb-down", "Stairs", 22938, 1),
	TRANSPORT_22938_2723_5272_1_TO_2722_5268_0(new WorldPoint(2723, 5272, 1), new WorldPoint(2722, 5268, 0),
			"Climb-down", "Stairs", 22938, 1),
	TRANSPORT_22939_2722_5260_0(new WorldPoint(2722, 5260, 0), new WorldPoint(2722, 5257, 1), "Climb-up", "Stairs",
			22939, 1),
	TRANSPORT_22939_2723_5260_0(new WorldPoint(2723, 5260, 0), new WorldPoint(2722, 5257, 1), "Climb-up", "Stairs",
			22939, 1),
	TRANSPORT_22940_2722_5257_1(new WorldPoint(2722, 5257, 1), new WorldPoint(2722, 5260, 0), "Climb-down", "Stairs",
			22940, 1),
	TRANSPORT_22940_2723_5257_1(new WorldPoint(2723, 5257, 1), new WorldPoint(2722, 5260, 0), "Climb-down", "Stairs",
			22940, 1),
	TRANSPORT_22934_2703_5363_1(new WorldPoint(2703, 5363, 1), new WorldPoint(2703, 5363, 2), "Climb-up", "Ladder",
			22934, 2),
	TRANSPORT_22935_2703_5363_2(new WorldPoint(2703, 5363, 2), new WorldPoint(2703, 5363, 1), "Climb-down", "Ladder",
			22935, 2),
	TRANSPORT_22931_2740_5359_1(new WorldPoint(2740, 5359, 1), new WorldPoint(2740, 5362, 2), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22931_2741_5359_1(new WorldPoint(2741, 5359, 1), new WorldPoint(2740, 5362, 2), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22932_2740_5362_2(new WorldPoint(2740, 5362, 2), new WorldPoint(2740, 5359, 1), "Climb-down", "Stairs",
			22932, 1),
	TRANSPORT_22932_2741_5362_2(new WorldPoint(2741, 5362, 2), new WorldPoint(2740, 5359, 1), "Climb-down", "Stairs",
			22932, 1),
	TRANSPORT_22934_2745_5355_1(new WorldPoint(2745, 5355, 1), new WorldPoint(2745, 5355, 2), "Climb-up", "Ladder",
			22934, 1),
	TRANSPORT_22935_2745_5355_2(new WorldPoint(2745, 5355, 2), new WorldPoint(2745, 5355, 1), "Climb-down", "Ladder",
			22935, 1),
	TRANSPORT_22931_2698_5304_1(new WorldPoint(2698, 5304, 1), new WorldPoint(2695, 5304, 2), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22932_2695_5304_2(new WorldPoint(2695, 5304, 2), new WorldPoint(2698, 5304, 1), "Climb-down", "Stairs",
			22932, 1),
	TRANSPORT_22931_2739_5296_1(new WorldPoint(2739, 5296, 1), new WorldPoint(2742, 5296, 2), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22932_2742_5296_2(new WorldPoint(2742, 5296, 2), new WorldPoint(2739, 5296, 1), "Climb-down", "Stairs",
			22932, 1),
	TRANSPORT_22931_2696_5291_1(new WorldPoint(2696, 5291, 1), new WorldPoint(2696, 5294, 2), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22931_2697_5291_1(new WorldPoint(2697, 5291, 1), new WorldPoint(2696, 5294, 2), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22932_2696_5294_2(new WorldPoint(2696, 5294, 2), new WorldPoint(2696, 5291, 1), "Climb-down", "Stairs",
			22932, 1),
	TRANSPORT_22932_2697_5294_2(new WorldPoint(2697, 5294, 2), new WorldPoint(2696, 5291, 1), "Climb-down", "Stairs",
			22932, 1),
	TRANSPORT_22931_2743_5286_1(new WorldPoint(2743, 5286, 1), new WorldPoint(2743, 5289, 2), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22932_2743_5289_2(new WorldPoint(2743, 5289, 2), new WorldPoint(2743, 5286, 1), "Climb-down", "Stairs",
			22932, 1),
	TRANSPORT_22931_2739_5260_1(new WorldPoint(2739, 5260, 1), new WorldPoint(2739, 5257, 2), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22931_2740_5260_1(new WorldPoint(2740, 5260, 1), new WorldPoint(2739, 5257, 2), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22932_2739_5257_2(new WorldPoint(2739, 5257, 2), new WorldPoint(2739, 5260, 1), "Climb-down", "Stairs",
			22932, 1),
	TRANSPORT_22932_2740_5257_2(new WorldPoint(2740, 5257, 2), new WorldPoint(2739, 5260, 1), "Climb-down", "Stairs",
			22932, 1),
	TRANSPORT_22941_2722_5255_1(new WorldPoint(2722, 5255, 1), new WorldPoint(2722, 5249, 3), "Climb-up", "Stairs",
			22941, 1),
	TRANSPORT_22941_2723_5255_1(new WorldPoint(2723, 5255, 1), new WorldPoint(2722, 5249, 3), "Climb-up", "Stairs",
			22941, 1),
	TRANSPORT_22942_2722_5249_3(new WorldPoint(2722, 5249, 3), new WorldPoint(2722, 5255, 1), "Climb-down", "Stairs",
			22942, 1),
	TRANSPORT_22942_2723_5249_3(new WorldPoint(2723, 5249, 3), new WorldPoint(2722, 5255, 1), "Climb-down", "Stairs",
			22942, 1),
	TRANSPORT_22600_2715_5241_0(new WorldPoint(2715, 5241, 0), new WorldPoint(2719, 5241, 3), "Climb-up", "Ladder",
			22600, 2),
	TRANSPORT_22666_2719_5241_3(new WorldPoint(2719, 5241, 3), new WorldPoint(2715, 5241, 0), "Climb-down",
			"Ladder top", 22666, 2),
	TRANSPORT_22666_2719_5242_3(new WorldPoint(2719, 5242, 3), new WorldPoint(2715, 5241, 0), "Climb-down",
			"Ladder top", 22666, 2),
	TRANSPORT_22931_2735_5366_1(new WorldPoint(2735, 5366, 1), new WorldPoint(2738, 5366, 2), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22931_2735_5367_1(new WorldPoint(2735, 5367, 1), new WorldPoint(2738, 5366, 2), "Climb-up", "Stairs",
			22931, 1),
	TRANSPORT_22932_2738_5366_2(new WorldPoint(2738, 5366, 2), new WorldPoint(2735, 5366, 1), "Climb-down", "Stairs",
			22932, 1),
	TRANSPORT_22932_2741_5367_2(new WorldPoint(2738, 5367, 2), new WorldPoint(2735, 5366, 1), "Climb-down", "Stairs",
			22932, 1);

	private final WorldPoint origin;
	private final WorldPoint destination;
	private final String menuOption;
	private final String menuTarget;
	private final int objectId;
	private final int duration;
}

package com.dklights.enums;

import com.dklights.DKLightsConstants;

import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;

public enum InventoryState
{
	NO_LIGHT_BULBS,
	ONLY_EMPTY_BULBS,
	HAS_WORKING_BULBS;

	public InventoryState getInventoryState(Client client)
	{
		ItemContainer inventory = client.getItemContainer(DKLightsConstants.INVENTORY_ID);
		if (inventory == null)
		{
			return InventoryState.NO_LIGHT_BULBS;
		}

		boolean hasWorkingBulbs = false;
		boolean hasEmptyBulbs = false;

		for (Item item : inventory.getItems())
		{
			if (item.getId() == DKLightsConstants.LIGHT_BULB_WORKING)
			{
				hasWorkingBulbs = true;
			}
			else if (item.getId() == DKLightsConstants.LIGHT_BULB_EMPTY)
			{
				hasEmptyBulbs = true;
			}
		}

		if (hasWorkingBulbs)
		{
			return HAS_WORKING_BULBS;
		}
		else if (hasEmptyBulbs)
		{
			return ONLY_EMPTY_BULBS;
		}
		else
		{
			return NO_LIGHT_BULBS;
		}
	}
}

package com.dklights.enums;

public enum HighlightType
{
	BORDER,
	CLICKBOX
}

package com.dklights.enums;

public enum LampStatus
{
	BROKEN,
	WORKING,
	UNKNOWN,
}
package com.dklights.enums;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.coords.WorldPoint;

@Getter
@RequiredArgsConstructor
public enum Lamp
{

	// Plane 0 North
	P0_N_LAMP_5(5, 23025, new WorldPoint(2691, 5328, 0), Area.P0_N, "Room just NW of the market"),
	P0_N_LAMP_6(6, 23035, new WorldPoint(2746, 5323, 0), Area.P0_N, "Group of rooms just NE of the market"),
	P0_N_LAMP_7(7, 23036, new WorldPoint(2749, 5329, 0), Area.P0_N, "Group of rooms just NE of the market"),
	P0_N_LAMP_8(8, 23037, new WorldPoint(2742, 5327, 0), Area.P0_N, "Group of rooms just NE of the market"),
	P0_N_LAMP_9(9, 23038, new WorldPoint(2737, 5324, 0), Area.P0_N, "Group of rooms just NE of the market"),
	P0_N_LAMP_10(10, 23026, new WorldPoint(2701, 5345, 0), Area.P0_N, "Bank area"),
	P0_N_LAMP_11(11, 23027, new WorldPoint(2706, 5354, 0), Area.P0_N, "Bank area"),
	P0_N_LAMP_12(12, 23028, new WorldPoint(2701, 5362, 0), Area.P0_N, "Oldak's teleportation lab"),
	P0_N_LAMP_13(13, 23029, new WorldPoint(2706, 5369, 0), Area.P0_N, "Oldak's teleportation lab"),
	P0_N_LAMP_14(14, 23030, new WorldPoint(2745, 5360, 0), Area.P0_N, "NE most room"),
	P0_N_LAMP_15(15, 23031, new WorldPoint(2739, 5360, 0), Area.P0_N, "NE most room"),
	P0_N_LAMP_16(16, 23032, new WorldPoint(2736, 5350, 0), Area.P0_N, "Room east of the bank area"),
	P0_N_LAMP_17(17, 23033, new WorldPoint(2747, 5348, 0), Area.P0_N, "Group of rooms just NE of the market"),
	P0_N_LAMP_18(18, 23034, new WorldPoint(2741, 5344, 0), Area.P0_N, "Group of rooms just NE of the market"),
	P0_N_LAMP_19(19, 23039, new WorldPoint(2744, 5348, 0), Area.P0_N, "Group of rooms just NE of the market"),

	// Plane 0 South
	P0_S_LAMP_0(0, 22988, new WorldPoint(2738, 5283, 0), Area.P0_S, "Group of rooms just SE of the market"),
	P0_S_LAMP_1(1, 22989, new WorldPoint(2749, 5292, 0), Area.P0_S, "Group of rooms just SE of the market"),
	P0_S_LAMP_2(2, 22992, new WorldPoint(2744, 5299, 0), Area.P0_S, "Group of rooms just SE of the market"),
	P0_S_LAMP_3(3, 22993, new WorldPoint(2690, 5302, 0), Area.P0_S, "Group of rooms just SW of the market"),
	P0_S_LAMP_4(4, 22996, new WorldPoint(2698, 5302, 0), Area.P0_S, "Group of rooms just SW of the market"),
	P0_S_LAMP_10(10, 22978, new WorldPoint(2699, 5256, 0), Area.P0_S, "SW most group of rooms"),
	P0_S_LAMP_11(11, 22979, new WorldPoint(2695, 5260, 0), Area.P0_S, "SW most group of rooms"),
	P0_S_LAMP_12(12, 22981, new WorldPoint(2698, 5269, 0), Area.P0_S, "SW most group of rooms"),
	P0_S_LAMP_13(13, 22982, new WorldPoint(2735, 5278, 0), Area.P0_S, "Eastern house in south part of the city"),
	P0_S_LAMP_14(14, 22983, new WorldPoint(2739, 5253, 0), Area.P0_S, "SE most group of rooms"),
	P0_S_LAMP_15(15, 22985, new WorldPoint(2749, 5261, 0), Area.P0_S, "SE most group of rooms"),
	P0_S_LAMP_16(16, 22997, new WorldPoint(2707, 5274, 0), Area.P0_S, "House just west of the wire machine"),
	
	// Plane 1 North
	P1_N_LAMP_5(5, 23010, new WorldPoint(2693, 5331, 1), Area.P1_N, "Western house with a garden"),
	P1_N_LAMP_6(6, 23017, new WorldPoint(2742, 5335, 1), Area.P1_N, "Nursery"),
	P1_N_LAMP_7(7, 23018, new WorldPoint(2738, 5324, 1), Area.P1_N, "House south of the nursery"),
	P1_N_LAMP_8(8, 23024, new WorldPoint(2693, 5333, 1), Area.P1_N, "Western house with a garden"),
	P1_N_LAMP_9(9, 23040, new WorldPoint(2742, 5341, 1), Area.P1_N, "Nursery"),
	P1_N_LAMP_10(10, 23011, new WorldPoint(2697, 5344, 1), Area.P1_N, "Western house north of the garden house"),
	P1_N_LAMP_11(11, 23012, new WorldPoint(2705, 5354, 1), Area.P1_N, "House just south of Oldak's lab"),
	P1_N_LAMP_12(12, 23013, new WorldPoint(2716, 5364, 1), Area.P1_N, "Council chamber"),
	P1_N_LAMP_13(13, 23014, new WorldPoint(2736, 5363, 1), Area.P1_N, "House with Ur-tag"),
	P1_N_LAMP_14(14, 23015, new WorldPoint(2739, 5362, 1), Area.P1_N, "House just east of Ur-tag"),
	P1_N_LAMP_15(15, 23016, new WorldPoint(2733, 5350, 1), Area.P1_N, "House just south of Ur-tag"),
	P1_N_LAMP_16(16, 23023, new WorldPoint(2705, 5348, 1), Area.P1_N, "House just south of Oldak's lab"),
	P1_N_LAMP_17(17, 23041, new WorldPoint(2701, 5366, 1), Area.P1_N, "Upstairs of Oldak's teleportation lab"),

	// Plane 1 South
	P1_S_LAMP_0(0, 22990, new WorldPoint(2699, 5305, 1), Area.P1_S, "Western house"),
	P1_S_LAMP_1(1, 22991, new WorldPoint(2739, 5286, 1), Area.P1_S, "Eastern house"),
	P1_S_LAMP_2(2, 22994, new WorldPoint(2737, 5294, 1), Area.P1_S, "Eastern house"),
	P1_S_LAMP_3(3, 22999, new WorldPoint(2741, 5283, 1), Area.P1_S, "Eastern house"),
	P1_S_LAMP_4(4, 23005, new WorldPoint(2695, 5294, 1), Area.P1_S, "Western house"),
	P1_S_LAMP_10(10, 22986, new WorldPoint(2736, 5272, 1), Area.P1_S, "Upstairs of the eastern house in the south part of the city"),
	P1_S_LAMP_11(11, 23000, new WorldPoint(2731, 5272, 1), Area.P1_S, "Upstairs of the eastern house in the south part of the city"),
	P1_S_LAMP_12(12, 23001, new WorldPoint(2736, 5278, 1), Area.P1_S, "Upstairs of the eastern house in the south part of the city"),
	P1_S_LAMP_13(13, 23002, new WorldPoint(2709, 5270, 1), Area.P1_S, "Upstairs of the house west of the wire machine"),
	P1_S_LAMP_14(14, 23003, new WorldPoint(2707, 5278, 1), Area.P1_S, "Upstairs of the house west of the wire machine"),

	// Plane 2 North
	P2_N_LAMP_9(9, 23019, new WorldPoint(2746, 5355, 2), Area.P2_N, "Zanik's bedroom"),
	P2_N_LAMP_10(10, 23020, new WorldPoint(2739, 5362, 2), Area.P2_N, "Upstairs of the house just east of Ur-tag"),
	P2_N_LAMP_11(11, 23021, new WorldPoint(2736, 5363, 2), Area.P2_N, "Upstairs of the house with Ur-tag"),
	P2_N_LAMP_12(12, 23022, new WorldPoint(2729, 5368, 2), Area.P2_N, "Upstairs of the house with Ur-tag"),

	// Plane 2 South
	P2_S_LAMP_0(0, 22984, new WorldPoint(2741, 5283, 2), Area.P2_S, "Upstairs of the eastern house two houses south of the empty building"),
	P2_S_LAMP_1(1, 22987, new WorldPoint(2737, 5298, 2), Area.P2_S, "Upstairs of the eastern house just south of the empty building"),
	P2_S_LAMP_2(2, 22995, new WorldPoint(2741, 5294, 2), Area.P2_S, "Upstairs of the eastern house just south of the empty building"),
	P2_S_LAMP_3(3, 22998, new WorldPoint(2741, 5287, 2), Area.P2_S, "Upstairs of the eastern house two houses south of the empty building"),
	P2_S_LAMP_4(4, 23004, new WorldPoint(2744, 5282, 2), Area.P2_S, "Upstairs of the eastern house two houses south of the empty building"),
	P2_S_LAMP_5(5, 23006, new WorldPoint(2695, 5294, 2), Area.P2_S, "Upstairs of the western house just north of the train station"),
	P2_S_LAMP_6(6, 23007, new WorldPoint(2699, 5289, 2), Area.P2_S, "Upstairs of the western house just north of the train station"),
	P2_S_LAMP_7(7, 23008, new WorldPoint(2699, 5305, 2), Area.P2_S, "Upstairs of the western house two houses north of the train station"),
	P2_S_LAMP_8(8, 23009, new WorldPoint(2695, 5301, 2), Area.P2_S, "Upstairs of the western house two houses north of the train station"),
	P2_S_LAMP_9(9, 22980, new WorldPoint(2740, 5264, 2), Area.P2_S, "Upstairs of the SE most house");

	private final int bitPosition;
	private final int objectId;
	private final WorldPoint worldPoint;
	private final Area area;
	private final String description;
}

package com.dklights.enums;

import java.util.List;

public enum Direction
{
	WEST(-1, 0),
	EAST(1, 0),
	SOUTH(0, -1),
	NORTH(0, 1),
	SOUTH_WEST(-1, -1),
	SOUTH_EAST(1, -1),
	NORTH_WEST(-1, 1),
	NORTH_EAST(1, 1);

	final int x;
	final int y;

	Direction(int x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public int getX()
	{
		return x;
	}

	public int getY()
	{
		return y;
	}

	public boolean isDiagonal()
	{
		return this == SOUTH_WEST || this == SOUTH_EAST || this == NORTH_WEST || this == NORTH_EAST;
	}

	public static List<Direction> getCardinalDirections()
	{
		return java.util.Arrays.asList(NORTH, EAST, SOUTH, WEST);
	}
}
package com.dklights.enums;

public enum TimerType
{
	PIE,
	TICKS,
	SECONDS
}

package com.dklights.enums;

public enum PathDrawStyle
{
	TILES,
	CENTER_LINE,
	TILE_BORDERS
}

package com.dklights;

import com.dklights.enums.Area;
import com.dklights.enums.Lamp;
import com.dklights.enums.LampStatus;
import com.dklights.enums.Transport;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Sets;

import java.util.Collections;
import java.util.EnumMap;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import net.runelite.api.coords.WorldPoint;

public class DKLightsHelper
{
	private static final Map<Area, Set<Lamp>> LAMPS_BY_AREA;
	private static final Map<Integer, Set<Lamp>> LAMPS_BY_BIT_POSITION;
	private static final Map<Integer, Lamp> LAMPS_BY_OBJECT_ID;
	private static final Map<WorldPoint, Lamp> LAMPS_BY_WORLD_POINT;

	private static final Map<Area, Set<Integer>> BIT_POSITIONS_BY_AREA;
	private static final Map<Area, Integer> MAX_BIT_BY_AREA;

	static
	{
		ImmutableMap.Builder<Area, Set<Lamp>> areaBuilder = new ImmutableMap.Builder<>();
		for (Area area : Area.values())
		{
			Set<Lamp> lampsInArea = Sets.immutableEnumSet(java.util.Arrays.stream(Lamp.values())
					.filter(lamp -> lamp.getArea() == area).collect(Collectors.toSet()));
			areaBuilder.put(area, lampsInArea);
		}
		LAMPS_BY_AREA = areaBuilder.build();

		ImmutableMap.Builder<Integer, Set<Lamp>> bitBuilder = new ImmutableMap.Builder<>();
		for (int i = 0; i < 32; i++)
		{
			final int bit = i;
			Set<Lamp> lampsForBit = Sets.immutableEnumSet(java.util.Arrays.stream(Lamp.values())
					.filter(lamp -> lamp.getBitPosition() == bit).collect(Collectors.toSet()));
			if (!lampsForBit.isEmpty())
			{
				bitBuilder.put(i, lampsForBit);
			}
		}
		LAMPS_BY_BIT_POSITION = bitBuilder.build();

		ImmutableMap.Builder<Integer, Lamp> idBuilder = new ImmutableMap.Builder<>();
		ImmutableMap.Builder<WorldPoint, Lamp> wpBuilder = new ImmutableMap.Builder<>();
		for (Lamp lamp : Lamp.values())
		{
			idBuilder.put(lamp.getObjectId(), lamp);
			wpBuilder.put(lamp.getWorldPoint(), lamp);
		}
		LAMPS_BY_OBJECT_ID = idBuilder.build();
		LAMPS_BY_WORLD_POINT = wpBuilder.build();

		ImmutableMap.Builder<Area, Set<Integer>> bitPosBuilder = new ImmutableMap.Builder<>();
		ImmutableMap.Builder<Area, Integer> maxBitBuilder = new ImmutableMap.Builder<>();
		for (Area area : Area.values())
		{
			Set<Lamp> lamps = LAMPS_BY_AREA.get(area);
			if (lamps == null || lamps.isEmpty())
			{
				bitPosBuilder.put(area, Collections.emptySet());
				maxBitBuilder.put(area, 0);
				continue;
			}

			Set<Integer> bits = lamps.stream().map(Lamp::getBitPosition).collect(Collectors.toSet());
			bitPosBuilder.put(area, bits);

			int maxBit = lamps.stream().mapToInt(Lamp::getBitPosition).max().orElse(0);
			maxBitBuilder.put(area, maxBit);
		}
		BIT_POSITIONS_BY_AREA = bitPosBuilder.build();
		MAX_BIT_BY_AREA = maxBitBuilder.build();
	}

	public static Set<Lamp> getLampsByArea(Area area)
	{
		return LAMPS_BY_AREA.getOrDefault(area, Collections.emptySet());
	}

	public static Area getArea(WorldPoint worldPoint)
	{
		int plane = worldPoint.getPlane();
		int y = worldPoint.getY();
		int x = worldPoint.getX();

		if (x < DKLightsConstants.DK_WEST_VALUE || x > DKLightsConstants.DK_EAST_VALUE
				|| y > DKLightsConstants.DK_NORTH_VALUE || y < DKLightsConstants.DK_SOUTH_VALUE)
		{
			return null;
		}

		if (plane == 0)
		{
			return y >= DKLightsConstants.WORLD_MAP_LINE ? Area.P0_N : Area.P0_S;
		}
		else if (plane == 1)
		{
			return y >= DKLightsConstants.WORLD_MAP_LINE ? Area.P1_N : Area.P1_S;
		}
		else if (plane == 2)
		{
			return y >= DKLightsConstants.WORLD_MAP_LINE ? Area.P2_N : Area.P2_S;
		}
		return null;
	}

	public static Lamp getLamp(int objectId)
	{
		return LAMPS_BY_OBJECT_ID.get(objectId);
	}

	public static Lamp getLamp(WorldPoint worldPoint)
	{
		return LAMPS_BY_WORLD_POINT.get(worldPoint);
	}

	public static boolean isLamp(int objectId)
	{
		return LAMPS_BY_OBJECT_ID.containsKey(objectId);
	}

	public static Set<Lamp> getBrokenLamps(int varbitValue, Area currentArea)
	{
		Set<Lamp> brokenLamps = Sets.newEnumSet(Collections.emptySet(), Lamp.class);
		if (currentArea == null)
		{
			return brokenLamps;
		}

		Area oppositeArea = currentArea.getOpposite();
		Set<Lamp> lampsInCurrentArea = getLampsByArea(currentArea);
		Set<Lamp> lampsInOppositeArea = getLampsByArea(oppositeArea);

		int maxBitPosition = MAX_BIT_BY_AREA.getOrDefault(currentArea, 0);

		for (int i = 0; i <= maxBitPosition; i++)
		{
			if ((varbitValue & (1 << i)) != 0)
			{
				Set<Lamp> lampsForBit = LAMPS_BY_BIT_POSITION.getOrDefault(i, Collections.emptySet());

				Lamp lampToAdd = null;
				for (Lamp lamp : lampsForBit)
				{
					if (lampsInCurrentArea.contains(lamp))
					{
						lampToAdd = lamp;
						break;
					}

					if (lampsInOppositeArea.contains(lamp))
					{
						lampToAdd = lamp;
					}
				}

				if (lampToAdd != null)
				{
					brokenLamps.add(lampToAdd);
				}
			}
		}

		return brokenLamps;
	}

	public static Set<Lamp> getValidOppositeLamps(Area currentArea)
	{
		Area oppositeArea = currentArea.getOpposite();
		if (oppositeArea == null)
		{
			return Collections.emptySet();
		}

		Set<Lamp> lampsInOppositeArea = getLampsByArea(oppositeArea);

		int maxBitPosition = MAX_BIT_BY_AREA.getOrDefault(currentArea, 0);
		Set<Integer> currentAreaBitPositions = BIT_POSITIONS_BY_AREA.getOrDefault(currentArea, Collections.emptySet());

		return lampsInOppositeArea.stream().filter(lamp -> lamp.getBitPosition() <= maxBitPosition
				&& !currentAreaBitPositions.contains(lamp.getBitPosition())).collect(Collectors.toSet());
	}

	public static Map<Lamp, LampStatus> updateLampStatuses(Map<Lamp, LampStatus> lampStatuses, Set<Lamp> brokenLamps,
			boolean isLampsFixed, Area currentArea)
	{

		Map<Lamp, LampStatus> updatedStatuses = new EnumMap<>(lampStatuses);

		Set<Lamp> lampsInCurrentArea = getLampsByArea(currentArea);
		for (Lamp lamp : lampsInCurrentArea)
		{
			updatedStatuses.put(lamp, brokenLamps.contains(lamp) ? LampStatus.BROKEN : LampStatus.WORKING);
		}

		Area oppositeArea = currentArea.getOpposite();
		if (oppositeArea != null)
		{
			Set<Lamp> validOppositeLamps = getValidOppositeLamps(currentArea);
			for (Lamp lamp : validOppositeLamps)
			{
				updatedStatuses.put(lamp, brokenLamps.contains(lamp) ? LampStatus.BROKEN : LampStatus.WORKING);
			}

			if (isLampsFixed)
			{
				for (Lamp lamp : Lamp.values())
				{
					Area lampArea = lamp.getArea();
					if (lampArea != currentArea && lampArea != oppositeArea)
					{
						LampStatus status = updatedStatuses.get(lamp);
						if (status == LampStatus.WORKING)
						{
							updatedStatuses.put(lamp, LampStatus.UNKNOWN);
						}
					}
				}
			}
		}
		autoFixAllLampsIfNeeded(updatedStatuses);

		return updatedStatuses;
	}

	public static int countBrokenLamps(Map<Lamp, LampStatus> lampStatuses)
	{
		int totalBroken = 0;
		for (LampStatus status : lampStatuses.values())
		{
			if (status == LampStatus.BROKEN)
			{
				totalBroken++;
			}
		}
		return totalBroken;
	}

	public static void autoFixAllLampsIfNeeded(Map<Lamp, LampStatus> lampStatuses)
	{
		int totalBroken = countBrokenLamps(lampStatuses);

		if (totalBroken == 10)
		{
			for (Lamp lamp : Lamp.values())
			{
				if (lampStatuses.get(lamp) != LampStatus.BROKEN)
				{
					lampStatuses.put(lamp, LampStatus.WORKING);
				}
			}
		}
	}

	public static boolean areaHasUnknownLamps(Area area, Map<Lamp, LampStatus> lampStatuses)
	{
		if (area == null)
		{
			return false;
		}

		Set<Lamp> lampsInArea = getLampsByArea(area);
		for (Lamp lamp : lampsInArea)
		{
			LampStatus status = lampStatuses.getOrDefault(lamp, LampStatus.UNKNOWN);
			if (status == LampStatus.UNKNOWN)
			{
				return true;
			}
		}
		return false;
	}

	public static int countUnknownLampsInArea(Map<Lamp, LampStatus> lampStatuses, Area area)
	{
		if (area == null)
		{
			return 0;
		}

		int unknownCount = 0;
		Set<Lamp> lampsInArea = getLampsByArea(area);

		for (Lamp lamp : lampsInArea)
		{
			if (lampStatuses.getOrDefault(lamp, LampStatus.UNKNOWN) == LampStatus.UNKNOWN)
			{
				unknownCount++;
			}
		}
		return unknownCount;
	}

	public static boolean isInBankArea(WorldPoint playerLocation)
	{
		return playerLocation.distanceTo(DKLightsConstants.BANK_LOCATION) <= 5;
	}

	public static boolean isLocationBetweenTransportPoints(WorldPoint objectLocation, Transport transport)
	{
		WorldPoint origin = transport.getOrigin();
		WorldPoint destination = transport.getDestination();

		if (objectLocation.getPlane() != origin.getPlane() && objectLocation.getPlane() != destination.getPlane())
		{
			return false;
		}

		int objX = objectLocation.getX();
		int objY = objectLocation.getY();

		int minX = Math.min(origin.getX(), destination.getX());
		int maxX = Math.max(origin.getX(), destination.getX());
		int minY = Math.min(origin.getY(), destination.getY());
		int maxY = Math.max(origin.getY(), destination.getY());

		boolean xBetween = objX >= minX && objX <= maxX;
		boolean yBetween = objY >= minY && objY <= maxY;

		if (xBetween && yBetween)
		{
			return true;
		}

		boolean nearOrigin = Math.abs(objX - origin.getX()) <= 1 && Math.abs(objY - origin.getY()) <= 1;
		boolean nearDestination = Math.abs(objX - destination.getX()) <= 1 && Math.abs(objY - destination.getY()) <= 1;

		return nearOrigin && nearDestination;
	}
}

package com.dklights;

import java.awt.Color;

import com.dklights.enums.HighlightType;
import com.dklights.enums.PathDrawStyle;
import com.dklights.enums.TimerType;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup("dklights")
public interface DKLightsConfig extends Config {

    @ConfigItem(
		keyName = "showLegacyOverlay",
		name = "Show Legacy Overlay",
		description = "Show the legacy overlay with a list of broken lamps.",
		position = 1
	)
	default boolean showLegacyOverlay()
	{
		return false;
	}

	// --- Section: Pathfinding ---
	@ConfigSection(
		name = "Pathfinding",
		description = "Settings for pathfinding to lamps and utilities.",
		position = 2
	)
	String pathSection = "pathSection";

	@ConfigItem(
		keyName = "showPathToLocation",
		name = "Show Path",
		description = "Draw a tile path to the closest broken lamp or utility location (bank/wire machine).",
		section = pathSection,
		position = 1
	)
	default boolean showPathToLocation() 
	{
		return true;
	}

	@ConfigItem(
		keyName = "pathDrawStyle",
		name = "Path Draw Style",
		description = "The visual style of the drawn path.",
		section = pathSection,
		position = 2
	)
	default PathDrawStyle pathDrawStyle() 
	{
		return PathDrawStyle.TILES;
	}

	@ConfigItem(
		keyName = "pathColor",
		name = "Lamp Path Color",
		description = "Color of the path to the closest broken lamp.",
		section = pathSection,
		position = 3
	)
	default Color pathColor() 
	{
		return new Color(255, 102, 102);
	}

	@ConfigItem(
		keyName = "utilityPathColor",
		name = "Utility Path Color",
		description = "Color of the path to the bank or wire machine.",
		section = pathSection,
		position = 4
	)
	default Color utilityPathColor() 
	{
		return new Color(102, 255, 102);
	}

	@ConfigItem(
		keyName = "maxPathDistance",
		name = "Teleport Hint Distance",
		description = "Show a teleport hint if the path to the closest lamp is longer than this. 0 to disable.",
		section = pathSection,
		position = 5
	)
	default int maxPathDistance() 
	{
		return 64;
	}

	// --- Section: Lamp Highlights ---
	@ConfigSection(
		name = "Lamp Highlights",
		description = "Settings for highlighting Dorgesh-Kaan lamps.",
		position = 10
	)
	String lampsSection = "lampsSection";

	@ConfigItem(
		keyName = "lampsHighlightStyle",
		name = "Lamp Highlight Style",
		description = "Choose how to highlight lamps.",
		section = lampsSection,
		position = 1
	)
	default HighlightType lampsHighlightStyle()
	 {
		return HighlightType.CLICKBOX;
	}

	@ConfigItem(
		keyName = "highlightBrokenLamps",
		name = "Broken Lamps",
		description = "Highlight known broken lamps.",
		section = lampsSection,
		position = 2
	)
	default boolean highlightBrokenLamps() 
	{
		return true;
	}

	@ConfigItem(
		keyName = "brokenLampColor",
		name = "Broken Lamp Color",
		description = "Color for broken lamps.",
		section = lampsSection,
		position = 3
	)
	default Color getBrokenLampColor() 
	{
		return Color.RED;
	}

	@ConfigItem(
		keyName = "highlightWorkingLamps",
		name = "Working Lamps",
		description = "Highlight known working lamps.",
		section = lampsSection,
		position = 4
	)
	default boolean highlightWorkingLamps() 
	{
		return true;
	}

	@ConfigItem(
		keyName = "workingLampColor",
		name = "Working Lamp Color",
		description = "Color for working lamps.",
		section = lampsSection,
		position = 5
	)
	default Color getWorkingLampColor() 
	{
		return Color.GREEN;
	}

	@ConfigItem(
		keyName = "highlightAllLamps",
		name = "All Lamps",
		description = "Highlight all lamps.",
		section = lampsSection,
		position = 6
	)
	default boolean highlightAllLamps() 
	{
		return true;
	}

	@ConfigItem(
		keyName = "defaultLampColor",
		name = "Default Lamp Color",
		description = "Color for lamps when 'All Lamps' is enabled.",
		section = lampsSection,
		position = 7
	)
	default Color getDefaultLampColor() 
	{
		return Color.GRAY;
	}

	@ConfigItem(
		keyName = "highlightAllPlanesLamps",
		name = "Highlight Lamps on Other Floors",
		description = "Show highlights for lamps on different floors from you.",
		section = lampsSection,
		position = 8
	)
	default boolean highlightOtherPlanesLamps() 
	{
		return true;
	}

	@ConfigItem(
		keyName = "darkenOtherPlanesLamps",
		name = "Darken Lamps on Other Floors",
		description = "Darkens the highlight color for lamps on different floors. Requires 'Highlight Lamps on Other Floors' to be on.",
		section = lampsSection,
		position = 9
	)
	default boolean darkenOtherPlanesLamps() 
	{
		return true;
	}

	// --- Section: Other Highlights ---
	@ConfigSection(
		name = "Other Highlights",
		description = "Settings for highlighting objects like the wire machine, doors, and stairs.",
		position = 20
	)
	String hintsSection = "hintsSection";

	@ConfigItem(
		keyName = "objectsHighlightStyle",
		name = "Object Highlight Style",
		description = "Choose how to highlight objects (stairs, doors, wire machine).",
		section = hintsSection,
		position = 1
	)
	default HighlightType objectsHighlightStyle() 
	{
		return HighlightType.CLICKBOX;
	}

	@ConfigItem(
		keyName = "highlightWireMachine",
		name = "Highlight Wire Machine",
		description = "Highlight the wire machine and show a respawn timer.",
		section = hintsSection,
		position = 2
	)
	default boolean highlightWireMachine() 
	{
		return true;
	}

	@ConfigItem(
		keyName = "wireMachineHighlightColor",
		name = "Wire Machine Color",
		description = "The color to highlight the wire machine.",
		section = hintsSection,
		position = 3
	)
	default Color wireMachineHighlightColor() 
	{
		return Color.ORANGE;
	}

	@ConfigItem(
		keyName = "timerType",
		name = "Wire Machine Timer Style",
		description = "The UI style for displaying the respawn timer on the wire machine.",
		section = hintsSection,
		position = 4
	)
	default TimerType timerType() 
	{
		return TimerType.PIE;
	}

	@ConfigItem(
		keyName = "highlightInformativeStairs",
		name = "Highlight Informative Stairs",
		description = "Highlight stairs/ladders that lead to areas with unknown lamp information.",
		section = hintsSection,
		position = 5
	)
	default boolean highlightInformativeStairs() 
	{
		return true;
	}

	@ConfigItem(
		keyName = "informativeStairColor",
		name = "Informative Stair Color",
		description = "The color to highlight informative stairs/ladders.",
		section = hintsSection,
		position = 6
	)
	default Color informativeStairColor() 
	{
		return new Color(255, 102, 183);
	}

	@ConfigItem(
		keyName = "highlightClosedDoors",
		name = "Highlight All Closed Doors",
		description = "Highlights all closed doors in Dorgesh-Kaan, not just those on your path.",
		section = hintsSection,
		position = 7
	)
	default boolean highlightClosedDoors() 
	{
		return false;
	}

	@ConfigItem(
		keyName = "doorHighlightColor",
		name = "Door Highlight Color",
		description = "Color for the 'Highlight All Closed Doors' option.",
		section = hintsSection,
		position = 8
	)
	default Color doorHighlightColor() 
	{
		return Color.YELLOW;
	}

	// --- Section: UI & Overlays ---
	@ConfigSection(
		name = "UI & Overlays",
		description = "Settings for the side panel map and statistics overlay.",
		position = 30
	)
	String uiSection = "uiSection";

	@ConfigItem(
		keyName = "showStatsOverlay",
		name = "Show Stats Overlay",
		description = "Show the overlay with target, distance, and lamps/hr stats.",
		section = uiSection,
		position = 5
	)
	default boolean showStatsOverlay() 
	{
		return true;
	}

	@ConfigItem(
		keyName = "showClosestDistance",
		name = "Show Distance",
		description = "Show the 'Distance:' line in the Stats Overlay.",
		section = uiSection,
		position = 6
	)
	default boolean showClosestDistance() 
	{
		return true;
	}

	// --- Section: Global Highlight Styles ---
	@ConfigSection(
		name = "Global Highlight Styles",
		description = "General settings that affect all 'Border' style highlights.",
		position = 40
	)
	String highlightStyleSection = "highlightStyleSection";

	@Range(min = 1, max = 4)
	@ConfigItem(
		keyName = "borderThickness",
		name = "Border Thickness",
		description = "Thickness (in pixels) for border-style highlights.",
		section = highlightStyleSection,
		position = 1
	)
	default int borderThickness() 
	{
		return 2;
	}

	@Range(min = 0, max = 4)
	@ConfigItem(
		keyName = "borderFeather",
		name = "Border Feather",
		description = "Feathering amount for border-style highlights. 0 to disable.",
		section = highlightStyleSection,
		position = 2
	)
	default int borderFeather() 
	{
		return 0;
	}
}

/*
 * Copyright (c) 2020, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.dklights.overlay;

import com.dklights.DKLightsConfig;
import com.dklights.DKLightsPlugin;
import com.dklights.enums.Area;
import com.dklights.enums.Lamp;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.LinkedHashMap;
import java.util.Set;

import javax.inject.Inject;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;

public class LegacyOverlay extends OverlayPanel
{

	private final DKLightsPlugin plugin;
    private final DKLightsConfig config;

	@Inject
	private LegacyOverlay(DKLightsPlugin plugin, DKLightsConfig config)
	{
		super(plugin);
        this.config = config;
		this.plugin = plugin;

		setPosition(OverlayPosition.TOP_LEFT);
	}

	private void addTextToOverlayPanel(String text)
	{
		panelComponent.getChildren().add(LineComponent.builder().left(text).build());
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
        if (!config.showLegacyOverlay())
        {
            return null;
        }

		Set<Lamp> areaLampPoints = plugin.getStateManager().getBrokenLamps();
		Area currentArea = plugin.getStateManager().getCurrentArea();

		panelComponent.getChildren().clear();
		if (currentArea == null)
		{
			return null;
		}

		boolean addedText = false;
		if (areaLampPoints != null && areaLampPoints.size() != 10)
		{
			addTextToOverlayPanel("Unknown lights: " + (10 - areaLampPoints.size()));
		}
		for (Area area : Area.values())
		{
			LinkedHashMap<String, Integer> descriptionCount = new LinkedHashMap<>();
			for (Lamp l : areaLampPoints)
			{
				if (l.getArea() != area)
				{
					continue;
				}

				if (!descriptionCount.containsKey(l.getDescription()))
				{
					descriptionCount.put(l.getDescription(), 1);
				}
				else
				{
					descriptionCount.put(l.getDescription(), descriptionCount.get(l.getDescription()) + 1);
				}
			}

			if (descriptionCount.size() != 0)
			{
				addTextToOverlayPanel(area.getName());
			}
			for (String s : descriptionCount.keySet())
			{
				String num = " (x" + descriptionCount.get(s) + ")";
				if (descriptionCount.get(s) == 1)
				{
					num = "";
				}
				addTextToOverlayPanel("* " + s + num);
				addedText = true;
			}
		}

		if (!addedText)
		{
			addTextToOverlayPanel("No broken lamps in this area");
		}


		return super.render(graphics);
	}
}

package com.dklights.overlay;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.util.List;
import javax.inject.Inject;

import com.dklights.DKLightsConfig;
import com.dklights.DKLightsConstants;
import com.dklights.DKLightsPlugin;
import com.dklights.enums.TargetType;

import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;

public class TeleportOverlay extends WidgetItemOverlay
{
	private final DKLightsPlugin plugin;
	private final DKLightsConfig config;

	@Inject
	private TeleportOverlay(DKLightsPlugin plugin, DKLightsConfig config, ItemManager itemManager)
	{
		this.plugin = plugin;
		this.config = config;
		showOnInventory();
	}

	@Override
	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem itemWidget)
	{
		if (itemId != DKLightsConstants.TELEPORT_SPHERE_ID)
		{
			return;
		}

		List<WorldPoint> path = plugin.getNavigationManager().getShortestPath();

		if (path != null
				&& (path.size() > config.maxPathDistance() || plugin.getStateManager().getBrokenLamps().isEmpty())
				&& plugin.getNavigationManager().getCurrentTargetType() == TargetType.LAMP)
		{
			Rectangle bounds = itemWidget.getCanvasBounds();
			Color oldColor = graphics.getColor();

			Color base = config.pathColor();

			long phase = (System.currentTimeMillis() / 600) % 2;
			int alpha = (phase == 0) ? 64 : 192;

			graphics.setColor(new Color(base.getRed(), base.getGreen(), base.getBlue(), alpha));
			graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);

			graphics.setColor(oldColor);
		}
	}
}
package com.dklights.overlay;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Shape;
import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;

import com.dklights.DKLightsConfig;
import com.dklights.DKLightsConstants;
import com.dklights.DKLightsHelper;
import com.dklights.DKLightsPlugin;
import com.dklights.enums.HighlightType;
import com.dklights.enums.Lamp;
import com.dklights.enums.LampStatus;
import com.dklights.enums.PathDrawStyle;
import com.dklights.enums.TargetType;
import com.dklights.enums.TimerType;
import com.dklights.enums.Transport;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.TileObject;
import net.runelite.api.WallObject;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.components.ProgressPieComponent;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

@Slf4j
public class DKLightsOverlay extends Overlay
{

	private final Client client;
	private final DKLightsPlugin plugin;
	private final DKLightsConfig config;
	private final ModelOutlineRenderer modelOutlineRenderer;

	@Inject
	private DKLightsOverlay(Client client, DKLightsPlugin plugin, DKLightsConfig config,
			ModelOutlineRenderer modelOutlineRenderer)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		this.modelOutlineRenderer = modelOutlineRenderer;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (client.getLocalPlayer() == null)
		{
			return null;
		}

		Set<WorldPoint> pathPoints = new HashSet<>(plugin.getNavigationManager().getShortestPath());

		Map<WorldPoint, WallObject> doorsMap = plugin.getStateManager().getSpawnedDoors();
		Map<WorldPoint, GameObject> stairsMap = plugin.getStateManager().getSpawnedStairs();

		Set<TileObject> pathRenderedObjects = new HashSet<>();

		renderLamps(graphics);

		drawPathToLocation(graphics, pathPoints, pathRenderedObjects, doorsMap, stairsMap);

		if (config.highlightClosedDoors())
		{
			for (WallObject door : doorsMap.values())
			{
				if (door.getPlane() != client.getTopLevelWorldView().getPlane())
				{
					continue;
				}
				if (!pathRenderedObjects.contains(door))
				{
					renderTileObject(door, config.doorHighlightColor(), graphics, config.objectsHighlightStyle());
				}
			}
		}

		if (config.highlightInformativeStairs())
		{
			for (GameObject stair : plugin.getStateManager().getInformativeStairs())
			{
				if (stair.getPlane() != client.getTopLevelWorldView().getPlane())
				{
					continue;
				}
				if (!pathRenderedObjects.contains(stair))
				{
					renderTileObject(stair, config.informativeStairColor(), graphics, config.objectsHighlightStyle());
				}
			}
		}

		if (config.highlightWireMachine() && plugin.getStateManager().getWireMachine() != null)
		{
			GameObject wireMachine = plugin.getStateManager().getWireMachine();
			if (wireMachine.getId() == DKLightsConstants.WIRE_MACHINE_ACTIVE)
			{
				renderTileObject(wireMachine, config.wireMachineHighlightColor(), graphics,
						config.objectsHighlightStyle());
			}
			else
			{
				renderWireTimer(graphics);
			}
		}

		return null;
	}

	private void renderLamps(Graphics2D graphics)
	{
		for (GameObject lampObject : plugin.getStateManager().getSpawnedLamps().values())
		{
			if (lampObject.getPlane() != client.getTopLevelWorldView().getPlane()
					&& !config.highlightOtherPlanesLamps())
			{
				continue;
			}

			Lamp lamp = DKLightsHelper.getLamp(lampObject.getId());
			if (lamp == null)
			{
				continue;
			}

			LampStatus status = plugin.getStateManager().getLampStatuses().getOrDefault(lamp, LampStatus.UNKNOWN);

			Color color;
			if (status == LampStatus.BROKEN && config.highlightBrokenLamps())
			{
				color = config.getBrokenLampColor();
			}
			else if (status == LampStatus.WORKING && config.highlightWorkingLamps())
			{
				color = config.getWorkingLampColor();
			}
			else if (config.highlightAllLamps())
			{
				color = config.getDefaultLampColor();
			}
			else
			{
				continue;
			}

			if (lampObject.getPlane() != client.getTopLevelWorldView().getPlane() && config.darkenOtherPlanesLamps())
			{
				color = color.darker();
			}

			renderTileObject(lampObject, color, graphics, config.lampsHighlightStyle());
		}
	}

	private void renderTileObject(TileObject tileObject, Color color, Graphics2D graphics, HighlightType style)
	{
		switch (style)
		{
		case BORDER:
			modelOutlineRenderer.drawOutline(tileObject, config.borderThickness(), color, config.borderFeather());
			break;
		case CLICKBOX:
			Shape clickbox = tileObject.getClickbox();
			if (clickbox != null)
			{
				Point mousePosition = client.getMouseCanvasPosition();
				if (clickbox.contains(mousePosition.getX(), mousePosition.getY()))
				{
					graphics.setColor(color.darker());
				}
				else
				{
					graphics.setColor(color);
				}
				graphics.draw(clickbox);
				graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), 50));
				graphics.fill(clickbox);
			}
			break;
		}
	}

	private void drawPathToLocation(Graphics2D graphics, Set<WorldPoint> pathPoints,
			Set<TileObject> pathRenderedObjects, Map<WorldPoint, WallObject> doorsMap,
			Map<WorldPoint, GameObject> stairsMap)
	{
		if (!config.showPathToLocation())
		{
			return;
		}

		List<WorldPoint> path = plugin.getNavigationManager().getShortestPath();
		if (path == null || path.isEmpty())
		{
			return;
		}

		TargetType targetType = plugin.getNavigationManager().getCurrentTargetType();
		boolean isUtilityTarget = targetType == TargetType.BANK || targetType == TargetType.WIRING_MACHINE;

		Set<Transport> activeTransports = new HashSet<>();
		Map<WorldPoint, Color> pathPointColors = new HashMap<>();
		PathDrawStyle style = config.pathDrawStyle();
		Point prevScreenPoint = null;
		boolean isAfterClosedDoor = false;

		for (WorldPoint point : path)
		{
			if (point.getPlane() != client.getTopLevelWorldView().getPlane())
			{
				prevScreenPoint = null;
				continue;
			}

			LocalPoint localPoint = LocalPoint.fromWorld(client.getTopLevelWorldView(), point);
			if (localPoint == null)
			{
				prevScreenPoint = null;
				continue;
			}

			Color pathColor = isUtilityTarget ? config.utilityPathColor() : config.pathColor();
			if (!isUtilityTarget && config.maxPathDistance() > 0 && path.size() > config.maxPathDistance())
			{
				long phase = (System.currentTimeMillis() / 600) % 2;
				pathColor = phase == 0 ? pathColor.darker() : pathColor.brighter();
			}

			if (isAfterClosedDoor)
			{
				pathColor = pathColor.darker().darker();
			}

			pathPointColors.put(point, pathColor);

			switch (style)
			{
			case TILES:
				Polygon poly = Perspective.getCanvasTilePoly(client, localPoint);
				if (poly != null)
				{
					OverlayUtil.renderPolygon(graphics, poly, pathColor);
				}
				break;

			case TILE_BORDERS:
				Polygon borderPoly = Perspective.getCanvasTilePoly(client, localPoint);
				if (borderPoly != null)
				{
					graphics.setColor(pathColor);
					graphics.draw(borderPoly);
				}
				break;

			case CENTER_LINE:
				Point screenPoint = Perspective.localToCanvas(client, localPoint,
						client.getTopLevelWorldView().getPlane());
				if (screenPoint == null)
				{
					continue;
				}
				if (prevScreenPoint != null)
				{
					graphics.setColor(pathColor);
					graphics.setStroke(new BasicStroke(2));
					graphics.drawLine(prevScreenPoint.getX(), prevScreenPoint.getY(), screenPoint.getX(),
							screenPoint.getY());
				}
				prevScreenPoint = screenPoint;
				break;
			}

			WallObject door = doorsMap.get(point);
			if (door != null)
			{
				renderTileObject(door, pathColor, graphics, config.objectsHighlightStyle());
				pathRenderedObjects.add(door);
				isAfterClosedDoor = true;
			}

			List<Transport> transports = plugin.getPathfinder().getTransportsAt(point);
			for (Transport transport : transports)
			{
				if (pathPoints.contains(transport.getOrigin()) && pathPoints.contains(transport.getDestination()))
				{
					activeTransports.add(transport);
				}
			}
		}

		highlightTransportsOnPath(graphics, activeTransports, pathPointColors, pathRenderedObjects, stairsMap);	
	}

	private void highlightTransportsOnPath(Graphics2D graphics, Set<Transport> activeTransports,
			Map<WorldPoint, Color> pathPointColors, Set<TileObject> pathRenderedObjects, Map<WorldPoint, GameObject> stairsMap)
	{

		if (activeTransports.isEmpty())
		{
			return;
		}

		for (GameObject stair : stairsMap.values())
		{
			if (stair.getPlane() != client.getTopLevelWorldView().getPlane())
			{
				continue;
			}

			WorldPoint stairLocation = stair.getWorldLocation();
			Transport transport = transportBetweenTransportPoints(stairLocation, activeTransports);
			if (transport != null)
			{
				Color highlightColor = pathPointColors.get(transport.getOrigin());

				renderTileObject(stair, highlightColor, graphics, config.objectsHighlightStyle());
				pathRenderedObjects.add(stair);
			}
		}

	}

	private Transport transportBetweenTransportPoints(WorldPoint objectLocation, Set<Transport> activeTransports)
	{
		for (Transport transport : activeTransports)
		{
			if (DKLightsHelper.isLocationBetweenTransportPoints(objectLocation, transport))
			{
				return transport;
			}
		}
		return null;
	}

	private void renderWireTimer(Graphics2D graphics)
	{
		int respawnTick = plugin.getStateManager().getWireRespawnTick();

		if (respawnTick == -1 || plugin.getStateManager().getWireMachine() == null)
		{
			return;
		}

		int currentTick = client.getTickCount();
		int ticksRemaining = respawnTick - currentTick;

		Instant now = Instant.now();
		Instant lastTick = plugin.getLastTickInstant();
		long millisSinceLastTick = Duration.between(lastTick, now).toMillis();

		millisSinceLastTick = Math.max(0, Math.min(millisSinceLastTick, 600));

		double tickFractionPassed = millisSinceLastTick / 600.0;

		double smoothTicksRemaining = Math.max(0.0, (double) ticksRemaining - tickFractionPassed);

		if (smoothTicksRemaining <= 0)
		{
			return;
		}

		double progress = smoothTicksRemaining / DKLightsConstants.WIRE_RESPAWN_TICKS;

		LocalPoint lp = plugin.getStateManager().getWireMachine().getLocalLocation();
		Point point = net.runelite.api.Perspective.getCanvasTextLocation(client, graphics, lp, " ", 0);

		if (point == null)
		{
			return;
		}

		if (config.timerType() == TimerType.PIE)
		{
			ProgressPieComponent pie = new ProgressPieComponent();
			pie.setPosition(point);
			pie.setBorderColor(config.wireMachineHighlightColor());
			pie.setDiameter(20);
			pie.setFill(config.wireMachineHighlightColor());
			// Use the smooth progress value
			pie.setProgress(progress);
			pie.render(graphics);
		}
		else if (config.timerType() == TimerType.TICKS)
		{
			// Ticks should still likely show the discrete value
			String text = String.valueOf(ticksRemaining);
			OverlayUtil.renderTextLocation(graphics, point, text, Color.WHITE);
		}
		else if (config.timerType() == TimerType.SECONDS)
		{
			// Calculate seconds based on the smooth value
			double seconds = smoothTicksRemaining * 0.6;
			String text = String.format("%.1f", seconds);
			OverlayUtil.renderTextLocation(graphics, point, text, Color.WHITE);
		}
	}
}

package com.dklights.overlay;

import com.dklights.DKLightsConfig;
import com.dklights.DKLightsHelper;
import com.dklights.DKLightsPlugin;
import com.dklights.enums.Area;
import com.dklights.enums.TargetType;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.LineComponent.LineComponentBuilder;
import net.runelite.client.ui.overlay.components.TitleComponent;

public class StatsOverlay extends OverlayPanel
{
	private final DKLightsPlugin plugin;
	private final DKLightsConfig config;
	private final Client client;

	@Inject
	private StatsOverlay(DKLightsPlugin plugin, DKLightsConfig config, Client client)
	{
		super(plugin);
		this.plugin = plugin;
		this.config = config;
		this.client = client;
		setPosition(OverlayPosition.TOP_LEFT);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.showStatsOverlay())
		{
			return null;
		}

		// Only show overlay when in Dorgesh-Kaan region
		if (client.getLocalPlayer() == null)
		{
			return null;
		}

		Area currentArea = DKLightsHelper.getArea(client.getLocalPlayer().getWorldLocation());
		if (currentArea == null)
		{
			return null;
		}

		panelComponent.getChildren().add(TitleComponent.builder().text("Dorgesh-Kaan Lamps").color(Color.CYAN).build());

		panelComponent.getChildren()
				.add(LineComponent.builder().left("Target:")
						.right(plugin.getNavigationManager().getCurrentTargetType().getDisplayName())
						.rightColor(config.pathColor()).build());

		if (config.showClosestDistance() && config.showPathToLocation() && plugin.getNavigationManager().getCurrentTargetType() != TargetType.NONE)
		{
			int closestDist = plugin.getNavigationManager().getClosestDistance();
			String distText = (closestDist == Integer.MAX_VALUE) ? "-" : String.valueOf(closestDist);
			LineComponentBuilder line = LineComponent.builder().left("Distance:").right(distText + " tiles");

			if (closestDist != Integer.MAX_VALUE && closestDist > config.maxPathDistance()
					&& plugin.getNavigationManager().getCurrentTargetType() == TargetType.LAMP)
			{
				boolean blinkOn = (System.currentTimeMillis() / 600) % 2 == 0;
				line.rightColor(blinkOn ? Color.RED : Color.WHITE);
			}

			panelComponent.getChildren().add(line.build());
		}

		int lampsFixed = plugin.getStatsTracker().getLampsFixed();
		if (lampsFixed > 0)
		{
			panelComponent.getChildren()
					.add(LineComponent.builder().left("Lamps fixed:").right(Integer.toString(lampsFixed)).build());

			int lampsPerHr = plugin.getStatsTracker().getLampsPerHr();
			if (lampsPerHr > 0)
			{
				panelComponent.getChildren()
						.add(LineComponent.builder().left("Lamps/hr:").right(Integer.toString(lampsPerHr)).build());
			}
		}

		panelComponent.getChildren().add(LineComponent.builder().left("Total Fixed:")
				.right(String.valueOf(plugin.getStatsTracker().getTotalLampsFixed())).build());

		return super.render(graphics);
	}
}
package com.dklights;

import com.dklights.enums.Area;
import com.dklights.enums.Direction;
import com.dklights.enums.Lamp;
import com.dklights.enums.LampStatus;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.HintArrowType;
import net.runelite.api.WallObject;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;

@Slf4j
public class DKLightsStateManager
{

	private final Client client;
	private final DKLightsStatsTracker statsTracker;

	@Getter
	private final Map<Lamp, LampStatus> lampStatuses = new EnumMap<>(Lamp.class);
	@Getter
	private final Map<WorldPoint, GameObject> spawnedLamps = new HashMap<>();
	@Getter
	private final Map<WorldPoint, WallObject> spawnedDoors = new HashMap<>();
	@Getter
	private final Map<Lamp, Set<Direction>> lampWallCache = new EnumMap<>(Lamp.class);
	@Getter
	private final Map<WorldPoint, GameObject> spawnedStairs = new HashMap<>();
	@Getter
	private final Set<GameObject> informativeStairs = new HashSet<>();

	private final Map<WorldPoint, Area> stairTargetAreaMap = new HashMap<>();

	@Getter
	private GameObject wireMachine;
	@Getter
	private int wireRespawnTick = -1;

	private Set<Lamp> previouslyBrokenLamps = new HashSet<>();
	@Getter
	private Area currentArea = null;
	private Area lastArea = null;
	private String lastHintFloor = null;
	private final Set<Lamp> fixedLamps = new HashSet<>();
	@Getter
	private final Set<Lamp> brokenLamps = new HashSet<>();
	private boolean isLampFixed = false;
	private int gameTickCounter = 0;
	private static final int HEAVY_OPERATIONS_INTERVAL = 5;

	public DKLightsStateManager(Client client, DKLightsStatsTracker statsTracker)
	{
		this.client = client;
		this.statsTracker = statsTracker;
		resetLampStatuses();
	}

	public void shutDown()
	{
		spawnedLamps.clear();
		spawnedDoors.clear();
		spawnedStairs.clear();
		stairTargetAreaMap.clear();
		informativeStairs.clear();
		previouslyBrokenLamps.clear();
		fixedLamps.clear();
		brokenLamps.clear();

		wireMachine = null;
		lastArea = null;
		gameTickCounter = 0;
		isLampFixed = false;
		wireRespawnTick = -1;
	}

	public void onGameTick()
	{
		WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
		if (playerLocation == null)
		{
			return;
		}

		gameTickCounter++;
		boolean isHeavyOperationTick = (gameTickCounter % HEAVY_OPERATIONS_INTERVAL) == 0;

		currentArea = DKLightsHelper.getArea(playerLocation);
		if (currentArea == null)
		{
			lastArea = null;
			return;
		}

		if (!currentArea.equals(lastArea))
		{
			lastArea = currentArea;
			previouslyBrokenLamps.clear();
			return;
		}

		int lampVarbit = client.getVarbitValue(DKLightsConstants.DORGESHKAAN_LAMPS_VARBIT);

		brokenLamps.clear();
		brokenLamps.addAll(DKLightsHelper.getBrokenLamps(lampVarbit, currentArea));

		if (!brokenLamps.equals(previouslyBrokenLamps))
		{
			fixedLamps.clear();
			fixedLamps.addAll(previouslyBrokenLamps);
			fixedLamps.removeAll(brokenLamps);

			if (!fixedLamps.isEmpty())
			{
				statsTracker.incrementLampsFixed();
				isLampFixed = true;
			}
		}

		Map<Lamp, LampStatus> newStatuses = DKLightsHelper.updateLampStatuses(lampStatuses, brokenLamps, isLampFixed,
				currentArea);

		if (isLampFixed)
		{
			detectRuneLiteHintArrow(newStatuses);
			isLampFixed = false;
		}

		lampStatuses.clear();
		lampStatuses.putAll(newStatuses);

		if (isHeavyOperationTick)
		{
			detectInformativeStairs(playerLocation);
		}

		previouslyBrokenLamps.clear();
		previouslyBrokenLamps.addAll(brokenLamps);
		lastArea = currentArea;
	}

	public void onGameObjectSpawned(GameObject gameObject)
	{
		if (DKLightsHelper.isLamp(gameObject.getId()))
		{
			spawnedLamps.put(gameObject.getWorldLocation(), gameObject);
		}
		else if (DKLightsConstants.STAIR_IDS.contains(gameObject.getId()))
		{
			spawnedStairs.put(gameObject.getWorldLocation(), gameObject);
			cacheStairTargetArea(gameObject);
		}
		else if (DKLightsConstants.WIRE_MACHINE_IDS.contains(gameObject.getId()))
		{
			wireMachine = gameObject;
			if (gameObject.getId() == DKLightsConstants.WIRE_MACHINE_INACTIVE)
			{
				wireRespawnTick = client.getTickCount() + DKLightsConstants.WIRE_RESPAWN_TICKS;
			}
			else
			{
				wireRespawnTick = -1;
			}
		}
	}

	public void onGameObjectDespawned(GameObject gameObject)
	{
		if (DKLightsHelper.isLamp(gameObject.getId()))
		{
			spawnedLamps.remove(gameObject.getWorldLocation());
		}
		else if (DKLightsConstants.STAIR_IDS.contains(gameObject.getId()))
		{
			spawnedStairs.remove(gameObject.getWorldLocation());
			stairTargetAreaMap.remove(gameObject.getWorldLocation());
		}
		else if (DKLightsConstants.WIRE_MACHINE_IDS.contains(gameObject.getId()))
		{
			wireMachine = null;
			wireRespawnTick = -1;
		}
	}

	public void onWallObjectSpawned(WallObject wallObject)
	{
		if (DKLightsConstants.DOOR_IDS.contains(wallObject.getId()))
		{
			spawnedDoors.put(wallObject.getWorldLocation(), wallObject);
		}
		updateWallCache(wallObject.getWorldLocation(), true);
	}

	public void onWallObjectDespawned(WallObject wallObject)
	{
		if (DKLightsConstants.DOOR_IDS.contains(wallObject.getId()))
		{
			spawnedDoors.remove(wallObject.getWorldLocation());
		}
		updateWallCache(wallObject.getWorldLocation(), false);
	}

	public void onGameStateChanged(GameState gameState)
	{
		if (gameState == GameState.LOADING || gameState == GameState.LOGIN_SCREEN || gameState == GameState.HOPPING)
		{

			spawnedLamps.clear();
			spawnedDoors.clear();
			spawnedStairs.clear();
			stairTargetAreaMap.clear();
			informativeStairs.clear();
			lampWallCache.clear();
			wireMachine = null;
			wireRespawnTick = -1;
			currentArea = null;

			if (gameState != GameState.LOADING)
			{
				resetLampStatuses();
			}
		}
	}

	public void onChatMessage(ChatMessage chatMessage)
	{
		ChatMessageType chatMessageType = chatMessage.getType();
		String message = chatMessage.getMessage();

		if (chatMessageType == ChatMessageType.GAMEMESSAGE
				&& message.contains(DKLightsConstants.NEARBY_LAMP_CHAT_MESSAGE))
		{
			parseNearbyLampChatMessage(message);
		}
	}

	private void updateWallCache(WorldPoint wallLocation, boolean isSpawned)
	{
		for (Lamp lamp : Lamp.values())
		{
			WorldPoint lampLocation = lamp.getWorldPoint();
			if (lampLocation.distanceTo(wallLocation) > 1)
			{
				continue;
			}

			for (Direction dir : Direction.values())
			{
				if (lampLocation.dx(dir.getX()).dy(dir.getY()).equals(wallLocation))
				{
					if (isSpawned)
					{
						lampWallCache.computeIfAbsent(lamp, k -> new HashSet<>()).add(dir);
					}
					else
					{
						lampWallCache.computeIfPresent(lamp, (k, v) ->
						{
							v.remove(dir);
							return v.isEmpty() ? null : v;
						});
					}
					return;
				}
			}
		}
	}

	private void parseNearbyLampChatMessage(String message)
	{
		Matcher matcher = DKLightsConstants.NEARBY_LAMP_PATTERN.matcher(message);
		if (matcher.find())
		{
			log.info("Parsed nearby lamp hint: direction={}, floor={}", matcher.group(1), matcher.group(2));
			lastHintFloor = matcher.group(2);
		}
	}

	private void resetLampStatuses()
	{
		lampStatuses.clear();
		for (Lamp lamp : Lamp.values())
		{
			lampStatuses.put(lamp, LampStatus.UNKNOWN);
		}
	}

	private void cacheStairTargetArea(GameObject stair)
	{
		WorldPoint stairLocation = stair.getWorldLocation();
		if (stairTargetAreaMap.containsKey(stairLocation))
		{
			return;
		}

		Area targetArea = null;
		if (DKLightsConstants.STAIR_IDS_UP.contains(stair.getId()))
		{
			targetArea = DKLightsHelper.getArea(stairLocation.dz(1));
		}
		else if (DKLightsConstants.STAIR_IDS_DOWN.contains(stair.getId()))
		{
			targetArea = DKLightsHelper.getArea(stairLocation.dz(-1));
		}

		if (targetArea != null)
		{
			stairTargetAreaMap.put(stairLocation, targetArea);
		}
	}

	private void detectInformativeStairs(WorldPoint playerLocation)
	{
		informativeStairs.clear();

		if (spawnedStairs.isEmpty())
		{
			return;
		}

		Set<Area> unknownAreas = new HashSet<>();
		for (Area area : Area.values())
		{
			if (DKLightsHelper.areaHasUnknownLamps(area, lampStatuses))
			{
				unknownAreas.add(area);
			}
		}

		if (unknownAreas.isEmpty())
		{
			return;
		}

		Map<Area, GameObject> closestStairForArea = new EnumMap<>(Area.class);
		Map<Area, Integer> minDistanceForArea = new EnumMap<>(Area.class);

		for (GameObject stair : spawnedStairs.values())
		{
			WorldPoint stairLocation = stair.getWorldLocation();

			Area targetArea = stairTargetAreaMap.get(stairLocation);

			if (targetArea != null && unknownAreas.contains(targetArea))
			{
				int distanceToPlayer = playerLocation.distanceTo(stairLocation);
				int currentMinDistance = minDistanceForArea.getOrDefault(targetArea, Integer.MAX_VALUE);

				if (distanceToPlayer < currentMinDistance)
				{
					minDistanceForArea.put(targetArea, distanceToPlayer);
					closestStairForArea.put(targetArea, stair);
				}
			}
		}

		informativeStairs.addAll(closestStairForArea.values());
	}

	private void detectRuneLiteHintArrow(Map<Lamp, LampStatus> newStatuses)
	{
		boolean currentlyHasHintArrow = client.hasHintArrow();
		WorldPoint currentHintArrowPoint = null;

		if (currentlyHasHintArrow && client.getHintArrowType() == HintArrowType.COORDINATE)
		{
			currentHintArrowPoint = client.getHintArrowPoint();
			log.info("RuneLite hint arrow detected at {}", currentHintArrowPoint);
		}

		if (currentlyHasHintArrow && currentHintArrowPoint != null)
		{

			for (Lamp lamp : Lamp.values())
			{
				WorldPoint lampLocation = lamp.getWorldPoint();
				if (lampLocation.getX() == currentHintArrowPoint.getX()
						&& lampLocation.getY() == currentHintArrowPoint.getY())
				{

					int playerPlane = client.getLocalPlayer().getWorldLocation().getPlane();
					boolean planeMatches = false;

					if (lastHintFloor.equals("upstairs") && lampLocation.getPlane() > playerPlane)
					{
						planeMatches = true;
					}
					else if (lastHintFloor.equals("downstairs") && lampLocation.getPlane() < playerPlane)
					{
						planeMatches = true;
					}
					else if (lastHintFloor.equals("on the same floor") && lampLocation.getPlane() == playerPlane)
					{
						planeMatches = true;
					}

					if (planeMatches)
					{
						newStatuses.put(lamp, LampStatus.BROKEN);
						break;
					}
				}
			}
		}
	}
}

package com.dklights;

import com.dklights.enums.Direction;
import com.dklights.enums.InventoryState;
import com.dklights.enums.Lamp;
import com.dklights.enums.LampStatus;
import com.dklights.enums.TargetType;
import com.dklights.pathfinder.Pathfinder;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.stream.Collectors;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.coords.WorldPoint;

@Slf4j
public class DKLightsNavigationManager
{

	private final Client client;
	private final DKLightsConfig config;
	private final Pathfinder pathfinder;
	private final ExecutorService pathfindingExecutor;

	@Getter
	private List<WorldPoint> shortestPath = new ArrayList<>();
	@Getter
	private int closestDistance = 0;
	@Getter
	private TargetType currentTargetType = TargetType.NONE;

	private Lamp lastLoggedClosestLamp = null;
	private CompletableFuture<Void> currentClosestLampTask;
	private long lastClosestLampCalculation = 0;
	private static final long CLOSEST_LAMP_COOLDOWN_MS = 600;

	private final Set<Lamp> brokenLamps = new HashSet<>();

	public DKLightsNavigationManager(Client client, DKLightsConfig config, Pathfinder pathfinder,
			ExecutorService pathfindingExecutor)
	{
		this.client = client;
		this.config = config;
		this.pathfinder = pathfinder;
		this.pathfindingExecutor = pathfindingExecutor;
	}

	public void update(Map<Lamp, LampStatus> lampStatuses, Map<Lamp, Set<Direction>> lampWallCache,
			InventoryState inventoryState, WorldPoint playerLocation, GameObject wireMachine)
	{

		if (playerLocation == null || pathfinder == null || pathfindingExecutor == null)
		{
			return;
		}

		WorldPoint targetLocation;

		switch (inventoryState)
		{
		case NO_LIGHT_BULBS:
			targetLocation = DKLightsConstants.BANK_LOCATION;
			currentTargetType = TargetType.BANK;
			break;

		case ONLY_EMPTY_BULBS:
			targetLocation = DKLightsConstants.WIRE_MACHINE_LOCATION;
			currentTargetType = TargetType.WIRING_MACHINE;
			break;

		case HAS_WORKING_BULBS:
            targetLocation = null;
			currentTargetType = TargetType.LAMP;
            break;

		default:
			currentTargetType = TargetType.NONE;
			shortestPath.clear();
			return;
		}

        if (!config.showPathToLocation())
		{
			if (!shortestPath.isEmpty())
			{
				shortestPath.clear();
			}
			if (closestDistance != 0)
			{
				closestDistance = 0;
			}
			if (currentClosestLampTask != null && !currentClosestLampTask.isDone())
			{
				currentClosestLampTask.cancel(true);
			}
			return;
		}

		if (targetLocation != null)
		{
			calculatePathToTarget(targetLocation, currentTargetType, playerLocation);
		}
        else
        {
			findClosestBrokenLamp(lampStatuses, lampWallCache, playerLocation);
        }
	}

	public void shutDown()
	{
		if (currentClosestLampTask != null)
		{
			currentClosestLampTask.cancel(true);
		}
	}

	public void clearPathAndTarget()
	{
		shortestPath.clear();
		closestDistance = 0;
		currentTargetType = TargetType.NONE;
		if (currentClosestLampTask != null && !currentClosestLampTask.isDone())
		{
			currentClosestLampTask.cancel(true);
		}
	}

	private void findClosestBrokenLamp(Map<Lamp, LampStatus> lampStatuses, Map<Lamp, Set<Direction>> lampWallCache,
			WorldPoint playerLocation)
	{
		brokenLamps.clear();
		for (Map.Entry<Lamp, LampStatus> entry : lampStatuses.entrySet())
		{
			if (entry.getValue() == LampStatus.BROKEN)
			{
				brokenLamps.add(entry.getKey());
			}
		}
		final Set<Lamp> lampsToCheck = new HashSet<>(brokenLamps);

		if (lampsToCheck.isEmpty())
		{
			if (lastLoggedClosestLamp != null)
			{
				log.info("No broken lamps found");
				lastLoggedClosestLamp = null;
			}
			shortestPath.clear();
			closestDistance = 0;
			return;
		}

		long currentTime = System.currentTimeMillis();
		if (currentTime - lastClosestLampCalculation < CLOSEST_LAMP_COOLDOWN_MS)
		{
			return;
		}
		lastClosestLampCalculation = currentTime;

		if (currentClosestLampTask != null && !currentClosestLampTask.isDone())
		{
			currentClosestLampTask.cancel(true);
		}

		final WorldPoint playerPos = playerLocation;

		currentClosestLampTask = CompletableFuture.runAsync(() ->
		{
			try
			{
				final Set<WorldPoint> brokenLampLocations = lampsToCheck.stream().map(Lamp::getWorldPoint)
						.collect(Collectors.toSet());

				if (Thread.currentThread().isInterrupted())
				{
					return;
				}

				List<WorldPoint> path = pathfinder.findNearestPath(playerPos, brokenLampLocations, lampWallCache);

				if (Thread.currentThread().isInterrupted())
				{
					return;
				}

				if (path != null && !path.isEmpty())
				{
					final List<WorldPoint> finalPath = new ArrayList<>(path);
					final int finalDistance = finalPath.size();
					final WorldPoint destination = finalPath.get(finalPath.size() - 1);

					final Lamp finalClosestLamp = lampsToCheck.stream()
							.filter(lamp -> lamp.getWorldPoint().equals(destination)).findFirst().orElse(null);

					shortestPath = finalPath;
					closestDistance = finalDistance;

					if (finalClosestLamp != null && !finalClosestLamp.equals(lastLoggedClosestLamp))
					{
						lastLoggedClosestLamp = finalClosestLamp;
					}
				}
				else
				{
					shortestPath.clear();
					closestDistance = 0;
					if (lastLoggedClosestLamp != null)
					{
						lastLoggedClosestLamp = null;
					}
				}
			}
			catch (Exception e)
			{
				log.error("Error during closest lamp calculation (BFS)", e);
				shortestPath.clear();
				closestDistance = 0;
				lastLoggedClosestLamp = null;
			}
		}, pathfindingExecutor).exceptionally(throwable ->
		{
			if (!(throwable instanceof java.util.concurrent.CancellationException))
			{
				log.error("Closest lamp calculation (BFS) failed", throwable);
			}
			return null;
		});
	}

	private void calculatePathToTarget(WorldPoint targetLocation, TargetType targetType, WorldPoint playerLocation)
	{
		long currentTime = System.currentTimeMillis();
		if (currentTime - lastClosestLampCalculation < CLOSEST_LAMP_COOLDOWN_MS)
		{
			return;
		}
		lastClosestLampCalculation = currentTime;

		if (currentClosestLampTask != null && !currentClosestLampTask.isDone())
		{
			currentClosestLampTask.cancel(true);
		}

		final WorldPoint playerPos = playerLocation;
		final WorldPoint target = targetLocation;

		if (DKLightsHelper.isInBankArea(playerLocation) && targetType == TargetType.BANK)
		{
			shortestPath.clear();
			return;
		}

		currentClosestLampTask = CompletableFuture.runAsync(() ->
		{
			try
			{
				if (Thread.currentThread().isInterrupted())
				{
					return;
				}

				List<WorldPoint> path = pathfinder.findPath(playerPos, target);

				if (!Thread.currentThread().isInterrupted())
				{
					if (path != null && !path.isEmpty())
					{
						shortestPath = new ArrayList<>(path);
						closestDistance = path.size();
					}
					else
					{
						shortestPath = new ArrayList<>();
						shortestPath.add(playerPos);
						shortestPath.add(target);
						closestDistance = target.distanceTo(playerPos);
					}
				}
			}
			catch (Exception e)
			{
				log.error("Error calculating path to {}: {}", targetType, e.getMessage());
				if (!Thread.currentThread().isInterrupted())
				{
					shortestPath = new ArrayList<>();
					shortestPath.add(playerPos);
					shortestPath.add(target);
					closestDistance = target.distanceTo(playerPos);
				}
			}
		}, pathfindingExecutor).exceptionally(throwable ->
		{
			if (!(throwable instanceof java.util.concurrent.CancellationException))
			{
				log.error("Path calculation to {} failed", targetType, throwable);
			}
			return null;
		});
	}
}

package com.dklights;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class DKLightsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DKLightsPlugin.class);
		RuneLite.main(args);
	}
}
