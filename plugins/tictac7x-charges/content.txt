package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnWidgetLoaded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.store.ItemWithQuantity;

import java.util.regex.Matcher;

import static tictac7x.charges.TicTac7xChargesImprovedPlugin.getNumberFromCommaString;

public class ListenerOnWidgetLoaded extends ListenerBase {
    public ListenerOnWidgetLoaded(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final WidgetLoaded event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;

            boolean triggerUsed = false;
            final OnWidgetLoaded trigger = (OnWidgetLoaded) triggerBase;
            final Widget widget = getWidget(trigger);

            if (trigger.text.isPresent()) {
                final String text = getCleanText(widget.getText());
                final Matcher matcher = trigger.text.get().matcher(text);
                matcher.find();

                if (trigger.setDynamically.isPresent()) {
                    ((ChargedItem) chargedItem).setCharges(getNumberFromCommaString(matcher.group("charges")));
                    triggerUsed = true;
                }

                if (trigger.matcherConsumer.isPresent()) {
                    trigger.matcherConsumer.get().accept(matcher);
                    triggerUsed = true;
                }
            }

            if (trigger.textAsChargesConsumer.isPresent()) {
                trigger.textAsChargesConsumer.get().accept(Integer.parseInt(widget.getText()));
                triggerUsed = true;
            }

            if (trigger.itemQuantityConsumer.isPresent()) {
                trigger.itemQuantityConsumer.get().accept(widget.getItemQuantity());
                triggerUsed = true;
            }

            if (trigger.itemWithQuantityConsumer.isPresent()) {
                trigger.itemWithQuantityConsumer.get().accept(new ItemWithQuantity(widget.getItemId(), widget.getItemQuantity()));
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed && !trigger.multiTrigger) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final WidgetLoaded event) {
        if (!(triggerBase instanceof OnWidgetLoaded)) return false;
        final OnWidgetLoaded trigger = (OnWidgetLoaded) triggerBase;
        final Widget widget = getWidget(trigger);

        // Widget group check.
        if (event.getGroupId() != trigger.groupId) {
            return false;
        }

        // Widget existance check.
        if (widget == null) {
            return false;
        }

        // Text check.
        if (trigger.text.isPresent()) {
            final Matcher matcher = trigger.text.get().matcher(getCleanText(widget.getText()));
            if (!matcher.find()) {
                return false;
            }
        }

        return super.isValidTrigger(trigger);
    }

    private String getCleanText(final String text) {
        return text.replaceAll("</?col.*?>", "").replaceAll("<br>", " ");
    }

    private Widget getWidget(final OnWidgetLoaded trigger) {
        Widget widget = client.getWidget(trigger.groupId, trigger.childId);

        if (widget != null && trigger.subChildId.isPresent()) {
            widget = widget.getChild(trigger.subChildId.get());
        }

        return widget;
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.api.events.StatChanged;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnStatChanged;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnStatChanged extends ListenerBase {
    public ListenerOnStatChanged(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final StatChanged event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnStatChanged trigger = (OnStatChanged) triggerBase;
            boolean triggerUsed = false;

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final StatChanged event) {
        if (!(triggerBase instanceof OnStatChanged)) return false;
        final OnStatChanged trigger = (OnStatChanged) triggerBase;
        final Skill skill = event.getSkill();

        // Skill check.
        if (trigger.skill != skill) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.Hitsplat;
import net.runelite.api.HitsplatID;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.store.HitsplatGroup;
import tictac7x.charges.store.HitsplatTarget;

public class ListenerOnHitsplatApplied extends ListenerBase {
    public ListenerOnHitsplatApplied(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final HitsplatApplied event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnHitsplatApplied trigger = (OnHitsplatApplied) triggerBase;
            boolean triggerUsed = false;

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final HitsplatApplied event) {
        if (!(triggerBase instanceof OnHitsplatApplied)) return false;
        final OnHitsplatApplied trigger = (OnHitsplatApplied) triggerBase;
        final Hitsplat hitsplat = event.getHitsplat();

        // Hitsplat caused by other player check.
        if (event.getHitsplat().isOthers()) {
            return false;
        }

        // Hitsplat self check.
        if (trigger.hitsplatTarget == HitsplatTarget.SELF && event.getActor() != client.getLocalPlayer()) {
            return false;
        }

        // Hitsplat enemy check.
        if (trigger.hitsplatTarget == HitsplatTarget.ENEMY && event.getActor() == client.getLocalPlayer()) {
            return false;
        }

        // Hitsplay group check.
        if (trigger.hitsplatGroup == HitsplatGroup.REGULAR && (
            hitsplat.getHitsplatType() != HitsplatID.DAMAGE_ME &&
            hitsplat.getHitsplatType() != HitsplatID.DAMAGE_MAX_ME
        )) {
            return false;
        }

        // More than zero damage.
        if (trigger.moreThanZeroDamage.isPresent() && hitsplat.getAmount() == 0) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnMenuOptionClicked;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.store.AdvancedMenuEntry;

public class ListenerOnMenuOptionClicked extends ListenerBase {
    public ListenerOnMenuOptionClicked(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final AdvancedMenuEntry event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnMenuOptionClicked trigger = (OnMenuOptionClicked) triggerBase;
            boolean triggerUsed = false;

            if (trigger.menuOptionConsumer.isPresent()) {
                trigger.menuOptionConsumer.get().accept(event);
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final AdvancedMenuEntry event) {
        if (!(triggerBase instanceof OnMenuOptionClicked)) return false;
        final OnMenuOptionClicked trigger = (OnMenuOptionClicked) triggerBase;

        // Option check.
        if (!event.option.equals(trigger.option)) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnScriptPreFired;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnScriptPreFired extends ListenerBase {
    public ListenerOnScriptPreFired(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final ScriptPreFired event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnScriptPreFired trigger = (OnScriptPreFired) triggerBase;
            boolean triggerUsed = false;

            if (trigger.scriptConsumer.isPresent()) {
                trigger.scriptConsumer.get().accept(event);
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final ScriptPreFired event) {
        if (!(triggerBase instanceof OnScriptPreFired)) return false;
        final OnScriptPreFired trigger = (OnScriptPreFired) triggerBase;

        // Id check.
        if (trigger.scriptId != event.getScriptId()) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.events.AnimationChanged;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnAnimationChanged;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnAnimationChanged extends ListenerBase {
    public ListenerOnAnimationChanged(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final AnimationChanged event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;

            final OnAnimationChanged trigger = (OnAnimationChanged) triggerBase;
            boolean triggerUsed = false;

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final AnimationChanged event) {
        if (!(triggerBase instanceof OnAnimationChanged)) return false;
        final OnAnimationChanged trigger = (OnAnimationChanged) triggerBase;

        // Player check.
        if (event.getActor() != client.getLocalPlayer()) {
            return false;
        }

        // Animation id check.
        animationIdCheck: if (trigger.animationId != null) {
            for (final int animationId : trigger.animationId) {
                if (event.getActor().getAnimation() == animationId) {
                    break animationIdCheck;
                }
            }

            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.events.ItemDespawned;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.OnItemPickup;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnItemPickup extends ListenerBase {
    public ListenerOnItemPickup(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final ItemDespawned event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;

            final OnItemPickup trigger = (OnItemPickup) triggerBase;
            boolean triggerUsed = false;

            if (trigger.pickUpToStorage.isPresent()) {
                ((ChargedItemWithStorage) chargedItem).storage.add(event.getItem().getId(), event.getItem().getQuantity());
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final ItemDespawned event) {
        if (!(triggerBase instanceof OnItemPickup)) return false;
        if (!(chargedItem instanceof ChargedItemWithStorage)) return false;
        final OnItemPickup trigger = (OnItemPickup) triggerBase;
        final ChargedItemWithStorage chargedItem = (ChargedItemWithStorage) this.chargedItem;

        // Correct item check.
        boolean correctItem = false;
        for (final StorageItem storageItem : chargedItem.storage.getStorableItems()) {
            if (event.getItem().getId() == storageItem.itemId) {
                correctItem = true;
                break;
            }
        }
        if (!correctItem) {
            return false;
        }

        // By one check.
        if (trigger.isByOne.isPresent() && trigger.isByOne.get() && event.getItem().getQuantity() > 1) {
            return false;
        }

        // Menu option check.
        if (!chargedItem.store.inMenuOptions("Take")) {
            return false;
        }

        // Menu target check.
        if (!chargedItem.store.inMenuTargets(event.getItem().getId())) {
            return false;
        }

        // Player location check.
        if (client.getLocalPlayer().getWorldLocation().distanceTo(event.getTile().getWorldLocation()) > 1) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnUserAction;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnUserAction extends ListenerBase {
    public ListenerOnUserAction(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger() {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase)) continue;

            final OnUserAction trigger = (OnUserAction) triggerBase;
            boolean triggerUsed = false;

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase) {
        if (!(triggerBase instanceof OnUserAction)) return false;

        final OnUserAction trigger = (OnUserAction) triggerBase;
        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnVarbitChanged;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnVarbitChanged extends ListenerBase {
    public ListenerOnVarbitChanged(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final VarbitChanged event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnVarbitChanged trigger = (OnVarbitChanged) triggerBase;
            boolean triggerUsed = false;

            // Set dynamically.
            if (trigger.setDynamically.isPresent() && chargedItem instanceof ChargedItem) {
                ((ChargedItem) chargedItem).setCharges(event.getValue());
            }

            // Varbit value consumer.
            if (trigger.varbitValueConsumer.isPresent()) {
                trigger.varbitValueConsumer.get().accept(event.getValue());
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final VarbitChanged event) {
        if (!(triggerBase instanceof OnVarbitChanged)) return false;
        final OnVarbitChanged trigger = (OnVarbitChanged) triggerBase;

        // Varbit id check.
        if (event.getVarbitId() != trigger.varbitId) {
            return false;
        }

        // Varbit value check.
        if (trigger.varbitValue.isPresent() && event.getValue() != trigger.varbitValue.get()) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;

import java.util.regex.Matcher;

import static tictac7x.charges.TicTac7xChargesImprovedPlugin.getNumberFromCommaString;

public class ListenerOnChatMessage extends ListenerBase {
    public ListenerOnChatMessage(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final ChatMessage event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            boolean triggerUsed = false;
            final OnChatMessage trigger = (OnChatMessage) triggerBase;

            final String message = TicTac7xChargesImprovedPlugin.getCleanChatMessage(event);
            final Matcher matcher = trigger.message.matcher(message);
            matcher.find();

            if (trigger.setDynamically.isPresent() && (chargedItem instanceof ChargedItem)) {
                ((ChargedItem) chargedItem).setCharges(getNumberFromCommaString(matcher.group("charges")));
                triggerUsed = true;
            }

            if (trigger.increaseDynamically.isPresent() && (chargedItem instanceof ChargedItem)) {
                ((ChargedItem) chargedItem).increaseCharges(getNumberFromCommaString(matcher.group("charges")));
                triggerUsed = true;
            }

            if (trigger.decreaseDynamically.isPresent() && (chargedItem instanceof ChargedItem)) {
                ((ChargedItem) chargedItem).decreaseCharges(getNumberFromCommaString(matcher.group("charges")));
                triggerUsed = true;
            }

            if (trigger.useDifference.isPresent() && (chargedItem instanceof ChargedItem)) {
                ((ChargedItem) chargedItem).setCharges(getNumberFromCommaString(matcher.group("total")) - getNumberFromCommaString(matcher.group("used")));
                triggerUsed = true;
            }

            if (trigger.matcherConsumer.isPresent()) {
                trigger.matcherConsumer.get().accept(matcher);
                triggerUsed = true;
            }

            if (trigger.stringConsumer.isPresent()) {
                trigger.stringConsumer.get().accept(message);
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final ChatMessage event) {
        if (!(triggerBase instanceof OnChatMessage)) return false;
        final OnChatMessage trigger = (OnChatMessage) triggerBase;

        // Message check.
        final String message = TicTac7xChargesImprovedPlugin.getCleanChatMessage(event);
        final Matcher matcher = trigger.message.matcher(message);
        if (!matcher.find()) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.events.GraphicChanged;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnGraphicChanged extends ListenerBase {
    public ListenerOnGraphicChanged(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final GraphicChanged event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnGraphicChanged trigger = (OnGraphicChanged) triggerBase;
            boolean triggerUsed = false;

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final GraphicChanged event) {
        if (!(triggerBase instanceof OnGraphicChanged)) return false;
        final OnGraphicChanged trigger = (OnGraphicChanged) triggerBase;

        // Player check.
        if (event.getActor() != client.getLocalPlayer()) {
            return false;
        }

        // Graphic id check.
        graphicIdCheck: if (trigger.graphicId != null) {
            for (final int graphicId : trigger.graphicId) {
                if (event.getActor().hasSpotAnim(graphicId)) {
                    break graphicIdCheck;
                }
            }

            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnResetDaily extends ListenerBase {
    public ListenerOnResetDaily(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public boolean trigger() {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase)) continue;
            final OnResetDaily trigger = (OnResetDaily) triggerBase;
            boolean triggerUsed = false;

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return true;
        }

        return false;
    }

    public boolean isValidTrigger(final TriggerBase triggerBase) {
        if (!(triggerBase instanceof OnResetDaily)) return false;
        final OnResetDaily trigger = (OnResetDaily) triggerBase;

        if (trigger.resetSpecificItem.isPresent() && !chargedItem.store.itemInPossession(trigger.resetSpecificItem.get())) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.store.ReplaceTarget;

import java.util.ArrayList;
import java.util.List;

public class ListenerOnMenuEntryAdded extends ListenerBase {
    public ListenerOnMenuEntryAdded(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final MenuEntryAdded event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnMenuEntryAdded trigger = (OnMenuEntryAdded) triggerBase;
            boolean triggerUsed = false;

            if (trigger.replaceOption.isPresent()) {
                event.getMenuEntry().setOption(trigger.replaceOption.get());
                triggerUsed = true;
            }

            if (trigger.replaceTargets.isPresent()) {
                for (final ReplaceTarget replaceTarget : trigger.replaceTargets.get()) {
                    if (event.getTarget().contains(replaceTarget.target)) {
                        event.getMenuEntry().setTarget(event.getTarget().replaceAll(replaceTarget.target, replaceTarget.replace));
                        triggerUsed = true;
                        break;
                    }
                }
            }

            if (trigger.replaceTargetDynamically.isPresent() && event.getTarget().contains(trigger.replaceTargetDynamically.get().target)) {
                try {
                    event.getMenuEntry().setTarget(event.getTarget().replaceAll(trigger.replaceTargetDynamically.get().target, trigger.replaceTargetDynamically.get().replace.call()));
                } catch (final Exception ignored) {}
                triggerUsed = true;
            }

            if (trigger.hide.isPresent() && trigger.menuEntryOption.isPresent()) {
                final List<MenuEntry> newMenuEntries = new ArrayList<>();

                for (final MenuEntry entry : client.getMenuEntries()) {
                    if (!entry.getOption().equals(trigger.menuEntryOption.get())) {
                        newMenuEntries.add(entry);
                    }
                }

                client.setMenuEntries(newMenuEntries.toArray(new MenuEntry[0]));
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final MenuEntryAdded event) {
        if (!(triggerBase instanceof OnMenuEntryAdded)) return false;
        final OnMenuEntryAdded trigger = (OnMenuEntryAdded) triggerBase;

        // Check base triggers to avoid calling impostor id getters on client.
        impostorIdsTargetCheck: if (trigger.replaceImpostorIds.isPresent() && trigger.onMenuTarget.isPresent()) {
            for (final String target : trigger.onMenuTarget.get()) {
                if (event.getTarget().contains(target)) {
                    break impostorIdsTargetCheck;
                }
            }

            if (!super.isValidTrigger(trigger)) {
                return false;
            }
        }

        // Item id check.
        if (!trigger.replaceImpostorIds.isPresent() && event.getMenuEntry().getItemId() != chargedItem.itemId) {
            return false;
        }

        // Hide config check.
        if (trigger.hide.isPresent() && !config.hideDestroy()) {
            return false;
        }

        // Menu entry option check.
        if (trigger.menuEntryOption.isPresent() && !event.getOption().equals(trigger.menuEntryOption.get())) {
            return false;
        }

        // Menu option replace check.
        if (trigger.replaceOption.isPresent() && (
            !trigger.menuEntryOption.isPresent() ||
            !config.useCommonMenuEntries() ||
            !event.getOption().equals(trigger.menuEntryOption.get())
        )) {
            return false;
        }

        // Menu target replace check.
        menuReplaceTargetsCheck: if (trigger.replaceTargets.isPresent()) {
            for (final ReplaceTarget replaceTarget: trigger.replaceTargets.get()) {
                if (event.getTarget().contains(replaceTarget.target)) {
                    break menuReplaceTargetsCheck;
                }
            }

            return false;
        }

        // Menu replace impostor id check.
        replaceImpostorIdCheck: if (trigger.replaceImpostorIds.isPresent()) {
            for (final int impostorId : trigger.replaceImpostorIds.get()) {
                try {
                    if (client.getObjectDefinition(event.getMenuEntry().getIdentifier()).getImpostor().getId() == impostorId) {
                        break replaceImpostorIdCheck;
                    }
                } catch (final Exception ignored) {}
            }

            return false;
        }

        return true;
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.api.events.StatChanged;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnXpDrop extends ListenerBase {
    public ListenerOnXpDrop(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final StatChanged event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnXpDrop trigger = (OnXpDrop) triggerBase;
            boolean triggerUsed = false;

            if (trigger.xpAmountConsumer.isPresent()) {
                trigger.xpAmountConsumer.get().accept(event.getXp() - chargedItem.store.getSkillXp(trigger.skill).get());
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final StatChanged event) {
        if (!(triggerBase instanceof OnXpDrop)) return false;
        final OnXpDrop trigger = (OnXpDrop) triggerBase;
        final Skill skill = event.getSkill();

        // Skill check.
        if (trigger.skill != skill) {
            return false;
        }

        // XP drop check.
        if (
            !chargedItem.store.getSkillXp(skill).isPresent() ||
            chargedItem.store.getSkillXp(skill).get() == event.getXp()
        ) {
            return false;
        }

        // Amount check.
        if (trigger.amount.isPresent() && (
            !chargedItem.store.getSkillXp(trigger.skill).isPresent() ||
            trigger.amount.get() != (event.getXp() - chargedItem.store.getSkillXp(trigger.skill).get()))
        ) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.ChargedItemWithStatus;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.store.AdvancedMenuEntry;

import java.util.regex.Matcher;

public abstract class ListenerBase {
    protected final Client client;
    protected final ItemManager itemManager;
    protected final ChargedItemBase chargedItem;
    protected final Notifier notifier;
    protected final TicTac7xChargesImprovedConfig config;

    public ListenerBase(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        this.client = client;
        this.itemManager = itemManager;
        this.chargedItem = chargedItem;
        this.notifier = notifier;
        this.config = config;
    }

    boolean trigger(final TriggerBase trigger) {
        boolean triggerUsed = false;

        // Fixed charges.
        if (trigger.fixedCharges.isPresent() && (chargedItem instanceof ChargedItem)) {
            ((ChargedItem) chargedItem).setCharges(trigger.fixedCharges.get());
            triggerUsed = true;
        }

        // Increase charges.
        if (trigger.increaseCharges.isPresent() && (chargedItem instanceof ChargedItem)) {
            ((ChargedItem) chargedItem).increaseCharges(trigger.increaseCharges.get());
            triggerUsed = true;
        }

        // Decrease charges.
        if (trigger.decreaseCharges.isPresent() && (chargedItem instanceof ChargedItem)) {
            ((ChargedItem) chargedItem).decreaseCharges(trigger.decreaseCharges.get());
            triggerUsed = true;
        }

        // Empty storage.
        if (trigger.emptyStorage.isPresent() && (chargedItem instanceof ChargedItemWithStorage)) {
            ((ChargedItemWithStorage) chargedItem).storage.clear();
            triggerUsed = true;
        }

        // Empty storage to inventory.
        if (trigger.emptyStorageToInventory.isPresent() && (chargedItem instanceof ChargedItemWithStorage)) {
            ((ChargedItemWithStorage) chargedItem).storage.emptyToInventory();
            triggerUsed = true;
        }

        // Add to storage.
        if (trigger.addToStorage.isPresent() && (chargedItem instanceof ChargedItemWithStorage)) {
            ((ChargedItemWithStorage) chargedItem).storage.add(trigger.addToStorage.get()[0], trigger.addToStorage.get()[1]);
            triggerUsed = true;
        }

        // Add to storage.
        if (trigger.removeFromStorage.isPresent() && (chargedItem instanceof ChargedItemWithStorage)) {
            ((ChargedItemWithStorage) chargedItem).storage.remove(trigger.removeFromStorage.get().itemId, trigger.removeFromStorage.get().quantity);
            triggerUsed = true;
        }

        // Consumer.
        if (trigger.consumer.isPresent()) {
            if (trigger.runConsumerOnNextGameTick.isPresent() && trigger.runConsumerOnNextGameTick.get()) {
                chargedItem.store.nextTickQueue.add(trigger.consumer.get());
            } else {
                trigger.consumer.get().run();
            }
            triggerUsed = true;
        }

        // Activate.
        if (trigger.activate.isPresent() && (chargedItem instanceof ChargedItemWithStatus)) {
            ((ChargedItemWithStatus) chargedItem).activate();
            triggerUsed = true;
        }

        // Deactivate.
        if (trigger.deactivate.isPresent() && (chargedItem instanceof ChargedItemWithStatus)) {
            ((ChargedItemWithStatus) chargedItem).deactivate();
            triggerUsed = true;
        }

        // Notification
        if (trigger.notificationCustom.isPresent()) {
            notifier.notify(trigger.notificationCustom.get());
            triggerUsed = true;
        }

        return triggerUsed;
    }

    boolean isValidTrigger(final TriggerBase trigger) {
        // Specific item check.
        specificItemCheck: if (trigger.requiredItem.isPresent()) {
            for (final int itemId : trigger.requiredItem.get()) {
                if (chargedItem.store.inventoryContainsItem(itemId) || chargedItem.store.equipmentContainsItem(itemId)) {
                    break specificItemCheck;
                }
            }
            return false;
        }

        // Unallowed items check.
        if (trigger.unallowedItem.isPresent()) {
            for (final int itemId : trigger.unallowedItem.get()) {
                if (chargedItem.store.inventoryContainsItem(itemId) || chargedItem.store.equipmentContainsItem(itemId)) {
                    return false;
                }
            }
        }

        // On item click check.
        if (trigger.onItemClick.isPresent() && chargedItem.store.notInMenuTargets(chargedItem.itemId)) {
            return false;
        }

        // Menu option check.
        if (trigger.onMenuOption.isPresent() && chargedItem.store.notInMenuOptions(trigger.onMenuOption.get())) {
            return false;
        }

        // Menu option ids check.
        if (trigger.onMenuOptionId.isPresent() && chargedItem.store.notInMenuOptionIds(trigger.onMenuOptionId.get())) {
            return false;
        }

        // Menu target check.
        if (trigger.onMenuTarget.isPresent() && chargedItem.store.notInMenuTargets(trigger.onMenuTarget.get())) {
            return false;
        }

        // Menu impostor id check.
        if (trigger.onMenuImpostor.isPresent() && chargedItem.store.notInMenuImpostors(trigger.onMenuImpostor.get())) {
            return false;
        }

        // Equipped check.
        if (trigger.isEquipped.isPresent() && !chargedItem.store.equipmentContainsItem(chargedItem.itemId)) {
            return false;
        }

        // Use storage item on charged item check.
        if (trigger.onUseStorageItemOnChargedItem.isPresent() && chargedItem instanceof ChargedItemWithStorage) {
            boolean isValid = false;
            loopChecker: for (final AdvancedMenuEntry menuEntry : chargedItem.store.menuOptionsClicked) {
                if (!menuEntry.target.contains(" -> ")) {
                    continue;
                };

                final String itemOne = menuEntry.target.split(" -> ")[0];
                final String itemTwo = menuEntry.target.split(" -> ")[1];

                if (!itemOne.equals(chargedItem.getItemName()) && !itemTwo.equals(chargedItem.getItemName())) {
                    continue;
                }
                for (final StorageItem storeableItem : ((ChargedItemWithStorage) chargedItem).storage.getStorableItems()) {
                    if (
                        itemOne.equals(itemManager.getItemComposition(storeableItem.itemId).getName()) ||
                        itemTwo.equals(itemManager.getItemComposition(storeableItem.itemId).getName())
                    ) {
                        isValid = true;
                        break loopChecker;
                    }
                }
            }

            if (!isValid) {
                return false;
            }
        }

        // Use charged item on storage item check.
        if (trigger.onUseChargedItemOnStorageItem.isPresent() && chargedItem instanceof ChargedItemWithStorage) {
            boolean useCheck = false;
            useCheckLooper: for (final AdvancedMenuEntry menuEntry : chargedItem.store.menuOptionsClicked) {
                if (!menuEntry.option.equals("Use") || !menuEntry.target.contains(" -> ") || !menuEntry.target.split(" -> ")[0].equals(itemManager.getItemComposition(chargedItem.itemId).getName())) continue;

                for (final StorageItem storageItem : ((ChargedItemWithStorage) chargedItem).getStorage().values()) {
                    if (menuEntry.target.split(" -> ")[1].equals(itemManager.getItemComposition(storageItem.itemId).getName())) {
                        useCheck = true;
                        break useCheckLooper;
                    }
                }
            }
            if (!useCheck) {
                return false;
            }
        }

        // Activated check.
        if ((chargedItem instanceof ChargedItemWithStatus) && trigger.isActivated.isPresent() && trigger.isActivated.get() && !((ChargedItemWithStatus) chargedItem).isActivated()) {
            return false;
        }

        // Chat message check.
        if (trigger.hasChatMessage.isPresent()) {
            if (!chargedItem.store.getLastChatMessage().isPresent()) {
                return false;
            }

            final Matcher matcher = trigger.hasChatMessage.get().matcher(chargedItem.store.getLastChatMessage().get());
            if (!matcher.find()) {
                return false;
            }
        }

        if (trigger.emptyStorageToInventory.isPresent() && !(chargedItem instanceof ChargedItemWithStorage)) {
            return false;
        }

        return true;
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;

public class ListenerOnItemContainerChanged extends ListenerBase {
    public ListenerOnItemContainerChanged(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final ItemContainerChanged event) {
        // Get quantity from amount in item container.
        for (final TriggerItem triggerItem : chargedItem.items) {
            if (triggerItem.quantityCharges.isPresent()) {
               for (final Item item : event.getItemContainer().getItems()) {
                    if (item.getId() == triggerItem.itemId) {
                        ((ChargedItem) chargedItem).setCharges(item.getQuantity());
                        break;
                    }
                }
            }
        }

        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            boolean triggerUsed = false;
            final OnItemContainerChanged trigger = (OnItemContainerChanged) triggerBase;

            // Fill storage from inventory all items.
            if (trigger.fillStorageFromInventory.isPresent()) {
                ((ChargedItemWithStorage) chargedItem).storage.fillFromInventory();
                triggerUsed = true;
            }

            // Empty storage to bank.
            if (trigger.emptyStorageToBank.isPresent()) {
                ((ChargedItemWithStorage) chargedItem).storage.emptyToBank();
                triggerUsed = true;
            }

            // Empty storage to inventory.
            if (trigger.emptyStorageToInventory.isPresent()) {
                ((ChargedItemWithStorage) chargedItem).storage.emptyToInventory();
                triggerUsed = true;
            }

            // Update storage directly from item container.
            if (trigger.updateStorage.isPresent()) {
                ((ChargedItemWithStorage) chargedItem).storage.updateFromItemContainer(event.getItemContainer());
                triggerUsed = true;
            }

            if (trigger.onItemContainerDifference.isPresent()) {
                trigger.onItemContainerDifference.get().accept(chargedItem.store.getInventoryItemsDifference());
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final ItemContainerChanged event) {
        if (!(triggerBase instanceof OnItemContainerChanged)) return false;
        final OnItemContainerChanged trigger = (OnItemContainerChanged) triggerBase;

        // Item container type check.
        final ItemContainer itemContainer = event.getItemContainer();
        if (
            itemContainer == null || itemContainer.getId() != trigger.itemContainerId) {
            return false;
        }

        // Fill storage from inventory check.
        if (trigger.fillStorageFromInventory.isPresent() && !(chargedItem instanceof ChargedItemWithStorage)) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.triggers;

public class OnGraphicChanged extends TriggerBase {
    public final int[] graphicId;

    public OnGraphicChanged(final int ...graphicId) {
        this.graphicId = graphicId;
    }
}

package tictac7x.charges.item.triggers;

import net.runelite.api.Skill;

public class OnStatChanged extends TriggerBase {
    public final Skill skill;

    public OnStatChanged(final Skill skill) {
        this.skill = skill;
    }
}

package tictac7x.charges.item.triggers;

import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.store.ItemWithQuantity;
import tictac7x.charges.store.ItemsDifference;

import java.util.Optional;
import java.util.function.Consumer;
import java.util.regex.Pattern;

public abstract class TriggerBase {
    // Checks.
    public Optional<int[]> requiredItem = Optional.empty();
    public Optional<int[]> unallowedItem = Optional.empty();
    public Optional<String[]> onMenuOption = Optional.empty();
    public Optional<int[]> onMenuOptionId = Optional.empty();
    public Optional<String[]> onMenuTarget = Optional.empty();
    public Optional<int[]> onMenuImpostor = Optional.empty();
    public Optional<Boolean> onItemClick = Optional.empty();
    public Optional<StorageItem[]> onUseStorageItemOnChargedItem = Optional.empty();
    public Optional<StorageItem[]> onUseChargedItemOnStorageItem = Optional.empty();
    public Optional<Boolean> isEquipped = Optional.empty();
    public Optional<Pattern> hasChatMessage = Optional.empty();
    public Optional<Boolean> runConsumerOnNextGameTick = Optional.empty();
    public boolean multiTrigger = false;

    // Actions.
    public Optional<Integer> fixedCharges = Optional.empty();
    public Optional<Integer> increaseCharges = Optional.empty();
    public Optional<Integer> decreaseCharges = Optional.empty();
    public Optional<Runnable> consumer = Optional.empty();

    public Optional<String> notificationCustom = Optional.empty();

    // Storage.
    public Optional<Boolean> emptyStorage = Optional.empty();
    public Optional<Boolean> emptyStorageToInventory = Optional.empty();
    public Optional<Boolean> pickUpToStorage = Optional.empty();
    public Optional<int[]> addToStorage = Optional.empty();
    public Optional<ItemWithQuantity> removeFromStorage = Optional.empty();

    // Activity.
    public Optional<Boolean> isActivated = Optional.empty();
    public Optional<Boolean> activate = Optional.empty();
    public Optional<Boolean> deactivate = Optional.empty();

    public Optional<Consumer<ItemsDifference>> onItemContainerDifference = Optional.empty();

    public TriggerBase setFixedCharges(final int charges) {
        this.fixedCharges = Optional.of(charges);
        return this;
    }

    public TriggerBase increaseCharges(final int charges) {
        this.increaseCharges = Optional.of(charges);
        return this;
    }

    public TriggerBase decreaseCharges(final int charges) {
        this.decreaseCharges = Optional.of(charges);
        return this;
    }

    public TriggerBase emptyStorage() {
        this.emptyStorage = Optional.of(true);
        return this;
    }

    public TriggerBase emptyStorageToInventory() {
        this.emptyStorageToInventory = Optional.of(true);
        return this;
    }

    public TriggerBase requiredItem(final int ...itemIds) {
        this.requiredItem = Optional.of(itemIds);
        return this;
    }

    public TriggerBase unallowedItem(final int ...itemIds) {
        this.unallowedItem = Optional.of(itemIds);
        return this;
    }

    public TriggerBase onMenuOption(final String ...options) {
        this.onMenuOption = Optional.of(options);
        return this;
    }

    public TriggerBase onMenuOptionId(final int ...menuOptionIds) {
        this.onMenuOptionId = Optional.of(menuOptionIds);
        return this;
    }

    public TriggerBase onMenuTarget(final String ...targets) {
        this.onMenuTarget = Optional.of(targets);
        return this;
    }

    public TriggerBase onMenuImpostor(final int ...impostorIds) {
        this.onMenuImpostor = Optional.of(impostorIds);
        return this;
    }

    public TriggerBase onItemClick() {
        this.onItemClick = Optional.of(true);
        return this;
    }

    public TriggerBase pickUpToStorage() {
        this.pickUpToStorage = Optional.of(true);
        return this;
    }

    public TriggerBase onUseStorageItemOnChargedItem(final StorageItem[] storeableItems) {
        this.onUseStorageItemOnChargedItem = Optional.of(storeableItems);
        return this;
    }

    public TriggerBase onUseChargedItemOnStorageItem(final StorageItem[] storeableItems) {
        this.onUseChargedItemOnStorageItem = Optional.of(storeableItems);
        return this;
    }

    public TriggerBase activate() {
        this.activate = Optional.of(true);
        return this;
    }

    public TriggerBase deactivate() {
        this.deactivate = Optional.of(true);
        return this;
    }

    public TriggerBase notification(final String notification) {
        this.notificationCustom = Optional.of(notification);
        return this;
    }

    public TriggerBase isEquipped() {
        this.isEquipped = Optional.of(true);
        return this;
    }

    public TriggerBase consumer(final Runnable consumer) {
        this.consumer = Optional.of(consumer);
        return this;
    }

    public TriggerBase runConsumerOnNextGameTick(final Runnable consumer) {
        this.runConsumerOnNextGameTick = Optional.of(true);
        this.consumer = Optional.of(consumer);
        return this;
    }

    public TriggerBase isActivated() {
        this.isActivated = Optional.of(true);
        return this;
    }

    public TriggerBase addToStorage(final int itemId, final int quantity) {
        this.addToStorage = Optional.of(new int[]{itemId, quantity});
        return this;
    }

    public TriggerBase addToStorage(final int itemId) {
        this.addToStorage = Optional.of(new int[]{itemId, 1});
        return this;
    }

    public TriggerBase multiTrigger() {
        this.multiTrigger = true;
        return this;
    }

    public TriggerBase onItemContainerDifference(Consumer<ItemsDifference> consumer) {
        this.onItemContainerDifference = Optional.of(consumer);
        return this;
    }

    public TriggerBase removeFromStorage(final int itemId, final int quantity) {
        this.removeFromStorage = Optional.of(new ItemWithQuantity(itemId, quantity));
        return this;
    }

    public TriggerBase hasChatMessage(final String message) {
        this.hasChatMessage = Optional.of(Pattern.compile(message));
        return this;
    }
}

package tictac7x.charges.item.triggers;

public class OnAnimationChanged extends TriggerBase {
    public final int[] animationId;

    public OnAnimationChanged(final int ...animationId) {
        this.animationId = animationId;
    }
}

package tictac7x.charges.item.triggers;

import java.util.Optional;
import java.util.function.Consumer;

public class OnVarbitChanged extends TriggerBase {
    public final int varbitId;

    public Optional<Integer> varbitValue = Optional.empty();
    public Optional<Consumer<Integer>> varbitValueConsumer = Optional.empty();
    public Optional<Boolean> setDynamically = Optional.empty();

    public OnVarbitChanged(final int varbitId) {
        this.varbitId = varbitId;
    }

    public OnVarbitChanged(final int varbitId, final int varbitValue) {
        this.varbitId = varbitId;
        this.varbitValue = Optional.of(varbitValue);
    }

    public OnVarbitChanged varbitValueConsumer(final Consumer<Integer> consumer) {
        this.varbitValueConsumer = Optional.of(consumer);
        return this;
    }

    public OnVarbitChanged setDynamically() {
        this.setDynamically = Optional.of(true);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import java.util.Optional;

public class OnItemContainerChanged extends TriggerBase {
    public final int itemContainerId;

    public Optional<Boolean> updateStorage = Optional.empty();
    public Optional<Boolean> fillStorageFromInventory = Optional.empty();
    public Optional<Boolean> emptyStorageToInventory = Optional.empty();
    public Optional<Boolean> emptyStorageToBank = Optional.empty();

    public OnItemContainerChanged(final int itemContainerId) {
        this.itemContainerId = itemContainerId;
    }

    public OnItemContainerChanged fillStorageFromInventory() {
        this.fillStorageFromInventory = Optional.of(true);
        return this;
    }

    public OnItemContainerChanged emptyStorageToInventory() {
        this.emptyStorageToInventory = Optional.of(true);
        return this;
    }

    public OnItemContainerChanged updateStorage() {
        this.updateStorage = Optional.of(true);
        return this;
    }

    public OnItemContainerChanged emptyStorageToBank() {
        this.emptyStorageToBank = Optional.of(true);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import java.util.Optional;

public class OnResetDaily extends TriggerBase {
    public Optional<Integer> resetSpecificItem = Optional.empty();

    public OnResetDaily specificItem(final int itemId) {
        this.resetSpecificItem = Optional.of(itemId);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import java.util.Optional;

public class TriggerItem {
    public final int itemId;

    public Optional<Boolean> quantityCharges = Optional.empty();
    public Optional<Boolean> hideOverlay = Optional.empty();
    public Optional<Boolean> needsToBeEquipped = Optional.empty();
    public Optional<Integer> maxCharges = Optional.empty();
    public Optional<Integer> fixedCharges = Optional.empty();

    public TriggerItem(final int itemId) {
        this.itemId = itemId;
    }

    public TriggerItem fixedCharges(final int charges) {
        this.fixedCharges = Optional.of(charges);
        return this;
    }

    public TriggerItem quantityCharges() {
        this.quantityCharges = Optional.of(true);
        return this;
    }

    public TriggerItem hideOverlay() {
        this.hideOverlay = Optional.of(true);
        return this;
    }

    public TriggerItem needsToBeEquipped() {
        this.needsToBeEquipped = Optional.of(true);
        return this;
    }

    public TriggerItem maxCharges(final int charges) {
        this.maxCharges = Optional.of(charges);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import net.runelite.api.Skill;
import net.runelite.api.events.ScriptPreFired;

import java.util.Optional;
import java.util.function.Consumer;

public class OnScriptPreFired extends TriggerBase {
    public final int scriptId;
    public Optional<Consumer<ScriptPreFired>> scriptConsumer = Optional.empty();

    public OnScriptPreFired(final int scriptId) {
        this.scriptId = scriptId;
    }

    public OnScriptPreFired scriptConsumer(final Consumer<ScriptPreFired> consumer) {
        this.scriptConsumer = Optional.of(consumer);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import tictac7x.charges.store.AdvancedMenuEntry;

import java.util.Optional;
import java.util.function.Consumer;

public class OnMenuOptionClicked extends TriggerBase {
    public final String option;
    public Optional<Consumer<AdvancedMenuEntry>> menuOptionConsumer = Optional.empty();

    public OnMenuOptionClicked(final String option) {
        this.option = option;
    }

    public OnMenuOptionClicked menuOptionConsumer(final Consumer<AdvancedMenuEntry> consumer) {
        this.menuOptionConsumer = Optional.of(consumer);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import net.runelite.api.Skill;

import java.util.Optional;
import java.util.function.Consumer;

public class OnXpDrop extends TriggerBase {
    public final Skill skill;
    public Optional<Integer> amount = Optional.empty();
    public Optional<Consumer<Integer>> xpAmountConsumer = Optional.empty();

    public OnXpDrop(final Skill skill) {
        this.skill = skill;
    }

    public OnXpDrop(final Skill skill, final int amount) {
        this.skill = skill;
        this.amount = Optional.of(amount);
    }

    public OnXpDrop xpAmountConsumer(final Consumer<Integer> xpAmountConsumer) {
        this.xpAmountConsumer = Optional.of(xpAmountConsumer);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import tictac7x.charges.store.HitsplatGroup;
import tictac7x.charges.store.HitsplatTarget;

import java.util.Optional;

public class OnHitsplatApplied extends TriggerBase {
    public final HitsplatTarget hitsplatTarget;
    public HitsplatGroup hitsplatGroup = HitsplatGroup.REGULAR;

    public Optional<Boolean> moreThanZeroDamage = Optional.empty();

    public OnHitsplatApplied(final HitsplatTarget hitsplatTarget) {
        this.hitsplatTarget = hitsplatTarget;
    }

    public OnHitsplatApplied moreThanZeroDamage() {
        this.moreThanZeroDamage = Optional.of(true);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import tictac7x.charges.store.DynamicReplaceTarget;
import tictac7x.charges.store.ReplaceTarget;

import java.util.Optional;
import java.util.concurrent.Callable;

public class OnMenuEntryAdded extends TriggerBase {
    public final Optional<String> menuEntryOption;
    public Optional<Boolean> hide = Optional.empty();
    public Optional<String> replaceOption = Optional.empty();
    public Optional<ReplaceTarget[]> replaceTargets = Optional.empty();
    public Optional<int[]> replaceImpostorIds = Optional.empty();
    public Optional<DynamicReplaceTarget> replaceTargetDynamically = Optional.empty();

    public OnMenuEntryAdded() {
        this.menuEntryOption = Optional.empty();
    }

    public OnMenuEntryAdded(final String option) {
        this.menuEntryOption = Optional.of(option);
    }

    public OnMenuEntryAdded hide() {
        this.hide = Optional.of(true);
        return this;
    }

    public OnMenuEntryAdded replaceOption(final String option) {
        this.replaceOption = Optional.of(option);
        return this;
    }

    public OnMenuEntryAdded replaceTarget(final String target, final String replace) {
        return replaceTargets(new ReplaceTarget(target, replace));
    }

    public OnMenuEntryAdded replaceTargetDynamically(final String target, final Callable<String> dynamicTarget) {
        this.replaceTargetDynamically = Optional.of(new DynamicReplaceTarget(target, dynamicTarget));
        return this;
    }

    public OnMenuEntryAdded replaceTargets(final ReplaceTarget ...targets) {
        this.replaceTargets = Optional.of(targets);
        return this;
    }

    public OnMenuEntryAdded isReplaceImpostorId(final int ...impostorIds) {
        this.replaceImpostorIds = Optional.of(impostorIds);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import java.util.Optional;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class OnChatMessage extends TriggerBase {
    public final Pattern message;

    public Optional<Boolean> setDynamically = Optional.empty();
    public Optional<Boolean> increaseDynamically = Optional.empty();
    public Optional<Boolean> decreaseDynamically = Optional.empty();
    public Optional<Boolean> useDifference = Optional.empty();
    public Optional<Consumer<Matcher>> matcherConsumer = Optional.empty();
    public Optional<Boolean> notification = Optional.empty();
    public Optional<Consumer<String>> stringConsumer = Optional.empty();

    public OnChatMessage(final String message) {
        this.message = Pattern.compile(message);
    }

    public TriggerBase setDynamicallyCharges() {
        this.setDynamically = Optional.of(true);
        return this;
    }

    public OnChatMessage matcherConsumer(final Consumer<Matcher> consumer) {
        this.matcherConsumer = Optional.of(consumer);
        return this;
    }

    public OnChatMessage notification() {
        this.notification = Optional.of(true);
        return this;
    }

    public OnChatMessage increaseDynamically() {
        this.increaseDynamically = Optional.of(true);
        return this;
    }

    public OnChatMessage useDifference() {
        this.useDifference = Optional.of(true);
        return this;
    }

    public OnChatMessage stringConsumer(final Consumer<String> consumer) {
        this.stringConsumer = Optional.of(consumer);
        return this;
    }

    public OnChatMessage decreaseDynamicallyCharges() {
        this.decreaseDynamically = Optional.of(true);
        return this;
    }
}

package tictac7x.charges.item.triggers;

public class OnUserAction extends TriggerBase {}

package tictac7x.charges.item.triggers;

import tictac7x.charges.store.ItemWithQuantity;

import java.util.Optional;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class OnWidgetLoaded extends TriggerBase {
    public final int groupId;
    public final int childId;
    public Optional<Integer> subChildId = Optional.empty();

    public Optional<Pattern> text = Optional.empty();
    public Optional<Consumer<Matcher>> matcherConsumer = Optional.empty();
    public Optional<Consumer<Integer>> itemQuantityConsumer = Optional.empty();
    public Optional<Consumer<ItemWithQuantity>> itemWithQuantityConsumer = Optional.empty();
    public Optional<Consumer<Integer>> textAsChargesConsumer = Optional.empty();
    public Optional<Boolean> setDynamically = Optional.empty();

    public OnWidgetLoaded(final int groupId, final int childId) {
        this.groupId = groupId;
        this.childId = childId;
    }

    public OnWidgetLoaded(final int groupId, final int childId, final int subChildId) {
        this.groupId = groupId;
        this.childId = childId;
        this.subChildId = Optional.of(subChildId);
    }

    public OnWidgetLoaded setDynamically() {
        this.setDynamically = Optional.of(true);
        return this;
    }

    public OnWidgetLoaded text(final String text) {
        this.text = Optional.of(Pattern.compile(text));
        return this;
    }

    public OnWidgetLoaded matcherConsumer(final Consumer<Matcher> consumer) {
        this.matcherConsumer = Optional.of(consumer);
        return this;
    }

    public OnWidgetLoaded textAsChargesConsumer(final Consumer<Integer> consumer) {
        this.textAsChargesConsumer = Optional.of(consumer);
        return this;
    }

    public OnWidgetLoaded itemQuantityConsumer(final Consumer<Integer> consumer) {
        this.itemQuantityConsumer = Optional.of(consumer);
        return this;
    }

    public OnWidgetLoaded itemWithQuantityConsumer(final Consumer<ItemWithQuantity> consumer) {
        this.itemWithQuantityConsumer = Optional.of(consumer);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import tictac7x.charges.item.storage.StorageItem;

import java.util.Optional;

public class OnItemPickup extends TriggerBase {
    public final StorageItem[] items;
    public Optional<Boolean> isByOne = Optional.empty();

    public OnItemPickup(final StorageItem[] items) {
        this.items = items;
    }

    public OnItemPickup isByOne() {
        this.isByOne = Optional.of(true);
        return this;
    }
}

package tictac7x.charges.item;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.store.Store;

public class ChargedItemWithStorageMultipleCharges extends ChargedItemWithStorage {
    public ChargedItemWithStorageMultipleCharges(String configKey, int itemId, Client client, ClientThread clientThread, ConfigManager configManager, ItemManager itemManager, InfoBoxManager infoBoxManager, ChatMessageManager chatMessageManager, Notifier notifier, TicTac7xChargesImprovedConfig config, Store store, final Gson gson) {
        super(configKey, itemId, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
    }

    @Override
    public String getCharges() {
        String individualCharges = "";

        int validItems = 0;
        for (final StorageItem storageItem : getStorage().values()) {
            if (storageItem.quantity >= 0) {
                individualCharges += storageItem.quantity + "/";
                validItems++;
            }
        }

        return validItems > 0 ? individualCharges.replaceAll("/$", "") : "?";
    }
}

package tictac7x.charges.item.storage;

public class StorageItem {
    public final int itemId;
    public int quantity = 0;

    public StorageItem(final int itemId) {
        this.itemId = itemId;
    }

    public StorageItem(final int itemId, final int quantity) {
        this.itemId = itemId;
        this.quantity = quantity;
    }
}

package tictac7x.charges.item.storage;

import java.util.Optional;

public class StorableItem extends StorageItem {
    public Optional<String[]> checkName = Optional.empty();
    public Optional<String> displayName = Optional.empty();
    public Optional<Integer> order = Optional.empty();

    public StorableItem(int itemId) {
        super(itemId);
    }

    public StorableItem(int itemId, int quantity) {
        super(itemId, quantity);
    }

    public StorableItem checkName(final String ...checkName) {
        this.checkName = Optional.of(checkName);
        return this;
    }

    public StorableItem specificOrder(final int order) {
        this.order = Optional.of(order);
        return this;
    }

    public StorableItem displayName(final String displayName) {
        this.displayName = Optional.of(displayName);
        return this;
    }

    public StorableItem quantity(final int quantity) {
        this.quantity = quantity;
        return this;
    }
}

package tictac7x.charges.item.storage;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.ItemWithQuantity;
import tictac7x.charges.store.Store;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Optional;

public class Storage {
    private final ChargedItemWithStorage chargedItem;
    private final String storageConfigKey;
    private final ItemManager itemManager;
    private final ConfigManager configManager;
    private final Store store;
    private final Gson gson;

    protected Map<Integer, StorageItem> storage = new LinkedHashMap<>();

    public Optional<Integer> maximumTotalQuantity = Optional.empty();
    public Optional<Integer> maximumTotalQuantityWithItemEquipped = Optional.empty();
    public Optional<int[]> maximumTotalQuantityWithItemEquippedItems = Optional.empty();
    public Optional<Boolean> showIndividualCharges = Optional.empty();
    public boolean holdsSingleType = false;
    public boolean emptyIsNegative = false;
    private Optional<Integer> maximumIndividualQuantity = Optional.empty();
    private StorableItem[] storableItems = new StorableItem[]{};


    public Storage(final ChargedItemWithStorage chargedItem, final String configKey, final ItemManager itemManager, final ConfigManager configManager, final Store store, final Gson gson) {
        this.chargedItem = chargedItem;
        this.storageConfigKey = configKey + "_storage";
        this.itemManager = itemManager;
        this.configManager = configManager;
        this.store = store;
        this.gson = gson;
    }

    public Storage setMaximumTotalQuantity(final int quantity) {
        this.maximumTotalQuantity = Optional.of(quantity);
        return this;
    }

    public Storage emptyIsNegative() {
        this.emptyIsNegative = true;
        return this;
    }
    
    public Storage setHoldsSingleType(final boolean holdsSingleType) {
        this.holdsSingleType = holdsSingleType;
        return this;
    }

    public Storage setMaximumTotalQuantityWithEquippedItem(int quantity, final int ...itemIds) {
        this.maximumTotalQuantityWithItemEquipped = Optional.of(quantity);
        this.maximumTotalQuantityWithItemEquippedItems = Optional.of(itemIds);
        return this;
    }

    public Storage setMaximumIndividualQuantity(final int quantity) {
        this.maximumIndividualQuantity = Optional.of(quantity);
        return this;
    }

    public Storage showIndividualCharges() {
        this.showIndividualCharges = Optional.of(true);
        return this;
    }

    public Storage storableItems(final StorableItem... storableItems) {
        this.storableItems = storableItems;
        return this;
    }

    public void clear() {
        storage = new LinkedHashMap<>();
        save();
    }

    public void add(final int itemId, final int quantity) {
        if (getMaximumTotalQuantity().isPresent()) {
            if (getCharges() == getMaximumTotalQuantity().get()) {
                return;
            }
        }

        final Optional<StorageItem> item = getItem(itemId);
        put(itemId, (item.isPresent() ? item.get().quantity : 0) + quantity);
    }

    public void add(final Optional<StorageItem> item, final int quantity) {
        if (!item.isPresent()) return;
        add(item.get().itemId, quantity);
    }

    public void put(final Optional<StorageItem> item, final int quantity) {
        if (!item.isPresent()) return;
        put(item.get().itemId, quantity);
    }

    public void clearAndPut(final Optional<StorageItem> item, final int quantity) {
        if (!item.isPresent()) return;
        clearAndPut(item.get().itemId, quantity);
    }

    public void clearAndPut(final int itemId, final int quantity) {
        clear();
        put(itemId, quantity);
    }

    public void remove(final Optional<StorageItem> item, final int quantity) {
        if (!item.isPresent()) return;
        remove(item.get().itemId, quantity);
    }

    public void remove(final int itemId, final int quantity) {
        final Optional<StorageItem> item = getItem(itemId);

        // Don't decrease quantity of unlimited storage item.
        if (item.isPresent() && item.get().quantity == Charges.UNLIMITED) {
            return;
        }

        put(itemId, (item.isPresent() ? Math.max(0, item.get().quantity - quantity) : 0));
    }

    public void removeAndPrioritizeInventory(final int itemId, final int quantity) {
        this.remove(itemId, Math.max(quantity - store.getInventoryItemQuantity(itemId), 0));
    }

    public void removeAndPrioritizeInventory(final Optional<Integer> itemId, final int quantity) {
        if (itemId.isPresent()) {
            this.removeAndPrioritizeInventory(itemId.get(), quantity);
        }
    }

    public void put(final int itemId, int quantity) {
        // -1 = item that was previously in the array, but that slot no longer has an item.
        // 6512 = empty item inside huntsmans kit.
        if (itemId == -1 || itemId == 6512) return;

        // Storage holds only one unique item at once check.
        if (holdsSingleType) {
            for (final StorageItem storageItem : storage.values()) {
                if (storageItem.itemId != itemId && storageItem.quantity > 0) {
                    return;
                }
            }
        }

        // Check for individual maximum quantity.
        if (maximumIndividualQuantity.isPresent() && quantity > maximumIndividualQuantity.get()) {
            quantity = maximumIndividualQuantity.get();
        }

        final Optional<Integer> maximumTotalQuantity = getMaximumTotalQuantity();
        if (maximumTotalQuantity.isPresent()) {
            int newTotalQuantity = 0;
            for (final StorageItem storageItem : storage.values()) {
                if (storageItem.itemId == itemId) continue;
                newTotalQuantity += storageItem.quantity;
            }
            newTotalQuantity += quantity; //Add outside the loop in case the item is not currently stored

            if (newTotalQuantity > maximumTotalQuantity.get()) {
                quantity -= newTotalQuantity - maximumTotalQuantity.get();
            }
        }

        final Optional<StorageItem> item = getItem(itemId);
        if (quantity == 0) {
            storage.remove(itemId);
        } else if (item.isPresent()) {
            item.get().quantity = quantity;
        } else {
            storage.put(itemId, new StorageItem(itemId, quantity));
        }

        save();
    }

    public void fillFromInventory() {
        for (final ItemWithQuantity itemDifference : store.getInventoryItemsDifference().items) {
            if (isStorageItem(itemDifference) && itemDifference.quantity < 0) {
                add(itemDifference.itemId, Math.abs(itemDifference.quantity));
            }
        }
    }

    private boolean isStorageItem(final ItemWithQuantity item) {
        for (final StorageItem storageItem : storableItems) {
            if (storageItem.itemId == item.itemId) {
                return true;
            }
        }

        return false;
    }

    public void emptyToInventory() {
        for (final ItemWithQuantity itemDifference : store.getInventoryItemsDifference().items) {
            if (storage.containsKey(itemDifference.itemId)) {
                storage.get(itemDifference.itemId).quantity -= itemDifference.quantity;
            }
        }
    }

    public void emptyToInventoryWithoutItemContainerChanged() {
        int inventorySpaceFree = store.getInventoryEmptySlots();

        for (final StorageItem storageItem : storage.values()) {
            if (storageItem.quantity > 0) {
                final int toRemove = Math.min(storageItem.quantity, inventorySpaceFree);
                remove(storageItem.itemId, toRemove);
                inventorySpaceFree -= toRemove;
            }
        }
    }

    public void emptyToBank() {
        for (final ItemWithQuantity itemDifference : store.getBankItemsDifference().items) {
            if (storage.containsKey(itemDifference.itemId)) {
                storage.get(itemDifference.itemId).quantity -= itemDifference.quantity;
            }
        }
    }

    public void updateFromItemContainer(final ItemContainer itemContainer) {
        if (itemContainer == null) return;

        storage = new LinkedHashMap<>();

        for (final Item item : itemContainer.getItems()) {
            if (item != null) {
                put(item.getId(), item.getQuantity());
            }
        }
    }

    public int getCharges() {
        int charges = 0;

        for (final StorageItem item : storage.values()) {
            charges += item.quantity;
        }

        return charges;
    }

    public Map<Integer, StorageItem> getStorage() {
        return storage;
    }

    public void loadStorage() {
        storage = new LinkedHashMap<>();

        // Load storage from config.
        try {
            final String jsonString = configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, storageConfigKey);
            final JsonArray jsonStorage = (JsonArray) (new JsonParser()).parse(jsonString);

            for (final JsonElement jsonStorageItem : jsonStorage) {
                final StorageItem loadedItem = new StorageItem(
                    jsonStorageItem.getAsJsonObject().get("itemId").getAsInt(),
                    jsonStorageItem.getAsJsonObject().get("quantity").getAsInt()
                );

                // Update previous item quantity or put new into the storage.
                if (storage.containsKey(loadedItem.itemId)) {
                    storage.get(loadedItem.itemId).quantity = loadedItem.quantity;
                } else {
                    put(loadedItem.itemId, loadedItem.quantity);
                }
            }
        } catch (final Exception ignored) {}
    }

    private void save() {
        final JsonArray jsonStorage = new JsonArray();

        for (final StorageItem storageItem : storage.values()) {
            final JsonObject jsonItem = new JsonObject();
            jsonItem.addProperty("itemId", storageItem.itemId);
            jsonItem.addProperty("quantity", storageItem.quantity);
            jsonStorage.add(jsonItem);
        }

        configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, storageConfigKey, gson.toJson(jsonStorage));
    }

    private Optional<StorageItem> getItem(final int itemId) {
        if (storage.containsKey(itemId)) {
            return Optional.of(storage.get(itemId));
        } else {
            return Optional.empty();
        }
    }

    public boolean isEmpty() {
        for (final StorageItem storageItem : storage.values()) {
            if (storageItem.quantity > 0) {
                return false;
            }
        }

        return true;
    }

    public boolean isFull() {
        if (maximumTotalQuantity.isPresent()) {
            int quantity = 0;

            for (final StorageItem storageItem : storage.values()) {
                quantity += storageItem.quantity;
            }

            return quantity == maximumTotalQuantity.get();
        }

        return false;
    }

    public Optional<Integer> getMaximumTotalQuantity() {
        // Maximum storage from trigger item.
        for (final TriggerItem item : chargedItem.items) {
            if (chargedItem.itemId == item.itemId && item.maxCharges.isPresent()) {
                return item.maxCharges;
            }
        }

        // Maximum storage with specific item equipped.
        if (maximumTotalQuantityWithItemEquipped.isPresent() && maximumTotalQuantityWithItemEquippedItems.isPresent() && store.equipmentContainsItem(maximumTotalQuantityWithItemEquippedItems.get())) {
            return maximumTotalQuantityWithItemEquipped;
        }

        // Maximum storage.
        if (maximumTotalQuantity.isPresent()) {
            return maximumTotalQuantity;
        }

        return Optional.empty();
    }

    public final Optional<StorageItem> getStorageItemFromName(final String name) {
        // Based on checkName.
        for (final StorableItem storableItem : storableItems) {
            if (storableItem.checkName.isPresent()) {
                for (final String checkName :storableItem.checkName.get()) {
                    if (
                        name.equalsIgnoreCase(checkName) ||
                        name.toLowerCase().contains(checkName.toLowerCase()) ||
                        name.contains(itemManager.getItemComposition(storableItem.itemId).getName())
                    ) {
                        return Optional.of(storableItem);
                    }
                }
            }
        }

        return Optional.empty();
    }

    public StorableItem[] getStorableItems() {
        return storableItems;
    }

    public int getStorageItemOrder(final StorageItem storageItem) {
        for (final StorableItem storableItem : storableItems) {
            if (storableItem.itemId == storageItem.itemId) {
                if (storableItem.order.isPresent()) {
                    return storableItem.order.get();
                }
            }
        }

        return Integer.MAX_VALUE;
    }

    public String getStorageItemName(final StorageItem storageItem) {
        for (final StorableItem storableItem : storableItems) {
            if (storableItem.itemId == storageItem.itemId) {
                if (storableItem.displayName.isPresent()) {
                    return storableItem.displayName.get();
                }
            }
        }

        return itemManager.getItemComposition(storageItem.itemId).getName();
    }
}

package tictac7x.charges.item.overlays;

import net.runelite.api.Client;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.ItemOverlayLocation;

import java.awt.*;
import java.util.Optional;

public class ChargedItemOverlay extends WidgetItemOverlay {
    private final Client client;
    private final TooltipManager tooltipManager;
    private final ConfigManager configManager;
    private final TicTac7xChargesImprovedConfig config;
    private final ChargedItemBase[] chargedItems;

    public ChargedItemOverlay(
        final Client client,
        final TooltipManager tooltipManager,
        final ItemManager itemManager,
        final ConfigManager configManager,
        final TicTac7xChargesImprovedConfig config,
        final ChargedItemBase[] chargedItems
    ) {
        this.client = client;
        this.tooltipManager = tooltipManager;
        this.configManager = configManager;
        this.config = config;
        this.chargedItems = chargedItems;
        showOnInventory();
        showOnEquipment();
        showOnInterfaces(84);
        showOnBank();
    }

    private boolean isBankWidget(final WidgetItem item_widget) {
        return
            item_widget.getWidget().getParentId() == 786442 ||
            item_widget.getWidget().getParentId() == 786443 ||
            item_widget.getWidget().getParentId() == 786444 ||
            item_widget.getWidget().getParentId() == 786445
        ;
    }


    @Override
    public void renderItemOverlay(final Graphics2D graphics, final int itemId, final WidgetItem widgetItem) {
        if (!config.showOverlays()) return;

        Optional<ChargedItemBase> chargedItem = Optional.empty();
        Optional<TriggerItem> triggerItem = Optional.empty();

        // Find correct charged item.
        chargedItemFinder: for (final ChargedItemBase chargedItemBase : chargedItems) {
            for (final TriggerItem chargedItemTriggerItem : chargedItemBase.items) {
                if (chargedItemTriggerItem.itemId == itemId) {
                    chargedItem = Optional.of(chargedItemBase);
                    triggerItem = Optional.of(chargedItemTriggerItem);
                    break chargedItemFinder;
                }
            }
        }

        // Invalid item.
        if (!chargedItem.isPresent() || !triggerItem.isPresent()) return;

        if (
            // Item overlay disabled.
            !isChargedItemOverlayEnabled(chargedItem.get()) ||

            // Infinity charges hidden.
            !config.showUnlimited() && chargedItem.get().getCharges().equals("") ||
            !config.showUnlimited() && triggerItem.get().fixedCharges.isPresent() && triggerItem.get().fixedCharges.get().equals(Charges.UNLIMITED) ||

            // Hide overlays in bank.
            !config.showBankOverlays() && isBankWidget(widgetItem) ||

            // Show overlays only in bank.
            config.showOverlaysOnlyInBank() && client.getWidget(12, 1) == null
        ) return;

        // Get default charges from charged item.
        String charges = chargedItem.get().getCharges();
        Color color = chargedItem.get().getTextColor();

        // Override charges and color for fixed items.
        for (final TriggerItem item : chargedItem.get().items) {
            if (item.itemId == itemId && item.fixedCharges.isPresent()) {
                charges = item.fixedCharges.get() == Charges.UNLIMITED
                    ? ""
                    : String.valueOf(item.fixedCharges.get());
                color = item.fixedCharges.get() == 0 ? config.getColorEmpty() : config.getColorDefault();
            }
        }

        graphics.setFont(FontManager.getRunescapeSmallFont());

        final Rectangle bounds = widgetItem.getCanvasBounds();
        final TextComponent charges_component = new TextComponent();
        charges_component.setText(charges);
        final Dimension textDimension = charges_component.render(graphics);

        final int itemOverlayX = (int) ((
            config.itemOverlayLocation() == ItemOverlayLocation.BOTTOM_LEFT ||
            config.itemOverlayLocation() == ItemOverlayLocation.TOP_LEFT
        )
            ? bounds.getMinX()
            : bounds.getMaxX() - textDimension.getWidth() - 5
        );

        final int itemOverlayY = (int) ((
            config.itemOverlayLocation() == ItemOverlayLocation.TOP_LEFT ||
            config.itemOverlayLocation() == ItemOverlayLocation.TOP_RIGHT
        )
            ? bounds.getMinY() + textDimension.getHeight() - 2
            : bounds.getMaxY()
        );

        charges_component.setPosition(new Point(itemOverlayX, itemOverlayY));

        // Set color.
        charges_component.setColor(color);

        // Override for bank items.
        if (isBankWidget(widgetItem) && !chargedItem.get().getCharges().equals("?")) {
            charges_component.setColor(config.getColorDefault());
        }

        charges_component.render(graphics);

        // Charged item with storage
        renderTooltip(chargedItem.get(), widgetItem);
    }

    private void renderTooltip(final ChargedItemBase chargedItem, final WidgetItem widgetItem) {
        // Config, not storage item, empty storage checks.
        if (
            !config.showStorageTooltips() ||
            !(chargedItem instanceof ChargedItemWithStorage)
        ) return;

        // Mouse position check.
        final net.runelite.api.Point mousePosition = client.getMouseCanvasPosition();
        if (!widgetItem.getCanvasBounds().contains(mousePosition.getX(), mousePosition.getY())) return;


        final String tooltip = chargedItem.getTooltip();
        if (!tooltip.isEmpty()) {
            tooltipManager.addFront(new Tooltip(tooltip));
        }
    }

    private boolean isChargedItemOverlayEnabled(final ChargedItemBase chargedItem) {
        final Optional<String> visible = Optional.ofNullable(configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, chargedItem.configKey + "_overlay"));

        if (visible.isPresent() && visible.get().equals("false")) {
            return false;
        }

        return true;
    }
}

package tictac7x.charges.item.overlays;

import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;

import java.awt.Color;
import java.util.Optional;

public class ChargedItemInfobox extends InfoBox {
    private final ChargedItemBase chargedItem;
    private final ItemManager itemManager;
    private final InfoBoxManager infoBoxManager;
    private final TicTac7xChargesImprovedConfig config;
    private final ConfigManager configManager;

    private int itemId;

    public ChargedItemInfobox(
        final ChargedItemBase chargedItem,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ConfigManager configManager,
        final TicTac7xChargesImprovedConfig config,
        final TicTac7xChargesImprovedPlugin plugin
    ) {
        super(itemManager.getImage(chargedItem.itemId), plugin);
        this.chargedItem = chargedItem;
        this.itemManager = itemManager;
        this.infoBoxManager = infoBoxManager;
        this.configManager = configManager;
        this.config = config;
        this.itemId = chargedItem.itemId;
    }

    @Override
    public String getName() {
        return super.getName() + "_" + chargedItem.itemId;
    }

    @Override
    public String getText() {
        return chargedItem.getTotalCharges();
    }

    @Override
    public String getTooltip() {
        return chargedItem.getTooltip();
    }

    @Override
    public Color getTextColor() {
        return chargedItem.getTextColor();
    }

    @Override
    public boolean render() {
        updateInfobox();

        if (
            !config.showInfoboxes() ||
            !isChargedItemInfoboxEnabled() ||
            chargedItem.getCharges().equals("") && !config.showUnlimited() ||
            (!chargedItem.inInventory() && !chargedItem.inEquipment())
        ) {
            return false;
        }

        return true;
    }

    private void updateInfobox() {
        if (itemId != chargedItem.itemId) {
            // Update infobox id to keep track of correct item.
            itemId = chargedItem.itemId;

            // Update infobox image.
            setImage(itemManager.getImage(itemId));
            infoBoxManager.updateInfoBoxImage(this);
        }
    }

    private boolean isChargedItemInfoboxEnabled() {
        final Optional<String> visible = Optional.ofNullable(configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, chargedItem.configKey + "_infobox"));

        if (visible.isPresent() && visible.get().equals("false")) {
            return false;
        }

        return true;
    }
}



package tictac7x.charges.item;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

import java.util.Optional;

public class ChargedItem extends ChargedItemBase {
    public ChargedItem(String configKey, int itemId, Client client, ClientThread clientThread, ConfigManager configManager, ItemManager itemManager, InfoBoxManager infoBoxManager, ChatMessageManager chatMessageManager, Notifier notifier, TicTac7xChargesImprovedConfig config, Store store, final Gson gson) {
        super(configKey, itemId, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store);
    }

    @Override
    public String getCharges() {
        for (final TriggerItem triggerItem : items) {
            if (triggerItem.itemId == itemId && triggerItem.fixedCharges.isPresent()) {
                return getChargesMinified(triggerItem.fixedCharges.get());
            }
        }

        if (getChargesFromConfig() == Charges.UNLIMITED) {
            return "";
        }

        if (getChargesFromConfig() >= 0) {
            return getChargesMinified(getChargesFromConfig());
        }

        return "?";
    }

    @Override
    public String getTotalCharges() {
        int totalFixedCharges = 0;
        int equipmentFixedCharges = 0;
        boolean fixedItemsFound = false;

        for (final TriggerItem triggerItem : items) {
            if (triggerItem.fixedCharges.isPresent()) {
                totalFixedCharges += store.getInventoryItemQuantity(triggerItem.itemId) * triggerItem.fixedCharges.get();
                equipmentFixedCharges += store.getEquipmentItemQuantity(triggerItem.itemId) * triggerItem.fixedCharges.get();
                fixedItemsFound = true;
            }
        }

        try {
            if (getChargesFromConfig() == Charges.UNKNOWN && fixedItemsFound) {
                return equipmentFixedCharges > 0 ?
                    getChargesMinified(equipmentFixedCharges) :
                    getChargesMinified(totalFixedCharges);
            }
        } catch (final Exception ignored) {}

        return getCharges();
    }

    public void setCharges(int charges) {
        charges =
            // Unlimited
            charges == Charges.UNLIMITED ? charges :

            // 0 -> charges
            Math.max(0, charges);

        if (this.getChargesFromConfig() != charges) {
            configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, configKey, charges);
        }
    }

    public void decreaseCharges(final int charges) {
        setCharges(this.getChargesFromConfig() - charges);
    }

    public void increaseCharges(final int charges) {
        setCharges(this.getChargesFromConfig() + charges);
    }

    private int getChargesFromConfig() {
        final Optional<String> charges = Optional.ofNullable(configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, configKey));

        if (!charges.isPresent()) {
            return Charges.UNKNOWN;
        }

        try {
            return Integer.parseInt(charges.get());
        } catch (final Exception ignored) {
            return Charges.UNKNOWN;
        }
    }
}



package tictac7x.charges.item;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.store.ItemActivity;
import tictac7x.charges.store.Store;

import java.awt.Color;
import java.util.Optional;

public class ChargedItemWithStatus extends ChargedItem {

    public ChargedItemWithStatus(String configKey, int itemId, Client client, ClientThread clientThread, ConfigManager configManager, ItemManager itemManager, InfoBoxManager infoBoxManager, ChatMessageManager chatMessageManager, Notifier notifier, TicTac7xChargesImprovedConfig config, Store store, final Gson gson) {
        super(configKey, itemId, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
    }

    public boolean isDeactivated() {
        final Optional<String> status = Optional.ofNullable(configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, getConfigStatusKey()));

        if (!status.isPresent()) {
            return false;
        }

        return status.get().equals(ItemActivity.DEACTIVATED.toString());
    }

    public boolean isActivated() {
        final Optional<String> status = Optional.ofNullable(configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, getConfigStatusKey()));

        if (!status.isPresent()) {
            return false;
        }

        return status.get().equals(ItemActivity.ACTIVATED.toString());
    }

    public String getConfigStatusKey() {
        return configKey + "_status";
    }

    public void deactivate() {
        setActivity(ItemActivity.DEACTIVATED);
    }

    public void activate() {
        setActivity(ItemActivity.ACTIVATED);
    }

    private void setActivity(final ItemActivity status) {
        configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, getConfigStatusKey(), status);
    }

    @Override
    public Color getTextColor() {
        if (isActivated()) {
            return config.getColorActivated();
        }

        if (isDeactivated()) {
            return config.getColorEmpty();
        }

        return super.getTextColor();
    }
}

package tictac7x.charges.item;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.storage.Storage;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

import java.awt.Color;
import java.util.Comparator;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

public class ChargedItemWithStorage extends ChargedItemBase {
    public Storage storage;

    public ChargedItemWithStorage(String configKey, int itemId, Client client, ClientThread clientThread, ConfigManager configManager, ItemManager itemManager, InfoBoxManager infoBoxManager, ChatMessageManager chatMessageManager, Notifier notifier, TicTac7xChargesImprovedConfig config, Store store, final Gson gson) {
        super(configKey, itemId, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store);
        this.storage = new Storage(this, configKey, itemManager, configManager, store, gson);

        clientThread.invokeLater(() -> {
            loadCharges();
        });
    }

    @Override
    public String getTooltip() {
        String tooltip = "";
        for (final StorageItem storageItem : storage.getStorage().values().stream()
            .sorted(Comparator.comparing(storageItem -> storage.getStorageItemOrder(storageItem)))
            .collect(Collectors.toList())
        ) {
            if (storageItem.quantity > 0) {
                tooltip += storage.getStorageItemName(storageItem) + ": ";
                tooltip += ColorUtil.wrapWithColorTag(String.valueOf(storageItem.quantity), JagexColors.MENU_TARGET) + "</br>";
            }
        }

        return tooltip.replaceAll("</br>$", "");
    }

    public Map<Integer, StorageItem> getStorage() {
        return this.storage.getStorage();
    }

    public Optional<StorageItem> getStorageItemFromName(final String name) {
        return storage.getStorageItemFromName(name);
    }

    public int getQuantity() {
        int quantity = 0;

        for (final StorageItem storageItem : getStorage().values()) {
            if (storageItem.quantity >= 0) {
                quantity += storageItem.quantity;
            }
        }

        return quantity;
    }

    @Override
    public String getCharges() {
        int quantity = getQuantity();

        if (quantity == Charges.UNKNOWN) {
            return "?";
        }

        return getChargesMinified(quantity);
    }

    @Override
    public String getTotalCharges() {
        return getCharges();
    }

    private void loadCharges() {
        storage.loadStorage();
    }

    @Override
    public Color getTextColor() {
        // Full storage is positive.
        if (storage.emptyIsNegative && storage.isFull()) {
            return config.getColorActivated();
        }

        // Full storage is negative.
        if (
            storage.emptyIsNegative && storage.isEmpty() ||
            !storage.emptyIsNegative && storage.getMaximumTotalQuantity().isPresent() && getCharges().equals(String.valueOf(storage.getMaximumTotalQuantity().get()))
        ) {
            return config.getColorEmpty();
        }

        // Storage is empty.
        if (getQuantity() == 0) {
            return config.getColorDefault();
        }

        return super.getTextColor();
    }
}

package tictac7x.charges.item;

import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.events.*;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.listeners.*;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.AdvancedMenuEntry;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

import javax.annotation.Nonnull;
import java.awt.Color;

public abstract class ChargedItemBase {
    public final String configKey;
    protected final Client client;
    protected final ClientThread clientThread;
    protected final ItemManager itemManager;
    protected final InfoBoxManager infoBoxManager;
    protected final ConfigManager configManager;
    protected final ChatMessageManager chatMessageManager;
    protected final Notifier notifier;
    protected final TicTac7xChargesImprovedConfig config;

    public final Store store;

    public int itemId;

    public TriggerItem[] items = new TriggerItem[]{};
    public TriggerBase[] triggers = new TriggerBase[]{};

    private final ListenerOnChatMessage listenerOnChatMessage;
    private final ListenerOnItemContainerChanged listenerOnItemContainerChanged;
    private final ListenerOnItemPickup listenerOnItemPickup;
    private final ListenerOnXpDrop listenerOnXpDrop;
    private final ListenerOnStatChanged listenerOnStatChanged;
    private final ListenerOnMenuEntryAdded listenerOnMenuEntryAdded;
    private final ListenerOnResetDaily listenerOnResetDaily;
    private final ListenerOnGraphicChanged listenerOnGraphicChanged;
    private final ListenerOnAnimationChanged listenerOnAnimationChanged;
    private final ListenerOnHitsplatApplied listenerOnHitsplatApplied;
    private final ListenerOnWidgetLoaded listenerOnWidgetLoaded;
    private final ListenerOnVarbitChanged listenerOnVarbitChanged;
    private final ListenerOnUserAction listenerOnUserAction;
    private final ListenerOnMenuOptionClicked listenerOnMenuOptionClicked;
    private final ListenerOnScriptPreFired listenerOnScriptPreFired;

    private boolean inInventory = false;
    private boolean inEquipment = false;

    public ChargedItemBase(
        final String configKey,
        final int itemId,
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store
    ) {
        this.itemId = itemId;
        this.configKey = configKey;

        this.client = client;
        this.clientThread = clientThread;
        this.configManager = configManager;
        this.itemManager = itemManager;
        this.infoBoxManager = infoBoxManager;
        this.chatMessageManager = chatMessageManager;
        this.notifier = notifier;
        this.config = config;
        this.store = store;

        listenerOnChatMessage = new ListenerOnChatMessage(client, itemManager, this, notifier, config);
        listenerOnItemContainerChanged = new ListenerOnItemContainerChanged(client, itemManager, this, notifier, config);
        listenerOnItemPickup = new ListenerOnItemPickup(client, itemManager, this, notifier, config);
        listenerOnXpDrop = new ListenerOnXpDrop(client, itemManager, this, notifier, config);
        listenerOnStatChanged = new ListenerOnStatChanged(client, itemManager, this, notifier, config);
        listenerOnMenuEntryAdded = new ListenerOnMenuEntryAdded(client, itemManager, this, notifier, config);
        listenerOnResetDaily = new ListenerOnResetDaily(client, itemManager, this, notifier, config);
        listenerOnGraphicChanged = new ListenerOnGraphicChanged(client, itemManager, this, notifier, config);
        listenerOnAnimationChanged = new ListenerOnAnimationChanged(client, itemManager, this, notifier, config);
        listenerOnHitsplatApplied = new ListenerOnHitsplatApplied(client, itemManager, this, notifier, config);
        listenerOnWidgetLoaded = new ListenerOnWidgetLoaded(client, itemManager, this, notifier, config);
        listenerOnVarbitChanged = new ListenerOnVarbitChanged(client, itemManager, this, notifier, config);
        listenerOnUserAction = new ListenerOnUserAction(client, itemManager, this, notifier, config);
        listenerOnMenuOptionClicked = new ListenerOnMenuOptionClicked(client, itemManager, this, notifier, config);
        listenerOnScriptPreFired = new ListenerOnScriptPreFired(client, itemManager, this, notifier, config);
    }

    public abstract String getCharges();

    public abstract String getTotalCharges();

    public boolean inInventory() {
        return inInventory;
    }

    public boolean inEquipment() {
        return inEquipment;
    }

    private boolean inInventoryOrEquipment() {
        return inInventory || inEquipment;
    }

    public String getTooltip() {
        return getItemName() + (needsToBeEquipped() && !inEquipment() ? " (needs to be equipped)" : "") + ": " + ColorUtil.wrapWithColorTag(String.valueOf(getCharges()), JagexColors.MENU_TARGET);
    }

    @Nonnull
    private TriggerItem getCurrentItem() {
        for (final TriggerItem triggerItem : items) {
            if (triggerItem.itemId == itemId) {
                return triggerItem;
            }
        }

        return null;
    }

    public String getItemName() {
        return itemManager.getItemComposition(itemId).getName();
    }

    public boolean needsToBeEquipped() {
        return getCurrentItem().needsToBeEquipped.isPresent();
    }

    public Color getTextColor() {
        if (getCharges().equals("?")) {
            return config.getColorUnknown();
        }

        if (getCharges().equals("0") || needsToBeEquipped() && !inEquipment()) {
            return config.getColorEmpty();
        }

        return config.getColorDefault();
    }

    protected String getChargesMinified(final int charges) {
        // Unlimited.
        if (charges == Charges.UNLIMITED) return "";

        // Unknown.
        if (charges == Charges.UNKNOWN) return "?";

        // Show as is.
        if (charges < 1000) return String.valueOf(charges);

        // Minify to use millions (M).
        if (charges >= 1000000) return charges / 1000000 + "M";

        // Minify to use thousands (K).
        final int thousands = charges / 1000;
        final int hundreds = Math.min((charges % 1000 + 50) / 100, 9);
        return thousands + (thousands < 10 && hundreds > 0 ? "." + hundreds : "") + "K";
    }

    public void onChatMessage(final ChatMessage event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnChatMessage.trigger(event);
    }

    public void onHitsplatApplied(final HitsplatApplied event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnHitsplatApplied.trigger(event);
    }

    public void onWidgetLoaded(final WidgetLoaded event) {
        if (!inInventoryOrEquipment()) return;
        clientThread.invokeLater(() -> {
            listenerOnWidgetLoaded.trigger(event);
        });
    }

    public void onVarbitChanged(final VarbitChanged event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnVarbitChanged.trigger(event);
    }

    public void onStatChanged(final StatChanged event) {
        listenerOnStatChanged.trigger(event);
        if (!inInventoryOrEquipment()) return;
        listenerOnXpDrop.trigger(event);
    }

    public void onGraphicChanged(final GraphicChanged event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnGraphicChanged.trigger(event);
    }

    public void onAnimationChanged(final AnimationChanged event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnAnimationChanged.trigger(event);
    }

    public void onItemContainerChanged(final ItemContainerChanged event) {
        updateItem(event);

        if (!inInventoryOrEquipment()) return;
        listenerOnItemContainerChanged.trigger(event);
    }

    public void onMenuEntryAdded(final MenuEntryAdded event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnMenuEntryAdded.trigger(event);
    }

    public void onItemDespawned(final ItemDespawned event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnItemPickup.trigger(event);
    }

    public void onResetDaily() {
        listenerOnResetDaily.trigger();
    }

    public void onUserAction() {
        if (!inInventoryOrEquipment()) return;
        listenerOnUserAction.trigger();
    }

    public void onMenuOptionClicked(final AdvancedMenuEntry event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnMenuOptionClicked.trigger(event);
    }

    public void onScriptPreFired(final ScriptPreFired event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnScriptPreFired.trigger(event);
    }

    private void updateItem(final ItemContainerChanged event) {
        if (
            event.getContainerId() != InventoryID.INVENTORY.getId() &&
            event.getContainerId() != InventoryID.EQUIPMENT.getId()
        ) return;

        Integer itemId = null;
        boolean inEquipment = false;
        boolean inInventory = false;

        if (store.equipment.isPresent()) {
            equipmentLooper: for (final Item item : store.equipment.get().getItems()) {
                for (final TriggerItem triggerItem : items) {
                    if (triggerItem.itemId == item.getId()) {
                        itemId = triggerItem.itemId;
                        inEquipment = true;
                        break equipmentLooper;
                    }
                }
            }
        }

        if (store.inventory.isPresent()) {
            inventoryLooper: for (final Item item : store.inventory.get().getItems()) {
                for (final TriggerItem triggerItem : items) {
                    if (triggerItem.itemId == item.getId()) {
                        if (itemId == null) {
                            itemId = triggerItem.itemId;
                        }
                        inInventory = true;
                        break inventoryLooper;
                    }
                }
            }
        }

        if (itemId !=null )this.itemId = itemId;
        this.inEquipment = inEquipment;
        this.inInventory = inInventory;
    }
}

package tictac7x.charges.store;

import java.util.concurrent.Callable;

public class DynamicReplaceTarget {
    public final String target;
    public final Callable<String> replace;

    public DynamicReplaceTarget(final String target, final Callable<String> replace) {
        this.target = target;
        this.replace = replace;
    }
}

package tictac7x.charges.store;

public enum HitsplatGroup {
    REGULAR
}

package tictac7x.charges.store;

public class ReplaceTarget {
    public final String target;
    public final String replace;

    public ReplaceTarget(final String target, final String replace) {
        this.target = target;
        this.replace = replace;
    }
}

package tictac7x.charges.store;

public enum ItemActivity {
    DEACTIVATED,
    ACTIVATED
}

package tictac7x.charges.store;

public class Charges {
    public static final int UNKNOWN = -1;
    public static final int UNLIMITED = -2;
}

package tictac7x.charges.store;


package tictac7x.charges.store;

import net.runelite.api.Client;
import net.runelite.api.events.MenuOptionClicked;

public class AdvancedMenuEntry {
    public final int eventId;
    public final String target;
    public final String option;
    public final int actionId;
    public final String action;
    public final int itemId;
    public final int impostorId;

    public AdvancedMenuEntry(final MenuOptionClicked event, final Client client) {
        this.eventId = event.getId();
        this.target = event.getMenuTarget().replaceAll("</?col.*?>", "");
        this.option = event.getMenuOption().replaceAll("</?col.*?>", "");
        this.actionId = event.getMenuAction().getId();
        this.action = event.getMenuAction().name();
        this.itemId = event.getItemId();

        int impostorId = -1;
        try {
            impostorId = client.getObjectDefinition(event.getMenuEntry().getIdentifier()).getImpostor().getId();
        } catch (final Exception ignored) {}
        this.impostorId = impostorId;
    }
}

package tictac7x.charges.store;

public enum ItemOverlayLocation {
    BOTTOM_LEFT,
    BOTTOM_RIGHT,
    TOP_LEFT,
    TOP_RIGHT,
}

package tictac7x.charges.store;

import net.runelite.api.InventoryID;

public final class ItemContainerId {
    public static final int INVENTORY = InventoryID.INVENTORY.getId();
    public static final int BANK = InventoryID.BANK.getId();
    public static final int FORESTRY_KIT = 814;
    public static final int HUNTSMANS_KIT = 855;
}
package tictac7x.charges.store;

public enum HitsplatTarget {
    SELF,
    ENEMY
}

package tictac7x.charges.store;

public class ItemWithQuantity {
    public final int itemId;
    public final int quantity;

    public ItemWithQuantity(final int itemId, final int quantity) {
        this.itemId = itemId;
        this.quantity = quantity;
    }
}

package tictac7x.charges.store;

import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.Skill;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.StatChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;

import java.util.*;
import java.util.function.Consumer;

public class Store {
    private final Client client;
    private final ItemManager itemManager;
    private final ConfigManager configManager;

    private int gametick = 0;
    private int gametick_before = 0;

    private Optional<ChargedItemBase[]> chargedItems = Optional.empty();
    private List<Integer> dailyResetItemIds = new ArrayList<>();
    private Optional<String> lastChatMessage = Optional.empty();
    public Optional<ItemContainer> inventory = Optional.empty();
    public Optional<ItemContainer> equipment = Optional.empty();
    public Optional<ItemContainer> bank = Optional.empty();

    public List<StorageItem> currentInventoryItems = new ArrayList<>();
    public List<StorageItem> previousInventoryItems = new ArrayList<>();
    public List<StorageItem> currentBankItems = new ArrayList<>();
    public List<StorageItem> previousBankItems = new ArrayList<>();
    public final Queue<Runnable> nextTickQueue = new ArrayDeque<>();

    public final List<AdvancedMenuEntry> menuOptionsClicked = new ArrayList<>();
    private final Map<Skill, Integer> skillsXp = new HashMap<>();

    public Store(final Client client, final ItemManager itemManager, final ConfigManager configManager) {
        this.client = client;
        this.itemManager = itemManager;
        this.configManager = configManager;
    }

    public Optional<String> getLastChatMessage() {
        return this.lastChatMessage;
    }

    public void setLastChatMessage(final ChatMessage event) {
        if (event.getType() == ChatMessageType.GAMEMESSAGE || event.getType() == ChatMessageType.DIALOG || event.getType() == ChatMessageType.SPAM) {
            lastChatMessage = Optional.of(TicTac7xChargesImprovedPlugin.getCleanChatMessage(event));
        }
    }

    public void setChargedItems(final ChargedItemBase[] chargedItems) {
        this.chargedItems = Optional.of(chargedItems);

        List<Integer> dailyResetItemIds = new ArrayList<>();
        Arrays.stream(chargedItems).filter(chargedItem -> {
            for (final TriggerBase trigger : chargedItem.triggers) {
                if (trigger instanceof OnResetDaily) {
                    return true;
                }
            }
            return false;
        }).forEach(chargedItem -> {
            for (final TriggerItem triggerItem : chargedItem.items) {
                dailyResetItemIds.add(triggerItem.itemId);
            }
        });
        this.dailyResetItemIds = dailyResetItemIds;
    }

    public Optional<Integer> getSkillXp(final Skill skill) {
        if (skillsXp.containsKey(skill)) {
            return Optional.of(skillsXp.get(skill));
        }

        return Optional.empty();
    }

    public int getInventoryPreviouslyEmptySlots() {
        return 28 - previousInventoryItems.size();
    }

    public int getInventoryEmptySlots() {
        return 28 - currentInventoryItems.size();
    }

    public void onStatChanged(final StatChanged event) {
        skillsXp.put(event.getSkill(), event.getXp());
    }

    public void onItemContainerChanged(final ItemContainerChanged event) {
        runNextGameTickQueue();

        // Update inventory, save previous items.
        if (event.getContainerId() == InventoryID.INVENTORY.getId()) {
            inventory = Optional.of(event.getItemContainer());

            previousInventoryItems = new ArrayList<>();
            for (final StorageItem storageItem : currentInventoryItems) {
                previousInventoryItems.add(new StorageItem(storageItem.itemId, storageItem.quantity));
            }

            currentInventoryItems = new ArrayList<>();
            for (final Item item : event.getItemContainer().getItems()) {
                if (isInvalidItem(item)) continue;
                currentInventoryItems.add(new StorageItem(item.getId(), item.getQuantity()));
            }
        } else if (event.getContainerId() == InventoryID.EQUIPMENT.getId()) {
            equipment = Optional.of(event.getItemContainer());
        } else if (event.getContainerId() == InventoryID.BANK.getId()) {
            bank = Optional.of(event.getItemContainer());

            previousBankItems = new ArrayList<>();
            for (final StorageItem storageItem : currentBankItems) {
                previousBankItems.add(new StorageItem(storageItem.itemId, storageItem.quantity));
            }

            currentBankItems = new ArrayList<>();
            for (final Item item : event.getItemContainer().getItems()) {
                if (isInvalidItem(item)) continue;
                currentBankItems.add(new StorageItem(item.getId(), item.getQuantity()));
            }
        }

        updateStorage(event);
    }

    public void onMenuOptionClicked(final AdvancedMenuEntry advancedMenuEntry) {
        // Gametick changed, clear previous menu entries since they are no longer valid.
        if (gametick >= gametick_before + 2) {
            gametick = 0; gametick_before = 0;
            menuOptionsClicked.clear();
        }

        // Save menu option and target for other triggers to use.
        menuOptionsClicked.add(advancedMenuEntry);
    }

    private void runNextGameTickQueue() {
        while (!nextTickQueue.isEmpty()) {
            final Runnable consumer = nextTickQueue.poll();
            consumer.run();
        }
    }

    public void onGameTick(final GameTick ignored) {
        runNextGameTickQueue();

        // Automatically load all skill xps.
        if (!getSkillXp(Skill.MAGIC).isPresent()) {
            skillsXp.put(Skill.AGILITY, client.getSkillExperience(Skill.AGILITY));
            skillsXp.put(Skill.ATTACK, client.getSkillExperience(Skill.ATTACK));
            skillsXp.put(Skill.CONSTRUCTION, client.getSkillExperience(Skill.CONSTRUCTION));
            skillsXp.put(Skill.COOKING, client.getSkillExperience(Skill.COOKING));
            skillsXp.put(Skill.CRAFTING, client.getSkillExperience(Skill.CRAFTING));
            skillsXp.put(Skill.DEFENCE, client.getSkillExperience(Skill.DEFENCE));
            skillsXp.put(Skill.FARMING, client.getSkillExperience(Skill.FARMING));
            skillsXp.put(Skill.FIREMAKING, client.getSkillExperience(Skill.FIREMAKING));
            skillsXp.put(Skill.FISHING, client.getSkillExperience(Skill.FISHING));
            skillsXp.put(Skill.FLETCHING, client.getSkillExperience(Skill.FLETCHING));
            skillsXp.put(Skill.HERBLORE, client.getSkillExperience(Skill.HERBLORE));
            skillsXp.put(Skill.HITPOINTS, client.getSkillExperience(Skill.HITPOINTS));
            skillsXp.put(Skill.HUNTER, client.getSkillExperience(Skill.HUNTER));
            skillsXp.put(Skill.MAGIC, client.getSkillExperience(Skill.MAGIC));
            skillsXp.put(Skill.MINING, client.getSkillExperience(Skill.MINING));
            skillsXp.put(Skill.PRAYER, client.getSkillExperience(Skill.PRAYER));
            skillsXp.put(Skill.RANGED, client.getSkillExperience(Skill.RANGED));
            skillsXp.put(Skill.RUNECRAFT, client.getSkillExperience(Skill.RUNECRAFT));
            skillsXp.put(Skill.SLAYER, client.getSkillExperience(Skill.SLAYER));
            skillsXp.put(Skill.SMITHING, client.getSkillExperience(Skill.SMITHING));
            skillsXp.put(Skill.STRENGTH, client.getSkillExperience(Skill.STRENGTH));
            skillsXp.put(Skill.THIEVING, client.getSkillExperience(Skill.THIEVING));
            skillsXp.put(Skill.WOODCUTTING, client.getSkillExperience(Skill.WOODCUTTING));
        }
        gametick++;

        // Keep only last menu entry.
        if (menuOptionsClicked.size() > 1) {
            final AdvancedMenuEntry lastMenuEntry = menuOptionsClicked.get(menuOptionsClicked.size() - 1);
            menuOptionsClicked.clear();
            menuOptionsClicked.add(lastMenuEntry);
        }
    }

    public boolean inMenuTargets(final int ...itemIds) {
        final String[] targets = new String[itemIds.length];

        for (int i = 0; i < itemIds.length; i++) {
            targets[i] = itemManager.getItemComposition(itemIds[i]).getName();
        }

        return inMenuTargets(targets);
    }

    public boolean inMenuTargets(final String ...targets) {
        for (final String target : targets) {
            for (final AdvancedMenuEntry advancedMenuEntry : menuOptionsClicked) {
                if (advancedMenuEntry.target.contains(target)) {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean notInMenuTargets(final String ...targets) {
        return !inMenuTargets(targets);
    }

    public boolean notInMenuTargets(final StorageItem... storageItems) {
        final int[] storeableItemIds = new int[storageItems.length];

        for (int i = 0; i < storageItems.length; i ++) {
            storeableItemIds[i] = storageItems[i].itemId;
        }

        return notInMenuTargets(storeableItemIds);
    }

    public boolean notInMenuTargets(final int ...itemIds) {
        return !inMenuTargets(itemIds);
    }

    public boolean inMenuOptions(final String ...options) {
        for (final AdvancedMenuEntry advancedMenuEntry : menuOptionsClicked) {
            for (final String option : options) {
                if (advancedMenuEntry.option.equals(option)) {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean notInMenuOptions(final String ...options) {
        return !inMenuOptions(options);
    }

    public boolean inMenuOptionIds(final int ...menuOptionIds) {
        for (final AdvancedMenuEntry advancedMenuEntry : menuOptionsClicked) {
            for (final int menuOptionId : menuOptionIds) {
                if (advancedMenuEntry.eventId == menuOptionId) {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean notInMenuOptionIds(final int ...menuOptionsIds) {
        return !inMenuOptionIds(menuOptionsIds);
    }

    public boolean inMenuImpostors(final int ...impostorIds) {
        for (final AdvancedMenuEntry advancedMenuEntry : menuOptionsClicked) {
            for (final int impostorId : impostorIds) {
                if (advancedMenuEntry.impostorId == impostorId) {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean notInMenuImpostors(final int ...impostorIds) {
        return !inMenuImpostors(impostorIds);
    }

    public int getInventoryItemQuantity(final int itemId) {
        int quantity = 0;

        for (final StorageItem storageItem : currentInventoryItems) {
            if (storageItem.itemId == itemId) {
                quantity += storageItem.quantity;
            }
        }

        return quantity;
    }

    public int getEquipmentItemQuantity(final int itemId) {
        int quantity = 0;

        if (equipment.isPresent()) {
            for (final Item item : equipment.get().getItems()) {
                if (item.getId() == itemId) {
                    quantity += item.getQuantity();
                }
            }
        }

        return quantity;
    }

    public int getPreviousInventoryItemQuantity(final int itemId) {
        int quantity = 0;

        for (final StorageItem storageItem : previousInventoryItems) {
            if (storageItem.itemId == itemId) {
                quantity += storageItem.quantity;
            }
        }

        return quantity;
    }

    public boolean inventoryContainsItem(final int itemId) {
        for (final StorageItem storageItem : currentInventoryItems) {
            if (storageItem.itemId == itemId) {
                return true;
            }
        }

        return false;
    }

    public boolean equipmentContainsItem(final int ...itemIds) {
        if (!equipment.isPresent()) return false;

        for (final Item equipmentItem : equipment.get().getItems()) {
            for (final int itemId : itemIds) {
                if (equipmentItem.getId() == itemId) {
                    return true;
                }
            }
        }

        return false;
    }

    private void updateStorage(final ItemContainerChanged event) {
        if (
            event.getContainerId() != InventoryID.BANK.getId() &&
            event.getContainerId() != InventoryID.INVENTORY.getId() &&
            event.getContainerId() != InventoryID.EQUIPMENT.getId()
        ) {
            return;
        }

        final List<Integer> itemIds = new ArrayList<>();

        // Update items.
        for (final Item item : event.getItemContainer().getItems()) {
            if (item.getId() != -1 && item.getQuantity() > 0 && dailyResetItemIds.contains(item.getId())) {
                itemIds.add(item.getId());
            }
        }

        final StringBuilder storageStringBuilder = new StringBuilder();
        for (final Integer itemId : itemIds) {
            storageStringBuilder.append(itemId).append(",");
        }
        final String storageString = storageStringBuilder.toString().replaceAll(",$", "");

        // Save storage string to config.
        if (event.getContainerId() == InventoryID.BANK.getId()) {
            configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.storage_bank, storageString);
        } else if (event.getContainerId() == InventoryID.INVENTORY.getId()) {
            configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.storage_inventory, storageString);
        } else if (event.getContainerId() == InventoryID.EQUIPMENT.getId()) {
            configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.storage_equipment, storageString);
        }
    }

    private Set<Integer> getAllItems() {
        final Set<Integer> allItems = new HashSet<>();

        final String storageBank = configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.storage_bank);
        final String storageInventory = configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.storage_inventory);
        final String storageEquipment = configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.storage_equipment);

        final List<String> storages = new ArrayList<>();
        storages.addAll(Arrays.asList(storageBank.split(",")));
        storages.addAll(Arrays.asList(storageInventory.split(",")));
        storages.addAll(Arrays.asList(storageEquipment.split(",")));

        for (final String itemId : storages) {
            try {
                allItems.add(Integer.parseInt(itemId));
            } catch (final Exception ignored) {}
        }

        return allItems;
    }

    public boolean itemInPossession(final int itemId) {
        for (final int item : getAllItems()) {
            if (item == itemId) {
                return true;
            }
        }

        return false;
    }

    public ItemsDifference getInventoryItemsDifference() {
        final List<ItemWithQuantity> itemsDifference = new ArrayList<>();

        final Map<Integer, Integer> quantitiesNew = new HashMap<>();
        final Map<Integer, Integer> quantitiesBefore = new HashMap<>();

        if (inventory.isPresent()) {
            for (final Item itemNew : inventory.get().getItems()) {
                if (isInvalidItem(itemNew) || quantitiesNew.containsKey(itemNew.getId())) continue;
                quantitiesNew.put(itemNew.getId(), inventory.get().count(itemNew.getId()));
            }

            for (final StorageItem itemOld : previousInventoryItems) {
                if (quantitiesBefore.containsKey(itemOld.itemId)) {
                    quantitiesBefore.put(itemOld.itemId, quantitiesBefore.get(itemOld.itemId) + itemOld.quantity);
                } else {
                    quantitiesBefore.put(itemOld.itemId, itemOld.quantity);
                }
            }
        }

        for (final int itemId : quantitiesNew.keySet()) {
            final int quantity = quantitiesNew.get(itemId) - quantitiesBefore.getOrDefault(itemId, 0);
            if (quantity != 0) {
                itemsDifference.add(new ItemWithQuantity(itemId, quantitiesNew.get(itemId) - quantitiesBefore.getOrDefault(itemId, 0)));
            }
        }

        for (final int itemId : quantitiesBefore.keySet()) {
            if (!quantitiesNew.containsKey(itemId)) {
                itemsDifference.add(new ItemWithQuantity(itemId, -quantitiesBefore.get(itemId)));
            }
        }

        return new ItemsDifference(itemsDifference);
    }

    public ItemsDifference getBankItemsDifference() {
        final List<ItemWithQuantity> itemsDifference = new ArrayList<>();

        final Map<Integer, Integer> quantitiesNew = new HashMap<>();
        final Map<Integer, Integer> quantitiesBefore = new HashMap<>();

        if (bank.isPresent()) {
            for (final Item itemNew : bank.get().getItems()) {
                if (isInvalidItem(itemNew)) continue;
                quantitiesNew.put(itemNew.getId(), bank.get().count(itemNew.getId()));
            }

            for (final StorageItem itemOld : previousBankItems) {
                if (quantitiesBefore.containsKey(itemOld.itemId)) {
                    quantitiesBefore.put(itemOld.itemId, quantitiesBefore.get(itemOld.itemId) + itemOld.quantity);
                } else {
                    quantitiesBefore.put(itemOld.itemId, itemOld.quantity);
                }
            }
        }

        for (final int itemId : quantitiesNew.keySet()) {
            itemsDifference.add(new ItemWithQuantity(itemId, quantitiesNew.get(itemId) - quantitiesBefore.getOrDefault(itemId, 0)));
        }

        for (final int itemId : quantitiesBefore.keySet()) {
            if (!quantitiesNew.containsKey(itemId)) {
                itemsDifference.add(new ItemWithQuantity(itemId, -quantitiesBefore.get(itemId)));
            }
        }

        return new ItemsDifference(itemsDifference);
    }

    private boolean isInvalidItem(final Item item) {
        return item == null | item.getId() == -1 || item.getId() == 6512;
    }

    public void addConsumerToNextTickQueue(final Runnable consumer) {
        nextTickQueue.add(consumer);
    }
}

package tictac7x.charges.store;

import java.util.List;

public class ItemsDifference {
    public final List<ItemWithQuantity> items;

    public ItemsDifference(final List<ItemWithQuantity> items) {
        this.items = items;
    }

    public boolean hasItem(final int itemId) {
        for (final ItemWithQuantity item : items) {
            if (item.itemId == itemId) {
                return true;
            }
        }

        return false;
    }

    public int getItemQuantity(final int itemId) {
        for (final ItemWithQuantity item : items) {
            if (item.itemId == itemId) {
                return item.quantity;
            }
        }

        return 0;
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class F_SnowyKnightMix extends ChargedItem {
    public F_SnowyKnightMix(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.snowy_knight_mix, ItemID.SNOWY_KNIGHT_MIX_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.SNOWY_KNIGHT_MIX_1).fixedCharges(1),
            new TriggerItem(ItemID.SNOWY_KNIGHT_MIX_2).fixedCharges(2),
        };
    }

    @Override
    public String getTooltip() {
        return "Snowy knight mix: " + getTotalCharges();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.ItemWithQuantity;
import tictac7x.charges.store.Store;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_PlankSack extends ChargedItemWithStorage {
    private final Pattern homeBuildingPlanksPattern = Pattern.compile("(?<type>Plank|Oak plank|Teak plank|Mahogany plank): (?<amount>[0-9]+)");
    private final Map<Integer, Integer> homeBuildingWidgetMaterialsUsed = new HashMap<>();
    private Optional<Integer> sawmillLogId = Optional.empty();
    private Optional<Integer> sawmillPlankId = Optional.empty();

    public U_PlankSack(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.plank_sack, ItemID.PLANK_SACK, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage.setMaximumTotalQuantity(28).emptyIsNegative().storableItems(
            new StorableItem(ItemID.PLANK).checkName("Regular plank"),
            new StorableItem(ItemID.OAK_PLANK).checkName("Oak plank"),
            new StorableItem(ItemID.TEAK_PLANK).checkName("Teak plank"),
            new StorableItem(ItemID.MAHOGANY_PLANK).checkName("Mahogany plank")
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.PLANK_SACK),
            new TriggerItem(ItemID.PLANK_SACK_25629),
        };

        this.triggers = new TriggerBase[]{
            // Empty.
            new OnChatMessage("Your sack is empty.").emptyStorage(),

            // Check.
            new OnChatMessage("Basic planks: (?<regular>.+), Oak planks: (?<oak>.+), Teak planks: (?<teak>.+), Mahogany planks: (?<mahogany>.+)").matcherConsumer(m -> {
                storage.clear();
                storage.put(ItemID.PLANK, Integer.parseInt(m.group("regular")));
                storage.put(ItemID.OAK_PLANK, Integer.parseInt(m.group("oak")));
                storage.put(ItemID.TEAK_PLANK, Integer.parseInt(m.group("teak")));
                storage.put(ItemID.MAHOGANY_PLANK, Integer.parseInt(m.group("mahogany")));
            }),

            // Empty to inventory.
            new OnItemContainerChanged(INVENTORY).emptyStorageToInventory().onMenuOption("Empty"),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Use plank on sack.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Hallowed Sepulchre
            new OnXpDrop(Skill.CONSTRUCTION).xpAmountConsumer((xp) -> {
                storage.removeAndPrioritizeInventory(ItemID.MAHOGANY_PLANK, 2);
            }).onMenuOptionId(
                39527, 39528
            ),

            // Mahogany homes - 1 plank
            new OnXpDrop(Skill.CONSTRUCTION).xpAmountConsumer((xp) -> {
                storage.removeAndPrioritizeInventory(getPlankIdBasedOnXpAndPlanks(xp, 1), 1);
            }).onMenuOptionId(
                39982, // Bob clock
                40010, // Leela mirror
                40295, // Tau hat stand
                40099, // Larry clock
                40298, // Larry hat stand
                40289, // Mariah hat stand
                40168, // Ross hat stand
                40170, // Ross mirror
                39995, // Jeff mirror
                39996, // Jeff chair
                40011, // Barbara clock
                40014, // Barbara chair (1)
                40015, // Barbara chair (2)
                40158, // Noella hat stand
                40159, // Noella mirror
                40163, // Noella clock
                40089, // Norman clock
                40177  // Jess clock
            ),

            // Mahogany homes - 2 planks
            new OnXpDrop(Skill.CONSTRUCTION).xpAmountConsumer((xp) -> {
                storage.removeAndPrioritizeInventory(getPlankIdBasedOnXpAndPlanks(xp, 2), 2);
            }).onMenuOptionId(
                39985, // Bob bookcase (1)
                39986, // Bob bookcase (2)
                39983, // Bob cabinet (1)
                39984, // Bob cabinet (2)
                39987, // Bob wardrobe
                39988, // Bob drawers
                40007, // Leela small table (1)
                40008, // Leela small table (2)
                40292, // Leela cupboard
                40086, // Tau cupboard
                40087, // Tau shelves (1)
                40088, // Tau shelves (2)
                40095, // Larry drawers (1)
                40096, // Larry drawers (2)
                40003, // Mariah shelves
                40004, // Mariah bed
                40005, // Mariah small table (1)
                40006, // Mariah small table (2)
                40288, // Mariah cupboard
                40165, // Ross drawers (1)
                40166, // Ross drawers (2)
                40169, // Ross bed
                39990, // Jeff bookcase
                39991, // Jeff shelves
                39993, // Jeff drawers
                39994, // Jeff dresser
                40013, // Barbara bed
                40294, // Barbara drawers
                40156, // Noella dresser
                40157, // Noella cupboard
                40160, // Noella drawers
                40092, // Norman bookshelf
                40093, // Norman drawers
                40094, // Norman small table
                39998, // Sarah bed
                39999, // Sarah dresser
                40000, // Sarah small table
                40001, // Sarah shelves
                40171, // Jess drawers (1)
                40172, // Jess drawers (2)
                40173, // Jess cabinet (1)
                40174  // Jess cabinet (2)
            ),

            // Mahogany homes - 3 planks
            new OnXpDrop(Skill.CONSTRUCTION).xpAmountConsumer((xp) -> {
                storage.removeAndPrioritizeInventory(getPlankIdBasedOnXpAndPlanks(xp, 3), 3);
            }).onMenuOptionId(
                40009, // Leela table
                40291, // Leela double bed
                40084, // Tau table (1)
                40085, // Tau table (2)
                40097, // Larry table (1)
                40098, // Larry table (2)
                40002, // Mariah table
                40167, // Ross double bed
                39989, // Jeff table
                39992, // Jeff bed
                40012, // Barbara table
                40161, // Noella table (1)
                40162, // Noella table (2)
                40090, // Norman table
                40091, // Norman double bed
                39997, // Sarah table
                40175, // Jess bed
                40176  // Jess table
            ),

            // Mahogany homes - 4 planks
            new OnXpDrop(Skill.CONSTRUCTION).xpAmountConsumer((xp) -> {
                storage.removeAndPrioritizeInventory(getPlankIdBasedOnXpAndPlanks(xp, 4), 4);
            }).onMenuOptionId(
                39981  // Bob large table
            ),

            // Building in home with clicks.
            new OnScriptPreFired(1405).scriptConsumer(script -> {
                final Optional<Widget> itemWidget = Optional.ofNullable(script.getScriptEvent().getSource());
                if (!itemWidget.isPresent()) return;

                final Optional<Widget> materialsWidget = Optional.ofNullable(itemWidget.get().getChild(3));
                if (!materialsWidget.isPresent()) return;

                addPlanksToBeUsedFromHomeMaterialsWidgetText(materialsWidget.get().getText());
            }),
            // Building in home with keybinds.
            new OnScriptPreFired(1632).scriptConsumer(script -> {
                homeBuildingWidgetMaterialsUsed.clear();

                final int keyChar = script.getScriptEvent().getTypedKeyChar();
                if (keyChar < 48 || keyChar > 57) return;
                final int nthItemToBuild = keyChar - 48;

                final Optional<Widget> materialsWidget = TicTac7xChargesImprovedPlugin.getWidget(client, 458, 3 + nthItemToBuild, 3);
                if (!materialsWidget.isPresent()) return;

                addPlanksToBeUsedFromHomeMaterialsWidgetText(materialsWidget.get().getText());
            }),
            // XP drop after planks to be used from home materials widget text.
            new OnXpDrop(Skill.CONSTRUCTION).consumer(() -> {
                if (homeBuildingWidgetMaterialsUsed.isEmpty()) return;

                for (final Map.Entry<Integer, Integer> entry : homeBuildingWidgetMaterialsUsed.entrySet()) {
                    storage.removeAndPrioritizeInventory(entry.getKey(), entry.getValue());
                }

                homeBuildingWidgetMaterialsUsed.clear();
            }),

            // Sawmill, this script fires multiple times and regardless of the number of crafts
            new OnScriptPreFired(2053).scriptConsumer(script -> {
                final Optional<Widget> itemWidget = Optional.ofNullable(script.getScriptEvent().getSource());
                if (!itemWidget.isPresent()) return;

                final int sawmillLogId = (int) script.getScriptEvent().getArguments()[2];
                switch (sawmillLogId) {
                    case ItemID.LOGS:
                        this.sawmillLogId = Optional.of(ItemID.LOGS);
                        this.sawmillPlankId = Optional.of(ItemID.PLANK);
                        break;
                    case ItemID.OAK_LOGS:
                        this.sawmillLogId = Optional.of(ItemID.OAK_LOGS);
                        this.sawmillPlankId = Optional.of(ItemID.OAK_PLANK);
                        break;
                    case ItemID.TEAK_LOGS:
                        this.sawmillLogId = Optional.of(ItemID.TEAK_LOGS);
                        this.sawmillPlankId = Optional.of(ItemID.TEAK_PLANK);
                        break;
                    case ItemID.MAHOGANY_LOGS:
                        this.sawmillLogId = Optional.of(ItemID.MAHOGANY_LOGS);
                        this.sawmillPlankId = Optional.of(ItemID.MAHOGANY_PLANK);
                        break;
                }
            }),
            new OnItemContainerChanged(INVENTORY).onItemContainerDifference(itemsDifference -> {
                if (!sawmillLogId.isPresent() || !sawmillPlankId.isPresent()) return;

                final int logsDifference = itemsDifference.getItemQuantity(sawmillLogId.get());
                final int planksDifference = itemsDifference.getItemQuantity(sawmillPlankId.get());
                final int vouchersDifference = itemsDifference.getItemQuantity(ItemID.SAWMILL_VOUCHER);

                storage.add(this.sawmillPlankId.get(), Math.abs(logsDifference) + Math.abs(vouchersDifference) - Math.abs(planksDifference));

                this.sawmillLogId = Optional.empty();
                this.sawmillPlankId = Optional.empty();
            }),
        };
    }

    private void addPlanksToBeUsedFromHomeMaterialsWidgetText(final String materials) {
        final Matcher matcher = homeBuildingPlanksPattern.matcher(materials);
        while (matcher.find()) {
            final String type = matcher.group("type");
            final int amount = Integer.parseInt(matcher.group("amount"));
            switch (type) {
                case "Plank":
                    homeBuildingWidgetMaterialsUsed.put(ItemID.PLANK, amount);
                    break;
                case "Oak plank":
                    homeBuildingWidgetMaterialsUsed.put(ItemID.OAK_PLANK, amount);
                    break;
                case "Teak plank":
                    homeBuildingWidgetMaterialsUsed.put(ItemID.TEAK_PLANK, amount);
                    break;
                case "Mahogany plank":
                    homeBuildingWidgetMaterialsUsed.put(ItemID.MAHOGANY_PLANK, amount);
                    break;
            }
        }
    }

    private Optional<Integer> getPlankIdBasedOnXpAndPlanks(final int xp, final int planks) {
        // Regular planks
        if (
            xp >= 20 && xp <= 23 && planks == 1 ||
            xp >= 120 && xp <= 133 && planks == 1 ||
            xp >= 44 && xp <= 48 && planks == 2 ||
            xp >= 67 && xp <= 70 && planks == 3 ||
            xp >= 88 && xp <= 92 && planks == 4
        ) {
            return Optional.of(ItemID.PLANK);

        // Oak planks
        } else if (
            xp >= 48 && xp <= 51 && planks == 1 ||
            xp >= 160 && xp <= 165 && planks == 1 ||
            xp >= 96 && xp <= 100 && planks == 2 ||
            xp >= 144 && xp <= 148 && planks == 3 ||
            xp >= 192 && xp <= 198 && planks == 4
        ) {
            return Optional.of(ItemID.OAK_PLANK);

        // Teak planks
        } else if (
            xp >= 71 && xp <= 75 && planks == 1 ||
            xp >= 190 && xp <= 195 && planks == 1 ||
            xp >= 144 && xp <= 149 && planks == 2 ||
            xp >= 216 && xp <= 222 && planks == 3 ||
            xp >= 216 && xp <= 297 && planks == 4
        ) {
            return Optional.of(ItemID.TEAK_PLANK);

        // Mahogany planks
        } else if (
            xp >= 112 && xp <= 115 && planks == 1 ||
            xp >= 240 && xp <= 247 && planks == 1 ||
            xp >= 224 && xp <= 230 && planks == 2 ||
            xp >= 336 && xp <= 345 && planks == 3 ||
            xp >= 448 && xp <= 460 && planks == 4
        ) {
            return Optional.of(ItemID.MAHOGANY_PLANK);
        }

        return Optional.empty();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.OnVarbitChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_MasterScrollBook extends ChargedItemWithStorage {
    public U_MasterScrollBook(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.master_scroll_book, ItemID.MASTER_SCROLL_BOOK, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage = storage.setMaximumIndividualQuantity(1000).storableItems(
            new StorableItem(ItemID.NARDAH_TELEPORT).displayName("Nardah").specificOrder(1),
            new StorableItem(ItemID.DIGSITE_TELEPORT).displayName("Digsite").specificOrder(2),
            new StorableItem(ItemID.FELDIP_HILLS_TELEPORT).displayName("Feldip Hills").specificOrder(3),
            new StorableItem(ItemID.LUNAR_ISLE_TELEPORT).displayName("Lunar Isle").specificOrder(4),
            new StorableItem(ItemID.MORTTON_TELEPORT).displayName("Mort'ton").specificOrder(5),
            new StorableItem(ItemID.PEST_CONTROL_TELEPORT).displayName("Pest Control").specificOrder(6),
            new StorableItem(ItemID.PISCATORIS_TELEPORT).displayName("Piscatoris").specificOrder(7),
            new StorableItem(ItemID.TAI_BWO_WANNAI_TELEPORT).displayName("Tai Bwo Wannai").specificOrder(8),
            new StorableItem(ItemID.IORWERTH_CAMP_TELEPORT).displayName("Iorwerth Camp").specificOrder(9),
            new StorableItem(ItemID.MOS_LEHARMLESS_TELEPORT).displayName("Mos Le' Harmless").specificOrder(10),
            new StorableItem(ItemID.LUMBERYARD_TELEPORT).displayName("Lumberyard").specificOrder(11),
            new StorableItem(ItemID.ZULANDRA_TELEPORT).displayName("Zul-Andra").specificOrder(12),
            new StorableItem(ItemID.KEY_MASTER_TELEPORT).displayName("Key Master").specificOrder(13),
            new StorableItem(ItemID.REVENANT_CAVE_TELEPORT).displayName("Revenant Caves").specificOrder(14),
            new StorableItem(ItemID.WATSON_TELEPORT).displayName("Watson").specificOrder(15),
            new StorableItem(ItemID.GUTHIXIAN_TEMPLE_TELEPORT).displayName("Guthixian Temple").specificOrder(16),
            new StorableItem(ItemID.SPIDER_CAVE_TELEPORT).displayName("Spider Cave").specificOrder(17),
            new StorableItem(ItemID.COLOSSAL_WYRM_TELEPORT_SCROLL).displayName("Colossal Wyrm").specificOrder(18)
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.MASTER_SCROLL_BOOK_EMPTY),
            new TriggerItem(ItemID.MASTER_SCROLL_BOOK),
        };

        this.triggers = new TriggerBase[]{
            new OnVarbitChanged(5672).varbitValueConsumer(charges -> storage.put(ItemID.NARDAH_TELEPORT, charges)),
            new OnVarbitChanged(5673).varbitValueConsumer(charges -> storage.put(ItemID.DIGSITE_TELEPORT, charges)),
            new OnVarbitChanged(5674).varbitValueConsumer(charges -> storage.put(ItemID.FELDIP_HILLS_TELEPORT, charges)),
            new OnVarbitChanged(5675).varbitValueConsumer(charges -> storage.put(ItemID.LUNAR_ISLE_TELEPORT, charges)),
            new OnVarbitChanged(5676).varbitValueConsumer(charges -> storage.put(ItemID.MORTTON_TELEPORT, charges)),
            new OnVarbitChanged(5677).varbitValueConsumer(charges -> storage.put(ItemID.PEST_CONTROL_TELEPORT, charges)),
            new OnVarbitChanged(5678).varbitValueConsumer(charges -> storage.put(ItemID.PISCATORIS_TELEPORT, charges)),
            new OnVarbitChanged(5679).varbitValueConsumer(charges -> storage.put(ItemID.TAI_BWO_WANNAI_TELEPORT, charges)),
            new OnVarbitChanged(5680).varbitValueConsumer(charges -> storage.put(ItemID.IORWERTH_CAMP_TELEPORT, charges)),
            new OnVarbitChanged(5681).varbitValueConsumer(charges -> storage.put(ItemID.MOS_LEHARMLESS_TELEPORT, charges)),
            new OnVarbitChanged(5682).varbitValueConsumer(charges -> storage.put(ItemID.LUMBERYARD_TELEPORT, charges)),
            new OnVarbitChanged(5683).varbitValueConsumer(charges -> storage.put(ItemID.ZULANDRA_TELEPORT, charges)),
            new OnVarbitChanged(5684).varbitValueConsumer(charges -> storage.put(ItemID.KEY_MASTER_TELEPORT, charges)),
            new OnVarbitChanged(6056).varbitValueConsumer(charges -> storage.put(ItemID.REVENANT_CAVE_TELEPORT, charges)),
            new OnVarbitChanged(8253).varbitValueConsumer(charges -> storage.put(ItemID.WATSON_TELEPORT, charges)),
            new OnVarbitChanged(10967).varbitValueConsumer(charges -> storage.put(ItemID.GUTHIXIAN_TEMPLE_TELEPORT, charges)),
            new OnVarbitChanged(10995).varbitValueConsumer(charges -> storage.put(ItemID.SPIDER_CAVE_TELEPORT, charges)),
            new OnVarbitChanged(11029).varbitValueConsumer(charges -> storage.put(ItemID.COLOSSAL_WYRM_TELEPORT_SCROLL, charges)),

            // Replace default teleport option.
            new OnMenuEntryAdded("Teleport").replaceTargetDynamically("Master scroll book", this::getDefaultTeleportLocation),
        };
    }

    @Override
    public String getCharges() {
        final int varbit10966 = client.getVarbitValue(10966);
        final int varbit10968 = client.getVarbitValue(10968);

        // Default teleport not set, show all scrolls.
        if (varbit10966 == 0 && varbit10968 == 0) {
            return super.getCharges();
        }

        // Default teleport set, but no teleports.
        if (!storage.getStorage().containsKey(storage.getStorableItems()[varbit10968 * 15 + varbit10966 - 1].itemId)) {
            return "0";
        }

        return String.valueOf(storage.getStorage().get(storage.getStorableItems()[varbit10968 * 15 + varbit10966 - 1].itemId).quantity);
    }

    @Override
    public String getTooltip() {
        final int varbit10966 = client.getVarbitValue(10966);
        final int varbit10968 = client.getVarbitValue(10968);

        // Default teleport not set, show all scrolls.
        if (varbit10966 == 0 && varbit10968 == 0) {
            return super.getTooltip();
        }

        final int teleportScrollIndex = varbit10968 * 15 + varbit10966 - 1;

        // Default teleport set, but no teleports.
        if (!storage.getStorage().containsKey(storage.getStorableItems()[teleportScrollIndex].itemId)) {
            return super.getTooltip().replaceAll(getDefaultTeleportLocation() + ": <col=" + JagexColors.MENU_TARGET + ">.+?</col>", getDefaultTeleportLocation() + ": " + ColorUtil.wrapWithColorTag("0", config.getColorEmpty()));
        }

        final StorageItem defaultTeleportScrollStoreableItem = storage.getStorableItems()[teleportScrollIndex];
        final StorageItem defaultTeleportScrollStorageItem = storage.getStorage().get(defaultTeleportScrollStoreableItem.itemId);

        return super.getTooltip().replaceAll(getDefaultTeleportLocation() + ": <col=ff9040>.+?</col>", getDefaultTeleportLocation() + ": <col=00ff00>" + defaultTeleportScrollStorageItem.quantity + "</col>");
    }

    private String getDefaultTeleportLocation() {
        final int varbit10966 = client.getVarbitValue(10966);
        final int varbit10968 = client.getVarbitValue(10968);

        // Default teleport not set, show default.
        if (varbit10966 == 0 && varbit10968 == 0) {
            return itemManager.getItemComposition(itemId).getName();

        // Default teleport set, show correct location display name.
        } else {
            return storage.getStorableItems()[varbit10968 * 15 + varbit10966 - 1].displayName.get();
        }
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_EnchantedLyre extends ChargedItem {
    public W_EnchantedLyre(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.enchanted_lyre, ItemID.ENCHANTED_LYRE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.LYRE).fixedCharges(0),
            new TriggerItem(ItemID.ENCHANTED_LYRE).fixedCharges(0),
            new TriggerItem(ItemID.ENCHANTED_LYRE1).fixedCharges(1),
            new TriggerItem(ItemID.ENCHANTED_LYRE2).fixedCharges(2),
            new TriggerItem(ItemID.ENCHANTED_LYRE3).fixedCharges(3),
            new TriggerItem(ItemID.ENCHANTED_LYRE4).fixedCharges(4),
            new TriggerItem(ItemID.ENCHANTED_LYRE5).fixedCharges(5),
        };

        this.triggers = new TriggerBase[]{
            new OnMenuEntryAdded("Play").replaceOption("Teleport"),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_BryophytasStaff extends ChargedItem {
    public W_BryophytasStaff(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.bryophytas_staff, ItemID.BRYOPHYTAS_STAFF, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.BRYOPHYTAS_STAFF_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemID.BRYOPHYTAS_STAFF)
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("The nature staff has (?<charges>.+) charges?.").setDynamicallyCharges(),

            // Save a nature rune.
            new OnChatMessage("Your staff saved you a nature rune.").increaseCharges(1),

            // Charge.
            new OnChatMessage("Your Bryophyta's staff now has (?<charges>.+) charges?.").setDynamicallyCharges(),

            // Regular spellbook.
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Bones to Bananas",
                "Low Level Alchemy",
                "Superheat Item",
                "High Level Alchemy"
            ).decreaseCharges(1),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Make sets").onMenuTarget(
                "Emerald bolts (e)"
            ).decreaseCharges(1),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Bind",
                "Bones to Peaches"
            ).decreaseCharges(2),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Snare"
            ).decreaseCharges(3),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Entangle"
            ).decreaseCharges(4),


            // Arcuus spellbook.
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Dark Lure",
                "Harmony Island Teleport"
            ).decreaseCharges(1),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Degrime",
                "Ward of Arceuus"
            ).decreaseCharges(2),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Reanimate").onMenuTarget(
                "Basic Reanimation"
            ).decreaseCharges(2),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Reanimate").onMenuTarget(
                "Adept Reanimation",
                "Expert Reanimation"
            ).decreaseCharges(3),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Reanimate").onMenuTarget(
                "Master Reanimation"
            ).decreaseCharges(4),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Resurrect").onMenuTarget(
                "Resurrect Crops"
            ).decreaseCharges(12),

            // Lunar spellbook.
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Tan Leather",
                "Plank Make",
                "Energy Transfer"
            ).decreaseCharges(1),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Spin Flax",
                "Fertile Soil"
            ).decreaseCharges(2),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Geomancy"
            ).decreaseCharges(3),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_StrangeOldLockpick extends ChargedItem {
    public U_StrangeOldLockpick(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.strange_old_lockpick, ItemID.STRANGE_OLD_LOCKPICK, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.STRANGE_OLD_LOCKPICK),
            new TriggerItem(ItemID.STRANGE_OLD_LOCKPICK_FULL).fixedCharges(50)
        };
        
        this.triggers = new TriggerBase[] {
            new OnChatMessage("Your Strange old lockpick( now)? has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),
            new OnChatMessage("The Strange old lockpick crumbles to dust as you use it one last time.").notification("Your strange old lockpick crumbles to dust."),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_TumekensShadow extends ChargedItem {
    public W_TumekensShadow(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.tumekens_shadow, ItemID.TUMEKENS_SHADOW, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.TUMEKENS_SHADOW_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemID.TUMEKENS_SHADOW),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Tumeken's shadow( only)? has (?<charges>.+) charges? (remaining|left)").setDynamicallyCharges(),

            // Uncharge.
            new OnChatMessage("You uncharge your Tumeken's shadow").setFixedCharges(0),

            // Charge.
            new OnChatMessage("You apply (?<charges>.+) to your Tumeken's shadow.").setDynamicallyCharges(),

            // Charge additionally.
            new OnChatMessage("You apply an additional .* charges to your Tumeken's shadow. It now has (?<charges>.+) charges in total.").setDynamicallyCharges(),

            // Attack.
            new OnGraphicChanged(2125).decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_RingOfCelestial extends ChargedItem {
    public J_RingOfCelestial(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.celestial_ring, ItemID.CELESTIAL_RING, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.CELESTIAL_RING_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemID.CELESTIAL_SIGNET_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemID.CELESTIAL_RING).needsToBeEquipped(),
            new TriggerItem(ItemID.CELESTIAL_SIGNET).needsToBeEquipped()
        };

        this.triggers = new TriggerBase[] {
            // Charge.
            new OnChatMessage("You add .+ charges? to your Celestial (ring|signet). It now has (?<charges>.+) charges?.").setDynamicallyCharges(),
            new OnChatMessage("You add (?<charges>.+) charges? to your Celestial (ring|signet).").setDynamicallyCharges(),

            // Check.
            new OnChatMessage("Your Celestial (ring|signet) has (?<charges>.+) charges?.").setDynamicallyCharges(),

            // Ran out of charges.
            new OnChatMessage("Your Celestial (ring|signet) has run out of charges.").notification().setFixedCharges(0),

            // Mine.
            new OnChatMessage("You manage to (mine|quarry) some (clay|copper|tin|guardian fragments|guardian essence|tephra|blurite|limestone|iron|silver|coal|sandstone|gold|granite|mithril|lovakite|adamantite|soft clay)( ore)?.").isEquipped().decreaseCharges(1),
        };
    }
}
package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Varbits;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorageMultipleCharges;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

class ExplorersRingStorageItemId {
    public static final int TELEPORTS = -1000;
    public static final int ALCHEMY = -1001;
    public static final int ENERGY_RESTORES = -1002;
}

public class J_RingOfExplorer extends ChargedItemWithStorageMultipleCharges {
    public J_RingOfExplorer(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.explorers_ring, ItemID.EXPLORERS_RING_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage = storage.storableItems(
            new StorableItem(ExplorersRingStorageItemId.ALCHEMY).displayName("Alchemy charges"),
            new StorableItem(ExplorersRingStorageItemId.TELEPORTS).displayName("Teleports"),
            new StorableItem(ExplorersRingStorageItemId.ENERGY_RESTORES).displayName("Energy restores")
        ).showIndividualCharges();

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.EXPLORERS_RING_1),
            new TriggerItem(ItemID.EXPLORERS_RING_2),
            new TriggerItem(ItemID.EXPLORERS_RING_3),
            new TriggerItem(ItemID.EXPLORERS_RING_4),
        };

        this.triggers = new TriggerBase[]{
            // Use.
            new OnVarbitChanged(Varbits.EXPLORER_RING_ALCHS).consumer(() -> updateStorage()),
            new OnVarbitChanged(Varbits.EXPLORER_RING_RUNENERGY).consumer(() -> updateStorage()),
            new OnVarbitChanged(Varbits.EXPLORER_RING_TELEPORTS).consumer(() -> updateStorage()),

            // Check.
            new OnMenuOptionClicked("Check").onItemClick().consumer(() -> updateStorage()),

            new OnResetDaily().specificItem(ItemID.EXPLORERS_RING_1).consumer(() -> {
                storage.clear();
                storage.put(ExplorersRingStorageItemId.ALCHEMY, 30);
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 2);
                storage.put(ExplorersRingStorageItemId.TELEPORTS, 0);
            }),

            new OnResetDaily().specificItem(ItemID.EXPLORERS_RING_2).consumer(() -> {
                storage.clear();
                storage.put(ExplorersRingStorageItemId.ALCHEMY, 30);
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 3);
                storage.put(ExplorersRingStorageItemId.TELEPORTS, 3);
            }),

            new OnResetDaily().specificItem(ItemID.EXPLORERS_RING_3).consumer(() -> {
                storage.clear();
                storage.put(ExplorersRingStorageItemId.ALCHEMY, 30);
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 4);
                storage.put(ExplorersRingStorageItemId.TELEPORTS, Charges.UNLIMITED);
            }),

            new OnResetDaily().specificItem(ItemID.EXPLORERS_RING_4).consumer(() -> {
                storage.clear();
                storage.put(ExplorersRingStorageItemId.ALCHEMY, 30);
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 3);
                storage.put(ExplorersRingStorageItemId.TELEPORTS, Charges.UNLIMITED);
            }),
        };
    }

    private void updateStorage() {
        storage.clear();

        // Alchemy.
        storage.put(ExplorersRingStorageItemId.ALCHEMY, 30 - client.getVarbitValue(Varbits.EXPLORER_RING_ALCHS));

        // Energy restores.
        final int energyRestoresUsed = client.getVarbitValue(Varbits.EXPLORER_RING_RUNENERGY);
        switch (itemId) {
            case ItemID.EXPLORERS_RING_1:
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 2 - energyRestoresUsed);
                break;
            case ItemID.EXPLORERS_RING_2:
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 3 - energyRestoresUsed);
                break;
            case ItemID.EXPLORERS_RING_3:
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 4 - energyRestoresUsed);
                break;
            case ItemID.EXPLORERS_RING_4:
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 3 - energyRestoresUsed);
                break;
        }

        // Teleports.
        final int teleportsUsed = client.getVarbitValue(Varbits.EXPLORER_RING_TELEPORTS);
        switch (itemId) {
            case ItemID.EXPLORERS_RING_1:
                storage.put(ExplorersRingStorageItemId.TELEPORTS, 0);
                break;
            case ItemID.EXPLORERS_RING_2:
                storage.put(ExplorersRingStorageItemId.TELEPORTS, 3 - teleportsUsed);
                break;
            case ItemID.EXPLORERS_RING_3:
            case ItemID.EXPLORERS_RING_4:
                storage.put(ExplorersRingStorageItemId.TELEPORTS, Charges.UNLIMITED);
                break;
        }
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class C_ArdougneCloak extends ChargedItem {
    public C_ArdougneCloak(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ardougne_cloak, ItemID.ARDOUGNE_CLOAK_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.ARDOUGNE_CLOAK_1).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemID.ARDOUGNE_CLOAK_2),
            new TriggerItem(ItemID.ARDOUGNE_CLOAK_3),
            new TriggerItem(ItemID.ARDOUGNE_CLOAK_4).fixedCharges(Charges.UNLIMITED),
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("You have used (?<used>.+) of your (?<total>.+) Ardougne Farm teleports for today.").useDifference(),
            new OnResetDaily().specificItem(ItemID.ARDOUGNE_CLOAK_2).setFixedCharges(3),
            new OnResetDaily().specificItem(ItemID.ARDOUGNE_CLOAK_3).setFixedCharges(5),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class H_CircletOfWater extends ChargedItem {
    public H_CircletOfWater(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.circlet_of_water, ItemID.CIRCLET_OF_WATER, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.CIRCLET_OF_WATER_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemID.CIRCLET_OF_WATER).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Protect from heat.
            new OnChatMessage("Your circlet protects you from the desert heat.").decreaseCharges(1),

            // Check.
            new OnChatMessage("Your circlet has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Charge while empty.
            new OnChatMessage("You add (?<charges>.+) charges? to your circlet.$").setDynamicallyCharges(),

            // Charge while not empty.
            new OnChatMessage("You add .+ charges? to your circlet. It now has (?<charges>.+) charges?.").setDynamicallyCharges(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnAnimationChanged;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_CrystalBow extends ChargedItem {
    public W_CrystalBow(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.crystal_bow, ItemID.CRYSTAL_BOW, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.CRYSTAL_BOW),
            new TriggerItem(ItemID.CRYSTAL_BOW_24123),
            new TriggerItem(ItemID.CRYSTAL_BOW_110),
            new TriggerItem(ItemID.CRYSTAL_BOW_110_I),
            new TriggerItem(ItemID.CRYSTAL_BOW_210),
            new TriggerItem(ItemID.CRYSTAL_BOW_210_I),
            new TriggerItem(ItemID.CRYSTAL_BOW_310),
            new TriggerItem(ItemID.CRYSTAL_BOW_310_I),
            new TriggerItem(ItemID.CRYSTAL_BOW_410),
            new TriggerItem(ItemID.CRYSTAL_BOW_410_I),
            new TriggerItem(ItemID.CRYSTAL_BOW_510),
            new TriggerItem(ItemID.CRYSTAL_BOW_510_I),
            new TriggerItem(ItemID.CRYSTAL_BOW_610),
            new TriggerItem(ItemID.CRYSTAL_BOW_610_I),
            new TriggerItem(ItemID.CRYSTAL_BOW_710),
            new TriggerItem(ItemID.CRYSTAL_BOW_710_I),
            new TriggerItem(ItemID.CRYSTAL_BOW_810),
            new TriggerItem(ItemID.CRYSTAL_BOW_810_I),
            new TriggerItem(ItemID.CRYSTAL_BOW_910),
            new TriggerItem(ItemID.CRYSTAL_BOW_910_I),
            new TriggerItem(ItemID.CRYSTAL_BOW_FULL),
            new TriggerItem(ItemID.CRYSTAL_BOW_FULL_I),
            new TriggerItem(ItemID.CRYSTAL_BOW_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemID.NEW_CRYSTAL_BOW),
            new TriggerItem(ItemID.NEW_CRYSTAL_BOW_4213),
            new TriggerItem(ItemID.NEW_CRYSTAL_BOW_16888),
            new TriggerItem(ItemID.NEW_CRYSTAL_BOW_I),
            new TriggerItem(ItemID.NEW_CRYSTAL_BOW_I_16889),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your crystal bow has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Attack.
            new OnAnimationChanged(426).isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static tictac7x.charges.store.ItemContainerId.BANK;
import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_FishBarrel extends ChargedItemWithStorage {
    private Optional<StorageItem> lastCaughtFish = Optional.empty();

    public U_FishBarrel(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.fish_barrel, ItemID.FISH_BARREL, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage = storage.setMaximumTotalQuantity(28).storableItems(
            // Small net
            new StorableItem(ItemID.RAW_SHRIMPS).checkName("Shrimp"),
            new StorableItem(ItemID.RAW_ANCHOVIES).checkName("Anchovies"),
            new StorableItem(ItemID.RAW_MONKFISH).checkName("Monkfish"),

            // Big net
            new StorableItem(ItemID.RAW_MACKEREL).checkName("Mackerel"),
            new StorableItem(ItemID.RAW_COD).checkName("Cod"),
            new StorableItem(ItemID.RAW_BASS).checkName("Bass"),

            // Rod
            new StorableItem(ItemID.RAW_SARDINE).checkName("Sardine"),
            new StorableItem(ItemID.RAW_HERRING).checkName("Herring"),
            new StorableItem(ItemID.RAW_TROUT).checkName("Trout"),
            new StorableItem(ItemID.RAW_PIKE).checkName("Pike"),
            new StorableItem(ItemID.RAW_SLIMY_EEL).checkName("Slimy swamp eel"),
            new StorableItem(ItemID.RAW_SLIMY_EEL).checkName("Slimy eel"),
            new StorableItem(ItemID.RAW_SALMON).checkName("Salmon"),
            new StorableItem(ItemID.RAW_RAINBOW_FISH).checkName("Rainbow fish"),
            new StorableItem(ItemID.RAW_CAVE_EEL).checkName("Cave eel"),
            new StorableItem(ItemID.RAW_LAVA_EEL).checkName("Lava eel"),
            new StorableItem(ItemID.INFERNAL_EEL).checkName("Infernal eel"),
            new StorableItem(ItemID.RAW_ANGLERFISH).checkName("Anglerfish"),
            new StorableItem(ItemID.SACRED_EEL).checkName("Sacred eel"),

            // Harpoon
            new StorableItem(ItemID.RAW_TUNA).checkName("Tuna"),
            new StorableItem(ItemID.RAW_SWORDFISH).checkName("Swordfish"),
            new StorableItem(ItemID.RAW_SHARK).checkName("Shark"),

            // Aerial
            new StorableItem(ItemID.BLUEGILL).checkName("Bluegill"),
            new StorableItem(ItemID.COMMON_TENCH).checkName("Common tench"),
            new StorableItem(ItemID.MOTTLED_EEL).checkName("Mottled eel"),
            new StorableItem(ItemID.GREATER_SIREN).checkName("Greater siren"),

            // Cage
            new StorableItem(ItemID.RAW_LOBSTER).checkName("Lobster"),
            new StorableItem(ItemID.RAW_DARK_CRAB).checkName("Dark crab"),

            // Barbarian
            new StorableItem(ItemID.LEAPING_TROUT).checkName("Leaping trout"),
            new StorableItem(ItemID.LEAPING_SALMON).checkName("Leaping salmon"),
            new StorableItem(ItemID.LEAPING_STURGEON).checkName("Leaping sturgeon"),

            // Other
            new StorableItem(ItemID.RAW_KARAMBWAN).checkName("Karambwan"),
            new StorableItem(ItemID.RAW_SEA_TURTLE).checkName("Sea turtle"),
            new StorableItem(ItemID.RAW_MANTA_RAY).checkName("Manta ray")
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.FISH_BARREL),
            new TriggerItem(ItemID.OPEN_FISH_BARREL),
            new TriggerItem(ItemID.FISH_SACK_BARREL),
            new TriggerItem(ItemID.OPEN_FISH_SACK_BARREL),
        };

        this.triggers = new TriggerBase[]{
            // Check or empty already empty.
            new OnChatMessage("(Your|The) barrel is empty.").onItemClick().emptyStorage(),

            // Catch fish.
            new OnChatMessage("You catch (a|an|some) (?<fish>.+).").matcherConsumer(m -> {
                lastCaughtFish = getStorageItemFromName(m.group("fish"));
                storage.add(lastCaughtFish, 1);
            }).requiredItem(ItemID.OPEN_FISH_BARREL, ItemID.OPEN_FISH_SACK_BARREL),

            // Extra fish.
            new OnChatMessage(".* enabled you to catch an extra fish.").requiredItem(ItemID.OPEN_FISH_BARREL, ItemID.OPEN_FISH_SACK_BARREL).consumer(() -> {
                storage.add(lastCaughtFish, 1);
            }),

            // Check.
            new OnChatMessage("The barrel contains:").stringConsumer(s -> {
                storage.clear();

                final Pattern pattern = Pattern.compile("(?<quantity>\\d+).x.(?<fish>.*?)(,|$)");
                final Matcher matcher = pattern.matcher(s);

                while (matcher.find()) {
                    storage.put(getStorageItemFromName(matcher.group("fish")), Integer.parseInt(matcher.group("quantity")));
                }
            }).onItemClick(),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Use fish on barrel.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Empty to bank.
            new OnItemContainerChanged(BANK).emptyStorageToBank().onMenuOption("Empty"),

            // Empty to deposit box.
            new OnChatMessage("You empty the barrel.").onMenuOption("Empty").emptyStorage(),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_SkullSceptre extends ChargedItem {
    public W_SkullSceptre(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.skull_sceptre, ItemID.SKULL_SCEPTRE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.SKULL_SCEPTRE),
            new TriggerItem(ItemID.SKULL_SCEPTRE_I)
        };

        this.triggers = new TriggerBase[] {
            // Teleport.
            new OnChatMessage("Your Skull Sceptre has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Check.
            new OnChatMessage("Concentrating deeply, you divine that the sceptre has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Charge to maximum.
            new OnChatMessage("You charge the Skull Sceptre with .*. It now contains the maximum number of charges, (?<charges>.+).").setDynamicallyCharges(),

            // Charge.
            new OnChatMessage("You charge the Skull Sceptre with .*. It now contains (?<charges>.+) charges?.").setDynamicallyCharges(),

            // Unified menu entries.
            new OnMenuEntryAdded("Divine").replaceOption("Check"),
            new OnMenuEntryAdded("Invoke").replaceOption("Teleport"),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_RingOfPursuit extends ChargedItem {
    public J_RingOfPursuit(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_pursuit, ItemID.RING_OF_PURSUIT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.RING_OF_PURSUIT).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Your ring of pursuit has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Use.
            new OnChatMessage("Your ring of pursuit reveals the entire trail to you. It has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Use last charge.
            new OnChatMessage("Your ring of pursuit reveals the entire trail to you. It then crumbles to dust.").notification().setFixedCharges(10),

            // Destroy.
            new OnChatMessage("The ring shatters. Your next ring of pursuit will start afresh from 10 charges.").setFixedCharges(10),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class H_KandarinHeadgear extends ChargedItem {
    public H_KandarinHeadgear(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.kandarin_headgear, ItemID.KANDARIN_HEADGEAR_3, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.KANDARIN_HEADGEAR_3),
            new TriggerItem(ItemID.KANDARIN_HEADGEAR_4).fixedCharges(Charges.UNLIMITED),
        };

        this.triggers = new TriggerBase[] {
            // Try to teleport while empty.
            new OnChatMessage("You have already used your available teleports for today. Your headgear will recharge tomorrow.").onItemClick().setFixedCharges(0),

            // Teleport.
            new OnGraphicChanged(111).onItemClick().decreaseCharges(1),

            // Daily reset.
            new OnResetDaily().specificItem(ItemID.KANDARIN_HEADGEAR_3).setFixedCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_FungicideSpray extends ChargedItem {
    public U_FungicideSpray(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.fungicide_spray, ItemID.FUNGICIDE_SPRAY_0, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.FUNGICIDE_SPRAY_0).fixedCharges(0),
            new TriggerItem(ItemID.FUNGICIDE_SPRAY_1).fixedCharges(1),
            new TriggerItem(ItemID.FUNGICIDE_SPRAY_2).fixedCharges(2),
            new TriggerItem(ItemID.FUNGICIDE_SPRAY_3).fixedCharges(3),
            new TriggerItem(ItemID.FUNGICIDE_SPRAY_4).fixedCharges(4),
            new TriggerItem(ItemID.FUNGICIDE_SPRAY_5).fixedCharges(5),
            new TriggerItem(ItemID.FUNGICIDE_SPRAY_6).fixedCharges(6),
            new TriggerItem(ItemID.FUNGICIDE_SPRAY_7).fixedCharges(7),
            new TriggerItem(ItemID.FUNGICIDE_SPRAY_8).fixedCharges(8),
            new TriggerItem(ItemID.FUNGICIDE_SPRAY_9).fixedCharges(9),
            new TriggerItem(ItemID.FUNGICIDE_SPRAY_10).fixedCharges(10),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class S_DragonfireShield extends ChargedItem {
    public S_DragonfireShield(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.dragonfire_shield, ItemID.DRAGONFIRE_SHIELD, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.DRAGONFIRE_SHIELD_11284).fixedCharges(0),
            new TriggerItem(ItemID.DRAGONFIRE_SHIELD),
            new TriggerItem(ItemID.DRAGONFIRE_WARD_22003).fixedCharges(0),
            new TriggerItem(ItemID.DRAGONFIRE_WARD)
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("The shield has (?<charges>.+) charges?.").setDynamicallyCharges().onItemClick(),

            // Uncharge.
            new OnChatMessage("You vent the shield's remaining charges harmlessly into the air.").setFixedCharges(0),

            // Charge collected.
            new OnChatMessage("Your dragonfire (shield|ward) glows more brightly.").increaseCharges(1),

            // Already full.
            new OnChatMessage("Your dragonfire shield is already fully charged.").setFixedCharges(50),

            // Attack.
            new OnGraphicChanged(1165).isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class J_DigsitePendant extends ChargedItem {
    public J_DigsitePendant(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.digsite_pendant, ItemID.DIGSITE_PENDANT_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.DIGSITE_PENDANT_1).fixedCharges(1),
            new TriggerItem(ItemID.DIGSITE_PENDANT_2).fixedCharges(2),
            new TriggerItem(ItemID.DIGSITE_PENDANT_3).fixedCharges(3),
            new TriggerItem(ItemID.DIGSITE_PENDANT_4).fixedCharges(4),
            new TriggerItem(ItemID.DIGSITE_PENDANT_5).fixedCharges(5),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import static tictac7x.charges.store.HitsplatTarget.ENEMY;

public class W_Arclight extends ChargedItem {
    public W_Arclight(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.arclight, ItemID.ARCLIGHT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.ARCLIGHT),
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("Your arclight has (?<charges>.+) charges?( left)?.").setDynamicallyCharges(),
            new OnChatMessage("Your arclight can perform (?<charges>.+) more attacks.").setDynamicallyCharges(),
            new OnChatMessage("Your arclight has degraded.").notification().setFixedCharges(0),
            new OnHitsplatApplied(ENEMY).isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class F_MoonlightMothMix extends ChargedItem {
    public F_MoonlightMothMix(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.moonlight_moth_mix, ItemID.MOONLIGHT_MOTH_MIX_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.MOONLIGHT_MOTH_MIX_1).fixedCharges(1),
            new TriggerItem(ItemID.MOONLIGHT_MOTH_MIX_2).fixedCharges(2),
        };
    }

    @Override
    public String getTooltip() {
        return "Moonlight moth mix: " + getTotalCharges();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import static tictac7x.charges.store.HitsplatTarget.ENEMY;

public class W_CrystalHalberd extends ChargedItem {
    public W_CrystalHalberd(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.crystal_halberd, ItemID.CRYSTAL_HALBERD, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.CRYSTAL_HALBERD),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_24125),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_110),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_110_I),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_210),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_210_I),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_310),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_310_I),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_410),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_410_I),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_510),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_510_I),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_610),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_610_I),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_710),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_710_I),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_810),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_810_I),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_910),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_910_I),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_FULL),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_FULL_I),
            new TriggerItem(ItemID.CRYSTAL_HALBERD_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemID.NEW_CRYSTAL_HALBERD_FULL),
            new TriggerItem(ItemID.NEW_CRYSTAL_HALBERD_FULL_I),
            new TriggerItem(ItemID.NEW_CRYSTAL_HALBERD_FULL_16893),
            new TriggerItem(ItemID.NEW_CRYSTAL_HALBERD_FULL_I_16892),
        };
        this.triggers = new TriggerBase[]{
            new OnChatMessage("Your crystal halberd has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),
            new OnHitsplatApplied(ENEMY).isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class U_EternalTeleportCrystal extends ChargedItem {
    public U_EternalTeleportCrystal(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.eternal_teleport_crystal, ItemID.ETERNAL_TELEPORT_CRYSTAL, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.ETERNAL_TELEPORT_CRYSTAL).fixedCharges(Charges.UNLIMITED),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;

import java.util.Optional;

import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class C_ForestryKit extends ChargedItemWithStorage {
    public C_ForestryKit(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.forestry_kit, ItemID.FORESTRY_KIT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.storage = storage.storableItems(
            new StorableItem(ItemID.ANIMAINFUSED_BARK).specificOrder(1),
            new StorableItem(ItemID.FORESTERS_RATION).specificOrder(2),
            new StorableItem(ItemID.NATURE_OFFERINGS).specificOrder(3),
            new StorableItem(ItemID.SECATEURS_ATTACHMENT).specificOrder(4),
            new StorableItem(ItemID.LEAVES).displayName("Regular leaves").checkName("regular").specificOrder(5),
            new StorableItem(ItemID.OAK_LEAVES).checkName("oak").specificOrder(6),
            new StorableItem(ItemID.WILLOW_LEAVES).checkName("willow").specificOrder(7),
            new StorableItem(ItemID.MAPLE_LEAVES).checkName("maple").specificOrder(8),
            new StorableItem(ItemID.YEW_LEAVES).checkName("yew").specificOrder(9),
            new StorableItem(ItemID.MAGIC_LEAVES).checkName("magic").specificOrder(10),
            new StorableItem(ItemID.FORESTRY_HAT).specificOrder(11),
            new StorableItem(ItemID.FORESTRY_TOP).specificOrder(12),
            new StorableItem(ItemID.FORESTRY_LEGS).specificOrder(13),
            new StorableItem(ItemID.FORESTRY_BOOTS).specificOrder(14),
            new StorableItem(ItemID.LUMBERJACK_HAT).specificOrder(15),
            new StorableItem(ItemID.LUMBERJACK_TOP).specificOrder(16),
            new StorableItem(ItemID.LUMBERJACK_LEGS).specificOrder(17),
            new StorableItem(ItemID.LUMBERJACK_BOOTS).specificOrder(18),
            new StorableItem(ItemID.WOODCUTTING_CAPE).specificOrder(19),
            new StorableItem(ItemID.WOODCUT_CAPET).specificOrder(20)
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.FORESTRY_KIT),
        };

        this.triggers = new TriggerBase[]{
            // View contents.
            new OnItemContainerChanged(ItemContainerId.FORESTRY_KIT).updateStorage(),

            // Get leaves while chopping wood.
            new OnChatMessage("Some (?<leaves>.+) leaves fall to the ground and you place them into your Forestry kit.").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("leaves")), 1);
            }),

            // Get leaves from event.
            new OnChatMessage("You've been awarded (?<amount>.+) piles of (?<leaves>.+) leaves which you put into your Forestry kit.").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("leaves")), Integer.parseInt(m.group("amount")));
            }),

            // Get bark from an event.
            new OnChatMessage("You've been awarded (?<bark>.+) Anima-infused bark.").matcherConsumer(m -> {
                storage.add(ItemID.ANIMAINFUSED_BARK, Integer.parseInt(m.group("bark")));
            }),

            // Use ration when choping.
            new OnChatMessage("You consume a Forester's ration to fuel a mighty chop.").consumer(() -> {
                storage.remove(ItemID.FORESTERS_RATION, 1);
            }),

            // Out of rations.
            new OnChatMessage("You've eaten your last Forester's ration.").consumer(() -> {
                storage.put(ItemID.FORESTERS_RATION, 0);
            }),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onItemClick().onMenuOption("Fill"),

            // Buy items from Friendly Forester by 1.
            new OnMenuOptionClicked("Buy-1").consumer(() -> {
                purchaseFromFriendlyForesterShop(1);
            }),

            // Buy items from Friendly Forester by 5.
            new OnMenuOptionClicked("Buy-5").consumer(() -> {
                purchaseFromFriendlyForesterShop(5);
            }),

            // Buy items from Friendly Forester by 10.
            new OnMenuOptionClicked("Buy-10").consumer(() -> {
                purchaseFromFriendlyForesterShop(10);
            }),

            // Buy items from Friendly Forester by 50.
            new OnMenuOptionClicked("Buy-50").consumer(() -> {
                purchaseFromFriendlyForesterShop(50);
            }),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }

    private void purchaseFromFriendlyForesterShop(final int amountToBuy) {
        final Optional<Widget> forestryShopWidget = TicTac7xChargesImprovedPlugin.getWidget(client, 819, 3);
        if (!forestryShopWidget.isPresent()) return;

        int animaBarkPerItem = 0;
        final int selectedShopItem = client.getVarpValue(3869);
        switch (selectedShopItem) {
            case 0: // Forestry kit
                break;
            case 1: // Secateurs blade
                animaBarkPerItem = 20;
                break;
            case 2: // Ritual mulch
                animaBarkPerItem = 150;
                break;
            case 6: // Log brace
                animaBarkPerItem = 3_000;
                break;
            case 7: // Clothes pouch blueprint
                animaBarkPerItem = 10_000;
                break;
            case 8: // Cape pouch
                animaBarkPerItem = 2_500;
                break;
            case 9: // Log basket
                animaBarkPerItem = 5_000;
                break;
            case 10: // Felling axe handle
                animaBarkPerItem = 10_000;
                break;
            case 11: // Twitcher's gloves
                animaBarkPerItem = 5_000;
                break;
            case 12: // Funky shaped log
                animaBarkPerItem = 15_000;
                break;
            case 13: // Sawmill voucher (x10)
                animaBarkPerItem = 150;
                break;
            case 14: // Lumberjack boots
                animaBarkPerItem = 1_000;
                break;
            case 15: // Lumberjack hat
                animaBarkPerItem = 1_200;
                break;
            case 16: // Lumberjack legs
                animaBarkPerItem = 1_300;
                break;
            case 17: // Lumberjack top
                animaBarkPerItem = 1_500;
                break;
            case 18: // Forestry boots
            case 19: // Forestry hat
            case 20: // Forestry legs
            case 21: // Forestry top
                animaBarkPerItem = 1_250;
                break;
        }

        storage.removeAndPrioritizeInventory(ItemID.ANIMAINFUSED_BARK, animaBarkPerItem * amountToBuy);
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class S_KharedstMemoirs extends ChargedItem {
    public S_KharedstMemoirs(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.kharedsts_memoirs, ItemID.KHAREDSTS_MEMOIRS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.KHAREDSTS_MEMOIRS),
            new TriggerItem(ItemID.BOOK_OF_THE_DEAD)
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("You add an entry to Kharedst's Memoirs.").increaseCharges(20),

            // Teleport.
            new OnChatMessage("((Kharedst's Memoirs)|(The Book of the Dead)) now has (?<charges>.+) (memories|memory) remaining.").setDynamicallyCharges(),

            // Check empty.
            new OnChatMessage("((Kharedst's Memoirs)|(The Book of the Dead)) holds no charges.").setFixedCharges(0),

            // Check.
            new OnChatMessage("On the inside of the cover a message is displayed in dark ink. It reads: (?<charges>.+)/.+? (memories|memory) remain.").setDynamicallyCharges(),

            // Charge.
            new OnChatMessage("((Kharedst's Memoirs)|(The Book of the Dead)) now has (?<charges>.+) charges.").setDynamicallyCharges(),

            // Try to charge book of the dead when already full.
            new OnChatMessage("The Book of the Dead is already fully charged.").setFixedCharges(250),

            // Try to charge kharedst memoirs when already full.
            new OnChatMessage("Kharedst's Memoirs is already fully charged.").setFixedCharges(100),

            // Common menu entries.
            new OnMenuEntryAdded("Reminisce").replaceOption("Teleport"),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class J_AlchemistsAmulet extends ChargedItem {
    public J_AlchemistsAmulet(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.alchemists_amulet, ItemID.ALCHEMISTS_AMULET, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.ALCHEMISTS_AMULET).needsToBeEquipped(), //Uncharged 29988
            new TriggerItem(ItemID.ALCHEMISTS_AMULET_29990).needsToBeEquipped(), //Charged
            new TriggerItem(ItemID.ALCHEMISTS_AMULET_29992).needsToBeEquipped(), //???
        };

        this.triggers = new TriggerBase[] {
            // Check
            new OnChatMessage("Your Alchemist's amulet has (?<charges>.+) charges left.").setDynamicallyCharges(),

            // Charge
            new OnChatMessage("You apply an additional .+ charges to your Alchemist's amulet. It now has (?<charges>.+) charges in total.").setDynamicallyCharges(),
            new OnChatMessage("You apply (?<charges>.+) charges to your Alchemist's amulet.").setDynamicallyCharges(),

            // Uncharge
            new OnChatMessage("You uncharge your Alchemist's amulet, regaining .+ amulets of chemistry in the process.").setFixedCharges(0),

            // Use charge
            new OnChatMessage("Your Alchemist's amulet helps you create a 4-dose potion. It has (?<charges>.+) charges left.").setDynamicallyCharges(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_OgreBellows extends ChargedItem {
    public U_OgreBellows(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ogre_bellows, ItemID.OGRE_BELLOWS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.OGRE_BELLOWS).fixedCharges(0),
            new TriggerItem(ItemID.OGRE_BELLOWS_1).fixedCharges(1),
            new TriggerItem(ItemID.OGRE_BELLOWS_2).fixedCharges(2),
            new TriggerItem(ItemID.OGRE_BELLOWS_3).fixedCharges(3),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_RingOfShadows extends ChargedItem {
    public J_RingOfShadows(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_shadows, ItemID.RING_OF_SHADOWS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.RING_OF_SHADOWS_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemID.RING_OF_SHADOWS)
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("Your ring of shadows has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Charge.
            new OnChatMessage("You add (?<charges>.+) charges? to the ring of shadows.$").setDynamicallyCharges(),

            // Charge.
            new OnChatMessage("You add .+ charges? to the ring of shadows. It now has (?<charges>.+) charges?.").setDynamicallyCharges(),

            // TODO - teleport
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class W_WarpedSceptre extends ChargedItem {
    public W_WarpedSceptre(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.warped_sceptre, ItemID.WARPED_SCEPTRE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.WARPED_SCEPTRE_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemID.WARPED_SCEPTRE)
        };

        this.triggers = new TriggerBase[] {
            // Charge additional.
            new OnChatMessage("You add an additional .+ charges? to your warped sceptre. It now has (?<charges>.+) charges in total.").setDynamicallyCharges(),

            // Charge empty.
            new OnChatMessage("You add (?<charges>.+) charges? to your warped sceptre.").setDynamicallyCharges(),

            // Check.
            new OnChatMessage("Your warped sceptre( only)? has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Attack.
            new OnGraphicChanged(2567).decreaseCharges(1),

            // Uncharge.
            new OnChatMessage("You uncharge your warped sceptre").setFixedCharges(0),

            // Ran out of charges.
            new OnChatMessage("Your warped sceptre has run out of charges!").setFixedCharges(0),
        };
    }
}

package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class AhrimsRobetop extends ChargedItem {
    public AhrimsRobetop(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.AHRIMS_ROBETOP, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.AHRIMS_ROBETOP).fixedCharges(100),
            new TriggerItem(ItemID.AHRIMS_ROBETOP_100).fixedCharges(100),
            new TriggerItem(ItemID.AHRIMS_ROBETOP_75).fixedCharges(75),
            new TriggerItem(ItemID.AHRIMS_ROBETOP_50).fixedCharges(50),
            new TriggerItem(ItemID.AHRIMS_ROBETOP_25).fixedCharges(25),
            new TriggerItem(ItemID.AHRIMS_ROBETOP_0).fixedCharges(0)
        };
        this.triggers = new TriggerBase[]{
            new OnChatMessage("Ahrim's body has broken!").notification(),
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class KarilsLeathertop extends ChargedItem {
    public KarilsLeathertop(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.KARILS_LEATHERTOP, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.KARILS_LEATHERTOP).fixedCharges(100),
            new TriggerItem(ItemID.KARILS_LEATHERTOP_100).fixedCharges(100),
            new TriggerItem(ItemID.KARILS_LEATHERTOP_75).fixedCharges(75),
            new TriggerItem(ItemID.KARILS_LEATHERTOP_50).fixedCharges(50),
            new TriggerItem(ItemID.KARILS_LEATHERTOP_25).fixedCharges(25),
            new TriggerItem(ItemID.KARILS_LEATHERTOP_0).fixedCharges(0)
        };
        this.triggers = new TriggerBase[] {
            new OnChatMessage("Karil's body has broken!").notification()
        };
    }
}

package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class KarilsCrossbow extends ChargedItem {
    public KarilsCrossbow(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.KARILS_CROSSBOW, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.KARILS_CROSSBOW).fixedCharges(100),
            new TriggerItem(ItemID.KARILS_CROSSBOW_100).fixedCharges(100),
            new TriggerItem(ItemID.KARILS_CROSSBOW_75).fixedCharges(75),
            new TriggerItem(ItemID.KARILS_CROSSBOW_50).fixedCharges(50),
            new TriggerItem(ItemID.KARILS_CROSSBOW_25).fixedCharges(25),
            new TriggerItem(ItemID.KARILS_CROSSBOW_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class ToragsPlatelegs extends ChargedItem {
    public ToragsPlatelegs(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.TORAGS_PLATELEGS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.TORAGS_PLATELEGS).fixedCharges(100),
            new TriggerItem(ItemID.TORAGS_PLATELEGS_100).fixedCharges(100),
            new TriggerItem(ItemID.TORAGS_PLATELEGS_75).fixedCharges(75),
            new TriggerItem(ItemID.TORAGS_PLATELEGS_50).fixedCharges(50),
            new TriggerItem(ItemID.TORAGS_PLATELEGS_25).fixedCharges(25),
            new TriggerItem(ItemID.TORAGS_PLATELEGS_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class GuthansHelm extends ChargedItem {
    public GuthansHelm(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.GUTHANS_HELM, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.GUTHANS_HELM).fixedCharges(100),
            new TriggerItem(ItemID.GUTHANS_HELM_100).fixedCharges(100),
            new TriggerItem(ItemID.GUTHANS_HELM_75).fixedCharges(75),
            new TriggerItem(ItemID.GUTHANS_HELM_50).fixedCharges(50),
            new TriggerItem(ItemID.GUTHANS_HELM_25).fixedCharges(25),
            new TriggerItem(ItemID.GUTHANS_HELM_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class DharoksPlatebody extends ChargedItem {
    public DharoksPlatebody(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.DHAROKS_PLATEBODY, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.DHAROKS_PLATEBODY).fixedCharges(100),
            new TriggerItem(ItemID.DHAROKS_PLATEBODY_100).fixedCharges(100),
            new TriggerItem(ItemID.DHAROKS_PLATEBODY_75).fixedCharges(75),
            new TriggerItem(ItemID.DHAROKS_PLATEBODY_50).fixedCharges(50),
            new TriggerItem(ItemID.DHAROKS_PLATEBODY_25).fixedCharges(25),
            new TriggerItem(ItemID.DHAROKS_PLATEBODY_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class DharoksPlatelegs extends ChargedItem {
    public DharoksPlatelegs(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.DHAROKS_PLATELEGS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.DHAROKS_PLATELEGS).fixedCharges(100),
            new TriggerItem(ItemID.DHAROKS_PLATELEGS_100).fixedCharges(100),
            new TriggerItem(ItemID.DHAROKS_PLATELEGS_75).fixedCharges(75),
            new TriggerItem(ItemID.DHAROKS_PLATELEGS_50).fixedCharges(50),
            new TriggerItem(ItemID.DHAROKS_PLATELEGS_25).fixedCharges(25),
            new TriggerItem(ItemID.DHAROKS_PLATELEGS_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class VeracsFlail extends ChargedItem {
    public VeracsFlail(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.VERACS_FLAIL, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.VERACS_FLAIL).fixedCharges(100),
            new TriggerItem(ItemID.VERACS_FLAIL_100).fixedCharges(100),
            new TriggerItem(ItemID.VERACS_FLAIL_75).fixedCharges(75),
            new TriggerItem(ItemID.VERACS_FLAIL_50).fixedCharges(50),
            new TriggerItem(ItemID.VERACS_FLAIL_25).fixedCharges(25),
            new TriggerItem(ItemID.VERACS_FLAIL_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class VeracsHelm extends ChargedItem {
    public VeracsHelm(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.VERACS_HELM, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.VERACS_HELM).fixedCharges(100),
            new TriggerItem(ItemID.VERACS_HELM_100).fixedCharges(100),
            new TriggerItem(ItemID.VERACS_HELM_75).fixedCharges(75),
            new TriggerItem(ItemID.VERACS_HELM_50).fixedCharges(50),
            new TriggerItem(ItemID.VERACS_HELM_25).fixedCharges(25),
            new TriggerItem(ItemID.VERACS_HELM_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class GuthansWarspear extends ChargedItem {
    public GuthansWarspear(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.GUTHANS_WARSPEAR, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.GUTHANS_WARSPEAR).fixedCharges(100),
            new TriggerItem(ItemID.GUTHANS_WARSPEAR_100).fixedCharges(100),
            new TriggerItem(ItemID.GUTHANS_WARSPEAR_75).fixedCharges(75),
            new TriggerItem(ItemID.GUTHANS_WARSPEAR_50).fixedCharges(50),
            new TriggerItem(ItemID.GUTHANS_WARSPEAR_25).fixedCharges(25),
            new TriggerItem(ItemID.GUTHANS_WARSPEAR_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class AhrimsRobeskirt extends ChargedItem {
    public AhrimsRobeskirt(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.AHRIMS_ROBESKIRT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.AHRIMS_ROBESKIRT).fixedCharges(100),
            new TriggerItem(ItemID.AHRIMS_ROBESKIRT_100).fixedCharges(100),
            new TriggerItem(ItemID.AHRIMS_ROBESKIRT_75).fixedCharges(75),
            new TriggerItem(ItemID.AHRIMS_ROBESKIRT_50).fixedCharges(50),
            new TriggerItem(ItemID.AHRIMS_ROBESKIRT_25).fixedCharges(25),
            new TriggerItem(ItemID.AHRIMS_ROBESKIRT_0).fixedCharges(0)
        };
        this.triggers = new TriggerBase[]{
            new OnChatMessage("Ahrim's skirt has broken!").notification(),
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class DharoksGreataxe extends ChargedItem {
    public DharoksGreataxe(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.DHAROKS_GREATAXE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.DHAROKS_GREATAXE).fixedCharges(100),
            new TriggerItem(ItemID.DHAROKS_GREATAXE_100).fixedCharges(100),
            new TriggerItem(ItemID.DHAROKS_GREATAXE_75).fixedCharges(75),
            new TriggerItem(ItemID.DHAROKS_GREATAXE_50).fixedCharges(50),
            new TriggerItem(ItemID.DHAROKS_GREATAXE_25).fixedCharges(25),
            new TriggerItem(ItemID.DHAROKS_GREATAXE_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class VeracsBrassard extends ChargedItem {
    public VeracsBrassard(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.VERACS_BRASSARD, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.VERACS_BRASSARD).fixedCharges(100),
            new TriggerItem(ItemID.VERACS_BRASSARD_100).fixedCharges(100),
            new TriggerItem(ItemID.VERACS_BRASSARD_75).fixedCharges(75),
            new TriggerItem(ItemID.VERACS_BRASSARD_50).fixedCharges(50),
            new TriggerItem(ItemID.VERACS_BRASSARD_25).fixedCharges(25),
            new TriggerItem(ItemID.VERACS_BRASSARD_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class KarilsLeatherskirt extends ChargedItem {
    public KarilsLeatherskirt(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.KARILS_LEATHERSKIRT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.KARILS_LEATHERSKIRT).fixedCharges(100),
            new TriggerItem(ItemID.KARILS_LEATHERSKIRT_100).fixedCharges(100),
            new TriggerItem(ItemID.KARILS_LEATHERSKIRT_75).fixedCharges(75),
            new TriggerItem(ItemID.KARILS_LEATHERSKIRT_50).fixedCharges(50),
            new TriggerItem(ItemID.KARILS_LEATHERSKIRT_25).fixedCharges(25),
            new TriggerItem(ItemID.KARILS_LEATHERSKIRT_0).fixedCharges(0)
        };
        this.triggers = new TriggerBase[]{
            new OnChatMessage("Karil's skirt has broken!").notification()
        };
    }
}

package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class KarilsCoif extends ChargedItem {
    public KarilsCoif(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.KARILS_COIF, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.KARILS_COIF).fixedCharges(100),
            new TriggerItem(ItemID.KARILS_COIF_100).fixedCharges(100),
            new TriggerItem(ItemID.KARILS_COIF_75).fixedCharges(75),
            new TriggerItem(ItemID.KARILS_COIF_50).fixedCharges(50),
            new TriggerItem(ItemID.KARILS_COIF_25).fixedCharges(25),
            new TriggerItem(ItemID.KARILS_COIF_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class GuthansPlatebody extends ChargedItem {
    public GuthansPlatebody(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.GUTHANS_PLATEBODY, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.GUTHANS_PLATEBODY).fixedCharges(100),
            new TriggerItem(ItemID.GUTHANS_PLATEBODY_100).fixedCharges(100),
            new TriggerItem(ItemID.GUTHANS_PLATEBODY_75).fixedCharges(75),
            new TriggerItem(ItemID.GUTHANS_PLATEBODY_50).fixedCharges(50),
            new TriggerItem(ItemID.GUTHANS_PLATEBODY_25).fixedCharges(25),
            new TriggerItem(ItemID.GUTHANS_PLATEBODY_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class ToragsHammers extends ChargedItem {
    public ToragsHammers(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.TORAGS_HAMMERS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.TORAGS_HAMMERS).fixedCharges(100),
            new TriggerItem(ItemID.TORAGS_HAMMERS_100).fixedCharges(100),
            new TriggerItem(ItemID.TORAGS_HAMMERS_75).fixedCharges(75),
            new TriggerItem(ItemID.TORAGS_HAMMERS_50).fixedCharges(50),
            new TriggerItem(ItemID.TORAGS_HAMMERS_25).fixedCharges(25),
            new TriggerItem(ItemID.TORAGS_HAMMERS_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class AhrimsHood extends ChargedItem {
    public AhrimsHood(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.AHRIMS_HOOD, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.AHRIMS_HOOD).fixedCharges(100),
            new TriggerItem(ItemID.AHRIMS_HOOD_100).fixedCharges(100),
            new TriggerItem(ItemID.AHRIMS_HOOD_75).fixedCharges(75),
            new TriggerItem(ItemID.AHRIMS_HOOD_50).fixedCharges(50),
            new TriggerItem(ItemID.AHRIMS_HOOD_25).fixedCharges(25),
            new TriggerItem(ItemID.AHRIMS_HOOD_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class AhrimsStaff extends ChargedItem {
    public AhrimsStaff(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.AHRIMS_STAFF, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.AHRIMS_STAFF).fixedCharges(100),
            new TriggerItem(ItemID.AHRIMS_STAFF_100).fixedCharges(100),
            new TriggerItem(ItemID.AHRIMS_STAFF_75).fixedCharges(75),
            new TriggerItem(ItemID.AHRIMS_STAFF_50).fixedCharges(50),
            new TriggerItem(ItemID.AHRIMS_STAFF_25).fixedCharges(25),
            new TriggerItem(ItemID.AHRIMS_STAFF_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class ToragsHelm extends ChargedItem {
    public ToragsHelm(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.TORAGS_HELM, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.TORAGS_HELM).fixedCharges(100),
            new TriggerItem(ItemID.TORAGS_HELM_100).fixedCharges(100),
            new TriggerItem(ItemID.TORAGS_HELM_75).fixedCharges(75),
            new TriggerItem(ItemID.TORAGS_HELM_50).fixedCharges(50),
            new TriggerItem(ItemID.TORAGS_HELM_25).fixedCharges(25),
            new TriggerItem(ItemID.TORAGS_HELM_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class VeracsPlateskirt extends ChargedItem {
    public VeracsPlateskirt(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.VERACS_PLATESKIRT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.VERACS_PLATESKIRT).fixedCharges(100),
            new TriggerItem(ItemID.VERACS_PLATESKIRT_100).fixedCharges(100),
            new TriggerItem(ItemID.VERACS_PLATESKIRT_75).fixedCharges(75),
            new TriggerItem(ItemID.VERACS_PLATESKIRT_50).fixedCharges(50),
            new TriggerItem(ItemID.VERACS_PLATESKIRT_25).fixedCharges(25),
            new TriggerItem(ItemID.VERACS_PLATESKIRT_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class DharoksHelm extends ChargedItem {
    public DharoksHelm(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.DHAROKS_HELM, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.DHAROKS_HELM).fixedCharges(100),
            new TriggerItem(ItemID.DHAROKS_HELM_100).fixedCharges(100),
            new TriggerItem(ItemID.DHAROKS_HELM_75).fixedCharges(75),
            new TriggerItem(ItemID.DHAROKS_HELM_50).fixedCharges(50),
            new TriggerItem(ItemID.DHAROKS_HELM_25).fixedCharges(25),
            new TriggerItem(ItemID.DHAROKS_HELM_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class GuthansChainskirt extends ChargedItem {
    public GuthansChainskirt(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.GUTHANS_CHAINSKIRT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.GUTHANS_CHAINSKIRT).fixedCharges(100),
            new TriggerItem(ItemID.GUTHANS_CHAINSKIRT_100).fixedCharges(100),
            new TriggerItem(ItemID.GUTHANS_CHAINSKIRT_75).fixedCharges(75),
            new TriggerItem(ItemID.GUTHANS_CHAINSKIRT_50).fixedCharges(50),
            new TriggerItem(ItemID.GUTHANS_CHAINSKIRT_25).fixedCharges(25),
            new TriggerItem(ItemID.GUTHANS_CHAINSKIRT_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class ToragsPlatebody extends ChargedItem {
    public ToragsPlatebody(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.barrows_gear, ItemID.TORAGS_PLATEBODY, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.TORAGS_PLATEBODY).fixedCharges(100),
            new TriggerItem(ItemID.TORAGS_PLATEBODY_100).fixedCharges(100),
            new TriggerItem(ItemID.TORAGS_PLATEBODY_75).fixedCharges(75),
            new TriggerItem(ItemID.TORAGS_PLATEBODY_50).fixedCharges(50),
            new TriggerItem(ItemID.TORAGS_PLATEBODY_25).fixedCharges(25),
            new TriggerItem(ItemID.TORAGS_PLATEBODY_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class J_DesertAmulet extends ChargedItem {
    public J_DesertAmulet(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.desert_amulet, ItemID.DESERT_AMULET_2, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.DESERT_AMULET_2),
            new TriggerItem(ItemID.DESERT_AMULET_3),
            new TriggerItem(ItemID.DESERT_AMULET_4).fixedCharges(Charges.UNLIMITED),
        };

        this.triggers = new TriggerBase[]{
            new OnChatMessage("You have already used your available teleports for today.").setFixedCharges(0),
            new OnResetDaily().specificItem(ItemID.DESERT_AMULET_2).setFixedCharges(1),
            new OnResetDaily().specificItem(ItemID.DESERT_AMULET_3).setFixedCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.ReplaceTarget;
import tictac7x.charges.store.Store;

import static tictac7x.charges.store.ItemContainerId.BANK;
import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_HerbSack extends ChargedItemWithStorage {
    public U_HerbSack(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.herb_sack, ItemID.HERB_SACK, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage = storage.setMaximumIndividualQuantity(30).storableItems(
            new StorableItem(ItemID.GRIMY_GUAM_LEAF).checkName("Guam leaf"),
            new StorableItem(ItemID.GRIMY_MARRENTILL).checkName("Marrentill"),
            new StorableItem(ItemID.GRIMY_TARROMIN).checkName("Tarromin"),
            new StorableItem(ItemID.GRIMY_HARRALANDER).checkName("Harralander"),
            new StorableItem(ItemID.GRIMY_RANARR_WEED).checkName("Ranarr weed"),
            new StorableItem(ItemID.GRIMY_TOADFLAX).checkName("Toadflax"),
            new StorableItem(ItemID.GRIMY_IRIT_LEAF).checkName("Irit leaf"),
            new StorableItem(ItemID.GRIMY_AVANTOE).checkName("Avantoe"),
            new StorableItem(ItemID.GRIMY_KWUARM).checkName("Kwuarm"),
            new StorableItem(ItemID.GRIMY_HUASCA).checkName("Huasca"),
            new StorableItem(ItemID.GRIMY_SNAPDRAGON).checkName("Snapdragon"),
            new StorableItem(ItemID.GRIMY_CADANTINE).checkName("Cadantine"),
            new StorableItem(ItemID.GRIMY_LANTADYME).checkName("Lantadyme"),
            new StorableItem(ItemID.GRIMY_DWARF_WEED).checkName("Dwarf weed"),
            new StorableItem(ItemID.GRIMY_TORSTOL).checkName("Torstol")
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.HERB_SACK),
            new TriggerItem(ItemID.OPEN_HERB_SACK),
        };
        this.triggers = new TriggerBase[] {
            // Check or empty.
            new OnChatMessage("The herb sack is empty.").emptyStorage(),

            // Pickup.
            new OnChatMessage("You put the Grimy (?<herb>.+) herb into your herb sack.").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("herb")), 1);
            }),

            // Check.
            new OnChatMessage("You look in your herb sack and see:").emptyStorage(),
            new OnChatMessage("(?<quantity>.+) x Grimy (?<herb>.+)").matcherConsumer(m -> {
                storage.put(getStorageItemFromName(m.group("herb")), Integer.parseInt(m.group("quantity")));
            }),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Empty to inventory.
            new OnItemContainerChanged(INVENTORY).emptyStorageToInventory().onMenuOption("Empty"),

            // Empty to bank.
            new OnItemContainerChanged(BANK).emptyStorageToBank().onMenuOption("Empty"),

            // Pick guam leaf.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Guam herbs").onMenuImpostor(26828, 39816).addToStorage(ItemID.GRIMY_GUAM_LEAF),
            new OnMenuEntryAdded().isReplaceImpostorId(
                26824, 26825, 26826, 26827, 26828,
                39812, 39813, 39814, 39815, 39816
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Guam herbs"),
                new ReplaceTarget("Herb patch", "Guam herbs")
            ).onMenuTarget("Herbs"),

            // Pick marrentill.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Marrentill herbs").onMenuImpostor(39751, 39821).addToStorage(ItemID.GRIMY_MARRENTILL),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39747, 39748, 39749, 39750, 39751,
                39816, 39817, 39818, 39819, 39821
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Marrentill herbs"),
                new ReplaceTarget("Herb patch", "Marrentill herbs")
            ).onMenuTarget("Herbs"),

            // Pick tarromin.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Tarromin herbs").onMenuImpostor(39756, 39826).addToStorage(ItemID.GRIMY_TARROMIN),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39752, 39753, 39754, 39755, 39756,
                39822, 39823, 39824, 39825, 39826
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Tarromin herbs"),
                new ReplaceTarget("Herb patch", "Tarromin herbs")
            ).onMenuTarget("Herbs"),

            // Pick harralander.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Harralander herbs").onMenuImpostor(39761, 39831).addToStorage(ItemID.GRIMY_HARRALANDER),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39757, 39758, 39759, 39760, 39761,
                39827, 39828, 39829, 39830, 39831
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Harralander herbs"),
                new ReplaceTarget("Herb patch", "Harralander herbs")
            ).onMenuTarget("Herbs"),

            // Pick ranarr.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Ranarr weed herbs").onMenuImpostor(39766, 39836).addToStorage(ItemID.GRIMY_RANARR_WEED),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39762, 39763, 39764, 39765, 39766,
                39832, 39833, 39834, 39835, 39836
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Ranarr weed herbs"),
                new ReplaceTarget("Herb patch", "Ranarr weed herbs")
            ).onMenuTarget("Herbs"),

            // Pick irit leaf.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Irit leaf herbs").onMenuImpostor(39771, 39841).addToStorage(ItemID.GRIMY_IRIT_LEAF),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39767, 39768, 39769, 39770, 39771,
                39837, 39838, 39839, 39840, 39841
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Irit leaf herbs"),
                new ReplaceTarget("Herb patch", "Irit leaf herbs")
            ).onMenuTarget("Herbs"),

            // Pick avantoe.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Avantoe herbs").onMenuImpostor(39776, 39846).addToStorage(ItemID.GRIMY_AVANTOE),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39772, 39773, 39774, 39775, 39776,
                39842, 39843, 39844, 39845, 39846
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Avantoe herbs"),
                new ReplaceTarget("Herb patch", "Avantoe herbs")
            ).onMenuTarget("Herbs"),

            // Pick toadflax.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Toadflax herbs").onMenuImpostor(39781, 39851).addToStorage(ItemID.GRIMY_TOADFLAX),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39777, 39778, 39779, 39780, 39781,
                39847, 39848, 39849, 39850, 39851
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Toadflax herbs"),
                new ReplaceTarget("Herb patch", "Toadflax herbs")
            ).onMenuTarget("Herbs"),

            // Pick kwuarm.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Kwuarm herbs").onMenuImpostor(39786, 39856).addToStorage(ItemID.GRIMY_KWUARM),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39782, 39783, 39784, 39785, 39786,
                39852, 39853, 39854, 39855, 39856
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Kwuarm herbs"),
                new ReplaceTarget("Herb patch", "Kwuarm herbs")
            ).onMenuTarget("Herbs"),

            // Pick huasca.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Huasca herbs").onMenuImpostor(39786, 39856).addToStorage(ItemID.GRIMY_HUASCA),
            new OnMenuEntryAdded().isReplaceImpostorId(
                55342, 55343, 55344, 55345, 55346,
                55347, 55348, 55349, 55350, 55351
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Huasca herbs"),
                new ReplaceTarget("Herb patch", "Huasca herbs")
            ).onMenuTarget("Herbs"),

            // Pick cadantine.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Cadantine herbs").onMenuImpostor(39791, 39861).addToStorage(ItemID.GRIMY_CADANTINE),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39787, 39788, 39789, 39790, 39791,
                39857, 39858, 39859, 39860, 39861
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Cadantine herbs"),
                new ReplaceTarget("Herb patch", "Cadantine herbs")
            ).onMenuTarget("Herbs"),

            // Pick lantadyme.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Lantadyme herbs").onMenuImpostor(39796, 39866).addToStorage(ItemID.GRIMY_LANTADYME),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39792, 39793, 39794, 39795, 39796,
                39862, 39863, 39864, 39865, 39866
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Lantadyme herbs"),
                new ReplaceTarget("Herb patch", "Lantadyme herbs")
            ).onMenuTarget("Herbs"),

            // Pick dwarf weed.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Dwarf weed herbs").onMenuImpostor(39801, 39871).addToStorage(ItemID.GRIMY_DWARF_WEED),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39797, 39798, 39799, 39800, 39801,
                39867, 39868, 39869, 39870, 39871
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Dwarf weed herbs"),
                new ReplaceTarget("Herb patch", "Dwarf weed herbs")
            ).onMenuTarget("Herbs"),

            // Pick torstol.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Torstol herbs").onMenuImpostor(39806, 39876).addToStorage(ItemID.GRIMY_TORSTOL),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39802, 39803, 39804, 39805, 39806,
                39872, 39873, 39874, 39875, 39876
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Torstol herbs"),
                new ReplaceTarget("Herb patch", "Torstol herbs")
            ).onMenuTarget("Herbs"),

            // Pick snapdragon
            new OnXpDrop(Skill.FARMING).requiredItem(ItemID.OPEN_HERB_SACK).onMenuOption("Pick").onMenuTarget("Herbs", "Snapdragon herbs").onMenuImpostor(39811, 39881).addToStorage(ItemID.GRIMY_SNAPDRAGON),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39807, 39808, 39809, 39810, 39811,
                39877, 39878, 39879, 39880, 39881
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Snapdragon herbs"),
                new ReplaceTarget("Herb patch", "Snapdragon herbs")
            ).onMenuTarget("Herbs"),

            // Hide destroy option.
            new OnMenuEntryAdded("Destroy").hide()
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_JarGenerator extends ChargedItem {
    public U_JarGenerator(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.jar_generator, ItemID.JAR_GENERATOR, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.JAR_GENERATOR)
        };

        this.triggers = new TriggerBase[] {
            // Check or use.
            new OnChatMessage("You have (?<charges>.+) charges left in your jar generator.").setDynamicallyCharges(),

            // Crumbles.
            new OnChatMessage("Your jar generator runs out of charges and disappears.").setFixedCharges(100),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class S_FaladorShield extends ChargedItem {
    public S_FaladorShield(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.falador_shield, ItemID.FALADOR_SHIELD_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.FALADOR_SHIELD_1),
            new TriggerItem(ItemID.FALADOR_SHIELD_2),
            new TriggerItem(ItemID.FALADOR_SHIELD_3),
            new TriggerItem(ItemID.FALADOR_SHIELD_4),
        };
        
        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("You have one remaining charge for today.").onItemClick().setFixedCharges(1),
            new OnChatMessage("You have two remaining charges for today.").onItemClick().setFixedCharges(2),

            // Teleport when empty.
            new OnChatMessage("You have already used (both )?your charge(s)? for today.").onItemClick().setFixedCharges(0),
            new OnChatMessage("You have already used all available recharges today. Try again tomorrow when the shield has recharged.").onItemClick().setFixedCharges(0),

            // Recharge prayer.
            new OnGraphicChanged(321).onItemClick().decreaseCharges(1),

            // Daily resets.
            new OnResetDaily().specificItem(ItemID.FALADOR_SHIELD_1).setFixedCharges(1),
            new OnResetDaily().specificItem(ItemID.FALADOR_SHIELD_2).setFixedCharges(1),
            new OnResetDaily().specificItem(ItemID.FALADOR_SHIELD_3).setFixedCharges(1),
            new OnResetDaily().specificItem(ItemID.FALADOR_SHIELD_4).setFixedCharges(2),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class W_VenatorBow extends ChargedItem {
    public W_VenatorBow(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.venator_bow, ItemID.VENATOR_BOW, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.VENATOR_BOW_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemID.VENATOR_BOW)
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your venator bow has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Attack.
            new OnGraphicChanged(2289).decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStatus;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.ItemActivity;
import tictac7x.charges.store.Store;

import java.awt.*;
import java.time.Duration;
import java.time.Instant;

public class J_EscapeCrystal extends ChargedItemWithStatus {
    private Instant instant = Instant.now();
    private boolean alertedAboutActivation = false;

    public J_EscapeCrystal(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.escape_crystal, ItemID.ESCAPE_CRYSTAL, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.ESCAPE_CRYSTAL).quantityCharges().hideOverlay(),
        };

        this.triggers = new TriggerBase[]{
            // Activate / Deactivate.
            new OnVarbitChanged(14838).varbitValueConsumer(value -> {
                if (value == 1) {
                    activate();
                } else {
                    deactivate();
                }
            }),

            // Inactivity period from dialog when changed inactivity period.
            new OnChatMessage("The inactivity period for auto-activation (remains unchanged at|is now) (?<seconds>.+?)s.*").matcherConsumer(matcher -> {
                configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.escape_crystal_inactivity_period, matcher.group("seconds"));
            }),

            // Inactivity period from game message when activating.
            new OnChatMessage("Your escape crystals will now auto-activate if you take damage after a (?<seconds>.+?) seconds.*").matcherConsumer(matcher -> {
                configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.escape_crystal_inactivity_period, matcher.group("seconds"));
            }),

            // Inactivity period from widget.
            new OnWidgetLoaded(219, 1, 3).text("Set auto-activation inactivity period \\(in seconds\\)\\(current: (?<seconds>.+?)s\\)").matcherConsumer(matcher -> {
                configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.escape_crystal_inactivity_period, matcher.group("seconds"));
            }),

            // Keyboard or mouse action resets idle timer.
            new OnUserAction().consumer(() -> {
                resetIdleTimer();
            })
        };
    }

    private boolean isInCombat() {
        return client.getLocalPlayer().getHealthScale() != -1;
    }

    private void resetIdleTimer() {
        instant = Instant.now();
        alertedAboutActivation = false;
    }

    private long getSecondsRemainingUntilActivation() {
        return Math.max(0, config.getEscapeCrystalInactivityPeriod() - Duration.between(instant, Instant.now()).toMillis() / 1000);
    }

    private boolean isAboutToActivate() {
        return isActivated() && isInCombat() && (getSecondsRemainingUntilActivation() <= config.getEscapeCrystalTimeRemainingWarning());
    }

    @Override
    public Color getTextColor() {
        return isAboutToActivate() ? Color.YELLOW : super.getTextColor();
    }

    @Override
    public String getCharges() {
        if (config.getEscapeCrystalStatus() == ItemActivity.DEACTIVATED || (!inInventory() && !inEquipment())) { return ""; }
        if (config.getEscapeCrystalInactivityPeriod() == Charges.UNKNOWN) { return "?"; }

        final long secondsRemainingUntilActivation = getSecondsRemainingUntilActivation();
        if (!alertedAboutActivation && isAboutToActivate()) {
            alertedAboutActivation = true;
            notifier.notify("Escape crystal is activating in " + secondsRemainingUntilActivation + " seconds.");
        }

        return secondsRemainingUntilActivation / 60 + ":" + String.format("%02d", secondsRemainingUntilActivation % 60);
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.HitsplatTarget;
import tictac7x.charges.store.Store;

public class S_CrystalShield extends ChargedItem {
    public S_CrystalShield(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.crystal_shield, ItemID.CRYSTAL_SHIELD, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.CRYSTAL_SHIELD),
            new TriggerItem(ItemID.CRYSTAL_SHIELD_24127),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your crystal shield has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Get hit.
            new OnHitsplatApplied(HitsplatTarget.SELF).moreThanZeroDamage().isEquipped().decreaseCharges(1)
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class B_FremennikSeaBoots extends ChargedItem {
    public B_FremennikSeaBoots(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.fremennik_sea_boots, ItemID.FREMENNIK_SEA_BOOTS_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.FREMENNIK_SEA_BOOTS_1),
            new TriggerItem(ItemID.FREMENNIK_SEA_BOOTS_2),
            new TriggerItem(ItemID.FREMENNIK_SEA_BOOTS_3),
            new TriggerItem(ItemID.FREMENNIK_SEA_BOOTS_4).fixedCharges(Charges.UNLIMITED),
        };

        this.triggers = new TriggerBase[]{
            // Try to teleport while empty.
            new OnChatMessage("You have already used your available teleport for today. Try again tomorrow when the boots have recharged.").setFixedCharges(0),

            // Teleport.
            new OnGraphicChanged(111).onItemClick().decreaseCharges(1),

            // Daily reset.
            new OnResetDaily().specificItem(ItemID.FREMENNIK_SEA_BOOTS_1).setFixedCharges(1),
            new OnResetDaily().specificItem(ItemID.FREMENNIK_SEA_BOOTS_2).setFixedCharges(1),
            new OnResetDaily().specificItem(ItemID.FREMENNIK_SEA_BOOTS_3).setFixedCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class U_SeedBox extends ChargedItemWithStorage {
    public U_SeedBox(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.seed_box, ItemID.SEED_BOX, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.SEED_BOX),
            new TriggerItem(ItemID.OPEN_SEED_BOX),
        };
        this.triggers = new TriggerBase[] {
            // Check or empty.
            new OnChatMessage("(The|Your) seed box is( now| already)? empty.").emptyStorage(),

            // Empty into inventory.
            new OnChatMessage("Emptied (?<quantity>.+) x (?<seed>.+)( seed)? to your inventory.").matcherConsumer(m -> {
                final int seed = getSeedIdFromName(m.group("seed"));
                final int quantity = Integer.parseInt(m.group("quantity"));
                storage.remove(seed, quantity);
            }),

            // Store.
            new OnChatMessage("Stored (?<quantity>.+) x (?<seed>.+)( seed)? in your seed box.").matcherConsumer(m -> {
                final int seed = getSeedIdFromName(m.group("seed"));
                final int quantity = Integer.parseInt(m.group("quantity"));
                storage.add(seed, quantity);
            }),

            // Pickup.
            new OnChatMessage("You put (?<quantity>.+) x (?<seed>.+)( seed)? straight into your open seed box.").matcherConsumer(m -> {
                final int seed = getSeedIdFromName(m.group("seed"));
                final int quantity = Integer.parseInt(m.group("quantity"));
                storage.put(seed, quantity);
            }),

            // Check first message.
            new OnChatMessage("The seed box contains:").emptyStorage(),

            // Check.
            new OnChatMessage("^(?<quantity>.+) x (?<seed>.+)( seed)?.").matcherConsumer(m -> {
                final int seed = getSeedIdFromName(m.group("seed"));
                final int quantity = Integer.parseInt(m.group("quantity"));
                storage.put(seed, quantity);
            }),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide()
        };
    }

    private int getSeedIdFromName(final String seed) {
        switch (seed.toLowerCase().replace(" seed", "")) {
            // Allotments.
            case "potato":
                return ItemID.POTATO_SEED;
            case "onion":
                return ItemID.ONION_SEED;
            case "cabbage":
                return ItemID.CABBAGE_SEED;
            case "tomato":
                return ItemID.TOMATO_SEED;
            case "sweetcorn":
                return ItemID.SWEETCORN_SEED;
            case "strawberry":
                return ItemID.STRAWBERRY_SEED;
            case "watermelon":
                return ItemID.WATERMELON_SEED;
            case "snape grass":
                return ItemID.SNAPE_GRASS_SEED;

            // Hops.
            case "barley":
                return ItemID.BARLEY_SEED;
            case "hammerstone":
                return ItemID.HAMMERSTONE_SEED;
            case "asgarnian":
                return ItemID.ASGARNIAN_SEED;
            case "jute":
                return ItemID.JUTE_SEED;
            case "yanillian":
                return ItemID.YANILLIAN_SEED;
            case "krandorian":
                return ItemID.KRANDORIAN_SEED;
            case "wildblood":
                return ItemID.WILDBLOOD_SEED;

            // Trees.
            case "acorn":
                return ItemID.ACORN;
            case "willow":
                return ItemID.WILLOW_SEED;
            case "maple":
                return ItemID.MAPLE_SEED;
            case "yew":
                return ItemID.YEW_SEED;
            case "magic":
                return ItemID.MAGIC_SEED;
            case "redwood tree":
                return ItemID.REDWOOD_TREE_SEED;

            // Fruit trees.
            case "apple tree":
                return ItemID.APPLE_TREE_SEED;
            case "banana tree":
                return ItemID.BANANA_TREE_SEED;
            case "orange tree":
                return ItemID.ORANGE_TREE_SEED;
            case "curry tree":
                return ItemID.CURRY_TREE_SEED;
            case "pineapple":
                return ItemID.PINEAPPLE_SEED;
            case "papaya tree":
                return ItemID.PAPAYA_TREE_SEED;
            case "palm tree":
                return ItemID.PALM_TREE_SEED;
            case "dragonfruit tree":
                return ItemID.DRAGONFRUIT_TREE_SEED;

            // Bushes.
            case "redberry":
                return ItemID.REDBERRY_SEED;
            case "cadavaberry":
                return ItemID.CADAVABERRY_SEED;
            case "dwellberry":
                return ItemID.DWELLBERRY_SEED;
            case "jangerberry":
                return ItemID.JANGERBERRY_SEED;
            case "whiteberry":
                return ItemID.WHITEBERRY_SEED;
            case "poison ivy":
                return ItemID.POISON_IVY_SEED;

            // Flowers.
            case "marigold":
                return ItemID.MARIGOLD_SEED;
            case "rosemary":
                return ItemID.ROSEMARY_SEED;
            case "nasturtium":
                return ItemID.NASTURTIUM_SEED;
            case "woad":
                return ItemID.WOAD_SEED;
            case "limpwurt":
                return ItemID.LIMPWURT_SEED;
            case "white lily":
                return ItemID.WHITE_LILY_SEED;

            // Herbs.
            case "guam":
                return ItemID.GUAM_SEED;
            case "marrentill":
                return ItemID.MARRENTILL_SEED;
            case "tarromin":
                return ItemID.TARROMIN_SEED;
            case "harralander":
                return ItemID.HARRALANDER_SEED;
            case "ranarr":
                return ItemID.RANARR_SEED;
            case "toadflax":
                return ItemID.TOADFLAX_SEED;
            case "irit":
                return ItemID.IRIT_SEED;
            case "avantoe":
                return ItemID.AVANTOE_SEED;
            case "kwuarm":
                return ItemID.KWUARM_SEED;
            case "snapdragon":
                return ItemID.SNAPDRAGON_SEED;
            case "cadantine":
                return ItemID.CADANTINE_SEED;
            case "lantadyme":
                return ItemID.LANTADYME_SEED;
            case "dwarf weed":
                return ItemID.DWARF_WEED_SEED;
            case "torstol":
                return ItemID.TORSTOL_SEED;

            // Special seeds.
            case "seaweed spore":
                return ItemID.SEAWEED_SPORE;
            case "teak":
                return ItemID.TEAK_SEED;
            case "grape":
                return ItemID.GRAPE_SEED;
            case "mushroom spore":
                return ItemID.MUSHROOM_SPORE;
            case "mahogany":
                return ItemID.MAHOGANY_SEED;
            case "cactus":
                return ItemID.CACTUS_SEED;
            case "belladonna":
                return ItemID.BELLADONNA_SEED;
            case "potato cactus":
                return ItemID.POTATO_CACTUS_SEED;
            case "hespori":
                return ItemID.HESPORI_SEED;
            case "calquat tree":
                return ItemID.CALQUAT_TREE_SEED;
            case "crystal acorn":
                return ItemID.CRYSTAL_ACORN;
            case "kronos":
                return ItemID.KRONOS_SEED;
            case "iasor":
                return ItemID.IASOR_SEED;
            case "attas":
                return ItemID.ATTAS_SEED;
            case "spirit":
                return ItemID.SPIRIT_SEED;
            case "celastrus":
                return ItemID.CELASTRUS_SEED;
        }

        return Charges.UNKNOWN;
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_GricollersCan extends ChargedItem {
    public U_GricollersCan(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.gricollers_can, ItemID.GRICOLLERS_CAN, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.GRICOLLERS_CAN),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Watering can charges remaining: (?<charges>.+)%").setDynamicallyCharges().onItemClick(),

            // Water inventory item.
            new OnChatMessage("You water").onItemClick().decreaseCharges(1),

            // Fill.
            new OnChatMessage("You fill the watering can").onItemClick().setFixedCharges(1000),

            // Water.
            new OnGraphicChanged(410).decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_RingOfSlayer extends ChargedItem {
    public J_RingOfSlayer(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.slayer_ring, ItemID.SLAYER_RING_8, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.SLAYER_RING_1).fixedCharges(1),
            new TriggerItem(ItemID.SLAYER_RING_2).fixedCharges(2),
            new TriggerItem(ItemID.SLAYER_RING_3).fixedCharges(3),
            new TriggerItem(ItemID.SLAYER_RING_4).fixedCharges(4),
            new TriggerItem(ItemID.SLAYER_RING_5).fixedCharges(5),
            new TriggerItem(ItemID.SLAYER_RING_6).fixedCharges(6),
            new TriggerItem(ItemID.SLAYER_RING_7).fixedCharges(7),
            new TriggerItem(ItemID.SLAYER_RING_8).fixedCharges(8),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class W_SlayerStaffE extends ChargedItem {
    public W_SlayerStaffE(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.slayer_staff_e, ItemID.SLAYERS_STAFF_E, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.SLAYERS_STAFF_E)
        };

        this.triggers = new TriggerBase[] {
            // Enchant.
            new OnChatMessage("The spell enchants your staff. The tatty parchment crumbles to dust.").setFixedCharges(2500),

            // Check.
            new OnChatMessage("Your staff has (?<charges>.+) charges?.").setDynamicallyCharges(),

            // Attack.
            new OnAnimationChanged(1576).isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_PharaohsSceptre extends ChargedItem {
    public W_PharaohsSceptre(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.pharaohs_sceptre, ItemID.PHARAOHS_SCEPTRE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_9045),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_9046),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_9047),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_9048),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_9049),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_9050),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_9051),

            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_13074),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_13075),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_13076),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_13077),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_13078),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_16176),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_21445),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_21446),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_26948),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_26950),
            new TriggerItem(ItemID.PHARAOHS_SCEPTRE_UNCHARGED).fixedCharges(0),
        };
        
        this.triggers = new TriggerBase[]{
            // Check and automatic messages.
            new OnChatMessage("Your sceptre has (?<charges>.+) charges? left.").setDynamicallyCharges().onItemClick(),
            // Charge non-empty sceptre.
            new OnChatMessage("Right, you already had .+ charges?, and I don't give discounts. That means .+ artefacts gives you (?<charges>.+) charges?. Now be on your way.").increaseDynamically(),
            // Charge empty sceptre.
            new OnChatMessage("Right, .+ artefacts gives you (?<charges>.+) charges. Now be on your way.").setDynamicallyCharges(),
            // Teleport.
            new OnGraphicChanged(715).onItemClick().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class F_SunlightMothMix extends ChargedItem {
    public F_SunlightMothMix(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.sunlight_moth_mix, ItemID.SUNLIGHT_MOTH_MIX_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.SUNLIGHT_MOTH_MIX_1).fixedCharges(1),
            new TriggerItem(ItemID.SUNLIGHT_MOTH_MIX_2).fixedCharges(2),
        };
    }

    @Override
    public String getTooltip() {
        return "Sunlight moth mix: " + getTotalCharges();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class S_Chronicle extends ChargedItem {
    public S_Chronicle(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.chronicle, ItemID.CHRONICLE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.CHRONICLE),
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("Your book has (?<charges>.+) charges? left.").setDynamicallyCharges().onItemClick()
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_TridentOfTheSeas extends ChargedItem {
    public W_TridentOfTheSeas(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.trident_of_the_seas, ItemID.TRIDENT_OF_THE_SEAS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.UNCHARGED_TRIDENT).fixedCharges(0),
            new TriggerItem(ItemID.UNCHARGED_TRIDENT_E).fixedCharges(0),
            new TriggerItem(ItemID.UNCHARGED_TOXIC_TRIDENT).fixedCharges(0),
            new TriggerItem(ItemID.UNCHARGED_TOXIC_TRIDENT_E).fixedCharges(0),
            new TriggerItem(ItemID.TRIDENT_OF_THE_SEAS),
            new TriggerItem(ItemID.TRIDENT_OF_THE_SEAS_FULL).fixedCharges(2500),
            new TriggerItem(ItemID.TRIDENT_OF_THE_SEAS_E),
            new TriggerItem(ItemID.TRIDENT_OF_THE_SWAMP),
            new TriggerItem(ItemID.TRIDENT_OF_THE_SWAMP_E),
        };

        this.triggers = new TriggerBase[] {
            // Ran out of charges.
            new OnChatMessage("Your Trident of the (seas|swamp)( \\(e\\))? has run out of charges.").notification().setFixedCharges(0),

            // Check, one charge left.
            new OnChatMessage("Your Trident of the (seas|swamp)( \\(e\\))? has one charge.").setFixedCharges(1),

            // Check for charges and warning when low.
            new OnChatMessage("Your Trident of the (seas|swamp)( \\([full|e]\\))? (only )?has (?<charges>.+) charges( left)?.").setDynamicallyCharges(),

            // Charge to full.
            new OnChatMessage("You add .* charges? to the Trident of the (seas|swamp)( \\(full\\))?. New total: (?<charges>.+)").setDynamicallyCharges(),

            // Attack.
            new OnGraphicChanged(1251).isEquipped().decreaseCharges(1)
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.OnWidgetLoaded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class C_MagicCape extends ChargedItem {
    public C_MagicCape(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.magic_cape, ItemID.MAGIC_CAPE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.MAGIC_CAPE),
            new TriggerItem(ItemID.MAGIC_CAPET)
        };

        this.triggers = new TriggerBase[] {
            // After spellbook swap.
            new OnChatMessage("You have changed your spellbook (?<used>.+)/(?<total>.+) times today.").useDifference(),

            // Spellbook swap widget.
            new OnWidgetLoaded(219, 1, 0).text("Choose spellbook: \\((?<charges>.+)/5 left\\)").setDynamically(),

            // Daily reset.
            new OnResetDaily().setFixedCharges(5),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_PendantOfAtes extends ChargedItem {
    public J_PendantOfAtes(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.pendant_of_ates, ItemID.PENDANT_OF_ATES, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.PENDANT_OF_ATES_INERT).fixedCharges(0),
            new TriggerItem(ItemID.PENDANT_OF_ATES),
        };

        this.triggers = new TriggerBase[]{
            // Check empty.
            new OnChatMessage("The pendant has no charges.").setFixedCharges(0).onItemClick(),

            // Check.
            new OnChatMessage("The pendant has (?<charges>.+) charges?.").setDynamicallyCharges().onItemClick(),

            // Charge.
            new OnChatMessage("You add .+ frozen tears? to your pendant. It now has (?<charges>.+) charges.").setDynamicallyCharges(),

            // Uncharge.
            new OnChatMessage("You uncharge your pendant by removing (?<charges>.+) frozen tears? from it.").decreaseDynamicallyCharges(),

            // Teleport.
            new OnGraphicChanged(2754).decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStatus;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_AshSanctifier extends ChargedItemWithStatus {
    public U_AshSanctifier(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ash_sanctifier, ItemID.ASH_SANCTIFIER, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.ASH_SANCTIFIER),
        };
        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("(The|Your) ash sanctifier has (?<charges>.+) charges?( left)?. It has been deactivated").setDynamicallyCharges().deactivate(),
            new OnChatMessage("(The|Your) ash sanctifier has (?<charges>.+) charges?( left)?. It is active").setDynamicallyCharges().activate(),
            new OnChatMessage("(The|Your) ash sanctifier has (?<charges>.+) charges?( left)?.").setDynamicallyCharges(),

            // Activate.
            new OnChatMessage("The ash sanctifier is active and ready to scatter ashes.").activate(),

            // Deactivate.
            new OnChatMessage("The ash sanctifier has been deactivated, and will not scatter ashes now.").deactivate(),

            // Automatic scatter.
            new OnXpDrop(Skill.PRAYER).isActivated().decreaseCharges(1),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_ToxicStaffOfTheDead extends ChargedItem {
    public W_ToxicStaffOfTheDead(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.toxic_staff_of_the_dead, ItemID.TOXIC_STAFF_OF_THE_DEAD, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.TOXIC_STAFF_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemID.TOXIC_STAFF_OF_THE_DEAD)
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("Scales: (?<charges>.+)").setDynamicallyCharges(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;

import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

import java.awt.*;
import java.util.Optional;

import static tictac7x.charges.TicTac7xChargesImprovedPlugin.getNumberFromWordRepresentation;

public class U_ColossalPouch extends ChargedItemWithStorage {
    public U_ColossalPouch(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.colossal_pouch, ItemID.COLOSSAL_POUCH, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.storage = storage.storableItems(
            new StorableItem(ItemID.RUNE_ESSENCE),
            new StorableItem(ItemID.PURE_ESSENCE),
            new StorableItem(ItemID.DAEYALT_ESSENCE),
            new StorableItem(ItemID.GUARDIAN_ESSENCE)
        ).setMaximumTotalQuantity(40).setHoldsSingleType(true);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.COLOSSAL_POUCH),
            new TriggerItem(ItemID.COLOSSAL_POUCH_26786), // Degraded
        };

        this.triggers = new TriggerBase[]{
            // Empty.
            new OnChatMessage("There is no essence in this pouch.").emptyStorage(),

            // Guardians of the rift.
            new OnChatMessage("The rift becomes active!").consumer(() -> {
                storage.put(ItemID.GUARDIAN_ESSENCE, 0);
            }),
            new OnVarbitChanged(13691, 0).consumer(() -> {
                storage.put(ItemID.GUARDIAN_ESSENCE, 0);
            }),

            // Check.
            new OnChatMessage("There (is|are) (?<quantity>.+?) (?<essence>normal|pure|daeyalt|guardian|normal) essences? in this pouch.").matcherConsumer((m) -> {
                final int quantity = getNumberFromWordRepresentation(m.group("quantity"));

                int essenceId;
                switch (m.group("essence")) {
                    case "normal":
                        essenceId = ItemID.RUNE_ESSENCE;
                        break;
                    case "pure":
                        essenceId = ItemID.PURE_ESSENCE;
                        break;
                    case "daeyalt":
                        essenceId = ItemID.DAEYALT_ESSENCE;
                        break;
                    case "guardian":
                        essenceId = ItemID.GUARDIAN_ESSENCE;
                        break;
                    default:
                        return;
                }

                storage.clearAndPut(essenceId, quantity);
            }).onMenuOption("Check"),

            // Decay.
            new OnChatMessage("Your pouch has decayed through use.").onMenuOption("Fill").consumer(() -> {
                configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.colossal_pouch_decay_count, config.getColossalPouchDecayCount() + 1);
                storage.setMaximumTotalQuantity(getPouchCapacity());
            }),

            // Repair.
            new OnChatMessage("Fine. A simple transfiguration spell should resolve things for you.").consumer(() -> {
                configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.colossal_pouch_decay_count, 0);
                storage.setMaximumTotalQuantity(getPouchCapacity());
            }),

            // Fill from inventory.
            new OnMenuOptionClicked("Fill").runConsumerOnNextGameTick(() -> {
                if (store.inventoryContainsItem(ItemID.GUARDIAN_ESSENCE)) {
                    storage.add(ItemID.GUARDIAN_ESSENCE, store.getInventoryItemQuantity(ItemID.GUARDIAN_ESSENCE));
                } else if (store.inventoryContainsItem(ItemID.DAEYALT_ESSENCE)) {
                    storage.add(ItemID.DAEYALT_ESSENCE, store.getInventoryItemQuantity(ItemID.DAEYALT_ESSENCE));
                } else if (store.inventoryContainsItem(ItemID.PURE_ESSENCE)) {
                    storage.add(ItemID.PURE_ESSENCE, store.getInventoryItemQuantity(ItemID.PURE_ESSENCE));
                } else if (store.inventoryContainsItem(ItemID.RUNE_ESSENCE)) {
                    storage.add(ItemID.RUNE_ESSENCE, store.getInventoryItemQuantity(ItemID.RUNE_ESSENCE));
                }
            }),

            // Use essence on pouch.
            new OnMenuOptionClicked("Use").menuOptionConsumer(advancedMenuEntry -> {
                final Optional<StorageItem> essence = getStorageItemFromName(advancedMenuEntry.target);
                if (essence.isPresent()) {
                    store.nextTickQueue.add(() -> storage.add(essence.get().itemId, store.getInventoryItemQuantity(essence.get().itemId)));
                }
            }).onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Empty to inventory.
            new OnMenuOptionClicked("Empty").runConsumerOnNextGameTick(() -> {
                storage.emptyToInventoryWithoutItemContainerChanged();
            }),

            // Set maximum charges on level up
            new OnStatChanged(Skill.RUNECRAFT).consumer(() -> {
                storage.setMaximumTotalQuantity(getPouchCapacity());
            }),
        };
    }

    @Override
    public Color getTextColor() {
        if (storage.isFull()) {
            if (config.getColossalPouchDecayCount() == 0) {
                return config.getColorActivated();
            } else {
                return config.getColorEmpty();
            }
        }

        return super.getTextColor();
    }

    private final int[] CAPACITY_85 = {40, 35, 30, 25, 20, 15, 10, 5};
    private final int[] CAPACITY_75 = {27, 23, 20, 16, 13, 10, 6, 3};
    private final int[] CAPACITY_50 = {16, 14, 12, 10, 8, 6, 4, 2};
    private final int[] CAPACITY_25 = {8, 5, 2}; // TODO: verify these

    public int getPouchCapacity() {
        final int decayCount = config.getColossalPouchDecayCount();
        final int runecraftLevel = this.client.getRealSkillLevel(Skill.RUNECRAFT);

        if (runecraftLevel >= 85) {
            return CAPACITY_85[Math.min(CAPACITY_85.length - 1, decayCount)];
        } else if (runecraftLevel >= 75) {
            return CAPACITY_75[Math.min(CAPACITY_75.length - 1, decayCount)];
        } else if (runecraftLevel >= 50) {
            return CAPACITY_50[Math.min(CAPACITY_50.length - 1, decayCount)];
        } else if (runecraftLevel >= 25) {
            return CAPACITY_25[Math.min(CAPACITY_25.length - 1, decayCount)];
        } else {
            return 0;
        }
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;

public class J_BraceletOfClay extends ChargedItem {
    public J_BraceletOfClay(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.bracelet_of_clay, ItemID.BRACELET_OF_CLAY, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.BRACELET_OF_CLAY).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("You can mine (?<charges>.+) more pieces? of soft clay before your bracelet crumbles to dust.").setDynamicallyCharges(),

            // Mine clay.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).isEquipped().onMenuOption("Mine").onMenuTarget("Clay rocks").consumer(() -> {
                final int clayBefore = store.getPreviousInventoryItemQuantity(ItemID.SOFT_CLAY);
                final int clayAfter = store.getInventoryItemQuantity(ItemID.SOFT_CLAY);
                decreaseCharges(clayAfter - clayBefore);
            }),

            // Mine soft clay.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).isEquipped().onMenuOption("Mine").onMenuTarget("Soft clay rocks").consumer(() -> {
                final int clayBefore = store.getPreviousInventoryItemQuantity(ItemID.SOFT_CLAY);
                final int clayAfter = store.getInventoryItemQuantity(ItemID.SOFT_CLAY);

                // At least 2 soft clay was mined.
                if (clayAfter - clayBefore >= 2) {
                    decreaseCharges(1);
                }
            }),

            // Crumbles.
            new OnChatMessage("Your bracelet of clay crumbles to dust.").setFixedCharges(28).notification("Your clay bracelet crumbles to dust.")
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.OnItemPickup;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import static tictac7x.charges.store.ItemContainerId.INVENTORY;
import static tictac7x.charges.store.ItemContainerId.BANK;


public class U_GemBag extends ChargedItemWithStorage {
    public U_GemBag(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.gem_bag, ItemID.GEM_BAG_12020, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage.setMaximumIndividualQuantity(60).storableItems(
            new StorableItem(ItemID.UNCUT_SAPPHIRE).checkName("Sapphire").specificOrder(1),
            new StorableItem(ItemID.UNCUT_EMERALD).checkName("Emerald").specificOrder(2),
            new StorableItem(ItemID.UNCUT_RUBY).checkName("Ruby").specificOrder(3),
            new StorableItem(ItemID.UNCUT_DIAMOND).checkName("Diamond").specificOrder(4),
            new StorableItem(ItemID.UNCUT_DRAGONSTONE).checkName("Dragonstone").specificOrder(5)
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.GEM_BAG_12020),
            new TriggerItem(ItemID.OPEN_GEM_BAG),
        };

        this.triggers = new TriggerBase[]{
            // Empty to bank or inventory.
            new OnChatMessage("The gem bag is( now)? empty.").emptyStorage(),

            // Empty and Check.
            new OnChatMessage("(Left in bag: )?Sapphires: (?<sapphires>.+) / Emeralds: (?<emeralds>.+) / Rubies: (?<rubies>.+) Diamonds: (?<diamonds>.+) / Dragonstones: (?<dragonstones>.+)").matcherConsumer(m -> {
                storage.put(ItemID.UNCUT_SAPPHIRE, Integer.parseInt(m.group("sapphires")));
                storage.put(ItemID.UNCUT_EMERALD, Integer.parseInt(m.group("emeralds")));
                storage.put(ItemID.UNCUT_RUBY, Integer.parseInt(m.group("rubies")));
                storage.put(ItemID.UNCUT_DIAMOND, Integer.parseInt(m.group("diamonds")));
                storage.put(ItemID.UNCUT_DRAGONSTONE, Integer.parseInt(m.group("dragonstones")));
            }),

            // Mining regular or gem rocks.
            new OnChatMessage("You just (found|mined) (a|an) (?<gem>.+)!").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("gem")), 1);
            }).requiredItem(ItemID.OPEN_GEM_BAG),

            // Pickpocketing.
            new OnChatMessage("The following stolen loot gets added to your gem bag: Uncut (?<gem>.+) x (?<quantity>.+).").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("gem")), Integer.parseInt(m.group("quantity")));
            }),

            // Stealing from stalls.
            new OnChatMessage("You steal an uncut (?<gem>.+) and add it to your gem bag.").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("gem")), 1);
            }),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Empty to bank.
            new OnItemContainerChanged(BANK).emptyStorageToBank().onMenuOption("Empty"),

            // Use gem on bag
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseChargedItemOnStorageItem(storage.getStorableItems()),
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Pick up.
            new OnItemPickup(storage.getStorableItems()).isByOne().requiredItem(ItemID.OPEN_GEM_BAG).pickUpToStorage(),

            // Telegrab.
            new OnXpDrop(Skill.MAGIC).requiredItem(ItemID.OPEN_GEM_BAG).onMenuOption("Cast").onMenuTarget(
                "Uncut sapphire"
            ).addToStorage(ItemID.UNCUT_SAPPHIRE, 1),
            new OnXpDrop(Skill.MAGIC).requiredItem(ItemID.OPEN_GEM_BAG).onMenuOption("Cast").onMenuTarget(
                "Uncut emerald"
            ).addToStorage(ItemID.UNCUT_EMERALD, 1),
            new OnXpDrop(Skill.MAGIC).requiredItem(ItemID.OPEN_GEM_BAG).onMenuOption("Cast").onMenuTarget(
                "Uncut ruby"
            ).addToStorage(ItemID.UNCUT_RUBY, 1),
            new OnXpDrop(Skill.MAGIC).requiredItem(ItemID.OPEN_GEM_BAG).onMenuOption("Cast").onMenuTarget(
                "Uncut diamond"
            ).addToStorage(ItemID.UNCUT_DIAMOND, 1),
            new OnXpDrop(Skill.MAGIC).requiredItem(ItemID.OPEN_GEM_BAG).onMenuOption("Cast").onMenuTarget(
                "Uncut dragonstone"
            ).addToStorage(ItemID.UNCUT_DRAGONSTONE, 1),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_SoulBearer extends ChargedItem {
    public U_SoulBearer(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.soul_bearer, ItemID.SOUL_BEARER, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.SOUL_BEARER),
            new TriggerItem(ItemID.DAMAGED_SOUL_BEARER).fixedCharges(0),
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("You remove the runes from the soul bearer.").setFixedCharges(0),
            new OnChatMessage("(The|Your) soul bearer( now)? has one charge.").setFixedCharges(1),
            new OnChatMessage("Your soul bearer carries the ensouled heads to your bank. It has run out of charges.").notification().setFixedCharges(0),
            new OnChatMessage("The soul bearer has (?<charges>.+) charges?.").setDynamicallyCharges(),
            new OnChatMessage("You add .+ charges? to your soul bearer. It now has (?<charges>.+) charges?.").setDynamicallyCharges(),
            new OnChatMessage("Your soul bearer carries the ensouled heads to your bank. It has (?<charges>.+) charges? left.").setDynamicallyCharges()
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class F_BlackWarlockMix extends ChargedItem {
    public F_BlackWarlockMix(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.black_warlock_mix, ItemID.BLACK_WARLOCK_MIX_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.BLACK_WARLOCK_MIX_1).fixedCharges(1),
            new TriggerItem(ItemID.BLACK_WARLOCK_MIX_2).fixedCharges(2),
        };
    }

    @Override
    public String getTooltip() {
        return "Black warlock mix: " + getTotalCharges();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_BraceletOfExpeditious extends ChargedItem {
    public J_BraceletOfExpeditious(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.bracelet_of_expeditious, ItemID.EXPEDITIOUS_BRACELET, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.EXPEDITIOUS_BRACELET).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your expeditious bracelet has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Charge used.
            new OnChatMessage("Your expeditious bracelet helps you progress your slayer( task)? faster. It has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Bracelet fully used.
            new OnChatMessage("Your expeditious bracelet helps you progress your slayer faster. It then crumbles to dust.").setFixedCharges(30).notification("Your expeditious bracelet crumbles to dust."),

            // Break.
            new OnChatMessage("The bracelet shatters. Your next expeditious bracelet will start afresh from (?<charges>.+) charges.").setDynamicallyCharges(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_IbansStaff extends ChargedItem {
    public W_IbansStaff(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ibans_staff, ItemID.IBANS_STAFF, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.IBANS_STAFF),
            new TriggerItem(ItemID.IBANS_STAFF_1410),
            new TriggerItem(ItemID.IBANS_STAFF_U),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("You have (?<charges>.+) charges left on the staff.").setDynamicallyCharges().onItemClick(),
            // Attack.
            new OnGraphicChanged(87).isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class W_WesternBanner extends ChargedItem {
    public W_WesternBanner(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.western_banner, ItemID.WESTERN_BANNER_3, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.WESTERN_BANNER_3),
            new TriggerItem(ItemID.WESTERN_BANNER_4).fixedCharges(Charges.UNLIMITED),
        };

        this.triggers = new TriggerBase[]{
            new OnResetDaily().requiredItem(ItemID.WESTERN_BANNER_3).setFixedCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;

import static tictac7x.charges.store.ItemContainerId.BANK;
import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_FurPouch extends ChargedItemWithStorage {
    public U_FurPouch(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.fur_pouch, ItemID.SMALL_FUR_POUCH, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.storage = storage
            .storableItems(
                // Tracking.
                new StorableItem(ItemID.POLAR_KEBBIT_FUR),
                new StorableItem(ItemID.COMMON_KEBBIT_FUR),
                new StorableItem(ItemID.FELDIP_WEASEL_FUR),
                new StorableItem(ItemID.DESERT_DEVIL_FUR),

                // Deadfall.
                new StorableItem(ItemID.FOX_FUR),

                // Pitfalls.
                new StorableItem(ItemID.LARUPIA_FUR),
                new StorableItem(ItemID.GRAAHK_FUR),
                new StorableItem(ItemID.KYATT_FUR),
                new StorableItem(ItemID.SUNLIGHT_ANTELOPE_FUR),
                new StorableItem(ItemID.MOONLIGHT_ANTELOPE_FUR),

                // Aerial.
                new StorableItem(ItemID.SPOTTED_KEBBIT_FUR),
                new StorableItem(ItemID.DARK_KEBBIT_FUR),
                new StorableItem(ItemID.DASHING_KEBBIT_FUR)
            );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.SMALL_FUR_POUCH).maxCharges(14),
            new TriggerItem(ItemID.SMALL_FUR_POUCH_OPEN).maxCharges(14),
            new TriggerItem(ItemID.MEDIUM_FUR_POUCH).maxCharges(21),
            new TriggerItem(ItemID.MEDIUM_FUR_POUCH_OPEN).maxCharges(21),
            new TriggerItem(ItemID.LARGE_FUR_POUCH).maxCharges(28),
            new TriggerItem(ItemID.LARGE_FUR_POUCH_OPEN).maxCharges(28),
        };

        this.triggers = new TriggerBase[]{
            // Empty.
            new OnChatMessage("Your fur pouch is currently holding 0 fur.").emptyStorage(),
            new OnChatMessage("Your fur pouch is empty.").emptyStorage(),

            // Fill from inventory.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Empty to inventory.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).emptyStorageToInventory().onMenuOption("Empty"),

            // Empty to bank.
            new OnItemContainerChanged(BANK).emptyStorageToBank().onMenuOption("Empty"),

            // Use fur on pouch.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Hide destroy option.
            new OnMenuEntryAdded("Destroy").hide(),

            // Tracking.
            new OnChatMessage("You manage to noose a polar kebbit that is hiding in the snowdrift.").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).addToStorage(ItemID.POLAR_KEBBIT_FUR),
            new OnChatMessage("You manage to noose a common kebbit that is hiding in the bush.").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).addToStorage(ItemID.COMMON_KEBBIT_FUR),
            new OnChatMessage("You manage to noose a Feldip weasel that is hiding in the bush.").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).addToStorage(ItemID.FELDIP_WEASEL_FUR),
            new OnChatMessage("You manage to noose a desert devil that is hiding in the sand.").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).addToStorage(ItemID.DESERT_DEVIL_FUR),

            // Deadfalls.
            new OnChatMessage("You've caught a pyre fox.").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).addToStorage(ItemID.FOX_FUR),

            // Pitfalls.
            new OnChatMessage("You've caught a spined larupia!").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).addToStorage(ItemID.LARUPIA_FUR),
            new OnItemContainerChanged(ItemContainerId.INVENTORY).hasChatMessage("You've caught a spined larupia!").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).onItemContainerDifference(itemsDifference -> {
                if (itemsDifference.hasItem(ItemID.TATTY_LARUPIA_FUR)) {
                    storage.remove(ItemID.LARUPIA_FUR, 1);
                }
            }),
            new OnChatMessage("You've caught a horned graahk!").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).addToStorage(ItemID.GRAAHK_FUR),
            new OnItemContainerChanged(ItemContainerId.INVENTORY).hasChatMessage("You've caught a horned graahk!").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).onItemContainerDifference(itemsDifference -> {
                if (itemsDifference.hasItem(ItemID.TATTY_GRAAHK_FUR)) {
                    storage.remove(ItemID.GRAAHK_FUR, 1);
                }
            }),
            new OnChatMessage("You've caught a sabre-?toothed kyatt!").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).addToStorage(ItemID.KYATT_FUR),
            new OnItemContainerChanged(ItemContainerId.INVENTORY).hasChatMessage("You've caught a sabre-?toothed kyatt!").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).onItemContainerDifference(itemsDifference -> {
                if (itemsDifference.hasItem(ItemID.TATTY_KYATT_FUR)) {
                    storage.remove(ItemID.KYATT_FUR, 1);
                }
            }),
            new OnChatMessage("You've caught a sunlight antelope!").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).addToStorage(ItemID.SUNLIGHT_ANTELOPE_FUR),
            new OnChatMessage("You've caught a moonlight antelope!").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).addToStorage(ItemID.MOONLIGHT_ANTELOPE_FUR),

            // Aerial.
            new OnXpDrop(Skill.HUNTER, 104).hasChatMessage("You retrieve the falcon as well as the fur of the dead kebbit.").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).consumer(() -> {
                storage.add(ItemID.SPOTTED_KEBBIT_FUR, 1);
            }),
            new OnXpDrop(Skill.HUNTER, 132).hasChatMessage("You retrieve the falcon as well as the fur of the dead kebbit.").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).consumer(() -> {
                storage.add(ItemID.DARK_KEBBIT_FUR, 1);
            }),
            new OnXpDrop(Skill.HUNTER, 156).hasChatMessage("You retrieve the falcon as well as the fur of the dead kebbit.").requiredItem(ItemID.SMALL_FUR_POUCH_OPEN, ItemID.MEDIUM_FUR_POUCH_OPEN, ItemID.LARGE_FUR_POUCH_OPEN).consumer(() -> {
                storage.add(ItemID.DASHING_KEBBIT_FUR, 1);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class S_TomeOfWater extends ChargedItem {
    public S_TomeOfWater(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.tome_of_water, ItemID.TOME_OF_WATER, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.TOME_OF_WATER_EMPTY).fixedCharges(0),
            new TriggerItem(ItemID.TOME_OF_WATER).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your tome currently holds (?<charges>.+) charges?.").setDynamicallyCharges().onItemClick(),

            // Attack with regular spellbook water spells.
            new OnGraphicChanged(93, 120, 135, 161, 1458).isEquipped().decreaseCharges(1)
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static tictac7x.charges.store.ItemContainerId.BANK;
import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_LogBasket extends ChargedItemWithStorage {
    private Optional<StorageItem> lastLogs = Optional.empty();
    private int infernalQuantityTracker = 0;

    public U_LogBasket(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.log_basket, ItemID.LOG_BASKET, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage.setMaximumTotalQuantity(28).storableItems(
            new StorableItem(ItemID.LOGS).displayName("Regular logs").checkName("some logs", "x Logs"),
            new StorableItem(ItemID.ACHEY_TREE_LOGS).checkName("Achey tree logs"),
            new StorableItem(ItemID.OAK_LOGS).checkName("Oak logs"),
            new StorableItem(ItemID.WILLOW_LOGS).checkName("Willow logs"),
            new StorableItem(ItemID.TEAK_LOGS).checkName("Teak logs"),
            new StorableItem(ItemID.JUNIPER_LOGS).checkName("Juniper logs"),
            new StorableItem(ItemID.MAPLE_LOGS).checkName("Maple logs"),
            new StorableItem(ItemID.MAHOGANY_LOGS).checkName("Mahogany logs"),
            new StorableItem(ItemID.ARCTIC_PINE_LOGS).checkName("Arctic pine logs"),
            new StorableItem(ItemID.YEW_LOGS).checkName("Yew logs"),
            new StorableItem(ItemID.BLISTERWOOD_LOGS).checkName("Blisterwood logs"),
            new StorableItem(ItemID.MAGIC_LOGS).checkName("Magic logs"),
            new StorableItem(ItemID.REDWOOD_LOGS).checkName("Redwood logs")
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.LOG_BASKET),
            new TriggerItem(ItemID.OPEN_LOG_BASKET),
            new TriggerItem(ItemID.FORESTRY_BASKET),
            new TriggerItem(ItemID.OPEN_FORESTRY_BASKET),
        };
        this.triggers = new TriggerBase[] {
            // Check while empty.
            new OnChatMessage("(Your|The) basket is empty.").onItemClick().emptyStorage().consumer(() -> {
                infernalQuantityTracker = 0;
                lastLogs = Optional.empty();
            }),

            // Empty to bank.
            new OnChatMessage("You empty your basket( into the bank)?.").onItemClick().emptyStorage().consumer(() -> {
                infernalQuantityTracker = 0;
                lastLogs = Optional.empty();
            }),

            // Check.
            new OnChatMessage("The basket contains:").stringConsumer(s -> {
                storage.clear();

                final Pattern pattern = Pattern.compile("(?<quantity>\\d+).x.(?<logs>.*?)(,|$)");
                final Matcher matcher = pattern.matcher(s);

                while (matcher.find()) {
                    storage.put(getStorageItemFromName(matcher.group("logs")), Integer.parseInt(matcher.group("quantity")));
                }

                infernalQuantityTracker = getQuantity();
            }).onItemClick(),

            // Miscellania support.
            new OnChatMessage("You get some maple logs and give them to Lumberjack Leif.").requiredItem(ItemID.OPEN_LOG_BASKET, ItemID.OPEN_FORESTRY_BASKET).addToStorage(ItemID.MAPLE_LOGS, 0),

            // Chop.
            new OnChatMessage("You get (?<logs>some .+).").matcherConsumer(m -> {
                lastLogs = getStorageItemFromName(m.group("logs"));
                storage.add(lastLogs, 1);
                infernalQuantityTracker++;
            }).requiredItem(ItemID.OPEN_LOG_BASKET, ItemID.OPEN_FORESTRY_BASKET),

            new OnItemPickup(storage.getStorableItems()).isByOne().requiredItem(ItemID.OPEN_LOG_BASKET).pickUpToStorage(),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Empty to inventory.
            new OnItemContainerChanged(INVENTORY).onMenuOption("Continue").hasChatMessage("You empty as many logs as you can carry.").emptyStorageToInventory(),

            // Use log on basket.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Empty to bank.
            new OnItemContainerChanged(BANK).emptyStorageToBank().onMenuOption("Empty"),

            // Leprechaun.
            new OnMenuOptionClicked("Continue").consumer(() -> {
                final Optional<Widget> bankWoodcuttingResourcesWidget = TicTac7xChargesImprovedPlugin.getWidget(client, 219, 1, 2);
                if (bankWoodcuttingResourcesWidget.isPresent() && bankWoodcuttingResourcesWidget.get().getText().equals("Only bank woodcutting resources")) {
                    storage.clear();
                }
            }),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),

            // Infernal axe support.
            new OnXpDrop(Skill.FIREMAKING).onMenuOption("Chop down", "Cut").consumer(() -> {
                if (infernalQuantityTracker < 29 && lastLogs.isPresent()) {
                    storage.remove(lastLogs, 1);
                    infernalQuantityTracker--;
                }
            }).requiredItem(ItemID.OPEN_LOG_BASKET, ItemID.OPEN_FORESTRY_BASKET),
        };
    }

}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import static tictac7x.charges.store.HitsplatTarget.SELF;

public class A_CrystalLegs extends ChargedItem {
    public A_CrystalLegs(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.crystal_legs, ItemID.CRYSTAL_LEGS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.CRYSTAL_LEGS),
            new TriggerItem(ItemID.CRYSTAL_LEGS_27701),
            new TriggerItem(ItemID.CRYSTAL_LEGS_27713),
            new TriggerItem(ItemID.CRYSTAL_LEGS_27725),
            new TriggerItem(ItemID.CRYSTAL_LEGS_27737),
            new TriggerItem(ItemID.CRYSTAL_LEGS_27749),
            new TriggerItem(ItemID.CRYSTAL_LEGS_27761),
            new TriggerItem(ItemID.CRYSTAL_LEGS_27773),
            new TriggerItem(ItemID.CRYSTAL_LEGS_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_LEGS_INACTIVE_27703).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_LEGS_INACTIVE_27715).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_LEGS_INACTIVE_27727).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_LEGS_INACTIVE_27739).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_LEGS_INACTIVE_27751).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_LEGS_INACTIVE_27763).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_LEGS_INACTIVE_27775).fixedCharges(0)
        };

        this.triggers = new TriggerBase[]{
            new OnChatMessage("Your crystal legs has (?<charges>.+) charges? remaining").setDynamicallyCharges().onItemClick(),
            new OnHitsplatApplied(SELF).isEquipped().decreaseCharges(1)
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_NecklaceOfPhoenix extends ChargedItem {
    public J_NecklaceOfPhoenix(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.phoenix_necklace, ItemID.PHOENIX_NECKLACE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.PHOENIX_NECKLACE).fixedCharges(1).needsToBeEquipped(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class W_BowOfFaerdhinen extends ChargedItem {
    public W_BowOfFaerdhinen(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.bow_of_faerdhinen, ItemID.BOW_OF_FAERDHINEN, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.BOW_OF_FAERDHINEN_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemID.BOW_OF_FAERDHINEN),
            new TriggerItem(ItemID.BOW_OF_FAERDHINEN_27187),
            new TriggerItem(ItemID.BOW_OF_FAERDHINEN_C).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemID.BOW_OF_FAERDHINEN_C_25869).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemID.BOW_OF_FAERDHINEN_C_25884).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemID.BOW_OF_FAERDHINEN_C_25886).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemID.BOW_OF_FAERDHINEN_C_25888).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemID.BOW_OF_FAERDHINEN_C_25890).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemID.BOW_OF_FAERDHINEN_C_25892).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemID.BOW_OF_FAERDHINEN_C_25894).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemID.BOW_OF_FAERDHINEN_C_25896).fixedCharges(Charges.UNLIMITED),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your bow of Faerdhinen has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Attack.
            new OnGraphicChanged(1888).isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;

public class C_Coffin extends ChargedItemWithStorage {
    public C_Coffin(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.coffin, ItemID.GOLD_COFFIN, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.storage = storage.storableItems(
            new StorableItem(ItemID.LOAR_REMAINS).checkName("Loar"),
            new StorableItem(ItemID.PHRIN_REMAINS).checkName("Phrin"),
            new StorableItem(ItemID.RIYL_REMAINS).checkName("Riyl"),
            new StorableItem(ItemID.ASYN_REMAINS).checkName("Asyn"),
            new StorableItem(ItemID.FIYR_REMAINS).checkName("Fiyr"),
            new StorableItem(ItemID.URIUM_REMAINS).checkName("Urium")
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.BROKEN_COFFIN).fixedCharges(0),
            new TriggerItem(ItemID.BRONZE_COFFIN).maxCharges(3),
            new TriggerItem(ItemID.OPEN_BRONZE_COFFIN).maxCharges(3),
            new TriggerItem(ItemID.STEEL_COFFIN).maxCharges(8),
            new TriggerItem(ItemID.OPEN_STEEL_COFFIN).maxCharges(8),
            new TriggerItem(ItemID.BLACK_COFFIN).maxCharges(14),
            new TriggerItem(ItemID.OPEN_BLACK_COFFIN).maxCharges(14),
            new TriggerItem(ItemID.SILVER_COFFIN).maxCharges(20),
            new TriggerItem(ItemID.OPEN_SILVER_COFFIN).maxCharges(20),
            new TriggerItem(ItemID.GOLD_COFFIN).maxCharges(28),
            new TriggerItem(ItemID.OPEN_GOLD_COFFIN).maxCharges(28),
        };

        this.triggers = new TriggerBase[] {
            // Add remains to coffin.
            new OnChatMessage("You put the (?<remains>.+) remains into your open coffin.").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("remains")), 1);
            }),

            // Check.
            new OnChatMessage("Loar (?<loar>.+) / Phrin (?<phrin>.+) / Riyl (?<riyl>.+) / Asyn (?<asyn>.+) / Fiyr (?<fiyr>.+) / Urium (?<urium>.+)").matcherConsumer(m -> {
                storage.clear();
                storage.put(ItemID.LOAR_REMAINS, Integer.parseInt(m.group("loar")));
                storage.put(ItemID.PHRIN_REMAINS, Integer.parseInt(m.group("phrin")));
                storage.put(ItemID.RIYL_REMAINS, Integer.parseInt(m.group("riyl")));
                storage.put(ItemID.ASYN_REMAINS, Integer.parseInt(m.group("asyn")));
                storage.put(ItemID.FIYR_REMAINS, Integer.parseInt(m.group("fiyr")));
                storage.put(ItemID.URIUM_REMAINS, Integer.parseInt(m.group("urium")));
            }),

            // Try to empty already empty.
            new OnChatMessage("Your coffin is empty.").onItemClick().emptyStorage(),

            // Fill from inventory.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class U_CrystalSaw extends ChargedItem {
    public U_CrystalSaw(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.crystal_saw, ItemID.CRYSTAL_SAW, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.CRYSTAL_SAW),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your saw has (?<charges>.+) charges? left.").setDynamicallyCharges(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStatus;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_BoneCrusher extends ChargedItemWithStatus {
    public U_BoneCrusher(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.bonecrusher, ItemID.BONECRUSHER, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.BONECRUSHER),
            new TriggerItem(ItemID.BONECRUSHER_NECKLACE)
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("The bonecrusher( necklace)? has no charges.").setFixedCharges(0),
            new OnChatMessage("The bonecrusher( necklace)? has one charge.").setFixedCharges(1),
            new OnChatMessage("(The|Your) bonecrusher( necklace)? has (?<charges>.+) charges?( left)?. It is active").setDynamicallyCharges().activate(),
            new OnChatMessage("(The|Your) bonecrusher( necklace)? has (?<charges>.+) charges?( left)?. It has been deactivated").setDynamicallyCharges().deactivate(),
            new OnChatMessage("(The|Your) bonecrusher( necklace)? has (?<charges>.+) charges?( left)?.").setDynamicallyCharges(),
            // Uncharge.
            new OnChatMessage("You remove all the charges from the bonecrusher( necklace)?.").setFixedCharges(0),
            // Ran out.
            new OnChatMessage("Your bonecrusher( necklace)? has run out of charges.").notification().setFixedCharges(0),
            // Activate.
            new OnChatMessage("The bonecrusher( necklace)? has been deactivated").deactivate(),
            // Deactivate.
            new OnChatMessage("The bonecrusher( necklace)? is active").activate(),
            // Automatic bury.
            new OnXpDrop(Skill.PRAYER).isActivated().decreaseCharges(1),
            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_SanguinestiStaff extends ChargedItem {
    public W_SanguinestiStaff(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.sanguinesti_staff, ItemID.SANGUINESTI_STAFF, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.SANGUINESTI_STAFF),
            new TriggerItem(ItemID.SANGUINESTI_STAFF_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemID.HOLY_SANGUINESTI_STAFF),
            new TriggerItem(ItemID.HOLY_SANGUINESTI_STAFF_UNCHARGED).fixedCharges(0),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your (Holy s|S)anguinesti staff has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Charge partially full.
            new OnChatMessage("You apply an additional .+ charges? to your Sanguinesti staff. It now has (?<charges>.+) charges? in total.").setDynamicallyCharges(),

            // Charge empty.
            new OnChatMessage("You apply (?<charges>.+) charges to your Sanguinesti staff.").setDynamicallyCharges()
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

import java.util.Optional;

public class J_RingOfEndurance extends ChargedItem {
    public J_RingOfEndurance(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_endurance, ItemID.RING_OF_ENDURANCE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.RING_OF_ENDURANCE),
            new TriggerItem(ItemID.RING_OF_ENDURANCE_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemID.RING_OF_ENDURANCE_UNCHARGED_24844).fixedCharges(0),
        };

        this.triggers = new TriggerBase[] {
            // Charge.
            new OnChatMessage("You load your Ring of endurance with (?<charges>.+) stamina doses?.").increaseDynamically(),

            // Check.
            new OnChatMessage("Your Ring of endurance is charged with (?<charges>.+) stamina doses?.").setDynamicallyCharges(),

            // Use charge.
            new OnChatMessage("Your Ring of endurance doubles the duration of your stamina potion's effect.").decreaseCharges(1),

            // Uncharge.
            new OnMenuOptionClicked("Yes").runConsumerOnNextGameTick(() -> {
                final Optional<Widget> unchargeWidget = TicTac7xChargesImprovedPlugin.getWidget(client, 584, 0, 2);
                if (unchargeWidget.isPresent() && unchargeWidget.get().getText().equals("Are you sure you want to uncharge your Ring of endurance?")) {
                    setCharges(0);
                }
            }),
        };
    }
}
package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStatus;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.HitsplatTarget;
import tictac7x.charges.store.Store;

public class J_RingOfSuffering extends ChargedItemWithStatus {
    public J_RingOfSuffering(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_suffering, ItemID.RING_OF_SUFFERING, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.RING_OF_SUFFERING).fixedCharges(0),
            new TriggerItem(ItemID.RING_OF_SUFFERING_I).fixedCharges(0),
            new TriggerItem(ItemID.RING_OF_SUFFERING_I_25246).fixedCharges(0),
            new TriggerItem(ItemID.RING_OF_SUFFERING_I_26761).fixedCharges(0),
            new TriggerItem(ItemID.RING_OF_SUFFERING_R),
            new TriggerItem(ItemID.RING_OF_SUFFERING_RI),
            new TriggerItem(ItemID.RING_OF_SUFFERING_RI_25248),
            new TriggerItem(ItemID.RING_OF_SUFFERING_RI_26762),
        };

        this.triggers = new TriggerBase[]{
            // Check
            new OnChatMessage("Your ring currently has (?<charges>.+) recoil charges? remaining. The recoil effect is currently enabled.").setDynamicallyCharges().onItemClick().activate(),
            new OnChatMessage("Your ring currently has (?<charges>.+) recoil charges? remaining. The recoil effect is currently disabled.").setDynamicallyCharges().onItemClick().deactivate(),

            // Charge
            new OnChatMessage("You load your ring with .+ rings? of recoil. It now has (?<charges>.+) recoil charges.").setDynamicallyCharges(),

            // Get hit.
            new OnHitsplatApplied(HitsplatTarget.SELF).moreThanZeroDamage().isEquipped().isActivated().decreaseCharges(1),

            // Disable.
            new OnChatMessage("You disable the recoil effect of your ring.").deactivate(),

            // Enable.
            new OnChatMessage("You enable the recoil effect of your ring.").activate(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnAnimationChanged;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.ItemWithQuantity;
import tictac7x.charges.store.Store;

public class U_QuetzalWhistle extends ChargedItem {
    public U_QuetzalWhistle(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.quetzal_whistle, ItemID.BASIC_QUETZAL_WHISTLE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.BASIC_QUETZAL_WHISTLE).maxCharges(5),
            new TriggerItem(ItemID.ENHANCED_QUETZAL_WHISTLE).maxCharges(20),
            new TriggerItem(ItemID.PERFECTED_QUETZAL_WHISTLE).maxCharges(50),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your quetzal whistle has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Teleport.
            new OnAnimationChanged(10944).decreaseCharges(1),

            // Teleport menu entry.
            new OnMenuEntryAdded("Signal").replaceOption("Teleport"),

            // Craft basic quetzal whistle.
            new OnChatMessage("You craft yourself a basic quetzal whistle.").setFixedCharges(0),

            // Fully charged.
            new OnChatMessage("Looks like the birds are all full for now. Make them work a bit before feeding them again!").requiredItem(ItemID.BASIC_QUETZAL_WHISTLE).setFixedCharges(5),
            new OnChatMessage("Looks like the birds are all full for now. Make them work a bit before feeding them again!").requiredItem(ItemID.ENHANCED_QUETZAL_WHISTLE).setFixedCharges(20),
            new OnChatMessage("Looks like the birds are all full for now. Make them work a bit before feeding them again!").requiredItem(ItemID.PERFECTED_QUETZAL_WHISTLE).setFixedCharges(50),

            // Partially charged.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).hasChatMessage("Soar Leader Pitri|There you go. Some whistle charges for you!").onItemContainerDifference(itemsDifference -> {
                for (final ItemWithQuantity item : itemsDifference.items) {
                    switch (item.itemId) {
                        case ItemID.QUETZAL_FEED:
                        case ItemID.RAW_WILD_KEBBIT:
                        case ItemID.RAW_BARBTAILED_KEBBIT:
                        case ItemID.RAW_LARUPIA:
                            increaseCharges(Math.abs(item.quantity));
                            break;
                        case ItemID.RAW_GRAAHK:
                        case ItemID.RAW_KYATT:
                        case ItemID.RAW_PYRE_FOX:
                            increaseCharges(Math.abs(item.quantity) * 2);
                            break;
                        case ItemID.RAW_DASHING_KEBBIT:
                        case ItemID.RAW_SUNLIGHT_ANTELOPE:
                        case ItemID.RAW_MOONLIGHT_ANTELOPE:
                            increaseCharges(Math.abs(item.quantity) * 3);
                            break;
                    }
                }
            })
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class U_CoalBag extends ChargedItemWithStorage {
    public U_CoalBag(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.coal_bag, ItemID.COAL_BAG_12019, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.storage = storage
            .storableItems(new StorableItem(ItemID.COAL).checkName("Coal"))
            .setMaximumTotalQuantity(27)
            .setMaximumTotalQuantityWithEquippedItem(36, ItemID.SMITHING_CAPE, ItemID.HITPOINTS_CAPET);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.COAL_BAG_12019),
            new TriggerItem(ItemID.OPEN_COAL_BAG),
        };
        this.triggers = new TriggerBase[] {
            // Check or empty.
            new OnChatMessage("The coal bag is( now)? empty.").emptyStorage(),

            // Fill or check with 1 coal.
            new OnChatMessage("The coal bag( still)? contains one piece of coal.").consumer(() -> {
                storage.put(ItemID.COAL, 1);
            }),

            // Check or empty with not enough inventory space.
            new OnChatMessage("The coal bag( still)? contains (?<charges>.+) pieces of coal.").matcherConsumer((m) -> {
                storage.put(ItemID.COAL, Integer.parseInt(m.group("charges")));
            }),

            // Mine coal with open bag.
            // Extra coal mined by celestial ring.
            // Extra coal mined by varrock platebody.
            new OnChatMessage(
                "(You manage to mine some coal.|Your Celestial ring allows you to mine an additional ore.|The Varrock platebody enabled you to mine an additional ore.)"
            ).onMenuOption("Mine").onMenuTarget("Coal rocks").requiredItem(ItemID.OPEN_COAL_BAG).consumer(() -> {
                storage.add(ItemID.COAL, 1);
            }),

            // Superheat spells.
            new OnXpDrop(Skill.SMITHING).onMenuOption("Cast").onMenuTarget(
                "Superheat Item -> Lovakite ore",
                "Superheat Item -> Iron ore"
            ).consumer(() -> {
                storage.removeAndPrioritizeInventory(ItemID.COAL, 2);
            }),
            new OnXpDrop(Skill.SMITHING).onMenuOption("Cast").onMenuTarget(
                "Superheat Item -> Mithril ore"
            ).consumer(() -> {
                storage.removeAndPrioritizeInventory(ItemID.COAL, 4);
            }),
            new OnXpDrop(Skill.SMITHING).onMenuOption("Cast").onMenuTarget(
                "Superheat Item -> Adamantite ore"
            ).consumer(() -> {
                storage.removeAndPrioritizeInventory(ItemID.COAL, 6);
            }),
            new OnXpDrop(Skill.SMITHING).onMenuOption("Cast").onMenuTarget(
                "Superheat Item -> Runite ore"
            ).consumer(() -> {
                storage.removeAndPrioritizeInventory(ItemID.COAL, 8);
            }),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;

public class U_HuntsmansKit extends ChargedItemWithStorage {
    public U_HuntsmansKit(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.huntsmans_kit, ItemID.HUNTSMANS_KIT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.storage = storage.storableItems(
            new StorableItem(ItemID.BIRD_SNARE),
            new StorableItem(ItemID.BUTTERFLY_NET),
            new StorableItem(ItemID.BUTTERFLY_JAR),
            new StorableItem(ItemID.RABBIT_SNARE),
            new StorableItem(ItemID.SMALL_FISHING_NET),
            new StorableItem(ItemID.MAGIC_BOX),
            new StorableItem(ItemID.TEASING_STICK),
            new StorableItem(ItemID.WOOD_CAMO_TOP),
            new StorableItem(ItemID.WOOD_CAMO_LEGS),
            new StorableItem(ItemID.JUNGLE_CAMO_TOP),
            new StorableItem(ItemID.JUNGLE_CAMO_LEGS),
            new StorableItem(ItemID.LARUPIA_HAT),
            new StorableItem(ItemID.LARUPIA_TOP),
            new StorableItem(ItemID.LARUPIA_LEGS),
            new StorableItem(ItemID.KYATT_HAT),
            new StorableItem(ItemID.KYATT_TOP),
            new StorableItem(ItemID.KYATT_LEGS),
            new StorableItem(ItemID.GUILD_HUNTER_HEADWEAR),
            new StorableItem(ItemID.GUILD_HUNTER_TOP),
            new StorableItem(ItemID.GUILD_HUNTER_LEGS),
            new StorableItem(ItemID.GUILD_HUNTER_BOOTS),
            new StorableItem(ItemID.RING_OF_PURSUIT),
            new StorableItem(ItemID.NOOSE_WAND),
            new StorableItem(ItemID.MAGIC_BUTTERFLY_NET),
            new StorableItem(ItemID.BOX_TRAP),
            new StorableItem(ItemID.UNLIT_TORCH),
            new StorableItem(ItemID.ROPE),
            new StorableItem(ItemID.HUNTERS_SPEAR),
            new StorableItem(ItemID.POLAR_CAMO_TOP),
            new StorableItem(ItemID.POLAR_CAMO_LEGS),
            new StorableItem(ItemID.DESERT_CAMO_TOP),
            new StorableItem(ItemID.DESERT_CAMO_LEGS),
            new StorableItem(ItemID.GRAAHK_HEADDRESS),
            new StorableItem(ItemID.GRAAHK_TOP),
            new StorableItem(ItemID.GRAAHK_LEGS),
            new StorableItem(ItemID.HUNTER_HOOD),
            new StorableItem(ItemID.HUNTER_CAPE),
            new StorableItem(ItemID.HUNTER_CAPET),
            new StorableItem(ItemID.IMPLING_JAR)
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.HUNTSMANS_KIT)
        };

        this.triggers = new TriggerBase[]{
            // Fill from inventory.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Empty to inventory.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).emptyStorageToInventory().onMenuOption("Empty"),

            // Hide destroy option.
            new OnMenuEntryAdded("Destroy").hide(),

            // Update from item container when viewing huntsmans kit contents.
            new OnItemContainerChanged(ItemContainerId.HUNTSMANS_KIT).updateStorage(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_NecklaceOfPassage extends ChargedItem {
    public J_NecklaceOfPassage(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.necklace_of_passage, ItemID.NECKLACE_OF_PASSAGE1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.NECKLACE_OF_PASSAGE1).fixedCharges(1),
            new TriggerItem(ItemID.NECKLACE_OF_PASSAGE2).fixedCharges(2),
            new TriggerItem(ItemID.NECKLACE_OF_PASSAGE3).fixedCharges(3),
            new TriggerItem(ItemID.NECKLACE_OF_PASSAGE4).fixedCharges(4),
            new TriggerItem(ItemID.NECKLACE_OF_PASSAGE5).fixedCharges(5),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import static tictac7x.charges.store.HitsplatTarget.SELF;

public class A_CrystalHelm extends ChargedItem {
    public A_CrystalHelm(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.crystal_helm, ItemID.CRYSTAL_HELM, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.CRYSTAL_HELM),
            new TriggerItem(ItemID.CRYSTAL_HELM_27705),
            new TriggerItem(ItemID.CRYSTAL_HELM_27717),
            new TriggerItem(ItemID.CRYSTAL_HELM_27729),
            new TriggerItem(ItemID.CRYSTAL_HELM_27741),
            new TriggerItem(ItemID.CRYSTAL_HELM_27753),
            new TriggerItem(ItemID.CRYSTAL_HELM_27765),
            new TriggerItem(ItemID.CRYSTAL_HELM_27777),
            new TriggerItem(ItemID.CRYSTAL_HELM_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_HELM_INACTIVE_27707).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_HELM_INACTIVE_27719).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_HELM_INACTIVE_27731).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_HELM_INACTIVE_27743).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_HELM_INACTIVE_27755).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_HELM_INACTIVE_27767).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_HELM_INACTIVE_27779).fixedCharges(0)
        };

        this.triggers = new TriggerBase[]{
            new OnChatMessage("Your crystal helm has (?<charges>.+) charges? remaining").setDynamicallyCharges().onItemClick(),
            new OnHitsplatApplied(SELF).isEquipped().decreaseCharges(1)
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class J_RingOfElements extends ChargedItem {
    public J_RingOfElements(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_the_elements, ItemID.RING_OF_THE_ELEMENTS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.RING_OF_THE_ELEMENTS),
            new TriggerItem(ItemID.RING_OF_THE_ELEMENTS_26818),
        };

        this.triggers = new TriggerBase[] {
            // Teleport.
            new OnVarbitChanged(13707).setDynamically(),

            // Menu entry.
            new OnMenuEntryAdded("Rub").replaceOption("Teleport"),
        };
    }
}
package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.OnWidgetLoaded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_XericsTalisman extends ChargedItem {
    public J_XericsTalisman(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.xerics_talisman, ItemID.XERICS_TALISMAN, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.XERICS_TALISMAN_INERT).fixedCharges(0),
            new TriggerItem(ItemID.XERICS_TALISMAN),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("(The|Your) talisman( now)? has one charge.").onItemClick().setFixedCharges(1),
            new OnChatMessage("(The|Your) talisman( now)? has (?<charges>.+) charges.").setDynamicallyCharges().onItemClick(),

            // Teleport.
            new OnGraphicChanged(1612).decreaseCharges(1),

            // Teleport widget.
            new OnWidgetLoaded(187, 0, 1).text("The talisman has (?<charges>.+) charges.").setDynamically(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class U_TeleportCrystal extends ChargedItem {
    public U_TeleportCrystal(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.teleport_crystal, ItemID.TELEPORT_CRYSTAL, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.TELEPORT_CRYSTAL).fixedCharges(0),
            new TriggerItem(ItemID.TELEPORT_CRYSTAL_1).fixedCharges(1),
            new TriggerItem(ItemID.TELEPORT_CRYSTAL_2).fixedCharges(2),
            new TriggerItem(ItemID.TELEPORT_CRYSTAL_3).fixedCharges(3),
            new TriggerItem(ItemID.TELEPORT_CRYSTAL_4).fixedCharges(4),
            new TriggerItem(ItemID.TELEPORT_CRYSTAL_5).fixedCharges(5),
            new TriggerItem(ItemID.ETERNAL_TELEPORT_CRYSTAL).fixedCharges(Charges.UNLIMITED),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_BraceletOfFlamtaer extends ChargedItem {
    public J_BraceletOfFlamtaer(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.bracelet_of_flamtaer, ItemID.FLAMTAER_BRACELET, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.FLAMTAER_BRACELET).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[]{
            new OnChatMessage("Your Flamtaer bracelet helps you build the temple quicker. It has (?<charges>.+) charges? left.").setDynamicallyCharges(),
            new OnChatMessage("Your flamtaer bracelet has (?<charges>.+) charges? left.").setDynamicallyCharges(),
            new OnChatMessage("Your Flamtaer bracelet helps you build the temple quicker. It then crumbles to dust.").setFixedCharges(80).notification("Your flamtaer bracelet crumbles to dust."),
            new OnChatMessage("The bracelet shatters. Your next Flamtaer bracelet will star afresh from 80 charges.").setFixedCharges(80)
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class J_RingOfDueling extends ChargedItem {
    public J_RingOfDueling(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_dueling, ItemID.RING_OF_DUELING1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.RING_OF_DUELING1).fixedCharges(1),
            new TriggerItem(ItemID.RING_OF_DUELING2).fixedCharges(2),
            new TriggerItem(ItemID.RING_OF_DUELING3).fixedCharges(3),
            new TriggerItem(ItemID.RING_OF_DUELING4).fixedCharges(4),
            new TriggerItem(ItemID.RING_OF_DUELING5).fixedCharges(5),
            new TriggerItem(ItemID.RING_OF_DUELING6).fixedCharges(6),
            new TriggerItem(ItemID.RING_OF_DUELING7).fixedCharges(7),
            new TriggerItem(ItemID.RING_OF_DUELING8).fixedCharges(8),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import static tictac7x.charges.store.ItemContainerId.BANK;
import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_MeatPouch extends ChargedItemWithStorage {
    public U_MeatPouch(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.meat_pouch, ItemID.SMALL_MEAT_POUCH, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.storage = storage.storableItems(
            // Tracking.
            new StorableItem(ItemID.RAW_BEAST_MEAT),

            // Deadfall.
            new StorableItem(ItemID.RAW_WILD_KEBBIT),
            new StorableItem(ItemID.RAW_BARBTAILED_KEBBIT),
            new StorableItem(ItemID.RAW_PYRE_FOX),

            // Pitfalls.
            new StorableItem(ItemID.RAW_LARUPIA),
            new StorableItem(ItemID.RAW_GRAAHK),
            new StorableItem(ItemID.RAW_KYATT),
            new StorableItem(ItemID.RAW_SUNLIGHT_ANTELOPE),
            new StorableItem(ItemID.RAW_MOONLIGHT_ANTELOPE),

            // Aerial.
            new StorableItem(ItemID.RAW_DASHING_KEBBIT)
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.SMALL_MEAT_POUCH).maxCharges(14),
            new TriggerItem(ItemID.SMALL_MEAT_POUCH_OPEN).maxCharges(14),
            new TriggerItem(ItemID.LARGE_MEAT_POUCH).maxCharges(28),
            new TriggerItem(ItemID.LARGE_MEAT_POUCH_OPEN).maxCharges(28),
        };

        this.triggers = new TriggerBase[]{
            // Empty.
            new OnChatMessage("Your meat pouch is currently holding 0 meat").emptyStorage(),
            new OnChatMessage("Your meat pouch is empty.").emptyStorage(),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Empty to inventory.
            new OnItemContainerChanged(INVENTORY).emptyStorageToInventory().onMenuOption("Empty"),

            // Empty to bank.
            new OnItemContainerChanged(BANK).emptyStorageToBank().onMenuOption("Empty"),

            // Use meat on pouch.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Hide destroy option.
            new OnMenuEntryAdded("Destroy").hide(),

            // Tracking.
            new OnChatMessage("You manage to noose a polar kebbit that is hiding in the snowdrift.").requiredItem(ItemID.SMALL_MEAT_POUCH_OPEN, ItemID.LARGE_MEAT_POUCH_OPEN).addToStorage(ItemID.RAW_BEAST_MEAT),
            new OnChatMessage("You manage to noose a common kebbit that is hiding in the bush.").requiredItem(ItemID.SMALL_MEAT_POUCH_OPEN, ItemID.LARGE_MEAT_POUCH_OPEN).addToStorage(ItemID.RAW_BEAST_MEAT),
            new OnChatMessage("You manage to noose a Feldip weasel that is hiding in the bush.").requiredItem(ItemID.SMALL_MEAT_POUCH_OPEN, ItemID.LARGE_MEAT_POUCH_OPEN).addToStorage(ItemID.RAW_BEAST_MEAT),
            new OnChatMessage("You manage to noose a desert devil that is hiding in the sand.").requiredItem(ItemID.SMALL_MEAT_POUCH_OPEN, ItemID.LARGE_MEAT_POUCH_OPEN).addToStorage(ItemID.RAW_BEAST_MEAT),
            new OnChatMessage("You manage to noose a razor-backed kebbit that is hiding in the bush.").requiredItem(ItemID.SMALL_MEAT_POUCH_OPEN, ItemID.LARGE_MEAT_POUCH_OPEN).addToStorage(ItemID.RAW_BEAST_MEAT),

            // Deadfall.
            new OnChatMessage("You've caught a wild kebbit.").requiredItem(ItemID.SMALL_MEAT_POUCH_OPEN, ItemID.LARGE_MEAT_POUCH_OPEN).addToStorage(ItemID.RAW_WILD_KEBBIT),
            new OnChatMessage("You've caught a barb-tailed kebbit.").requiredItem(ItemID.SMALL_MEAT_POUCH_OPEN, ItemID.LARGE_MEAT_POUCH_OPEN).addToStorage(ItemID.RAW_BARBTAILED_KEBBIT),
            new OnChatMessage("You've caught a pyre fox.").requiredItem(ItemID.SMALL_MEAT_POUCH_OPEN, ItemID.LARGE_MEAT_POUCH_OPEN).addToStorage(ItemID.RAW_PYRE_FOX),

            // Pitfalls.
            new OnChatMessage("You've caught a spined larupia!").requiredItem(ItemID.SMALL_MEAT_POUCH_OPEN, ItemID.LARGE_MEAT_POUCH_OPEN).addToStorage(ItemID.RAW_LARUPIA),
            new OnChatMessage("You've caught a horned graahk!").requiredItem(ItemID.SMALL_MEAT_POUCH_OPEN, ItemID.LARGE_MEAT_POUCH_OPEN).addToStorage(ItemID.RAW_GRAAHK),
            new OnChatMessage("You've caught a sabre-?toothed kyatt!").requiredItem(ItemID.SMALL_MEAT_POUCH_OPEN, ItemID.LARGE_MEAT_POUCH_OPEN).addToStorage(ItemID.RAW_KYATT),
            new OnChatMessage("You've caught a sunlight antelope!").requiredItem(ItemID.SMALL_MEAT_POUCH_OPEN, ItemID.LARGE_MEAT_POUCH_OPEN).addToStorage(ItemID.RAW_SUNLIGHT_ANTELOPE),
            new OnChatMessage("You've caught a moonlight antelope!").requiredItem(ItemID.SMALL_MEAT_POUCH_OPEN, ItemID.LARGE_MEAT_POUCH_OPEN).addToStorage(ItemID.RAW_MOONLIGHT_ANTELOPE),

            // Aerial.
            new OnXpDrop(Skill.HUNTER, 156).requiredItem(ItemID.SMALL_MEAT_POUCH_OPEN, ItemID.LARGE_MEAT_POUCH_OPEN).hasChatMessage("You retrieve the falcon as well as the fur of the dead kebbit.").consumer(() -> {
                storage.add(ItemID.RAW_DASHING_KEBBIT, 1);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_Waterskin extends ChargedItem {
    public U_Waterskin(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.waterskin, ItemID.WATERSKIN0, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.WATERSKIN0).fixedCharges(0),
            new TriggerItem(ItemID.WATERSKIN1).fixedCharges(1),
            new TriggerItem(ItemID.WATERSKIN2).fixedCharges(2),
            new TriggerItem(ItemID.WATERSKIN3).fixedCharges(3),
            new TriggerItem(ItemID.WATERSKIN4).fixedCharges(4),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnWidgetLoaded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_NecklaceOfDodgy extends ChargedItem {
    public J_NecklaceOfDodgy(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.dodgy_necklace, ItemID.DODGY_NECKLACE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.DODGY_NECKLACE).needsToBeEquipped(),
        };
        
        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your dodgy necklace has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Protects.
            new OnChatMessage("Your dodgy necklace protects you. It has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Breaks.
            new OnChatMessage("Your dodgy necklace protects you. It then crumbles to dust.").setFixedCharges(10).notification("Your dodgy necklace crumbles to dust."),

            // Break.
            new OnChatMessage("The necklace shatters. Your next dodgy necklace will start afresh from (?<charges>.+) charges.").setDynamicallyCharges(),

            new OnWidgetLoaded(219, 1, 0).text("Status: (?<charges>.+) charges? left.").setDynamically(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class F_SapphireGlacialisMix extends ChargedItem {
    public F_SapphireGlacialisMix(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.sapphire_glacialis_mix, ItemID.SAPPHIRE_GLACIALIS_MIX_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.SAPPHIRE_GLACIALIS_MIX_1).fixedCharges(1),
            new TriggerItem(ItemID.SAPPHIRE_GLACIALIS_MIX_2).fixedCharges(2),
        };
    }

    @Override
    public String getTooltip() {
        return "Sapphrie glacialis mix: " + getTotalCharges();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_BraceletOfSlaughter extends ChargedItem {
    public J_BraceletOfSlaughter(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.bracelet_of_slaughter, ItemID.BRACELET_OF_SLAUGHTER, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.BRACELET_OF_SLAUGHTER).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your bracelet of slaughter has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Charge used.
            new OnChatMessage("Your bracelet of slaughter prevents your slayer count from decreasing. It has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Bracelet fully used.
            new OnChatMessage("Your bracelet of slaughter prevents your slayer count from decreasing. It then crumbles to dust.").setFixedCharges(30).notification("Your slaughter bracelet crumbles to dust."),

            // Break.
            new OnChatMessage("The bracelet shatters. Your next bracelet of slaughter will start afresh from (?<charges>.+) charges.").setDynamicallyCharges(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

import java.util.Optional;

public class J_BindingNecklace extends ChargedItem {
    public J_BindingNecklace(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.binding_necklace, ItemID.BINDING_NECKLACE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.BINDING_NECKLACE).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Check, one left.
            new OnChatMessage("You have one charge left before your Binding necklace disintegrates.").setFixedCharges(1),

            // Check.
            new OnChatMessage("You have (?<charges>.+) charges left before your Binding necklace disintegrates.").setDynamicallyCharges(),

            // Charge used.
            new OnChatMessage("You (partially succeed to )?bind the temple's power into (mud|lava|steam|dust|smoke|mist) runes\\.").decreaseCharges(1),

            // Fully used.
            new OnChatMessage("Your Binding necklace has disintegrated.").runConsumerOnNextGameTick(() -> setCharges(16)),

            // Destroy.
            new OnScriptPreFired(1651).scriptConsumer((script) -> {
                final Optional<Widget> destroyWidget = TicTac7xChargesImprovedPlugin.getWidget(client, 584, 0, 2);
                if (
                    destroyWidget.isPresent() && destroyWidget.get().getText().equals("Destroy necklace of binding?") &&
                    script.getScriptEvent().getArguments().length >= 5 &&
                    script.getScriptEvent().getArguments()[4].toString().equals("Yes")
                ) {
                    store.addConsumerToNextTickQueue(() -> setCharges(16));
                }
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import java.util.Optional;

import static tictac7x.charges.TicTac7xChargesImprovedPlugin.getNumberFromCommaString;

public class U_BottomlessCompostBucket extends ChargedItemWithStorage {
    public U_BottomlessCompostBucket(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.bottomless_compost_bucket, ItemID.BOTTOMLESS_COMPOST_BUCKET_22997, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage = storage.setMaximumTotalQuantity(10_000).storableItems(
            new StorableItem(ItemID.ULTRACOMPOST).checkName("ultra"),
            new StorableItem(ItemID.SUPERCOMPOST).checkName("super"),
            new StorableItem(ItemID.COMPOST).checkName("regular").displayName("Regular compost")
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.BOTTOMLESS_COMPOST_BUCKET).fixedCharges(0),
            new TriggerItem(ItemID.BOTTOMLESS_COMPOST_BUCKET_22997),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your bottomless compost bucket is currently holding one use of (?<type>.+) ?compost.").matcherConsumer(m -> {
                storage.clearAndPut(getStorageItemFromName(m.group("type")), 1);
            }),
            new OnChatMessage("Your bottomless compost bucket is currently holding (?<quantity>.+) uses of (?<type>.+) ?compost.").matcherConsumer(m -> {
                final int quantity = getNumberFromCommaString(m.group("quantity"));
                storage.clearAndPut(getStorageItemFromName(m.group("type")), quantity);
            }),

            // Use compost on a patch, run on next gametick, because the "You treat" message appears on same tick after this one.
            new OnChatMessage("Your bottomless compost bucket has a single use of (?<type>.+) ?compost remaining.").matcherConsumer(m -> {
                store.addConsumerToNextTickQueue(() -> {
                    storage.clearAndPut(getStorageItemFromName(m.group("type")), 1);
                });
            }),
            new OnChatMessage("Your bottomless compost bucket has (?<quantity>.+) uses of (?<type>.+) ?compost remaining.").matcherConsumer(m -> {
                store.addConsumerToNextTickQueue(() -> {
                    final int quantity = getNumberFromCommaString(m.group("quantity"));
                    storage.clearAndPut(getStorageItemFromName(m.group("type")), quantity);
                });
            }),
            new OnChatMessage("You treat the .* with (?<type>.*) ?compost.").matcherConsumer(m -> {
                final String type = m.group("type");
                storage.remove(getStorageItemFromName(type.isEmpty() ? "regular" : type), 1);
            }).onItemClick(),

            // Discard.
            new OnChatMessage("You discard the contents of your bottomless compost bucket.").emptyStorage(),

            // Empty.
            new OnChatMessage("Your bottomless compost bucket has run out of compost!").emptyStorage(),

            // Fill.
            new OnChatMessage("You fill your bottomless compost bucket with a single bucket of (?<type>.+) ?compost. Your bottomless compost bucket now contains a total of (?<quantity>.+) uses.").matcherConsumer(m -> {
                final int quantity = getNumberFromCommaString(m.group("quantity"));
                storage.clearAndPut(getStorageItemFromName(m.group("type")), quantity);
            }),
            new OnChatMessage("You fill your bottomless compost bucket with .* buckets of (?<type>.+) ?compost. Your bottomless compost bucket now contains a total of (?<quantity>.+) uses.").matcherConsumer(m -> {
                final int quantity = getNumberFromCommaString(m.group("quantity"));
                storage.clearAndPut(getStorageItemFromName(m.group("type")), quantity);
            }),

            // Almost full.
            new OnChatMessage("Your bottomless compost bucket is just about full. You won't be able to squeeze any more compost in there.").consumer(() -> {
                storage.clearAndPut(getCompostType(), 9999);
            }),

            // Full.
            new OnChatMessage("Your bottomless compost bucket is now full!").consumer(() -> {
                storage.clearAndPut(getCompostType(), 10_000);
            }),

            // Fill compost from bin.
            new OnXpDrop(Skill.FARMING).unallowedItem(ItemID.BUCKET).onMenuOption("Take").onMenuTarget("Compost Bin", "Big Compost Bin").consumer(() -> {
                storage.add(getCompostType(), 2);
            }),

            // Use on compost bin.
            new OnXpDrop(Skill.FARMING).onMenuOption("Use").onMenuTarget("Bottomless compost bucket -> Compost Bin", "Bottomless compost bucket -> Big Compost Bin").consumer(() -> {
                storage.add(getCompostType(), 2);
            }),
        };
    }

    private Optional<StorageItem> getCompostType() {
        for (final StorageItem storageItem : getStorage().values()) {
            if (storageItem.quantity > 0) {
                return Optional.of(storageItem);
            }
        }

        return Optional.empty();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class F_RubyHarvestMix extends ChargedItem {
    public F_RubyHarvestMix(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ruby_harvest_mix, ItemID.RUBY_HARVEST_MIX_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.RUBY_HARVEST_MIX_1).fixedCharges(1),
            new TriggerItem(ItemID.RUBY_HARVEST_MIX_2).fixedCharges(2),
        };
    }

    @Override
    public String getTooltip() {
        return "Ruby harvest mix: " + getTotalCharges();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class S_TomeOfFire extends ChargedItem {
    public S_TomeOfFire(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.tome_of_fire, ItemID.TOME_OF_FIRE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.TOME_OF_FIRE_EMPTY).fixedCharges(0),
            new TriggerItem(ItemID.TOME_OF_FIRE).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your tome has been charged with (Burnt|Searing) Pages. It currently holds (?<charges>.+) charges?.").setDynamicallyCharges().onItemClick(),

            // Attack with regular spellbook fire spells.
            new OnGraphicChanged(99, 126, 129, 155, 1464).isEquipped().decreaseCharges(1)
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.HitsplatTarget;
import tictac7x.charges.store.Store;

public class J_RingOfRecoil extends ChargedItem {
    public J_RingOfRecoil(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_recoil, ItemID.RING_OF_RECOIL, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.RING_OF_RECOIL).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("You can inflict one more point of damage before a ring will shatter.").setFixedCharges(1),

            // Check.
            new OnChatMessage("You can inflict (?<charges>.+) more points of damage before a ring will shatter.").setDynamicallyCharges(),

            // Trying to break when full.
            new OnChatMessage("The ring is fully charged. There would be no point in breaking it.").onItemClick().setFixedCharges(40),

            // Shattered.
            new OnChatMessage("Your Ring of Recoil has shattered.").notification().setFixedCharges(40),

            // Take damage.
            new OnHitsplatApplied(HitsplatTarget.SELF).moreThanZeroDamage().isEquipped().decreaseCharges(1),

            // Check from break dialog.
            new OnWidgetLoaded(219, 1, 0).text("Status: (?<charges>.+) damage points? left.").setDynamically(),

            // Break.
            new OnChatMessage("The ring shatters. Your next ring of recoil will start afresh from (?<charges>.+) damage points?.").setDynamicallyCharges(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import static tictac7x.charges.store.HitsplatTarget.SELF;

public class A_CrystalBody extends ChargedItem {
    public A_CrystalBody(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.crystal_body, ItemID.CRYSTAL_BODY, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.CRYSTAL_BODY),
            new TriggerItem(ItemID.CRYSTAL_BODY_27697),
            new TriggerItem(ItemID.CRYSTAL_BODY_27709),
            new TriggerItem(ItemID.CRYSTAL_BODY_27721),
            new TriggerItem(ItemID.CRYSTAL_BODY_27733),
            new TriggerItem(ItemID.CRYSTAL_BODY_27745),
            new TriggerItem(ItemID.CRYSTAL_BODY_27757),
            new TriggerItem(ItemID.CRYSTAL_BODY_27769),
            new TriggerItem(ItemID.CRYSTAL_BODY_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_BODY_INACTIVE_27699).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_BODY_INACTIVE_27711).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_BODY_INACTIVE_27723).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_BODY_INACTIVE_27735).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_BODY_INACTIVE_27747).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_BODY_INACTIVE_27759).fixedCharges(0),
            new TriggerItem(ItemID.CRYSTAL_BODY_INACTIVE_27771).fixedCharges(0)
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("Your crystal body has (?<charges>.+) charges? remaining").setDynamicallyCharges().onItemClick(),
            new OnHitsplatApplied(SELF).isEquipped().decreaseCharges(1)
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class J_Camulet extends ChargedItem {
    public J_Camulet(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.camulet, ItemID.CAMULET, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.CAMULET),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your Camulet has one charge left.").setFixedCharges(1),
            new OnChatMessage("Your Camulet has (?<charges>.+) charges left.").setDynamicallyCharges(),

            // Recharge.
            new OnChatMessage("You recharge the Camulet using camel dung. Yuck!").setFixedCharges(4),

            // Trying to charge fully charged.
            new OnChatMessage("The Camulet is already fully charged.").setFixedCharges(4),

            // Unlimited charges.
            new OnChatMessage("The Camulet has unlimited charges.").setFixedCharges(Charges.UNLIMITED),

            // Replace check.
            new OnMenuEntryAdded("Check-charge").replaceOption("Check"),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class U_TackleBox extends ChargedItem {
    public U_TackleBox(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.tackle_box, ItemID.TACKLE_BOX, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemID.TACKLE_BOX).fixedCharges(Charges.UNLIMITED),
        };

        this.triggers = new TriggerBase[]{
            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }
}

package tictac7x.charges;

import com.google.common.collect.ImmutableMap;
import com.google.gson.Gson;
import com.google.inject.Provides;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.*;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.overlays.ChargedItemInfobox;
import tictac7x.charges.item.overlays.ChargedItemOverlay;
import tictac7x.charges.items.*;
import tictac7x.charges.items.barrows.*;
import tictac7x.charges.store.AdvancedMenuEntry;
import tictac7x.charges.store.Store;

import javax.annotation.Nullable;
import javax.inject.Inject;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;

@PluginDescriptor(
	name = "Item Charges Improved",
	description = "Show charges of various items",
	tags = {
		"charges",
		"barrows",
		"crystal",
		"ardougne",
		"coffing",
		"magic",
		"cape",
		"circlet",
		"bracelet",
		"clay",
		"expeditious",
		"flamtaer",
		"slaughter",
		"camulet",
		"celestial",
		"ring",
		"escape",
		"recoil",
		"shadow",
		"suffering",
		"slayer",
		"xeric",
		"talisman",
		"chronicle",
		"dragonfire",
		"falador",
		"kharedst",
		"memoirs",
		"ash",
		"sanctifier",
		"bone",
		"crusher",
		"bottomless",
		"compost",
		"bucket",
		"coal",
		"bag",
		"fish",
		"barrel",
		"fungicide",
		"spray",
		"gem",
		"gricoller",
		"can",
		"herb",
		"sack",
		"log",
		"basket",
		"ogre",
		"bellows",
		"seed",
		"box",
		"soul",
		"bearer",
		"teleport",
		"waterskin",
		"arclight",
		"bryophyta",
		"staff",
		"bow",
		"halberd",
		"iban",
		"pharaoh",
		"sceptre",
		"sanguinesti",
		"skull",
		"trident",
		"sea",
		"toxic",
		"jar",
		"tome",
		"fur",
		"meat",
		"pouch",
		"pursuit",
		"book",
		"scroll"
	}
)

public class TicTac7xChargesImprovedPlugin extends Plugin implements KeyListener, MouseListener, MouseWheelListener {
	private final String pluginVersion = "v0.5.14";
	private final String pluginMessage = "" +
		"<colHIGHLIGHT>Item Charges Improved " + pluginVersion + ":<br>" +
		"<colHIGHLIGHT>* Option to choose item overlay location.<br>" +
		"<colHIGHLIGHT>* Alchemist's amulet added.<br>" +
		"<colHIGHLIGHT>* Log basket fixes.<br>" +
		"<colHIGHLIGHT>* Daily reset items fixes."
	;

	private final int VARBIT_MINUTES = 8354;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private TicTac7xChargesImprovedConfig config;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private TooltipManager tooltipManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private Notifier notifier;
	
	@Inject
	private Gson gson;

	@Provides
	TicTac7xChargesImprovedConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(TicTac7xChargesImprovedConfig.class);
	}

	private Store store;

	private ChargedItemOverlay overlayChargedItems;

	private ChargedItemBase[] chargedItems;
	private List<InfoBox> chargedItemsInfoboxes = new ArrayList<>();

	private final ZoneId timezone = ZoneId.of("Europe/London");

	@Override
	protected void startUp() {
		keyManager.registerKeyListener(this);
		mouseManager.registerMouseListener(this);
		mouseManager.registerMouseWheelListener(this);
		configMigration();

		store = new Store(client, itemManager, configManager);

		chargedItems = new ChargedItemBase[]{
			// Weapons
			new W_Arclight(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_BowOfFaerdhinen(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_BryophytasStaff(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_CrystalBow(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_CrystalHalberd(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_EnchantedLyre(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_IbansStaff(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_PharaohsSceptre(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_SanguinestiStaff(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_SkullSceptre(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_SlayerStaffE(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_TridentOfTheSeas(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_TumekensShadow(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_VenatorBow(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_WarpedSceptre(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_WesternBanner(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Shields
			new S_Chronicle(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new S_CrystalShield(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new S_DragonfireShield(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new S_FaladorShield(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new S_KharedstMemoirs(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new S_TomeOfFire(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new S_TomeOfWater(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Boots
			new B_FremennikSeaBoots(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Helms
			new H_CircletOfWater(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new H_KandarinHeadgear(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Capes
			new C_ArdougneCloak(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new C_Coffin(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new C_ForestryKit(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new C_MagicCape(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Jewellery
			new J_AlchemistsAmulet(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_BindingNecklace(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_BraceletOfClay(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_BraceletOfExpeditious(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_BraceletOfFlamtaer(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_BraceletOfSlaughter(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_Camulet(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_DesertAmulet(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_DigsitePendant(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_EscapeCrystal(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_NecklaceOfPassage(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_NecklaceOfPhoenix(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_NecklaceOfDodgy(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_PendantOfAtes(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfCelestial(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfDueling(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfElements(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfEndurance(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfExplorer(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfPursuit(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfRecoil(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfShadows(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfSlayer(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfSuffering(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_XericsTalisman(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Utilities
			new U_AshSanctifier(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_BoneCrusher(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_BottomlessCompostBucket(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_CoalBag(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_CrystalSaw(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_ColossalPouch(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_FishBarrel(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_FungicideSpray(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_FurPouch(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_GemBag(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_GricollersCan(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_HerbSack(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_HuntsmansKit(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_JarGenerator(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_LogBasket(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_MasterScrollBook(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_MeatPouch(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_OgreBellows(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_QuetzalWhistle(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_PlankSack(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_SeedBox(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_SoulBearer(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_StrangeOldLockpick(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_TackleBox(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_TeleportCrystal(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_EternalTeleportCrystal(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_Waterskin(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Foods
			new F_BlackWarlockMix(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new F_MoonlightMothMix(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new F_RubyHarvestMix(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new F_SapphireGlacialisMix(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new F_SnowyKnightMix(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new F_SunlightMothMix(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),


			// Crystal armor set
			new A_CrystalBody(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new A_CrystalHelm(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new A_CrystalLegs(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Barrows armor sets
			new AhrimsHood(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new AhrimsRobetop(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new AhrimsRobeskirt(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new AhrimsStaff(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			new DharoksHelm(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new DharoksPlatebody(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new DharoksPlatelegs(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new DharoksGreataxe(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			new GuthansHelm(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new GuthansPlatebody(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new GuthansChainskirt(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new GuthansWarspear(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			new KarilsCoif(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new KarilsLeathertop(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new KarilsLeatherskirt(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new KarilsCrossbow(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			new ToragsHelm(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new ToragsPlatebody(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new ToragsPlatelegs(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new ToragsHammers(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			new VeracsHelm(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new VeracsBrassard(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new VeracsPlateskirt(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new VeracsFlail(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
		};

		store.setChargedItems(chargedItems);

		// Items overlays.
		overlayChargedItems = new ChargedItemOverlay(client, tooltipManager, itemManager, configManager, config, chargedItems);
		overlayManager.add(overlayChargedItems);

		// Items infoboxes.
		chargedItemsInfoboxes.clear();
		Arrays.stream(chargedItems).forEach(chargedItem -> chargedItemsInfoboxes.add(new ChargedItemInfobox(chargedItem, itemManager, infoBoxManager, configManager, config, this)));
		chargedItemsInfoboxes.forEach(chargedItemInfobox -> infoBoxManager.addInfoBox(chargedItemInfobox));
	}

	@Override
	protected void shutDown() {
		keyManager.unregisterKeyListener(this);
		mouseManager.unregisterMouseListener(this);
		mouseManager.unregisterMouseWheelListener(this);

		overlayManager.remove(overlayChargedItems);
		chargedItemsInfoboxes.forEach(chargedItemInfobox -> infoBoxManager.removeInfoBox(chargedItemInfobox));
	}

	@Subscribe
	public void onChatMessage(final ChatMessage event) {
		store.setLastChatMessage(event);
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onChatMessage(event));

//		System.out.println("MESSAGE | " +
//			"type: " + event.getType().name() +
//			", message: " + getCleanChatMessage(event) +
//			", sender: " + event.getSender()
//		);
	}

	@Subscribe
	public void onItemContainerChanged(final ItemContainerChanged event) {
		store.onItemContainerChanged(event);

		for (final ChargedItemBase infobox : chargedItems) {
			infobox.onItemContainerChanged(event);
		}

//		String itemContainer = String.valueOf(event.getContainerId());
//		for (final Item item : event.getItemContainer().getItems()) {
//			itemContainer += "\r\n" +
//				item.getId() + ": " + itemManager.getItemComposition(item.getId()).getName() +
//				", quantity: " + item.getQuantity();
//		}
//		System.out.println("ITEM CONTAINER | " +
//			itemContainer
//		);
	}

	@Subscribe
	public void onGraphicChanged(final GraphicChanged event) {
		if (event.getActor() != client.getLocalPlayer()) return;

		Arrays.stream(chargedItems).forEach(infobox -> infobox.onGraphicChanged(event));

		if (config.showDebugIds()) {
			for (final ActorSpotAnim graphic : event.getActor().getSpotAnims()) {
				chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage("[Item Charges Improved] Graphic ID: " + graphic.getId())
					.build()
				);
			}
		}
	}

	@Subscribe
	public void onHitsplatApplied(final HitsplatApplied event) {
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onHitsplatApplied(event));

//		System.out.println("HITSPLAT | " +
//			"actor: " + (event.getActor() == client.getLocalPlayer() ? "self" : "enemy") +
//			", type: " + event.getHitsplat().getHitsplatType() +
//			", amount:" + event.getHitsplat().getAmount() +
//			", others = " + event.getHitsplat().isOthers() +
//			", mine = " + event.getHitsplat().isMine()
//		);
	}

	@Subscribe
	public void onAnimationChanged(final AnimationChanged event) {
		if (event.getActor() != client.getLocalPlayer() || event.getActor().getAnimation() == -1) return;

		Arrays.stream(chargedItems).forEach(infobox -> infobox.onAnimationChanged(event));

		if (config.showDebugIds()) {
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage("[Item Charges Improved] Animation ID: " + event.getActor().getAnimation())
				.build()
			);
		}
	}

	@Subscribe
	public void onWidgetLoaded(final WidgetLoaded event) {
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onWidgetLoaded(event));

//		System.out.println("WIDGET | " +
//			"group: " + event.getGroupId()
//		);
	}

	@Subscribe
	public void onMenuOptionClicked(final MenuOptionClicked event) {
		final AdvancedMenuEntry advancedMenuEntry = new AdvancedMenuEntry(event, client);
		if (
			// Menu option not found.
			advancedMenuEntry.option.isEmpty() ||
			// Not menu.
			advancedMenuEntry.target.isEmpty() && (
				!advancedMenuEntry.option.contains("Buy-") &&
				!advancedMenuEntry.option.equals("Continue")
			) ||
			// Start use by clicking on item.
			advancedMenuEntry.option.equals("Use") && advancedMenuEntry.action.equals("WIDGET_TARGET") ||
			// Cancel option.
			advancedMenuEntry.action.equals("CANCEL") ||
			// RuneLite specific action.
			advancedMenuEntry.action.equals("RUNELITE")
		) return;

		store.onMenuOptionClicked(advancedMenuEntry);

		for (final ChargedItemBase chargedItem : chargedItems) {
			chargedItem.onMenuOptionClicked(advancedMenuEntry);
		}

//		System.out.println("MENU OPTION | " +
//			"event id: " + advancedMenuEntry.eventId +
//			", option: " + advancedMenuEntry.option +
//			", target: " + advancedMenuEntry.target +
//			", action id: " + advancedMenuEntry.actionId +
//			", action name: " + advancedMenuEntry.action +
//			", item id: " + advancedMenuEntry.itemId +
//			", impostor id: " + advancedMenuEntry.impostorId
//		);
	}

	final List<Integer> scriptIdsToIgnore = Arrays.asList(
		44, 85, 100, 839, 900, 1004, 1005, 1045, 1445, 1972, 2100, 2101,
		2165, 2250, 2372, 2476, 2512, 2513, 3174, 3277, 3350, 3351, 4024,
		4029, 4482, 4517, 4518, 4666, 4667, 4668, 4669, 4671, 4672, 4716,
		4721, 4729, 4730, 4731, 4734, 5343, 5923, 5933, 5935, 5936, 5939,
		5943, 5944, 6015, 6016, 6063, 6152
	);

	@Subscribe
	public void onScriptPreFired(final ScriptPreFired event) {
		if (scriptIdsToIgnore.contains(event.getScriptId())) return;

//		String scriptDebug = "script id: " + event.getScriptId();
//		try {
//			final Optional<Widget> widget = Optional.ofNullable(event.getScriptEvent().getSource());
//			if (widget.isPresent()) {
//				scriptDebug += ", widget id: " + widget.get().getId();
//			}
//		} catch (final Exception ignored) {}
//		try {
//			String arguments = ", arguments: [";
//			for (final Object argument : event.getScriptEvent().getArguments()) {
//				arguments += argument + ", ";
//			}
//			arguments += "]";
//			scriptDebug += arguments.replaceAll(", ]", "]");
//		} catch (final Exception ignored) {}
//		System.out.println("SCRIPT FIRED | " + scriptDebug);

		for (final ChargedItemBase chargedItem : chargedItems) {
			chargedItem.onScriptPreFired(event);
		}
	}

	@Subscribe
	public void onGameStateChanged(final GameStateChanged event) {
		if (event.getGameState() == GameState.LOGGING_IN) {
			checkForChargesReset();
		}

		if (event.getGameState() != GameState.LOGGED_IN) return;

		// Send message about plugin updates for once.
		if (!config.getVersion().equals(pluginVersion)) {
			configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.version, pluginVersion);
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(pluginMessage)
				.build()
			);
		}
	}

	@Subscribe
	public void onStatChanged(final StatChanged event) {
//		String statChanged =
//			event.getSkill().getName() +
//			", level: " + event.getLevel() +
//			", total xp: " + event.getXp();
//
//		if (store.getSkillXp(event.getSkill()).isPresent()) {
//			statChanged += ", xp drop: " + (event.getXp() - store.getSkillXp(event.getSkill()).get());
//		}
//		System.out.println("STAT CHANGED | " +
//			statChanged
//		);

		Arrays.stream(chargedItems).forEach(infobox -> infobox.onStatChanged(event));
		store.onStatChanged(event);
	}

	@Subscribe
	public void onItemDespawned(final ItemDespawned event) {
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onItemDespawned(event));
	}

	@Subscribe
	public void onVarbitChanged(final VarbitChanged event) {
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onVarbitChanged(event));

		// If server minutes are 0, it's a new day!
		if (event.getVarbitId() == VARBIT_MINUTES && client.getGameState() == GameState.LOGGED_IN && event.getValue() == 0) {
			checkForChargesReset();
		}

//		System.out.println("VARBIT CHANGED | " +
//			"id: " + event.getVarbitId() +
//			", value: " + event.getValue()
//		);
	}

	@Subscribe
	public void onMenuEntryAdded(final MenuEntryAdded event) {
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onMenuEntryAdded(event));

//		if (event.getMenuEntry().getItemId() != -1) {
//			System.out.println("MENU ENTRY ADDED | " +
//				"item id: " + event.getMenuEntry().getItemId() +
//				", option: " + event.getOption() +
//				", target: " + event.getTarget()
//			);
//		}
	}

	@Subscribe
	public void onGameTick(final GameTick gametick) {
		store.onGameTick(gametick);
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged event) {
		if (event.getGroup().equals(TicTac7xChargesImprovedConfig.group) && event.getKey().equals(TicTac7xChargesImprovedConfig.debug_ids)) {
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(config.showDebugIds()
					? "<colHIGHLIGHT>[Item Charges Improved] Debug information is now enabled."
					: "<colHIGHLIGHT>[Item Charges Improved] Debug information is now disabled."
				).build()
			);
		}
	}

	private void onUserAction() {
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onUserAction());
	}

	private void checkForChargesReset() {
		final String date = LocalDateTime.now(timezone).format(DateTimeFormatter.ISO_LOCAL_DATE);
		if (date.equals(config.getResetDate())) return;

		configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.date, date);
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onResetDaily());

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage("<colHIGHLIGHT>Daily item charges have been reset.")
			.build()
		);
	}

	private void configMigration() {
		// Migrate old hidden infoboxes multi-select to checkboxes.
		final Optional<String> necklaceOfPassageOverlay = Optional.ofNullable(configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, "necklage_of_passage_overlay"));
		final Optional<String> necklaceOfPassageInfobox = Optional.ofNullable(configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, "necklage_of_passage_infobox"));

		if (necklaceOfPassageOverlay.isPresent()) {
			configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.necklace_of_passage + TicTac7xChargesImprovedConfig.overlay, necklaceOfPassageOverlay.get().equals("true"));
			configManager.unsetConfiguration(TicTac7xChargesImprovedConfig.group, "necklage_of_passage_overlay");
		}

		if (necklaceOfPassageInfobox.isPresent()) {
			configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.necklace_of_passage + TicTac7xChargesImprovedConfig.infobox, necklaceOfPassageInfobox.get().equals("true"));
			configManager.unsetConfiguration(TicTac7xChargesImprovedConfig.group, "necklage_of_passage_infobox");
		}
	}

	@Override
	public void keyPressed(final KeyEvent keyEvent) {
		onUserAction();
	}

	@Override
	public void keyTyped(final KeyEvent keyEvent) {}

	@Override
	public void keyReleased(final KeyEvent keyEvent) {}

	@Override
	public MouseEvent mousePressed(final MouseEvent mouseEvent) {
		onUserAction();
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseDragged(final MouseEvent mouseEvent) {
		onUserAction();
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseMoved(final MouseEvent mouseEvent) {
		onUserAction();
		return mouseEvent;
	}

	@Override
	public MouseWheelEvent mouseWheelMoved(final MouseWheelEvent mouseWheelEvent) {
		onUserAction();
		return mouseWheelEvent;
	}

	@Override
	public MouseEvent mouseClicked(final MouseEvent mouseEvent) {
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseReleased(final MouseEvent mouseEvent) {
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseEntered(final MouseEvent mouseEvent) {
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseExited(final MouseEvent mouseEvent) {
		return mouseEvent;
	}

	public static String getCleanChatMessage(final ChatMessage event) {
		return event.getMessage().replaceAll("</?col.*?>", "").replaceAll("<br>", " ").replaceAll("\u00A0"," ");
	}

	public static int getNumberFromCommaString(final String charges) {
		return Integer.parseInt(charges.replaceAll(",", "").replaceAll("\\.", ""));
	}

	public static Optional<Widget> getWidget(final Client client, final int parent, final int child) {
		@Nullable
		final Widget widget = client.getWidget(parent, child);
		return Optional.ofNullable(widget);
	}

	public static Optional<Widget> getWidget(final Client client, final int parent, final int child, final int subChild) {
		@Nullable
		final Widget widget = client.getWidget(parent, child);
		if (widget == null) return Optional.empty();

		@Nullable
		final Widget subWidget = widget.getChild(subChild);
		return Optional.ofNullable(subWidget);
	}
	
	private static final ImmutableMap<String, Integer> TEXT_TO_NUMBER_MAP = ImmutableMap.<String, Integer>builder()
		.put("zero", 0).put("one", 1).put("two", 2).put("three", 3).put("four", 4).put("five", 5)
		.put("six", 6).put("seven", 7).put("eight", 8).put("nine", 9).put("ten", 10)
		.put("eleven", 11).put("twelve", 12).put("thirteen", 13).put("fourteen", 14).put("fifteen", 15)
		.put("sixteen", 16).put("seventeen", 17).put("eighteen", 18).put("nineteen", 19).put("twenty", 20)
		.put("thirty", 30).put("forty", 40).put("fifty", 50).put("sixty", 60).put("seventy", 70)
		.put("eighty", 80).put("ninety", 90).put("hundred", 100).build();

	public static int getNumberFromWordRepresentation(final String charges) {
		// Support strings like "twenty two" and "twenty-two"
		final String[] words = charges.toLowerCase().split("[ -]");
		int result = 0;
		int current = 0;

		for (final String word : words) {
			if (TEXT_TO_NUMBER_MAP.containsKey(word)) {
				current += TEXT_TO_NUMBER_MAP.get(word);
			} else if (word.equals("hundred")) {
				current *= 100;
			} else if (word.equals("thousand")) {
				result += current * 1000;
				current = 0;
			}
		}

		return result + current;
	}
}


package tictac7x.charges;

import net.runelite.client.config.*;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.ItemActivity;
import tictac7x.charges.store.ItemOverlayLocation;

import java.awt.Color;

import static tictac7x.charges.TicTac7xChargesImprovedConfig.group;

@ConfigGroup(group)
public interface TicTac7xChargesImprovedConfig extends Config {
    String group = "tictac7x-charges";
    String version = "version";
    String storage_bank = "storage_bank";
    String storage_inventory = "storage_inventory";
    String storage_equipment = "storage_equipment";
    String date = "date";
    String debug_ids = "debug_ids";
    String infobox = "_infobox";
    String overlay = "_overlay";

    String alchemists_amulet = "alchemists_amulet";
    String arclight = "arclight";
    String ardougne_cloak = "ardougne_cloak";
    String ash_sanctifier = "ash_sanctifier";
    String ash_sanctifier_status = "ash_sanctifier_status";
    String barrows_gear = "barrows_gear";
    String binding_necklace = "binding_necklace";
    String bonecrusher = "bonecrusher";
    String bonecrusher_status = "bonecrusher_status";
    String bottomless_compost_bucket = "bottomless_compost_bucket";
    String bow_of_faerdhinen = "bow_of_faerdhinen";
    String bracelet_of_clay = "bracelet_of_clay";
    String bracelet_of_expeditious = "bracelet_of_expeditious";
    String bracelet_of_flamtaer = "bracelet_of_flamtaer";
    String bracelet_of_slaughter = "bracelet_of_slaughter";
    String bryophytas_staff = "bryophytas_staff";
    String camulet = "camulet";
    String celestial_ring = "celestial_ring";
    String chronicle = "chronicle";
    String circlet_of_water = "circlet_of_water";
    String coal_bag = "coal_bag";
    String colossal_pouch = "colossal_pouch";
    String colossal_pouch_decay_count = "colossal_pouch_decay_count";
    String coffin = "coffin";
    String crystal_body = "crystal_body";
    String crystal_bow = "crystal_bow";
    String crystal_halberd = "crystal_halberd";
    String crystal_helm = "crystal_helm";
    String crystal_legs = "crystal_legs";
    String crystal_saw = "crystal_saw";
    String crystal_shield = "crystal_shield";
    String desert_amulet = "desert_amulet";
    String dodgy_necklace = "dodgy_necklace";
    String dragonfire_shield = "dragonfire_shield";
    String enchanted_lyre = "enchanted_lyre";
    String escape_crystal = "escape_crystal";
    String escape_crystal_status = "escape_crystal_status";
    String escape_crystal_inactivity_period = "escape_crystal_inactivity_period";
    String escape_crystal_time_remaining_warning = "escape_crystal_time_remaining_warning";
    String explorers_ring = "explorers_ring";
    String falador_shield = "falador_shield";
    String fish_barrel = "fish_barrel";
    String forestry_kit = "forestry_kit";
    String fremennik_sea_boots = "fremennik_sea_boots";
    String fungicide_spray = "fungicide_spray";
    String fur_pouch = "fur_pouch";
    String gem_bag = "gem_bag";
    String gricollers_can = "gricollers_can";
    String herb_sack = "herb_sack";
    String ibans_staff = "ibans_staff";
    String jar_generator = "jar_generator";
    String kandarin_headgear = "kandarin_headgear";
    String kharedsts_memoirs = "kharedsts_memoirs";
    String log_basket = "log_basket";
    String magic_cape = "magic_cape";
    String master_scroll_book = "master_scroll_book";
    String meat_pouch = "meat_pouch";
    String huntsmans_kit = "huntsmans_kit";
    String necklace_of_passage = "necklace_of_passage";
    String ogre_bellows = "ogre_bellows";
    String pharaohs_sceptre = "pharaohs_sceptre";
    String phoenix_necklace = "phoenix_necklace";
    String plank_sack = "plank_sack";
    String quetzal_whistle = "quetzal_whistle";
    String ring_of_dueling = "ring_of_dueling";
    String ring_of_pursuit = "ring_of_pursuit";
    String ring_of_recoil = "ring_of_recoil";
    String ring_of_shadows = "ring_of_shadows";
    String ring_of_suffering = "ring_of_suffering";
    String ring_of_suffering_status = "ring_of_suffering_status";
    String ring_of_the_elements = "ring_of_the_elements";
    String ring_of_endurance = "ring_of_endurance";
    String sanguinesti_staff = "sanguinesti_staff";
    String seed_box = "seed_box";
    String skull_sceptre = "skull_sceptre";
    String slayer_ring = "slayer_ring";
    String slayer_staff_e = "slayer_staff_e";
    String soul_bearer = "soul_bearer";
    String strange_old_lockpick = "strange_old_lockpick";
    String tackle_box = "tackle_box";
    String teleport_crystal = "teleport_crystal";
    String eternal_teleport_crystal = "teleport_crystal";
    String tome_of_fire = "tome_of_fire";
    String tome_of_water = "tome_of_water";
    String toxic_staff_of_the_dead = "toxic_staff_of_the_dead";
    String trident_of_the_seas = "trident_of_the_seas";
    String venator_bow = "venator_bow";
    String warped_sceptre = "warped_sceptre";
    String waterskin = "waterskin";
    String western_banner = "western_banner";
    String xerics_talisman = "xerics_talisman";
    String ruby_harvest_mix = "ruby_harvest_mix";
    String sapphire_glacialis_mix = "sapphire_glacialis_mix";
    String snowy_knight_mix = "snowy_knight_mix";
    String black_warlock_mix = "black_warlock_mix";
    String sunlight_moth_mix = "sunlight_moth_mix";
    String moonlight_moth_mix = "moonlight_moth_mix";
    String tumekens_shadow = "tumekens_shadow";
    String digsite_pendant = "digsite_pendant";
    String pendant_of_ates = "pendant_of_ates";

    @ConfigSection(
        name = "General",
        description = "General settings",
        position = 1
    ) String general = "general";

        @ConfigItem(
            keyName = "show_infoboxes",
            name = "Show infoboxes",
            description = "Show or hide all charges infoboxes simultaneously.",
            section = general,
            position = 1
        ) default boolean showInfoboxes() { return true; }

        @ConfigItem(
            keyName = "show_overlays",
            name = "Show overlays",
            description = "Show or hide all charges overlays on top of items simultaneously.",
            section = general,
            position = 2
        ) default boolean showOverlays() { return true; }

        @ConfigItem(
            keyName = "bank_overlays",
            name = "Show overlays in bank",
            description = "Show charges of the items in bank",
            section = general,
            position = 3
        ) default boolean showBankOverlays() { return true; }

        @ConfigItem(
            keyName = "hide_outside_bank_overlays",
            name = "Show overlays only while in bank",
            description = "Shows item charges overlays only when in bank",
            section = general,
            position = 4
        ) default boolean showOverlaysOnlyInBank() { return false; }

        @ConfigItem(
            keyName = "item_overlay_location",
            name = "Item overlay location",
            description = "Location of the charges for item overlays",
            section = general,
            position = 5
        ) default ItemOverlayLocation itemOverlayLocation() { return ItemOverlayLocation.BOTTOM_LEFT; }

        @ConfigItem(
            keyName = "storage_tooltips",
            name = "Show storage tooltips",
            description = "Show tooltips for items with storage",
            section = general,
            position = 6
        ) default boolean showStorageTooltips() { return true; }

        @ConfigItem(
            keyName = "menu_replacements",
            name = "Unify menu entries",
            description = "Replace obscure menu entries like \"Reminisce\" and \"Divine\" with \"Teleport\" and \"Check\" and show detailed herb patches names.",
            section = general,
            position = 7
        ) default boolean useCommonMenuEntries() { return true; }

        @ConfigItem(
            keyName = "hide_destroy",
            name = "Hide destroy menu entries",
            description = "Hide destroy menu entry from items that make no sense to destroy",
            section = general,
            position = 8
        ) default boolean hideDestroy() { return true; }

        @ConfigItem(
            keyName = "show_unlimited_charges",
            name = "Show unlimited charges",
            description = "Show infinity symbol for items with unlimited charges",
            section = general,
            position = 9
        ) default boolean showUnlimited() { return true; }

    @ConfigSection(
        name = "Colors",
        description = "Colors of item overlays",
        position = 2
    ) String colors = "colors";

        @Alpha
        @ConfigItem(
            keyName = "colors_default",
            name = "Default",
            description = "Color of default charges",
            position = 1,
            section = colors
        ) default Color getColorDefault() { return Color.white; }

        @Alpha
        @ConfigItem(
            keyName = "colors_unknown",
            name = "Unknown",
            description = "Color of unknown charges",
            position = 2,
            section = colors
        ) default Color getColorUnknown() { return Color.gray; }

        @Alpha
        @ConfigItem(
            keyName = "colors_empty",
            name = "Empty",
            description = "Color of empty charges",
            position = 3,
            section = colors
        ) default Color getColorEmpty() { return Color.red; }

        @Alpha
        @ConfigItem(
            keyName = "colors_activated",
            name = "Activated",
            description = "Color of activated charges",
            position = 4,
            section = colors
        ) default Color getColorActivated() { return Color.green; }

    @ConfigSection(
        name = "Escape Crystal",
        description = "Escape Crystal",
        position = 3,
        closedByDefault = true
    ) String escape_crystal_section = "escape_crystal_section";

        @ConfigItem(
            keyName = escape_crystal_time_remaining_warning,
            name = "Time remaining warning",
            description = "How many seconds before you are warned before Escape crystal activates",
            position = 4,
            section = escape_crystal_section
        ) default int getEscapeCrystalTimeRemainingWarning() { return 5; }

    @ConfigSection(
        name = "Infoboxes",
        description = "Choose for which charged items infobox is visible",
        position = 4,
        closedByDefault = true
    ) String infoboxes = "infoboxes";

        @ConfigItem(
            keyName = binding_necklace + infobox,
            name = "Binding necklace",
            description = "",
            section = infoboxes
        ) default boolean bindingNecklaceInfobox() { return true; }

        @ConfigItem(
            keyName = pendant_of_ates + infobox,
            name = "Pendant of ates",
            description = "",
            section = infoboxes
        ) default boolean pendantOfAtesInfobox() { return true; }

        @ConfigItem(
            keyName = digsite_pendant + infobox,
            name = "Digsite pendant",
            description = "",
            section = infoboxes
        ) default boolean digsitePendantInfobox() { return true; }

        @ConfigItem(
            keyName = tumekens_shadow + infobox,
            name = "Tumeken's shadow",
            description = "",
            section = infoboxes
        ) default boolean tumekensShadowInfobox() { return true; }

        @ConfigItem(
            keyName = master_scroll_book + infobox,
            name = "Master scroll book",
            description = "",
            section = infoboxes
        ) default boolean masterScrollBookInfobox() { return true; }

        @ConfigItem(
            keyName = ruby_harvest_mix + infobox,
            name = "Ruby harvest mix",
            description = "",
            section = infoboxes
        ) default boolean rubyHarvestMixInfobox() { return false; }

        @ConfigItem(
            keyName = sapphire_glacialis_mix + infobox,
            name = "Sapphire glacialis mix",
            description = "",
            section = infoboxes
        ) default boolean sapphireGlacialisMixInfobox() { return false; }

        @ConfigItem(
            keyName = snowy_knight_mix + infobox,
            name = "Snowy knight mix",
            description = "",
            section = infoboxes
        ) default boolean snowyKnightMixInfobox() { return false; }

        @ConfigItem(
            keyName = black_warlock_mix + infobox,
            name = "Black warlock mix",
            description = "",
            section = infoboxes
        ) default boolean blackWarlockInfobox() { return false; }

        @ConfigItem(
            keyName = sunlight_moth_mix + infobox,
            name = "Sunlight moth mix",
            description = "",
            section = infoboxes
        ) default boolean sunlightMothMixInfobox() { return false; }

        @ConfigItem(
            keyName = moonlight_moth_mix + infobox,
            name = "Moonlight moth mix",
            description = "",
            section = infoboxes
        ) default boolean moonlightMothMixInfobox() { return false; }

        @ConfigItem(
            keyName = ring_of_dueling + infobox,
            name = "Ring of dueling",
            description = "",
            section = infoboxes
        ) default boolean ringOfDuelingInfobox() { return true; }

        @ConfigItem(
            keyName = ring_of_pursuit + infobox,
            name = "Ring of pursuit",
            description = "",
            section = infoboxes
        ) default boolean ringOfPursuitInfobox() { return true; }

        @ConfigItem(
            keyName = huntsmans_kit + infobox,
            name = "Huntsman's kit",
            description = "",
            section = infoboxes
        ) default boolean huntsmansKitInfobox() { return true; }

        @ConfigItem(
            keyName = bow_of_faerdhinen + infobox,
            name = "Bow of faerdhinen",
            description = "",
            section = infoboxes
        ) default boolean bowOfFaerdhinenInfobox() { return true; }

        @ConfigItem(
            keyName = venator_bow + infobox,
            name = "Venator bow",
            description = "",
            section = infoboxes
        ) default boolean venatorBowInfobox() { return true; }

        @ConfigItem(
            keyName = meat_pouch + infobox,
            name = "Meat pouch",
            description = "",
            section = infoboxes
        ) default boolean meatPouchInfobox() { return true; }

        @ConfigItem(
            keyName = western_banner + infobox,
            name = "Western banner",
            description = "",
            section = infoboxes
        ) default boolean westernBannerInfobox() { return true; }

        @ConfigItem(
            keyName = barrows_gear + infobox,
            name = "Barrows set",
            description = "",
            section = infoboxes
        ) default boolean barrowsInfobox() { return true; }

        @ConfigItem(
            keyName = crystal_body + infobox,
            name = "Crystal body",
            description = "",
            section = infoboxes
        ) default boolean crystalBodyInfobox() { return true; }

        @ConfigItem(
            keyName = crystal_helm + infobox,
            name = "Crystal helm",
            description = "",
            section = infoboxes
        ) default boolean crystalHelmInfobox() { return true; }

        @ConfigItem(
            keyName = crystal_legs + infobox,
            name = "Crystal legs",
            description = "",
            section = infoboxes
        ) default boolean crystalLegsInfobox() { return true; }

        @ConfigItem(
            keyName = fremennik_sea_boots + infobox,
            name = "Fremennik sea boots",
            description = "",
            section = infoboxes
        ) default boolean fremennikSeaBootsInfobox() { return true; }

        @ConfigItem(
            keyName = ardougne_cloak + infobox,
            name = "Ardougne cloak",
            description = "",
            section = infoboxes
        ) default boolean ardougneCloakInfobox() { return true; }

        @ConfigItem(
            keyName = coffin + infobox,
            name = "Coffin",
            description = "",
            section = infoboxes
        ) default boolean coffinInfobox() { return true; }

        @ConfigItem(
            keyName = forestry_kit + infobox,
            name = "Forestry kit",
            description = "",
            section = infoboxes
        ) default boolean forestryKitInfobox() { return true; }

        @ConfigItem(
            keyName = fur_pouch + infobox,
            name = "Fur pouch",
            description = "",
            section = infoboxes
        ) default boolean furPouchInfobox() { return true; }

        @ConfigItem(
            keyName = magic_cape + infobox,
            name = "Magic cape",
            description = "",
            section = infoboxes
        ) default boolean magicCapeInfobox() { return true; }

        @ConfigItem(
            keyName = circlet_of_water + infobox,
            name = "Circlet of water",
            description = "",
            section = infoboxes
        ) default boolean circletOfWaterInfobox() { return true; }

        @ConfigItem(
            keyName = kandarin_headgear + infobox,
            name = "Kandarin Headgear",
            description = "",
            section = infoboxes
        ) default boolean kandarinHeadgearInfobox() { return true; }

        @ConfigItem(
            keyName = bracelet_of_clay + infobox,
            name = "Bracelet of clay",
            description = "",
            section = infoboxes
        ) default boolean braceletOfClayInfobox() { return true; }

        @ConfigItem(
            keyName = bracelet_of_expeditious + infobox,
            name = "Expeditious bracelet",
            description = "",
            section = infoboxes
        ) default boolean expeditiousBraceletInfobox() { return true; }

        @ConfigItem(
            keyName = bracelet_of_flamtaer + infobox,
            name = "Flamtaer bracelet",
            description = "",
            section = infoboxes
        ) default boolean flamtaerBraceletInfobox() { return true; }

        @ConfigItem(
            keyName = bracelet_of_slaughter + infobox,
            name = "Bracelet of slaughter",
            description = "",
            section = infoboxes
        ) default boolean braceletOfSlaughterInfobox() { return true; }

        @ConfigItem(
            keyName = camulet + infobox,
            name = "Camulet",
            description = "",
            section = infoboxes
        ) default boolean camuletInfobox() { return true; }

        @ConfigItem(
            keyName = desert_amulet + infobox,
            name = "Desert amulet",
            description = "",
            section = infoboxes
        ) default boolean desertAmuletInfobox() { return true; }

        @ConfigItem(
            keyName = escape_crystal + infobox,
            name = "Escape crystal",
            description = "",
            section = infoboxes
        ) default boolean escapeCrystalInfobox() { return true; }

        @ConfigItem(
            keyName = dodgy_necklace + infobox,
            name = "Dodgy necklace",
            description = "",
            section = infoboxes
        ) default boolean dodgyNecklaceInfobox() { return true; }

        @ConfigItem(
            keyName = necklace_of_passage + infobox,
            name = "Necklace of passage",
            description = "",
            section = infoboxes
        ) default boolean necklaceOfPassageInfobox() { return true; }

        @ConfigItem(
            keyName = phoenix_necklace + infobox,
            name = "Phoenix necklace",
            description = "",
            section = infoboxes
        ) default boolean phoenixNecklaceInfobox() { return true; }

        @ConfigItem(
            keyName = celestial_ring + infobox,
            name = "Celestial ring",
            description = "",
            section = infoboxes
        ) default boolean celestialRingInfobox() { return true; }

        @ConfigItem(
            keyName = ring_of_the_elements + infobox,
            name = "Ring of the elements",
            description = "",
            section = infoboxes
        ) default boolean ringOfTheElementsInfobox() { return true; }

        @ConfigItem(
            keyName = ring_of_endurance + infobox,
            name = "Ring of endurance",
            description = "",
            section = infoboxes
        ) default boolean ringOfEnduranceInfobox() { return true; }

        @ConfigItem(
            keyName = explorers_ring + infobox,
            name = "Explorer's ring",
            description = "",
            section = infoboxes
        ) default boolean explorersRingInfobox() { return true; }

        @ConfigItem(
            keyName = ring_of_recoil + infobox,
            name = "Ring of recoil",
            description = "",
            section = infoboxes
        ) default boolean ringOfRecoilInfobox() { return true; }

        @ConfigItem(
            keyName = ring_of_shadows + infobox,
            name = "Ring of shadows",
            description = "",
            section = infoboxes
        ) default boolean ringOfShadowsInfobox() { return true; }

        @ConfigItem(
            keyName = slayer_ring + infobox,
            name = "Slayer ring",
            description = "",
            section = infoboxes
        ) default boolean slayerRingInfobox() { return true; }

        @ConfigItem(
            keyName = ring_of_suffering + infobox,
            name = "Ring of suffering",
            description = "",
            section = infoboxes
        ) default boolean ringOfSufferingInfobox() { return true; }

        @ConfigItem(
            keyName = xerics_talisman + infobox,
            name = "Xeric's talisman",
            description = "",
            section = infoboxes
        ) default boolean xericsTalismanInfobox() { return true; }

        @ConfigItem(
            keyName = chronicle + infobox,
            name = "Chronicle",
            description = "",
            section = infoboxes
        ) default boolean chronicleInfobox() { return true; }

        @ConfigItem(
            keyName = crystal_shield + infobox,
            name = "Crystal shield",
            description = "",
            section = infoboxes
        ) default boolean crystalShieldInfobox() { return true; }

        @ConfigItem(
            keyName = dragonfire_shield + infobox,
            name = "Dragonfire shield",
            description = "",
            section = infoboxes
        ) default boolean dragonfireShieldInfobox() { return true; }

        @ConfigItem(
            keyName = falador_shield + infobox,
            name = "Falador shield",
            description = "",
            section = infoboxes
        ) default boolean faladorShieldInfobox() { return true; }

        @ConfigItem(
            keyName = kharedsts_memoirs + infobox,
            name = "Kharedst's memoirs",
            description = "",
            section = infoboxes
        ) default boolean kharedstsMemoirsInfobox() { return true; }

        @ConfigItem(
            keyName = kharedsts_memoirs + infobox,
            name = "Book of the dead",
            description = "",
            section = infoboxes
        ) default boolean bookOfTheDeadInfobox() { return true; }

        @ConfigItem(
            keyName = tome_of_fire + infobox,
            name = "Tome of fire",
            description = "",
            section = infoboxes
        ) default boolean tomeOfFireInfobox() { return true; }

        @ConfigItem(
            keyName = tome_of_water + infobox,
            name = "Tome of water",
            description = "",
            section = infoboxes
        ) default boolean tomeOfWaterInfobox() { return true; }

        @ConfigItem(
            keyName = ash_sanctifier + infobox,
            name = "Ash sanctifier",
            description = "",
            section = infoboxes
        ) default boolean ashSanctifierInfobox() { return true; }

        @ConfigItem(
            keyName = bonecrusher + infobox,
            name = "Bonecrusher",
            description = "",
            section = infoboxes
        ) default boolean bonecrusherInfobox() { return true; }

        @ConfigItem(
            keyName = bottomless_compost_bucket + infobox,
            name = "Bottomless compost bucket",
            description = "",
            section = infoboxes
        ) default boolean bottomlessCompostBucketInfobox() { return true; }

        @ConfigItem(
            keyName = coal_bag + infobox,
            name = "Coal bag",
            description = "",
            section = infoboxes
        ) default boolean coalBagInfobox() { return true; }

        @ConfigItem(
            keyName = colossal_pouch + infobox,
            name = "Colossal pouch",
            description = "",
            section = infoboxes
        ) default boolean colossalPouchInfobox() { return true; }

        @ConfigItem(
            keyName = crystal_saw + infobox,
            name = "Crystal saw",
            description = "",
            section = infoboxes
        ) default boolean crystalSawInfobox() { return true; }

        @ConfigItem(
            keyName = fish_barrel + infobox,
            name = "Fish barrel",
            description = "",
            section = infoboxes
        ) default boolean fishBarrelInfobox() { return true; }

        @ConfigItem(
            keyName = fungicide_spray + infobox,
            name = "Fungicide spray",
            description = "",
            section = infoboxes
        ) default boolean fungicideSprayInfobox() { return true; }

        @ConfigItem(
            keyName = gem_bag + infobox,
            name = "Gem bag",
            description = "",
            section = infoboxes
        ) default boolean gemBagInfobox() { return true; }

        @ConfigItem(
            keyName = gricollers_can + infobox,
            name = "Gricoller's can",
            description = "",
            section = infoboxes
        ) default boolean gricollersCanInfobox() { return true; }

        @ConfigItem(
            keyName = herb_sack + infobox,
            name = "Herb sack",
            description = "",
            section = infoboxes
        ) default boolean herbSackInfobox() { return true; }

        @ConfigItem(
            keyName = jar_generator + infobox,
            name = "Jar generator",
            description = "",
            section = infoboxes
        ) default boolean jarGeneratorInfobox() { return true; }

        @ConfigItem(
            keyName = log_basket + infobox,
            name = "Log basket",
            description = "",
            section = infoboxes
        ) default boolean logBasketInfobox() { return true; }

        @ConfigItem(
            keyName = ogre_bellows + infobox,
            name = "Ogre bellows",
            description = "",
            section = infoboxes
        ) default boolean ogreBellowsInfobox() { return true; }

        @ConfigItem(
            keyName = plank_sack + infobox,
            name = "Plank sack",
            description = "",
            section = infoboxes
        ) default boolean plankSackInfobox() { return true; }

        @ConfigItem(
            keyName = quetzal_whistle + infobox,
            name = "Quetzal whistle",
            description = "",
            section = infoboxes
        ) default boolean quetzalWhistleInfobox() { return true; }

        @ConfigItem(
            keyName = seed_box + infobox,
            name = "Seed box",
            description = "",
            section = infoboxes
        ) default boolean seedBoxInfobox() { return true; }

        @ConfigItem(
            keyName = soul_bearer + infobox,
            name = "Soul bearer",
            description = "",
            section = infoboxes
        ) default boolean soulBearerInfobox() { return true; }

        @ConfigItem(
            keyName = strange_old_lockpick + infobox,
            name = "Strange old lockpick",
            description = "",
            section = infoboxes
        ) default boolean strangeOldLockpickInfobox() { return true; }

        @ConfigItem(
            keyName = tackle_box + infobox,
            name = "Tackle box",
            description = "",
            section = infoboxes
        ) default boolean tackleBoxInfobox() { return true; }

        @ConfigItem(
            keyName = teleport_crystal + infobox,
            name = "Teleport crystal",
            description = "",
            section = infoboxes
        ) default boolean teleportCrystalInfobox() { return true; }

        @ConfigItem(
            keyName = eternal_teleport_crystal + infobox,
            name = "Eternal teleport crystal",
            description = "",
            section = infoboxes
        ) default boolean eternalTeleportCrystalInfobox() { return true; }

        @ConfigItem(
            keyName = waterskin + infobox,
            name = "Waterskin",
            description = "",
            section = infoboxes
        ) default boolean waterskinInfobox() { return true; }

        @ConfigItem(
            keyName = arclight + infobox,
            name = "Arclight",
            description = "",
            section = infoboxes
        ) default boolean arclightInfobox() { return true; }

        @ConfigItem(
            keyName = bryophytas_staff + infobox,
            name = "Bryophyta's staff",
            description = "",
            section = infoboxes
        ) default boolean bryophytasStaffInfobox() { return true; }

        @ConfigItem(
            keyName = crystal_bow + infobox,
            name = "Crystal bow",
            description = "",
            section = infoboxes
        ) default boolean crystalBowInfobox() { return true; }

        @ConfigItem(
            keyName = crystal_halberd + infobox,
            name = "Crystal halberd",
            description = "",
            section = infoboxes
        ) default boolean crystalHalberdInfobox() { return true; }

        @ConfigItem(
            keyName = enchanted_lyre + infobox,
            name = "Enchanted Lyre",
            description = "",
            section = infoboxes
        ) default boolean enchantedLyreInfobox() { return true; }

        @ConfigItem(
            keyName = ibans_staff + infobox,
            name = "Iban's staff",
            description = "",
            section = infoboxes
        ) default boolean ibansStaffInfobox() { return true; }

        @ConfigItem(
            keyName = pharaohs_sceptre + infobox,
            name = "Pharaoh's sceptre",
            description = "",
            section = infoboxes
        ) default boolean pharaohsSceptreInfobox() { return true; }

        @ConfigItem(
            keyName = sanguinesti_staff + infobox,
            name = "Sanguinesti staff",
            description = "",
            section = infoboxes
        ) default boolean sanguinestiStaffInfobox() { return true; }

        @ConfigItem(
            keyName = skull_sceptre + infobox,
            name = "Skull sceptre",
            description = "",
            section = infoboxes
        ) default boolean skullSceptreInfobox() { return true; }

        @ConfigItem(
            keyName = slayer_staff_e + infobox,
            name = "Slayer staff (e)",
            description = "",
            section = infoboxes
        ) default boolean slayerStaffEInfobox() { return true; }

        @ConfigItem(
            keyName = toxic_staff_of_the_dead + infobox,
            name = "Toxic staff of the dead",
            description = "",
            section = infoboxes
        ) default boolean toxicStaffOfTheDeadInfobox() { return true; }

        @ConfigItem(
            keyName = trident_of_the_seas + infobox,
            name = "Trident of the seas",
            description = "",
            section = infoboxes
        ) default boolean tridentOfTheSeasInfobox() { return true; }

        @ConfigItem(
            keyName = warped_sceptre + infobox,
            name = "Warped sceptre",
            description = "",
            section = infoboxes
        ) default boolean warpedSceptreInfobox() { return true; }

        @ConfigItem(
                keyName = alchemists_amulet + infobox,
                name = "Alchemist's Amulet",
                description = "",
                section = infoboxes
        ) default boolean alchemistsAmuletInfobox() { return true; }

    @ConfigSection(
        name = "Overlays",
        description = "Choose for which charged items number is shown next to it",
        position = 4,
        closedByDefault = true
    ) String overlays = "overlays";

        @ConfigItem(
            keyName = binding_necklace + overlay,
            name = "Binding necklace",
            description = "",
            section = overlays
        ) default boolean bindingNecklaceOverlay() { return true; }

        @ConfigItem(
            keyName = pendant_of_ates + overlay,
            name = "Pendant of ates",
            description = "",
            section = overlays
        ) default boolean pendantOfAtesOverlay() { return true; }

        @ConfigItem(
            keyName = digsite_pendant + overlay,
            name = "Digsite pendant",
            description = "",
            section = overlays
        ) default boolean digsitePendantOverlay() { return true; }

        @ConfigItem(
            keyName = tumekens_shadow + overlay,
            name = "Tumeken's shadow",
            description = "",
            section = overlays
        ) default boolean tumekensShadowOverlay() { return true; }

        @ConfigItem(
            keyName = master_scroll_book + overlay,
            name = "Master scroll book",
            description = "",
            section = overlays
        ) default boolean masterScrollBookOverlay() { return true; }

        @ConfigItem(
            keyName = ruby_harvest_mix + overlay,
            name = "Ruby harvest mix",
            description = "",
            section = overlays
        ) default boolean rubyHarvestMixOverlay() { return true; }

        @ConfigItem(
            keyName = sapphire_glacialis_mix + overlay,
            name = "Sapphire glacialis mix",
            description = "",
            section = overlays
        ) default boolean sapphireGlacialisMixOverlay() { return true; }

        @ConfigItem(
            keyName = snowy_knight_mix + overlay,
            name = "Snowy knight mix",
            description = "",
            section = overlays
        ) default boolean snowyKnightMixOverlay() { return true; }

        @ConfigItem(
            keyName = black_warlock_mix + overlay,
            name = "Black warlock mix",
            description = "",
            section = overlays
        ) default boolean blackWarlockOverlay() { return true; }

        @ConfigItem(
            keyName = sunlight_moth_mix + overlay,
            name = "Sunlight moth mix",
            description = "",
            section = overlays
        ) default boolean sunlightMothMixOverlay() { return true; }

        @ConfigItem(
            keyName = moonlight_moth_mix + overlay,
            name = "Moonlight moth mix",
            description = "",
            section = overlays
        ) default boolean moonlightMothMixOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_dueling + overlay,
            name = "Ring of dueling",
            description = "",
            section = overlays
        ) default boolean ringOfDuelingOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_pursuit + overlay,
            name = "Ring of pursuit",
            description = "",
            section = overlays
        ) default boolean ringOfPursuitOverlay() { return true; }

        @ConfigItem(
            keyName = huntsmans_kit + overlay,
            name = "Huntsman's kit",
            description = "",
            section = overlays
        ) default boolean huntsmansKitOverlay() { return true; }

        @ConfigItem(
            keyName = arclight + overlay,
            name = "Arclight",
            description = "",
            section = overlays
        ) default boolean arclightOverlay() { return true; }

        @ConfigItem(
            keyName = ardougne_cloak + overlay,
            name = "Ardougne cloak",
            description = "",
            section = overlays
        ) default boolean ardougneCloakOverlay() { return true; }

        @ConfigItem(
            keyName = ash_sanctifier + overlay,
            name = "Ash sanctifier",
            description = "",
            section = overlays
        ) default boolean ashSanctifierOverlay() { return true; }

        @ConfigItem(
            keyName = barrows_gear + overlay,
            name = "Barrows set",
            description = "",
            section = overlays
        ) default boolean barrowsOverlay() { return true; }

        @ConfigItem(
            keyName = bonecrusher + overlay,
            name = "Bonecrusher",
            description = "",
            section = overlays
        ) default boolean bonecrusherOverlay() { return true; }

        @ConfigItem(
            keyName = bottomless_compost_bucket + overlay,
            name = "Bottomless compost bucket",
            description = "",
            section = overlays
        ) default boolean bottomlessCompostBucketOverlay() { return true; }

        @ConfigItem(
            keyName = bow_of_faerdhinen + overlay,
            name = "Bow of faerdhinen",
            description = "",
            section = overlays
        ) default boolean bowOfFaerdhinenOverlay() { return true; }

        @ConfigItem(
            keyName = bracelet_of_clay + overlay,
            name = "Bracelet of clay",
            description = "",
            section = overlays
        ) default boolean braceletOfClayOverlay() { return true; }

        @ConfigItem(
            keyName = bracelet_of_expeditious + overlay,
            name = "Expeditious bracelet",
            description = "",
            section = overlays
        ) default boolean expeditiousBraceletOverlay() { return true; }

        @ConfigItem(
            keyName = bracelet_of_flamtaer + overlay,
            name = "Flamtaer bracelet",
            description = "",
            section = overlays
        ) default boolean flamtaerBraceletOverlay() { return true; }

        @ConfigItem(
            keyName = bracelet_of_slaughter + overlay,
            name = "Bracelet of slaughter",
            description = "",
            section = overlays
        ) default boolean braceletOfSlaughterOverlay() { return true; }

        @ConfigItem(
            keyName = camulet + overlay,
            name = "Camulet",
            description = "",
            section = overlays
        ) default boolean camuletOverlay() { return true; }

        @ConfigItem(
            keyName = celestial_ring + overlay,
            name = "Celestial ring",
            description = "",
            section = overlays
        ) default boolean celestialRingOverlay() { return true; }

        @ConfigItem(
            keyName = chronicle + overlay,
            name = "Chronicle",
            description = "",
            section = overlays
        ) default boolean chronicleOverlay() { return true; }

        @ConfigItem(
            keyName = circlet_of_water + overlay,
            name = "Circlet of water",
            description = "",
            section = overlays
        ) default boolean circletOfWaterOverlay() { return true; }

        @ConfigItem(
            keyName = coal_bag + overlay,
            name = "Coal bag",
            description = "",
            section = overlays
        ) default boolean coalBagOverlay() { return true; }

        @ConfigItem(
            keyName = colossal_pouch + overlay,
            name = "Colossal pouch",
            description = "",
            section = overlays
        ) default boolean colossalPouchOverlay() { return true; }

        @ConfigItem(
            keyName = coffin + overlay,
            name = "Coffin",
            description = "",
            section = overlays
        ) default boolean coffinOverlay() { return true; }

        @ConfigItem(
            keyName = crystal_body + overlay,
            name = "Crystal body",
            description = "",
            section = overlays
        ) default boolean crystalBodyOverlay() { return true; }

        @ConfigItem(
            keyName = crystal_helm + overlay,
            name = "Crystal helm",
            description = "",
            section = overlays
        ) default boolean crystalHelmOverlay() { return true; }

        @ConfigItem(
            keyName = crystal_legs + overlay,
            name = "Crystal legs",
            description = "",
            section = overlays
        ) default boolean crystalLegsOverlay() { return true; }

        @ConfigItem(
            keyName = crystal_saw + overlay,
            name = "Crystal saw",
            description = "",
            section = overlays
        ) default boolean crystalSawOverlay() { return true; }

        @ConfigItem(
            keyName = crystal_shield + overlay,
            name = "Crystal shield",
            description = "",
            section = overlays
        ) default boolean crystalShieldOverlay() { return true; }

        @ConfigItem(
            keyName = desert_amulet + overlay,
            name = "Desert amulet",
            description = "",
            section = overlays
        ) default boolean desertAmuletOverlay() { return true; }

        @ConfigItem(
            keyName = dragonfire_shield + overlay,
            name = "Dragonfire shield",
            description = "",
            section = overlays
        ) default boolean dragonfireShieldOverlay() { return true; }

        @ConfigItem(
            keyName = falador_shield + overlay,
            name = "Falador shield",
            description = "",
            section = overlays
        ) default boolean faladorShieldOverlay() { return true; }

        @ConfigItem(
            keyName = fur_pouch + overlay,
            name = "Fur pouch",
            description = "",
            section = overlays
        ) default boolean furPouchOverlay() { return true; }

        @ConfigItem(
            keyName = escape_crystal + overlay,
            name = "Escape crystal",
            description = "",
            section = overlays
        ) default boolean escapeCrystalOverlay() { return true; }

        @ConfigItem(
            keyName = explorers_ring + overlay,
            name = "Explorer's ring",
            description = "",
            section = overlays
        ) default boolean explorersRingOverlay() { return true; }

        @ConfigItem(
            keyName = dodgy_necklace + overlay,
            name = "Dodgy necklace",
            description = "",
            section = overlays
        ) default boolean dodgyNecklaceOverlay() { return true; }

        @ConfigItem(
            keyName = fish_barrel + overlay,
            name = "Fish barrel",
            description = "",
            section = overlays
        ) default boolean fishBarrelOverlay() { return true; }

        @ConfigItem(
            keyName = forestry_kit + overlay,
            name = "Forestry kit",
            description = "",
            section = overlays
        ) default boolean forestryKitOverlay() { return true; }

        @ConfigItem(
            keyName = fremennik_sea_boots + overlay,
            name = "Fremennik sea boots",
            description = "",
            section = overlays
        ) default boolean fremennikSeaBootsOverlay() { return true; }

        @ConfigItem(
            keyName = fungicide_spray + overlay,
            name = "Fungicide spray",
            description = "",
            section = overlays
        ) default boolean fungicideSprayOverlay() { return true; }

        @ConfigItem(
            keyName = gem_bag + overlay,
            name = "Gem bag",
            description = "",
            section = overlays
        ) default boolean gemBagOverlay() { return true; }

        @ConfigItem(
            keyName = gricollers_can + overlay,
            name = "Gricoller's can",
            description = "",
            section = overlays
        ) default boolean gricollersCanOverlay() { return true; }

        @ConfigItem(
            keyName = herb_sack + overlay,
            name = "Herb sack",
            description = "",
            section = overlays
        ) default boolean herbSackOverlay() { return true; }

        @ConfigItem(
            keyName = jar_generator + overlay,
            name = "Jar generator",
            description = "",
            section = overlays
        ) default boolean jarGeneratorOverlay() { return true; }

        @ConfigItem(
            keyName = kandarin_headgear + overlay,
            name = "Kandarin Headgear",
            description = "",
            section = overlays
        ) default boolean kandarinHeadgearOverlay() { return true; }

        @ConfigItem(
            keyName = kharedsts_memoirs + overlay,
            name = "Kharedst's memoirs",
            description = "",
            section = overlays
        ) default boolean kharedstsMemoirsOverlay() { return true; }

        @ConfigItem(
            keyName = kharedsts_memoirs + overlay,
            name = "Book of the dead",
            description = "",
            section = overlays
        ) default boolean bookOfTheDeadOverlay() { return true; }

        @ConfigItem(
            keyName = log_basket + overlay,
            name = "Log basket",
            description = "",
            section = overlays
        ) default boolean logBasketOverlay() { return true; }

        @ConfigItem(
            keyName = magic_cape + overlay,
            name = "Magic cape",
            description = "",
            section = overlays
        ) default boolean magicCapeOverlay() { return true; }

        @ConfigItem(
            keyName = meat_pouch + overlay,
            name = "Meat pouch",
            description = "",
            section = overlays
        ) default boolean meatPouchOverlay() { return true; }

        @ConfigItem(
            keyName = necklace_of_passage + overlay,
            name = "Necklace of passage",
            description = "",
            section = overlays
        ) default boolean necklaceOfPassageOverlay() { return true; }

        @ConfigItem(
            keyName = ogre_bellows + overlay,
            name = "Ogre bellows",
            description = "",
            section = overlays
        ) default boolean ogreBellowsOverlay() { return true; }

        @ConfigItem(
            keyName = phoenix_necklace + overlay,
            name = "Phoenix necklace",
            description = "",
            section = overlays
        ) default boolean phoenixNecklaceOverlay() { return true; }

        @ConfigItem(
            keyName = plank_sack + overlay,
            name = "Plank sack",
            description = "",
            section = overlays
        ) default boolean plankSackOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_recoil + overlay,
            name = "Ring of recoil",
            description = "",
            section = overlays
        ) default boolean ringOfRecoilOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_shadows + overlay,
            name = "Ring of shadows",
            description = "",
            section = overlays
        ) default boolean ringOfShadowsOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_suffering + overlay,
            name = "Ring of suffering",
            description = "",
            section = overlays
        ) default boolean ringOfSufferingOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_the_elements + overlay,
            name = "Ring of the elements",
            description = "",
            section = overlays
        ) default boolean ringOfTheElementsOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_endurance + overlay,
            name = "Ring of endurance",
            description = "",
            section = overlays
        ) default boolean ringOfEnduranceOverlay() { return true; }

        @ConfigItem(
            keyName = seed_box + overlay,
            name = "Seed box",
            description = "",
            section = overlays
        ) default boolean seedBoxOverlay() { return true; }

        @ConfigItem(
            keyName = slayer_ring + overlay,
            name = "Slayer ring",
            description = "",
            section = overlays
        ) default boolean slayerRingOverlay() { return true; }

        @ConfigItem(
            keyName = soul_bearer + overlay,
            name = "Soul bearer",
            description = "",
            section = overlays
        ) default boolean soulBearerOverlay() { return true; }

        @ConfigItem(
            keyName = strange_old_lockpick + overlay,
            name = "Strange old lockpick",
            description = "",
            section = overlays
        ) default boolean strangeOldLockpickOverlay() { return true; }

        @ConfigItem(
            keyName = tackle_box + overlay,
            name = "Tackle box",
            description = "",
            section = overlays
        ) default boolean tackleBoxOverlay() { return true; }

        @ConfigItem(
            keyName = teleport_crystal + overlay,
            name = "Teleport crystal",
            description = "",
            section = overlays
        ) default boolean teleportCrystalOverlay() { return true; }

        @ConfigItem(
            keyName = eternal_teleport_crystal + overlay,
            name = "Eternal teleport crystal",
            description = "",
            section = overlays
        ) default boolean eternalTeleportCrystalOverlay() { return true; }

        @ConfigItem(
            keyName = tome_of_fire + overlay,
            name = "Tome of fire",
            description = "",
            section = overlays
        ) default boolean tomeOfFireOverlay() { return true; }

        @ConfigItem(
            keyName = tome_of_water + overlay,
            name = "Tome of water",
            description = "",
            section = overlays
        ) default boolean tomeOfWaterOverlay() { return true; }

        @ConfigItem(
            keyName = venator_bow + overlay,
            name = "Venator bow",
            description = "",
            section = overlays
        ) default boolean venatorBowOverlay() { return true; }

        @ConfigItem(
            keyName = waterskin + overlay,
            name = "Waterskin",
            description = "",
            section = overlays
        ) default boolean waterskinOverlay() { return true; }

        @ConfigItem(
            keyName = western_banner + overlay,
            name = "Western banner",
            description = "",
            section = overlays
        ) default boolean westernBannerOverlay() { return true; }

        @ConfigItem(
            keyName = bryophytas_staff + overlay,
            name = "Bryophyta's staff",
            description = "",
            section = overlays
        ) default boolean bryophytasStaffOverlay() { return true; }

        @ConfigItem(
            keyName = crystal_bow + overlay,
            name = "Crystal bow",
            description = "",
            section = overlays
        ) default boolean crystalBowOverlay() { return true; }

        @ConfigItem(
            keyName = crystal_halberd + overlay,
            name = "Crystal halberd",
            description = "",
            section = overlays
        ) default boolean crystalHalberdOverlay() { return true; }

        @ConfigItem(
            keyName = enchanted_lyre + overlay,
            name = "Enchanted Lyre",
            description = "",
            section = overlays
        ) default boolean enchantedLyreOverlay() { return true; }

        @ConfigItem(
            keyName = ibans_staff + overlay,
            name = "Iban's staff",
            description = "",
            section = overlays
        ) default boolean ibansStaffOverlay() { return true; }

        @ConfigItem(
            keyName = pharaohs_sceptre + overlay,
            name = "Pharaoh's sceptre",
            description = "",
            section = overlays
        ) default boolean pharaohsSceptreOverlay() { return true; }

        @ConfigItem(
            keyName = quetzal_whistle + overlay,
            name = "Quetzal whistle",
            description = "",
            section = overlays
        ) default boolean quetzalWhistleOverlay() { return true; }

        @ConfigItem(
            keyName = sanguinesti_staff + overlay,
            name = "Sanguinesti staff",
            description = "",
            section = overlays
        ) default boolean sanguinestiStaffOverlay() { return true; }

        @ConfigItem(
            keyName = skull_sceptre + overlay,
            name = "Skull sceptre",
            description = "",
            section = overlays
        ) default boolean skullSceptreOverlay() { return true; }

        @ConfigItem(
            keyName = slayer_staff_e + overlay,
            name = "Slayer staff (e)",
            description = "",
            section = overlays
        ) default boolean slayerStaffEOverlay() { return true; }

        @ConfigItem(
            keyName = toxic_staff_of_the_dead + overlay,
            name = "Toxic staff of the dead",
            description = "",
            section = overlays
        ) default boolean toxicStaffOfTheDeadOverlay() { return true; }

        @ConfigItem(
            keyName = trident_of_the_seas + overlay,
            name = "Trident of the seas",
            description = "",
            section = overlays
        ) default boolean tridentOfTheSeasOverlay() { return true; }

        @ConfigItem(
            keyName = warped_sceptre + overlay,
            name = "Warped sceptre",
            description = "",
            section = overlays
        ) default boolean warpedSceptreOverlay() { return true; }

        @ConfigItem(
            keyName = xerics_talisman + overlay,
            name = "Xeric's talisman",
            description = "",
            section = overlays
        ) default boolean xericsTalismanOverlay() { return true; }

        @ConfigItem(
                keyName = alchemists_amulet + overlay,
                name = "Alchemist's Amulet",
                description = "",
                section = overlays
        ) default boolean alchemistsAmuletOverlay() { return true; }

    @ConfigSection(
        name = "Debug",
        description = "Values of charges for all items under the hood",
        position = 99,
        closedByDefault = true
    ) String debug = "debug";

        @ConfigItem(
            keyName = version,
            name = version,
            description = "Version of the plugin for update message",
            section = debug,
            position = 1
        ) default String getVersion() { return ""; }

        @ConfigItem(
            keyName = date,
            name = "Date",
            description = "Date to check for charges reset when logging in",
            section = debug,
            position = 2
        ) default String getResetDate() { return ""; }

        @ConfigItem(
            keyName = storage_bank,
            name = storage_bank,
            description = "All player bank items to check for daily resets",
            section = debug,
            position = 3
        ) default String getStorageBank() { return ""; }

        @ConfigItem(
            keyName = storage_inventory,
            name = storage_inventory,
            description = "All player inventory items to check for daily resets",
            section = debug,
            position = 4
        ) default String getStorageInventory() { return ""; }

        @ConfigItem(
            keyName = storage_equipment,
            name = storage_equipment,
            description = "All player equipment items to check for daily resets",
            section = debug,
            position = 5
        ) default String getStorageEquipment() { return ""; }

        @ConfigItem(
            keyName = debug_ids,
            name = "Debug IDs",
            description = "Shows animation and graphics ids within ingame messages to add support for new items",
            section = debug,
            position = 6
        ) default boolean showDebugIds() { return false; }

        @ConfigItem(
            keyName = ring_of_pursuit,
            name = ring_of_pursuit,
            description = ring_of_pursuit,
            section = debug
        ) default int ringOfPursuitCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = arclight,
            name = arclight,
            description = arclight,
            section = debug
        ) default int getArclightCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ash_sanctifier,
            name = ash_sanctifier,
            description = ash_sanctifier,
            section = debug
        ) default int getAshSanctifierCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ash_sanctifier_status,
            name = ash_sanctifier_status,
            description = ash_sanctifier_status,
            section = debug
        ) default ItemActivity getAshSanctifierStatus() { return ItemActivity.ACTIVATED; }

        @ConfigItem(
            keyName = binding_necklace,
            name = binding_necklace,
            description = binding_necklace,
            section = debug
        ) default int getBindingNecklaceCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = bonecrusher,
            name = bonecrusher,
            description = bonecrusher,
            section = debug
        ) default int getBoneCrusherCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = bonecrusher_status,
            name = bonecrusher_status,
            description = bonecrusher_status,
            section = debug
        ) default ItemActivity getBoneCrusherStatus() { return ItemActivity.ACTIVATED; }

        @ConfigItem(
            keyName = kharedsts_memoirs,
            name = kharedsts_memoirs,
            description = kharedsts_memoirs,
            section = debug
        ) default int getKharedstsMemoirsCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = bottomless_compost_bucket + "_storage",
            name = bottomless_compost_bucket + "_storage",
            description = bottomless_compost_bucket + "_storage",
            section = debug
        ) default String getBottomlessCompostBucketStorage() { return ""; }

        @ConfigItem(
            keyName = bracelet_of_slaughter,
            name = bracelet_of_slaughter,
            description = bracelet_of_slaughter,
            section = debug
        ) default int getBraceletOfSlaughterCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = bryophytas_staff,
            name = bryophytas_staff,
            description = bryophytas_staff,
            section = debug
        ) default int getBryophytasStaffCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = celestial_ring,
            name = celestial_ring,
            description = celestial_ring,
            section = debug
        ) default int getCelestialRingCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = chronicle,
            name = chronicle,
            description = chronicle,
            section = debug
        ) default int getChronicleCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = crystal_shield,
            name = crystal_shield,
            description = crystal_shield,
            section = debug
        ) default int getCrystalShieldCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = crystal_bow,
            name = crystal_bow,
            description = crystal_bow,
            section = debug
        ) default int getCrystalBowCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = bracelet_of_expeditious,
            name = bracelet_of_expeditious,
            description = bracelet_of_expeditious,
            section = debug
        ) default int getBraceletOfExpeditiousCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = falador_shield,
            name = falador_shield,
            description = falador_shield,
            section = debug
        ) default int getFaladorShieldCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = fish_barrel,
            name = fish_barrel,
            description = fish_barrel,
            section = debug
        ) default int getFishBarrelCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = gricollers_can,
            name = gricollers_can,
            description = gricollers_can,
            section = debug
        ) default int getGricollersCanCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ibans_staff,
            name = ibans_staff,
            description = ibans_staff,
            section = debug
        ) default int getIbansStaffCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = pharaohs_sceptre,
            name = pharaohs_sceptre,
            description = pharaohs_sceptre,
            section = debug
        ) default int getPharaohsSceptreCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ring_of_suffering,
            name = ring_of_suffering,
            description = ring_of_suffering,
            section = debug
        ) default int getRingOfSufferingCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ring_of_suffering_status,
            name = ring_of_suffering_status,
            description = ring_of_suffering_status,
            section = debug
        ) default ItemActivity getRingOfSufferingStatus() { return ItemActivity.ACTIVATED; }

        @ConfigItem(
            keyName = sanguinesti_staff,
            name = sanguinesti_staff,
            description = sanguinesti_staff,
            section = debug
        ) default int getSanguinestiStaffCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = skull_sceptre,
            name = skull_sceptre,
            description = skull_sceptre,
            section = debug
        ) default int getSkullSceptreCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = soul_bearer,
            name = soul_bearer,
            description = soul_bearer,
            section = debug
        ) default int getSoulBearerCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = trident_of_the_seas,
            name = trident_of_the_seas,
            description = trident_of_the_seas,
            section = debug
        ) default int getTridentOfTheSeasCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = xerics_talisman,
            name = xerics_talisman,
            description = xerics_talisman,
            section = debug
        ) default int getXericsTalismanCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = dragonfire_shield,
            name = dragonfire_shield,
            description = dragonfire_shield,
            section = debug
        ) default int getDragonfireShieldCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = camulet,
            name = camulet,
            description = camulet,
            section = debug
        ) default int getCamuletCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = circlet_of_water,
            name = circlet_of_water,
            description = circlet_of_water,
            section = debug
        ) default int getCircletOfWaterCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = teleport_crystal,
            name = teleport_crystal,
            description = teleport_crystal,
            section = debug
        ) default int getTeleportCrystalCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = bracelet_of_clay,
            name = bracelet_of_clay,
            description = bracelet_of_clay,
            section = debug
        ) default int getBraceletOfClayCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = coffin,
            name = coffin,
            description = coffin,
            section = debug
        ) default int getCoffinCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = huntsmans_kit + "_storage",
            name = huntsmans_kit + "_storage",
            description = huntsmans_kit + "_storage",
            section = debug
        ) default String getHuntsmansKitStorage() { return ""; }

        @ConfigItem(
            keyName = log_basket + "_storage",
            name = log_basket + "_storage",
            description = log_basket + "_storage",
            section = debug
        ) default String getLogBasketStorage() { return ""; }

        @ConfigItem(
            keyName = forestry_kit + "_storage",
            name = forestry_kit + "_storage",
            description = forestry_kit + "_storage",
            section = debug
        ) default String getForestryKitStorage() { return ""; }

        @ConfigItem(
            keyName = ardougne_cloak,
            name = ardougne_cloak,
            description = ardougne_cloak,
            section = debug
        ) default int getArdougneCloakCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = magic_cape,
            name = magic_cape,
            description = magic_cape,
            section = debug
        ) default int getMagicCapeCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = meat_pouch + "_storage",
            name = meat_pouch + "_storage",
            description = meat_pouch + "_storage",
            section = debug
        ) default String getMeatPouchStorageCharges() { return ""; }

        @ConfigItem(
            keyName = gem_bag + "_storage",
            name = gem_bag + "_storage",
            description = gem_bag + "_storage",
            section = debug
        ) default String getGemBagStorageCharges() { return ""; }

        @ConfigItem(
            keyName = seed_box,
            name = seed_box,
            description = seed_box,
            section = debug
        ) default int getSeedBoxCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = seed_box + "_storage",
            name = seed_box + "_storage",
            description = seed_box + "_storage",
            section = debug
        ) default String getSeedBoxStorage() { return ""; }

        @ConfigItem(
            keyName = crystal_helm,
            name = crystal_helm,
            description = crystal_helm,
            section = debug
        ) default int getCrystalHelmCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = crystal_body,
            name = crystal_body,
            description = crystal_body,
            section = debug
        ) default int getCrystalBodyCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = crystal_legs,
            name = crystal_legs,
            description = crystal_legs,
            section = debug
        ) default int getCrystalLegsCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = crystal_halberd,
            name = crystal_halberd,
            description = crystal_halberd,
            section = debug
        ) default int getCrystalHalberdCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ring_of_shadows,
            name = ring_of_shadows,
            description = ring_of_shadows,
            section = debug
        ) default int getRingOfShadowsCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = coal_bag,
            name = coal_bag,
            description = coal_bag,
            section = debug
        ) default int getCoalBagCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = colossal_pouch + "_storage",
            name = colossal_pouch + "_storage",
            description = colossal_pouch + "_storage",
            section = debug
        ) default String getColossalPouchStorage() { return ""; }

        @ConfigItem(
            keyName = colossal_pouch_decay_count,
            name = colossal_pouch_decay_count,
            description = "Colossal pouch decay count",
            section = debug
        ) default int getColossalPouchDecayCount() { return 0; };

        @ConfigItem(
            keyName = herb_sack + "_storage",
            name = herb_sack + "_storage",
            description = herb_sack + "_storage",
            section = debug
        ) default String getHerbSackStorage() { return ""; }

        @ConfigItem(
            keyName = escape_crystal_status,
            name = escape_crystal_status,
            description = escape_crystal_status,
            section = debug
        ) default ItemActivity getEscapeCrystalStatus() { return ItemActivity.DEACTIVATED; }

        @ConfigItem(
            keyName = escape_crystal_inactivity_period,
            name = escape_crystal_inactivity_period,
            description = escape_crystal_inactivity_period,
            section = debug
        ) default int getEscapeCrystalInactivityPeriod() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = strange_old_lockpick,
            name = strange_old_lockpick,
            description = strange_old_lockpick,
            section = debug
        ) default int getStrangeOldLockCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = desert_amulet,
            name = desert_amulet,
            description = desert_amulet,
            section = debug
        ) default int getDesertAmuletCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = tome_of_fire,
            name = tome_of_fire,
            description = tome_of_fire,
            section = debug
        ) default int getTomeOfFireCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = dodgy_necklace,
            name = dodgy_necklace,
            description = dodgy_necklace,
            section = debug
        ) default int getDodgyNecklaceCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = kandarin_headgear,
            name = kandarin_headgear,
            description = kandarin_headgear,
            section = debug
        ) default int getKandarinHeadgearCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = fremennik_sea_boots,
            name = fremennik_sea_boots,
            description = fremennik_sea_boots,
            section = debug
        ) default int getFremennikSeaBootsCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = fur_pouch + "_storage",
            name = fur_pouch + "_storage",
            description = fur_pouch + "_storage",
            section = debug
        ) default String getFurPouchStorageCharges() { return ""; }

        @ConfigItem(
            keyName = jar_generator,
            name = jar_generator,
            description = jar_generator,
            section = debug
        ) default int getJarGeneratorCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = explorers_ring + "_storage",
            name = explorers_ring + "_storage",
            description = explorers_ring + "_storage",
            section = debug
        ) default String getExplorersRingCharges() { return ""; }

        @ConfigItem(
            keyName = enchanted_lyre,
            name = enchanted_lyre,
            description = enchanted_lyre,
            section = debug
        ) default int getEnchantedLyreCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ring_of_the_elements,
            name = ring_of_the_elements,
            description = ring_of_the_elements,
            section = debug
        ) default int getRingOfElementsCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ring_of_endurance,
            name = ring_of_endurance,
            description = ring_of_endurance,
            section = debug
        ) default int getRingOfEnduranceCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = plank_sack,
            name = plank_sack,
            description = plank_sack,
            section = debug
        ) default int getPlankSackCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = slayer_staff_e,
            name = slayer_staff_e,
            description = slayer_staff_e,
            section = debug
        ) default int getSlayerStaffECharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = warped_sceptre,
            name = warped_sceptre,
            description = warped_sceptre,
            section = debug
        ) default int getWarpedSceptreCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = crystal_saw,
            name = crystal_saw,
            description = crystal_saw,
            section = debug
        ) default int getCrystalSawCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = quetzal_whistle,
            name = quetzal_whistle,
            description = quetzal_whistle,
            section = debug
        ) default int getQuetzalWhistleCharges() { return Charges.UNKNOWN; }
}

package tictac7x.charges;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TicTac7xChargesPluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(TicTac7xChargesImprovedPlugin.class);
		RuneLite.main(args);
	}
}
