package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnWidgetLoaded;
import tictac7x.charges.item.triggers.TriggerBase;

import java.util.Optional;
import java.util.regex.Matcher;

import static tictac7x.charges.TicTac7xChargesImprovedPlugin.getNumberFromCommaString;

public class ListenerOnWidgetLoaded extends ListenerBase {
    public ListenerOnWidgetLoaded(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final WidgetLoaded event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;

            boolean triggerUsed = false;
            final OnWidgetLoaded trigger = (OnWidgetLoaded) triggerBase;
            final Optional<Widget> widget = TicTac7xChargesImprovedPlugin.getWidget(client, trigger.groupId, trigger.childId, trigger.subChildId);
            if (!widget.isPresent()) continue;

            if (trigger.text.isPresent()) {
                final String text = TicTac7xChargesImprovedPlugin.getCleanText(widget.get().getText());
                final Matcher matcher = trigger.text.get().matcher(text);
                matcher.find();

                if (trigger.setDynamically.isPresent()) {
                    ((ChargedItem) chargedItem).setCharges(getNumberFromCommaString(matcher.group("charges")));
                    triggerUsed = true;
                }

                if (trigger.matcherConsumer.isPresent()) {
                    trigger.matcherConsumer.get().accept(matcher);
                    triggerUsed = true;
                }
            }

            if (trigger.widgetConsumer.isPresent()) {
                trigger.widgetConsumer.get().accept(widget.get());
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed && !trigger.multiTrigger) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final WidgetLoaded event) {
        if (!(triggerBase instanceof OnWidgetLoaded)) return false;
        final OnWidgetLoaded trigger = (OnWidgetLoaded) triggerBase;

        // Widget group check.
        if (event.getGroupId() != trigger.groupId) {
            return false;
        }

        // Widget existance check.
        final Optional<Widget> widget = TicTac7xChargesImprovedPlugin.getWidget(client, trigger.groupId, trigger.childId, trigger.subChildId);
        if (!widget.isPresent()) {
            return false;
        }

        // Text check.
        if (trigger.text.isPresent()) {
            final Matcher matcher = trigger.text.get().matcher(TicTac7xChargesImprovedPlugin.getCleanText(widget.get().getText()));
            if (!matcher.find()) {
                return false;
            }
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnCombat;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnCombat extends ListenerBase {
    private int ticksInCombat = 0;

    public ListenerOnCombat(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger() {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase)) continue;
            final OnCombat trigger = (OnCombat) triggerBase;
            boolean triggerUsed = false;

            if (trigger.ticksInCombat == ticksInCombat) {
                triggerUsed = true;
                ticksInCombat = 0;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase) {
        if (!(triggerBase instanceof OnCombat)) return false;

        // Ticks check.
        if (++ticksInCombat != ((OnCombat) triggerBase).ticksInCombat) {
            return false;
        }

        return super.isValidTrigger(triggerBase);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.api.events.StatChanged;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnStatChanged;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnStatChanged extends ListenerBase {
    public ListenerOnStatChanged(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final StatChanged event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnStatChanged trigger = (OnStatChanged) triggerBase;
            boolean triggerUsed = false;

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final StatChanged event) {
        if (!(triggerBase instanceof OnStatChanged)) return false;
        final OnStatChanged trigger = (OnStatChanged) triggerBase;
        final Skill skill = event.getSkill();

        // Skill check.
        if (trigger.skill != skill) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.HitsplatID;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.customEvents.CustomHitsplatApplied;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.store.WeaponAttackStyle;
import tictac7x.charges.store.HitsplatGroup;
import tictac7x.charges.store.HitsplatTarget;

public class ListenerOnHitsplatApplied extends ListenerBase {
    private final WeaponAttackStyle weaponAttackStyle;

    public ListenerOnHitsplatApplied(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);

        this.weaponAttackStyle = new WeaponAttackStyle(client);
    }

    public void trigger(final CustomHitsplatApplied event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnHitsplatApplied trigger = (OnHitsplatApplied) triggerBase;
            boolean triggerUsed = false;

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed && !trigger.multiTrigger) {
                // Once per game tick check.
                if (trigger.oncePerGameTick.isPresent()) {
                    trigger.triggerTick = client.getTickCount();
                }

                return;
            }
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final CustomHitsplatApplied event) {
        if (!(triggerBase instanceof OnHitsplatApplied)) return false;
        final OnHitsplatApplied trigger = (OnHitsplatApplied) triggerBase;

        // Hitsplat caused by other player check.
        if (!event.byMe) {
            return false;
        }

        // Hitsplat self check.
        if (trigger.hitsplatTarget == HitsplatTarget.SELF && !event.toMe) {
            return false;
        }

        // Hitsplat enemy check.
        if (trigger.hitsplatTarget == HitsplatTarget.ENEMY && event.toMe) {
            return false;
        }

        // All hitsplat check.
        if (trigger.hitsplatGroup == HitsplatGroup.ALL) {
            if (
                event.type != HitsplatID.DAMAGE_ME &&
                event.type != HitsplatID.DAMAGE_MAX_ME &&
                event.type != HitsplatID.BLOCK_ME
            ) {
                return false;
            }
        }

        // Successful hitsplat check.
        if (trigger.hitsplatGroup == HitsplatGroup.SUCCESSFUL) {
            if (
                event.type != HitsplatID.DAMAGE_ME &&
                event.type != HitsplatID.DAMAGE_MAX_ME
            ) {
                return false;
            }
        }

        // More than zero damage.
        if (trigger.moreThanZeroDamage.isPresent() && event.amount == 0) {
            return false;
        }

        // Name check.
        if (trigger.hasTargetName.isPresent() && (event.actor.getName() == null || !event.actor.getName().equals(trigger.hasTargetName.get()))) {
            return false;
        }

        // Once per game tick check.
        if (trigger.oncePerGameTick.isPresent() && client.getTickCount() == trigger.triggerTick) {
            return false;
        }

        // Attack style check.
        if (trigger.combatStyle.isPresent() && weaponAttackStyle.getCombatStyle() != trigger.combatStyle.get()) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.StatChanged;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnGameTick;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnGameTick extends ListenerBase {
    public ListenerOnGameTick(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final GameTick gameTick) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, gameTick)) continue;
            final OnGameTick trigger = (OnGameTick) triggerBase;
            boolean triggerUsed = false;

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final GameTick event) {
        if (!(triggerBase instanceof OnGameTick)) return false;
        final OnGameTick trigger = (OnGameTick) triggerBase;

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnMenuOptionClicked;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.customEvents.CustomMenuOptionClicked;

public class ListenerOnMenuOptionClicked extends ListenerBase {
    public ListenerOnMenuOptionClicked(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final CustomMenuOptionClicked event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnMenuOptionClicked trigger = (OnMenuOptionClicked) triggerBase;
            boolean triggerUsed = false;

            if (trigger.menuOptionConsumer.isPresent()) {
                trigger.menuOptionConsumer.get().accept(event);
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final CustomMenuOptionClicked event) {
        if (!(triggerBase instanceof OnMenuOptionClicked)) return false;
        final OnMenuOptionClicked trigger = (OnMenuOptionClicked) triggerBase;

        // Option check.
        boolean optionCheck = false;
        for (final String option : trigger.options) {
            if (event.option.equals(option)) {
                optionCheck = true;
                break;
            }
        }
        if (!optionCheck) return false;

        // Item id check.
        if (trigger.hasItemId.isPresent() && event.itemId != trigger.hasItemId.get()) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnScriptPreFired;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnScriptPreFired extends ListenerBase {
    public ListenerOnScriptPreFired(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final ScriptPreFired event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnScriptPreFired trigger = (OnScriptPreFired) triggerBase;
            boolean triggerUsed = false;

            if (trigger.scriptConsumer.isPresent()) {
                trigger.scriptConsumer.get().accept(event);
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final ScriptPreFired event) {
        if (!(triggerBase instanceof OnScriptPreFired)) return false;
        final OnScriptPreFired trigger = (OnScriptPreFired) triggerBase;

        // Id check.
        if (trigger.scriptId != event.getScriptId()) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.events.AnimationChanged;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnAnimationChanged;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnAnimationChanged extends ListenerBase {
    public ListenerOnAnimationChanged(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final AnimationChanged event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;

            final OnAnimationChanged trigger = (OnAnimationChanged) triggerBase;
            boolean triggerUsed = false;

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final AnimationChanged event) {
        if (!(triggerBase instanceof OnAnimationChanged)) return false;
        final OnAnimationChanged trigger = (OnAnimationChanged) triggerBase;

        // Player check.
        if (event.getActor() != client.getLocalPlayer()) {
            return false;
        }

        // Animation id check.
        animationIdCheck: if (trigger.animationId != null) {
            for (final int animationId : trigger.animationId) {
                if (event.getActor().getAnimation() == animationId) {
                    break animationIdCheck;
                }
            }

            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.events.ItemDespawned;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.OnItemPickup;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnItemPickup extends ListenerBase {
    public ListenerOnItemPickup(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final ItemDespawned event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;

            final OnItemPickup trigger = (OnItemPickup) triggerBase;
            boolean triggerUsed = false;

            if (trigger.pickUpToStorage.isPresent()) {
                ((ChargedItemWithStorage) chargedItem).storage.add(event.getItem().getId(), event.getItem().getQuantity());
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final ItemDespawned event) {
        if (!(triggerBase instanceof OnItemPickup)) return false;
        if (!(chargedItem instanceof ChargedItemWithStorage)) return false;
        final OnItemPickup trigger = (OnItemPickup) triggerBase;
        final ChargedItemWithStorage chargedItem = (ChargedItemWithStorage) this.chargedItem;

        // Correct item check.
        boolean correctItem = false;
        for (final StorageItem storageItem : chargedItem.storage.getStorableItems()) {
            if (event.getItem().getId() == storageItem.getId()) {
                correctItem = true;
                break;
            }
        }
        if (!correctItem) {
            return false;
        }

        // By one check.
        if (trigger.isByOne.isPresent() && trigger.isByOne.get() && event.getItem().getQuantity() > 1) {
            return false;
        }

        // Menu option check.
        if (!chargedItem.store.inMenuOptions("Take")) {
            return false;
        }

        // Menu target check.
        if (!chargedItem.store.inMenuTargets(event.getItem().getId())) {
            return false;
        }

        // Player location check.
        if (client.getLocalPlayer().getWorldLocation().distanceTo(event.getTile().getWorldLocation()) > 1) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnUserAction;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnUserAction extends ListenerBase {
    public ListenerOnUserAction(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger() {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase)) continue;

            final OnUserAction trigger = (OnUserAction) triggerBase;
            boolean triggerUsed = false;

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase) {
        if (!(triggerBase instanceof OnUserAction)) return false;

        final OnUserAction trigger = (OnUserAction) triggerBase;
        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnVarbitChanged;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnVarbitChanged extends ListenerBase {
    public ListenerOnVarbitChanged(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final VarbitChanged event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnVarbitChanged trigger = (OnVarbitChanged) triggerBase;
            boolean triggerUsed = false;

            // Set dynamically.
            if (trigger.setDynamically.isPresent() && chargedItem instanceof ChargedItem) {
                ((ChargedItem) chargedItem).setCharges(event.getValue());
            }

            // Varbit value consumer.
            if (trigger.varbitValueConsumer.isPresent()) {
                trigger.varbitValueConsumer.get().accept(event.getValue());
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final VarbitChanged event) {
        if (!(triggerBase instanceof OnVarbitChanged)) return false;
        final OnVarbitChanged trigger = (OnVarbitChanged) triggerBase;

        // Varbit id check.
        if (event.getVarbitId() != trigger.varbitId) {
            return false;
        }

        // Varbit value check.
        if (trigger.varbitValue.isPresent() && event.getValue() != trigger.varbitValue.get()) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.customEvents.CustomChatMessage;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;

import java.util.regex.Matcher;

import static tictac7x.charges.TicTac7xChargesImprovedPlugin.getNumberFromCommaString;

public class ListenerOnChatMessage extends ListenerBase {
    public ListenerOnChatMessage(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final CustomChatMessage event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            boolean triggerUsed = false;
            final OnChatMessage trigger = (OnChatMessage) triggerBase;

            final Matcher matcher = trigger.message.matcher(event.message);
            matcher.find();

            if (trigger.setDynamically.isPresent() && (chargedItem instanceof ChargedItem)) {
                ((ChargedItem) chargedItem).setCharges(getNumberFromCommaString(matcher.group("charges")));
                triggerUsed = true;
            }

            if (trigger.increaseDynamically.isPresent() && (chargedItem instanceof ChargedItem)) {
                ((ChargedItem) chargedItem).increaseCharges(getNumberFromCommaString(matcher.group("charges")));
                triggerUsed = true;
            }

            if (trigger.decreaseDynamically.isPresent() && (chargedItem instanceof ChargedItem)) {
                ((ChargedItem) chargedItem).decreaseCharges(getNumberFromCommaString(matcher.group("charges")));
                triggerUsed = true;
            }

            if (trigger.useDifference.isPresent() && (chargedItem instanceof ChargedItem)) {
                ((ChargedItem) chargedItem).setCharges(getNumberFromCommaString(matcher.group("total")) - getNumberFromCommaString(matcher.group("used")));
                triggerUsed = true;
            }

            if (trigger.matcherConsumer.isPresent()) {
                trigger.matcherConsumer.get().accept(matcher);
                triggerUsed = true;
            }

            if (trigger.stringConsumer.isPresent()) {
                trigger.stringConsumer.get().accept(event.message);
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final CustomChatMessage event) {
        if (!(triggerBase instanceof OnChatMessage)) return false;
        final OnChatMessage trigger = (OnChatMessage) triggerBase;

        // Message check.
        final Matcher matcher = trigger.message.matcher(event.message);
        if (!matcher.find()) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.events.GraphicChanged;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnGraphicChanged extends ListenerBase {
    public ListenerOnGraphicChanged(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final GraphicChanged event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnGraphicChanged trigger = (OnGraphicChanged) triggerBase;
            boolean triggerUsed = false;

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final GraphicChanged event) {
        if (!(triggerBase instanceof OnGraphicChanged)) return false;
        final OnGraphicChanged trigger = (OnGraphicChanged) triggerBase;

        // Player check.
        if (event.getActor() != client.getLocalPlayer()) {
            return false;
        }

        // Graphic id check.
        graphicIdCheck: if (trigger.graphicId != null) {
            for (final int graphicId : trigger.graphicId) {
                if (event.getActor().hasSpotAnim(graphicId)) {
                    break graphicIdCheck;
                }
            }

            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnResetDaily extends ListenerBase {
    public ListenerOnResetDaily(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public boolean trigger() {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase)) continue;
            final OnResetDaily trigger = (OnResetDaily) triggerBase;
            boolean triggerUsed = false;

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return true;
        }

        return false;
    }

    public boolean isValidTrigger(final TriggerBase triggerBase) {
        if (!(triggerBase instanceof OnResetDaily)) return false;
        final OnResetDaily trigger = (OnResetDaily) triggerBase;

        if (trigger.resetSpecificItem.isPresent() && !chargedItem.store.itemInPossession(trigger.resetSpecificItem.get())) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.ReplaceTarget;

import java.util.ArrayList;
import java.util.List;

public class ListenerOnMenuEntryAdded extends ListenerBase {
    public ListenerOnMenuEntryAdded(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final MenuEntryAdded event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) {
                continue;
            };
            final OnMenuEntryAdded trigger = (OnMenuEntryAdded) triggerBase;
            boolean triggerUsed = false;

            if (trigger.replaceOption.isPresent()) {
                event.getMenuEntry().setOption(trigger.replaceOption.get());
                triggerUsed = true;
            }

            if (trigger.replaceOptionConsumer.isPresent()) {
                try {
                    event.getMenuEntry().setOption(trigger.replaceOptionConsumer.get().call());
                    triggerUsed = true;
                } catch (final Exception ignored) {}
            }

            if (trigger.replaceTargets.isPresent()) {
                for (final ReplaceTarget replaceTarget : trigger.replaceTargets.get()) {
                    if (event.getTarget().contains(replaceTarget.target)) {
                        event.getMenuEntry().setTarget(event.getTarget().replaceAll(replaceTarget.target, replaceTarget.replace));
                        triggerUsed = true;
                        break;
                    }
                }
            }

            if (trigger.replaceTargetDynamically.isPresent() && event.getTarget().contains(trigger.replaceTargetDynamically.get().target)) {
                try {
                    event.getMenuEntry().setTarget(event.getTarget().replaceAll(trigger.replaceTargetDynamically.get().target, trigger.replaceTargetDynamically.get().replace.call()));
                } catch (final Exception ignored) {}
                triggerUsed = true;
            }

            if (trigger.hide.isPresent() && trigger.menuEntryOption.isPresent()) {
                final List<MenuEntry> newMenuEntries = new ArrayList<>();

                for (final MenuEntry entry : client.getMenuEntries()) {
                    if (!entry.getOption().equals(trigger.menuEntryOption.get())) {
                        newMenuEntries.add(entry);
                    }
                }

                client.setMenuEntries(newMenuEntries.toArray(new MenuEntry[0]));
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final MenuEntryAdded event) {
        if (!(triggerBase instanceof OnMenuEntryAdded)) return false;
        final OnMenuEntryAdded trigger = (OnMenuEntryAdded) triggerBase;

        // Check base triggers to avoid calling impostor id getters on client.
        impostorIdsTargetCheck: if (trigger.replaceImpostorIds.isPresent() && trigger.onMenuTarget.isPresent()) {
            for (final String target : trigger.onMenuTarget.get()) {
                if (event.getTarget().contains(target)) {
                    break impostorIdsTargetCheck;
                }
            }

            if (!super.isValidTrigger(trigger)) {
                return false;
            }
        }

        // Item id check.
        if (!trigger.replaceImpostorIds.isPresent()) {
            boolean idCheck = false;

            for (final TriggerItem item : chargedItem.items) {
                if (item.itemId == event.getMenuEntry().getItemId()) {
                    idCheck = true;
                    break;
                }
            }

            if (!idCheck) {
                return false;
            }
        }

        // Hide config check.
        if (trigger.hide.isPresent() && !config.hideDestroy()) {
            return false;
        }

        // Menu entry option check.
        if (trigger.menuEntryOption.isPresent() && !event.getOption().equals(trigger.menuEntryOption.get())) {
            return false;
        }

        // Menu target replace check.
        menuReplaceTargetsCheck: if (trigger.replaceTargets.isPresent()) {
            for (final ReplaceTarget replaceTarget: trigger.replaceTargets.get()) {
                if (event.getTarget().contains(replaceTarget.target)) {
                    break menuReplaceTargetsCheck;
                }
            }

            return false;
        }

        // Menu replace impostor id check.
        replaceImpostorIdCheck: if (trigger.replaceImpostorIds.isPresent()) {
            for (final int impostorId : trigger.replaceImpostorIds.get()) {
                try {
                    if (client.getObjectDefinition(event.getMenuEntry().getIdentifier()).getImpostor().getId() == impostorId) {
                        break replaceImpostorIdCheck;
                    }
                } catch (final Exception ignored) {}
            }

            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.api.events.StatChanged;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;

public class ListenerOnXpDrop extends ListenerBase {
    public ListenerOnXpDrop(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final StatChanged event) {
        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, event)) continue;
            final OnXpDrop trigger = (OnXpDrop) triggerBase;
            boolean triggerUsed = false;

            if (trigger.xpAmountConsumer.isPresent()) {
                trigger.xpAmountConsumer.get().accept(event.getXp() - chargedItem.store.getSkillXp(trigger.skill).get());
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final StatChanged event) {
        if (!(triggerBase instanceof OnXpDrop)) return false;
        final OnXpDrop trigger = (OnXpDrop) triggerBase;
        final Skill skill = event.getSkill();

        // Skill check.
        if (trigger.skill != skill) {
            return false;
        }

        // XP drop check.
        if (
            !chargedItem.store.getSkillXp(skill).isPresent() ||
            chargedItem.store.getSkillXp(skill).get() == event.getXp()
        ) {
            return false;
        }

        // Amount check.
        if (trigger.amount.isPresent() && (
            !chargedItem.store.getSkillXp(trigger.skill).isPresent() ||
            trigger.amount.get() != (event.getXp() - chargedItem.store.getSkillXp(trigger.skill).get()))
        ) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.ChargedItemWithStatus;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.customEvents.CustomMenuOptionClicked;

import java.util.Optional;

public abstract class ListenerBase {
    protected final Client client;
    protected final ItemManager itemManager;
    protected final ChargedItemBase chargedItem;
    protected final Notifier notifier;
    protected final TicTac7xChargesImprovedConfig config;

    public ListenerBase(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        this.client = client;
        this.itemManager = itemManager;
        this.chargedItem = chargedItem;
        this.notifier = notifier;
        this.config = config;
    }

    boolean trigger(final TriggerBase trigger) {
        boolean triggerUsed = false;

        // Fixed charges.
        if (trigger.fixedCharges.isPresent() && (chargedItem instanceof ChargedItem)) {
            ((ChargedItem) chargedItem).setCharges(trigger.fixedCharges.get());
            triggerUsed = true;
        }

        // Increase charges.
        if (trigger.increaseCharges.isPresent() && (chargedItem instanceof ChargedItem)) {
            ((ChargedItem) chargedItem).increaseCharges(trigger.increaseCharges.get());
            triggerUsed = true;
        }

        // Decrease charges.
        if (trigger.decreaseCharges.isPresent() && (chargedItem instanceof ChargedItem)) {
            ((ChargedItem) chargedItem).decreaseCharges(trigger.decreaseCharges.get());
            triggerUsed = true;
        }

        // Empty storage.
        if (trigger.emptyStorage.isPresent() && (chargedItem instanceof ChargedItemWithStorage)) {
            ((ChargedItemWithStorage) chargedItem).storage.clear();
            triggerUsed = true;
        }

        // Empty storage to inventory.
        if (trigger.emptyStorageToInventory.isPresent() && (chargedItem instanceof ChargedItemWithStorage)) {
            ((ChargedItemWithStorage) chargedItem).storage.emptyToInventory();
            triggerUsed = true;
        }

        // Add to storage.
        if (trigger.addToStorage.isPresent() && (chargedItem instanceof ChargedItemWithStorage)) {
            ((ChargedItemWithStorage) chargedItem).storage.add(trigger.addToStorage.get()[0], trigger.addToStorage.get()[1]);
            triggerUsed = true;
        }

        // Consumer.
        if (trigger.consumer.isPresent()) {
            if (trigger.runConsumerOnNextGameTick.isPresent() && trigger.runConsumerOnNextGameTick.get()) {
                chargedItem.store.nextTickQueue.add(trigger.consumer.get());
            } else {
                trigger.consumer.get().run();
            }
            triggerUsed = true;
        }

        // Activate.
        if (trigger.activate.isPresent() && (chargedItem instanceof ChargedItemWithStatus)) {
            ((ChargedItemWithStatus) chargedItem).activate();
            triggerUsed = true;
        }

        // Deactivate.
        if (trigger.deactivate.isPresent() && (chargedItem instanceof ChargedItemWithStatus)) {
            ((ChargedItemWithStatus) chargedItem).deactivate();
            triggerUsed = true;
        }

        // Notification
        if (trigger.notificationCustom.isPresent()) {
            notifier.notify(trigger.notificationCustom.get());
            triggerUsed = true;
        }

        return triggerUsed;
    }

    boolean isValidTrigger(final TriggerBase trigger) {
        // Specific item check.
        specificItemCheck: if (trigger.requiredItem.isPresent()) {
            for (final int itemId : trigger.requiredItem.get()) {
                if (chargedItem.store.inventoryContainsItem(itemId) || chargedItem.store.equipmentContainsItem(itemId)) {
                    break specificItemCheck;
                }
            }
            return false;
        }

        // Unallowed items check.
        if (trigger.unallowedItem.isPresent()) {
            for (final int itemId : trigger.unallowedItem.get()) {
                if (chargedItem.store.inventoryContainsItem(itemId) || chargedItem.store.equipmentContainsItem(itemId)) {
                    return false;
                }
            }
        }

        // On item click check.
        if (trigger.onItemClick.isPresent() && chargedItem.store.notInMenuTargets(chargedItem.itemId)) {
            return false;
        }

        // Menu option check.
        if (trigger.onMenuOption.isPresent() && chargedItem.store.notInMenuOptions(trigger.onMenuOption.get())) {
            return false;
        }

        // Menu option ids check.
        if (trigger.onMenuOptionId.isPresent() && chargedItem.store.notInMenuOptionIds(trigger.onMenuOptionId.get())) {
            return false;
        }

        // Menu target check.
        if (trigger.onMenuTarget.isPresent() && !trigger.onHover && chargedItem.store.notInMenuTargets(trigger.onMenuTarget.get())) {
            return false;
        }

        // Menu impostor id check.
        if (trigger.onMenuImpostor.isPresent() && chargedItem.store.notInMenuImpostors(trigger.onMenuImpostor.get())) {
            return false;
        }

        // Equipped check.
        if (trigger.isEquipped.isPresent() && !chargedItem.store.equipmentContainsItem(chargedItem.itemId)) {
            return false;
        }

        // Use storage item on charged item check.
        if (trigger.onUseStorageItemOnChargedItem.isPresent() && chargedItem instanceof ChargedItemWithStorage) {
            boolean isValid = false;
            loopChecker: for (final CustomMenuOptionClicked menuEntry : chargedItem.store.menuOptionsClicked) {
                if (!menuEntry.target.contains(" -> ")) {
                    continue;
                };

                final String itemOne = menuEntry.target.split(" -> ")[0];
                final String itemTwo = menuEntry.target.split(" -> ")[1];

                if (!itemOne.equals(chargedItem.getItemName()) && !itemTwo.equals(chargedItem.getItemName())) {
                    continue;
                }
                for (final StorageItem storeableItem : ((ChargedItemWithStorage) chargedItem).storage.getStorableItems()) {
                    if (
                        itemOne.equals(itemManager.getItemComposition(storeableItem.getId()).getName()) ||
                        itemTwo.equals(itemManager.getItemComposition(storeableItem.getId()).getName())
                    ) {
                        isValid = true;
                        break loopChecker;
                    }
                }
            }

            if (!isValid) {
                return false;
            }
        }

        // Use charged item on storage item check.
        if (trigger.onUseChargedItemOnStorageItem.isPresent() && chargedItem instanceof ChargedItemWithStorage) {
            boolean useCheck = false;
            useCheckLooper: for (final CustomMenuOptionClicked menuEntry : chargedItem.store.menuOptionsClicked) {
                if (!menuEntry.option.equals("Use") || !menuEntry.target.contains(" -> ") || !menuEntry.target.split(" -> ")[0].equals(itemManager.getItemComposition(chargedItem.itemId).getName())) continue;

                for (final StorageItem storageItem : ((ChargedItemWithStorage) chargedItem).getStorage().getItems()) {
                    if (menuEntry.target.split(" -> ")[1].equals(itemManager.getItemComposition(storageItem.getId()).getName())) {
                        useCheck = true;
                        break useCheckLooper;
                    }
                }
            }
            if (!useCheck) {
                return false;
            }
        }

        // Activated check.
        if ((chargedItem instanceof ChargedItemWithStatus) && trigger.isActivated.isPresent() && trigger.isActivated.get() && !((ChargedItemWithStatus) chargedItem).isActivated()) {
            return false;
        }

        // Chat message check.
        if (trigger.hasChatMessage.isPresent()) {
            boolean matches = false;

            for (final String message : chargedItem.store.getLastChatMessages()) {
                if (trigger.hasChatMessage.get().matcher(message).find()) {
                    matches = true;
                    break;
                }
            }

            if (!matches) {
                return false;
            }
        }

        // Varbit check.
        if (trigger.varbitCheck.isPresent()) {
            if (client.getVarbitValue(trigger.varbitCheck.get()[0]) != trigger.varbitCheck.get()[1]) {
                return false;
            }
        }

        // Visible widget check.
        if (trigger.isWidgetVisible.isPresent()) {
            boolean widgetVisible = false;
            for (final int[] widgetIds : trigger.isWidgetVisible.get()) {
                final Optional<Widget> widget = TicTac7xChargesImprovedPlugin.getWidget(client, widgetIds[0], widgetIds[1]);
                if (widget.isPresent() && !widget.get().isHidden()) {
                    widgetVisible = true;
                    break;
                }
            }

            if (!widgetVisible) {
                return false;
            }
        }

        if (trigger.emptyStorageToInventory.isPresent() && !(chargedItem instanceof ChargedItemWithStorage)) {
            return false;
        }

        // Specific item equipped check.
        if (trigger.itemEquipped.isPresent() && !chargedItem.store.equipmentContainsItem(trigger.itemEquipped.get())) {
            return false;
        }

        return true;
    }
}

package tictac7x.charges.item.listeners;

import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.customEvents.CustomItemContainerChanged;
import tictac7x.charges.item.storage.StorageItems;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;

public class ListenerOnItemContainerChanged extends ListenerBase {
    public ListenerOnItemContainerChanged(final Client client, final ItemManager itemManager, final ChargedItemBase chargedItem, final Notifier notifier, final TicTac7xChargesImprovedConfig config) {
        super(client, itemManager, chargedItem, notifier, config);
    }

    public void trigger(final CustomItemContainerChanged itemContainerChanged) {
        // Get quantity from amount in item container.
        for (final TriggerItem triggerItem : chargedItem.items) {
            if (triggerItem.quantityCharges.isPresent()) {
               for (final StorageItem item : itemContainerChanged.getItems()) {
                    if (item.getId() == triggerItem.itemId) {
                        ((ChargedItem) chargedItem).setCharges(item.getQuantity());
                        break;
                    }
                }
            }
        }

        for (final TriggerBase triggerBase : chargedItem.triggers) {
            if (!isValidTrigger(triggerBase, itemContainerChanged)) continue;
            boolean triggerUsed = false;
            final OnItemContainerChanged trigger = (OnItemContainerChanged) triggerBase;

            // Fill storage from inventory all items.
            if (trigger.fillStorageFromInventory.isPresent()) {
                ((ChargedItemWithStorage) chargedItem).storage.fillFromInventory();
                triggerUsed = true;
            }

            // Empty storage to bank.
            if (trigger.emptyStorageToBank.isPresent()) {
                ((ChargedItemWithStorage) chargedItem).storage.emptyToBank();
                triggerUsed = true;
            }

            // Empty storage to inventory.
            if (trigger.emptyStorageToInventory.isPresent()) {
                ((ChargedItemWithStorage) chargedItem).storage.emptyToInventory();
                triggerUsed = true;
            }

            // Update storage directly from item container.
            if (trigger.updateStorage.isPresent()) {
                ((ChargedItemWithStorage) chargedItem).storage.updateFromItemContainer(itemContainerChanged);
                triggerUsed = true;
            }

            if (trigger.onInventoryDifference.isPresent()) {
                trigger.onInventoryDifference.get().accept(chargedItem.store.getInventoryItemsDifference());
                triggerUsed = true;
            }

            if (trigger.onBankDifference.isPresent()) {
                trigger.onBankDifference.get().accept(chargedItem.store.getBankItemsDifference());
                triggerUsed = true;
            }

            if (trigger.itemsConsumer.isPresent()) {
                trigger.itemsConsumer.get().accept(new StorageItems(itemContainerChanged));
                triggerUsed = true;
            }

            if (super.trigger(trigger)) {
                triggerUsed = true;
            }

            if (triggerUsed) return;
        }
    }

    public boolean isValidTrigger(final TriggerBase triggerBase, final CustomItemContainerChanged itemContainerChanged) {
        if (!(triggerBase instanceof OnItemContainerChanged)) return false;
        final OnItemContainerChanged trigger = (OnItemContainerChanged) triggerBase;

        // Item container type check.
        if (
            itemContainerChanged.getContainerId() != trigger.itemContainerId) {
            return false;
        }

        // Fill storage from inventory check.
        if (trigger.fillStorageFromInventory.isPresent() && !(chargedItem instanceof ChargedItemWithStorage)) {
            return false;
        }

        return super.isValidTrigger(trigger);
    }
}

package tictac7x.charges.item.triggers;

public class OnGraphicChanged extends TriggerBase {
    public final int[] graphicId;

    public OnGraphicChanged(final int ...graphicId) {
        this.graphicId = graphicId;
    }
}

package tictac7x.charges.item.triggers;

import net.runelite.api.Skill;

public class OnStatChanged extends TriggerBase {
    public final Skill skill;

    public OnStatChanged(final Skill skill) {
        this.skill = skill;
    }
}

package tictac7x.charges.item.triggers;

import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.storage.StorageItems;

import java.util.Optional;
import java.util.function.Consumer;
import java.util.regex.Pattern;

public abstract class TriggerBase {
    // Checks.
    public Optional<int[]> requiredItem = Optional.empty();
    public Optional<int[]> unallowedItem = Optional.empty();
    public Optional<String[]> onMenuOption = Optional.empty();
    public Optional<int[]> onMenuOptionId = Optional.empty();
    public Optional<String[]> onMenuTarget = Optional.empty();
    public Optional<int[]> onMenuImpostor = Optional.empty();
    public Optional<Boolean> onItemClick = Optional.empty();
    public boolean onHover = false;
    public Optional<StorageItem[]> onUseStorageItemOnChargedItem = Optional.empty();
    public Optional<StorageItem[]> onUseChargedItemOnStorageItem = Optional.empty();
    public Optional<Boolean> isEquipped = Optional.empty();
    public Optional<Pattern> hasChatMessage = Optional.empty();
    public Optional<Boolean> runConsumerOnNextGameTick = Optional.empty();
    public Optional<int[]> varbitCheck = Optional.empty();
    public Optional<int[][]> isWidgetVisible = Optional.empty();
    public Optional<int[]> itemEquipped = Optional.empty();
    public boolean multiTrigger = false;

    // Actions.
    public Optional<Integer> fixedCharges = Optional.empty();
    public Optional<Integer> increaseCharges = Optional.empty();
    public Optional<Integer> decreaseCharges = Optional.empty();
    public Optional<Runnable> consumer = Optional.empty();

    public Optional<String> notificationCustom = Optional.empty();

    // Storage.
    public Optional<Boolean> emptyStorage = Optional.empty();
    public Optional<Boolean> emptyStorageToInventory = Optional.empty();
    public Optional<Boolean> pickUpToStorage = Optional.empty();
    public Optional<int[]> addToStorage = Optional.empty();

    // Activity.
    public Optional<Boolean> isActivated = Optional.empty();
    public Optional<Boolean> activate = Optional.empty();
    public Optional<Boolean> deactivate = Optional.empty();

    public Optional<Consumer<StorageItems>> onInventoryDifference = Optional.empty();
    public Optional<Consumer<StorageItems>> onBankDifference = Optional.empty();

    public TriggerBase setFixedCharges(final int charges) {
        this.fixedCharges = Optional.of(charges);
        return this;
    }

    public TriggerBase increaseCharges(final int charges) {
        this.increaseCharges = Optional.of(charges);
        return this;
    }

    public TriggerBase decreaseCharges(final int charges) {
        this.decreaseCharges = Optional.of(charges);
        return this;
    }

    public TriggerBase emptyStorage() {
        this.emptyStorage = Optional.of(true);
        return this;
    }

    public TriggerBase emptyStorageToInventory() {
        this.emptyStorageToInventory = Optional.of(true);
        return this;
    }

    public TriggerBase requiredItem(final int ...itemIds) {
        this.requiredItem = Optional.of(itemIds);
        return this;
    }

    public TriggerBase unallowedItem(final int ...itemIds) {
        this.unallowedItem = Optional.of(itemIds);
        return this;
    }

    public TriggerBase onMenuOption(final String ...options) {
        this.onMenuOption = Optional.of(options);
        return this;
    }

    public TriggerBase onMenuOptionId(final int ...menuOptionIds) {
        this.onMenuOptionId = Optional.of(menuOptionIds);
        return this;
    }

    public TriggerBase onMenuTarget(final String ...targets) {
        this.onMenuTarget = Optional.of(targets);
        return this;
    }

    public TriggerBase onMenuImpostor(final int ...impostorIds) {
        this.onMenuImpostor = Optional.of(impostorIds);
        return this;
    }

    public TriggerBase onItemClick() {
        this.onItemClick = Optional.of(true);
        return this;
    }

    public TriggerBase onHover() {
        this.onHover = true;
        return this;
    }

    public TriggerBase pickUpToStorage() {
        this.pickUpToStorage = Optional.of(true);
        return this;
    }

    public TriggerBase onUseStorageItemOnChargedItem(final StorageItem[] storeableItems) {
        this.onUseStorageItemOnChargedItem = Optional.of(storeableItems);
        return this;
    }

    public TriggerBase onUseChargedItemOnStorageItem(final StorageItem[] storeableItems) {
        this.onUseChargedItemOnStorageItem = Optional.of(storeableItems);
        return this;
    }

    public TriggerBase activate() {
        this.activate = Optional.of(true);
        return this;
    }

    public TriggerBase deactivate() {
        this.deactivate = Optional.of(true);
        return this;
    }

    public TriggerBase notification(final String notification) {
        this.notificationCustom = Optional.of(notification);
        return this;
    }

    public TriggerBase isEquipped() {
        this.isEquipped = Optional.of(true);
        return this;
    }

    public TriggerBase consumer(final Runnable consumer) {
        this.consumer = Optional.of(consumer);
        return this;
    }

    public TriggerBase runConsumerOnNextGameTick(final Runnable consumer) {
        this.runConsumerOnNextGameTick = Optional.of(true);
        this.consumer = Optional.of(consumer);
        return this;
    }

    public TriggerBase isActivated() {
        this.isActivated = Optional.of(true);
        return this;
    }

    public TriggerBase addToStorage(final int itemId, final int quantity) {
        this.addToStorage = Optional.of(new int[]{itemId, quantity});
        return this;
    }

    public TriggerBase addToStorage(final int itemId) {
        this.addToStorage = Optional.of(new int[]{itemId, 1});
        return this;
    }

    public TriggerBase multiTrigger() {
        this.multiTrigger = true;
        return this;
    }

    public TriggerBase onInventoryDifference(Consumer<StorageItems> consumer) {
        this.onInventoryDifference = Optional.of(consumer);
        return this;
    }

    public TriggerBase onBankDifference(Consumer<StorageItems> consumer) {
        this.onBankDifference = Optional.of(consumer);
        return this;
    }

    public TriggerBase hasChatMessage(final String message) {
        this.hasChatMessage = Optional.of(Pattern.compile(message));
        return this;
    }

    public TriggerBase varbitCheck(final int varbitId, final int varbitValue) {
        this.varbitCheck = Optional.of(new int[]{varbitId, varbitValue});
        return this;
    }

    public TriggerBase isWidgetVisible(final int[] ...widgetIds) {
        this.isWidgetVisible = Optional.of(widgetIds);
        return this;
    }

    public TriggerBase itemEquipped(final int ...itemId) {
        this.itemEquipped = Optional.of(itemId);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import java.util.Optional;

public class OnCombat extends TriggerBase {
    public final int ticksInCombat;

    public OnCombat(final int ticksInCombat) {
        this.ticksInCombat = ticksInCombat;
    }
}

package tictac7x.charges.item.triggers;

public class OnAnimationChanged extends TriggerBase {
    public final int[] animationId;

    public OnAnimationChanged(final int ...animationId) {
        this.animationId = animationId;
    }
}

package tictac7x.charges.item.triggers;

import java.util.Optional;
import java.util.function.Consumer;

public class OnVarbitChanged extends TriggerBase {
    public final int varbitId;

    public Optional<Integer> varbitValue = Optional.empty();
    public Optional<Consumer<Integer>> varbitValueConsumer = Optional.empty();
    public Optional<Boolean> setDynamically = Optional.empty();

    public OnVarbitChanged(final int varbitId) {
        this.varbitId = varbitId;
    }

    public OnVarbitChanged(final int varbitId, final int varbitValue) {
        this.varbitId = varbitId;
        this.varbitValue = Optional.of(varbitValue);
    }

    public OnVarbitChanged varbitValueConsumer(final Consumer<Integer> consumer) {
        this.varbitValueConsumer = Optional.of(consumer);
        return this;
    }

    public OnVarbitChanged setDynamically() {
        this.setDynamically = Optional.of(true);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import tictac7x.charges.item.storage.StorageItems;

import java.util.Optional;
import java.util.function.Consumer;

public class OnItemContainerChanged extends TriggerBase {
    public final int itemContainerId;

    public Optional<Boolean> updateStorage = Optional.empty();
    public Optional<Boolean> fillStorageFromInventory = Optional.empty();
    public Optional<Boolean> emptyStorageToInventory = Optional.empty();
    public Optional<Boolean> emptyStorageToBank = Optional.empty();
    public Optional<Consumer<StorageItems>> itemsConsumer = Optional.empty();

    public OnItemContainerChanged(final int itemContainerId) {
        this.itemContainerId = itemContainerId;
    }

    public OnItemContainerChanged fillStorageFromInventory() {
        this.fillStorageFromInventory = Optional.of(true);
        return this;
    }

    public OnItemContainerChanged emptyStorageToInventory() {
        this.emptyStorageToInventory = Optional.of(true);
        return this;
    }

    public OnItemContainerChanged updateStorage() {
        this.updateStorage = Optional.of(true);
        return this;
    }

    public OnItemContainerChanged emptyStorageToBank() {
        this.emptyStorageToBank = Optional.of(true);
        return this;
    }

    public TriggerBase itemsConsumer(final Consumer<StorageItems> event) {
        this.itemsConsumer = Optional.of(event);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import java.util.Optional;

public class OnResetDaily extends TriggerBase {
    public Optional<Integer> resetSpecificItem = Optional.empty();

    public OnResetDaily specificItem(final int itemId) {
        this.resetSpecificItem = Optional.of(itemId);
        return this;
    }
}

package tictac7x.charges.item.triggers;

public class OnGameTick extends TriggerBase {
}

package tictac7x.charges.item.triggers;

import java.util.Optional;

public class TriggerItem {
    public final int itemId;

    public Optional<Boolean> quantityCharges = Optional.empty();
    public Optional<Boolean> hideOverlay = Optional.empty();
    public Optional<Boolean> needsToBeEquipped = Optional.empty();
    public Optional<Integer> maxCharges = Optional.empty();
    public Optional<Integer> fixedCharges = Optional.empty();

    public TriggerItem(final int itemId) {
        this.itemId = itemId;
    }

    public TriggerItem fixedCharges(final int charges) {
        this.fixedCharges = Optional.of(charges);
        return this;
    }

    public TriggerItem quantityCharges() {
        this.quantityCharges = Optional.of(true);
        return this;
    }

    public TriggerItem hideOverlay() {
        this.hideOverlay = Optional.of(true);
        return this;
    }

    public TriggerItem needsToBeEquipped() {
        this.needsToBeEquipped = Optional.of(true);
        return this;
    }

    public TriggerItem maxCharges(final int charges) {
        this.maxCharges = Optional.of(charges);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import net.runelite.api.Skill;
import net.runelite.api.events.ScriptPreFired;

import java.util.Optional;
import java.util.function.Consumer;

public class OnScriptPreFired extends TriggerBase {
    public final int scriptId;
    public Optional<Consumer<ScriptPreFired>> scriptConsumer = Optional.empty();

    public OnScriptPreFired(final int scriptId) {
        this.scriptId = scriptId;
    }

    public OnScriptPreFired scriptConsumer(final Consumer<ScriptPreFired> consumer) {
        this.scriptConsumer = Optional.of(consumer);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import tictac7x.charges.customEvents.CustomMenuOptionClicked;

import java.util.Optional;
import java.util.function.Consumer;

public class OnMenuOptionClicked extends TriggerBase {
    public final String[] options;
    public Optional<Consumer<CustomMenuOptionClicked>> menuOptionConsumer = Optional.empty();
    public Optional<Integer> hasItemId = Optional.empty();

    public OnMenuOptionClicked(final String ...options) {
        this.options = options;
    }

    public OnMenuOptionClicked menuOptionConsumer(final Consumer<CustomMenuOptionClicked> consumer) {
        this.menuOptionConsumer = Optional.of(consumer);
        return this;
    }

    public OnMenuOptionClicked hasItemId(final int itemId) {
        this.hasItemId = Optional.of(itemId);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import net.runelite.api.Skill;

import java.util.Optional;
import java.util.function.Consumer;

public class OnXpDrop extends TriggerBase {
    public final Skill skill;
    public Optional<Integer> amount = Optional.empty();
    public Optional<Consumer<Integer>> xpAmountConsumer = Optional.empty();

    public OnXpDrop(final Skill skill) {
        this.skill = skill;
    }

    public OnXpDrop(final Skill skill, final int amount) {
        this.skill = skill;
        this.amount = Optional.of(amount);
    }

    public OnXpDrop xpAmountConsumer(final Consumer<Integer> xpAmountConsumer) {
        this.xpAmountConsumer = Optional.of(xpAmountConsumer);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import tictac7x.charges.store.CombatStyle;
import tictac7x.charges.store.HitsplatGroup;
import tictac7x.charges.store.HitsplatTarget;

import java.util.Optional;

public class OnHitsplatApplied extends TriggerBase {
    public final HitsplatTarget hitsplatTarget;
    public final HitsplatGroup hitsplatGroup;

    public Optional<Boolean> moreThanZeroDamage = Optional.empty();
    public Optional<String> hasTargetName = Optional.empty();
    public Optional<Boolean> oncePerGameTick = Optional.empty();
    public Optional<CombatStyle> combatStyle = Optional.empty();
    public int triggerTick = 0;

    public OnHitsplatApplied(final HitsplatTarget hitsplatTarget) {
        this.hitsplatTarget = hitsplatTarget;
        this.hitsplatGroup = HitsplatGroup.SUCCESSFUL;
    }

    public OnHitsplatApplied(final HitsplatTarget hitsplatTarget, final HitsplatGroup hitsplatGroup) {
        this.hitsplatTarget = hitsplatTarget;
        this.hitsplatGroup = hitsplatGroup;
    }

    public OnHitsplatApplied moreThanZeroDamage() {
        this.moreThanZeroDamage = Optional.of(true);
        return this;
    }

    public OnHitsplatApplied hasTargetName(final String name) {
        this.hasTargetName = Optional.of(name);
        return this;
    }

    public TriggerBase oncePerGameTick() {
        this.oncePerGameTick = Optional.of(true);
        return this;
    }

    public TriggerBase combatStyle(final CombatStyle combatStyle) {
        this.combatStyle = Optional.of(combatStyle);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import tictac7x.charges.store.DynamicReplaceTarget;
import tictac7x.charges.store.ReplaceTarget;

import java.util.Optional;
import java.util.concurrent.Callable;

public class OnMenuEntryAdded extends TriggerBase {
    public final Optional<String> menuEntryOption;
    public Optional<Boolean> hide = Optional.empty();
    public Optional<String> replaceOption = Optional.empty();
    public Optional<ReplaceTarget[]> replaceTargets = Optional.empty();
    public Optional<int[]> replaceImpostorIds = Optional.empty();
    public Optional<DynamicReplaceTarget> replaceTargetDynamically = Optional.empty();
    public Optional<Callable<String>> replaceOptionConsumer = Optional.empty();

    public OnMenuEntryAdded() {
        this.menuEntryOption = Optional.empty();
    }

    public OnMenuEntryAdded(final String option) {
        this.menuEntryOption = Optional.of(option);
    }

    public OnMenuEntryAdded hide() {
        this.hide = Optional.of(true);
        return this;
    }

    public OnMenuEntryAdded replaceOption(final String option) {
        this.replaceOption = Optional.of(option);
        return this;
    }

    public OnMenuEntryAdded replaceTarget(final String target, final String replace) {
        return replaceTargets(new ReplaceTarget(target, replace));
    }

    public OnMenuEntryAdded replaceTargetDynamically(final String target, final Callable<String> dynamicTarget) {
        this.replaceTargetDynamically = Optional.of(new DynamicReplaceTarget(target, dynamicTarget));
        return this;
    }

    public OnMenuEntryAdded replaceTargets(final ReplaceTarget ...targets) {
        this.replaceTargets = Optional.of(targets);
        return this;
    }

    public OnMenuEntryAdded isReplaceImpostorId(final int ...impostorIds) {
        this.replaceImpostorIds = Optional.of(impostorIds);
        return this;
    }

    public OnMenuEntryAdded replaceOptionConsumer(Callable<String> consumer) {
        this.replaceOptionConsumer = Optional.of(consumer);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import java.util.Optional;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class OnChatMessage extends TriggerBase {
    public final Pattern message;

    public Optional<Boolean> setDynamically = Optional.empty();
    public Optional<Boolean> increaseDynamically = Optional.empty();
    public Optional<Boolean> decreaseDynamically = Optional.empty();
    public Optional<Boolean> useDifference = Optional.empty();
    public Optional<Consumer<Matcher>> matcherConsumer = Optional.empty();
    public Optional<Boolean> notification = Optional.empty();
    public Optional<Consumer<String>> stringConsumer = Optional.empty();

    public OnChatMessage(final String message) {
        this.message = Pattern.compile(message);
    }

    public TriggerBase setDynamicallyCharges() {
        this.setDynamically = Optional.of(true);
        return this;
    }

    public OnChatMessage matcherConsumer(final Consumer<Matcher> consumer) {
        this.matcherConsumer = Optional.of(consumer);
        return this;
    }

    public OnChatMessage notification() {
        this.notification = Optional.of(true);
        return this;
    }

    public OnChatMessage increaseDynamically() {
        this.increaseDynamically = Optional.of(true);
        return this;
    }

    public OnChatMessage setDifferenceCharges() {
        this.useDifference = Optional.of(true);
        return this;
    }

    public OnChatMessage stringConsumer(final Consumer<String> consumer) {
        this.stringConsumer = Optional.of(consumer);
        return this;
    }

    public OnChatMessage decreaseDynamicallyCharges() {
        this.decreaseDynamically = Optional.of(true);
        return this;
    }
}

package tictac7x.charges.item.triggers;

public class OnUserAction extends TriggerBase {}

package tictac7x.charges.item.triggers;

import net.runelite.api.widgets.Widget;

import java.util.Optional;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class OnWidgetLoaded extends TriggerBase {
    public final int groupId;
    public final int childId;
    public Optional<Integer> subChildId = Optional.empty();

    public Optional<Pattern> text = Optional.empty();
    public Optional<Consumer<Matcher>> matcherConsumer = Optional.empty();
    public Optional<Consumer<Widget>> widgetConsumer = Optional.empty();
    public Optional<Boolean> setDynamically = Optional.empty();

    public OnWidgetLoaded(final int groupId, final int childId) {
        this.groupId = groupId;
        this.childId = childId;
    }

    public OnWidgetLoaded(final int groupId, final int childId, final int subChildId) {
        this.groupId = groupId;
        this.childId = childId;
        this.subChildId = Optional.of(subChildId);
    }

    public OnWidgetLoaded setDynamically() {
        this.setDynamically = Optional.of(true);
        return this;
    }

    public OnWidgetLoaded text(final String text) {
        this.text = Optional.of(Pattern.compile(text));
        return this;
    }

    public OnWidgetLoaded matcherConsumer(final Consumer<Matcher> consumer) {
        this.matcherConsumer = Optional.of(consumer);
        return this;
    }

    public OnWidgetLoaded widgetConsumer(final Consumer<Widget> consumer) {
        this.widgetConsumer = Optional.of(consumer);
        return this;
    }
}

package tictac7x.charges.item.triggers;

import tictac7x.charges.item.storage.StorageItem;

import java.util.Optional;

public class OnItemPickup extends TriggerBase {
    public final StorageItem[] items;
    public Optional<Boolean> isByOne = Optional.empty();

    public OnItemPickup(final StorageItem[] items) {
        this.items = items;
    }

    public OnItemPickup isByOne() {
        this.isByOne = Optional.of(true);
        return this;
    }
}

package tictac7x.charges.item;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.store.Store;

public class ChargedItemWithStorageMultipleCharges extends ChargedItemWithStorage {
    public ChargedItemWithStorageMultipleCharges(String configKey, int itemId, Client client, ClientThread clientThread, ConfigManager configManager, ItemManager itemManager, InfoBoxManager infoBoxManager, ChatMessageManager chatMessageManager, Notifier notifier, TicTac7xChargesImprovedConfig config, Store store, final Gson gson) {
        super(configKey, itemId, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
    }

    @Override
    public String getCharges(final int itemId) {
        String individualCharges = "";

        int validItems = 0;
        for (final StorageItem storageItem : getStorage().getItems()) {
            if (storageItem.getQuantity() >= 0) {
                individualCharges += storageItem.getQuantity() + "/";
                validItems++;
            }
        }

        return validItems > 0 ? individualCharges.replaceAll("/$", "") : "?";
    }
}

package tictac7x.charges.item.storage;

public class StorageItem {
    private final int id;
    private int quantity;

    public StorageItem(final int id) {
        this.id = id;
        this.quantity = 0;
    }

    public StorageItem(final int id, final int quantity) {
        this.id = id;
        this.quantity = quantity;
    }

    public int getId() {
        return id;
    }

    public void setQuantity(final int quantity) {
        this.quantity = quantity;
    }

    public int getQuantity() {
        return quantity;
    }

    public void decreaseQuantity(final int quantity) {
        this.quantity = Math.max(this.quantity - quantity, 0);
    }

    public void increaseQuantity(final int quantity) {
        this.quantity += quantity;
    }
}

package tictac7x.charges.item.storage;

import java.util.Optional;

public class StorableItem extends StorageItem {
    public Optional<String[]> checkName = Optional.empty();
    public Optional<String> displayName = Optional.empty();
    public Optional<Integer> order = Optional.empty();

    public StorableItem(int itemId) {
        super(itemId);
    }

    public StorableItem(int itemId, int quantity) {
        super(itemId, quantity);
    }

    public StorableItem checkName(final String ...checkName) {
        this.checkName = Optional.of(checkName);
        return this;
    }

    public StorableItem specificOrder(final int order) {
        this.order = Optional.of(order);
        return this;
    }

    public StorableItem displayName(final String displayName) {
        this.displayName = Optional.of(displayName);
        return this;
    }
}

package tictac7x.charges.item.storage;

import tictac7x.charges.customEvents.CustomItemContainerChanged;

import java.util.*;

public class StorageItems {
    final Map<Integer, StorageItem> items = new LinkedHashMap<>();

    public StorageItems() {}

    public StorageItems(final CustomItemContainerChanged itemContainerChanged) {
        for (final StorageItem item : itemContainerChanged.getItems()) {
            if (items.containsKey(item.getId())) continue;
            items.put(item.getId(), new StorageItem(item.getId(), itemContainerChanged.count(item.getId())));
        }
    }

    public int count(final int itemId) {
        return items.containsKey(itemId)
            ? items.get(itemId).getQuantity()
            : 0;
    }

    public void put(final StorageItem storageItem) {
        items.put(storageItem.getId(), storageItem);
    }

    public List<StorageItem> getItems() {
        final List<StorageItem> items = new ArrayList<>();

        for (final StorageItem item : this.items.values()) {
            items.add(new StorageItem(item.getId(), item.getQuantity()));
        }

        return items;
    }

    public boolean hasItem(final int itemId) {
        return items.containsKey(itemId);
    }

    public void clear() {
        items.clear();
    }

    public void remove(final int itemId) {
        items.remove(itemId);
    }

    public Optional<StorageItem> getItem(final int itemId) {
        return items.containsKey(itemId)
            ? Optional.of(items.get(itemId))
            : Optional.empty();
    }
}

package tictac7x.charges.item.storage;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.customEvents.CustomItemContainerChanged;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

import java.util.Optional;

public class Storage {
    private final ChargedItemWithStorage chargedItem;
    private final String storageConfigKey;
    private final ItemManager itemManager;
    private final ConfigManager configManager;
    private final Store store;
    private final Gson gson;

    protected StorageItems storage = new StorageItems();

    public Optional<Integer> maximumTotalQuantity = Optional.empty();
    public Optional<Integer> maximumTotalQuantityWithItemEquipped = Optional.empty();
    public Optional<int[]> maximumTotalQuantityWithItemEquippedItems = Optional.empty();
    public Optional<Boolean> showIndividualCharges = Optional.empty();
    public boolean holdsSingleType = false;
    public boolean emptyIsNegative = false;
    private Optional<Integer> maximumIndividualQuantity = Optional.empty();
    private StorableItem[] storableItems = new StorableItem[]{};


    public Storage(final ChargedItemWithStorage chargedItem, final String configKey, final ItemManager itemManager, final ConfigManager configManager, final Store store, final Gson gson) {
        this.chargedItem = chargedItem;
        this.storageConfigKey = configKey + "_storage";
        this.itemManager = itemManager;
        this.configManager = configManager;
        this.store = store;
        this.gson = gson;
    }

    public Storage setMaximumTotalQuantity(final int quantity) {
        this.maximumTotalQuantity = Optional.of(quantity);
        return this;
    }

    public Storage emptyIsNegative() {
        this.emptyIsNegative = true;
        return this;
    }
    
    public Storage setHoldsSingleType(final boolean holdsSingleType) {
        this.holdsSingleType = holdsSingleType;
        return this;
    }

    public Storage setMaximumTotalQuantityWithEquippedItem(int quantity, final int ...itemIds) {
        this.maximumTotalQuantityWithItemEquipped = Optional.of(quantity);
        this.maximumTotalQuantityWithItemEquippedItems = Optional.of(itemIds);
        return this;
    }

    public Storage setMaximumIndividualQuantity(final int quantity) {
        this.maximumIndividualQuantity = Optional.of(quantity);
        return this;
    }

    public Storage showIndividualCharges() {
        this.showIndividualCharges = Optional.of(true);
        return this;
    }

    public Storage storableItems(final StorableItem... storableItems) {
        this.storableItems = storableItems;
        return this;
    }

    public void clear() {
        storage.clear();
        save();
    }

    public void add(final int itemId, final int quantity) {
        if (getMaximumTotalQuantity().isPresent()) {
            if (getCharges() == getMaximumTotalQuantity().get()) {
                return;
            }
        }

        final Optional<StorageItem> item = getItem(itemId);
        put(itemId, (item.isPresent() ? item.get().getQuantity() : 0) + quantity);
    }

    public void add(final StorageItem item) {
        add(item.getId(), item.getQuantity());
    }

    public void add(final Optional<StorageItem> item) {
        if (!item.isPresent()) return;
        add(item.get().getId(), item.get().getQuantity());
    }

    public void put(final Optional<StorageItem> item) {
        if (!item.isPresent()) return;
        put(item.get().getId(), item.get().getQuantity());
    }

    public void clearAndPut(final Optional<StorageItem> item) {
        if (!item.isPresent()) return;
        clearAndPut(item.get().getId(), item.get().getQuantity());
    }

    public void clearAndPut(final int itemId, final int quantity) {
        clear();
        put(itemId, quantity);
    }

    public void remove(final Optional<StorageItem> item) {
        if (!item.isPresent()) return;
        remove(item.get().getId(), item.get().getQuantity());
    }

    public void remove(final int itemId, final int quantity) {
        final Optional<StorageItem> item = getItem(itemId);

        // Don't decrease quantity of unlimited storage item.
        if (item.isPresent() && item.get().getQuantity() == Charges.UNLIMITED) {
            return;
        }

        put(itemId, (item.isPresent() ? Math.max(0, item.get().getQuantity() - quantity) : 0));
    }

    public void removeAndPrioritizeInventory(final int itemId, final int quantity) {
        this.remove(itemId, Math.max(quantity - store.getInventoryItemQuantity(itemId), 0));
    }

    public void removeAndPrioritizeInventory(final Optional<Integer> itemId, final int quantity) {
        if (itemId.isPresent()) {
            this.removeAndPrioritizeInventory(itemId.get(), quantity);
        }
    }

    public void put(final int itemId, int quantity) {
        // -1 = item that was previously in the array, but that slot no longer has an item.
        // 6512 = empty item inside huntsmans kit.
        if (itemId == -1 || itemId == 6512) return;

        boolean storableCheck = false;
        for (final StorableItem item : storableItems) {
            if (item.getId() == itemId) {
                storableCheck = true;
                break;
            }
        }
        if (!storableCheck) return;

        // Storage holds only one unique item at once check.
        if (holdsSingleType) {
            for (final StorageItem storageItem : storage.getItems()) {
                if (storageItem.getId() != itemId && storageItem.getQuantity() > 0) {
                    return;
                }
            }
        }

        // Check for individual maximum quantity.
        if (maximumIndividualQuantity.isPresent() && quantity > maximumIndividualQuantity.get()) {
            quantity = maximumIndividualQuantity.get();
        }

        final Optional<Integer> maximumTotalQuantity = getMaximumTotalQuantity();
        if (maximumTotalQuantity.isPresent()) {
            int newTotalQuantity = 0;
            for (final StorageItem storageItem : storage.getItems()) {
                if (storageItem.getId() == itemId) continue;
                newTotalQuantity += storageItem.getQuantity();
            }
            newTotalQuantity += quantity; //Add outside the loop in case the item is not currently stored

            if (newTotalQuantity > maximumTotalQuantity.get()) {
                quantity -= newTotalQuantity - maximumTotalQuantity.get();
            }
        }

        final Optional<StorageItem> item = getItem(itemId);
        if (quantity == 0) {
            storage.remove(itemId);
        } else if (item.isPresent()) {
            item.get().setQuantity(quantity);
        } else {
            storage.put(new StorageItem(itemId, quantity));
        }

        save();
    }

    public void fillFromInventory() {
        for (final StorageItem itemDifference : store.getInventoryItemsDifference().getItems()) {
            if (isStorageItem(itemDifference) && itemDifference.getQuantity() < 0) {
                add(itemDifference.getId(), Math.abs(itemDifference.getQuantity()));
            }
        }
    }

    private boolean isStorageItem(final StorageItem item) {
        for (final StorageItem storageItem : storableItems) {
            if (storageItem.getId() == item.getId()) {
                return true;
            }
        }

        return false;
    }

    public void emptyToInventory() {
        for (final StorageItem itemDifference : store.getInventoryItemsDifference().getItems()) {
            storage.getItem(itemDifference.getId()).ifPresent(item -> item.decreaseQuantity(itemDifference.getQuantity()));
        }
    }

    public void emptyToInventoryWithoutItemContainerChanged() {
        int inventorySpaceFree = store.getInventoryEmptySlots();

        for (final StorageItem storageItem : storage.getItems()) {
            if (storageItem.getQuantity() > 0) {
                final int toRemove = Math.min(storageItem.getQuantity(), inventorySpaceFree);
                remove(storageItem.getId(), toRemove);
                inventorySpaceFree -= toRemove;
            }
        }
    }

    public void emptyToBank() {
        for (final StorageItem itemDifference : store.getBankItemsDifference().getItems()) {
            storage.getItem(itemDifference.getId()).ifPresent(item -> item.decreaseQuantity(itemDifference.getQuantity()));
        }
    }

    public void updateFromItemContainer(final CustomItemContainerChanged itemContainer) {
        storage = new StorageItems(itemContainer);
        save();
    }

    public int getCharges() {
        int charges = 0;

        for (final StorageItem item : storage.getItems()) {
            charges += item.getQuantity();
        }

        return charges;
    }

    public StorageItems getStorage() {
        return storage;
    }

    public void loadStorage() {
        storage = new StorageItems();

        // Load storage from config.
        try {
            final String jsonString = configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, storageConfigKey);
            final JsonArray jsonStorage = (JsonArray) (new JsonParser()).parse(jsonString);

            for (final JsonElement jsonStorageItem : jsonStorage) {
                final StorageItem loadedItem = new StorageItem(
                    jsonStorageItem.getAsJsonObject().get("itemId").getAsInt(),
                    jsonStorageItem.getAsJsonObject().get("quantity").getAsInt()
                );

                put(loadedItem.getId(), loadedItem.getQuantity());
            }
        } catch (final Exception ignored) {}
    }

    private void save() {
        final JsonArray jsonStorage = new JsonArray();

        for (final StorageItem storageItem : storage.getItems()) {
            final JsonObject jsonItem = new JsonObject();
            jsonItem.addProperty("itemId", storageItem.getId());
            jsonItem.addProperty("quantity", storageItem.getQuantity());
            jsonStorage.add(jsonItem);
        }

        configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, storageConfigKey, gson.toJson(jsonStorage));
    }

    private Optional<StorageItem> getItem(final int itemId) {
        return storage.getItem(itemId);
    }

    public boolean isEmpty() {
        for (final StorageItem storageItem : storage.getItems()) {
            if (storageItem.getQuantity() > 0) {
                return false;
            }
        }

        return true;
    }

    public boolean isFull() {
        if (maximumTotalQuantity.isPresent()) {
            int quantity = 0;

            for (final StorageItem storageItem : storage.getItems()) {
                quantity += storageItem.getQuantity();
            }

            return quantity == maximumTotalQuantity.get();
        }

        return false;
    }

    public Optional<Integer> getMaximumTotalQuantity() {
        // Maximum storage from trigger item.
        for (final TriggerItem item : chargedItem.items) {
            if (chargedItem.itemId == item.itemId && item.maxCharges.isPresent()) {
                return item.maxCharges;
            }
        }

        // Maximum storage with specific item equipped.
        if (maximumTotalQuantityWithItemEquipped.isPresent() && maximumTotalQuantityWithItemEquippedItems.isPresent() && store.equipmentContainsItem(maximumTotalQuantityWithItemEquippedItems.get())) {
            return maximumTotalQuantityWithItemEquipped;
        }

        // Maximum storage.
        if (maximumTotalQuantity.isPresent()) {
            return maximumTotalQuantity;
        }

        return Optional.empty();
    }

    public final Optional<StorageItem> getStorageItemFromName(final String name, final int quantity) {
        for (final StorableItem storableItem : storableItems) {
            // Based on checkName.
            if (storableItem.checkName.isPresent()) {
                for (final String checkName :storableItem.checkName.get()) {
                    if (
                        name.equalsIgnoreCase(checkName) ||
                        name.toLowerCase().contains(checkName.toLowerCase()) ||
                        name.contains(itemManager.getItemComposition(storableItem.getId()).getName())
                    ) {
                        return Optional.of(new StorageItem(storableItem.getId(), quantity));
                    }
                }
            }
        }

        return Optional.empty();
    }

    public StorableItem[] getStorableItems() {
        return storableItems;
    }

    public int getStorageItemOrder(final StorageItem storageItem) {
        for (final StorableItem storableItem : storableItems) {
            if (storableItem.getId() == storageItem.getId()) {
                if (storableItem.order.isPresent()) {
                    return storableItem.order.get();
                }
            }
        }

        return Integer.MAX_VALUE;
    }

    public String getStorageItemName(final StorageItem storageItem) {
        for (final StorableItem storableItem : storableItems) {
            if (storableItem.getId() == storageItem.getId()) {
                if (storableItem.displayName.isPresent()) {
                    return storableItem.displayName.get();
                }
            }
        }

        return itemManager.getItemComposition(storageItem.getId()).getName();
    }

    public boolean isStorableItemInInventory() {
        for (final StorageItem inventoryItem : store.inventory.getItems()) {
            for (final StorableItem storableItem : storableItems) {
                if (inventoryItem.getId() == storableItem.getId()) {
                    return true;
                }
            }
        }

        return false;
    }
}

package tictac7x.charges.item.overlays;

import net.runelite.api.Client;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.ItemOverlayLocation;

import java.awt.*;
import java.util.Optional;

import static tictac7x.charges.TicTac7xChargesImprovedPlugin.INFINITE_SYMBOL;

public class ChargedItemOverlay extends WidgetItemOverlay {
    private final Client client;
    private final TooltipManager tooltipManager;
    private final ConfigManager configManager;
    private final TicTac7xChargesImprovedConfig config;
    private final ChargedItemBase[] chargedItems;

    public ChargedItemOverlay(
        final Client client,
        final TooltipManager tooltipManager,
        final ItemManager itemManager,
        final ConfigManager configManager,
        final TicTac7xChargesImprovedConfig config,
        final ChargedItemBase[] chargedItems
    ) {
        this.client = client;
        this.tooltipManager = tooltipManager;
        this.configManager = configManager;
        this.config = config;
        this.chargedItems = chargedItems;
        showOnInventory();
        showOnEquipment();
        showOnInterfaces(84);
        showOnBank();
    }

    private boolean isBankWidget(final WidgetItem item_widget) {
        return
            item_widget.getWidget().getParentId() == 786442 ||
            item_widget.getWidget().getParentId() == 786443 ||
            item_widget.getWidget().getParentId() == 786444 ||
            item_widget.getWidget().getParentId() == 786445
        ;
    }


    @Override
    public void renderItemOverlay(final Graphics2D graphics, final int itemId, final WidgetItem widgetItem) {
        if (!config.showOverlays()) return;

        Optional<ChargedItemBase> chargedItem = Optional.empty();
        Optional<TriggerItem> triggerItem = Optional.empty();

        // Find correct charged item.
        chargedItemFinder: for (final ChargedItemBase chargedItemBase : chargedItems) {
            for (final TriggerItem chargedItemTriggerItem : chargedItemBase.items) {
                if (chargedItemTriggerItem.itemId == itemId) {
                    chargedItem = Optional.of(chargedItemBase);
                    triggerItem = Optional.of(chargedItemTriggerItem);
                    break chargedItemFinder;
                }
            }
        }


        // Invalid item.
        if (!chargedItem.isPresent() || !triggerItem.isPresent()) return;

        if (
            // Item overlay disabled.
            !isChargedItemOverlayEnabled(chargedItem.get()) ||

            // Infinity charges hidden.
            !config.showUnlimited() && chargedItem.get().getCharges(itemId).equals(INFINITE_SYMBOL) ||
            !config.showUnlimited() && triggerItem.get().fixedCharges.isPresent() && triggerItem.get().fixedCharges.get().equals(Charges.UNLIMITED) ||

            // Hide overlays in bank.
            !config.showBankOverlays() && isBankWidget(widgetItem) ||

            // Show overlays only in bank.
            config.showOverlaysOnlyInBank() && client.getWidget(12, 1) == null
        ) return;

        // Get default charges from charged item.
        String charges = chargedItem.get().getCharges(itemId);
        Color color = chargedItem.get().getTextColor(itemId);

        graphics.setFont(FontManager.getRunescapeSmallFont());

        final Rectangle bounds = widgetItem.getCanvasBounds();
        final TextComponent charges_component = new TextComponent();
        charges_component.setText(charges);
        final Dimension textDimension = charges_component.render(graphics);

        final int itemOverlayX = (int) ((
            config.itemOverlayLocation() == ItemOverlayLocation.BOTTOM_LEFT ||
            config.itemOverlayLocation() == ItemOverlayLocation.TOP_LEFT
        )
            ? bounds.getMinX()
            : bounds.getMaxX() - textDimension.getWidth() - 5
        );

        final int itemOverlayY = (int) ((
            config.itemOverlayLocation() == ItemOverlayLocation.TOP_LEFT ||
            config.itemOverlayLocation() == ItemOverlayLocation.TOP_RIGHT
        )
            ? bounds.getMinY() + textDimension.getHeight() - 2
            : bounds.getMaxY()
        );

        charges_component.setPosition(new Point(itemOverlayX, itemOverlayY));

        // Set color.
        charges_component.setColor(color);

        // Override for bank items.
        if (isBankWidget(widgetItem) && !chargedItem.get().getCharges(itemId).equals("?")) {
            charges_component.setColor(config.getColorDefault());
        }

        charges_component.render(graphics);

        // Charged item with storage
        renderTooltip(chargedItem.get(), widgetItem);
    }

    private void renderTooltip(final ChargedItemBase chargedItem, final WidgetItem widgetItem) {
        // Config, not storage item, empty storage checks.
        if (
            !config.showStorageTooltips() ||
            !(chargedItem instanceof ChargedItemWithStorage)
        ) return;

        // Mouse position check.
        final net.runelite.api.Point mousePosition = client.getMouseCanvasPosition();
        if (!widgetItem.getCanvasBounds().contains(mousePosition.getX(), mousePosition.getY())) return;


        final String tooltip = chargedItem.getTooltip();
        if (!tooltip.isEmpty()) {
            tooltipManager.addFront(new Tooltip(tooltip));
        }
    }

    private boolean isChargedItemOverlayEnabled(final ChargedItemBase chargedItem) {
        final String configKey = (
            chargedItem.configKey.contains(TicTac7xChargesImprovedConfig.barrows_gear) ? TicTac7xChargesImprovedConfig.barrows_gear :
            chargedItem.configKey.contains(TicTac7xChargesImprovedConfig.moons_gear) ? TicTac7xChargesImprovedConfig.moons_gear :
            chargedItem.configKey
        ) + TicTac7xChargesImprovedConfig.overlay;

        final Optional<String> visible = Optional.ofNullable(configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, configKey));
        if (visible.isPresent() && visible.get().equals("true")) {
            return true;
        }

        return false;
    }
}

package tictac7x.charges.item.overlays;

import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemBase;

import java.awt.Color;
import java.util.Optional;

import static tictac7x.charges.TicTac7xChargesImprovedPlugin.INFINITE_SYMBOL;

public class ChargedItemInfobox extends InfoBox {
    private final ChargedItemBase chargedItem;
    private final ItemManager itemManager;
    private final InfoBoxManager infoBoxManager;
    private final TicTac7xChargesImprovedConfig config;
    private final ConfigManager configManager;

    private int itemId;

    public ChargedItemInfobox(
        final ChargedItemBase chargedItem,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ConfigManager configManager,
        final TicTac7xChargesImprovedConfig config,
        final TicTac7xChargesImprovedPlugin plugin
    ) {
        super(itemManager.getImage(chargedItem.itemId), plugin);
        this.chargedItem = chargedItem;
        this.itemManager = itemManager;
        this.infoBoxManager = infoBoxManager;
        this.configManager = configManager;
        this.config = config;
        this.itemId = chargedItem.itemId;
    }

    @Override
    public String getName() {
        return super.getName() + "_" + chargedItem.itemId;
    }

    @Override
    public String getText() {
        return chargedItem.getTotalCharges();
    }

    @Override
    public String getTooltip() {
        return chargedItem.getTooltip();
    }

    @Override
    public Color getTextColor() {
        return chargedItem.getTextColor();
    }

    @Override
    public boolean render() {
        updateInfobox();

        if (
            !config.showInfoboxes() ||
            !isChargedItemInfoboxEnabled() ||
            chargedItem.getCharges(itemId).equals(INFINITE_SYMBOL) && !config.showUnlimited() ||
            (!chargedItem.inInventory() && !chargedItem.inEquipment())
        ) {
            return false;
        }

        return true;
    }

    private void updateInfobox() {
        if (itemId != chargedItem.itemId) {
            // Update infobox id to keep track of correct item.
            itemId = chargedItem.itemId;

            // Update infobox image.
            setImage(itemManager.getImage(itemId));
            infoBoxManager.updateInfoBoxImage(this);
        }
    }

    private boolean isChargedItemInfoboxEnabled() {
        final String configKey = (
            chargedItem.configKey.contains(TicTac7xChargesImprovedConfig.barrows_gear) ? TicTac7xChargesImprovedConfig.barrows_gear :
            chargedItem.configKey.contains(TicTac7xChargesImprovedConfig.moons_gear) ? TicTac7xChargesImprovedConfig.moons_gear :
            chargedItem.configKey
        ) + TicTac7xChargesImprovedConfig.infobox;

        final Optional<String> visible = Optional.ofNullable(configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, configKey));

        if (visible.isPresent() && visible.get().equals("true")) {
            return true;
        }

        return false;
    }
}



package tictac7x.charges.item;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

import java.util.Optional;

import static tictac7x.charges.TicTac7xChargesImprovedPlugin.INFINITE_SYMBOL;

public class ChargedItem extends ChargedItemBase {
    public ChargedItem(String configKey, int itemId, Client client, ClientThread clientThread, ConfigManager configManager, ItemManager itemManager, InfoBoxManager infoBoxManager, ChatMessageManager chatMessageManager, Notifier notifier, TicTac7xChargesImprovedConfig config, Store store, final Gson gson) {
        super(configKey, itemId, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store);
    }

    @Override
    public String getCharges(final int itemId) {
        for (final TriggerItem triggerItem : items) {
            if (triggerItem.itemId == itemId && triggerItem.fixedCharges.isPresent()) {
                return getChargesMinified(triggerItem.fixedCharges.get());
            }
        }

        if (getChargesFromConfig() == Charges.UNLIMITED) {
            return INFINITE_SYMBOL;
        }

        if (getChargesFromConfig() >= 0) {
            return getChargesMinified(getChargesFromConfig());
        }

        return "?";
    }

    @Override
    public String getTotalCharges() {
        int totalFixedCharges = 0;
        int equipmentFixedCharges = 0;
        boolean fixedItemsFound = false;

        for (final TriggerItem triggerItem : items) {
            if (triggerItem.fixedCharges.isPresent()) {
                totalFixedCharges += store.getInventoryItemQuantity(triggerItem.itemId) * triggerItem.fixedCharges.get();
                equipmentFixedCharges += store.getEquipmentItemQuantity(triggerItem.itemId) * triggerItem.fixedCharges.get();
                fixedItemsFound = true;
            }
        }

        try {
            if (getChargesFromConfig() == Charges.UNKNOWN && fixedItemsFound) {
                return equipmentFixedCharges > 0 ?
                    getChargesMinified(equipmentFixedCharges) :
                    getChargesMinified(totalFixedCharges);
            }
        } catch (final Exception ignored) {}

        return getCharges(itemId);
    }

    public void setCharges(int charges) {
        charges =
            // Unlimited
            charges == Charges.UNLIMITED ? charges :

            // 0 -> charges
            Math.max(0, charges);

        if (this.getChargesFromConfig() != charges) {
            configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, configKey, charges);
        }
    }

    public void decreaseCharges(final int charges) {
        setCharges(this.getChargesFromConfig() - charges);
    }

    public void increaseCharges(final int charges) {
        setCharges(this.getChargesFromConfig() + charges);
    }

    protected int getChargesFromConfig() {
        final Optional<String> charges = Optional.ofNullable(configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, configKey));

        if (!charges.isPresent()) {
            return Charges.UNKNOWN;
        }

        try {
            return Integer.parseInt(charges.get());
        } catch (final Exception ignored) {
            return Charges.UNKNOWN;
        }
    }
}



package tictac7x.charges.item;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.store.ItemActivity;
import tictac7x.charges.store.Store;

import java.awt.Color;
import java.util.Optional;

public class ChargedItemWithStatus extends ChargedItem {

    public ChargedItemWithStatus(String configKey, int itemId, Client client, ClientThread clientThread, ConfigManager configManager, ItemManager itemManager, InfoBoxManager infoBoxManager, ChatMessageManager chatMessageManager, Notifier notifier, TicTac7xChargesImprovedConfig config, Store store, final Gson gson) {
        super(configKey, itemId, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
    }

    public boolean isDeactivated() {
        final Optional<String> status = Optional.ofNullable(configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, getConfigStatusKey()));

        if (!status.isPresent()) {
            return false;
        }

        return status.get().equals(ItemActivity.DEACTIVATED.toString());
    }

    public boolean isActivated() {
        final Optional<String> status = Optional.ofNullable(configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, getConfigStatusKey()));

        if (!status.isPresent()) {
            return false;
        }

        return status.get().equals(ItemActivity.ACTIVATED.toString());
    }

    public String getConfigStatusKey() {
        return configKey + "_status";
    }

    public void deactivate() {
        setActivity(ItemActivity.DEACTIVATED);
    }

    public void activate() {
        setActivity(ItemActivity.ACTIVATED);
    }

    private void setActivity(final ItemActivity status) {
        configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, getConfigStatusKey(), status);
    }

    @Override
    public Color getTextColor() {
        if (isActivated()) {
            return config.getColorActivated();
        }

        if (isDeactivated()) {
            return config.getColorEmpty();
        }

        return super.getTextColor();
    }
}

package tictac7x.charges.item;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.storage.Storage;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.storage.StorageItems;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

import java.awt.Color;
import java.util.Comparator;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

public class ChargedItemWithStorage extends ChargedItemBase {
    public Storage storage;

    public ChargedItemWithStorage(String configKey, int itemId, Client client, ClientThread clientThread, ConfigManager configManager, ItemManager itemManager, InfoBoxManager infoBoxManager, ChatMessageManager chatMessageManager, Notifier notifier, TicTac7xChargesImprovedConfig config, Store store, final Gson gson) {
        super(configKey, itemId, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store);
        this.storage = new Storage(this, configKey, itemManager, configManager, store, gson);

        clientThread.invokeLater(() -> {
            loadCharges();
        });
    }

    @Override
    public String getTooltip() {
        String tooltip = "";
        for (final StorageItem storageItem : storage.getStorage().getItems().stream()
            .sorted(Comparator.comparing(storageItem -> storage.getStorageItemOrder(storageItem)))
            .collect(Collectors.toList())
        ) {
            if (storageItem.getQuantity() > 0) {
                tooltip += storage.getStorageItemName(storageItem) + ": ";
                tooltip += ColorUtil.wrapWithColorTag(String.valueOf(storageItem.getQuantity()), JagexColors.MENU_TARGET) + "</br>";
            }
        }

        return tooltip.replaceAll("</br>$", "");
    }

    public StorageItems getStorage() {
        return this.storage.getStorage();
    }

    public Optional<StorageItem> getStorageItemFromName(final String name, final int quantity) {
        return storage.getStorageItemFromName(name, quantity);
    }

    public int getQuantity() {
        int quantity = 0;

        for (final StorageItem storageItem : getStorage().getItems()) {
            if (storageItem.getQuantity() > 0) {
                quantity += storageItem.getQuantity();
            }
        }

        return quantity;
    }

    @Override
    public String getCharges(final int itemId) {
        int quantity = getQuantity();

        if (quantity == Charges.UNKNOWN) {
            return "?";
        }

        return getChargesMinified(quantity);
    }

    @Override
    public String getTotalCharges() {
        return getCharges(itemId);
    }

    private void loadCharges() {
        storage.loadStorage();
    }

    @Override
    public Color getTextColor() {
        // Full storage is positive.
        if (storage.emptyIsNegative && storage.isFull()) {
            return config.getColorActivated();
        }

        // Full storage is negative.
        if (
            storage.emptyIsNegative && storage.isEmpty() ||
            !storage.emptyIsNegative && storage.getMaximumTotalQuantity().isPresent() && getCharges(itemId).equals(String.valueOf(storage.getMaximumTotalQuantity().get()))
        ) {
            return config.getColorEmpty();
        }

        // Storage is empty.
        if (getQuantity() == 0) {
            return config.getColorDefault();
        }

        return super.getTextColor();
    }
}

package tictac7x.charges.item;

import net.runelite.api.Client;
import net.runelite.api.events.*;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.customEvents.CustomChatMessage;
import tictac7x.charges.customEvents.CustomHitsplatApplied;
import tictac7x.charges.item.listeners.*;
import tictac7x.charges.customEvents.CustomItemContainerChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.customEvents.CustomMenuOptionClicked;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

import javax.annotation.Nonnull;
import java.awt.Color;

import static tictac7x.charges.TicTac7xChargesImprovedPlugin.INFINITE_SYMBOL;

public abstract class ChargedItemBase {
    public final String configKey;
    protected final Client client;
    protected final ClientThread clientThread;
    protected final ItemManager itemManager;
    protected final InfoBoxManager infoBoxManager;
    protected final ConfigManager configManager;
    protected final ChatMessageManager chatMessageManager;
    protected final Notifier notifier;
    protected final TicTac7xChargesImprovedConfig config;

    public final Store store;

    public int itemId;

    public TriggerItem[] items = new TriggerItem[]{};
    public TriggerBase[] triggers = new TriggerBase[]{};

    private final ListenerOnChatMessage listenerOnChatMessage;
    private final ListenerOnItemContainerChanged listenerOnItemContainerChanged;
    private final ListenerOnItemPickup listenerOnItemPickup;
    private final ListenerOnXpDrop listenerOnXpDrop;
    private final ListenerOnStatChanged listenerOnStatChanged;
    private final ListenerOnMenuEntryAdded listenerOnMenuEntryAdded;
    private final ListenerOnResetDaily listenerOnResetDaily;
    private final ListenerOnGraphicChanged listenerOnGraphicChanged;
    private final ListenerOnAnimationChanged listenerOnAnimationChanged;
    private final ListenerOnHitsplatApplied listenerOnHitsplatApplied;
    private final ListenerOnWidgetLoaded listenerOnWidgetLoaded;
    private final ListenerOnVarbitChanged listenerOnVarbitChanged;
    private final ListenerOnUserAction listenerOnUserAction;
    private final ListenerOnMenuOptionClicked listenerOnMenuOptionClicked;
    private final ListenerOnScriptPreFired listenerOnScriptPreFired;
    private final ListenerOnCombat listenerOnCombat;
    private final ListenerOnGameTick listenerOnGameTick;

    public boolean inInventory = false;
    public boolean inEquipment = false;

    public ChargedItemBase(
        final String configKey,
        final int itemId,
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store
    ) {
        this.itemId = itemId;
        this.configKey = configKey;

        this.client = client;
        this.clientThread = clientThread;
        this.configManager = configManager;
        this.itemManager = itemManager;
        this.infoBoxManager = infoBoxManager;
        this.chatMessageManager = chatMessageManager;
        this.notifier = notifier;
        this.config = config;
        this.store = store;

        listenerOnChatMessage = new ListenerOnChatMessage(client, itemManager, this, notifier, config);
        listenerOnItemContainerChanged = new ListenerOnItemContainerChanged(client, itemManager, this, notifier, config);
        listenerOnItemPickup = new ListenerOnItemPickup(client, itemManager, this, notifier, config);
        listenerOnXpDrop = new ListenerOnXpDrop(client, itemManager, this, notifier, config);
        listenerOnStatChanged = new ListenerOnStatChanged(client, itemManager, this, notifier, config);
        listenerOnMenuEntryAdded = new ListenerOnMenuEntryAdded(client, itemManager, this, notifier, config);
        listenerOnResetDaily = new ListenerOnResetDaily(client, itemManager, this, notifier, config);
        listenerOnGraphicChanged = new ListenerOnGraphicChanged(client, itemManager, this, notifier, config);
        listenerOnAnimationChanged = new ListenerOnAnimationChanged(client, itemManager, this, notifier, config);
        listenerOnHitsplatApplied = new ListenerOnHitsplatApplied(client, itemManager, this, notifier, config);
        listenerOnWidgetLoaded = new ListenerOnWidgetLoaded(client, itemManager, this, notifier, config);
        listenerOnVarbitChanged = new ListenerOnVarbitChanged(client, itemManager, this, notifier, config);
        listenerOnUserAction = new ListenerOnUserAction(client, itemManager, this, notifier, config);
        listenerOnMenuOptionClicked = new ListenerOnMenuOptionClicked(client, itemManager, this, notifier, config);
        listenerOnScriptPreFired = new ListenerOnScriptPreFired(client, itemManager, this, notifier, config);
        listenerOnCombat = new ListenerOnCombat(client, itemManager, this, notifier, config);
        listenerOnGameTick = new ListenerOnGameTick(client, itemManager, this, notifier, config);
    }

    public abstract String getCharges(final int itemId);

    public abstract String getTotalCharges();

    public boolean inInventory() {
        return inInventory;
    }

    public boolean inEquipment() {
        return inEquipment;
    }

    private boolean inInventoryOrEquipment() {
        return inInventory || inEquipment;
    }

    public String getTooltip() {
        return getItemName() + (needsToBeEquipped() && !inEquipment() ? " (needs to be equipped)" : "") + ": " + ColorUtil.wrapWithColorTag(String.valueOf(getCharges(itemId)), JagexColors.MENU_TARGET);
    }

    @Nonnull
    private TriggerItem getCurrentItem() {
        for (final TriggerItem triggerItem : items) {
            if (triggerItem.itemId == itemId) {
                return triggerItem;
            }
        }

        return null;
    }

    public String getItemName() {
        return itemManager.getItemComposition(itemId).getName();
    }

    public boolean needsToBeEquipped() {
        return getCurrentItem().needsToBeEquipped.isPresent();
    }

    public Color getTextColor() {
        if (getCharges(itemId).equals("?")) {
            return config.getColorUnknown();
        }

        if (getCharges(itemId).equals("0") || needsToBeEquipped() && !inEquipment()) {
            return config.getColorEmpty();
        }

        return config.getColorDefault();
    }

    public Color getTextColor(final int itemId) {
        for (final TriggerItem triggerItem : items) {
            if (triggerItem.itemId == itemId && triggerItem.fixedCharges.isPresent() && triggerItem.fixedCharges.get() == 0) {
                return config.getColorEmpty();
            }
        }

        return getTextColor();
    }

    protected String getChargesMinified(final int charges) {
        // Unlimited.
        if (charges == Charges.UNLIMITED) return INFINITE_SYMBOL;

        // Unknown.
        if (charges == Charges.UNKNOWN) return "?";

        // Show as is.
        if (charges < 1000) return String.valueOf(charges);

        // Minify to use millions (M).
        if (charges >= 1000000) return charges / 1000000 + "M";

        // Minify to use thousands (K).
        final int thousands = charges / 1000;
        final int hundreds = Math.min((charges % 1000 + 50) / 100, 9);
        return thousands + (thousands < 10 && hundreds > 0 ? "." + hundreds : "") + "K";
    }

    public void onChatMessage(final CustomChatMessage event) {
        if (event.message.contains("The banker charges") || inInventoryOrEquipment()) {
            listenerOnChatMessage.trigger(event);
        }
    }

    public void onHitsplatApplied(final CustomHitsplatApplied event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnHitsplatApplied.trigger(event);
    }

    public void onWidgetLoaded(final WidgetLoaded event) {
        if (!inInventoryOrEquipment()) return;
        clientThread.invokeLater(() -> {
            listenerOnWidgetLoaded.trigger(event);
        });
    }

    public void onVarbitChanged(final VarbitChanged event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnVarbitChanged.trigger(event);
    }

    public void onStatChanged(final StatChanged event) {
        listenerOnStatChanged.trigger(event);
        if (!inInventoryOrEquipment()) return;
        listenerOnXpDrop.trigger(event);
    }

    public void onGraphicChanged(final GraphicChanged event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnGraphicChanged.trigger(event);
    }

    public void onAnimationChanged(final AnimationChanged event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnAnimationChanged.trigger(event);
    }

    public void onItemContainerChanged(final CustomItemContainerChanged event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnItemContainerChanged.trigger(event);
    }

    public void onMenuEntryAdded(final MenuEntryAdded event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnMenuEntryAdded.trigger(event);
    }

    public void onItemDespawned(final ItemDespawned event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnItemPickup.trigger(event);
    }

    public void onResetDaily() {
        listenerOnResetDaily.trigger();
    }

    public void onUserAction() {
        if (!inInventoryOrEquipment()) return;
        listenerOnUserAction.trigger();
    }

    public void onMenuOptionClicked(final CustomMenuOptionClicked event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnMenuOptionClicked.trigger(event);
    }

    public void onScriptPreFired(final ScriptPreFired event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnScriptPreFired.trigger(event);
    }

    public void onCombat() {
        if (!inInventoryOrEquipment()) return;
        listenerOnCombat.trigger();
    }

    public void onGameTick(final GameTick event) {
        if (!inInventoryOrEquipment()) return;
        listenerOnGameTick.trigger(event);
    }
}

package tictac7x.charges.customEvents;

import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.item.storage.StorageItem;

import java.util.ArrayList;
import java.util.List;

public class CustomItemContainerChanged {
    public final int itemContainerId;
    private final List<StorageItem> items;

    public CustomItemContainerChanged(final int itemContainerId, final List<StorageItem> items) {
        this.itemContainerId = itemContainerId;
        this.items = items;
    }

    public CustomItemContainerChanged(final ItemContainerChanged event, final ItemManager itemManager) {
        this.itemContainerId = event.getContainerId();
        this.items = new ArrayList<>();

        for (final Item item : event.getItemContainer().getItems()) {
            if (item == null || item.getId() == -1 || item.getId() == 6512) continue;

            final ItemComposition itemComposition = itemManager.getItemComposition(item.getId());
            items.add(new StorageItem(
                itemComposition.getPlaceholderTemplateId() != -1 ? itemComposition.getPlaceholderId() : item.getId(),
                itemComposition.getPlaceholderTemplateId() != -1 ? 0 : item.getQuantity()
            ));
        }
    }

    public CustomItemContainerChanged(final CustomItemContainerChanged previousItemContainerChanged) {
        this.itemContainerId = previousItemContainerChanged.itemContainerId;
        this.items = new ArrayList<>();

        for (final StorageItem item : previousItemContainerChanged.getItems()) {
            items.add(new StorageItem(item.getId(), item.getQuantity()));
        }
    }

    public List<StorageItem> getItems() {
        return items;
    }

    public int size() {
        return items.size();
    }

    public int getContainerId() {
        return itemContainerId;
    }

    public int count(final int itemId) {
        int count = 0;

        for (final StorageItem item : items) {
            if (item.getId() == itemId) {
                count += item.getQuantity();
            }
        }

        return count;
    }

    public boolean hasItem(final int itemId) {
        for (final StorageItem item : items) {
            if (item.getId() == itemId) {
                return true;
            }
        }

        return false;
    }

    public void addStackableItem(final StorageItem itemToAdd) {
        for (final StorageItem item : items) {
            if (item.getId() == itemToAdd.getId()) {
                item.increaseQuantity(itemToAdd.getQuantity());
                return;
            }
        }
    }

    public void addNonStackableItem(final StorageItem itemToAdd) {
        for (int i = 0; i < itemToAdd.getQuantity(); i++) {
            items.add(new StorageItem(itemToAdd.getId(), 1));
        }
    }

    @Override
    public String toString() {
        String string = "ITEM CONTAINER CHANGED: | item container id: " + itemContainerId + "\r\n";

        for (final StorageItem item : items) {
            string += item.getId() + ", quantity: " + item.getQuantity() + "\r\n";
        }

        return string;
    }
}

package tictac7x.charges.customEvents;

import net.runelite.api.Client;
import net.runelite.api.events.MenuOptionClicked;

public class CustomMenuOptionClicked {
    public final int eventId;
    public final String target;
    public final String option;
    public final int actionId;
    public final String action;
    public final int itemId;
    public final int impostorId;

    public CustomMenuOptionClicked(final MenuOptionClicked event, final Client client) {
        this.eventId = event.getId();
        this.target = event.getMenuTarget().replaceAll("</?col.*?>", "");
        this.option = event.getMenuOption().replaceAll("</?col.*?>", "");
        this.actionId = event.getMenuAction().getId();
        this.action = event.getMenuAction().name();
        this.itemId = event.getItemId();

        int impostorId = -1;
        try {
            impostorId = client.getObjectDefinition(event.getMenuEntry().getIdentifier()).getImpostor().getId();
        } catch (final Exception ignored) {}
        this.impostorId = impostorId;
    }

    @Override
    public String toString() {
        return ("MENU OPTION CLICKED | " +
            "event id: " + eventId +
            ", option: \"" + option + "\"" +
            ", target: \"" + target + "\"" +
            ", action id: " + actionId +
            ", action name: \"" + action + "\"" +
            ", item id: " + itemId +
            ", impostor id: " + impostorId
        );
    }
}

package tictac7x.charges.customEvents;

import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.events.HitsplatApplied;

public class CustomHitsplatApplied {
    public final Actor actor;
    public final int type;
    public final int amount;
    public final boolean toMe;
    public final boolean byMe;

    public CustomHitsplatApplied(final HitsplatApplied event, final Client client) {
        this.actor = event.getActor();
        this.type = event.getHitsplat().getHitsplatType();
        this.amount = event.getHitsplat().getAmount();
        this.toMe = event.getActor() == client.getLocalPlayer();
        this.byMe = event.getHitsplat().isMine();
    }

    @Override
    public String toString() {
        return ("HITSPLAT | " +
			"actor: " + (toMe ? "me" : "enemy -> " + actor.getName()) +
			", type: " + type +
			", amount:" + amount +
			", by others: " + !byMe +
			", by me: " + byMe
		);
    }
}

package tictac7x.charges.customEvents;

import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;

public class CustomChatMessage {
    public final ChatMessageType type;
    public final String message;
    private final String sender;

    public CustomChatMessage(final ChatMessage event) {
        this.type = event.getType();
        this.message = event.getMessage().replaceAll("</?col.*?>", "").replaceAll("<br>", " ").replaceAll("\u00A0"," ");
        this.sender = event.getSender();
    }

    @Override
    public String toString() {
        return ("MESSAGE | " +
            "type: " + type.name() +
            ", message: " + message +
            ", sender: " + sender
        );
    }
}

package tictac7x.charges.store;

import net.runelite.api.gameval.AnimationID;

public class AnimationId {
    public static final int HUMAN_BOW = AnimationID.HUMAN_BOW;
    public static final int CHUGGING_BARREL_DRINK = AnimationID.PREPOT_DEVICE_DRINK_FULL;
    public static final int SLAYER_STAFF_CAST = AnimationID.SLAYER_MAGICDART_CAST;
    public static final int QUETZAL_WHISTLE_BIRD = AnimationID.HUMAN_QUETZAL_WHISTLE;
    public static final int RING_OF_SHADOWS_TELEPORT = AnimationID.MAHJARRAT_HUMAN_DISAPPEAR_01_NOHELD_QUICK;
}

package tictac7x.charges.store;

import java.util.concurrent.Callable;

public class DynamicReplaceTarget {
    public final String target;
    public final Callable<String> replace;

    public DynamicReplaceTarget(final String target, final Callable<String> replace) {
        this.target = target;
        this.replace = replace;
    }
}

package tictac7x.charges.store;

public enum HitsplatGroup {
    ALL,
    SUCCESSFUL,
}

package tictac7x.charges.store;

public class ReplaceTarget {
    public final String target;
    public final String replace;

    public ReplaceTarget(final String target, final String replace) {
        this.target = target;
        this.replace = replace;
    }
}

package tictac7x.charges.store;

public enum ItemActivity {
    DEACTIVATED,
    ACTIVATED
}

package tictac7x.charges.store;

public class Charges {
    public static final int UNKNOWN = -1;
    public static final int UNLIMITED = -2;
}

package tictac7x.charges.store;

public final class WidgetId {
    public static final int[] BANK = new int[]{12, 1};
    public static final int[] DEPOSIT_BOX = new int[]{192, 1};
}
package tictac7x.charges.store;

public enum ItemOverlayLocation {
    BOTTOM_LEFT,
    BOTTOM_RIGHT,
    TOP_LEFT,
    TOP_RIGHT,
}

package tictac7x.charges.store;

import net.runelite.api.gameval.VarbitID;

public class VarbitId {
    public static final int MAGIC_CAPE_CHARGES_USED = VarbitID.SB_SWAP_CHECK;
    public static final int MINUTES = VarbitID.CLOCK;
}

package tictac7x.charges.store;


import net.runelite.api.gameval.InventoryID;

public final class ItemContainerId {
    public static final int INVENTORY = InventoryID.INV;
    public static final int BANK = InventoryID.BANK;
    public static final int SEED_BOX = InventoryID.SEED_BOX;
    public static final int TACKLE_BOX = InventoryID.TACKLE_BOX;
    public static final int FORESTRY_KIT = InventoryID.FORESTRY_KIT;
    public static final int HUNTSMANS_KIT = InventoryID.HUNTSMANS_KIT;
    public static final int CHUGGING_BARREL = InventoryID.PREPOT_DEVICE_INV;
}
package tictac7x.charges.store;

public enum HitsplatTarget {
    SELF,
    ENEMY
}

package tictac7x.charges.store;

import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.customEvents.CustomChatMessage;
import tictac7x.charges.customEvents.CustomHitsplatApplied;
import tictac7x.charges.customEvents.CustomMenuOptionClicked;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.customEvents.CustomItemContainerChanged;
import tictac7x.charges.item.storage.StorageItems;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.awt.Font.DIALOG;
import static net.runelite.api.ChatMessageType.GAMEMESSAGE;
import static net.runelite.api.ChatMessageType.SPAM;

public class Store {
    private final Client client;
    private final ItemManager itemManager;
    private final ConfigManager configManager;
    private final int HIGHEST_MONSTER_ATTACK_SPEED = 8;

    private int gametick = 0;
    private int gametick_before = 0;
    private int inCombatTicksRemainingDamageDoneToOthers = 0;
    private int inCombatTicksRemainingDamageDoneToMe = 0;

    private ChargedItemBase[] chargedItems = new ChargedItemBase[]{};
    private List<Integer> dailyResetItemIds = new ArrayList<>();
    private int lastChatMessagesTick = 0;
    private List<String> lastChatMessages = new ArrayList<>();

    public CustomItemContainerChanged inventory = new CustomItemContainerChanged(InventoryID.INVENTORY.getId(), new ArrayList<>());
    public CustomItemContainerChanged previousInventory = new CustomItemContainerChanged(InventoryID.INVENTORY.getId(), new ArrayList<>());
    public CustomItemContainerChanged equipment = new CustomItemContainerChanged(InventoryID.EQUIPMENT.getId(), new ArrayList<>());
    public CustomItemContainerChanged bank = new CustomItemContainerChanged(InventoryID.BANK.getId(), new ArrayList<>());
    public CustomItemContainerChanged previousBank = new CustomItemContainerChanged(InventoryID.BANK.getId(), new ArrayList<>());


    public final Queue<Runnable> nextTickQueue = new ArrayDeque<>();
    public final List<CustomMenuOptionClicked> menuOptionsClicked = new ArrayList<>();
    private final Map<Skill, Integer> skillsXp = new HashMap<>();

    final Pattern withdrawPattern = Pattern.compile("Withdraw-(?<amount>.+)");

    public Store(final Client client, final ItemManager itemManager, final ConfigManager configManager) {
        this.client = client;
        this.itemManager = itemManager;
        this.configManager = configManager;
    }

    public List<String> getLastChatMessages() {
        return lastChatMessages;
    }

    public void onChatMessage(final CustomChatMessage chatMessage) {
        switch (chatMessage.type) {
            case GAMEMESSAGE:
            case DIALOG:
            case SPAM:
                break;
            default:
                return;
        }

        final int tick = client.getTickCount();
        if (tick != lastChatMessagesTick) {
            lastChatMessages = new ArrayList<>();
            lastChatMessagesTick = tick;
        }

        lastChatMessages.add(chatMessage.message);
    }

    public void setChargedItems(final ChargedItemBase[] chargedItems) {
        this.chargedItems = chargedItems;

        List<Integer> dailyResetItemIds = new ArrayList<>();
        Arrays.stream(chargedItems).filter(chargedItem -> {
            for (final TriggerBase trigger : chargedItem.triggers) {
                if (trigger instanceof OnResetDaily) {
                    return true;
                }
            }
            return false;
        }).forEach(chargedItem -> {
            for (final TriggerItem triggerItem : chargedItem.items) {
                dailyResetItemIds.add(triggerItem.itemId);
            }
        });
        this.dailyResetItemIds = dailyResetItemIds;
    }

    public Optional<Integer> getSkillXp(final Skill skill) {
        if (skillsXp.containsKey(skill)) {
            return Optional.of(skillsXp.get(skill));
        }

        return Optional.empty();
    }

    public int getInventoryEmptySlots() {
        return 28 - inventory.size();
    }

    public void onStatChanged(final StatChanged event) {
        skillsXp.put(event.getSkill(), event.getXp());
    }

    public void onItemContainerChanged(final CustomItemContainerChanged itemContainerChanged) {
        runNextGameTickQueue();

        if (
            itemContainerChanged.getContainerId() == InventoryID.BANK.getId() ||
            itemContainerChanged.getContainerId() == InventoryID.INVENTORY.getId() ||
            itemContainerChanged.getContainerId() == InventoryID.EQUIPMENT.getId()
        ) {
            // Update inventory, save previous items.
            if (itemContainerChanged.getContainerId() == InventoryID.INVENTORY.getId()) {
                previousInventory = inventory;
                inventory = itemContainerChanged;
            } else if (itemContainerChanged.getContainerId() == InventoryID.EQUIPMENT.getId()) {
                equipment = itemContainerChanged;
            } else if (itemContainerChanged.getContainerId() == InventoryID.BANK.getId()) {
                previousBank = bank;
                bank = itemContainerChanged;

                final StringBuilder storageStringBuilder = new StringBuilder();
                for (final StorageItem item : itemContainerChanged.getItems()) {
                    storageStringBuilder.append(item.getId()).append(",");
                }
                final String storageString = storageStringBuilder.toString().replaceAll(",$", "");
                configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.storage_bank, storageString);
            }

            updateChargedItemsPrimaryId(itemContainerChanged.getContainerId() == InventoryID.BANK.getId());
        }

        for (final ChargedItemBase infobox : chargedItems) {
            infobox.onItemContainerChanged(itemContainerChanged);
        }
    }

    private void updateChargedItemsPrimaryId(final boolean checkBank) {
        for (final ChargedItemBase chargedItem : chargedItems) {
            Optional<Integer> bankItemId = Optional.empty();
            boolean bankItemDynamic = false;

            Optional<Integer> inventoryItemId = Optional.empty();
            boolean inventoryItemDynamic = false;

            Optional<Integer> equipmentItemId = Optional.empty();
            boolean equipmentItemDynamic = false;

            // Bank has the least priority.
            if (checkBank) {
                for (final StorageItem item : bank.getItems()) {
                    for (final TriggerItem triggerItem : chargedItem.items) {
                        if (item.getId() == triggerItem.itemId) {
                            if (!bankItemId.isPresent() || triggerItem.fixedCharges.isPresent() && !bankItemDynamic || !triggerItem.fixedCharges.isPresent()) {
                                bankItemId = Optional.of(item.getId());

                                if (!triggerItem.fixedCharges.isPresent()) {
                                    bankItemDynamic = true;
                                }
                            }
                        }
                    }
                }
            }

            // Inventory is more important than bank.
            for (final StorageItem item : inventory.getItems()) {
                for (final TriggerItem triggerItem : chargedItem.items) {
                    if (item.getId() == triggerItem.itemId) {
                        if (!inventoryItemId.isPresent() || triggerItem.fixedCharges.isPresent() && !inventoryItemDynamic || !triggerItem.fixedCharges.isPresent()) {
                            inventoryItemId = Optional.of(item.getId());

                            if (!triggerItem.fixedCharges.isPresent()) {
                                inventoryItemDynamic = true;
                            }
                        }
                    }
                }
            }

            // Equipment has most priority.
            for (final StorageItem item : equipment.getItems()) {
                for (final TriggerItem triggerItem : chargedItem.items) {
                    if (item.getId() == triggerItem.itemId) {
                        if (!equipmentItemId.isPresent() || triggerItem.fixedCharges.isPresent() && !equipmentItemDynamic || !triggerItem.fixedCharges.isPresent()) {
                            equipmentItemId = Optional.of(item.getId());

                            if (!triggerItem.fixedCharges.isPresent()) {
                                equipmentItemDynamic = true;
                            }
                        }
                    }
                }
            }

            chargedItem.inEquipment = equipmentItemId.isPresent();
            chargedItem.inInventory = inventoryItemId.isPresent();
            chargedItem.itemId =
                equipmentItemId.isPresent() ? equipmentItemId.get() :
                inventoryItemId.isPresent() ? inventoryItemId.get() :
                bankItemId.isPresent() ? bankItemId.get() :
                chargedItem.itemId;
        }
    }

    public void onMenuOptionClicked(final CustomMenuOptionClicked customMenuOptionClicked) {
        checkBankWithdraw(customMenuOptionClicked);

        // Gametick changed, clear previous menu entries since they are no longer valid.
        if (gametick >= gametick_before + 2) {
            gametick = 0; gametick_before = 0;
            menuOptionsClicked.clear();
        }

        // Save menu option and target for other triggers to use.
        menuOptionsClicked.add(customMenuOptionClicked);
    }

    private void checkBankWithdraw(final CustomMenuOptionClicked customMenuOptionClicked) {
        final Matcher matcher = withdrawPattern.matcher(customMenuOptionClicked.option);
        if (!matcher.find()) return;

        final String amountString = matcher.group("amount");
        if (amountString.equals("X")) return;

        final int amount =
            amountString.equals("All") ? bank.count(customMenuOptionClicked.itemId) :
            amountString.equals("All-but-1") ? bank.count(customMenuOptionClicked.itemId) - 1 :
            Integer.parseInt(amountString);

        final ItemComposition itemComposition = itemManager.getItemComposition(customMenuOptionClicked.itemId);

        // Copy of current inventory.
        final CustomItemContainerChanged itemContainerChanged = new CustomItemContainerChanged(inventory);

        // Add new items.
        if (itemComposition.isStackable() || client.getVarbitValue(3958) == 1) {
            itemContainerChanged.addStackableItem(new StorageItem(customMenuOptionClicked.itemId, amount));
        } else {
            itemContainerChanged.addNonStackableItem(new StorageItem(customMenuOptionClicked.itemId, Math.min(amount, 28 - inventory.getItems().size())));
        }

        onItemContainerChanged(itemContainerChanged);
    }

    private void runNextGameTickQueue() {
        while (!nextTickQueue.isEmpty()) {
            final Runnable consumer = nextTickQueue.poll();
            consumer.run();
        }
    }

    public void onGameTick(final GameTick ignored) {
        runNextGameTickQueue();

        // Automatically load all skill xps.
        if (!getSkillXp(Skill.MAGIC).isPresent()) {
            skillsXp.put(Skill.AGILITY, client.getSkillExperience(Skill.AGILITY));
            skillsXp.put(Skill.ATTACK, client.getSkillExperience(Skill.ATTACK));
            skillsXp.put(Skill.CONSTRUCTION, client.getSkillExperience(Skill.CONSTRUCTION));
            skillsXp.put(Skill.COOKING, client.getSkillExperience(Skill.COOKING));
            skillsXp.put(Skill.CRAFTING, client.getSkillExperience(Skill.CRAFTING));
            skillsXp.put(Skill.DEFENCE, client.getSkillExperience(Skill.DEFENCE));
            skillsXp.put(Skill.FARMING, client.getSkillExperience(Skill.FARMING));
            skillsXp.put(Skill.FIREMAKING, client.getSkillExperience(Skill.FIREMAKING));
            skillsXp.put(Skill.FISHING, client.getSkillExperience(Skill.FISHING));
            skillsXp.put(Skill.FLETCHING, client.getSkillExperience(Skill.FLETCHING));
            skillsXp.put(Skill.HERBLORE, client.getSkillExperience(Skill.HERBLORE));
            skillsXp.put(Skill.HITPOINTS, client.getSkillExperience(Skill.HITPOINTS));
            skillsXp.put(Skill.HUNTER, client.getSkillExperience(Skill.HUNTER));
            skillsXp.put(Skill.MAGIC, client.getSkillExperience(Skill.MAGIC));
            skillsXp.put(Skill.MINING, client.getSkillExperience(Skill.MINING));
            skillsXp.put(Skill.PRAYER, client.getSkillExperience(Skill.PRAYER));
            skillsXp.put(Skill.RANGED, client.getSkillExperience(Skill.RANGED));
            skillsXp.put(Skill.RUNECRAFT, client.getSkillExperience(Skill.RUNECRAFT));
            skillsXp.put(Skill.SLAYER, client.getSkillExperience(Skill.SLAYER));
            skillsXp.put(Skill.SMITHING, client.getSkillExperience(Skill.SMITHING));
            skillsXp.put(Skill.STRENGTH, client.getSkillExperience(Skill.STRENGTH));
            skillsXp.put(Skill.THIEVING, client.getSkillExperience(Skill.THIEVING));
            skillsXp.put(Skill.WOODCUTTING, client.getSkillExperience(Skill.WOODCUTTING));
        }
        gametick++;

        // Keep only last menu entry.
        if (menuOptionsClicked.size() > 1) {
            final CustomMenuOptionClicked lastMenuEntry = menuOptionsClicked.get(menuOptionsClicked.size() - 1);
            menuOptionsClicked.clear();
            menuOptionsClicked.add(lastMenuEntry);
        }

        if (isInCombat()) {
            for (final ChargedItemBase chargedItem : chargedItems) {
                chargedItem.onCombat();
            }
        }

        inCombatTicksRemainingDamageDoneToOthers = Math.max(0, inCombatTicksRemainingDamageDoneToOthers - 1);
        inCombatTicksRemainingDamageDoneToMe = Math.max(0, inCombatTicksRemainingDamageDoneToMe - 1);
    }

    public boolean inMenuTargets(final int ...itemIds) {
        final String[] targets = new String[itemIds.length];

        for (int i = 0; i < itemIds.length; i++) {
            targets[i] = itemManager.getItemComposition(itemIds[i]).getName();
        }

        return inMenuTargets(targets);
    }

    public boolean inMenuTargets(final String ...targets) {
        for (final String target : targets) {
            for (final CustomMenuOptionClicked customMenuOptionClicked : menuOptionsClicked) {
                if (customMenuOptionClicked.target.contains(target)) {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean notInMenuTargets(final String ...targets) {
        return !inMenuTargets(targets);
    }

    public boolean notInMenuTargets(final StorageItem... storageItems) {
        final int[] storeableItemIds = new int[storageItems.length];

        for (int i = 0; i < storageItems.length; i ++) {
            storeableItemIds[i] = storageItems[i].getId();
        }

        return notInMenuTargets(storeableItemIds);
    }

    public boolean notInMenuTargets(final int ...itemIds) {
        return !inMenuTargets(itemIds);
    }

    public boolean inMenuOptions(final String ...options) {
        for (final CustomMenuOptionClicked customMenuOptionClicked : menuOptionsClicked) {
            for (final String option : options) {
                if (customMenuOptionClicked.option.equals(option)) {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean notInMenuOptions(final String ...options) {
        return !inMenuOptions(options);
    }

    public boolean inMenuOptionIds(final int ...menuOptionIds) {
        for (final CustomMenuOptionClicked customMenuOptionClicked : menuOptionsClicked) {
            for (final int menuOptionId : menuOptionIds) {
                if (customMenuOptionClicked.eventId == menuOptionId) {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean notInMenuOptionIds(final int ...menuOptionsIds) {
        return !inMenuOptionIds(menuOptionsIds);
    }

    public boolean inMenuImpostors(final int ...impostorIds) {
        for (final CustomMenuOptionClicked customMenuOptionClicked : menuOptionsClicked) {
            for (final int impostorId : impostorIds) {
                if (customMenuOptionClicked.impostorId == impostorId) {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean notInMenuImpostors(final int ...impostorIds) {
        return !inMenuImpostors(impostorIds);
    }

    public int getInventoryItemQuantity(final int itemId) {
        int quantity = 0;

        for (final StorageItem storageItem : inventory.getItems()) {
            if (storageItem.getId() == itemId) {
                quantity += storageItem.getQuantity();
            }
        }

        return quantity;
    }

    public int getEquipmentItemQuantity(final int itemId) {
        int quantity = 0;

        for (final StorageItem item : equipment.getItems()) {
            if (item.getId() == itemId) {
                quantity += item.getQuantity();
            }
        }

        return quantity;
    }

    public int getPreviousInventoryItemQuantity(final int itemId) {
        int quantity = 0;

        for (final StorageItem storageItem : previousInventory.getItems()) {
            if (storageItem.getId() == itemId) {
                quantity += storageItem.getQuantity();
            }
        }

        return quantity;
    }

    public boolean inventoryContainsItem(final int itemId) {
        for (final StorageItem storageItem : inventory.getItems()) {
            if (storageItem.getId() == itemId) {
                return true;
            }
        }

        return false;
    }

    public boolean equipmentContainsItem(final int ...itemIds) {
        for (final StorageItem equipmentItem : equipment.getItems()) {
            for (final int itemId : itemIds) {
                if (equipmentItem.getId() == itemId) {
                    return true;
                }
            }
        }

        return false;
    }

    private List<StorageItem> getAllItems() {
        final List<StorageItem> allItems = new ArrayList<>();
        allItems.addAll(inventory.getItems());
        allItems.addAll(equipment.getItems());
        allItems.addAll(bank.getItems());
        return allItems;
    }

    public boolean itemInPossession(final int itemId) {
        for (final StorageItem item : getAllItems()) {
            if (item.getId() == itemId) {
                return true;
            }
        }

        return false;
    }

    public StorageItems getInventoryItemsDifference() {
        final StorageItems itemsDifference = new StorageItems();

        final Map<Integer, Integer> quantitiesNew = new HashMap<>();
        final Map<Integer, Integer> quantitiesBefore = new HashMap<>();

        for (final StorageItem itemNew : inventory.getItems()) {
            if (quantitiesNew.containsKey(itemNew.getId())) continue;
            quantitiesNew.put(itemNew.getId(), inventory.count(itemNew.getId()));
        }

        for (final StorageItem itemOld : previousInventory.getItems()) {
            if (quantitiesBefore.containsKey(itemOld.getId())) {
                quantitiesBefore.put(itemOld.getId(), quantitiesBefore.get(itemOld.getId()) + itemOld.getQuantity());
            } else {
                quantitiesBefore.put(itemOld.getId(), itemOld.getQuantity());
            }
        }

        for (final int itemId : quantitiesNew.keySet()) {
            final int quantity = quantitiesNew.get(itemId) - quantitiesBefore.getOrDefault(itemId, 0);
            if (quantity != 0) {
                itemsDifference.put(new StorageItem(itemId, quantitiesNew.get(itemId) - quantitiesBefore.getOrDefault(itemId, 0)));
            }
        }

        for (final int itemId : quantitiesBefore.keySet()) {
            if (!quantitiesNew.containsKey(itemId)) {
                itemsDifference.put(new StorageItem(itemId, -quantitiesBefore.get(itemId)));
            }
        }

        return itemsDifference;
    }

    public StorageItems getBankItemsDifference() {
        final StorageItems itemsDifference = new StorageItems();

        final Map<Integer, Integer> quantitiesNew = new HashMap<>();
        final Map<Integer, Integer> quantitiesBefore = new HashMap<>();

        for (final StorageItem itemNew : bank.getItems()) {
            if (quantitiesNew.containsKey(itemNew.getId())) continue;
            quantitiesNew.put(itemNew.getId(), bank.count(itemNew.getId()));
        }

        for (final StorageItem itemOld : previousBank.getItems()) {
            if (quantitiesBefore.containsKey(itemOld.getId())) {
                quantitiesBefore.put(itemOld.getId(), quantitiesBefore.get(itemOld.getId()) + itemOld.getQuantity());
            } else {
                quantitiesBefore.put(itemOld.getId(), itemOld.getQuantity());
            }
        }

        for (final int itemId : quantitiesNew.keySet()) {
            final int quantity = quantitiesNew.get(itemId) - quantitiesBefore.getOrDefault(itemId, 0);
            if (quantity != 0) {
                itemsDifference.put(new StorageItem(itemId, quantitiesNew.get(itemId) - quantitiesBefore.getOrDefault(itemId, 0)));
            }
        }

        for (final int itemId : quantitiesBefore.keySet()) {
            if (!quantitiesNew.containsKey(itemId)) {
                itemsDifference.put(new StorageItem(itemId, -quantitiesBefore.get(itemId)));
            }
        }

        return itemsDifference;
    }

    public void addConsumerToNextTickQueue(final Runnable consumer) {
        nextTickQueue.add(consumer);
    }

    public void onHitSplatApplied(final CustomHitsplatApplied event) {
        if (event.byMe) {
            inCombatTicksRemainingDamageDoneToOthers = HIGHEST_MONSTER_ATTACK_SPEED;
        }

        if (event.toMe) {
            inCombatTicksRemainingDamageDoneToMe = HIGHEST_MONSTER_ATTACK_SPEED;
        }
    }

    public void onGraphicChanged(final GraphicChanged event) {
        if (event.getActor() == client.getLocalPlayer() && event.getActor().getGraphic() == GraphicID.SPLASH) {
            inCombatTicksRemainingDamageDoneToOthers = HIGHEST_MONSTER_ATTACK_SPEED;
        }
    }

    public boolean isInCombat() {
        return inCombatTicksRemainingDamageDoneToOthers > 0;
    }

    public boolean isLockedInCombat() {
        return inCombatTicksRemainingDamageDoneToMe > 0;
    }
}

package tictac7x.charges.store;

import net.runelite.api.gameval.ItemID;

public class ItemId {
    // Ahrim set
    public static final int AHRIMS_HOOD = ItemID.BARROWS_AHRIM_HEAD;
    public static final int AHRIMS_HOOD_100 = ItemID.BARROWS_AHRIM_HEAD_100;
    public static final int AHRIMS_HOOD_75 = ItemID.BARROWS_AHRIM_HEAD_75;
    public static final int AHRIMS_HOOD_50 = ItemID.BARROWS_AHRIM_HEAD_50;
    public static final int AHRIMS_HOOD_25 = ItemID.BARROWS_AHRIM_HEAD_25;
    public static final int AHRIMS_HOOD_0 = ItemID.BARROWS_AHRIM_HEAD_BROKEN;
    public static final int AHRIMS_ROBETOP = ItemID.BARROWS_AHRIM_BODY;
    public static final int AHRIMS_ROBETOP_100 = ItemID.BARROWS_AHRIM_BODY_100;
    public static final int AHRIMS_ROBETOP_75 = ItemID.BARROWS_AHRIM_BODY_75;
    public static final int AHRIMS_ROBETOP_50 = ItemID.BARROWS_AHRIM_BODY_50;
    public static final int AHRIMS_ROBETOP_25 = ItemID.BARROWS_AHRIM_BODY_25;
    public static final int AHRIMS_ROBETOP_0 = ItemID.BARROWS_AHRIM_BODY_BROKEN;
    public static final int AHRIMS_ROBESKIRT = ItemID.BARROWS_AHRIM_LEGS;
    public static final int AHRIMS_ROBESKIRT_100 = ItemID.BARROWS_AHRIM_LEGS_100;
    public static final int AHRIMS_ROBESKIRT_75 = ItemID.BARROWS_AHRIM_LEGS_75;
    public static final int AHRIMS_ROBESKIRT_50 = ItemID.BARROWS_AHRIM_LEGS_50;
    public static final int AHRIMS_ROBESKIRT_25 = ItemID.BARROWS_AHRIM_LEGS_25;
    public static final int AHRIMS_ROBESKIRT_0 = ItemID.BARROWS_AHRIM_LEGS_BROKEN;
    public static final int AHRIMS_STAFF = ItemID.BARROWS_AHRIM_WEAPON;
    public static final int AHRIMS_STAFF_100 = ItemID.BARROWS_AHRIM_WEAPON_100;
    public static final int AHRIMS_STAFF_75 = ItemID.BARROWS_AHRIM_WEAPON_75;
    public static final int AHRIMS_STAFF_50 = ItemID.BARROWS_AHRIM_WEAPON_50;
    public static final int AHRIMS_STAFF_25 = ItemID.BARROWS_AHRIM_WEAPON_25;
    public static final int AHRIMS_STAFF_0 = ItemID.BARROWS_AHRIM_WEAPON_BROKEN;

    // Dharok set
    public static final int DHAROKS_HELM = ItemID.BARROWS_AHRIM_HEAD;
    public static final int DHAROKS_HELM_100 = ItemID.BARROWS_AHRIM_HEAD_100;
    public static final int DHAROKS_HELM_75 = ItemID.BARROWS_AHRIM_HEAD_75;
    public static final int DHAROKS_HELM_50 = ItemID.BARROWS_AHRIM_HEAD_50;
    public static final int DHAROKS_HELM_25 = ItemID.BARROWS_AHRIM_HEAD_25;
    public static final int DHAROKS_HELM_0 = ItemID.BARROWS_AHRIM_HEAD_BROKEN;
    public static final int DHAROKS_PLATEBODY = ItemID.BARROWS_DHAROK_BODY;
    public static final int DHAROKS_PLATEBODY_100 = ItemID.BARROWS_DHAROK_BODY_100;
    public static final int DHAROKS_PLATEBODY_75 = ItemID.BARROWS_DHAROK_BODY_75;
    public static final int DHAROKS_PLATEBODY_50 = ItemID.BARROWS_DHAROK_BODY_50;
    public static final int DHAROKS_PLATEBODY_25 = ItemID.BARROWS_DHAROK_BODY_25;
    public static final int DHAROKS_PLATEBODY_0 = ItemID.BARROWS_DHAROK_BODY_BROKEN;
    public static final int DHAROKS_PLATELEGS = ItemID.BARROWS_DHAROK_LEGS;
    public static final int DHAROKS_PLATELEGS_100 = ItemID.BARROWS_DHAROK_LEGS_100;
    public static final int DHAROKS_PLATELEGS_75 = ItemID.BARROWS_DHAROK_LEGS_75;
    public static final int DHAROKS_PLATELEGS_50 = ItemID.BARROWS_DHAROK_LEGS_50;
    public static final int DHAROKS_PLATELEGS_25 = ItemID.BARROWS_DHAROK_LEGS_25;
    public static final int DHAROKS_PLATELEGS_0 = ItemID.BARROWS_DHAROK_LEGS_BROKEN;
    public static final int DHAROKS_GREATAXE = ItemID.BARROWS_DHAROK_WEAPON;
    public static final int DHAROKS_GREATAXE_100 = ItemID.BARROWS_DHAROK_WEAPON_100;
    public static final int DHAROKS_GREATAXE_75 = ItemID.BARROWS_DHAROK_WEAPON_75;
    public static final int DHAROKS_GREATAXE_50 = ItemID.BARROWS_DHAROK_WEAPON_50;
    public static final int DHAROKS_GREATAXE_25 = ItemID.BARROWS_DHAROK_WEAPON_25;
    public static final int DHAROKS_GREATAXE_0 = ItemID.BARROWS_DHAROK_WEAPON_BROKEN;

    // Guthan set
    public static final int GUTHANS_HELM = ItemID.BARROWS_GUTHAN_HEAD;
    public static final int GUTHANS_HELM_100 = ItemID.BARROWS_GUTHAN_HEAD_100;
    public static final int GUTHANS_HELM_75 = ItemID.BARROWS_GUTHAN_HEAD_75;
    public static final int GUTHANS_HELM_50 = ItemID.BARROWS_GUTHAN_HEAD_50;
    public static final int GUTHANS_HELM_25 = ItemID.BARROWS_GUTHAN_HEAD_25;
    public static final int GUTHANS_HELM_0 = ItemID.BARROWS_GUTHAN_HEAD_BROKEN;
    public static final int GUTHANS_PLATEBODY = ItemID.BARROWS_GUTHAN_BODY;
    public static final int GUTHANS_PLATEBODY_100 = ItemID.BARROWS_GUTHAN_BODY_100;
    public static final int GUTHANS_PLATEBODY_75 = ItemID.BARROWS_GUTHAN_BODY_75;
    public static final int GUTHANS_PLATEBODY_50 = ItemID.BARROWS_GUTHAN_BODY_50;
    public static final int GUTHANS_PLATEBODY_25 = ItemID.BARROWS_GUTHAN_BODY_25;
    public static final int GUTHANS_PLATEBODY_0 = ItemID.BARROWS_GUTHAN_BODY_BROKEN;
    public static final int GUTHANS_CHAINSKIRT = ItemID.BARROWS_GUTHAN_LEGS;
    public static final int GUTHANS_CHAINSKIRT_100 = ItemID.BARROWS_GUTHAN_LEGS_100;
    public static final int GUTHANS_CHAINSKIRT_75 = ItemID.BARROWS_GUTHAN_LEGS_75;
    public static final int GUTHANS_CHAINSKIRT_50 = ItemID.BARROWS_GUTHAN_LEGS_50;
    public static final int GUTHANS_CHAINSKIRT_25 = ItemID.BARROWS_GUTHAN_LEGS_25;
    public static final int GUTHANS_CHAINSKIRT_0 = ItemID.BARROWS_GUTHAN_LEGS_BROKEN;
    public static final int GUTHANS_WARSPEAR = ItemID.BARROWS_GUTHAN_WEAPON;
    public static final int GUTHANS_WARSPEAR_100 = ItemID.BARROWS_GUTHAN_WEAPON_100;
    public static final int GUTHANS_WARSPEAR_75 = ItemID.BARROWS_GUTHAN_WEAPON_75;
    public static final int GUTHANS_WARSPEAR_50 = ItemID.BARROWS_GUTHAN_WEAPON_50;
    public static final int GUTHANS_WARSPEAR_25 = ItemID.BARROWS_GUTHAN_WEAPON_25;
    public static final int GUTHANS_WARSPEAR_0 = ItemID.BARROWS_GUTHAN_WEAPON_BROKEN;

    // Karil
    public static final int KARILS_COIF = ItemID.BARROWS_KARIL_HEAD;
    public static final int KARILS_COIF_100 = ItemID.BARROWS_KARIL_HEAD_100;
    public static final int KARILS_COIF_75 = ItemID.BARROWS_KARIL_HEAD_75;
    public static final int KARILS_COIF_50 = ItemID.BARROWS_KARIL_HEAD_50;
    public static final int KARILS_COIF_25 = ItemID.BARROWS_KARIL_HEAD_25;
    public static final int KARILS_COIF_0 = ItemID.BARROWS_KARIL_HEAD_BROKEN;
    public static final int KARILS_LEATHERTOP = ItemID.BARROWS_KARIL_BODY;
    public static final int KARILS_LEATHERTOP_100 = ItemID.BARROWS_KARIL_BODY_100;
    public static final int KARILS_LEATHERTOP_75 = ItemID.BARROWS_KARIL_BODY_75;
    public static final int KARILS_LEATHERTOP_50 = ItemID.BARROWS_KARIL_BODY_50;
    public static final int KARILS_LEATHERTOP_25 = ItemID.BARROWS_KARIL_BODY_25;
    public static final int KARILS_LEATHERTOP_0 = ItemID.BARROWS_KARIL_BODY_BROKEN;
    public static final int KARILS_LEATHERSKIRT = ItemID.BARROWS_KARIL_LEGS;
    public static final int KARILS_LEATHERSKIRT_100 = ItemID.BARROWS_KARIL_LEGS_100;
    public static final int KARILS_LEATHERSKIRT_75 = ItemID.BARROWS_KARIL_LEGS_75;
    public static final int KARILS_LEATHERSKIRT_50 = ItemID.BARROWS_KARIL_LEGS_50;
    public static final int KARILS_LEATHERSKIRT_25 = ItemID.BARROWS_KARIL_LEGS_25;
    public static final int KARILS_LEATHERSKIRT_0 = ItemID.BARROWS_KARIL_LEGS_BROKEN;
    public static final int KARILS_CROSSBOW = ItemID.BARROWS_KARIL_WEAPON;
    public static final int KARILS_CROSSBOW_100 = ItemID.BARROWS_KARIL_WEAPON_100;
    public static final int KARILS_CROSSBOW_75 = ItemID.BARROWS_KARIL_WEAPON_75;
    public static final int KARILS_CROSSBOW_50 = ItemID.BARROWS_KARIL_WEAPON_50;
    public static final int KARILS_CROSSBOW_25 = ItemID.BARROWS_KARIL_WEAPON_25;
    public static final int KARILS_CROSSBOW_0 = ItemID.BARROWS_KARIL_WEAPON_BROKEN;

    // Torag
    public static final int TORAGS_HELM = ItemID.BARROWS_TORAG_HEAD;
    public static final int TORAGS_HELM_100 = ItemID.BARROWS_TORAG_HEAD_100;
    public static final int TORAGS_HELM_75 = ItemID.BARROWS_TORAG_HEAD_75;
    public static final int TORAGS_HELM_50 = ItemID.BARROWS_TORAG_HEAD_50;
    public static final int TORAGS_HELM_25 = ItemID.BARROWS_TORAG_HEAD_25;
    public static final int TORAGS_HELM_0 = ItemID.BARROWS_TORAG_HEAD_BROKEN;
    public static final int TORAGS_PLATEBODY = ItemID.BARROWS_TORAG_BODY;
    public static final int TORAGS_PLATEBODY_100 = ItemID.BARROWS_TORAG_BODY_100;
    public static final int TORAGS_PLATEBODY_75 = ItemID.BARROWS_TORAG_BODY_75;
    public static final int TORAGS_PLATEBODY_50 = ItemID.BARROWS_TORAG_BODY_50;
    public static final int TORAGS_PLATEBODY_25 = ItemID.BARROWS_TORAG_BODY_25;
    public static final int TORAGS_PLATEBODY_0 = ItemID.BARROWS_TORAG_BODY_BROKEN;
    public static final int TORAGS_PLATELEGS = ItemID.BARROWS_TORAG_LEGS;
    public static final int TORAGS_PLATELEGS_100 = ItemID.BARROWS_TORAG_LEGS_100;
    public static final int TORAGS_PLATELEGS_75 = ItemID.BARROWS_TORAG_LEGS_75;
    public static final int TORAGS_PLATELEGS_50 = ItemID.BARROWS_TORAG_LEGS_50;
    public static final int TORAGS_PLATELEGS_25 = ItemID.BARROWS_TORAG_LEGS_25;
    public static final int TORAGS_PLATELEGS_0 = ItemID.BARROWS_TORAG_LEGS_BROKEN;
    public static final int TORAGS_HAMMERS = ItemID.BARROWS_TORAG_WEAPON;
    public static final int TORAGS_HAMMERS_100 = ItemID.BARROWS_TORAG_WEAPON_100;
    public static final int TORAGS_HAMMERS_75 = ItemID.BARROWS_TORAG_WEAPON_75;
    public static final int TORAGS_HAMMERS_50 = ItemID.BARROWS_TORAG_WEAPON_50;
    public static final int TORAGS_HAMMERS_25 = ItemID.BARROWS_TORAG_WEAPON_25;
    public static final int TORAGS_HAMMERS_0 = ItemID.BARROWS_TORAG_WEAPON_BROKEN;

    // Verac
    public static final int VERACS_HELM = ItemID.BARROWS_VERAC_HEAD;
    public static final int VERACS_HELM_100 = ItemID.BARROWS_VERAC_HEAD_100;
    public static final int VERACS_HELM_75 = ItemID.BARROWS_VERAC_HEAD_75;
    public static final int VERACS_HELM_50 = ItemID.BARROWS_VERAC_HEAD_50;
    public static final int VERACS_HELM_25 = ItemID.BARROWS_VERAC_HEAD_25;
    public static final int VERACS_HELM_0 = ItemID.BARROWS_VERAC_HEAD_BROKEN;
    public static final int VERACS_BRASSARD = ItemID.BARROWS_VERAC_BODY;
    public static final int VERACS_BRASSARD_100 = ItemID.BARROWS_VERAC_BODY_100;
    public static final int VERACS_BRASSARD_75 = ItemID.BARROWS_VERAC_BODY_75;
    public static final int VERACS_BRASSARD_50 = ItemID.BARROWS_VERAC_BODY_50;
    public static final int VERACS_BRASSARD_25 = ItemID.BARROWS_VERAC_BODY_25;
    public static final int VERACS_BRASSARD_0 = ItemID.BARROWS_VERAC_BODY_BROKEN;
    public static final int VERACS_PLATESKIRT = ItemID.BARROWS_VERAC_LEGS;
    public static final int VERACS_PLATESKIRT_100 = ItemID.BARROWS_VERAC_LEGS_100;
    public static final int VERACS_PLATESKIRT_75 = ItemID.BARROWS_VERAC_LEGS_75;
    public static final int VERACS_PLATESKIRT_50 = ItemID.BARROWS_VERAC_LEGS_50;
    public static final int VERACS_PLATESKIRT_25 = ItemID.BARROWS_VERAC_LEGS_25;
    public static final int VERACS_PLATESKIRT_0 = ItemID.BARROWS_VERAC_LEGS_BROKEN;
    public static final int VERACS_FLAIL = ItemID.BARROWS_VERAC_WEAPON;
    public static final int VERACS_FLAIL_100 = ItemID.BARROWS_VERAC_WEAPON_100;
    public static final int VERACS_FLAIL_75 = ItemID.BARROWS_VERAC_WEAPON_75;
    public static final int VERACS_FLAIL_50 = ItemID.BARROWS_VERAC_WEAPON_50;
    public static final int VERACS_FLAIL_25 = ItemID.BARROWS_VERAC_WEAPON_25;
    public static final int VERACS_FLAIL_0 = ItemID.BARROWS_VERAC_WEAPON_BROKEN;

    // Blood moon
    public static final int BLOOD_MOON_HELM = ItemID.BLOOD_MOON_HELM;
    public static final int BLOOD_MOON_HELM_DEGRADED = ItemID.BLOOD_MOON_HELM_DEGRADED;
    public static final int BLOOD_MOON_HELM_BROKEN = ItemID.BLOOD_MOON_HELM_BROKEN;
    public static final int BLOOD_MOON_CHESTPLATE = ItemID.BLOOD_MOON_CHESTPLATE;
    public static final int BLOOD_MOON_CHESTPLATE_DEGRADED = ItemID.BLOOD_MOON_CHESTPLATE_DEGRADED;
    public static final int BLOOD_MOON_CHESTPLATE_BROKEN = ItemID.BLOOD_MOON_CHESTPLATE_BROKEN;
    public static final int BLOOD_MOON_TASSETS = ItemID.BLOOD_MOON_TASSETS;
    public static final int BLOOD_MOON_TASSETS_DEGRADED = ItemID.BLOOD_MOON_TASSETS_DEGRADED;
    public static final int BLOOD_MOON_TASSETS_BROKEN = ItemID.BLOOD_MOON_TASSETS_BROKEN;

    // Blue moon
    public static final int BLUE_MOON_HELM = ItemID.FROST_MOON_HELM;
    public static final int BLUE_MOON_HELM_DEGRADED = ItemID.FROST_MOON_HELM_DEGRADED;
    public static final int BLUE_MOON_HELM_BROKEN = ItemID.FROST_MOON_HELM_BROKEN;
    public static final int BLUE_MOON_CHESTPLATE = ItemID.FROST_MOON_CHESTPLATE;
    public static final int BLUE_MOON_CHESTPLATE_DEGRADED = ItemID.FROST_MOON_CHESTPLATE_DEGRADED;
    public static final int BLUE_MOON_CHESTPLATE_BROKEN = ItemID.FROST_MOON_CHESTPLATE_BROKEN;
    public static final int BLUE_MOON_TASSETS = ItemID.FROST_MOON_TASSETS;
    public static final int BLUE_MOON_TASSETS_DEGRADED = ItemID.FROST_MOON_TASSETS_DEGRADED;
    public static final int BLUE_MOON_TASSETS_BROKEN = ItemID.FROST_MOON_TASSETS_BROKEN;

    // Eclipse moon
    public static final int ECLIPSE_MOON_HELM = ItemID.ECLIPSE_MOON_HELM;
    public static final int ECLIPSE_MOON_HELM_DEGRADED = ItemID.ECLIPSE_MOON_HELM_DEGRADED;
    public static final int ECLIPSE_MOON_HELM_BROKEN = ItemID.ECLIPSE_MOON_HELM_BROKEN;
    public static final int ECLIPSE_MOON_CHESTPLATE = ItemID.ECLIPSE_MOON_CHESTPLATE;
    public static final int ECLIPSE_MOON_CHESTPLATE_DEGRADED = ItemID.ECLIPSE_MOON_CHESTPLATE_DEGRADED;
    public static final int ECLIPSE_MOON_CHESTPLATE_BROKEN = ItemID.ECLIPSE_MOON_CHESTPLATE_BROKEN;
    public static final int ECLIPSE_MOON_TASSETS = ItemID.ECLIPSE_MOON_TASSETS;
    public static final int ECLIPSE_MOON_TASSETS_DEGRADED = ItemID.ECLIPSE_MOON_TASSETS_DEGRADED;
    public static final int ECLIPSE_MOON_TASSETS_BROKEN = ItemID.ECLIPSE_MOON_TASSETS_BROKEN;

    // Fremennik sea boots
    public static final int FREMENNIK_SEA_BOOTS_1 = ItemID.FREMENNIK_BOOTS_EASY;
    public static final int FREMENNIK_SEA_BOOTS_2 = ItemID.FREMENNIK_BOOTS_MEDIUM;
    public static final int FREMENNIK_SEA_BOOTS_3 = ItemID.FREMENNIK_BOOTS_HARD;
    public static final int FREMENNIK_SEA_BOOTS_4 = ItemID.FREMENNIK_BOOTS_ELITE;

    // Ardougne cloak
    public static final int ARDOUGNE_CLOAK_1 = ItemID.ARDY_CAPE_EASY;
    public static final int ARDOUGNE_CLOAK_2 = ItemID.ARDY_CAPE_MEDIUM;
    public static final int ARDOUGNE_CLOAK_3 = ItemID.ARDY_CAPE_HARD;
    public static final int ARDOUGNE_CLOAK_4 = ItemID.ARDY_CAPE_ELITE;

    // Crystal helm
    public static final int CRYSTAL_HELM = ItemID.CRYSTAL_HELMET;
    public static final int CRYSTAL_HELM_INACTIVE = ItemID.CRYSTAL_HELMET_INACTIVE;
    public static final int CRYSTAL_HELM_HEFIN = ItemID.CRYSTAL_HELMET_HEFIN;
    public static final int CRYSTAL_HELM_HEFIN_INACTIVE = ItemID.CRYSTAL_HELMET_INACTIVE_HEFIN;
    public static final int CRYSTAL_HELM_ITHELL = ItemID.CRYSTAL_HELMET_ITHELL;
    public static final int CRYSTAL_HELM_ITHELL_INACTIVE = ItemID.CRYSTAL_HELMET_INACTIVE_ITHELL;
    public static final int CRYSTAL_HELM_IORWERTH = ItemID.CRYSTAL_HELMET_IORWERTH;
    public static final int CRYSTAL_HELM_IORWERTH_INACTIVE = ItemID.CRYSTAL_HELMET_INACTIVE_IORWERTH;
    public static final int CRYSTAL_HELM_TRAHAEARN = ItemID.CRYSTAL_HELMET_TRAHAEARN;
    public static final int CRYSTAL_HELM_TRAHAEARN_INACTIVE = ItemID.CRYSTAL_HELMET_INACTIVE_TRAHAEARN;
    public static final int CRYSTAL_HELM_CADARN = ItemID.CRYSTAL_HELMET_CADARN;
    public static final int CRYSTAL_HELM_CADARN_INACTIVE = ItemID.CRYSTAL_HELMET_INACTIVE_CADARN;
    public static final int CRYSTAL_HELM_CRWYS = ItemID.CRYSTAL_HELMET_CRWYS;
    public static final int CRYSTAL_HELM_CRWYS_INACTIVE = ItemID.CRYSTAL_HELMET_INACTIVE_CRWYS;
    public static final int CRYSTAL_HELM_AMLODD = ItemID.CRYSTAL_HELMET_AMLODD;
    public static final int CRYSTAL_HELM_AMLODD_INACTIVE = ItemID.CRYSTAL_HELMET_INACTIVE_AMLODD;

    // Crystal body
    public static final int CRYSTAL_BODY = ItemID.CRYSTAL_CHESTPLATE;
    public static final int CRYSTAL_BODY_INACTIVE = ItemID.CRYSTAL_CHESTPLATE_INACTIVE;
    public static final int CRYSTAL_BODY_HEFIN = ItemID.CRYSTAL_CHESTPLATE_HEFIN;
    public static final int CRYSTAL_BODY_HEFIN_INACTIVE = ItemID.CRYSTAL_CHESTPLATE_INACTIVE_HEFIN;
    public static final int CRYSTAL_BODY_ITHELL = ItemID.CRYSTAL_CHESTPLATE_ITHELL;
    public static final int CRYSTAL_BODY_ITHELL_INACTIVE = ItemID.CRYSTAL_CHESTPLATE_INACTIVE_ITHELL;
    public static final int CRYSTAL_BODY_IORWERTH = ItemID.CRYSTAL_CHESTPLATE_IORWERTH;
    public static final int CRYSTAL_BODY_IORWERTH_INACTIVE = ItemID.CRYSTAL_CHESTPLATE_INACTIVE_IORWERTH;
    public static final int CRYSTAL_BODY_TRAHAEARN = ItemID.CRYSTAL_CHESTPLATE_TRAHAEARN;
    public static final int CRYSTAL_BODY_TRAHAEARN_INACTIVE = ItemID.CRYSTAL_CHESTPLATE_INACTIVE_TRAHAEARN;
    public static final int CRYSTAL_BODY_CADARN = ItemID.CRYSTAL_CHESTPLATE_CADARN;
    public static final int CRYSTAL_BODY_CADARN_INACTIVE = ItemID.CRYSTAL_CHESTPLATE_INACTIVE_CADARN;
    public static final int CRYSTAL_BODY_CRWYS = ItemID.CRYSTAL_CHESTPLATE_CRWYS;
    public static final int CRYSTAL_BODY_CRWYS_INACTIVE = ItemID.CRYSTAL_CHESTPLATE_INACTIVE_CRWYS;
    public static final int CRYSTAL_BODY_AMLODD = ItemID.CRYSTAL_CHESTPLATE_AMLODD;
    public static final int CRYSTAL_BODY_AMLODD_INACTIVE = ItemID.CRYSTAL_CHESTPLATE_INACTIVE_AMLODD;

    // Crystal legs
    public static final int CRYSTAL_LEGS = ItemID.CRYSTAL_PLATELEGS;
    public static final int CRYSTAL_LEGS_INACTIVE = ItemID.CRYSTAL_PLATELEGS_INACTIVE;
    public static final int CRYSTAL_LEGS_HEFIN = ItemID.CRYSTAL_PLATELEGS_HEFIN;
    public static final int CRYSTAL_LEGS_HEFIN_INACTIVE = ItemID.CRYSTAL_PLATELEGS_INACTIVE_HEFIN;
    public static final int CRYSTAL_LEGS_ITHELL = ItemID.CRYSTAL_PLATELEGS_ITHELL;
    public static final int CRYSTAL_LEGS_ITHELL_INACTIVE = ItemID.CRYSTAL_PLATELEGS_INACTIVE_ITHELL;
    public static final int CRYSTAL_LEGS_IORWERTH = ItemID.CRYSTAL_PLATELEGS_IORWERTH;
    public static final int CRYSTAL_LEGS_IORWERTH_INACTIVE = ItemID.CRYSTAL_PLATELEGS_INACTIVE_IORWERTH;
    public static final int CRYSTAL_LEGS_TRAHAEARN = ItemID.CRYSTAL_PLATELEGS_TRAHAEARN;
    public static final int CRYSTAL_LEGS_TRAHAEARN_INACTIVE = ItemID.CRYSTAL_PLATELEGS_INACTIVE_TRAHAEARN;
    public static final int CRYSTAL_LEGS_CADARN = ItemID.CRYSTAL_PLATELEGS_CADARN;
    public static final int CRYSTAL_LEGS_CADARN_INACTIVE = ItemID.CRYSTAL_PLATELEGS_INACTIVE_CADARN;
    public static final int CRYSTAL_LEGS_CRWYS = ItemID.CRYSTAL_PLATELEGS_CRWYS;
    public static final int CRYSTAL_LEGS_CRWYS_INACTIVE = ItemID.CRYSTAL_PLATELEGS_INACTIVE_CRWYS;
    public static final int CRYSTAL_LEGS_AMLODD = ItemID.CRYSTAL_PLATELEGS_AMLODD;
    public static final int CRYSTAL_LEGS_AMLODD_INACTIVE = ItemID.CRYSTAL_PLATELEGS_INACTIVE_AMLODD;

    // Coffin
    public static final int LOAR_REMAINS = ItemID.SHADE_BONES1;
    public static final int PHRIN_REMAINS = ItemID.SHADE_BONES2;
    public static final int RIYL_REMAINS = ItemID.SHADE_BONES3;
    public static final int ASYN_REMAINS = ItemID.SHADE_BONES4;
    public static final int FIYR_REMAINS = ItemID.SHADE_BONES5;
    public static final int URIUM_REMAINS = ItemID.SHADE_BONES6;
    public static final int BROKEN_COFFIN = ItemID.SHADES_COFFIN_BROKEN;
    public static final int BRONZE_COFFIN = ItemID.SHADES_COFFIN_BRONZE;
    public static final int BRONZE_COFFIN_OPEN = ItemID.SHADES_COFFIN_BRONZE_OPEN;
    public static final int STEEL_COFFIN = ItemID.SHADES_COFFIN_STEEL;
    public static final int STEEL_COFFIN_OPEN = ItemID.SHADES_COFFIN_STEEL_OPEN;
    public static final int BLACK_COFFIN = ItemID.SHADES_COFFIN_BLACK;
    public static final int BLACK_COFFIN_OPEN = ItemID.SHADES_COFFIN_BLACK_OPEN;
    public static final int SILVER_COFFIN = ItemID.SHADES_COFFIN_SILVER;
    public static final int SILVER_COFFIN_OPEN = ItemID.SHADES_COFFIN_SILVER_OPEN;
    public static final int GOLD_COFFIN = ItemID.SHADES_COFFIN_GOLD;
    public static final int GOLD_COFFIN_OPEN = ItemID.SHADES_COFFIN_GOLD;

    // Forestry basket
    public static final int FORESTRY_BASKET = ItemID.FORESTRY_BASKET_CLOSED;
    public static final int FORESTRY_BASKET_OPEN = ItemID.FORESTRY_BASKET_OPEN;

    // Forestry kit
    public static final int FORESTRY_KIT = ItemID.FORESTRY_KIT;
    public static final int ANIMAINFUSED_BARK = ItemID.FORESTRY_CURRENCY;
    public static final int FORESTERS_RATION = ItemID.FORESTRY_RATION;
    public static final int NATURE_OFFERINGS = ItemID.NATURE_OFFERINGS;
    public static final int SECATEURS_ATTACHMENT = ItemID.FORESTRY_SECATEURS_ATTACHMENT;
    public static final int LEAVES = ItemID.LEAVES;
    public static final int OAK_LEAVES = ItemID.LEAVES_OAK;
    public static final int WILLOW_LEAVES = ItemID.LEAVES_WILLOW;
    public static final int MAPLE_LEAVES = ItemID.LEAVES_MAPLE;
    public static final int YEW_LEAVES = ItemID.LEAVES_YEW;
    public static final int MAGIC_LEAVES = ItemID.LEAVES_MAGIC;
    public static final int FORESTRY_HAT = ItemID.FORESTRY_LUMBERJACK_HAT;
    public static final int FORESTRY_TOP = ItemID.FORESTRY_LUMBERJACK_TOP;
    public static final int FORESTRY_LEGS = ItemID.FORESTRY_LUMBERJACK_LEGS;
    public static final int FORESTRY_BOOTS = ItemID.FORESTRY_LUMBERJACK_BOOTS;
    public static final int LUMBERJACK_HAT = ItemID.RAMBLE_LUMBERJACK_HAT;
    public static final int LUMBERJACK_TOP = ItemID.RAMBLE_LUMBERJACK_TOP;
    public static final int LUMBERJACK_LEGS = ItemID.RAMBLE_LUMBERJACK_LEGS;
    public static final int LUMBERJACK_BOOTS = ItemID.RAMBLE_LUMBERJACK_BOOTS;
    public static final int WOODCUTTING_CAPE = ItemID.SKILLCAPE_WOODCUTTING;
    public static final int WOODCUTTING_CAPE_TRIMMED = ItemID.SKILLCAPE_WOODCUTTING_TRIMMED;

    // Magic cape
    public static final int MAGIC_CAPE = ItemID.SKILLCAPE_MAGIC;
    public static final int MAGIC_CAPE_TRIMMED = ItemID.SKILLCAPE_MAGIC_TRIMMED;

    // Black warlock mix
    public static final int BLACK_WARLOCK_MIX_1 = ItemID.HUNTER_MIX_WARLOCK_1DOSE;
    public static final int BLACK_WARLOCK_MIX_2 = ItemID.HUNTER_MIX_WARLOCK_2DOSE;

    // Moonlight moth mix
    public static final int MOONLIGHT_MOTH_MIX_1 = ItemID.HUNTER_MIX_MOONMOTH_1DOSE;
    public static final int MOONLIGHT_MOTH_MIX_2 = ItemID.HUNTER_MIX_MOONMOTH_2DOSE;

    // Ruby harvest mix
    public static final int RUBY_HARVEST_MIX_1 = ItemID.HUNTER_MIX_RUBY_1DOSE;
    public static final int RUBY_HARVEST_MIX_2 = ItemID.HUNTER_MIX_RUBY_2DOSE;

    // Sapphire glacialis mix
    public static final int SAPPHIRE_GLACIALIS_MIX_1 = ItemID.HUNTER_MIX_GLACIALIS_1DOSE;
    public static final int SAPPHIRE_GLACIALIS_MIX_2 = ItemID.HUNTER_MIX_GLACIALIS_2DOSE;

    // Snowy knight mix
    public static final int SNOWY_KNIGHT_MIX_1 = ItemID.HUNTER_MIX_SNOWY_1DOSE;
    public static final int SNOWY_KNIGHT_MIX_2 = ItemID.HUNTER_MIX_SNOWY_2DOSE;

    // Sunlight moth mix
    public static final int SUNLIGHT_MOTH_MIX_1 = ItemID.HUNTER_MIX_SUNMOTH_1DOSE;
    public static final int SUNLIGHT_MOTH_MIX_2 = ItemID.HUNTER_MIX_SUNMOTH_2DOSE;

    // Circlet of water
    public static final int CIRCLET_OF_WATER = ItemID.WATER_CIRCLET_CHARGED;
    public static final int CIRCLET_OF_WATER_UNCHARGED = ItemID.WATER_CIRCLET;

    // Kandarin headgear
    public static final int KANDARIN_HEADGEAR_3 = ItemID.SEERS_HEADBAND_HARD;
    public static final int KANDARIN_HEADGEAR_4 = ItemID.SEERS_HEADBAND_ELITE;

    // Alchemists amulet
    public static final int ALCHEMISTS_AMULET = ItemID.AMULET_OF_CHEMISTRY_IMBUED_CHARGED;
    public static final int ALCHEMISTS_AMULET_UNCHARGED = ItemID.AMULET_OF_CHEMISTRY_IMBUED_UNCHARGED;

    // Amulet of blood fury
    public static final int AMULET_OF_BLOOD_FURY = ItemID.BLOOD_AMULET;

    // Amulet of chemistry
    public static final int AMULET_OF_CHEMISTRY = ItemID.AMULET_OF_CHEMISTRY;

    // Binding necklace
    public static final int BINDING_NECKLACE = ItemID.MAGIC_EMERALD_NECKLACE;

    // Bracelet of clay
    public static final int BRACELET_OF_CLAY = ItemID.JEWL_BRACELET_OF_CLAY;
    public static final int SOFT_CLAY = ItemID.SOFTCLAY;

    // Bracelet of slaughter
    public static final int BRACELET_OF_SLAUGHTER = ItemID.BRACELET_OF_SLAUGHTER;

    // Burning amulet
    public static final int BURNING_AMULET_1 = ItemID.BURNING_AMULET_1;
    public static final int BURNING_AMULET_2 = ItemID.BURNING_AMULET_2;
    public static final int BURNING_AMULET_3 = ItemID.BURNING_AMULET_3;
    public static final int BURNING_AMULET_4 = ItemID.BURNING_AMULET_4;
    public static final int BURNING_AMULET_5 = ItemID.BURNING_AMULET_5;

    // Camulet
    public static final int CAMULET = ItemID.CAMULET;

    // Castle wars bracelet
    public static final int CASTLE_WARS_BRACELET_1 = ItemID.JEWL_CASTLEWARS_BRACELET;
    public static final int CASTLE_WARS_BRACELET_2 = ItemID.JEWL_CASTLEWARS_BRACELET2;
    public static final int CASTLE_WARS_BRACELET_3 = ItemID.JEWL_CASTLEWARS_BRACELET3;

    // Celestial ring
    public static final int CELESTIAL_RING = ItemID.CELESTIAL_RING_CHARGED;
    public static final int CELESTIAL_RING_UNCHARGED = ItemID.CELESTIAL_RING;
    public static final int CELESTIAL_SIGNET = ItemID.CELESTIAL_SIGNET_CHARGED;
    public static final int CELESTIAL_SIGNET_UNCHARGED = ItemID.CELESTIAL_SIGNET;

    // Desert amulet
    public static final int DESERT_AMULET_2 = ItemID.DESERT_AMULET_MEDIUM;
    public static final int DESERT_AMULET_3 = ItemID.DESERT_AMULET_HARD;
    public static final int DESERT_AMULET_4 = ItemID.DESERT_AMULET_ELITE;

    // Digsite pendant
    public static final int DIGSITE_PENDANT_1 = ItemID.NECKLACE_OF_DIGSITE_1;
    public static final int DIGSITE_PENDANT_2 = ItemID.NECKLACE_OF_DIGSITE_2;
    public static final int DIGSITE_PENDANT_3 = ItemID.NECKLACE_OF_DIGSITE_3;
    public static final int DIGSITE_PENDANT_4 = ItemID.NECKLACE_OF_DIGSITE_4;
    public static final int DIGSITE_PENDANT_5 = ItemID.NECKLACE_OF_DIGSITE_5;

    // Dodgy necklace
    public static final int DODGY_NECKLACE = ItemID.DODGY_NECKLACE;

    // Efaritays aid
    public static final int EFARITAYS_AID = ItemID.VAMPYRE_RING;
    public static final int BLESSED_AXE = ItemID.ANMA_AXE;
    public static final int SILVER_SICKLE = ItemID.SILVER_SICKLE;
    public static final int SILVER_SICKLE_BLESSED = ItemID.SILVER_SICKLE_BLESSED;
    public static final int EMERALD_SICKLE_BLESSED = ItemID.SILVER_SICKLE_EMERALD;
    public static final int EMERALD_SICKLE_BLESSED_ENCHANTED = ItemID.SILVER_SICKLE_ENCHANTED;
    public static final int RUBY_SICKLE_BLESSED = ItemID.SILVER_SICKLE_RUBY;
    public static final int RUBY_SICKLE_BLESSED_ENCHANTED = ItemID.SILVER_SICKLE_RUBY_ENCHANTED;
    public static final int BLISTERWOOD_SICKLE = ItemID.BLISTERWOOD_SICKLE;
    public static final int IVANDIS_FLAIL = ItemID.IVANDIS_FLAIL;
    public static final int BLISTERWOOD_FLAIL = ItemID.BLISTERWOOD_FLAIL;
    public static final int SILVERLIGHT = ItemID.SILVERLIGHT;
    public static final int DARKLIGHT = ItemID.DARKLIGHT;
    public static final int EMBERLIGHT = ItemID.EMBERLIGHT;
    public static final int ROD_OF_IVANDIS_1 = ItemID.BURGH_ROD_COMMAND_FINAL_1;
    public static final int ROD_OF_IVANDIS_2 = ItemID.BURGH_ROD_COMMAND_FINAL_2;
    public static final int ROD_OF_IVANDIS_3 = ItemID.BURGH_ROD_COMMAND_FINAL_3;
    public static final int ROD_OF_IVANDIS_4 = ItemID.BURGH_ROD_COMMAND_FINAL_4;
    public static final int ROD_OF_IVANDIS_5 = ItemID.BURGH_ROD_COMMAND_FINAL_5;
    public static final int ROD_OF_IVANDIS_6 = ItemID.BURGH_ROD_COMMAND_FINAL_6;
    public static final int ROD_OF_IVANDIS_7 = ItemID.BURGH_ROD_COMMAND_FINAL_7;
    public static final int ROD_OF_IVANDIS_8 = ItemID.BURGH_ROD_COMMAND_FINAL_8;
    public static final int ROD_OF_IVANDIS_9 = ItemID.BURGH_ROD_COMMAND_FINAL_9;
    public static final int ROD_OF_IVANDIS_10 = ItemID.BURGH_ROD_COMMAND_FINAL_10;
    public static final int WOLFBANE = ItemID.DAGGER_WOLFBANE;
    public static final int SILVER_BOLTS = ItemID.XBOWS_CROSSBOW_BOLTS_SILVER;

    // Escape crystal
    public static final int ESCAPE_CRYSTAL = ItemID.TOB_TELEPORT;

    // Expeditious bracelet
    public static final int EXPEDITIOUS_BRACELET = ItemID.EXPEDITIOUS_BRACELET;

    // Explorers ring
    public static final int EXPLORERS_RING_1 = ItemID.LUMBRIDGE_RING_EASY;
    public static final int EXPLORERS_RING_2 = ItemID.LUMBRIDGE_RING_MEDIUM;
    public static final int EXPLORERS_RING_3 = ItemID.LUMBRIDGE_RING_HARD;
    public static final int EXPLORERS_RING_4 = ItemID.LUMBRIDGE_RING_ELITE;

    // Flamtaer bracelet
    public static final int FLAMTAER_BRACELET = ItemID.FLAMTAER_BRACELET;

    // Games necklace
    public static final int GAMES_NECKLACE_1 = ItemID.NECKLACE_OF_MINIGAMES_1;
    public static final int GAMES_NECKLACE_2 = ItemID.NECKLACE_OF_MINIGAMES_2;
    public static final int GAMES_NECKLACE_3 = ItemID.NECKLACE_OF_MINIGAMES_3;
    public static final int GAMES_NECKLACE_4 = ItemID.NECKLACE_OF_MINIGAMES_4;
    public static final int GAMES_NECKLACE_5 = ItemID.NECKLACE_OF_MINIGAMES_5;
    public static final int GAMES_NECKLACE_6 = ItemID.NECKLACE_OF_MINIGAMES_6;
    public static final int GAMES_NECKLACE_7 = ItemID.NECKLACE_OF_MINIGAMES_7;
    public static final int GAMES_NECKLACE_8 = ItemID.NECKLACE_OF_MINIGAMES_8;

    // Giantsoul amulet
    public static final int GIANTSOUL_AMULET = ItemID.GIANTSOUL_AMULET_CHARGED;
    public static final int GIANTSOUL_AMULET_UNCHARGED = ItemID.GIANTSOUL_AMULET_UNCHARGED;

    // Necklace of passage
    public static final int NECKLACE_OF_PASSAGE_1 = ItemID.NECKLACE_OF_PASSAGE_1;
    public static final int NECKLACE_OF_PASSAGE_2 = ItemID.NECKLACE_OF_PASSAGE_2;
    public static final int NECKLACE_OF_PASSAGE_3 = ItemID.NECKLACE_OF_PASSAGE_3;
    public static final int NECKLACE_OF_PASSAGE_4 = ItemID.NECKLACE_OF_PASSAGE_4;
    public static final int NECKLACE_OF_PASSAGE_5 = ItemID.NECKLACE_OF_PASSAGE_5;

    // Pendant of ates
    public static final int PENDANT_OF_ATES = ItemID.PENDANT_OF_ATES;
    public static final int PENDANT_OF_ATES_UNCHARGED = ItemID.PENDANT_OF_ATES_EMPTY;

    // Phoenix necklace
    public static final int PHOENIX_NECKLACE = ItemID.JEWL_NECKLACE_OF_PHOENIX;

    // Ring of dueling
    public static final int RING_OF_DUELING_1 = ItemID.RING_OF_DUELING_1;
    public static final int RING_OF_DUELING_2 = ItemID.RING_OF_DUELING_2;
    public static final int RING_OF_DUELING_3 = ItemID.RING_OF_DUELING_3;
    public static final int RING_OF_DUELING_4 = ItemID.RING_OF_DUELING_4;
    public static final int RING_OF_DUELING_5 = ItemID.RING_OF_DUELING_5;
    public static final int RING_OF_DUELING_6 = ItemID.RING_OF_DUELING_6;
    public static final int RING_OF_DUELING_7 = ItemID.RING_OF_DUELING_7;
    public static final int RING_OF_DUELING_8 = ItemID.RING_OF_DUELING_8;

    // Ring of endurance
    public static final int RING_OF_ENDURANCE = ItemID.RING_OF_ENDURANCE;
    public static final int RING_OF_ENDURANCE_UNCHARGED = ItemID.RING_OF_ENDURANCE_UNCHARGED;
    public static final int RING_OF_ENDURANCE_NOCHARGES = ItemID.RING_OF_ENDURANCE_NOCHARGES;

    // Ring of forging
    public static final int RING_OF_FORGING = ItemID.RING_OF_FORGING;

    // Ring of pursuit
    public static final int RING_OF_PURSUIT = ItemID.RING_OF_PURSUIT;

    // Ring of recoil
    public static final int RING_OF_RECOIL = ItemID.RING_OF_RECOIL;

    // Ring of shadows
    public static final int RING_OF_SHADOWS = ItemID.RING_OF_SHADOWS;
    public static final int RING_OF_SHADOWS_UNCHARGED = ItemID.RING_OF_SHADOWS_UNCHARGED;

    // Ring of suffering
    public static final int RING_OF_SUFFERING_UNCHARGED = ItemID.ZENYTE_RING_ENCHANTED;
    public static final int RING_OF_SUFFERING_UNCHARGED_IMBUED_NMZ = ItemID.NZONE_ZENYTE_RING_ENCHANTED;
    public static final int RING_OF_SUFFERING_UNCHARGED_IMBUED_SW = ItemID.SW_ZENYTE_RING_ENCHANTED;
    public static final int RING_OF_SUFFERING_UNCHARGED_IMBUED_PVP = ItemID.PVPA_ZENYTE_RING_ENCHANTED;
    public static final int RING_OF_SUFFERING = ItemID.ZENYTE_RING_ENCHANTED_RECOIL;
    public static final int RING_OF_SUFFERING_IMBUED_NMZ = ItemID.NZONE_ZENYTE_RING_ENCHANTED_RECOIL;
    public static final int RING_OF_SUFFERING_IMBUED_SW = ItemID.SW_ZENYTE_RING_ENCHANTED_RECOIL;
    public static final int RING_OF_SUFFERING_IMBUED_PVP = ItemID.PVPA_ZENYTE_RING_ENCHANTED_RECOIL;

    // Ring of the elements
    public static final int RING_OF_THE_ELEMENTS = ItemID.RING_OF_ELEMENTS_CHARGED;
    public static final int RING_OF_THE_ELEMENTS_UNCHARGED = ItemID.RING_OF_ELEMENTS;

    // Skills necklace
    public static final int SKILLS_NECKLACE_0 = ItemID.JEWL_NECKLACE_OF_SKILLS;
    public static final int SKILLS_NECKLACE_1 = ItemID.JEWL_NECKLACE_OF_SKILLS_1;
    public static final int SKILLS_NECKLACE_2 = ItemID.JEWL_NECKLACE_OF_SKILLS_2;
    public static final int SKILLS_NECKLACE_3 = ItemID.JEWL_NECKLACE_OF_SKILLS_3;
    public static final int SKILLS_NECKLACE_4 = ItemID.JEWL_NECKLACE_OF_SKILLS_4;
    public static final int SKILLS_NECKLACE_5 = ItemID.JEWL_NECKLACE_OF_SKILLS_5;
    public static final int SKILLS_NECKLACE_6 = ItemID.JEWL_NECKLACE_OF_SKILLS_6;

    // Slayer ring
    public static final int SLAYER_RING_1 = ItemID.SLAYER_RING_1;
    public static final int SLAYER_RING_2 = ItemID.SLAYER_RING_2;
    public static final int SLAYER_RING_3 = ItemID.SLAYER_RING_3;
    public static final int SLAYER_RING_4 = ItemID.SLAYER_RING_4;
    public static final int SLAYER_RING_5 = ItemID.SLAYER_RING_5;
    public static final int SLAYER_RING_6 = ItemID.SLAYER_RING_6;
    public static final int SLAYER_RING_7 = ItemID.SLAYER_RING_7;
    public static final int SLAYER_RING_8 = ItemID.SLAYER_RING_8;

    // Xeric's talisman
    public static final int XERICS_TALISMAN = ItemID.XERIC_TALISMAN;
    public static final int XERICS_TALISMAN_UNCHARGED = ItemID.XERIC_TALISMAN_EMPTY;

    // Chronicle
    public static final int CHRONICLE = ItemID.CHRONICLE;

    // Crystal shield
    public static final int CRYSTAL_SHIELD = ItemID.CRYSTAL_SHIELD_2500;
    public static final int CRYSTAL_SHIELD_DEGRADED = ItemID.CRYSTAL_SHIELD;

    // Dragonfire shield
    public static final int DRAGONFIRE_SHIELD = ItemID.DRAGONFIRE_SHIELD;
    public static final int DRAGONFIRE_SHIELD_UNCHARGED = ItemID.DRAGONFIRE_SHIELD_UNCHARGED;
    public static final int DRAGONFIRE_WARD = ItemID.DRAGONFIRE_WARD;
    public static final int DRAGONFIRE_WARD_UNCHARGED = ItemID.DRAGONFIRE_WARD_UNCHARGED;

    // Falador shield
    public static final int FALADOR_SHIELD_1 = ItemID.FALADOR_SHIELD_EASY;
    public static final int FALADOR_SHIELD_2 = ItemID.FALADOR_SHIELD_MEDIUM;
    public static final int FALADOR_SHIELD_3 = ItemID.FALADOR_SHIELD_HARD;
    public static final int FALADOR_SHIELD_4= ItemID.FALADOR_SHIELD_ELITE;

    // Kharedst memoirs
    public static final int KHAREDSTS_MEMOIRS = ItemID.VEOS_KHAREDSTS_MEMOIRS;
    public static final int BOOK_OF_THE_DEAD = ItemID.BOOK_OF_THE_DEAD;

    // Tome of earth
    public static final int TOME_OF_EARTH = ItemID.TOME_OF_EARTH;
    public static final int TOME_OF_EARTH_UNCHARGED = ItemID.TOME_OF_EARTH_UNCHARGED;

    // Tome of water
    public static final int TOME_OF_WATER = ItemID.TOME_OF_WATER;
    public static final int TOME_OF_WATER_UNCHARGED = ItemID.TOME_OF_WATER_UNCHARGED;

    // Tome of fire
    public static final int TOME_OF_FIRE = ItemID.TOME_OF_FIRE;
    public static final int TOME_OF_FIRE_UNCHARGED = ItemID.TOME_OF_FIRE_UNCHARGED;

    // Ash sanctifier
    public static final int ASH_SANCTIFIER = ItemID.ASH_SANCTIFIER;

    // Bone crusher
    public static final int BONECRUSHER = ItemID.BONECRUSHER;
    public static final int BONECRUSHER_NECKLACE = ItemID.BONECRUSHER_NECKLACE;

    // Bottomless compost bucket
    public static final int BOTTOMLESS_COMPOST_BUCKET = ItemID.BOTTOMLESS_COMPOST_BUCKET_FILLED;
    public static final int BOTTOMLESS_COMPOST_BUCKET_UNCHARGED = ItemID.BOTTOMLESS_COMPOST_BUCKET;
    public static final int ULTRACOMPOST = ItemID.BUCKET_ULTRACOMPOST;
    public static final int SUPERCOMPOST = ItemID.BUCKET_SUPERCOMPOST;
    public static final int COMPOST = ItemID.BUCKET_COMPOST;
    public static final int BUCKET = ItemID.BUCKET_EMPTY;

    // Chugging barrel
    public static final int CHUGGING_BARREL = ItemID.MM_PREPOT_DEVICE;
    public static final int CHUGGING_BARREL_DISASSEMBLED = ItemID.MM_PREPOT_DEVICE_DISASSEMBLED;
    public static final int ATTACK_POTION_1 = ItemID._1DOSE1ATTACK;
    public static final int ANTIPOISON_1 = ItemID._1DOSEANTIPOISON;
    public static final int RELICYMS_BALM_1 = ItemID.RELICYMS_BALM1;
    public static final int STRENGTH_POTION_1 = ItemID._1DOSE1STRENGTH;
    public static final int RESTORE_POTION_1 = ItemID._1DOSESTATRESTORE;
    public static final int GUTHIX_BALANCE_1 = ItemID.BURGH_GUTHIX_BALANCE_1;
    public static final int ENERGY_POTION_1 = ItemID._1DOSE1ENERGY;
    public static final int DEFENCE_POTION_1 = ItemID._1DOSE1DEFENSE;
    public static final int AGILITY_POTION_1 = ItemID._1DOSE1AGILITY;
    public static final int COMBAT_POTION_1 = ItemID._1DOSECOMBAT;
    public static final int PRAYER_POTION_1 = ItemID._1DOSEPRAYERRESTORE;
    public static final int SUPER_ATTACK_1 = ItemID._1DOSE2ATTACK;
    public static final int SUPER_ANTIPOISON_1 = ItemID._1DOSE2ANTIPOISON;
    public static final int FISHING_POTION_1 = ItemID._1DOSEFISHERSPOTION;
    public static final int SUPER_ENERGY_POTION_1 = ItemID._1DOSE2ENERGY;
    public static final int HUNTER_POTION_1 = ItemID._1DOSEHUNTING;
    public static final int GOADING_POTION_1 = ItemID._1DOSEGOADING;
    public static final int SUPER_STRENGTH_1 = ItemID._1DOSE2STRENGTH;
    public static final int MAGIC_ESSENCE_1 = ItemID._1DOSEMAGICESS;
    public static final int PRAYER_REGENERATION_POTION_1 = ItemID._1DOSE1PRAYER_REGENERATION;
    public static final int SUPER_RESTORE_1 = ItemID._1DOSE2RESTORE;
    public static final int SANFEW_SERUM_1 = ItemID.SANFEW_SALVE_1_DOSE;
    public static final int SUPER_DEFENCE_1 = ItemID._1DOSE2DEFENSE;
    public static final int ANTIDOTE_1 = ItemID.ANTIDOTE_1;
    public static final int ANTIFIRE_POTION_1 = ItemID._1DOSE1ANTIDRAGON;
    public static final int DIVINE_SUPER_ATTACK_POTION_1 = ItemID._1DOSEDIVINEATTACK;
    public static final int DIVINE_SUPER_DEFENCE_POTION_1 = ItemID._1DOSEDIVINEDEFENCE;
    public static final int DIVINE_SUPER_STRENGTH_POTION_1 = ItemID._1DOSEDIVINESTRENGTH;
    public static final int RANGING_POTION_1 = ItemID._1DOSERANGERSPOTION;
    public static final int DIVINE_RANGING_POTION_1 = ItemID._1DOSEDIVINERANGE;
    public static final int MAGIC_POTION_1 = ItemID._1DOSE1MAGIC;
    public static final int STAMINA_POTION_1 = ItemID._1DOSESTAMINA;
    public static final int ZAMORAK_BREW_1 = ItemID._1DOSEPOTIONOFZAMORAK;
    public static final int DIVINE_MAGIC_POTION_1 = ItemID._1DOSEDIVINEMAGIC;
    public static final int ANTIDOTE1_5958 = ItemID.ANTIDOTE__1;
    public static final int BASTION_POTION_1 = ItemID._1DOSEBASTION;
    public static final int BATTLEMAGE_POTION_1 = ItemID._1DOSEBATTLEMAGE;
    public static final int SARADOMIN_BREW_1 = ItemID.BR_1DOSEPOTIONOFSARADOMIN;
    public static final int EXTENDED_ANTIFIRE_1 = ItemID._1DOSE2ANTIDRAGON;
    public static final int ANCIENT_BREW_1 = ItemID._1DOSEANCIENTBREW;
    public static final int DIVINE_BASTION_POTION_1 = ItemID._1DOSEDIVINEBASTION;
    public static final int DIVINE_BATTLEMAGE_POTION_1 = ItemID._1DOSEDIVINEBATTLEMAGE;
    public static final int ANTIVENOM_1 = ItemID.ANTIVENOM1;
    public static final int MENAPHITE_REMEDY_1 = ItemID._1DOSESTATRENEWAL;
    public static final int SUPER_COMBAT_POTION_1 = ItemID._1DOSE2COMBAT;
    public static final int FORGOTTEN_BREW_1 = ItemID._1DOSEFORGOTTENBREW;
    public static final int SUPER_ANTIFIRE_POTION_1 = ItemID._1DOSE3ANTIDRAGON;
    public static final int ANTIVENOM_PLUS_1 = ItemID.ANTIVENOM_1;
    public static final int EXTENDED_ANTIVENOM_1 = ItemID.EXTENDED_ANTIVENOM_1;
    public static final int DIVINE_SUPER_COMBAT_POTION_1 = ItemID._1DOSEDIVINECOMBAT;
    public static final int EXTENDED_SUPER_ANTIFIRE_1 = ItemID._1DOSE4ANTIDRAGON;
    public static final int ATTACK_MIX_1 = ItemID.BRUTAL_1DOSE1ATTACK;
    public static final int ANTIPOISON_MIX_1 = ItemID.BRUTAL_1DOSEANTIPOISON;
    public static final int RELICYMS_MIX_1 = ItemID.BRUTAL_RELICYMS_BALM1;
    public static final int STRENGTH_MIX_1 = ItemID.BRUTAL_1DOSE1STRENGTH;
    public static final int RESTORE_MIX_1 = ItemID.BRUTAL_1DOSESTATRESTORE;
    public static final int ENERGY_MIX_1 = ItemID.BRUTAL_1DOSE1ENERGY;
    public static final int DEFENCE_MIX_1 = ItemID.BRUTAL_1DOSE1DEFENSE;
    public static final int AGILITY_MIX_1 = ItemID.BRUTAL_1DOSE1AGILITY;
    public static final int COMBAT_MIX_1 = ItemID.BRUTAL_1DOSECOMBAT;
    public static final int PRAYER_MIX_1 = ItemID.BRUTAL_1DOSEPRAYERRESTORE;
    public static final int SUPERATTACK_MIX_1 = ItemID.BRUTAL_1DOSE2ATTACK;
    public static final int ANTIPOISON_SUPERMIX_1 = ItemID.BRUTAL_1DOSE2ANTIPOISON;
    public static final int FISHING_MIX_1 = ItemID.BRUTAL_1DOSEFISHERSPOTION;
    public static final int SUPER_ENERGY_MIX_1 = ItemID.BRUTAL_1DOSE2ENERGY;
    public static final int HUNTING_MIX_1 = ItemID.BRUTAL_1DOSE1HUNTING;
    public static final int SUPER_STR_MIX_1 = ItemID.BRUTAL_1DOSE2STRENGTH;
    public static final int MAGIC_ESSENCE_MIX_1 = ItemID.BRUTAL_1DOSEMAGICESS;
    public static final int SUPER_RESTORE_MIX_1 = ItemID.BRUTAL_1DOSE2RESTORE;
    public static final int SUPER_DEFENCE_MIX_1 = ItemID.BRUTAL_1DOSE2DEFENSE;
    public static final int ANTIDOTE_MIX_1 = ItemID.BRUTAL_ANTIDOTE_1;
    public static final int ANTIFIRE_MIX_1 = ItemID.BRUTAL_1DOSE1ANTIDRAGON;
    public static final int RANGING_MIX_1 = ItemID.BRUTAL_1DOSERANGERSPOTION;
    public static final int MAGIC_MIX_1 = ItemID.BRUTAL_1DOSE1MAGIC;
    public static final int ZAMORAK_MIX_1 = ItemID.BRUTAL_1DOSEPOTIONOFZAMORAK;
    public static final int STAMINA_MIX_1 = ItemID.BRUTAL_1DOSESTAMINA;
    public static final int EXTENDED_ANTIFIRE_MIX_1 = ItemID.BRUTAL_1DOSE2ANTIDRAGON;
    public static final int ANCIENT_MIX_1 = ItemID.BRUTAL_1DOSEANCIENTBREW;
    public static final int SUPER_ANTIFIRE_MIX_1 = ItemID.BRUTAL_1DOSE3ANTIDRAGON;
    public static final int EXTENDED_SUPER_ANTIFIRE_MIX_1 = ItemID.BRUTAL_1DOSE4ANTIDRAGON;

    // Coal bag
    public static final int COAL_BAG = ItemID.COAL_BAG;
    public static final int COAL_BAG_OPEN = ItemID.COAL_BAG_OPEN;
    public static final int COAL = ItemID.COAL;
    public static final int SMITHING_CAPE = ItemID.SKILLCAPE_SMITHING;
    public static final int SMITHING_CAPE_TRIMMED = ItemID.SKILLCAPE_SMITHING_TRIMMED;

    // Colossal pouch
    public static final int COLOSSAL_POUCH = ItemID.RCU_POUCH_COLOSSAL;
    public static final int COLOSSAL_POUCH_DEGRADED = ItemID.RCU_POUCH_COLOSSAL_DEGRADE;
    public static final int RUNE_ESSENCE = ItemID.BLANKRUNE;
    public static final int PURE_ESSENCE = ItemID.BLANKRUNE_HIGH;
    public static final int DAEYALT_ESSENCE = ItemID.BLANKRUNE_DAEYALT;
    public static final int GUARDIAN_ESSENCE = ItemID.GOTR_GUARDIAN_ESSENCE;

    // Crystal saw
    public static final int CRYSTAL_SAW = ItemID.EYEGLO_CRYSTAL_SAW;

    // Eternal teleport crystal
    public static final int ETERNAL_TELEPORT_CRYSTAL = ItemID.PRIF_TELEPORT_CRYSTAL;

    // Fish barrel
    public static final int FISH_BARREL = ItemID.FISH_BARREL_CLOSED;
    public static final int FISH_BARREL_OPEN = ItemID.FISH_BARREL_OPEN;
    public static final int FISH_SACK_BARREL = ItemID.FISH_SACK_BARREL_CLOSED;
    public static final int FISH_SACK_BARREL_OPEN = ItemID.FISH_SACK_BARREL_OPEN;
    public static final int RAW_SHRIMPS = ItemID.RAW_SHRIMP;
    public static final int RAW_ANCHOVIES = ItemID.RAW_ANCHOVIES;
    public static final int RAW_MONKFISH = ItemID.RAW_MONKFISH;
    public static final int RAW_MACKEREL = ItemID.RAW_MACKEREL;
    public static final int RAW_COD = ItemID.RAW_COD;
    public static final int RAW_BASS = ItemID.RAW_BASS;
    public static final int RAW_SARDINE = ItemID.RAW_SARDINE;
    public static final int RAW_HERRING = ItemID.RAW_HERRING;
    public static final int RAW_TROUT = ItemID.RAW_TROUT;
    public static final int RAW_PIKE = ItemID.RAW_PIKE;
    public static final int RAW_SLIMY_EEL = ItemID.MORT_SLIMEY_EEL;
    public static final int RAW_SALMON = ItemID.RAW_SALMON;
    public static final int RAW_RAINBOW_FISH = ItemID.HUNTING_RAW_FISH_SPECIAL;
    public static final int RAW_CAVE_EEL = ItemID.RAW_CAVE_EEL;
    public static final int RAW_LAVA_EEL = ItemID.RAW_LAVA_EEL;
    public static final int INFERNAL_EEL = ItemID.INFERNAL_EEL;
    public static final int RAW_ANGLERFISH = ItemID.RAW_ANGLERFISH;
    public static final int SACRED_EEL = ItemID.SNAKEBOSS_EEL;
    public static final int RAW_TUNA = ItemID.RAW_TUNA;
    public static final int RAW_SWORDFISH = ItemID.RAW_SWORDFISH;
    public static final int RAW_SHARK = ItemID.RAW_SHARK;
    public static final int BLUEGILL = ItemID.AERIAL_FISHING_BLUEGILL;
    public static final int COMMON_TENCH = ItemID.AERIAL_FISHING_COMMON_TENCH;
    public static final int MOTTLED_EEL = ItemID.AERIAL_FISHING_MOTTLED_EEL;
    public static final int GREATER_SIREN = ItemID.AERIAL_FISHING_GREATER_SIREN;
    public static final int RAW_LOBSTER = ItemID.RAW_LOBSTER;
    public static final int RAW_DARK_CRAB = ItemID.RAW_DARK_CRAB;
    public static final int LEAPING_TROUT = ItemID.BRUT_SPAWNING_TROUT;
    public static final int LEAPING_SALMON = ItemID.BRUT_SPAWNING_SALMON;
    public static final int LEAPING_STURGEON = ItemID.BRUT_STURGEON;
    public static final int RAW_KARAMBWAN = ItemID.TBWT_RAW_KARAMBWAN;
    public static final int RAW_SEA_TURTLE = ItemID.RAW_SEATURTLE;
    public static final int RAW_MANTA_RAY = ItemID.RAW_MANTARAY;

    // Flamtaer bag
    public static final int FLAMTAER_BAG = ItemID.FLAMTAER_BAG;
    public static final int TIMBER_BEAM = ItemID.TIMBERBEAM;
    public static final int LIMESTONE_BRICK = ItemID.LIMESTONEBRICK;
    public static final int SWAMP_PASTE = ItemID.SWAMPPASTE;

    // Fungicide spray
    public static final int FUNGICIDE_SPRAY_0 = ItemID.SLAYER_SPRAY_PUMP_0;
    public static final int FUNGICIDE_SPRAY_1 = ItemID.SLAYER_SPRAY_PUMP_1;
    public static final int FUNGICIDE_SPRAY_2 = ItemID.SLAYER_SPRAY_PUMP_2;
    public static final int FUNGICIDE_SPRAY_3 = ItemID.SLAYER_SPRAY_PUMP_3;
    public static final int FUNGICIDE_SPRAY_4 = ItemID.SLAYER_SPRAY_PUMP_4;
    public static final int FUNGICIDE_SPRAY_5 = ItemID.SLAYER_SPRAY_PUMP_5;
    public static final int FUNGICIDE_SPRAY_6 = ItemID.SLAYER_SPRAY_PUMP_6;
    public static final int FUNGICIDE_SPRAY_7 = ItemID.SLAYER_SPRAY_PUMP_7;
    public static final int FUNGICIDE_SPRAY_8 = ItemID.SLAYER_SPRAY_PUMP_8;
    public static final int FUNGICIDE_SPRAY_9 = ItemID.SLAYER_SPRAY_PUMP_9;
    public static final int FUNGICIDE_SPRAY_10 = ItemID.SLAYER_SPRAY_PUMP_10;

    // Fur pouch
    public static final int FUR_POUCH_SMALL = ItemID.HG_FURPOUCH_SMALL;
    public static final int FUR_POUCH_SMALL_OPEN = ItemID.HG_FURPOUCH_SMALL_OPEN;
    public static final int FUR_POUCH_MEDIUM = ItemID.HG_FURPOUCH_MED;
    public static final int FUR_POUCH_MEDIUM_OPEN = ItemID.HG_FURPOUCH_MED_OPEN;
    public static final int FUR_POUCH_LARGE = ItemID.HG_FURPOUCH_LARGE;
    public static final int FUR_POUCH_LARGE_OPEN = ItemID.HG_FURPOUCH_LARGE_OPEN;
    public static final int POLAR_KEBBIT_FUR = ItemID.HUNTINGBEAST_POLAR_FUR;
    public static final int COMMON_KEBBIT_FUR = ItemID.HUNTINGBEAST_WOODLAND_FUR;
    public static final int FELDIP_WEASEL_FUR = ItemID.HUNTINGBEAST_JUNGLE_FUR;
    public static final int DESERT_DEVIL_FUR = ItemID.HUNTINGBEAST_DESERT_FUR;
    public static final int FOX_FUR = ItemID.HUNTING_FENNECFOX_FUR;
    public static final int LARUPIA_FUR = ItemID.HUNTING_FUR_JAGUAR_PERFECT;
    public static final int LARUPIA_FUR_TATTY = ItemID.HUNTING_FUR_JAGUAR_SHABBY;
    public static final int GRAAHK_FUR = ItemID.HUNTING_FUR_LEOPARD_PERFECT;
    public static final int GRAAHK_FUR_TATTY = ItemID.HUNTING_FUR_LEOPARD_SHABBY;
    public static final int KYATT_FUR = ItemID.HUNTING_FUR_TIGER_PERFECT;
    public static final int KYATT_FUR_TATTY = ItemID.HUNTING_FUR_TIGER_SHABBY;
    public static final int SUNLIGHT_ANTELOPE_FUR = ItemID.HUNTING_ANTELOPESUN_FUR;
    public static final int MOONLIGHT_ANTELOPE_FUR = ItemID.HUNTING_ANTELOPEMOON_FUR;
    public static final int SPOTTED_KEBBIT_FUR = ItemID.HUNTINGBEAST_SPEEDY_FUR;
    public static final int DARK_KEBBIT_FUR = ItemID.HUNTINGBEAST_SILENT_FUR;
    public static final int DASHING_KEBBIT_FUR = ItemID.HUNTINGBEAST_SPEEDY2_FUR;

    // Gem bag
    public static final int GEM_BAG = ItemID.GEM_BAG;
    public static final int GEM_BAG_OPEN = ItemID.GEM_BAG_OPEN;
    public static final int UNCUT_SAPPHIRE = ItemID.UNCUT_SAPPHIRE;
    public static final int UNCUT_EMERALD = ItemID.UNCUT_EMERALD;
    public static final int UNCUT_RUBY = ItemID.UNCUT_RUBY;
    public static final int UNCUT_DIAMOND = ItemID.UNCUT_DIAMOND;
    public static final int UNCUT_DRAGONSTONE = ItemID.UNCUT_DRAGONSTONE;

    // Gricollers can
    public static final int GRICOLLERS_CAN = ItemID.ZEAH_WATERINGCAN;

    // Herb sack
    public static final int HERB_SACK = ItemID.SLAYER_HERB_SACK;
    public static final int HERB_SACK_OPEN = ItemID.SLAYER_HERB_SACK_OPEN;
    public static final int GRIMY_GUAM_LEAF = ItemID.UNIDENTIFIED_GUAM;
    public static final int GRIMY_MARRENTILL = ItemID.UNIDENTIFIED_MARENTILL;
    public static final int GRIMY_TARROMIN = ItemID.UNIDENTIFIED_TARROMIN;
    public static final int GRIMY_HARRALANDER = ItemID.UNIDENTIFIED_HARRALANDER;
    public static final int GRIMY_RANARR_WEED = ItemID.UNIDENTIFIED_RANARR;
    public static final int GRIMY_TOADFLAX = ItemID.UNIDENTIFIED_TOADFLAX;
    public static final int GRIMY_IRIT_LEAF = ItemID.UNIDENTIFIED_IRIT;
    public static final int GRIMY_AVANTOE = ItemID.UNIDENTIFIED_AVANTOE;
    public static final int GRIMY_KWUARM = ItemID.UNIDENTIFIED_KWUARM;
    public static final int GRIMY_HUASCA = ItemID.UNIDENTIFIED_HUASCA;
    public static final int GRIMY_SNAPDRAGON = ItemID.UNIDENTIFIED_SNAPDRAGON;
    public static final int GRIMY_CADANTINE = ItemID.UNIDENTIFIED_CADANTINE;
    public static final int GRIMY_LANTADYME = ItemID.UNIDENTIFIED_LANTADYME;
    public static final int GRIMY_DWARF_WEED = ItemID.UNIDENTIFIED_DWARF_WEED;
    public static final int GRIMY_TORSTOL = ItemID.UNIDENTIFIED_TORSTOL;

    // Huntsmans kit
    public static final int HUNTSMANS_KIT = ItemID.HUNTSMANS_KIT;
    public static final int BIRD_SNARE = ItemID.HUNTING_OJIBWAY_BIRD_SNARE;
    public static final int BUTTERFLY_NET = ItemID.HUNTING_BUTTERFLY_NET;
    public static final int BUTTERFLY_JAR = ItemID.BUTTERFLY_JAR;
    public static final int RABBIT_SNARE = ItemID.HUNTING_SNARE;
    public static final int SMALL_FISHING_NET = ItemID.NET;
    public static final int MAGIC_BOX = ItemID.MAGIC_IMP_BOX;
    public static final int TEASING_STICK = ItemID.HUNTING_TEASING_STICK;
    public static final int WOOD_CAMO_TOP = ItemID.HUNTING_CAMOFLAUGE_ROBE_WOOD;
    public static final int WOOD_CAMO_LEGS = ItemID.HUNTING_TROUSERS_WOOD;
    public static final int JUNGLE_CAMO_TOP = ItemID.HUNTING_CAMOFLAUGE_ROBE_JUNGLE;
    public static final int JUNGLE_CAMO_LEGS = ItemID.HUNTING_TROUSERS_JUNGLE;
    public static final int LARUPIA_HAT = ItemID.HUNTING_HAT_JAGUAR;
    public static final int LARUPIA_TOP = ItemID.HUNTING_TORSO_JAGUAR;
    public static final int LARUPIA_LEGS = ItemID.HUNTING_TROUSERS_JAGUAR;
    public static final int KYATT_HAT = ItemID.HUNTING_HAT_TIGER;
    public static final int KYATT_TOP = ItemID.HUNTING_TORSO_TIGER;
    public static final int KYATT_LEGS = ItemID.HUNTING_TROUSERS_TIGER;
    public static final int GUILD_HUNTER_HEADWEAR = ItemID.HG_HUNTER_HOOD;
    public static final int GUILD_HUNTER_TOP = ItemID.HG_HUNTER_TOP;
    public static final int GUILD_HUNTER_LEGS = ItemID.HG_HUNTER_LEGS;
    public static final int GUILD_HUNTER_BOOTS = ItemID.HG_HUNTER_BOOTS;
    public static final int NOOSE_WAND = ItemID.NOOSE_WAND;
    public static final int MAGIC_BUTTERFLY_NET = ItemID.II_MAGIC_BUTTERFLY_NET;
    public static final int BOX_TRAP = ItemID.HUNTING_BOX_TRAP;
    public static final int UNLIT_TORCH = ItemID.TORCH_UNLIT;
    public static final int ROPE = ItemID.ROPE;
    public static final int HUNTERS_SPEAR = ItemID.HG_HUNTER_SPEAR;
    public static final int POLAR_CAMO_TOP = ItemID.HUNTING_CAMOFLAUGE_ROBE_POLAR;
    public static final int POLAR_CAMO_LEGS = ItemID.HUNTING_TROUSERS_POLAR;
    public static final int DESERT_CAMO_TOP = ItemID.HUNTING_CAMOFLAUGE_ROBE_DESERT;
    public static final int DESERT_CAMO_LEGS = ItemID.HUNTING_TROUSERS_DESERT;
    public static final int GRAAHK_HEADDRESS = ItemID.HUNTING_HAT_LEOPARD;
    public static final int GRAAHK_TOP = ItemID.HUNTING_TORSO_LEOPARD;
    public static final int GRAAHK_LEGS = ItemID.HUNTING_TROUSERS_LEOPARD;
    public static final int HUNTER_HOOD = ItemID.SKILLCAPE_HUNTING_HOOD;
    public static final int HUNTER_CAPE = ItemID.SKILLCAPE_HUNTING;
    public static final int HUNTER_CAPE_TRIMMED = ItemID.SKILLCAPE_HUNTING_TRIMMED;
    public static final int IMPLING_JAR = ItemID.II_IMPLING_JAR;

    // Imp in a box
    public static final int IMP_IN_A_BOX_1 = ItemID.MAGIC_IMP_BOX_HALF;
    public static final int IMP_IN_A_BOX_2 = ItemID.MAGIC_IMP_BOX_FULL;

    // Jar generator
    public static final int JAR_GENERATOR = ItemID.II_JAR_GENERATOR;

    // Log basket
    public static final int LOG_BASKET = ItemID.LOG_BASKET_CLOSED;
    public static final int LOG_BASKET_OPEN = ItemID.LOG_BASKET_OPEN;
    public static final int LOGS = ItemID.LOGS;
    public static final int ACHEY_TREE_LOGS = ItemID.ACHEY_TREE_LOGS;
    public static final int OAK_LOGS = ItemID.OAK_LOGS;
    public static final int WILLOW_LOGS = ItemID.WILLOW_LOGS;
    public static final int TEAK_LOGS = ItemID.TEAK_LOGS;
    public static final int JUNIPER_LOGS = ItemID.JUNIPER_LOGS;
    public static final int MAPLE_LOGS = ItemID.MAPLE_LOGS;
    public static final int MAHOGANY_LOGS = ItemID.MAHOGANY_LOGS;
    public static final int ARCTIC_PINE_LOGS = ItemID.ARCTIC_PINE_LOG;
    public static final int YEW_LOGS = ItemID.YEW_LOGS;
    public static final int BLISTERWOOD_LOGS = ItemID.BLISTERWOOD_LOGS;
    public static final int MAGIC_LOGS = ItemID.MAGIC_LOGS;
    public static final int REDWOOD_LOGS = ItemID.REDWOOD_LOGS;

    // Master scroll book
    public static final int MASTER_SCROLL_BOOK = ItemID.BOOKOFSCROLLS_CHARGED;
    public static final int MASTER_SCROLL_BOOK_UNCHARGED = ItemID.BOOKOFSCROLLS_EMPTY;
    public static final int TELEPORTSCROLL_NARDAH = ItemID.TELEPORTSCROLL_NARDAH;
    public static final int TELEPORTSCROLL_DIGSITE = ItemID.TELEPORTSCROLL_DIGSITE;
    public static final int TELEPORTSCROLL_FELDIP_HILLS = ItemID.TELEPORTSCROLL_FELDIP;
    public static final int TELEPORTSCROLL_LUNAR_ISLE = ItemID.TELEPORTSCROLL_LUNARISLE;
    public static final int TELEPORTSCROLL_MORTTON = ItemID.TELEPORTSCROLL_MORTTON;
    public static final int TELEPORTSCROLL_PEST_CONTROL = ItemID.TELEPORTSCROLL_PESTCONTROL;
    public static final int TELEPORTSCROLL_PISCATORIS = ItemID.TELEPORTSCROLL_PISCATORIS;
    public static final int TELEPORTSCROLL_TAI_BWO_WANNAI = ItemID.TELEPORTSCROLL_TAIBWO;
    public static final int TELEPORTSCROLL_IORWERTH_CAMP = ItemID.TELEPORTSCROLL_ELF;
    public static final int TELEPORTSCROLL_MOS_LEHARMLESS = ItemID.TELEPORTSCROLL_MOSLES;
    public static final int TELEPORTSCROLL_LUMBERYARD = ItemID.TELEPORTSCROLL_LUMBERYARD;
    public static final int TELEPORTSCROLL_ZULANDRA = ItemID.TELEPORTSCROLL_ZULANDRA;
    public static final int TELEPORTSCROLL_KEY_MASTER = ItemID.TELEPORTSCROLL_CERBERUS;
    public static final int TELEPORTSCROLL_REVENANTS_CAVE = ItemID.TELEPORTSCROLL_REVENANTS;
    public static final int TELEPORTSCROLL_WATSON = ItemID.TELEPORTSCROLL_WATSON;
    public static final int TELEPORTSCROLL_GUTHIXIAN_TEMPLE = ItemID.TELEPORTSCROLL_GUTHIXIAN_TEMPLE;
    public static final int TELEPORTSCROLL_SPIDER_CAVE = ItemID.TELEPORTSCROLL_SPIDERCAVE;
    public static final int TELEPORTSCROLL_COLOSSAL_WYRM = ItemID.TELEPORTSCROLL_COLOSSAL_WYRM;

    // Meat pouch
    public static final int MEAT_POUCH_SMALL = ItemID.HG_MEATPOUCH_SMALL;
    public static final int MEAT_POUCH_SMALL_OPEN = ItemID.HG_MEATPOUCH_SMALL_OPEN;
    public static final int MEAT_POUCH_LARGE = ItemID.HG_MEATPOUCH_LARGE;
    public static final int MEAT_POUCH_LARGE_OPEN = ItemID.HG_MEATPOUCH_LARGE_OPEN;
    public static final int RAW_BEAST_MEAT = ItemID.SPIT_RAW_BEAST_MEAT;
    public static final int RAW_WILD_KEBBIT = ItemID.HUNTINGBEAST_WILD_MEAT;
    public static final int RAW_BARBTAILED_KEBBIT = ItemID.HUNTINGBEAST_BARBED_MEAT;
    public static final int RAW_PYRE_FOX = ItemID.HUNTING_FENNECFOX_MEAT;
    public static final int RAW_LARUPIA = ItemID.HUNTING_LARUPIA_MEAT;
    public static final int RAW_GRAAHK = ItemID.HUNTING_GRAAHK_MEAT;
    public static final int RAW_KYATT = ItemID.HUNTING_KYATT_MEAT;
    public static final int RAW_SUNLIGHT_ANTELOPE = ItemID.HUNTING_ANTELOPESUN_MEAT;
    public static final int RAW_MOONLIGHT_ANTELOPE = ItemID.HUNTING_ANTELOPEMOON_MEAT;
    public static final int RAW_DASHING_KEBBIT = ItemID.HUNTINGBEAST_SPEEDY2_MEAT;

    // Ogre bellows
    public static final int OGRE_BELLOWS_0 = ItemID.EMPTY_OGRE_BELLOWS;
    public static final int OGRE_BELLOWS_1 = ItemID.FILLED_OGRE_BELLOW1;
    public static final int OGRE_BELLOWS_2 = ItemID.FILLED_OGRE_BELLOW2;
    public static final int OGRE_BELLOWS_3 = ItemID.FILLED_OGRE_BELLOW3;

    // Plank sack
    public static final int PLANK_SACK = ItemID.PLANK_SACK;
    public static final int PLANK = ItemID.WOODPLANK;
    public static final int OAK_PLANK = ItemID.PLANK_OAK;
    public static final int TEAK_PLANK = ItemID.PLANK_TEAK;
    public static final int MAHOGANY_PLANK = ItemID.PLANK_MAHOGANY;
    public static final int SAWMILL_VOUCHER = ItemID.FORESTRY_SAWMILL_VOUCHER;

    // Quetzal whistle
    public static final int QUETZAL_WHISTLE_BASIC = ItemID.HG_QUETZALWHISTLE_BASIC;
    public static final int QUETZAL_WHISTLE_ENHANCED = ItemID.HG_QUETZALWHISTLE_ENHANCED;
    public static final int QUETZAL_WHISTLE_PERFECTED = ItemID.HG_QUETZALWHISTLE_PERFECTED;
    public static final int QUETZAL_FEED = ItemID.VMQ2_QUETZAL_FEED;

    // Reagent pouch
    public static final int REAGENT_POUCH = ItemID.MM_SECONDARY_POUCH;
    public static final int REAGENT_POUCH_OPEN = ItemID.MM_SECONDARY_POUCH_OPEN;
    public static final int EYE_OF_NEWT = ItemID.EYE_OF_NEWT;
    public static final int LIMPWURT_ROOT = ItemID.LIMPWURT_ROOT;
    public static final int RED_SPIDERS_EGGS = ItemID.RED_SPIDERS_EGGS;
    public static final int TOADS_LEGS = ItemID.TOADS_LEGS;
    public static final int SNAPE_GRASS = ItemID.SNAPE_GRASS;
    public static final int MORT_MYRE_FUNGUS = ItemID.MORTMYREMUSHROOM;
    public static final int WHITE_BERRIES = ItemID.WHITE_BERRIES;
    public static final int JANGERBERRIES = ItemID.JANGERBERRIES;
    public static final int POISON_IVY_BERRIES = ItemID.POISONIVY_BERRIES;
    public static final int POTATO_CACTUS = ItemID.CACTUS_POTATO;
    public static final int CACTUS_SPINE = ItemID.CACTUS_SPINE;
    public static final int ASHES = ItemID.ASHES;
    public static final int CHOCOLATE_DUST = ItemID.CHOCOLATE_DUST;
    public static final int DRAGON_SCALE_DUST = ItemID.DRAGON_SCALE_DUST;
    public static final int GOAT_HORN_DUST = ItemID.GROUND_DESERT_GOAT_HORN;
    public static final int GORAK_CLAW_POWDER = ItemID.FAIRYTALE2_GROUND_GORAK_CLAWS;
    public static final int KEBBIT_TEETH_DUST = ItemID.HUNTINGBEAST_SABRETEETH_DUST;
    public static final int SILVER_DUST = ItemID.SILVER_DUST;
    public static final int UNICORN_HORN_DUST = ItemID.UNICORN_HORN_DUST;
    public static final int WINE_OF_ZAMORAK = ItemID.WINE_OF_ZAMORAK;
    public static final int ALDARIUM = ItemID.ALDARIUM;
    public static final int YEW_ROOTS = ItemID.YEW_ROOTS;
    public static final int MAGIC_ROOTS = ItemID.MAGIC_ROOTS;
    public static final int CRUSHED_NEST = ItemID.CRUSHED_BIRD_NEST;
    public static final int CRUSHED_SUPERIOR_DRAGON_BONES = ItemID.CRUSHED_DRAGON_BONES;
    public static final int NAIL_BEAST_NAILS = ItemID.NAIL_BEAST_NAIL;
    public static final int LILY_OF_THE_SANDS = ItemID.LILY_OF_THE_SANDS;
    public static final int CAVIAR = ItemID.BRUT_CAVIAR;
    public static final int ROE = ItemID.BRUT_ROE;

    // Seed box
    public static final int SEED_BOX = ItemID.SEED_BOX;
    public static final int SEED_BOX_OPEN = ItemID.SEED_BOX_OPEN;
    public static final int POTATO_SEED = ItemID.POTATO_SEED;
    public static final int ONION_SEED = ItemID.ONION_SEED;
    public static final int CABBAGE_SEED = ItemID.CABBAGE_SEED;
    public static final int TOMATO_SEED = ItemID.TOMATO_SEED;
    public static final int SWEETCORN_SEED = ItemID.SWEETCORN_SEED;
    public static final int STRAWBERRY_SEED = ItemID.STRAWBERRY_SEED;
    public static final int WATERMELON_SEED = ItemID.WATERMELON_SEED;
    public static final int SNAPE_GRASS_SEED = ItemID.SNAPE_GRASS_SEED;
    public static final int BARLEY_SEED = ItemID.BARLEY_SEED;
    public static final int HAMMERSTONE_SEED = ItemID.HAMMERSTONE_HOP_SEED;
    public static final int ASGARNIAN_SEED = ItemID.ASGARNIAN_HOP_SEED;
    public static final int JUTE_SEED = ItemID.JUTE_SEED;
    public static final int YANILLIAN_SEED = ItemID.YANILLIAN_HOP_SEED;
    public static final int KRANDORIAN_SEED = ItemID.KRANDORIAN_HOP_SEED;
    public static final int WILDBLOOD_SEED = ItemID.WILDBLOOD_HOP_SEED;
    public static final int ACORN = ItemID.ACORN;
    public static final int WILLOW_SEED = ItemID.WILLOW_SEED;
    public static final int MAPLE_SEED = ItemID.MAPLE_SEED;
    public static final int YEW_SEED = ItemID.YEW_SEED;
    public static final int MAGIC_SEED = ItemID.MAGIC_TREE_SEED;
    public static final int REDWOOD_TREE_SEED = ItemID.REDWOOD_TREE_SEED;
    public static final int APPLE_TREE_SEED = ItemID.APPLE_TREE_SEED;
    public static final int BANANA_TREE_SEED = ItemID.BANANA_TREE_SEED;
    public static final int ORANGE_TREE_SEED = ItemID.ORANGE_TREE_SEED;
    public static final int CURRY_TREE_SEED = ItemID.CURRY_TREE_SEED;
    public static final int PINEAPPLE_SEED = ItemID.PINEAPPLE_TREE_SEED;
    public static final int PAPAYA_TREE_SEED = ItemID.PAPAYA_TREE_SEED;
    public static final int PALM_TREE_SEED = ItemID.PALM_TREE_SEED;
    public static final int DRAGONFRUIT_TREE_SEED = ItemID.DRAGONFRUIT_TREE_SEED;
    public static final int REDBERRY_SEED = ItemID.REDBERRY_BUSH_SEED;
    public static final int CADAVABERRY_SEED = ItemID.CADAVABERRY_BUSH_SEED;
    public static final int DWELLBERRY_SEED = ItemID.DWELLBERRY_BUSH_SEED;
    public static final int JANGERBERRY_SEED = ItemID.JANGERBERRY_BUSH_SEED;
    public static final int WHITEBERRY_SEED = ItemID.WHITEBERRY_BUSH_SEED;
    public static final int POISON_IVY_SEED = ItemID.POISONIVY_BUSH_SEED;
    public static final int MARIGOLD_SEED = ItemID.MARIGOLD_SEED;
    public static final int ROSEMARY_SEED = ItemID.ROSEMARY_SEED;
    public static final int NASTURTIUM_SEED = ItemID.NASTURTIUM_SEED;
    public static final int WOAD_SEED = ItemID.WOAD_SEED;
    public static final int LIMPWURT_SEED = ItemID.LIMPWURT_SEED;
    public static final int WHITE_LILY_SEED = ItemID.WHITE_LILY_SEED;
    public static final int GUAM_SEED = ItemID.GUAM_SEED;
    public static final int MARRENTILL_SEED = ItemID.MARRENTILL_SEED;
    public static final int TARROMIN_SEED = ItemID.TARROMIN_SEED;
    public static final int HARRALANDER_SEED = ItemID.HARRALANDER_SEED;
    public static final int RANARR_SEED = ItemID.RANARR_SEED;
    public static final int TOADFLAX_SEED = ItemID.TOADFLAX_SEED;
    public static final int IRIT_SEED = ItemID.IRIT_SEED;
    public static final int AVANTOE_SEED = ItemID.AVANTOE_SEED;
    public static final int HUASCA_SEED = ItemID.HUASCA_SEED;
    public static final int KWUARM_SEED = ItemID.KWUARM_SEED;
    public static final int SNAPDRAGON_SEED = ItemID.SNAPDRAGON_SEED;
    public static final int CADANTINE_SEED = ItemID.CADANTINE_SEED;
    public static final int LANTADYME_SEED = ItemID.LANTADYME_SEED;
    public static final int DWARF_WEED_SEED = ItemID.DWARF_WEED_SEED;
    public static final int TORSTOL_SEED = ItemID.TORSTOL_SEED;
    public static final int SEAWEED_SPORE = ItemID.SEAWEED_SEED;
    public static final int TEAK_SEED = ItemID.TEAK_SEED;
    public static final int GRAPE_SEED = ItemID.GRAPE_SEED;
    public static final int MUSHROOM_SPORE = ItemID.MUSHROOM_SEED;
    public static final int MAHOGANY_SEED = ItemID.MAHOGANY_SEED;
    public static final int CACTUS_SEED = ItemID.CACTUS_SEED;
    public static final int BELLADONNA_SEED = ItemID.BELLADONNA_SEED;
    public static final int POTATO_CACTUS_SEED = ItemID.POTATO_CACTUS_SEED;
    public static final int HESPORI_SEED = ItemID.HESPORI_SEED;
    public static final int CALQUAT_TREE_SEED = ItemID.CALQUAT_TREE_SEED;
    public static final int CRYSTAL_ACORN = ItemID.CRYSTAL_TREE_SEED;
    public static final int KRONOS_SEED = ItemID.KRONOS_SEED;
    public static final int IASOR_SEED = ItemID.IASOR_SEED;
    public static final int ATTAS_SEED = ItemID.ATTAS_SEED;
    public static final int SPIRIT_SEED = ItemID.SPIRIT_TREE_SEED;
    public static final int CELASTRUS_SEED = ItemID.CELASTRUS_TREE_SEED;

    // Soul bearer
    public static final int SOUL_BEARER = ItemID.ARCEUUS_SOULBEARER;
    public static final int SOUL_BEARER_UNCHARGED = ItemID.ARCEUUS_SOULBEARER_DAMAGED;

    // Strange old lockpick
    public static final int STRANGE_OLD_LOCKPICK = ItemID.STRANGE_OLD_LOCKPICK_FULL;
    public static final int STRANGE_OLD_LOCKPICK_DEGRADED = ItemID.STRANGE_OLD_LOCKPICK;

    // Tackle box
    public static final int TACKLE_BOX = ItemID.TACKLE_BOX;
    public static final int ANGLER_HAT = ItemID.TRAWLER_REWARD_HAT;
    public static final int ANGLER_TOP = ItemID.TRAWLER_REWARD_TOP;
    public static final int ANGLER_WADERS = ItemID.TRAWLER_REWARD_LEGS;
    public static final int ANGLER_BOOTS = ItemID.TRAWLER_REWARD_BOOTS;
    public static final int SPIRIT_ANGLER_HEADBAND = ItemID.SPIRIT_ANGLER_HAT;
    public static final int SPIRIT_ANGLER_TOP = ItemID.SPIRIT_ANGLER_TOP;
    public static final int SPIRIT_ANGLER_WADERS = ItemID.SPIRIT_ANGLER_LEGS;
    public static final int SPIRIT_ANGLER_BOOTS = ItemID.SPIRIT_ANGLER_BOOTS;
    public static final int SPIRIT_FLAKES = ItemID.SPIRIT_FLAKES;
    public static final int FISHBOWL_HELMET = ItemID.HUNDRED_PIRATE_DIVING_HELMET;
    public static final int FLIPPERS = ItemID.MUDSKIPPER_FLIPPERS;
    public static final int DARK_FLIPPERS = ItemID.DARK_FLIPPERS;
    public static final int DIVING_APPARATUS = ItemID.HUNDRED_PIRATE_DIVING_BACKPACK;
    public static final int TINY_NET = ItemID.TINY_NET;
    public static final int RADAS_BLESSING_1 = ItemID.ZEAH_BLESSING_EASY;
    public static final int RADAS_BLESSING_2 = ItemID.ZEAH_BLESSING_MEDIUM;
    public static final int RADAS_BLESSING_3 = ItemID.ZEAH_BLESSING_HARD;
    public static final int RADAS_BLESSING_4 = ItemID.ZEAH_BLESSING_ELITE;
    public static final int HARPOON = ItemID.HARPOON;
    public static final int BARBTAIL_HARPOON = ItemID.HUNTING_BARBED_HARPOON;
    public static final int DRAGON_HARPOON = ItemID.DRAGON_HARPOON;
    public static final int DRAGON_HARPOON_OR = ItemID.TRAILBLAZER_HARPOON_NO_INFERNAL;
    public static final int DRAGON_HARPOON_OR_30349 = ItemID.TRAILBLAZER_RELOADED_HARPOON_NO_INFERNAL;
    public static final int INFERNAL_HARPOON = ItemID.INFERNAL_HARPOON;
    public static final int INFERNAL_HARPOON_UNCHARGED = ItemID.INFERNAL_HARPOON_EMPTY;
    public static final int INFERNAL_HARPOON_UNCHARGED_25367 = ItemID.TRAILBLAZER_HARPOON_EMPTY;
    public static final int INFERNAL_HARPOON_UNCHARGED_30343 = ItemID.TRAILBLAZER_RELOADED_HARPOON_EMPTY;
    public static final int INFERNAL_HARPOON_OR = ItemID.TRAILBLAZER_HARPOON;
    public static final int INFERNAL_HARPOON_OR_30342 = ItemID.TRAILBLAZER_RELOADED_HARPOON;
    public static final int CRYSTAL_HARPOON = ItemID.CRYSTAL_HARPOON;
    public static final int CRYSTAL_HARPOON_23864 = ItemID.GAUNTLET_HARPOON;
    public static final int CRYSTAL_HARPOON_INACTIVE = ItemID.CRYSTAL_HARPOON_INACTIVE;
    public static final int MERFOLK_TRIDENT = ItemID.MERFOLK_TRIDENT;
    public static final int FISHING_ROD = ItemID.FISHING_ROD;
    public static final int PEARL_FISHING_ROD = ItemID.FISHINGROD_PEARL;
    public static final int FLY_FISHING_ROD = ItemID.FLY_FISHING_ROD;
    public static final int PEARL_FLY_FISHING_ROD = ItemID.FISHINGROD_PEARL_FLY;
    public static final int OILY_FISHING_ROD = ItemID.OILY_FISHING_ROD;
    public static final int OILY_PEARL_FISHING_ROD = ItemID.FISHINGROD_PEARL_OILY;
    public static final int BARBARIAN_ROD = ItemID.BRUT_FISHING_ROD;
    public static final int PEARL_BARBARIAN_ROD = ItemID.FISHINGROD_PEARL_BRUT;
    public static final int BIG_FISHING_NET = ItemID.BIG_NET;
    public static final int DRIFT_NET = ItemID.FOSSIL_DRIFT_NET;
    public static final int LOBSTER_POT = ItemID.LOBSTER_POT;
    public static final int KARAMBWAN_VESSEL = ItemID.TBWT_KARAMBWAN_VESSEL;
    public static final int KARAMBWAN_VESSEL_3159 = ItemID.TBWT_KARAMBWAN_VESSEL_LOADED_WITH_KARAMBWANJI;
    public static final int RAW_KARAMBWANJI = ItemID.TBWT_RAW_KARAMBWANJI;
    public static final int FISHING_BAIT = ItemID.FISHING_BAIT;
    public static final int FEATHER = ItemID.FEATHER;
    public static final int DARK_FISHING_BAIT = ItemID.WILDERNESS_FISHING_BAIT;
    public static final int SANDWORMS = ItemID.PISCARILIUS_SANDWORMS;
    public static final int FISH_OFFCUTS = ItemID.BRUT_FISH_CUTS;
    public static final int FISH_CHUNKS = ItemID.FISH_CHUNKS;
    public static final int FISHING_POTION2 = ItemID._2DOSEFISHERSPOTION;
    public static final int FISHING_POTION3 = ItemID._3DOSEFISHERSPOTION;
    public static final int FISHING_POTION4 = ItemID._4DOSEFISHERSPOTION;
    public static final int MOLCH_PEARL = ItemID.AERIAL_FISHING_PEARL;
    public static final int STRIPY_FEATHER = ItemID.HUNTING_STRIPY_BIRD_FEATHER;

    // Teleport crystal
    public static final int TELEPORT_CRYSTAL_0 = ItemID.GAUNTLET_TELEPORT_CRYSTAL;
    public static final int TELEPORT_CRYSTAL_1 = ItemID.MOURNING_TELEPORT_CRYSTAL_1;
    public static final int TELEPORT_CRYSTAL_2 = ItemID.MOURNING_TELEPORT_CRYSTAL_2;
    public static final int TELEPORT_CRYSTAL_3 = ItemID.MOURNING_TELEPORT_CRYSTAL_3;
    public static final int TELEPORT_CRYSTAL_4 = ItemID.MOURNING_TELEPORT_CRYSTAL_4;
    public static final int TELEPORT_CRYSTAL_5 = ItemID.MOURNING_TELEPORT_CRYSTAL_5;

    // Waterskin
    public static final int WATERSKIN_0 = ItemID.WATER_SKIN0;
    public static final int WATERSKIN_1 = ItemID.WATER_SKIN1;
    public static final int WATERSKIN_2 = ItemID.WATER_SKIN2;
    public static final int WATERSKIN_3 = ItemID.WATER_SKIN3;
    public static final int WATERSKIN_4 = ItemID.WATER_SKIN4;

    // Arclight
    public static final int ARCLIGHT = ItemID.ARCLIGHT;
    public static final int ARCLIGHT_UNCHARGED = ItemID.ARCLIGHT_INACTIVE;

    // Bow of faerdhinen
    public static final int BOW_OF_FAERDHINEN_INACTIVE = ItemID.BOW_OF_FAERDHINEN_INACTIVE;
    public static final int BOW_OF_FAERDHINEN = ItemID.BOW_OF_FAERDHINEN;
    public static final int BOW_OF_FAERDHINEN_CORRUPTED = ItemID.BOW_OF_FAERDHINEN_INFINITE;
    public static final int BOW_OF_FAERDHINEN_CORRUPTED_ITHELL = ItemID.BOW_OF_FAERDHINEN_INFINITE_ITHELL;
    public static final int BOW_OF_FAERDHINEN_CORRUPTED_IORWERTH = ItemID.BOW_OF_FAERDHINEN_INFINITE_IORWERTH;
    public static final int BOW_OF_FAERDHINEN_CORRUPTED_TRAHAEARN = ItemID.BOW_OF_FAERDHINEN_INFINITE_TRAHAEARN;
    public static final int BOW_OF_FAERDHINEN_CORRUPTED_CADARN = ItemID.BOW_OF_FAERDHINEN_INFINITE_CADARN;
    public static final int BOW_OF_FAERDHINEN_CORRUPTED_CRWYS = ItemID.BOW_OF_FAERDHINEN_INFINITE_CRWYS;
    public static final int BOW_OF_FAERDHINEN_CORRUPTED_MEILYR = ItemID.BOW_OF_FAERDHINEN_INFINITE_MEILYR;
    public static final int BOW_OF_FAERDHINEN_CORRUPTED_AMLODD = ItemID.BOW_OF_FAERDHINEN_INFINITE_AMLODD;

    // Crystal bow
    public static final int CRYSTAL_BOW = ItemID.CRYSTAL_BOW;
    public static final int CRYSTAL_BOW_FULL = ItemID.CRYSTAL_BOW_2500;
    public static final int CRYSTAL_BOW_UNCHARGED = ItemID.CRYSTAL_BOW_INACTIVE;

    // Crystal halberd
    public static final int CRYSTAL_HALBERD = ItemID.CRYSTAL_HALBERD;
    public static final int CRYSTAL_HALBERD_FULL = ItemID.CRYSTAL_HALBERD_2500;
    public static final int CRYSTAL_HALBERD_UNCHARGED = ItemID.CRYSTAL_HALBERD_INACTIVE;

    // Enchanted lyre
    public static final int ENCHANTED_LYRE_0 = ItemID.VIKING_ENCHANTED_STRUNG_LYRE;
    public static final int ENCHANTED_LYRE_1 = ItemID.MAGIC_STRUNG_LYRE;
    public static final int ENCHANTED_LYRE_2 = ItemID.MAGIC_STRUNG_LYRE_2;
    public static final int ENCHANTED_LYRE_3 = ItemID.MAGIC_STRUNG_LYRE_3;
    public static final int ENCHANTED_LYRE_4 = ItemID.MAGIC_STRUNG_LYRE_4;
    public static final int ENCHANTED_LYRE_5 = ItemID.MAGIC_STRUNG_LYRE_5;
    public static final int ENCHANTED_LYRE_IMBUED = ItemID.MAGIC_STRUNG_LYRE_INFINITE;

    // Bryophyta' staff
    public static final int BRYOPHYTAS_STAFF = ItemID.NATURE_STAFF_CHARGED;
    public static final int BRYOPHYTAS_STAFF_UNCHARGED = ItemID.NATURE_STAFF_UNCHARGED;

    // Iban's staff
    public static final int IBANS_STAFF = ItemID.IBANSTAFF;
    public static final int IBANS_STAFF_BROKEN = ItemID.BROKENIBANSTAFF;
    public static final int IBANS_STAFF_UPGRADED = ItemID.IBANSTAFF_UPGRADED;

    // Pharaoh's sceptre
    public static final int PHARAOHS_SCEPTRE_UNCHARGED = ItemID.PHARAOHS_SCEPTRE;
    public static final int PHARAOHS_SCEPTRE = ItemID.PHARAOHS_SCEPTRE_CHARGED;
    public static final int PHARAOHS_SCEPTRE_INITIAL = ItemID.PHARAOHS_SCEPTRE_CHARGED_INITIAL;

    // Sanguinesti staff
    public static final int SANGUINESTI_STAFF = ItemID.SANGUINESTI_STAFF;
    public static final int SANGUINESTI_STAFF_UNCHARGED = ItemID.SANGUINESTI_STAFF_UNCHARGED;
    public static final int SANGUINESTI_STAFF_HOLY = ItemID.SANGUINESTI_STAFF_OR;
    public static final int SANGUINESTI_STAFF_HOLY_UNCHARGED = ItemID.SANGUINESTI_STAFF_UNCHARGED_OR;

    // Scythe of vitur
    public static final int SCYTHE_OF_VITUR = ItemID.SCYTHE_OF_VITUR;
    public static final int SCYTHE_OF_VITUR_UNCHARGED = ItemID.SCYTHE_OF_VITUR_UNCHARGED;
    public static final int HOLY_SCYTHE_OF_VITUR = ItemID.SCYTHE_OF_VITUR_OR;
    public static final int HOLY_SCYTHE_OF_VITUR_UNCHARGED = ItemID.SCYTHE_OF_VITUR_UNCHARGED_OR;
    public static final int SANGUINE_SCYTHE_OF_VITUR = ItemID.SCYTHE_OF_VITUR_BL;
    public static final int SANGUINE_SCYTHE_OF_VITUR_UNCHARGED = ItemID.SCYTHE_OF_VITUR_UNCHARGED_BL;

    // Skull sceptre
    public static final int SKULL_SCEPTRE = ItemID.SOS_SKULL_SCEPTRE;
    public static final int SKULL_SCEPTRE_IMBUED = ItemID.SOS_SKULL_SCEPTRE_IMBUED;

    // Slayer staff enchanted
    public static final int SLAYER_STAFF_ENCHANTED = ItemID.SLAYER_STAFF_ENCHANTED;

    // Toxic staff of the dead
    public static final int TOXIC_STAFF_OF_THE_DEAD = ItemID.TOXIC_SOTD_CHARGED;
    public static final int TOXIC_STAFF_OF_THE_DEAD_UNCHARGED = ItemID.TOXIC_SOTD;

    // Tridents
    public static final int TRIDENT_OF_THE_SEAS_UNCHARGED = ItemID.TOTS_UNCHARGED;
    public static final int TRIDENT_OF_THE_SEAS = ItemID.TOTS_CHARGED;
    public static final int TRIDENT_OF_THE_SEAS_FULL = ItemID.TOTS;
    public static final int TRIDENT_OF_THE_SEAS_ENCHANTED = ItemID.TOTS_I_CHARGED;
    public static final int TRIDENT_OF_THE_SEAS_ENCHANTED_UNCHARGED = ItemID.TOTS_I_UNCHARGED;
    public static final int TRIDENT_OF_THE_SWAMP = ItemID.TOXIC_TOTS_CHARGED;
    public static final int TRIDENT_OF_THE_SWAMP_UNCHARGED = ItemID.TOXIC_TOTS_UNCHARGED;
    public static final int TRIDENT_OF_THE_SWAMP_ENCHANTED = ItemID.TOXIC_TOTS_I_CHARGED;
    public static final int TRIDENT_OF_THE_SWAMP_ENCHANTED_UNCHARGED = ItemID.TOXIC_TOTS_I_UNCHARGED;

    // Tumekens shadow
    public static final int TUMEKENS_SHADOW = ItemID.TUMEKENS_SHADOW;
    public static final int TUMEKENS_SHADOW_UNCHARGED = ItemID.TUMEKENS_SHADOW_UNCHARGED;

    // Venator bow
    public static final int VENATOR_BOW = ItemID.VENATOR_BOW;
    public static final int VENATOR_BOW_UNCHARGED = ItemID.VENATOR_BOW_UNCHARGED;

    // Warped sceptre
    public static final int WARPED_SCEPTRE = ItemID.WARPED_SCEPTRE;
    public static final int WARPED_SCEPTRE_UNCHARGED = ItemID.WARPED_SCEPTRE_UNCHARGED;

    // Western banner
    public static final int WESTERN_BANNER_3 = ItemID.WESTERN_BANNER_HARD;
    public static final int WESTERN_BANNER_4 = ItemID.WESTERN_BANNER_ELITE;
}

package tictac7x.charges.store;

public enum CombatStyle {
    MELEE,
    RANGED,
    MAGIC,
    UNKNOWN,
}

package tictac7x.charges.store;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.EnumID;
import net.runelite.api.ParamID;
import net.runelite.api.StructComposition;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;

/**
 * Get a generalised weapon style (melee/magic/ranged) from the current attack style.
 * @see net.runelite.client.plugins.attackstyles.AttackStylesPlugin
 */
@Slf4j
public class WeaponAttackStyle {
    private final Client client;

    public WeaponAttackStyle(final Client client) {
        this.client = client;
    }

    public CombatStyle getCombatStyle() {
        final int currentAttackStyleVarbit = client.getVarpValue(VarPlayer.ATTACK_STYLE);
        final int currentEquippedWeaponTypeVarbit = client.getVarbitValue(Varbits.EQUIPPED_WEAPON_TYPE);
        final int weaponStyleEnum = client.getEnum(EnumID.WEAPON_STYLES).getIntValue(currentEquippedWeaponTypeVarbit);
        final int[] weaponStyleStructs = client.getEnum(weaponStyleEnum).getIntVals();

        final AttackStyle attackStyle = getAttackStyle(currentAttackStyleVarbit, weaponStyleStructs);
        return getWeaponFromAttackStyle(attackStyle, weaponStyleStructs);
    }

    private AttackStyle getAttackStyle(int attackStyleVarbit, final int [] weaponStyleStructs) {
        // Get selected weapon attack style
        StructComposition attackStyleStruct = client.getStructComposition(weaponStyleStructs[attackStyleVarbit]);
        String attackStyleName = attackStyleStruct.getStringValue(ParamID.ATTACK_STYLE_NAME);

        // Get selected attack style
        return AttackStyle.valueOf(attackStyleName.toUpperCase());
    }

    private CombatStyle getWeaponFromAttackStyle(final AttackStyle attackStyle, final int[] weaponStyleStructs) {
        switch (attackStyle) {
            case ACCURATE:
            case AGGRESSIVE:
            case CONTROLLED:
                return CombatStyle.MELEE;
            case RANGING:
            case LONGRANGE:
                return CombatStyle.RANGED;
            case CASTING:
            case DEFENSIVE_CASTING:
                return CombatStyle.MAGIC;
            // "Defensive" is shared between melee and magic
            // We can look at the first attack style to determine which one is in use
            case DEFENSIVE:
                final AttackStyle firstAttackStyle = getAttackStyle(0, weaponStyleStructs);

                return firstAttackStyle != AttackStyle.DEFENSIVE
                    ? getWeaponFromAttackStyle(firstAttackStyle, weaponStyleStructs)
                    : CombatStyle.UNKNOWN;
            default:
                return CombatStyle.UNKNOWN;
        }
    }

    @Getter
    enum AttackStyle {
        ACCURATE("Accurate"),
        AGGRESSIVE("Aggressive"),
        DEFENSIVE("Defensive"),
        CONTROLLED("Controlled"),
        RANGING("Ranging"),
        LONGRANGE("Longrange"),
        CASTING("Casting"),
        DEFENSIVE_CASTING("Defensive Casting"),
        OTHER("Other");

        private final String name;

        AttackStyle(String name) {
            this.name = name;
        }
    }
}

package tictac7x.charges.store;

public enum EscapeCrystalTimeRemainingUnit {
    SECONDS,
    TICKS,
}

package tictac7x.charges.store;

public enum CombatTimeDegradableStyle {
    CHARGES,
    PERCENTAGE,
    TIME,
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.CombatStyle;
import tictac7x.charges.store.HitsplatGroup;
import tictac7x.charges.store.HitsplatTarget;
import tictac7x.charges.store.Store;

public class J_EfaritaysAid extends ChargedItem {
    public J_EfaritaysAid(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.efaritays_aid, ItemId.EFARITAYS_AID, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.EFARITAYS_AID).needsToBeEquipped()
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Your ring has (?<charges>.+) charges? left.").setDynamicallyCharges().onItemClick(),

            // Break.
            new OnChatMessage("The ring shatters. Your next Efaritay's aid ring will start afresh from (?<charges>.+) charges.").setDynamicallyCharges(),

            // Out of charges.
            new OnChatMessage("Your ring crumbles to dust.").setFixedCharges(0),

            // Charges from break dialog.
            new OnWidgetLoaded(219, 1, 0).text("Status: (?<charges>.+) charges? left.").setDynamically().onMenuOption("Break").onMenuTarget("Efaritay's aid"),

            // Attack tier-2 vampyre.
            new OnHitsplatApplied(HitsplatTarget.ENEMY).hasTargetName("Vampyre Juvinate").isEquipped().multiTrigger().decreaseCharges(1),

            // Additional charge used with silver melee weapon on successful hit.
            new OnHitsplatApplied(HitsplatTarget.ENEMY, HitsplatGroup.ALL).hasTargetName("Vampyre Juvinate").combatStyle(CombatStyle.MELEE).isEquipped().multiTrigger().itemEquipped(
                ItemId.BLESSED_AXE,
                ItemId.IVANDIS_FLAIL,
                ItemId.BLISTERWOOD_FLAIL,
                ItemId.SILVER_SICKLE,
                ItemId.SILVER_SICKLE_BLESSED,
                ItemId.EMERALD_SICKLE_BLESSED,
                ItemId.EMERALD_SICKLE_BLESSED_ENCHANTED,
                ItemId.RUBY_SICKLE_BLESSED,
                ItemId.RUBY_SICKLE_BLESSED_ENCHANTED,
                ItemId.BLISTERWOOD_SICKLE,
                ItemId.SILVERLIGHT,
                ItemId.DARKLIGHT,
                ItemId.ARCLIGHT,
                ItemId.ARCLIGHT_UNCHARGED,
                ItemId.EMBERLIGHT,
                ItemId.ROD_OF_IVANDIS_1,
                ItemId.ROD_OF_IVANDIS_2,
                ItemId.ROD_OF_IVANDIS_3,
                ItemId.ROD_OF_IVANDIS_4,
                ItemId.ROD_OF_IVANDIS_5,
                ItemId.ROD_OF_IVANDIS_6,
                ItemId.ROD_OF_IVANDIS_7,
                ItemId.ROD_OF_IVANDIS_8,
                ItemId.ROD_OF_IVANDIS_9,
                ItemId.ROD_OF_IVANDIS_10,
                ItemId.WOLFBANE
            ).decreaseCharges(1),

            // Additional charge used with silver bolts on successful hit.
            new OnHitsplatApplied(HitsplatTarget.ENEMY, HitsplatGroup.ALL).hasTargetName("Vampyre Juvinate").combatStyle(CombatStyle.RANGED).isEquipped().multiTrigger().itemEquipped(
                ItemId.SILVER_BOLTS
            ).decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class F_SnowyKnightMix extends ChargedItem {
    public F_SnowyKnightMix(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.snowy_knight_mix, ItemId.SNOWY_KNIGHT_MIX_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.SNOWY_KNIGHT_MIX_1).fixedCharges(1),
            new TriggerItem(ItemId.SNOWY_KNIGHT_MIX_2).fixedCharges(2),
        };
    }

    @Override
    public String getTooltip() {
        return "Snowy knight mix: " + getTotalCharges();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.Skill;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.WidgetId;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_PlankSack extends ChargedItemWithStorage {
    private final Pattern homeBuildingPlanksPattern = Pattern.compile("(?<type>Plank|Oak plank|Teak plank|Mahogany plank): (?<amount>[0-9]+)");
    private final Map<Integer, Integer> homeBuildingWidgetMaterialsUsed = new HashMap<>();
    private Optional<Integer> sawmillLogId = Optional.empty();
    private Optional<Integer> sawmillPlankId = Optional.empty();

    public U_PlankSack(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.plank_sack, ItemId.PLANK_SACK, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage.setMaximumTotalQuantity(28).emptyIsNegative().storableItems(
            new StorableItem(ItemId.PLANK).checkName("Regular plank"),
            new StorableItem(ItemId.OAK_PLANK).checkName("Oak plank"),
            new StorableItem(ItemId.TEAK_PLANK).checkName("Teak plank"),
            new StorableItem(ItemId.MAHOGANY_PLANK).checkName("Mahogany plank")
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.PLANK_SACK),
        };

        this.triggers = new TriggerBase[]{
            // Empty.
            new OnChatMessage("Your sack is empty.").emptyStorage(),

            // Check.
            new OnChatMessage("Basic planks: (?<regular>.+), Oak planks: (?<oak>.+), Teak planks: (?<teak>.+), Mahogany planks: (?<mahogany>.+)").matcherConsumer(m -> {
                storage.clear();
                storage.put(ItemId.PLANK, Integer.parseInt(m.group("regular")));
                storage.put(ItemId.OAK_PLANK, Integer.parseInt(m.group("oak")));
                storage.put(ItemId.TEAK_PLANK, Integer.parseInt(m.group("teak")));
                storage.put(ItemId.MAHOGANY_PLANK, Integer.parseInt(m.group("mahogany")));
            }),

            // Empty to inventory.
            new OnItemContainerChanged(INVENTORY).emptyStorageToInventory().onMenuOption("Empty", TicTac7xChargesImprovedPlugin.menuOptionEmptyToInventory),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption("Fill", TicTac7xChargesImprovedPlugin.menuOptionFillFromInventory),

            // Use plank on sack.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Replace "Use" with proper Fill/Empty option.
            new OnMenuEntryAdded("Use").replaceOptionConsumer(() -> getMenuOptionForUse()).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),
            new OnMenuEntryAdded("Use").replaceOptionConsumer(() -> getMenuOptionForUse()).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Hallowed Sepulchre
            new OnXpDrop(Skill.CONSTRUCTION).xpAmountConsumer((xp) -> {
                storage.removeAndPrioritizeInventory(ItemId.MAHOGANY_PLANK, 2);
            }).onMenuOptionId(
                39527, 39528
            ),

            // Plank Make on Log in Inventory
            new OnXpDrop(Skill.MAGIC).onMenuOption("Cast").onMenuTarget(
                "Plank Make -> Logs").addToStorage(ItemId.PLANK, 1),
            new OnXpDrop(Skill.MAGIC).onMenuOption("Cast").onMenuTarget(
                "Plank Make -> Oak logs").addToStorage(ItemId.OAK_PLANK, 1),
            new OnXpDrop(Skill.MAGIC).onMenuOption("Cast").onMenuTarget(
                "Plank Make -> Teak logs").addToStorage(ItemId.TEAK_PLANK, 1),
            new OnXpDrop(Skill.MAGIC).onMenuOption("Cast").onMenuTarget(
                "Plank Make -> Mahogany logs").addToStorage(ItemId.MAHOGANY_PLANK, 1),

            // Mahogany homes - 1 plank
            new OnXpDrop(Skill.CONSTRUCTION).xpAmountConsumer((xp) -> {
                storage.removeAndPrioritizeInventory(getPlankIdBasedOnXpAndPlanks(xp, 1), 1);
            }).onMenuOptionId(
                39982, // Bob clock
                40010, // Leela mirror
                40295, // Tau hat stand
                40099, // Larry clock
                40298, // Larry hat stand
                40289, // Mariah hat stand
                40168, // Ross hat stand
                40170, // Ross mirror
                39995, // Jeff mirror
                39996, // Jeff chair
                40011, // Barbara clock
                40014, // Barbara chair (1)
                40015, // Barbara chair (2)
                40158, // Noella hat stand
                40159, // Noella mirror
                40163, // Noella clock
                40089, // Norman clock
                40177  // Jess clock
            ),

            // Mahogany homes - 2 planks
            new OnXpDrop(Skill.CONSTRUCTION).xpAmountConsumer((xp) -> {
                storage.removeAndPrioritizeInventory(getPlankIdBasedOnXpAndPlanks(xp, 2), 2);
            }).onMenuOptionId(
                39985, // Bob bookcase (1)
                39986, // Bob bookcase (2)
                39983, // Bob cabinet (1)
                39984, // Bob cabinet (2)
                39987, // Bob wardrobe
                39988, // Bob drawers
                40007, // Leela small table (1)
                40008, // Leela small table (2)
                40292, // Leela cupboard
                40086, // Tau cupboard
                40087, // Tau shelves (1)
                40088, // Tau shelves (2)
                40095, // Larry drawers (1)
                40096, // Larry drawers (2)
                40003, // Mariah shelves
                40004, // Mariah bed
                40005, // Mariah small table (1)
                40006, // Mariah small table (2)
                40288, // Mariah cupboard
                40165, // Ross drawers (1)
                40166, // Ross drawers (2)
                40169, // Ross bed
                39990, // Jeff bookcase
                39991, // Jeff shelves
                39993, // Jeff drawers
                39994, // Jeff dresser
                40013, // Barbara bed
                40294, // Barbara drawers
                40156, // Noella dresser
                40157, // Noella cupboard
                40160, // Noella drawers
                40092, // Norman bookshelf
                40093, // Norman drawers
                40094, // Norman small table
                39998, // Sarah bed
                39999, // Sarah dresser
                40000, // Sarah small table
                40001, // Sarah shelves
                40171, // Jess drawers (1)
                40172, // Jess drawers (2)
                40173, // Jess cabinet (1)
                40174  // Jess cabinet (2)
            ),

            // Mahogany homes - 3 planks
            new OnXpDrop(Skill.CONSTRUCTION).xpAmountConsumer((xp) -> {
                storage.removeAndPrioritizeInventory(getPlankIdBasedOnXpAndPlanks(xp, 3), 3);
            }).onMenuOptionId(
                40009, // Leela table
                40291, // Leela double bed
                40084, // Tau table (1)
                40085, // Tau table (2)
                40097, // Larry table (1)
                40098, // Larry table (2)
                40002, // Mariah table
                40167, // Ross double bed
                39989, // Jeff table
                39992, // Jeff bed
                40012, // Barbara table
                40161, // Noella table (1)
                40162, // Noella table (2)
                40090, // Norman table
                40091, // Norman double bed
                39997, // Sarah table
                40175, // Jess bed
                40176  // Jess table
            ),

            // Mahogany homes - 4 planks
            new OnXpDrop(Skill.CONSTRUCTION).xpAmountConsumer((xp) -> {
                storage.removeAndPrioritizeInventory(getPlankIdBasedOnXpAndPlanks(xp, 4), 4);
            }).onMenuOptionId(
                39981  // Bob large table
            ),

            // Building in home with clicks.
            new OnScriptPreFired(1405).scriptConsumer(script -> {
                final Optional<Widget> itemWidget = Optional.ofNullable(script.getScriptEvent().getSource());
                if (!itemWidget.isPresent()) return;

                final Optional<Widget> materialsWidget = Optional.ofNullable(itemWidget.get().getChild(3));
                if (!materialsWidget.isPresent()) return;

                addPlanksToBeUsedFromHomeMaterialsWidgetText(materialsWidget.get().getText());
            }),
            // Building in home with keybinds.
            new OnScriptPreFired(1632).scriptConsumer(script -> {
                homeBuildingWidgetMaterialsUsed.clear();

                final int keyChar = script.getScriptEvent().getTypedKeyChar();
                if (keyChar < 48 || keyChar > 57) return;
                final int nthItemToBuild = keyChar - 48;

                final Optional<Widget> materialsWidget = TicTac7xChargesImprovedPlugin.getWidget(client, 458, 3 + nthItemToBuild, 3);
                if (!materialsWidget.isPresent()) return;

                addPlanksToBeUsedFromHomeMaterialsWidgetText(materialsWidget.get().getText());
            }),
            // XP drop after planks to be used from home materials widget text.
            new OnXpDrop(Skill.CONSTRUCTION).consumer(() -> {
                if (homeBuildingWidgetMaterialsUsed.isEmpty()) return;

                for (final Map.Entry<Integer, Integer> entry : homeBuildingWidgetMaterialsUsed.entrySet()) {
                    storage.removeAndPrioritizeInventory(entry.getKey(), entry.getValue());
                }

                homeBuildingWidgetMaterialsUsed.clear();
            }),

            // Sawmill, this script fires multiple times and regardless of the number of crafts
            new OnScriptPreFired(2053).scriptConsumer(script -> {
                final Optional<Widget> itemWidget = Optional.ofNullable(script.getScriptEvent().getSource());
                if (!itemWidget.isPresent()) return;

                final int sawmillLogId = (int) script.getScriptEvent().getArguments()[2];
                switch (sawmillLogId) {
                    case ItemId.LOGS:
                        this.sawmillLogId = Optional.of(ItemId.LOGS);
                        this.sawmillPlankId = Optional.of(ItemId.PLANK);
                        break;
                    case ItemId.OAK_LOGS:
                        this.sawmillLogId = Optional.of(ItemId.OAK_LOGS);
                        this.sawmillPlankId = Optional.of(ItemId.OAK_PLANK);
                        break;
                    case ItemId.TEAK_LOGS:
                        this.sawmillLogId = Optional.of(ItemId.TEAK_LOGS);
                        this.sawmillPlankId = Optional.of(ItemId.TEAK_PLANK);
                        break;
                    case ItemId.MAHOGANY_LOGS:
                        this.sawmillLogId = Optional.of(ItemId.MAHOGANY_LOGS);
                        this.sawmillPlankId = Optional.of(ItemId.MAHOGANY_PLANK);
                        break;
                }
            }),
            new OnItemContainerChanged(INVENTORY).onInventoryDifference(itemsDifference -> {
                if (!sawmillLogId.isPresent() || !sawmillPlankId.isPresent()) return;

                final int logsDifference = itemsDifference.count(sawmillLogId.get());
                final int planksDifference = itemsDifference.count(sawmillPlankId.get());
                final int vouchersDifference = itemsDifference.count(ItemId.SAWMILL_VOUCHER);

                storage.add(this.sawmillPlankId.get(), Math.abs(logsDifference) + Math.abs(vouchersDifference) - Math.abs(planksDifference));

                this.sawmillLogId = Optional.empty();
                this.sawmillPlankId = Optional.empty();
            }),
        };
    }

    private void addPlanksToBeUsedFromHomeMaterialsWidgetText(final String materials) {
        final Matcher matcher = homeBuildingPlanksPattern.matcher(materials);
        while (matcher.find()) {
            final String type = matcher.group("type");
            final int amount = Integer.parseInt(matcher.group("amount"));
            switch (type) {
                case "Plank":
                    homeBuildingWidgetMaterialsUsed.put(ItemId.PLANK, amount);
                    break;
                case "Oak plank":
                    homeBuildingWidgetMaterialsUsed.put(ItemId.OAK_PLANK, amount);
                    break;
                case "Teak plank":
                    homeBuildingWidgetMaterialsUsed.put(ItemId.TEAK_PLANK, amount);
                    break;
                case "Mahogany plank":
                    homeBuildingWidgetMaterialsUsed.put(ItemId.MAHOGANY_PLANK, amount);
                    break;
            }
        }
    }

    private Optional<Integer> getPlankIdBasedOnXpAndPlanks(final int xp, final int planks) {
        // Regular planks
        if (
            xp >= 20 && xp <= 23 && planks == 1 ||
            xp >= 120 && xp <= 133 && planks == 1 ||
            xp >= 44 && xp <= 48 && planks == 2 ||
            xp >= 67 && xp <= 70 && planks == 3 ||
            xp >= 88 && xp <= 92 && planks == 4
        ) {
            return Optional.of(ItemId.PLANK);

        // Oak planks
        } else if (
            xp >= 48 && xp <= 51 && planks == 1 ||
            xp >= 160 && xp <= 165 && planks == 1 ||
            xp >= 96 && xp <= 100 && planks == 2 ||
            xp >= 144 && xp <= 148 && planks == 3 ||
            xp >= 192 && xp <= 198 && planks == 4
        ) {
            return Optional.of(ItemId.OAK_PLANK);

        // Teak planks
        } else if (
            xp >= 71 && xp <= 75 && planks == 1 ||
            xp >= 190 && xp <= 195 && planks == 1 ||
            xp >= 144 && xp <= 149 && planks == 2 ||
            xp >= 216 && xp <= 222 && planks == 3 ||
            xp >= 216 && xp <= 297 && planks == 4
        ) {
            return Optional.of(ItemId.TEAK_PLANK);

        // Mahogany planks
        } else if (
            xp >= 112 && xp <= 115 && planks == 1 ||
            xp >= 240 && xp <= 247 && planks == 1 ||
            xp >= 224 && xp <= 230 && planks == 2 ||
            xp >= 336 && xp <= 345 && planks == 3 ||
            xp >= 448 && xp <= 460 && planks == 4
        ) {
            return Optional.of(ItemId.MAHOGANY_PLANK);
        }

        return Optional.empty();
    }

    private String getMenuOptionForUse() {
        return storage.isStorableItemInInventory()
            ? TicTac7xChargesImprovedPlugin.menuOptionFillFromInventory
            : TicTac7xChargesImprovedPlugin.menuOptionEmptyToInventory;
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.OnVarbitChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import java.util.Optional;

public class U_MasterScrollBook extends ChargedItemWithStorage {
    public U_MasterScrollBook(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.master_scroll_book, ItemId.MASTER_SCROLL_BOOK, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage = storage.setMaximumIndividualQuantity(1000).storableItems(
            new StorableItem(ItemId.TELEPORTSCROLL_NARDAH).displayName("Nardah").specificOrder(1),
            new StorableItem(ItemId.TELEPORTSCROLL_DIGSITE).displayName("Digsite").specificOrder(2),
            new StorableItem(ItemId.TELEPORTSCROLL_FELDIP_HILLS).displayName("Feldip Hills").specificOrder(3),
            new StorableItem(ItemId.TELEPORTSCROLL_LUNAR_ISLE).displayName("Lunar Isle").specificOrder(4),
            new StorableItem(ItemId.TELEPORTSCROLL_MORTTON).displayName("Mort'ton").specificOrder(5),
            new StorableItem(ItemId.TELEPORTSCROLL_PEST_CONTROL).displayName("Pest Control").specificOrder(6),
            new StorableItem(ItemId.TELEPORTSCROLL_PISCATORIS).displayName("Piscatoris").specificOrder(7),
            new StorableItem(ItemId.TELEPORTSCROLL_TAI_BWO_WANNAI).displayName("Tai Bwo Wannai").specificOrder(8),
            new StorableItem(ItemId.TELEPORTSCROLL_IORWERTH_CAMP).displayName("Iorwerth Camp").specificOrder(9),
            new StorableItem(ItemId.TELEPORTSCROLL_MOS_LEHARMLESS).displayName("Mos Le' Harmless").specificOrder(10),
            new StorableItem(ItemId.TELEPORTSCROLL_LUMBERYARD).displayName("Lumberyard").specificOrder(11),
            new StorableItem(ItemId.TELEPORTSCROLL_ZULANDRA).displayName("Zul-Andra").specificOrder(12),
            new StorableItem(ItemId.TELEPORTSCROLL_KEY_MASTER).displayName("Key Master").specificOrder(13),
            new StorableItem(ItemId.TELEPORTSCROLL_REVENANTS_CAVE).displayName("Revenant Caves").specificOrder(14),
            new StorableItem(ItemId.TELEPORTSCROLL_WATSON).displayName("Watson").specificOrder(15),
            new StorableItem(ItemId.TELEPORTSCROLL_GUTHIXIAN_TEMPLE).displayName("Guthixian Temple").specificOrder(16),
            new StorableItem(ItemId.TELEPORTSCROLL_SPIDER_CAVE).displayName("Spider Cave").specificOrder(17),
            new StorableItem(ItemId.TELEPORTSCROLL_COLOSSAL_WYRM).displayName("Colossal Wyrm").specificOrder(18)
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.MASTER_SCROLL_BOOK_UNCHARGED),
            new TriggerItem(ItemId.MASTER_SCROLL_BOOK),
        };

        this.triggers = new TriggerBase[]{
            new OnVarbitChanged(5672).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_NARDAH, charges)),
            new OnVarbitChanged(5673).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_DIGSITE, charges)),
            new OnVarbitChanged(5674).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_FELDIP_HILLS, charges)),
            new OnVarbitChanged(5675).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_LUNAR_ISLE, charges)),
            new OnVarbitChanged(5676).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_MORTTON, charges)),
            new OnVarbitChanged(5677).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_PEST_CONTROL, charges)),
            new OnVarbitChanged(5678).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_PISCATORIS, charges)),
            new OnVarbitChanged(5679).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_TAI_BWO_WANNAI, charges)),
            new OnVarbitChanged(5680).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_IORWERTH_CAMP, charges)),
            new OnVarbitChanged(5681).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_MOS_LEHARMLESS, charges)),
            new OnVarbitChanged(5682).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_LUMBERYARD, charges)),
            new OnVarbitChanged(5683).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_ZULANDRA, charges)),
            new OnVarbitChanged(5684).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_KEY_MASTER, charges)),
            new OnVarbitChanged(6056).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_REVENANTS_CAVE, charges)),
            new OnVarbitChanged(8253).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_WATSON, charges)),
            new OnVarbitChanged(10967).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_GUTHIXIAN_TEMPLE, charges)),
            new OnVarbitChanged(10995).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_SPIDER_CAVE, charges)),
            new OnVarbitChanged(11029).varbitValueConsumer(charges -> storage.put(ItemId.TELEPORTSCROLL_COLOSSAL_WYRM, charges)),

            // Replace default teleport option.
            new OnMenuEntryAdded("Teleport").replaceTargetDynamically("Master scroll book", this::getDefaultTeleportLocation),
        };
    }

    @Override
    public String getCharges(final int itemId) {
        final int varbit10966 = client.getVarbitValue(10966);
        final int varbit10968 = client.getVarbitValue(10968);

        // Default teleport not set, show all scrolls.
        if (varbit10966 == 0 && varbit10968 == 0) {
            return super.getCharges(itemId);
        }

        // Default teleport set, but no teleports.
        if (!storage.getStorage().hasItem(storage.getStorableItems()[varbit10968 * 15 + varbit10966 - 1].getId())) {
            return "0";
        }

        final Optional<StorageItem> storageItem = storage.getStorage().getItem(storage.getStorableItems()[varbit10968 * 15 + varbit10966 - 1].getId());

        if (!storageItem.isPresent()) {
            return "0";
        }

        return String.valueOf(storageItem.get().getQuantity());
    }

    @Override
    public String getTooltip() {
        final int varbit10966 = client.getVarbitValue(10966);
        final int varbit10968 = client.getVarbitValue(10968);

        // Default teleport not set, show all scrolls.
        if (varbit10966 == 0 && varbit10968 == 0) {
            return super.getTooltip();
        }

        final int teleportScrollIndex = varbit10968 * 15 + varbit10966 - 1;

        // Default teleport set, but no teleports.
        if (!storage.getStorage().hasItem(storage.getStorableItems()[teleportScrollIndex].getId())) {
            return super.getTooltip().replaceAll(getDefaultTeleportLocation() + ": <col=" + JagexColors.MENU_TARGET + ">.+?</col>", getDefaultTeleportLocation() + ": " + ColorUtil.wrapWithColorTag("0", config.getColorEmpty()));
        }

        final StorageItem defaultTeleportScrollStoreableItem = storage.getStorableItems()[teleportScrollIndex];
        final Optional<StorageItem> defaultTeleportScrollStorageItem = storage.getStorage().getItem(defaultTeleportScrollStoreableItem.getId());

        if (!defaultTeleportScrollStorageItem.isPresent()) {
            return "?";
        }

        return super.getTooltip().replaceAll(getDefaultTeleportLocation() + ": <col=ff9040>.+?</col>", getDefaultTeleportLocation() + ": <col=00ff00>" + defaultTeleportScrollStorageItem.get().getQuantity() + "</col>");
    }

    private String getDefaultTeleportLocation() {
        final int varbit10966 = client.getVarbitValue(10966);
        final int varbit10968 = client.getVarbitValue(10968);

        // Default teleport not set, show default.
        if (varbit10966 == 0 && varbit10968 == 0) {
            return itemManager.getItemComposition(itemId).getName();

        // Default teleport set, show correct location display name.
        } else {
            return storage.getStorableItems()[varbit10968 * 15 + varbit10966 - 1].displayName.get();
        }
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_EnchantedLyre extends ChargedItem {
    public W_EnchantedLyre(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.enchanted_lyre, ItemId.ENCHANTED_LYRE_0, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.ENCHANTED_LYRE_0).fixedCharges(0),
            new TriggerItem(ItemId.ENCHANTED_LYRE_1).fixedCharges(1),
            new TriggerItem(ItemId.ENCHANTED_LYRE_2).fixedCharges(2),
            new TriggerItem(ItemId.ENCHANTED_LYRE_3).fixedCharges(3),
            new TriggerItem(ItemId.ENCHANTED_LYRE_4).fixedCharges(4),
            new TriggerItem(ItemId.ENCHANTED_LYRE_5).fixedCharges(5),
            new TriggerItem(ItemId.ENCHANTED_LYRE_IMBUED).fixedCharges(Charges.UNLIMITED),
        };

        this.triggers = new TriggerBase[]{
            new OnMenuEntryAdded("Play").replaceOption("Teleport"),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_BryophytasStaff extends ChargedItem {
    public W_BryophytasStaff(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.bryophytas_staff, ItemId.BRYOPHYTAS_STAFF, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BRYOPHYTAS_STAFF_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.BRYOPHYTAS_STAFF)
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("The nature staff has (?<charges>.+) charges?.").setDynamicallyCharges(),

            // Save a nature rune.
            new OnChatMessage("Your staff saved you a nature rune.").increaseCharges(1),

            // Charge.
            new OnChatMessage("Your Bryophyta's staff now has (?<charges>.+) charges?.").setDynamicallyCharges(),

            // Auto-charge.
            new OnChatMessage("The banker charges your Bryophyta's staff using (?<naturerune>.+)x Nature rune.").matcherConsumer(m -> {
                final int natureRunes = Integer.parseInt(m.group("naturerune"));
                increaseCharges(natureRunes);
            }),

            // Regular spellbook.
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Bones to Bananas",
                "Low Level Alchemy",
                "Superheat Item",
                "High Level Alchemy"
            ).decreaseCharges(1),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Make sets").onMenuTarget(
                "Emerald bolts (e)"
            ).decreaseCharges(1),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Bind",
                "Bones to Peaches"
            ).decreaseCharges(2),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Snare"
            ).decreaseCharges(3),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Entangle"
            ).decreaseCharges(4),


            // Arcuus spellbook.
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Dark Lure",
                "Harmony Island Teleport"
            ).decreaseCharges(1),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Degrime",
                "Ward of Arceuus"
            ).decreaseCharges(2),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Reanimate").onMenuTarget(
                "Basic Reanimation"
            ).decreaseCharges(2),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Reanimate").onMenuTarget(
                "Adept Reanimation",
                "Expert Reanimation"
            ).decreaseCharges(3),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Reanimate").onMenuTarget(
                "Master Reanimation"
            ).decreaseCharges(4),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Resurrect").onMenuTarget(
                "Resurrect Crops"
            ).decreaseCharges(12),

            // Lunar spellbook.
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Tan Leather",
                "Plank Make",
                "Energy Transfer"
            ).decreaseCharges(1),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Spin Flax",
                "Fertile Soil"
            ).decreaseCharges(2),
            new OnXpDrop(Skill.MAGIC).isEquipped().onMenuOption("Cast").onMenuTarget(
                "Geomancy"
            ).decreaseCharges(3),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_StrangeOldLockpick extends ChargedItem {
    public U_StrangeOldLockpick(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.strange_old_lockpick, ItemId.STRANGE_OLD_LOCKPICK, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.STRANGE_OLD_LOCKPICK).fixedCharges(50),
            new TriggerItem(ItemId.STRANGE_OLD_LOCKPICK_DEGRADED),
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("Your Strange old lockpick( now)? has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),
            new OnChatMessage("The Strange old lockpick crumbles to dust as you use it one last time.").notification("Your strange old lockpick crumbles to dust."),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_TumekensShadow extends ChargedItem {
    public W_TumekensShadow(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.tumekens_shadow, ItemId.TUMEKENS_SHADOW, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TUMEKENS_SHADOW_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.TUMEKENS_SHADOW),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Tumeken's shadow( only)? has (?<charges>.+) charges? (remaining|left)").setDynamicallyCharges(),

            // Uncharge.
            new OnChatMessage("You uncharge your Tumeken's shadow").setFixedCharges(0),

            // Charge.
            new OnChatMessage("You apply (?<charges>.+) to your Tumeken's shadow.").setDynamicallyCharges(),

            // Charge additionally.
            new OnChatMessage("You apply an additional .* charges to your Tumeken's shadow. It now has (?<charges>.+) charges in total.").setDynamicallyCharges(),

            // Attack.
            new OnGraphicChanged(2125).decreaseCharges(1),

            // Auto-charge.
            new OnChatMessage("The banker charges your Tumeken's shadow using (?<soulrune>.+)x Soul rune").matcherConsumer(m -> {
                final int soulRunes = Integer.parseInt(m.group("soulrune"));
                increaseCharges(soulRunes / 2);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_TridentOfTheSeasE extends ChargedItem {
    public W_TridentOfTheSeasE(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.trident_of_the_seas_e, ItemId.TRIDENT_OF_THE_SEAS_ENCHANTED, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TRIDENT_OF_THE_SEAS_ENCHANTED_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.TRIDENT_OF_THE_SEAS_ENCHANTED),
        };

        this.triggers = new TriggerBase[] {
            // Ran out of charges.
            new OnChatMessage("Your Trident of the seas \\(e\\) has run out of charges.").notification().setFixedCharges(0),

            // Check, one charge left.
            new OnChatMessage("Your Trident of the seas \\(e\\) has one charge.").setFixedCharges(1),

            // Check for charges and warning when low.
            new OnChatMessage("Your Trident of the seas \\(e\\)( only)? has (?<charges>.+) charges( left)?.").setDynamicallyCharges(),

            // Charge to full.
            new OnChatMessage("You add .* charges? to the Trident of the seas \\(e\\). New total: (?<charges>.+)").setDynamicallyCharges(),

            // Attack.
            new OnGraphicChanged(1251).isEquipped().decreaseCharges(1),

            // Auto-charge.
            new OnChatMessage("The banker charges your Trident of the seas (e) using (?<deathrune>.+)x Death rune.*").matcherConsumer(m -> {
                final int deathRunes = Integer.parseInt(m.group("deathrune"));
                increaseCharges(deathRunes);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class C_ArdougneCloak extends ChargedItem {
    public C_ArdougneCloak(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ardougne_cloak, ItemId.ARDOUGNE_CLOAK_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.ARDOUGNE_CLOAK_1).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemId.ARDOUGNE_CLOAK_2),
            new TriggerItem(ItemId.ARDOUGNE_CLOAK_3),
            new TriggerItem(ItemId.ARDOUGNE_CLOAK_4).fixedCharges(Charges.UNLIMITED),
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("You have used (?<used>.+) of your (?<total>.+) Ardougne Farm teleports for today.").setDifferenceCharges(),
            new OnResetDaily().specificItem(ItemId.ARDOUGNE_CLOAK_2).setFixedCharges(3),
            new OnResetDaily().specificItem(ItemId.ARDOUGNE_CLOAK_3).setFixedCharges(5),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class H_CircletOfWater extends ChargedItem {
    public H_CircletOfWater(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.circlet_of_water, ItemId.CIRCLET_OF_WATER, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.CIRCLET_OF_WATER_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.CIRCLET_OF_WATER).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Protect from heat.
            new OnChatMessage("Your circlet protects you from the desert heat.").decreaseCharges(1),

            // Check.
            new OnChatMessage("Your circlet has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Charge while empty.
            new OnChatMessage("You add (?<charges>.+) charges? to your circlet.$").setDynamicallyCharges(),

            // Charge while not empty.
            new OnChatMessage("You add .+ charges? to your circlet. It now has (?<charges>.+) charges?.").setDynamicallyCharges(),

            // Auto-charge.
            new OnChatMessage("The banker charges your Circlet of water using (?<waterrune>.+)x Water rune.").matcherConsumer(m -> {
                final int waterRunes = Integer.parseInt(m.group("waterrune"));
                increaseCharges(waterRunes / 5);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.AnimationId;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnAnimationChanged;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_CrystalBow extends ChargedItem {
    public W_CrystalBow(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.crystal_bow, ItemId.CRYSTAL_BOW, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.CRYSTAL_BOW_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_BOW),
            new TriggerItem(ItemId.CRYSTAL_BOW_FULL).fixedCharges(2500),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your crystal bow has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Attack.
            new OnAnimationChanged(AnimationId.HUMAN_BOW).isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.WidgetId;

import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_FishBarrel extends ChargedItemWithStorage {
    private Optional<StorageItem> lastCaughtFish = Optional.empty();

    public U_FishBarrel(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.fish_barrel, ItemId.FISH_BARREL, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.FISH_BARREL),
            new TriggerItem(ItemId.FISH_BARREL_OPEN),
            new TriggerItem(ItemId.FISH_SACK_BARREL),
            new TriggerItem(ItemId.FISH_SACK_BARREL_OPEN),
        };

        storage = storage.setMaximumTotalQuantity(28).storableItems(
            // Small net
            new StorableItem(ItemId.RAW_SHRIMPS).checkName("Shrimp"),
            new StorableItem(ItemId.RAW_ANCHOVIES).checkName("Anchovies"),
            new StorableItem(ItemId.RAW_MONKFISH).checkName("Monkfish"),

            // Big net
            new StorableItem(ItemId.RAW_MACKEREL).checkName("Mackerel"),
            new StorableItem(ItemId.RAW_COD).checkName("Cod"),
            new StorableItem(ItemId.RAW_BASS).checkName("Bass"),

            // Rod
            new StorableItem(ItemId.RAW_SARDINE).checkName("Sardine"),
            new StorableItem(ItemId.RAW_HERRING).checkName("Herring"),
            new StorableItem(ItemId.RAW_TROUT).checkName("Trout"),
            new StorableItem(ItemId.RAW_PIKE).checkName("Pike"),
            new StorableItem(ItemId.RAW_SLIMY_EEL).checkName("Slimy swamp eel", "Slimy eel"),
            new StorableItem(ItemId.RAW_SALMON).checkName("Salmon"),
            new StorableItem(ItemId.RAW_RAINBOW_FISH).checkName("Rainbow fish"),
            new StorableItem(ItemId.RAW_CAVE_EEL).checkName("Cave eel"),
            new StorableItem(ItemId.RAW_LAVA_EEL).checkName("Lava eel"),
            new StorableItem(ItemId.INFERNAL_EEL).checkName("Infernal eel"),
            new StorableItem(ItemId.RAW_ANGLERFISH).checkName("Anglerfish"),
            new StorableItem(ItemId.SACRED_EEL).checkName("Sacred eel"),

            // Harpoon
            new StorableItem(ItemId.RAW_TUNA).checkName("Tuna"),
            new StorableItem(ItemId.RAW_SWORDFISH).checkName("Swordfish"),
            new StorableItem(ItemId.RAW_SHARK).checkName("Shark"),

            // Aerial
            new StorableItem(ItemId.BLUEGILL).checkName("Bluegill"),
            new StorableItem(ItemId.COMMON_TENCH).checkName("Common tench"),
            new StorableItem(ItemId.MOTTLED_EEL).checkName("Mottled eel"),
            new StorableItem(ItemId.GREATER_SIREN).checkName("Greater siren"),

            // Cage
            new StorableItem(ItemId.RAW_LOBSTER).checkName("Lobster"),
            new StorableItem(ItemId.RAW_DARK_CRAB).checkName("Dark crab"),

            // Barbarian
            new StorableItem(ItemId.LEAPING_TROUT).checkName("Leaping trout"),
            new StorableItem(ItemId.LEAPING_SALMON).checkName("Leaping salmon"),
            new StorableItem(ItemId.LEAPING_STURGEON).checkName("Leaping sturgeon"),

            // Other
            new StorableItem(ItemId.RAW_KARAMBWAN).checkName("Karambwan"),
            new StorableItem(ItemId.RAW_SEA_TURTLE).checkName("Sea turtle"),
            new StorableItem(ItemId.RAW_MANTA_RAY).checkName("Manta ray")
        );

        this.triggers = new TriggerBase[]{
            // Check or empty already empty.
            new OnChatMessage("(Your|The) barrel is empty.").onItemClick().emptyStorage(),

            // Catch fish.
            new OnChatMessage("You catch (a|an|some) (?<fish>.+).").matcherConsumer(m -> {
                lastCaughtFish = getStorageItemFromName(m.group("fish"), 1);
                storage.add(lastCaughtFish);
            }).requiredItem(ItemId.FISH_BARREL_OPEN, ItemId.FISH_SACK_BARREL_OPEN),

            // Extra fish.
            new OnChatMessage(".* enabled you to catch an extra fish.").requiredItem(ItemId.FISH_BARREL_OPEN, ItemId.FISH_SACK_BARREL_OPEN).consumer(() -> {
                storage.add(lastCaughtFish);
            }),

            // Replace "Empty" with proper "Empty to bank".
            new OnMenuEntryAdded("Empty").replaceOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Check.
            new OnChatMessage("The barrel contains:").stringConsumer(s -> {
                storage.clear();

                final Pattern pattern = Pattern.compile("(?<quantity>\\d+).x.(?<fish>.*?)(,|$)");
                final Matcher matcher = pattern.matcher(s);

                while (matcher.find()) {
                    storage.put(getStorageItemFromName(matcher.group("fish"), Integer.parseInt(matcher.group("quantity"))));
                }
            }).onItemClick(),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Use fish on barrel.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Empty to deposit box.
            new OnChatMessage("You empty the barrel.").onMenuOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank).emptyStorage(),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_SkullSceptre extends ChargedItem {
    public W_SkullSceptre(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.skull_sceptre, ItemId.SKULL_SCEPTRE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.SKULL_SCEPTRE),
            new TriggerItem(ItemId.SKULL_SCEPTRE_IMBUED)
        };

        this.triggers = new TriggerBase[] {
            // Teleport.
            new OnChatMessage("Your Skull Sceptre has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Check.
            new OnChatMessage("Concentrating deeply, you divine that the sceptre has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Charge to maximum.
            new OnChatMessage("You charge the Skull Sceptre with .*. It now contains the maximum number of charges, (?<charges>.+).").setDynamicallyCharges(),

            // Charge.
            new OnChatMessage("You charge the Skull Sceptre with .*. It now contains (?<charges>.+) charges?.").setDynamicallyCharges(),

            // Unified menu entry.
            new OnMenuEntryAdded("Divine").replaceOption("Check"),
            new OnMenuEntryAdded("Invoke").replaceOption("Teleport"),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_BurningAmulet extends ChargedItem {
    public J_BurningAmulet(
            final Client client,
            final ClientThread clientThread,
            final ConfigManager configManager,
            final ItemManager itemManager,
            final InfoBoxManager infoBoxManager,
            final ChatMessageManager chatMessageManager,
            final Notifier notifier,
            final TicTac7xChargesImprovedConfig config,
            final Store store,
            final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.burning_amulet, ItemId.BURNING_AMULET_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BURNING_AMULET_1).fixedCharges(1),
            new TriggerItem(ItemId.BURNING_AMULET_2).fixedCharges(2),
            new TriggerItem(ItemId.BURNING_AMULET_3).fixedCharges(3),
            new TriggerItem(ItemId.BURNING_AMULET_4).fixedCharges(4),
            new TriggerItem(ItemId.BURNING_AMULET_5).fixedCharges(5),
        };

        this.triggers = new TriggerBase[]{
            new OnMenuEntryAdded("Rub").replaceOption("Teleport"),
        };
    }
}
package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_RingOfPursuit extends ChargedItem {
    public J_RingOfPursuit(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_pursuit, ItemId.RING_OF_PURSUIT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.RING_OF_PURSUIT).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Your ring of pursuit has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Use.
            new OnChatMessage("Your ring of pursuit reveals the entire trail to you. It has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Use last charge.
            new OnChatMessage("Your ring of pursuit reveals the entire trail to you. It then crumbles to dust.").notification().setFixedCharges(10),

            // Destroy.
            new OnChatMessage("The ring shatters. Your next ring of pursuit will start afresh from 10 charges.").setFixedCharges(10),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.storage.StorageItems;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.WidgetId;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import static tictac7x.charges.TicTac7xChargesImprovedPlugin.getNumberFromWordRepresentation;
import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_ReagentPouch extends ChargedItemWithStorage {
    public U_ReagentPouch(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.reagent_pouch, ItemId.REAGENT_POUCH, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage.emptyIsNegative().setMaximumIndividualQuantity(26).storableItems(
            new StorableItem(ItemId.EYE_OF_NEWT).checkName("Eye of newt"),
            new StorableItem(ItemId.LIMPWURT_ROOT).checkName("Limpwurt root"),
            new StorableItem(ItemId.RED_SPIDERS_EGGS).checkName("Red spider's eggs", "eggs"),
            new StorableItem(ItemId.TOADS_LEGS).checkName("Toad's legs", "toad legs"),
            new StorableItem(ItemId.SNAPE_GRASS).checkName("Snape grass"),
            new StorableItem(ItemId.MORT_MYRE_FUNGUS).checkName("Mort myre fungus", "Mort Myre fungi"),
            new StorableItem(ItemId.WHITE_BERRIES).checkName("White berries"),
            new StorableItem(ItemId.JANGERBERRIES).checkName("Jangerberries"),
            new StorableItem(ItemId.POISON_IVY_BERRIES).checkName("Poison ivy berries"),
            new StorableItem(ItemId.POTATO_CACTUS).checkName("Potato cactus"),
            new StorableItem(ItemId.CACTUS_SPINE).checkName("Cactus spine"),
            new StorableItem(ItemId.ASHES).checkName("Ashes"),
            new StorableItem(ItemId.CHOCOLATE_DUST).checkName("Chocolate dust"),
            new StorableItem(ItemId.DRAGON_SCALE_DUST).checkName("Dragon scale dust", "dragon scale"),
            new StorableItem(ItemId.GOAT_HORN_DUST).checkName("Goat horn dust", "ground desert goat horn"),
            new StorableItem(ItemId.GORAK_CLAW_POWDER).checkName("Gorak claw powder"),
            new StorableItem(ItemId.KEBBIT_TEETH_DUST).checkName("Kebbit teeth dust", "ground kebbit teeth"),
            new StorableItem(ItemId.SILVER_DUST).checkName("Silver dust"),
            new StorableItem(ItemId.UNICORN_HORN_DUST).checkName("Unicorn horn dust", "unicorn horn"),
            new StorableItem(ItemId.WINE_OF_ZAMORAK).checkName("Wine of zamorak", "wine"),
            new StorableItem(ItemId.ALDARIUM).checkName("Aldarium"),
            new StorableItem(ItemId.YEW_ROOTS).checkName("Yew roots"),
            new StorableItem(ItemId.MAGIC_ROOTS).checkName("Magic roots"),
            new StorableItem(ItemId.CRUSHED_NEST).checkName("Crushed nest", "crushed bird nest"),
            new StorableItem(ItemId.CRUSHED_SUPERIOR_DRAGON_BONES).checkName("Crushed superior dragon bones"),
            new StorableItem(ItemId.NAIL_BEAST_NAILS).checkName("Nail beast nails"),
            new StorableItem(ItemId.LILY_OF_THE_SANDS).checkName("Lily of the sands"),
            new StorableItem(ItemId.CAVIAR).checkName("Caviar"),
            new StorableItem(ItemId.ROE).checkName("Roe")
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.REAGENT_POUCH),
            new TriggerItem(ItemId.REAGENT_POUCH_OPEN),
        };

        this.triggers = new TriggerBase[] {
            // Check empty.
            new OnChatMessage("The Reagent pouch is empty.").emptyStorage(),

            // Check.
            new OnChatMessage("You look in your Reagent pouch and see:").emptyStorage(),
            new OnChatMessage("(?<amount>.+) x (?<item>.+)").matcherConsumer(m -> {
                final Optional<StorageItem> item = getStorageItemFromName(m.group("item"), Integer.parseInt(m.group("amount")));
                storage.put(item);
            }).hasChatMessage("You look in your Reagent pouch and see:"),

            // Pick up.
            new OnChatMessage("You put the (?<item>.+) into your Reagent pouch.").matcherConsumer(m -> {
                final Optional<StorageItem> item = getStorageItemFromName(m.group("item"), 1);
                storage.add(item);
            }),

            // Empty to bank.
            new OnChatMessage("You empty your pouch into the bank").onItemClick().emptyStorage(),

            // Empty to inventory.
            new OnItemContainerChanged(INVENTORY).emptyStorageToInventory().onMenuOption("Empty"),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).onInventoryDifference(inventoryDifference -> {
                for (final StorageItem inventoryDifferenceItem : inventoryDifference.getItems()) {
                    // Item was put into the reagent pouch, but there is more in inventory, meaning that item is filled to maximum.
                    if (store.inventory.hasItem(inventoryDifferenceItem.getId())) {
                        storage.put(inventoryDifferenceItem.getId(), 26);
                    }
                }
            }).onMenuOption("Fill", TicTac7xChargesImprovedPlugin.menuOptionFillFromInventory),

            new OnMenuOptionClicked("Fill", TicTac7xChargesImprovedPlugin.menuOptionFillFromInventory).consumer(() -> {
                for (final StorageItem item : store.inventory.getItems()) {
                    storage.add(item);
                }
            }),

            // Replace "Use" with proper Fill/Empty option.
            new OnMenuEntryAdded("Use").replaceOptionConsumer(this::getMenuOptionForUse).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Mix potions.
            new OnChatMessage("You mix the (?<item>.+) into (your|the unfinished)( antifire)? (potion|antidote\\+\\+).*").matcherConsumer((m) -> {
                final Optional<StorageItem> item = getStorageItemFromName(m.group("item"), 1);
                storage.remove(item);
            }).requiredItem(ItemId.REAGENT_POUCH_OPEN),

            // Pick whiteberries
            new OnChatMessage("You pick some whiteberries").requiredItem(ItemId.REAGENT_POUCH_OPEN).consumer(() -> {
                storage.add(ItemId.WHITE_BERRIES, 1);
            }),
            // Harvest snape grass
            new OnXpDrop(Skill.FARMING).onMenuOption("Harvest").onMenuTarget("Snape grass plant").addToStorage(ItemId.SNAPE_GRASS, 1),
            // Pick mort myre fungus
            new OnChatMessage("You pick (?<quantity>.+) mushrooms? from the log.").matcherConsumer(m -> {
                storage.add(ItemId.MORT_MYRE_FUNGUS, getNumberFromWordRepresentation(m.group("quantity")));
            }),
        };
    }

    private String getMenuOptionForUse() {
        return storage.isStorableItemInInventory()
            ? TicTac7xChargesImprovedPlugin.menuOptionFillFromInventory
            : TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank;
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class H_KandarinHeadgear extends ChargedItem {
    public H_KandarinHeadgear(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.kandarin_headgear, ItemId.KANDARIN_HEADGEAR_3, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.KANDARIN_HEADGEAR_3),
            new TriggerItem(ItemId.KANDARIN_HEADGEAR_4).fixedCharges(Charges.UNLIMITED),
        };

        this.triggers = new TriggerBase[] {
            // Try to teleport while empty.
            new OnChatMessage("You have already used your available teleports for today. Your headgear will recharge tomorrow.").onItemClick().setFixedCharges(0),

            // Teleport.
            new OnGraphicChanged(111).onItemClick().decreaseCharges(1),

            // Daily reset.
            new OnResetDaily().specificItem(ItemId.KANDARIN_HEADGEAR_3).setFixedCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_FungicideSpray extends ChargedItem {
    public U_FungicideSpray(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.fungicide_spray, ItemId.FUNGICIDE_SPRAY_0, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.FUNGICIDE_SPRAY_0).fixedCharges(0),
            new TriggerItem(ItemId.FUNGICIDE_SPRAY_1).fixedCharges(1),
            new TriggerItem(ItemId.FUNGICIDE_SPRAY_2).fixedCharges(2),
            new TriggerItem(ItemId.FUNGICIDE_SPRAY_3).fixedCharges(3),
            new TriggerItem(ItemId.FUNGICIDE_SPRAY_4).fixedCharges(4),
            new TriggerItem(ItemId.FUNGICIDE_SPRAY_5).fixedCharges(5),
            new TriggerItem(ItemId.FUNGICIDE_SPRAY_6).fixedCharges(6),
            new TriggerItem(ItemId.FUNGICIDE_SPRAY_7).fixedCharges(7),
            new TriggerItem(ItemId.FUNGICIDE_SPRAY_8).fixedCharges(8),
            new TriggerItem(ItemId.FUNGICIDE_SPRAY_9).fixedCharges(9),
            new TriggerItem(ItemId.FUNGICIDE_SPRAY_10).fixedCharges(10),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class S_DragonfireShield extends ChargedItem {
    public S_DragonfireShield(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.dragonfire_shield, ItemId.DRAGONFIRE_SHIELD, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.DRAGONFIRE_SHIELD_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.DRAGONFIRE_SHIELD),
            new TriggerItem(ItemId.DRAGONFIRE_WARD_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.DRAGONFIRE_WARD)
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("The shield has (?<charges>.+) charges?.").setDynamicallyCharges().onItemClick(),

            // Uncharge.
            new OnChatMessage("You vent the shield's remaining charges harmlessly into the air.").setFixedCharges(0),

            // Charge collected.
            new OnChatMessage("Your dragonfire (shield|ward) glows more brightly.").increaseCharges(1),

            // Already full.
            new OnChatMessage("Your dragonfire shield is already fully charged.").setFixedCharges(50),

            // Attack.
            new OnGraphicChanged(1165).isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class J_DigsitePendant extends ChargedItem {
    public J_DigsitePendant(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.digsite_pendant, ItemId.DIGSITE_PENDANT_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.DIGSITE_PENDANT_1).fixedCharges(1),
            new TriggerItem(ItemId.DIGSITE_PENDANT_2).fixedCharges(2),
            new TriggerItem(ItemId.DIGSITE_PENDANT_3).fixedCharges(3),
            new TriggerItem(ItemId.DIGSITE_PENDANT_4).fixedCharges(4),
            new TriggerItem(ItemId.DIGSITE_PENDANT_5).fixedCharges(5),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import static tictac7x.charges.store.HitsplatTarget.ENEMY;

public class W_Arclight extends ChargedItem {
    public W_Arclight(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.arclight, ItemId.ARCLIGHT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.ARCLIGHT),
            new TriggerItem(ItemId.ARCLIGHT_UNCHARGED).fixedCharges(0),
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("Your arclight has (?<charges>.+) charges?( left)?.").setDynamicallyCharges(),
            new OnChatMessage("Your arclight can perform (?<charges>.+) more attacks.").setDynamicallyCharges(),
            new OnChatMessage("Your arclight has degraded.").notification().setFixedCharges(0),
            new OnHitsplatApplied(ENEMY).isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class F_MoonlightMothMix extends ChargedItem {
    public F_MoonlightMothMix(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.moonlight_moth_mix, ItemId.MOONLIGHT_MOTH_MIX_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.MOONLIGHT_MOTH_MIX_1).fixedCharges(1),
            new TriggerItem(ItemId.MOONLIGHT_MOTH_MIX_2).fixedCharges(2),
        };
    }

    @Override
    public String getTooltip() {
        return "Moonlight moth mix: " + getTotalCharges();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import static tictac7x.charges.store.HitsplatTarget.ENEMY;

public class W_CrystalHalberd extends ChargedItem {
    public W_CrystalHalberd(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.crystal_halberd, ItemId.CRYSTAL_HALBERD, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.CRYSTAL_HALBERD_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_HALBERD),
            new TriggerItem(ItemId.CRYSTAL_HALBERD_FULL).fixedCharges(2500),
        };
        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Your crystal halberd has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Attack.
            new OnHitsplatApplied(ENEMY).oncePerGameTick().isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class U_EternalTeleportCrystal extends ChargedItem {
    public U_EternalTeleportCrystal(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.eternal_teleport_crystal, ItemId.ETERNAL_TELEPORT_CRYSTAL, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.ETERNAL_TELEPORT_CRYSTAL).fixedCharges(Charges.UNLIMITED),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;

import java.util.Optional;

import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class C_ForestryKit extends ChargedItemWithStorage {
    public C_ForestryKit(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.forestry_kit, ItemId.FORESTRY_KIT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.storage = storage.storableItems(
            new StorableItem(ItemId.ANIMAINFUSED_BARK).specificOrder(1),
            new StorableItem(ItemId.FORESTERS_RATION).specificOrder(2),
            new StorableItem(ItemId.NATURE_OFFERINGS).specificOrder(3),
            new StorableItem(ItemId.SECATEURS_ATTACHMENT).specificOrder(4),
            new StorableItem(ItemId.LEAVES).displayName("Regular leaves").checkName("regular").specificOrder(5),
            new StorableItem(ItemId.OAK_LEAVES).checkName("oak").specificOrder(6),
            new StorableItem(ItemId.WILLOW_LEAVES).checkName("willow").specificOrder(7),
            new StorableItem(ItemId.MAPLE_LEAVES).checkName("maple").specificOrder(8),
            new StorableItem(ItemId.YEW_LEAVES).checkName("yew").specificOrder(9),
            new StorableItem(ItemId.MAGIC_LEAVES).checkName("magic").specificOrder(10),
            new StorableItem(ItemId.FORESTRY_HAT).specificOrder(11),
            new StorableItem(ItemId.FORESTRY_TOP).specificOrder(12),
            new StorableItem(ItemId.FORESTRY_LEGS).specificOrder(13),
            new StorableItem(ItemId.FORESTRY_BOOTS).specificOrder(14),
            new StorableItem(ItemId.LUMBERJACK_HAT).specificOrder(15),
            new StorableItem(ItemId.LUMBERJACK_TOP).specificOrder(16),
            new StorableItem(ItemId.LUMBERJACK_LEGS).specificOrder(17),
            new StorableItem(ItemId.LUMBERJACK_BOOTS).specificOrder(18),
            new StorableItem(ItemId.WOODCUTTING_CAPE).specificOrder(19),
            new StorableItem(ItemId.WOODCUTTING_CAPE_TRIMMED).specificOrder(20)
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.FORESTRY_KIT),
        };

        this.triggers = new TriggerBase[]{
            // View contents.
            new OnItemContainerChanged(ItemContainerId.FORESTRY_KIT).updateStorage(),

            // Get leaves while chopping wood.
            new OnChatMessage("Some (?<leaves>.+) leaves fall to the ground and you place them into your Forestry kit.").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("leaves"), 1));
            }),

            // Get leaves from event.
            new OnChatMessage("You've been awarded (?<amount>.+) piles of (?<leaves>.+) leaves which you put into your Forestry kit.").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("leaves"), Integer.parseInt(m.group("amount"))));
            }),

            // Get bark from an event.
            new OnChatMessage("You've been awarded (?<bark>.+) Anima-infused bark.").matcherConsumer(m -> {
                storage.add(ItemId.ANIMAINFUSED_BARK, Integer.parseInt(m.group("bark")));
            }),

            // Use ration when choping.
            new OnChatMessage("You consume a Forester's ration to fuel a mighty chop.").consumer(() -> {
                storage.removeAndPrioritizeInventory(ItemId.FORESTERS_RATION, 1);
            }),

            // Nature offering used.
            new OnChatMessage("The nature offerings enabled you to chop an extra log").consumer(() -> {
                storage.removeAndPrioritizeInventory(ItemId.NATURE_OFFERINGS, 1);
            }),

            // Out of rations.
            new OnChatMessage("You've eaten your last Forester's ration.").consumer(() -> {
                storage.put(ItemId.FORESTERS_RATION, 0);
            }),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onItemClick().onMenuOption("Fill"),

            // Buy items from Friendly Forester by 1.
            new OnMenuOptionClicked("Buy-1").consumer(() -> {
                purchaseFromFriendlyForesterShop(1);
            }),

            // Buy items from Friendly Forester by 5.
            new OnMenuOptionClicked("Buy-5").consumer(() -> {
                purchaseFromFriendlyForesterShop(5);
            }),

            // Buy items from Friendly Forester by 10.
            new OnMenuOptionClicked("Buy-10").consumer(() -> {
                purchaseFromFriendlyForesterShop(10);
            }),

            // Buy items from Friendly Forester by 50.
            new OnMenuOptionClicked("Buy-50").consumer(() -> {
                purchaseFromFriendlyForesterShop(50);
            }),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }

    private void purchaseFromFriendlyForesterShop(final int amountToBuy) {
        final Optional<Widget> forestryShopWidget = TicTac7xChargesImprovedPlugin.getWidget(client, 819, 3);
        if (!forestryShopWidget.isPresent()) return;

        int animaBarkPerItem = 0;
        final int selectedShopItem = client.getVarpValue(3869);
        switch (selectedShopItem) {
            case 0: // Forestry kit
                break;
            case 1: // Secateurs blade
                animaBarkPerItem = 20;
                break;
            case 2: // Ritual mulch
                animaBarkPerItem = 150;
                break;
            case 6: // Log brace
                animaBarkPerItem = 3_000;
                break;
            case 7: // Clothes pouch blueprint
                animaBarkPerItem = 10_000;
                break;
            case 8: // Cape pouch
                animaBarkPerItem = 2_500;
                break;
            case 9: // Log basket
                animaBarkPerItem = 5_000;
                break;
            case 10: // Felling axe handle
                animaBarkPerItem = 10_000;
                break;
            case 11: // Twitcher's gloves
                animaBarkPerItem = 5_000;
                break;
            case 12: // Funky shaped log
                animaBarkPerItem = 15_000;
                break;
            case 13: // Sawmill voucher (x10)
                animaBarkPerItem = 150;
                break;
            case 14: // Lumberjack boots
                animaBarkPerItem = 1_000;
                break;
            case 15: // Lumberjack hat
                animaBarkPerItem = 1_200;
                break;
            case 16: // Lumberjack legs
                animaBarkPerItem = 1_300;
                break;
            case 17: // Lumberjack top
                animaBarkPerItem = 1_500;
                break;
            case 18: // Forestry boots
            case 19: // Forestry hat
            case 20: // Forestry legs
            case 21: // Forestry top
                animaBarkPerItem = 1_250;
                break;
        }

        storage.removeAndPrioritizeInventory(ItemId.ANIMAINFUSED_BARK, animaBarkPerItem * amountToBuy);
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_TridentOfTheSwamp extends ChargedItem {
    public W_TridentOfTheSwamp(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.trident_of_the_swamp, ItemId.TRIDENT_OF_THE_SWAMP, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TRIDENT_OF_THE_SWAMP_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.TRIDENT_OF_THE_SWAMP),
        };

        this.triggers = new TriggerBase[] {
            // Ran out of charges.
            new OnChatMessage("Your Trident of the swamp has run out of charges.").notification().setFixedCharges(0),

            // Check, one charge left.
            new OnChatMessage("Your Trident of the swamp has one charge.").setFixedCharges(1),

            // Check for charges and warning when low.
            new OnChatMessage("Your Trident of the swamp( only)? has (?<charges>.+) charges( left)?.").setDynamicallyCharges(),

            // Charge to full.
            new OnChatMessage("You add .* charges? to the Trident of the swamp. New total: (?<charges>.+)").setDynamicallyCharges(),

            // Attack.
            new OnGraphicChanged(1251).isEquipped().decreaseCharges(1),

            // Auto-charge.
            new OnChatMessage("The banker charges your Trident of the swamp using (?<deathrune>.+)x Death rune.*").matcherConsumer(m -> {
                final int deathRunes = Integer.parseInt(m.group("deathrune"));
                increaseCharges(deathRunes);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class S_KharedstMemoirs extends ChargedItem {
    public S_KharedstMemoirs(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.kharedsts_memoirs, ItemId.KHAREDSTS_MEMOIRS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.KHAREDSTS_MEMOIRS),
            new TriggerItem(ItemId.BOOK_OF_THE_DEAD)
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("You add an entry to Kharedst's Memoirs.").increaseCharges(20),

            // Teleport.
            new OnChatMessage("((Kharedst's Memoirs)|(The Book of the Dead)) now has (?<charges>.+) (memories|memory) remaining.").setDynamicallyCharges(),

            // Check empty.
            new OnChatMessage("((Kharedst's Memoirs)|(The Book of the Dead)) holds no charges.").setFixedCharges(0),

            // Check.
            new OnChatMessage("On the inside of the cover a message is displayed in dark ink. It reads: (?<charges>.+)/.+? (memories|memory) remain.").setDynamicallyCharges(),

            // Charge.
            new OnChatMessage("((Kharedst's Memoirs)|(The Book of the Dead)) now has (?<charges>.+) charges.").setDynamicallyCharges(),

            // Try to charge book of the dead when already full.
            new OnChatMessage("The Book of the Dead is already fully charged.").setFixedCharges(250),

            // Try to charge kharedst memoirs when already full.
            new OnChatMessage("Kharedst's Memoirs is already fully charged.").setFixedCharges(100),

            // Common menu entries.
            new OnMenuEntryAdded("Reminisce").replaceOption("Teleport"),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class J_AlchemistsAmulet extends ChargedItem {
    public J_AlchemistsAmulet(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.alchemists_amulet, ItemId.ALCHEMISTS_AMULET, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.ALCHEMISTS_AMULET).needsToBeEquipped(),
            new TriggerItem(ItemId.ALCHEMISTS_AMULET_UNCHARGED).fixedCharges(0),
        };

        this.triggers = new TriggerBase[] {
            // Check
            new OnChatMessage("Your Alchemist's amulet has (?<charges>.+) charges left.").setDynamicallyCharges(),

            // Charge
            new OnChatMessage("You apply an additional .+ charges to your Alchemist's amulet. It now has (?<charges>.+) charges in total.").setDynamicallyCharges(),
            new OnChatMessage("You apply (?<charges>.+) charges to your Alchemist's amulet.").setDynamicallyCharges(),

            // Uncharge
            new OnChatMessage("You uncharge your Alchemist's amulet, regaining .+ amulets of chemistry in the process.").setFixedCharges(0),

            // Use charge
            new OnChatMessage("Your Alchemist's amulet helps you create a 4-dose potion. It no longer has any charges.").setFixedCharges(0),
            new OnChatMessage("Your Alchemist's amulet helps you create a 4-dose potion. It has one charge left.").setFixedCharges(1),
            new OnChatMessage("Your Alchemist's amulet helps you create a 4-dose potion. It has (?<charges>.+) charges left.").setDynamicallyCharges(),

            // Auto-charge
            new OnChatMessage("The banker charges your Alchemist's amulet using (?<amulets>.+)x Amulet of chemistry.*").matcherConsumer(m -> {
                final int amuletsOfChemistry = Integer.parseInt(m.group("amulets"));
                increaseCharges(amuletsOfChemistry * 10);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_OgreBellows extends ChargedItem {
    public U_OgreBellows(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ogre_bellows, ItemId.OGRE_BELLOWS_0, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.OGRE_BELLOWS_0).fixedCharges(0),
            new TriggerItem(ItemId.OGRE_BELLOWS_1).fixedCharges(1),
            new TriggerItem(ItemId.OGRE_BELLOWS_2).fixedCharges(2),
            new TriggerItem(ItemId.OGRE_BELLOWS_3).fixedCharges(3),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.item.triggers.OnAnimationChanged;
import tictac7x.charges.store.AnimationId;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_RingOfShadows extends ChargedItem {
    public J_RingOfShadows(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_shadows, ItemId.RING_OF_SHADOWS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.RING_OF_SHADOWS_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.RING_OF_SHADOWS)
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your ring of shadows has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Charge.
            new OnChatMessage("You add (?<charges>.+) charges? to the ring of shadows.$").setDynamicallyCharges(),

            // Charge.
            new OnChatMessage("You add .+ charges? to the ring of shadows. It now has (?<charges>.+) charges?.").setDynamicallyCharges(),

            // Teleport.
            new OnAnimationChanged(AnimationId.RING_OF_SHADOWS_TELEPORT).decreaseCharges(1),

            // Auto-charge.
            new OnChatMessage("The banker charges your Ring of shadows using (?<bloodrune>.+)x Blood rune.*").matcherConsumer(m -> {
                final int bloodRunes = Integer.parseInt(m.group("ringofrecoil"));
                increaseCharges(bloodRunes);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class W_WarpedSceptre extends ChargedItem {
    public W_WarpedSceptre(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.warped_sceptre, ItemId.WARPED_SCEPTRE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.WARPED_SCEPTRE_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.WARPED_SCEPTRE)
        };

        this.triggers = new TriggerBase[] {
            // Charge additional.
            new OnChatMessage("You add an additional .+ charges? to your warped sceptre. It now has (?<charges>.+) charges in total.").setDynamicallyCharges(),

            // Charge empty.
            new OnChatMessage("You add (?<charges>.+) charges? to your warped sceptre.").setDynamicallyCharges(),

            // Check.
            new OnChatMessage("Your warped sceptre( only)? has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Attack.
            new OnGraphicChanged(2567).decreaseCharges(1),

            // Uncharge.
            new OnChatMessage("You uncharge your warped sceptre").setFixedCharges(0),

            // Ran out of charges.
            new OnChatMessage("Your warped sceptre has run out of charges!").setFixedCharges(0),

            // Auto-charge.
            new OnChatMessage("The banker charges your Warped sceptre using (?<chaosrune>.+)x Chaos rune, and .+x Earth rune.*").matcherConsumer(m -> {
                final int chaosRunes = Integer.parseInt(m.group("chaosrune"));
                increaseCharges(chaosRunes / 2);
            }),
        };
    }
}

package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class AhrimsRobetop extends _BarrowsItem {
    public AhrimsRobetop(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Ahrim's body", ItemId.AHRIMS_ROBETOP, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.AHRIMS_ROBETOP).fixedCharges(1000),
            new TriggerItem(ItemId.AHRIMS_ROBETOP_100),
            new TriggerItem(ItemId.AHRIMS_ROBETOP_75),
            new TriggerItem(ItemId.AHRIMS_ROBETOP_50),
            new TriggerItem(ItemId.AHRIMS_ROBETOP_25),
            new TriggerItem(ItemId.AHRIMS_ROBETOP_0).fixedCharges(0),
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.customEvents.CustomMenuOptionClicked;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnCombat;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.store.Store;

public class _BarrowsItem extends ChargedItem {
    public _BarrowsItem(
        final String itemName,
        final int itemId,
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(
            TicTac7xChargesImprovedConfig.barrows_gear + "_" + itemName.toLowerCase().replaceAll("'", "").replaceAll(" ", "_"),
            itemId,
            client,
            clientThread,
            configManager,
            itemManager,
            infoBoxManager,
            chatMessageManager,
            notifier,
            config,
            store,
            gson
        );

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage(itemName + ": (?<percentage>.+)% remaining until the next degradation.").matcherConsumer((m) -> {
                final int percentage = Integer.parseInt(m.group("percentage"));
                final int chargesUsedInCurrentTier = (100 - percentage) * 250 / 100;

                for (final CustomMenuOptionClicked menuOptionClicked : store.menuOptionsClicked) {
                    if (menuOptionClicked.target.contains(itemManager.getItemComposition(itemId).getName())) {
                        final int currentTierMaxCharges = Integer.parseInt(menuOptionClicked.target.replaceAll("\\D", "")) * 10;
                        setCharges(currentTierMaxCharges - chargesUsedInCurrentTier);
                        return;
                    }
                }
            }),

            // Degrade in combat.
            new OnCombat(90).isEquipped().decreaseCharges(1),
        };
    }

    @Override
    protected String getChargesMinified(final int itemId) {
        switch (config.combatTimeDegradableStyle()) {
            case PERCENTAGE:
                return getChargesFromConfig() * 100 / 1000 + "%";
            case TIME:
                final double hours = (double) (getChargesFromConfig() * 90 * 600) / 1000 / 3600;
                return String.format("%.1fh", hours).replaceAll("\\.0", "");
            case CHARGES:
            default:
                return super.getChargesMinified(itemId);
        }
    }
}

package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class KarilsLeathertop extends _BarrowsItem {
    public KarilsLeathertop(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Karil's body", ItemId.KARILS_LEATHERTOP, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.KARILS_LEATHERTOP).fixedCharges(1000),
            new TriggerItem(ItemId.KARILS_LEATHERTOP_100),
            new TriggerItem(ItemId.KARILS_LEATHERTOP_75),
            new TriggerItem(ItemId.KARILS_LEATHERTOP_50),
            new TriggerItem(ItemId.KARILS_LEATHERTOP_25),
            new TriggerItem(ItemId.KARILS_LEATHERTOP_0).fixedCharges(0)
        };
    }
}

package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class KarilsCrossbow extends _BarrowsItem {
    public KarilsCrossbow(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Karil's weapon", ItemId.KARILS_CROSSBOW, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.KARILS_CROSSBOW).fixedCharges(1000),
            new TriggerItem(ItemId.KARILS_CROSSBOW_100),
            new TriggerItem(ItemId.KARILS_CROSSBOW_75),
            new TriggerItem(ItemId.KARILS_CROSSBOW_50),
            new TriggerItem(ItemId.KARILS_CROSSBOW_25),
            new TriggerItem(ItemId.KARILS_CROSSBOW_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class ToragsPlatelegs extends _BarrowsItem {
    public ToragsPlatelegs(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Torag's legs", ItemId.TORAGS_PLATELEGS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TORAGS_PLATELEGS).fixedCharges(1000),
            new TriggerItem(ItemId.TORAGS_PLATELEGS_100),
            new TriggerItem(ItemId.TORAGS_PLATELEGS_75),
            new TriggerItem(ItemId.TORAGS_PLATELEGS_50),
            new TriggerItem(ItemId.TORAGS_PLATELEGS_25),
            new TriggerItem(ItemId.TORAGS_PLATELEGS_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class GuthansHelm extends _BarrowsItem {
    public GuthansHelm(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Guthan's helmet", ItemId.GUTHANS_HELM, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.GUTHANS_HELM).fixedCharges(1000),
            new TriggerItem(ItemId.GUTHANS_HELM_100),
            new TriggerItem(ItemId.GUTHANS_HELM_75),
            new TriggerItem(ItemId.GUTHANS_HELM_50),
            new TriggerItem(ItemId.GUTHANS_HELM_25),
            new TriggerItem(ItemId.GUTHANS_HELM_0).fixedCharges(0),
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class DharoksPlatebody extends _BarrowsItem {
    public DharoksPlatebody(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Dharok's body", ItemId.DHAROKS_PLATEBODY, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.DHAROKS_PLATEBODY).fixedCharges(1000),
            new TriggerItem(ItemId.DHAROKS_PLATEBODY_100),
            new TriggerItem(ItemId.DHAROKS_PLATEBODY_75),
            new TriggerItem(ItemId.DHAROKS_PLATEBODY_50),
            new TriggerItem(ItemId.DHAROKS_PLATEBODY_25),
            new TriggerItem(ItemId.DHAROKS_PLATEBODY_0).fixedCharges(0),
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class DharoksPlatelegs extends _BarrowsItem {
    public DharoksPlatelegs(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Dharok's legs", ItemId.DHAROKS_PLATELEGS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.DHAROKS_PLATELEGS).fixedCharges(1000),
            new TriggerItem(ItemId.DHAROKS_PLATELEGS_100),
            new TriggerItem(ItemId.DHAROKS_PLATELEGS_75),
            new TriggerItem(ItemId.DHAROKS_PLATELEGS_50),
            new TriggerItem(ItemId.DHAROKS_PLATELEGS_25),
            new TriggerItem(ItemId.DHAROKS_PLATELEGS_0).fixedCharges(0),
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class VeracsFlail extends _BarrowsItem {
    public VeracsFlail(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Verac's weapon", ItemId.VERACS_FLAIL, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.VERACS_FLAIL).fixedCharges(1000),
            new TriggerItem(ItemId.VERACS_FLAIL_100),
            new TriggerItem(ItemId.VERACS_FLAIL_75),
            new TriggerItem(ItemId.VERACS_FLAIL_50),
            new TriggerItem(ItemId.VERACS_FLAIL_25),
            new TriggerItem(ItemId.VERACS_FLAIL_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class VeracsHelm extends _BarrowsItem {
    public VeracsHelm(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Verac's helmet", ItemId.VERACS_HELM, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.VERACS_HELM).fixedCharges(1000),
            new TriggerItem(ItemId.VERACS_HELM_100),
            new TriggerItem(ItemId.VERACS_HELM_75),
            new TriggerItem(ItemId.VERACS_HELM_50),
            new TriggerItem(ItemId.VERACS_HELM_25),
            new TriggerItem(ItemId.VERACS_HELM_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class GuthansWarspear extends _BarrowsItem {
    public GuthansWarspear(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Guthan's weapon", ItemId.GUTHANS_WARSPEAR, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.GUTHANS_WARSPEAR).fixedCharges(1000),
            new TriggerItem(ItemId.GUTHANS_WARSPEAR_100),
            new TriggerItem(ItemId.GUTHANS_WARSPEAR_75),
            new TriggerItem(ItemId.GUTHANS_WARSPEAR_50),
            new TriggerItem(ItemId.GUTHANS_WARSPEAR_25),
            new TriggerItem(ItemId.GUTHANS_WARSPEAR_0).fixedCharges(0),
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.ItemId;
import tictac7x.charges.store.Store;

public class AhrimsRobeskirt extends _BarrowsItem {
    public AhrimsRobeskirt(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Ahrim's skirt", ItemId.AHRIMS_ROBESKIRT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.AHRIMS_ROBESKIRT).fixedCharges(1000),
            new TriggerItem(ItemId.AHRIMS_ROBESKIRT_100),
            new TriggerItem(ItemId.AHRIMS_ROBESKIRT_75),
            new TriggerItem(ItemId.AHRIMS_ROBESKIRT_50),
            new TriggerItem(ItemId.AHRIMS_ROBESKIRT_25),
            new TriggerItem(ItemId.AHRIMS_ROBESKIRT_0).fixedCharges(0),
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class DharoksGreataxe extends _BarrowsItem {
    public DharoksGreataxe(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Dharok's weapon", ItemId.DHAROKS_GREATAXE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.DHAROKS_GREATAXE).fixedCharges(1000),
            new TriggerItem(ItemId.DHAROKS_GREATAXE_100),
            new TriggerItem(ItemId.DHAROKS_GREATAXE_75),
            new TriggerItem(ItemId.DHAROKS_GREATAXE_50),
            new TriggerItem(ItemId.DHAROKS_GREATAXE_25),
            new TriggerItem(ItemId.DHAROKS_GREATAXE_0).fixedCharges(0),
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class VeracsBrassard extends _BarrowsItem {
    public VeracsBrassard(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Verac's body", ItemId.VERACS_BRASSARD, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.VERACS_BRASSARD).fixedCharges(1000),
            new TriggerItem(ItemId.VERACS_BRASSARD_100),
            new TriggerItem(ItemId.VERACS_BRASSARD_75),
            new TriggerItem(ItemId.VERACS_BRASSARD_50),
            new TriggerItem(ItemId.VERACS_BRASSARD_25),
            new TriggerItem(ItemId.VERACS_BRASSARD_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class KarilsLeatherskirt extends _BarrowsItem {
    public KarilsLeatherskirt(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Karil's skirt", ItemId.KARILS_LEATHERSKIRT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.KARILS_LEATHERSKIRT).fixedCharges(1000),
            new TriggerItem(ItemId.KARILS_LEATHERSKIRT_100),
            new TriggerItem(ItemId.KARILS_LEATHERSKIRT_75),
            new TriggerItem(ItemId.KARILS_LEATHERSKIRT_50),
            new TriggerItem(ItemId.KARILS_LEATHERSKIRT_25),
            new TriggerItem(ItemId.KARILS_LEATHERSKIRT_0).fixedCharges(0)
        };
    }
}

package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class KarilsCoif extends _BarrowsItem {
    public KarilsCoif(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Karil's coif", ItemId.KARILS_COIF, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.KARILS_COIF).fixedCharges(1000),
            new TriggerItem(ItemId.KARILS_COIF_100),
            new TriggerItem(ItemId.KARILS_COIF_75),
            new TriggerItem(ItemId.KARILS_COIF_50),
            new TriggerItem(ItemId.KARILS_COIF_25),
            new TriggerItem(ItemId.KARILS_COIF_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class GuthansPlatebody extends _BarrowsItem {
    public GuthansPlatebody(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Guthan's body", ItemId.GUTHANS_PLATEBODY, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.GUTHANS_PLATEBODY).fixedCharges(1000),
            new TriggerItem(ItemId.GUTHANS_PLATEBODY_100),
            new TriggerItem(ItemId.GUTHANS_PLATEBODY_75),
            new TriggerItem(ItemId.GUTHANS_PLATEBODY_50),
            new TriggerItem(ItemId.GUTHANS_PLATEBODY_25),
            new TriggerItem(ItemId.GUTHANS_PLATEBODY_0).fixedCharges(0),
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class ToragsHammers extends _BarrowsItem {
    public ToragsHammers(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Torag's weapon", ItemId.TORAGS_HAMMERS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TORAGS_HAMMERS).fixedCharges(1000),
            new TriggerItem(ItemId.TORAGS_HAMMERS_100),
            new TriggerItem(ItemId.TORAGS_HAMMERS_75),
            new TriggerItem(ItemId.TORAGS_HAMMERS_50),
            new TriggerItem(ItemId.TORAGS_HAMMERS_25),
            new TriggerItem(ItemId.TORAGS_HAMMERS_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class AhrimsHood extends _BarrowsItem {
    public AhrimsHood(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Ahrim's hood", ItemId.AHRIMS_HOOD, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.AHRIMS_HOOD).fixedCharges(1000),
            new TriggerItem(ItemId.AHRIMS_HOOD_100),
            new TriggerItem(ItemId.AHRIMS_HOOD_75),
            new TriggerItem(ItemId.AHRIMS_HOOD_50),
            new TriggerItem(ItemId.AHRIMS_HOOD_25),
            new TriggerItem(ItemId.AHRIMS_HOOD_0).fixedCharges(0),
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class AhrimsStaff extends _BarrowsItem {
    public AhrimsStaff(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Ahrim's weapon", ItemId.AHRIMS_STAFF, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.AHRIMS_STAFF).fixedCharges(1000),
            new TriggerItem(ItemId.AHRIMS_STAFF_100),
            new TriggerItem(ItemId.AHRIMS_STAFF_75),
            new TriggerItem(ItemId.AHRIMS_STAFF_50),
            new TriggerItem(ItemId.AHRIMS_STAFF_25),
            new TriggerItem(ItemId.AHRIMS_STAFF_0).fixedCharges(0),
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class ToragsHelm extends _BarrowsItem {
    public ToragsHelm(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Torag's helmet", ItemId.TORAGS_HELM, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TORAGS_HELM).fixedCharges(1000),
            new TriggerItem(ItemId.TORAGS_HELM_100),
            new TriggerItem(ItemId.TORAGS_HELM_75),
            new TriggerItem(ItemId.TORAGS_HELM_50),
            new TriggerItem(ItemId.TORAGS_HELM_25),
            new TriggerItem(ItemId.TORAGS_HELM_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class VeracsPlateskirt extends _BarrowsItem {
    public VeracsPlateskirt(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Verac's skirt", ItemId.VERACS_PLATESKIRT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.VERACS_PLATESKIRT).fixedCharges(1000),
            new TriggerItem(ItemId.VERACS_PLATESKIRT_100),
            new TriggerItem(ItemId.VERACS_PLATESKIRT_75),
            new TriggerItem(ItemId.VERACS_PLATESKIRT_50),
            new TriggerItem(ItemId.VERACS_PLATESKIRT_25),
            new TriggerItem(ItemId.VERACS_PLATESKIRT_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class DharoksHelm extends _BarrowsItem {
    public DharoksHelm(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Dharok's helmet", ItemId.DHAROKS_HELM, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.DHAROKS_HELM).fixedCharges(1000),
            new TriggerItem(ItemId.DHAROKS_HELM_100),
            new TriggerItem(ItemId.DHAROKS_HELM_75),
            new TriggerItem(ItemId.DHAROKS_HELM_50),
            new TriggerItem(ItemId.DHAROKS_HELM_25),
            new TriggerItem(ItemId.DHAROKS_HELM_0).fixedCharges(0),
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class GuthansChainskirt extends _BarrowsItem {
    public GuthansChainskirt(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Guthan's skirt", ItemId.GUTHANS_CHAINSKIRT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.GUTHANS_CHAINSKIRT).fixedCharges(1000),
            new TriggerItem(ItemId.GUTHANS_CHAINSKIRT_100),
            new TriggerItem(ItemId.GUTHANS_CHAINSKIRT_75),
            new TriggerItem(ItemId.GUTHANS_CHAINSKIRT_50),
            new TriggerItem(ItemId.GUTHANS_CHAINSKIRT_25),
            new TriggerItem(ItemId.GUTHANS_CHAINSKIRT_0).fixedCharges(0),
        };
    }
}
package tictac7x.charges.items.barrows;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class ToragsPlatebody extends _BarrowsItem {
    public ToragsPlatebody(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super("Torag's body", ItemId.TORAGS_PLATEBODY, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TORAGS_PLATEBODY).fixedCharges(1000),
            new TriggerItem(ItemId.TORAGS_PLATEBODY_100),
            new TriggerItem(ItemId.TORAGS_PLATEBODY_75),
            new TriggerItem(ItemId.TORAGS_PLATEBODY_50),
            new TriggerItem(ItemId.TORAGS_PLATEBODY_25),
            new TriggerItem(ItemId.TORAGS_PLATEBODY_0).fixedCharges(0)
        };
    }
}
package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class J_DesertAmulet extends ChargedItem {
    public J_DesertAmulet(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.desert_amulet, ItemId.DESERT_AMULET_2, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.DESERT_AMULET_2),
            new TriggerItem(ItemId.DESERT_AMULET_3),
            new TriggerItem(ItemId.DESERT_AMULET_4).fixedCharges(Charges.UNLIMITED),
        };

        this.triggers = new TriggerBase[]{
            new OnChatMessage("You have already used your available teleports for today.").setFixedCharges(0),
            new OnResetDaily().specificItem(ItemId.DESERT_AMULET_2).setFixedCharges(1),
            new OnResetDaily().specificItem(ItemId.DESERT_AMULET_3).setFixedCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.ReplaceTarget;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.WidgetId;

import static tictac7x.charges.store.ItemContainerId.BANK;
import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_HerbSack extends ChargedItemWithStorage {
    public U_HerbSack(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.herb_sack, ItemId.HERB_SACK, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.HERB_SACK),
            new TriggerItem(ItemId.HERB_SACK_OPEN),
        };

        storage = storage.setMaximumIndividualQuantity(30).storableItems(
            new StorableItem(ItemId.GRIMY_GUAM_LEAF).checkName("Guam leaf"),
            new StorableItem(ItemId.GRIMY_MARRENTILL).checkName("Marrentill"),
            new StorableItem(ItemId.GRIMY_TARROMIN).checkName("Tarromin"),
            new StorableItem(ItemId.GRIMY_HARRALANDER).checkName("Harralander"),
            new StorableItem(ItemId.GRIMY_RANARR_WEED).checkName("Ranarr weed"),
            new StorableItem(ItemId.GRIMY_TOADFLAX).checkName("Toadflax"),
            new StorableItem(ItemId.GRIMY_IRIT_LEAF).checkName("Irit leaf"),
            new StorableItem(ItemId.GRIMY_AVANTOE).checkName("Avantoe"),
            new StorableItem(ItemId.GRIMY_KWUARM).checkName("Kwuarm"),
            new StorableItem(ItemId.GRIMY_HUASCA).checkName("Huasca"),
            new StorableItem(ItemId.GRIMY_SNAPDRAGON).checkName("Snapdragon"),
            new StorableItem(ItemId.GRIMY_CADANTINE).checkName("Cadantine"),
            new StorableItem(ItemId.GRIMY_LANTADYME).checkName("Lantadyme"),
            new StorableItem(ItemId.GRIMY_DWARF_WEED).checkName("Dwarf weed"),
            new StorableItem(ItemId.GRIMY_TORSTOL).checkName("Torstol")
        );

        this.triggers = new TriggerBase[] {
            // Check or empty.
            new OnChatMessage("The herb sack is empty.").emptyStorage(),

            // Pickup.
            new OnChatMessage("You put the Grimy (?<herb>.+) herb into your herb sack.").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("herb"), 1));
            }),

            // Check.
            new OnChatMessage("You look in your herb sack and see:").emptyStorage(),
            new OnChatMessage("(?<quantity>.+) x Grimy (?<herb>.+)").matcherConsumer(m -> {
                storage.put(getStorageItemFromName(m.group("herb"), Integer.parseInt(m.group("quantity"))));
            }),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Empty to inventory.
            new OnItemContainerChanged(INVENTORY).emptyStorageToInventory().onMenuOption("Empty"),

            // Empty to bank.
            new OnItemContainerChanged(BANK).emptyStorageToBank().onMenuOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank),

            // Empty from deposit box.
            new OnMenuOptionClicked(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank).onItemClick().isWidgetVisible(WidgetId.DEPOSIT_BOX).emptyStorage(),

            // Replace "Empty" with proper "Empty to bank".
            new OnMenuEntryAdded("Empty").replaceOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Hide destroy option.
            new OnMenuEntryAdded("Destroy").hide(),

            // Pick guam leaf.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs",
                "Guam herbs"
            ).onMenuImpostor(
                26828,
                39816
            ).addToStorage(ItemId.GRIMY_GUAM_LEAF),
            new OnMenuEntryAdded().isReplaceImpostorId(
                26824, 26825, 26826, 26827, 26828,
                39812, 39813, 39814, 39815, 39816
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Guam herbs"),
                new ReplaceTarget("Herb patch", "Guam herbs")
            ).onMenuTarget("Herbs").onHover(),

            // Pick marrentill.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs",
                "Marrentill herbs"
            ).onMenuImpostor(
                39751,
                39821
            ).addToStorage(ItemId.GRIMY_MARRENTILL),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39747, 39748, 39749, 39750, 39751,
                39816, 39817, 39818, 39819, 39821
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Marrentill herbs"),
                new ReplaceTarget("Herb patch", "Marrentill herbs")
            ).onMenuTarget("Herbs").onHover(),

            // Pick tarromin.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs",
                "Tarromin herbs"
            ).onMenuImpostor(
                39756,
                39826
            ).addToStorage(ItemId.GRIMY_TARROMIN),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39752, 39753, 39754, 39755, 39756,
                39822, 39823, 39824, 39825, 39826
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Tarromin herbs"),
                new ReplaceTarget("Herb patch", "Tarromin herbs")
            ).onMenuTarget("Herbs").onHover(),

            // Pick harralander.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs",
                "Harralander herbs"
            ).onMenuImpostor(
                39761,
                39831
            ).addToStorage(ItemId.GRIMY_HARRALANDER),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39757, 39758, 39759, 39760, 39761,
                39827, 39828, 39829, 39830, 39831
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Harralander herbs"),
                new ReplaceTarget("Herb patch", "Harralander herbs")
            ).onMenuTarget("Herbs").onHover(),

            // Pick ranarr.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs",
                "Ranarr weed herbs"
            ).onMenuImpostor(
                39766,
                39836
            ).addToStorage(ItemId.GRIMY_RANARR_WEED),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39762, 39763, 39764, 39765, 39766,
                39832, 39833, 39834, 39835, 39836
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Ranarr weed herbs"),
                new ReplaceTarget("Herb patch", "Ranarr weed herbs")
            ).onMenuTarget("Herbs").onHover(),

            // Pick irit leaf.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs",
                "Irit leaf herbs"
            ).onMenuImpostor(
                39771,
                39841
            ).addToStorage(ItemId.GRIMY_IRIT_LEAF),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39767, 39768, 39769, 39770, 39771,
                39837, 39838, 39839, 39840, 39841
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Irit leaf herbs"),
                new ReplaceTarget("Herb patch", "Irit leaf herbs")
            ).onMenuTarget("Herbs").onHover(),

            // Pick avantoe.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs",
                "Avantoe herbs"
            ).onMenuImpostor(
                39776,
                39846
            ).addToStorage(ItemId.GRIMY_AVANTOE),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39772, 39773, 39774, 39775, 39776,
                39842, 39843, 39844, 39845, 39846
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Avantoe herbs"),
                new ReplaceTarget("Herb patch", "Avantoe herbs")
            ).onMenuTarget("Herbs").onHover(),

            // Pick toadflax.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs",
                "Toadflax herbs"
            ).onMenuImpostor(
                39781,
                39851
            ).addToStorage(ItemId.GRIMY_TOADFLAX),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39777, 39778, 39779, 39780, 39781,
                39847, 39848, 39849, 39850, 39851
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Toadflax herbs"),
                new ReplaceTarget("Herb patch", "Toadflax herbs")
            ).onMenuTarget("Herbs").onHover(),

            // Pick kwuarm.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs",
                "Kwuarm herbs"
            ).onMenuImpostor(
                39786,
                39856
            ).addToStorage(ItemId.GRIMY_KWUARM),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39782, 39783, 39784, 39785, 39786,
                39852, 39853, 39854, 39855, 39856
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Kwuarm herbs"),
                new ReplaceTarget("Herb patch", "Kwuarm herbs")
            ).onMenuTarget("Herbs").onHover(),

            // Pick huasca.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs",
                "Huasca herbs"
            ).onMenuImpostor(
                55351,
                55346
            ).addToStorage(ItemId.GRIMY_HUASCA),
            new OnMenuEntryAdded().isReplaceImpostorId(
                55342, 55343, 55344, 55345, 55346,
                55347, 55348, 55349, 55350, 55351
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Huasca herbs"),
                new ReplaceTarget("Herb patch", "Huasca herbs")
            ).onMenuTarget("Herbs").onHover(),

            // Pick cadantine.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs",
                "Cadantine herbs"
            ).onMenuImpostor(
                39791,
                39861
            ).addToStorage(ItemId.GRIMY_CADANTINE),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39787, 39788, 39789, 39790, 39791,
                39857, 39858, 39859, 39860, 39861
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Cadantine herbs"),
                new ReplaceTarget("Herb patch", "Cadantine herbs")
            ).onMenuTarget("Herbs").onHover(),

            // Pick lantadyme.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs", "Lantadyme herbs").onMenuImpostor(39796, 39866).addToStorage(ItemId.GRIMY_LANTADYME),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39792, 39793, 39794, 39795, 39796,
                39862, 39863, 39864, 39865, 39866
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Lantadyme herbs"),
                new ReplaceTarget("Herb patch", "Lantadyme herbs")
            ).onMenuTarget("Herbs").onHover(),

            // Pick dwarf weed.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs",
                "Dwarf weed herbs"
            ).onMenuImpostor(
                39801,
                39871
            ).addToStorage(ItemId.GRIMY_DWARF_WEED),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39797, 39798, 39799, 39800, 39801,
                39867, 39868, 39869, 39870, 39871
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Dwarf weed herbs"),
                new ReplaceTarget("Herb patch", "Dwarf weed herbs")
            ).onMenuTarget("Herbs").onHover(),

            // Pick torstol.
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs",
                "Torstol herbs"
            ).onMenuImpostor(
                39806,
                39876
            ).addToStorage(ItemId.GRIMY_TORSTOL),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39802, 39803, 39804, 39805, 39806,
                39872, 39873, 39874, 39875, 39876
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Torstol herbs"),
                new ReplaceTarget("Herb patch", "Torstol herbs")
            ).onMenuTarget("Herbs").onHover(),

            // Pick snapdragon
            new OnXpDrop(Skill.FARMING).requiredItem(ItemId.HERB_SACK_OPEN).onMenuOption("Pick").onMenuTarget("Herbs",
                "Snapdragon herbs"
            ).onMenuImpostor(
                39811,
                39881
            ).addToStorage(ItemId.GRIMY_SNAPDRAGON),
            new OnMenuEntryAdded().isReplaceImpostorId(
                39807, 39808, 39809, 39810, 39811,
                39877, 39878, 39879, 39880, 39881
            ).replaceTargets(
                new ReplaceTarget("Herbs", "Snapdragon herbs"),
                new ReplaceTarget("Herb patch", "Snapdragon herbs")
            ).onMenuTarget("Herbs").onHover(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.AnimationId;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;

public class U_ChuggingBarrel extends ChargedItemWithStorage {
    public U_ChuggingBarrel(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.chugging_barrel, ItemId.CHUGGING_BARREL, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.storage.storableItems(
            // Regular potions.
            new StorableItem(ItemId.ATTACK_POTION_1),
            new StorableItem(ItemId.ANTIPOISON_1),
            new StorableItem(ItemId.RELICYMS_BALM_1),
            new StorableItem(ItemId.STRENGTH_POTION_1),
            new StorableItem(ItemId.RESTORE_POTION_1),
            new StorableItem(ItemId.GUTHIX_BALANCE_1),
            new StorableItem(ItemId.ENERGY_POTION_1),
            new StorableItem(ItemId.DEFENCE_POTION_1),
            new StorableItem(ItemId.AGILITY_POTION_1),
            new StorableItem(ItemId.COMBAT_POTION_1),
            new StorableItem(ItemId.PRAYER_POTION_1),
            new StorableItem(ItemId.SUPER_ATTACK_1),
            new StorableItem(ItemId.SUPER_ANTIPOISON_1),
            new StorableItem(ItemId.FISHING_POTION_1),
            new StorableItem(ItemId.SUPER_ENERGY_POTION_1),
            new StorableItem(ItemId.HUNTER_POTION_1),
            new StorableItem(ItemId.GOADING_POTION_1),
            new StorableItem(ItemId.SUPER_STRENGTH_1),
            new StorableItem(ItemId.MAGIC_ESSENCE_1),
            new StorableItem(ItemId.PRAYER_REGENERATION_POTION_1),
            new StorableItem(ItemId.SUPER_RESTORE_1),
            new StorableItem(ItemId.SANFEW_SERUM_1),
            new StorableItem(ItemId.SUPER_DEFENCE_1),
            new StorableItem(ItemId.ANTIDOTE_1),
            new StorableItem(ItemId.ANTIFIRE_POTION_1),
            new StorableItem(ItemId.DIVINE_SUPER_ATTACK_POTION_1),
            new StorableItem(ItemId.DIVINE_SUPER_DEFENCE_POTION_1),
            new StorableItem(ItemId.DIVINE_SUPER_STRENGTH_POTION_1),
            new StorableItem(ItemId.RANGING_POTION_1),
            new StorableItem(ItemId.DIVINE_RANGING_POTION_1),
            new StorableItem(ItemId.MAGIC_POTION_1),
            new StorableItem(ItemId.STAMINA_POTION_1),
            new StorableItem(ItemId.ZAMORAK_BREW_1),
            new StorableItem(ItemId.DIVINE_MAGIC_POTION_1),
            new StorableItem(ItemId.ANTIDOTE1_5958),
            new StorableItem(ItemId.BASTION_POTION_1),
            new StorableItem(ItemId.BATTLEMAGE_POTION_1),
            new StorableItem(ItemId.SARADOMIN_BREW_1),
            new StorableItem(ItemId.EXTENDED_ANTIFIRE_1),
            new StorableItem(ItemId.ANCIENT_BREW_1),
            new StorableItem(ItemId.DIVINE_BASTION_POTION_1),
            new StorableItem(ItemId.DIVINE_BATTLEMAGE_POTION_1),
            new StorableItem(ItemId.ANTIVENOM_1),
            new StorableItem(ItemId.MENAPHITE_REMEDY_1),
            new StorableItem(ItemId.SUPER_COMBAT_POTION_1),
            new StorableItem(ItemId.FORGOTTEN_BREW_1),
            new StorableItem(ItemId.SUPER_ANTIFIRE_POTION_1),
            new StorableItem(ItemId.ANTIVENOM_PLUS_1),
            new StorableItem(ItemId.EXTENDED_ANTIVENOM_1),
            new StorableItem(ItemId.DIVINE_SUPER_COMBAT_POTION_1),
            new StorableItem(ItemId.EXTENDED_SUPER_ANTIFIRE_1),

            // Mixes.
            new StorableItem(ItemId.ATTACK_MIX_1),
            new StorableItem(ItemId.ANTIPOISON_MIX_1),
            new StorableItem(ItemId.RELICYMS_MIX_1),
            new StorableItem(ItemId.STRENGTH_MIX_1),
            new StorableItem(ItemId.RESTORE_MIX_1),
            new StorableItem(ItemId.ENERGY_MIX_1),
            new StorableItem(ItemId.DEFENCE_MIX_1),
            new StorableItem(ItemId.AGILITY_MIX_1),
            new StorableItem(ItemId.COMBAT_MIX_1),
            new StorableItem(ItemId.PRAYER_MIX_1),
            new StorableItem(ItemId.SUPERATTACK_MIX_1),
            new StorableItem(ItemId.ANTIPOISON_SUPERMIX_1),
            new StorableItem(ItemId.FISHING_MIX_1),
            new StorableItem(ItemId.SUPER_ENERGY_MIX_1),
            new StorableItem(ItemId.HUNTING_MIX_1),
            new StorableItem(ItemId.SUPER_STR_MIX_1),
            new StorableItem(ItemId.MAGIC_ESSENCE_MIX_1),
            new StorableItem(ItemId.SUPER_RESTORE_MIX_1),
            new StorableItem(ItemId.SUPER_DEFENCE_MIX_1),
            new StorableItem(ItemId.ANTIDOTE_MIX_1),
            new StorableItem(ItemId.ANTIFIRE_MIX_1),
            new StorableItem(ItemId.RANGING_MIX_1),
            new StorableItem(ItemId.MAGIC_MIX_1),
            new StorableItem(ItemId.ZAMORAK_MIX_1),
            new StorableItem(ItemId.STAMINA_MIX_1),
            new StorableItem(ItemId.EXTENDED_ANTIFIRE_MIX_1),
            new StorableItem(ItemId.ANCIENT_MIX_1),
            new StorableItem(ItemId.SUPER_ANTIFIRE_MIX_1),
            new StorableItem(ItemId.EXTENDED_SUPER_ANTIFIRE_MIX_1)
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.CHUGGING_BARREL_DISASSEMBLED).fixedCharges(0),
            new TriggerItem(ItemId.CHUGGING_BARREL),
        };

        this.triggers = new TriggerBase[]{
            // Check contents.
            new OnItemContainerChanged(ItemContainerId.CHUGGING_BARREL).updateStorage(),

            // Drink.
            new OnAnimationChanged(AnimationId.CHUGGING_BARREL_DRINK).consumer(() -> {
                for (final StorageItem storageItem : storage.getStorage().getItems()) {
                    storage.put(storageItem.getId(), storageItem.getQuantity() - 1);
                }
            }),

            // Hide dismantle.
            new OnMenuEntryAdded("Dismantle").hide(),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),

            // Unify "Open" to "Configure"
            new OnMenuEntryAdded("Open").replaceOption("Configure"),
        };
    }

    @Override
    public String getCharges(final int itemId) {
        int sipsMinimum = 0;

        for (final StorageItem storageItem : storage.getStorage().getItems()) {
            if (sipsMinimum == 0 || storageItem.getQuantity() < sipsMinimum) {
                sipsMinimum = storageItem.getQuantity();
            }
        }

        return String.valueOf(sipsMinimum);
    }

    @Override
    public String getTooltip() {
        final String tooltip = super.getTooltip();
        return tooltip.replaceAll("\\(1\\)", "");
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_JarGenerator extends ChargedItem {
    public U_JarGenerator(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.jar_generator, ItemId.JAR_GENERATOR, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.JAR_GENERATOR)
        };

        this.triggers = new TriggerBase[] {
            // Check or use.
            new OnChatMessage("You have (?<charges>.+) charges left in your jar generator.").setDynamicallyCharges(),

            // Crumbles.
            new OnChatMessage("Your jar generator runs out of charges and disappears.").setFixedCharges(100),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class S_FaladorShield extends ChargedItem {
    public S_FaladorShield(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.falador_shield, ItemId.FALADOR_SHIELD_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.FALADOR_SHIELD_1),
            new TriggerItem(ItemId.FALADOR_SHIELD_2),
            new TriggerItem(ItemId.FALADOR_SHIELD_3),
            new TriggerItem(ItemId.FALADOR_SHIELD_4),
        };
        
        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("You have one remaining charge for today.").onItemClick().setFixedCharges(1),
            new OnChatMessage("You have two remaining charges for today.").onItemClick().setFixedCharges(2),

            // Teleport when empty.
            new OnChatMessage("You have already used (both )?your charge(s)? for today.").onItemClick().setFixedCharges(0),
            new OnChatMessage("You have already used all available recharges today. Try again tomorrow when the shield has recharged.").onItemClick().setFixedCharges(0),

            // Recharge prayer.
            new OnGraphicChanged(321).onItemClick().decreaseCharges(1),

            // Daily resets.
            new OnResetDaily().specificItem(ItemId.FALADOR_SHIELD_1).setFixedCharges(1),
            new OnResetDaily().specificItem(ItemId.FALADOR_SHIELD_2).setFixedCharges(1),
            new OnResetDaily().specificItem(ItemId.FALADOR_SHIELD_3).setFixedCharges(1),
            new OnResetDaily().specificItem(ItemId.FALADOR_SHIELD_4).setFixedCharges(2),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class W_VenatorBow extends ChargedItem {
    public W_VenatorBow(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.venator_bow, ItemId.VENATOR_BOW, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.VENATOR_BOW_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.VENATOR_BOW)
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your venator bow has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Attack.
            new OnGraphicChanged(2289).decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_PhoenixNecklace extends ChargedItem {
    public J_PhoenixNecklace(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.phoenix_necklace, ItemId.PHOENIX_NECKLACE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.PHOENIX_NECKLACE).fixedCharges(1).needsToBeEquipped(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStatus;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.*;

import java.awt.*;
import java.time.Duration;
import java.time.Instant;

public class J_EscapeCrystal extends ChargedItemWithStatus {
    private Instant instantToTeleport = Instant.now();
    private boolean alertedAboutActivation = false;

    public J_EscapeCrystal(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.escape_crystal, ItemId.ESCAPE_CRYSTAL, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.ESCAPE_CRYSTAL).quantityCharges().hideOverlay(),
        };

        this.triggers = new TriggerBase[]{
            // Activate / Deactivate.
            new OnVarbitChanged(VarbitID.TELEPORT_CRYSTAL_AFK_MODE).varbitValueConsumer(value -> {
                if (value == 1) {
                    activate();
                } else {
                    deactivate();
                }
            }),

            // Inactivity timer.
            new OnVarbitChanged(VarbitID.TELEPORT_CRYSTAL_AFK_DELAY).varbitValueConsumer((value) -> {
                configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.escape_crystal_inactivity_period, value);
            }),

            // Keyboard or mouse action resets idle timer.
            new OnUserAction().consumer(this::resetIdleTimer),
        };
    }

    private void resetIdleTimer() {
        instantToTeleport = Instant.now().plusMillis(config.getEscapeCrystalInactivityPeriod() * 600L + 600L);

        store.addConsumerToNextTickQueue(() -> {
            alertedAboutActivation = false;
        });
    }

    private long getTimeRemainingUntilActivation() {
        switch (config.getEscapeCrystalTimeRemainingUnit()) {
            case SECONDS:
                return Math.max(0, (Duration.between(Instant.now(), instantToTeleport).toMillis()) / 1000);
            case TICKS:
            default:
                return Math.max(0, (Duration.between(Instant.now(), instantToTeleport).toMillis()) / 600);
        }
    }

    private boolean isAboutToActivate() {
        return config.getEscapeCrystalTimeRemainingWarning() > 0 && isActivated() && store.isLockedInCombat() && getTimeRemainingUntilActivation() <= config.getEscapeCrystalTimeRemainingWarning();
    }

    @Override
    public Color getTextColor() {
        return isAboutToActivate() ? Color.YELLOW : super.getTextColor();
    }

    @Override
    public String getCharges(final int itemId) {
        if (config.getEscapeCrystalStatus() == ItemActivity.DEACTIVATED || (!inInventory() && !inEquipment())) { return "\u221E"; }
        if (config.getEscapeCrystalInactivityPeriod() == Charges.UNKNOWN) { return "?"; }

        final long timeRemainingUntilActivation = getTimeRemainingUntilActivation();
        if (!alertedAboutActivation && isAboutToActivate()) {
            alertedAboutActivation = true;
            notifier.notify("Escape crystal is activating in " + timeRemainingUntilActivation + (config.getEscapeCrystalTimeRemainingUnit() == EscapeCrystalTimeRemainingUnit.SECONDS ? " seconds." : " ticks."));
        }

        switch (config.getEscapeCrystalTimeRemainingUnit()) {
            case SECONDS:
                return timeRemainingUntilActivation / 60 + ":" + String.format("%02d", timeRemainingUntilActivation % 60);
            case TICKS:
            default:
                return String.valueOf(timeRemainingUntilActivation);
        }
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class J_RingOfTheElements extends ChargedItem {
    public J_RingOfTheElements(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_the_elements, ItemId.RING_OF_THE_ELEMENTS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.RING_OF_THE_ELEMENTS),
            new TriggerItem(ItemId.RING_OF_THE_ELEMENTS_UNCHARGED).fixedCharges(0),
        };

        this.triggers = new TriggerBase[] {
            // Teleport.
            new OnVarbitChanged(13707).setDynamically(),

            // Unified menu entry.
            new OnMenuEntryAdded("Rub").replaceOption("Teleport"),

            // Last destination replaced with actual altar.
            new OnMenuEntryAdded("Last Destination").replaceOption("Air Altar").replaceTarget("Ring of the elements", "").varbitCheck(13708, 1),
            new OnMenuEntryAdded("Last Destination").replaceOption("Water Altar").replaceTarget("Ring of the elements", "").varbitCheck(13708, 2),
            new OnMenuEntryAdded("Last Destination").replaceOption("Earth Altar").replaceTarget("Ring of the elements", "").varbitCheck(13708, 3),
            new OnMenuEntryAdded("Last Destination").replaceOption("Fire Altar").replaceTarget("Ring of the elements", "").varbitCheck(13708, 4),
        };
    }
}
package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class S_TomeOfEarth extends ChargedItem {
    public S_TomeOfEarth(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.tome_of_earth, ItemId.TOME_OF_EARTH, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TOME_OF_EARTH_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.TOME_OF_EARTH).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your tome currently holds (?<charges>.+) charges?.").setDynamicallyCharges().onItemClick(),

            // Attack with regular spellbook earth spells.
            new OnGraphicChanged(96, 123, 138, 164, 1461).isEquipped().decreaseCharges(1),

            // Auto-charge.
            new OnChatMessage("The banker charges your Tome of earth using (?<soiledpage>.+)x Soiled page.").matcherConsumer(m -> {
                final int soiledPages = Integer.parseInt(m.group("soiledpage"));
                increaseCharges(soiledPages * 20);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.HitsplatTarget;
import tictac7x.charges.store.Store;

public class S_CrystalShield extends ChargedItem {
    public S_CrystalShield(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.crystal_shield, ItemId.CRYSTAL_SHIELD_DEGRADED, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.CRYSTAL_SHIELD),
            new TriggerItem(ItemId.CRYSTAL_SHIELD_DEGRADED),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your crystal shield has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Get hit.
            new OnHitsplatApplied(HitsplatTarget.SELF).moreThanZeroDamage().isEquipped().decreaseCharges(1)
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.Skill;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.WidgetId;

import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static tictac7x.charges.store.ItemContainerId.BANK;
import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class C_ForestryBasket extends ChargedItemWithStorage {
    private Optional<StorageItem> lastLogs = Optional.empty();
    private int infernalQuantityTracker = 0;
    private final String menuOptionEmptyLogsToBank = "Empty logs to bank";
    private final String menuOptionFillLeavesFromBank = "Fill leaves from bank";
    private final String menuOptionEmptyLeavesToBank = "Empty leaves to bank";

    public C_ForestryBasket(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.forestry_basket, ItemId.FORESTRY_BASKET, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.storage = storage.storableItems(
            // Log basket.
            new StorableItem(ItemId.LOGS).displayName("Regular logs").checkName("some logs", "x Logs").specificOrder(1),
            new StorableItem(ItemId.ACHEY_TREE_LOGS).checkName("Achey tree logs").specificOrder(2),
            new StorableItem(ItemId.OAK_LOGS).checkName("Oak logs").specificOrder(3),
            new StorableItem(ItemId.WILLOW_LOGS).checkName("Willow logs").specificOrder(4),
            new StorableItem(ItemId.TEAK_LOGS).checkName("Teak logs").specificOrder(5),
            new StorableItem(ItemId.JUNIPER_LOGS).checkName("Juniper logs").specificOrder(6),
            new StorableItem(ItemId.MAPLE_LOGS).checkName("Maple logs").specificOrder(7),
            new StorableItem(ItemId.MAHOGANY_LOGS).checkName("Mahogany logs").specificOrder(8),
            new StorableItem(ItemId.ARCTIC_PINE_LOGS).checkName("Arctic pine logs").specificOrder(9),
            new StorableItem(ItemId.YEW_LOGS).checkName("Yew logs").specificOrder(10),
            new StorableItem(ItemId.BLISTERWOOD_LOGS).checkName("Blisterwood logs").specificOrder(11),
            new StorableItem(ItemId.MAGIC_LOGS).checkName("Magic logs").specificOrder(12),
            new StorableItem(ItemId.REDWOOD_LOGS).checkName("Redwood logs").specificOrder(3),

            // Forestry kit.
            new StorableItem(ItemId.ANIMAINFUSED_BARK).specificOrder(14),
            new StorableItem(ItemId.FORESTERS_RATION).specificOrder(15),
            new StorableItem(ItemId.NATURE_OFFERINGS).specificOrder(16),
            new StorableItem(ItemId.SECATEURS_ATTACHMENT).specificOrder(17),
            new StorableItem(ItemId.LEAVES).displayName("Regular leaves").checkName("regular").specificOrder(18),
            new StorableItem(ItemId.OAK_LEAVES).checkName("oak").specificOrder(19),
            new StorableItem(ItemId.WILLOW_LEAVES).checkName("willow").specificOrder(20),
            new StorableItem(ItemId.MAPLE_LEAVES).checkName("maple").specificOrder(21),
            new StorableItem(ItemId.YEW_LEAVES).checkName("yew").specificOrder(22),
            new StorableItem(ItemId.MAGIC_LEAVES).checkName("magic").specificOrder(23),
            new StorableItem(ItemId.FORESTRY_HAT).specificOrder(24),
            new StorableItem(ItemId.FORESTRY_TOP).specificOrder(25),
            new StorableItem(ItemId.FORESTRY_LEGS).specificOrder(26),
            new StorableItem(ItemId.FORESTRY_BOOTS).specificOrder(27),
            new StorableItem(ItemId.LUMBERJACK_HAT).specificOrder(28),
            new StorableItem(ItemId.LUMBERJACK_TOP).specificOrder(29),
            new StorableItem(ItemId.LUMBERJACK_LEGS).specificOrder(30),
            new StorableItem(ItemId.LUMBERJACK_BOOTS).specificOrder(31),
            new StorableItem(ItemId.WOODCUTTING_CAPE).specificOrder(32),
            new StorableItem(ItemId.WOODCUTTING_CAPE_TRIMMED).specificOrder(33)
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.FORESTRY_BASKET),
            new TriggerItem(ItemId.FORESTRY_BASKET_OPEN),
        };

        this.triggers = new TriggerBase[]{
            // View contents.
            new OnItemContainerChanged(ItemContainerId.FORESTRY_KIT).itemsConsumer(storageItems -> {
                storage.put(ItemId.ANIMAINFUSED_BARK, storageItems.count(ItemId.ANIMAINFUSED_BARK));
                storage.put(ItemId.FORESTERS_RATION, storageItems.count(ItemId.FORESTERS_RATION));
                storage.put(ItemId.NATURE_OFFERINGS, storageItems.count(ItemId.NATURE_OFFERINGS));
                storage.put(ItemId.SECATEURS_ATTACHMENT, storageItems.count(ItemId.SECATEURS_ATTACHMENT));
                storage.put(ItemId.LEAVES, storageItems.count(ItemId.LEAVES));
                storage.put(ItemId.OAK_LEAVES, storageItems.count(ItemId.OAK_LEAVES));
                storage.put(ItemId.WILLOW_LEAVES, storageItems.count(ItemId.WILLOW_LEAVES));
                storage.put(ItemId.MAPLE_LEAVES, storageItems.count(ItemId.MAPLE_LEAVES));
                storage.put(ItemId.YEW_LEAVES, storageItems.count(ItemId.YEW_LEAVES));
                storage.put(ItemId.MAGIC_LEAVES, storageItems.count(ItemId.MAGIC_LEAVES));
                storage.put(ItemId.FORESTRY_HAT, storageItems.count(ItemId.FORESTRY_HAT));
                storage.put(ItemId.FORESTRY_TOP, storageItems.count(ItemId.FORESTRY_TOP));
                storage.put(ItemId.FORESTRY_LEGS, storageItems.count(ItemId.FORESTRY_LEGS));
                storage.put(ItemId.FORESTRY_BOOTS, storageItems.count(ItemId.FORESTRY_BOOTS));
                storage.put(ItemId.LUMBERJACK_HAT, storageItems.count(ItemId.LUMBERJACK_HAT));
                storage.put(ItemId.LUMBERJACK_TOP, storageItems.count(ItemId.LUMBERJACK_TOP));
                storage.put(ItemId.LUMBERJACK_LEGS, storageItems.count(ItemId.LUMBERJACK_LEGS));
                storage.put(ItemId.LUMBERJACK_BOOTS, storageItems.count(ItemId.LUMBERJACK_BOOTS));
                storage.put(ItemId.WOODCUTTING_CAPE, storageItems.count(ItemId.WOODCUTTING_CAPE));
                storage.put(ItemId.WOODCUTTING_CAPE_TRIMMED, storageItems.count(ItemId.WOODCUTTING_CAPE_TRIMMED));
            }),

            // Get leaves while chopping wood.
            new OnChatMessage("Some (?<leaves>.+) leaves fall to the ground and you place them into your Forestry kit.").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("leaves"), 1));
            }),

            // Get leaves from event.
            new OnChatMessage("You've been awarded (?<amount>.+) piles of (?<leaves>.+) leaves which you put into your Forestry kit.").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("leaves"), Integer.parseInt(m.group("amount"))));
            }),

            // Get bark from an event.
            new OnChatMessage("You've been awarded (?<bark>.+) Anima-infused bark.").matcherConsumer(m -> {
                storage.add(ItemId.ANIMAINFUSED_BARK, Integer.parseInt(m.group("bark")));
            }),

            // Use ration when choping.
            new OnChatMessage("You consume a Forester's ration to fuel a mighty chop.").consumer(() -> {
                storage.removeAndPrioritizeInventory(ItemId.FORESTERS_RATION, 1);
            }),

            // Nature offering used.
            new OnChatMessage("The nature offerings enabled you to chop an extra log").consumer(() -> {
                storage.removeAndPrioritizeInventory(ItemId.NATURE_OFFERINGS, 1);
            }),

            // Out of rations.
            new OnChatMessage("You've eaten your last Forester's ration.").consumer(() -> {
                storage.put(ItemId.FORESTERS_RATION, 0);
            }),

            // Buy items from Friendly Forester by 1.
            new OnMenuOptionClicked("Buy-1").consumer(() -> {
                purchaseFromFriendlyForesterShop(1);
            }),

            // Buy items from Friendly Forester by 5.
            new OnMenuOptionClicked("Buy-5").consumer(() -> {
                purchaseFromFriendlyForesterShop(5);
            }),

            // Buy items from Friendly Forester by 10.
            new OnMenuOptionClicked("Buy-10").consumer(() -> {
                purchaseFromFriendlyForesterShop(10);
            }),

            // Buy items from Friendly Forester by 50.
            new OnMenuOptionClicked("Buy-50").consumer(() -> {
                purchaseFromFriendlyForesterShop(50);
            }),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),

            // Check while empty.
            new OnChatMessage("(Your|The) basket is empty.").onItemClick().emptyStorage().consumer(() -> {
                infernalQuantityTracker = 0;
                lastLogs = Optional.empty();
            }),

            // Empty to bank.
            new OnChatMessage("You empty your basket( into the bank)?.").onItemClick().consumer(() -> {
                emptyLogBasket();
                infernalQuantityTracker = 0;
                lastLogs = Optional.empty();
            }),

            // Check.
            new OnChatMessage("The basket contains:").stringConsumer(s -> {
                final Pattern pattern = Pattern.compile("(?<quantity>\\d+).x.(?<logs>.*?)(,|$)");
                final Matcher matcher = pattern.matcher(s);

                while (matcher.find()) {
                    storage.put(getStorageItemFromName(matcher.group("logs"), Integer.parseInt(matcher.group("quantity"))));
                }

                infernalQuantityTracker = getQuantity();
            }),

            // Miscellania support.
            new OnChatMessage("You get some maple logs and give them to Lumberjack Leif.").requiredItem(ItemId.FORESTRY_BASKET_OPEN).addToStorage(ItemId.MAPLE_LOGS, 0),

            // Chop.
            new OnChatMessage("You get (?<logs>some .+).").matcherConsumer(m -> {
                lastLogs = getStorageItemFromName(m.group("logs"), 1);
                storage.add(lastLogs);
                infernalQuantityTracker++;
            }).requiredItem(ItemId.FORESTRY_BASKET_OPEN),

            // Extra logs from nature offerings.
            new OnChatMessage("The nature offerings enabled you to chop an extra log.").requiredItem(ItemId.FORESTRY_BASKET_OPEN).runConsumerOnNextGameTick(() -> {
                if (lastLogs.isPresent()) {
                    storage.add(lastLogs.get().getId(), 1);
                }
            }),

            new OnItemPickup(storage.getStorableItems()).isByOne().requiredItem(ItemId.FORESTRY_BASKET_OPEN).pickUpToStorage(),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Empty to inventory.
            new OnItemContainerChanged(INVENTORY).onMenuOption("Continue").hasChatMessage("You empty as many logs as you can carry.").emptyStorageToInventory(),

            // Use log on basket.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Empty to bank.
            new OnItemContainerChanged(BANK).emptyStorageToBank().onMenuOption(menuOptionEmptyLogsToBank, menuOptionEmptyLeavesToBank),

            // Fill from bank.
            new OnItemContainerChanged(BANK).onMenuOption(menuOptionFillLeavesFromBank).onBankDifference(itemsDifference -> {
                for (final StorageItem item : itemsDifference.getItems()) {
                    switch (item.getId()) {
                        case ItemId.LEAVES:
                        case ItemId.OAK_LEAVES:
                        case ItemId.WILLOW_LEAVES:
                        case ItemId.MAPLE_LEAVES:
                        case ItemId.YEW_LEAVES:
                        case ItemId.MAGIC_LEAVES:
                            break;
                        default:
                            continue;
                    }
                    storage.add(item.getId(), Math.abs(item.getQuantity()));
                }
            }),

            // Leprechaun.
            new OnMenuOptionClicked("Continue").consumer(() -> {
                final Optional<Widget> bankWoodcuttingResourcesWidget = TicTac7xChargesImprovedPlugin.getWidget(client, 219, 1, 2);
                if (bankWoodcuttingResourcesWidget.isPresent() && bankWoodcuttingResourcesWidget.get().getText().equals("Only bank woodcutting resources")) {
                    emptyLogBasket();
                }
            }),

            // Replace "Use" with proper "Empty/Fill".
            new OnMenuEntryAdded("Use").replaceOptionConsumer(() -> getMenuOptionForUse()).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),

            // Infernal axe support.
            new OnXpDrop(Skill.FIREMAKING).onMenuOption("Chop down", "Cut").consumer(() -> {
                if (infernalQuantityTracker < 29 && lastLogs.isPresent()) {
                    storage.remove(lastLogs.get().getId(), 1);
                    infernalQuantityTracker--;
                }
            }).requiredItem(ItemId.FORESTRY_BASKET_OPEN),
        };
    }

    private void purchaseFromFriendlyForesterShop(final int amountToBuy) {
        final Optional<Widget> forestryShopWidget = TicTac7xChargesImprovedPlugin.getWidget(client, 819, 3);
        if (!forestryShopWidget.isPresent()) return;

        int animaBarkPerItem = 0;
        final int selectedShopItem = client.getVarpValue(3869);
        switch (selectedShopItem) {
            case 0: // Forestry kit
                break;
            case 1: // Secateurs blade
                animaBarkPerItem = 20;
                break;
            case 2: // Ritual mulch
                animaBarkPerItem = 150;
                break;
            case 6: // Log brace
                animaBarkPerItem = 3_000;
                break;
            case 7: // Clothes pouch blueprint
                animaBarkPerItem = 10_000;
                break;
            case 8: // Cape pouch
                animaBarkPerItem = 2_500;
                break;
            case 9: // Log basket
                animaBarkPerItem = 5_000;
                break;
            case 10: // Felling axe handle
                animaBarkPerItem = 10_000;
                break;
            case 11: // Twitcher's gloves
                animaBarkPerItem = 5_000;
                break;
            case 12: // Funky shaped log
                animaBarkPerItem = 15_000;
                break;
            case 13: // Sawmill voucher (x10)
                animaBarkPerItem = 150;
                break;
            case 14: // Lumberjack boots
                animaBarkPerItem = 1_000;
                break;
            case 15: // Lumberjack hat
                animaBarkPerItem = 1_200;
                break;
            case 16: // Lumberjack legs
                animaBarkPerItem = 1_300;
                break;
            case 17: // Lumberjack top
                animaBarkPerItem = 1_500;
                break;
            case 18: // Forestry boots
            case 19: // Forestry hat
            case 20: // Forestry legs
            case 21: // Forestry top
                animaBarkPerItem = 1_250;
                break;
        }

        storage.removeAndPrioritizeInventory(ItemId.ANIMAINFUSED_BARK, animaBarkPerItem * amountToBuy);
    }

    private String getMenuOptionForUse() {
        return isLogsInBasket()
            ? menuOptionEmptyLogsToBank
            : isLeavesInBasket()
                ? menuOptionEmptyLeavesToBank
                : menuOptionFillLeavesFromBank;
    }

    private void emptyLogBasket() {
        storage.put(ItemId.LOGS, 0);
        storage.put(ItemId.ACHEY_TREE_LOGS, 0);
        storage.put(ItemId.OAK_LOGS, 0);
        storage.put(ItemId.WILLOW_LOGS, 0);
        storage.put(ItemId.TEAK_LOGS, 0);
        storage.put(ItemId.JUNIPER_LOGS, 0);
        storage.put(ItemId.MAPLE_LOGS, 0);
        storage.put(ItemId.MAHOGANY_LOGS, 0);
        storage.put(ItemId.ARCTIC_PINE_LOGS, 0);
        storage.put(ItemId.YEW_LOGS, 0);
        storage.put(ItemId.BLISTERWOOD_LOGS, 0);
        storage.put(ItemId.MAGIC_LOGS, 0);
        storage.put(ItemId.REDWOOD_LOGS, 0);
    }

    private boolean isLogsInBasket() {
        for (final StorageItem storageItem : storage.getStorage().getItems()) {
            if (storageItem.getQuantity() == 0) continue;

            switch (storageItem.getId()) {
                case ItemId.LOGS:
                case ItemId.ACHEY_TREE_LOGS:
                case ItemId.OAK_LOGS:
                case ItemId.WILLOW_LOGS:
                case ItemId.TEAK_LOGS:
                case ItemId.JUNIPER_LOGS:
                case ItemId.MAPLE_LOGS:
                case ItemId.MAHOGANY_LOGS:
                case ItemId.ARCTIC_PINE_LOGS:
                case ItemId.YEW_LOGS:
                case ItemId.BLISTERWOOD_LOGS:
                case ItemId.MAGIC_LOGS:
                case ItemId.REDWOOD_LOGS:
                    return true;
            }
        }
        return false;
    }

    private boolean isLeavesInBasket() {
        for (final StorageItem storageItem : storage.getStorage().getItems()) {
            if (storageItem.getQuantity() == 0) continue;

            switch (storageItem.getId()) {
                case ItemId.LEAVES:
                case ItemId.OAK_LEAVES:
                case ItemId.WILLOW_LEAVES:
                case ItemId.MAPLE_LEAVES:
                case ItemId.YEW_LEAVES:
                case ItemId.MAGIC_LEAVES:
                    return true;
            }
        }
        return false;
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.OnResetDaily;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class B_FremennikSeaBoots extends ChargedItem {
    public B_FremennikSeaBoots(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.fremennik_sea_boots, ItemId.FREMENNIK_SEA_BOOTS_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.FREMENNIK_SEA_BOOTS_1),
            new TriggerItem(ItemId.FREMENNIK_SEA_BOOTS_2),
            new TriggerItem(ItemId.FREMENNIK_SEA_BOOTS_3),
            new TriggerItem(ItemId.FREMENNIK_SEA_BOOTS_4).fixedCharges(Charges.UNLIMITED),
        };

        this.triggers = new TriggerBase[]{
            // Try to teleport while empty.
            new OnChatMessage("You have already used your available teleport for today. Try again tomorrow when the boots have recharged.").setFixedCharges(0),

            // Teleport.
            new OnGraphicChanged(111).onItemClick().decreaseCharges(1),

            // Daily reset.
            new OnResetDaily().specificItem(ItemId.FREMENNIK_SEA_BOOTS_1).setFixedCharges(1),
            new OnResetDaily().specificItem(ItemId.FREMENNIK_SEA_BOOTS_2).setFixedCharges(1),
            new OnResetDaily().specificItem(ItemId.FREMENNIK_SEA_BOOTS_3).setFixedCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.*;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;

public class U_SeedBox extends ChargedItemWithStorage {
    public U_SeedBox(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.seed_box, ItemId.SEED_BOX, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.SEED_BOX),
            new TriggerItem(ItemId.SEED_BOX_OPEN),
        };

        this.storage.storableItems(
            new StorableItem(ItemId.POTATO_SEED).checkName("potato"),
            new StorableItem(ItemId.ONION_SEED).checkName("onion"),
            new StorableItem(ItemId.CABBAGE_SEED).checkName("cabbage"),
            new StorableItem(ItemId.TOMATO_SEED).checkName("tomato"),
            new StorableItem(ItemId.SWEETCORN_SEED).checkName("sweetcorn"),
            new StorableItem(ItemId.STRAWBERRY_SEED).checkName("strawberry"),
            new StorableItem(ItemId.WATERMELON_SEED).checkName("watermelon"),
            new StorableItem(ItemId.SNAPE_GRASS_SEED).checkName("snape"),
            new StorableItem(ItemId.BARLEY_SEED).checkName("barley"),
            new StorableItem(ItemId.HAMMERSTONE_SEED).checkName("hammerstone"),
            new StorableItem(ItemId.ASGARNIAN_SEED).checkName("asgarnian"),
            new StorableItem(ItemId.JUTE_SEED).checkName("jute"),
            new StorableItem(ItemId.YANILLIAN_SEED).checkName("vanillian"),
            new StorableItem(ItemId.KRANDORIAN_SEED).checkName("krandorian"),
            new StorableItem(ItemId.WILDBLOOD_SEED).checkName("wildblood"),
            new StorableItem(ItemId.ACORN).checkName("acorn"),
            new StorableItem(ItemId.WILLOW_SEED).checkName("willow"),
            new StorableItem(ItemId.MAPLE_SEED).checkName("maple"),
            new StorableItem(ItemId.YEW_SEED).checkName("yew"),
            new StorableItem(ItemId.MAGIC_SEED).checkName("magic"),
            new StorableItem(ItemId.REDWOOD_TREE_SEED).checkName("redwood"),
            new StorableItem(ItemId.PINEAPPLE_SEED).checkName("pineapple"),
            new StorableItem(ItemId.APPLE_TREE_SEED).checkName("apple"),
            new StorableItem(ItemId.BANANA_TREE_SEED).checkName("banana"),
            new StorableItem(ItemId.ORANGE_TREE_SEED).checkName("orange"),
            new StorableItem(ItemId.CURRY_TREE_SEED).checkName("curry"),
            new StorableItem(ItemId.PAPAYA_TREE_SEED).checkName("papaya"),
            new StorableItem(ItemId.PALM_TREE_SEED).checkName("palm"),
            new StorableItem(ItemId.DRAGONFRUIT_TREE_SEED).checkName("dragonfruit"),
            new StorableItem(ItemId.REDBERRY_SEED).checkName("redberry"),
            new StorableItem(ItemId.CADAVABERRY_SEED).checkName("cadavaberry"),
            new StorableItem(ItemId.DWELLBERRY_SEED).checkName("dwellberry"),
            new StorableItem(ItemId.JANGERBERRY_SEED).checkName("jangerberry"),
            new StorableItem(ItemId.WHITEBERRY_SEED).checkName("whiteberry"),
            new StorableItem(ItemId.POISON_IVY_SEED).checkName("poison ivy"),
            new StorableItem(ItemId.MARIGOLD_SEED).checkName("marigold"),
            new StorableItem(ItemId.ROSEMARY_SEED).checkName("rosemary"),
            new StorableItem(ItemId.NASTURTIUM_SEED).checkName("nasturtium"),
            new StorableItem(ItemId.WOAD_SEED).checkName("woad"),
            new StorableItem(ItemId.LIMPWURT_SEED).checkName("limpwurt"),
            new StorableItem(ItemId.WHITE_LILY_SEED).checkName("white lily"),
            new StorableItem(ItemId.GUAM_SEED).checkName("guam"),
            new StorableItem(ItemId.MARRENTILL_SEED).checkName("marrentill"),
            new StorableItem(ItemId.TARROMIN_SEED).checkName("tarromin"),
            new StorableItem(ItemId.HARRALANDER_SEED).checkName("harralander"),
            new StorableItem(ItemId.RANARR_SEED).checkName("ranarr"),
            new StorableItem(ItemId.TOADFLAX_SEED).checkName("toadflax"),
            new StorableItem(ItemId.IRIT_SEED).checkName("irit"),
            new StorableItem(ItemId.AVANTOE_SEED).checkName("avantoe"),
            new StorableItem(ItemId.HUASCA_SEED).checkName("huasca"),
            new StorableItem(ItemId.KWUARM_SEED).checkName("kwuarm"),
            new StorableItem(ItemId.SNAPDRAGON_SEED).checkName("snapdragon"),
            new StorableItem(ItemId.CADANTINE_SEED).checkName("cadantine"),
            new StorableItem(ItemId.LANTADYME_SEED).checkName("lantadyme"),
            new StorableItem(ItemId.DWARF_WEED_SEED).checkName("dwarf weed"),
            new StorableItem(ItemId.TORSTOL_SEED).checkName("torstol"),
            new StorableItem(ItemId.SEAWEED_SPORE).checkName("seaweed spore"),
            new StorableItem(ItemId.TEAK_SEED).checkName("teak"),
            new StorableItem(ItemId.GRAPE_SEED).checkName("grape"),
            new StorableItem(ItemId.MUSHROOM_SPORE).checkName("mushroom spore"),
            new StorableItem(ItemId.MAHOGANY_SEED).checkName("mahogany"),
            new StorableItem(ItemId.POTATO_CACTUS_SEED).checkName("potato cactus"),
            new StorableItem(ItemId.CACTUS_SEED).checkName("cactus"),
            new StorableItem(ItemId.BELLADONNA_SEED).checkName("belladonna"),
            new StorableItem(ItemId.HESPORI_SEED).checkName("hespori"),
            new StorableItem(ItemId.CALQUAT_TREE_SEED).checkName("calquat"),
            new StorableItem(ItemId.CRYSTAL_ACORN).checkName("crystal acorn"),
            new StorableItem(ItemId.KRONOS_SEED).checkName("kronos"),
            new StorableItem(ItemId.IASOR_SEED).checkName("iasor"),
            new StorableItem(ItemId.ATTAS_SEED).checkName("attas"),
            new StorableItem(ItemId.SPIRIT_SEED).checkName("spirit"),
            new StorableItem(ItemId.CELASTRUS_SEED).checkName("celastrus")
        );

        this.triggers = new TriggerBase[] {
            // Check or empty.
            new OnChatMessage("(The|Your) seed box is( now| already)? empty.").emptyStorage(),

            // Empty into inventory.
            new OnChatMessage("Emptied (?<quantity>.+) x (?<seed>.+)( seed)? to your inventory.").matcherConsumer(m -> {
                storage.remove(getStorageItemFromName(m.group("seed"), Integer.parseInt(m.group("quantity"))));
            }),

            // Store.
            new OnChatMessage("Stored (?<quantity>.+) x (?<seed>.+)( seed)? in your seed box.").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("seed"), Integer.parseInt(m.group("quantity"))));
            }),

            // Pickup.
            new OnChatMessage("You put (?<quantity>.+) x (?<seed>.+)( seed)? straight into your open seed box.").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("seed"), Integer.parseInt(m.group("quantity"))));
            }),

            // Check.
            new OnItemContainerChanged(ItemContainerId.SEED_BOX).updateStorage(),

            // Replace "Empty" with proper "Empty to bank".
            new OnMenuEntryAdded("Empty").replaceOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide()
        };
    }

    private int getSeedIdFromName(final String seed) {
        switch (seed.toLowerCase().replace(" seed", "")) {
            // Allotments.
            case "potato":
                return ItemId.POTATO_SEED;
            case "onion":
                return ItemId.ONION_SEED;
            case "cabbage":
                return ItemId.CABBAGE_SEED;
            case "tomato":
                return ItemId.TOMATO_SEED;
            case "sweetcorn":
                return ItemId.SWEETCORN_SEED;
            case "strawberry":
                return ItemId.STRAWBERRY_SEED;
            case "watermelon":
                return ItemId.WATERMELON_SEED;
            case "snape grass":
                return ItemId.SNAPE_GRASS_SEED;

            // Hops.
            case "barley":
                return ItemId.BARLEY_SEED;
            case "hammerstone":
                return ItemId.HAMMERSTONE_SEED;
            case "asgarnian":
                return ItemId.ASGARNIAN_SEED;
            case "jute":
                return ItemId.JUTE_SEED;
            case "yanillian":
                return ItemId.YANILLIAN_SEED;
            case "krandorian":
                return ItemId.KRANDORIAN_SEED;
            case "wildblood":
                return ItemId.WILDBLOOD_SEED;

            // Trees.
            case "acorn":
                return ItemId.ACORN;
            case "willow":
                return ItemId.WILLOW_SEED;
            case "maple":
                return ItemId.MAPLE_SEED;
            case "yew":
                return ItemId.YEW_SEED;
            case "magic":
                return ItemId.MAGIC_SEED;
            case "redwood tree":
                return ItemId.REDWOOD_TREE_SEED;

            // Fruit trees.
            case "apple tree":
                return ItemId.APPLE_TREE_SEED;
            case "banana tree":
                return ItemId.BANANA_TREE_SEED;
            case "orange tree":
                return ItemId.ORANGE_TREE_SEED;
            case "curry tree":
                return ItemId.CURRY_TREE_SEED;
            case "pineapple":
                return ItemId.PINEAPPLE_SEED;
            case "papaya tree":
                return ItemId.PAPAYA_TREE_SEED;
            case "palm tree":
                return ItemId.PALM_TREE_SEED;
            case "dragonfruit tree":
                return ItemId.DRAGONFRUIT_TREE_SEED;

            // Bushes.
            case "redberry":
                return ItemId.REDBERRY_SEED;
            case "cadavaberry":
                return ItemId.CADAVABERRY_SEED;
            case "dwellberry":
                return ItemId.DWELLBERRY_SEED;
            case "jangerberry":
                return ItemId.JANGERBERRY_SEED;
            case "whiteberry":
                return ItemId.WHITEBERRY_SEED;
            case "poison ivy":
                return ItemId.POISON_IVY_SEED;

            // Flowers.
            case "marigold":
                return ItemId.MARIGOLD_SEED;
            case "rosemary":
                return ItemId.ROSEMARY_SEED;
            case "nasturtium":
                return ItemId.NASTURTIUM_SEED;
            case "woad":
                return ItemId.WOAD_SEED;
            case "limpwurt":
                return ItemId.LIMPWURT_SEED;
            case "white lily":
                return ItemId.WHITE_LILY_SEED;

            // Herbs.
            case "guam":
                return ItemId.GUAM_SEED;
            case "marrentill":
                return ItemId.MARRENTILL_SEED;
            case "tarromin":
                return ItemId.TARROMIN_SEED;
            case "harralander":
                return ItemId.HARRALANDER_SEED;
            case "ranarr":
                return ItemId.RANARR_SEED;
            case "toadflax":
                return ItemId.TOADFLAX_SEED;
            case "irit":
                return ItemId.IRIT_SEED;
            case "avantoe":
                return ItemId.AVANTOE_SEED;
            case "kwuarm":
                return ItemId.KWUARM_SEED;
            case "snapdragon":
                return ItemId.SNAPDRAGON_SEED;
            case "cadantine":
                return ItemId.CADANTINE_SEED;
            case "lantadyme":
                return ItemId.LANTADYME_SEED;
            case "dwarf weed":
                return ItemId.DWARF_WEED_SEED;
            case "torstol":
                return ItemId.TORSTOL_SEED;

            // Special seeds.
            case "seaweed spore":
                return ItemId.SEAWEED_SPORE;
            case "teak":
                return ItemId.TEAK_SEED;
            case "grape":
                return ItemId.GRAPE_SEED;
            case "mushroom spore":
                return ItemId.MUSHROOM_SPORE;
            case "mahogany":
                return ItemId.MAHOGANY_SEED;
            case "cactus":
                return ItemId.CACTUS_SEED;
            case "belladonna":
                return ItemId.BELLADONNA_SEED;
            case "potato cactus":
                return ItemId.POTATO_CACTUS_SEED;
            case "hespori":
                return ItemId.HESPORI_SEED;
            case "calquat tree":
                return ItemId.CALQUAT_TREE_SEED;
            case "crystal acorn":
                return ItemId.CRYSTAL_ACORN;
            case "kronos":
                return ItemId.KRONOS_SEED;
            case "iasor":
                return ItemId.IASOR_SEED;
            case "attas":
                return ItemId.ATTAS_SEED;
            case "spirit":
                return ItemId.SPIRIT_SEED;
            case "celastrus":
                return ItemId.CELASTRUS_SEED;
        }

        return Charges.UNKNOWN;
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_GricollersCan extends ChargedItem {
    public U_GricollersCan(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.gricollers_can, ItemId.GRICOLLERS_CAN, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.GRICOLLERS_CAN),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Watering can charges remaining: (?<charges>.+)%").setDynamicallyCharges().onItemClick(),

            // Water inventory item.
            new OnChatMessage("You water").onItemClick().decreaseCharges(1),

            // Fill.
            new OnChatMessage("You fill the watering can").onItemClick().setFixedCharges(1000),

            // Water.
            new OnGraphicChanged(410).decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class J_SkillsNecklace extends ChargedItem {
    public J_SkillsNecklace(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.skills_necklace, ItemId.SKILLS_NECKLACE_0, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.SKILLS_NECKLACE_0).fixedCharges(0),
            new TriggerItem(ItemId.SKILLS_NECKLACE_1).fixedCharges(1),
            new TriggerItem(ItemId.SKILLS_NECKLACE_2).fixedCharges(2),
            new TriggerItem(ItemId.SKILLS_NECKLACE_3).fixedCharges(3),
            new TriggerItem(ItemId.SKILLS_NECKLACE_4).fixedCharges(4),
            new TriggerItem(ItemId.SKILLS_NECKLACE_5).fixedCharges(5),
            new TriggerItem(ItemId.SKILLS_NECKLACE_6).fixedCharges(6),
        };

        this.triggers = new TriggerBase[] {
            // Unified menu entry.
            new OnMenuEntryAdded("Rub").replaceOption("Teleport"),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.AnimationId;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class W_SlayerStaffE extends ChargedItem {
    public W_SlayerStaffE(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.slayer_staff_e, ItemId.SLAYER_STAFF_ENCHANTED, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.SLAYER_STAFF_ENCHANTED)
        };

        this.triggers = new TriggerBase[] {
            // Enchant.
            new OnChatMessage("The spell enchants your staff. The tatty parchment crumbles to dust.").setFixedCharges(2500),

            // Check.
            new OnChatMessage("Your staff has (?<charges>.+) charges?.").setDynamicallyCharges(),

            // Attack.
            new OnAnimationChanged(AnimationId.SLAYER_STAFF_CAST).isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_PharaohsSceptre extends ChargedItem {
    public W_PharaohsSceptre(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.pharaohs_sceptre, ItemId.PHARAOHS_SCEPTRE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.PHARAOHS_SCEPTRE_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.PHARAOHS_SCEPTRE_INITIAL),
            new TriggerItem(ItemId.PHARAOHS_SCEPTRE),
        };
        
        this.triggers = new TriggerBase[]{
            // Check and automatic messages.
            new OnChatMessage("Your sceptre has (?<charges>.+) charges? left.").setDynamicallyCharges().onItemClick(),

            // Charge non-empty sceptre.
            new OnChatMessage("Right, you already had .+ charges?, and I don't give discounts. That means .+ artefacts gives you (?<charges>.+) charges?. Now be on your way.").increaseDynamically(),

            // Charge empty sceptre.
            new OnChatMessage("Right, .+ artefacts gives you (?<charges>.+) charges. Now be on your way.").setDynamicallyCharges(),

            // Teleport.
            new OnGraphicChanged(715).decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.HitsplatTarget;
import tictac7x.charges.store.Store;

public class W_ScytheOfVitur extends ChargedItem {
    public W_ScytheOfVitur(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.scythe_of_vitur, ItemId.SCYTHE_OF_VITUR, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.SCYTHE_OF_VITUR),
            new TriggerItem(ItemId.SCYTHE_OF_VITUR_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.HOLY_SCYTHE_OF_VITUR),
            new TriggerItem(ItemId.HOLY_SCYTHE_OF_VITUR_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.SANGUINE_SCYTHE_OF_VITUR),
            new TriggerItem(ItemId.SANGUINE_SCYTHE_OF_VITUR_UNCHARGED).fixedCharges(0),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Your (Holy s|Sanguine s|[Ss])cythe (of vitur )?has (?<charges>.+) charges (remaining|left).").setDynamicallyCharges(),

            // Charge partially full.
            new OnChatMessage("You apply an additional .+ charges to your (Holy s|Sanguine s|S)cythe of vitur. It now has (?<charges>.+) charges in total.").setDynamicallyCharges(),

            // Charge empty.
            new OnChatMessage("You apply (?<charges>.+) charges to your (Holy s|Sanguine s|S)cythe of vitur.").setDynamicallyCharges(),

            // Attack.
            new OnHitsplatApplied(HitsplatTarget.ENEMY).moreThanZeroDamage().oncePerGameTick().isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class F_SunlightMothMix extends ChargedItem {
    public F_SunlightMothMix(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.sunlight_moth_mix, ItemId.SUNLIGHT_MOTH_MIX_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.SUNLIGHT_MOTH_MIX_1).fixedCharges(1),
            new TriggerItem(ItemId.SUNLIGHT_MOTH_MIX_2).fixedCharges(2),
        };
    }

    @Override
    public String getTooltip() {
        return "Sunlight moth mix: " + getTotalCharges();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class S_Chronicle extends ChargedItem {
    public S_Chronicle(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.chronicle, ItemId.CHRONICLE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.CHRONICLE),
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("Your book has (?<charges>.+) charges? left.").setDynamicallyCharges().onItemClick()
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_TridentOfTheSeas extends ChargedItem {
    public W_TridentOfTheSeas(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.trident_of_the_seas, ItemId.TRIDENT_OF_THE_SEAS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TRIDENT_OF_THE_SEAS_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.TRIDENT_OF_THE_SEAS),
            new TriggerItem(ItemId.TRIDENT_OF_THE_SEAS_FULL).fixedCharges(2500),
        };

        this.triggers = new TriggerBase[] {
            // Ran out of charges.
            new OnChatMessage("Your Trident of the seas has run out of charges.").notification().setFixedCharges(0),

            // Check, one charge left.
            new OnChatMessage("Your Trident of the seas has one charge.").setFixedCharges(1),

            // Check for charges and warning when low.
            new OnChatMessage("Your Trident of the seas( only)? has (?<charges>.+) charges( left)?.").setDynamicallyCharges(),

            // Charge to full.
            new OnChatMessage("You add .* charges? to the Trident of the seas. New total: (?<charges>.+)").setDynamicallyCharges(),

            // Attack.
            new OnGraphicChanged(1251).isEquipped().decreaseCharges(1),

            // Auto-charge.
            new OnChatMessage("The banker charges your Trident of the seas using (?<deathrune>.+)x Death rune.*").matcherConsumer(m -> {
                final int deathRunes = Integer.parseInt(m.group("deathrune"));
                increaseCharges(deathRunes);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnWidgetLoaded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_DodgyNecklace extends ChargedItem {
    public J_DodgyNecklace(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.dodgy_necklace, ItemId.DODGY_NECKLACE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.DODGY_NECKLACE).needsToBeEquipped(),
        };
        
        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your dodgy necklace has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Protects.
            new OnChatMessage("Your dodgy necklace protects you. It has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Breaks.
            new OnChatMessage("Your dodgy necklace protects you. It then crumbles to dust.").setFixedCharges(10).notification("Your dodgy necklace crumbles to dust."),

            // Break.
            new OnChatMessage("The necklace shatters. Your next dodgy necklace will start afresh from (?<charges>.+) charges.").setDynamicallyCharges(),

            new OnWidgetLoaded(219, 1, 0).text("Status: (?<charges>.+) charges? left.").setDynamically().onItemClick(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.VarbitId;

public class C_MagicCape extends ChargedItem {
    public C_MagicCape(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.magic_cape, ItemId.MAGIC_CAPE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.MAGIC_CAPE),
            new TriggerItem(ItemId.MAGIC_CAPE_TRIMMED)
        };

        this.triggers = new TriggerBase[] {
            new OnVarbitChanged(VarbitId.MAGIC_CAPE_CHARGES_USED).varbitValueConsumer(chargesUsed -> setCharges(5 - chargesUsed)),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class J_PendantOfAtes extends ChargedItem {
    public J_PendantOfAtes(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.pendant_of_ates, ItemId.PENDANT_OF_ATES, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.PENDANT_OF_ATES_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.PENDANT_OF_ATES),
        };

        this.triggers = new TriggerBase[]{
            // Check empty.
            new OnChatMessage("The pendant has no charges.").setFixedCharges(0).onItemClick(),

            // Check.
            new OnChatMessage("The pendant has (?<charges>.+) charges?.").setDynamicallyCharges().onItemClick(),

            // Charge.
            new OnChatMessage("You add .+ frozen tears? to your pendant. It now has (?<charges>.+) charges.").setDynamicallyCharges(),

            // Uncharge.
            new OnChatMessage("You uncharge your pendant by removing (?<charges>.+) frozen tears? from it.").decreaseDynamicallyCharges(),

            // Teleport.
            new OnGraphicChanged(2754).decreaseCharges(1),

            // Auto-charge.
            new OnChatMessage("The banker charges your Pendant of ates using (?<frozentear>.+)x Frozen tear.").matcherConsumer(m -> {
                final int frozenTear = Integer.parseInt(m.group("frozentear"));
                increaseCharges(frozenTear);
            }),

            // Unified menu entry.
            new OnMenuEntryAdded("Rub").replaceOption("Teleport"),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class J_GiantsoulAmulet extends ChargedItem {
    public J_GiantsoulAmulet(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.giantsoul_amulet, ItemId.GIANTSOUL_AMULET, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.GIANTSOUL_AMULET_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.GIANTSOUL_AMULET),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your Giantsoul amulet has (?<charges>.+) charges? left powering it.").setDynamicallyCharges(),

            // Charge.
            new OnChatMessage("You add .+ charges? to your Giantsoul amulet, giving it a total of (?<charges>.+) charges?.").setDynamicallyCharges(),

            // Teleport.
            new OnGraphicChanged(3226).decreaseCharges(1),

            // Auto-charge.
            new OnChatMessage("The banker charges your Giantsoul amulet using (?<bigbones>.+)x Big bones.*").matcherConsumer(m -> {
                final int bigBones = Integer.parseInt(m.group("bigbones"));
                increaseCharges(bigBones);
            }),

            // Unified menu entry.
            new OnMenuEntryAdded("Rub").replaceOption("Teleport"),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_ExpeditiousBracelet extends ChargedItem {
    public J_ExpeditiousBracelet(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.expeditious_bracelet, ItemId.EXPEDITIOUS_BRACELET, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.EXPEDITIOUS_BRACELET).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your expeditious bracelet has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Charge used.
            new OnChatMessage("Your expeditious bracelet helps you progress your slayer( task)? faster. It has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Bracelet fully used.
            new OnChatMessage("Your expeditious bracelet helps you progress your slayer faster. It then crumbles to dust.").setFixedCharges(30).notification("Your expeditious bracelet crumbles to dust."),

            // Break.
            new OnChatMessage("The bracelet shatters. Your next expeditious bracelet will start afresh from (?<charges>.+) charges.").setDynamicallyCharges(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStatus;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_AshSanctifier extends ChargedItemWithStatus {
    public U_AshSanctifier(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ash_sanctifier, ItemId.ASH_SANCTIFIER, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.ASH_SANCTIFIER),
        };
        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("(The|Your) ash sanctifier has (?<charges>.+) charges?( left)?. It has been deactivated").setDynamicallyCharges().deactivate(),
            new OnChatMessage("(The|Your) ash sanctifier has (?<charges>.+) charges?( left)?. It is active").setDynamicallyCharges().activate(),
            new OnChatMessage("(The|Your) ash sanctifier has (?<charges>.+) charges?( left)?.").setDynamicallyCharges(),

            // Activate.
            new OnChatMessage("The ash sanctifier is active and ready to scatter ashes.").activate(),

            // Deactivate.
            new OnChatMessage("The ash sanctifier has been deactivated, and will not scatter ashes now.").deactivate(),

            // Automatic scatter.
            new OnXpDrop(Skill.PRAYER).isActivated().decreaseCharges(1),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),

            // Auto-charge.
            new OnChatMessage("The banker charges your Ash sanctifier using (?<deathrune>.+)x Death rune.").matcherConsumer(m -> {
                final int deathRunes = Integer.parseInt(m.group("deathrune"));
                increaseCharges(deathRunes * 10);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_ToxicStaffOfTheDead extends ChargedItem {
    public W_ToxicStaffOfTheDead(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.toxic_staff_of_the_dead, ItemId.TOXIC_STAFF_OF_THE_DEAD, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TOXIC_STAFF_OF_THE_DEAD_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.TOXIC_STAFF_OF_THE_DEAD)
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("Scales: (?<charges>.+)").setDynamicallyCharges(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_FlamtaerBracelet extends ChargedItem {
    public J_FlamtaerBracelet(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.flamtaer_bracelet, ItemId.FLAMTAER_BRACELET, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.FLAMTAER_BRACELET).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[]{
            new OnChatMessage("Your Flamtaer bracelet helps you build the temple quicker. It has (?<charges>.+) charges? left.").setDynamicallyCharges(),
            new OnChatMessage("Your flamtaer bracelet has (?<charges>.+) charges? left.").setDynamicallyCharges(),
            new OnChatMessage("Your Flamtaer bracelet helps you build the temple quicker. It then crumbles to dust.").setFixedCharges(80).notification("Your flamtaer bracelet crumbles to dust."),
            new OnChatMessage("The bracelet shatters. Your next Flamtaer bracelet will star afresh from 80 charges.").setFixedCharges(80)
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;

import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.WidgetId;

import java.awt.*;
import java.util.Optional;

import static tictac7x.charges.TicTac7xChargesImprovedPlugin.getNumberFromWordRepresentation;
import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_ColossalPouch extends ChargedItemWithStorage {
    public U_ColossalPouch(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.colossal_pouch, ItemId.COLOSSAL_POUCH, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.storage = storage.storableItems(
            new StorableItem(ItemId.RUNE_ESSENCE),
            new StorableItem(ItemId.PURE_ESSENCE),
            new StorableItem(ItemId.DAEYALT_ESSENCE),
            new StorableItem(ItemId.GUARDIAN_ESSENCE)
        ).setMaximumTotalQuantity(40).setHoldsSingleType(true);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.COLOSSAL_POUCH),
            new TriggerItem(ItemId.COLOSSAL_POUCH_DEGRADED),
        };

        this.triggers = new TriggerBase[]{
            // Empty.
            new OnChatMessage("There is no essence in this pouch.").emptyStorage(),

            // Guardians of the rift.
            new OnChatMessage("The rift becomes active!").consumer(() -> {
                storage.put(ItemId.GUARDIAN_ESSENCE, 0);
            }),
            new OnVarbitChanged(13691, 0).consumer(() -> {
                storage.put(ItemId.GUARDIAN_ESSENCE, 0);
            }),

            // Check.
            new OnChatMessage("There (is|are) (?<quantity>.+?) (?<essence>normal|pure|daeyalt|guardian|normal) essences? in this pouch.").matcherConsumer((m) -> {
                final int quantity = getNumberFromWordRepresentation(m.group("quantity"));

                int essenceId;
                switch (m.group("essence")) {
                    case "normal":
                        essenceId = ItemId.RUNE_ESSENCE;
                        break;
                    case "pure":
                        essenceId = ItemId.PURE_ESSENCE;
                        break;
                    case "daeyalt":
                        essenceId = ItemId.DAEYALT_ESSENCE;
                        break;
                    case "guardian":
                        essenceId = ItemId.GUARDIAN_ESSENCE;
                        break;
                    default:
                        return;
                }

                storage.clearAndPut(essenceId, quantity);
            }).onMenuOption("Check"),

            // Decay.
            new OnChatMessage("Your pouch has decayed through use.").onMenuOption("Fill").consumer(() -> {
                configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.colossal_pouch_decay_count, config.getColossalPouchDecayCount() + 1);
                storage.setMaximumTotalQuantity(getPouchCapacity());
            }),

            // Repair.
            new OnChatMessage("Fine. A simple transfiguration spell should resolve things for you.").consumer(() -> {
                configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.colossal_pouch_decay_count, 0);
                storage.setMaximumTotalQuantity(getPouchCapacity());
            }),

            // Fill from inventory.
            new OnMenuOptionClicked("Fill").runConsumerOnNextGameTick(() -> {
                if (store.inventoryContainsItem(ItemId.GUARDIAN_ESSENCE)) {
                    storage.add(ItemId.GUARDIAN_ESSENCE, store.getInventoryItemQuantity(ItemId.GUARDIAN_ESSENCE));
                } else if (store.inventoryContainsItem(ItemId.DAEYALT_ESSENCE)) {
                    storage.add(ItemId.DAEYALT_ESSENCE, store.getInventoryItemQuantity(ItemId.DAEYALT_ESSENCE));
                } else if (store.inventoryContainsItem(ItemId.PURE_ESSENCE)) {
                    storage.add(ItemId.PURE_ESSENCE, store.getInventoryItemQuantity(ItemId.PURE_ESSENCE));
                } else if (store.inventoryContainsItem(ItemId.RUNE_ESSENCE)) {
                    storage.add(ItemId.RUNE_ESSENCE, store.getInventoryItemQuantity(ItemId.RUNE_ESSENCE));
                }
            }),

            // Use essence on pouch.
            new OnMenuOptionClicked("Use").menuOptionConsumer(advancedMenuEntry -> {
                final Optional<StorageItem> essence = getStorageItemFromName(advancedMenuEntry.target, 0);
                if (essence.isPresent()) {
                    essence.get().setQuantity(store.getInventoryItemQuantity(essence.get().getId()));
                    store.nextTickQueue.add(() -> storage.add(essence));
                }
            }).onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Empty to inventory.
            new OnMenuOptionClicked("Empty").runConsumerOnNextGameTick(() -> {
                storage.emptyToInventoryWithoutItemContainerChanged();
            }),

            // Empty to inventory at bank.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).onMenuOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToInventory).emptyStorageToInventory(),

            // Fill from inventory at bank.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption(TicTac7xChargesImprovedPlugin.menuOptionFillFromInventory),

            // Replace "Fill" with proper Fill/Empty option.
            new OnMenuEntryAdded("Fill").replaceOptionConsumer(() -> getMenuOptionForUse()).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),
            new OnMenuEntryAdded("Fill").replaceOptionConsumer(() -> getMenuOptionForUse()).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Set maximum charges on level up
            new OnStatChanged(Skill.RUNECRAFT).consumer(() -> {
                storage.setMaximumTotalQuantity(getPouchCapacity());
            }),
        };
    }

    private String getMenuOptionForUse() {
        return (storage.isStorableItemInInventory() || storage.isEmpty())
            ? TicTac7xChargesImprovedPlugin.menuOptionFillFromInventory
            : TicTac7xChargesImprovedPlugin.menuOptionEmptyToInventory;
    }

    @Override
    public Color getTextColor() {
        if (storage.isFull()) {
            if (config.getColossalPouchDecayCount() == 0) {
                return config.getColorActivated();
            } else {
                return config.getColorEmpty();
            }
        }

        return super.getTextColor();
    }

    private final int[] CAPACITY_85 = {40, 35, 30, 25, 20, 15, 10, 5};
    private final int[] CAPACITY_75 = {27, 23, 20, 16, 13, 10, 6, 3};
    private final int[] CAPACITY_50 = {16, 14, 12, 10, 8, 6, 4, 2};
    private final int[] CAPACITY_25 = {8, 5, 2}; // TODO: verify these

    public int getPouchCapacity() {
        final int decayCount = config.getColossalPouchDecayCount();
        final int runecraftLevel = this.client.getRealSkillLevel(Skill.RUNECRAFT);

        if (runecraftLevel >= 85) {
            return CAPACITY_85[Math.min(CAPACITY_85.length - 1, decayCount)];
        } else if (runecraftLevel >= 75) {
            return CAPACITY_75[Math.min(CAPACITY_75.length - 1, decayCount)];
        } else if (runecraftLevel >= 50) {
            return CAPACITY_50[Math.min(CAPACITY_50.length - 1, decayCount)];
        } else if (runecraftLevel >= 25) {
            return CAPACITY_25[Math.min(CAPACITY_25.length - 1, decayCount)];
        } else {
            return 0;
        }
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;

public class J_BraceletOfClay extends ChargedItem {
    public J_BraceletOfClay(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.bracelet_of_clay, ItemId.BRACELET_OF_CLAY, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BRACELET_OF_CLAY).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("You can mine (?<charges>.+) more pieces? of soft clay before your bracelet crumbles to dust.").setDynamicallyCharges(),

            // Mine clay.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).isEquipped().onMenuOption("Mine").onMenuTarget("Clay rocks").consumer(() -> {
                final int clayBefore = store.getPreviousInventoryItemQuantity(ItemId.SOFT_CLAY);
                final int clayAfter = store.getInventoryItemQuantity(ItemId.SOFT_CLAY);
                decreaseCharges(clayAfter - clayBefore);
            }),

            // Mine soft clay.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).isEquipped().onMenuOption("Mine").onMenuTarget("Soft clay rocks").consumer(() -> {
                final int clayBefore = store.getPreviousInventoryItemQuantity(ItemId.SOFT_CLAY);
                final int clayAfter = store.getInventoryItemQuantity(ItemId.SOFT_CLAY);

                // At least 2 soft clay was mined.
                if (clayAfter - clayBefore >= 2) {
                    decreaseCharges(1);
                }
            }),

            // Crumbles.
            new OnChatMessage("Your bracelet of clay crumbles to dust.").setFixedCharges(28).notification("Your clay bracelet crumbles to dust.")
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.WidgetId;

import static tictac7x.charges.store.ItemContainerId.INVENTORY;
import static tictac7x.charges.store.ItemContainerId.BANK;

public class U_GemBag extends ChargedItemWithStorage {
    public U_GemBag(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.gem_bag, ItemId.GEM_BAG, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.GEM_BAG),
            new TriggerItem(ItemId.GEM_BAG_OPEN),
        };

        storage.setMaximumIndividualQuantity(60).storableItems(
            new StorableItem(ItemId.UNCUT_SAPPHIRE).checkName("Sapphire").specificOrder(1),
            new StorableItem(ItemId.UNCUT_EMERALD).checkName("Emerald").specificOrder(2),
            new StorableItem(ItemId.UNCUT_RUBY).checkName("Ruby").specificOrder(3),
            new StorableItem(ItemId.UNCUT_DIAMOND).checkName("Diamond").specificOrder(4),
            new StorableItem(ItemId.UNCUT_DRAGONSTONE).checkName("Dragonstone").specificOrder(5)
        );

        this.triggers = new TriggerBase[]{
            // Empty to bank or inventory.
            new OnChatMessage("The gem bag is( now)? empty.").emptyStorage(),

            // Empty and Check.
            new OnChatMessage("(Left in bag: )?Sapphires: (?<sapphires>.+) / Emeralds: (?<emeralds>.+) / Rubies: (?<rubies>.+) Diamonds: (?<diamonds>.+) / Dragonstones: (?<dragonstones>.+)").matcherConsumer(m -> {
                storage.put(ItemId.UNCUT_SAPPHIRE, Integer.parseInt(m.group("sapphires")));
                storage.put(ItemId.UNCUT_EMERALD, Integer.parseInt(m.group("emeralds")));
                storage.put(ItemId.UNCUT_RUBY, Integer.parseInt(m.group("rubies")));
                storage.put(ItemId.UNCUT_DIAMOND, Integer.parseInt(m.group("diamonds")));
                storage.put(ItemId.UNCUT_DRAGONSTONE, Integer.parseInt(m.group("dragonstones")));
            }),

            // Mining regular or gem rocks.
            new OnChatMessage("You just (found|mined) (a|an) (?<gem>.+)!").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("gem"), 1));
            }).requiredItem(ItemId.GEM_BAG_OPEN),

            // Pickpocketing.
            new OnChatMessage("The following stolen loot gets added to your gem bag: Uncut (?<gem>.+) x (?<quantity>.+).").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("gem"), Integer.parseInt(m.group("quantity"))));
            }),

            // Stealing from stalls.
            new OnChatMessage("You steal an uncut (?<gem>.+) and add it to your gem bag.").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("gem"), 1));
            }),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Empty to bank.
            new OnItemContainerChanged(BANK).emptyStorageToBank().onMenuOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank),

            // Use gem on bag
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseChargedItemOnStorageItem(storage.getStorableItems()),
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Pick up.
            new OnItemPickup(storage.getStorableItems()).isByOne().requiredItem(ItemId.GEM_BAG_OPEN).pickUpToStorage(),

            // Telegrab.
            new OnXpDrop(Skill.MAGIC).requiredItem(ItemId.GEM_BAG_OPEN).onMenuOption("Cast").onMenuTarget(
                "Uncut sapphire"
            ).addToStorage(ItemId.UNCUT_SAPPHIRE, 1),
            new OnXpDrop(Skill.MAGIC).requiredItem(ItemId.GEM_BAG_OPEN).onMenuOption("Cast").onMenuTarget(
                "Uncut emerald"
            ).addToStorage(ItemId.UNCUT_EMERALD, 1),
            new OnXpDrop(Skill.MAGIC).requiredItem(ItemId.GEM_BAG_OPEN).onMenuOption("Cast").onMenuTarget(
                "Uncut ruby"
            ).addToStorage(ItemId.UNCUT_RUBY, 1),
            new OnXpDrop(Skill.MAGIC).requiredItem(ItemId.GEM_BAG_OPEN).onMenuOption("Cast").onMenuTarget(
                "Uncut diamond"
            ).addToStorage(ItemId.UNCUT_DIAMOND, 1),
            new OnXpDrop(Skill.MAGIC).requiredItem(ItemId.GEM_BAG_OPEN).onMenuOption("Cast").onMenuTarget(
                "Uncut dragonstone"
            ).addToStorage(ItemId.UNCUT_DRAGONSTONE, 1),

            // Replace "Empty" with proper "Empty to bank".
            new OnMenuEntryAdded("Empty").replaceOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_SoulBearer extends ChargedItem {
    public U_SoulBearer(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.soul_bearer, ItemId.SOUL_BEARER, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.SOUL_BEARER),
            new TriggerItem(ItemId.SOUL_BEARER_UNCHARGED).fixedCharges(0),
        };

        this.triggers = new TriggerBase[] {
            // Uncharge.
            new OnChatMessage("You remove the runes from the soul bearer.").setFixedCharges(0),

            // Check.
            new OnChatMessage("(The|Your) soul bearer( now)? has (?<charges>.+) charges.").setDynamicallyCharges(),

            // Check.
            new OnChatMessage("(The|Your) soul bearer( now)? has one charge.").setFixedCharges(1),

            // Charge.
            new OnChatMessage("You add .+ charges? to your soul bearer. It now has (?<charges>.+) charges?.").setDynamicallyCharges(),

            // Charge used.
            new OnChatMessage("Your soul bearer carries the ensouled heads to your bank. It has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Last charge used.
            new OnChatMessage("Your soul bearer carries the ensouled heads to your bank. It has run out of charges.").notification().setFixedCharges(0),

            // Auto-charge.
            new OnChatMessage("The banker charges your Soul bearer using (?<bloodrune>.+)x Blood rune.*").matcherConsumer(m -> {
                final int bloodRunes = Integer.parseInt(m.group("bloodrune"));
                increaseCharges(bloodRunes);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_TridentOfTheSwampE extends ChargedItem {
    public W_TridentOfTheSwampE(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.trident_of_the_swamp_e, ItemId.TRIDENT_OF_THE_SWAMP_ENCHANTED, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TRIDENT_OF_THE_SWAMP_ENCHANTED_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.TRIDENT_OF_THE_SWAMP_ENCHANTED),
        };

        this.triggers = new TriggerBase[] {
            // Ran out of charges.
            new OnChatMessage("Your Trident of the swamp \\(e\\) has run out of charges.").notification().setFixedCharges(0),

            // Check, one charge left.
            new OnChatMessage("Your Trident of the swamp \\(e\\) has one charge.").setFixedCharges(1),

            // Check for charges and warning when low.
            new OnChatMessage("Your Trident of the swamp \\(e\\)( only)? has (?<charges>.+) charges( left)?.").setDynamicallyCharges(),

            // Charge to full.
            new OnChatMessage("You add .* charges? to the Trident of the swamp \\(e\\). New total: (?<charges>.+)").setDynamicallyCharges(),

            // Attack.
            new OnGraphicChanged(1251).isEquipped().decreaseCharges(1),

            // Auto-charge.
            new OnChatMessage("The banker charges your Trident of the swamp \\(e\\) using (?<deathrune>.+)x Death rune.*").matcherConsumer(m -> {
                final int deathRunes = Integer.parseInt(m.group("deathrune"));
                increaseCharges(deathRunes);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.Varbits;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorageMultipleCharges;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

class ExplorersRingStorageItemId {
    public static final int TELEPORTS = -1000;
    public static final int ALCHEMY = -1001;
    public static final int ENERGY_RESTORES = -1002;
}

public class J_ExplorersRing extends ChargedItemWithStorageMultipleCharges {
    public J_ExplorersRing(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.explorers_ring, ItemId.EXPLORERS_RING_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage = storage.storableItems(
            new StorableItem(ExplorersRingStorageItemId.ALCHEMY).displayName("Alchemy charges"),
            new StorableItem(ExplorersRingStorageItemId.TELEPORTS).displayName("Teleports"),
            new StorableItem(ExplorersRingStorageItemId.ENERGY_RESTORES).displayName("Energy restores")
        ).showIndividualCharges();

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.EXPLORERS_RING_1),
            new TriggerItem(ItemId.EXPLORERS_RING_2),
            new TriggerItem(ItemId.EXPLORERS_RING_3),
            new TriggerItem(ItemId.EXPLORERS_RING_4),
        };

        this.triggers = new TriggerBase[]{
            // Use.
            new OnVarbitChanged(Varbits.EXPLORER_RING_ALCHS).consumer(() -> updateStorage()),
            new OnVarbitChanged(Varbits.EXPLORER_RING_RUNENERGY).consumer(() -> updateStorage()),
            new OnVarbitChanged(Varbits.EXPLORER_RING_TELEPORTS).consumer(() -> updateStorage()),

            // Check.
            new OnMenuOptionClicked("Check").onItemClick().consumer(() -> updateStorage()),

            new OnResetDaily().specificItem(ItemId.EXPLORERS_RING_1).consumer(() -> {
                storage.clear();
                storage.put(ExplorersRingStorageItemId.ALCHEMY, 30);
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 2);
                storage.put(ExplorersRingStorageItemId.TELEPORTS, 0);
            }),

            new OnResetDaily().specificItem(ItemId.EXPLORERS_RING_2).consumer(() -> {
                storage.clear();
                storage.put(ExplorersRingStorageItemId.ALCHEMY, 30);
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 3);
                storage.put(ExplorersRingStorageItemId.TELEPORTS, 3);
            }),

            new OnResetDaily().specificItem(ItemId.EXPLORERS_RING_3).consumer(() -> {
                storage.clear();
                storage.put(ExplorersRingStorageItemId.ALCHEMY, 30);
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 4);
                storage.put(ExplorersRingStorageItemId.TELEPORTS, Charges.UNLIMITED);
            }),

            new OnResetDaily().specificItem(ItemId.EXPLORERS_RING_4).consumer(() -> {
                storage.clear();
                storage.put(ExplorersRingStorageItemId.ALCHEMY, 30);
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 3);
                storage.put(ExplorersRingStorageItemId.TELEPORTS, Charges.UNLIMITED);
            }),
        };
    }

    private void updateStorage() {
        storage.clear();

        // Alchemy.
        storage.put(ExplorersRingStorageItemId.ALCHEMY, 30 - client.getVarbitValue(Varbits.EXPLORER_RING_ALCHS));

        // Energy restores.
        final int energyRestoresUsed = client.getVarbitValue(Varbits.EXPLORER_RING_RUNENERGY);
        switch (itemId) {
            case ItemId.EXPLORERS_RING_1:
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 2 - energyRestoresUsed);
                break;
            case ItemId.EXPLORERS_RING_2:
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 3 - energyRestoresUsed);
                break;
            case ItemId.EXPLORERS_RING_3:
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 4 - energyRestoresUsed);
                break;
            case ItemId.EXPLORERS_RING_4:
                storage.put(ExplorersRingStorageItemId.ENERGY_RESTORES, 3 - energyRestoresUsed);
                break;
        }

        // Teleports.
        final int teleportsUsed = client.getVarbitValue(Varbits.EXPLORER_RING_TELEPORTS);
        switch (itemId) {
            case ItemId.EXPLORERS_RING_1:
                storage.put(ExplorersRingStorageItemId.TELEPORTS, 0);
                break;
            case ItemId.EXPLORERS_RING_2:
                storage.put(ExplorersRingStorageItemId.TELEPORTS, 3 - teleportsUsed);
                break;
            case ItemId.EXPLORERS_RING_3:
            case ItemId.EXPLORERS_RING_4:
                storage.put(ExplorersRingStorageItemId.TELEPORTS, Charges.UNLIMITED);
                break;
        }
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class F_BlackWarlockMix extends ChargedItem {
    public F_BlackWarlockMix(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.black_warlock_mix, ItemId.BLACK_WARLOCK_MIX_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BLACK_WARLOCK_MIX_1).fixedCharges(1),
            new TriggerItem(ItemId.BLACK_WARLOCK_MIX_2).fixedCharges(2),
        };
    }

    @Override
    public String getTooltip() {
        return "Black warlock mix: " + getTotalCharges();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_IbansStaff extends ChargedItem {
    public W_IbansStaff(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ibans_staff, ItemId.IBANS_STAFF, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.IBANS_STAFF),
            new TriggerItem(ItemId.IBANS_STAFF_BROKEN),
            new TriggerItem(ItemId.IBANS_STAFF_UPGRADED),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("You have (?<charges>.+) charges left on the staff.").setDynamicallyCharges().onItemClick(),

            // Attack.
            new OnGraphicChanged(87).isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class W_WesternBanner extends ChargedItem {
    public W_WesternBanner(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.western_banner, ItemId.WESTERN_BANNER_3, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.WESTERN_BANNER_3),
            new TriggerItem(ItemId.WESTERN_BANNER_4).fixedCharges(Charges.UNLIMITED),
        };

        this.triggers = new TriggerBase[]{
            // Teleport.
            new OnMenuOptionClicked("Teleport").hasItemId(ItemId.WESTERN_BANNER_3).setFixedCharges(0),

            // Teleport already used.
            new OnChatMessage("You have already used your available teleports for today. Try again tomorrow after the standard has recharged.").onItemClick().setFixedCharges(0),

            // Daily reset.
            new OnResetDaily().requiredItem(ItemId.WESTERN_BANNER_3).setFixedCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.WidgetId;

import static tictac7x.charges.store.ItemContainerId.BANK;
import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_FurPouch extends ChargedItemWithStorage {
    public U_FurPouch(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.fur_pouch, ItemId.FUR_POUCH_SMALL, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.storage = storage
            .storableItems(
                // Tracking.
                new StorableItem(ItemId.POLAR_KEBBIT_FUR),
                new StorableItem(ItemId.COMMON_KEBBIT_FUR),
                new StorableItem(ItemId.FELDIP_WEASEL_FUR),
                new StorableItem(ItemId.DESERT_DEVIL_FUR),

                // Deadfall.
                new StorableItem(ItemId.FOX_FUR),

                // Pitfalls.
                new StorableItem(ItemId.LARUPIA_FUR),
                new StorableItem(ItemId.GRAAHK_FUR),
                new StorableItem(ItemId.KYATT_FUR),
                new StorableItem(ItemId.SUNLIGHT_ANTELOPE_FUR),
                new StorableItem(ItemId.MOONLIGHT_ANTELOPE_FUR),

                // Aerial.
                new StorableItem(ItemId.SPOTTED_KEBBIT_FUR),
                new StorableItem(ItemId.DARK_KEBBIT_FUR),
                new StorableItem(ItemId.DASHING_KEBBIT_FUR)
            );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.FUR_POUCH_SMALL).maxCharges(14),
            new TriggerItem(ItemId.FUR_POUCH_SMALL_OPEN).maxCharges(14),
            new TriggerItem(ItemId.FUR_POUCH_MEDIUM).maxCharges(21),
            new TriggerItem(ItemId.FUR_POUCH_MEDIUM_OPEN).maxCharges(21),
            new TriggerItem(ItemId.FUR_POUCH_LARGE).maxCharges(28),
            new TriggerItem(ItemId.FUR_POUCH_LARGE_OPEN).maxCharges(28),
        };

        this.triggers = new TriggerBase[]{
            // Empty.
            new OnChatMessage("Your fur pouch is currently holding 0 fur.").emptyStorage(),
            new OnChatMessage("Your fur pouch is empty.").emptyStorage(),

            // Fill from inventory.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Empty to inventory.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).emptyStorageToInventory().onMenuOption("Empty"),

            // Empty to bank.
            new OnItemContainerChanged(BANK).emptyStorageToBank().onMenuOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank),

            // Empty from deposit box.
            new OnMenuOptionClicked(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank).onItemClick().isWidgetVisible(WidgetId.DEPOSIT_BOX).emptyStorage(),

            // Use fur on pouch.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Replace "Empty" with proper "Empty to bank".
            new OnMenuEntryAdded("Empty").replaceOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Hide destroy option.
            new OnMenuEntryAdded("Destroy").hide(),

            // Tracking.
            new OnChatMessage("You manage to noose a polar kebbit that is hiding in the snowdrift.").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).addToStorage(ItemId.POLAR_KEBBIT_FUR),
            new OnChatMessage("You manage to noose a common kebbit that is hiding in the bush.").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).addToStorage(ItemId.COMMON_KEBBIT_FUR),
            new OnChatMessage("You manage to noose a Feldip weasel that is hiding in the bush.").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).addToStorage(ItemId.FELDIP_WEASEL_FUR),
            new OnChatMessage("You manage to noose a desert devil that is hiding in the sand.").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).addToStorage(ItemId.DESERT_DEVIL_FUR),

            // Deadfalls.
            new OnChatMessage("You've caught a pyre fox.").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).addToStorage(ItemId.FOX_FUR),

            // Pitfalls.
            new OnChatMessage("You've caught a spined larupia!").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).addToStorage(ItemId.LARUPIA_FUR),
            new OnItemContainerChanged(ItemContainerId.INVENTORY).hasChatMessage("You've caught a spined larupia!").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).onInventoryDifference(itemsDifference -> {
                if (itemsDifference.hasItem(ItemId.LARUPIA_FUR_TATTY)) {
                    storage.remove(ItemId.LARUPIA_FUR, 1);
                }
            }),
            new OnChatMessage("You've caught a horned graahk!").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).addToStorage(ItemId.GRAAHK_FUR),
            new OnItemContainerChanged(ItemContainerId.INVENTORY).hasChatMessage("You've caught a horned graahk!").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).onInventoryDifference(itemsDifference -> {
                if (itemsDifference.hasItem(ItemId.GRAAHK_FUR_TATTY)) {
                    storage.remove(ItemId.GRAAHK_FUR, 1);
                }
            }),
            new OnChatMessage("You've caught a sabre-?toothed kyatt!").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).addToStorage(ItemId.KYATT_FUR),
            new OnItemContainerChanged(ItemContainerId.INVENTORY).hasChatMessage("You've caught a sabre-?toothed kyatt!").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).onInventoryDifference(itemsDifference -> {
                if (itemsDifference.hasItem(ItemId.KYATT_FUR_TATTY)) {
                    storage.remove(ItemId.KYATT_FUR, 1);
                }
            }),
            new OnChatMessage("You've caught a sunlight antelope!").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).addToStorage(ItemId.SUNLIGHT_ANTELOPE_FUR),
            new OnChatMessage("You've caught a moonlight antelope!").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).addToStorage(ItemId.MOONLIGHT_ANTELOPE_FUR),

            // Aerial.
            new OnXpDrop(Skill.HUNTER, 104).hasChatMessage("You retrieve the falcon as well as the fur of the dead kebbit.").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).consumer(() -> {
                storage.add(ItemId.SPOTTED_KEBBIT_FUR, 1);
            }),
            new OnXpDrop(Skill.HUNTER, 132).hasChatMessage("You retrieve the falcon as well as the fur of the dead kebbit.").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).consumer(() -> {
                storage.add(ItemId.DARK_KEBBIT_FUR, 1);
            }),
            new OnXpDrop(Skill.HUNTER, 156).hasChatMessage("You retrieve the falcon as well as the fur of the dead kebbit.").requiredItem(ItemId.FUR_POUCH_SMALL_OPEN, ItemId.FUR_POUCH_MEDIUM_OPEN, ItemId.FUR_POUCH_LARGE_OPEN).consumer(() -> {
                storage.add(ItemId.DASHING_KEBBIT_FUR, 1);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class S_TomeOfWater extends ChargedItem {
    public S_TomeOfWater(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.tome_of_water, ItemId.TOME_OF_WATER, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TOME_OF_WATER_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.TOME_OF_WATER).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your tome currently holds (?<charges>.+) charges?.").setDynamicallyCharges().onItemClick(),

            // Attack with regular spellbook water spells.
            new OnGraphicChanged(93, 120, 135, 161, 1458).isEquipped().decreaseCharges(1),

            // Auto-charge.
            new OnChatMessage("The banker charges your Tome of fire using (?<soakedpage>.+)x Soaked page.").matcherConsumer(m -> {
                final int soakedPages = Integer.parseInt(m.group("soakedpage"));
                increaseCharges(soakedPages * 20);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.Skill;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.WidgetId;

import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static tictac7x.charges.store.ItemContainerId.BANK;
import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_LogBasket extends ChargedItemWithStorage {
    private Optional<StorageItem> lastLogs = Optional.empty();
    private int infernalQuantityTracker = 0;

    public U_LogBasket(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.log_basket, ItemId.LOG_BASKET, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage.setMaximumTotalQuantity(28).storableItems(
            new StorableItem(ItemId.LOGS).displayName("Regular logs").checkName("some logs", "x Logs"),
            new StorableItem(ItemId.ACHEY_TREE_LOGS).checkName("Achey tree logs"),
            new StorableItem(ItemId.OAK_LOGS).checkName("Oak logs"),
            new StorableItem(ItemId.WILLOW_LOGS).checkName("Willow logs"),
            new StorableItem(ItemId.TEAK_LOGS).checkName("Teak logs"),
            new StorableItem(ItemId.JUNIPER_LOGS).checkName("Juniper logs"),
            new StorableItem(ItemId.MAPLE_LOGS).checkName("Maple logs"),
            new StorableItem(ItemId.MAHOGANY_LOGS).checkName("Mahogany logs"),
            new StorableItem(ItemId.ARCTIC_PINE_LOGS).checkName("Arctic pine logs"),
            new StorableItem(ItemId.YEW_LOGS).checkName("Yew logs"),
            new StorableItem(ItemId.BLISTERWOOD_LOGS).checkName("Blisterwood logs"),
            new StorableItem(ItemId.MAGIC_LOGS).checkName("Magic logs"),
            new StorableItem(ItemId.REDWOOD_LOGS).checkName("Redwood logs")
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.LOG_BASKET),
            new TriggerItem(ItemId.LOG_BASKET_OPEN),
        };
        this.triggers = new TriggerBase[] {
            // Check while empty.
            new OnChatMessage("(Your|The) basket is empty.").onItemClick().emptyStorage().consumer(() -> {
                infernalQuantityTracker = 0;
                lastLogs = Optional.empty();
            }),

            // Empty to bank.
            new OnChatMessage("You empty your basket( into the bank)?.").onItemClick().emptyStorage().consumer(() -> {
                infernalQuantityTracker = 0;
                lastLogs = Optional.empty();
            }),

            // Check.
            new OnChatMessage("The basket contains:").stringConsumer(s -> {
                storage.clear();

                final Pattern pattern = Pattern.compile("(?<quantity>\\d+).x.(?<logs>.*?)(,|$)");
                final Matcher matcher = pattern.matcher(s);

                while (matcher.find()) {
                    storage.put(getStorageItemFromName(matcher.group("logs"), Integer.parseInt(matcher.group("quantity"))));
                }

                infernalQuantityTracker = getQuantity();
            }).onItemClick(),

            // Miscellania support.
            new OnChatMessage("You get some maple logs and give them to Lumberjack Leif.").requiredItem(ItemId.LOG_BASKET_OPEN).addToStorage(ItemId.MAPLE_LOGS, 0),

            // Chop.
            new OnChatMessage("You get (?<logs>some .+).").matcherConsumer(m -> {
                lastLogs = getStorageItemFromName(m.group("logs"), 1);
                storage.add(lastLogs);
                infernalQuantityTracker++;
            }).requiredItem(ItemId.LOG_BASKET_OPEN),

            // Extra logs from nature offerings.
            new OnChatMessage("The nature offerings enabled you to chop an extra log.").requiredItem(ItemId.LOG_BASKET_OPEN).runConsumerOnNextGameTick(() -> {
                if (lastLogs.isPresent()) {
                    storage.add(lastLogs.get().getId(), 1);
                }
            }),

            new OnItemPickup(storage.getStorableItems()).isByOne().requiredItem(ItemId.LOG_BASKET_OPEN).pickUpToStorage(),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Fully empty to inventory.
            new OnChatMessage("You empty your basket.").emptyStorage(),

            // Partially empty to inventory.
            new OnItemContainerChanged(INVENTORY).onMenuOption("Continue").hasChatMessage("You empty as many logs as you can carry.").emptyStorageToInventory(),

            // Use log on basket.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Empty to bank.
            new OnItemContainerChanged(BANK).emptyStorageToBank().onMenuOption("Empty", TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank),

            // Leprechaun.
            new OnMenuOptionClicked("Continue").consumer(() -> {
                final Optional<Widget> bankWoodcuttingResourcesWidget = TicTac7xChargesImprovedPlugin.getWidget(client, 219, 1, 2);
                if (bankWoodcuttingResourcesWidget.isPresent() && bankWoodcuttingResourcesWidget.get().getText().equals("Only bank woodcutting resources")) {
                    storage.clear();
                }
            }),

            // Replace "Empty" with proper Empty to bank option.
            new OnMenuEntryAdded("Empty").replaceOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),

            // Infernal axe support.
            new OnXpDrop(Skill.FIREMAKING).onMenuOption("Chop down", "Cut").consumer(() -> {
                if (infernalQuantityTracker < 29 && lastLogs.isPresent()) {
                    storage.remove(lastLogs.get().getId(), 1);
                    infernalQuantityTracker--;
                }
            }).requiredItem(ItemId.LOG_BASKET_OPEN),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import static tictac7x.charges.store.HitsplatTarget.SELF;

public class A_CrystalLegs extends ChargedItem {
    public A_CrystalLegs(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.crystal_legs, ItemId.CRYSTAL_LEGS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.CRYSTAL_LEGS),
            new TriggerItem(ItemId.CRYSTAL_LEGS_HEFIN),
            new TriggerItem(ItemId.CRYSTAL_LEGS_ITHELL),
            new TriggerItem(ItemId.CRYSTAL_LEGS_IORWERTH),
            new TriggerItem(ItemId.CRYSTAL_LEGS_TRAHAEARN),
            new TriggerItem(ItemId.CRYSTAL_LEGS_CADARN),
            new TriggerItem(ItemId.CRYSTAL_LEGS_CRWYS),
            new TriggerItem(ItemId.CRYSTAL_LEGS_AMLODD),
            new TriggerItem(ItemId.CRYSTAL_LEGS_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_LEGS_HEFIN_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_LEGS_ITHELL_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_LEGS_IORWERTH_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_LEGS_TRAHAEARN_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_LEGS_CADARN_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_LEGS_CRWYS_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_LEGS_AMLODD_INACTIVE).fixedCharges(0),
        };

        this.triggers = new TriggerBase[]{
            new OnChatMessage("Your crystal legs has (?<charges>.+) charges? remaining").setDynamicallyCharges().onItemClick(),
            new OnHitsplatApplied(SELF).isEquipped().decreaseCharges(1)
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class W_BowOfFaerdhinen extends ChargedItem {
    public W_BowOfFaerdhinen(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.bow_of_faerdhinen, ItemId.BOW_OF_FAERDHINEN, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BOW_OF_FAERDHINEN_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.BOW_OF_FAERDHINEN),
            new TriggerItem(ItemId.BOW_OF_FAERDHINEN_CORRUPTED).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemId.BOW_OF_FAERDHINEN_CORRUPTED_ITHELL).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemId.BOW_OF_FAERDHINEN_CORRUPTED_IORWERTH).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemId.BOW_OF_FAERDHINEN_CORRUPTED_TRAHAEARN).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemId.BOW_OF_FAERDHINEN_CORRUPTED_CADARN).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemId.BOW_OF_FAERDHINEN_CORRUPTED_CRWYS).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemId.BOW_OF_FAERDHINEN_CORRUPTED_MEILYR).fixedCharges(Charges.UNLIMITED),
            new TriggerItem(ItemId.BOW_OF_FAERDHINEN_CORRUPTED_AMLODD).fixedCharges(Charges.UNLIMITED),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your bow of Faerdhinen has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Attack.
            new OnGraphicChanged(1888).isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;

public class C_Coffin extends ChargedItemWithStorage {
    public C_Coffin(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.coffin, ItemId.GOLD_COFFIN, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.storage = storage.storableItems(
            new StorableItem(ItemId.LOAR_REMAINS).checkName("Loar"),
            new StorableItem(ItemId.PHRIN_REMAINS).checkName("Phrin"),
            new StorableItem(ItemId.RIYL_REMAINS).checkName("Riyl"),
            new StorableItem(ItemId.ASYN_REMAINS).checkName("Asyn"),
            new StorableItem(ItemId.FIYR_REMAINS).checkName("Fiyr"),
            new StorableItem(ItemId.URIUM_REMAINS).checkName("Urium")
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BROKEN_COFFIN).fixedCharges(0),
            new TriggerItem(ItemId.BRONZE_COFFIN).maxCharges(3),
            new TriggerItem(ItemId.BRONZE_COFFIN_OPEN).maxCharges(3),
            new TriggerItem(ItemId.STEEL_COFFIN).maxCharges(8),
            new TriggerItem(ItemId.STEEL_COFFIN_OPEN).maxCharges(8),
            new TriggerItem(ItemId.BLACK_COFFIN).maxCharges(14),
            new TriggerItem(ItemId.BLACK_COFFIN_OPEN).maxCharges(14),
            new TriggerItem(ItemId.SILVER_COFFIN).maxCharges(20),
            new TriggerItem(ItemId.SILVER_COFFIN_OPEN).maxCharges(20),
            new TriggerItem(ItemId.GOLD_COFFIN).maxCharges(28),
            new TriggerItem(ItemId.GOLD_COFFIN_OPEN).maxCharges(28),
        };

        this.triggers = new TriggerBase[] {
            // Add remains to coffin.
            new OnChatMessage("You put the (?<remains>.+) remains into your open coffin.").matcherConsumer(m -> {
                storage.add(getStorageItemFromName(m.group("remains"), 1));
            }),

            // Check.
            new OnChatMessage("Loar (?<loar>.+) / Phrin (?<phrin>.+) / Riyl (?<riyl>.+) / Asyn (?<asyn>.+) / Fiyr (?<fiyr>.+) / Urium (?<urium>.+)").matcherConsumer(m -> {
                storage.clear();
                storage.put(ItemId.LOAR_REMAINS, Integer.parseInt(m.group("loar")));
                storage.put(ItemId.PHRIN_REMAINS, Integer.parseInt(m.group("phrin")));
                storage.put(ItemId.RIYL_REMAINS, Integer.parseInt(m.group("riyl")));
                storage.put(ItemId.ASYN_REMAINS, Integer.parseInt(m.group("asyn")));
                storage.put(ItemId.FIYR_REMAINS, Integer.parseInt(m.group("fiyr")));
                storage.put(ItemId.URIUM_REMAINS, Integer.parseInt(m.group("urium")));
            }),

            // Try to empty already empty.
            new OnChatMessage("Your coffin is empty.").onItemClick().emptyStorage(),

            // Fill from inventory.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class U_CrystalSaw extends ChargedItem {
    public U_CrystalSaw(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.crystal_saw, ItemId.CRYSTAL_SAW, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.CRYSTAL_SAW),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your saw has (?<charges>.+) charges? left.").setDynamicallyCharges(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStatus;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_BoneCrusher extends ChargedItemWithStatus {
    public U_BoneCrusher(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.bonecrusher, ItemId.BONECRUSHER, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BONECRUSHER),
            new TriggerItem(ItemId.BONECRUSHER_NECKLACE)
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("The bonecrusher( necklace)? has no charges.").setFixedCharges(0),
            new OnChatMessage("The bonecrusher( necklace)? has one charge.").setFixedCharges(1),
            new OnChatMessage("(The|Your) bonecrusher( necklace)? has (?<charges>.+) charges?( left)?. It is active").setDynamicallyCharges().activate(),
            new OnChatMessage("(The|Your) bonecrusher( necklace)? has (?<charges>.+) charges?( left)?. It has been deactivated").setDynamicallyCharges().deactivate(),
            new OnChatMessage("(The|Your) bonecrusher( necklace)? has (?<charges>.+) charges?( left)?.").setDynamicallyCharges(),

            // Uncharge.
            new OnChatMessage("You remove all the charges from the bonecrusher( necklace)?.").setFixedCharges(0),

            // Ran out.
            new OnChatMessage("Your bonecrusher( necklace)? has run out of charges.").notification().setFixedCharges(0),

            // Activate.
            new OnChatMessage("The bonecrusher( necklace)? has been deactivated").deactivate(),

            // Deactivate.
            new OnChatMessage("The bonecrusher( necklace)? is active").activate(),

            // Automatic bury.
            new OnXpDrop(Skill.PRAYER).isActivated().decreaseCharges(1),

            // Auto-charge.
            new OnChatMessage("The banker charges your Bonecrusher( necklace)? using (?<ectotoken>.+)x Ecto-token.").matcherConsumer(m -> {
                final int ectoTokens = Integer.parseInt(m.group("ectotoken"));
                increaseCharges(ectoTokens * 25);
            }),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_CastleWarsBracelet extends ChargedItem {
    public J_CastleWarsBracelet(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.castle_wars_bracelet, ItemId.CASTLE_WARS_BRACELET_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.CASTLE_WARS_BRACELET_1).fixedCharges(1).needsToBeEquipped(),
            new TriggerItem(ItemId.CASTLE_WARS_BRACELET_2).fixedCharges(2).needsToBeEquipped(),
            new TriggerItem(ItemId.CASTLE_WARS_BRACELET_3).fixedCharges(3).needsToBeEquipped(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_GamesNecklace extends ChargedItem {
    public J_GamesNecklace(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.games_necklace, ItemId.GAMES_NECKLACE_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.GAMES_NECKLACE_1).fixedCharges(1),
            new TriggerItem(ItemId.GAMES_NECKLACE_2).fixedCharges(2),
            new TriggerItem(ItemId.GAMES_NECKLACE_3).fixedCharges(3),
            new TriggerItem(ItemId.GAMES_NECKLACE_4).fixedCharges(4),
            new TriggerItem(ItemId.GAMES_NECKLACE_5).fixedCharges(5),
            new TriggerItem(ItemId.GAMES_NECKLACE_6).fixedCharges(6),
            new TriggerItem(ItemId.GAMES_NECKLACE_7).fixedCharges(7),
            new TriggerItem(ItemId.GAMES_NECKLACE_8).fixedCharges(8),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class W_SanguinestiStaff extends ChargedItem {
    public W_SanguinestiStaff(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.sanguinesti_staff, ItemId.SANGUINESTI_STAFF, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.SANGUINESTI_STAFF),
            new TriggerItem(ItemId.SANGUINESTI_STAFF_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.SANGUINESTI_STAFF_HOLY),
            new TriggerItem(ItemId.SANGUINESTI_STAFF_HOLY_UNCHARGED).fixedCharges(0),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your (Holy s|S)anguinesti staff has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Charge partially full.
            new OnChatMessage("You apply an additional .+ charges? to your Sanguinesti staff. It now has (?<charges>.+) charges? in total.").setDynamicallyCharges(),

            // Charge empty.
            new OnChatMessage("You apply (?<charges>.+) charges to your Sanguinesti staff.").setDynamicallyCharges(),

            // Auto-charge.
            new OnChatMessage("The banker charges your (Holy s|S)anguinesti staff using (?<bloodrune>.+)x Blood rune.").matcherConsumer(m -> {
                final int bloodRunes = Integer.parseInt(m.group("bloodrune"));
                increaseCharges(bloodRunes / 3);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

import java.util.Optional;

public class J_RingOfEndurance extends ChargedItem {
    public J_RingOfEndurance(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_endurance, ItemId.RING_OF_ENDURANCE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.RING_OF_ENDURANCE),
            new TriggerItem(ItemId.RING_OF_ENDURANCE_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.RING_OF_ENDURANCE_NOCHARGES).fixedCharges(0),
        };

        this.triggers = new TriggerBase[] {
            // Charge.
            new OnChatMessage("You load your Ring of endurance with (?<charges>.+) stamina doses?.").increaseDynamically(),

            // Check.
            new OnChatMessage("Your Ring of endurance is charged with (?<charges>.+) stamina doses?.").setDynamicallyCharges(),

            // Use charge.
            new OnChatMessage("Your Ring of endurance doubles the duration of your stamina potion's effect.").decreaseCharges(1),

            // Uncharge.
            new OnMenuOptionClicked("Yes").runConsumerOnNextGameTick(() -> {
                final Optional<Widget> unchargeWidget = TicTac7xChargesImprovedPlugin.getWidget(client, 584, 0, 2);
                if (unchargeWidget.isPresent() && unchargeWidget.get().getText().equals("Are you sure you want to uncharge your Ring of endurance?")) {
                    setCharges(0);
                }
            }),
        };
    }
}
package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStatus;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.HitsplatTarget;
import tictac7x.charges.store.Store;

public class J_RingOfSuffering extends ChargedItemWithStatus {
    public J_RingOfSuffering(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_suffering, ItemId.RING_OF_SUFFERING_UNCHARGED, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.RING_OF_SUFFERING_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.RING_OF_SUFFERING_UNCHARGED_IMBUED_NMZ).fixedCharges(0),
            new TriggerItem(ItemId.RING_OF_SUFFERING_UNCHARGED_IMBUED_SW).fixedCharges(0),
            new TriggerItem(ItemId.RING_OF_SUFFERING_UNCHARGED_IMBUED_PVP).fixedCharges(0),
            new TriggerItem(ItemId.RING_OF_SUFFERING),
            new TriggerItem(ItemId.RING_OF_SUFFERING_IMBUED_NMZ),
            new TriggerItem(ItemId.RING_OF_SUFFERING_IMBUED_SW),
            new TriggerItem(ItemId.RING_OF_SUFFERING_IMBUED_PVP),
        };

        this.triggers = new TriggerBase[]{
            // Check
            new OnChatMessage("Your ring currently has (?<charges>.+) recoil charges? remaining. The recoil effect is currently enabled.").setDynamicallyCharges().onItemClick().activate(),
            new OnChatMessage("Your ring currently has (?<charges>.+) recoil charges? remaining. The recoil effect is currently disabled.").setDynamicallyCharges().onItemClick().deactivate(),

            // Charge
            new OnChatMessage("You load your ring with .+ rings? of recoil. It now has (?<charges>.+) recoil charges.").setDynamicallyCharges(),

            // Get hit.
            new OnHitsplatApplied(HitsplatTarget.SELF).moreThanZeroDamage().isEquipped().isActivated().decreaseCharges(1),

            // Disable.
            new OnChatMessage("You disable the recoil effect of your ring.").deactivate(),

            // Enable.
            new OnChatMessage("You enable the recoil effect of your ring.").activate(),

            // Auto-charge.
            new OnChatMessage("The banker charges your Ring of suffering.* using (?<ringofrecoil>.+)x Ring of recoil.").matcherConsumer(m -> {
                final int ringOfRecoils = Integer.parseInt(m.group("ringofrecoil"));
                increaseCharges(ringOfRecoils * 40);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.AnimationId;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.OnAnimationChanged;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;

public class U_QuetzalWhistle extends ChargedItem {
    public U_QuetzalWhistle(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.quetzal_whistle, ItemId.QUETZAL_WHISTLE_BASIC, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.QUETZAL_WHISTLE_BASIC).maxCharges(5),
            new TriggerItem(ItemId.QUETZAL_WHISTLE_ENHANCED).maxCharges(20),
            new TriggerItem(ItemId.QUETZAL_WHISTLE_PERFECTED).maxCharges(50),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your quetzal whistle has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // Teleport.
            new OnAnimationChanged(AnimationId.QUETZAL_WHISTLE_BIRD).decreaseCharges(1),

            // Teleport menu entry.
            new OnMenuEntryAdded("Signal").replaceOption("Teleport"),

            // Craft basic quetzal whistle.
            new OnChatMessage("You craft yourself a basic quetzal whistle.").setFixedCharges(0),

            // Fully charged.
            new OnChatMessage("Looks like the birds are all full for now. Make them work a bit before feeding them again!").requiredItem(ItemId.QUETZAL_WHISTLE_BASIC).setFixedCharges(5),
            new OnChatMessage("Looks like the birds are all full for now. Make them work a bit before feeding them again!").requiredItem(ItemId.QUETZAL_WHISTLE_ENHANCED).setFixedCharges(20),
            new OnChatMessage("Looks like the birds are all full for now. Make them work a bit before feeding them again!").requiredItem(ItemId.QUETZAL_WHISTLE_PERFECTED).setFixedCharges(50),

            // Partially charged.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).hasChatMessage("Soar Leader Pitri|There you go. Some whistle charges for you!").onInventoryDifference(itemsDifference -> {
                for (final StorageItem item : itemsDifference.getItems()) {
                    switch (item.getId()) {
                        case ItemId.QUETZAL_FEED:
                        case ItemId.RAW_WILD_KEBBIT:
                        case ItemId.RAW_BARBTAILED_KEBBIT:
                        case ItemId.RAW_LARUPIA:
                            increaseCharges(Math.abs(item.getQuantity()));
                            break;
                        case ItemId.RAW_GRAAHK:
                        case ItemId.RAW_KYATT:
                        case ItemId.RAW_PYRE_FOX:
                            increaseCharges(Math.abs(item.getQuantity()) * 2);
                            break;
                        case ItemId.RAW_DASHING_KEBBIT:
                        case ItemId.RAW_SUNLIGHT_ANTELOPE:
                        case ItemId.RAW_MOONLIGHT_ANTELOPE:
                            increaseCharges(Math.abs(item.getQuantity()) * 3);
                            break;
                    }
                }
            })
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStatus;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.ItemId;
import tictac7x.charges.store.Store;

public class U_ImpInABox extends ChargedItemWithStatus {
    public U_ImpInABox(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.imp_in_a_box, ItemId.IMP_IN_A_BOX_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.IMP_IN_A_BOX_1).fixedCharges(1),
            new TriggerItem(ItemId.IMP_IN_A_BOX_2).fixedCharges(2),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_RingOfForging extends ChargedItem {
    public J_RingOfForging(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_forging, ItemId.RING_OF_FORGING, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.RING_OF_FORGING).needsToBeEquipped()
        };

        this.triggers = new TriggerBase[] {
            // Break full.
            new OnChatMessage("The ring is fully charged. There would be no point in breaking it.").onMenuOption("Break").onMenuTarget("Ring of forging").setFixedCharges(140),

            // Check.
            new OnChatMessage("You can smelt (?<charges>.+) more pieces of iron ore before a ring melts.").setDynamicallyCharges(),

            // Smelt.
            new OnChatMessage("You retrieve a bar of iron.").decreaseCharges(1),

            // Break.
            new OnChatMessage("The ring shatters. Your next ring of forging will start afresh from (?<charges>.+) charges.").setDynamicallyCharges(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.WidgetId;

public class U_CoalBag extends ChargedItemWithStorage {
    public U_CoalBag(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.coal_bag, ItemId.COAL_BAG, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.storage = storage
            .storableItems(new StorableItem(ItemId.COAL).checkName("Coal"))
            .setMaximumTotalQuantity(27)
            .setMaximumTotalQuantityWithEquippedItem(36, ItemId.SMITHING_CAPE, ItemId.SMITHING_CAPE_TRIMMED);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.COAL_BAG),
            new TriggerItem(ItemId.COAL_BAG_OPEN),
        };
        this.triggers = new TriggerBase[] {
            // Check or empty.
            new OnChatMessage("The coal bag is( now)? empty.").emptyStorage(),

            // Fill or check with 1 coal.
            new OnChatMessage("The coal bag( still)? contains one piece of coal.").consumer(() -> {
                storage.put(ItemId.COAL, 1);
            }),

            // Check or empty with not enough inventory space.
            new OnChatMessage("The coal bag( still)? contains (?<charges>.+) pieces of coal.").matcherConsumer((m) -> {
                storage.put(ItemId.COAL, Integer.parseInt(m.group("charges")));
            }),

            // Replace "Fill" with proper "Fill from bank".
            new OnMenuEntryAdded("Fill").replaceOption(TicTac7xChargesImprovedPlugin.menuOptionFillFromBank).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Replace "Empty" with proper "Empty to bank".
            new OnMenuEntryAdded("Empty").replaceOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Mine coal with open bag.
            // Extra coal mined by celestial ring.
            // Extra coal mined by varrock platebody.
            new OnChatMessage(
                "(You manage to mine some coal.|Your Celestial ring allows you to mine an additional ore.|The Varrock platebody enabled you to mine an additional ore.)"
            ).onMenuOption("Mine").onMenuTarget("Coal rocks").requiredItem(ItemId.COAL_BAG_OPEN).addToStorage(ItemId.COAL, 1),

            // Superheat spells.
            new OnXpDrop(Skill.SMITHING).onMenuOption("Cast").onMenuTarget(
                "Superheat Item -> Lovakite ore",
                "Superheat Item -> Iron ore"
            ).consumer(() -> {
                storage.removeAndPrioritizeInventory(ItemId.COAL, 2);
            }),
            new OnXpDrop(Skill.SMITHING).onMenuOption("Cast").onMenuTarget(
                "Superheat Item -> Mithril ore"
            ).consumer(() -> {
                storage.removeAndPrioritizeInventory(ItemId.COAL, 4);
            }),
            new OnXpDrop(Skill.SMITHING).onMenuOption("Cast").onMenuTarget(
                "Superheat Item -> Adamantite ore"
            ).consumer(() -> {
                storage.removeAndPrioritizeInventory(ItemId.COAL, 6);
            }),
            new OnXpDrop(Skill.SMITHING).onMenuOption("Cast").onMenuTarget(
                "Superheat Item -> Runite ore"
            ).consumer(() -> {
                storage.removeAndPrioritizeInventory(ItemId.COAL, 8);
            }),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.WidgetId;

import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_FlamtaerBag extends ChargedItemWithStorage {
//    private boolean flamtaerBagEmptyDialogVisible = false;

    public U_FlamtaerBag(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.flamtaer_bag, ItemId.FLAMTAER_BAG, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage.storableItems(
            new StorableItem(ItemId.TIMBER_BEAM).specificOrder(1),
            new StorableItem(ItemId.LIMESTONE_BRICK).specificOrder(2),
            new StorableItem(ItemId.SWAMP_PASTE).specificOrder(3)
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.FLAMTAER_BAG),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Timber beams: (?<beams>.+) Limestone bricks: (?<bricks>.+) Swamp paste: (?<paste>.+)").matcherConsumer(m -> {
                storage.clear();
                storage.put(ItemId.TIMBER_BEAM, Integer.parseInt(m.group("beams")));
                storage.put(ItemId.LIMESTONE_BRICK, Integer.parseInt(m.group("bricks")));
                storage.put(ItemId.SWAMP_PASTE, Integer.parseInt(m.group("paste")));
            }),

            // Repaired.
            new OnChatMessage("Your temple repair resource pool is full").consumer(() -> {
                storage.removeAndPrioritizeInventory(ItemId.TIMBER_BEAM, 1);
                storage.removeAndPrioritizeInventory(ItemId.LIMESTONE_BRICK, 1);
                storage.removeAndPrioritizeInventory(ItemId.SWAMP_PASTE, 5);
            }),

            // Replace "Empty" with proper "Empty to inventory" at bank.
            new OnMenuEntryAdded("Empty").replaceOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToInventory).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Empty to inventory at bank.
            new OnItemContainerChanged(INVENTORY).emptyStorageToInventory().onMenuOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToInventory),

            // Use storable items on flamtaer bag.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Use flamtaer bag on storable item.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseChargedItemOnStorageItem(storage.getStorableItems()),

//            // Flamtaer empty widget appeared.
//            new OnWidgetLoaded(219, 1).widgetConsumer(widget -> {
//                final Optional<Widget> emptyEverything = Optional.ofNullable(widget.getChild(1));
//                final Optional<Widget> emptyFirstOption = Optional.ofNullable(widget.getChild(2));
//
//                flamtaerBagEmptyDialogVisible = (
//                    emptyEverything.isPresent() && emptyEverything.get().getText().equals("Everything") &&
//                    emptyFirstOption.isPresent() && (
//                        emptyFirstOption.get().getText().contains("Timber beams") ||
//                        emptyFirstOption.get().getText().contains("Limestone bricks") ||
//                        emptyFirstOption.get().getText().contains("Swamp paste")
//                    )
//                );
//            }),
//            // TODO - figure out how to detect which option was chosen from empty dialog

            // Trying to empty already empty bag.
            new OnChatMessage("The bag is empty").onMenuOption("Empty", TicTac7xChargesImprovedPlugin.menuOptionEmptyToInventory).onItemClick().emptyStorage(),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.WidgetId;

public class U_HuntsmansKit extends ChargedItemWithStorage {
    public U_HuntsmansKit(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.huntsmans_kit, ItemId.HUNTSMANS_KIT, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.HUNTSMANS_KIT)
        };

        this.storage = storage.storableItems(
            new StorableItem(ItemId.BIRD_SNARE),
            new StorableItem(ItemId.BUTTERFLY_NET),
            new StorableItem(ItemId.BUTTERFLY_JAR),
            new StorableItem(ItemId.RABBIT_SNARE),
            new StorableItem(ItemId.SMALL_FISHING_NET),
            new StorableItem(ItemId.MAGIC_BOX),
            new StorableItem(ItemId.TEASING_STICK),
            new StorableItem(ItemId.WOOD_CAMO_TOP),
            new StorableItem(ItemId.WOOD_CAMO_LEGS),
            new StorableItem(ItemId.JUNGLE_CAMO_TOP),
            new StorableItem(ItemId.JUNGLE_CAMO_LEGS),
            new StorableItem(ItemId.LARUPIA_HAT),
            new StorableItem(ItemId.LARUPIA_TOP),
            new StorableItem(ItemId.LARUPIA_LEGS),
            new StorableItem(ItemId.KYATT_HAT),
            new StorableItem(ItemId.KYATT_TOP),
            new StorableItem(ItemId.KYATT_LEGS),
            new StorableItem(ItemId.GUILD_HUNTER_HEADWEAR),
            new StorableItem(ItemId.GUILD_HUNTER_TOP),
            new StorableItem(ItemId.GUILD_HUNTER_LEGS),
            new StorableItem(ItemId.GUILD_HUNTER_BOOTS),
            new StorableItem(ItemId.RING_OF_PURSUIT),
            new StorableItem(ItemId.NOOSE_WAND),
            new StorableItem(ItemId.MAGIC_BUTTERFLY_NET),
            new StorableItem(ItemId.BOX_TRAP),
            new StorableItem(ItemId.UNLIT_TORCH),
            new StorableItem(ItemId.ROPE),
            new StorableItem(ItemId.HUNTERS_SPEAR),
            new StorableItem(ItemId.POLAR_CAMO_TOP),
            new StorableItem(ItemId.POLAR_CAMO_LEGS),
            new StorableItem(ItemId.DESERT_CAMO_TOP),
            new StorableItem(ItemId.DESERT_CAMO_LEGS),
            new StorableItem(ItemId.GRAAHK_HEADDRESS),
            new StorableItem(ItemId.GRAAHK_TOP),
            new StorableItem(ItemId.GRAAHK_LEGS),
            new StorableItem(ItemId.HUNTER_HOOD),
            new StorableItem(ItemId.HUNTER_CAPE),
            new StorableItem(ItemId.HUNTER_CAPE_TRIMMED),
            new StorableItem(ItemId.IMPLING_JAR)
        );

        this.triggers = new TriggerBase[]{
            // Fill from inventory.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).fillStorageFromInventory().onMenuOption("Fill", TicTac7xChargesImprovedPlugin.menuOptionFillFromInventory),

            // Empty to inventory.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).emptyStorageToInventory().onMenuOption("Empty", TicTac7xChargesImprovedPlugin.menuOptionEmptyToInventory),

            // Update from item container when viewing huntsmans kit contents.
            new OnItemContainerChanged(ItemContainerId.HUNTSMANS_KIT).updateStorage(),

            // Replace "Use" with proper Fill/Empty option.
            new OnMenuEntryAdded("Use").replaceOptionConsumer(() -> getMenuOptionForUse()).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),
            new OnMenuEntryAdded("Use").replaceOptionConsumer(() -> getMenuOptionForUse()).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Hide destroy option.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }

    private String getMenuOptionForUse() {
        return storage.isStorableItemInInventory()
                ? TicTac7xChargesImprovedPlugin.menuOptionFillFromInventory
                : TicTac7xChargesImprovedPlugin.menuOptionEmptyToInventory;
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_CelestialRing extends ChargedItem {
    public J_CelestialRing(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.celestial_ring, ItemId.CELESTIAL_RING, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.CELESTIAL_RING_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.CELESTIAL_SIGNET_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.CELESTIAL_RING).needsToBeEquipped(),
            new TriggerItem(ItemId.CELESTIAL_SIGNET).needsToBeEquipped()
        };

        this.triggers = new TriggerBase[] {
            // Charge.
            new OnChatMessage("You add .+ charges? to your Celestial (ring|signet). It now has (?<charges>.+) charges?.").setDynamicallyCharges(),
            new OnChatMessage("You add (?<charges>.+) charges? to your Celestial (ring|signet).").setDynamicallyCharges(),

            // Check.
            new OnChatMessage("Your Celestial (ring|signet) has (?<charges>.+) charges?.").setDynamicallyCharges(),

            // Ran out of charges.
            new OnChatMessage("Your Celestial (ring|signet) has run out of charges.").notification().setFixedCharges(0),

            // Mine.
            new OnChatMessage("You manage to (mine|quarry) some (clay|copper|tin|guardian fragments|guardian essence|tephra|blurite|limestone|iron|silver|coal|sandstone|gold|granite|mithril|lovakite|adamantite|soft clay)( ore)?.").isEquipped().decreaseCharges(1),

            // Auto-charge.
            new OnChatMessage("The banker charges your Celestial (ring|signet) using (?<stardust>.+)x Stardust.").matcherConsumer(m -> {
                final int stardust = Integer.parseInt(m.group("stardust"));
                increaseCharges(stardust);
            })
        };
    }
}
package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_NecklaceOfPassage extends ChargedItem {
    public J_NecklaceOfPassage(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.necklace_of_passage, ItemId.NECKLACE_OF_PASSAGE_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.NECKLACE_OF_PASSAGE_1).fixedCharges(1),
            new TriggerItem(ItemId.NECKLACE_OF_PASSAGE_2).fixedCharges(2),
            new TriggerItem(ItemId.NECKLACE_OF_PASSAGE_3).fixedCharges(3),
            new TriggerItem(ItemId.NECKLACE_OF_PASSAGE_4).fixedCharges(4),
            new TriggerItem(ItemId.NECKLACE_OF_PASSAGE_5).fixedCharges(5),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import static tictac7x.charges.store.HitsplatTarget.SELF;

public class A_CrystalHelm extends ChargedItem {
    public A_CrystalHelm(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.crystal_helm, ItemId.CRYSTAL_HELM, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.CRYSTAL_HELM),
            new TriggerItem(ItemId.CRYSTAL_HELM_HEFIN),
            new TriggerItem(ItemId.CRYSTAL_HELM_ITHELL),
            new TriggerItem(ItemId.CRYSTAL_HELM_IORWERTH),
            new TriggerItem(ItemId.CRYSTAL_HELM_TRAHAEARN),
            new TriggerItem(ItemId.CRYSTAL_HELM_CADARN),
            new TriggerItem(ItemId.CRYSTAL_HELM_CRWYS),
            new TriggerItem(ItemId.CRYSTAL_HELM_AMLODD),
            new TriggerItem(ItemId.CRYSTAL_HELM_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_HELM_HEFIN_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_HELM_ITHELL_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_HELM_IORWERTH_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_HELM_TRAHAEARN_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_HELM_CADARN_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_HELM_CRWYS_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_HELM_AMLODD_INACTIVE).fixedCharges(0),
        };

        this.triggers = new TriggerBase[]{
            new OnChatMessage("Your crystal helm has (?<charges>.+) charges? remaining").setDynamicallyCharges().onItemClick(),
            new OnHitsplatApplied(SELF).isEquipped().decreaseCharges(1)
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class J_XericsTalisman extends ChargedItem {
    public J_XericsTalisman(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.xerics_talisman, ItemId.XERICS_TALISMAN, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.XERICS_TALISMAN_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.XERICS_TALISMAN),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("(The|Your) talisman( now)? has one charge.").onItemClick().setFixedCharges(1),
            new OnChatMessage("(The|Your) talisman( now)? has (?<charges>.+) charges.").setDynamicallyCharges().onItemClick(),

            // Teleport.
            new OnGraphicChanged(1612).decreaseCharges(1),

            // Teleport widget.
            new OnWidgetLoaded(187, 0, 1).text("The talisman has (?<charges>.+) charges.").setDynamically(),

            // Unified menu entry.
            new OnMenuEntryAdded("Rub").replaceOption("Teleport"),

            // Auto-charge.
            new OnChatMessage("The banker charges your Xeric's talisman using (?<lizardmanfang>.+)x Lizardman fang.").matcherConsumer(m -> {
                final int lizardmanFangs = Integer.parseInt(m.group("lizardmanfang"));
                increaseCharges(lizardmanFangs);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class U_TeleportCrystal extends ChargedItem {
    public U_TeleportCrystal(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.teleport_crystal, ItemId.TELEPORT_CRYSTAL_0, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TELEPORT_CRYSTAL_0).fixedCharges(0),
            new TriggerItem(ItemId.TELEPORT_CRYSTAL_1).fixedCharges(1),
            new TriggerItem(ItemId.TELEPORT_CRYSTAL_2).fixedCharges(2),
            new TriggerItem(ItemId.TELEPORT_CRYSTAL_3).fixedCharges(3),
            new TriggerItem(ItemId.TELEPORT_CRYSTAL_4).fixedCharges(4),
            new TriggerItem(ItemId.TELEPORT_CRYSTAL_5).fixedCharges(5),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnWidgetLoaded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_AmuletOfChemistry extends ChargedItem {
    public J_AmuletOfChemistry(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.amulet_of_chemistry, ItemId.AMULET_OF_CHEMISTRY, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.AMULET_OF_CHEMISTRY).needsToBeEquipped()
        };

        this.triggers = new TriggerBase[] {
            // Check
            new OnChatMessage("Your amulet of chemistry has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Use charge
            new OnChatMessage("Your amulet of chemistry helps you create a 4-dose potion. It then crumbles to dust.").setFixedCharges(5),
            new OnChatMessage("Your amulet of chemistry helps you create a 4-dose potion. It has one charge left.").setFixedCharges(1),
            new OnChatMessage("Your amulet of chemistry helps you create a 4-dose potion. It has (?<charges>.+) charges left.").setDynamicallyCharges(),

            // Status from break dialog
            new OnWidgetLoaded(219, 1, 0).text("Status: (?<charges>.+) charges? left.").setDynamically().onItemClick(),

            // Break
            new OnChatMessage("The amulet shatters. Your next amulet of chemistry will start afresh from (?<charges>.+) charges.").setDynamicallyCharges(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

public class J_RingOfDueling extends ChargedItem {
    public J_RingOfDueling(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_dueling, ItemId.RING_OF_DUELING_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.RING_OF_DUELING_1).fixedCharges(1),
            new TriggerItem(ItemId.RING_OF_DUELING_2).fixedCharges(2),
            new TriggerItem(ItemId.RING_OF_DUELING_3).fixedCharges(3),
            new TriggerItem(ItemId.RING_OF_DUELING_4).fixedCharges(4),
            new TriggerItem(ItemId.RING_OF_DUELING_5).fixedCharges(5),
            new TriggerItem(ItemId.RING_OF_DUELING_6).fixedCharges(6),
            new TriggerItem(ItemId.RING_OF_DUELING_7).fixedCharges(7),
            new TriggerItem(ItemId.RING_OF_DUELING_8).fixedCharges(8),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.WidgetId;

import static tictac7x.charges.store.ItemContainerId.BANK;
import static tictac7x.charges.store.ItemContainerId.INVENTORY;

public class U_MeatPouch extends ChargedItemWithStorage {
    public U_MeatPouch(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.meat_pouch, ItemId.MEAT_POUCH_SMALL, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.storage = storage.storableItems(
            // Tracking.
            new StorableItem(ItemId.RAW_BEAST_MEAT),

            // Deadfall.
            new StorableItem(ItemId.RAW_WILD_KEBBIT),
            new StorableItem(ItemId.RAW_BARBTAILED_KEBBIT),
            new StorableItem(ItemId.RAW_PYRE_FOX),

            // Pitfalls.
            new StorableItem(ItemId.RAW_LARUPIA),
            new StorableItem(ItemId.RAW_GRAAHK),
            new StorableItem(ItemId.RAW_KYATT),
            new StorableItem(ItemId.RAW_SUNLIGHT_ANTELOPE),
            new StorableItem(ItemId.RAW_MOONLIGHT_ANTELOPE),

            // Aerial.
            new StorableItem(ItemId.RAW_DASHING_KEBBIT)
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.MEAT_POUCH_SMALL).maxCharges(14),
            new TriggerItem(ItemId.MEAT_POUCH_SMALL_OPEN).maxCharges(14),
            new TriggerItem(ItemId.MEAT_POUCH_LARGE).maxCharges(28),
            new TriggerItem(ItemId.MEAT_POUCH_LARGE_OPEN).maxCharges(28),
        };

        this.triggers = new TriggerBase[]{
            // Empty.
            new OnChatMessage("Your meat pouch is currently holding 0 meat").emptyStorage(),
            new OnChatMessage("Your meat pouch is empty.").emptyStorage(),

            // Fill from inventory.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onMenuOption("Fill"),

            // Empty to inventory.
            new OnItemContainerChanged(INVENTORY).emptyStorageToInventory().onMenuOption("Empty"),

            // Empty to bank.
            new OnItemContainerChanged(BANK).emptyStorageToBank().onMenuOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank),

            // Empty from deposit box.
            new OnMenuOptionClicked(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank).onItemClick().isWidgetVisible(WidgetId.DEPOSIT_BOX).emptyStorage(),

            // Use meat on pouch.
            new OnItemContainerChanged(INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Replace "Empty" with proper "Empty to bank".
            new OnMenuEntryAdded("Empty").replaceOption(TicTac7xChargesImprovedPlugin.menuOptionEmptyToBank).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Hide destroy option.
            new OnMenuEntryAdded("Destroy").hide(),

            // Tracking.
            new OnChatMessage("You manage to noose a polar kebbit that is hiding in the snowdrift.").requiredItem(ItemId.MEAT_POUCH_SMALL_OPEN, ItemId.MEAT_POUCH_LARGE_OPEN).addToStorage(ItemId.RAW_BEAST_MEAT),
            new OnChatMessage("You manage to noose a common kebbit that is hiding in the bush.").requiredItem(ItemId.MEAT_POUCH_SMALL_OPEN, ItemId.MEAT_POUCH_LARGE_OPEN).addToStorage(ItemId.RAW_BEAST_MEAT),
            new OnChatMessage("You manage to noose a Feldip weasel that is hiding in the bush.").requiredItem(ItemId.MEAT_POUCH_SMALL_OPEN, ItemId.MEAT_POUCH_LARGE_OPEN).addToStorage(ItemId.RAW_BEAST_MEAT),
            new OnChatMessage("You manage to noose a desert devil that is hiding in the sand.").requiredItem(ItemId.MEAT_POUCH_SMALL_OPEN, ItemId.MEAT_POUCH_LARGE_OPEN).addToStorage(ItemId.RAW_BEAST_MEAT),
            new OnChatMessage("You manage to noose a razor-backed kebbit that is hiding in the bush.").requiredItem(ItemId.MEAT_POUCH_SMALL_OPEN, ItemId.MEAT_POUCH_LARGE_OPEN).addToStorage(ItemId.RAW_BEAST_MEAT),

            // Deadfall.
            new OnChatMessage("You've caught a wild kebbit.").requiredItem(ItemId.MEAT_POUCH_SMALL_OPEN, ItemId.MEAT_POUCH_LARGE_OPEN).addToStorage(ItemId.RAW_WILD_KEBBIT),
            new OnChatMessage("You've caught a barb-tailed kebbit.").requiredItem(ItemId.MEAT_POUCH_SMALL_OPEN, ItemId.MEAT_POUCH_LARGE_OPEN).addToStorage(ItemId.RAW_BARBTAILED_KEBBIT),
            new OnChatMessage("You've caught a pyre fox.").requiredItem(ItemId.MEAT_POUCH_SMALL_OPEN, ItemId.MEAT_POUCH_LARGE_OPEN).addToStorage(ItemId.RAW_PYRE_FOX),

            // Pitfalls.
            new OnChatMessage("You've caught a spined larupia!").requiredItem(ItemId.MEAT_POUCH_SMALL_OPEN, ItemId.MEAT_POUCH_LARGE_OPEN).addToStorage(ItemId.RAW_LARUPIA),
            new OnChatMessage("You've caught a horned graahk!").requiredItem(ItemId.MEAT_POUCH_SMALL_OPEN, ItemId.MEAT_POUCH_LARGE_OPEN).addToStorage(ItemId.RAW_GRAAHK),
            new OnChatMessage("You've caught a sabre-?toothed kyatt!").requiredItem(ItemId.MEAT_POUCH_SMALL_OPEN, ItemId.MEAT_POUCH_LARGE_OPEN).addToStorage(ItemId.RAW_KYATT),
            new OnChatMessage("You've caught a sunlight antelope!").requiredItem(ItemId.MEAT_POUCH_SMALL_OPEN, ItemId.MEAT_POUCH_LARGE_OPEN).addToStorage(ItemId.RAW_SUNLIGHT_ANTELOPE),
            new OnChatMessage("You've caught a moonlight antelope!").requiredItem(ItemId.MEAT_POUCH_SMALL_OPEN, ItemId.MEAT_POUCH_LARGE_OPEN).addToStorage(ItemId.RAW_MOONLIGHT_ANTELOPE),

            // Aerial.
            new OnXpDrop(Skill.HUNTER, 156).requiredItem(ItemId.MEAT_POUCH_SMALL_OPEN, ItemId.MEAT_POUCH_LARGE_OPEN).hasChatMessage("You retrieve the falcon as well as the fur of the dead kebbit.").consumer(() -> {
                storage.add(ItemId.RAW_DASHING_KEBBIT, 1);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class U_Waterskin extends ChargedItem {
    public U_Waterskin(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.waterskin, ItemId.WATERSKIN_0, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.WATERSKIN_0).fixedCharges(0),
            new TriggerItem(ItemId.WATERSKIN_1).fixedCharges(1),
            new TriggerItem(ItemId.WATERSKIN_2).fixedCharges(2),
            new TriggerItem(ItemId.WATERSKIN_3).fixedCharges(3),
            new TriggerItem(ItemId.WATERSKIN_4).fixedCharges(4),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class F_SapphireGlacialisMix extends ChargedItem {
    public F_SapphireGlacialisMix(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.sapphire_glacialis_mix, ItemId.SAPPHIRE_GLACIALIS_MIX_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.SAPPHIRE_GLACIALIS_MIX_1).fixedCharges(1),
            new TriggerItem(ItemId.SAPPHIRE_GLACIALIS_MIX_2).fixedCharges(2),
        };
    }

    @Override
    public String getTooltip() {
        return "Sapphrie glacialis mix: " + getTotalCharges();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_BraceletOfSlaughter extends ChargedItem {
    public J_BraceletOfSlaughter(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.bracelet_of_slaughter, ItemId.BRACELET_OF_SLAUGHTER, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BRACELET_OF_SLAUGHTER).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your bracelet of slaughter has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Charge used.
            new OnChatMessage("Your bracelet of slaughter prevents your slayer count from decreasing. It has (?<charges>.+) charges? left.").setDynamicallyCharges(),

            // Bracelet fully used.
            new OnChatMessage("Your bracelet of slaughter prevents your slayer count from decreasing. It then crumbles to dust.").setFixedCharges(30).notification("Your slaughter bracelet crumbles to dust."),

            // Break.
            new OnChatMessage("The bracelet shatters. Your next bracelet of slaughter will start afresh from (?<charges>.+) charges.").setDynamicallyCharges(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.Store;

import java.util.Optional;

public class J_BindingNecklace extends ChargedItem {
    public J_BindingNecklace(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.binding_necklace, ItemId.BINDING_NECKLACE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BINDING_NECKLACE).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Check, one left.
            new OnChatMessage("You have one charge left before your Binding necklace disintegrates.").setFixedCharges(1),

            // Check.
            new OnChatMessage("You have (?<charges>.+) charges left before your Binding necklace disintegrates.").setDynamicallyCharges(),

            // Charge used.
            new OnChatMessage("You (partially succeed to )?bind the temple's power into (mud|lava|steam|dust|smoke|mist) runes\\.").decreaseCharges(1),

            // Fully used.
            new OnChatMessage("Your Binding necklace has disintegrated.").runConsumerOnNextGameTick(() -> setCharges(16)),

            // Destroy.
            new OnScriptPreFired(1651).scriptConsumer((script) -> {
                final Optional<Widget> destroyWidget = TicTac7xChargesImprovedPlugin.getWidget(client, 584, 0, 2);
                if (
                    destroyWidget.isPresent() && destroyWidget.get().getText().equals("Destroy necklace of binding?") &&
                    script.getScriptEvent().getArguments().length >= 5 &&
                    script.getScriptEvent().getArguments()[4].toString().equals("Yes")
                ) {
                    store.addConsumerToNextTickQueue(() -> setCharges(16));
                }
            }),
        };
    }
}

package tictac7x.charges.items.moons;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnCombat;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class BlueMoonHelm extends _MoonItem {
    public BlueMoonHelm(
            final Client client,
            final ClientThread clientThread,
            final ConfigManager configManager,
            final ItemManager itemManager,
            final InfoBoxManager infoBoxManager,
            final ChatMessageManager chatMessageManager,
            final Notifier notifier,
            final TicTac7xChargesImprovedConfig config,
            final Store store,
            final Gson gson
    ) {
        super("blue_helm", ItemId.BLUE_MOON_HELM, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BLUE_MOON_HELM).fixedCharges(3000),
            new TriggerItem(ItemId.BLUE_MOON_HELM_DEGRADED),
            new TriggerItem(ItemId.BLUE_MOON_HELM_BROKEN).fixedCharges(0),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Your Blue moon helm has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // In combat.
            new OnCombat(90).isEquipped().decreaseCharges(1),
        };
    }
}
package tictac7x.charges.items.moons;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnCombat;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class BlueMoonChestplate extends _MoonItem {
    public BlueMoonChestplate(
            final Client client,
            final ClientThread clientThread,
            final ConfigManager configManager,
            final ItemManager itemManager,
            final InfoBoxManager infoBoxManager,
            final ChatMessageManager chatMessageManager,
            final Notifier notifier,
            final TicTac7xChargesImprovedConfig config,
            final Store store,
            final Gson gson
    ) {
        super("blue_chestplate", ItemId.BLUE_MOON_CHESTPLATE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BLUE_MOON_CHESTPLATE).fixedCharges(3000),
            new TriggerItem(ItemId.BLUE_MOON_CHESTPLATE_DEGRADED),
            new TriggerItem(ItemId.BLUE_MOON_CHESTPLATE_BROKEN).fixedCharges(0),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Your Blue moon chestplate has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // In combat.
            new OnCombat(90).isEquipped().decreaseCharges(1),
        };
    }
}
package tictac7x.charges.items.moons;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnCombat;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class EclipseMoonTassets extends _MoonItem {
    public EclipseMoonTassets(
            final Client client,
            final ClientThread clientThread,
            final ConfigManager configManager,
            final ItemManager itemManager,
            final InfoBoxManager infoBoxManager,
            final ChatMessageManager chatMessageManager,
            final Notifier notifier,
            final TicTac7xChargesImprovedConfig config,
            final Store store,
            final Gson gson
    ) {
        super("eclipse_tassets", ItemId.ECLIPSE_MOON_TASSETS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.ECLIPSE_MOON_TASSETS).fixedCharges(3000),
            new TriggerItem(ItemId.ECLIPSE_MOON_TASSETS_DEGRADED),
            new TriggerItem(ItemId.ECLIPSE_MOON_TASSETS_BROKEN).fixedCharges(0),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Your Eclipse moon tassets has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // In combat.
            new OnCombat(90).isEquipped().decreaseCharges(1),
        };
    }
}
package tictac7x.charges.items.moons;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnCombat;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class BlueMoonTassets extends _MoonItem {
    public BlueMoonTassets(
            final Client client,
            final ClientThread clientThread,
            final ConfigManager configManager,
            final ItemManager itemManager,
            final InfoBoxManager infoBoxManager,
            final ChatMessageManager chatMessageManager,
            final Notifier notifier,
            final TicTac7xChargesImprovedConfig config,
            final Store store,
            final Gson gson
    ) {
        super("blue_tassets", ItemId.BLUE_MOON_TASSETS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BLUE_MOON_TASSETS).fixedCharges(3000),
            new TriggerItem(ItemId.BLUE_MOON_TASSETS_DEGRADED),
            new TriggerItem(ItemId.BLUE_MOON_TASSETS_BROKEN).fixedCharges(0),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Your Blue moon tassets has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // In combat.
            new OnCombat(90).isEquipped().decreaseCharges(1),
        };
    }
}
package tictac7x.charges.items.moons;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnCombat;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class EclipseMoonHelm extends _MoonItem {
    public EclipseMoonHelm(
            final Client client,
            final ClientThread clientThread,
            final ConfigManager configManager,
            final ItemManager itemManager,
            final InfoBoxManager infoBoxManager,
            final ChatMessageManager chatMessageManager,
            final Notifier notifier,
            final TicTac7xChargesImprovedConfig config,
            final Store store,
            final Gson gson
    ) {
        super("eclipse_helm", ItemId.ECLIPSE_MOON_HELM, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.ECLIPSE_MOON_HELM).fixedCharges(3000),
            new TriggerItem(ItemId.ECLIPSE_MOON_HELM_DEGRADED),
            new TriggerItem(ItemId.ECLIPSE_MOON_HELM_BROKEN).fixedCharges(0),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Your Eclipse moon helm has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // In combat.
            new OnCombat(90).isEquipped().decreaseCharges(1),
        };
    }
}
package tictac7x.charges.items.moons;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnCombat;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class BloodMoonTassets extends _MoonItem {
    public BloodMoonTassets(
            final Client client,
            final ClientThread clientThread,
            final ConfigManager configManager,
            final ItemManager itemManager,
            final InfoBoxManager infoBoxManager,
            final ChatMessageManager chatMessageManager,
            final Notifier notifier,
            final TicTac7xChargesImprovedConfig config,
            final Store store,
            final Gson gson
    ) {
        super("blood_tassets", ItemId.BLOOD_MOON_TASSETS, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BLOOD_MOON_TASSETS).fixedCharges(3000),
            new TriggerItem(ItemId.BLOOD_MOON_TASSETS_DEGRADED),
            new TriggerItem(ItemId.BLOOD_MOON_TASSETS_BROKEN).fixedCharges(0),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Your Blood moon tassets has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // In combat.
            new OnCombat(90).isEquipped().decreaseCharges(1),
        };
    }
}
package tictac7x.charges.items.moons;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnCombat;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class BloodMoonHelm extends _MoonItem {
    public BloodMoonHelm(
            final Client client,
            final ClientThread clientThread,
            final ConfigManager configManager,
            final ItemManager itemManager,
            final InfoBoxManager infoBoxManager,
            final ChatMessageManager chatMessageManager,
            final Notifier notifier,
            final TicTac7xChargesImprovedConfig config,
            final Store store,
            final Gson gson
    ) {
        super("blood_helm", ItemId.BLOOD_MOON_HELM, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BLOOD_MOON_HELM).fixedCharges(3000),
            new TriggerItem(ItemId.BLOOD_MOON_HELM_DEGRADED),
            new TriggerItem(ItemId.BLOOD_MOON_HELM_BROKEN).fixedCharges(0),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Your Blood moon helm has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // In combat.
            new OnCombat(90).isEquipped().decreaseCharges(1),
        };
    }
}
package tictac7x.charges.items.moons;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.store.Store;

public class _MoonItem extends ChargedItem {
    public _MoonItem(final String configKey, final int itemId, final Client client, final ClientThread clientThread, final ConfigManager configManager, final ItemManager itemManager, final InfoBoxManager infoBoxManager, final ChatMessageManager chatMessageManager, final Notifier notifier, final TicTac7xChargesImprovedConfig config, final Store store, final Gson gson) {
        super(TicTac7xChargesImprovedConfig.moons_gear + "_" + configKey, itemId, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
    }

    @Override
    protected String getChargesMinified(final int itemId) {
        switch (config.combatTimeDegradableStyle()) {
            case PERCENTAGE:
                return getChargesFromConfig() * 100 / 3000 + "%";
            case TIME:
                final double hours = (double) (getChargesFromConfig() * 90 * 600) / 1000 / 3600;
                return String.format("%.1fh", hours).replaceAll("\\.0", "");
            case CHARGES:
            default:
                return super.getChargesMinified(itemId);
        }
    }
}

package tictac7x.charges.items.moons;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnCombat;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class BloodMoonChestplate extends _MoonItem {
    public BloodMoonChestplate(
            final Client client,
            final ClientThread clientThread,
            final ConfigManager configManager,
            final ItemManager itemManager,
            final InfoBoxManager infoBoxManager,
            final ChatMessageManager chatMessageManager,
            final Notifier notifier,
            final TicTac7xChargesImprovedConfig config,
            final Store store,
            final Gson gson
    ) {
        super("blood_chestplate", ItemId.BLOOD_MOON_CHESTPLATE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BLOOD_MOON_CHESTPLATE).fixedCharges(3000),
            new TriggerItem(ItemId.BLOOD_MOON_CHESTPLATE_DEGRADED),
            new TriggerItem(ItemId.BLOOD_MOON_CHESTPLATE_BROKEN).fixedCharges(0),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Your Blood moon chestplate has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // In combat.
            new OnCombat(90).isEquipped().decreaseCharges(1),
        };
    }
}
package tictac7x.charges.items.moons;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnCombat;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class EclipseMoonChestplate extends _MoonItem {
    public EclipseMoonChestplate(
            final Client client,
            final ClientThread clientThread,
            final ConfigManager configManager,
            final ItemManager itemManager,
            final InfoBoxManager infoBoxManager,
            final ChatMessageManager chatMessageManager,
            final Notifier notifier,
            final TicTac7xChargesImprovedConfig config,
            final Store store,
            final Gson gson
    ) {
        super("eclipse_chestplate", ItemId.ECLIPSE_MOON_CHESTPLATE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.ECLIPSE_MOON_CHESTPLATE).fixedCharges(3000),
            new TriggerItem(ItemId.ECLIPSE_MOON_CHESTPLATE_DEGRADED),
            new TriggerItem(ItemId.ECLIPSE_MOON_CHESTPLATE_BROKEN).fixedCharges(0),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("Your Eclipse moon chestplate has (?<charges>.+) charges? remaining.").setDynamicallyCharges(),

            // In combat.
            new OnCombat(90).isEquipped().decreaseCharges(1),
        };
    }
}
package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.api.Skill;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.storage.StorageItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnXpDrop;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import java.util.Optional;

import static tictac7x.charges.TicTac7xChargesImprovedPlugin.getNumberFromCommaString;

public class U_BottomlessCompostBucket extends ChargedItemWithStorage {
    public U_BottomlessCompostBucket(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.bottomless_compost_bucket, ItemId.BOTTOMLESS_COMPOST_BUCKET, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        storage = storage.setMaximumTotalQuantity(10_000).storableItems(
            new StorableItem(ItemId.ULTRACOMPOST).checkName("ultra"),
            new StorableItem(ItemId.SUPERCOMPOST).checkName("super"),
            new StorableItem(ItemId.COMPOST).checkName("regular").displayName("Regular compost")
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.BOTTOMLESS_COMPOST_BUCKET_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.BOTTOMLESS_COMPOST_BUCKET),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your bottomless compost bucket is currently holding one use of (?<type>.+) ?compost.").matcherConsumer(m -> {
                storage.clearAndPut(getStorageItemFromName(m.group("type"), 1));
            }),
            new OnChatMessage("Your bottomless compost bucket is currently holding (?<quantity>.+) uses of (?<type>.+) ?compost.").matcherConsumer(m -> {
                final int quantity = getNumberFromCommaString(m.group("quantity"));
                storage.clearAndPut(getStorageItemFromName(m.group("type"), quantity));
            }),

            // Use compost on a patch, run on next gametick, because the "You treat" message appears on same tick after this one.
            new OnChatMessage("Your bottomless compost bucket has a single use of (?<type>.+) ?compost remaining.").matcherConsumer(m -> {
                store.addConsumerToNextTickQueue(() -> {
                    storage.clearAndPut(getStorageItemFromName(m.group("type"), 1));
                });
            }),
            new OnChatMessage("Your bottomless compost bucket has (?<quantity>.+) uses of (?<type>.+) ?compost remaining.").matcherConsumer(m -> {
                store.addConsumerToNextTickQueue(() -> {
                    final int quantity = getNumberFromCommaString(m.group("quantity"));
                    storage.clearAndPut(getStorageItemFromName(m.group("type"), quantity));
                });
            }),
            new OnChatMessage("You treat the .* with (?<type>.*) ?compost.").matcherConsumer(m -> {
                final String type = m.group("type");
                storage.remove(getStorageItemFromName(type.isEmpty() ? "regular" : type, 1));
            }).onItemClick(),

            // Discard.
            new OnChatMessage("You discard the contents of your bottomless compost bucket.").emptyStorage(),

            // Empty.
            new OnChatMessage("Your bottomless compost bucket has run out of compost!").emptyStorage(),

            // Fill.
            new OnChatMessage("You fill your bottomless compost bucket with a single bucket of (?<type>.+) ?compost. Your bottomless compost bucket now contains a total of (?<quantity>.+) uses.").matcherConsumer(m -> {
                final int quantity = getNumberFromCommaString(m.group("quantity"));
                storage.clearAndPut(getStorageItemFromName(m.group("type"), quantity));
            }),
            new OnChatMessage("You fill your bottomless compost bucket with .* buckets of (?<type>.+) ?compost. Your bottomless compost bucket now contains a total of (?<quantity>.+) uses.").matcherConsumer(m -> {
                final int quantity = getNumberFromCommaString(m.group("quantity"));
                storage.clearAndPut(getStorageItemFromName(m.group("type"), quantity));
            }),

            // Almost full.
            new OnChatMessage("Your bottomless compost bucket is just about full. You won't be able to squeeze any more compost in there.").consumer(() -> {
                if (getCompostType().isPresent()) {
                    storage.clearAndPut(getCompostType().get().getId(), 9999);
                }
            }),

            // Full.
            new OnChatMessage("Your bottomless compost bucket is now full!").consumer(() -> {
                if (getCompostType().isPresent()) {
                    storage.clearAndPut(getCompostType().get().getId(), 10_000);
                }
            }),

            // Fill compost from bin.
            new OnXpDrop(Skill.FARMING).unallowedItem(ItemId.BUCKET).onMenuOption("Take").onMenuTarget("Compost Bin", "Big Compost Bin").consumer(() -> {
                if (getCompostType().isPresent()) {
                    storage.add(getCompostType().get().getId(), 2);
                }
            }),

            // Use on compost bin.
            new OnXpDrop(Skill.FARMING).onMenuOption("Use").onMenuTarget("Bottomless compost bucket -> Compost Bin", "Bottomless compost bucket -> Big Compost Bin").consumer(() -> {
                if (getCompostType().isPresent()) {
                    storage.add(getCompostType().get().getId(), 2);
                }
            }),
        };
    }

    private Optional<StorageItem> getCompostType() {
        for (final StorageItem storageItem : getStorage().getItems()) {
            if (storageItem.getQuantity() > 0) {
                return Optional.of(storageItem);
            }
        }

        return Optional.empty();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class F_RubyHarvestMix extends ChargedItem {
    public F_RubyHarvestMix(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ruby_harvest_mix, ItemId.RUBY_HARVEST_MIX_1, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.RUBY_HARVEST_MIX_1).fixedCharges(1),
            new TriggerItem(ItemId.RUBY_HARVEST_MIX_2).fixedCharges(2),
        };
    }

    @Override
    public String getTooltip() {
        return "Ruby harvest mix: " + getTotalCharges();
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.CombatStyle;
import tictac7x.charges.store.HitsplatTarget;
import tictac7x.charges.store.Store;

public class J_AmuletOfBloodFury extends ChargedItem {
    public J_AmuletOfBloodFury(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.amulet_of_blood_fury, ItemId.AMULET_OF_BLOOD_FURY, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.AMULET_OF_BLOOD_FURY),
        };

        this.triggers = new TriggerBase[]{
            // Creation
            new OnChatMessage("You have successfully created an Amulet of blood fury.").setFixedCharges(10000),

            // Check.
            new OnChatMessage("Your Amulet of blood fury (will work|can perform) for (?<charges>.+) more hits?.").setDynamicallyCharges(),

            // Charge.
            new OnChatMessage("You have successfully added .+ hits? to your Amulet of blood fury. It will now work for (?<charges>.+) more hits?.").setDynamicallyCharges(),

            // Take damage.
            new OnHitsplatApplied(HitsplatTarget.ENEMY).combatStyle(CombatStyle.MELEE).isEquipped().decreaseCharges(1),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnGraphicChanged;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class S_TomeOfFire extends ChargedItem {
    public S_TomeOfFire(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.tome_of_fire, ItemId.TOME_OF_FIRE, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TOME_OF_FIRE_UNCHARGED).fixedCharges(0),
            new TriggerItem(ItemId.TOME_OF_FIRE).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your tome has been charged with (Burnt|Searing) Pages. It currently holds (?<charges>.+) charges?.").setDynamicallyCharges().onItemClick(),

            // Attack with regular spellbook fire spells.
            new OnGraphicChanged(99, 126, 129, 155, 1464).isEquipped().decreaseCharges(1),

            // Auto-charge.
            new OnChatMessage("The banker charges your Tome of fire using (?<burntpage>.+)x Burnt page.").matcherConsumer(m -> {
                final int burntPages = Integer.parseInt(m.group("burntpage"));
                increaseCharges(burntPages * 20);
            }),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.*;
import tictac7x.charges.store.HitsplatTarget;
import tictac7x.charges.store.Store;

public class J_RingOfRecoil extends ChargedItem {
    public J_RingOfRecoil(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.ring_of_recoil, ItemId.RING_OF_RECOIL, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.RING_OF_RECOIL).needsToBeEquipped(),
        };

        this.triggers = new TriggerBase[]{
            // Check.
            new OnChatMessage("You can inflict one more point of damage before a ring will shatter.").setFixedCharges(1),

            // Check.
            new OnChatMessage("You can inflict (?<charges>.+) more points of damage before a ring will shatter.").setDynamicallyCharges(),

            // Trying to break when full.
            new OnChatMessage("The ring is fully charged. There would be no point in breaking it.").onItemClick().setFixedCharges(40),

            // Shattered.
            new OnChatMessage("Your Ring of Recoil has shattered.").notification().setFixedCharges(40),

            // Take damage.
            new OnHitsplatApplied(HitsplatTarget.SELF).moreThanZeroDamage().isEquipped().decreaseCharges(1),

            // Check from break dialog.
            new OnWidgetLoaded(219, 1, 0).text("Status: (?<charges>.+) damage points? left.").setDynamically(),

            // Break.
            new OnChatMessage("The ring shatters. Your next ring of recoil will start afresh from (?<charges>.+) damage points?.").setDynamicallyCharges(),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnHitsplatApplied;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

import static tictac7x.charges.store.HitsplatTarget.SELF;

public class A_CrystalBody extends ChargedItem {
    public A_CrystalBody(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.crystal_body, ItemId.CRYSTAL_BODY, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.CRYSTAL_BODY),
            new TriggerItem(ItemId.CRYSTAL_BODY_HEFIN),
            new TriggerItem(ItemId.CRYSTAL_BODY_ITHELL),
            new TriggerItem(ItemId.CRYSTAL_BODY_IORWERTH),
            new TriggerItem(ItemId.CRYSTAL_BODY_TRAHAEARN),
            new TriggerItem(ItemId.CRYSTAL_BODY_CADARN),
            new TriggerItem(ItemId.CRYSTAL_BODY_CRWYS),
            new TriggerItem(ItemId.CRYSTAL_BODY_AMLODD),
            new TriggerItem(ItemId.CRYSTAL_BODY_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_BODY_HEFIN_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_BODY_ITHELL_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_BODY_IORWERTH_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_BODY_TRAHAEARN_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_BODY_CADARN_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_BODY_CRWYS_INACTIVE).fixedCharges(0),
            new TriggerItem(ItemId.CRYSTAL_BODY_AMLODD_INACTIVE).fixedCharges(0),
        };

        this.triggers = new TriggerBase[] {
            new OnChatMessage("Your crystal body has (?<charges>.+) charges? remaining").setDynamicallyCharges().onItemClick(),
            new OnHitsplatApplied(SELF).isEquipped().decreaseCharges(1)
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.OnChatMessage;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Charges;
import tictac7x.charges.store.Store;

public class J_Camulet extends ChargedItem {
    public J_Camulet(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.camulet, ItemId.CAMULET, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.CAMULET),
        };

        this.triggers = new TriggerBase[] {
            // Check.
            new OnChatMessage("Your Camulet has one charge left.").setFixedCharges(1),
            new OnChatMessage("Your Camulet has (?<charges>.+) charges left.").setDynamicallyCharges(),

            // Recharge.
            new OnChatMessage("You recharge the Camulet using camel dung. Yuck!").setFixedCharges(4),

            // Trying to charge fully charged.
            new OnChatMessage("The Camulet is already fully charged.").setFixedCharges(4),

            // Unlimited charges.
            new OnChatMessage("The Camulet has unlimited charges.").setFixedCharges(Charges.UNLIMITED),

            // Replace check.
            new OnMenuEntryAdded("Check-charge").replaceOption("Check"),

            // Replace rub
            new OnMenuEntryAdded("Rub").replaceOption("Teleport"),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.item.ChargedItem;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.Store;

public class J_SlayerRing extends ChargedItem {
    public J_SlayerRing(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.slayer_ring, ItemId.SLAYER_RING_8, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.SLAYER_RING_1).fixedCharges(1),
            new TriggerItem(ItemId.SLAYER_RING_2).fixedCharges(2),
            new TriggerItem(ItemId.SLAYER_RING_3).fixedCharges(3),
            new TriggerItem(ItemId.SLAYER_RING_4).fixedCharges(4),
            new TriggerItem(ItemId.SLAYER_RING_5).fixedCharges(5),
            new TriggerItem(ItemId.SLAYER_RING_6).fixedCharges(6),
            new TriggerItem(ItemId.SLAYER_RING_7).fixedCharges(7),
            new TriggerItem(ItemId.SLAYER_RING_8).fixedCharges(8),
        };
    }
}

package tictac7x.charges.items;

import com.google.gson.Gson;
import net.runelite.api.Client;
import tictac7x.charges.store.ItemId;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import tictac7x.charges.TicTac7xChargesImprovedConfig;
import tictac7x.charges.TicTac7xChargesImprovedPlugin;
import tictac7x.charges.item.ChargedItemWithStorage;
import tictac7x.charges.item.storage.StorableItem;
import tictac7x.charges.item.triggers.OnItemContainerChanged;
import tictac7x.charges.item.triggers.OnMenuEntryAdded;
import tictac7x.charges.item.triggers.TriggerBase;
import tictac7x.charges.item.triggers.TriggerItem;
import tictac7x.charges.store.ItemContainerId;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.WidgetId;

public class U_TackleBox extends ChargedItemWithStorage {
    public U_TackleBox(
        final Client client,
        final ClientThread clientThread,
        final ConfigManager configManager,
        final ItemManager itemManager,
        final InfoBoxManager infoBoxManager,
        final ChatMessageManager chatMessageManager,
        final Notifier notifier,
        final TicTac7xChargesImprovedConfig config,
        final Store store,
        final Gson gson
    ) {
        super(TicTac7xChargesImprovedConfig.tackle_box, ItemId.TACKLE_BOX, client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson);
        this.storage = storage.storableItems(
            new StorableItem(ItemId.ANGLER_HAT),
            new StorableItem(ItemId.ANGLER_TOP),
            new StorableItem(ItemId.ANGLER_WADERS),
            new StorableItem(ItemId.ANGLER_BOOTS),
            new StorableItem(ItemId.SPIRIT_ANGLER_HEADBAND),
            new StorableItem(ItemId.SPIRIT_ANGLER_TOP),
            new StorableItem(ItemId.SPIRIT_ANGLER_WADERS),
            new StorableItem(ItemId.SPIRIT_ANGLER_BOOTS),
            new StorableItem(ItemId.SPIRIT_FLAKES),
            new StorableItem(ItemId.FISHBOWL_HELMET),
            new StorableItem(ItemId.FLIPPERS),
            new StorableItem(ItemId.DARK_FLIPPERS),
            new StorableItem(ItemId.DIVING_APPARATUS),
            new StorableItem(ItemId.TINY_NET),
            new StorableItem(ItemId.RADAS_BLESSING_1),
            new StorableItem(ItemId.RADAS_BLESSING_2),
            new StorableItem(ItemId.RADAS_BLESSING_3),
            new StorableItem(ItemId.RADAS_BLESSING_4),
            new StorableItem(ItemId.HARPOON),
            new StorableItem(ItemId.BARBTAIL_HARPOON),
            new StorableItem(ItemId.DRAGON_HARPOON),
            new StorableItem(ItemId.DRAGON_HARPOON_OR),
            new StorableItem(ItemId.DRAGON_HARPOON_OR_30349),
            new StorableItem(ItemId.INFERNAL_HARPOON),
            new StorableItem(ItemId.INFERNAL_HARPOON_UNCHARGED),
            new StorableItem(ItemId.INFERNAL_HARPOON_UNCHARGED_25367),
            new StorableItem(ItemId.INFERNAL_HARPOON_UNCHARGED_30343),
            new StorableItem(ItemId.INFERNAL_HARPOON_OR),
            new StorableItem(ItemId.INFERNAL_HARPOON_OR_30342),
            new StorableItem(ItemId.CRYSTAL_HARPOON),
            new StorableItem(ItemId.CRYSTAL_HARPOON_23864),
            new StorableItem(ItemId.CRYSTAL_HARPOON_INACTIVE),
            new StorableItem(ItemId.MERFOLK_TRIDENT),
            new StorableItem(ItemId.FISHING_ROD),
            new StorableItem(ItemId.PEARL_FISHING_ROD),
            new StorableItem(ItemId.FLY_FISHING_ROD),
            new StorableItem(ItemId.PEARL_FLY_FISHING_ROD),
            new StorableItem(ItemId.OILY_FISHING_ROD),
            new StorableItem(ItemId.OILY_PEARL_FISHING_ROD),
            new StorableItem(ItemId.BARBARIAN_ROD),
            new StorableItem(ItemId.PEARL_BARBARIAN_ROD),
            new StorableItem(ItemId.SMALL_FISHING_NET),
            new StorableItem(ItemId.BIG_FISHING_NET),
            new StorableItem(ItemId.DRIFT_NET),
            new StorableItem(ItemId.LOBSTER_POT),
            new StorableItem(ItemId.KARAMBWAN_VESSEL),
            new StorableItem(ItemId.KARAMBWAN_VESSEL_3159),
            new StorableItem(ItemId.RAW_KARAMBWANJI),
            new StorableItem(ItemId.FISHING_BAIT),
            new StorableItem(ItemId.FEATHER),
            new StorableItem(ItemId.DARK_FISHING_BAIT),
            new StorableItem(ItemId.SANDWORMS),
            new StorableItem(ItemId.FISH_OFFCUTS),
            new StorableItem(ItemId.FISH_CHUNKS),
            new StorableItem(ItemId.FISHING_POTION_1),
            new StorableItem(ItemId.FISHING_POTION2),
            new StorableItem(ItemId.FISHING_POTION3),
            new StorableItem(ItemId.FISHING_POTION4),
            new StorableItem(ItemId.MOLCH_PEARL),
            new StorableItem(ItemId.STRIPY_FEATHER)
        );

        this.items = new TriggerItem[]{
            new TriggerItem(ItemId.TACKLE_BOX),
        };

        this.triggers = new TriggerBase[]{
            // Fill from inventory.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).fillStorageFromInventory().onMenuOption("Fill", TicTac7xChargesImprovedPlugin.menuOptionFillFromInventory),

            // Empty to inventory.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).emptyStorageToInventory().onMenuOption("Empty", TicTac7xChargesImprovedPlugin.menuOptionEmptyToInventory),

            // Use storable item on kit.
            new OnItemContainerChanged(ItemContainerId.INVENTORY).fillStorageFromInventory().onUseChargedItemOnStorageItem(storage.getStorableItems()),
            new OnItemContainerChanged(ItemContainerId.INVENTORY).fillStorageFromInventory().onUseStorageItemOnChargedItem(storage.getStorableItems()),

            // Update from item container when viewing huntsmans kit contents.
            new OnItemContainerChanged(ItemContainerId.TACKLE_BOX).updateStorage(),

            // Replace "Use" with proper Fill/Empty option.
            new OnMenuEntryAdded("Use").replaceOptionConsumer(() -> getMenuOptionForUse()).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),
            new OnMenuEntryAdded("Use").replaceOptionConsumer(() -> getMenuOptionForUse()).isWidgetVisible(WidgetId.BANK, WidgetId.DEPOSIT_BOX),

            // Hide destroy.
            new OnMenuEntryAdded("Destroy").hide(),
        };
    }

    private String getMenuOptionForUse() {
        return storage.isStorableItemInInventory()
            ? TicTac7xChargesImprovedPlugin.menuOptionFillFromInventory
            : TicTac7xChargesImprovedPlugin.menuOptionEmptyToInventory;
    }
}

package tictac7x.charges;

import com.google.common.collect.ImmutableMap;
import com.google.gson.Gson;
import com.google.inject.Provides;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.*;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.OSType;
import tictac7x.charges.customEvents.CustomChatMessage;
import tictac7x.charges.customEvents.CustomHitsplatApplied;
import tictac7x.charges.item.ChargedItemBase;
import tictac7x.charges.item.overlays.ChargedItemInfobox;
import tictac7x.charges.item.overlays.ChargedItemOverlay;
import tictac7x.charges.customEvents.CustomItemContainerChanged;
import tictac7x.charges.items.*;
import tictac7x.charges.items.barrows.*;
import tictac7x.charges.customEvents.CustomMenuOptionClicked;
import tictac7x.charges.items.moons.*;
import tictac7x.charges.store.Store;
import tictac7x.charges.store.VarbitId;

import javax.inject.Inject;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;

@PluginDescriptor(
	name = "Item Charges Improved",
	description = "Show charges of various items",
	tags = {
		"charges",
		"barrows",
		"crystal",
		"ardougne",
		"coffing",
		"magic",
		"cape",
		"circlet",
		"bracelet",
		"clay",
		"expeditious",
		"flamtaer",
		"slaughter",
		"camulet",
		"celestial",
		"ring",
		"escape",
		"recoil",
		"shadow",
		"suffering",
		"slayer",
		"xeric",
		"talisman",
		"chronicle",
		"dragonfire",
		"falador",
		"kharedst",
		"memoirs",
		"ash",
		"sanctifier",
		"bone",
		"crusher",
		"bottomless",
		"compost",
		"bucket",
		"coal",
		"bag",
		"fish",
		"barrel",
		"fungicide",
		"spray",
		"gem",
		"gricoller",
		"can",
		"herb",
		"sack",
		"log",
		"basket",
		"ogre",
		"bellows",
		"seed",
		"box",
		"soul",
		"bearer",
		"teleport",
		"waterskin",
		"arclight",
		"bryophyta",
		"staff",
		"bow",
		"halberd",
		"iban",
		"pharaoh",
		"sceptre",
		"sanguinesti",
		"skull",
		"trident",
		"sea",
		"toxic",
		"jar",
		"tome",
		"fur",
		"meat",
		"pouch",
		"pursuit",
		"book",
		"scroll"
	}
)

public class TicTac7xChargesImprovedPlugin extends Plugin implements KeyListener, MouseListener, MouseWheelListener {
	private final String pluginVersion = "v0.6.2";
	private final String pluginMessage =
		"<colHIGHLIGHT>Item Charges Improved " + pluginVersion + ":<br>" +
		"<colHIGHLIGHT>* Games necklace added.<br>" +
		"<colHIGHLIGHT>* Imp in a box added.<br>" +
		"<colHIGHLIGHT>* Barrows charges formula fixed.<br>" +
		"<colHIGHLIGHT>* Escape crystal now uses ticks by default for more precise remaining time.<br>" +
		"<colHIGHLIGHT>* Seed box fixes, reagent pouch improvements."
	;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private TicTac7xChargesImprovedConfig config;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private TooltipManager tooltipManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private Notifier notifier;
	
	@Inject
	private Gson gson;

	@Provides
	TicTac7xChargesImprovedConfig provideConfig(final ConfigManager configManager) {
		return configManager.getConfig(TicTac7xChargesImprovedConfig.class);
	}

	private Store store;

	private ChargedItemOverlay overlayChargedItems;

	private ChargedItemBase[] chargedItems;
	private final List<InfoBox> chargedItemsInfoboxes = new ArrayList<>();

	private final ZoneId timezone = ZoneId.of("Europe/London");
	public static final String INFINITE_SYMBOL = OSType.getOSType() == OSType.MacOS ? "inf" : "∞";

	@Override
	protected void startUp() {
		configMigration();
		keyManager.registerKeyListener(this);
		mouseManager.registerMouseListener(this);
		mouseManager.registerMouseWheelListener(this);

		store = new Store(client, itemManager, configManager);

		chargedItems = new ChargedItemBase[]{
			// Crystal armor set
			new A_CrystalBody(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new A_CrystalHelm(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new A_CrystalLegs(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Boots
			new B_FremennikSeaBoots(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Capes
			new C_ArdougneCloak(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new C_Coffin(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new C_ForestryBasket(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new C_ForestryKit(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new C_MagicCape(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Foods
			new F_BlackWarlockMix(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new F_MoonlightMothMix(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new F_RubyHarvestMix(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new F_SapphireGlacialisMix(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new F_SnowyKnightMix(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new F_SunlightMothMix(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Helms
			new H_CircletOfWater(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new H_KandarinHeadgear(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Jewellery
			new J_AlchemistsAmulet(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_AmuletOfChemistry(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_AmuletOfBloodFury(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_BindingNecklace(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_BraceletOfClay(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_BraceletOfSlaughter(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_BurningAmulet(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_Camulet(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_CastleWarsBracelet(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_DesertAmulet(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_DigsitePendant(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_EfaritaysAid(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_EscapeCrystal(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_ExpeditiousBracelet(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_FlamtaerBracelet(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_GamesNecklace(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_GiantsoulAmulet(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_NecklaceOfPassage(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_PhoenixNecklace(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_DodgyNecklace(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_PendantOfAtes(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_CelestialRing(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfDueling(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfForging(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfTheElements(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfEndurance(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_ExplorersRing(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfPursuit(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfRecoil(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfShadows(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_SlayerRing(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_RingOfSuffering(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_SkillsNecklace(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new J_XericsTalisman(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Shields
			new S_Chronicle(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new S_CrystalShield(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new S_DragonfireShield(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new S_FaladorShield(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new S_KharedstMemoirs(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new S_TomeOfEarth(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new S_TomeOfFire(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new S_TomeOfWater(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Utilities
			new U_AshSanctifier(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_BoneCrusher(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_BottomlessCompostBucket(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_ChuggingBarrel(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_CoalBag(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_CrystalSaw(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_ColossalPouch(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_FishBarrel(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_FlamtaerBag(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_FungicideSpray(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_FurPouch(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_GemBag(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_GricollersCan(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_HerbSack(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_HuntsmansKit(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_ImpInABox(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_JarGenerator(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_LogBasket(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_MasterScrollBook(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_MeatPouch(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_OgreBellows(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_QuetzalWhistle(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_PlankSack(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_ReagentPouch(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_SeedBox(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_SoulBearer(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_StrangeOldLockpick(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_TackleBox(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_TeleportCrystal(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_EternalTeleportCrystal(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new U_Waterskin(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Weapons
			new W_Arclight(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_BowOfFaerdhinen(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_BryophytasStaff(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_CrystalBow(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_CrystalHalberd(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_EnchantedLyre(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_IbansStaff(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_PharaohsSceptre(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_SanguinestiStaff(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_ScytheOfVitur(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_SkullSceptre(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_SlayerStaffE(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_TridentOfTheSeas(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_TridentOfTheSeasE(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_TridentOfTheSwamp(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_TridentOfTheSwampE(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_TumekensShadow(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_VenatorBow(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_WarpedSceptre(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new W_WesternBanner(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Barrows armor sets
			new AhrimsHood(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new AhrimsRobetop(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new AhrimsRobeskirt(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new AhrimsStaff(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			new DharoksHelm(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new DharoksPlatebody(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new DharoksPlatelegs(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new DharoksGreataxe(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			new GuthansHelm(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new GuthansPlatebody(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new GuthansChainskirt(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new GuthansWarspear(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			new KarilsCoif(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new KarilsLeathertop(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new KarilsLeatherskirt(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new KarilsCrossbow(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			new ToragsHelm(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new ToragsPlatebody(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new ToragsPlatelegs(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new ToragsHammers(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			new VeracsHelm(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new VeracsBrassard(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new VeracsPlateskirt(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new VeracsFlail(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),

			// Moons armor set.
			new BloodMoonHelm(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new BloodMoonChestplate(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new BloodMoonTassets(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new BlueMoonHelm(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new BlueMoonChestplate(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new BlueMoonTassets(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new EclipseMoonHelm(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new EclipseMoonChestplate(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
			new EclipseMoonTassets(client, clientThread, configManager, itemManager, infoBoxManager, chatMessageManager, notifier, config, store, gson),
		};

		store.setChargedItems(chargedItems);

		// Items overlays.
		overlayChargedItems = new ChargedItemOverlay(client, tooltipManager, itemManager, configManager, config, chargedItems);
		overlayManager.add(overlayChargedItems);

		// Items infoboxes.
		for (final ChargedItemBase chargedItem : chargedItems) {
			final ChargedItemInfobox chargedItemInfobox = new ChargedItemInfobox(chargedItem, itemManager, infoBoxManager, configManager, config, this);
			chargedItemsInfoboxes.add(chargedItemInfobox);
			infoBoxManager.addInfoBox(chargedItemInfobox);
		}
	}

	@Override
	protected void shutDown() {
		keyManager.unregisterKeyListener(this);
		mouseManager.unregisterMouseListener(this);
		mouseManager.unregisterMouseWheelListener(this);
		overlayManager.remove(overlayChargedItems);
		chargedItemsInfoboxes.forEach(chargedItemInfobox -> infoBoxManager.removeInfoBox(chargedItemInfobox));
		chargedItemsInfoboxes.clear();
	}

	@Subscribe
	public void onChatMessage(final ChatMessage event) {
		final CustomChatMessage chatMessage = new CustomChatMessage(event);
		store.onChatMessage(chatMessage);
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onChatMessage(chatMessage));
	}

	@Subscribe
	public void onItemContainerChanged(final ItemContainerChanged event) {
		final CustomItemContainerChanged itemContainerChanged = new CustomItemContainerChanged(event, itemManager);
		store.onItemContainerChanged(itemContainerChanged);
	}

	@Subscribe
	public void onGraphicChanged(final GraphicChanged event) {
		if (event.getActor() != client.getLocalPlayer()) return;
		store.onGraphicChanged(event);

		Arrays.stream(chargedItems).forEach(infobox -> infobox.onGraphicChanged(event));

		if (config.showDebugIds()) {
			for (final ActorSpotAnim graphic : event.getActor().getSpotAnims()) {
				chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage("[Item Charges Improved] Graphic ID: " + graphic.getId())
					.build()
				);
			}
		}
	}

	@Subscribe
	public void onHitsplatApplied(final HitsplatApplied event) {
		final CustomHitsplatApplied hitsplatApplied = new CustomHitsplatApplied(event, client);
		store.onHitSplatApplied(hitsplatApplied);
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onHitsplatApplied(hitsplatApplied));
	}

	@Subscribe
	public void onAnimationChanged(final AnimationChanged event) {
		if (event.getActor() != client.getLocalPlayer() || event.getActor().getAnimation() == -1) return;

		Arrays.stream(chargedItems).forEach(infobox -> infobox.onAnimationChanged(event));

		if (config.showDebugIds()) {
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage("[Item Charges Improved] Animation ID: " + event.getActor().getAnimation())
				.build()
			);
		}
	}

	@Subscribe
	public void onWidgetLoaded(final WidgetLoaded event) {
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onWidgetLoaded(event));

//		System.out.println("WIDGET | " +
//			"group: " + event.getGroupId()
//		);
	}

	@Subscribe
	public void onMenuOptionClicked(final MenuOptionClicked event) {
		final CustomMenuOptionClicked customMenuOptionClicked = new CustomMenuOptionClicked(event, client);

		if (
			// Menu option not found.
			customMenuOptionClicked.option.isEmpty() ||
			// Not menu.
			customMenuOptionClicked.target.isEmpty() && (
				!customMenuOptionClicked.option.contains("Buy-") &&
				!customMenuOptionClicked.option.equals("Continue")
			) ||
			// Start use by clicking on item.
			customMenuOptionClicked.option.equals("Use") && customMenuOptionClicked.action.equals("WIDGET_TARGET") ||
			// Cancel option.
			customMenuOptionClicked.action.equals("CANCEL") ||
			// RuneLite specific action.
			customMenuOptionClicked.action.equals("RUNELITE")
		) return;

		store.onMenuOptionClicked(customMenuOptionClicked);
		store.addConsumerToNextTickQueue(() -> {
			for (final ChargedItemBase chargedItem : chargedItems) {
				chargedItem.onMenuOptionClicked(customMenuOptionClicked);
			}
		});
	}

	final List<Integer> scriptIdsToIgnore = Arrays.asList(
		44, 85, 100, 839, 900, 1004, 1005, 1045, 1445, 1972, 2100, 2101,
		2165, 2250, 2372, 2476, 2512, 2513, 3174, 3277, 3350, 3351, 4024,
		4029, 4482, 4517, 4518, 4666, 4667, 4668, 4669, 4671, 4672, 4716,
		4721, 4729, 4730, 4731, 4734, 5343, 5923, 5933, 5935, 5936, 5939,
		5943, 5944, 6015, 6016, 6063, 6152
	);

	@Subscribe
	public void onScriptPreFired(final ScriptPreFired event) {
		if (scriptIdsToIgnore.contains(event.getScriptId())) return;

//		String scriptDebug = "script id: " + event.getScriptId();
//		try {
//			final Optional<Widget> widget = Optional.ofNullable(event.getScriptEvent().getSource());
//			if (widget.isPresent()) {
//				scriptDebug += ", widget id: " + widget.get().getId();
//			}
//		} catch (final Exception ignored) {}
//		try {
//			String arguments = ", arguments: [";
//			for (final Object argument : event.getScriptEvent().getArguments()) {
//				arguments += argument + ", ";
//			}
//			arguments += "]";
//			scriptDebug += arguments.replaceAll(", ]", "]");
//		} catch (final Exception ignored) {}
//		System.out.println("SCRIPT FIRED | " + scriptDebug);

		Arrays.stream(chargedItems).forEach(infobox -> infobox.onScriptPreFired(event));
	}

	@Subscribe
	public void onGameStateChanged(final GameStateChanged event) {
		if (event.getGameState() == GameState.LOGGING_IN) {
			checkForChargesReset();
		}

		if (event.getGameState() != GameState.LOGGED_IN) return;

		// Send message about plugin updates for once.
		if (!config.getVersion().equals(pluginVersion)) {
			configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.version, pluginVersion);
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(pluginMessage)
				.build()
			);
		}
	}

	@Subscribe
	public void onStatChanged(final StatChanged event) {
//		String statChanged =
//			event.getSkill().getName() +
//			", level: " + event.getLevel() +
//			", total xp: " + event.getXp();
//
//		if (store.getSkillXp(event.getSkill()).isPresent()) {
//			statChanged += ", xp drop: " + (event.getXp() - store.getSkillXp(event.getSkill()).get());
//		}
//		System.out.println("STAT CHANGED | " +
//			statChanged
//		);

		Arrays.stream(chargedItems).forEach(infobox -> infobox.onStatChanged(event));
		store.onStatChanged(event);
	}

	@Subscribe
	public void onItemDespawned(final ItemDespawned event) {
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onItemDespawned(event));
	}

	@Subscribe
	public void onVarbitChanged(final VarbitChanged event) {
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onVarbitChanged(event));

		// If server minutes are 0, it's a new day!
		if (event.getVarbitId() == VarbitId.MINUTES && client.getGameState() == GameState.LOGGED_IN && event.getValue() == 0) {
			checkForChargesReset();
		}

//		System.out.println("VARBIT CHANGED | " +
//			"id: " + event.getVarbitId() +
//			", value: " + event.getValue()
//		);
	}

	@Subscribe
	public void onMenuEntryAdded(final MenuEntryAdded event) {
		if (event.getOption().equals("Cancel")) return;
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onMenuEntryAdded(event));

//		if (event.getMenuEntry().getItemId() != -1) {
//			System.out.println("MENU ENTRY ADDED | " +
//				"item id: " + event.getMenuEntry().getItemId() +
//				", option: " + event.getOption() +
//				", target: " + event.getTarget()
//			);
//		}
	}

	@Subscribe
	public void onGameTick(final GameTick event) {
		store.onGameTick(event);
		Arrays.stream(chargedItems).forEach(infobox -> infobox.onGameTick(event));
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged event) {
		if (event.getGroup().equals(TicTac7xChargesImprovedConfig.group) && event.getKey().equals(TicTac7xChargesImprovedConfig.debug_ids)) {
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(config.showDebugIds()
					? "<colHIGHLIGHT>[Item Charges Improved] Debug information is now enabled."
					: "<colHIGHLIGHT>[Item Charges Improved] Debug information is now disabled."
				).build()
			);
		}
	}

	private void onUserAction() {
		Arrays.stream(chargedItems).forEach(ChargedItemBase::onUserAction);
	}

	private void checkForChargesReset() {
		final String date = LocalDateTime.now(timezone).format(DateTimeFormatter.ISO_LOCAL_DATE);
		if (date.equals(config.getResetDate())) return;

		configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.date, date);
		Arrays.stream(chargedItems).forEach(ChargedItemBase::onResetDaily);

		if (config.showDailyReset()) {
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage("<colHIGHLIGHT>Daily item charges have been reset.")
				.build()
			);
		}
	}

	private void configMigration() {
		// Migrate old hidden infoboxes multi-select to checkboxes.
		final Optional<String> necklaceOfPassageOverlay = Optional.ofNullable(configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, "necklage_of_passage_overlay"));
		final Optional<String> necklaceOfPassageInfobox = Optional.ofNullable(configManager.getConfiguration(TicTac7xChargesImprovedConfig.group, "necklage_of_passage_infobox"));

		if (necklaceOfPassageOverlay.isPresent()) {
			configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.necklace_of_passage + TicTac7xChargesImprovedConfig.overlay, necklaceOfPassageOverlay.get().equals("true"));
			configManager.unsetConfiguration(TicTac7xChargesImprovedConfig.group, "necklage_of_passage_overlay");
		}

		if (necklaceOfPassageInfobox.isPresent()) {
			configManager.setConfiguration(TicTac7xChargesImprovedConfig.group, TicTac7xChargesImprovedConfig.necklace_of_passage + TicTac7xChargesImprovedConfig.infobox, necklaceOfPassageInfobox.get().equals("true"));
			configManager.unsetConfiguration(TicTac7xChargesImprovedConfig.group, "necklage_of_passage_infobox");
		}
	}

	@Override
	public void keyPressed(final KeyEvent keyEvent) {
		onUserAction();
	}

	@Override
	public void keyTyped(final KeyEvent keyEvent) {}

	@Override
	public void keyReleased(final KeyEvent keyEvent) {}

	@Override
	public MouseEvent mousePressed(final MouseEvent mouseEvent) {
		onUserAction();
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseDragged(final MouseEvent mouseEvent) {
		onUserAction();
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseMoved(final MouseEvent mouseEvent) {
		onUserAction();
		return mouseEvent;
	}

	@Override
	public MouseWheelEvent mouseWheelMoved(final MouseWheelEvent mouseWheelEvent) {
		onUserAction();
		return mouseWheelEvent;
	}

	@Override
	public MouseEvent mouseClicked(final MouseEvent mouseEvent) {
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseReleased(final MouseEvent mouseEvent) {
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseEntered(final MouseEvent mouseEvent) {
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseExited(final MouseEvent mouseEvent) {
		return mouseEvent;
	}

	public static String getCleanText(final String text) {
		return text.replaceAll("</?col.*?>", "").replaceAll("<br>", " ").replaceAll("\u00A0"," ");
	}

	public static String getCleanChatMessage(final ChatMessage event) {
		return getCleanText(event.getMessage());
	}

	public static String menuOptionEmptyToBank = "Empty to bank";
	public static String menuOptionFillFromBank = "Fill from bank";
	public static String menuOptionEmptyToInventory = "Empty to inventory";
	public static String menuOptionFillFromInventory = "Fill from inventory";

	public static int getNumberFromCommaString(final String charges) {
		return Integer.parseInt(charges.replaceAll(",", "").replaceAll("\\.", ""));
	}

	public static Optional<Widget> getWidget(final Client client, final int parent, final int child) {
		return Optional.ofNullable(client.getWidget(parent, child));
	}

	public static Optional<Widget> getWidget(final Client client, final int parent, final int child, final int subChild) {
		return getWidget(client, parent, child, Optional.of(subChild));
	}

	public static Optional<Widget> getWidget(final Client client, final int parent, final int child, final Optional<Integer> subChild) {
		final Optional<Widget> widget = getWidget(client, parent, child);
		if (!widget.isPresent()) return Optional.empty();

		if (subChild.isPresent()) {
			return Optional.ofNullable(widget.get().getChild(subChild.get()));
		} else {
			return widget;
		}
	}
	
	private static final ImmutableMap<String, Integer> TEXT_TO_NUMBER_MAP = ImmutableMap.<String, Integer>builder()
		.put("zero", 0).put("one", 1).put("two", 2).put("three", 3).put("four", 4).put("five", 5)
		.put("six", 6).put("seven", 7).put("eight", 8).put("nine", 9).put("ten", 10)
		.put("eleven", 11).put("twelve", 12).put("thirteen", 13).put("fourteen", 14).put("fifteen", 15)
		.put("sixteen", 16).put("seventeen", 17).put("eighteen", 18).put("nineteen", 19).put("twenty", 20)
		.put("thirty", 30).put("forty", 40).put("fifty", 50).put("sixty", 60).put("seventy", 70)
		.put("eighty", 80).put("ninety", 90).put("hundred", 100).build();

	public static int getNumberFromWordRepresentation(final String charges) {
		// Support strings like "twenty two" and "twenty-two"
		final String[] words = charges.toLowerCase().split("[ -]");
		int result = 0;
		int current = 0;

		for (final String word : words) {
			if (TEXT_TO_NUMBER_MAP.containsKey(word)) {
				current += TEXT_TO_NUMBER_MAP.get(word);
			} else if (word.equals("hundred")) {
				current *= 100;
			} else if (word.equals("thousand")) {
				result += current * 1000;
				current = 0;
			}
		}

		return result + current;
	}
}


package tictac7x.charges;

import net.runelite.client.config.*;
import tictac7x.charges.store.*;

import java.awt.Color;

import static tictac7x.charges.TicTac7xChargesImprovedConfig.group;

@ConfigGroup(group)
public interface TicTac7xChargesImprovedConfig extends Config {
    String group = "tictac7x-charges";
    String version = "version";
    String storage_bank = "storage_bank";
    String date = "date";
    String debug_ids = "debug_ids";
    String infobox = "_infobox";
    String overlay = "_overlay";
    String storage = "_storage";

    // Armor sets
    String crystal_body = "crystal_body";
    String crystal_helm = "crystal_helm";
    String crystal_legs = "crystal_legs";
    String barrows_gear = "barrows_gear";
    String moons_gear = "moons_gear";

    // Helms
    String circlet_of_water = "circlet_of_water";
    String kandarin_headgear = "kandarin_headgear";

    // Boots
    String fremennik_sea_boots = "fremennik_sea_boots";

    // Capes
    String ardougne_cloak = "ardougne_cloak";
    String coffin = "coffin";
    String forestry_basket = "forestry_basket";
    String forestry_kit = "forestry_kit";
    String magic_cape = "magic_cape";

    // Foods
    String ruby_harvest_mix = "ruby_harvest_mix";
    String sapphire_glacialis_mix = "sapphire_glacialis_mix";
    String snowy_knight_mix = "snowy_knight_mix";
    String black_warlock_mix = "black_warlock_mix";
    String sunlight_moth_mix = "sunlight_moth_mix";
    String moonlight_moth_mix = "moonlight_moth_mix";

    // Jewellery
    String alchemists_amulet = "alchemists_amulet";
    String amulet_of_blood_fury = "amulet_of_blood_fury";
    String amulet_of_chemistry = "amulet_of_chemistry";
    String binding_necklace = "binding_necklace";
    String bracelet_of_clay = "bracelet_of_clay";
    String bracelet_of_slaughter = "bracelet_of_slaughter";
    String expeditious_bracelet = "expeditious_bracelet";
    String burning_amulet = "burning_amulet";
    String camulet = "camulet";
    String castle_wars_bracelet = "castle_wars_bracelet";
    String celestial_ring = "celestial_ring";
    String desert_amulet = "desert_amulet";
    String digsite_pendant = "digsite_pendant";
    String dodgy_necklace = "dodgy_necklace";
    String efaritays_aid = "efaritays_aid";
    String escape_crystal = "escape_crystal";
    String escape_crystal_status = "escape_crystal_status";
    String escape_crystal_inactivity_period = "escape_crystal_inactivity_period";
    String escape_crystal_time_remaining_warning = "escape_crystal_time_remaining_warning";
    String escape_crystal_time_remaining_unit = "escape_crystal_time_remaining_unit";
    String explorers_ring = "explorers_ring";
    String flamtaer_bracelet = "flamtaer_bracelet";
    String games_necklace = "games_necklace";
    String giantsoul_amulet = "giantsoul_amulet";
    String necklace_of_passage = "necklace_of_passage";
    String pendant_of_ates = "pendant_of_ates";
    String phoenix_necklace = "phoenix_necklace";
    String ring_of_dueling = "ring_of_dueling";
    String ring_of_endurance = "ring_of_endurance";
    String ring_of_forging = "ring_of_forging";
    String ring_of_pursuit = "ring_of_pursuit";
    String ring_of_recoil = "ring_of_recoil";
    String ring_of_shadows = "ring_of_shadows";
    String ring_of_suffering = "ring_of_suffering";
    String ring_of_suffering_status = "ring_of_suffering_status";
    String ring_of_the_elements = "ring_of_the_elements";
    String skills_necklace = "skills_necklace";
    String slayer_ring = "slayer_ring";
    String xerics_talisman = "xerics_talisman";

    // Shields
    String chronicle = "chronicle";
    String crystal_shield = "crystal_shield";
    String dragonfire_shield = "dragonfire_shield";
    String falador_shield = "falador_shield";
    String kharedsts_memoirs = "kharedsts_memoirs";
    String tome_of_earth = "tome_of_earth";
    String tome_of_fire = "tome_of_fire";
    String tome_of_water = "tome_of_water";

    // Utilities
    String ash_sanctifier = "ash_sanctifier";
    String ash_sanctifier_status = "ash_sanctifier_status";
    String bonecrusher = "bonecrusher";
    String bonecrusher_status = "bonecrusher_status";
    String bottomless_compost_bucket = "bottomless_compost_bucket";
    String chugging_barrel = "chugging_barrel";
    String coal_bag = "coal_bag";
    String colossal_pouch = "colossal_pouch";
    String colossal_pouch_decay_count = "colossal_pouch_decay_count";
    String crystal_saw = "crystal_saw";
    String enchanted_lyre = "enchanted_lyre";
    String fish_barrel = "fish_barrel";
    String flamtaer_bag = "flamtaer_bag";
    String fungicide_spray = "fungicide_spray";
    String fur_pouch = "fur_pouch";
    String gem_bag = "gem_bag";
    String gricollers_can = "gricollers_can";
    String herb_sack = "herb_sack";
    String jar_generator = "jar_generator";
    String log_basket = "log_basket";
    String master_scroll_book = "master_scroll_book";
    String meat_pouch = "meat_pouch";
    String huntsmans_kit = "huntsmans_kit";
    String imp_in_a_box = "imp_in_a_box";
    String ogre_bellows = "ogre_bellows";
    String plank_sack = "plank_sack";
    String quetzal_whistle = "quetzal_whistle";
    String reagent_pouch = "reagent_pouch";
    String seed_box = "seed_box";
    String soul_bearer = "soul_bearer";
    String strange_old_lockpick = "strange_old_lockpick";
    String tackle_box = "tackle_box";
    String teleport_crystal = "teleport_crystal";
    String eternal_teleport_crystal = "teleport_crystal";
    String waterskin = "waterskin";

    // Weapons
    String arclight = "arclight";
    String bow_of_faerdhinen = "bow_of_faerdhinen";
    String bryophytas_staff = "bryophytas_staff";
    String crystal_bow = "crystal_bow";
    String crystal_halberd = "crystal_halberd";
    String ibans_staff = "ibans_staff";
    String pharaohs_sceptre = "pharaohs_sceptre";
    String sanguinesti_staff = "sanguinesti_staff";
    String scythe_of_vitur = "scythe_of_vitur";
    String skull_sceptre = "skull_sceptre";
    String slayer_staff_e = "slayer_staff_e";
    String toxic_staff_of_the_dead = "toxic_staff_of_the_dead";
    String trident_of_the_seas = "trident_of_the_seas";
    String trident_of_the_seas_e = "trident_of_the_seas_e";
    String trident_of_the_swamp = "trident_of_the_swamp";
    String trident_of_the_swamp_e = "trident_of_the_swamp_e";
    String tumekens_shadow = "tumekens_shadow";
    String venator_bow = "venator_bow";
    String warped_sceptre = "warped_sceptre";
    String western_banner = "western_banner";

    @ConfigSection(
        name = "General",
        description = "General settings",
        position = 1
    ) String general = "general";

        @ConfigItem(
            keyName = "show_infoboxes",
            name = "Show infoboxes",
            description = "Show or hide all charges infoboxes simultaneously.",
            section = general,
            position = 1
        ) default boolean showInfoboxes() { return true; }

        @ConfigItem(
            keyName = "show_overlays",
            name = "Show overlays",
            description = "Show or hide all charges overlays on top of items simultaneously.",
            section = general,
            position = 2
        ) default boolean showOverlays() { return true; }

        @ConfigItem(
            keyName = "bank_overlays",
            name = "Show overlays in bank",
            description = "Show charges of the items in bank",
            section = general,
            position = 3
        ) default boolean showBankOverlays() { return true; }

        @ConfigItem(
            keyName = "hide_outside_bank_overlays",
            name = "Show overlays only while in bank",
            description = "Shows item charges overlays only when in bank",
            section = general,
            position = 4
        ) default boolean showOverlaysOnlyInBank() { return false; }

        @ConfigItem(
            keyName = "item_overlay_location",
            name = "Item overlay location",
            description = "Location of the charges for item overlays",
            section = general,
            position = 5
        ) default ItemOverlayLocation itemOverlayLocation() { return ItemOverlayLocation.BOTTOM_LEFT; }

        @ConfigItem(
            keyName = "storage_tooltips",
            name = "Show storage tooltips",
            description = "Show tooltips for items with storage",
            section = general,
            position = 6
        ) default boolean showStorageTooltips() { return true; }

        @ConfigItem(
            keyName = "hide_destroy",
            name = "Hide destroy menu entries",
            description = "Hide destroy menu entry from items that make no sense to destroy",
            section = general,
            position = 7
        ) default boolean hideDestroy() { return true; }

        @ConfigItem(
            keyName = "show_unlimited_charges",
            name = "Show unlimited charges",
            description = "Show infinity symbol for items with unlimited charges",
            section = general,
            position = 8
        ) default boolean showUnlimited() { return true; }

        @ConfigItem(
            keyName = "combat_degradable_style",
            name = "Time degradable style",
            description = "How to show charges for combat time degradable gear",
            section = general,
            position = 9
        ) default CombatTimeDegradableStyle combatTimeDegradableStyle() { return CombatTimeDegradableStyle.CHARGES; }

        @ConfigItem(
            keyName = "show_daily_reset",
            name = "Show daily reset message",
            description = "Show message in chatbox when items daily charges have been reset",
            section = general,
            position = 10
        ) default boolean showDailyReset() { return false; }

    @ConfigSection(
        name = "Colors",
        description = "Colors of item overlays",
        position = 2
    ) String colors = "colors";

        @Alpha
        @ConfigItem(
            keyName = "colors_default",
            name = "Default",
            description = "Color of default charges",
            position = 1,
            section = colors
        ) default Color getColorDefault() { return Color.white; }

        @Alpha
        @ConfigItem(
            keyName = "colors_unknown",
            name = "Unknown",
            description = "Color of unknown charges",
            position = 2,
            section = colors
        ) default Color getColorUnknown() { return Color.gray; }

        @Alpha
        @ConfigItem(
            keyName = "colors_empty",
            name = "Empty",
            description = "Color of empty charges",
            position = 3,
            section = colors
        ) default Color getColorEmpty() { return Color.red; }

        @Alpha
        @ConfigItem(
            keyName = "colors_activated",
            name = "Activated",
            description = "Color of activated charges",
            position = 4,
            section = colors
        ) default Color getColorActivated() { return Color.green; }

    @ConfigSection(
        name = "Escape Crystal",
        description = "Escape Crystal",
        position = 3,
        closedByDefault = true
    ) String escape_crystal_section = "escape_crystal_section";

        @ConfigItem(
            keyName = escape_crystal_time_remaining_warning,
            name = "Time remaining alert",
            description = "How many time before you are warned before Escape crystal activates",
            position = 4,
            section = escape_crystal_section
        ) default int getEscapeCrystalTimeRemainingWarning() { return 5; }

        @ConfigItem(
            keyName = escape_crystal_time_remaining_unit,
            name = "Time remaining unit",
            description = "What unit to use for escape crystal activation (ticks is more precise)",
            position = 5,
            section = escape_crystal_section
        ) default EscapeCrystalTimeRemainingUnit getEscapeCrystalTimeRemainingUnit() { return EscapeCrystalTimeRemainingUnit.TICKS; }

    @ConfigSection(
        name = "Infoboxes",
        description = "Choose for which charged items infobox is visible",
        position = 4,
        closedByDefault = true
    ) String infoboxes = "infoboxes";

        @ConfigItem(
            keyName = binding_necklace + infobox,
            name = "Binding necklace",
            description = "",
            section = infoboxes
        ) default boolean bindingNecklaceInfobox() { return true; }

        @ConfigItem(
            keyName = pendant_of_ates + infobox,
            name = "Pendant of ates",
            description = "",
            section = infoboxes
        ) default boolean pendantOfAtesInfobox() { return true; }

        @ConfigItem(
            keyName = digsite_pendant + infobox,
            name = "Digsite pendant",
            description = "",
            section = infoboxes
        ) default boolean digsitePendantInfobox() { return true; }

        @ConfigItem(
            keyName = tumekens_shadow + infobox,
            name = "Tumeken's shadow",
            description = "",
            section = infoboxes
        ) default boolean tumekensShadowInfobox() { return true; }

        @ConfigItem(
            keyName = master_scroll_book + infobox,
            name = "Master scroll book",
            description = "",
            section = infoboxes
        ) default boolean masterScrollBookInfobox() { return true; }

        @ConfigItem(
            keyName = ruby_harvest_mix + infobox,
            name = "Ruby harvest mix",
            description = "",
            section = infoboxes
        ) default boolean rubyHarvestMixInfobox() { return false; }

        @ConfigItem(
            keyName = sapphire_glacialis_mix + infobox,
            name = "Sapphire glacialis mix",
            description = "",
            section = infoboxes
        ) default boolean sapphireGlacialisMixInfobox() { return false; }

        @ConfigItem(
            keyName = snowy_knight_mix + infobox,
            name = "Snowy knight mix",
            description = "",
            section = infoboxes
        ) default boolean snowyKnightMixInfobox() { return false; }

        @ConfigItem(
            keyName = black_warlock_mix + infobox,
            name = "Black warlock mix",
            description = "",
            section = infoboxes
        ) default boolean blackWarlockInfobox() { return false; }

        @ConfigItem(
            keyName = sunlight_moth_mix + infobox,
            name = "Sunlight moth mix",
            description = "",
            section = infoboxes
        ) default boolean sunlightMothMixInfobox() { return false; }

        @ConfigItem(
            keyName = moonlight_moth_mix + infobox,
            name = "Moonlight moth mix",
            description = "",
            section = infoboxes
        ) default boolean moonlightMothMixInfobox() { return false; }

        @ConfigItem(
            keyName = reagent_pouch + infobox,
            name = "Reagent pouch",
            description = "",
            section = infoboxes
        ) default boolean reagentPouchInfobox() { return true; }

        @ConfigItem(
            keyName = ring_of_dueling + infobox,
            name = "Ring of dueling",
            description = "",
            section = infoboxes
        ) default boolean ringOfDuelingInfobox() { return true; }

        @ConfigItem(
            keyName = ring_of_forging + infobox,
            name = "Ring of forging",
            description = "",
            section = infoboxes
        ) default boolean ringOfForgingInfobox() { return true; }

        @ConfigItem(
            keyName = ring_of_pursuit + infobox,
            name = "Ring of pursuit",
            description = "",
            section = infoboxes
        ) default boolean ringOfPursuitInfobox() { return true; }

        @ConfigItem(
            keyName = huntsmans_kit + infobox,
            name = "Huntsman's kit",
            description = "",
            section = infoboxes
        ) default boolean huntsmansKitInfobox() { return true; }

        @ConfigItem(
            keyName = imp_in_a_box + infobox,
            name = "Imp in a box",
            description = "",
            section = infoboxes
        ) default boolean impInABoxInfobox() { return true; }

        @ConfigItem(
            keyName = bow_of_faerdhinen + infobox,
            name = "Bow of faerdhinen",
            description = "",
            section = infoboxes
        ) default boolean bowOfFaerdhinenInfobox() { return true; }

        @ConfigItem(
            keyName = venator_bow + infobox,
            name = "Venator bow",
            description = "",
            section = infoboxes
        ) default boolean venatorBowInfobox() { return true; }

        @ConfigItem(
            keyName = meat_pouch + infobox,
            name = "Meat pouch",
            description = "",
            section = infoboxes
        ) default boolean meatPouchInfobox() { return true; }

        @ConfigItem(
            keyName = western_banner + infobox,
            name = "Western banner",
            description = "",
            section = infoboxes
        ) default boolean westernBannerInfobox() { return true; }

        @ConfigItem(
            keyName = barrows_gear + infobox,
            name = "Barrows set",
            description = "",
            section = infoboxes
        ) default boolean barrowsInfobox() { return true; }

        @ConfigItem(
            keyName = moons_gear + infobox,
            name = "Moons gear",
            description = "",
            section = infoboxes
        ) default boolean moonsSetInfobox() { return true; }

        @ConfigItem(
            keyName = crystal_body + infobox,
            name = "Crystal body",
            description = "",
            section = infoboxes
        ) default boolean crystalBodyInfobox() { return true; }

        @ConfigItem(
            keyName = crystal_helm + infobox,
            name = "Crystal helm",
            description = "",
            section = infoboxes
        ) default boolean crystalHelmInfobox() { return true; }

        @ConfigItem(
            keyName = crystal_legs + infobox,
            name = "Crystal legs",
            description = "",
            section = infoboxes
        ) default boolean crystalLegsInfobox() { return true; }

        @ConfigItem(
            keyName = fremennik_sea_boots + infobox,
            name = "Fremennik sea boots",
            description = "",
            section = infoboxes
        ) default boolean fremennikSeaBootsInfobox() { return true; }

        @ConfigItem(
            keyName = ardougne_cloak + infobox,
            name = "Ardougne cloak",
            description = "",
            section = infoboxes
        ) default boolean ardougneCloakInfobox() { return true; }

        @ConfigItem(
            keyName = coffin + infobox,
            name = "Coffin",
            description = "",
            section = infoboxes
        ) default boolean coffinInfobox() { return true; }

        @ConfigItem(
            keyName = forestry_basket + infobox,
            name = "Forestry basket",
            description = "",
            section = infoboxes
        ) default boolean forestryBasketInfobox() { return true; }

        @ConfigItem(
            keyName = forestry_kit + infobox,
            name = "Forestry kit",
            description = "",
            section = infoboxes
        ) default boolean forestryKitInfobox() { return true; }

        @ConfigItem(
            keyName = fur_pouch + infobox,
            name = "Fur pouch",
            description = "",
            section = infoboxes
        ) default boolean furPouchInfobox() { return true; }

        @ConfigItem(
            keyName = magic_cape + infobox,
            name = "Magic cape",
            description = "",
            section = infoboxes
        ) default boolean magicCapeInfobox() { return true; }

        @ConfigItem(
            keyName = circlet_of_water + infobox,
            name = "Circlet of water",
            description = "",
            section = infoboxes
        ) default boolean circletOfWaterInfobox() { return true; }

        @ConfigItem(
            keyName = chugging_barrel + infobox,
            name = "Chugging barrel",
            description = "",
            section = infoboxes
        ) default boolean chuggingBarrelInfobox() { return true; }

        @ConfigItem(
            keyName = kandarin_headgear + infobox,
            name = "Kandarin Headgear",
            description = "",
            section = infoboxes
        ) default boolean kandarinHeadgearInfobox() { return true; }

        @ConfigItem(
            keyName = bracelet_of_clay + infobox,
            name = "Bracelet of clay",
            description = "",
            section = infoboxes
        ) default boolean braceletOfClayInfobox() { return true; }

        @ConfigItem(
            keyName = expeditious_bracelet + infobox,
            name = "Expeditious bracelet",
            description = "",
            section = infoboxes
        ) default boolean expeditiousBraceletInfobox() { return true; }

        @ConfigItem(
            keyName = flamtaer_bracelet + infobox,
            name = "Flamtaer bracelet",
            description = "",
            section = infoboxes
        ) default boolean flamtaerBraceletInfobox() { return true; }

        @ConfigItem(
            keyName = games_necklace + infobox,
            name = "Games necklace",
            description = "",
            section = infoboxes
        ) default boolean gamesNecklaceInfobox() { return true; }

        @ConfigItem(
            keyName = bracelet_of_slaughter + infobox,
            name = "Bracelet of slaughter",
            description = "",
            section = infoboxes
        ) default boolean braceletOfSlaughterInfobox() { return true; }

        @ConfigItem(
            keyName = camulet + infobox,
            name = "Camulet",
            description = "",
            section = infoboxes
        ) default boolean camuletInfobox() { return true; }

        @ConfigItem(
            keyName = castle_wars_bracelet + infobox,
            name = "Castle wars bracelet",
            description = "",
            section = infoboxes
        ) default boolean castleWarsBraceletInfobox() { return true; }

        @ConfigItem(
            keyName = desert_amulet + infobox,
            name = "Desert amulet",
            description = "",
            section = infoboxes
        ) default boolean desertAmuletInfobox() { return true; }

        @ConfigItem(
            keyName = escape_crystal + infobox,
            name = "Escape crystal",
            description = "",
            section = infoboxes
        ) default boolean escapeCrystalInfobox() { return true; }

        @ConfigItem(
            keyName = dodgy_necklace + infobox,
            name = "Dodgy necklace",
            description = "",
            section = infoboxes
        ) default boolean dodgyNecklaceInfobox() { return true; }

        @ConfigItem(
            keyName = necklace_of_passage + infobox,
            name = "Necklace of passage",
            description = "",
            section = infoboxes
        ) default boolean necklaceOfPassageInfobox() { return true; }

        @ConfigItem(
            keyName = phoenix_necklace + infobox,
            name = "Phoenix necklace",
            description = "",
            section = infoboxes
        ) default boolean phoenixNecklaceInfobox() { return true; }

        @ConfigItem(
            keyName = celestial_ring + infobox,
            name = "Celestial ring",
            description = "",
            section = infoboxes
        ) default boolean celestialRingInfobox() { return true; }

        @ConfigItem(
            keyName = ring_of_the_elements + infobox,
            name = "Ring of the elements",
            description = "",
            section = infoboxes
        ) default boolean ringOfTheElementsInfobox() { return true; }

        @ConfigItem(
            keyName = ring_of_endurance + infobox,
            name = "Ring of endurance",
            description = "",
            section = infoboxes
        ) default boolean ringOfEnduranceInfobox() { return true; }

        @ConfigItem(
            keyName = explorers_ring + infobox,
            name = "Explorer's ring",
            description = "",
            section = infoboxes
        ) default boolean explorersRingInfobox() { return true; }

        @ConfigItem(
            keyName = ring_of_recoil + infobox,
            name = "Ring of recoil",
            description = "",
            section = infoboxes
        ) default boolean ringOfRecoilInfobox() { return true; }

        @ConfigItem(
            keyName = ring_of_shadows + infobox,
            name = "Ring of shadows",
            description = "",
            section = infoboxes
        ) default boolean ringOfShadowsInfobox() { return true; }

        @ConfigItem(
            keyName = slayer_ring + infobox,
            name = "Slayer ring",
            description = "",
            section = infoboxes
        ) default boolean slayerRingInfobox() { return true; }

        @ConfigItem(
            keyName = ring_of_suffering + infobox,
            name = "Ring of suffering",
            description = "",
            section = infoboxes
        ) default boolean ringOfSufferingInfobox() { return true; }

        @ConfigItem(
            keyName = xerics_talisman + infobox,
            name = "Xeric's talisman",
            description = "",
            section = infoboxes
        ) default boolean xericsTalismanInfobox() { return true; }

        @ConfigItem(
            keyName = chronicle + infobox,
            name = "Chronicle",
            description = "",
            section = infoboxes
        ) default boolean chronicleInfobox() { return true; }

        @ConfigItem(
            keyName = crystal_shield + infobox,
            name = "Crystal shield",
            description = "",
            section = infoboxes
        ) default boolean crystalShieldInfobox() { return true; }

        @ConfigItem(
            keyName = dragonfire_shield + infobox,
            name = "Dragonfire shield",
            description = "",
            section = infoboxes
        ) default boolean dragonfireShieldInfobox() { return true; }

        @ConfigItem(
            keyName = falador_shield + infobox,
            name = "Falador shield",
            description = "",
            section = infoboxes
        ) default boolean faladorShieldInfobox() { return true; }

        @ConfigItem(
            keyName = kharedsts_memoirs + infobox,
            name = "Kharedst's memoirs",
            description = "",
            section = infoboxes
        ) default boolean kharedstsMemoirsInfobox() { return true; }

        @ConfigItem(
            keyName = kharedsts_memoirs + infobox,
            name = "Book of the dead",
            description = "",
            section = infoboxes
        ) default boolean bookOfTheDeadInfobox() { return true; }

        @ConfigItem(
            keyName = tome_of_earth + infobox,
            name = "Tome of earth",
            description = "",
            section = infoboxes
        ) default boolean tomeOfEarthInfobox() { return true; }

        @ConfigItem(
            keyName = tome_of_fire + infobox,
            name = "Tome of fire",
            description = "",
            section = infoboxes
        ) default boolean tomeOfFireInfobox() { return true; }

        @ConfigItem(
            keyName = tome_of_water + infobox,
            name = "Tome of water",
            description = "",
            section = infoboxes
        ) default boolean tomeOfWaterInfobox() { return true; }

        @ConfigItem(
            keyName = ash_sanctifier + infobox,
            name = "Ash sanctifier",
            description = "",
            section = infoboxes
        ) default boolean ashSanctifierInfobox() { return true; }

        @ConfigItem(
            keyName = bonecrusher + infobox,
            name = "Bonecrusher",
            description = "",
            section = infoboxes
        ) default boolean bonecrusherInfobox() { return true; }

        @ConfigItem(
            keyName = bottomless_compost_bucket + infobox,
            name = "Bottomless compost bucket",
            description = "",
            section = infoboxes
        ) default boolean bottomlessCompostBucketInfobox() { return true; }

        @ConfigItem(
            keyName = coal_bag + infobox,
            name = "Coal bag",
            description = "",
            section = infoboxes
        ) default boolean coalBagInfobox() { return true; }

        @ConfigItem(
            keyName = colossal_pouch + infobox,
            name = "Colossal pouch",
            description = "",
            section = infoboxes
        ) default boolean colossalPouchInfobox() { return true; }

        @ConfigItem(
            keyName = crystal_saw + infobox,
            name = "Crystal saw",
            description = "",
            section = infoboxes
        ) default boolean crystalSawInfobox() { return true; }

        @ConfigItem(
            keyName = fish_barrel + infobox,
            name = "Fish barrel",
            description = "",
            section = infoboxes
        ) default boolean fishBarrelInfobox() { return true; }

        @ConfigItem(
            keyName = flamtaer_bag + infobox,
            name = "Flamtaer bag",
            description = "",
            section = infoboxes
        ) default boolean flamtaerBagInfobox() { return true; }

        @ConfigItem(
            keyName = fungicide_spray + infobox,
            name = "Fungicide spray",
            description = "",
            section = infoboxes
        ) default boolean fungicideSprayInfobox() { return true; }

        @ConfigItem(
            keyName = gem_bag + infobox,
            name = "Gem bag",
            description = "",
            section = infoboxes
        ) default boolean gemBagInfobox() { return true; }

        @ConfigItem(
            keyName = giantsoul_amulet + infobox,
            name = "Giantsoul amulet",
            description = "",
            section = infoboxes
        ) default boolean giantsoulAmuletInfobox() { return true; }

        @ConfigItem(
            keyName = gricollers_can + infobox,
            name = "Gricoller's can",
            description = "",
            section = infoboxes
        ) default boolean gricollersCanInfobox() { return true; }

        @ConfigItem(
            keyName = herb_sack + infobox,
            name = "Herb sack",
            description = "",
            section = infoboxes
        ) default boolean herbSackInfobox() { return true; }

        @ConfigItem(
            keyName = jar_generator + infobox,
            name = "Jar generator",
            description = "",
            section = infoboxes
        ) default boolean jarGeneratorInfobox() { return true; }

        @ConfigItem(
            keyName = log_basket + infobox,
            name = "Log basket",
            description = "",
            section = infoboxes
        ) default boolean logBasketInfobox() { return true; }

        @ConfigItem(
            keyName = ogre_bellows + infobox,
            name = "Ogre bellows",
            description = "",
            section = infoboxes
        ) default boolean ogreBellowsInfobox() { return true; }

        @ConfigItem(
            keyName = plank_sack + infobox,
            name = "Plank sack",
            description = "",
            section = infoboxes
        ) default boolean plankSackInfobox() { return true; }

        @ConfigItem(
            keyName = quetzal_whistle + infobox,
            name = "Quetzal whistle",
            description = "",
            section = infoboxes
        ) default boolean quetzalWhistleInfobox() { return true; }

        @ConfigItem(
            keyName = seed_box + infobox,
            name = "Seed box",
            description = "",
            section = infoboxes
        ) default boolean seedBoxInfobox() { return true; }

        @ConfigItem(
            keyName = skills_necklace + infobox,
            name = "Skills necklace",
            description = "",
            section = infoboxes
        ) default boolean skillsNecklaceInfobox() { return true; }

        @ConfigItem(
            keyName = soul_bearer + infobox,
            name = "Soul bearer",
            description = "",
            section = infoboxes
        ) default boolean soulBearerInfobox() { return true; }

        @ConfigItem(
            keyName = strange_old_lockpick + infobox,
            name = "Strange old lockpick",
            description = "",
            section = infoboxes
        ) default boolean strangeOldLockpickInfobox() { return true; }

        @ConfigItem(
            keyName = tackle_box + infobox,
            name = "Tackle box",
            description = "",
            section = infoboxes
        ) default boolean tackleBoxInfobox() { return true; }

        @ConfigItem(
            keyName = teleport_crystal + infobox,
            name = "Teleport crystal",
            description = "",
            section = infoboxes
        ) default boolean teleportCrystalInfobox() { return true; }

        @ConfigItem(
            keyName = eternal_teleport_crystal + infobox,
            name = "Eternal teleport crystal",
            description = "",
            section = infoboxes
        ) default boolean eternalTeleportCrystalInfobox() { return true; }

        @ConfigItem(
            keyName = waterskin + infobox,
            name = "Waterskin",
            description = "",
            section = infoboxes
        ) default boolean waterskinInfobox() { return true; }

        @ConfigItem(
            keyName = arclight + infobox,
            name = "Arclight",
            description = "",
            section = infoboxes
        ) default boolean arclightInfobox() { return true; }

        @ConfigItem(
            keyName = bryophytas_staff + infobox,
            name = "Bryophyta's staff",
            description = "",
            section = infoboxes
        ) default boolean bryophytasStaffInfobox() { return true; }

        @ConfigItem(
            keyName = burning_amulet + infobox,
            name = "Burning amulet",
            description = "",
            section = infoboxes
        ) default boolean burninAmuletInfobox() { return true; }

        @ConfigItem(
            keyName = crystal_bow + infobox,
            name = "Crystal bow",
            description = "",
            section = infoboxes
        ) default boolean crystalBowInfobox() { return true; }

        @ConfigItem(
            keyName = crystal_halberd + infobox,
            name = "Crystal halberd",
            description = "",
            section = infoboxes
        ) default boolean crystalHalberdInfobox() { return true; }

        @ConfigItem(
            keyName = efaritays_aid + infobox,
            name = "Efaritay's aid",
            description = "",
            section = infoboxes
        ) default boolean efaritaysAidInfobox() { return true; }

        @ConfigItem(
            keyName = enchanted_lyre + infobox,
            name = "Enchanted Lyre",
            description = "",
            section = infoboxes
        ) default boolean enchantedLyreInfobox() { return true; }

        @ConfigItem(
            keyName = ibans_staff + infobox,
            name = "Iban's staff",
            description = "",
            section = infoboxes
        ) default boolean ibansStaffInfobox() { return true; }

        @ConfigItem(
            keyName = pharaohs_sceptre + infobox,
            name = "Pharaoh's sceptre",
            description = "",
            section = infoboxes
        ) default boolean pharaohsSceptreInfobox() { return true; }

        @ConfigItem(
            keyName = sanguinesti_staff + infobox,
            name = "Sanguinesti staff",
            description = "",
            section = infoboxes
        ) default boolean sanguinestiStaffInfobox() { return true; }

        @ConfigItem(
            keyName = scythe_of_vitur + infobox,
            name = "Scythe of Vitur",
            description = "",
            section = infoboxes
        ) default boolean scytheOfViturInfobox() { return true; }

        @ConfigItem(
            keyName = skull_sceptre + infobox,
            name = "Skull sceptre",
            description = "",
            section = infoboxes
        ) default boolean skullSceptreInfobox() { return true; }

        @ConfigItem(
            keyName = slayer_staff_e + infobox,
            name = "Slayer staff (e)",
            description = "",
            section = infoboxes
        ) default boolean slayerStaffEInfobox() { return true; }

        @ConfigItem(
            keyName = toxic_staff_of_the_dead + infobox,
            name = "Toxic staff of the dead",
            description = "",
            section = infoboxes
        ) default boolean toxicStaffOfTheDeadInfobox() { return true; }

        @ConfigItem(
            keyName = trident_of_the_seas + infobox,
            name = "Trident of the seas",
            description = "",
            section = infoboxes
        ) default boolean tridentOfTheSeasInfobox() { return true; }

        @ConfigItem(
            keyName = trident_of_the_seas_e + infobox,
            name = "Trident of the seas (e)",
            description = "",
            section = infoboxes
        ) default boolean tridentOfTheSeasEInfobox() { return true; }

        @ConfigItem(
            keyName = trident_of_the_swamp + infobox,
            name = "Trident of the swamp",
            description = "",
            section = infoboxes
        ) default boolean tridentOfTheSwampInfobox() { return true; }

        @ConfigItem(
            keyName = trident_of_the_swamp_e + infobox,
            name = "Trident of the swamp (e)",
            description = "",
            section = infoboxes
        ) default boolean tridentOfTheSwampEInfobox() { return true; }

        @ConfigItem(
            keyName = warped_sceptre + infobox,
            name = "Warped sceptre",
            description = "",
            section = infoboxes
        ) default boolean warpedSceptreInfobox() { return true; }

        @ConfigItem(
            keyName = alchemists_amulet + infobox,
            name = "Alchemist's amulet",
            description = "",
            section = infoboxes
        ) default boolean alchemistsAmuletInfobox() { return true; }

        @ConfigItem(
            keyName = amulet_of_blood_fury + infobox,
            name = "Amulet of blood fury",
            description = "",
            section = infoboxes
        ) default boolean amuletOfBloodFuryInfobox() { return true; }

        @ConfigItem(
            keyName = amulet_of_chemistry + infobox,
            name = "Amulet of chemistry",
            description = "",
            section = infoboxes
        ) default boolean amuletOfChemistryInfobox() { return true; }

    @ConfigSection(
        name = "Overlays",
        description = "Choose for which charged items number is shown next to it",
        position = 4,
        closedByDefault = true
    ) String overlays = "overlays";

        @ConfigItem(
            keyName = binding_necklace + overlay,
            name = "Binding necklace",
            description = "",
            section = overlays
        ) default boolean bindingNecklaceOverlay() { return true; }

        @ConfigItem(
            keyName = pendant_of_ates + overlay,
            name = "Pendant of ates",
            description = "",
            section = overlays
        ) default boolean pendantOfAtesOverlay() { return true; }

        @ConfigItem(
            keyName = digsite_pendant + overlay,
            name = "Digsite pendant",
            description = "",
            section = overlays
        ) default boolean digsitePendantOverlay() { return true; }

        @ConfigItem(
            keyName = tumekens_shadow + overlay,
            name = "Tumeken's shadow",
            description = "",
            section = overlays
        ) default boolean tumekensShadowOverlay() { return true; }

        @ConfigItem(
            keyName = master_scroll_book + overlay,
            name = "Master scroll book",
            description = "",
            section = overlays
        ) default boolean masterScrollBookOverlay() { return true; }

        @ConfigItem(
            keyName = ruby_harvest_mix + overlay,
            name = "Ruby harvest mix",
            description = "",
            section = overlays
        ) default boolean rubyHarvestMixOverlay() { return true; }

        @ConfigItem(
            keyName = sapphire_glacialis_mix + overlay,
            name = "Sapphire glacialis mix",
            description = "",
            section = overlays
        ) default boolean sapphireGlacialisMixOverlay() { return true; }

        @ConfigItem(
            keyName = snowy_knight_mix + overlay,
            name = "Snowy knight mix",
            description = "",
            section = overlays
        ) default boolean snowyKnightMixOverlay() { return true; }

        @ConfigItem(
            keyName = black_warlock_mix + overlay,
            name = "Black warlock mix",
            description = "",
            section = overlays
        ) default boolean blackWarlockOverlay() { return true; }

        @ConfigItem(
            keyName = sunlight_moth_mix + overlay,
            name = "Sunlight moth mix",
            description = "",
            section = overlays
        ) default boolean sunlightMothMixOverlay() { return true; }

        @ConfigItem(
            keyName = moonlight_moth_mix + overlay,
            name = "Moonlight moth mix",
            description = "",
            section = overlays
        ) default boolean moonlightMothMixOverlay() { return true; }

        @ConfigItem(
            keyName = reagent_pouch + overlay,
            name = "Reagent pouch",
            description = "",
            section = overlays
        ) default boolean reagentPouchOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_dueling + overlay,
            name = "Ring of dueling",
            description = "",
            section = overlays
        ) default boolean ringOfDuelingOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_forging + overlay,
            name = "Ring of forging",
            description = "",
            section = overlays
        ) default boolean ringOfForgingOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_pursuit + overlay,
            name = "Ring of pursuit",
            description = "",
            section = overlays
        ) default boolean ringOfPursuitOverlay() { return true; }

        @ConfigItem(
            keyName = huntsmans_kit + overlay,
            name = "Huntsman's kit",
            description = "",
            section = overlays
        ) default boolean huntsmansKitOverlay() { return true; }

        @ConfigItem(
            keyName = imp_in_a_box + overlay,
            name = "Imp in a box",
            description = "",
            section = overlays
        ) default boolean impInABoxOverlay() { return true; }

        @ConfigItem(
            keyName = arclight + overlay,
            name = "Arclight",
            description = "",
            section = overlays
        ) default boolean arclightOverlay() { return true; }

        @ConfigItem(
            keyName = ardougne_cloak + overlay,
            name = "Ardougne cloak",
            description = "",
            section = overlays
        ) default boolean ardougneCloakOverlay() { return true; }

        @ConfigItem(
            keyName = ash_sanctifier + overlay,
            name = "Ash sanctifier",
            description = "",
            section = overlays
        ) default boolean ashSanctifierOverlay() { return true; }

        @ConfigItem(
            keyName = barrows_gear + overlay,
            name = "Barrows set",
            description = "",
            section = overlays
        ) default boolean barrowsOverlay() { return true; }

        @ConfigItem(
            keyName = moons_gear + overlay,
            name = "Moons gear",
            description = "",
            section = overlays
        ) default boolean moonsGearOverlay() { return true; }

        @ConfigItem(
            keyName = bonecrusher + overlay,
            name = "Bonecrusher",
            description = "",
            section = overlays
        ) default boolean bonecrusherOverlay() { return true; }

        @ConfigItem(
            keyName = bottomless_compost_bucket + overlay,
            name = "Bottomless compost bucket",
            description = "",
            section = overlays
        ) default boolean bottomlessCompostBucketOverlay() { return true; }

        @ConfigItem(
            keyName = bow_of_faerdhinen + overlay,
            name = "Bow of faerdhinen",
            description = "",
            section = overlays
        ) default boolean bowOfFaerdhinenOverlay() { return true; }

        @ConfigItem(
            keyName = bracelet_of_clay + overlay,
            name = "Bracelet of clay",
            description = "",
            section = overlays
        ) default boolean braceletOfClayOverlay() { return true; }

        @ConfigItem(
            keyName = expeditious_bracelet + overlay,
            name = "Expeditious bracelet",
            description = "",
            section = overlays
        ) default boolean expeditiousBraceletOverlay() { return true; }

        @ConfigItem(
            keyName = flamtaer_bracelet + overlay,
            name = "Flamtaer bracelet",
            description = "",
            section = overlays
        ) default boolean flamtaerBraceletOverlay() { return true; }

        @ConfigItem(
            keyName = games_necklace + overlay,
            name = "Games necklace",
            description = "",
            section = overlays
        ) default boolean gamesNecklaceOverlay() { return true; }

        @ConfigItem(
            keyName = bracelet_of_slaughter + overlay,
            name = "Bracelet of slaughter",
            description = "",
            section = overlays
        ) default boolean braceletOfSlaughterOverlay() { return true; }

        @ConfigItem(
            keyName = camulet + overlay,
            name = "Camulet",
            description = "",
            section = overlays
        ) default boolean camuletOverlay() { return true; }

        @ConfigItem(
            keyName = castle_wars_bracelet + overlay,
            name = "Castle wars bracelet",
            description = "",
            section = overlays
        ) default boolean castleWarsBraceletOverlay() { return true; }

        @ConfigItem(
            keyName = celestial_ring + overlay,
            name = "Celestial ring",
            description = "",
            section = overlays
        ) default boolean celestialRingOverlay() { return true; }

        @ConfigItem(
            keyName = chronicle + overlay,
            name = "Chronicle",
            description = "",
            section = overlays
        ) default boolean chronicleOverlay() { return true; }

        @ConfigItem(
            keyName = circlet_of_water + overlay,
            name = "Circlet of water",
            description = "",
            section = overlays
        ) default boolean circletOfWaterOverlay() { return true; }

        @ConfigItem(
            keyName = chugging_barrel + overlay,
            name = "Chugging barrel",
            description = "",
            section = overlays
        ) default boolean chuggingBarrelOverlay() { return true; }

        @ConfigItem(
            keyName = coal_bag + overlay,
            name = "Coal bag",
            description = "",
            section = overlays
        ) default boolean coalBagOverlay() { return true; }

        @ConfigItem(
            keyName = colossal_pouch + overlay,
            name = "Colossal pouch",
            description = "",
            section = overlays
        ) default boolean colossalPouchOverlay() { return true; }

        @ConfigItem(
            keyName = coffin + overlay,
            name = "Coffin",
            description = "",
            section = overlays
        ) default boolean coffinOverlay() { return true; }

        @ConfigItem(
            keyName = crystal_body + overlay,
            name = "Crystal body",
            description = "",
            section = overlays
        ) default boolean crystalBodyOverlay() { return true; }

        @ConfigItem(
            keyName = crystal_helm + overlay,
            name = "Crystal helm",
            description = "",
            section = overlays
        ) default boolean crystalHelmOverlay() { return true; }

        @ConfigItem(
            keyName = crystal_legs + overlay,
            name = "Crystal legs",
            description = "",
            section = overlays
        ) default boolean crystalLegsOverlay() { return true; }

        @ConfigItem(
            keyName = crystal_saw + overlay,
            name = "Crystal saw",
            description = "",
            section = overlays
        ) default boolean crystalSawOverlay() { return true; }

        @ConfigItem(
            keyName = crystal_shield + overlay,
            name = "Crystal shield",
            description = "",
            section = overlays
        ) default boolean crystalShieldOverlay() { return true; }

        @ConfigItem(
            keyName = desert_amulet + overlay,
            name = "Desert amulet",
            description = "",
            section = overlays
        ) default boolean desertAmuletOverlay() { return true; }

        @ConfigItem(
            keyName = dragonfire_shield + overlay,
            name = "Dragonfire shield",
            description = "",
            section = overlays
        ) default boolean dragonfireShieldOverlay() { return true; }

        @ConfigItem(
            keyName = falador_shield + overlay,
            name = "Falador shield",
            description = "",
            section = overlays
        ) default boolean faladorShieldOverlay() { return true; }

        @ConfigItem(
            keyName = fur_pouch + overlay,
            name = "Fur pouch",
            description = "",
            section = overlays
        ) default boolean furPouchOverlay() { return true; }

        @ConfigItem(
            keyName = escape_crystal + overlay,
            name = "Escape crystal",
            description = "",
            section = overlays
        ) default boolean escapeCrystalOverlay() { return true; }

        @ConfigItem(
            keyName = explorers_ring + overlay,
            name = "Explorer's ring",
            description = "",
            section = overlays
        ) default boolean explorersRingOverlay() { return true; }

        @ConfigItem(
            keyName = dodgy_necklace + overlay,
            name = "Dodgy necklace",
            description = "",
            section = overlays
        ) default boolean dodgyNecklaceOverlay() { return true; }

        @ConfigItem(
            keyName = fish_barrel + overlay,
            name = "Fish barrel",
            description = "",
            section = overlays
        ) default boolean fishBarrelOverlay() { return true; }

        @ConfigItem(
            keyName = flamtaer_bag + overlay,
            name = "Flamtaer bag",
            description = "",
            section = overlays
        ) default boolean flamtaerBagOverlay() { return true; }

        @ConfigItem(
            keyName = forestry_basket + overlay,
            name = "Forestry basket",
            description = "",
            section = overlays
        ) default boolean forestryBasketOverlay() { return true; }

        @ConfigItem(
            keyName = forestry_kit + overlay,
            name = "Forestry kit",
            description = "",
            section = overlays
        ) default boolean forestryKitOverlay() { return true; }

        @ConfigItem(
            keyName = fremennik_sea_boots + overlay,
            name = "Fremennik sea boots",
            description = "",
            section = overlays
        ) default boolean fremennikSeaBootsOverlay() { return true; }

        @ConfigItem(
            keyName = fungicide_spray + overlay,
            name = "Fungicide spray",
            description = "",
            section = overlays
        ) default boolean fungicideSprayOverlay() { return true; }

        @ConfigItem(
            keyName = gem_bag + overlay,
            name = "Gem bag",
            description = "",
            section = overlays
        ) default boolean gemBagOverlay() { return true; }

        @ConfigItem(
            keyName = giantsoul_amulet + overlay,
            name = "Giantsoul amulet",
            description = "",
            section = overlays
        ) default boolean giantsoulAmuletOverlay() { return true; }

        @ConfigItem(
            keyName = gricollers_can + overlay,
            name = "Gricoller's can",
            description = "",
            section = overlays
        ) default boolean gricollersCanOverlay() { return true; }

        @ConfigItem(
            keyName = herb_sack + overlay,
            name = "Herb sack",
            description = "",
            section = overlays
        ) default boolean herbSackOverlay() { return true; }

        @ConfigItem(
            keyName = jar_generator + overlay,
            name = "Jar generator",
            description = "",
            section = overlays
        ) default boolean jarGeneratorOverlay() { return true; }

        @ConfigItem(
            keyName = kandarin_headgear + overlay,
            name = "Kandarin Headgear",
            description = "",
            section = overlays
        ) default boolean kandarinHeadgearOverlay() { return true; }

        @ConfigItem(
            keyName = kharedsts_memoirs + overlay,
            name = "Kharedst's memoirs",
            description = "",
            section = overlays
        ) default boolean kharedstsMemoirsOverlay() { return true; }

        @ConfigItem(
            keyName = kharedsts_memoirs + overlay,
            name = "Book of the dead",
            description = "",
            section = overlays
        ) default boolean bookOfTheDeadOverlay() { return true; }

        @ConfigItem(
            keyName = log_basket + overlay,
            name = "Log basket",
            description = "",
            section = overlays
        ) default boolean logBasketOverlay() { return true; }

        @ConfigItem(
            keyName = magic_cape + overlay,
            name = "Magic cape",
            description = "",
            section = overlays
        ) default boolean magicCapeOverlay() { return true; }

        @ConfigItem(
            keyName = meat_pouch + overlay,
            name = "Meat pouch",
            description = "",
            section = overlays
        ) default boolean meatPouchOverlay() { return true; }

        @ConfigItem(
            keyName = necklace_of_passage + overlay,
            name = "Necklace of passage",
            description = "",
            section = overlays
        ) default boolean necklaceOfPassageOverlay() { return true; }

        @ConfigItem(
            keyName = ogre_bellows + overlay,
            name = "Ogre bellows",
            description = "",
            section = overlays
        ) default boolean ogreBellowsOverlay() { return true; }

        @ConfigItem(
            keyName = phoenix_necklace + overlay,
            name = "Phoenix necklace",
            description = "",
            section = overlays
        ) default boolean phoenixNecklaceOverlay() { return true; }

        @ConfigItem(
            keyName = plank_sack + overlay,
            name = "Plank sack",
            description = "",
            section = overlays
        ) default boolean plankSackOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_recoil + overlay,
            name = "Ring of recoil",
            description = "",
            section = overlays
        ) default boolean ringOfRecoilOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_shadows + overlay,
            name = "Ring of shadows",
            description = "",
            section = overlays
        ) default boolean ringOfShadowsOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_suffering + overlay,
            name = "Ring of suffering",
            description = "",
            section = overlays
        ) default boolean ringOfSufferingOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_the_elements + overlay,
            name = "Ring of the elements",
            description = "",
            section = overlays
        ) default boolean ringOfTheElementsOverlay() { return true; }

        @ConfigItem(
            keyName = ring_of_endurance + overlay,
            name = "Ring of endurance",
            description = "",
            section = overlays
        ) default boolean ringOfEnduranceOverlay() { return true; }

        @ConfigItem(
            keyName = seed_box + overlay,
            name = "Seed box",
            description = "",
            section = overlays
        ) default boolean seedBoxOverlay() { return true; }

        @ConfigItem(
            keyName = skills_necklace + overlay,
            name = "Skills necklace",
            description = "",
            section = overlays
        ) default boolean skillsNecklaceOverlay() { return true; }

        @ConfigItem(
            keyName = slayer_ring + overlay,
            name = "Slayer ring",
            description = "",
            section = overlays
        ) default boolean slayerRingOverlay() { return true; }

        @ConfigItem(
            keyName = soul_bearer + overlay,
            name = "Soul bearer",
            description = "",
            section = overlays
        ) default boolean soulBearerOverlay() { return true; }

        @ConfigItem(
            keyName = strange_old_lockpick + overlay,
            name = "Strange old lockpick",
            description = "",
            section = overlays
        ) default boolean strangeOldLockpickOverlay() { return true; }

        @ConfigItem(
            keyName = tackle_box + overlay,
            name = "Tackle box",
            description = "",
            section = overlays
        ) default boolean tackleBoxOverlay() { return true; }

        @ConfigItem(
            keyName = teleport_crystal + overlay,
            name = "Teleport crystal",
            description = "",
            section = overlays
        ) default boolean teleportCrystalOverlay() { return true; }

        @ConfigItem(
            keyName = eternal_teleport_crystal + overlay,
            name = "Eternal teleport crystal",
            description = "",
            section = overlays
        ) default boolean eternalTeleportCrystalOverlay() { return true; }

        @ConfigItem(
            keyName = tome_of_earth + overlay,
            name = "Tome of earth",
            description = "",
            section = overlays
        ) default boolean tomeOfEarthOverlay() { return true; }

        @ConfigItem(
            keyName = tome_of_fire + overlay,
            name = "Tome of fire",
            description = "",
            section = overlays
        ) default boolean tomeOfFireOverlay() { return true; }

        @ConfigItem(
            keyName = tome_of_water + overlay,
            name = "Tome of water",
            description = "",
            section = overlays
        ) default boolean tomeOfWaterOverlay() { return true; }

        @ConfigItem(
            keyName = venator_bow + overlay,
            name = "Venator bow",
            description = "",
            section = overlays
        ) default boolean venatorBowOverlay() { return true; }

        @ConfigItem(
            keyName = waterskin + overlay,
            name = "Waterskin",
            description = "",
            section = overlays
        ) default boolean waterskinOverlay() { return true; }

        @ConfigItem(
            keyName = western_banner + overlay,
            name = "Western banner",
            description = "",
            section = overlays
        ) default boolean westernBannerOverlay() { return true; }

        @ConfigItem(
            keyName = bryophytas_staff + overlay,
            name = "Bryophyta's staff",
            description = "",
            section = overlays
        ) default boolean bryophytasStaffOverlay() { return true; }

        @ConfigItem(
            keyName = burning_amulet + overlay,
            name = "Burning amulet",
            description = "",
            section = overlays
        ) default boolean burningAmuletOverlay() { return true; }

        @ConfigItem(
            keyName = crystal_bow + overlay,
            name = "Crystal bow",
            description = "",
            section = overlays
        ) default boolean crystalBowOverlay() { return true; }

        @ConfigItem(
            keyName = crystal_halberd + overlay,
            name = "Crystal halberd",
            description = "",
            section = overlays
        ) default boolean crystalHalberdOverlay() { return true; }

        @ConfigItem(
            keyName = efaritays_aid + overlay,
            name = "Efaritay's aid",
            description = "",
            section = overlays
        ) default boolean efaritaysAidOverlay() { return true; }

        @ConfigItem(
            keyName = enchanted_lyre + overlay,
            name = "Enchanted Lyre",
            description = "",
            section = overlays
        ) default boolean enchantedLyreOverlay() { return true; }

        @ConfigItem(
            keyName = ibans_staff + overlay,
            name = "Iban's staff",
            description = "",
            section = overlays
        ) default boolean ibansStaffOverlay() { return true; }

        @ConfigItem(
            keyName = pharaohs_sceptre + overlay,
            name = "Pharaoh's sceptre",
            description = "",
            section = overlays
        ) default boolean pharaohsSceptreOverlay() { return true; }

        @ConfigItem(
            keyName = quetzal_whistle + overlay,
            name = "Quetzal whistle",
            description = "",
            section = overlays
        ) default boolean quetzalWhistleOverlay() { return true; }

        @ConfigItem(
            keyName = sanguinesti_staff + overlay,
            name = "Sanguinesti staff",
            description = "",
            section = overlays
        ) default boolean sanguinestiStaffOverlay() { return true; }

        @ConfigItem(
            keyName = scythe_of_vitur + overlay,
            name = "Scythe of Vitur",
            description = "",
            section = overlays
        ) default boolean scytheOfViturOverlay() { return true; }

        @ConfigItem(
            keyName = skull_sceptre + overlay,
            name = "Skull sceptre",
            description = "",
            section = overlays
        ) default boolean skullSceptreOverlay() { return true; }

        @ConfigItem(
            keyName = slayer_staff_e + overlay,
            name = "Slayer staff (e)",
            description = "",
            section = overlays
        ) default boolean slayerStaffEOverlay() { return true; }

        @ConfigItem(
            keyName = toxic_staff_of_the_dead + overlay,
            name = "Toxic staff of the dead",
            description = "",
            section = overlays
        ) default boolean toxicStaffOfTheDeadOverlay() { return true; }

        @ConfigItem(
            keyName = trident_of_the_seas + overlay,
            name = "Trident of the seas",
            description = "",
            section = overlays
        ) default boolean tridentOfTheSeasOverlay() { return true; }

        @ConfigItem(
            keyName = trident_of_the_seas_e + overlay,
            name = "Trident of the seas (e)",
            description = "",
            section = overlays
        ) default boolean tridentOfTheSeasEOverlay() { return true; }

        @ConfigItem(
            keyName = trident_of_the_swamp + overlay,
            name = "Trident of the swamp",
            description = "",
            section = overlays
        ) default boolean tridentOfTheSwampOverlay() { return true; }

        @ConfigItem(
            keyName = trident_of_the_swamp_e + overlay,
            name = "Trident of the swamp (e)",
            description = "",
            section = overlays
        ) default boolean tridentOfTheSwampEOverlay() { return true; }

        @ConfigItem(
            keyName = warped_sceptre + overlay,
            name = "Warped sceptre",
            description = "",
            section = overlays
        ) default boolean warpedSceptreOverlay() { return true; }

        @ConfigItem(
            keyName = xerics_talisman + overlay,
            name = "Xeric's talisman",
            description = "",
            section = overlays
        ) default boolean xericsTalismanOverlay() { return true; }

        @ConfigItem(
            keyName = alchemists_amulet + overlay,
            name = "Alchemist's amulet",
            description = "",
            section = overlays
        ) default boolean alchemistsAmuletOverlay() { return true; }

        @ConfigItem(
            keyName = amulet_of_blood_fury + overlay,
            name = "Amulet of blood fury",
            description = "",
            section = overlays
        ) default boolean amuletOfBloodFuryOverlay() { return true; }

        @ConfigItem(
            keyName = amulet_of_chemistry + overlay,
            name = "Amulet of chemistry",
            description = "",
            section = overlays
        ) default boolean amuletOfChemistryOverlay() { return true; }

    @ConfigSection(
        name = "Debug",
        description = "Values of charges for all items under the hood",
        position = 99,
        closedByDefault = true
    ) String debug = "debug";

        @ConfigItem(
            keyName = version,
            name = version,
            description = "Version of the plugin for update message",
            section = debug,
            position = -4
        ) default String getVersion() { return ""; }

        @ConfigItem(
            keyName = date,
            name = "Date",
            description = "Date to check for charges reset when logging in",
            section = debug,
            position = -3
        ) default String getResetDate() { return ""; }

        @ConfigItem(
            keyName = debug_ids,
            name = "Debug IDs",
            description = "Shows animation and graphics ids within ingame messages to add support for new items",
            section = debug,
            position = -2
        ) default boolean showDebugIds() { return false; }

        @ConfigItem(
            keyName = storage_bank,
            name = storage_bank,
            description = "All player bank items to check for daily resets",
            section = debug,
            position = 1
        ) default String getStorageBank() { return ""; }

        @ConfigItem(
            keyName = barrows_gear + "_ahrims_hood",
            name = barrows_gear + "_ahrims_hood",
            description = barrows_gear + "_ahrims_hood",
            section = debug
        ) default int ahrimsHoodCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ring_of_pursuit,
            name = ring_of_pursuit,
            description = ring_of_pursuit,
            section = debug
        ) default int ringOfPursuitCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = arclight,
            name = arclight,
            description = arclight,
            section = debug
        ) default int getArclightCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ash_sanctifier,
            name = ash_sanctifier,
            description = ash_sanctifier,
            section = debug
        ) default int getAshSanctifierCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ash_sanctifier_status,
            name = ash_sanctifier_status,
            description = ash_sanctifier_status,
            section = debug
        ) default ItemActivity getAshSanctifierStatus() { return ItemActivity.ACTIVATED; }

        @ConfigItem(
            keyName = binding_necklace,
            name = binding_necklace,
            description = binding_necklace,
            section = debug
        ) default int getBindingNecklaceCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = bonecrusher,
            name = bonecrusher,
            description = bonecrusher,
            section = debug
        ) default int getBoneCrusherCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = efaritays_aid,
            name = efaritays_aid,
            description = efaritays_aid,
            section = debug
        ) default int getEfaritaysAidCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = bonecrusher_status,
            name = bonecrusher_status,
            description = bonecrusher_status,
            section = debug
        ) default ItemActivity getBoneCrusherStatus() { return ItemActivity.ACTIVATED; }

        @ConfigItem(
            keyName = kharedsts_memoirs,
            name = kharedsts_memoirs,
            description = kharedsts_memoirs,
            section = debug
        ) default int getKharedstsMemoirsCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = bottomless_compost_bucket + storage,
            name = bottomless_compost_bucket + storage,
            description = bottomless_compost_bucket + storage,
            section = debug
        ) default String getBottomlessCompostBucketStorage() { return ""; }

        @ConfigItem(
            keyName = bracelet_of_slaughter,
            name = bracelet_of_slaughter,
            description = bracelet_of_slaughter,
            section = debug
        ) default int getBraceletOfSlaughterCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = bryophytas_staff,
            name = bryophytas_staff,
            description = bryophytas_staff,
            section = debug
        ) default int getBryophytasStaffCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = celestial_ring,
            name = celestial_ring,
            description = celestial_ring,
            section = debug
        ) default int getCelestialRingCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = chronicle,
            name = chronicle,
            description = chronicle,
            section = debug
        ) default int getChronicleCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = crystal_shield,
            name = crystal_shield,
            description = crystal_shield,
            section = debug
        ) default int getCrystalShieldCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = crystal_bow,
            name = crystal_bow,
            description = crystal_bow,
            section = debug
        ) default int getCrystalBowCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = expeditious_bracelet,
            name = expeditious_bracelet,
            description = expeditious_bracelet,
            section = debug
        ) default int getBraceletOfExpeditiousCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = falador_shield,
            name = falador_shield,
            description = falador_shield,
            section = debug
        ) default int getFaladorShieldCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = fish_barrel + storage,
            name = fish_barrel + storage,
            description = fish_barrel + storage,
            section = debug
        ) default String getFishBarrelStorage() { return ""; }

        @ConfigItem(
            keyName = flamtaer_bag + storage,
            name = flamtaer_bag + storage,
            description = flamtaer_bag + storage,
            section = debug
        ) default String getFlamtaerBagStorage() { return ""; }

        @ConfigItem(
            keyName = gricollers_can,
            name = gricollers_can,
            description = gricollers_can,
            section = debug
        ) default int getGricollersCanCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ibans_staff,
            name = ibans_staff,
            description = ibans_staff,
            section = debug
        ) default int getIbansStaffCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = moons_gear + "_eclipse_chestplate",
            name = moons_gear + "_eclipse_chestplate",
            description = moons_gear + "_eclipse_chestplate",
            section = debug
        ) default int getEclipseMoonChestplateCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = pharaohs_sceptre,
            name = pharaohs_sceptre,
            description = pharaohs_sceptre,
            section = debug
        ) default int getPharaohsSceptreCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = reagent_pouch + storage,
            name = reagent_pouch + storage,
            description = reagent_pouch + storage,
            section = debug
        ) default String getReagentPouchStorage() { return ""; }

        @ConfigItem(
            keyName = ring_of_forging,
            name = ring_of_forging,
            description = ring_of_forging,
            section = debug
        ) default int getRingOfForgingCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ring_of_suffering,
            name = ring_of_suffering,
            description = ring_of_suffering,
            section = debug
        ) default int getRingOfSufferingCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ring_of_suffering_status,
            name = ring_of_suffering_status,
            description = ring_of_suffering_status,
            section = debug
        ) default ItemActivity getRingOfSufferingStatus() { return ItemActivity.ACTIVATED; }

        @ConfigItem(
            keyName = sanguinesti_staff,
            name = sanguinesti_staff,
            description = sanguinesti_staff,
            section = debug
        ) default int getSanguinestiStaffCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = scythe_of_vitur,
            name = scythe_of_vitur,
            description = scythe_of_vitur,
            section = debug
        ) default int getScytheOfViturCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = skull_sceptre,
            name = skull_sceptre,
            description = skull_sceptre,
            section = debug
        ) default int getSkullSceptreCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = soul_bearer,
            name = soul_bearer,
            description = soul_bearer,
            section = debug
        ) default int getSoulBearerCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = trident_of_the_seas,
            name = trident_of_the_seas,
            description = trident_of_the_seas,
            section = debug
        ) default int getTridentOfTheSeasCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = xerics_talisman,
            name = xerics_talisman,
            description = xerics_talisman,
            section = debug
        ) default int getXericsTalismanCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = dragonfire_shield,
            name = dragonfire_shield,
            description = dragonfire_shield,
            section = debug
        ) default int getDragonfireShieldCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = camulet,
            name = camulet,
            description = camulet,
            section = debug
        ) default int getCamuletCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = circlet_of_water,
            name = circlet_of_water,
            description = circlet_of_water,
            section = debug
        ) default int getCircletOfWaterCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = chugging_barrel + storage,
            name = chugging_barrel + storage,
            description = chugging_barrel + storage,
            section = debug
        ) default String getChuggingBarrelStorage() { return ""; }

        @ConfigItem(
            keyName = teleport_crystal,
            name = teleport_crystal,
            description = teleport_crystal,
            section = debug
        ) default int getTeleportCrystalCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = bracelet_of_clay,
            name = bracelet_of_clay,
            description = bracelet_of_clay,
            section = debug
        ) default int getBraceletOfClayCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = coffin,
            name = coffin,
            description = coffin,
            section = debug
        ) default int getCoffinCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = huntsmans_kit + storage,
            name = huntsmans_kit + storage,
            description = huntsmans_kit + storage,
            section = debug
        ) default String getHuntsmansKitStorage() { return ""; }

        @ConfigItem(
            keyName = log_basket + storage,
            name = log_basket + storage,
            description = log_basket + storage,
            section = debug
        ) default String getLogBasketStorage() { return ""; }

        @ConfigItem(
            keyName = forestry_basket + storage,
            name = forestry_basket + storage,
            description = forestry_basket + storage,
            section = debug
        ) default String getForestryBasketStorage() { return ""; }

        @ConfigItem(
            keyName = forestry_kit + storage,
            name = forestry_kit + storage,
            description = forestry_kit + storage,
            section = debug
        ) default String getForestryKitStorage() { return ""; }

        @ConfigItem(
            keyName = ardougne_cloak,
            name = ardougne_cloak,
            description = ardougne_cloak,
            section = debug
        ) default int getArdougneCloakCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = magic_cape,
            name = magic_cape,
            description = magic_cape,
            section = debug
        ) default int getMagicCapeCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = meat_pouch + storage,
            name = meat_pouch + storage,
            description = meat_pouch + storage,
            section = debug
        ) default String getMeatPouchStorageCharges() { return ""; }

        @ConfigItem(
            keyName = gem_bag + storage,
            name = gem_bag + storage,
            description = gem_bag + storage,
            section = debug
        ) default String getGemBagStorageCharges() { return ""; }

        @ConfigItem(
            keyName = seed_box,
            name = seed_box,
            description = seed_box,
            section = debug
        ) default int getSeedBoxCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = seed_box + storage,
            name = seed_box + storage,
            description = seed_box + storage,
            section = debug
        ) default String getSeedBoxStorage() { return ""; }

        @ConfigItem(
            keyName = crystal_helm,
            name = crystal_helm,
            description = crystal_helm,
            section = debug
        ) default int getCrystalHelmCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = crystal_body,
            name = crystal_body,
            description = crystal_body,
            section = debug
        ) default int getCrystalBodyCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = crystal_legs,
            name = crystal_legs,
            description = crystal_legs,
            section = debug
        ) default int getCrystalLegsCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = crystal_halberd,
            name = crystal_halberd,
            description = crystal_halberd,
            section = debug
        ) default int getCrystalHalberdCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ring_of_shadows,
            name = ring_of_shadows,
            description = ring_of_shadows,
            section = debug
        ) default int getRingOfShadowsCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = coal_bag,
            name = coal_bag,
            description = coal_bag,
            section = debug
        ) default int getCoalBagCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = colossal_pouch + storage,
            name = colossal_pouch + storage,
            description = colossal_pouch + storage,
            section = debug
        ) default String getColossalPouchStorage() { return ""; }

        @ConfigItem(
            keyName = colossal_pouch_decay_count,
            name = colossal_pouch_decay_count,
            description = "Colossal pouch decay count",
            section = debug
        ) default int getColossalPouchDecayCount() { return 0; };

        @ConfigItem(
            keyName = herb_sack + storage,
            name = herb_sack + storage,
            description = herb_sack + storage,
            section = debug
        ) default String getHerbSackStorage() { return ""; }

        @ConfigItem(
            keyName = escape_crystal_status,
            name = escape_crystal_status,
            description = escape_crystal_status,
            section = debug
        ) default ItemActivity getEscapeCrystalStatus() { return ItemActivity.DEACTIVATED; }

        @ConfigItem(
            keyName = escape_crystal_inactivity_period,
            name = escape_crystal_inactivity_period,
            description = escape_crystal_inactivity_period,
            section = debug
        ) default int getEscapeCrystalInactivityPeriod() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = strange_old_lockpick,
            name = strange_old_lockpick,
            description = strange_old_lockpick,
            section = debug
        ) default int getStrangeOldLockCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = desert_amulet,
            name = desert_amulet,
            description = desert_amulet,
            section = debug
        ) default int getDesertAmuletCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = tome_of_fire,
            name = tome_of_fire,
            description = tome_of_fire,
            section = debug
        ) default int getTomeOfFireCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = dodgy_necklace,
            name = dodgy_necklace,
            description = dodgy_necklace,
            section = debug
        ) default int getDodgyNecklaceCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = kandarin_headgear,
            name = kandarin_headgear,
            description = kandarin_headgear,
            section = debug
        ) default int getKandarinHeadgearCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = fremennik_sea_boots,
            name = fremennik_sea_boots,
            description = fremennik_sea_boots,
            section = debug
        ) default int getFremennikSeaBootsCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = fur_pouch + storage,
            name = fur_pouch + storage,
            description = fur_pouch + storage,
            section = debug
        ) default String getFurPouchStorageCharges() { return ""; }

        @ConfigItem(
            keyName = jar_generator,
            name = jar_generator,
            description = jar_generator,
            section = debug
        ) default int getJarGeneratorCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = explorers_ring + storage,
            name = explorers_ring + storage,
            description = explorers_ring + storage,
            section = debug
        ) default String getExplorersRingCharges() { return ""; }

        @ConfigItem(
            keyName = enchanted_lyre,
            name = enchanted_lyre,
            description = enchanted_lyre,
            section = debug
        ) default int getEnchantedLyreCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ring_of_the_elements,
            name = ring_of_the_elements,
            description = ring_of_the_elements,
            section = debug
        ) default int getRingOfElementsCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = ring_of_endurance,
            name = ring_of_endurance,
            description = ring_of_endurance,
            section = debug
        ) default int getRingOfEnduranceCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = plank_sack,
            name = plank_sack,
            description = plank_sack,
            section = debug
        ) default int getPlankSackCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = slayer_staff_e,
            name = slayer_staff_e,
            description = slayer_staff_e,
            section = debug
        ) default int getSlayerStaffECharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = warped_sceptre,
            name = warped_sceptre,
            description = warped_sceptre,
            section = debug
        ) default int getWarpedSceptreCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = crystal_saw,
            name = crystal_saw,
            description = crystal_saw,
            section = debug
        ) default int getCrystalSawCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = quetzal_whistle,
            name = quetzal_whistle,
            description = quetzal_whistle,
            section = debug
        ) default int getQuetzalWhistleCharges() { return Charges.UNKNOWN; }

        @ConfigItem(
            keyName = tackle_box + storage,
            name = tackle_box + storage,
            description = tackle_box + storage,
            section = debug
        ) default String getTackleBoxStorage() { return ""; }

        @ConfigItem(
            keyName = amulet_of_chemistry,
            name = amulet_of_chemistry,
            description = amulet_of_chemistry,
            section = debug
        ) default int getAmuletOfChemistryCharges() { return Charges.UNKNOWN; }
}

package tictac7x.charges;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TicTac7xChargesPluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(TicTac7xChargesImprovedPlugin.class);
		RuneLite.main(args);
	}
}
