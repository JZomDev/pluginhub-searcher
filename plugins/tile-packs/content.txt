/*
 * Copyright (c) 2019, Jordan Atwood <nightfirecat@protonmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tilepacks.data;

import lombok.Value;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.awt.*;

/**
 * Used to denote marked tiles and their colors.
 * Note: This is not used for serialization of ground markers; see {@link GroundMarkerPoint}
 */
@Value
public class ColorTileMarker {
    private WorldPoint worldPoint;
    @Nullable
    private Color color;
    @Nullable
    private String label;
}
/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Source: https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/groundmarkers/GroundMarkerPoint.java
 */
package com.tilepacks.data;

import lombok.EqualsAndHashCode;
import lombok.Value;

import javax.annotation.Nullable;
import java.awt.*;

/**
 * Used for serialization of ground marker points.
 */
@Value
@EqualsAndHashCode(exclude = {"color", "label"})
public class GroundMarkerPoint {
    private int regionId;
    private int regionX;
    private int regionY;
    private int z;
    @Nullable
    private Color color;
    @Nullable
    private String label;
}
/*
 * Copyright (c) 2022, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tilepacks.data;

/**
 * Represents all the data needed to make a TilePack
 */
public class TilePack {
    public Integer id;
    public String packName;
    public String link;
    public String packTiles;

    public TilePack(Integer id, String packName, String packTiles) {
        this.id = id;
        this.packName = packName;
        this.packTiles = packTiles;
    }

    public TilePack(Integer id, String packName, String link, String packTiles) {
        this.id = id;
        this.packName = packName;
        this.link = link;
        this.packTiles = packTiles;
    }
}
/*
 * Copyright (c) 2024, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tilepacks.data;

/**
 * Represents all the data of a custom config for a tile pack
 * This is separate from the pack storage because it allows the custom configs to be applied to the default packs
 * without storing them into the settings file.
 */
public class TilePackConfig {
    public Integer packId;
    public boolean visible;

    public TilePackConfig(Integer packId, boolean visible) {
        this.packId = packId;
        this.visible = visible;
    }
}
/*
 * Copyright (c) 2024, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tilepacks;

import com.google.common.base.Strings;
import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.tilepacks.data.TilePackConfig;
import lombok.Value;
import lombok.experimental.NonFinal;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import java.util.HashMap;
import java.util.Map;

/**
 * This class is responsible for all functions that interface with or modify the configs related to global filters.
 */
@Slf4j
@Value
public class FilterManager {
    private static final String CONFIG_GROUP = "tilePacks";
    private static final String SHOW_VISIBLE = "showVisible";
    private static final String SHOW_INVISIBLE = "showInvisible";

    @NonFinal
    private boolean showVisible;
    @NonFinal
    private boolean showInvisible;

    private final ConfigManager configManager;

    @Inject
    FilterManager( ConfigManager configManager) {
        this.configManager = configManager;
        this.loadFilters();
    }

    //loads the filters from the config
    private void loadFilters() {
        String showVisibleConfig = configManager.getConfiguration(CONFIG_GROUP, SHOW_VISIBLE);

        if (Strings.isNullOrEmpty(showVisibleConfig)) {
            this.showVisible = true;
        } else {
            this.showVisible = Boolean.parseBoolean(showVisibleConfig);
        }

        String showInvisibleConfig = configManager.getConfiguration(CONFIG_GROUP, SHOW_INVISIBLE);

        if (Strings.isNullOrEmpty(showInvisibleConfig)) {
            this.showInvisible = false;
        } else {
            this.showInvisible = Boolean.parseBoolean(showInvisibleConfig);
        }
    }

    //sets showVisible in the config
    public void setShowVisible(boolean showVisible) {
        this.showVisible = showVisible;
        configManager.setConfiguration(CONFIG_GROUP, SHOW_VISIBLE, showVisible);
    }

    //returns the value of showVisible
    public boolean getShowVisible() {
        return this.showVisible;
    }

    //sets showInvisible in the config
    public void setShowInvisible(boolean showInvisible) {
        this.showInvisible = showInvisible;
        configManager.setConfiguration(CONFIG_GROUP, SHOW_INVISIBLE, showInvisible);
    }

    //returns the value of showVisible
    public boolean getShowInvisible() {
        return this.showInvisible;
    }
}

/*
 * Copyright (c) 2024, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tilepacks;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.tilepacks.data.ColorTileMarker;
import com.tilepacks.data.GroundMarkerPoint;
import com.tilepacks.data.TilePack;
import lombok.Getter;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.WorldEntity;
import net.runelite.api.WorldView;
import net.runelite.api.coords.WorldPoint;

import javax.inject.Inject;
import java.util.*;
import java.util.stream.Collectors;

/**
 * This class is responsible for translating the tile packs into drawable points
 */
@Slf4j
@Value
public class PointManager {

    @Getter
    private ListMultimap<WorldView, ColorTileMarker> points = ArrayListMultimap.create();

    private final TilePackManager tilePackManager;
    private final Gson gson;
    private final Client client;

    @Inject
    PointManager(TilePackManager tilePackManager, Gson gson, Client client) {
        this.tilePackManager = tilePackManager;
        this.gson = gson;
        this.client = client;
    }

    //loads the points from the packs for the players active regions
    public void loadPoints() {
        points.clear();

        WorldView worldView = client.getTopLevelWorldView();
        if (worldView == null)
        {
            return;
        }

        loadWorldViewPoints(worldView);

        for (WorldEntity we : worldView.worldEntities())
        {
            loadWorldViewPoints(we.getWorldView());
        }
    }

    public void loadWorldViewPoints(WorldView worldView)
    {
        points.removeAll(worldView);

        int[] regions = worldView.getMapRegions();
        if (regions == null)
        {
            return;
        }

        for (int regionId : regions)
        {
            Collection<GroundMarkerPoint> regionPoints = getActivePoints(regionId);
            Collection<ColorTileMarker> colorTileMarkers = translateToColorTileMarker(worldView, regionPoints);
            points.putAll(worldView, colorTileMarkers);
        }
    }

    //gets all the active points for all enabled packs.
    private List<GroundMarkerPoint> getActivePoints() {
        List<GroundMarkerPoint> markers = new ArrayList<>();
        List<Integer> enabledPacks = tilePackManager.getEnabledPacks();
        for (Map.Entry<Integer, TilePack> pack : tilePackManager.getTilePacks().entrySet()) {
            if (enabledPacks.contains(pack.getKey())) {
                markers.addAll(gson.fromJson(
                        pack.getValue().packTiles,
                        new TypeToken<List<GroundMarkerPoint>>() {
                        }.getType()));
            }
        }
        return markers;
    }

    //gets all the active points, filtered for a region
    private List<GroundMarkerPoint> getActivePoints(int regionId) {
        List<GroundMarkerPoint> activePoints = getActivePoints();
        Map<Integer, List<GroundMarkerPoint>> regionGroupedPoints = activePoints.stream()
                .collect(Collectors.groupingBy(GroundMarkerPoint::getRegionId));
        List<GroundMarkerPoint> regionPoints = regionGroupedPoints.get(regionId);
        if (regionPoints == null) {
            return Collections.emptyList();
        }
        return regionPoints;
    }


    private Collection<ColorTileMarker> translateToColorTileMarker(WorldView wv, Collection<GroundMarkerPoint> points)
    {
        if (points.isEmpty())
        {
            return Collections.emptyList();
        }

        return points.stream()
                .map(point -> new ColorTileMarker(
                        WorldPoint.fromRegion(point.getRegionId(), point.getRegionX(), point.getRegionY(), point.getZ()),
                        point.getColor(), point.getLabel()))
                .flatMap(colorTile ->
                {
                    final Collection<WorldPoint> localWorldPoints = WorldPoint.toLocalInstance(wv, colorTile.getWorldPoint());
                    return localWorldPoints.stream().map(wp -> new ColorTileMarker(wp, colorTile.getColor(), colorTile.getLabel()));
                })
                .collect(Collectors.toList());
    }
}

/*
 * Copyright (c) 2024, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tilepacks;

import com.google.common.base.Strings;
import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.tilepacks.data.TilePackConfig;
import lombok.Value;
import lombok.experimental.NonFinal;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import java.util.HashMap;
import java.util.Map;

/**
 * This class is responsible for all functions that interface with or modify the custom configs of a TilePack.
 * A custom config is settings for a tile pack.
 * Both built in and custom packs have a config.
 */
@Slf4j
@Value
public class TilePackConfigManager {
    private static final String CONFIG_GROUP = "tilePacks";
    private static final String TILE_PACK_CONFIGS = "tilePackConfigs";

    @NonFinal
    private Map<Integer, TilePackConfig> customConfigs = new HashMap<Integer, TilePackConfig>();

    private final Gson gson;
    private final ConfigManager configManager;

    @Inject
    TilePackConfigManager(Gson gson, ConfigManager configManager) {
        this.gson = gson;
        this.configManager = configManager;
        this.loadTilePackConfigs();
    }

    //loads the custom pack configs from the settings file
    private void loadTilePackConfigs() {
        String json = configManager.getConfiguration(CONFIG_GROUP, TILE_PACK_CONFIGS);

        if (Strings.isNullOrEmpty(json)) {
            return;
        }
        customConfigs = gson.fromJson(json, new TypeToken<Map<Integer, TilePackConfig>>() {
        }.getType());
    }

    //replaces a config with the latest version, then saves the custom config list.
    public void updateTilePackConfig(TilePackConfig tilePackConfig) {
        customConfigs.put(tilePackConfig.packId, tilePackConfig);

        String json = gson.toJson(customConfigs);
        configManager.setConfiguration(CONFIG_GROUP, TILE_PACK_CONFIGS, json);
    }

    //returns the custom config of a pack, or a default config if it doesn't exist.
    public TilePackConfig getTilePackConfig(Integer packId) {
        TilePackConfig tilePackConfig = customConfigs.get(packId);
        if(tilePackConfig != null) {
            return tilePackConfig;
        }

        return new TilePackConfig(packId, true);
    }
}

/*
 * Copyright (c) 2024, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tilepacks;

import com.google.common.base.Strings;
import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.tilepacks.data.TilePack;
import lombok.Value;
import lombok.experimental.NonFinal;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This class is responsible for all functions that interface with or modify tile packs
 */
@Slf4j
@Value
public class TilePackManager {
    private static final String CONFIG_GROUP = "tilePacks";
    private static final String CUSTOM_ID = "customId";
    private static final String CUSTOM_PACKS = "customPacks";
    private static final String PACKS_PREFIX = "packs";

    @NonFinal
    private Map<Integer, TilePack> tilePacks = new HashMap<Integer, TilePack>();
    @NonFinal
    private List<Integer> enabledPacks = new ArrayList<Integer>();

    private final Gson gson;
    private final ConfigManager configManager;

    @Inject
    TilePackManager(Gson gson, ConfigManager configManager) {
        this.gson = gson;
        this.configManager = configManager;

        this.loadEnabledPacks();
        this.loadPacks();
    }

    //loads the packs from the json file
    private void loadPacks() {
        try (InputStream in = getClass().getResourceAsStream("tilePacks.jsonc")) {
            final InputStreamReader data = new InputStreamReader(in, StandardCharsets.UTF_8);
            final Type type = new TypeToken<Map<Integer, TilePack>>() {
            }.getType();
            Map<Integer, TilePack> parsed = gson.fromJson(data, type);
            //merge in any custom packs
            Map<Integer, TilePack> customPacks = loadCustomPacks();
            parsed.putAll(customPacks);

            tilePacks = parsed;
        } catch (Exception e) {
            log.error("error loading packs from json, this is likely due to a bad json file.", e);
        }
    }

    //loads the custom packs from the config
    private Map<Integer, TilePack> loadCustomPacks() {
        String json = configManager.getConfiguration(CONFIG_GROUP, CUSTOM_PACKS);

        if (Strings.isNullOrEmpty(json)) {
            return new HashMap<Integer, TilePack>();
        }
        return gson.fromJson(json, new TypeToken<Map<Integer, TilePack>>() {
        }.getType());
    }

    //saves a pack id to the saved config of enabled packs
    public void addEnabledPack(Integer packId) {
        enabledPacks.add(packId);

        String json = gson.toJson(enabledPacks);
        configManager.setConfiguration(CONFIG_GROUP, PACKS_PREFIX, json);
    }

    //removes a pack id from the saved config of enabled packs
    public void removeEnabledPack(Integer packId) {
        enabledPacks.remove(packId);
        if (enabledPacks.isEmpty()) {
            configManager.unsetConfiguration(CONFIG_GROUP, PACKS_PREFIX);
            return;
        }

        String json = gson.toJson(enabledPacks);
        configManager.setConfiguration(CONFIG_GROUP, PACKS_PREFIX, json);
    }

    //gets a list of all enabled pack ids
    private void loadEnabledPacks() {
        String json = configManager.getConfiguration(CONFIG_GROUP, PACKS_PREFIX);

        log.debug("json {}", json);
        if (Strings.isNullOrEmpty(json)) {
            return;
        }
        enabledPacks = gson.fromJson(json, new TypeToken<List<Integer>>() {
        }.getType());
    }

    //gets the custom id the user is currently on
    //each pack the user adds needs a unique index, so we need to manage that
    public Integer loadCustomId() {
        String json = configManager.getConfiguration(CONFIG_GROUP, CUSTOM_ID);

        if (Strings.isNullOrEmpty(json)) {
            //default to 9999 because we add 1, and I want it to start at an even 10k.
            return 9999;
        }
        return gson.fromJson(json, new TypeToken<Integer>() {
        }.getType());
    }

    //saves a custom pack to the users config
    public void addCustomPack(String name, String tiles) {
        Integer customId = loadCustomId() + 1;
        TilePack pack = new TilePack(customId, name, tiles);
        Map<Integer, TilePack> customPacks = loadCustomPacks();
        customPacks.put(customId, pack);

        String json = gson.toJson(customPacks);
        configManager.setConfiguration(CONFIG_GROUP, CUSTOM_PACKS, json);
        configManager.setConfiguration(CONFIG_GROUP, CUSTOM_ID, customId);

        addEnabledPack(pack.id);
        tilePacks.put(pack.id, pack);
    }

    //removes a custom pack from the users config
    public void removeCustomPack(Integer packId) {
        //unsubscribe the pack before removing it.
        removeEnabledPack(packId);
        Map<Integer, TilePack> customPacks = loadCustomPacks();
        customPacks.remove(packId);
        if (customPacks.isEmpty()) {
            configManager.unsetConfiguration(CONFIG_GROUP, CUSTOM_PACKS);
            return;
        }

        String json = gson.toJson(customPacks);
        configManager.setConfiguration(CONFIG_GROUP, CUSTOM_PACKS, json);

        tilePacks.remove(packId);
    }

    public boolean isPackEnabled(Integer packId) {
        return enabledPacks.contains(packId);
    }
}

package com.tilepacks;

import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

import java.awt.*;

@ConfigGroup(TilePacksConfig.GROUP)
public interface TilePacksConfig extends Config {
    String GROUP = "tilepacks";

    @ConfigItem(
            keyName = "hidePlugin",
            name = "Hide on toolbar",
            description = "When checked, the plugin will not appear in the tool bar"
    )
    default boolean hidePlugin() {
        return false;
    }

    @ConfigItem(
            keyName = "showLabels",
            name = "Show Labels",
            description = "When checked, labels will render as defined in each pack"
    )
    default boolean showLabels() {
        return true;
    }

    @ConfigItem(
            keyName = "overrideColorActive",
            name = "Override Color Active",
            description = "When checked, all tiles will render as the selected color"
    )
    default boolean overrideColorActive() {
        return false;
    }

    @Alpha
    @ConfigItem(
            keyName = "overrideColor",
            name = "Override Color",
            description = "If Use Override Color is checked, all tiles will be this color."
    )
    default Color overrideColor() {
        return Color.YELLOW;
    }

    @ConfigItem(
            keyName = "drawTilesOnMinimmap",
            name = "Draw tiles on minimap",
            description = "Configures whether tile packs tiles should be drawn on minimap"
    )
    default boolean drawTilesOnMinimmap() {
        return false;
    }

    @ConfigItem(
            keyName = "borderWidth",
            name = "Border Width",
            description = "Width of the marked tile border"
    )
    default double borderWidth() {
        return 2;
    }

    @ConfigItem(
            keyName = "fillOpacity",
            name = "Fill Opacity",
            description = "Opacity of the tile fill color"
    )
    default int fillOpacity() {
        return 50;
    }
}
/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2021, Adam <Adam@sigterm.info>
 * Copyright (c) 2022, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tilepacks;

import com.google.gson.Gson;
import com.google.inject.Provides;
import com.tilepacks.ui.overlay.GroundMarkerMinimapOverlay;
import com.tilepacks.ui.overlay.GroundMarkerOverlay;
import com.tilepacks.ui.panel.TilePacksListPanel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.WorldViewLoaded;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;

@Slf4j
@PluginDescriptor(
        name = "Tile Packs"
)
public class TilePacksPlugin extends Plugin {
    @Inject
    private Client client;
    @Inject
    private TilePacksConfig config;
    @Inject
    private ConfigManager configManager;
    @Inject
    private Gson gson;
    @Inject
    private ClientToolbar clientToolbar;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private ChatMessageManager chatMessageManager;

    private GroundMarkerMinimapOverlay minimapOverlay;
    private GroundMarkerOverlay overlay;
    private TilePackManager tilePackManager;
    private PointManager pointManager;
    private TilePackConfigManager tilePackConfigManager;
    private FilterManager filterManager;
    private TilePacksListPanel panel;
    private NavigationButton navButton;

    @Override
    protected void startUp() throws Exception {
        tilePackManager = new TilePackManager(gson, configManager);
        pointManager = new PointManager(tilePackManager, gson, client);
        tilePackConfigManager = new TilePackConfigManager(gson, configManager);
        filterManager = new FilterManager(configManager);

        overlay = new GroundMarkerOverlay(pointManager, client, config);
        minimapOverlay = new GroundMarkerMinimapOverlay(pointManager, client, config);
        overlayManager.add(overlay);
        overlayManager.add(minimapOverlay);
        panel = new TilePacksListPanel(tilePackManager, pointManager, tilePackConfigManager, filterManager, chatMessageManager, gson);

        final BufferedImage icon = ImageUtil.loadImageResource(TilePacksPlugin.class, "tilepacks_icon.png");

        navButton = NavigationButton.builder()
                .tooltip("Tile Packs")
                .icon(icon)
                .priority(4)//how is this determined? Could it be a config?
                .panel(panel)
                .build();

        pointManager.loadPoints();

        log.debug("Tile Packs Plugin started");
        if (config.hidePlugin()) {
            return;
        }

        clientToolbar.addNavigation(navButton);

    }

    @Override
    protected void shutDown() throws Exception {
        overlayManager.remove(overlay);
        overlayManager.remove(minimapOverlay);
        clientToolbar.removeNavigation(navButton);
        log.debug("Tile Packs Plugin stopped");
    }

    @Subscribe
    public void onConfigChanged(final ConfigChanged event) {
        if (event.getGroup().equals(TilePacksConfig.GROUP)) {
            switch (event.getKey()) {
                case "hidePlugin":
                    if (config.hidePlugin()) {
                        clientToolbar.removeNavigation(navButton);
                    } else {
                        clientToolbar.addNavigation(navButton);
                    }
                    break;
            }
        } else {
            pointManager.loadPoints();
        }
    }
    @Subscribe
    public void onProfileChanged(ProfileChanged profileChanged)
    {
        pointManager.loadPoints();
    }

    @Subscribe
    public void onWorldViewLoaded(WorldViewLoaded event) {
        log.debug("Changing world view");
        // map region has just been updated
        pointManager.loadWorldViewPoints(event.getWorldView());
    }

    @Provides
    TilePacksConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(TilePacksConfig.class);
    }
}

/*
 * Copyright (c) 2019, Benjamin <https://github.com/genetic-soybean>
 * Copyright (c) 2023, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tilepacks.ui.overlay;

import com.google.common.collect.Multimap;
import com.tilepacks.PointManager;
import com.tilepacks.TilePacksConfig;
import com.tilepacks.data.ColorTileMarker;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;

/**
 * Manages the drawing of the markers on the minimap
 */
@Slf4j
public class GroundMarkerMinimapOverlay extends Overlay {
    private final PointManager pointManager;
    private final Client client;
    private final TilePacksConfig config;

    @Inject
    public GroundMarkerMinimapOverlay(PointManager pointManager, Client client, TilePacksConfig config) {
        this.pointManager = pointManager;
        this.client = client;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(PRIORITY_LOW);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.drawTilesOnMinimmap()) {
            return null;
        }

        final Multimap<WorldView, ColorTileMarker> points = pointManager.getPoints();
        if (points.isEmpty()) {
            return null;
        }
        for (WorldView worldView : points.keySet()) {
            for (final ColorTileMarker point : points.get(worldView)) {
                WorldPoint worldPoint = point.getWorldPoint();
                if (worldPoint.getPlane() != worldView.getPlane()) {
                    continue;
                }

                Color tileColor;
                if (config.overrideColorActive()) {
                    tileColor = config.overrideColor();
                } else {
                    tileColor = point.getColor();
                }

                drawOnMinimap(graphics, worldView, worldPoint, tileColor);
            }
        }

        return null;
    }

    private void drawOnMinimap(Graphics2D graphics, WorldView worldView, WorldPoint point, Color color) {
        LocalPoint localPoint = LocalPoint.fromWorld(worldView, point);
        if (localPoint == null)
        {
            return;
        }

        int x = localPoint.getX() & -Perspective.LOCAL_TILE_SIZE;
        int y = localPoint.getY() & -Perspective.LOCAL_TILE_SIZE;

        Point mp1 = Perspective.localToMinimap(client, new LocalPoint(x, y, worldView.getId()));
        Point mp2 = Perspective.localToMinimap(client, new LocalPoint(x, y + Perspective.LOCAL_TILE_SIZE, worldView.getId()));
        Point mp3 = Perspective.localToMinimap(client, new LocalPoint(x + Perspective.LOCAL_TILE_SIZE, y + Perspective.LOCAL_TILE_SIZE, worldView.getId()));
        Point mp4 = Perspective.localToMinimap(client, new LocalPoint(x + Perspective.LOCAL_TILE_SIZE, y, worldView.getId()));

        if (mp1 == null || mp2 == null || mp3 == null || mp4 == null) {
            return;
        }

        Polygon poly = new Polygon();
        poly.addPoint(mp1.getX(), mp1.getY());
        poly.addPoint(mp2.getX(), mp2.getY());
        poly.addPoint(mp3.getX(), mp3.getY());
        poly.addPoint(mp4.getX(), mp4.getY());

        Stroke stroke = new BasicStroke(1f);
        graphics.setStroke(stroke);
        graphics.setColor(color);
        graphics.drawPolygon(poly);
    }
}
/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2022, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tilepacks.ui.overlay;

import com.google.common.base.Strings;
import com.google.common.collect.Multimap;
import com.tilepacks.PointManager;
import com.tilepacks.TilePacksConfig;
import com.tilepacks.data.ColorTileMarker;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.*;

import javax.annotation.Nullable;
import javax.inject.Inject;
import java.awt.*;

/**
 * Manages the drawing of the markers on ground
 */
public class GroundMarkerOverlay extends Overlay {
    private static final int MAX_DRAW_DISTANCE = 32;

    private final PointManager pointManager;
    private final Client client;
    private final TilePacksConfig config;

    @Inject
    public GroundMarkerOverlay(PointManager pointManager, Client client, TilePacksConfig config) {
        this.pointManager = pointManager;
        this.client = client;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(PRIORITY_LOW);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        final Multimap<WorldView, ColorTileMarker> points = pointManager.getPoints();
        if (points.isEmpty()) {
            return null;
        }

        Stroke stroke = new BasicStroke((float) config.borderWidth());
        for (WorldView worldView : points.keySet()) {
            for (final ColorTileMarker point : points.get(worldView)) {
                WorldPoint worldPoint = point.getWorldPoint();
                if (worldPoint.getPlane() != worldView.getPlane()) {
                    continue;
                }

                Color tileColor;
                if (config.overrideColorActive()) {
                    tileColor = config.overrideColor();
                } else {
                    tileColor = point.getColor();
                }

                String label = null;
                if (config.showLabels()) {
                    label = point.getLabel();
                }

                drawTile(graphics, worldView, worldPoint, tileColor, label, stroke);
            }
        }

        return null;
    }

    private void drawTile(Graphics2D graphics, WorldView worldView, WorldPoint point, Color color, @Nullable String label, Stroke borderStroke) {
        if (client.getLocalPlayer().getWorldView().isTopLevel())
        {
            WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

            if (point.distanceTo(playerLocation) >= MAX_DRAW_DISTANCE)
            {
                return;
            }
        }

        LocalPoint lp = LocalPoint.fromWorld(worldView, point);
        if (lp == null) {
            return;
        }

        Polygon poly = Perspective.getCanvasTilePoly(client, lp);
        if (poly != null) {
            OverlayUtil.renderPolygon(graphics, poly, color, new Color(0, 0, 0, config.fillOpacity()), borderStroke);
        }

        if (!Strings.isNullOrEmpty(label)) {
            Point canvasTextLocation = Perspective.getCanvasTextLocation(client, graphics, lp, label, 0);
            if (canvasTextLocation != null) {
                OverlayUtil.renderTextLocation(graphics, canvasTextLocation, label, color);
            }
        }
    }
}
/*
 * Copyright (c) 2024, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tilepacks.ui.panel;

import com.google.gson.Gson;
import com.tilepacks.TilePacksPlugin;
import com.tilepacks.data.TilePack;
import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

/**
 * UI control that handles copying the tiles of a pack to the clipboard
 */
public class CopyToClipboardLabel extends JLabel {
    private static final ImageIcon COPY_ICON;
    private static final ImageIcon COPY_ICON_HOVER;

    private final ChatMessageManager chatMessageManager;
    private final Gson gson;
    private final TilePack tilePack;

    static {
        // Icon is https://www.flaticon.com/free-icon/close_1828665
        // Made by https://www.flaticon.com/authors/pixel-perfect
        final BufferedImage copyIcon = ImageUtil.loadImageResource(TilePacksPlugin.class, "copy_icon.png");
        COPY_ICON = new ImageIcon(copyIcon);
        COPY_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(copyIcon, 0.50f));
    }

    CopyToClipboardLabel(ChatMessageManager chatMessageManager, Gson gson, TilePack tilePack) {
        super();
        this.chatMessageManager = chatMessageManager;
        this.gson = gson;
        this.tilePack = tilePack;

        setIcon(COPY_ICON);
        setToolTipText("Copy tiles of pack to clipboard");
        addMouseListener(new CopyToClipboardMouseAdapter());
    }

    class CopyToClipboardMouseAdapter extends MouseAdapter {
        @Override
        public void mousePressed(MouseEvent e) {
            if (SwingUtilities.isLeftMouseButton(e)) {
                final String copy = tilePack.packTiles;

                Toolkit.getDefaultToolkit()
                        .getSystemClipboard()
                        .setContents(new StringSelection(copy), null);
                chatMessageManager.queue(QueuedMessage.builder()
                        .type(ChatMessageType.CONSOLE)
                        .runeLiteFormattedMessage(tilePack.packName + " tiles copied to clipboard")
                        .build());
            }
        }

        @Override
        public void mouseEntered(MouseEvent e) {
            setIcon(COPY_ICON_HOVER);
        }

        @Override
        public void mouseExited(MouseEvent e) {
            setIcon(COPY_ICON);
        }
    }
}


/*
 * Copyright (c) 2023, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tilepacks.ui.panel;

import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.tilepacks.PointManager;
import com.tilepacks.TilePackManager;
import com.tilepacks.data.GroundMarkerPoint;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.FlatTextField;

import javax.swing.*;
import java.awt.*;
import java.util.List;

/**
 * UI that handles the addition of new tile packs
 */
public class CustomPackManagerPanel extends PluginPanel {

    private final TilePackManager tilePackManager;
    private final PointManager pointManager;
    private final Gson gson;
    private final TilePacksListPanel tilePacksList;

    private final JLabel inputLabel;
    private final FlatTextField nameInput;
    private final JLabel tilesLabel;
    private final FlatTextField tilesInput;
    private final JButton addPackButton;

    CustomPackManagerPanel(TilePackManager tilePackManager, PointManager pointManager,
                           Gson gson, TilePacksListPanel tilePacksList) {
        super();
        this.tilePackManager = tilePackManager;
        this.pointManager = pointManager;
        this.gson = gson;
        this.tilePacksList = tilePacksList;

        inputLabel = new JLabel("Custom Pack Name");
        add(inputLabel);

        nameInput = new FlatTextField();
        nameInput.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
        nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameInput.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        nameInput.setMinimumSize(new Dimension(0, 30));
        add(nameInput);

        tilesLabel = new JLabel("Custom Pack Tiles");
        add(tilesLabel);

        tilesInput = new FlatTextField();
        tilesInput.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
        tilesInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        tilesInput.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        tilesInput.setMinimumSize(new Dimension(0, 30));
        add(tilesInput);

        addPackButton = new JButton();
        addPackButton.setText("Add Pack");
        addPackButton.setHorizontalAlignment(JLabel.CENTER);
        addPackButton.setFocusable(false);
        addPackButton.setPreferredSize((new Dimension(PluginPanel.PANEL_WIDTH - 10, 30)));
        addPackButton.addActionListener(e ->
        {
            if (nameInput.getText().isEmpty()) {
                JOptionPane.showMessageDialog(inputLabel, "Must add a pack name");
                return;
            }
            if (tilesInput.getText().isEmpty()) {
                JOptionPane.showMessageDialog(inputLabel, "Must add tiles");
            }
            //check the format of the import points. We actually save the string, so this formatting is just to check it is valid.
            List<GroundMarkerPoint> importPoints;
            try {
                importPoints = gson.fromJson(tilesInput.getText(), new TypeToken<List<GroundMarkerPoint>>() {
                }.getType());
            } catch (Exception ex) {
                JOptionPane.showMessageDialog(inputLabel, "Error parsing tiles, check the formatting");
                return;
            }
            if (importPoints.isEmpty()) {
                JOptionPane.showMessageDialog(inputLabel, "Error parsing tiles, check the formatting");
                return;
            }
            tilePackManager.addCustomPack(nameInput.getText(), tilesInput.getText());
            pointManager.loadPoints();
            tilePacksList.createTilePackPanels();
        });
        add(addPackButton);
    }
}

/*
 * Copyright (c) 2024, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tilepacks.ui.panel;

import com.tilepacks.PointManager;
import com.tilepacks.TilePackManager;
import com.tilepacks.TilePacksPlugin;
import com.tilepacks.data.TilePack;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

/**
 * UI control that handles the deletion of custom packs
 */
public class DeleteCustomPackLabel extends JLabel {
    private static final ImageIcon DELETE_ICON;
    private static final ImageIcon DELETE_ICON_HOVER;

    private final TilePackManager tilePackManager;
    private final PointManager pointManager;
    private final TilePack tilePack;
    private final TilePacksListPanel tilePacksList;

    static {
        // Icon is https://www.flaticon.com/free-icon/close_1828665
        // Made by https://www.flaticon.com/authors/pixel-perfect
        final BufferedImage deleteIcon = ImageUtil.loadImageResource(TilePacksPlugin.class, "delete_icon.png");
        DELETE_ICON = new ImageIcon(deleteIcon);
        DELETE_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(deleteIcon, 0.50f));
    }

    DeleteCustomPackLabel(TilePackManager tilePackManager, PointManager pointManager, TilePack tilePack, TilePacksListPanel tilePacksList) {
        super();
        this.tilePackManager = tilePackManager;
        this.pointManager = pointManager;
        this.tilePack = tilePack;
        this.tilePacksList = tilePacksList;

        setIcon(DELETE_ICON);
        setToolTipText("Delete this custom pack, this is permanent");
        addMouseListener(new DeleteCustomPackMouseAdapter(this));
    }

    class DeleteCustomPackMouseAdapter extends MouseAdapter {
        private final DeleteCustomPackLabel deleteCustomPackLabel;

        DeleteCustomPackMouseAdapter(DeleteCustomPackLabel deleteCustomPackLabel) {
            this.deleteCustomPackLabel = deleteCustomPackLabel;
        }

        @Override
        public void mousePressed(MouseEvent e) {
            if (SwingUtilities.isLeftMouseButton(e)) {
                final int result = JOptionPane.showOptionDialog(deleteCustomPackLabel,
                        "Are you sure you want to delete this pack?",
                        "Delete Pack?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                        null, new String[]{"Yes", "No"}, "No");

                if (result == JOptionPane.YES_OPTION) {
                    tilePackManager.removeCustomPack(tilePack.id);
                    pointManager.loadPoints();
                    tilePacksList.createTilePackPanels();
                }
            }
        }

        @Override
        public void mouseEntered(MouseEvent e) {
            setIcon(DELETE_ICON_HOVER);
        }

        @Override
        public void mouseExited(MouseEvent e) {
            setIcon(DELETE_ICON);
        }
    }
}


/*
 * Copyright (c) 2025, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tilepacks.ui.panel.header;

import com.tilepacks.TilePacksPlugin;
import com.tilepacks.data.TilePack;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

/**
 * UI control that navigates to GitHub
 */
public class GithubLinkLabel extends JLabel {
    private static final ImageIcon HELP_ICON;
    private static final ImageIcon HELP_ICON_HOVER;
    private static final String GITHUB_LINK = "https://github.com/TrevorMDev/tile-packs?tab=readme-ov-file#tile-packs";

    static {
        // Icon is https://www.flaticon.com/free-icon/help-web-button_18436
        // Made by https://www.flaticon.com/authors/freepik
        final BufferedImage helpIcon = ImageUtil.loadImageResource(TilePacksPlugin.class, "question_mark_icon.png");
        HELP_ICON = new ImageIcon(helpIcon);
        HELP_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(helpIcon, 0.50f));
    }

    GithubLinkLabel() {
        super();

        setIcon(HELP_ICON);
        setToolTipText("Click for help with Tile Packs");
        addMouseListener(new HelpLinkMouseAdapter());
    }

    class HelpLinkMouseAdapter extends MouseAdapter {
        @Override
        public void mousePressed(MouseEvent e) {
            if (SwingUtilities.isLeftMouseButton(e)) {
                LinkBrowser.browse(GITHUB_LINK);
            }
        }

        @Override
        public void mouseEntered(MouseEvent e) {
            setIcon(HELP_ICON_HOVER);
        }

        @Override
        public void mouseExited(MouseEvent e) {
            setIcon(HELP_ICON);
        }
    }
}


/*
 * Copyright (c) 2024, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tilepacks.ui.panel.header;

import com.tilepacks.FilterManager;
import com.tilepacks.ui.panel.TilePacksListPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

/**
 * The header that lives at the top of the panel above the list of tile packs
 * Handles the search bar and global filters
 */
public class HeaderPanel extends JPanel {
    private final FilterManager filterManager;
    private final TilePacksListPanel tilePacksList;

    private final IconTextField searchTextField;
    private final JPanel bottomPanel = new JPanel();
    private final JPanel filterPanel = new JPanel();
    private final VisibleHeaderLabel visibleListLabel;
    private final InvisibleHeaderLabel invisibleListLabel;
    private final GithubLinkLabel githubLinkLabel;

    public HeaderPanel(FilterManager filterManager, TilePacksListPanel tilePacksList) {
        super();
        this.filterManager = filterManager;
        this.tilePacksList = tilePacksList;

        setLayout(new BorderLayout());

        searchTextField = new IconTextField();
        searchTextField.setIcon(IconTextField.Icon.SEARCH);
        searchTextField.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
        searchTextField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        searchTextField.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        searchTextField.setMinimumSize(new Dimension(0, 30));
        searchTextField.addKeyListener(new SearchTextFieldKeyListener());
        searchTextField.addClearListener(() -> tilePacksList.createTilePackPanels());
        add(searchTextField, BorderLayout.CENTER);

        bottomPanel.setLayout(new BorderLayout());
        bottomPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        bottomPanel.setBorder(new MatteBorder(1, 0, 0, 0, ColorScheme.DARK_GRAY_COLOR));
        add(bottomPanel, BorderLayout.SOUTH);

        filterPanel.setLayout(new FlowLayout(FlowLayout.LEADING, 4, 6));
        filterPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        bottomPanel.add(filterPanel, BorderLayout.WEST);

        visibleListLabel = new VisibleHeaderLabel(filterManager, tilePacksList);
        filterPanel.add(visibleListLabel);
        invisibleListLabel = new InvisibleHeaderLabel(filterManager, tilePacksList);
        filterPanel.add(invisibleListLabel);

        githubLinkLabel = new GithubLinkLabel();
        githubLinkLabel.setBorder(new EmptyBorder(0, 0, 0, 8));
        bottomPanel.add(githubLinkLabel, BorderLayout.EAST);
    }

    public String getSearchText() {
        return searchTextField.getText();
    }

    class SearchTextFieldKeyListener implements KeyListener {
        @Override
        public void keyTyped(KeyEvent e) {
        }

        @Override
        public void keyPressed(KeyEvent e) {
        }

        @Override
        public void keyReleased(KeyEvent e) {
            tilePacksList.createTilePackPanels();
        }
    }
}


/*
 * Copyright (c) 2024, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tilepacks.ui.panel.header;

import com.tilepacks.FilterManager;
import com.tilepacks.TilePacksPlugin;
import com.tilepacks.ui.panel.TilePacksListPanel;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

/**
 * UI control that handles the filtering of the list as visible, invisible or both.
 */
public class InvisibleHeaderLabel extends JLabel {
    private static final ImageIcon INVISIBLE_ICON_ACTIVE;
    private static final ImageIcon INVISIBLE_ICON_ACTIVE_HOVER;
    private static final ImageIcon INVISIBLE_ICON;
    private static final ImageIcon INVISIBLE_ICON_HOVER;

    private final FilterManager filterManager;
    private final TilePacksListPanel tilePacksList;

    static {
        // Icon is https://www.flaticon.com/free-icon/visible_4175339
        // Made by https://www.flaticon.com/authors/uicon
        final BufferedImage invisibleIcon = ImageUtil.loadImageResource(TilePacksPlugin.class, "invisible_icon.png");
        INVISIBLE_ICON_ACTIVE = new ImageIcon(ImageUtil.recolorImage(invisibleIcon, Color.white));
        INVISIBLE_ICON_ACTIVE_HOVER = new ImageIcon(ImageUtil.recolorImage(invisibleIcon, ColorUtil.colorWithAlpha(Color.white, 128)));
        INVISIBLE_ICON = new ImageIcon(invisibleIcon);
        INVISIBLE_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(invisibleIcon, 0.50f));
    }

    InvisibleHeaderLabel(FilterManager filterManager, TilePacksListPanel tilePacksList) {
        super();
        this.filterManager = filterManager;
        this.tilePacksList = tilePacksList;

        if(filterManager.getShowInvisible()) {
            setIcon(INVISIBLE_ICON_ACTIVE);
        } else {
            setIcon(INVISIBLE_ICON);
        }
        setToolTipText("Show invisible packs");

        this.addMouseListener(new InvisibleHeaderLabelMouseAdapter());
    }

    class InvisibleHeaderLabelMouseAdapter extends MouseAdapter {
        @Override
        public void mousePressed(MouseEvent e) {
            if (SwingUtilities.isLeftMouseButton(e)) {
                if(filterManager.getShowInvisible()) {
                    filterManager.setShowInvisible(false);
                    setIcon(INVISIBLE_ICON_HOVER);
                } else {
                    filterManager.setShowInvisible(true);
                    setIcon(INVISIBLE_ICON_ACTIVE_HOVER);
                }
                tilePacksList.createTilePackPanels();
            }
        }

        @Override
        public void mouseEntered(MouseEvent e) {
            if(filterManager.getShowInvisible()) {
                setIcon(INVISIBLE_ICON_ACTIVE_HOVER);
            } else {
                setIcon(INVISIBLE_ICON_HOVER);
            }
        }

        @Override
        public void mouseExited(MouseEvent e) {
            if(filterManager.getShowInvisible()) {
                setIcon(INVISIBLE_ICON_ACTIVE);
            } else {
                setIcon(INVISIBLE_ICON);
            }
        }
    }
}


/*
 * Copyright (c) 2024, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tilepacks.ui.panel.header;

import com.tilepacks.FilterManager;
import com.tilepacks.TilePacksPlugin;
import com.tilepacks.ui.panel.TilePacksListPanel;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

/**
 * UI control that handles the filtering of the list as visible, invisible or both.
 */
public class VisibleHeaderLabel extends JLabel {
    private static final ImageIcon VISIBLE_ICON_ACTIVE;
    private static final ImageIcon VISIBLE_ICON_ACTIVE_HOVER;
    private static final ImageIcon VISIBLE_ICON;
    private static final ImageIcon VISIBLE_ICON_HOVER;

    private final FilterManager filterManager;
    private final TilePacksListPanel tilePacksList;

    static {
        // Icon is https://www.flaticon.com/free-icon/visibility_3395544
        // Made by https://www.flaticon.com/authors/andrean-prabowo
        final BufferedImage visibleIcon = ImageUtil.loadImageResource(TilePacksPlugin.class, "visible_icon.png");
        VISIBLE_ICON_ACTIVE = new ImageIcon(ImageUtil.recolorImage(visibleIcon, Color.white));
        VISIBLE_ICON_ACTIVE_HOVER = new ImageIcon(ImageUtil.recolorImage(visibleIcon, ColorUtil.colorWithAlpha(Color.white, 128)));
        VISIBLE_ICON = new ImageIcon(visibleIcon);
        VISIBLE_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(visibleIcon, 0.50f));
    }

    VisibleHeaderLabel(FilterManager filterManager, TilePacksListPanel tilePacksList) {
        super();
        this.filterManager = filterManager;
        this.tilePacksList = tilePacksList;

        if(filterManager.getShowVisible()) {
            setIcon(VISIBLE_ICON_ACTIVE);
        } else {
            setIcon(VISIBLE_ICON);
        }
        setToolTipText("Show visible tile packs");

        this.addMouseListener(new VisibleHeaderLabelMouseAdapter());
    }

    class VisibleHeaderLabelMouseAdapter extends MouseAdapter {
        @Override
        public void mousePressed(MouseEvent e) {
            if (SwingUtilities.isLeftMouseButton(e)) {
                if(filterManager.getShowVisible()) {
                    filterManager.setShowVisible(false);
                    setIcon(VISIBLE_ICON_HOVER);
                } else {
                    filterManager.setShowVisible(true);
                    setIcon(VISIBLE_ICON_ACTIVE_HOVER);
                }
                tilePacksList.createTilePackPanels();
            }
        }

        @Override
        public void mouseEntered(MouseEvent e) {
            if(filterManager.getShowVisible()) {
                setIcon(VISIBLE_ICON_ACTIVE_HOVER);
            } else {
                setIcon(VISIBLE_ICON_HOVER);
            }
        }

        @Override
        public void mouseExited(MouseEvent e) {
            if(filterManager.getShowVisible()) {
                setIcon(VISIBLE_ICON_ACTIVE);
            } else {
                setIcon(VISIBLE_ICON);
            }
        }
    }
}


/*
 * Copyright (c) 2024, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tilepacks.ui.panel;

import com.tilepacks.TilePacksPlugin;
import com.tilepacks.data.TilePack;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

/**
 * UI control that handles the opening of help links
 */
public class HelpLinkLabel extends JLabel {
    private static final ImageIcon HELP_ICON;
    private static final ImageIcon HELP_ICON_HOVER;
    private static final ImageIcon YOUTUBE_ICON;
    private static final ImageIcon YOUTUBE_ICON_HOVER;
    private static final ImageIcon DISCORD_ICON;
    private static final ImageIcon DISCORD_ICON_HOVER;

    private final TilePack tilePack;

    static {
        // Icon is https://www.flaticon.com/free-icon/resize_3388930
        // Made by https://www.flaticon.com/authors/pixel-perfect
        final BufferedImage helpIcon = ImageUtil.loadImageResource(TilePacksPlugin.class, "help_icon.png");
        HELP_ICON = new ImageIcon(helpIcon);
        HELP_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(helpIcon, 0.50f));

        final BufferedImage youtubeIcon = ImageUtil.loadImageResource(TilePacksPlugin.class, "youtube.png");
        YOUTUBE_ICON = new ImageIcon(youtubeIcon);
        YOUTUBE_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(youtubeIcon, 0.50f));

        final BufferedImage discordIcon = ImageUtil.loadImageResource(TilePacksPlugin.class, "discord.png");
        DISCORD_ICON = new ImageIcon(discordIcon);
        DISCORD_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(discordIcon, 0.50f));
    }

    HelpLinkLabel(TilePack tilePack) {
        super();
        this.tilePack = tilePack;

        setIcon(determineIcon(false));
        setToolTipText("Click to open source of pack in browser");
        addMouseListener(new HelpLinkMouseAdapter());
    }

    private ImageIcon determineIcon(boolean hovering) {
        if(this.tilePack.link.contains("youtube.com") || this.tilePack.link.contains("youtu.be")) {
            return hovering ? YOUTUBE_ICON_HOVER : YOUTUBE_ICON;
        } else if(this.tilePack.link.contains("discord.gg")) {
            return hovering ? DISCORD_ICON_HOVER : DISCORD_ICON;
        }
        return hovering ? HELP_ICON_HOVER : HELP_ICON;
    }

    class HelpLinkMouseAdapter extends MouseAdapter {
        @Override
        public void mousePressed(MouseEvent e) {
            if (SwingUtilities.isLeftMouseButton(e)) {
                LinkBrowser.browse(tilePack.link);
            }
        }

        @Override
        public void mouseEntered(MouseEvent e) {
            setIcon(determineIcon(true));
        }

        @Override
        public void mouseExited(MouseEvent e) {
            setIcon(determineIcon(false));
        }
    }
}


/*
 * Copyright (c) 2021, Adam <Adam@sigterm.info>
 * Copyright (c) 2022, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tilepacks.ui.panel;

import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.tilepacks.PointManager;
import com.tilepacks.TilePackConfigManager;
import com.tilepacks.TilePackManager;
import com.tilepacks.data.TilePackConfig;
import com.tilepacks.data.TilePack;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;

@Slf4j
/**
 * UI container for the TilePack and its controls
 * One exists for each TilePack
 *
 * Icons are from https://www.flaticon.com/
 * All icons are 20x20
 * Grey icons are #858585
 * Green icons are #4CAF50
 * Red icons are #E31C1C
 */
public class TilePackPanel extends JPanel {
    private static final int CONTROL_SIZE = 20;

    private final TilePackManager tilePackManager;
    private final PointManager pointManager;
    private final TilePackConfigManager tilePackConfigManager;
    private final ChatMessageManager chatMessageManager;
    private final Gson gson;
    private final TilePacksListPanel tilePacksList;

    private final TilePack tilePack;
    private final TilePackConfig tilePackConfig;

    private final JPanel topRow = new JPanel();
    private final JPanel controlPanel = new JPanel();
    private final JLabel packName;
    private final JLabel deleteCustomPack;
    private final JLabel toggleVisible;
    private final JLabel copyToClipboard;
    private final JLabel helpLink;
    private final JLabel togglePack;

    TilePackPanel(TilePackManager tilePackManager,
                  PointManager pointManager,
                  TilePackConfigManager tilePackConfigManager,
                  ChatMessageManager chatMessageManager,
                  Gson gson,
                  TilePacksListPanel tilePacksList,
                  TilePack tilePack,
                  TilePackConfig tilePackConfig
    ) {
        super();
        this.tilePackManager = tilePackManager;
        this.pointManager = pointManager;
        this.tilePackConfigManager = tilePackConfigManager;
        this.chatMessageManager = chatMessageManager;
        this.gson = gson;
        this.tilePacksList = tilePacksList;
        this.tilePack = tilePack;
        this.tilePackConfig = tilePackConfig;

        log.debug("Loading pack - {}", tilePack.packName);

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(3, 2, 3, 2));

        topRow.setLayout(new BorderLayout());
        topRow.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        topRow.setBorder(new EmptyBorder(2, 4, 1, 4));
        add(topRow, BorderLayout.NORTH);

        packName = new JLabel();
        // Disabling html prevents accidental leaking of IP via a shared tile pack
        packName.putClientProperty("html.disable", Boolean.TRUE);
        packName.setText(tilePack.packName);
        packName.setFont(FontManager.getRunescapeFont());
        topRow.add(packName, BorderLayout.WEST);

        controlPanel.setLayout(new FlowLayout(FlowLayout.TRAILING, 4, 6));
        controlPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        controlPanel.setBorder(new MatteBorder(1, 0, 0, 0, ColorScheme.DARK_GRAY_COLOR));
        add(controlPanel, BorderLayout.SOUTH);

        //anything over 10k is a custom pack
        if (tilePack.id >= 10000) {
            deleteCustomPack = new DeleteCustomPackLabel(tilePackManager, pointManager, tilePack, tilePacksList);
        } else {
            deleteCustomPack = new JLabel();
        }
        deleteCustomPack.setPreferredSize(new Dimension(CONTROL_SIZE, CONTROL_SIZE));
        controlPanel.add(deleteCustomPack);

        toggleVisible = new ToggleVisibleLabel(tilePackConfigManager, tilePack, tilePackConfig, tilePacksList);
        toggleVisible.setPreferredSize(new Dimension(CONTROL_SIZE, CONTROL_SIZE));
        controlPanel.add(toggleVisible);

        copyToClipboard = new CopyToClipboardLabel(chatMessageManager, gson, tilePack);
        copyToClipboard.setPreferredSize(new Dimension(CONTROL_SIZE, CONTROL_SIZE));
        controlPanel.add(copyToClipboard);

        if (!Strings.isNullOrEmpty(tilePack.link)) {
            helpLink = new HelpLinkLabel(tilePack);
        } else {
            helpLink = new JLabel();
        }
        helpLink.setPreferredSize(new Dimension(CONTROL_SIZE, CONTROL_SIZE));
        controlPanel.add(helpLink);

        togglePack = new TogglePackLabel(tilePackManager, pointManager, tilePack);
        togglePack.setPreferredSize(new Dimension(CONTROL_SIZE, CONTROL_SIZE));
        controlPanel.add(togglePack);
    }
}

/*
 * Copyright (c) 2022, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tilepacks.ui.panel;

import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.tilepacks.FilterManager;
import com.tilepacks.TilePackConfigManager;
import com.tilepacks.PointManager;
import com.tilepacks.TilePackManager;
import com.tilepacks.data.TilePackConfig;
import com.tilepacks.data.TilePack;
import com.tilepacks.ui.panel.header.HeaderPanel;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import java.awt.*;
import java.util.Map;

/**
 * UI panel parent, contains all content for the panel.
 */
public class TilePacksListPanel extends PluginPanel {

    private final TilePackManager tilePackManager;
    private final PointManager pointManager;
    private final TilePackConfigManager tilePackConfigManager;
    private final FilterManager filterManager;
    private final ChatMessageManager chatMessageManager;
    private final Gson gson;

    private final HeaderPanel headerPanel;
    private final JPanel listContainer = new JPanel();

    public TilePacksListPanel(TilePackManager tilePackManager,
                              PointManager pointManager,
                              TilePackConfigManager tilePackConfigManager,
                              FilterManager filterManager,
                              ChatMessageManager chatMessageManager,
                              Gson gson
    ) {
        super();
        this.tilePackManager = tilePackManager;
        this.pointManager = pointManager;
        this.tilePackConfigManager = tilePackConfigManager;
        this.filterManager = filterManager;
        this.chatMessageManager = chatMessageManager;
        this.gson = gson;

        headerPanel = new HeaderPanel(filterManager, this);
        add(headerPanel);

        add(listContainer);
        listContainer.setLayout(new GridLayout(0, 1, 0, 0));

        CustomPackManagerPanel customPackManager = new CustomPackManagerPanel(tilePackManager, pointManager, gson,this);

        add(customPackManager);

        createTilePackPanels();
    }

    public void createTilePackPanels() {
        listContainer.removeAll();
        String search = headerPanel.getSearchText();
        for (Map.Entry<Integer, TilePack> pack : tilePackManager.getTilePacks().entrySet()) {
            TilePack tilePack = pack.getValue();
            TilePackConfig tilePackConfig = tilePackConfigManager.getTilePackConfig(tilePack.id);
            boolean matchesSearch = Strings.isNullOrEmpty(search) || tilePack.packName.toLowerCase().contains(search.toLowerCase());
            boolean matchesFilters = (filterManager.getShowVisible() && tilePackConfig.visible) || (filterManager.getShowInvisible() && !tilePackConfig.visible);

            if (matchesSearch && matchesFilters) {
                JPanel tile = new TilePackPanel(tilePackManager, pointManager, tilePackConfigManager, chatMessageManager,
                        gson, this, tilePack, tilePackConfig);
                listContainer.add(tile);
            }
        }
        listContainer.revalidate();
        listContainer.repaint();
    }
}
/*
 * Copyright (c) 2024, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tilepacks.ui.panel;

import com.tilepacks.PointManager;
import com.tilepacks.TilePackManager;
import com.tilepacks.TilePacksPlugin;
import com.tilepacks.data.TilePack;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

/**
 * UI control that handles the enabling and disabling of the TilePack
 */
public class TogglePackLabel extends JLabel {
    private static final ImageIcon ADD_ICON;
    private static final ImageIcon ADD_ICON_HOVER;
    private static final ImageIcon REMOVE_ICON;
    private static final ImageIcon REMOVE_ICON_HOVER;

    private final TilePackManager tilePackManager;
    private final PointManager pointManager;
    private final TilePack tilePack;

    static {
        // Icon is https://www.flaticon.com/free-icon/plus_1828819
        // Made by https://www.flaticon.com/authors/pixel-perfect
        final BufferedImage addIcon = ImageUtil.loadImageResource(TilePacksPlugin.class, "add_icon.png");
        ADD_ICON = new ImageIcon(addIcon);
        ADD_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(addIcon, 0.53f));
        // Icon is https://www.flaticon.com/free-icon/minus_11433623
        // Made by https://www.flaticon.com/authors/utari-nuraeni
        final BufferedImage removeIcon = ImageUtil.loadImageResource(TilePacksPlugin.class, "remove_icon.png");
        REMOVE_ICON = new ImageIcon(removeIcon);
        REMOVE_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(removeIcon, 0.50f));
    }

    TogglePackLabel(TilePackManager tilePackManager, PointManager pointManager, TilePack tilePack) {
        super();
        this.tilePackManager = tilePackManager;
        this.pointManager = pointManager;
        this.tilePack = tilePack;

        if(tilePackManager.isPackEnabled(tilePack.id)) {
            setIcon(REMOVE_ICON);
            setToolTipText("Remove tiles");
        } else {
            setIcon(ADD_ICON);
            setToolTipText("Add tiles");
        }
        addMouseListener(new HelpLinkMouseAdapter());
    }

    class HelpLinkMouseAdapter extends MouseAdapter {
        @Override
        public void mousePressed(MouseEvent e) {
            if (SwingUtilities.isLeftMouseButton(e)) {
                if(tilePackManager.isPackEnabled(tilePack.id)) {
                    //remove click
                    tilePackManager.removeEnabledPack(tilePack.id);
                    setIcon(ADD_ICON_HOVER);
                    setToolTipText("Add tiles");
                } else {
                    //add click
                    tilePackManager.addEnabledPack(tilePack.id);
                    setIcon(REMOVE_ICON_HOVER);
                    setToolTipText("Remove tiles");
                }
                pointManager.loadPoints();
                revalidate();
                repaint();
            }
        }

        @Override
        public void mouseEntered(MouseEvent e) {
            if(tilePackManager.isPackEnabled(tilePack.id)) {
                setIcon(REMOVE_ICON_HOVER);
            } else {
                setIcon(ADD_ICON_HOVER);
            }
        }

        @Override
        public void mouseExited(MouseEvent e) {
            if(tilePackManager.isPackEnabled(tilePack.id)) {
                setIcon(REMOVE_ICON);
            } else {
                setIcon(ADD_ICON);
            }
        }
    }
}


/*
 * Copyright (c) 2024, Trevor <https://github.com/TrevorMDev>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tilepacks.ui.panel;

import com.tilepacks.TilePackConfigManager;
import com.tilepacks.TilePacksPlugin;
import com.tilepacks.data.TilePackConfig;
import com.tilepacks.data.TilePack;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

/**
 * UI control that handles the toggling of if a pack is visible or hidden
 */
public class ToggleVisibleLabel extends JLabel {
    private static final ImageIcon VISIBLE_ICON;
    private static final ImageIcon VISIBLE_ICON_HOVER;
    private static final ImageIcon INVISIBLE_ICON;
    private static final ImageIcon INVISIBLE_ICON_HOVER;

    private final TilePackConfigManager tilePackConfigManager;

    private final TilePack tilePack;
    private final TilePackConfig tilePackConfig;
    private final TilePacksListPanel tilePacksList;

    static {
        // Icon is https://www.flaticon.com/free-icon/visibility_3395544
        // Made by https://www.flaticon.com/authors/andrean-prabowo
        final BufferedImage visibleIcon = ImageUtil.loadImageResource(TilePacksPlugin.class, "visible_icon.png");
        VISIBLE_ICON = new ImageIcon(visibleIcon);
        VISIBLE_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(visibleIcon, 0.50f));

        // Icon is https://www.flaticon.com/free-icon/visible_4175339
        // Made by https://www.flaticon.com/authors/uicon
        final BufferedImage invisibleIcon = ImageUtil.loadImageResource(TilePacksPlugin.class, "invisible_icon.png");
        INVISIBLE_ICON = new ImageIcon(invisibleIcon);
        INVISIBLE_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(invisibleIcon, 0.50f));
    }

    ToggleVisibleLabel(TilePackConfigManager tilePackConfigManager,
                       TilePack tilePack,
                       TilePackConfig tilePackConfig,
                       TilePacksListPanel tilePacksList) {
        super();
        this.tilePackConfigManager = tilePackConfigManager;
        this.tilePack = tilePack;
        this.tilePackConfig = tilePackConfig;
        this.tilePacksList = tilePacksList;

        if(tilePackConfig.visible) {
            setIcon(VISIBLE_ICON);
            setToolTipText("Hide pack from list without deleting");
        } else {
            setIcon(INVISIBLE_ICON);
            setToolTipText("Show tile pack in main list");
        }

        this.addMouseListener(new ToggleVisibleMouseAdapter());
    }

    class ToggleVisibleMouseAdapter extends MouseAdapter {
        @Override
        public void mousePressed(MouseEvent e) {
            if (SwingUtilities.isLeftMouseButton(e)) {
                tilePackConfig.visible = !tilePackConfig.visible;
                if(tilePackConfig.visible) {
                    setIcon(VISIBLE_ICON);
                    setToolTipText("Hide pack from list without deleting");
                } else {
                    setIcon(INVISIBLE_ICON);
                    setToolTipText("Show tile pack in main list");
                }
                tilePackConfigManager.updateTilePackConfig(tilePackConfig);
                tilePacksList.createTilePackPanels();
            }
        }

        @Override
        public void mouseEntered(MouseEvent e) {
            if(tilePackConfig.visible) {
                setIcon(VISIBLE_ICON_HOVER);
            } else {
                setIcon(INVISIBLE_ICON_HOVER);
            }
        }

        @Override
        public void mouseExited(MouseEvent e) {
            if(tilePackConfig.visible) {
                setIcon(VISIBLE_ICON);
            } else {
                setIcon(INVISIBLE_ICON);
            }
        }
    }
}


package com.tilepacks;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TilePacksPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TilePacksPlugin.class);
		RuneLite.main(args);
	}
}
