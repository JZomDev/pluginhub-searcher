package com.arceuustimers;

public enum ArceuusSpell
{
	THRALL,
	THRALL_COOLDOWN,
	CHARGE,
	CHARGE_COOLDOWN,
	WARD,
	WARD_COOLDOWN,
	SHADOW,
	SHADOW_COOLDOWN,
	VIGOUR,
	CORRUPTION,
	OFFERING,
	LURE,
	MARK,
	SPELLBOOK_SWAP
}

package com.arceuustimers;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.ui.overlay.infobox.InfoBoxPriority;

import java.awt.*;

@ConfigGroup(ArceuusTimersConfig.GROUP)
public interface ArceuusTimersConfig extends Config
{
	enum TextFormat
	{
		SECONDS,
		MINUTES,
		GAME_TICKS
	}

	String GROUP = "arceuustimers";

	@ConfigSection(
			name = "Death Charge",
			description = "Death charge options.",
			position = 1,
			closedByDefault = true
	)
	String SECTION_DEATH_CHARGE = "deathCharge";

	String SHOW_DEATH_CHARGE = "showDeathChargeActive";
	@ConfigItem(
			section = SECTION_DEATH_CHARGE,
			keyName = SHOW_DEATH_CHARGE,
			name = "Show Active Charge",
			description = "Infobox for when Death Charge is active.",
			position = 2
	)
	default boolean showDeathChargeActive() { return true; }

	String SHOW_DEATH_CHARGE_COOLDOWN = "showDeathChargeCooldown";
	@ConfigItem(
			section = SECTION_DEATH_CHARGE,
			keyName = SHOW_DEATH_CHARGE_COOLDOWN,
			name = "Show Cooldown",
			description = "Infobox with timer for Death Charge's cooldown.",
			position = 3
	)
	default boolean showDeathChargeCooldown() { return true; }

    String STACK_DEATH_CHARGE = "stackDeathCharge";

    @ConfigItem(
            section = SECTION_DEATH_CHARGE,
            keyName = STACK_DEATH_CHARGE,
            name = "Stack Death Charge Boxes",
            description = "Merges multiple Death Charge infoboxes into one when active.",
            position = 4
    )
    default boolean stackDeathCharge() { return false; }

	@ConfigSection(
			name = "Resurrected Thralls",
			description = "Thrall options.",
			position = 5,
			closedByDefault = true
	)
	String SECTION_THRALL = "thrall";

	String SHOW_THRALL = "showThrall";
	@ConfigItem(
			section = SECTION_THRALL,
			keyName = SHOW_THRALL,
			name = "Show Thrall Timer",
			description = "Infobox with timer for Resurrected Thralls.",
			position = 6
	)
	default boolean showThrall() { return true; }

	String SHOW_THRALL_COOLDOWN = "showThrallCooldown";
	@ConfigItem(
			section = SECTION_THRALL,
			keyName = SHOW_THRALL_COOLDOWN,
			name = "Show Cooldown",
			description = "Infobox with timer for Resurrect Thrall cooldown.",
			position = 7
	)
	default boolean showThrallCooldown() { return true; }

	@ConfigSection(
			name = "Other Spells",
			description = "Options for the less popular Arceuus Spells",
			position = 8,
			closedByDefault = true
	)
	String SECTION_OTHER = "other";

	String SHOW_SHADOW_VEIL = "showShadowVeil";
	@ConfigItem(
			section = SECTION_OTHER,
			keyName = SHOW_SHADOW_VEIL,
			name = "Show Shadow Veil Timer",
			description = "Infobox with timer for Shadow Veil spell.",
			position = 9
	)
	default boolean showShadowVeil() { return true; }

	String SHOW_SHADOW_VEIL_COOLDOWN = "showShadowVeilCooldown";
	@ConfigItem(
			section = SECTION_OTHER,
			keyName = SHOW_SHADOW_VEIL_COOLDOWN,
			name = "Show Shadow Veil Cooldown",
			description = "Infobox with timer for Shadow Veil spell cooldown.",
			position = 10
	)
	default boolean showShadowVeilCooldown() { return true; }

	String SHOW_WARD_OF_ARCEUUS = "showWardOfArceuus";
	@ConfigItem(
			section = SECTION_OTHER,
			keyName = SHOW_WARD_OF_ARCEUUS,
			name = "Show Ward Of Arceuus Timer",
			description = "Infobox with timer for Ward of Arceuus when active.",
			position = 11
	)
	default boolean showWardOfArceuus() { return true; }

	String SHOW_WARD_OF_ARCEUUS_COOLDOWN = "showWardOfArceuusCooldown";
	@ConfigItem(
			section = SECTION_OTHER,
			keyName = SHOW_WARD_OF_ARCEUUS_COOLDOWN,
			name = "Show Ward Of Arceuus Cooldown",
			description = "Infobox with timer for Ward of Arceuus spell cooldown.",
			position = 12
	)
	default boolean showWardOfArceuusCooldown() { return true; }

	String SHOW_CORRUPTION_COOLDOWN = "showCorruptionCooldown";
	@ConfigItem(
			section = SECTION_OTHER,
			keyName = SHOW_CORRUPTION_COOLDOWN,
			name = "Show Corruption Cooldown",
			description = "Infobox with timer for Lesser and Greater Corruption spells.",
			position = 13
	)
	default boolean showCorruptionCooldown() { return true; }

	String SHOW_DARK_LURE_COOLDOWN = "showDarkLureCooldown";
	@ConfigItem(
			section = SECTION_OTHER,
			keyName = SHOW_DARK_LURE_COOLDOWN,
			name = "Show Dark Lure Cooldown",
			description = "Infobox with timer for Dark Lure spell.",
			position = 14
	)
	default boolean showDarkLureCooldown() { return true; }

	String SHOW_MARK_OF_DARKNESS = "showMarkTimer";
	@ConfigItem(
			section = SECTION_OTHER,
			keyName = SHOW_MARK_OF_DARKNESS,
			name = "Show Mark of Darkness Timer",
			description = "Infobox with timer for Mark of Darkness spell.",
			position = 15
	)
	default boolean showMarkTimer() { return true; }

	String SHOW_OFFERINGS_COOLDOWN = "showOfferingsCooldown";
	@ConfigItem(
			section = SECTION_OTHER,
			keyName = SHOW_OFFERINGS_COOLDOWN,
			name = "Show Offering Cooldown",
			description = "Infobox with timer for Demonic and Sinister Offering spells.",
			position = 16
	)
	default boolean showOfferingsCooldown() { return true; }

	String SHOW_VILE_VIGOUR_COOLDOWN = "showVileVigourCooldown";
	@ConfigItem(
			section = SECTION_OTHER,
			keyName = SHOW_VILE_VIGOUR_COOLDOWN,
			name = "Show Vile Vigour Cooldown",
			description = "Infobox with timer for Vile Vigour spell.",
			position = 17
	)
	default boolean showVileVigourCooldown() { return true; }

	String MAIN_TEXT_COLOUR = "mainText";
	@ConfigItem(
			keyName = MAIN_TEXT_COLOUR,
			name = "Text Colour",
			description = "Change the text colour of the time remaining.",
			position = 18
	)
	default Color textColour() { return Color.PINK.brighter(); }

	String LOW_TEXT_COLOUR = "lowTimeText";
	@ConfigItem(
			keyName = LOW_TEXT_COLOUR,
			name = "Low Time Colour",
			description = "Change text colour when the time remaining is low",
			position = 19
	)
	default Color lowTimeTextColour() { return Color.ORANGE; }

	String ARCEUUS_BOX_PRIORITY = "arceuusBoxPriority";
	@ConfigItem(
			keyName = ARCEUUS_BOX_PRIORITY,
			name = "Infobox Priority",
			description = "Change the priority of the Infoboxes created by this plugin.",
			position = 20
	)
	default InfoBoxPriority arceuusBoxPriority() { return InfoBoxPriority.NONE; }

	String TEXT_FORMAT = "textFormat";
	@ConfigItem(
			keyName = TEXT_FORMAT,
			name = "Text Format",
			description = "Choose the format for displaying time: seconds, minutes, or game ticks",
			position = 21
	)
	default TextFormat textFormat() { return TextFormat.SECONDS; }

	String SPELLBOOK_SWAP = "spellbookSwap";
	@ConfigItem(
			keyName = SPELLBOOK_SWAP,
			name = "Spellbook Swap Timer",
			description = "Show time left to cast a spell from the Lunar spell, Spellbook Swap.",
			position = 22
	)
	default boolean spellbookSwapToggle() { return true; }

}
package com.arceuustimers;

import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;

import java.awt.Color;
import java.awt.image.BufferedImage;

public class ArceuusTimersInfobox extends InfoBox
{
	private final double time;
	private double timeLeft;
	private final boolean showText;
	InfoBoxManager manager;
	ArceuusTimersConfig config;
    private String text = "";
	private static final double GAME_TICK = 0.6;
	private static final double LOW_TIME = 0.175;

	public ArceuusTimersInfobox(BufferedImage image, ArceuusTimersPlugin plugin, double time,
								InfoBoxManager manager, String tooltip, boolean showText)
	{
		super(image, plugin);
		this.time = time;
		this.manager = manager;
		this.showText = showText;
		this.config = plugin.getConfig();
		this.timeLeft = time;

		setTooltip(tooltip);
		setImage(image);
		setPriority(config.arceuusBoxPriority());
	}


    public ArceuusTimersInfobox(BufferedImage image, ArceuusTimersPlugin plugin, double time,
                                InfoBoxManager manager, String tooltip, boolean showText, String text)
    {
        super(image, plugin);
        this.time = time;
        this.text = text;
        this.manager = manager;
        this.showText = showText;
        this.config = plugin.getConfig();
        this.timeLeft = time;
        setTooltip(tooltip);
        setImage(image);
        setPriority(config.arceuusBoxPriority());
    }

	public void decreaseByGameTick()
	{
		timeLeft -= GAME_TICK;
	}

    public void changeText(String text)
    {
        this.text = text;
    }

	public String getText()
	{
		if (!showText || timeLeft < 0) return "";
        if (!text.isEmpty()) return text;
		switch (config.textFormat()) {
			case MINUTES:
				int minutes = (int)(timeLeft / 60);
				int seconds = (int)(timeLeft % 60);
				return String.format("%d:%02d", minutes, seconds);
			case GAME_TICKS:
				return "" + (int)(timeLeft / GAME_TICK);
			case SECONDS:
			default:
				return "" + (int)(timeLeft);
		}
	}

	public Color getTextColor()
	{
		if(timeLeft <= time * LOW_TIME) return config.lowTimeTextColour();
		return config.textColour();
	}

	public boolean render()
	{
		return timeLeft >= 0;
	}

	public boolean cull()
	{
		return timeLeft < 0;
	}
}
package com.arceuustimers;

import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

import javax.inject.Inject;

import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;
import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;

public class ArceuusTimersOverlay extends OverlayPanel
{
	@Inject
	private ArceuusTimersOverlay(ArceuusTimersPlugin plugin)
	{
		super(plugin);
		setPosition(OverlayPosition.BOTTOM_LEFT);
		setPriority(OverlayPriority.LOW);
		getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Arceuus Overlay "));
	}
}
package com.arceuustimers;

import com.arceuustimers.controllers.CorruptionController;
import com.arceuustimers.controllers.DeathChargeController;
import com.arceuustimers.controllers.MarkController;
import com.arceuustimers.controllers.SpellController;
import com.arceuustimers.controllers.StandardController;
import com.arceuustimers.controllers.ThrallController;
import com.arceuustimers.controllers.VariableTimerController;
import com.google.inject.Provides;
import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;

import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

@Slf4j
@PluginDescriptor(
	name = "Arceuus Timers",
	description = "Arceuus spellbook timers with an alternate design to the 'Timers' plugin.",
	tags = "timer,arceuus,spellbook,thrall,death charge,arceuus,timers"
)
public class ArceuusTimersPlugin extends Plugin
{
	private final HashMap<ArceuusSpell, SpellController> data = new HashMap<>();
	private final HashSet<Integer> spellVarbits = new HashSet<>();

	//private static final String TIMERS_PLUGIN = "timers";
	//private static final String SHOW_ARCEUUS = "showArceuus";
	//private static final String SHOW_ARCEUUS_COOLDOWN = "showArceuusCooldown";
	//private static final String SHOW_SPELLBOOK_SWAP = "showSpellbookSwap";
    private static final int VARBIT_UP = 1;
	private static final double NO_TEXT = -1.0;
	private static final double CD_LONG = 61.2;
	private static final double CD_MED = 31.2;
	private static final double CD_SHORT = 10.8;
	private static final double CD_TINY = 6.0;
	private static final double SBS_TIME = 120;

	private static final ThrallType[] THRALL_TYPES = {
			new ThrallType("/ghost.png", "Active thrall ( Ghost )"),       // VV 0, 3, 6
			new ThrallType("/skeleton.png", "Active thrall ( Skeleton )"), // VV 1, 4, 7
			new ThrallType("/zombie.png", "Active thrall ( Zombie )")      // VV 2, 5, 8
	};

	private final List<MessageHandler> gameMessageIconLockHandlers = Arrays.asList(
			new MessageHandler("You can only cast corruption spells every 30 seconds.", false, this::gameMessageCorrLockRelease),
			new MessageHandler("You resurrect a lesser ghostly thrall.", false, this::createThrall),
			new MessageHandler("You resurrect a lesser skeletal thrall.", false, this::createThrall),
			new MessageHandler("You resurrect a lesser zombified thrall.", false, this::createThrall),
			new MessageHandler("You resurrect a superior ghostly thrall.", false, this::createThrall),
			new MessageHandler("You resurrect a superior skeletal thrall.", false, this::createThrall),
			new MessageHandler("You resurrect a superior zombified thrall.", false, this::createThrall),
			new MessageHandler("You resurrect a greater ghostly thrall.", false, this::createThrall),
			new MessageHandler("You resurrect a greater skeletal thrall.", false, this::createThrall),
			new MessageHandler("You resurrect a greater zombified thrall.", false, this::createThrall),
			new MessageHandler("thrall returns to the grave.", true, this::closeThrallInfoBox),
			new MessageHandler("Your Ward of Arceuus has expired.", false, () -> expiredGameMessage(ArceuusSpell.WARD)),
			new MessageHandler("Your Shadow Veil has faded away.", false, () -> expiredGameMessage(ArceuusSpell.SHADOW)),
			new MessageHandler("You have placed a Mark of Darkness upon yourself.", false, this::gameMessageMarkOfDarkness),
			new MessageHandler("Your Mark of Darkness has faded away.", false, this::expiredMarkMessage)
	);

	private final Map<String, Runnable> menuOptionHandlers = new HashMap<String, Runnable>() {{
		put("Greater Corruption", () -> modifyCorruptionData("/greater.png", "Greater Corruption cooldown"));
		put("Lesser Corruption", () -> modifyCorruptionData("/lesser.png", "Lesser Corruption cooldown"));
		put("Sinister Offering", () -> modifyOfferingData("/sinister_offering.png", "Sinister Offering cooldown"));
		put("Demonic Offering", () -> modifyOfferingData("/demonic_offering.png", "Demonic Offering cooldown"));
	}};

	@Inject
	private Client client;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ArceuusTimersConfig config;

	@Inject
	private ArceuusTimersOverlay overlay;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private OverlayManager overlayManager;

	@Provides
	ArceuusTimersConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ArceuusTimersConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add( overlay );
		createSpellControllers();
		initialSpellVarbits();
		//Turn off 'Timers' plugin implementation
		//setTimersPlugin(false);
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove( overlay );
		//Only remove the active InfoBoxes that are created by this plugin
		removeActiveInfoboxes();
		//Turn on 'Timers' plugin implementation to replace this one
		//setTimersPlugin(true);
	}

	/*private void setTimersPlugin(boolean state)
	{
		configManager.setConfiguration(TIMERS_PLUGIN, SHOW_ARCEUUS, state);
		configManager.setConfiguration(TIMERS_PLUGIN, SHOW_ARCEUUS_COOLDOWN, state);
		configManager.setConfiguration(TIMERS_PLUGIN, SHOW_SPELLBOOK_SWAP, state);
	}*/

	private void removeActiveInfoboxes()
	{
		for (ArceuusSpell identifier : ArceuusSpell.values()) {
			SpellController spellController = data.get( identifier );
			spellController.shutdown();
		}
	}

	@Subscribe
	public void onGameTick(GameTick event) { updateActiveSpells(); }

	private void updateActiveSpells() {
		for (ArceuusSpell identifier : ArceuusSpell.values()) {
			SpellController spellController = data.get(identifier);
			if (spellController.getActive()) {
				spellController.updateTime();
			}
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals(ArceuusTimersConfig.GROUP)) {
			return;
		}

		switch (event.getKey()) {
			case ArceuusTimersConfig.SHOW_DEATH_CHARGE:
				updateConfigChange(config.showDeathChargeActive(),  VarbitID.ARCEUUS_DEATH_CHARGE_ACTIVE, ArceuusSpell.CHARGE);
				break;
			case ArceuusTimersConfig.SHOW_DEATH_CHARGE_COOLDOWN:
				updateConfigChange(config.showDeathChargeCooldown(),VarbitID.ARCEUUS_DEATH_CHARGE_COOLDOWN, ArceuusSpell.CHARGE_COOLDOWN);
				break;
            case ArceuusTimersConfig.STACK_DEATH_CHARGE:
                updateDeathChargeBoxes();
                break;
			case ArceuusTimersConfig.SHOW_THRALL:
				updateConfigChange(config.showThrall(), ArceuusSpell.THRALL);
				break;
			case ArceuusTimersConfig.SHOW_THRALL_COOLDOWN:
				updateConfigChange(config.showThrallCooldown(), VarbitID.ARCEUUS_RESURRECTION_COOLDOWN, ArceuusSpell.THRALL_COOLDOWN);
				break;
			case ArceuusTimersConfig.SHOW_CORRUPTION_COOLDOWN:
				updateConfigChange(config.showCorruptionCooldown(), VarbitID.ARCEUUS_CORRUPTION_COOLDOWN, ArceuusSpell.CORRUPTION);
				break;
			case ArceuusTimersConfig.SHOW_VILE_VIGOUR_COOLDOWN:
				updateConfigChange(config.showVileVigourCooldown(), VarbitID.ARCEUUS_VILE_VIGOUR_COOLDOWN, ArceuusSpell.VIGOUR);
				break;
			case ArceuusTimersConfig.SHOW_SHADOW_VEIL:
				if(!config.showShadowVeilCooldown() && !config.showShadowVeil())
				{
					updateConfigChange(config.showShadowVeilCooldown(), VarbitID.ARCEUUS_SHADOW_VEIL_COOLDOWN, ArceuusSpell.SHADOW_COOLDOWN);
				}else if((!config.showShadowVeilCooldown() && config.showShadowVeil()))
				{
					//Need to force a true here for the cooldown in case it is not on, otherwise shadow veil
					//won't function properly if it is recast after a cooldown while it is still active
					updateConfigChange(true, VarbitID.ARCEUUS_SHADOW_VEIL_COOLDOWN, ArceuusSpell.SHADOW_COOLDOWN);
					updateConfigChange(config.showShadowVeil(), VarbitID.ARCEUUS_SHADOW_VEIL_ACTIVE, ArceuusSpell.SHADOW);
				}else{
					updateConfigChange(config.showShadowVeil(), VarbitID.ARCEUUS_SHADOW_VEIL_ACTIVE, ArceuusSpell.SHADOW);
				}
				break;
			case ArceuusTimersConfig.SHOW_SHADOW_VEIL_COOLDOWN:
				if(config.showShadowVeil() && !config.showShadowVeilCooldown()) {
					updateConfigChange(ArceuusSpell.SHADOW_COOLDOWN);
				}else{
					updateConfigChange(config.showShadowVeilCooldown(), VarbitID.ARCEUUS_SHADOW_VEIL_COOLDOWN, ArceuusSpell.SHADOW_COOLDOWN);
				}
				break;
			case ArceuusTimersConfig.SHOW_DARK_LURE_COOLDOWN:
				updateConfigChange(config.showDarkLureCooldown(), VarbitID.ARCEUUS_DARK_LURE_COOLDOWN, ArceuusSpell.LURE);
				break;
			case ArceuusTimersConfig.SHOW_WARD_OF_ARCEUUS_COOLDOWN:
				if(config.showWardOfArceuus() && !config.showWardOfArceuusCooldown()) {
					updateConfigChange(ArceuusSpell.WARD_COOLDOWN);
				}else{
					updateConfigChange(config.showWardOfArceuusCooldown(), VarbitID.ARCEUUS_WARD_COOLDOWN, ArceuusSpell.WARD_COOLDOWN);
				}
				break;
			case ArceuusTimersConfig.SHOW_WARD_OF_ARCEUUS:
				updateConfigChange(config.showWardOfArceuus(), ArceuusSpell.WARD);
				break;
			case ArceuusTimersConfig.SHOW_OFFERINGS_COOLDOWN:
				updateConfigChange(config.showOfferingsCooldown(), VarbitID.ARCEUUS_OFFERING_COOLDOWN, ArceuusSpell.OFFERING);
				break;
			case ArceuusTimersConfig.SHOW_MARK_OF_DARKNESS:
				updateConfigChange(config.showMarkTimer(), ArceuusSpell.MARK);
            case ArceuusTimersConfig.SPELLBOOK_SWAP:
                updateConfigChange(config.spellbookSwapToggle(), VarbitID.LUNAR_SPELLBOOK_CHANGE, ArceuusSpell.SPELLBOOK_SWAP);
		}
	}

	private void updateConfigChange(boolean enabled, int bits, ArceuusSpell identifier)
	{
		if(enabled) {
			spellVarbits.add(bits);
		}else {
			spellVarbits.remove(bits);
			data.get(identifier).shutdown();
		}
	}

	private void updateConfigChange(ArceuusSpell identifier)
	{
		data.get(identifier).shutdown();
	}

    private void updateDeathChargeBoxes()
    {
        DeathChargeController deathChargeController = (DeathChargeController) data.get(ArceuusSpell.CHARGE);
        deathChargeController.reCreate();
    }

	private void updateConfigChange(boolean enabled,ArceuusSpell identifier) { if(!enabled) { data.get(identifier).shutdown(); } }

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		int varbit = event.getVarbitId();
		if (varbit == VarbitID.ARCEUUS_RESURRECTION_COOLDOWN && event.getValue() == VARBIT_UP) closeThrallInfoBox();
		if (varbit == VarbitID.ARCEUUS_RESURRECTION_USED) onThrallUsed(client.getVarbitValue( VarbitID.ARCEUUS_RESURRECTION_USED));
		SpellController spellController = data.get(getSpellIdentifier( varbit ));
		handleSpellVarbitChanges(varbit, spellController, event);
	}

	private void onThrallUsed(int varbitValue) {
		if (varbitValue < 0 || varbitValue > 8) return;
		ThrallType thrall = THRALL_TYPES[varbitValue % 3];
		modifyThrallData(thrall.fileName, thrall.tooltip);
	}

	private void handleSpellVarbitChanges(int varbit, SpellController spellController, VarbitChanged event) {
		if (!spellVarbits.contains(varbit)) { return; }
		if(handleCooldownConfigs(varbit)) { spellController.varbitChange(client.getVarbitValue(varbit)); }
		//Following two statements are for when a ward/veil is still active but
		//the cooldown has ended (i.e. boosted magic level is over 83) and is recast
		if(varbit == VarbitID.ARCEUUS_WARD_COOLDOWN && (event.getValue() == VARBIT_UP) && config.showWardOfArceuus())
		{
			VariableTimerController ward = (VariableTimerController) data.get(ArceuusSpell.WARD);
			ward.nonVarbitChange();
		}
		if(varbit == VarbitID.ARCEUUS_SHADOW_VEIL_COOLDOWN && (event.getValue() == VARBIT_UP) && config.showShadowVeil())
		{
			SpellController veil = data.get(getSpellIdentifier(VarbitID.ARCEUUS_SHADOW_VEIL_ACTIVE));
			veil.varbitChange(client.getVarbitValue(VarbitID.ARCEUUS_SHADOW_VEIL_ACTIVE));
		}
	}

	private boolean	handleCooldownConfigs(int varbit) {
		//These spells have cases where the timer relies on the cooldown varbit to re-trigger when already active
		//These boolean checks are to make sure the cooldown infoboxes do not get created if the config for
		//them is turned off but the program is allowed to process actions based off the cooldown varbits.
		boolean blockVeilCooldown = config.showShadowVeil() && !config.showShadowVeilCooldown() && varbit == VarbitID.ARCEUUS_SHADOW_VEIL_COOLDOWN;
		boolean blockWardCooldown = config.showWardOfArceuus() && !config.showWardOfArceuusCooldown() && varbit == VarbitID.ARCEUUS_WARD_COOLDOWN;
		return !(blockVeilCooldown || blockWardCooldown);
	}

	private void gameMessageCorrLockRelease()
	{
		CorruptionController corruption = (CorruptionController) data.get(ArceuusSpell.CORRUPTION);
		corruption.setIconLock(false);
	}
	private void gameMessageMarkOfDarkness() {
		MarkController mark = (MarkController) data.get(ArceuusSpell.MARK);
		mark.nonVarbitChange();
	}

	private void expiredGameMessage(ArceuusSpell spell)
	{
		VariableTimerController responder = (VariableTimerController) data.get(spell);
		responder.chatExpiredResponse();
	}

	private void expiredMarkMessage()
	{
		MarkController responder = (MarkController) data.get(ArceuusSpell.MARK);
		responder.chatExpiredResponse();
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (!event.getType().equals(ChatMessageType.GAMEMESSAGE)) return;
		String message = event.getMessage().replaceAll("<col=[a-z0-9]+>", "").replaceAll("</col>", "");
		for (MessageHandler handler : gameMessageIconLockHandlers)
		{
			if (handler.isSuffix ? message.endsWith(handler.message) : message.equals(handler.message))
			{
				if (handler.message.startsWith("You resurrect a ") && !config.showThrall())
				{
					log.debug("Thrall cast message ignored, showThrall=false: {}", message);
					return;
				}
				handler.action.run();
				log.debug("ARCEUUS TIMERS - Chat message handled: {}", message);
				return;
			}
		}
	}

	private void createThrall()
	{
		ThrallController thrall = (ThrallController) data.get(ArceuusSpell.THRALL);
		thrall.createThrall();
	}

	private void modifyThrallData(String fileName, String tooltip) {
		ThrallController changeData = (ThrallController) data.get(ArceuusSpell.THRALL);
		changeData.setFileName(fileName);
		changeData.setTooltip(tooltip);
	}

	private void modifyCorruptionData(String fileName, String tooltip) {
		CorruptionController changeData = (CorruptionController) data.get(ArceuusSpell.CORRUPTION);
		if (changeData.isIconLocked()) return;
		changeData.setTooltip(tooltip);
		changeData.setFileName(fileName);
		changeData.setIconLock(true);
	}

	private void modifyOfferingData(String fileName, String tooltip) {
		StandardController changeData = (StandardController) data.get(ArceuusSpell.OFFERING);
		changeData.setTooltip(tooltip);
		changeData.setFileName(fileName);
	}

	@Subscribe
	private void onMenuOptionClicked(MenuOptionClicked cast) {
		String option = cast.getMenuTarget().replaceAll("<col=[a-z0-9]+>", "").replaceAll("</col>", "");
		Runnable handler = menuOptionHandlers.get(option);
		if (handler != null) handler.run();
	}

	public ArceuusTimersConfig getConfig()
	{
		return config;
	}

	private ArceuusSpell getSpellIdentifier(int varbit)
	{
		switch(varbit) {
			case VarbitID.ARCEUUS_RESURRECTION_COOLDOWN: return ArceuusSpell.THRALL_COOLDOWN;
			case VarbitID.ARCEUUS_DEATH_CHARGE_ACTIVE: return ArceuusSpell.CHARGE;
			case VarbitID.ARCEUUS_DEATH_CHARGE_COOLDOWN: return ArceuusSpell.CHARGE_COOLDOWN;
			case VarbitID.ARCEUUS_CORRUPTION_COOLDOWN: return ArceuusSpell.CORRUPTION;
			case VarbitID.ARCEUUS_SHADOW_VEIL_ACTIVE: return ArceuusSpell.SHADOW;
			case VarbitID.ARCEUUS_SHADOW_VEIL_COOLDOWN: return ArceuusSpell.SHADOW_COOLDOWN;
			case VarbitID.ARCEUUS_WARD_COOLDOWN: return ArceuusSpell.WARD_COOLDOWN;
			case VarbitID.ARCEUUS_VILE_VIGOUR_COOLDOWN: return ArceuusSpell.VIGOUR;
			case VarbitID.ARCEUUS_DARK_LURE_COOLDOWN: return ArceuusSpell.LURE;
			case VarbitID.ARCEUUS_OFFERING_COOLDOWN: return ArceuusSpell.OFFERING;
			case VarbitID.LUNAR_SPELLBOOK_CHANGE: return  ArceuusSpell.SPELLBOOK_SWAP;
			default: return null;
		}
	}

	private void initialSpellVarbits()
	{
		if (config.showDeathChargeActive()) { spellVarbits.add(VarbitID.ARCEUUS_DEATH_CHARGE_ACTIVE); }
		if (config.showDeathChargeCooldown()) { spellVarbits.add(VarbitID.ARCEUUS_DEATH_CHARGE_COOLDOWN); }
		if (config.showThrallCooldown()) { spellVarbits.add(VarbitID.ARCEUUS_RESURRECTION_COOLDOWN); }
		if (config.showCorruptionCooldown()) { spellVarbits.add(VarbitID.ARCEUUS_CORRUPTION_COOLDOWN); }
		if (config.showShadowVeil() ) { spellVarbits.add(VarbitID.ARCEUUS_SHADOW_VEIL_ACTIVE); }
		if (config.showShadowVeilCooldown() || config.showShadowVeil() ){ spellVarbits.add(VarbitID.ARCEUUS_SHADOW_VEIL_COOLDOWN); }
		if (config.showVileVigourCooldown()) { spellVarbits.add(VarbitID.ARCEUUS_VILE_VIGOUR_COOLDOWN); }
		if (config.showOfferingsCooldown()) { spellVarbits.add(VarbitID.ARCEUUS_OFFERING_COOLDOWN); }
		if (config.showDarkLureCooldown()) { spellVarbits.add(VarbitID.ARCEUUS_DARK_LURE_COOLDOWN); }
		if (config.showWardOfArceuusCooldown() || config.showWardOfArceuus()){ spellVarbits.add(VarbitID.ARCEUUS_WARD_COOLDOWN); }
		if (config.spellbookSwapToggle()){ spellVarbits.add(VarbitID.LUNAR_SPELLBOOK_CHANGE); }
	}

	private void closeThrallInfoBox()
	{
		ThrallController thrall = (ThrallController) data.get(ArceuusSpell.THRALL);
		thrall.shutdown();
	}

	private void createSpellControllers()
	{
		HashMap<ArceuusSpell, InitialSpellData> initData = new HashMap<>();
		initData.put(ArceuusSpell.THRALL, new InitialSpellData("/ghost.png", CD_LONG, "Active thrall ( Ghost )"));
		initData.put(ArceuusSpell.THRALL_COOLDOWN, new InitialSpellData("/thrall_cooldown.png", CD_SHORT, "Thrall cooldown"));
		initData.put(ArceuusSpell.CHARGE, new InitialSpellData("/death_charge.png", CD_LONG, "Death Charge active"));
		initData.put(ArceuusSpell.CHARGE_COOLDOWN, new InitialSpellData("/death_charge_cooldown.png", CD_LONG, "Death Charge cooldown"));
		initData.put(ArceuusSpell.SHADOW, new InitialSpellData("/shadow_veil.png", CD_LONG, "Shadow Veil active"));
		initData.put(ArceuusSpell.SHADOW_COOLDOWN, new InitialSpellData("/shadow_veil_cooldown.png", CD_MED, "Shadow Veil cooldown"));
		initData.put(ArceuusSpell.VIGOUR, new InitialSpellData("/vile_vigour.png", CD_SHORT, "Vile Vigour cooldown"));
		initData.put(ArceuusSpell.CORRUPTION, new InitialSpellData("/greater.png", CD_MED, "Greater Corruption cooldown"));
		initData.put(ArceuusSpell.WARD, new InitialSpellData("/ward.png", CD_LONG, "Ward of Arceuus active"));
		initData.put(ArceuusSpell.WARD_COOLDOWN, new InitialSpellData("/ward_cooldown.png", CD_MED, "Ward of Arceuus cooldown"));
		initData.put(ArceuusSpell.LURE, new InitialSpellData("/lure.png", CD_SHORT, "Dark Lure cooldown"));
		initData.put(ArceuusSpell.OFFERING, new InitialSpellData("/sinister_offering.png", CD_TINY, "Sinister Offering cooldown"));
		initData.put(ArceuusSpell.MARK, new InitialSpellData("/mark.png", NO_TEXT, "Mark of Darkness active"));
		initData.put(ArceuusSpell.SPELLBOOK_SWAP, new InitialSpellData("/sbs.png", SBS_TIME, ""));

		for(ArceuusSpell spell: ArceuusSpell.values())
		{
			SpellController controller;
			switch (spell){
				case THRALL:
					controller = new ThrallController(
							initData.get( spell ).getFile(),
							initData.get( spell ).getCooldown(),
							initData.get( spell ).getTooltip(),
							infoBoxManager,
							this,
							client);
					break;
				case MARK:
					controller = new MarkController(
							initData.get( spell ).getFile(),
							initData.get( spell ).getCooldown(),
							initData.get( spell ).getTooltip(),
							infoBoxManager,
							this,
							client);
					break;
				case WARD:
				case SHADOW:
					controller = new VariableTimerController(
							initData.get( spell ).getFile(),
							initData.get( spell ).getCooldown(),
							initData.get( spell ).getTooltip(),
							infoBoxManager,
							this,
							client);
					break;
				case CORRUPTION:
					controller = new CorruptionController(
							initData.get( spell ).getFile(),
							initData.get( spell ).getCooldown(),
							initData.get( spell ).getTooltip(),
							infoBoxManager,
							this);
					break;
				case CHARGE:
					controller = new DeathChargeController(
							initData.get(spell).getFile(),
							initData.get(spell).getCooldown(),
							initData.get(spell).getTooltip(),
							infoBoxManager,
							this);
					break;
				default:
					controller = new StandardController(
							initData.get( spell ).getFile(),
							initData.get( spell ).getCooldown(),
							initData.get( spell ).getTooltip(),
							infoBoxManager,
							this);
					break;

			}
			data.put(spell,controller);
		}
	}

	private static class InitialSpellData{
		private final String file;
		private final double cooldown;
		private final String tooltip;
		public InitialSpellData(String file, double cooldown, String tooltip) {
			this.file = file;
			this.cooldown = cooldown;
			this.tooltip = tooltip;
		}

		public String getFile() {
			return file;
		}

		public double getCooldown() {
			return cooldown;
		}

		public String getTooltip() {
			return tooltip;
		}
	}

	private static class ThrallType {
		final String fileName;
		final String tooltip;

		ThrallType(String fileName, String tooltip) {
			this.fileName = fileName;
			this.tooltip = tooltip;
		}
	}

	private static class MessageHandler {
		final String message;
		final boolean isSuffix;
		final Runnable action;

		MessageHandler(String message, boolean isSuffix, Runnable action) {
			this.message = message;
			this.isSuffix = isSuffix;
			this.action = action;
		}
	}
}
package com.arceuustimers.controllers;

import com.arceuustimers.ArceuusTimersPlugin;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;

public class CorruptionController extends SpellController
{
	private boolean iconLock;
	private static final int VARBIT_DOWN = 0;
	private static final int VARBIT_UP = 1;

	public CorruptionController(String fileName, double cooldown, String tooltip, InfoBoxManager manager, ArceuusTimersPlugin plugin)
	{
		super(fileName,cooldown,tooltip,manager,plugin);
		this.iconLock = false;
	}

	public boolean isIconLocked() {
		return iconLock;
	}

	public void setIconLock(boolean iconLock) {
		this.iconLock = iconLock;
	}

	@Override
	public void varbitChange(int bit)
	{
		if( bit == VARBIT_UP && !super.getActive() ) {
			createBox();
			setIconLock(false);
		}
		else if( bit == VARBIT_DOWN && super.getActive()) {
			removeBox();
		}
	}

	@Override
	protected void createBox() {
		super.createBox();
	}

	@Override
	protected void removeBox()
	{
		super.removeBox();
	}


}

package com.arceuustimers.controllers;

import com.arceuustimers.ArceuusTimersInfobox;
import com.arceuustimers.ArceuusTimersPlugin;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ImageUtil;
import java.awt.image.BufferedImage;

public class DeathChargeController extends SpellController {
	private ArceuusTimersInfobox secondBox; // second infobox for charge 2
	private int currentCharges; // track current varbit value
    private boolean stacked = false;
	public DeathChargeController(String fileName, double cooldown, String tooltip, InfoBoxManager manager, ArceuusTimersPlugin plugin) {
		super(fileName, cooldown, tooltip, manager, plugin);
		this.secondBox = null;
		this.currentCharges = 0;
        this.stacked = plugin.getConfig().stackDeathCharge();
	}

	@Override
	public void varbitChange(int bit) {
		if (bit == currentCharges) return;
		if (bit == 0) {
			removeBox();
		} else if (bit == 1) {
			if (currentCharges == 0) {
				createBox(bit);
			} else if (currentCharges == 2) {
                if (stacked) box.changeText("1");
				removeSecondBox();
			}
		} else if (bit == 2) {
			if (currentCharges == 0) {
				createBox(bit);
				createSecondBox();
			} else if (currentCharges == 1) {
				createSecondBox();
			}
		}
		currentCharges = bit;
	}


	protected void createBox(int count) {
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), fileName);
        if(!stacked) {
            box = new ArceuusTimersInfobox(
                    icon,
                    plugin,
                    cooldown,
                    manager,
                    "Death Charge (1)",
                    stacked);
        }
        else {
            box = new ArceuusTimersInfobox(
                    icon,
                    plugin,
                    cooldown,
                    manager,
                    count == 2 ? "Death Charge's" : "Death Charge",
                    stacked,
                    Integer.toString(count));
        }
		manager.addInfoBox(box);
		active = true;
	}

	private void createSecondBox() {
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), fileName);
        if (stacked) return;
        secondBox = new ArceuusTimersInfobox(
				icon,
				plugin,
				cooldown,
				manager,
				"Death Charge (2)",
                false);
		manager.addInfoBox(secondBox);
	}

	@Override
	protected void removeBox() {
		if (box != null)
		{
			manager.removeInfoBox(box);
			box = null;
		}
		removeSecondBox();
		active = false;
		currentCharges = 0;
	}

	private void removeSecondBox()
	{
		if (secondBox == null) return;
		manager.removeInfoBox(secondBox);
		secondBox = null;
	}

	@Override
	public void shutdown() {
		removeBox();
	}

	@Override
	public void updateTime() {
		if (box != null) box.decreaseByGameTick();
		if (secondBox != null) secondBox.decreaseByGameTick();

	}

    public void reCreate()
    {
        if (box == null) return;
        int charge = currentCharges;
        shutdown();
        removeSecondBox();
        this.stacked = plugin.getConfig().stackDeathCharge();
        this.currentCharges = charge;
        if (charge == 1) {
                createBox(charge);
        } else if (charge == 2) {
            if (!stacked) {
                createBox(charge);
                createSecondBox();
            } else {
                createBox(charge);
            }
        }
    }

}
package com.arceuustimers.controllers;

import com.arceuustimers.ArceuusTimersPlugin;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.Skill;
import net.runelite.api.gameval.InventoryID;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;

public class MarkController extends SpellController
{
	private final Client client;
	private static final double GAME_TICK = 0.6;
	private static final int VARBIT_DOWN = 0;
	private static final int PURGING_STAFF = 29594;
    private static final double THREE_TICK_MINUTES = 300;
    private static final double FIFTEEN_TICK_MINUTES = 1500;

	public MarkController(String fileName, double cooldown, String tooltip, InfoBoxManager manager, ArceuusTimersPlugin plugin, Client client)
	{
		super(fileName,cooldown,tooltip,manager,plugin);
		this.client = client;
	}

	@Override
	public void varbitChange(int bit)
	{
		if(super.getActive()) {
			removeBox();
		}
		if (bit == VARBIT_DOWN) {
			return;
		}
		creationHandler();
	}

	public void nonVarbitChange() {
		if(super.getActive()) {
			removeBox();
		}
		creationHandler();
	}

	private void creationHandler()
	{
		double upTime = (GAME_TICK * THREE_TICK_MINUTES) + (GAME_TICK * 2);
        final ItemContainer inv = client.getItemContainer(InventoryID.WORN);
		if(inv != null)
			for(Item it : inv.getItems()) {
				if(it == null) continue;
				if(it.getId() != PURGING_STAFF) continue;
				upTime = ((GAME_TICK * FIFTEEN_TICK_MINUTES) + (GAME_TICK * 2));
			}
		super.setCooldown(upTime);
		createBox();
	}

	@Override
	protected void createBox()
	{
		super.createBox();
	}

	@Override
	protected void removeBox()
	{
		super.removeBox();
	}

	public void chatExpiredResponse()
	{
		if(super.getActive())removeBox();
	}
}

package com.arceuustimers.controllers;

import com.arceuustimers.ArceuusTimersInfobox;
import com.arceuustimers.ArceuusTimersPlugin;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;


public abstract class SpellController
{
	protected boolean active;
	protected ArceuusTimersInfobox box;
	protected String fileName;
	protected double cooldown;
	protected String tooltip;
	protected final InfoBoxManager manager;
	protected final ArceuusTimersPlugin plugin;
	protected static final int VARBIT_UP = 1;
	protected static final int VARBIT_DOWN = 0;
	private boolean showText = true;

	public SpellController(String fileName, double cooldown, String tooltip, InfoBoxManager manager, ArceuusTimersPlugin plugin) {
		this.fileName = fileName;
		this.cooldown = cooldown;
		this.tooltip = tooltip;
		this.manager = manager;
		this.plugin = plugin;
		this.active = false;
		this.box = null;
	}


	public boolean getActive() {
		return active;
	}

	public void setFileName(String fileName) {
		this.fileName = fileName;
	}

	public void setCooldown(double cooldown) {
		this.cooldown = cooldown;
	}

	public void setTooltip(String tooltip) {
		this.tooltip = tooltip;
	}

	public void varbitChange(int bit)
	{
		if( bit == VARBIT_UP && !this.active ) {
			createBox();
		}
		else if( bit == VARBIT_DOWN && this.active) {
			removeBox();
		}
	}

	public void shutdown()
	{
		if(this.active)
		{
			removeBox();
		}
	}

	public void updateTime()
	{
		if (!active || box == null) return;
		box.decreaseByGameTick();
		if (box.cull()) removeBox();
	}

	protected void createBox()
	{
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), fileName);
		this.box = new ArceuusTimersInfobox(
				icon,
				this.plugin,
				this.cooldown,
				this.manager,
				this.tooltip,
				showText);
		this.manager.addInfoBox(this.box);
		this.active = true;
	}

	protected void removeBox() {
		if (box != null)
		{
			manager.removeInfoBox(box);
			box = null;
		}
		active = false;
	}
}

package com.arceuustimers.controllers;

import com.arceuustimers.ArceuusTimersPlugin;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;

public class StandardController extends SpellController
{

	public StandardController(String fileName, double cooldown, String tooltip, InfoBoxManager manager, ArceuusTimersPlugin plugin)
	{
		super(fileName,cooldown,tooltip,manager,plugin);
	}


	@Override
	public void varbitChange(int bit)
	{
		super.varbitChange(bit);
	}

	@Override
	protected void createBox() {
		super.createBox();
	}

	@Override
	protected void removeBox()
	{
		super.removeBox();
	}


}

package com.arceuustimers.controllers;

import com.arceuustimers.ArceuusTimersPlugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
@Slf4j
public class ThrallController extends SpellController
{
	private final Client client;
	private static final double GAME_TICK = 0.6;
	private static final int UNLOCKED = 2;
	private static final double THRALL_MULTIPLIER = 2.0;

	public ThrallController(String fileName, double cooldown, String tooltip, InfoBoxManager manager, ArceuusTimersPlugin plugin, Client client)
	{
		super(fileName,cooldown,tooltip,manager,plugin);
		this.client = client;
	}

	public void createThrall()
	{
		if (getActive()) shutdown();
		double thrallUptime = GAME_TICK * client.getBoostedSkillLevel(Skill.MAGIC);
		if ((client.getVarbitValue(VarbitID.CA_TIER_STATUS_GRANDMASTER ) == UNLOCKED) ||
		    (client.getVarbitValue(VarbitID.CA_TIER_STATUS_MASTER) == UNLOCKED))
		{
			thrallUptime *= THRALL_MULTIPLIER;
		}
		thrallUptime -= GAME_TICK; // 1-tick delay for box creation
		setCooldown(thrallUptime);
		createBox();
	}

	@Override
	public void varbitChange(int bit)
	{
		//Remove creation of thrall infoboxes via varbits
	}

	@Override
	protected void createBox()
	{
		super.createBox();
	}

	@Override
	protected void removeBox()
	{
		super.removeBox();
	}
}

package com.arceuustimers.controllers;

import com.arceuustimers.ArceuusTimersPlugin;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;

public class VariableTimerController extends SpellController
{
	private final Client client;
	private static final double GAME_TICK = 0.6;
	private static final int VARBIT_DOWN = 0;

	public VariableTimerController(String fileName, double cooldown, String tooltip, InfoBoxManager manager, ArceuusTimersPlugin plugin, Client client)
	{
		super(fileName,cooldown,tooltip,manager,plugin);
		this.client = client;
	}

	@Override
	public void varbitChange(int bit)
	{
		if(super.getActive()) {
			removeBox();
		}
		if (bit == VARBIT_DOWN) {
			return;
		}
		creationHandler();
	}

	public void nonVarbitChange() {
		if(super.getActive()) {
			removeBox();
		}
		creationHandler();
	}

	private void creationHandler()
	{
		double upTime = (GAME_TICK * client.getRealSkillLevel(Skill.MAGIC)) + (GAME_TICK * 2);
		super.setCooldown(upTime);
		createBox();
	}

	@Override
	protected void createBox()
	{
		super.createBox();
	}

	@Override
	protected void removeBox()
	{
		super.removeBox();
	}

	public void chatExpiredResponse()
	{
		if(super.getActive())
		{
			removeBox();
		}
	}
}

package com.arceuustimers;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ArceuusTimersPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ArceuusTimersPlugin.class);
		RuneLite.main(args);
	}
}
