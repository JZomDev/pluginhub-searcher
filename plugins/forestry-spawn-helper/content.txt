package xyz.oelderoth.runelite.forestry;

import com.google.common.base.MoreObjects;
import java.awt.BasicStroke;
import java.awt.Color;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.time.Instant;
import javax.inject.Inject;
import net.runelite.client.util.ColorUtil;
import xyz.oelderoth.runelite.forestry.service.ForceSpawnService;
import xyz.oelderoth.runelite.forestry.service.WoodcuttingService;

@Singleton
public class ForceSpawnOverlay extends Overlay
{

	@Inject
	private Client client;

	@Inject
	private ModelOutlineRenderer renderer;

	@Inject
	private ForestryPluginConfig config;

	@Inject
	private ForceSpawnService forceSpawnService;

	@Inject
	private WoodcuttingService woodcuttingService;

	public ForceSpawnOverlay()
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPriority(PRIORITY_HIGH);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		var wcState = woodcuttingService.getWoodcuttingState();
		if (wcState != null && config.drawOutlineInProgressTree())
		{
			if (client.getTickCount() - wcState.getStartTick() > ForceSpawnService.MIN_TICK_COUNT)
			{
				renderHighlight(graphics,
					wcState.getGameObject(),
					config.inProgressBorderColor(),
					config.inProgressFillColor(),
					config.inProgressWidth(),
					config.completedFeather(),
					config.drawOutlineInProgressTree(),
					config.drawHullInProgressTree(),
					config.drawClickboxInProgressTree(),
					config.drawTileInProgressTree()
				);
			}
		}

		long now = Instant.now()
			.toEpochMilli();
		forceSpawnService.getTreeTimers()
			.stream()
			.filter(timer -> timer.getWorld() == client.getWorld())
			.forEach(timer -> {
				var completed = (now - timer.getStartTimeMs() > timer.getTreeType()
					.getDespawnDurationMs());
				var borderColor = completed ? config.completedBorderColor() : config.inProgressBorderColor();
				var fillColor = completed ? config.completedFillColor() : config.inProgressFillColor();
				var width = completed ? config.completedWidth() : config.inProgressWidth();
				var feather = completed ? config.completedFeather() : config.inProgressFeather();
				var drawOutline = completed ? config.drawOutlineCompleteTree() : config.drawOutlineInProgressTree();
				var drawHull = completed ? config.drawHullCompleteTree() : config.drawHullInProgressTree();
				var drawClickbox = completed ? config.drawClickboxCompleteTree() : config.drawClickboxInProgressTree();
				var drawTile = completed ? config.drawTileCompleteTree() : config.drawTileInProgressTree();

				woodcuttingService.getTreeObject(timer.getTree())
					.ifPresent(obj -> renderHighlight(graphics, obj, borderColor, fillColor, width, feather, drawOutline, drawHull, drawClickbox, drawTile));
			});

		return null;
	}

	private void renderHighlight(Graphics2D graphics, GameObject obj, Color borderColor, Color fillColor, int width, int feather, boolean drawOutline, boolean drawHull, boolean drawClickbox, boolean drawTile)
	{
		if (drawOutline)
		{
			renderer.drawOutline(obj, width, borderColor, feather);
		}
		if (drawHull)
		{
			var hull = obj.getConvexHull();
			if (hull != null)
			{
				// Default to a=50 to match default ObjectIndicators
				var color = MoreObjects.firstNonNull(fillColor, new Color(0, 0, 0, 50));
				OverlayUtil.renderPolygon(graphics, hull, borderColor, color, new BasicStroke(width));
			}
		}
		if (drawClickbox)
		{
			var clickbox = obj.getClickbox();
			if (clickbox != null)
			{
				// Default to using a/12 to match default ObjectIndicators
				var color = MoreObjects.firstNonNull(fillColor, ColorUtil.colorWithAlpha(borderColor, borderColor.getAlpha() / 12));
				OverlayUtil.renderPolygon(graphics, clickbox, borderColor, color, new BasicStroke(width));
			}
		}
		if (drawTile)
		{
			var tile = obj.getCanvasTilePoly();
			if (tile != null)
			{
				// Default to using a/12 to match default ObjectIndicators
				var color = MoreObjects.firstNonNull(fillColor, ColorUtil.colorWithAlpha(borderColor, borderColor.getAlpha() / 12));
				OverlayUtil.renderPolygon(graphics, tile, borderColor, color, new BasicStroke(width));
			}
		}
	}
}
package xyz.oelderoth.runelite.forestry;

import com.google.inject.Provides;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.overlay.OverlayManager;
import javax.inject.Inject;
import xyz.oelderoth.runelite.forestry.service.ForceSpawnService;
import xyz.oelderoth.runelite.forestry.service.WoodcuttingService;
import xyz.oelderoth.runelite.forestry.service.WorldHopService;
import xyz.oelderoth.runelite.forestry.ui.ForestryPluginPanel;

@PluginDescriptor(name = ForestryPlugin.PLUGIN_NAME, description = "A plugin to help with force spawning Forestry events")
@Slf4j
public class ForestryPlugin extends Plugin
{
	public static final String PLUGIN_NAME = "Forestry Spawn Helper";

	@Getter
	private static ForestryPlugin instance;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ScheduledExecutorService executorService;

	@Inject
	private ForceSpawnOverlay forceSpawnOverlay;

	@Inject
	private ForceSpawnService forceSpawnService;

	@Inject
	private WoodcuttingService woodcuttingService;

	@Inject
	private WorldHopService worldHopService;

	private ForestryPluginPanel pluginPanel;
	private ScheduledFuture<?> panelUpdateFuture;

	public ForestryPlugin()
	{
		instance = this;
	}

	@Override
	protected void startUp()
	{
		// Inject after startup to avoid incorrect default Swing styling
		if (pluginPanel == null) pluginPanel = injector.getInstance(ForestryPluginPanel.class);

		forceSpawnService.enable();
		worldHopService.enable();
		woodcuttingService.enable();
		overlayManager.add(forceSpawnOverlay);
		clientToolbar.addNavigation(pluginPanel.getNavigationButton());
		panelUpdateFuture = executorService.scheduleAtFixedRate(pluginPanel::update, 200, 200, TimeUnit.MILLISECONDS);
	}

	@Override
	protected void shutDown()
	{
		forceSpawnService.disable();
		worldHopService.disable();
		woodcuttingService.disable();
		overlayManager.remove(forceSpawnOverlay);
		clientToolbar.removeNavigation(pluginPanel.getNavigationButton());
		if (panelUpdateFuture != null)
		{
			panelUpdateFuture.cancel(true);
			panelUpdateFuture = null;
		}
		pluginPanel = null;
	}

	@Subscribe
	protected void onConfigChanged(ConfigChanged e)
	{
		if (e.getGroup().equals(ForestryPluginConfig.CONFIG_GROUP) && e.getKey().equals("sortOrder"))
			pluginPanel.rebuildSortedTimerList();
	}

	@Provides
	private ForestryPluginConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ForestryPluginConfig.class);
	}
}

package xyz.oelderoth.runelite.forestry.ui;

import java.awt.Cursor;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.function.Consumer;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Constants;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.ThinProgressBar;
import xyz.oelderoth.runelite.forestry.ForestryPluginConfig;
import xyz.oelderoth.runelite.forestry.service.WorldHopService;
import xyz.oelderoth.runelite.forestry.domain.TreeTimer;
import xyz.oelderoth.runelite.forestry.ui.builders.border.BorderBuilder;
import xyz.oelderoth.runelite.forestry.ui.builders.component.ClickFilter;
import xyz.oelderoth.runelite.forestry.ui.builders.component.LabelBuilder;
import xyz.oelderoth.runelite.forestry.ui.builders.component.MenuItemBuilder;
import xyz.oelderoth.runelite.forestry.ui.builders.panel.BorderPanelBuilder;
import xyz.oelderoth.runelite.forestry.ui.builders.panel.GridBagConstraintsBuilder;
import xyz.oelderoth.runelite.forestry.ui.builders.panel.GridBagPanelBuilder;
import xyz.oelderoth.runelite.forestry.ui.icons.Icons;

@Slf4j
public class TreeTimerPanel extends JPanel
{
	private final ForestryPluginConfig config;
	private final TreeTimer timer;

	private final JLabel estimateLabel = new LabelBuilder()
		.foreground(PluginScheme.HINT_COLOR)
		.font(FontManager.getRunescapeSmallFont())
		.build();

	private final ThinProgressBar progressBar = new ThinProgressBar();

	public TreeTimerPanel(ForestryPluginConfig config, ItemManager itemManager, WorldHopService hopService, TreeTimer timer, Consumer<JComponent> onDeleteRequested)
	{
		this.config = config;
		this.timer = timer;

		progressBar.setValue(0);
		progressBar.setMaximumValue(timer.getTreeType()
			.getDespawnDurationMs());
		progressBar.setForeground(config.inProgressBorderColor());

		var icon = new LabelBuilder()
			.bounds(0, 0, Constants.ITEM_SPRITE_WIDTH, Constants.ITEM_SPRITE_HEIGHT)
			.icon(itemManager.getImage(timer.getTreeType()
				.getItemId()))
			.build();

		var treeTypeLabel = new LabelBuilder()
			.font(FontManager.getRunescapeSmallFont())
			.text(timer.getTreeType() + " Tree")
			.build();

		var deleteLabel = new LabelBuilder()
			.icon(Icons.TRASH)
			.onMouseEntered((e, c) -> c.setIcon(Icons.TRASH_HOVER))
			.onMouseExited((e, c) -> c.setIcon(Icons.TRASH))
			.onClick((e, c) -> onDeleteRequested.accept(this))
			.cursor(Cursor.HAND_CURSOR)
			.tooltipText("Delete timer")
			.build();

		var worldLabel = new LabelBuilder()
			.foreground(PluginScheme.HINT_COLOR)
			.font(FontManager.getRunescapeSmallFont())
			.text("World " + timer.getWorld())
			.tooltipText("Hop to world " + timer.getWorld())
			.cursor(Cursor.HAND_CURSOR)
			.onMouseEntered((e, c) -> c.setForeground(PluginScheme.HINT_HOVER_COLOR))
			.onMouseExited((e, c) -> c.setForeground(PluginScheme.HINT_COLOR))
			.onMousePressed(ClickFilter.DOUBLE_CLICK, (e, c) -> c.setForeground(PluginScheme.HINT_CLICK_COLOR))
			.onClick(ClickFilter.DOUBLE_CLICK, (e, c) -> hopService.hopToWorld(timer.getWorld()))
			.build();

		var infoPanel = new GridBagPanelBuilder()
			.constraints(GridBagConstraintsBuilder.verticalRelative(2))
			.add(new BorderPanelBuilder()
				.addWest(treeTypeLabel)
				.addEast(worldLabel)
				.build())
			.add(new BorderPanelBuilder()
				.addWest(estimateLabel)
				.addEast(deleteLabel)
				.build())
			.build();

		var mainPanel = new BorderPanelBuilder()
			.background(PluginScheme.PANEL_COLOR)
			.border(BorderBuilder.empty(PluginScheme.DEFAULT_PADDING))
			.addWest(icon)
			.addCenter(infoPanel)
			.build();

		BorderPanelBuilder.fromPanel(this)
			.addCenter(mainPanel)
			.addSouth(progressBar)
			.menuItem(new MenuItemBuilder()
				.text("Remove timer")
				.actionListener(e -> onDeleteRequested.accept(this))
				.build())
			.menuItem(new MenuItemBuilder()
				.text("Hop to world " + timer.getWorld())
				.actionListener(e -> hopService.hopToWorld(timer.getWorld()))
				.build())
			.build();

		update();
	}

	public void update()
	{
		var now = Instant.now()
			.toEpochMilli();
		var elapsed = now - timer.getStartTimeMs();
		var remaining = timer.getTreeType()
			.getDespawnDurationMs() - elapsed;

		if (remaining <= 0)
		{
			estimateLabel.setText("Ready to harvest");
			estimateLabel.setForeground(config.completedBorderColor());

			progressBar.setValue(timer.getTreeType()
				.getDespawnDurationMs());
			progressBar.setForeground(config.completedBorderColor());
		}
		else
		{
			var duration = Duration.of(remaining, ChronoUnit.MILLIS);
			estimateLabel.setText(String.format("Ready in %02d:%02d", duration.toMinutesPart(), duration.toSecondsPart()));
			estimateLabel.setForeground(PluginScheme.HINT_COLOR);

			progressBar.setValue((int) elapsed);
			progressBar.setForeground(config.inProgressBorderColor());
		}
	}
}

package xyz.oelderoth.runelite.forestry.ui;

import java.awt.Cursor;
import java.time.Instant;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.function.Function;
import javax.inject.Inject;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.tuple.Pair;
import xyz.oelderoth.runelite.forestry.service.ForceSpawnService;
import xyz.oelderoth.runelite.forestry.ForestryPlugin;
import xyz.oelderoth.runelite.forestry.ForestryPluginConfig;
import xyz.oelderoth.runelite.forestry.service.WorldHopService;
import xyz.oelderoth.runelite.forestry.domain.TreeTimer;
import xyz.oelderoth.runelite.forestry.ui.builders.border.BorderBuilder;
import xyz.oelderoth.runelite.forestry.ui.builders.component.ClickFilter;
import xyz.oelderoth.runelite.forestry.ui.builders.component.LabelBuilder;
import xyz.oelderoth.runelite.forestry.ui.builders.panel.BorderPanelBuilder;
import xyz.oelderoth.runelite.forestry.ui.builders.panel.GridBagConstraintsBuilder;
import xyz.oelderoth.runelite.forestry.ui.builders.panel.GridBagPanelBuilder;
import xyz.oelderoth.runelite.forestry.ui.icons.Icons;

public class ForestryPluginPanel extends PluginPanel
{
	private final ItemManager itemManager;
	private final ForestryPluginConfig config;
	private ForceSpawnService forceSpawnService;
	private final WorldHopService worldHopService;
	private final CurrentTreePanel currentTreePanel;

	@Getter
	private final NavigationButton navigationButton = NavigationButton.builder()
		.icon(ImageUtil.loadImageResource(ForestryPluginPanel.class, "/skill_icons_small/woodcutting.png"))
		.tooltip(ForestryPlugin.PLUGIN_NAME)
		.priority(5)
		.panel(this)
		.build();

	private final JLabel timerHint = new LabelBuilder()
		.border(new EmptyBorder(0, PluginScheme.DEFAULT_PADDING, 0,0))
		.font(FontManager.getRunescapeSmallFont())
		.foreground(PluginScheme.HINT_COLOR)
		.html(true)
		.text("Start chopping an eligible tree,<br />then hop worlds or logout to track it")
		.build();

	private final JPanel timerListPanel = new GridBagPanelBuilder()
		.build();

	private final JLabel currentTreeTitle = new LabelBuilder()
		.font(FontManager.getRunescapeSmallFont())
		.border(new EmptyBorder(1, 0, 2, 0))
		.text("Current Tree")
		.build();

	private final JLabel deleteAllTimersButton = new LabelBuilder()
		.icon(Icons.TRASH)
		.onMouseEntered((e, c) -> c.setIcon(Icons.TRASH_HOVER))
		.onMouseExited((e, c) -> c.setIcon(Icons.TRASH))
		.tooltipText("Delete All Timers")
		.cursor(Cursor.HAND_CURSOR)
		.onClick(ClickFilter.LEFT_CLICK, (e, c) -> {
			if (forceSpawnService.getTreeTimers().isEmpty()) return;

			int confirm = JOptionPane.showConfirmDialog(c,
				"Are you sure you want to clear all active timers?",
				"Warning", JOptionPane.OK_CANCEL_OPTION);

			if (confirm == 0)
				forceSpawnService.getTreeTimers().clear();
		})
		.build();

	private final Map<Pair<Integer, Integer>, TreeTimerPanel> timerPanelsByHash = new HashMap<>();


	@Inject
	public ForestryPluginPanel(
		ItemManager itemManager,
		ForestryPluginConfig config,
		WorldHopService worldHopService,
		ForceSpawnService forceSpawnService,
		CurrentTreePanel currentTreePanel)
	{
		this.itemManager = itemManager;
		this.currentTreePanel = currentTreePanel;
		this.forceSpawnService = forceSpawnService;
		this.worldHopService = worldHopService;
		this.config = config;

		var panelTitle = new LabelBuilder()
			.text(ForestryPlugin.PLUGIN_NAME)
			.border(new EmptyBorder(1, 0, PluginScheme.DEFAULT_PADDING, 0))
			.build();

		var timerTitle = new LabelBuilder()
			.font(FontManager.getRunescapeSmallFont())
			.border(new EmptyBorder(1, 0, 2, 0))
			.text("Tracked Trees")
			.build();

		var mainPanel = new GridBagPanelBuilder()
			.background(PluginScheme.BACKGROUND_COLOR)
			.constraints(GridBagConstraintsBuilder.verticalRelative())
			.add(currentTreeTitle)
			.add(currentTreePanel)
			.add(new BorderPanelBuilder()
				.background(PluginScheme.BACKGROUND_COLOR)
				.addWest(timerTitle)
				.addEast(deleteAllTimersButton)
				.build())
			.add(timerHint)
			.add(timerListPanel)
			.build();

		BorderPanelBuilder.fromPanel(this)
			.border(BorderBuilder.empty(PluginScheme.DEFAULT_PADDING))
			.background(PluginScheme.BACKGROUND_COLOR)
			.addNorth(panelTitle)
			.addCenter(mainPanel)
			.build();
	}

	public void update() {
		if (config.showCurrentTree()) {
			currentTreePanel.setVisible(true);
			currentTreeTitle.setVisible(true);
		} else {
			currentTreePanel.setVisible(false);
			currentTreeTitle.setVisible(false);
		}

		var isNoActiveTimers = forceSpawnService.getTreeTimers().isEmpty();

		deleteAllTimersButton.setVisible(!isNoActiveTimers);
		timerHint.setVisible(config.showTimerHint() || isNoActiveTimers);

		var unknownKeys = new HashSet<>(timerPanelsByHash.keySet());
		var panelOrderDirty = false;

		for (var timer : forceSpawnService.getTreeTimers()) {
			var key = Pair.of(timer.getTree().hashCode(), timer.getWorld());
			unknownKeys.remove(key);
			if (timerPanelsByHash.containsKey(key)) continue;

			var panel = new TreeTimerPanel(config, itemManager, worldHopService, timer, (owner) -> {
				if (forceSpawnService.getTreeTimers().isEmpty()) return;

				int confirm = JOptionPane.showConfirmDialog(owner,
					"Are you sure you want to delete this timer?",
					"Warning", JOptionPane.OK_CANCEL_OPTION);

				if (confirm == 0)
					forceSpawnService.getTreeTimers().remove(timer);
			});
			timerPanelsByHash.put(key, panel);

			panelOrderDirty = true;
		}

		for (var removedPanelHash : unknownKeys) {
			var panel = timerPanelsByHash.getOrDefault(removedPanelHash, null);
			if (panel == null) continue;

			timerPanelsByHash.remove(removedPanelHash);

			panelOrderDirty = true;
		}

		if (panelOrderDirty)
			rebuildSortedTimerList();

		timerPanelsByHash.values().forEach(TreeTimerPanel::update);
	}

	public void rebuildSortedTimerList() {
		Function<TreeTimer, Long> extractor;
		switch (config.sortOrder()) {
			case START_TIME:
				extractor = TreeTimer::getStartTimeMs;
				break;
			case REMAINING_TIME:
				var now = Instant.now().toEpochMilli();
				extractor = (it) -> it.getTreeType().getDespawnDurationMs() - (now - it.getStartTimeMs());
				break;
			case WORLD:
				extractor = (it) -> (long) it.getWorld();
				break;
			case TREE_TYPE:
				extractor = (it) -> (long) it.getTreeType().ordinal();
				break;
			default:
				return;
		}

		forceSpawnService.getTreeTimers()
			.sort(Comparator.comparing(extractor));

		timerListPanel.removeAll();

		for (var timer : forceSpawnService.getTreeTimers()) {
			var panel = timerPanelsByHash.get(Pair.of(timer.getTree().hashCode(), timer.getWorld()));
			if (panel != null)
				timerListPanel.add(panel, GridBagConstraintsBuilder.verticalRelative());
		}

		timerListPanel.revalidate();
		timerListPanel.repaint();
	}
}

package xyz.oelderoth.runelite.forestry.ui;

import java.awt.Color;
import net.runelite.client.ui.ColorScheme;

@SuppressWarnings("unused")
public class PluginScheme
{
	public static final Color TEXT_COLOR = Color.WHITE;
	public static final Color TEXT_HOVER_COLOR = TEXT_COLOR.darker();
	public static final Color HINT_COLOR = ColorScheme.LIGHT_GRAY_COLOR;
	public static final Color HINT_HOVER_COLOR = HINT_COLOR.darker();
	public static final Color HINT_CLICK_COLOR = HINT_HOVER_COLOR.darker();
	public static final Color BACKGROUND_COLOR = ColorScheme.DARK_GRAY_COLOR;
	public static final Color PANEL_COLOR = ColorScheme.DARKER_GRAY_COLOR;
	public static final Color SUCCESS_COLOR = ColorScheme.PROGRESS_COMPLETE_COLOR;
	public static final Color INCOMPLETE_COLOR = ColorScheme.PROGRESS_INPROGRESS_COLOR;
	public static final int DEFAULT_PADDING = 8;
	public static final int SMALL_PADDING = DEFAULT_PADDING / 2;
}

package xyz.oelderoth.runelite.forestry.ui.icons;

import javax.swing.ImageIcon;
import net.runelite.client.util.ImageUtil;

public class Icons
{
	public static ImageIcon TRASH;
	public static ImageIcon TRASH_HOVER;

	static {
		var trash = ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "trash.png"), -100);
		TRASH = new ImageIcon(trash);
		TRASH_HOVER = new ImageIcon(ImageUtil.alphaOffset(trash, -100));
	}
}

package xyz.oelderoth.runelite.forestry.ui;

import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import xyz.oelderoth.runelite.forestry.service.ForceSpawnService;
import xyz.oelderoth.runelite.forestry.ForestryPluginConfig;
import xyz.oelderoth.runelite.forestry.service.WoodcuttingService;
import xyz.oelderoth.runelite.forestry.ui.builders.border.BorderBuilder;
import xyz.oelderoth.runelite.forestry.ui.builders.component.LabelBuilder;
import xyz.oelderoth.runelite.forestry.ui.builders.panel.BorderPanelBuilder;
import xyz.oelderoth.runelite.forestry.ui.builders.panel.GridBagConstraintsBuilder;
import xyz.oelderoth.runelite.forestry.ui.builders.panel.GridBagPanelBuilder;

@Singleton
public class CurrentTreePanel extends JPanel
{
	private final Client client;
	private final ItemManager itemManager;
	private final ForestryPluginConfig config;
	private final ForceSpawnService forceSpawnService;
	private final WoodcuttingService woodcuttingService;

	private final JLabel titleLabel = new LabelBuilder()
		.font(FontManager.getRunescapeSmallFont())
		.text("<PLACEHOLDER>")
		.build();

	private final JLabel hintLabel = new LabelBuilder()
		.foreground(PluginScheme.HINT_COLOR)
		.font(FontManager.getRunescapeSmallFont())
		.build();

	private final JLabel worldLabel = new LabelBuilder()
		.foreground(PluginScheme.HINT_COLOR)
		.font(FontManager.getRunescapeSmallFont())
		.build();

	private final JLabel icon = new LabelBuilder()
		.text("\u00a0")
		.bounds(0, 0, Constants.ITEM_SPRITE_WIDTH, Constants.ITEM_SPRITE_HEIGHT)
		.preferredSize(Constants.ITEM_SPRITE_WIDTH, Constants.ITEM_SPRITE_HEIGHT)
		.build();

	private int previousWorld = 0;

	@Inject
	public CurrentTreePanel(
		Client client,
		ItemManager itemManager,
		ForestryPluginConfig config,
		ForceSpawnService forceSpawnService,
		WoodcuttingService woodcuttingService)
	{
		this.client = client;
		this.itemManager = itemManager;
		this.config = config;
		this.forceSpawnService = forceSpawnService;
		this.woodcuttingService = woodcuttingService;

		var infoPanel = new GridBagPanelBuilder()
			.constraints(GridBagConstraintsBuilder.verticalRelative(2))
			.add(new BorderPanelBuilder()
				.addWest(titleLabel)
				.addEast(worldLabel)
				.build())
			.add(hintLabel)
			.build();

		BorderPanelBuilder.fromPanel(this)
			.background(PluginScheme.PANEL_COLOR)
			.border(BorderBuilder.empty(PluginScheme.DEFAULT_PADDING))
			.addWest(icon)
			.addCenter(infoPanel)
			.build();

		update();

		woodcuttingService.registerStateListener(s -> update());
	}

	public void update()
	{
		switch (client.getGameState())
		{
			case LOGGED_IN:
			case LOADING:
				var currentWorld = client.getWorld();
				if (previousWorld != currentWorld) {
					worldLabel.setText("World " + currentWorld);
					previousWorld = currentWorld;
				}
				break;
			case HOPPING:
				worldLabel.setText("Hopping...");
				break;
			default:
				worldLabel.setText("");
				break;
		}

		var wcStatus = woodcuttingService.getWoodcuttingState();

		if (wcStatus != null)
		{
			itemManager.getImage(wcStatus.getTreeType()
					.getItemId())
				.addTo(icon);
			titleLabel.setText(wcStatus.getTreeType() + " Tree");

			var existingTimerOpt = forceSpawnService.getTreeTimers()
				.stream()
				.filter(it -> it.getTree().matches(wcStatus.getGameObject()) && it.getWorld() == client.getWorld())
				.findAny();
			if (existingTimerOpt.isEmpty())
			{
				if (wcStatus.isForestryEligible()) {
					var ticks = client.getTickCount() - wcStatus.getStartTick();
					var remaining = ForceSpawnService.MIN_TICK_COUNT - ticks;

					if (remaining > 0)
					{
						hintLabel.setText("Cut for " + remaining + " ticks before hopping");
						hintLabel.setForeground(PluginScheme.HINT_COLOR);
					}
					else
					{
						hintLabel.setText("Hop worlds to start tracking");
						hintLabel.setForeground(config.inProgressBorderColor());
					}
				} else {
					hintLabel.setText("Not eligible for forestry events");
					hintLabel.setForeground(PluginScheme.HINT_COLOR);
				}
			}
			else
			{
				var timer = existingTimerOpt.get();
				var elapsed = Instant.now()
					.toEpochMilli() - timer.getStartTimeMs();
				var remaining = timer.getTreeType()
					.getDespawnDurationMs() - elapsed;
				if (remaining > 0)
				{
					var duration = Duration.of(remaining, ChronoUnit.MILLIS);
					hintLabel.setText(String.format("Ready to harvest in %02d:%02d", duration.toMinutesPart(), duration.toSecondsPart()));
					hintLabel.setForeground(config.inProgressBorderColor());
				}
				else
				{
					hintLabel.setText("Ready to harvest");
					hintLabel.setForeground(config.completedBorderColor());
				}
			}
		}
		else
		{
			titleLabel.setText("Not Woodcutting");
			hintLabel.setText("Start cutting an eligible tree");
			hintLabel.setForeground(PluginScheme.HINT_COLOR);
			icon.setIcon(null);
		}
	}
}

package xyz.oelderoth.runelite.forestry.ui.builders.component;

import com.google.common.collect.Lists;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Rectangle;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.function.BiConsumer;
import javax.swing.JComponent;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import org.intellij.lang.annotations.MagicConstant;

@SuppressWarnings({"unused", "unchecked", "UnusedReturnValue"})
public abstract class AbstractComponentBuilder<T extends JComponent, B extends AbstractComponentBuilder<T, ?>>
{
	private Border border;
	private Color background;
	private Cursor cursor;
	private Color foreground;
	private Font font;
	private Boolean visible;
	private Rectangle bounds;
	private Dimension preferredSize;
	private String tooltipText;
	private JPopupMenu popupMenu;
	private final List<BiConsumer<MouseEvent, T>> onMouseEntered = new ArrayList<>();
	private final List<BiConsumer<MouseEvent, T>> onMouseExited = new ArrayList<>();
	private final HashMap<ClickFilter, List<BiConsumer<MouseEvent, T>>> onClick = new HashMap<>();
	private final HashMap<ClickFilter, List<BiConsumer<MouseEvent, T>>> onMousePressed = new HashMap<>();
	private final HashMap<ClickFilter, List<BiConsumer<MouseEvent, T>>> onMouseReleased = new HashMap<>();

	public B border(Border border)
	{
		this.border = border;
		return (B) this;
	}

	public B bounds(Rectangle bounds)
	{
		this.bounds = bounds;
		return (B) this;
	}

	public B bounds(int x, int y, int w, int h)
	{
		this.bounds = new Rectangle(x, y, w, h);
		return (B) this;
	}

	public B background(Color background)
	{
		this.background = background;
		return (B) this;
	}

	public B cursor(Cursor cursor)
	{
		this.cursor = cursor;
		return (B) this;
	}

	public B cursor(@MagicConstant(valuesFromClass = Cursor.class) int cursor)
	{
		this.cursor = Cursor.getPredefinedCursor(cursor);
		return (B) this;
	}

	public B foreground(Color color)
	{
		this.foreground = color;
		return (B) this;
	}

	public B font(Font font)
	{
		this.font = font;
		return (B) this;
	}

	public B preferredSize(Dimension size) {
		preferredSize = size;
		return (B) this;
	}

	public B preferredSize(int w, int h) {
		return preferredSize(new Dimension(w, h));
	}

	public B popupMenu(JPopupMenu popupMenu) {
		this.popupMenu = popupMenu;
		return (B) this;
	}

	public B menuItem(JMenuItem menuItem) {
		if (this.popupMenu == null) popupMenu = new JPopupMenu();
		popupMenu.add(menuItem);
			return (B) this;
	}

	public B onMouseEntered(BiConsumer<MouseEvent, T> handler) {
		this.onMouseEntered.add(handler);
		return (B) this;
	}

	public B onMouseExited(BiConsumer<MouseEvent, T> handler) {
		this.onMouseExited.add(handler);
		return (B) this;
	}

	public B onClick(BiConsumer<MouseEvent, T> handler) {
		if (this.onClick.containsKey(null))
			this.onClick.get(null).add(handler);
		else
			this.onClick.put(null, Lists.newArrayList(handler));
		return (B) this;
	}

	public B onClick(ClickFilter filter, BiConsumer<MouseEvent, T> handler) {
		if (this.onClick.containsKey(filter)) {
			this.onClick.get(filter).add(handler);
		} else {
			this.onClick.put(filter, Lists.newArrayList(handler));
		}
		return (B) this;
	}

	public B onMousePressed(BiConsumer<MouseEvent, T> handler) {
		if (this.onMousePressed.containsKey(null))
			this.onMousePressed.get(null).add(handler);
		else
			this.onMousePressed.put(null, Lists.newArrayList(handler));
		return (B) this;
	}

	public B onMousePressed(ClickFilter filter, BiConsumer<MouseEvent, T> handler) {
		if (this.onMousePressed.containsKey(filter)) {
			this.onMousePressed.get(filter).add(handler);
		} else {
			this.onMousePressed.put(filter, Lists.newArrayList(handler));
		}
		return (B) this;
	}

	public B onMouseReleased(BiConsumer<MouseEvent, T> handler) {
		if (this.onMouseReleased.containsKey(null))
			this.onMouseReleased.get(null).add(handler);
		else
			this.onMouseReleased.put(null, Lists.newArrayList(handler));
		return (B) this;
	}

	public B onMouseReleased(ClickFilter filter, BiConsumer<MouseEvent, T> handler) {
		if (this.onMouseReleased.containsKey(filter)) {
			this.onMouseReleased.get(filter).add(handler);
		} else {
			this.onMouseReleased.put(filter, Lists.newArrayList(handler));
		}
		return (B) this;
	}

	public B tooltipText(String tooltipText) {
		this.tooltipText = tooltipText;
		return (B) this;
	}

	public B visible(boolean visible)
	{
		this.visible = visible;
		return (B) this;
	}

	private boolean hasAnyClickHandlers() {
		return !(onMouseEntered.isEmpty() && onMouseExited.isEmpty() && onClick.isEmpty());
	}

	private void invokeMouseHandlers(MouseEvent e, T component, HashMap<ClickFilter, List<BiConsumer<MouseEvent, T>>> handlers) {
		if (SwingUtilities.isLeftMouseButton(e)) {
			if (e.getClickCount() == 2) {
				handlers.getOrDefault(ClickFilter.DOUBLE_CLICK, Collections.emptyList())
					.forEach(it -> it.accept(e, component));
			} else {
				handlers.getOrDefault(ClickFilter.LEFT_CLICK, Collections.emptyList())
					.forEach(it -> it.accept(e, component));
			}
		}
		if (SwingUtilities.isRightMouseButton(e)) {
			handlers.getOrDefault(ClickFilter.RIGHT_CLICK, Collections.emptyList())
				.forEach(it -> it.accept(e, component));
		}
		if (SwingUtilities.isMiddleMouseButton(e)) {
			handlers.getOrDefault(ClickFilter.MIDDLE_CLICK, Collections.emptyList())
				.forEach(it -> it.accept(e, component));
		}

		handlers.getOrDefault(null, Collections.emptyList())
			.forEach(it -> it.accept(e, component));
	}

	private MouseListener buildMouseListener(T component) {
		return new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				invokeMouseHandlers(e, component, onMousePressed);
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				invokeMouseHandlers(e, component, onMouseReleased);
			}

			@Override
			public void mouseClicked(MouseEvent e)
			{
				invokeMouseHandlers(e, component, onClick);
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				onMouseEntered.forEach(it -> it.accept(e, component));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				onMouseExited.forEach(it -> it.accept(e, component));
			}
		};
	}

	public T apply(T component)
	{
		if (border != null)
			component.setBorder(border);
		if (background != null)
			component.setBackground(background);
		if (foreground != null)
			component.setForeground(foreground);
		if (font != null)
			component.setFont(font);
		if (visible != null)
			component.setVisible(visible);
		if (tooltipText != null)
			component.setToolTipText(tooltipText);
		if (preferredSize != null)
			component.setPreferredSize(preferredSize);
		if (cursor != null)
			component.setCursor(cursor);
		if (popupMenu != null)
			component.setComponentPopupMenu(popupMenu);
		if (hasAnyClickHandlers()) {
			component.addMouseListener(buildMouseListener(component));
		}

		return component;
	}

	public abstract T build();
}

package xyz.oelderoth.runelite.forestry.ui.builders.component;

public enum ClickFilter {
	LEFT_CLICK,
	RIGHT_CLICK,
	MIDDLE_CLICK,
	DOUBLE_CLICK
}

package xyz.oelderoth.runelite.forestry.ui.builders.component;

import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.Icon;
import javax.swing.JMenuItem;
import lombok.AccessLevel;
import lombok.Setter;
import lombok.experimental.Accessors;

@Setter
@Accessors(fluent = true, chain = true)
public class MenuItemBuilder extends AbstractComponentBuilder<JMenuItem, MenuItemBuilder>
{
	private String text;
	private Icon icon;
	@Setter(AccessLevel.NONE)
	private List<ActionListener> actionListeners = new ArrayList<>();

	public MenuItemBuilder actionListener(ActionListener listener)
	{
		actionListeners.add(listener);
		return this;
	}

	@Override
	public JMenuItem build()
	{
		var item = new JMenuItem();
		apply(item);
		if (text != null) item.setText(text);
		if (icon != null) item.setIcon(icon);
		if (actionListeners != null) actionListeners.forEach(item::addActionListener);
		return item;
	}
}

package xyz.oelderoth.runelite.forestry.ui.builders.component;

import java.awt.image.BufferedImage;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import lombok.AccessLevel;
import lombok.Setter;
import lombok.experimental.Accessors;
import net.runelite.client.util.AsyncBufferedImage;
import xyz.oelderoth.runelite.forestry.ui.PluginScheme;

@Setter
@Accessors(fluent = true, chain = true)
@SuppressWarnings("unused")
public class LabelBuilder extends AbstractComponentBuilder<JLabel, LabelBuilder>
{
	@Setter(AccessLevel.NONE)
	private JLabel label;

	private String text;
	private boolean html = false;
	private Icon icon;

	public LabelBuilder() {
		label = new JLabel();
		this.foreground(PluginScheme.TEXT_COLOR);
	}

	public LabelBuilder icon(Icon icon) {
		this.icon = icon;
		return this;
	}

	public LabelBuilder icon(BufferedImage image) {
		icon = new ImageIcon(image);
		return this;
	}

	public LabelBuilder icon(AsyncBufferedImage image) {
		image.addTo(label);
		icon = label.getIcon();
		return this;
	}

	public JLabel build() {
		apply(label);
		if (text != null) label.setText(html ? "<html>" + text + "</html>" : text);
		if (icon != null) label.setIcon(icon);
		return label;
	}
}

package xyz.oelderoth.runelite.forestry.ui.builders.component;

import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;

@SuppressWarnings("unused")
public class PopupMenuBuilder extends AbstractComponentBuilder<JPopupMenu, PopupMenuBuilder>
{
	private final JPopupMenu menu;

	public PopupMenuBuilder()
	{
		menu = new JPopupMenu();
	}

	public PopupMenuBuilder menuItem(JMenuItem item) {
		menu.add(item);
		return this;
	}

	@Override
	public JPopupMenu build()
	{
		apply(menu);
		return menu;
	}
}

package xyz.oelderoth.runelite.forestry.ui.builders.border;

import javax.swing.BorderFactory;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import xyz.oelderoth.runelite.forestry.ui.PluginScheme;

@SuppressWarnings("unused")
public class BorderBuilder
{
	public static Border empty() {
		 return empty(0);
	}

	public static Border empty(int amount)
	{
		return empty(amount, amount);
	}

	public static Border empty(int vAmount, int hAmount)
	{
		return new EmptyBorder(vAmount, hAmount, vAmount, hAmount);
	}

	public static Border separated()
	{
		return separated(0, 0);
	}

	public static Border separated(int amount)
	{
		return separated(amount, amount);
	}

	public static Border separated(int vAmount, int hAmount)
	{
		return new CompoundBorder(BorderFactory.createMatteBorder(1, 0, 0, 0, PluginScheme.BACKGROUND_COLOR), empty(vAmount, hAmount));
	}
}

package xyz.oelderoth.runelite.forestry.ui.builders.panel;

import java.awt.FlowLayout;
import java.awt.LayoutManager;
import javax.swing.JComponent;
import javax.swing.JPanel;
import lombok.AccessLevel;
import lombok.Setter;
import lombok.experimental.Accessors;
import xyz.oelderoth.runelite.forestry.ui.PluginScheme;
import xyz.oelderoth.runelite.forestry.ui.builders.component.AbstractComponentBuilder;

@Setter
@Accessors(fluent = true, chain = true)
@SuppressWarnings("unused")
public class LayoutPanelBuilder<T extends LayoutManager> extends AbstractComponentBuilder<JPanel, LayoutPanelBuilder<T>>
{
	@Setter(AccessLevel.NONE)
	private JPanel panel;
	private T layout;

	public static <T extends LayoutManager> LayoutPanelBuilder<T> fromPanel(JPanel panel)
	{
		return new LayoutPanelBuilder<>(panel);
	}

	protected LayoutPanelBuilder(JPanel panel)
	{
		this.panel = panel;
	}

	public LayoutPanelBuilder()
	{
		this(new JPanel(new FlowLayout()));
		background(PluginScheme.PANEL_COLOR);
	}


	public LayoutPanelBuilder<T> add(JComponent component) {
		panel.add(component);
		return this;
	}

	public JPanel build()
	{
		if (layout != null) panel.setLayout(layout);
		apply(panel);
		return panel;
	}
}

package xyz.oelderoth.runelite.forestry.ui.builders.panel;

import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import javax.swing.JComponent;
import javax.swing.JPanel;
import lombok.AccessLevel;
import lombok.Setter;
import lombok.experimental.Accessors;
import xyz.oelderoth.runelite.forestry.ui.PluginScheme;
import xyz.oelderoth.runelite.forestry.ui.builders.component.AbstractComponentBuilder;

@Setter
@Accessors(fluent = true, chain = true)
public class GridBagPanelBuilder extends AbstractComponentBuilder<JPanel, GridBagPanelBuilder>
{
	@Setter(AccessLevel.NONE)
	private JPanel panel;
	private GridBagConstraints constraints = new GridBagConstraints();

	public static GridBagPanelBuilder fromPanel(JPanel panel) {
		if (!(panel.getLayout() instanceof GridBagLayout))
			if (panel.getComponents().length > 0)
				throw new IllegalArgumentException("Panel must have a GridBagLayout or zero components");
			else
				panel.setLayout(new GridBagLayout());

		return new GridBagPanelBuilder(panel);
	}

	protected GridBagPanelBuilder(JPanel panel)
	{
		this.panel = panel;
	}

	public GridBagPanelBuilder()
	{
		this(new JPanel(new GridBagLayout()));
		background(PluginScheme.PANEL_COLOR);
	}

	public GridBagPanelBuilder add(JComponent component) {
		panel.add(component, constraints);
		return this;
	}

	public JPanel build()
	{
		apply(panel);
		return panel;
	}
}

package xyz.oelderoth.runelite.forestry.ui.builders.panel;

import java.awt.GridBagConstraints;
import java.awt.Insets;
import lombok.Setter;
import lombok.experimental.Accessors;
import xyz.oelderoth.runelite.forestry.ui.PluginScheme;

@Setter
@Accessors(fluent = true, chain = true)
public class GridBagConstraintsBuilder
{
	private int anchor = GridBagConstraints.CENTER;
	private int gridwidth = 1;
	private int gridheight = 1;
	private int gridx = GridBagConstraints.RELATIVE;
	private int gridy = GridBagConstraints.RELATIVE;
	private double weightx = 0;
	private double weighty = 0;
	private int fill = GridBagConstraints.NONE;
	private int ipadx = 0;
	private int ipady = 0;
	private Insets insets = new Insets(0, 0, 0, 0);

	public GridBagConstraints build()
	{
		return new GridBagConstraints(gridx, gridy, gridwidth, gridheight, weightx, weighty, anchor, fill, insets, ipadx, ipady);
	}

	public static GridBagConstraints verticalRelative() {
		return verticalRelative(PluginScheme.SMALL_PADDING);
	}

	public static GridBagConstraints verticalRelative(int vPadding) {
		return new GridBagConstraintsBuilder()
			.weightx(1.0)
			.fill(GridBagConstraints.HORIZONTAL)
			.gridx(0)
			.gridy(GridBagConstraints.RELATIVE)
			.insets(new Insets(vPadding, 0, vPadding, 0))
			.build();
	}

}

package xyz.oelderoth.runelite.forestry.ui.builders.panel;

import java.awt.FlowLayout;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import lombok.Setter;
import lombok.experimental.Accessors;
import org.intellij.lang.annotations.MagicConstant;
import xyz.oelderoth.runelite.forestry.ui.PluginScheme;

@Setter
@Accessors(fluent = true, chain = true)
public class FlowLayoutBuilder
{
	private int align;
	private int hgap;
	private int vgap;

	public FlowLayoutBuilder align(@MagicConstant(intValues = {FlowLayout.LEFT, FlowLayout.CENTER, FlowLayout.RIGHT, FlowLayout.LEADING, FlowLayout.TRAILING}) int align)
	{
		this.align = align;
		return this;
	}

	@SuppressWarnings("MagicConstant")
	public FlowLayout build()
	{
		return new FlowLayout(align, hgap, vgap);
	}
}

package xyz.oelderoth.runelite.forestry.ui.builders.panel;

import lombok.AccessLevel;
import lombok.Setter;
import lombok.experimental.Accessors;
import net.runelite.client.ui.components.PluginErrorPanel;

@Setter
@Accessors(fluent = true, chain = true)
public class ErrorPanelBuilder extends BorderPanelBuilder
{
	@Setter(AccessLevel.NONE)
	private PluginErrorPanel panel;
	private String title;
	private String description;

	protected ErrorPanelBuilder(PluginErrorPanel panel) {
		super(panel);
		this.panel = panel;
	}

	public ErrorPanelBuilder() {
		this(new PluginErrorPanel());
	}

	@Override
	public PluginErrorPanel build() {
		super.build();
		if (title != null || description != null) {
			panel.setContent(title, description);
		}
		return panel;
	}
}

package xyz.oelderoth.runelite.forestry.ui.builders.panel;

import java.awt.BorderLayout;
import javax.swing.JComponent;
import javax.swing.JPanel;
import lombok.AccessLevel;
import lombok.Setter;
import lombok.experimental.Accessors;
import xyz.oelderoth.runelite.forestry.ui.PluginScheme;
import xyz.oelderoth.runelite.forestry.ui.builders.component.AbstractComponentBuilder;

@Setter
@Accessors(fluent = true, chain = true)
@SuppressWarnings("unused")
public class BorderPanelBuilder extends AbstractComponentBuilder<JPanel, BorderPanelBuilder>
{
	@Setter(AccessLevel.NONE)
	private JPanel panel;

	public static BorderPanelBuilder fromPanel(JPanel panel) {
		if (!(panel.getLayout() instanceof BorderLayout))
			if (panel.getComponents().length > 0)
				throw new IllegalArgumentException("Panel must have a BorderLayout or zero components");
			else
				panel.setLayout(new BorderLayout());

		return new BorderPanelBuilder(panel);
	}

	protected BorderPanelBuilder(JPanel panel)
	{
		this.panel = panel;
	}

	public BorderPanelBuilder()
	{
		this(new JPanel(new BorderLayout()));
		background(PluginScheme.PANEL_COLOR);
	}

	public BorderPanelBuilder addNorth(JComponent component) {
		panel.add(component, BorderLayout.NORTH);
		return this;
	}

	public BorderPanelBuilder addSouth(JComponent component) {
		panel.add(component, BorderLayout.SOUTH);
		return this;
	}

	public BorderPanelBuilder addEast(JComponent component) {
		panel.add(component, BorderLayout.EAST);
		return this;
	}

	public BorderPanelBuilder addWest(JComponent component) {
		panel.add(component, BorderLayout.WEST);
		return this;
	}

	public BorderPanelBuilder addCenter(JComponent component) {
		panel.add(component, BorderLayout.CENTER);
		return this;
	}

	public JPanel build()
	{
		apply(panel);
		return panel;
	}
}

package xyz.oelderoth.runelite.forestry;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;
import net.runelite.client.ui.ColorScheme;

@ConfigGroup(ForestryPluginConfig.CONFIG_GROUP)
public interface ForestryPluginConfig extends Config
{
	String CONFIG_GROUP = "forestry_force_spawn";

	enum SORT_TYPE {
		START_TIME,
		REMAINING_TIME,
		WORLD,
		TREE_TYPE
	}

	@ConfigSection(
		name = "In-progress render style",
		description = "The render style for trees with an in-progress timer.",
		position = 10
	)
	String inProgressSection = "inprogress";

	@ConfigSection(
		name = "Completed render style",
		description = "The render style for trees with a completed timer.",
		position = 20
	)
	String completedSection = "completed";

	@ConfigSection(
		name = "Tree types",
		description = "The types of trees that the plugin should track.",
		position = 30
	)
	String treesSection = "trees";

	@ConfigItem(
		keyName = "showCurrentTree",
		name = "Show current tree information",
		description = "Show how long is left on the tree you're woodcutting before you can hop or harvest.",
		position = 0
	)
	default boolean showCurrentTree()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showTimerHint",
		name = "Always show instructions",
		description = "<html>Show instructions about how to start a timer, even if there are active timers.<br />Instructions will always be shown when there are no active timers.</html>",
		position = 1
	)
	default boolean showTimerHint()
	{
		return true;
	}

	@ConfigItem(
		keyName = "removeTimersAfter",
		name = "Remove timers after",
		description = "<html>How long after completion should a timer be removed, even if the tree hasn't been harvested.<br />Set to 0 to never remove timers.</html>",
		position = 2
	)
	@Units(Units.MINUTES)
	default int removeTimersAfter()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "sortOrder",
		name = "Sort timers by",
		description = "How the side panel should sort active timers",
		position = 3
	)
	default SORT_TYPE sortOrder()
	{
		return SORT_TYPE.START_TIME;
	}


	@ConfigItem(
		keyName = "outlineInProgress",
		name = "Highlight outline",
		description = "Highlight the outline around trees that have an in-progress timer.",
		position = 10,
		section = inProgressSection
	)
	default boolean drawOutlineInProgressTree()
	{
		return true;
	}

	@ConfigItem(
		keyName = "hullInProgress",
		name = "Highlight hull",
		description = "Highlight the hull for trees that have an in-progress timer.",
		position = 11,
		section = inProgressSection
	)
	default boolean drawHullInProgressTree()
	{
		return false;
	}

	@ConfigItem(
		keyName = "clickboxInProgress",
		name = "Highlight clickbox",
		description = "Highlight the clickbox for trees that have an in-progress timer.",
		position = 12,
		section = inProgressSection
	)
	default boolean drawClickboxInProgressTree()
	{
		return false;
	}

	@ConfigItem(
		keyName = "tileInProgress",
		name = "Highlight tile",
		description = "Highlight the tile for trees that have an in-progress timer.",
		position = 13,
		section = inProgressSection
	)
	default boolean drawTileInProgressTree()
	{
		return false;
	}

	@Alpha
	@ConfigItem(
		keyName = "inProgressColor",
		name = "Border color",
		description = "Color of the border for trees with an in-progress timer.",
		position = 14,
		section = inProgressSection
	)
	default Color inProgressBorderColor()
	{
		return ColorScheme.PROGRESS_INPROGRESS_COLOR;
	}

	@Alpha
	@ConfigItem(
		keyName = "inProgressFill",
		name = "Fill color",
		description = "Color of the fill for trees with an in-progress timer.",
		position = 15,
		section = inProgressSection
	)
	Color inProgressFillColor();

	@ConfigItem(
		keyName = "inProgressWidth",
		name = "Border width",
		description = "Width of the border for trees with an in-progress timer.",
		position = 16,
		section = inProgressSection
	)
	default int inProgressWidth()
	{
		return 2;
	}

	@ConfigItem(
		keyName = "inProgressFeather",
		name = "Outline feather",
		description = "Specify between 0-4 how much of the model outline should be faded for trees with an in-progress timer.",
		position = 17,
		section = inProgressSection
	)
	@Range(
		max = 4
	)
	default int inProgressFeather()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "outlineComplete",
		name = "Highlight completed trees",
		description = "Highlight the outline around trees that have a completed timer.",
		position = 20,
		section = completedSection
	)
	default boolean drawOutlineCompleteTree()
	{
		return true;
	}


	@ConfigItem(
		keyName = "hullComplete",
		name = "Highlight hull",
		description = "Highlight the hull for trees that have a completed timer..",
		position = 21,
		section = completedSection
	)
	default boolean drawHullCompleteTree()
	{
		return false;
	}

	@ConfigItem(
		keyName = "clickboxComplete",
		name = "Highlight clickbox",
		description = "Highlight the clickbox for trees that have a completed timer.",
		position = 22,
		section = completedSection
	)
	default boolean drawClickboxCompleteTree()
	{
		return false;
	}

	@ConfigItem(
		keyName = "tileComplete",
		name = "Highlight tile",
		description = "Highlight the tile for trees that have a completed timer.",
		position = 23,
		section = completedSection
	)
	default boolean drawTileCompleteTree()
	{
		return false;
	}

	@Alpha
	@ConfigItem(
		keyName = "completedColor",
		name = "Border color",
		description = "Color of the highlight for trees with a completed timer.",
		position = 24,
		section = completedSection
	)
	default Color completedBorderColor()
	{
		return ColorScheme.PROGRESS_COMPLETE_COLOR;
	}

	@Alpha
	@ConfigItem(
		keyName = "completedFill",
		name = "Fill color",
		description = "Color of the highlight for trees with a completed timer.",
		position = 25,
		section = completedSection
	)
	Color completedFillColor();

	@ConfigItem(
		keyName = "completedWidth",
		name = "Border width",
		description = "Width of the border for trees with a completed timer",
		position = 26,
		section = completedSection
	)
	default int completedWidth()
	{
		return 2;
	}

	@ConfigItem(
		keyName = "completedFeather",
		name = "Outline feather",
		description = "Specify between 0-4 how much of the model outline should be faded for trees with a completed timer",
		position = 27,
		section = completedSection
	)
	@Range(
		max = 4
	)
	default int completedFeather()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "trackOakTree",
		name = "Oak tree",
		description = "Track whether the plugin tracks oak trees.",
		position = 30,
		section = treesSection
	)
	default boolean trackOakTree()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackWillowTree",
		name = "Willow tree",
		description = "Track whether the plugin tracks willow trees.",
		position = 31,
		section = treesSection
	)
	default boolean trackWillowTree()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackTeakTree",
		name = "Teak tree",
		description = "Track whether the plugin tracks teak trees.",
		position = 32,
		section = treesSection
	)
	default boolean trackTeakTree()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackMapleTree",
		name = "Maple tree",
		description = "Track whether the plugin tracks maple trees.",
		position = 33,
		section = treesSection
	)
	default boolean trackMapleTree()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackMahoganyTree",
		name = "Mahogany tree",
		description = "Track whether the plugin tracks mahogany trees.",
		position = 34,
		section = treesSection
	)
	default boolean trackMahoganyTree()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackArcticPineTree",
		name = "Arctic pine tree",
		description = "Track whether the plugin tracks arctic pines trees.",
		position = 35,
		section = treesSection
	)
	default boolean trackArcticPineTree()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackYewTree",
		name = "Yew tree",
		description = "Track whether the plugin tracks yew trees.",
		position = 36,
		section = treesSection
	)
	default boolean trackYewTree()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackMagicTree",
		name = "Magic tree",
		description = "Track whether the plugin tracks magic trees.",
		position = 37,
		section = treesSection
	)
	default boolean trackMagicTree()
	{
		return true;
	}

}

package xyz.oelderoth.runelite.forestry.service;

import com.google.common.collect.Sets;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.AnimationID;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.ScriptID;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;
import net.runelite.api.coords.Angle;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import xyz.oelderoth.runelite.forestry.domain.TreeCutDownListener;
import xyz.oelderoth.runelite.forestry.domain.ObjectPosition;
import xyz.oelderoth.runelite.forestry.domain.TreeType;
import xyz.oelderoth.runelite.forestry.domain.WoodcuttingState;
import xyz.oelderoth.runelite.forestry.domain.WoodcuttingStateListener;

@Slf4j
@SuppressWarnings("UnusedReturnValue")
@Singleton
public class WoodcuttingService
{
	private static final Set<Integer> WOODCUTTING_ANIMATION_IDS = Sets.newHashSet(AnimationID.WOODCUTTING_BRONZE, AnimationID.WOODCUTTING_IRON, AnimationID.WOODCUTTING_STEEL, AnimationID.WOODCUTTING_BLACK, AnimationID.WOODCUTTING_MITHRIL, AnimationID.WOODCUTTING_ADAMANT, AnimationID.WOODCUTTING_RUNE, AnimationID.WOODCUTTING_GILDED, AnimationID.WOODCUTTING_DRAGON, AnimationID.WOODCUTTING_DRAGON_OR, AnimationID.WOODCUTTING_INFERNAL, AnimationID.WOODCUTTING_3A_AXE, AnimationID.WOODCUTTING_CRYSTAL, AnimationID.WOODCUTTING_TRAILBLAZER, AnimationID.WOODCUTTING_2H_BRONZE, AnimationID.WOODCUTTING_2H_IRON, AnimationID.WOODCUTTING_2H_STEEL, AnimationID.WOODCUTTING_2H_BLACK, AnimationID.WOODCUTTING_2H_MITHRIL, AnimationID.WOODCUTTING_2H_ADAMANT, AnimationID.WOODCUTTING_2H_RUNE, AnimationID.WOODCUTTING_2H_DRAGON, AnimationID.WOODCUTTING_2H_CRYSTAL, AnimationID.WOODCUTTING_2H_CRYSTAL_INACTIVE, AnimationID.WOODCUTTING_2H_3A);
	private static final int TREE_DESPAWNED_LOC_TYPE = 2;

	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Getter
	@Nullable
	private WoodcuttingState woodcuttingState = null;

	private final List<WoodcuttingStateListener> stateChangeListeners = new ArrayList<>();
	private final List<TreeCutDownListener> treeCutDownListeners = new ArrayList<>();
	private final HashMap<Integer, GameObject> objectCache = new HashMap<>();

	public void enable()
	{
		eventBus.register(this);
	}

	public void disable()
	{
		eventBus.unregister(this);
	}

	public void registerStateListener(WoodcuttingStateListener handler)
	{
		stateChangeListeners.add(handler);
	}

	public void unregisterStateListener(WoodcuttingStateListener handler)
	{
		stateChangeListeners.remove(handler);
	}

	public void registerTreeCutDownListener(TreeCutDownListener handler)
	{
		treeCutDownListeners.add(handler);
	}

	public void unregisterTreeCutDownListener(TreeCutDownListener handler)
	{
		treeCutDownListeners.remove(handler);
	}

	public Optional<GameObject> getTreeObject(ObjectPosition tree) {
		var hash = tree.hashCode();
		if (objectCache.containsKey(hash)) return Optional.of(objectCache.get(hash));

		var objOpt = getTreeFromWorldPoint(tree.getPoint());
		objOpt.ifPresent(obj -> objectCache.put(hash, obj));
		return objOpt;
	}

	@Subscribe
	private void onScriptPreFired(ScriptPreFired scriptPreFired)
	{
		if (scriptPreFired.getScriptId() == ScriptID.ADD_OVERLAYTIMER_LOC)
		{
			var args = scriptPreFired.getScriptEvent()
				.getArguments();
			var locCoord = (int) args[1];
			var locType = (int) args[4];

			if (locType == TREE_DESPAWNED_LOC_TYPE)
			{ // Tree despawned
				var worldPoint = WorldPoint.fromCoord(locCoord);
				var eventTreeOpt = getTreeFromWorldPoint(worldPoint);
				eventTreeOpt.ifPresent(this::onTreeCutDown);
			}
		}
	}

	@Subscribe
	private void onGameTick(GameTick gameTick)
	{
		var player = client.getLocalPlayer();

		if (WOODCUTTING_ANIMATION_IDS.contains(player.getAnimation()))
		{
			// TODO: Handle off-angle animations better
			var facingTree = getFacingTree(player);

			if (woodcuttingState != null)
			{
				var isSameTree = facingTree.map(TileObject::getHash)
					.filter(it -> it == woodcuttingState.getGameObject()
						.getHash())
					.isPresent();
				if (!isSameTree)
				{
					onStopCutTree(woodcuttingState.getGameObject());
					facingTree.ifPresent(this::onStartCutTree);
				}
			}
			else
			{
				facingTree.ifPresent(this::onStartCutTree);
			}
		}
		else if (woodcuttingState != null)
		{
			onStopCutTree(woodcuttingState.getGameObject());
		}
	}

	@Subscribe
	private void onGameStateChanged(GameStateChanged e) {
		if (e.getGameState() != GameState.LOGGED_IN)
			objectCache.clear();
	}

	@Subscribe
	private void onGameObjectDespawned(GameObjectDespawned e) {
		if (TreeType.isTree(e.getGameObject())) {
			var p = new ObjectPosition(e.getGameObject());
			objectCache.remove(p.hashCode());
		}
	}

	private void onStopCutTree(GameObject gameObject)
	{
		woodcuttingState = null;
		stateChangeListeners.forEach(handler -> handler.onWoodcuttingStateChanged(null));
	}

	private void onTreeCutDown(GameObject gameObject)
	{
		treeCutDownListeners.forEach(handler -> handler.onTreeCutDown(gameObject));
	}

	private Optional<GameObject> getTreeFromWorldPoint(WorldPoint worldPoint)
	{
		return Optional.ofNullable(LocalPoint.fromWorld(client.getTopLevelWorldView(), worldPoint))
			.map(localPoint -> client.getTopLevelWorldView()
				.getScene()
				.getTiles()[worldPoint.getPlane()][localPoint.getSceneX()][localPoint.getSceneY()])
			.map(Tile::getGameObjects)
			.flatMap(objects -> Arrays.stream(objects)
				.filter(it -> TreeType.getTreeType(it)
					.isPresent())
				.findFirst());
	}


	private Optional<GameObject> getFacingTree(Player player)
	{
		var facingLocation = getFacingLocation(player);
		return getTreeFromWorldPoint(facingLocation);
	}

	private WorldPoint getFacingLocation(Player player)
	{
		var worldPoint = player.getWorldLocation();
		var direction = new Angle(player.getOrientation()).getNearestDirection();
		switch (direction)
		{
			case NORTH:
				return worldPoint.dy(1);
			case SOUTH:
				return worldPoint.dy(-1);
			case EAST:
				return worldPoint.dx(1);
			case WEST:
				return worldPoint.dx(-1);
			default:
				throw new IllegalStateException("Unexpected value for direction: " + direction);
		}
	}

	private void onStartCutTree(GameObject gameObject)
	{
		TreeType.getTreeType(gameObject)
			.ifPresent(type -> {
				woodcuttingState = new WoodcuttingState(gameObject, type, client.getTickCount(), Instant.now()
					.toEpochMilli());

				stateChangeListeners.forEach(handler -> handler.onWoodcuttingStateChanged(woodcuttingState));
			});
	}
}

package xyz.oelderoth.runelite.forestry.service;

import java.util.ArrayList;
import java.util.List;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import java.time.Instant;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.client.events.ConfigChanged;
import xyz.oelderoth.runelite.forestry.ForestryPluginConfig;
import xyz.oelderoth.runelite.forestry.domain.ObjectPosition;
import xyz.oelderoth.runelite.forestry.domain.TreeType;
import xyz.oelderoth.runelite.forestry.domain.TreeTimer;
import xyz.oelderoth.runelite.forestry.ui.CurrentTreePanel;

@Singleton
public class ForceSpawnService
{
	public static final int MIN_TICK_COUNT = 4;

	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Inject
	private CurrentTreePanel currentTreePanel;

	@Inject
	private ForestryPluginConfig config;

	@Inject
	private WoodcuttingService woodcuttingService;

	@Getter
	private final List<TreeTimer> treeTimers = new ArrayList<>();

	public void enable()
	{
		eventBus.register(this);
		woodcuttingService.registerTreeCutDownListener(this::removeTimer);
	}

	public void disable()
	{
		eventBus.unregister(this);
		woodcuttingService.unregisterTreeCutDownListener(this::removeTimer);
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged e) {
		if (e.getGroup().equals(ForestryPluginConfig.CONFIG_GROUP) && e.getKey().startsWith("track"))
			treeTimers.removeIf(it -> !isTreeTypeEnabled(it.getTreeType()));
	}

	@Subscribe
	private void onGameStateChanged(GameStateChanged e)
	{
		currentTreePanel.update();

		var wcState = woodcuttingService.getWoodcuttingState();

		if (wcState == null || !wcState.isForestryEligible())
			return;
		if (e.getGameState() != GameState.HOPPING && e.getGameState() != GameState.LOGIN_SCREEN)
			return;
		if ((client.getTickCount() - wcState.getStartTick()) < ForceSpawnService.MIN_TICK_COUNT)
			return;

		treeTimers.add(new TreeTimer(new ObjectPosition(wcState.getGameObject()), wcState.getTreeType(), wcState.getStartTimeMs(), client.getWorld()));
	}

	@Subscribe
	private void onGameTick(GameTick gameTick)
	{
		currentTreePanel.update();

		if (config.removeTimersAfter() > 0) {
			var now = Instant.now().toEpochMilli();
			treeTimers.removeIf(timer -> (now - timer.getStartTimeMs() - timer.getTreeType().getDespawnDurationMs()) > (config.removeTimersAfter() * 60000L));
		}
	}

	private boolean isTreeTypeEnabled(TreeType treeType) {
		switch (treeType) {
			case Oak:
				return config.trackOakTree();
			case Willow:
				return config.trackWillowTree();
			case Teak:
				return config.trackTeakTree();
			case Maple:
				return config.trackMapleTree();
			case Mahogany:
				return config.trackMahoganyTree();
			case ArcticPine:
				return config.trackArcticPineTree();
			case Yew:
				return config.trackYewTree();
			case Magic:
				return config.trackMagicTree();
			default:
				return false;
		}
	}

	private void removeTimer(GameObject gameObject) {
		treeTimers.removeIf(timer -> timer.getWorld() == client.getWorld() && timer.getTree().matches(gameObject));
	}
}
package xyz.oelderoth.runelite.forestry.service;

import java.util.Optional;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.World;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.ComponentID;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.WorldService;
import net.runelite.client.util.WorldUtil;

@Slf4j
@Singleton
public class WorldHopService
{
	private static final int MAX_RETRY_ATTEMPTS = 3;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Inject
	private WorldService worldService;

	private World targetWorld = null;
	private int retryAttempts = 0;

	public void enable()
	{
		eventBus.register(this);
	}

	public void disable()
	{
		eventBus.unregister(this);
	}

	public void hopToWorld(int worldId)
	{
		var worldOpt = getWorldById(worldId);
		if (worldOpt.isEmpty())
		{
			resetHop();
			return;
		}

		var world = worldOpt.get();

		printMessageToChat(new ChatMessageBuilder()
			.append(ChatColorType.NORMAL)
			.append("Quick-hopping to World ")
			.append(ChatColorType.HIGHLIGHT)
			.append(Integer.toString(world.getId()))
			.append(ChatColorType.NORMAL)
			.append("..")
			.build());

		targetWorld = world;
	}


	@Subscribe
	private void onGameTick(GameTick gameTick)
	{
		if (targetWorld == null) return;
		if (client.getWidget(ComponentID.WORLD_SWITCHER_WORLD_LIST) == null)
		{
			client.openWorldHopper();

			if (++retryAttempts >= MAX_RETRY_ATTEMPTS)
			{
				resetHop();
				printMessageToChat(new ChatMessageBuilder()
					.append(ChatColorType.NORMAL)
					.append("Failed to quick-hop after ")
					.append(ChatColorType.HIGHLIGHT)
					.append(Integer.toString(retryAttempts))
					.append(ChatColorType.NORMAL)
					.append(" attempts.")
					.build());
			}
		}
		else
		{
			client.hopToWorld(targetWorld);
			targetWorld = null;
		}
	}

	private Optional<World> getWorldById(int worldId)
	{
		return Optional.ofNullable(worldService.getWorlds())
			.map(result -> result.findWorld(worldId))
			.map(apiWorld -> {
				var rsWorld = client.createWorld();
				rsWorld.setActivity(apiWorld.getActivity());
				rsWorld.setAddress(apiWorld.getAddress());
				rsWorld.setId(apiWorld.getId());
				rsWorld.setPlayerCount(apiWorld.getPlayers());
				rsWorld.setLocation(apiWorld.getLocation());
				rsWorld.setTypes(WorldUtil.toWorldTypes(apiWorld.getTypes()));

				return rsWorld;
			});
	}

	private void resetHop()
	{
		targetWorld = null;
		retryAttempts = 0;
	}

	private void printMessageToChat(String chatMessage) {
		chatMessageManager
			.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(chatMessage)
				.build());
	}
}

package xyz.oelderoth.runelite.forestry.domain;

import lombok.Data;
import net.runelite.api.GameObject;
import net.runelite.api.coords.WorldPoint;

@Data
public class ObjectPosition
{
	private final int objectID;
	private final WorldPoint point;

	public ObjectPosition(GameObject object) {
		objectID = object.getId();
		point = object.getWorldLocation();
	}

	public boolean matches(GameObject other) {
		var oP = other.getWorldLocation();
		return other.getId() == objectID && oP.getRegionID() == point.getRegionID() && oP.getPlane() == point.getPlane() && oP.getX() == point.getX() && oP.getY() == point.getY();
	}
}

package xyz.oelderoth.runelite.forestry.domain;

import com.google.common.collect.Sets;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameObject;
import net.runelite.api.ItemID;
import static net.runelite.api.ObjectID.*;

@Getter
@Slf4j
@AllArgsConstructor
public enum TreeType
{
	Oak(27000, ItemID.OAK_LOGS, Sets.newHashSet(OAK_TREE_4540, OAK_TREE_8462, OAK_TREE_8463, OAK_TREE_8464, OAK_TREE_8465, OAK_TREE_8466, OAK_TREE_8467, OAK_TREE_9734, OAK_TREE_10820, OAK_TREE_20806, OAK_TREE_37969, OAK_TREE_37970, OAK_TREE_42395, OAK_TREE_42831, OAK_TREE_51772, OAK_TREE_55913)),
	Willow(30000, ItemID.WILLOW_LOGS, Sets.newHashSet(WILLOW_TREE_4541, WILLOW_TREE_8481, WILLOW_TREE_8482, WILLOW_TREE_8483, WILLOW_TREE_8484, WILLOW_TREE_8485, WILLOW_TREE_8486, WILLOW_TREE_8487, WILLOW_TREE_8488, WILLOW_TREE_10819, WILLOW_TREE_10829, WILLOW_TREE_10831, WILLOW_TREE_10833)),
	Teak(30000, ItemID.TEAK_LOGS, Sets.newHashSet(TEAK_TREE_15062, TEAK_TREE_30437, TEAK_TREE_30438, TEAK_TREE_30439, TEAK_TREE_30440, TEAK_TREE_30441, TEAK_TREE_30442, TEAK_TREE_30443, TEAK_TREE_30444, TEAK_TREE_30445, TEAK_TREE_36686, TEAK_TREE_40758)),
	Maple(60000, ItemID.MAPLE_LOGS, Sets.newHashSet(MAPLE_TREE_4674, MAPLE_TREE_5126, MAPLE_TREE_8435, MAPLE_TREE_8436, MAPLE_TREE_8437, MAPLE_TREE_8438, MAPLE_TREE_8439, MAPLE_TREE_8440, MAPLE_TREE_8441, MAPLE_TREE_8442, MAPLE_TREE_8443, MAPLE_TREE_8444, MAPLE_TREE_10832, MAPLE_TREE_36681, MAPLE_TREE_36682, MAPLE_TREE_40754, MAPLE_TREE_40755)),
	ArcticPine(114000, ItemID.ARCTIC_PINE_LOGS, Sets.newHashSet(ARCTIC_PINE_TREE)),
	Mahogany(60000, ItemID.MAHOGANY_LOGS, Sets.newHashSet(MAHOGANY_TREE_30407, MAHOGANY_TREE_30408, MAHOGANY_TREE_30409, MAHOGANY_TREE_30410, MAHOGANY_TREE_30411, MAHOGANY_TREE_30412, MAHOGANY_TREE_30413, MAHOGANY_TREE_30414, MAHOGANY_TREE_30415, MAHOGANY_TREE_30416, MAHOGANY_TREE_30417, MAHOGANY_TREE_36688, MAHOGANY_TREE_40760)),
	Yew(114000, ItemID.YEW_LOGS, Sets.newHashSet(YEW_TREE_5121, YEW_TREE_8503, YEW_TREE_8504, YEW_TREE_8505, YEW_TREE_8506, YEW_TREE_8507, YEW_TREE_8508, YEW_TREE_8509, YEW_TREE_8510, YEW_TREE_8511, YEW_TREE_8512, YEW_TREE_8513, YEW_TREE_10822, 10823, YEW_TREE_36683, YEW_TREE_40756, YEW_TREE_42391, YEW_TREE_42427)),
	Magic(234000, ItemID.MAGIC_LOGS, Sets.newHashSet(MAGIC_TREE_5127, MAGIC_TREE_8396, MAGIC_TREE_8397, MAGIC_TREE_8398, MAGIC_TREE_8399, MAGIC_TREE_8400, MAGIC_TREE_8401, MAGIC_TREE_8402, MAGIC_TREE_8403, MAGIC_TREE_8404, MAGIC_TREE_8405, MAGIC_TREE_8406, MAGIC_TREE_8407, MAGIC_TREE_8408, MAGIC_TREE_8409, MAGIC_TREE_10834, MAGIC_TREE_36685));

	private final int despawnDurationMs;
	private final int itemId;
	private final Set<Integer> objectIDs;

	private final static Map<Integer, TreeType> treeTypeById = new HashMap<>();

	public static Optional<TreeType> getTreeType(int objectId) {
		return Optional.ofNullable(treeTypeById.get(objectId));
	}

	public static Optional<TreeType> getTreeType(GameObject object) {
		return Optional.ofNullable(object).map(GameObject::getId).flatMap(TreeType::getTreeType);
	}

	public static boolean isTree(GameObject object) {
		return treeTypeById.containsKey(object.getId());
	}

	static {
		for (var type : TreeType.values()) {
			for (var id: type.objectIDs) {
				treeTypeById.put(id, type);
			}
		}
	}
}
package xyz.oelderoth.runelite.forestry.domain;

import javax.annotation.Nullable;

@FunctionalInterface
public interface WoodcuttingStateListener
{
	void onWoodcuttingStateChanged(@Nullable WoodcuttingState state);
}

package xyz.oelderoth.runelite.forestry.domain;

import lombok.Data;
import net.runelite.api.GameObject;

@Data
public class WoodcuttingState
{
	private final GameObject gameObject;
	private final TreeType treeType;
	private final int startTick;
	private final long startTimeMs;

	public boolean isForestryEligible() {
		var regionId = gameObject.getWorldLocation().getRegionID();
		// TODO: More accurate area check
		return regionId != WOODCUTTING_GUILD_REGION_EAST && regionId != WOODCUTTING_GUILD_REGION_WEST;
	}

	private static int WOODCUTTING_GUILD_REGION_EAST = 6454;
	private static int WOODCUTTING_GUILD_REGION_WEST = 6198;
}

package xyz.oelderoth.runelite.forestry.domain;

import lombok.Data;

@Data
public class TreeTimer
{
	private final ObjectPosition tree;
	private final TreeType treeType;
	private final long startTimeMs;
	private final int world;
}

package xyz.oelderoth.runelite.forestry.domain;

import net.runelite.api.GameObject;

@FunctionalInterface
public interface TreeCutDownListener
{
	void onTreeCutDown(GameObject object);
}

package xyz.oelderoth.runelite.forestry;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ForestryPlugin.class);
		RuneLite.main(args);
	}
}
