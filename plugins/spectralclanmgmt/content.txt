package com.spectralclanmgmt;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class SpectralClanMgmtPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(SpectralClanMgmtPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2018 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.spectralclanmgmt;

import com.google.inject.Inject;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import net.runelite.api.FontID;
import net.runelite.api.widgets.WidgetType;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.client.input.KeyListener;

public class SpectralTextMenuInput extends SpectralClanMgmtPlugin.SpectralInput implements KeyListener
{
	@Data
	@AllArgsConstructor
	private static final class Entry
	{
		private String text;
		private Runnable callback;
	}
	
	private final SpectralChatboxPanel chatboxPanelManager;
	
	@Getter
	private String title;
	
	@Getter
	private List<Entry> options = new ArrayList<>();
	
	@Getter
	private Runnable onClose;
	
	@Inject
	protected SpectralTextMenuInput(SpectralChatboxPanel chatboxPanelManager)
	{
		this.chatboxPanelManager = chatboxPanelManager;
	}
	
	public SpectralTextMenuInput title(String title)
	{
		this.title = title;
		return this;
	}
	
	public SpectralTextMenuInput option(String text, Runnable callback)
	{
		options.add(new Entry(text, callback));
		return this;
	}
	
	public SpectralTextMenuInput onClose(Runnable onClose)
	{
		this.onClose = onClose;
		return this;
	}
	
	public SpectralTextMenuInput build(int lineNum)
	{
		if (title == null)
		{
			throw new IllegalStateException("Title must be set.");
		}
		
		if (options.size() < 1)
		{
			throw new IllegalStateException("You must have at least 1 option.");
		}
		
		chatboxPanelManager.openInput(this, lineNum);
		return this;
	}
	
	@Override
	public void open(int lineNum)
	{
		Widget container = chatboxPanelManager.getContainerWidget();
		Widget prompt = container.createChild(-1, WidgetType.TEXT);
		
		prompt.setText(title);
		prompt.setTextColor(0x000000);
		prompt.setFontId(FontID.QUILL_8);
		prompt.setLineHeight(19);
		prompt.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER);
		prompt.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
		
		int h = prompt.getLineHeight() * lineNum;
		
		prompt.setOriginalHeight(h);
		prompt.setOriginalX(0);
		prompt.setOriginalY(8);
		prompt.setXTextAlignment(WidgetTextAlignment.CENTER);
		prompt.setYTextAlignment(WidgetTextAlignment.CENTER);
		prompt.setWidthMode(WidgetSizeMode.MINUS);
		prompt.revalidate();
		
		int y = prompt.getOriginalY() + prompt.getHeight() + 6;
		
		int optionNum = 0;
		
		for (Entry option : options)
		{
			int optY = 0;
			
			if (options.size() > 3)
			{
				optY = y + (optionNum * 22);
			}
			else if (options.size() > 1 && options.size() < 4)
			{
				optY = y + (optionNum * 24);
			}
			else if (options.size() == 1)
			{
				optY = y + 18;
			}
			
			Widget optWidget = container.createChild(-1, WidgetType.TEXT);
			
			optWidget.setText(option.text);
			optWidget.setFontId(FontID.QUILL_8);
			optWidget.setTextColor(0xFF0000);
			optWidget.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER);
			optWidget.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
			optWidget.setOriginalX(0);
			optWidget.setOriginalY(optY);
			optWidget.setOriginalHeight(19);
			
			optWidget.setXTextAlignment(WidgetTextAlignment.CENTER);
			optWidget.setYTextAlignment(WidgetTextAlignment.CENTER);
			optWidget.setWidthMode(WidgetSizeMode.MINUS);
			
			optWidget.setAction(0, "Continue");
			optWidget.setOnOpListener((JavaScriptCallback) ev -> callback(option));
			optWidget.setOnMouseOverListener((JavaScriptCallback) ev -> optWidget.setTextColor(0xFFFFFF));
			optWidget.setOnMouseLeaveListener((JavaScriptCallback) ev -> optWidget.setTextColor(0xFF0000));
			optWidget.setHasListener(true);
			optWidget.revalidate();
			
			optionNum += 1;
		}
	}
	
	private void callback(Entry entry)
	{
		Widget container = chatboxPanelManager.getContainerWidget();
		container.setOnKeyListener((Object[]) null);
		chatboxPanelManager.close();
		entry.callback.run();
	}
	
	@Override
	public void close()
	{
		if (onClose != null)
		{
			onClose.run();
		}
	}
	
	@Override
	public void keyTyped(KeyEvent e)
	{
		if (!chatboxPanelManager.shouldTakeInput())
		{
			return;
		}
		
		char c = e.getKeyChar();
		
		if (c == '\033')
		{
			chatboxPanelManager.close();
			e.consume();
			return;
		}
		
		int n = c - '1';
		
		if (n >= 0 && n < options.size())
		{
			callback(options.get(n));
			e.consume();
		}
	}
	
	@Override
	public void keyPressed(KeyEvent e)
	{
		if (!chatboxPanelManager.shouldTakeInput())
		{
			return;
		}
		
		if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
		{
			e.consume();
		}
	}
	
	@Override
	public void keyReleased(KeyEvent e)
	{
	}
}
package com.spectralclanmgmt;

/*
Explanation behind this class:

This is to hold the values for the random phrases that could be said when the !spectral command is issued.
This command, like the other Spectral commands, won't work outside of the clan chat channel. 
If it's used in any other channel, or by anyone that's not a ranked member of Spectral, 
the command will be consumed so it won't be displayed in the chat.

Permission checks are done via asynchronous http requests to Spectral's web app when spectral's commands are used 
to verify that the player, or the clan as a whole, is allowed to use any of spectral's commands. 
In the instance that a clan member's permissions to use one or all of spectral's commands has been revoked, 
the command will be consumed. If the command isn't able to be used by a ranked clan member for any reason, 
such as when their permissions have been revoked, a chat message will be added to the game chat explaining why.
*/

public class SpectralClanMgmtCommandPhrases
{
	/* 
	Values for this string array only come from Spectral's private spreadsheet that only the clan's moderators can edit.
	All values on the phrases spreadsheet are verified by the clan's mods and leaders to adhere to OSRS's rules and Jagex's T&C.
	All values on the phrases spreadsheet are verified to not exceed the chat box's input limit before being added to the sheet. 
	The mods and leaders verify that the phrases don't contain links, directions to links, or anything that qualifies 
	as illegal or rule-breaking content as outlined in the Safety and Abuse section, and the User Content section, of Jagex's T&C.
	 */
	
	private String[] phrases;
	
	protected SpectralClanMgmtCommandPhrases()
	{
		this.phrases = null;
	}
	
	protected String[] getPhrases()
	{
		return this.phrases;
	}
	
	protected void setPhrases(String[] phrases)
	{
		this.phrases = phrases;
	}
}

package com.spectralclanmgmt;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import java.io.*;
import java.util.concurrent.*;

import okhttp3.*;
import javax.inject.Inject;

@Slf4j
public class SpectralClanMgmtHttpRequest
{
	@Inject
	private OkHttpClient httpclient;
	
	private SpectralClanMgmtConfig config;
	
	private SpectralClanMgmtPlugin plugin;
	
	private SpectralClanMgmtButton button;
	
	private Client client;
	
	private boolean isReady = true;
	
	@Inject
	protected SpectralClanMgmtHttpRequest(SpectralClanMgmtPlugin plugin, SpectralClanMgmtConfig config, Client client, OkHttpClient okHttpClient)
	{
		this.plugin = plugin;
		this.config = config;
		this.client = client;
		this.httpclient = okHttpClient.newBuilder().connectTimeout(10, TimeUnit.SECONDS).readTimeout(6, TimeUnit.MINUTES).build();
		this.button = null;
	}
	
	protected void setButton(SpectralClanMgmtButton button)
	{
		this.button = button;
	}
	
	// For getting the permissions, config links, and phrases all at once.
	// This will be called after start up and when a command is used and it's been at least 5 minutes since the permissions were last checked.
	protected String getRequestAsyncPluginData(String configLink, String player, String acctHash)
	{
		if (!configLink.equalsIgnoreCase("discord") && !configLink.equalsIgnoreCase("both") && !configLink.equalsIgnoreCase("reg-fail"))
		{
			return configLink;
		}
		
		CompletableFuture<String> respBody = new CompletableFuture<>();
		
		HttpUrl url = HttpUrl.parse(config.scriptURL()).newBuilder()
		.addQueryParameter("configLink", configLink)
		.addQueryParameter("player", player)
		.addQueryParameter("acctHash", acctHash)
		.addQueryParameter("accessKey", config.memberKey())
		.build();
		
		Request request = new Request.Builder()
									 .url(url.toString())
									 .get()
									 .build();
		
		httpclient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				respBody.completeExceptionally(e);
			}
			
			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				if (!response.isSuccessful())
				{
					respBody.completeExceptionally(new IOException("Something went wrong. Report this issue with this response code to the developer: " + response.toString()));
				}
				else
				{
					try
					{
						respBody.complete(plugin.setPluginData(response));
					}
					finally
					{
						response.close();
					}
				}
			}
		});
		
		return respBody.join();
	}
	
	/* 
	This is for the Admin-related export tasks in the SpectralClanMgmtButton class (new member additions and name changes).
	 */
	protected CompletableFuture<String> postRequestAsyncAdmin(String task, String firstArg, String secondArg, String thirdArg, String adminPlayer, String acctHash)
	{
		CompletableFuture<String> respBody = new CompletableFuture<>();
		
		String arg1 = "task";
		String arg2 = "";
		String arg3 = "";
		String arg4 = "";
		String arg5 = "adminPlayer";
		String arg6 = "accessKey";
		String arg7 = "acctHash";
		
		if (task.equalsIgnoreCase("add-new"))
		{
			arg2 = "joinDate";
			arg3 = "mainPlayer";
		}
		else if (task.equalsIgnoreCase("add-alt"))
		{
			arg2 = "joinDate";
			arg3 = "mainPlayer";
			arg4 = "altPlayer";
		}
		else if (task.equalsIgnoreCase("name-change"))
		{
			arg2 = "currentName";
			arg3 = "oldName";
			arg4 = "memberType";
		}
		else if (task.equalsIgnoreCase("revoke-permission") || task.equalsIgnoreCase("restore-permission"))
		{
			arg2 = "player";
			arg3 = "category";
		}
		else if (task.equalsIgnoreCase("rank-swap"))
		{
			arg2 = "oldMain";
			arg3 = "newMain";
		}
		else if (task.equalsIgnoreCase("discord-deserter") || task.equalsIgnoreCase("discord-returnee"))
		{
			arg2 = "mainPlayer";
		}
		
		HttpUrl adminURL;
		
		// URL of the web app for the script.
		if (task.equalsIgnoreCase("revoke-permission") || task.equalsIgnoreCase("restore-permission"))
		{
			adminURL = HttpUrl.parse(config.scriptURL());
		}
		else
		{
			adminURL = HttpUrl.parse(plugin.getAdminURL());
		}
		
		String payload = "";
		
		if (task.equalsIgnoreCase("revoke-permission") || task.equalsIgnoreCase("restore-permission") || task.equalsIgnoreCase("add-new") || task.equalsIgnoreCase("rank-swap"))
		{
			payload = "{\"" + arg1 + "\":\"" + task + "\",\"" + arg2 + "\":\"" + firstArg + "\",\"" + arg3 + "\":\"" + secondArg + "\",\"" + arg5 + "\":\"" + adminPlayer + "\",\"" + arg6 + "\":\"" + config.memberKey() + "\",\"" + arg7 + "\":\"" + acctHash + "\"}";
		}
		else if (task.equalsIgnoreCase("discord-deserter"))
		{
			payload = "{\"" + arg1 + "\":\"" + task + "\",\"" + arg2 + "\":\"" + firstArg + "\",\"" + arg5 + "\":\"" + adminPlayer + "\",\"" + arg6 + "\":\"" + config.memberKey() + "\",\"" + arg7 + "\":\"" + acctHash + "\"}";
		}
		else
		{
			payload = "{\"" + arg1 + "\":\"" + task + "\",\"" + arg2 + "\":\"" + firstArg + "\",\"" + arg3 + "\":\"" + secondArg + "\",\"" + arg4 + "\":\"" + thirdArg + "\",\"" + arg5 + "\":\"" + adminPlayer + "\",\"" + arg6 + "\":\"" + config.memberKey() + "\",\"" + arg7 + "\":\"" + acctHash + "\"}";
		}
		
		RequestBody body = RequestBody.create(MediaType.parse("application/json"), payload);
		
		Request request = new Request.Builder()
									 .url(adminURL)
									 .post(body)
									 .addHeader("Content-Type", "application/json")
									 .build();
		
		httpclient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				respBody.completeExceptionally(e);
			}
			
			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				if (!response.isSuccessful())
				{
					respBody.completeExceptionally(new IOException("Something went wrong. Report this issue with this response code to the developer: " + response.toString()));
				}
				else
				{
					try
					{
						respBody.complete(button.exportDone(task, response));
					}
					finally
					{
						response.close();
					}
				}
			}
		});
		
		return respBody;
	}
	
	/*
	This is the postRequestAsync method for the Discord-related commands.
	*/
	protected CompletableFuture<String> postRequestAsyncRecruitMod(String task, String spectralCommand, String player, String acctHash)
	{
		CompletableFuture<String> respBody = new CompletableFuture<>();
		
		// URL of the web app for the script.
		HttpUrl url = HttpUrl.parse(config.scriptURL());
		String command = spectralCommand.substring(1);
		String payload = "{\"task\":\"" + task + "\",\"command\":\"" + command + "\",\"player\":\"" + player + "\",\"accessKey\":\"" + config.memberKey() + "\",\"acctHash\":\"" + acctHash + "\"}";
		
		RequestBody body = RequestBody.create(MediaType.parse("application/json"), payload);
		
		Request request = new Request.Builder()
		.url(url)
		.post(body)
		.addHeader("Content-Type", "application/json")
		.build();
		
		httpclient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				respBody.completeExceptionally(e);
			}
			
			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				if (!response.isSuccessful())
				{
					respBody.completeExceptionally(new IOException("Something went wrong. Report this issue with this response code to the developer: " + response.toString()));
				}
				else
				{
					try
					{
						respBody.complete(plugin.setModRecruit(response));
					}
					finally
					{
						response.close();
					}
				}
			}
		});
		
		return respBody;
	}
	
	/*
	This is the postRequestAsync method for retrieving a member's access key.
	*/
	protected CompletableFuture<String> postRequestAsyncAccessKey(String task, String player, String acctHash)
	{
		CompletableFuture<String> respBody = new CompletableFuture<>();
		
		HttpUrl url = HttpUrl.parse(config.scriptURL());
		String payload = "{\"task\":\"" + task + "\",\"player\":\"" + player + "\",\"acctHash\":\"" + acctHash + "\"}";
		
		RequestBody body = RequestBody.create(MediaType.parse("application/json"), payload);
		
		Request request = new Request.Builder()
		.url(url)
		.post(body)
		.addHeader("Content-Type", "application/json")
		.build();
		
		httpclient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				respBody.completeExceptionally(e);
			}
			
			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				if (!response.isSuccessful())
				{
					respBody.completeExceptionally(new IOException("Something went wrong. Report this issue with this response code to the developer: " + response.toString()));
				}
				else
				{
					try
					{
						respBody.complete(plugin.setAccessKey(response));
					}
					finally
					{
						response.close();
					}
				}
			}
		});
		
		return respBody;
	}
	
	/*
	This is the postRequestAsync method for processing and storing a player's account hash in a private data storage location.
	This will send an http request to Spectral's Discord application and trigger its Discord bot to ping the member who used the !addme command
	in Spectral's private Discord server to confirm that they initiated the request. Only the member can respond to the bot's message, 
	and the member has up to 5 minutes to respond to it in the server before the application will return a failed response. 
	Once the member confirms that they initiated the request, the application will process and store the account hash and return a response.
	Including the player's name and account hash, along with a private access key, was the best option I could come up with for 
	validating if any http requests sent to Spectral's web app came from this plugin.
	*/
	protected CompletableFuture<String> postRequestAsyncRegisterPlayerID(String task, String player, String acctHash)
	{
		CompletableFuture<String> respBody = new CompletableFuture<>();
		
		HttpUrl url = HttpUrl.parse(plugin.getDiscordURL());
		String payload = "{\"task\":\"" + task + "\",\"player\":\"" + player + "\",\"acctHash\":\"" + acctHash + "\"}";
		
		RequestBody body = RequestBody.create(MediaType.parse("application/json"), payload);
		
		Request request = new Request.Builder()
		.url(url)
		.post(body)
		.addHeader("Content-Type", "application/json")
		.build();
		
		httpclient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				respBody.completeExceptionally(e);
			}
			
			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				if (!response.isSuccessful())
				{
					respBody.completeExceptionally(new IOException("Something went wrong. Report this issue with this response code to the developer: " + response.toString()));
				}
				else
				{
					try
					{
						respBody.complete(plugin.updateRegistered(player, response));
					}
					finally
					{
						response.close();
					}
				}
			}
		});
		
		return respBody;
	}
	
	protected boolean getIsReady()
	{
		return this.isReady;
	}
	
	protected void setIsReady(boolean value)
	{
		this.isReady = value;
	}
}
/*
 * Copyright (c) 2018 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.spectralclanmgmt;

import com.google.inject.Provider;
import com.google.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.ScriptID;
import net.runelite.api.VarClientInt;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.vars.InputType;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.chatbox.ChatboxTextInput;
import net.runelite.client.input.*;
import javax.inject.Inject;

@Singleton
@Slf4j
public class SpectralChatboxPanel
{
	private final Client client;
	private final ClientThread clientThread;
	private final EventBus eventBus;
	private final KeyManager keyManager;
	private final MouseManager mouseManager;
	private final Provider<ChatboxTextInput> chatboxTextInputProvider;
	private final Provider<SpectralTextMenuInput> spectralTextMenuInputProvider;
	
	@Getter
	private SpectralClanMgmtPlugin.SpectralInput currentInput = null;
	
	@Inject
	protected SpectralChatboxPanel(EventBus eventBus, Client client, ClientThread clientThread,
	KeyManager keyManager, MouseManager mouseManager,
	Provider<SpectralTextMenuInput> spectralTextMenuInputProvider, Provider<ChatboxTextInput> chatboxTextInputProvider)
	{
		this.client = client;
		this.clientThread = clientThread;
		this.eventBus = eventBus;
		this.keyManager = keyManager;
		this.mouseManager = mouseManager;
		this.spectralTextMenuInputProvider = spectralTextMenuInputProvider;
		this.chatboxTextInputProvider = chatboxTextInputProvider;
		eventBus.register(this);
	}
	
	protected void shutdown()
	{
		eventBus.unregister(this);
	}
	
	public void close()
	{
		clientThread.invokeLater(this::unsafeCloseInput);
	}
	
	private void unsafeCloseInput()
	{
		client.runScript(
		ScriptID.MESSAGE_LAYER_CLOSE,
		0,
		1,
		0
		);
		
		if (currentInput != null)
		{
			killCurrentPanel();
		}
	}
	
	private void unsafeOpenInput(SpectralClanMgmtPlugin.SpectralInput input, int lineNum)
	{
		client.runScript(ScriptID.MESSAGE_LAYER_OPEN, 0);
		
		eventBus.register(input);
		
		if (input instanceof KeyListener)
		{
			keyManager.registerKeyListener((KeyListener) input);
		}
		
		if (input instanceof MouseListener)
		{
			mouseManager.registerMouseListener((MouseListener) input);
		}
		
		if (input instanceof MouseWheelListener)
		{
			mouseManager.registerMouseWheelListener((MouseWheelListener) input);
		}
		
		if (currentInput != null)
		{
			killCurrentPanel();
		}
		
		currentInput = input;
		client.setVarcIntValue(VarClientInt.INPUT_TYPE, InputType.RUNELITE_CHATBOX_PANEL.getType());
		client.getWidget(ComponentID.CHATBOX_TITLE).setHidden(true);
		client.getWidget(ComponentID.CHATBOX_FULL_INPUT).setHidden(true);
		
		Widget c = getContainerWidget();
		c.deleteAllChildren();
		c.setOnDialogAbortListener((JavaScriptCallback) ev -> this.unsafeCloseInput());
		input.open(lineNum);
	}
	
	public void openInput(SpectralClanMgmtPlugin.SpectralInput input, int lineNum)
	{
		clientThread.invokeLater(() -> unsafeOpenInput(input, lineNum));
	}
	
	public SpectralTextMenuInput openTextMenuInput(String title)
	{
		return (SpectralTextMenuInput)spectralTextMenuInputProvider.get().title(title);
	}
	
	@Subscribe
	public void onScriptPreFired(ScriptPreFired ev)
	{
		if (currentInput != null && ev.getScriptId() == ScriptID.MESSAGE_LAYER_CLOSE)
		{
			killCurrentPanel();
		}
	}
	
	@Subscribe
	private void onGameStateChanged(GameStateChanged ev)
	{
		if (currentInput != null && ev.getGameState() == GameState.LOGIN_SCREEN)
		{
			killCurrentPanel();
		}
	}
	
	private void killCurrentPanel()
	{
		try
		{
			currentInput.close();
		}
		catch (Exception e)
		{
			log.warn("Exception closing {}", currentInput.getClass(), e);
		}
		
		eventBus.unregister(currentInput);
		
		if (currentInput instanceof KeyListener)
		{
			keyManager.unregisterKeyListener((KeyListener) currentInput);
		}
		if (currentInput instanceof MouseListener)
		{
			mouseManager.unregisterMouseListener((MouseListener) currentInput);
		}
		if (currentInput instanceof MouseWheelListener)
		{
			mouseManager.unregisterMouseWheelListener((MouseWheelListener) currentInput);
		}
		
		currentInput = null;
	}
	
	public Widget getContainerWidget()
	{
		return client.getWidget(ComponentID.CHATBOX_CONTAINER);
	}
	
	public boolean shouldTakeInput()
	{
		// the search box on the world map can be focused, and chat input goes there, even
		// though the chatbox still has its key listener.
		Widget worldMapSearch = client.getWidget(ComponentID.WORLD_MAP_SEARCH);
		return worldMapSearch == null || client.getVarcIntValue(VarClientInt.WORLD_MAP_SEARCH_FOCUSED) != 1;
	}
}

package com.spectralclanmgmt;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonSyntaxException;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import javax.inject.Inject;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.clan.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ChatInput;
import net.runelite.client.events.ConfigChanged;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.Pattern;
import net.runelite.client.util.Text;
import okhttp3.OkHttpClient;
import okhttp3.Response;

@Slf4j
@PluginDescriptor(
name = "Spectral Clan Mgmt",
description = "A Runelite plugin to help the members of Spectral, an OSRS clan."
)
public class SpectralClanMgmtPlugin extends Plugin
{
	/*
	For anyone looking at this, I'm aware that this plugin has some ugly fucking code, but I'm gonna have to ask you to forgive me
	cause it's been over 3 years since I did any major coding with an OOL, and I am beyond rusty. And it shows.
	But the code works, and at this point, I'm satisfied with that.
	*/
	
	@Inject
	private EventBus eventBus;
	
	@Inject
	private SpectralClanMgmtConfig config;
	
	@Inject
	private Client client;
	
	@Inject
	private ClientThread clientThread;
	
	@Inject
	private SpectralChatboxPanel chatboxPanelManager;
	
	@Inject
	private ScheduledExecutorService executor;
	
	@Inject
	private ChatCommandManager chatCommandManager;
	
	@Inject
	private Gson gson;
	
	@Inject
	private OkHttpClient okHttpClient;
	
	@Inject
	private SpectralClanMgmtHttpRequest httpRequest;
	
	@Inject
	private SpectralClanMgmtButton spectralClanMemberButton;
	
	@Getter
	private String adminURL = "";
	
	@Getter
	private String discordURL = "";
	
	private ClanSettings clanSettings;
	
	private HashMap<Integer, ClanMember> sortedClanMembers = new HashMap<Integer, ClanMember>();
	
	private static final int CLAN_SETTINGS_INTERFACE = 690;
	
	private static final int CLAN_SETTINGS_MEMBERS_INTERFACE = 693;
	
	private static final int CLAN_SETTINGS_MEMBERS_INTERFACE_HEADER = 45416450;
	
	private SpectralClanMgmtCommandPhrases spectralPhrases;
	
	// These two booleans are the permission flags that determine if spectral's commands can be used.
	// The values comes from our online web app so we can revoke permissions at any time without having to modify the plugin.
	// Permission checks are done after startup, as well as when a command is used and 
	// it's been at least 5 minutes since permissions were last checked.
	private boolean canUseDiscordCommands;
	private boolean canUseSpectralCommand;
	
	protected boolean validAccessKey;
	
	private boolean pluginLoaded;
	
	private boolean commandProcessing;
	
	private boolean memberWidgetLoaded;
	
	private boolean firstGameTick;
	
	// Used to ensure you won't see the same phrase multiple times in a row when you use the !spectral command.
	private int previousPhrasePosition;
	
	// Controls how many times an http request will be resent if 
	// a previous request failed to receive a response.
	// Up to 5 attempts can be made after a failed request.
	private int attemptCount;
	
	private int gameTickCount;
	
	// They'll need to wait a certain amount of time after they use one of spectral's command before they can use one again.
	private int coolDown;
	
	private boolean coolDownFinished;
	
	/*
	For the command use, we'll limit the permission checks to once every 5 minutes they're logged in.
	Doing the permission check every time makes the commands too slow.
	*/
	private int permissionCheckTimer;
	
	// In case we decide to change one or both of these at some point, we'll set their default values here to make it easier.
	// These are updated from Spectral's web app so we won't need to update the plugin if these are too short/long.
	private int permissionCheckTime = 500;
	
	private int coolDownTime = 50;
	
	// Tracks if the plugin has finished its initial data and permissions loading.
	private boolean ready;
	
	protected GameState gameState;
	
	private HashMap<String, Boolean> reg = new HashMap<String, Boolean>();
	
	private final String COMMAND_KEY = "!key";
	
	private final String COMMAND_ADDME = "!addme";
	
	private final String COMMAND_SPECTRAL = "!spectral";
	
	private final String COMMAND_MOD = "!mod";
	
	private final String COMMAND_RECRUIT = "!recruit";
	
	/*
	Since I can't seem to be able to simply override the open method in the ChatboxTextMenuInput class
	so I can change how the text menu is displayed in the chatbox when it's built,
	my only choice is to remake the classes and include the copyright notices for them.
	Since this class is tiny and needed for the ChatboxPanelManager and ChatboxTextMenuInput,
	I'd rather recreate it here as an inner class rather than add a new class file for it.
	I did end up modifying the open method.
	 */
	public abstract static class SpectralInput
	{
		/*
		 * Copyright (c) 2018 Abex
		 * All rights reserved.
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are met:
		 *
		 * 1. Redistributions of source code must retain the above copyright notice, this
		 *    list of conditions and the following disclaimer.
		 * 2. Redistributions in binary form must reproduce the above copyright notice,
		 *    this list of conditions and the following disclaimer in the documentation
		 *    and/or other materials provided with the distribution.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
		 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
		 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
		 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
		 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
		 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
		 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
		 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */
		public void open(int lineNum)
		{
		}
		
		public void close()
		{
		}
	}
	
	@Getter
	public class SpectralCommand
	{
		private final String spectralCommand;
		
		private final String player;
		
		private final String acctHash;
		
		private final int rank;
		
		private final ChatInput chatInput;
		
		protected SpectralCommand(String player, String acctHash, int rank, String spectralCommand, ChatInput chatInput)
		{
			this.spectralCommand = spectralCommand;
			this.rank = rank;
			this.player = player;
			this.acctHash = acctHash;
			this.chatInput = chatInput;
		}
	}
	
	@Provides
	SpectralClanMgmtConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(SpectralClanMgmtConfig.class);
	}
	
	@Override
	protected void startUp() throws Exception
	{
		log.info("Spectral Clan Mgmt Plugin started!");
		gameState = client.getGameState();
		spectralPhrases = new SpectralClanMgmtCommandPhrases();
		httpRequest = new SpectralClanMgmtHttpRequest(this, config, client, okHttpClient);
		attemptCount = 0;
		coolDown = -1;
		coolDownFinished = true;
		permissionCheckTimer = -1;
		gameTickCount = 0;
		previousPhrasePosition = -1;
		firstGameTick = false;
		adminURL = "";
		discordURL = "";
		canUseSpectralCommand = false;
		canUseDiscordCommands = false;
		validAccessKey = false;
		ready = false;
		pluginLoaded = false;
		commandProcessing = false;
		spectralClanMemberButton = new SpectralClanMgmtButton(this, chatboxPanelManager, config, client, httpRequest, gson);
		chatCommandManager.registerCommand(COMMAND_SPECTRAL,this::showCommand, this::getCommand);
		chatCommandManager.registerCommand(COMMAND_ADDME,this::showCommand, this::getCommand);
		chatCommandManager.registerCommand(COMMAND_KEY,this::showCommand, this::getCommand);
		chatCommandManager.registerCommand(COMMAND_MOD,this::showCommand, this::getCommand);
		chatCommandManager.registerCommand(COMMAND_RECRUIT,this::showCommand, this::getCommand);
		reg.clear();
		reg.putAll(getReg());
	}
	
	@Override
	protected void shutDown() throws Exception
	{
		chatboxPanelManager.shutdown();
		adminURL = "";
		discordURL = "";
		canUseSpectralCommand = false;
		canUseDiscordCommands = false;
		spectralPhrases = null;
		httpRequest = null;
		chatCommandManager.unregisterCommand(COMMAND_SPECTRAL);
		chatCommandManager.unregisterCommand(COMMAND_MOD);
		chatCommandManager.unregisterCommand(COMMAND_RECRUIT);
		chatCommandManager.unregisterCommand(COMMAND_KEY);
		chatCommandManager.unregisterCommand(COMMAND_ADDME);
		reg.clear();
		sortedClanMembers.clear();
		log.info("Spectral Clan Mgmt Plugin stopped!");
	}
	
	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		GameState previousGameState;
		
		if (gameState != null)
		{
			previousGameState = gameState;
		}
		else
		{
			previousGameState = gameStateChanged.getGameState();
		}
		
		gameState = gameStateChanged.getGameState();
		boolean throwAwayBoolean = checkGameState(gameState);
		
		return;
	}
	
	@Subscribe
	public void onGameTick(GameTick gameTick) throws ExecutionException, InterruptedException
	{
		if (gameState == GameState.LOGGED_IN)
		{
			// This is for the command use cooldown.
			if (!coolDownFinished)
			{
				if (coolDown != -1)
				{
					coolDown++;
					
					if (coolDown == coolDownTime)
					{
						coolDownFinished = true;
						coolDown = -1;
					}
				}
			}
			
			if (permissionCheckTimer != -1)
			{
				permissionCheckTimer++;
			}
			
			if (!firstGameTick)
			{
				firstGameTick = true;
				gameTickCount = 0;
				return;
			}
			else
			{
				if (gameTickCount > -1)
				{
					gameTickCount++;
				}
			}
			
			// This is for when it's time to check permissions again and refresh the plugin data,
			// since it doesn't need to wait 5 ticks before starting like it does when first logging in.
			if (!commandProcessing && ready && attemptCount < 5 && !config.memberKey().equals("") && (permissionCheckTimer >= permissionCheckTime))
			{
				if (gameTickCount == -1)
				{
					gameTickCount = 5;
					pluginLoaded = false;
				}
			}
			
			// The plugin needs to wait 5 ticks instead of 1 after logging in before it does the initial request for the plugin's data,
			// because when it only waited 1 tick, client.getClanSettings(0) would occasionally return null and so the data wouldn't be retrieved.
			if (gameTickCount >= 5)
			{
				gameTickCount = -1;
				
				if (!commandProcessing && !pluginLoaded && !config.scriptURL().equals("") && attemptCount < 5)
				{
					commandProcessing = true;
					final String player = client.getLocalPlayer().getName();
					final String acctHash = String.valueOf(client.getAccountHash());
					int playerRank = 0;
					ClanSettings clan = client.getClanSettings();
					
					if (clan != null && clan.getName().equals("Spectral"))
					{
						if (clan.findMember(player) != null)
						{
							playerRank = clan.titleForRank(clan.findMember(player).getRank()).getId();
						}
					}
					
					final int rank = playerRank;
					
					executor.execute(() ->
					{
						try
						{
							getPluginData(rank, Text.sanitize(player), acctHash, "onGameTick");
						}
						catch (Exception e)
						{
							return;
						}
					});
				}
				else if (commandProcessing && !config.scriptURL().equals("") && !pluginLoaded && attemptCount < 5)
				{
					firstGameTick = false;
				}
				
				if (ready)
				{
					return;
				}
			}
			else
			{
				return;
			}
		}
	}
	
	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		// Update this so it only does the check once the local player has logged in even if they change the config on the loading screen.
		if (event.getGroup().equals("spectralclanmgmt") && event.getKey().equals("scriptURL"))
		{
			if (config.scriptURL().equals(""))
			{
				adminURL = "";
				discordURL = "";
				canUseDiscordCommands = false;
				canUseSpectralCommand = false;
				validAccessKey = false;
			}
			else
			{
				attemptCount = 0;
			}
			
			firstGameTick = false;
			pluginLoaded = false;
			ready = false;
		}
		else if (event.getGroup().equals("spectralclanmgmt") && event.getKey().equals("memberKey"))
		{
			if (config.memberKey().equals(""))
			{
				adminURL = "";
				canUseDiscordCommands = false;
				canUseSpectralCommand = false;
			}
			else
			{
				attemptCount = 0;
			}
			
			validAccessKey = false;
			firstGameTick = false;
			pluginLoaded = false;
			ready = false;
		}
		else if (event.getGroup().equals("spectralclanmgmt") && event.getKey().equals("registered"))
		{
			reg.clear();
			reg.putAll(getReg());
			
			attemptCount = 0;
			adminURL = "";
			validAccessKey = false;
			canUseDiscordCommands = false;
			canUseSpectralCommand = false;
			if (!config.memberKey().equals(""))
			{
				firstGameTick = false;
				pluginLoaded = false;
			}
			else
			{
				firstGameTick = true;
				gameTickCount = -1;
				pluginLoaded = true;
			}
			ready = false;
		}
		else
		{
			return;
		}
	}
	
	@Subscribe
	protected void onWidgetLoaded(WidgetLoaded widget)
	{
		if (widget.getGroupId() == CLAN_SETTINGS_INTERFACE)
		{
			if (getLocalPlayerRank(Optional.empty()) == 0)
			{
				adminURL = "";
				discordURL = "";
				return;
			}
			
			if (!isAdminRank(getLocalPlayerRank(Optional.empty())))
			{
				adminURL = "";
			}
		}
		else if (widget.getGroupId() == CLAN_SETTINGS_MEMBERS_INTERFACE)
		{
			memberWidgetLoaded = true;
			
			getMembersData();
			
			// Since this part of the plugin is meant solely for the admin members of Spectral to use, 
			// we don't want the button to be created if the local player's rank isn't an admin one.
			if (spectralAdminChecks())
			{
				// ** This method was copied from the Wise Old Man Runelite Plugin code and modified to fit this plugin's usage. 
				// All credit for the original code goes to dekvall.
				clientThread.invoke(() ->
				{
					createClanMemberButton(CLAN_SETTINGS_MEMBERS_INTERFACE_HEADER, sortedClanMembers);
					
					if (spectralClanMemberButton.isButtonCreated())
					{
						spectralClanMemberButton.enableButton();
					}
				});
				// **
			}
			else
			{
				sortedClanMembers.clear();
			}
		}
	}
	
	@Subscribe
	protected void onWidgetClosed(WidgetClosed widget)
	{
		// If the Members List widget is closed, reset everything (just in case).
		if (widget.getGroupId() == CLAN_SETTINGS_MEMBERS_INTERFACE)
		{
			if (getLocalPlayerRank(Optional.empty()) == 0)
			{
				adminURL = "";
				discordURL = "";
			}
			
			sortedClanMembers.clear();
			
			// This is being set so that whenever a request is posted, if the members list UI isn't open when the response is received,
			// the HttpRequest class will route the results to the exportDone method in this class instead of the clan mgmt button's class.
			memberWidgetLoaded = false;
			
			if (spectralClanMemberButton.isButtonCreated())
			{
				spectralClanMemberButton.destroyButton();
			}
		}
	}
	
	@Subscribe
	public void onSpectralCommand(SpectralCommand spectralCommand)
	{
		if (!spectralCommand.getSpectralCommand().equalsIgnoreCase("!key") && !spectralCommand.getSpectralCommand().equalsIgnoreCase("!addme"))
		{
			if (permissionCheckTimer == -1 || permissionCheckTimer >= permissionCheckTime)
			{
				executor.execute(() ->
				{
					try
					{
						boolean result = CompletableFuture.supplyAsync(() -> getPluginData(spectralCommand.getRank(), spectralCommand.getPlayer(), spectralCommand.getAcctHash(), spectralCommand.getSpectralCommand()))
						.thenApplyAsync(permissionResult ->
						{
							if (spectralCommand.getSpectralCommand().equalsIgnoreCase("!spectral"))
							{
								return getSpectral(spectralCommand, permissionResult);
							}
							else
							{
								return getModRecruit(spectralCommand, permissionResult);
							}
						})
						.thenApplyAsync(res ->
						{
							commandProcessing = false;
							permissionCheckTimer = 0;
							coolDown = 0;
							coolDownFinished = false;
							return res;
						})
						.join();
						
						if (result)
						{
							spectralCommand.getChatInput().resume();
						}
						else
						{
							spectralCommand.getChatInput().consume();
						}
					}
					finally
					{
						return;
					}
				});
			}
			else
			{
				executor.execute(() ->
				{
					try
					{
						boolean result = CompletableFuture.supplyAsync(() ->
						{
							if (spectralCommand.getSpectralCommand().equalsIgnoreCase("!spectral"))
							{
								return getSpectral(spectralCommand, canUseSpectralCommand);
							}
							else
							{
								return getModRecruit(spectralCommand, canUseDiscordCommands);
							}
						})
						.thenApplyAsync(res ->
						{
							commandProcessing = false;
							coolDown = 0;
							coolDownFinished = false;
							return res;
						})
						.join();
						
						if (result)
						{
							spectralCommand.getChatInput().resume();
						}
						else
						{
							spectralCommand.getChatInput().consume();
						}
					}
					finally
					{
						return;
					}
				});
			}
		}
		else if (spectralCommand.getSpectralCommand().equalsIgnoreCase("!key"))
		{
			executor.execute(() ->
			{
				try
				{
					boolean result = CompletableFuture.supplyAsync(() ->
					{
						return getAccessKey(spectralCommand.getPlayer(), spectralCommand.getAcctHash());
					})
					.thenApplyAsync(res ->
					{
						commandProcessing = false;
						coolDown = 0;
						coolDownFinished = false;
						return res;
					})
					.join();
					
					spectralCommand.getChatInput().consume();
				}
				finally
				{
					return;
				}
			});
		}
		else if (spectralCommand.getSpectralCommand().equalsIgnoreCase("!addme"))
		{
			executor.execute(() ->
			{
				try
				{
					boolean result = CompletableFuture.supplyAsync(() ->
					{
						return registerPlayerID(spectralCommand.getPlayer(), spectralCommand.getAcctHash());
					})
					.thenApplyAsync(res ->
					{
						commandProcessing = false;
						coolDown = 0;
						coolDownFinished = false;
						return res;
					})
					.join();
					
					spectralCommand.getChatInput().consume();
				}
				finally
				{
					return;
				}
			});
		}
	}
	
	// This method is a modified version of code provided by aHooder.
	private boolean getCommand(ChatInput chatInput, String message)
	{
		final String[] stringStack = client.getStringStack();
		final int[] intStack = client.getIntStack();
		int intStackCount = client.getIntStackSize();
		final int chatType = intStack[intStackCount - 2];
		int rank = 0;
		final String player = Text.sanitize(client.getLocalPlayer().getName());
		
		ClanSettings clan = client.getClanSettings(0);
		
		if (chatType == 3)
		{
			if (clan != null && clan.getName().equals("Spectral"))
			{
				rank = clan.titleForRank(clan.findMember(client.getLocalPlayer().getName()).getRank()).getId();
				final String acctHash = String.valueOf(client.getAccountHash());
				
				if (rank != 0)
				{
					if (isNormalRank(rank) || isAdminRank(rank))
					{
						if (!checkGameState(gameState))
						{
							return true;
						}
						
						if (!checkURL(config.scriptURL()))
						{
							client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "A valid URL for Spectral's web app is not set in the plugin's settings. If the issue persists when there is a valid URL set, and you're a ranked member of Spectral, contact the developer.", null);
							return true;
						}
						
						if (!message.trim().toLowerCase().equals("!key") && !message.trim().toLowerCase().equals("!addme"))
						{
							if (reg.size() < 1 || !reg.containsKey(player) || (reg.containsKey(player) && !reg.get(player)))
							{
								client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Your player ID hasn't been registered. If you're a ranked member of Spectral, use the !addme command and follow the steps to register your player ID first. If the issue persists after your player ID has been registered, contact the developer.", null);
								return true;
							}
							
							if (config.memberKey().equals(""))
							{
								client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Your access key isn't set in the plugin's settings. If you're a ranked member of Spectral, use the !key command to get your access key first. If the issue persists after your access key is set, contact the developer.", null);
								return true;
							}
							
							if (!validAccessKey)
							{
								client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Your access key is not valid. If your access key is valid and the issue persists, and you're a ranked member of Spectral, contact the developer.", null);
								return true;
							}
						}
						
						if (!message.trim().toLowerCase().equals("!key") && !message.trim().toLowerCase().equals("!addme"))
						{
							if (!commandProcessing && attemptCount < 5 && coolDownFinished && ready && validAccessKey && !config.memberKey().equals("") && reg.size() > 0 && reg.containsKey(player) && reg.get(player))
							{
								commandProcessing = true;
								coolDown = -1;
								coolDownFinished = false;
								
								if (permissionCheckTimer == -1 || permissionCheckTimer >= permissionCheckTime)
								{
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "One moment, checking permissions again. If you have permission to use this command, your command will be executed once the check is done.", null);
								}
								
								String command = message.trim().toLowerCase();
								SpectralCommand spectralCommand = new SpectralCommand(player, acctHash, rank, command, chatInput);
								eventBus.post(spectralCommand);
							}
							else
							{
								// This could occur if they try to use a command right after the logging in when the plugin is still pulling the data.
								if (commandProcessing && !ready)
								{
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "You can't use Spectral's commands right now. Wait a minute before trying again.", null);
								}
								else if (attemptCount >= 5)
								{
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "The command couldn't be completed because your permissions couldn't be verified. Make sure your player ID is registered, and a valid URL for Spectral's web app and your access key are set in the plugin's settings first. If the issue persists and your player ID is registered, the URL and access key are valid, and you're a ranked member of Spectral, contact the developer.", null);
								}
								else if (reg.size() < 1 || !reg.containsKey(player) || (reg.containsKey(player) && !reg.get(player)))
								{
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "The command couldn't be completed because your player ID hasn't been registered. If you're a ranked member of Spectral, use the !addme command and follow the steps to register your player ID first. If the issue persists after your player ID has been registered, contact the developer.", null);
								}
								else if (!coolDownFinished)
								{
									String msg = "";
									
									if (coolDown != -1)
									{
										int waitTime = (int)Math.round(0.6 * (coolDownTime - coolDown));
										
										if (waitTime > 1 || waitTime < 1)
										{
											msg = "You need to wait " + waitTime + " more seconds before you can use one of Spectral's commands again.";
										}
										else if (waitTime == 1)
										{
											msg = "You need to wait " + waitTime + " more second before you can use one of Spectral's commands again.";
										}
									}
									else
									{
										msg = "You need to wait for the previous command to finish before you can use one of Spectral's commands again.";
									}
									
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, null);
								}
								else if (!ready)
								{
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "The plugin's data hasn't finished loading yet. Wait a minute before trying again.", null);
								}
								else if (!validAccessKey || config.memberKey().equals(""))
								{
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "The command couldn't be completed because your access key is invalid. If you're a ranked member of Spectral, use the !key command to get your access key first. If your access key is valid and the issue persists, contact the developer.", null);
								}
							}
						}
						else if (message.trim().toLowerCase().equals("!key"))
						{
							if (!commandProcessing && attemptCount < 5 && coolDownFinished && !validAccessKey && reg.size() > 0 && reg.containsKey(player) && reg.get(player))
							{
								commandProcessing = true;
								coolDown = -1;
								coolDownFinished = false;
								
								String command = message.trim().toLowerCase();
								SpectralCommand spectralCommand = new SpectralCommand(player, acctHash, rank, command, chatInput);
								eventBus.post(spectralCommand);
							}
							else
							{
								if (commandProcessing)
								{
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "You can't use Spectral's commands right now. Wait a minute before trying again.", null);
								}
								else if (attemptCount >= 5)
								{
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "The command couldn't be completed because your permissions couldn't be verified. Make sure your player ID is registered, and a valid URL for Spectral's web app and your access key are set in the plugin's settings first. If the issue persists and your player ID is registered, the URL and access key are valid, and you're a ranked member of Spectral, contact the developer.", null);
								}
								else if (reg.size() < 1 || !reg.containsKey(player) || (reg.containsKey(player) && !reg.get(player)))
								{
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "The command couldn't be completed because your player ID hasn't been registered. Use the !addme command and follow the steps to register your player ID first. If the issue persists after your player ID has been registered, and you're a ranked member of Spectral, contact the developer.", null);
								}
								else if (!coolDownFinished)
								{
									String msg = "";
									
									if (coolDown != -1)
									{
										int waitTime = (int)Math.round(0.6 * (coolDownTime - coolDown));
										
										if (waitTime > 1 || waitTime < 1)
										{
											msg = "You need to wait " + waitTime + " more seconds before you can use one of Spectral's commands again.";
										}
										else if (waitTime == 1)
										{
											msg = "You need to wait " + waitTime + " more second before you can use one of Spectral's commands again.";
										}
									}
									else
									{
										msg = "You need to wait for the previous command to finish before you can use one of Spectral's commands again.";
									}
									
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, null);
								}
								else if (validAccessKey)
								{
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "You already have a valid access key, there's no reason for you to use this command.", null);
								}
							}
						}
						else if (message.trim().toLowerCase().equals("!addme"))
						{
							if (!commandProcessing && attemptCount < 5 && coolDownFinished && (reg.size() < 1 || !reg.containsKey(player) || (reg.containsKey(player) && !reg.get(player))))
							{
								commandProcessing = true;
								coolDown = -1;
								coolDownFinished = false;
								
								String command = message.trim().toLowerCase();
								SpectralCommand spectralCommand = new SpectralCommand(player, acctHash, rank, command, chatInput);
								eventBus.post(spectralCommand);
							}
							else
							{
								if (commandProcessing)
								{
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "You can't use Spectral's commands right now. Wait a minute before trying again.", null);
								}
								else if (attemptCount >= 5)
								{
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "The command couldn't be completed because your permissions couldn't be verified. Make sure your player ID is registered, and a valid URL for Spectral's web app and your access key are set in the plugin's settings first. If the issue persists and your player ID is registered, the URL and access key are valid, and you're a ranked member of Spectral, contact the developer.", null);
								}
								else if (!coolDownFinished)
								{
									String msg = "";
									
									if (coolDown != -1)
									{
										int waitTime = (int)Math.round(0.6 * (coolDownTime - coolDown));
										
										if (waitTime > 1 || waitTime < 1)
										{
											msg = "You need to wait " + waitTime + " more seconds before you can use one of Spectral's commands again.";
										}
										else if (waitTime == 1)
										{
											msg = "You need to wait " + waitTime + " more second before you can use one of Spectral's commands again.";
										}
									}
									else
									{
										msg = "You need to wait for the previous command to finish before you can use one of Spectral's commands again.";
									}
									
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, null);
								}
								else if (reg.size() > 0 && reg.containsKey(player) && reg.get(player))
								{
									client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "You've already registered your player ID, there's no reason for you to use this command.", null);
								}
							}
						}
					}
				}
			}
			
			if (clan == null || (clan != null && !clan.getName().equals("Spectral")) || rank == 0 || (rank != 0 && !isNormalRank(rank) && !isAdminRank(rank)))
			{
				adminURL = "";
				discordURL = "";
				canUseSpectralCommand = false;
				canUseDiscordCommands = false;
				validAccessKey = false;
				pluginLoaded = true;
				commandProcessing = false;
				ready = true;
				attemptCount = 5;
				
				if (spectralPhrases != null)
				{
					spectralPhrases.setPhrases(null);
				}
				
				if (reg.size() > 0 && reg.containsKey(player))
				{
					updateReg(player, "", "delete");
				}
			}
		}
		
		return true;
	}
	
	// This method is a modified version of code provided by aHooder.
	private void showCommand(ChatMessage chatMessage, String message)
	{
		// In case these commands are ever seen outside of the clan chat, don't replace the command text in the chat.
		if (chatMessage.getType() != ChatMessageType.CLAN_CHAT)
		{
			return;
		}
		
		if (config.memberKey().equals(""))
		{
			return;
		}
		
		if (!validAccessKey)
		{
			return;
		}
		
		MessageNode messageNode = chatMessage.getMessageNode();
		
		if (messageNode.getValue().trim().equalsIgnoreCase("!recruit") || messageNode.getValue().trim().equalsIgnoreCase("!mod") || messageNode.getValue().trim().equalsIgnoreCase("!spectral"))
		{
			final String sender = Text.removeTags(messageNode.getName());
			int playerRank = getLocalPlayerRank(Optional.empty());
			int senderRank = getLocalPlayerRank(Optional.of(sender));
			
			if (playerRank == 0 || senderRank == 0)
			{
				return;
			}
			
			updateChat(messageNode);
		}
		else
		{
			return;
		}
	}
	
	protected void updateChat(MessageNode message)
	{
		String result = "";
		
		if (message.getValue().trim().equalsIgnoreCase("!recruit"))
		{
			result = "I pinged the recruiters in Discord for help!";
		}
		else if (message.getValue().trim().equalsIgnoreCase("!mod"))
		{
			result = "I pinged the mods in Discord for help!";
		}
		else if (message.getValue().trim().equalsIgnoreCase("!spectral"))
		{
			if (spectralPhrases != null && spectralPhrases.getPhrases() != null && spectralPhrases.getPhrases().length > 0)
			{
				// Get a randomly picked phrase from the phrases array. The phrase will replace the command text in the clan chat for the local player.
				Random ran = new Random();
				int rn = ran.nextInt(spectralPhrases.getPhrases().length);
				
				if (previousPhrasePosition != -1)
				{
					while (rn == previousPhrasePosition)
					{
						rn = ran.nextInt(spectralPhrases.getPhrases().length);
					}
				}
				
				previousPhrasePosition = rn;
				result = spectralPhrases.getPhrases()[rn];
			}
			else
			{
				result = "Uh oh, no phrases found! ;^;";
			}
		}
		
		final String cInput = result;
		
		String response = new ChatMessageBuilder()
		.append(ChatColorType.NORMAL)
		.append(cInput)
		.build();
		
		message.setRuneLiteFormatMessage(response);
		client.refreshChat();
	}
	
	protected boolean spectralAdminChecks()
	{
		if (config.memberKey().equals(""))
		{
			return false;
		}
		
		if (!validAccessKey)
		{
			return false;
		}
		
		clanSettings = client.getClanSettings(0);
		
		if (clanSettings.getName().equals("Spectral"))
		{
			// Since this part of the plugin is meant solely for the admin members of Spectral to use, 
			// we don't want the button to be created if the local player's rank isn't an admin one and they don't have their access key.
			if (isAdminRank(getLocalPlayerRank(Optional.empty())))
			{
				if (checkURL(adminURL))
				{
					if (sortedClanMembers != null)
					{
						if (sortedClanMembers.size() > 0)
						{
							return true;
						}
					}
				}
			}
		}
		
		return false;
	}
	
	// Checks if the string passed to the method is a valid URL. If it's missing, or it's not a valid URL, it'll return false
	// so we can respond and block the execution from continuing before an HttpRequest is created.
	protected static boolean checkURL(String URL)
	{
		String scriptURL = URL.trim();
		boolean isValid = false;
		
		if (!scriptURL.equals(""))
		{
			// For Spectral's purposes, there's no reason for the protocol to be anything other than http or https.
			Pattern urlRegexPattern = Pattern.compile("^((http|https)://)?([a-zA-Z0-9]+[.])?[a-zA-Z0-9-]+(.[a-zA-Z]{2,6})?(:[0-9]{1,5})?(/[a-zA-Z0-9-._?,'+&%$#=~]*)*$");
			isValid = urlRegexPattern.matcher(scriptURL).matches();
		}
		
		return isValid;
	}
	
	protected HashMap<String, Boolean> getReg()
	{
		HashMap<String, Boolean> regs = new HashMap<String, Boolean>();
		
		String registered = config.registered();
		
		if (!registered.equals(""))
		{
			String[] entries = registered.split(",");
			
			for (String entry : entries)
			{
				String[] pair = entry.split(":");
				
				if (pair.length == 2)
				{
					regs.put(pair[0], Boolean.valueOf(pair[1]));
				}
			}
		}
		
		return regs;
	}
	
	protected void updateReg(String player, String result, String action)
	{
		String registered = config.registered();
		
		if (action.equals("add"))
		{
			if (registered.contains(player + ":true,"))
			{
				registered.replace(player + ":true,", player + ":" + result + ",");
			}
			else if (registered.contains(player + ":false,"))
			{
				registered.replace(player + ":false,", player + ":" + result + ",");
			}
			else if (!registered.contains(player + ":true,") && !registered.contains(player + ":false,"))
			{
				registered = registered + player + ":" + result + ",";
			}
		}
		else if (action.equals("delete"))
		{
			if (!registered.equals(""))
			{
				if (registered.contains(player + ":true,"))
				{
					registered.replace(player + ":true,", "");
				}
				else if (registered.contains(player + ":false,"))
				{
					registered.replace(player + ":false,", "");
				}
			}
		}
		
		config.setRegistered(registered);
	}
	
	private Boolean getPluginData(int rank, String player, String acctHash, String src)
	{
		return CompletableFuture.supplyAsync(() ->
		{
			if (rank == 0 || (!isNormalRank(rank) && !isAdminRank(rank)))
			{
				return "perma-fail;You don't have permission to use this plugin.";
			}
			
			if (attemptCount >= 5)
			{
				return "attempt-fail;The plugin has made the max allowed attempts to retrieve its data.";
			}
			
			if (rank != 0 && (isNormalRank(rank) || isAdminRank(rank)) && (config.registered().equals("") || reg.size() < 1 || !reg.containsKey(player) || (reg.containsKey(player) && !reg.get(player))))
			{
				return "reg-fail";
			}
			
			if (!checkURL(config.scriptURL()))
			{
				return "url-fail;A valid URL for Spectral's web app is not set in the plugin's settings. If the issue persists when there is a valid URL set, and you're a ranked member of Spectral, contact the developer.";
			}
			
			if (config.memberKey().equals(""))
			{
				return "key-fail;Your access key isn't set in the plugin's settings. If you're a ranked member of Spectral, use the !key command to get your access key first. If the issue persists after your access key is set, contact the developer.";
			}
			
			if (isNormalRank(rank))
			{
				adminURL = "";
			}
			
			String configLink = "";
			
			if (isNormalRank(rank))
			{
				configLink = "discord";
			}
			else if (isAdminRank(rank))
			{
				configLink = "both";
			}
			
			return configLink;
		})
		.thenApplyAsync(configLink ->
		{
			return httpRequest.getRequestAsyncPluginData(configLink, player, acctHash);
		})
		.thenApplyAsync(res ->
		{
			String[] result = res.split("\\;");
			
			if (result[0].equalsIgnoreCase("perma-fail") || result[0].equalsIgnoreCase("url-fail"))
			{
				adminURL = "";
				discordURL = "";
				
				if (spectralPhrases != null)
				{
					spectralPhrases.setPhrases(null);
				}
				
				canUseSpectralCommand = false;
				canUseDiscordCommands = false;
				validAccessKey = false;
				pluginLoaded = true;
				attemptCount = 5;
				ready = true;
			}
			else if (result[0].equalsIgnoreCase("attempt-fail") || result[0].equalsIgnoreCase("reg-fail") || result[0].equalsIgnoreCase("key-fail"))
			{
				pluginLoaded = true;
				ready = true;
			}
			else if (result[0].equalsIgnoreCase("failure"))
			{
				attemptCount = 5;
				pluginLoaded = true;
				ready = true;
			}
			else if (result[0].equalsIgnoreCase("resp-failure"))
			{
				attemptCount++;
				
				if (attemptCount < 5)
				{
					ready = false;
					firstGameTick = false;
					pluginLoaded = false;
				}
				else
				{
					pluginLoaded = true;
					ready = true;
				}
			}
			else if (result[0].equalsIgnoreCase("success"))
			{
				attemptCount = 0;
				pluginLoaded = true;
				ready = true;
			}
			
			if (result[0].equalsIgnoreCase("perma-fail"))
			{
				if (reg.size() > 0 && reg.containsKey(player))
				{
					updateReg(player, "", "delete");
				}
			}
			
			if (src.equalsIgnoreCase("onGameTick"))
			{
				commandProcessing = false;
				clientThread.invokeLater(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", result[1], null));
			}
			else if (src.equalsIgnoreCase("!spectral") && result[0].equalsIgnoreCase("success"))
			{
				return canUseSpectralCommand;
			}
			else if ((src.equalsIgnoreCase("!mod") || src.equalsIgnoreCase("!recruit")) && result[0].equalsIgnoreCase("success"))
			{
				return canUseDiscordCommands;
			}
			
			return false;
			
		}).join();
	}
	
	protected String setPluginData(Response response) throws IOException
	{
		if (spectralPhrases != null)
		{
			spectralPhrases.setPhrases(null);
		}
		
		if (!response.isSuccessful())
		{
			return "resp-failure;An error occurred. The request either wasn't received or it wasn't accepted.";
		}
		
		JsonObject resp;
		String stat = "";
		String res = "";
		
		try
		{
			resp = gson.fromJson(response.body().charStream(), JsonObject.class);
		}
		catch (JsonSyntaxException ex)
		{
			return "resp-failure;An error occurred. Response body wasn't a JSON string.";
		}
		
		if (resp == null)
		{
			validAccessKey = false;
			canUseSpectralCommand = false;
			canUseDiscordCommands = false;
			discordURL = "";
			adminURL = "";
			return "resp-failure;Something went wrong and the plugin's data couldn't be retrieved. If you're a ranked member of Spectral, contact the developer about this issue.";
		}
		
		canUseSpectralCommand = false;
		canUseDiscordCommands = false;
		discordURL = "";
		adminURL = "";
		
		stat = resp.get("status").getAsString();
		JsonArray permission = resp.get("permission").getAsJsonArray();
		int permissionTime = resp.get("permissionTime").getAsInt();
		int downTime = resp.get("downTime").getAsInt();
		
		validAccessKey = permission.get(0).getAsBoolean();
		JsonArray conLink = resp.get("configLink").getAsJsonArray();
		String[] links = new String[conLink.size()];
		
		if (validAccessKey)
		{
			canUseSpectralCommand = permission.get(1).getAsBoolean();
			canUseDiscordCommands = permission.get(2).getAsBoolean();
			String phraseList = resp.get("phrases").getAsString();
			
			links[0] = String.valueOf(conLink.get(0));
			links[1] = String.valueOf(conLink.get(1));
			
			if (!links[0].equals(""))
			{
				discordURL = links[0].substring(1, links[0].length() - 1);
			}
			
			if (!links[1].equals(""))
			{
				adminURL = links[1].substring(1, links[1].length() - 1);
			}
			
			if (phraseList.trim() != "")
			{
				String[] phrases = phraseList.split("\\;");
				
				if (spectralPhrases != null)
				{
					spectralPhrases.setPhrases(phrases);
				}
				else
				{
					spectralPhrases = new SpectralClanMgmtCommandPhrases();
					spectralPhrases.setPhrases(phrases);
				}
			}
		}
		
		if (stat.equalsIgnoreCase("reg-fail"))
		{
			links[0] = String.valueOf(conLink.get(0));
			discordURL = links[0].substring(1, links[0].length() - 1);
		}
		
		if (permissionTime > 0)
		{
			permissionCheckTime = permissionTime;
		}
		
		if (downTime > 0)
		{
			coolDownTime = downTime;
		}
		
		permissionCheckTimer = 0;
		
		String result = "";
		
		if (stat.equalsIgnoreCase("success"))
		{
			result = ";The plugin's data was successfully retrieved and set.";
		}
		else if (stat.equalsIgnoreCase("failure"))
		{
			result = ";" + resp.get("reason").getAsString();
		}
		else if (stat.equalsIgnoreCase("reg-fail"))
		{
			result = ";Your player ID hasn't been registered. If you're a ranked member of Spectral, use the !addme command and follow the steps to register your player ID first. If the issue persists after your player ID has been registered, contact the developer.";
		}
		
		return stat + result;
	}
	
	// Clears and populates the members and membersJoinDates hashmaps with sorted values.
	// These will be used after this finishes.
	private void getMembersData()
	{
		clanSettings = client.getClanSettings();
		
		// We clear and set these every time this is run, because it's only called when the members list UI is loaded.
		sortedClanMembers.clear();
		
		if (clanSettings != null)
		{
			List<ClanMember> clanMembers = clanSettings.getMembers();
			
			Collections.sort(clanMembers, (m1, m2) -> m1.getName().compareToIgnoreCase(m2.getName()));
			
			int i = 0;
			
			// Now that we've got a sorted list of member names, we'll put them into a hashmap, 
			// using i to act as an index for the members. This will be used later in the button's class.
			for (ClanMember cm : clanMembers)
			{
				sortedClanMembers.put(i, cm);
				i++;
			}
		}
	}
	
	// ** This method was copied from the Wise Old Man Runelite Plugin code and rewritten to fit this plugin's usage. 
	// All credit for the original code goes to dekvall.
	private void createClanMemberButton(int w, HashMap<Integer, ClanMember> clanmembers)
	{
		ClanSettings clanSettings = client.getClanSettings(0);
		spectralClanMemberButton.createButton(w, clanmembers, clanSettings);
	}
	// **
	
	protected int getLocalPlayerRank(Optional<String> playerName)
	{
		int rank = 0;
		
		if (client.getClanSettings(0) != null && client.getClanSettings(0).getName().equals("Spectral"))
		{
			String player = playerName.orElse(client.getLocalPlayer().getName());
			
			if (client.getClanSettings(0).findMember(player) != null)
			{
				rank = client.getClanSettings(0).titleForRank(client.getClanSettings(0).findMember(player).getRank()).getId();
			}
		}
		
		return rank;
	}
	
	protected static boolean isAdminRank(int rank)
	{
		// The clan's admin ranks. The numbers are the key values in the ranks enum for the 
		// Owner, Deputy Owner, Moderator, and Completionist (Recruiter) ranks.
		ArrayList<Integer> adminRanks = new ArrayList<>(Arrays.asList(-4, -3, 264, 252));
		
		if (adminRanks.contains(rank))
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	
	protected static boolean isNormalRank(int rank)
	{
		// The clan's non-admin ranks. The numbers are the key values in the ranks enum for the 
		// Gnome Child, Lieutenant, Captain, General, Colonel, Brigadier, Admiral, Marshal, Astral, Soul, 
		// Sapphire, Emerald, Ruby, Diamond, Dragonstone, Onyx, Zenyte, Paladin, Skiller, Armadylean, TzKal, and Assistant ranks.
		ArrayList<Integer> normalRanks = new ArrayList<>(Arrays.asList(9, 35, 37, 39, 43, 44, 45, 46, 58, 60, 65, 66, 67, 68, 69, 70, 71, 111, 143, 161, 179, 227));
		
		if (normalRanks.contains(rank))
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	
	private boolean checkGameState(GameState game)
	{
		if (game == GameState.LOGIN_SCREEN)
		{
			attemptCount = 0;
			coolDown = -1;
			coolDownFinished = true;
			permissionCheckTimer = -1;
			firstGameTick = false;
			gameTickCount = 0;
			ready = false;
			pluginLoaded = false;
			commandProcessing = false;
			adminURL = "";
			discordURL = "";
			canUseSpectralCommand = false;
			canUseDiscordCommands = false;
			previousPhrasePosition = -1;
			
			if (spectralPhrases != null)
			{
				spectralPhrases.setPhrases(null);
			}
		}
		
		if (game == GameState.LOGGED_IN)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	
	private Boolean getSpectral(SpectralCommand spectralCommand, boolean perm)
	{
		String player = spectralCommand.getPlayer();
		boolean flag = false;
		String msg = "";
		
		if (!perm || config.memberKey().equals("") || !validAccessKey)
		{
			msg = "You aren't allowed to use this plugin's commands. Contact the developer if you're a ranked member of the Spectral clan and you see this message.";
			flag = true;
		}
		else if (spectralPhrases == null || (spectralPhrases != null && spectralPhrases.getPhrases() == null) || (spectralPhrases != null && spectralPhrases.getPhrases() != null && spectralPhrases.getPhrases().length == 0))
		{
			msg = "No phrases found for the command. Contact the developer about this issue.";
			flag = true;
		}
		
		if (flag)
		{
			final String message = msg;
			clientThread.invokeLater(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, null));
			return false;
		}
		else
		{
			return true;
		}
	}
	
	private Boolean getModRecruit(SpectralCommand spectralCommand, boolean perm)
	{
		String player = spectralCommand.getPlayer();
		String msg = "";
		boolean flag = false;
		
		if (!checkURL(config.scriptURL()))
		{
			msg = "The URL for Spectral's Web App is either missing or not valid. Contact the developer about this issue.";
			flag = true;
		}
		else if (!perm || config.memberKey().equals("") || !validAccessKey)
		{
			msg = "You aren't allowed to use this plugin's commands. If you're a ranked member of the Spectral clan, contact the developer.";
			flag = true;
		}
		
		if (flag)
		{
			final String message = msg;
			clientThread.invokeLater(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, null));
			return false;
		}
		else
		{
			CompletableFuture<Boolean> future = httpRequest.postRequestAsyncRecruitMod("discord", spectralCommand.getSpectralCommand(), player, spectralCommand.getAcctHash())
			.thenApply(result ->
			{
				String[] results = result.split("\\;");
				
				if (!results[0].equalsIgnoreCase("success"))
				{
					clientThread.invokeLater(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", results[1], null));
					return false;
				}
				
				return true;
			});
			
			return future.join();
		}
	}
	
	// The response from the http requests from both the !recruit and the !mod commands will be passed to this method.
	protected String setModRecruit(Response response) throws IOException
	{
		if (!response.isSuccessful())
		{
			return "failure;An error occurred. The request either wasn't received or it wasn't accepted.";
		}
		
		JsonObject resp;
		
		try
		{
			resp = gson.fromJson(response.body().charStream(), JsonObject.class);
		}
		catch (JsonSyntaxException ex)
		{
			return "failure;An error occurred. Response body wasn't a JSON string.";
		}
		
		String stat = "";
		String dat = "";
		
		if (resp == null)
		{
			stat = "failure";
			dat = "Something went wrong and the command couldn't be completed. If you're a ranked member of Spectral, contact the developer about this issue.";
		}
		else
		{
			stat = resp.get("status").getAsString();
			dat = resp.get("data").getAsString();
		}
		
		return stat + ";" + dat;
	}
	
	private Boolean registerPlayerID(String player, String acctHash)
	{
		if (!checkURL(discordURL))
		{
			clientThread.invokeLater(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "The URL for Spectral's Discord App is either missing or not valid. If you're a ranked member of Spectral, contact the developer about this issue.", null));
			return false;
		}
		else
		{
			clientThread.invoke(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Spectral's bot will ping you in the clan's Discord server. You have 5 minutes to click the button in the post the bot pinged you in to confirm you initiated the request. Once confirmed, your player ID will be registered.", null));
			
			CompletableFuture<Boolean> future = httpRequest.postRequestAsyncRegisterPlayerID("addme", player, acctHash)
			.thenApply(result ->
			{
				String[] results = result.split("\\;");
				
				clientThread.invokeLater(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", results[1], null));
				
				if (!results[0].equalsIgnoreCase("success"))
				{
					return false;
				}
				
				return true;
			});
			
			return future.join();
		}
	}
	
	protected String updateRegistered(String player, Response response) throws IOException
	{
		if (!response.isSuccessful())
		{
			return "failure;An error occurred. The request either wasn't received or it wasn't accepted.";
		}
		
		JsonObject resp;
		
		try
		{
			resp = gson.fromJson(response.body().charStream(), JsonObject.class);
		}
		catch (JsonSyntaxException ex)
		{
			return "failure;An error occurred. Response body wasn't a JSON string.";
		}
		
		if (resp == null)
		{
			return "failure;Something went wrong and your player ID couldn't be registered. If you're a ranked member of Spectral, contact the developer about this issue.";
		}
		
		String stat = resp.get("status").getAsString();
		String dat = resp.get("data").getAsString();
		String res = resp.get("registered").getAsString();
		String result = stat + ";" + dat;
		
		if (stat.equalsIgnoreCase("success") && config.memberKey().equals(""))
		{
			result = result + " You can use the !key command now to get your access key.";
		}
		
		updateReg(player, res, "add");
		return result;
	}
	
	private Boolean getAccessKey(String player, String acctHash)
	{
		if (!checkURL(config.scriptURL()))
		{
			clientThread.invokeLater(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "The URL for Spectral's Web App is either missing or not valid. If you're a ranked member of Spectral, contact the developer about this issue.", null));
			return false;
		}
		else
		{
			CompletableFuture<Boolean> future = httpRequest.postRequestAsyncAccessKey("get-key", player, acctHash)
			.thenApply(result ->
			{
				String[] results = result.split("\\;");
				
				clientThread.invokeLater(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", results[1], null));
				
				if (!results[0].equalsIgnoreCase("success"))
				{
					return false;
				}
				
				return true;
			});
			
			return future.join();
		}
	}
	
	protected String setAccessKey(Response response) throws IOException
	{
		if (!response.isSuccessful())
		{
			return "failure;An error occurred. The request either wasn't received or it wasn't accepted.";
		}
		
		JsonObject resp;
		
		try
		{
			resp = gson.fromJson(response.body().charStream(), JsonObject.class);
		}
		catch (JsonSyntaxException ex)
		{
			return "failure;An error occurred. Response body wasn't a JSON string.";
		}
		
		String stat = "";
		String dat = "";
		
		if (resp == null)
		{
			validAccessKey = false;
			stat = "failure";
			dat = "Something went wrong and your access key couldn't be found. If you're a ranked member of Spectral, contact the developer about this issue.";
		}
		else
		{
			stat = resp.get("status").getAsString();
			dat = resp.get("data").getAsString();
		}
		
		String result = "";
		
		if (stat.equalsIgnoreCase("success"))
		{
			if (!dat.equals(""))
			{
				config.setMemberKey(dat);
				validAccessKey = true;
				result = stat + ";Your access key was set.";
			}
			else
			{
				validAccessKey = false;
				config.setMemberKey("");
				result = stat + ";Something went wrong during the access key request. If you're a ranked member of Spectral, contact the developer about this issue.";
			}
		}
		else
		{
			result = stat + ";" + dat;
			validAccessKey = false;
			config.setMemberKey("");
		}
		
		return result;
	}
}
package com.spectralclanmgmt;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonSyntaxException;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanSettings;
import net.runelite.api.*;
import net.runelite.api.widgets.*;
import net.runelite.client.util.Text;
import okhttp3.Response;
import javax.inject.Inject;
import java.io.IOException;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

public class SpectralClanMgmtButton
{
	@Inject
	private Gson gson;
	private SpectralClanMgmtPlugin plugin;
	private SpectralClanMgmtConfig config;
	private final Client client;
	private ClanSettings clanSettings;
	private final SpectralChatboxPanel chatboxPanelManager;
	private final SpectralClanMgmtHttpRequest httpRequest;
	private Widget parent;
	private boolean wasClicked = false;
	private boolean listenersSet = false;
	private boolean firstMemberSelected = false;
	private boolean secondMemberSelected = false;
	private String task;
	private String firstMemberName;
	private String firstMemberDate;
	private String secondMemberName;
	private String category;
	private int adminRank = 0;
	private final List<Widget> cornersAndEdges = new ArrayList<>();
	private Widget textWidget;
	private HashMap<Integer, ClanMember> clanmembers = new HashMap<Integer, ClanMember>();
	private boolean buttonCreated;
	
	@Inject
	protected SpectralClanMgmtButton(SpectralClanMgmtPlugin plugin, SpectralChatboxPanel chatboxPanelManager, SpectralClanMgmtConfig config, Client client, SpectralClanMgmtHttpRequest httpRequest, Gson gson)
	{
		this.plugin = plugin;
		this.httpRequest = httpRequest;
		this.chatboxPanelManager = chatboxPanelManager;
		this.config = config;
		this.client = client;
		this.textWidget = null;
		this.buttonCreated = false;
		task = "";
		firstMemberName = "";
		firstMemberDate = "";
		secondMemberName = "";
		category = "";
		this.gson = gson;
		this.httpRequest.setButton(this);
	}
	
	public void createButton(int parent, HashMap<Integer, ClanMember> clanmembers, ClanSettings clanSettings)
	{
		this.clanmembers = clanmembers;
		this.clanSettings = clanSettings;
		this.parent = client.getWidget(parent);
		
		// **
		// The following code segment was copied from the Wise Old Man Runelite Plugin and modified. 
		// All credit for this code segment goes to dekvall.
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT, 153, 6, 9, 9);
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT, 38, 6, 9, 9);
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT, 153, 20, 9, 9);
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT, 38, 20, 9, 9);
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT, 153, 15, 9, 5);
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_EDGE_TOP, 47, 6, 106, 9);
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT, 38, 15, 9, 5);
		this.createWidgetWithSprite(SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM, 47, 20, 106, 9);
		this.textWidget = this.createWidgetWithText();
		// **
		
		this.buttonCreated = true;
	}
	
	// ** This method was copied from the Wise Old Man Runelite Plugin and modified. 
	// All credit for this code segment goes to dekvall.
	private void createWidgetWithSprite(int spriteId, int x, int y, int width, int height)
	{
		Widget w = this.parent.createChild(-1, WidgetType.GRAPHIC);
		
		w.setSpriteId(spriteId);
		w.setOriginalX(x);
		w.setOriginalY(y);
		w.setOriginalWidth(width);
		w.setOriginalHeight(height);
		w.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT);
		w.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
		w.revalidate();
		cornersAndEdges.add(w);
	}
	// **
	
	// ** This method was copied from the Wise Old Man Runelite Plugin and modified. 
	// All credit for this code segment goes to dekvall.
	private Widget createWidgetWithText()
	{
		Widget textWidget = this.parent.createChild(-1, WidgetType.TEXT);
		
		textWidget.setOriginalX(38);
		textWidget.setOriginalY(6);
		textWidget.setOriginalWidth(124);
		textWidget.setOriginalHeight(23);
		textWidget.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT);
		textWidget.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
		textWidget.setXTextAlignment(WidgetTextAlignment.CENTER);
		textWidget.setYTextAlignment(WidgetTextAlignment.CENTER);
		textWidget.setText("<col=9f9f9f>" + "Export Clan Member" + "</col>");
		textWidget.setFontId(FontID.PLAIN_11);
		textWidget.setTextShadowed(true);
		textWidget.setHasListener(true);
		textWidget.setOnMouseOverListener((JavaScriptCallback) e -> update(true));
		textWidget.setOnMouseLeaveListener((JavaScriptCallback) e -> update(false));
		textWidget.revalidate();
		
		return textWidget;
	}
	// **
	
	protected void destroyButton()
	{
		wasClicked = false;
		this.textWidget = null;
		this.buttonCreated = false;
		clanmembers.clear();
	}
	
	protected boolean isButtonCreated()
	{
		if (this.textWidget != null)
		{
			this.buttonCreated = true;
		}
		else
		{
			this.buttonCreated = false;
		}
		
		return this.buttonCreated;
	}
	
	// ** This method was copied from the Wise Old Man Runelite Plugin code and modified. 
	// All credit for the original code goes to dekvall.
	private void update(boolean hovered)
	{
		if (this.textWidget != null)
		{
			for (Widget w : cornersAndEdges)
			{
				int spriteId = w.getSpriteId();
				w.setSpriteId(hovered ? spriteId + 8 : spriteId - 8);
				w.revalidate();
			}
		}
	}
	// **
	
	// We need to convert the member's LocalDate type joinDate value from the ClanMember class into the correct number of epoch seconds.
	// To do this, we get the epoch seconds of the LocalDate value, then multiply that number by 1000.
	// With the new total epoch seconds, we'll get the right date when we convert it to a date value for the specified time zone.
	private String convertJoinDate(ClanMember member)
	{
		long joined = member.getJoinDate().atStartOfDay(ZoneId.of("Europe/Belfast")).toEpochSecond() * 1000L;
		ZonedDateTime convertedJoinDate = Instant.ofEpochMilli(joined).atZone(ZoneId.of("America/New_York"));
		String spectralJoinDate = convertedJoinDate.format(DateTimeFormatter.ofPattern("M/d/uuuu"));
		return spectralJoinDate;
	}
	
	// The method for the click listeners on the member names child widgets of the member names column.
	// Depending on the option the user first selected, different methods will be run.
	// The user can either select a new main or a new alt (along with the new alt's main in the clan), or a member for a name chang export.
	// The first member selection is essentially the same, we use the value of j to get the index of the member's name in the hashmap. 
	// For new member (Main or Alt) exports, we use the member's name to get their join date. 
	// The join date has already been converted into a date string for the EST/EDT timezone.
	// For selecting the Main member of a new Alt member export, we only need the selected main's name from the hashmap.
	private void getSelectedMember(int j)
	{
		if (task.equalsIgnoreCase("add-new")) // adding a new main task
		{
			if (!firstMemberSelected)
			{
				// j is for the position of the child widget in the children array. 
				// sn is the calculated index value that acts as the key for the member's name in the clanmembers hashmap.
				// So if j = 1, then sn will be 0. If j = 7, sn will be 2.
				int sn = (j - 1) / 3;
				
				if (clanmembers != null)
				{
					if (clanmembers.size() > 0)
					{
						// With the slot number, we get the selected member's name, 
						// and with the member's name we get their join date and store it in these variables for later.
						ClanMember selectedNewMember = clanmembers.get(sn);
						String selectedNewMemberDate = "";
						
						if (selectedNewMember != null)
						{
							selectedNewMemberDate = convertJoinDate(selectedNewMember);
						}
						
						if (selectedNewMember != null && !selectedNewMemberDate.equals(""))
						{
							int memberRank = clanSettings.titleForRank(selectedNewMember.getRank()).getId();
							
							if (memberRank == 9 || memberRank == -1) // 9 is for the Alt rank. -1 is for the Guest rank. Mains can't have either of these ranks.
							{
								// This occurs if the admin selected a member that has the rank for Alt accounts, which is a no-no for mains.
								task = "invalid-new";
								firstMemberName = selectedNewMember.getName();
							}
							else if (memberRank != 9 && (SpectralClanMgmtPlugin.isNormalRank(memberRank) || SpectralClanMgmtPlugin.isAdminRank(memberRank)))
							{
								// Flip the flag and set the local variable values to their corresponding global variables.
								firstMemberSelected = true;
								firstMemberName = selectedNewMember.getName();
								firstMemberDate = selectedNewMemberDate;
								// Proceed to the next step.
								confirmSelection();
								return;
							}
						}
					}
				}
				
				// We should only reach this point if the member selected wasn't a valid choice.
				// If the task wasn't already changed, then it means the task's value is meant to be "error".
				if (task.equalsIgnoreCase("add-new"))
				{
					task = "error";
				}
				
				if (!task.equalsIgnoreCase("add-new"))
				{
					if (task.equalsIgnoreCase("error"))
					{
						firstMemberName = "";
					}
					
					firstMemberSelected = false;
					firstMemberDate = "";
					// Proceed to the next step.
					displayError();
					return;
				}
				
			}
		}
		else if (task.equalsIgnoreCase("add-alt-get-new")) // first half of the add-alt overall task
		{
			// We're getting the new alt member here
			if (!firstMemberSelected)
			{
				int sn = (j - 1) / 3;
				
				if (clanmembers != null)
				{
					if (clanmembers.size() > 0)
					{
						// With the slot number, we get the selected member's name, 
						// and with the member's name we get their join date and store it in these variables for later.
						ClanMember selectedNewMember = clanmembers.get(sn);
						String selectedNewMemberDate = "";
						
						if (selectedNewMember != null)
						{
							selectedNewMemberDate = convertJoinDate(selectedNewMember);
						}
						
						if (selectedNewMember != null && !selectedNewMemberDate.equals(""))
						{
							int memberRank = clanSettings.titleForRank(selectedNewMember.getRank()).getId();
							
							// Check that the selected member has the required rank for Alts, or is one of the Admin ranks.
							// The Alts of Admins might have the Admin rank so they don't have to switch accounts while playing.
							// 9 is the ID for the Alt rank's title.
							if (memberRank == 9 || SpectralClanMgmtPlugin.isAdminRank(memberRank))
							{
								firstMemberSelected = true;
								firstMemberName = selectedNewMember.getName();
								firstMemberDate = selectedNewMemberDate;
								confirmSelection();
								return;
							}
							else
							{
								task = "invalid-alt";
								firstMemberName = selectedNewMember.getName();
							}
						}
					}
				}
				
				// We should only reach this point if the member selected wasn't a valid choice.
				// If the task wasn't already changed, then it means the task's value is meant to be "error".
				if (task.equalsIgnoreCase("add-alt-get-new"))
				{
					task = "error";
				}
				
				if (!task.equalsIgnoreCase("add-alt-get-new"))
				{
					if (task.equalsIgnoreCase("error"))
					{
						firstMemberName = "";
					}
					
					firstMemberSelected = false;
					firstMemberDate = "";
					// Proceed to the next step.
					displayError();
					return;
				}
			}
		}
		else if (task.equalsIgnoreCase("add-alt-get-main")) // second half of the add-alt overall task
		{
			// If an Alt has been selected, but the Alt's Main hasn't been selected, this code segment will be run.
			if (firstMemberSelected && !secondMemberSelected)
			{
				// j is for the position of the child widget in the children array. 
				// sn is the calculated index value that acts as the key for the member's name in the clanmembers hashmap.
				// So if j = 1, then sn will be 0. If j = 7, sn will be 2.
				int sn = (j - 1) / 3;
				
				if (clanmembers != null)
				{
					if (clanmembers.size() > 0)
					{
						// For the Alt's Main, we only need its name.
						ClanMember selectedMainMember = clanmembers.get(sn);
						
						if (selectedMainMember != null)
						{
							if (firstMemberName.equalsIgnoreCase(selectedMainMember.getName()))
							{
								task = "invalid-add-alt";
							}
							else
							{
								int memberRank = clanSettings.titleForRank(selectedMainMember.getRank()).getId();
								
								// Check that the selected member has one of the ranks for Mains.
								if (memberRank == 9 || memberRank == -1) // 9 is the ID for the Alt rank's title. -1 is the Guest rank's title. Mains can't have either of those ranks.
								{
									task = "invalid-main";
									secondMemberName = selectedMainMember.getName();
								}
								else if (memberRank != 9 && (SpectralClanMgmtPlugin.isNormalRank(memberRank) || SpectralClanMgmtPlugin.isAdminRank(memberRank)))
								{ // Have to include the check for Alt rank in the check here as well since it's a normal rank, but Mains can't have it.
									task = "add-alt";
									secondMemberSelected = true;
									secondMemberName = selectedMainMember.getName();
									// Proceed to the next step.
									confirmSelection();
									return;
								}
							}
						}
					}
				}
				
				// We should only reach this point if the member selected wasn't a valid choice.
				// If the task wasn't already changed, then it means the task's value is meant to be "error".
				if (task.equalsIgnoreCase("add-alt-get-main"))
				{
					task = "error";
				}
				
				if (!task.equalsIgnoreCase("add-alt-get-main"))
				{
					if (task.equalsIgnoreCase("error") || task.equalsIgnoreCase("invalid-add-alt"))
					{
						secondMemberName = "";
					}
					
					secondMemberSelected = false;
					displayError();
					return;
				}
			}
		}
		else if (task.equalsIgnoreCase("name-change"))
		{
			if (!firstMemberSelected)
			{
				// j is for the position of the child widget in the children array. 
				// sn is the calculated index value that acts as the key for the member's name in the clanmembers hashmap.
				// So if j = 1, then sn will be 0. If j = 7, sn will be 2.
				int sn = (j - 1) / 3;
				
				if (clanmembers != null)
				{
					if (clanmembers.size() > 0)
					{
						// For selecting a name change, we only want to get the current name and store it in a local variable.
						ClanMember selectedChangedMember = clanmembers.get(sn);
						
						if (selectedChangedMember != null)
						{
							String adminMember = client.getLocalPlayer().getName();
							
							if (!adminMember.equalsIgnoreCase(selectedChangedMember.getName()))
							{
								int memberRank = clanSettings.titleForRank(selectedChangedMember.getRank()).getId();
								
								if (memberRank == -1) // This shouldn't be possible, but if they somehow select a member with the Guest rank, have it error out.
								{
									category = "";
								}
								else if (memberRank == 9)
								{
									category = "alt";
								}
								else if (SpectralClanMgmtPlugin.isNormalRank(memberRank))
								{
									category = "main";
								}
								else if (SpectralClanMgmtPlugin.isAdminRank(memberRank)) // Admins
								{
									// Since admin members usually have the same rank for all their accts, the member type could be main or alt.
									category = "both";
								}
								
								if (!category.equals(""))
								{
									// Check if there's at least one friend on the admin's Friends list.
									if (client.getFriendContainer().getCount() > 0)
									{
										Friend changedMember = client.getFriendContainer().findByName(selectedChangedMember.getName());
										
										// Check if the selected member is on the admin's Friends list.
										if (changedMember != null)
										{
											// Check if the member has changed their name before.
											if (changedMember.getPrevName() != null && !changedMember.getPrevName().equals(""))
											{
												firstMemberSelected = true;
												firstMemberName = selectedChangedMember.getName();
												secondMemberName = changedMember.getPrevName();
												// Proceed to the next step.
												confirmSelection();
												return;
											}
											else // The member hasn't changed their name before.
											{
												task = "no-name-change";
												firstMemberName = selectedChangedMember.getName();
											}
										}
										else // The member isn't on the admin's Friends list.
										{
											task = "not-friend";
											firstMemberName = selectedChangedMember.getName();
										}
									}
									else // The admin's Friends list is empty.
									{
										task = "no-friends";
									}
								}
							}
							else // You can't submit a name change for yourself, because you can't add yourself to your Friends list.
							{
								task = "same-person";
							}
						}
					}
				}
				
				// We should only reach this point if the member selected wasn't a valid choice.
				// If the task wasn't already changed, then it means the task's value is meant to be "error".
				if (task.equalsIgnoreCase("name-change"))
				{
					task = "error";
				}
				
				if (!task.equalsIgnoreCase("name-change"))
				{
					if (task.equalsIgnoreCase("error") || task.equalsIgnoreCase("no-friends") || task.equalsIgnoreCase("same-player"))
					{
						firstMemberName = "";
					}
					
					firstMemberSelected = false;
					secondMemberName = "";
					category = "";
					// Proceed to the next step.
					displayError();
					return;
				}
			}
		}
		else if (task.equalsIgnoreCase("revoke-permission"))
		{
			if (!firstMemberSelected)
			{
				// j is for the position of the child widget in the children array. 
				// sn is the calculated index value that acts as the key for the member's name in the clanmembers hashmap.
				// So if j = 1, then sn will be 0. If j = 7, sn will be 2.
				int sn = (j - 1) / 3;
				
				if (clanmembers != null)
				{
					if (clanmembers.size() > 0)
					{
						// For selecting a name change, we only want to get the current name and store it in a local variable.
						ClanMember selectedMember = clanmembers.get(sn);
						String adminMember = client.getLocalPlayer().getName();
						
						if (selectedMember != null)
						{
							// You can't revoke your own permissions.
							if (selectedMember.getName().equals(adminMember))
							{
								task = "invalid-self";
							}
							else
							{
								int memberRank = clanSettings.titleForRank(selectedMember.getRank()).getId();
								
								// This shouldn't be possible, but if they somehow select a member with the Guest rank, have it error out.
								if (memberRank != -1)
								{
									if (adminRank == memberRank)
									{
										// You can't revoke the permissions of a member with the same rank.
										task = "invalid-same-rank";
									}
									else if ((adminRank == -3 && memberRank == -4) || (adminRank == 264 && new ArrayList<>(Arrays.asList(-4, -3)).contains(memberRank)) || (adminRank == 252 && new ArrayList<>(Arrays.asList(-4, -3, 264)).contains(memberRank)))
									{
										// You can't revoke the permissions of a member with a higher rank.
										task = "invalid-higher-rank";
									}
									else
									{
										firstMemberSelected = true;
										firstMemberName = selectedMember.getName();
										// Proceed to the next step.
										confirmSelection();
										return;
									}
								}
							}
						}
					}
				}
				
				// We should only reach this point if the member selected wasn't a valid choice.
				// If the task wasn't already changed, then it means the task's value is meant to be "error".
				if (task.equalsIgnoreCase("revoke-permission"))
				{
					task = "error";
				}
				
				if (!task.equalsIgnoreCase("revoke-permission"))
				{
					firstMemberSelected = false;
					firstMemberName = "";
					category = "";
					// Proceed to the next step.
					displayError();
					return;
				}
			}
		}
		else if (task.equalsIgnoreCase("restore-permission"))
		{
			if (!firstMemberSelected)
			{
				// j is for the position of the child widget in the children array. 
				// sn is the calculated index value that acts as the key for the member's name in the clanmembers hashmap.
				// So if j = 1, then sn will be 0. If j = 7, sn will be 2.
				int sn = (j - 1) / 3;
				
				if (clanmembers != null)
				{
					if (clanmembers.size() > 0)
					{
						// For selecting a name change, we only want to get the current name and store it in a local variable.
						ClanMember selectedMember = clanmembers.get(sn);
						String adminMember = client.getLocalPlayer().getName();
						
						if (selectedMember != null)
						{
							// You can't restore your own permissions.
							if (selectedMember.getName().equals(adminMember))
							{
								task = "invalid-self";
							}
							else
							{
								int memberRank = clanSettings.titleForRank(selectedMember.getRank()).getId();
								
								// This shouldn't be possible, but if they somehow select a member with the Guest rank, have it error out.
								if (memberRank != -1)
								{
									if (adminRank == memberRank)
									{
										// You can't restore the permissions of a member with the same rank.
										task = "invalid-same-rank";
									}
									else if ((adminRank == -3 && memberRank == -4) || (adminRank == 264 && new ArrayList<>(Arrays.asList(-4, -3)).contains(memberRank)) || (adminRank == 252 && new ArrayList<>(Arrays.asList(-4, -3, 264)).contains(memberRank)))
									{
										// You can't restore the permissions of a member with a higher rank.
										task = "invalid-higher-rank";
									}
									else
									{
										firstMemberSelected = true;
										firstMemberName = selectedMember.getName();
										// Proceed to the next step.
										confirmSelection();
										return;
									}
								}
							}
						}
					}
				}
				
				// We should only reach this point if the member selected wasn't a valid choice.
				// If the task wasn't already changed, then it means the task's value is meant to be "error".
				if (task.equalsIgnoreCase("restore-permission"))
				{
					task = "error";
				}
				
				if (!task.equalsIgnoreCase("restore-permission"))
				{
					firstMemberSelected = false;
					firstMemberName = "";
					category = "";
					// Proceed to the next step.
					displayError();
					return;
				}
			}
		}
		else if (task.equalsIgnoreCase("rank-swap-old")) // first half of the rank-swap overall task
		{
			if (!firstMemberSelected)
			{
				// j is for the position of the child widget in the children array. 
				// sn is the calculated index value that acts as the key for the member's name in the clanmembers hashmap.
				// So if j = 1, then sn will be 0. If j = 7, sn will be 2.
				int sn = (j - 1) / 3;
				
				if (clanmembers != null)
				{
					if (clanmembers.size() > 0)
					{
						ClanMember selectedOldMainMember = clanmembers.get(sn);
						
						if (selectedOldMainMember != null)
						{
							int memberRank = clanSettings.titleForRank(selectedOldMainMember.getRank()).getId();
							
							// Check that the selected member has the required rank for Alts, or an Admin rank.
							// The Alts of Admins might have the Admin rank so they don't have to switch accounts while playing.
							// 9 is the ID for the Alt rank's title.
							if (memberRank == 9 || SpectralClanMgmtPlugin.isAdminRank(memberRank))
							{
								firstMemberSelected = true;
								firstMemberName = selectedOldMainMember.getName();
								confirmSelection();
								return;
							}
							else
							{
								task = "invalid-old-main";
								firstMemberName = selectedOldMainMember.getName();
							}
						}
					}
				}
				
				// We should only reach this point if the member selected wasn't a valid choice.
				// If the task wasn't already changed, then it means the task's value is meant to be "error".
				if (task.equalsIgnoreCase("rank-swap-old"))
				{
					task = "error";
				}
				
				if (!task.equalsIgnoreCase("rank-swap-old"))
				{
					if (task.equalsIgnoreCase("error"))
					{
						firstMemberName = "";
					}
					
					firstMemberSelected = false;
					// Proceed to the next step.
					displayError();
					return;
				}
			}
		}
		else if (task.equalsIgnoreCase("rank-swap-new")) // second half of the rank-swap overall task
		{
			if (firstMemberSelected && !secondMemberSelected)
			{
				int sn = (j - 1) / 3;
				
				if (clanmembers != null)
				{
					if (clanmembers.size() > 0)
					{
						ClanMember selectedOldAltMember = clanmembers.get(sn);
						
						if (selectedOldAltMember != null)
						{
							if (firstMemberName.equalsIgnoreCase(selectedOldAltMember.getName()))
							{
								task = "invalid-rank-swap";
							}
							else
							{
								int memberRank = clanSettings.titleForRank(selectedOldAltMember.getRank()).getId();
								
								// Check that the selected member has one of the ranks for Mains.
								if (memberRank == 9 || memberRank == -1) // 9 is the ID for the Alt rank's title. -1 is the Guest rank's title. Mains can't have either of those ranks.
								{
									task = "invalid-old-alt";
									secondMemberName = selectedOldAltMember.getName();
								}
								else if (memberRank != 9 && (SpectralClanMgmtPlugin.isNormalRank(memberRank) || SpectralClanMgmtPlugin.isAdminRank(memberRank)))
								{ // Have to include the check for Alt rank in the check here as well since it's a normal rank, but Mains can't have it.
									
									task = "rank-swap";
									secondMemberSelected = true;
									secondMemberName = selectedOldAltMember.getName();
									confirmSelection();
									return;
								}
							}
						}
					}
				}
				
				// We should only reach this point if the member selected wasn't a valid choice.
				// If the task wasn't already changed, then it means the task's value is meant to be "error".
				if (task.equalsIgnoreCase("rank-swap-new"))
				{
					task = "error";
				}
				
				if (!task.equalsIgnoreCase("rank-swap-new"))
				{
					if (task.equalsIgnoreCase("error") || task.equalsIgnoreCase("invalid-rank-swap"))
					{
						secondMemberName = "";
					}
					
					secondMemberSelected = false;
					displayError();
					return;
				}
			}
		}
		else if (task.equalsIgnoreCase("discord-deserter") || task.equalsIgnoreCase("discord-returnee"))
		{
			if (!firstMemberSelected)
			{
				// j is for the position of the child widget in the children array. 
				// sn is the calculated index value that acts as the key for the member's name in the clanmembers hashmap.
				// So if j = 1, then sn will be 0. If j = 7, sn will be 2.
				int sn = (j - 1) / 3;
				
				if (clanmembers != null)
				{
					if (clanmembers.size() > 0)
					{
						// For selecting a name change, we only want to get the current name and store it in a local variable.
						ClanMember selectedMember = clanmembers.get(sn);
						
						if (selectedMember != null)
						{
							firstMemberSelected = true;
							firstMemberName = selectedMember.getName();
							confirmSelection();
							return;
						}
					}
				}
				
				// We should only reach this point if the member selected wasn't a valid choice.
				// If the task wasn't already changed, then it means the task's value is meant to be "error".
				if (task.equalsIgnoreCase("discord-deserter") || task.equalsIgnoreCase("discord-returnee"))
				{
					task = "error";
				}
				
				if (!task.equalsIgnoreCase("discord-deserter") && !task.equalsIgnoreCase("discord-returnee"))
				{
					firstMemberName = "";
					firstMemberSelected = false;
					displayError();
					return;
				}
			}
		}
	}
	
	private void confirmSelection()
	{
		chatboxPanelManager.close();
		
		if (task.equals("add-new"))
		{
			chatboxPanelManager
			.openTextMenuInput("You have selected '" + firstMemberName + "'. Is this correct?<br>Click Yes to export the data, No to select again, or Cancel to exit.")
			.option("Yes", () -> exportChange(task, firstMemberDate, firstMemberName, ""))
			.option("No", () -> selectNew())
			.option("Cancel", () -> removeListeners())
			.build(2);
		}
		else if (task.equals("add-alt-get-new"))
		{
			chatboxPanelManager
			.openTextMenuInput("You've selected '" + firstMemberName + "' as the Alt. Is this correct?<br>Click Yes to proceed, No to select again, or Cancel to exit.")
			.option("Yes", () -> selectMain())
			.option("No", () -> selectAlt())
			.option("Cancel", () -> removeListeners())
			.build(2);
		}
		else if (task.equals("add-alt"))
		{
			chatboxPanelManager
			.openTextMenuInput("You've selected '" + secondMemberName + "' as the Main. Is this correct?<br>Click Yes to export the data, No to reselect the Main, or Cancel to exit.")
			.option("Yes", () -> exportChange(task, firstMemberDate, secondMemberName, firstMemberName))
			.option("No", () -> selectMain())
			.option("Cancel", () -> removeListeners())
			.build(2);
		}
		else if (task.equals("name-change"))
		{
			chatboxPanelManager
			.openTextMenuInput("You have selected '" + firstMemberName + "'. Is this correct?<br>Click Yes to export the change, No to select again, or Cancel to exit.")
			.option("Yes", () -> exportChange(task, firstMemberName, secondMemberName, category))
			.option("No", () -> selectNameChange())
			.option("Cancel", () -> removeListeners())
			.build(2);
		}
		else if (task.equals("revoke-permission"))
		{
			String option = "";
			
			if (category.equals("Both"))
			{
				option = "Revoke both of " + firstMemberName + "'s command permissions?<br>";
			}
			else
			{
				option = "Revoke " + firstMemberName + "'s " + category + " command permissions?<br>";
			}
			
			chatboxPanelManager
			.openTextMenuInput(option + "Click Yes to export the change, No to start over, or Cancel to exit.")
			.option("Yes", () -> exportChange(task, firstMemberName, category, ""))
			.option("No", () -> selectRevokePermission(""))
			.option("Cancel", () -> removeListeners())
			.build(2);
		}
		else if (task.equals("restore-permission"))
		{
			String option = "";
			
			if (category.equals("Both"))
			{
				option = "Restore both of " + firstMemberName + "'s command permissions?<br>";
			}
			else
			{
				option = "Restore " + firstMemberName + "'s " + category + " command permissions?<br>";
			}
			
			chatboxPanelManager
			.openTextMenuInput(option + "Click Yes to export the change, No to start over, or Cancel to exit.")
			.option("Yes", () -> exportChange(task, firstMemberName, category, ""))
			.option("No", () -> selectRestorePermission(""))
			.option("Cancel", () -> removeListeners())
			.build(2);
		}
		else if (task.equals("rank-swap-old"))
		{
			chatboxPanelManager
			.openTextMenuInput("You've selected '" + firstMemberName + "' as the old Main. Is this correct?<br>Click Yes to proceed, No to reselect, or Cancel to exit.")
			.option("Yes", () -> selectOldAlt())
			.option("No", () -> selectOldMain())
			.option("Cancel", () -> removeListeners())
			.build(2);
		}
		else if (task.equals("rank-swap"))
		{
			chatboxPanelManager
			.openTextMenuInput("You've selected '" + secondMemberName + "' as the new Main. Is this correct?<br>Click Yes to export the data, No to reselect, or Cancel to exit.")
			.option("Yes", () -> exportChange(task, firstMemberName, secondMemberName, ""))
			.option("No", () -> selectOldAlt())
			.option("Cancel", () -> removeListeners())
			.build(2);
		}
		else if (task.equals("discord-deserter"))
		{
			chatboxPanelManager
			.openTextMenuInput("You have selected '" + firstMemberName + "'. Is this correct?<br>Click Yes to export the change, No to select again, or Cancel to exit.")
			.option("Yes", () -> exportChange(task, firstMemberName, "", ""))
			.option("No", () -> discordDeserterExport())
			.option("Cancel", () -> removeListeners())
			.build(2);
		}
		else if (task.equals("discord-returnee"))
		{
			chatboxPanelManager
			.openTextMenuInput("You have selected '" + firstMemberName + "'. Is this correct?<br>Click Yes to export the change, No to select again, or Cancel to exit.")
			.option("Yes", () -> exportChange(task, firstMemberName, "", ""))
			.option("No", () -> discordReturneeExport())
			.option("Cancel", () -> removeListeners())
			.build(2);
		}
	}
	
	private void displayError()
	{
		chatboxPanelManager.close();
		
		if (task.equals("invalid-new"))
		{
			task = "add-new";
			
			String newMem = firstMemberName;
			firstMemberName = "";
			
			chatboxPanelManager
			.openTextMenuInput("The member you've selected, '" + newMem + "', has the Alt rank.<br>Mains can only have normal ranks.<br>Select a different member for the Main, or click Cancel to exit.")
			.option("Cancel", () -> removeListeners())
			.build(3);
		}
		else if (task.equals("invalid-alt"))
		{
			task = "add-alt-get-new";
			
			String altMem = firstMemberName;
			firstMemberName = "";
			
			chatboxPanelManager
			.openTextMenuInput("The member you've selected, '" + altMem + "', doesn't have the Alt rank.<br>Alts can only have the Alt rank.<br>Select a different member for the Alt, or click Cancel to exit.")
			.option("Cancel", () -> removeListeners())
			.build(3);
		}
		else if (task.equals("invalid-main"))
		{
			// Double check that the selected alt member's name and join date are still set in their variables.
			if (!firstMemberName.equals("") && !firstMemberDate.equals(""))
			{
				task = "add-alt-get-main";
				
				String mainMem = secondMemberName;
				secondMemberName = "";
				
				chatboxPanelManager
				.openTextMenuInput("The member you've selected, '" + mainMem + "', has the Alt rank.<br>Mains can only have normal ranks.<br>Select a different member for the Main, or click Cancel to exit.")
				.option("Cancel", () -> removeListeners())
				.build(3);
			}
			else
			{
				task = "error";
			}
		}
		else if (task.equals("no-friends"))
		{
			removeListeners();
			
			chatboxPanelManager
			.openTextMenuInput("Your Friends list is empty.<br>For name change exports, the member must be on your Friends list.")
			.option("OK", () -> chatboxPanelManager.close())
			.build(2);
		}
		else if (task.equals("not-friend"))
		{
			String changedMem = firstMemberName;
			
			removeListeners();
			
			chatboxPanelManager
			.openTextMenuInput("'" + changedMem + "' isn't on your Friends list.<br>For name change exports, the member must be on your Friends list.")
			.option("OK", () -> chatboxPanelManager.close())
			.build(2);
		}
		else if (task.equals("same-person"))
		{
			removeListeners();
			
			chatboxPanelManager
			.openTextMenuInput("You can't export a name change for yourself.<br>Ask another admin member to export your name change.")
			.option("OK", () -> chatboxPanelManager.close())
			.build(2);
		}
		else if (task.equals("no-name-change"))
		{
			task = "name-change";
			
			String changedMem = firstMemberName;
			firstMemberName = "";
			
			chatboxPanelManager
			.openTextMenuInput("'" + changedMem + "' doesn't have a previous name.<br>Select a different member, or click Cancel to exit.")
			.option("Cancel", () -> removeListeners())
			.build(2);
		}
		else if (task.equals("invalid-self"))
		{
			removeListeners();
			
			chatboxPanelManager
			.openTextMenuInput("You can't change your own permissions.")
			.option("OK", () -> chatboxPanelManager.close())
			.build(1);
		}
		else if (task.equals("invalid-same-rank"))
		{
			removeListeners();
			
			chatboxPanelManager
			.openTextMenuInput("You can't change the permissions of members with the same rank.")
			.option("OK", () -> chatboxPanelManager.close())
			.build(1);
		}
		else if (task.equals("invalid-higher-rank"))
		{
			removeListeners();
			
			chatboxPanelManager
			.openTextMenuInput("You can't change the permissions of members with a higher rank.")
			.option("OK", () -> chatboxPanelManager.close())
			.build(1);
		}
		else if (task.equals("invalid-old-main"))
		{
			//The old Main should have the Alt rank, not one of the ranks for mains.
			// Double check that the selected member's name is still set in its variable.
			if (!firstMemberName.equals(""))
			{
				task = "rank-swap-old";
				
				String oldMain = firstMemberName;
				firstMemberName = "";
				
				chatboxPanelManager
				.openTextMenuInput("The member you've selected, '" + oldMain + "', doesn't have the Alt rank.<br>The old Main should have the Alt rank.<br>Select a different member for the old Main, or click Cancel to exit.")
				.option("Cancel", () -> removeListeners())
				.build(3);
			}
			else
			{
				task = "error";
			}
		}
		else if (task.equals("invalid-old-alt"))
		{
			//The old Alt should have whatever rank the old Main had before, not the Alt rank.
			// Double check that the selected member's name is still set in its variable.
			if (!secondMemberName.equals(""))
			{
				task = "rank-swap-new";
				
				String oldAlt = secondMemberName;
				secondMemberName = "";
				
				chatboxPanelManager
				.openTextMenuInput("The member you've selected, '" + oldAlt + "', has the Alt rank.<br>The new Main should have a normal rank.<br>Select a different member for the new Main, or click Cancel to exit.")
				.option("Cancel", () -> removeListeners())
				.build(3);
			}
			else
			{
				task = "error";
			}
		}
		else if (task.equals("invalid-add-alt") || task.equals("invalid-rank-swap"))
		{
			removeListeners();
			
			chatboxPanelManager
			.openTextMenuInput("You can't choose the same member for both selections.")
			.option("OK", () -> chatboxPanelManager.close())
			.build(1);
		}
		else if (task.equals("error"))
		{
			removeListeners();
			
			chatboxPanelManager
			.openTextMenuInput("Something went wrong.")
			.option("OK", () -> chatboxPanelManager.close())
			.build(1);
		}
	}
	
	protected void exportChange(String task, String firstArg, String secondArg, String thirdArg)
	{
		chatboxPanelManager.close();
		
		String admin = Text.sanitize(client.getLocalPlayer().getName());
		
		HashMap<String, Boolean> reg = new HashMap<String, Boolean>();
		
		reg.putAll(plugin.getReg());
		
		if (!config.memberKey().equals("") && plugin.validAccessKey && reg.size() > 0 && reg.containsKey(admin) && reg.get(admin))
		{
			if (httpRequest.getIsReady())
			{
				String fArg = "";
				String sArg = "";
				String tArg = "";
				String acctHash = String.valueOf(client.getAccountHash());
				
				// Before we proceed, we'll check that the Admin web app's URL is set and valid.
				if (plugin.checkURL(plugin.getAdminURL()))
				{
					if (task.equalsIgnoreCase("add-new"))
					{
						// firstArg = newMemberDate
						// secondArg = newMemberName
						// thirdArg = blank
						fArg = firstArg;
						sArg = Text.sanitize(secondArg);
					}
					else if (task.equalsIgnoreCase("add-alt"))
					{
						// firstArg = newMemberDate
						// secondArg = mainMemberName
						// thirdArg = newMemberName
						fArg = firstArg;
						sArg = Text.sanitize(secondArg);
						tArg = Text.sanitize(thirdArg);
					}
					else if (task.equalsIgnoreCase("name-change"))
					{
						// firstArg = memberCurrentName
						// secondArg = memberOldName
						// thirdArg = memberType
						fArg = Text.sanitize(firstArg);
						sArg = Text.sanitize(secondArg);
						tArg = thirdArg;
					}
					else if (task.equalsIgnoreCase("revoke-permission") || task.equalsIgnoreCase("restore-permission"))
					{
						// firstArg = selected member's name
						// secondArg = permission selection
						// thirdArg = blank
						fArg = Text.sanitize(firstArg);
						sArg = secondArg;
					}
					else if (task.equalsIgnoreCase("rank-swap"))
					{
						// firstArg = old Main's name
						// secondArg = new Main's name
						// thirdArg = blank
						fArg = Text.sanitize(firstArg);
						sArg = Text.sanitize(secondArg);
					}
					else if (task.equalsIgnoreCase("discord-deserter") || task.equalsIgnoreCase("discord-returnee"))
					{
						// firstArg = Main's name
						// secondArg = blank
						// thirdArg = blank
						fArg = Text.sanitize(firstArg);
					}
					
					httpRequest.setIsReady(false);
					
					httpRequest.postRequestAsyncAdmin(task, fArg, sArg, tArg, admin, acctHash).whenCompleteAsync((result, ex) ->
					{
						httpRequest.setIsReady(true);
						removeListeners();
						
						chatboxPanelManager
						.openTextMenuInput(result)
						.option("OK", () -> chatboxPanelManager.close())
						.build(2);
					});
				}
				else
				{
					httpRequest.setIsReady(true);
					removeListeners();
					
					chatboxPanelManager
					.openTextMenuInput("Wait a minute before trying again. If you continue to get this message,<br>contact the developer about the admin URL.")
					.option("OK", () -> chatboxPanelManager.close())
					.build(2);
				}
			}
		}
		else
		{
			httpRequest.setIsReady(true);
			removeListeners();
			
			if (config.memberKey().equals("") || !plugin.validAccessKey)
			{
				chatboxPanelManager
				.openTextMenuInput("A valid access key isn't set in the plugin's settings.<br>Use the !key command to get the access key first.")
				.option("OK", () -> chatboxPanelManager.close())
				.build(2);
			}
			else if (reg.size() < 1 || !reg.containsKey(admin) || (reg.containsKey(admin) && !reg.get(admin)))
			{
				chatboxPanelManager
				.openTextMenuInput("Your player ID isn't registered. Use the !addme command and<br>follow the steps to register your player ID first.")
				.option("OK", () -> chatboxPanelManager.close())
				.build(2);
			}
		}
	}
	
	// This method is called from our HttpRequest class when a response is received and the members list widget is not loaded.
	// It passes the status (success/failure) and the data holding the message from the web app.
	// Once we've received the response, we'll store the parameters in local variables and shutdown the request's thread.
	// The listeners are removed and the variables reset before the response is displayed in the chatbox.
	// Additional text is appended before the response is displayed depending on the task's value if the export's status is "success".
	protected String exportDone(String task, Response response) throws IOException
	{
		if (!response.isSuccessful())
		{
			return "Something went wrong.<br>Export could n't be completed.";
		}
		
		JsonObject resp;
		String stat = "";
		String res = "";
		
		try
		{
			resp = gson.fromJson(response.body().charStream(), JsonObject.class);
		}
		catch (JsonSyntaxException ex)
		{
			return "Something went wrong.<br>Response body wasn't a JSON string.";
		}
		
		if (resp == null)
		{
			return "Something went wrong.<br>Nothing was returned from the export.";
		}
		
		stat = resp.get("status").getAsString();
		res = resp.get("data").getAsString();
		
		if (stat.equalsIgnoreCase("success"))
		{
			if (task.equalsIgnoreCase("add-new"))
			{
				res = res + "<br>Now open Discord and wait for Spectral's bot to ping you.";
			}
			else if (!task.equalsIgnoreCase("add-new") && !task.equalsIgnoreCase("discord-deserter") && !task.equalsIgnoreCase("discord-returnee"))
			{
				res = res + "<br>All done!";
			}
		}
		
		return res;
	}
	
	// This adds the click listeners to specific widgets in the member names column.
	private void setListeners()
	{
		if (buttonCreated)
		{
			firstMemberSelected = false;
			secondMemberSelected = false;
			firstMemberName = "";
			firstMemberDate = "";
			secondMemberName = "";
			category = "";
			task = "";
			
			// This gets the child widgets of the member names column widget.
			Widget[] memberWidgets = client.getWidget(693, 10).getChildren();
			
			// This attaches a click listener to the second child widget (i = 1) of the member names column
			// and then every 3rd child widget after that, because those are the widgets with the member's name for its text.
			// We don't get the member's name from the widget's text though; instead we pass the value for i, stored in temp variable j,
			// to the method of the widget's click listener. j is the child widget's position in the array of children, and that will
			// allow us to get the value of the name displayed on the widget (without all the invisible or weird characters that fuck things up)
			// which will then be used to get the member's int join date.
			// We already got the members' names and their join dates earlier when the members list widget was loaded.
			for (int i = 1; i < memberWidgets.length; i = i + 3)
			{
				int j = i;
				memberWidgets[i].setHasListener(true);
				memberWidgets[i].setOnClickListener((JavaScriptCallback)e -> getSelectedMember(j));
			}
			
			client.getWidget(693, 10).setChildren(memberWidgets);
			
			listenersSet = true;
		}
	}
	
	// This is essentially a reset, everything is cleared and the listeners are removed in preparation 
	// for the button being clicked again or the members list widget being closed.
	protected void removeListeners()
	{
		wasClicked = false;
		firstMemberSelected = false;
		secondMemberSelected = false;
		firstMemberName = "";
		firstMemberDate = "";
		secondMemberName = "";
		category = "";
		task = "";
		
		if (buttonCreated)
		{
			Widget[] memberWidgets = client.getWidget(693, 10).getChildren();
			
			for (int i = 1; i < memberWidgets.length; i = i + 3)
			{
				memberWidgets[i].setOnClickListener((Object[])null);
				memberWidgets[i].setHasListener(false);
			}
			
			client.getWidget(693, 10).setChildren(memberWidgets);
		}
		
		listenersSet = false;
		
		chatboxPanelManager.close();
	}
	
	// Admin chose to export a new Main clan member.
	private void selectNew()
	{
		// Since there's multiple methods where setListeners can be called and these methods can be visited more than once,
		// we need to check if the flag for them has been set and, if the listeners haven't been added, we'll add them.
		if (listenersSet == false)
		{
			setListeners();
		}
		
		// Set the task to the admin's choice, reset the flag and global variables, then proceed.
		task = "add-new";
		firstMemberSelected = false;
		firstMemberName = "";
		firstMemberDate = "";
		
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("Select the new Main member's name from the left column.<br>Or click cancel to exit.")
		.option("Cancel", () -> removeListeners())
		.build(2);
	}
	
	// Admin chose to export a new Alt clan member.
	private void selectAlt()
	{
		// Since there's multiple methods where setListeners can be called and these methods can be visited more than once,
		// we need to check if the flag for them has been set and, if the listeners haven't been added, we'll add them.
		if (listenersSet == false)
		{
			setListeners();
		}
		
		// Set the task to the admin's choice, in this case it's the first half of the task, 
		// reset the flag and global variables for that part of the task, then proceed.
		task = "add-alt-get-new";
		firstMemberSelected = false;
		firstMemberName = "";
		firstMemberDate = "";
		
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("Select the new Alt member's name from the left column.<br>Or click cancel to exit.")
		.option("Cancel", () -> removeListeners())
		.build(2);
	}
	
	// Admin chose to export a new Alt clan member. Get the Main for the new Alt in the clan.
	private void selectMain()
	{
		// We would only reach this point after selectAlt has been run, 
		// so the listeners would've already been added and we don't need the check here.
		
		// Set the task to the admin's choice, in this case it's the second half of the task, 
		// reset the flag and global variables for that part of the task, then proceed.
		task = "add-alt-get-main";
		secondMemberSelected = false;
		secondMemberName = "";
		
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("Select the Main's name for the new Alt from the left column.<br>Or click cancel to exit.")
		.option("Cancel", () -> removeListeners())
		.build(2);
	}
	
	// Admin chose to export a rank swap. Get the member's old Main in the clan.
	private void selectOldMain()
	{
		// Since there's multiple methods where setListeners can be called and these methods can be visited more than once,
		// we need to check if the flag for them has been set and, if the listeners haven't been added, we'll add them.
		if (listenersSet == false)
		{
			setListeners();
		}
		
		// Set the task to the admin's choice, in this case it's the first half of the task, 
		// reset the flag and global variables for that part of the task, then proceed.
		task = "rank-swap-old";
		firstMemberSelected = false;
		firstMemberName = "";
		
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("Select the member's old Main from the left column.<br>Or click Cancel to exit.")
		.option("Cancel", () -> removeListeners())
		.build(2);
	}
	
	// Admin chose to export a rank swap. Get the member's new Main in the clan.
	private void selectOldAlt()
	{
		// We would only reach this point after selectOldMain has been run, 
		// so the listeners would've already been added and we don't need the check here.
		
		// Set the task to the admin's choice, in this case it's the second half of the task, 
		// reset the flag and global variables for that part of the task, then proceed.
		task = "rank-swap-new";
		secondMemberSelected = false;
		secondMemberName = "";
		
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("Select the member's new Main from the left column.<br>Or click Cancel to exit.")
		.option("Cancel", () -> removeListeners())
		.build(2);
	}
	
	// Admin chose to export a Discord Deserter. Get the member's Main in the clan.
	private void discordDeserterExport()
	{
		// Since there's multiple methods where setListeners can be called and these methods can be visited more than once,
		// we need to check if the flag for them has been set and, if the listeners haven't been added, we'll add them.
		if (listenersSet == false)
		{
			setListeners();
		}
		
		task = "discord-deserter";
		firstMemberSelected = false;
		firstMemberName = "";
		
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("Select the member's Main from the left column.<br>Or click Cancel to exit.")
		.option("Cancel", () -> removeListeners())
		.build(2);
	}
	
	// Admin chose to export a Discord Returnee. Get the member's Main in the clan.
	private void discordReturneeExport()
	{
		// Since there's multiple methods where setListeners can be called and these methods can be visited more than once,
		// we need to check if the flag for them has been set and, if the listeners haven't been added, we'll add them.
		if (listenersSet == false)
		{
			setListeners();
		}
		
		task = "discord-returnee";
		firstMemberSelected = false;
		firstMemberName = "";
		
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("Select the member's Main from the left column.<br>Or click Cancel to exit.")
		.option("Cancel", () -> removeListeners())
		.build(2);
	}
	
	// Admin chose to export a name change.
	private void selectNameChange()
	{
		// Since there's multiple methods where setListeners can be called and these methods can be visited more than once,
		// we need to check if the flag for them has been set and, if the listeners haven't been added, we'll add them.
		if (listenersSet == false)
		{
			setListeners();
		}
		
		// Set the task to the admin's choice, reset the flag and global variables, then proceed.
		task = "name-change";
		firstMemberSelected = false;
		firstMemberName = "";
		secondMemberName = "";
		// memberType will determine which column is searched on one of the sheets that has to be updated for name changes.
		category = "";
		
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("Select a member from the left column for the name change export.<br>Or click cancel to exit.")
		.option("Cancel", () -> removeListeners())
		.build(2);
	}
	
	// Admin selected No after choosing the Name Change option at the initial prompt.
	private void abortNameChange()
	{
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("For name change exports, the member must be on<br>your Friends list until the export is complete.")
		.option("OK", () -> cancelOptions())
		.build(2);
	}
	
	// A check prompt for the admin to confirm the prerequisite condition, the clan member being on their Friends list, is met.
	// An admin will need to add the clan member that changed their name to their Friends list first (they're aware of this)
	// before they can export the clan member's current and previous name to the script that will update the spreadsheet pages.
	// There are checks that will happen prior to the export being posted to ensure the member is on their Friends list
	// and has changed their name before.
	private void nameChangeCheckPreReq()
	{
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("Is the member you intend to select on your Friends list?")
		.option("Yes", () -> selectNameChange())
		.option("No", () -> abortNameChange())
		.option("Cancel", () -> cancelOptions())
		.build(1);
	}
	
	private void selectRestorePermission(String choice)
	{
		// Since there's multiple methods where setListeners can be called and these methods can be visited more than once,
		// we need to check if the flag for them has been set and, if the listeners haven't been added, we'll add them.
		if (listenersSet == false)
		{
			setListeners();
		}
		
		// Set the task to the admin's choice, reset the flag and global variables, then proceed.
		task = "restore-permission";
		firstMemberSelected = false;
		firstMemberName = "";
		category = "";
		
		chatboxPanelManager.close();
		
		if (choice.equals(""))
		{
			chatboxPanelManager
			.openTextMenuInput("Which permission(s) do you want to restore?")
			.option("Spectral", () -> selectRestorePermission("Spectral"))
			.option("Discord", () -> selectRestorePermission("Discord"))
			.option("Both", () -> selectRestorePermission("Both"))
			.build(1);
		}
		else
		{
			category = choice;
			
			chatboxPanelManager
			.openTextMenuInput("Select a member from the left column for the permission change.<br>Or click cancel to exit.")
			.option("Cancel", () -> removeListeners())
			.build(2);
		}
	}
	
	private void selectRevokePermission(String choice)
	{
		// Since there's multiple methods where setListeners can be called and these methods can be visited more than once,
		// we need to check if the flag for them has been set and, if the listeners haven't been added, we'll add them.
		if (listenersSet == false)
		{
			setListeners();
		}
		
		// Set the task to the admin's choice, reset the flag and global variables, then proceed.
		task = "revoke-permission";
		firstMemberSelected = false;
		firstMemberName = "";
		category = "";
		
		chatboxPanelManager.close();
		
		if (choice.equals(""))
		{
			chatboxPanelManager
			.openTextMenuInput("Which permission(s) do you want to revoke?")
			.option("Spectral", () -> selectRevokePermission("Spectral"))
			.option("Discord", () -> selectRevokePermission("Discord"))
			.option("Both", () -> selectRevokePermission("Both"))
			.build(1);
		}
		else
		{
			category = choice;
			
			chatboxPanelManager
			.openTextMenuInput("Select a member from the left column for the permission change.<br>Or click cancel to exit.")
			.option("Cancel", () -> removeListeners())
			.build(2);
		}
	}
	
	private void newMemberExport()
	{
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("Are you exporting a new Main or Alt member?<br>Select an option below, or click Cancel to exit.")
		.option("Main", () -> selectNew())
		.option("Alt", () -> selectAlt())
		.option("Cancel", () -> cancelOptions())
		.build(2);
	}
	
	private void permissionChangeExport()
	{
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("Are you revoking or restoring a permission for a member?<br>Select an option below, or click Cancel to exit.")
		.option("Revoke", () -> selectRevokePermission(""))
		.option("Restore", () -> selectRestorePermission(""))
		.option("Cancel", () -> cancelOptions())
		.build(2);
	}
	
	private void nameOrPermissionChange()
	{
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("Are you exporting a Name or Permission change?<br>Select an option below, or click Cancel to exit.")
		.option("Name", () -> nameChangeCheckPreReq())
		.option("Permission", () -> permissionChangeExport())
		.option("Cancel", () -> cancelOptions())
		.build(2);
	}
	
	private void memberOrRankSwapExport()
	{
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("Are you exporting a new Member or a Rank Swap?<br>Select an option below, or click Cancel to exit.")
		.option("New Member", () -> newMemberExport())
		.option("Rank Swap", () -> selectOldMain())
		.option("Cancel", () -> cancelOptions())
		.build(2);
	}
	
	private void discordMemberChange()
	{
		chatboxPanelManager.close();
		
		chatboxPanelManager
		.openTextMenuInput("Are you exporting a Discord Deserter or Returnee?<br>Select an option below, or click Cancel to exit.")
		.option("Discord Deserter", () -> discordDeserterExport())
		.option("Discord Returnee", () -> discordReturneeExport())
		.option("Cancel", () -> cancelOptions())
		.build(2);
	}
	
	private void cancelOptions()
	{
		wasClicked = false;
		chatboxPanelManager.close();
	}
	
	protected void enableButton()
	{
		if (buttonCreated)
		{
			textWidget.setText("<col=ffffff>Export Clan Change</col>");
			
			textWidget.setOnClickListener((JavaScriptCallback)e ->
			{
				adminRank = 0;
				
				HashMap<String, Boolean> reg = new HashMap<String, Boolean>();
				
				reg.putAll(plugin.getReg());
				
				String player = client.getLocalPlayer().getName();
				
				if (client.getClanSettings(0) != null)
				{
					if (client.getClanSettings(0).getName().equals("Spectral"))
					{
						if (client.getClanSettings(0).findMember(player) != null)
						{
							adminRank = client.getClanSettings(0).titleForRank(client.getClanSettings(0).findMember(player).getRank()).getId();
						}
					}
				}
				
				if (!config.memberKey().equals("") && plugin.validAccessKey && reg.size() > 0 && reg.containsKey(Text.sanitize(player)) && reg.get(Text.sanitize(player)))
				{
					// Putting this check here in case the player was an admin-ranked member when the button was created
					// and their rank is changed to a non-admin one while the button exists.
					if (SpectralClanMgmtPlugin.isAdminRank(adminRank))
					{
						// If the script's url is missing or isn't valid, we don't want anything to happen when the button is clicked beyond
						// a prompt in the chatbox.
						if (SpectralClanMgmtPlugin.checkURL(plugin.getAdminURL()))
						{
							if (httpRequest.getIsReady())
							{
								// wasClicked is used as a flag that stops the button from reacting to additional clicks
								// after the first click until the admin either finishes an export, cancels, or causes the members list widget to close.
								// We don't want them clicking the button then starting the export process, only to click the button
								// again at a point when everything wouldn't be reset (like after selecting an alt but not a main yet).
								if (wasClicked == false)
								{
									wasClicked = true;
									
									chatboxPanelManager
									.openTextMenuInput("Select an Export option below, or click Cancel to exit.")
									.option("New Member or Rank Swap", () -> memberOrRankSwapExport())
									.option("Name or Permission Change", () -> nameOrPermissionChange())
									.option("Discord Deserter or Returnee", () -> discordMemberChange())
									.option("Cancel", () -> cancelOptions())
									.build(1);
								}
							}
							else
							{
								// If this occurs, then the response from a post request hasn't been received yet.
								// This will automatically be closed, if it's not already, when the request's response is received.
								chatboxPanelManager
								.openTextMenuInput("You can't start another export right now.<br>Wait a minute before trying again.")
								.option("OK", () -> chatboxPanelManager.close())
								.build(2);
							}
						}
						else
						{
							chatboxPanelManager
							.openTextMenuInput("Wait a minute before trying again. If you still get this message,<br>contact the developer about the admin URL.")
							.option("OK", () -> chatboxPanelManager.close())
							.build(2);
						}
					}
					else
					{
						chatboxPanelManager
						.openTextMenuInput("Rank check failed. You don't have an admin rank anymore.<br>Contact the developer if you do have an admin rank still.")
						.option("OK", () -> chatboxPanelManager.close())
						.build(2);
					}
				}
				else
				{
					if (config.memberKey().equals("") || !plugin.validAccessKey)
					{
						chatboxPanelManager
						.openTextMenuInput("A valid access key isn't set in the plugin's settings.<br>Use the !key command to get the access key first.")
						.option("OK", () -> chatboxPanelManager.close())
						.build(2);
					}
					else if (reg.size() < 1 || !reg.containsKey(Text.sanitize(player)) || (reg.containsKey(Text.sanitize(player)) && !reg.get(Text.sanitize(player))))
					{
						chatboxPanelManager
						.openTextMenuInput("Your player ID isn't registered. Use the !addme command and<br>follow the steps to register your player ID first.")
						.option("OK", () -> chatboxPanelManager.close())
						.build(2);
					}
				}
			});
		}
	}
}
package com.spectralclanmgmt;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("spectralclanmgmt")
public interface SpectralClanMgmtConfig extends Config
{
	@ConfigItem(
	keyName = "scriptURL",
	name = "Spectral's Web App URL",
	description = "The URL of Spectral's Web App.",
	position = 0
	)
	default String scriptURL()
	{
		return "";
	}
	
	@ConfigItem(
	keyName = "memberKey",
	name = "Access Key",
	description = "The unique access key assigned to each member.",
	position = 1
	)
	default String memberKey()
	{
		return "";
	}
	
	@ConfigItem(
	keyName = "memberKey",
	name = "",
	description = "",
	position = 2,
	hidden = true
	)
	void setMemberKey(String key);
	
	@ConfigItem(
	keyName = "registered",
	name = "",
	description = "",
	position = 3,
	hidden = true
	)
	default String registered()
	{
		return "";
	};
	
	@ConfigItem(
	keyName = "registered",
	name = "",
	description = "",
	position = 4,
	hidden = true
	)
	void setRegistered(String newRegistered);
}

