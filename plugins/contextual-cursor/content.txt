/*
 * Copyright (c) 2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import static com.github.ldavid432.contextualcursor.ContextualCursorUtil.scaleImage;
import static com.github.ldavid432.contextualcursor.ContextualCursorUtil.scalePoint;
import com.github.ldavid432.contextualcursor.sprite.Sprite;
import static io.hydrox.contextualcursor.ContextualCursor.BLANK_CURSOR;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class ContextualCursorDrawOverlay extends Overlay
{
	//The pointer sticks out to the left slightly, so this makes sure it's point to the correct spot
	private static final Point POINTER_OFFSET = new Point(-5, 0);
	//The centre of the circle (biased bottom right since it's an even size), for use with sprites
	private static final Point CENTRAL_POINT = new Point(16, 18);

	private final Client client;
	private final ContextualCursorPlugin plugin;
	private final SpriteManager spriteManager;

	private Point scaledCenterPoint = CENTRAL_POINT;
	private Point scaledOffset = POINTER_OFFSET;
	private final BufferedImage blankCursor = BLANK_CURSOR.getImage();
	private Image scaledBlankCursor = blankCursor;
	private Sprite currentSprite;
	private Image currentScaledSprite;

	@Inject
	ContextualCursorDrawOverlay(Client client, ContextualCursorPlugin plugin, SpriteManager spriteManager)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
		setPriority(1f);
		this.client = client;
		this.plugin = plugin;
		this.spriteManager = spriteManager;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Sprite sprite = plugin.getSpriteToDraw();

		if (sprite == null)
		{
			return null;
		}

		BufferedImage image = sprite.getImage(client, spriteManager);
		if (image == null)
		{
			return null;
		}

		if (sprite != currentSprite || currentScaledSprite == null)
		{
			currentSprite = sprite;
			currentScaledSprite = scaleImage(image, plugin);
		}

		if (currentScaledSprite == null)
		{
			return null;
		}

		final Point mousePos = client.getMouseCanvasPosition();
		graphics.drawImage(scaledBlankCursor, mousePos.getX() + scaledOffset.getX(), mousePos.getY() + scaledOffset.getY(), null);
		final int spriteX = scaledOffset.getX() + scaledCenterPoint.getX() - currentScaledSprite.getWidth(null) / 2;
		final int spriteY = scaledOffset.getY() + scaledCenterPoint.getY() - currentScaledSprite.getHeight(null) / 2;
		graphics.drawImage(currentScaledSprite, mousePos.getX() + spriteX, mousePos.getY() + spriteY, null);
		return null;
	}

	public void updateScale()
	{
		scaledCenterPoint = scalePoint(CENTRAL_POINT, plugin.getCursorScale());
		scaledOffset = scalePoint(POINTER_OFFSET, plugin.getCursorScale());
		rerenderImages();
	}

	public void rerenderImages()
	{
		if (blankCursor != null)
		{
			scaledBlankCursor = scaleImage(blankCursor, plugin);
		}
		currentScaledSprite = null;
	}
}

/*
 * Copyright (c) 2019-2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import com.github.ldavid432.contextualcursor.sprite.Sprite;
import java.util.HashMap;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.gameval.SpriteID;

@AllArgsConstructor
public enum SpellSprite
{
	// Standard
	WIND_STRIKE(SpriteID.Magicon.WIND_STRIKE),
	CONFUSE(SpriteID.Magicon.CONFUSE),
	WATER_STRIKE(SpriteID.Magicon.WATER_STRIKE),
	LVL_1_ENCHANT("lvl-1 enchant", SpriteID.Magicon.LVL_1_ENCHANT),
	EARTH_STRIKE(SpriteID.Magicon.EARTH_STRIKE),
	WEAKEN(SpriteID.Magicon.WEAKEN),
	FIRE_STRIKE(SpriteID.Magicon.FIRE_STRIKE),
	WIND_BOLT(SpriteID.Magicon.WIND_BOLT),
	CURSE(SpriteID.Magicon.CURSE),
	BIND(SpriteID.Magicon2.BIND),
	LOW_LEVEL_ALCHEMY(SpriteID.Magicon.LOW_LEVEL_ALCHEMY),
	WATER_BOLT(SpriteID.Magicon.WATER_BOLT),
	LVL_2_ENCHANT("lvl-2 enchant", SpriteID.Magicon.LVL_2_ENCHANT),
	EARTH_BOLT(SpriteID.Magicon.EARTH_BOLT),
	TELEKINETIC_GRAB(SpriteID.Magicon.TELEKINETIC_GRAB),
	FIRE_BOLT(SpriteID.Magicon.FIRE_BOLT),
	CRUMBLE_UNDEAD(SpriteID.Magicon.CRUMBLE_UNDEAD),
	WIND_BLAST(SpriteID.Magicon.WIND_BLAST),
	SUPERHEAT_ITEM(SpriteID.Magicon.SUPERHEAT_ITEM),
	WATER_BLAST(SpriteID.Magicon.WATER_BLAST),
	LVL_3_ENCHANT("lvl-3 enchant", SpriteID.Magicon.LVL_3_ENCHANT),
	IBAN_BLAST(SpriteID.Magicon.IBAN_BLAST),
	SNARE(SpriteID.Magicon2.SNARE),
	MAGIC_DART(SpriteID.Magicon2.MAGIC_DART),
	EARTH_BLAST(SpriteID.Magicon.EARTH_BLAST),
	HIGH_LEVEL_ALCHEMY(SpriteID.Magicon.HIGH_LEVEL_ALCHEMY),
	CHARGE_WATER_ORB(SpriteID.Magicon.CHARGE_WATER_ORB),
	LVL_4_ENCHANT("lvl-4 enchant", SpriteID.Magicon.LVL_4_ENCHANT),
	FIRE_BLAST(SpriteID.Magicon.FIRE_BLAST),
	CHARGE_EARTH_ORB(SpriteID.Magicon.CHARGE_EARTH_ORB),
	SARADOMIN_STRIKE(SpriteID.Magicon.SARADOMIN_STRIKE),
	CLAWS_OF_GUTHIX(SpriteID.Magicon.CLAWS_OF_GUTHIX),
	FLAMES_OF_ZAMORAK(SpriteID.Magicon.FLAMES_OF_ZAMORAK),
	WIND_WAVE(SpriteID.Magicon.WIND_WAVE),
	CHARGE_FIRE_ORB(SpriteID.Magicon.CHARGE_FIRE_ORB),
	WATER_WAVE(SpriteID.Magicon.WATER_WAVE),
	CHARGE_AIR_ORB(SpriteID.Magicon.CHARGE_AIR_ORB),
	VULNERABILITY(SpriteID.Magicon.VULNERABILITY),
	LVL_5_ENCHANT("lvl-5 enchant", SpriteID.Magicon.LVL_5_ENCHANT),
	EARTH_WAVE(SpriteID.Magicon.EARTH_WAVE),
	ENFEEBLE(SpriteID.Magicon.ENFEEBLE),
	TELEOTHER_LUMBRIDGE(SpriteID.Magicon2.TELEOTHER_LUMBRIDGE),
	FIRE_WAVE(SpriteID.Magicon.FIRE_WAVE),
	ENTANGLE(SpriteID.Magicon2.ENTANGLE),
	STUN(SpriteID.Magicon.STUN),
	WIND_SURGE(SpriteID.Magicon2.WIND_SURGE),
	TELEOTHER_FALADOR(SpriteID.Magicon2.TELEOTHER_FALADOR),
	WATER_SURGE(SpriteID.Magicon2.WATER_SURGE),
	TELE_BLOCK(SpriteID.Magicon2.TELE_BLOCK),
	LVL_6_ENCHANT("lvl-6 enchant", SpriteID.Magicon2.LVL_6_ENCHANT),
	TELEOTHER_CAMELOT(SpriteID.Magicon2.TELEOTHER_CAMELOT),
	EARTH_SURGE(SpriteID.Magicon2.EARTH_SURGE),
	LVL_7_ENCHANT("lvl-7 enchant", SpriteID.Magicon2.LVL_7_ENCHANT),
	FIRE_SURGE(SpriteID.Magicon2.FIRE_SURGE),
	// Ancients
	SMOKE_RUSH(SpriteID.Magicon2.SMOKE_RUSH),
	SHADOW_RUSH(SpriteID.Magicon2.SHADOW_RUSH),
	BLOOD_RUSH(SpriteID.Magicon2.BLOOD_RUSH),
	ICE_RUSH(SpriteID.Magicon2.ICE_RUSH),
	SMOKE_BURST(SpriteID.Magicon2.SMOKE_BURST),
	SHADOW_BURST(SpriteID.Magicon2.SHADOW_BURST),
	BLOOD_BURST(SpriteID.Magicon2.BLOOD_BURST),
	ICE_BURST(SpriteID.Magicon2.ICE_BURST),
	SMOKE_BLITZ(SpriteID.Magicon2.SMOKE_BLITZ),
	SHADOW_BLITZ(SpriteID.Magicon2.SHADOW_BLITZ),
	BLOOD_BLITZ(SpriteID.Magicon2.BLOOD_BLITZ),
	ICE_BLITZ(SpriteID.Magicon2.ICE_BLITZ),
	SMOKE_BARRAGE(SpriteID.Magicon2.SMOKE_BARRAGE),
	SHADOW_BARRAGE(SpriteID.Magicon2.SHADOW_BARRAGE),
	BLOOD_BARRAGE(SpriteID.Magicon2.BLOOD_BARRAGE),
	ICE_BARRAGE(SpriteID.Magicon2.ICE_BARRAGE),
	// Lunars
	CURE_PLANT(SpriteID.LunarMagicOn.CURE_PLANT),
	MONSTER_EXAMINE(SpriteID.LunarMagicOn.MONSTER_EXAMINE),
	STAT_SPY(SpriteID.LunarMagicOn.STAT_SPY),
	FERTILE_SOIL(SpriteID.LunarMagicOn.FERTILE_SOIL),
	PLANK_MAKE(SpriteID.LunarMagicOn.PLANK_MAKE),
	CURE_OTHER(SpriteID.LunarMagicOn.CURE_OTHER),
	STAT_RESTORE_POT_SHARE(SpriteID.LunarMagicOn.STAT_RESTORE_POT_SHARE),
	BOOST_POTION_SHARE(SpriteID.LunarMagicOn.BOOST_POTION_SHARE),
	ENERGY_TRANSFER(SpriteID.LunarMagicOn.ENERGY_TRANSFER),
	HEAL_OTHER(SpriteID.LunarMagicOn.HEAL_OTHER),
	VENGEANCE_OTHER(SpriteID.LunarMagicOn.VENGEANCE_OTHER),
	// Arceuus
	BASIC_REANIMATION(SpriteID.MagicNecroOn.BASIC_REANIMATION),
	ADEPT_REANIMATION(SpriteID.MagicNecroOn.ADEPT_REANIMATION),
	EXPERT_REANIMATION(SpriteID.MagicNecroOn.EXPERT_REANIMATION),
	MASTER_REANIMATION(SpriteID.MagicNecroOn.MASTER_REANIMATION),
	RESURRECT_CROPS(SpriteID.MagicNecroOn.RESURRECT_CROPS),
	DARK_LURE(SpriteID.MagicNecroOn.DARK_LURE),
	MARK_OF_DARKNESS(SpriteID.MagicNecroOn.MARK_OF_DARKNESS),
	GHOSTLY_GRASP(SpriteID.MagicNecroOn.GHOSTLY_GRASP),
	SKELETAL_GRASP(SpriteID.MagicNecroOn.SKELETAL_GRASP),
	UNDEAD_GRASP(SpriteID.MagicNecroOn.UNDEAD_GRASP),
	INFERIOR_DEMONBANE(SpriteID.MagicNecroOn.INFERIOR_DEMONBANE),
	SUPERIOR_DEMONBANE(SpriteID.MagicNecroOn.SUPERIOR_DEMONBANE),
	DARK_DEMONBANE(SpriteID.MagicNecroOn.DARK_DEMONBANE);

	private final String name;
	@Getter
	private final Sprite sprite;

	SpellSprite(int spriteID)
	{
		this(null, Sprite.of(spriteID));
	}

	SpellSprite(String name, int spriteID)
	{
		this(name, Sprite.of(spriteID));
	}

	private String getName()
	{
		return name != null ? name : this.name().toLowerCase().replace("_", " ");
	}

	private static final Map<String, SpellSprite> map = new HashMap<>();

	static
	{
		for (SpellSprite spell : values())
		{
			map.put(spell.getName(), spell);
		}
	}

	static SpellSprite get(String spell)
	{
		return map.get(spell);
	}

	static void clearImages()
	{
		for (SpellSprite spell : map.values())
		{
			spell.sprite.clearImage();
		}
	}
}

/*
 * Copyright (c) 2020-2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import com.github.ldavid432.contextualcursor.ContextualCursorConfig;
import static com.github.ldavid432.contextualcursor.ContextualCursorConfig.DEBUG_TOOLTIP;
import static com.github.ldavid432.contextualcursor.ContextualCursorConfig.SCALE;
import static com.github.ldavid432.contextualcursor.ContextualCursorConfig.SCALE_SMOOTHING;
import com.github.ldavid432.contextualcursor.menuentry.MenuTarget;
import com.github.ldavid432.contextualcursor.sprite.Sprite;
import com.google.inject.Provides;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;
import javax.inject.Inject;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseAdapter;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@PluginDescriptor(
	name = "Contextual Cursor",
	description = "RSHD-style image cursors",
	tags = {"cursor", "rs3", "rs2", "rshd", "context"}
)
@Slf4j
public class ContextualCursorPlugin extends Plugin implements KeyListener
{
	@Inject
	private ContextualCursorDrawOverlay contextualCursorDrawOverlay;
	@Inject
	private ContextualCursorWorkerOverlay contextualCursorWorkerOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private ContextualCursorConfig config;

	@Getter
	private boolean altPressed;

	@Getter
	private boolean isDebugTooltipEnabled;

	@Getter
	@Setter
	@Nullable
	private Sprite spriteToDraw;

	@Getter
	private double cursorScale = 1.0;

	@Getter
	private boolean isSmoothScalingEnabled;

	@Getter
	private final Map<MenuTarget, Boolean> ignoredTargets = new HashMap<>();

	private final MouseListener mouseListener = new MouseAdapter()
	{
		@Override
		public MouseEvent mouseEntered(MouseEvent mouseEvent)
		{
			altPressed = mouseEvent.isAltDown();
			return mouseEvent;
		}

		@Override
		public MouseEvent mouseExited(MouseEvent mouseEvent)
		{
			altPressed = mouseEvent.isAltDown();
			return mouseEvent;
		}
	};

	protected void startUp()
	{
		overlayManager.add(contextualCursorWorkerOverlay);
		overlayManager.add(contextualCursorDrawOverlay);
		keyManager.registerKeyListener(this);
		mouseManager.registerMouseListener(mouseListener);

		isSmoothScalingEnabled = config.isCursorSmoothScalingEnabled();
		updateIgnores();
		updateScale();
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(contextualCursorWorkerOverlay);
		overlayManager.remove(contextualCursorDrawOverlay);
		contextualCursorWorkerOverlay.resetCursor();
		clearImages();
		keyManager.unregisterKeyListener(this);
		mouseManager.unregisterMouseListener(mouseListener);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() != GameState.LOGGED_IN && event.getGameState() != GameState.LOADING)
		{
			contextualCursorWorkerOverlay.resetCursor();
		}
	}

	@Override
	public void keyPressed(KeyEvent keyEvent)
	{
		altPressed = keyEvent.isAltDown();
	}

	@Override
	public void keyReleased(KeyEvent keyEvent)
	{
		altPressed = keyEvent.isAltDown();
	}

	@Override
	public void keyTyped(KeyEvent keyEvent)
	{

	}

	@Provides
	ContextualCursorConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ContextualCursorConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (Objects.equals(event.getGroup(), ContextualCursorConfig.GROUP))
		{
			if (event.getKey().startsWith("ignore"))
			{
				updateIgnores();
			}
			else if (event.getKey().equals(DEBUG_TOOLTIP))
			{
				isDebugTooltipEnabled = config.isDebugTooltipEnabled();
			}
			else if (event.getKey().equals(SCALE))
			{
				updateScale();
			}
			 else if (event.getKey().equals(SCALE_SMOOTHING))
			{
				isSmoothScalingEnabled = config.isCursorSmoothScalingEnabled();
				contextualCursorDrawOverlay.rerenderImages();
			}
		}
	}

	private void updateIgnores()
	{
		for (MenuTarget target : MenuTarget.VALUES)
		{
			ignoredTargets.put(target, target.isIgnored(config));
		}
	}

	private void updateScale()
	{
		cursorScale = (double) config.getCursorScale() / 100;
		contextualCursorWorkerOverlay.updateScale();
		contextualCursorDrawOverlay.updateScale();
	}

	private void clearImages()
	{
		ContextualCursor.clearImages();
		SpellSprite.clearImages();
	}
}

/*
 * Copyright (c) 2020-2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import com.github.ldavid432.contextualcursor.menuentry.MenuTarget;
import com.github.ldavid432.contextualcursor.sprite.Sprite;
import static io.hydrox.contextualcursor.ContextualCursor.GENERIC_CURSOR;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import java.util.Objects;
import java.util.stream.Stream;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Menu;
import net.runelite.api.MenuEntry;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ColorUtil;

@Slf4j
public class ContextualCursorWorkerOverlay extends Overlay
{
	private static final Cursor BLANK_MOUSE = Toolkit.getDefaultToolkit().createCustomCursor(
		new BufferedImage(32, 32, BufferedImage.TYPE_INT_ARGB),
		new java.awt.Point(0, 0),
		"blank"
	);
	private static final int MENU_OPTION_HEIGHT = 15;
	private static final int MENU_EXTRA_TOP = 4;

	private final Client client;
	private final ClientUI clientUI;
	private final ContextualCursorPlugin plugin;
	private final SpriteManager spriteManager;
	private final TooltipManager tooltipManager;

	// Last top level menu entry that has a submenu
	private MenuEntry lastSubmenuEntry;
	private boolean isInSubmenu;
	private boolean cursorOverriden;
	private Cursor originalCursor;
	private Tooltip spacerTooltip;

	@Inject
	ContextualCursorWorkerOverlay(Client client, ClientUI clientUI, ContextualCursorPlugin plugin,
								  SpriteManager spriteManager, TooltipManager tooltipManager)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(1f);
		this.client = client;
		this.clientUI = clientUI;
		this.plugin = plugin;
		this.spriteManager = spriteManager;
		this.tooltipManager = tooltipManager;
	}

	private void storeOriginalCursor()
	{
		if (cursorOverriden)
		{
			return;
		}
		final Cursor currentCursor = clientUI.getCurrentCursor();
		if (!currentCursor.getName().equals("blank"))
		{
			originalCursor = clientUI.getCurrentCursor();
		}
	}

	void resetCursor()
	{
		if (cursorOverriden)
		{
			cursorOverriden = false;
			plugin.setSpriteToDraw(null);
			if (originalCursor != null)
			{
				clientUI.setCursor(originalCursor);
			}
			else
			{
				clientUI.resetCursor();
			}
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.isAltPressed())
		{
			resetCursor();
			return null;
		}

		final MenuEntry menuEntry;

		if (client.isMenuOpen())
		{
			menuEntry = processMenu(client.getMenu());
		}
		else
		{
			isInSubmenu = false;
			lastSubmenuEntry = null;
			final MenuEntry[] menuEntries = client.getMenu().getMenuEntries();
			int last = menuEntries.length - 1;

			if (last < 0)
			{
				return null;
			}

			menuEntry = menuEntries[last];
		}

		if (menuEntry == null || isEntryIgnored(menuEntry, isInSubmenu))
		{
			debugTooltip(true, menuEntry);
			resetCursor();
			return null;
		}

		debugTooltip(false, menuEntry);
		processEntry(menuEntry, isInSubmenu);
		return null;
	}

	private MenuEntry processMenu(Menu menu)
	{
		final MenuEntry lastSubmenuEntry1 = lastSubmenuEntry;
		// This is slightly bugged since there is a small margin around menus where they will stay open (see other comment below)
		//  so this may think you are in a submenu if you move just outside the parent menu where the submenu would appear
		//  Not much we can do about it unless there is a way to determine if a submenu is open or closed
		if (isCursorOutsideMenu(menu) && lastSubmenuEntry1 != null && lastSubmenuEntry1.getSubMenu() != null && !isCursorOutsideMenu(lastSubmenuEntry1.getSubMenu()))
		{
			return processSubmenu(lastSubmenuEntry1.getSubMenu());
		}
		// Outside of parent menu, not in a submenu
		else if (isCursorOutsideMenu(menu))
		{
			return null;
		}

		final MenuEntry hoveredMenuEntry = getHoveredMenuEntry(menu);
		if (hoveredMenuEntry == null)
		{
			return null;
		}

		// This can bug out on stuff with submenus too close together (looking at you forestry basket)
		//  since there is some logic to allow you to move over other entries and to the submenu without closing the submenu
		//  https://github.com/runelite/runelite/issues/19670#issuecomment-3621605835
		if (hoveredMenuEntry.getSubMenu() != null)
		{
			lastSubmenuEntry = hoveredMenuEntry;
		}

		isInSubmenu = false;

		return hoveredMenuEntry;
	}

	private MenuEntry processSubmenu(Menu submenu)
	{
		final MenuEntry hoveredMenuEntry = getHoveredMenuEntry(submenu);
		if (hoveredMenuEntry == null)
		{
			return null;
		}

		isInSubmenu = true;

		return hoveredMenuEntry;
	}

	private MenuEntry getHoveredMenuEntry(Menu menu)
	{
		final MenuEntry[] menuEntries = menu.getMenuEntries();

		final int fromTop = (client.getMouseCanvasPosition().getY() - MENU_EXTRA_TOP) - menu.getMenuY();

		final int index = menuEntries.length - (fromTop / MENU_OPTION_HEIGHT);

		if (index >= menuEntries.length || index < 0)
		{
			return null;
		}

		return menuEntries[index];
	}

	private boolean isCursorOutsideMenu(Menu menu)
	{
		return menu.getMenuX() > client.getMouseCanvasPosition().getX() || menu.getMenuX() + menu.getMenuWidth() < client.getMouseCanvasPosition().getX();
	}

	private void processEntry(MenuEntry menuEntry, boolean isSubMenu)
	{
		Sprite sprite = ContextualCursor.get(menuEntry);

		// If we don't have a cursor for the submenu entry then use the parent cursor
		final MenuEntry lastSubmenuEntry1 = lastSubmenuEntry;
		if (sprite == null && isSubMenu && lastSubmenuEntry1 != null)
		{
			processEntry(lastSubmenuEntry1, false);
			return;
		}
		else
		{
			sprite = Objects.requireNonNullElse(sprite, GENERIC_CURSOR);
		}

		setSpriteToDraw(sprite);
	}

	private boolean isEntryIgnored(MenuEntry entry, boolean isInSubmenu)
	{
		MenuTarget target = mapTarget(entry, isInSubmenu);
		return plugin.getIgnoredTargets().getOrDefault(target, false);
	}

	private MenuTarget mapTarget(MenuEntry entry, boolean isInSubmenu)
	{
		for (MenuTarget target : MenuTarget.VALUES)
		{
			if (target.getMatcher().matches(entry) ||
				// isInSubmenu isn't available in the MenuEntryMatcher
				(target == MenuTarget.ITEM && isInSubmenu && entry.getItemId() > 0))
			{
				return target;
			}
		}
		return MenuTarget.OTHER;
	}

	private void setSpriteToDraw(Sprite sprite)
	{
		storeOriginalCursor();
		clientUI.setCursor(BLANK_MOUSE);
		cursorOverriden = true;
		plugin.setSpriteToDraw(sprite);
		// Add an empty tooltip to keep real tooltips out of the way
		if (spacerTooltip != null)
		{
			tooltipManager.addFront(spacerTooltip);
		}
	}

	private void debugTooltip(boolean isIgnored, MenuEntry entry)
	{
		if (entry == null || !plugin.isDebugTooltipEnabled())
		{
			return;
		}

		String ignored = null;
		if (isIgnored)
		{
			ignored = ColorUtil.wrapWithColorTag("Ignored", Color.RED);
		}

		String name = String.format("option=%s, type=%s", entry.getOption(), entry.getType());
		if (entry.getTarget() != null && !entry.getTarget().isBlank())
		{
			name += String.format(", target=%s", entry.getTarget());
		}

		String item = null;
		if (entry.isItemOp() || entry.getItemId() > 0)
		{
			item = String.format("Item: isItemOp=%s, id=%s", entry.isItemOp(), entry.getItemId());
		}

		String npc = null;
		if (entry.getNpc() != null)
		{
			npc = String.format("NPC: %s", entry.getNpc().getName());
		}

		String player = null;
		if (entry.getPlayer() != null)
		{
			player = String.format("PLayer: %s", entry.getPlayer().getName());
		}

		tooltipManager.addFront(
			new Tooltip(
				Stream.of(ignored, name, item, npc, player)
					.filter(Objects::nonNull)
					.reduce((s1, s2) -> s1 + "<br>" + s2)
					.get()
			)
		);
	}

	public void updateScale()
	{
		int spacerHeight = (int) ((40 * plugin.getCursorScale()) - 30);
		if (spacerHeight > 0)
		{
			spacerTooltip = new Tooltip(
				new ImageComponent(new BufferedImage(1, (int) ((40 * plugin.getCursorScale()) - 30), BufferedImage.TYPE_INT_ARGB))
			);
		}
		else
		{
			spacerTooltip = null;
		}
	}
}

/*
 * Copyright (c) 2019-2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatcher;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.hasAllOf;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.hasAnyOf;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.hasOption;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isGroundItem;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isNpc;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isObject;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isSpell;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isWidgetTarget;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.not;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.optionIsAnyOf;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.optionStartsWith;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.targetEndsWith;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.targetNamed;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.targetStartsWith;
import com.github.ldavid432.contextualcursor.sprite.ResourceSprite;
import com.github.ldavid432.contextualcursor.sprite.Sprite;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.MenuEntry;
import net.runelite.api.gameval.SpriteID;
import net.runelite.client.util.Text;

@Slf4j
public enum ContextualCursor
{
	BANK("bank", optionIsAnyOf("bank", "coffer"),
		hasAllOf(hasOption("use"), targetNamed("bank chest"))),
	CLOSE("close", "close", "disembark"),
	CONFIGURE(SpriteID.OptionsIcons._51, "configure", "configuration"), // Wrench sprite
	DRINK("drink", "drink"),
	DROP("drop", "drop", "empty", "deposit", "quick-deposit", "deposit-cargo", "empty basket", "bank-cargo"),
	EAT("eat", "eat"),
	ENTER("enter", "climb-into", "enter", "exit", "yanille", "varrock", "seers' village", "camelot",
		"grand exchange", "watchtower", "go-through", "pass-through", "pass"),
	EQUIP("equip", "wield", "wear", "equip"),
	EXCHANGE(SpriteID.GeSmallicons.GUIDE_PRICE, optionIsAnyOf("exchange", "trade", "trade with", "buy-boat"),
		hasAllOf(hasOption("collect"), not(targetEndsWith("coral")))),
	FRIEND(SpriteID.SideiconsInterface.FRIENDS, "add friend"),
	IGNORE(SpriteID.SideiconsInterface.IGNORES, "add ignore"),
	IMPOSSIBLE("impossible", "destroy", "stop-navigating", "cancel-task"),
	LADDER("ladder", "climb"),
	LADDER_DOWN("ladder_down", "climb-down", "climb down", "bottom-floor"),
	LADDER_UP("ladder_up", "climb-up", "climb up", "top-floor"),
	OPEN("open", "open"),
	PICK_UP("pick_up", optionIsAnyOf("take", "withdraw", "fill", "take-cargo", "take-last-cargo",
		"collect-from", "take-from", "pick-up", "take-knife", "take-any-cargo"),
		hasAllOf(hasOption("harvest"), isNpc())), // Various NPC corpses
	PLANK("plank", "buy-plank"),
	READ("read", "read", "story"),
	REPORT(SpriteID.PvpwIcons.DEADMAN_EXCLAMATION_MARK_SKULLED_WARNING, "report"),
	SEARCH("search", optionIsAnyOf("lookup", "examine", "view", "look-inside", "inspect"),
		hasAllOf(hasOption("check"), not(isGroundItem())), // Avoid hunter traps
		hasAllOf(hasOption("search"), not(targetNamed("wiki")))),
	TALK("talk", "talk", "talk-to", "talk to", "command"),
	UNTIE("untie", hasOption("tether"), isWidgetTarget("use", "rope")),
	USE("use", "use", "pet"),
	WIKI("wiki", hasOption("lookup-entity"), hasAllOf(hasOption("search"), targetNamed("wiki"))),

	// Sailing
	NAVIGATE(SpriteID.IconSailingFacilities24x24._4, hasAllOf(hasOption("navigate"), targetNamed("helm"))), // Ship's wheel
	SALVAGE(SpriteID.IconSailingFacilities24x24._5, "deploy"), // Salvage hook
	UNSET_SAILS(SpriteID.IconSailingFacilities24x24._0, hasAllOf(hasOption("un-set"), targetNamed("sails"))),
	SET_SAILS(SpriteID.IconSailingFacilities24x24._1, hasAllOf(hasOption("set"), targetNamed("sails"))),
	TRIM_SAILS(SpriteID.IconSailingFacilities24x24._2, hasAllOf(hasOption("trim"), isObject())), // Avoid trimmable capes
	CANNON(SpriteID.IconSailingFacilities24x24._6, optionIsAnyOf("check-ammunition", "reset-ammunition"),
		hasAllOf(targetEndsWith("cannon"), optionIsAnyOf("operate"))),
	TRAWLING_NET(SpriteID.IconSailingFacilities24x24._12, optionIsAnyOf("raise"),
		hasAllOf(targetEndsWith("trawling net"), optionIsAnyOf("operate"))),
	TRAWLING_NET_LOWER(SpriteID.IconSailingFacilities24x24._15, "lower"),
	CHUM_STATION(SpriteID.IconSailingFacilities24x24._16, hasAllOf(optionIsAnyOf("operate"),
		hasAnyOf(targetStartsWith("chum"), targetNamed("advanced chum station")))),
	WIND(SpriteID.IconSailingFacilities24x24._7, optionIsAnyOf("release-mote"),
		hasAllOf(hasOption("harvest"), targetNamed("crystal extractor"))),

	// Skills
	AGILITY(SpriteID.Staticons.AGILITY, optionIsAnyOf("balance", "balance-across", "climb-across", "climb-on", "climb-over",
		"cross", "grab", "grapple", "hurdle", "jump", "jump-up", "jump-to", "jump-off", "jump-in", "jump-on", "kick",
		"leap", "shoot", "squeeze-past", "squeeze-through", "swing", "swing across", "swing-across", "swing-on", "tap",
		"tag", "teeth-grip", "tread-softly", "vault", "walk-on", "walk-across", "crawl-through", "jump-over", "escape"),
		hasAllOf(hasOption("navigate"), not(targetNamed("helm")))), // underwater agility obstacles
	ATTACK(SpriteID.Staticons.ATTACK, "attack"),
	CONSTRUCTION(SpriteID.Staticons2.CONSTRUCTION, optionIsAnyOf("build", "remove", "modify", "upgrade", "build-trap"),
		hasAllOf(hasOption("craft"), targetNamed("shipwrights' workbench"))),
	COOKING(SpriteID.Staticons.COOKING, "cook", "churn", "cook-at", "prepare-fish"),
	CRAFTING(SpriteID.Staticons.CRAFTING, optionIsAnyOf("spin", "weave"),
		hasAllOf(hasOption("craft"), not(targetNamed("shipwrights' workbench")))), // crafting table / clockmaker's benches
	FARMING(SpriteID.Staticons2.FARMING, optionIsAnyOf("check-health", "rake", "pick", "pick-fruit", "clear",
		"pay", "guide", "cure"), hasAllOf(hasOption("harvest"), isObject(), not(targetNamed("crystal extractor"))), // Harvesting crops only
		hasAllOf(hasOption("collect"), targetEndsWith("coral")), // Collecting coral
		hasAllOf(optionStartsWith("pay"), isNpc()) // Paying farmers
	),
	FIREMAKING(SpriteID.Staticons.FIREMAKING, "light", "feed"),
	FISHING(SpriteID.Staticons.FISHING, optionIsAnyOf("net", "lure", "small net", "harpoon", "cage", "big net",
		"use-rod", "fish", "take-net"), hasAllOf(hasOption("bait"), isNpc())), // Bait fishing spots
	FLETCHING(SpriteID.Staticons.FLETCHING, "carve", "decorate"),
	HERBLORE(SpriteID.Staticons.HERBLORE, hasAllOf(optionIsAnyOf("clean"), targetStartsWith("grimy"))),
	HUNTER(SpriteID.Staticons2.HUNTER, optionIsAnyOf("catch", "lay", "dismantle", "reset", "set-trap"),
		hasAllOf(hasOption("check"), isGroundItem()), // Various hunter traps
		hasAllOf(hasOption("bait"), isObject())), // Crab traps
	MAGIC(SpriteID.Staticons.MAGIC, optionIsAnyOf("spellbook", "teleport", "teleport menu", "ancient", "lunar",
		"arceuus", "standard", "study"), hasAllOf(hasOption("venerate"), not(targetNamed("dark altar")))), // PoH spellbook altars
	MINING(SpriteID.Staticons.MINING, "mine", "smash-to-bits", "chip"),
	PRAYER(SpriteID.Staticons.PRAYER, "pray", "bury", "pray-at", "offer-fish", "scatter"),
	RANGED(SpriteID.Staticons.RANGED, "fire", "fire-at"),
	RUNECRAFTING(SpriteID.Staticons2.RUNECRAFT, optionIsAnyOf("craft-rune", "imbue", "reinvigorate"),
		hasAllOf(hasOption("venerate"), targetNamed("dark altar"))), // Avoid PoH spellbook altars
	SMITHING(SpriteID.Staticons.SMITHING, "smelt", "smith", "hammer", "refine"),
	SLAYER(SpriteID.Staticons2.SLAYER, "assignment"),
	STRENGTH(SpriteID.Staticons.STRENGTH, "bang", "move"),
	THIEVING(SpriteID.Staticons.THIEVING, "steal-from", "pickpocket", "search for traps", "pick-lock", "picklock", "bribe"),
	WOODCUTTING(SpriteID.Staticons.WOODCUTTING, "chop down", "chop-down", "chop", "cut", "hack"),
	SAILING(SpriteID.Staticons2.SAILING, "board", "board-previous", "board-friend", "dock", "customise-boat",
		"recover-boat", "sort-salvage", "chart", "pry-open", "collect-data", "start-trial", "start-previous-rank", "manage-crew"),

	SPELL("", isSpell())
		{
			@Override
			protected Sprite getSprite(MenuEntry menuEntry)
			{
				final Matcher spellFinder = SPELL_FINDER.matcher(menuEntry.getTarget().toLowerCase());

				if (!spellFinder.find())
				{
					return null;
				}

				final String spellText = spellFinder.group(1);
				final SpellSprite spell = SpellSprite.get(Text.sanitize(spellText));
				if (spell == null)
				{
					return null;
				}

				return spell.getSprite();
			}
		},
	;

	private final Sprite sprite;
	private final MenuEntryMatcher matcher;

	// Basic cursor with only global actions
	ContextualCursor(String cursorPath, String... actions)
	{
		this.sprite = Sprite.of(cursorPath);
		this.matcher = optionIsAnyOf(actions);
	}

	// Basic cursor with only global actions
	ContextualCursor(int spriteID, String... actions)
	{
		this.sprite = Sprite.of(spriteID);
		this.matcher = optionIsAnyOf(actions);
	}

	// Cursor with specific matchers
	ContextualCursor(String cursorPath, MenuEntryMatcher... matchers)
	{
		this.sprite = Sprite.of(cursorPath);
		this.matcher = hasAnyOf(matchers);
	}

	// Cursor with specific matchers
	ContextualCursor(int spriteID, MenuEntryMatcher... matchers)
	{
		this.sprite = Sprite.of(spriteID);
		this.matcher = hasAnyOf(matchers);
	}

	protected Sprite getSprite(MenuEntry menuEntry)
	{
		return sprite;
	}

	private static final Pattern SPELL_FINDER = Pattern.compile(">(.*?)(?:</col>| -> )");
	private static final ContextualCursor[] values = values();

	static Sprite get(MenuEntry menuEntry)
	{
		for (ContextualCursor cursor : values)
		{
			if (cursor.matcher.matches(menuEntry))
			{
				return cursor.getSprite(menuEntry);
			}
		}
		return null;
	}

	static final ResourceSprite BLANK_CURSOR = new ResourceSprite("blank");
	static final ResourceSprite GENERIC_CURSOR = new ResourceSprite("generic");

	static void clearImages()
	{
		for (ContextualCursor cursor : values)
		{
			cursor.sprite.clearImage();
		}

		BLANK_CURSOR.clearImage();
		GENERIC_CURSOR.clearImage();
	}
}

package com.github.ldavid432.contextualcursor;

import static com.github.ldavid432.contextualcursor.ContextualCursorConfig.GROUP;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(GROUP)
public interface ContextualCursorConfig extends Config
{
	String GROUP = "contextualcursor";
	String DEBUG_TOOLTIP = "showDebugTooltip";
	String SCALE = "scale";
	String SCALE_SMOOTHING = "scaleSmoothing";

	@ConfigSection(
		name = "Scale",
		description = "Adjust the cursor scaling",
		position = 0
	)
	String scaleSection = "scaleSection";

	@Range(min = 5)
	@Units(Units.PERCENT)
	@ConfigItem(
		name = "Cursor Scale",
		description = "Scale the contextual cursors size",
		keyName = SCALE,
		position = 0,
		section = scaleSection
	)
	default int getCursorScale()
	{
		return 100;
	}

	@ConfigItem(
		name = "Smooth Scaling",
		description = "Use a smooth scaling algorithm to scale the cursor",
		keyName = SCALE_SMOOTHING,
		position = 1,
		section = scaleSection
	)
	default boolean isCursorSmoothScalingEnabled()
	{
		return false;
	}

	@ConfigSection(
		name = "Ignores",
		description = "Don't show the contextual cursor for certain targets",
		position = 1
	)
	String ignoreSection = "ignoreSection";

	@ConfigItem(
		name = "Ignore NPCs",
		description = "Don't show contextual cursors on NPCs",
		keyName = "ignoreNpcs",
		position = 0,
		section = ignoreSection
	)
	default boolean shouldIgnoreNpcs()
	{
		return false;
	}

	@ConfigItem(
		name = "Ignore Objects",
		description = "Don't show contextual cursors on objects",
		keyName = "ignoreObjects",
		position = 1,
		section = ignoreSection
	)
	default boolean shouldIgnoreObjects()
	{
		return false;
	}

	@ConfigItem(
		name = "Ignore Inventory Items",
		description = "Don't show contextual cursors on items in your inventory",
		keyName = "ignoreItems",
		position = 2,
		section = ignoreSection
	)
	default boolean shouldIgnoreItems()
	{
		return false;
	}

	@ConfigItem(
		name = "Ignore Spells",
		description = "Don't show contextual cursors on spells",
		keyName = "ignoreSpells",
		position = 3,
		section = ignoreSection
	)
	default boolean shouldIgnoreSpells()
	{
		return false;
	}

	@ConfigItem(
		name = "Ignore Ground Items",
		description = "Don't show contextual cursors on items on the ground",
		keyName = "ignoreGroundItems",
		position = 4,
		section = ignoreSection
	)
	default boolean shouldIgnoreGroundItems()
	{
		return false;
	}

	@ConfigItem(
		name = "Ignore Players",
		description = "Don't show contextual cursors on players",
		keyName = "ignorePlayers",
		position = 5,
		section = ignoreSection
	)
	default boolean shouldIgnorePlayers()
	{
		return false;
	}

	@ConfigItem(
		name = "Ignore Interfaces",
		description = "Don't show contextual cursors on interfaces. It is not recommended to disable this as interface matching is not very accurate.",
		keyName = "ignoreInterfaces",
		position = 100,
		section = ignoreSection,
		// Maybe will look at adding this eventually but probably need to be more thorough with what is and isn't an interface
		//  Hopefully inventory and spellbook are good enough for now
		hidden = true
	)
	default boolean shouldIgnoreInterfaces()
	{
		return true;
	}

	@ConfigSection(
		name = "Debug",
		description = "Debugging options",
		position = 100,
		closedByDefault = true
	)
	String debugSection = "debugSection";

	@ConfigItem(
		name = "Debug Tooltip",
		description = "Shows a tooltip containing debug information on the current menu entry.<br>" +
			"If you'd like a specific menu entry to be added to the plugin you can screenshot<br>" +
			"the tooltip of your desired menu entry and include it in a GitHub issue.",
		keyName = DEBUG_TOOLTIP,
		position = 0,
		section = debugSection
	)
	default boolean isDebugTooltipEnabled()
	{
		return false;
	}

}

// TODO: ignore players

package com.github.ldavid432.contextualcursor.sprite;

import io.hydrox.contextualcursor.ContextualCursorPlugin;
import java.awt.image.BufferedImage;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import lombok.EqualsAndHashCode;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;

@EqualsAndHashCode(of = "fileName")
@RequiredArgsConstructor
public class ResourceSprite implements Sprite
{
	@Nonnull
	String fileName;

	@Nullable
	BufferedImage image;

	@Nullable
	@Override
	public BufferedImage getImage(Client client, SpriteManager spriteManager)
	{
		return getImage();
	}

	@Nullable
	public BufferedImage getImage()
	{
		if (image == null)
		{
			image = loadImage(fileName);
		}
		return image;
	}

	@Override
	public void clearImage()
	{
		image = null;
	}

	public static BufferedImage loadImage(String fileName)
	{
		return ImageUtil.loadImageResource(ContextualCursorPlugin.class, String.format("cursors/%s.png", fileName));
	}
}

package com.github.ldavid432.contextualcursor.sprite;

import java.awt.image.BufferedImage;
import javax.annotation.Nullable;
import net.runelite.api.Client;
import net.runelite.client.game.SpriteManager;

public interface Sprite
{
	@Nullable
	BufferedImage getImage(Client client, SpriteManager spriteManager);

	void clearImage();

	static Sprite of(int id)
	{
		return new CacheSprite(id);
	}

	static Sprite of(String path)
	{
		return new ResourceSprite(path);
	}
}

package com.github.ldavid432.contextualcursor.sprite;

import java.awt.image.BufferedImage;
import javax.annotation.Nullable;
import lombok.EqualsAndHashCode;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.client.game.SpriteManager;

@EqualsAndHashCode(of = "id")
@RequiredArgsConstructor
public class CacheSprite implements Sprite
{
	private final int id;

	@Nullable
	BufferedImage image;

	@Override
	public BufferedImage getImage(final Client client, final SpriteManager spriteManager)
	{
		if (image == null)
		{
			if (client.getSpriteOverrides().containsKey(id))
			{
				image = client.getSpriteOverrides().get(id).toBufferedImage();
			}
			else
			{
				image = spriteManager.getSprite(id, 0);
			}
		}

		return image;
	}

	@Override
	public void clearImage()
	{
		image = null;
	}
}

package com.github.ldavid432.contextualcursor;

import io.hydrox.contextualcursor.ContextualCursorPlugin;
import java.awt.Image;
import java.awt.image.BufferedImage;
import net.runelite.api.Point;

public class ContextualCursorUtil
{
	public static Image scaleImage(BufferedImage image, ContextualCursorPlugin plugin)
	{
		return scaleImage(image, plugin.getCursorScale(), plugin.isSmoothScalingEnabled());
	}

	private static Image scaleImage(BufferedImage image, double scale, boolean smoothScaling)
	{
		if (scale == 1.0)
		{
			return image;
		}
		else
		{
			return image.getScaledInstance(
				(int) (image.getWidth() * scale),
				(int) (image.getHeight() * scale),
				smoothScaling ? Image.SCALE_SMOOTH : Image.SCALE_FAST
			);
		}
	}

	public static Point scalePoint(Point point, double scale)
	{
		if (scale == 1.0)
		{
			return point;
		}
		else
		{
			return new Point((int) (point.getX() * scale), (int) (point.getY() * scale));
		}
	}
}

package com.github.ldavid432.contextualcursor.menuentry;

import com.github.ldavid432.contextualcursor.ContextualCursorConfig;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.hasAllOf;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isCancel;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isGroundItem;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isInterface;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isMovement;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isNpc;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isObject;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isPlayer;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isSpell;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.optionIsAnyOf;
import java.util.function.Function;
import lombok.Getter;
import net.runelite.api.MenuEntry;

public enum MenuTarget
{
	ALWAYS_IGNORED(c -> true, isMovement(), isCancel()),
	ITEM(ContextualCursorConfig::shouldIgnoreItems, MenuEntry::isItemOp,
		hasAllOf(entry -> entry.getItemId() > 0, optionIsAnyOf("use", "examine"))),
	SPELL(ContextualCursorConfig::shouldIgnoreSpells, isSpell()),
	INTERFACE(ContextualCursorConfig::shouldIgnoreInterfaces, isInterface()),
	NPC(ContextualCursorConfig::shouldIgnoreNpcs, isNpc()),
	GROUND_ITEM(ContextualCursorConfig::shouldIgnoreGroundItems, isGroundItem()),
	OBJECT(ContextualCursorConfig::shouldIgnoreObjects, isObject()),
	PLAYER(ContextualCursorConfig::shouldIgnorePlayers, isPlayer()),
	OTHER(c -> false, e -> true);

	private final Function<ContextualCursorConfig, Boolean> isIgnored;
	@Getter
	private final MenuEntryMatcher matcher;

	public boolean isIgnored(ContextualCursorConfig config)
	{
		return isIgnored.apply(config);
	}

	MenuTarget(Function<ContextualCursorConfig, Boolean> isIgnored, MenuEntryMatcher... matchers)
	{
		this.isIgnored = isIgnored;
		this.matcher = MenuEntryMatchers.hasAnyOf(matchers);
	}

	public static final MenuTarget[] VALUES = values();
}

package com.github.ldavid432.contextualcursor.menuentry;

import net.runelite.api.MenuEntry;

public interface MenuEntryMatcher
{
	boolean matches(MenuEntry menuEntry);
}

package com.github.ldavid432.contextualcursor.menuentry;

import java.util.function.BiFunction;
import java.util.stream.Stream;
import net.runelite.api.MenuAction;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.ArrayUtils;

public class MenuEntryMatchers
{
	// General matchers

	public static MenuEntryMatcher not(MenuEntryMatcher matcher)
	{
		return menuEntry -> !matcher.matches(menuEntry);
	}

	public static MenuEntryMatcher hasAnyOf(MenuEntryMatcher... matchers)
	{
		return menuEntry -> Stream.of(matchers).anyMatch(matcher -> matcher.matches(menuEntry));
	}

	public static MenuEntryMatcher hasAllOf(MenuEntryMatcher... matchers)
	{
		return menuEntry -> Stream.of(matchers).allMatch(matcher -> matcher.matches(menuEntry));
	}

	// Menu options

	public static MenuEntryMatcher optionIsAnyOf(String... options)
	{
		return menuEntry -> Stream.of(options).map(MenuEntryMatchers::hasOption).anyMatch(matcher -> matcher.matches(menuEntry));
	}

	public static MenuEntryMatcher hasOption(String option)
	{
		return onOption(option, String::equals);
	}

	public static MenuEntryMatcher optionStartsWith(String optionPrefix)
	{
		return onOption(optionPrefix, String::startsWith);
	}

	private static MenuEntryMatcher onOption(String option, BiFunction<String, String, Boolean> test)
	{
		return menuEntry -> test.apply(sanitize(menuEntry.getOption()), option);
	}

	// NPCs

	public static MenuEntryMatcher isNpc()
	{
		return menuEntry -> menuEntry.getNpc() != null;
	}

	// Objects

	public static MenuEntryMatcher isObject()
	{
		return menuEntry -> ArrayUtils.contains(OBJECT_TYPES, menuEntry.getType());
	}

	private static final MenuAction[] OBJECT_TYPES = {
		MenuAction.GAME_OBJECT_FIRST_OPTION, MenuAction.GAME_OBJECT_SECOND_OPTION, MenuAction.GAME_OBJECT_THIRD_OPTION,
		MenuAction.GAME_OBJECT_FOURTH_OPTION, MenuAction.GAME_OBJECT_FIFTH_OPTION, MenuAction.EXAMINE_OBJECT
	};

	// Ground Items

	public static MenuEntryMatcher isGroundItem()
	{
		return menuEntry -> ArrayUtils.contains(GROUND_ITEM_TYPES, menuEntry.getType());
	}

	private static final MenuAction[] GROUND_ITEM_TYPES = {
		MenuAction.GROUND_ITEM_FIRST_OPTION, MenuAction.GROUND_ITEM_SECOND_OPTION, MenuAction.GROUND_ITEM_THIRD_OPTION,
		MenuAction.GROUND_ITEM_FOURTH_OPTION, MenuAction.GROUND_ITEM_FIFTH_OPTION, MenuAction.EXAMINE_ITEM_GROUND
	};

	// Targets

	private static MenuEntryMatcher onTarget(String target, BiFunction<String, String, Boolean> test)
	{
		return menuEntry -> test.apply(sanitize(menuEntry.getTarget()), target);
	}

	public static MenuEntryMatcher targetNamed(String target)
	{
		return onTarget(target, String::equals);
	}

	public static MenuEntryMatcher targetStartsWith(String targetPrefix)
	{
		return onTarget(targetPrefix, String::startsWith);
	}

	public static MenuEntryMatcher targetEndsWith(String targetSuffix)
	{
		return onTarget(targetSuffix, String::endsWith);
	}

	// Action types

	private static MenuEntryMatcher isTypeAnyOf(MenuAction... actions)
	{
		return menuEntry -> Stream.of(actions).anyMatch(action -> menuEntry.getType() == action);
	}

	public static MenuEntryMatcher isMovement()
	{
		return isTypeAnyOf(MenuAction.WALK, MenuAction.SET_HEADING);
	}

	public static MenuEntryMatcher isCancel()
	{
		return isTypeAnyOf(MenuAction.CANCEL);
	}

	// this doesn't work great
	public static MenuEntryMatcher isInterface()
	{
		return isTypeAnyOf(MenuAction.CC_OP, MenuAction.CC_OP_LOW_PRIORITY);
	}

	// Spellbook spells

	public static MenuEntryMatcher isSpell()
	{
		return hasAllOf(isWidgetTarget(), hasOption("cast"));
	}

	// Players

	public static MenuEntryMatcher isPlayer()
	{
		return menuEntry -> menuEntry.getPlayer() != null;
	}

	// Widget

	private static final MenuAction[] WIDGET_TYPES = new MenuAction[]{
		MenuAction.WIDGET_TARGET_ON_GAME_OBJECT, MenuAction.WIDGET_TARGET_ON_NPC, MenuAction.WIDGET_TARGET_ON_PLAYER,
		MenuAction.WIDGET_TARGET_ON_GROUND_ITEM, MenuAction.WIDGET_TARGET_ON_WIDGET, MenuAction.WIDGET_TARGET
	};

	public static MenuEntryMatcher isWidgetTarget()
	{
		return isTypeAnyOf(WIDGET_TYPES);
	}

	public static MenuEntryMatcher isWidgetTarget(String option, String fromTarget) {
		return hasAllOf(hasOption(option), isWidgetTarget(), targetStartsWith(fromTarget + " ->"));
	}

	// Util

	private static String sanitize(String text)
	{
		return Text.removeTags(Text.sanitize(text).toLowerCase());
	}
}

package io.hydrox.contextualcursor;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ContextualCursorPluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ContextualCursorPlugin.class);
		RuneLite.main(args);
	}
}

