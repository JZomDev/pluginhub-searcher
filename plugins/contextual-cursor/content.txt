/*
 * Copyright (c) 2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import static io.hydrox.contextualcursor.ContextualCursor.BLANK_CURSOR;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import javax.inject.Inject;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;

public class ContextualCursorDrawOverlay extends Overlay
{
	//The pointer sticks out to the left slightly, so this makes sure it's point to the correct spot
	private static final Point POINTER_OFFSET = new Point(-5, 0);
	//The centre of the circle (biased bottom right since it's an even size), for use with sprites
	private static final Point CENTRAL_POINT = new Point(16, 18);

	private final Client client;
	private final ContextualCursorPlugin plugin;

	@Inject
	ContextualCursorDrawOverlay(Client client, ContextualCursorPlugin plugin)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
		setPriority(OverlayPriority.HIGHEST);
		this.client = client;
		this.plugin = plugin;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		BufferedImage sprite = plugin.getSpriteToDraw();
		if (sprite == null)
		{
			return null;
		}

		final Point mousePos = client.getMouseCanvasPosition();
		graphics.drawImage(BLANK_CURSOR.getImage(), mousePos.getX() + POINTER_OFFSET.getX(), mousePos.getY() + POINTER_OFFSET.getY(), null);
		final int spriteX = POINTER_OFFSET.getX() + CENTRAL_POINT.getX() - sprite.getWidth() / 2;
		final int spriteY = POINTER_OFFSET.getY() + CENTRAL_POINT.getY() - sprite.getHeight() / 2;
		graphics.drawImage(sprite, mousePos.getX() + spriteX, mousePos.getY() + spriteY, null);
		return null;
	}
}

/*
 * Copyright (c) 2019-2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import lombok.AllArgsConstructor;
import java.util.HashMap;
import java.util.Map;
import net.runelite.api.gameval.SpriteID;

@AllArgsConstructor
public enum SpellSprite
{
	// Standard
	WIND_STRIKE(SpriteID.Magicon.WIND_STRIKE),
	CONFUSE(SpriteID.Magicon.CONFUSE),
	WATER_STRIKE(SpriteID.Magicon.WATER_STRIKE),
	LVL_1_ENCHANT("lvl-1 enchant", SpriteID.Magicon.LVL_1_ENCHANT),
	EARTH_STRIKE(SpriteID.Magicon.EARTH_STRIKE),
	WEAKEN(SpriteID.Magicon.WEAKEN),
	FIRE_STRIKE(SpriteID.Magicon.FIRE_STRIKE),
	WIND_BOLT(SpriteID.Magicon.WIND_BOLT),
	CURSE(SpriteID.Magicon.CURSE),
	BIND(SpriteID.Magicon2.BIND),
	LOW_LEVEL_ALCHEMY(SpriteID.Magicon.LOW_LEVEL_ALCHEMY),
	WATER_BOLT(SpriteID.Magicon.WATER_BOLT),
	LVL_2_ENCHANT("lvl-2 enchant", SpriteID.Magicon.LVL_2_ENCHANT),
	EARTH_BOLT(SpriteID.Magicon.EARTH_BOLT),
	TELEKINETIC_GRAB(SpriteID.Magicon.TELEKINETIC_GRAB),
	FIRE_BOLT(SpriteID.Magicon.FIRE_BOLT),
	CRUMBLE_UNDEAD(SpriteID.Magicon.CRUMBLE_UNDEAD),
	WIND_BLAST(SpriteID.Magicon.WIND_BLAST),
	SUPERHEAT_ITEM(SpriteID.Magicon.SUPERHEAT_ITEM),
	WATER_BLAST(SpriteID.Magicon.WATER_BLAST),
	LVL_3_ENCHANT("lvl-3 enchant", SpriteID.Magicon.LVL_3_ENCHANT),
	IBAN_BLAST(SpriteID.Magicon.IBAN_BLAST),
	SNARE(SpriteID.Magicon2.SNARE),
	MAGIC_DART(SpriteID.Magicon2.MAGIC_DART),
	EARTH_BLAST(SpriteID.Magicon.EARTH_BLAST),
	HIGH_LEVEL_ALCHEMY(SpriteID.Magicon.HIGH_LEVEL_ALCHEMY),
	CHARGE_WATER_ORB(SpriteID.Magicon.CHARGE_WATER_ORB),
	LVL_4_ENCHANT("lvl-4 enchant", SpriteID.Magicon.LVL_4_ENCHANT),
	FIRE_BLAST(SpriteID.Magicon.FIRE_BLAST),
	CHARGE_EARTH_ORB(SpriteID.Magicon.CHARGE_EARTH_ORB),
	SARADOMIN_STRIKE(SpriteID.Magicon.SARADOMIN_STRIKE),
	CLAWS_OF_GUTHIX(SpriteID.Magicon.CLAWS_OF_GUTHIX),
	FLAMES_OF_ZAMORAK(SpriteID.Magicon.FLAMES_OF_ZAMORAK),
	WIND_WAVE(SpriteID.Magicon.WIND_WAVE),
	CHARGE_FIRE_ORB(SpriteID.Magicon.CHARGE_FIRE_ORB),
	WATER_WAVE(SpriteID.Magicon.WATER_WAVE),
	CHARGE_AIR_ORB(SpriteID.Magicon.CHARGE_AIR_ORB),
	VULNERABILITY(SpriteID.Magicon.VULNERABILITY),
	LVL_5_ENCHANT("lvl-5 enchant", SpriteID.Magicon.LVL_5_ENCHANT),
	EARTH_WAVE(SpriteID.Magicon.EARTH_WAVE),
	ENFEEBLE(SpriteID.Magicon.ENFEEBLE),
	TELEOTHER_LUMBRIDGE(SpriteID.Magicon2.TELEOTHER_LUMBRIDGE),
	FIRE_WAVE(SpriteID.Magicon.FIRE_WAVE),
	ENTANGLE(SpriteID.Magicon2.ENTANGLE),
	STUN(SpriteID.Magicon.STUN),
	WIND_SURGE(SpriteID.Magicon2.WIND_SURGE),
	TELEOTHER_FALADOR(SpriteID.Magicon2.TELEOTHER_FALADOR),
	WATER_SURGE(SpriteID.Magicon2.WATER_SURGE),
	TELE_BLOCK(SpriteID.Magicon2.TELE_BLOCK),
	LVL_6_ENCHANT("lvl-6 enchant", SpriteID.Magicon2.LVL_6_ENCHANT),
	TELEOTHER_CAMELOT(SpriteID.Magicon2.TELEOTHER_CAMELOT),
	EARTH_SURGE(SpriteID.Magicon2.EARTH_SURGE),
	LVL_7_ENCHANT("lvl-7 enchant", SpriteID.Magicon2.LVL_7_ENCHANT),
	FIRE_SURGE(SpriteID.Magicon2.FIRE_SURGE),
	// Ancients
	SMOKE_RUSH(SpriteID.Magicon2.SMOKE_RUSH),
	SHADOW_RUSH(SpriteID.Magicon2.SHADOW_RUSH),
	BLOOD_RUSH(SpriteID.Magicon2.BLOOD_RUSH),
	ICE_RUSH(SpriteID.Magicon2.ICE_RUSH),
	SMOKE_BURST(SpriteID.Magicon2.SMOKE_BURST),
	SHADOW_BURST(SpriteID.Magicon2.SHADOW_BURST),
	BLOOD_BURST(SpriteID.Magicon2.BLOOD_BURST),
	ICE_BURST(SpriteID.Magicon2.ICE_BURST),
	SMOKE_BLITZ(SpriteID.Magicon2.SMOKE_BLITZ),
	SHADOW_BLITZ(SpriteID.Magicon2.SHADOW_BLITZ),
	BLOOD_BLITZ(SpriteID.Magicon2.BLOOD_BLITZ),
	ICE_BLITZ(SpriteID.Magicon2.ICE_BLITZ),
	SMOKE_BARRAGE(SpriteID.Magicon2.SMOKE_BARRAGE),
	SHADOW_BARRAGE(SpriteID.Magicon2.SHADOW_BARRAGE),
	BLOOD_BARRAGE(SpriteID.Magicon2.BLOOD_BARRAGE),
	ICE_BARRAGE(SpriteID.Magicon2.ICE_BARRAGE),
	// Lunars
	CURE_PLANT(SpriteID.LunarMagicOn.CURE_PLANT),
	MONSTER_EXAMINE(SpriteID.LunarMagicOn.MONSTER_EXAMINE),
	STAT_SPY(SpriteID.LunarMagicOn.STAT_SPY),
	FERTILE_SOIL(SpriteID.LunarMagicOn.FERTILE_SOIL),
	PLANK_MAKE(SpriteID.LunarMagicOn.PLANK_MAKE),
	CURE_OTHER(SpriteID.LunarMagicOn.CURE_OTHER),
	STAT_RESTORE_POT_SHARE(SpriteID.LunarMagicOn.STAT_RESTORE_POT_SHARE),
	BOOST_POTION_SHARE(SpriteID.LunarMagicOn.BOOST_POTION_SHARE),
	ENERGY_TRANSFER(SpriteID.LunarMagicOn.ENERGY_TRANSFER),
	HEAL_OTHER(SpriteID.LunarMagicOn.HEAL_OTHER),
	VENGEANCE_OTHER(SpriteID.LunarMagicOn.VENGEANCE_OTHER),
	// Arceuus
	BASIC_REANIMATION(SpriteID.MagicNecroOn.BASIC_REANIMATION),
	ADEPT_REANIMATION(SpriteID.MagicNecroOn.ADEPT_REANIMATION),
	EXPERT_REANIMATION(SpriteID.MagicNecroOn.EXPERT_REANIMATION),
	MASTER_REANIMATION(SpriteID.MagicNecroOn.MASTER_REANIMATION),
	RESURRECT_CROPS(SpriteID.MagicNecroOn.RESURRECT_CROPS),
	DARK_LURE(SpriteID.MagicNecroOn.DARK_LURE),
	MARK_OF_DARKNESS(SpriteID.MagicNecroOn.MARK_OF_DARKNESS),
	GHOSTLY_GRASP(SpriteID.MagicNecroOn.GHOSTLY_GRASP),
	SKELETAL_GRASP(SpriteID.MagicNecroOn.SKELETAL_GRASP),
	UNDEAD_GRASP(SpriteID.MagicNecroOn.UNDEAD_GRASP),
	INFERIOR_DEMONBANE(SpriteID.MagicNecroOn.INFERIOR_DEMONBANE),
	SUPERIOR_DEMONBANE(SpriteID.MagicNecroOn.SUPERIOR_DEMONBANE),
	DARK_DEMONBANE(SpriteID.MagicNecroOn.DARK_DEMONBANE);

	private final String name;
	final int spriteID;

	SpellSprite(int spriteID)
	{
		this(null, spriteID);
	}

	private String getName()
	{
		return name != null ? name : this.name().toLowerCase().replace("_", " ");
	}

	private static final Map<String, SpellSprite> map = new HashMap<>();

	static
	{
		for (SpellSprite spell : values())
		{
			map.put(spell.getName(), spell);
		}
	}

	static SpellSprite get(String spell)
	{
		return map.get(spell);
	}
}

/*
 * Copyright (c) 2020-2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import javax.inject.Inject;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

@PluginDescriptor(
	name = "Contextual Cursor",
	description = "RSHD-style image cursors",
	tags = {"cursor", "rs3", "rs2", "rshd", "context"}
)
@Slf4j
public class ContextualCursorPlugin extends Plugin implements KeyListener, MouseListener
{
	@Inject
	private ContextualCursorDrawOverlay contextualCursorDrawOverlay;
	@Inject
	private ContextualCursorWorkerOverlay contextualCursorWorkerOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private MouseManager mouseManager;

	@Getter
	private boolean altPressed;

	@Getter
	@Setter
	private BufferedImage spriteToDraw;

	protected void startUp()
	{
		overlayManager.add(contextualCursorWorkerOverlay);
		overlayManager.add(contextualCursorDrawOverlay);
		keyManager.registerKeyListener(this);
		mouseManager.registerMouseListener(this);
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(contextualCursorWorkerOverlay);
		overlayManager.remove(contextualCursorDrawOverlay);
		contextualCursorWorkerOverlay.resetCursor();
		ContextualCursor.clearImages();
		keyManager.unregisterKeyListener(this);
		mouseManager.unregisterMouseListener(this);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() != GameState.LOGGED_IN && event.getGameState() != GameState.LOADING)
		{
			contextualCursorWorkerOverlay.resetCursor();
		}
	}

	@Override
	public void keyPressed(KeyEvent keyEvent)
	{
		altPressed = keyEvent.isAltDown();
	}

	@Override
	public void keyReleased(KeyEvent keyEvent)
	{
		altPressed = keyEvent.isAltDown();
	}

	@Override
	public MouseEvent mouseEntered(MouseEvent mouseEvent)
	{
		altPressed = mouseEvent.isAltDown();
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseExited(MouseEvent mouseEvent)
	{
		altPressed = mouseEvent.isAltDown();
		return mouseEvent;
	}

	// Beyond this point is junk.
	// Look upon this method-bloat and despair!

	@Override
	public MouseEvent mouseDragged(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseMoved(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseClicked(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override
	public MouseEvent mousePressed(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseReleased(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override
	public void keyTyped(KeyEvent keyEvent)
	{

	}
}

/*
 * Copyright (c) 2020-2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import com.github.ldavid432.contextualcursor.sprite.Sprite;
import com.google.common.collect.Sets;
import static io.hydrox.contextualcursor.ContextualCursor.GENERIC_CURSOR;
import java.util.Objects;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.Text;
import javax.inject.Inject;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class ContextualCursorWorkerOverlay extends Overlay
{
	private static final Cursor BLANK_MOUSE = Toolkit.getDefaultToolkit().createCustomCursor(
		new BufferedImage(32, 32, BufferedImage.TYPE_INT_ARGB),
		new java.awt.Point(0, 0),
		"blank"
	);
	private static final Tooltip SPACER_TOOLTIP = new Tooltip(
		new ImageComponent(new BufferedImage(1, 10, BufferedImage.TYPE_INT_ARGB))
	);
	private static final Pattern SPELL_FINDER = Pattern.compile(">(.*?)(?:</col>| -> )");
	private static final int MENU_OPTION_HEIGHT = 15;
	private static final int MENU_EXTRA_TOP = 4;
	private static final Set<MenuAction> IGNORED_ACTIONS = Sets.newHashSet(
		MenuAction.WALK, MenuAction.CC_OP, MenuAction.CANCEL, MenuAction.CC_OP_LOW_PRIORITY, MenuAction.SET_HEADING
	);

	private final Client client;
	private final ClientUI clientUI;
	private final ContextualCursorPlugin plugin;
	private final SpriteManager spriteManager;
	private final TooltipManager tooltipManager;

	// Last top level menu entry that has a submenu
	private MenuEntry lastSubmenuEntry;
	private boolean isInSubmenu;
	private boolean cursorOverriden;
	private Cursor originalCursor;

	@Inject
	ContextualCursorWorkerOverlay(Client client, ClientUI clientUI, ContextualCursorPlugin plugin,
								  SpriteManager spriteManager, TooltipManager tooltipManager)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(OverlayPriority.HIGHEST);
		this.client = client;
		this.clientUI = clientUI;
		this.plugin = plugin;
		this.spriteManager = spriteManager;
		this.tooltipManager = tooltipManager;
	}

	private void storeOriginalCursor()
	{
		if (cursorOverriden)
		{
			return;
		}
		final Cursor currentCursor = clientUI.getCurrentCursor();
		if (!currentCursor.getName().equals("blank"))
		{
			originalCursor = clientUI.getCurrentCursor();
		}
	}

	void resetCursor()
	{
		if (cursorOverriden)
		{
			cursorOverriden = false;
			plugin.setSpriteToDraw(null);
			if (originalCursor != null)
			{
				clientUI.setCursor(originalCursor);
			}
			else
			{
				clientUI.resetCursor();
			}
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.isAltPressed())
		{
			resetCursor();
			return null;
		}

		final MenuEntry menuEntry;

		if (client.isMenuOpen())
		{
			menuEntry = processMenu(client.getMenu());
		}
		else
		{
			isInSubmenu = false;
			lastSubmenuEntry = null;
			final MenuEntry[] menuEntries = client.getMenu().getMenuEntries();
			int last = menuEntries.length - 1;

			if (last < 0)
			{
				return null;
			}

			menuEntry = menuEntries[last];
		}

		if (menuEntry == null ||
			(!(menuEntry.isItemOp() || (isInSubmenu && menuEntry.getItemId() > 0))
				&& !menuEntry.getOption().equals("Examine")
				&& IGNORED_ACTIONS.contains(menuEntry.getType())))
		{
			resetCursor();
			return null;
		}

		processEntry(menuEntry, isInSubmenu);
		return null;
	}

	private MenuEntry processMenu(Menu menu)
	{
		final MenuEntry lastSubmenuEntry1 = lastSubmenuEntry;
		// This is slightly bugged since there is a small margin around menus where they will stay open (see other comment below)
		//  so this may think you are in a submenu if you move just outside the parent menu where the submenu would appear
		//  Not much we can do about it unless there is a way to determine if a submenu is open or closed
		if (isCursorOutsideMenu(menu) && lastSubmenuEntry1 != null && lastSubmenuEntry1.getSubMenu() != null && !isCursorOutsideMenu(lastSubmenuEntry1.getSubMenu()))
		{
			return processSubmenu(lastSubmenuEntry1.getSubMenu());
		}
		// Outside of parent menu, not in a submenu
		else if (isCursorOutsideMenu(menu))
		{
			return null;
		}

		final MenuEntry hoveredMenuEntry = getHoveredMenuEntry(menu);
		if (hoveredMenuEntry == null)
		{
			return null;
		}

		// This can bug out on stuff with submenus too close together (looking at you forestry basket)
		//  since there is some logic to allow you to move over other entries and to the submenu without closing the submenu
		//  https://github.com/runelite/runelite/issues/19670#issuecomment-3621605835
		if (hoveredMenuEntry.getSubMenu() != null)
		{
			lastSubmenuEntry = hoveredMenuEntry;
		}

		isInSubmenu = false;

		return hoveredMenuEntry;
	}

	private MenuEntry processSubmenu(Menu submenu)
	{
		final MenuEntry hoveredMenuEntry = getHoveredMenuEntry(submenu);
		if (hoveredMenuEntry == null)
		{
			return null;
		}

		isInSubmenu = true;

		return hoveredMenuEntry;
	}

	private MenuEntry getHoveredMenuEntry(Menu menu)
	{
		final MenuEntry[] menuEntries = menu.getMenuEntries();

		final int fromTop = (client.getMouseCanvasPosition().getY() - MENU_EXTRA_TOP) - menu.getMenuY();

		final int index = menuEntries.length - (fromTop / MENU_OPTION_HEIGHT);

		if (index >= menuEntries.length || index < 0)
		{
			return null;
		}

		return menuEntries[index];
	}

	private boolean isCursorOutsideMenu(Menu menu)
	{
		return menu.getMenuX() > client.getMouseCanvasPosition().getX() || menu.getMenuX() + menu.getMenuWidth() < client.getMouseCanvasPosition().getX();
	}

	private static final Set<MenuAction> SPELL_TYPES = Sets.newHashSet(
		MenuAction.WIDGET_TARGET_ON_GAME_OBJECT, MenuAction.WIDGET_TARGET_ON_NPC, MenuAction.WIDGET_TARGET_ON_PLAYER,
		MenuAction.WIDGET_TARGET_ON_GROUND_ITEM, MenuAction.WIDGET_TARGET_ON_WIDGET, MenuAction.WIDGET_TARGET
	);

	private void processEntry(MenuEntry menuEntry, boolean isSubMenu)
	{
		final Sprite sprite;
		// TODO: Can the spell sprites be turned into a single "spell" cursor?
		if (SPELL_TYPES.contains(menuEntry.getType()) && menuEntry.getOption().equals("Cast"))
		{
			final Matcher spellFinder = SPELL_FINDER.matcher(menuEntry.getTarget().toLowerCase());

			if (!spellFinder.find())
			{
				return;
			}

			final String spellText = spellFinder.group(1);
			final SpellSprite spell = SpellSprite.get(Text.sanitize(spellText));
			if (spell == null)
			{
				return;
			}

			final BufferedImage magicSprite = spriteManager.getSprite(spell.spriteID, 0);
			if (magicSprite == null)
			{
				return;
			}

			setSpriteToDraw(magicSprite);
			return;
		}
		else
		{
			final Sprite newSprite = ContextualCursor.get(menuEntry);

			// If we don't have a cursor for the submenu entry then use the parent cursor
			final MenuEntry lastSubmenuEntry1 = lastSubmenuEntry;
			if (newSprite == null && isSubMenu && lastSubmenuEntry1 != null)
			{
				processEntry(lastSubmenuEntry1, false);
				return;
			}
			else
			{
				sprite = Objects.requireNonNullElse(newSprite, GENERIC_CURSOR);
			}
		}

		BufferedImage image = sprite.getImage(client, spriteManager);
		if (image != null)
		{
			setSpriteToDraw(image);
		}
	}

	private void setSpriteToDraw(BufferedImage sprite)
	{
		storeOriginalCursor();
		clientUI.setCursor(BLANK_MOUSE);
		cursorOverriden = true;
		plugin.setSpriteToDraw(sprite);
		// Add an empty tooltip to keep real tooltips out of the way
		tooltipManager.addFront(SPACER_TOOLTIP);
	}
}

/*
 * Copyright (c) 2019-2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatcher;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.hasAllOf;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.hasAnyOf;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.hasOption;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isGroundItem;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isNpc;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.isObject;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.not;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.optionIsAnyOf;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.targetEndsWith;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.targetNamed;
import static com.github.ldavid432.contextualcursor.menuentry.MenuEntryMatchers.targetStartsWith;
import com.github.ldavid432.contextualcursor.sprite.ResourceSprite;
import com.github.ldavid432.contextualcursor.sprite.Sprite;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.MenuEntry;
import net.runelite.api.gameval.SpriteID;

@Slf4j
@Getter
public enum ContextualCursor
{
	BANK("bank", "bank", "coffer"),
	CLOSE("close", "close", "disembark"),
	CONFIGURE(SpriteID.OptionsIcons._51, "configure", "configuration"), // Wrench sprite
	DRINK("drink", "drink"),
	DROP("drop", "drop", "empty", "deposit", "quick-deposit", "deposit-cargo", "empty basket", "bank-cargo"),
	EAT("eat", "eat"),
	ENTER("enter", "climb-into", "enter", "exit", "yanille", "varrock", "seers' village", "camelot",
		"grand exchange", "watchtower", "go-through", "pass-through", "pass"),
	EQUIP("equip", "wield", "wear", "equip"),
	EXCHANGE(SpriteID.GeSmallicons.GUIDE_PRICE, optionIsAnyOf("exchange", "trade", "trade with", "buy-boat"),
		hasAllOf(hasOption("collect"), not(targetEndsWith("coral")))),
	FRIEND(SpriteID.SideiconsInterface.FRIENDS, "add friend"),
	IGNORE(SpriteID.SideiconsInterface.IGNORES, "add ignore"),
	IMPOSSIBLE("impossible", "destroy", "stop-navigating", "cancel-task"),
	LADDER("ladder", "climb"),
	LADDER_DOWN("ladder_down", "climb-down", "climb down", "bottom-floor"),
	LADDER_UP("ladder_up", "climb-up", "climb up", "top-floor"),
	OPEN("open", "open"),
	PICK_UP("pick_up", optionIsAnyOf("take", "withdraw", "fill", "take-cargo", "take-last-cargo",
		"collect-from", "take-from", "pick-up", "take-knife", "take-any-cargo"),
		hasAllOf(hasOption("harvest"), isNpc())), // Various NPC corpses
	PLANK("plank", "buy-plank"),
	READ("read", "read", "story"),
	REPORT(SpriteID.PvpwIcons.DEADMAN_EXCLAMATION_MARK_SKULLED_WARNING, "report"),
	SEARCH("search", optionIsAnyOf("lookup", "examine", "view", "look-inside", "inspect"),
		hasAllOf(hasOption("check"), not(isGroundItem())), // Avoid hunter traps
		hasAllOf(hasOption("search"), not(targetNamed("wiki")))),
	TALK("talk", "talk", "talk-to", "talk to", "command"),
	UNTIE("untie", "tether"),
	USE("use", "use", "pet"),
	WIKI("wiki", hasOption("lookup-entity"), hasAllOf(hasOption("search"), targetNamed("wiki"))),

	// Sailing
	NAVIGATE(SpriteID.IconSailingFacilities24x24._4, hasAllOf(hasOption("navigate"), targetNamed("helm"))), // Ship's wheel
	SALVAGE(SpriteID.IconSailingFacilities24x24._5, "deploy"), // Salvage hook
	UNSET_SAILS(SpriteID.IconSailingFacilities24x24._0, "un-set"),
	SET_SAILS(SpriteID.IconSailingFacilities24x24._1, "set"),
	TRIM_SAILS(SpriteID.IconSailingFacilities24x24._2, hasAllOf(hasOption("trim"), isObject())), // Avoid trimmable capes
	CANNON(SpriteID.IconSailingFacilities24x24._6, optionIsAnyOf("check-ammunition", "reset-ammunition"),
		hasAllOf(targetEndsWith("cannon"), optionIsAnyOf("operate"))),
	TRAWLING_NET(SpriteID.IconSailingFacilities24x24._12, optionIsAnyOf("raise"),
		hasAllOf(targetEndsWith("trawling net"), optionIsAnyOf("operate"))),
	TRAWLING_NET_LOWER(SpriteID.IconSailingFacilities24x24._15, "lower"),
	CHUM_STATION(SpriteID.IconSailingFacilities24x24._16, hasAllOf(optionIsAnyOf("operate"),
		hasAnyOf(targetStartsWith("chum"), targetNamed("advanced chum station")))),
	WIND(SpriteID.IconSailingFacilities24x24._7, optionIsAnyOf("release-mote"),
		hasAllOf(hasOption("harvest"), targetNamed("crystal extractor"))),

	// Skills
	AGILITY(SpriteID.Staticons.AGILITY, optionIsAnyOf("balance", "balance-across", "climb-across", "climb-on", "climb-over",
		"cross", "grab", "grapple", "hurdle", "jump", "jump-up", "jump-to", "jump-off", "jump-in", "jump-on", "kick",
		"leap", "shoot", "squeeze-past", "squeeze-through", "swing", "swing across", "swing-across", "swing-on", "tap",
		"tag", "teeth-grip", "tread-softly", "vault", "walk-on", "walk-across", "crawl-through", "jump-over", "escape"),
		hasAllOf(hasOption("navigate"), not(targetNamed("helm")))), // underwater agility obstacles
	ATTACK(SpriteID.Staticons.ATTACK, "attack"),
	CONSTRUCTION(SpriteID.Staticons2.CONSTRUCTION, optionIsAnyOf("build", "remove", "modify", "upgrade"),
		hasAllOf(hasOption("craft"), targetNamed("shipwrights' workbench"))),
	COOKING(SpriteID.Staticons.COOKING, "cook", "churn", "cook-at", "prepare-fish"),
	CRAFTING(SpriteID.Staticons.CRAFTING, optionIsAnyOf("spin", "weave"),
		hasAllOf(hasOption("craft"), not(targetNamed("shipwrights' workbench")))), // crafting table / clockmaker's benches
	FARMING(SpriteID.Staticons2.FARMING, optionIsAnyOf("check-health", "rake", "pick", "pick-fruit", "clear",
		"pay", "guide"), hasAllOf(hasOption("harvest"), isObject(), not(targetNamed("crystal extractor"))), // Harvesting crops only
		hasAllOf(hasOption("collect"), targetEndsWith("coral"))), // Collecting coral
	FIREMAKING(SpriteID.Staticons.FIREMAKING, "light", "feed"),
	FISHING(SpriteID.Staticons.FISHING, optionIsAnyOf("net", "lure", "small net", "harpoon", "cage", "big net",
		"use-rod", "fish", "take-net"), hasAllOf(hasOption("bait"), isNpc())), // Bait fishing spots
	FLETCHING(SpriteID.Staticons.FLETCHING, "carve", "decorate"),
	HERBLORE(SpriteID.Staticons.HERBLORE, hasAllOf(optionIsAnyOf("clean"), targetStartsWith("grimy"))),
	HUNTER(SpriteID.Staticons2.HUNTER, optionIsAnyOf("catch", "lay", "dismantle", "reset", "set-trap"),
		hasAllOf(hasOption("check"), isGroundItem()), // Various hunter traps
		hasAllOf(hasOption("bait"), isObject())), // Crab traps
	MAGIC(SpriteID.Staticons.MAGIC, optionIsAnyOf("spellbook", "teleport", "teleport menu", "ancient", "lunar",
		"arceuus", "standard", "study"), hasAllOf(hasOption("venerate"), not(targetNamed("dark altar")))), // PoH spellbook altars
	MINING(SpriteID.Staticons.MINING, "mine", "smash-to-bits", "chip"),
	PRAYER(SpriteID.Staticons.PRAYER, "pray", "bury", "pray-at", "offer-fish", "scatter"),
	RANGED(SpriteID.Staticons.RANGED, "fire", "fire-at"),
	RUNECRAFTING(SpriteID.Staticons2.RUNECRAFT, optionIsAnyOf("craft-rune", "imbue"),
		hasAllOf(hasOption("venerate"), targetNamed("dark altar"))), // Avoid PoH spellbook altars
	SMITHING(SpriteID.Staticons.SMITHING, "smelt", "smith", "hammer", "refine"),
	SLAYER(SpriteID.Staticons2.SLAYER, "assignment"),
	STRENGTH(SpriteID.Staticons.STRENGTH, "bang", "move"),
	THIEVING(SpriteID.Staticons.THIEVING, "steal-from", "pickpocket", "search for traps", "pick-lock"),
	WOODCUTTING(SpriteID.Staticons.WOODCUTTING, "chop down", "chop-down", "chop", "cut", "hack"),
	SAILING(SpriteID.Staticons2.SAILING, "board", "board-previous", "board-friend", "dock", "customise-boat",
		"recover-boat", "sort-salvage", "chart", "pry-open", "collect-data", "start-trial", "start-previous-rank"),
	;

	private final Sprite sprite;
	private final MenuEntryMatcher matcher;

	// Basic cursor with only global actions
	ContextualCursor(String cursorPath, String... actions)
	{
		this.sprite = Sprite.of(cursorPath);
		this.matcher = optionIsAnyOf(actions);
	}

	// Basic cursor with only global actions
	ContextualCursor(int spriteID, String... actions)
	{
		this.sprite = Sprite.of(spriteID);
		this.matcher = optionIsAnyOf(actions);
	}

	// Cursor with specific matchers
	ContextualCursor(String cursorPath, MenuEntryMatcher... matchers)
	{
		this.sprite = Sprite.of(cursorPath);
		this.matcher = hasAnyOf(matchers);
	}

	// Cursor with specific matchers
	ContextualCursor(int spriteID, MenuEntryMatcher... matchers)
	{
		this.sprite = Sprite.of(spriteID);
		this.matcher = hasAnyOf(matchers);
	}

	private static final ContextualCursor[] values = values();

	static Sprite get(MenuEntry menuEntry)
	{
		for (ContextualCursor cursor : values)
		{
			if (cursor.matcher.matches(menuEntry))
			{
				return cursor.getSprite();
			}
		}
		return null;
	}

	static final ResourceSprite BLANK_CURSOR = new ResourceSprite("blank");
	static final ResourceSprite GENERIC_CURSOR = new ResourceSprite("generic");

	static void clearImages()
	{
		for (ContextualCursor cursor : values)
		{
			cursor.sprite.clearImage();
		}

		BLANK_CURSOR.clearImage();
		GENERIC_CURSOR.clearImage();
	}
}

package com.github.ldavid432.contextualcursor.sprite;

import io.hydrox.contextualcursor.ContextualCursorPlugin;
import java.awt.image.BufferedImage;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;

@RequiredArgsConstructor
public class ResourceSprite implements Sprite
{
	@Nonnull
	String fileName;

	@Nullable
	BufferedImage image;

	@Nullable
	@Override
	public BufferedImage getImage(Client client, SpriteManager spriteManager)
	{
		return getImage();
	}

	@Nullable
	public BufferedImage getImage()
	{
		if (image == null)
		{
			image = loadImage(fileName);
		}
		return image;
	}

	@Override
	public void clearImage()
	{
		image = null;
	}

	public static BufferedImage loadImage(String fileName)
	{
		return ImageUtil.loadImageResource(ContextualCursorPlugin.class, String.format("cursors/%s.png", fileName));
	}
}

package com.github.ldavid432.contextualcursor.sprite;

import java.awt.image.BufferedImage;
import javax.annotation.Nullable;
import net.runelite.api.Client;
import net.runelite.client.game.SpriteManager;

public interface Sprite
{
	@Nullable
	BufferedImage getImage(Client client, SpriteManager spriteManager);

	void clearImage();

	static Sprite of(int id)
	{
		return new CacheSprite(id);
	}

	static Sprite of(String path)
	{
		return new ResourceSprite(path);
	}
}

package com.github.ldavid432.contextualcursor.sprite;

import java.awt.image.BufferedImage;
import javax.annotation.Nullable;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.client.game.SpriteManager;

@RequiredArgsConstructor
public class CacheSprite implements Sprite
{
	private final int id;

	@Nullable
	BufferedImage image;

	@Override
	public BufferedImage getImage(final Client client, final SpriteManager spriteManager)
	{
		if (image == null)
		{
			if (client.getSpriteOverrides().containsKey(id))
			{
				image = client.getSpriteOverrides().get(id).toBufferedImage();
			}
			else
			{
				image = spriteManager.getSprite(id, 0);
			}
		}

		return image;
	}

	@Override
	public void clearImage()
	{
		image = null;
	}
}

package com.github.ldavid432.contextualcursor.menuentry;

import net.runelite.api.MenuEntry;

public interface MenuEntryMatcher
{
	boolean matches(MenuEntry menuEntry);
}

package com.github.ldavid432.contextualcursor.menuentry;

import java.util.Objects;
import java.util.function.BiFunction;
import java.util.stream.Stream;
import net.runelite.api.MenuAction;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.ArrayUtils;

public class MenuEntryMatchers
{
	// General matchers

	public static MenuEntryMatcher not(MenuEntryMatcher matcher)
	{
		return menuEntry -> !matcher.matches(menuEntry);
	}

	public static MenuEntryMatcher hasAnyOf(MenuEntryMatcher... matchers)
	{
		return menuEntry -> Stream.of(matchers).anyMatch(matcher -> matcher.matches(menuEntry));
	}

	public static MenuEntryMatcher hasAllOf(MenuEntryMatcher... matchers)
	{
		return menuEntry -> Stream.of(matchers).allMatch(matcher -> matcher.matches(menuEntry));
	}

	// Menu options

	public static MenuEntryMatcher optionIsAnyOf(String... options)
	{
		return menuEntry -> Stream.of(options).map(MenuEntryMatchers::hasOption).anyMatch(matcher -> matcher.matches(menuEntry));
	}

	public static MenuEntryMatcher hasOption(String option)
	{
		return menuEntry -> Objects.equals(menuEntry.getOption().toLowerCase(), option);
	}

	// NPCs

	public static MenuEntryMatcher isNpc()
	{
		return menuEntry -> menuEntry.getNpc() != null;
	}

	// Objects

	public static MenuEntryMatcher isObject()
	{
		return menuEntry -> ArrayUtils.contains(OBJECT_TYPES, menuEntry.getType());
	}

	private static final MenuAction[] OBJECT_TYPES = {
		MenuAction.GAME_OBJECT_FIRST_OPTION, MenuAction.GAME_OBJECT_SECOND_OPTION, MenuAction.GAME_OBJECT_THIRD_OPTION,
		MenuAction.GAME_OBJECT_FOURTH_OPTION, MenuAction.GAME_OBJECT_FIFTH_OPTION
	};

	// Ground Items

	public static MenuEntryMatcher isGroundItem()
	{
		return menuEntry -> ArrayUtils.contains(GROUND_ITEM_TYPES, menuEntry.getType());
	}

	private static final MenuAction[] GROUND_ITEM_TYPES = {
		MenuAction.GROUND_ITEM_FIRST_OPTION, MenuAction.GROUND_ITEM_SECOND_OPTION, MenuAction.GROUND_ITEM_THIRD_OPTION,
		MenuAction.GROUND_ITEM_FOURTH_OPTION, MenuAction.GROUND_ITEM_FIFTH_OPTION
	};

	// Targets

	private static MenuEntryMatcher target(String target, BiFunction<String, String, Boolean> test)
	{
		return menuEntry -> test.apply(sanitize(menuEntry.getTarget()), target);
	}

	public static MenuEntryMatcher targetNamed(String target)
	{
		return target(target, String::equals);
	}

	public static MenuEntryMatcher targetStartsWith(String targetPrefix)
	{
		return target(targetPrefix, String::startsWith);
	}

	public static MenuEntryMatcher targetEndsWith(String targetSuffix)
	{
		return target(targetSuffix, String::endsWith);
	}

	// Util

	private static String sanitize(String text)
	{
		return Text.removeTags(Text.sanitize(text).toLowerCase());
	}
}

package io.hydrox.contextualcursor;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ContextualCursorPluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ContextualCursorPlugin.class);
		RuneLite.main(args);
	}
}

