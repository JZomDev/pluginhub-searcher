/*
 * Copyright (c) 2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import javax.inject.Inject;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;

public class ContextualCursorDrawOverlay extends Overlay
{
	//The pointer sticks out to the left slightly, so this makes sure it's point to the correct spot
	private static final Point POINTER_OFFSET = new Point(-5, 0);
	//The centre of the circle (biased bottom right since it's an even size), for use with sprites
	private static final Point CENTRAL_POINT = new Point(16, 18);

	private final Client client;
	private final ContextualCursorPlugin plugin;

	@Inject
	ContextualCursorDrawOverlay(Client client, ContextualCursorPlugin plugin)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
		setPriority(OverlayPriority.HIGHEST);
		this.client = client;
		this.plugin = plugin;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		BufferedImage sprite = plugin.getSpriteToDraw();
		if (sprite == null)
		{
			return null;
		}

		final Point mousePos = client.getMouseCanvasPosition();
		final ContextualCursor blank = ContextualCursor.BLANK;
		graphics.drawImage(blank.getCursor(), mousePos.getX() + POINTER_OFFSET.getX(), mousePos.getY() + POINTER_OFFSET.getY(), null);
		final int spriteX = POINTER_OFFSET.getX() + CENTRAL_POINT.getX() - sprite.getWidth() / 2;
		final int spriteY = POINTER_OFFSET.getY() + CENTRAL_POINT.getY() - sprite.getHeight() / 2;
		graphics.drawImage(sprite, mousePos.getX() + spriteX, mousePos.getY() + spriteY, null);
		return null;
	}
}

/*
 * Copyright (c) 2019-2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import lombok.AllArgsConstructor;
import java.util.HashMap;
import java.util.Map;
import net.runelite.api.gameval.SpriteID;

@AllArgsConstructor
public enum SpellSprite
{
	// Standard
	WIND_STRIKE(SpriteID.Magicon.WIND_STRIKE),
	CONFUSE(SpriteID.Magicon.CONFUSE),
	WATER_STRIKE(SpriteID.Magicon.WATER_STRIKE),
	LVL_1_ENCHANT("lvl-1 enchant", SpriteID.Magicon.LVL_1_ENCHANT),
	EARTH_STRIKE(SpriteID.Magicon.EARTH_STRIKE),
	WEAKEN(SpriteID.Magicon.WEAKEN),
	FIRE_STRIKE(SpriteID.Magicon.FIRE_STRIKE),
	WIND_BOLT(SpriteID.Magicon.WIND_BOLT),
	CURSE(SpriteID.Magicon.CURSE),
	BIND(SpriteID.Magicon2.BIND),
	LOW_LEVEL_ALCHEMY(SpriteID.Magicon.LOW_LEVEL_ALCHEMY),
	WATER_BOLT(SpriteID.Magicon.WATER_BOLT),
	LVL_2_ENCHANT("lvl-2 enchant", SpriteID.Magicon.LVL_2_ENCHANT),
	EARTH_BOLT(SpriteID.Magicon.EARTH_BOLT),
	TELEKINETIC_GRAB(SpriteID.Magicon.TELEKINETIC_GRAB),
	FIRE_BOLT(SpriteID.Magicon.FIRE_BOLT),
	CRUMBLE_UNDEAD(SpriteID.Magicon.CRUMBLE_UNDEAD),
	WIND_BLAST(SpriteID.Magicon.WIND_BLAST),
	SUPERHEAT_ITEM(SpriteID.Magicon.SUPERHEAT_ITEM),
	WATER_BLAST(SpriteID.Magicon.WATER_BLAST),
	LVL_3_ENCHANT("lvl-3 enchant", SpriteID.Magicon.LVL_3_ENCHANT),
	IBAN_BLAST(SpriteID.Magicon.IBAN_BLAST),
	SNARE(SpriteID.Magicon2.SNARE),
	MAGIC_DART(SpriteID.Magicon2.MAGIC_DART),
	EARTH_BLAST(SpriteID.Magicon.EARTH_BLAST),
	HIGH_LEVEL_ALCHEMY(SpriteID.Magicon.HIGH_LEVEL_ALCHEMY),
	CHARGE_WATER_ORB(SpriteID.Magicon.CHARGE_WATER_ORB),
	LVL_4_ENCHANT("lvl-4 enchant", SpriteID.Magicon.LVL_4_ENCHANT),
	FIRE_BLAST(SpriteID.Magicon.FIRE_BLAST),
	CHARGE_EARTH_ORB(SpriteID.Magicon.CHARGE_EARTH_ORB),
	SARADOMIN_STRIKE(SpriteID.Magicon.SARADOMIN_STRIKE),
	CLAWS_OF_GUTHIX(SpriteID.Magicon.CLAWS_OF_GUTHIX),
	FLAMES_OF_ZAMORAK(SpriteID.Magicon.FLAMES_OF_ZAMORAK),
	WIND_WAVE(SpriteID.Magicon.WIND_WAVE),
	CHARGE_FIRE_ORB(SpriteID.Magicon.CHARGE_FIRE_ORB),
	WATER_WAVE(SpriteID.Magicon.WATER_WAVE),
	CHARGE_AIR_ORB(SpriteID.Magicon.CHARGE_AIR_ORB),
	VULNERABILITY(SpriteID.Magicon.VULNERABILITY),
	LVL_5_ENCHANT("lvl-5 enchant", SpriteID.Magicon.LVL_5_ENCHANT),
	EARTH_WAVE(SpriteID.Magicon.EARTH_WAVE),
	ENFEEBLE(SpriteID.Magicon.ENFEEBLE),
	TELEOTHER_LUMBRIDGE(SpriteID.Magicon2.TELEOTHER_LUMBRIDGE),
	FIRE_WAVE(SpriteID.Magicon.FIRE_WAVE),
	ENTANGLE(SpriteID.Magicon2.ENTANGLE),
	STUN(SpriteID.Magicon.STUN),
	WIND_SURGE(SpriteID.Magicon2.WIND_SURGE),
	TELEOTHER_FALADOR(SpriteID.Magicon2.TELEOTHER_FALADOR),
	WATER_SURGE(SpriteID.Magicon2.WATER_SURGE),
	TELE_BLOCK(SpriteID.Magicon2.TELE_BLOCK),
	LVL_6_ENCHANT("lvl-6 enchant", SpriteID.Magicon2.LVL_6_ENCHANT),
	TELEOTHER_CAMELOT(SpriteID.Magicon2.TELEOTHER_CAMELOT),
	EARTH_SURGE(SpriteID.Magicon2.EARTH_SURGE),
	LVL_7_ENCHANT("lvl-7 enchant", SpriteID.Magicon2.LVL_7_ENCHANT),
	FIRE_SURGE(SpriteID.Magicon2.FIRE_SURGE),
	// Ancients
	SMOKE_RUSH(SpriteID.Magicon2.SMOKE_RUSH),
	SHADOW_RUSH(SpriteID.Magicon2.SHADOW_RUSH),
	BLOOD_RUSH(SpriteID.Magicon2.BLOOD_RUSH),
	ICE_RUSH(SpriteID.Magicon2.ICE_RUSH),
	SMOKE_BURST(SpriteID.Magicon2.SMOKE_BURST),
	SHADOW_BURST(SpriteID.Magicon2.SHADOW_BURST),
	BLOOD_BURST(SpriteID.Magicon2.BLOOD_BURST),
	ICE_BURST(SpriteID.Magicon2.ICE_BURST),
	SMOKE_BLITZ(SpriteID.Magicon2.SMOKE_BLITZ),
	SHADOW_BLITZ(SpriteID.Magicon2.SHADOW_BLITZ),
	BLOOD_BLITZ(SpriteID.Magicon2.BLOOD_BLITZ),
	ICE_BLITZ(SpriteID.Magicon2.ICE_BLITZ),
	SMOKE_BARRAGE(SpriteID.Magicon2.SMOKE_BARRAGE),
	SHADOW_BARRAGE(SpriteID.Magicon2.SHADOW_BARRAGE),
	BLOOD_BARRAGE(SpriteID.Magicon2.BLOOD_BARRAGE),
	ICE_BARRAGE(SpriteID.Magicon2.ICE_BARRAGE),
	// Lunars
	CURE_PLANT(SpriteID.LunarMagicOn.CURE_PLANT),
	MONSTER_EXAMINE(SpriteID.LunarMagicOn.MONSTER_EXAMINE),
	STAT_SPY(SpriteID.LunarMagicOn.STAT_SPY),
	FERTILE_SOIL(SpriteID.LunarMagicOn.FERTILE_SOIL),
	PLANK_MAKE(SpriteID.LunarMagicOn.PLANK_MAKE),
	CURE_OTHER(SpriteID.LunarMagicOn.CURE_OTHER),
	STAT_RESTORE_POT_SHARE(SpriteID.LunarMagicOn.STAT_RESTORE_POT_SHARE),
	BOOST_POTION_SHARE(SpriteID.LunarMagicOn.BOOST_POTION_SHARE),
	ENERGY_TRANSFER(SpriteID.LunarMagicOn.ENERGY_TRANSFER),
	HEAL_OTHER(SpriteID.LunarMagicOn.HEAL_OTHER),
	VENGEANCE_OTHER(SpriteID.LunarMagicOn.VENGEANCE_OTHER),
	// Arceuus
	BASIC_REANIMATION(SpriteID.MagicNecroOn.BASIC_REANIMATION),
	ADEPT_REANIMATION(SpriteID.MagicNecroOn.ADEPT_REANIMATION),
	EXPERT_REANIMATION(SpriteID.MagicNecroOn.EXPERT_REANIMATION),
	MASTER_REANIMATION(SpriteID.MagicNecroOn.MASTER_REANIMATION),
	RESURRECT_CROPS(SpriteID.MagicNecroOn.RESURRECT_CROPS),
	DARK_LURE(SpriteID.MagicNecroOn.DARK_LURE),
	MARK_OF_DARKNESS(SpriteID.MagicNecroOn.MARK_OF_DARKNESS),
	GHOSTLY_GRASP(SpriteID.MagicNecroOn.GHOSTLY_GRASP),
	SKELETAL_GRASP(SpriteID.MagicNecroOn.SKELETAL_GRASP),
	UNDEAD_GRASP(SpriteID.MagicNecroOn.UNDEAD_GRASP),
	INFERIOR_DEMONBANE(SpriteID.MagicNecroOn.INFERIOR_DEMONBANE),
	SUPERIOR_DEMONBANE(SpriteID.MagicNecroOn.SUPERIOR_DEMONBANE),
	DARK_DEMONBANE(SpriteID.MagicNecroOn.DARK_DEMONBANE);

	private final String name;
	final int spriteID;

	SpellSprite(int spriteID)
	{
		this(null, spriteID);
	}

	private String getName()
	{
		return name != null ? name : this.name().toLowerCase().replace("_", " ");
	}

	private static final Map<String, SpellSprite> map = new HashMap<>();

	static
	{
		for (SpellSprite spell : values())
		{
			map.put(spell.getName(), spell);
		}
	}

	static SpellSprite get(String spell)
	{
		return map.get(spell);
	}
}

/*
 * Copyright (c) 2020-2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import javax.inject.Inject;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

@PluginDescriptor(
	name = "Contextual Cursor",
	description = "RSHD-style image cursors",
	tags = {"cursor", "rs3", "rs2", "rshd", "context"}
)
@Slf4j
public class ContextualCursorPlugin extends Plugin implements KeyListener, MouseListener
{
	@Inject
	private ContextualCursorDrawOverlay contextualCursorDrawOverlay;
	@Inject
	private ContextualCursorWorkerOverlay contextualCursorWorkerOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private MouseManager mouseManager;

	@Getter
	private boolean altPressed;

	@Getter
	@Setter
	private BufferedImage spriteToDraw;

	protected void startUp()
	{
		overlayManager.add(contextualCursorWorkerOverlay);
		overlayManager.add(contextualCursorDrawOverlay);
		keyManager.registerKeyListener(this);
		mouseManager.registerMouseListener(this);
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(contextualCursorWorkerOverlay);
		overlayManager.remove(contextualCursorDrawOverlay);
		contextualCursorWorkerOverlay.resetCursor();
		keyManager.unregisterKeyListener(this);
		mouseManager.unregisterMouseListener(this);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() != GameState.LOGGED_IN && event.getGameState() != GameState.LOADING)
		{
			contextualCursorWorkerOverlay.resetCursor();
		}
	}

	@Override
	public void keyPressed(KeyEvent keyEvent)
	{
		altPressed = keyEvent.isAltDown();
	}

	@Override
	public void keyReleased(KeyEvent keyEvent)
	{
		altPressed = keyEvent.isAltDown();
	}

	@Override
	public MouseEvent mouseEntered(MouseEvent mouseEvent)
	{
		altPressed = mouseEvent.isAltDown();
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseExited(MouseEvent mouseEvent)
	{
		altPressed = mouseEvent.isAltDown();
		return mouseEvent;
	}

	// Beyond this point is junk.
	// Look upon this method-bloat and despair!

	@Override
	public MouseEvent mouseDragged(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseMoved(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseClicked(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override
	public MouseEvent mousePressed(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseReleased(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override
	public void keyTyped(KeyEvent keyEvent)
	{

	}
}

/*
 * Copyright (c) 2020-2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import com.google.common.collect.Sets;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Point;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.Text;
import javax.inject.Inject;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class ContextualCursorWorkerOverlay extends Overlay
{
	private static final Cursor BLANK_MOUSE = Toolkit.getDefaultToolkit().createCustomCursor(
		new BufferedImage(32, 32,BufferedImage.TYPE_INT_ARGB),
		new java.awt.Point(0, 0),
		"blank"
	);
	private static final Tooltip SPACER_TOOLTIP = new Tooltip(
		new ImageComponent(new BufferedImage(1, 10, BufferedImage.TYPE_INT_ARGB))
	);
	private static final Pattern SPELL_FINDER = Pattern.compile(">(.*?)(?:</col>| -> )");
	private static final int MENU_OPTION_HEIGHT = 15;
	private static final int MENU_EXTRA_TOP = 4;
	private static final int MENU_EXTRA_BOTTOM = 3;
	private static final int MENU_BORDERS_TOTAL = MENU_EXTRA_TOP + MENU_OPTION_HEIGHT + MENU_EXTRA_BOTTOM;
	private static final Set<MenuAction> IGNORED_ACTIONS = Sets.newHashSet(
		MenuAction.WALK, MenuAction.CC_OP, MenuAction.CANCEL, MenuAction.CC_OP_LOW_PRIORITY, MenuAction.SET_HEADING
	);

	private final Client client;
	private final ClientUI clientUI;
	private final ContextualCursorPlugin plugin;
	private final SpriteManager spriteManager;
	private final TooltipManager tooltipManager;

	private Point menuOpenPoint;

	private boolean cursorOverriden;
	private Cursor originalCursor;

	@Inject
	ContextualCursorWorkerOverlay(Client client, ClientUI clientUI, ContextualCursorPlugin plugin,
								  SpriteManager spriteManager, TooltipManager tooltipManager)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(OverlayPriority.HIGHEST);
		this.client = client;
		this.clientUI = clientUI;
		this.plugin = plugin;
		this.spriteManager = spriteManager;
		this.tooltipManager = tooltipManager;
	}

	private void storeOriginalCursor()
	{
		if (cursorOverriden)
		{
			return;
		}
		final Cursor currentCursor = clientUI.getCurrentCursor();
		if (!currentCursor.getName().equals("blank"))
		{
			originalCursor = clientUI.getCurrentCursor();
		}
	}

	void resetCursor()
	{
		if (cursorOverriden)
		{
			cursorOverriden = false;
			plugin.setSpriteToDraw(null);
			if (originalCursor != null)
			{
				clientUI.setCursor(originalCursor);
			}
			else
			{
				clientUI.resetCursor();
			}
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.isAltPressed())
		{
			resetCursor();
			return null;
		}

		final MenuEntry menuEntry;

		if (client.isMenuOpen())
		{
			menuEntry = processMenu();
		}
		else
		{
			menuOpenPoint = client.getMouseCanvasPosition();
			final MenuEntry[] menuEntries = client.getMenuEntries();
			int last = menuEntries.length - 1;

			if (last < 0)
			{
				return null;
			}

			menuEntry = menuEntries[last];
		}

		if (menuEntry == null ||
			(!menuEntry.isItemOp()
			&& !menuEntry.getOption().equals("Examine")
			&& IGNORED_ACTIONS.contains(menuEntry.getType())))
		{
			resetCursor();
			return null;
		}

		processEntry(graphics,  menuEntry.getType(), menuEntry.getOption(),  menuEntry.getTarget());
		return null;
	}

	private MenuEntry processMenu()
	{
		final MenuEntry[] menuEntries = client.getMenuEntries();

		final int menuTop;
		final int menuHeight = (menuEntries.length * MENU_OPTION_HEIGHT) + MENU_BORDERS_TOTAL;
		if (menuHeight + menuOpenPoint.getY() > client.getCanvasHeight())
		{
			menuTop = client.getCanvasHeight() - menuHeight;
		}
		else
		{
			menuTop = menuOpenPoint.getY();
		}

		final int fromTop = (client.getMouseCanvasPosition().getY() - MENU_EXTRA_TOP) - menuTop;

		final int index = menuEntries.length - (fromTop / MENU_OPTION_HEIGHT);

		if (index >= menuEntries.length || index < 0)
		{
			return null;
		}

		return menuEntries[index];
	}

	private static final Set<MenuAction> SPELL_TYPES = Sets.newHashSet(
		MenuAction.WIDGET_TARGET_ON_GAME_OBJECT, MenuAction.WIDGET_TARGET_ON_NPC, MenuAction.WIDGET_TARGET_ON_PLAYER,
		MenuAction.WIDGET_TARGET_ON_GROUND_ITEM, MenuAction.WIDGET_TARGET_ON_WIDGET, MenuAction.WIDGET_TARGET
	);

	private void processEntry(Graphics2D graphics, MenuAction type, String option, String target)
	{
		final ContextualCursor cursor;
		if (SPELL_TYPES.contains(type) && option.equals("Cast"))
		{
			final Matcher spellFinder = SPELL_FINDER.matcher(target.toLowerCase());

			if (!spellFinder.find())
			{
				return;
			}

			final String spellText = spellFinder.group(1);
			final SpellSprite spell = SpellSprite.get(Text.sanitize(spellText));
			if (spell == null) {
				return;
			}

			final BufferedImage magicSprite = spriteManager.getSprite(spell.spriteID, 0);
			if (magicSprite == null)
			{
				return;
			}

			setSpriteToDraw(magicSprite);
			return;
		}
		else if (option.equals("Lookup") && Text.removeTags(target).startsWith("Wiki ->"))
		{
			cursor = ContextualCursor.WIKI;
		}
		else
		{
			cursor = ContextualCursor.get(Text.removeTags(option));
		}

		if (cursor == null)
		{
			resetCursor();
			return;
		}

		BufferedImage sprite = cursor.getCursor();
		if (cursor.getSpriteID() != null)
		{
			if (client.getSpriteOverrides().containsKey(cursor.getSpriteID()))
			{
				sprite = client.getSpriteOverrides().get(cursor.getSpriteID()).toBufferedImage();
			}
			else
			{
				sprite = spriteManager.getSprite(cursor.getSpriteID(), 0);
			}
			if (sprite == null)
			{
				return;
			}
		}
		if (sprite != null)
		{
			setSpriteToDraw(sprite);
		}
	}

	private void setSpriteToDraw(BufferedImage sprite)
	{
		storeOriginalCursor();
		clientUI.setCursor(BLANK_MOUSE);
		cursorOverriden = true;
		plugin.setSpriteToDraw(sprite);
		// Add an empty tooltip to keep real tooltips out of the way
		tooltipManager.addFront(SPACER_TOOLTIP);
	}
}

/*
 * Copyright (c) 2019-2022 Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.contextualcursor;

import lombok.Getter;
import net.runelite.api.gameval.SpriteID;
import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;

@Getter
public enum ContextualCursor
{
	BLANK("blank"),
	GENERIC("generic"), //Cursor inside background

	BANK("bank", "bank", "bank-cargo"),
	CLOSE("close", "close", "disembark"),
	CONFIGURE(SpriteID.OptionsIcons._51, "configure", "configuration"), // Wrench sprite
	DRINK("drink", "drink"),
	DROP("drop", "drop", "empty", "deposit", "quick-deposit", "deposit-cargo"),
	EAT("eat", "eat"),
	ENTER("enter", "climb-into", "enter", "exit", "yanille", "varrock", "seers' village", "camelot",
		"grand exchange", "watchtower", "go-through"),
	EQUIP("equip", "wield", "wear", "equip"),
	EXCHANGE(SpriteID.GeSmallicons.GUIDE_PRICE, "exchange", "trade", "trade with", "collect", "buy-boat"),
	FRIEND(SpriteID.SideiconsInterface.FRIENDS, "add friend"),
	IGNORE(SpriteID.SideiconsInterface.IGNORES, "add ignore"),
	IMPOSSIBLE("impossible", "destroy", "stop-navigating", "cancel-task"),
	LADDER("ladder", "climb"),
	LADDER_DOWN("ladder_down", "climb-down", "climb down"),
	LADDER_UP("ladder_up", "climb-up", "climb up"),
	OPEN("open", "open"),
	PICK_UP("pick_up", "take", "withdraw" ,"fill", "take-cargo", "take-last-cargo", "collect-from", "take-from"),
	PLANK("plank", "buy-plank"),
	READ("read", "read", "story"),
	REPORT(SpriteID.PvpwIcons.DEADMAN_EXCLAMATION_MARK_SKULLED_WARNING, "report"),
	SEARCH("search", "search", "lookup", "examine", "view", "look-inside", "inspect"),
	TALK("talk", "talk", "talk-to", "talk to", "command"),
	UNTIE("untie", "tether"),
	USE("use", "use"),
	WIKI("wiki", "lookup-entity"),

	// Sailing
	NAVIGATE(SpriteID.IconSailingFacilities24x24._4, "navigate"), // Ship's wheel
	SALVAGE(SpriteID.IconSailingFacilities24x24._5, "deploy"), // Salvage hook
	UNSET_SAILS(SpriteID.IconSailingFacilities24x24._0, "un-set"), // Empty sails
	SET_SAILS(SpriteID.IconSailingFacilities24x24._1, "set"), // Sails
	TRIM_SAILS(SpriteID.IconSailingFacilities24x24._2, "trim"), // Luffed sails
	CANNON(SpriteID.IconSailingFacilities24x24._6, "check-ammunition", "reset-ammunition"),

	// Skills
	AGILITY(SpriteID.Staticons.AGILITY, "balance", "balance-across", "climb-across", "climb-on", "climb-over",
		"cross", "grab", "grapple", "hurdle", "jump", "jump-up", "jump-to", "jump-off", "jump-in", "jump-on", "kick",
		"leap", "shoot", "squeeze-past", "squeeze-through", "swing", "swing across", "swing-across", "swing-on", "tap",
		"tag", "teeth-grip", "tread-softly", "vault", "walk-on", "walk-across", "crawl-through", "jump-over", "escape"),
	ATTACK(SpriteID.Staticons.ATTACK, "attack"),
	CONSTRUCTION(SpriteID.Staticons2.CONSTRUCTION, "build", "remove", "craft", "modify"),
	COOKING(SpriteID.Staticons.COOKING, "cook", "churn", "cook-at", "prepare-fish"),
	CRAFTING(SpriteID.Staticons.CRAFTING, "spin"),
	FARMING(SpriteID.Staticons2.FARMING, "check-health", "harvest", "rake", "pick", "pick-fruit", "clear", "pay"),
	FIREMAKING(SpriteID.Staticons.FIREMAKING, "light", "feed"),
	FISHING(SpriteID.Staticons.FISHING, "net", "bait", "lure", "small net", "harpoon", "cage", "big net",
		"use-rod", "fish", "take-net"),
	HERBLORE(SpriteID.Staticons.HERBLORE, "clean"),
	HUNTER(SpriteID.Staticons2.HUNTER, "catch", "lay", "dismantle", "reset", "check"),
	MAGIC(SpriteID.Staticons.MAGIC, "spellbook", "teleport", "teleport menu"), // `venerate` interferes with the Dark Altar's RC use
	MINING(SpriteID.Staticons.MINING, "mine", "smash-to-bits"),
	PRAYER(SpriteID.Staticons.PRAYER, "pray", "bury", "pray-at", "offer-fish", "scatter"),
	RUNECRAFTING(SpriteID.Staticons2.RUNECRAFT, "craft-rune", "imbue"),
	SMITHING(SpriteID.Staticons.SMITHING, "smelt", "smith", "hammer", "refine"),
	SLAYER(SpriteID.Staticons2.SLAYER, "assignment"),
	STRENGTH(SpriteID.Staticons.STRENGTH, "bang", "move"),
	THIEVING(SpriteID.Staticons.THIEVING, "steal-from", "pickpocket", "search for traps", "pick-lock"),
	WOODCUTTING(SpriteID.Staticons.WOODCUTTING, "chop down", "chop-down", "chop", "cut", "hack"),
	SAILING(SpriteID.Staticons2.SAILING, "board", "board-previous", "board-friend", "dock", "customise-boat",
		"recover-boat", "sort-salvage", "chart", "pry-open", "collect-data");

	private BufferedImage cursor;
	private Integer spriteID;
	private String[] actions;

	ContextualCursor(String cursor_path, String ... actions)
	{
		this.cursor = ImageUtil.loadImageResource(ContextualCursorPlugin.class, String.format("cursors/%s.png", cursor_path));
		this.actions = actions;
	}

	ContextualCursor(int spriteID, String ... actions)
	{
		this.spriteID = spriteID;
		this.actions = actions;
	}

	private static final Map<String, ContextualCursor> cursorMap = new HashMap<>();

	static
	{
		for (ContextualCursor cursor : values())
		{
			for (String action : cursor.actions)
			{
				cursorMap.put(action, cursor);
			}
		}
	}

	static ContextualCursor get(String action)
	{
		return cursorMap.getOrDefault(action.toLowerCase(), GENERIC);
	}
}

package io.hydrox.contextualcursor;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ContextualCursorPluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ContextualCursorPlugin.class);
		RuneLite.main(args);
	}
}

