/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.RuneScapeProfileType;

import org.apache.commons.lang3.StringUtils;

// Contains data identifying the player profile associated with a trade histories
@Slf4j
public class TradeHistoryProfile
{
    private final long hash;
    private final String playerName;
    private final RuneScapeProfileType type;

    public TradeHistoryProfile(final Long hash, final String playerName, final RuneScapeProfileType type)
    {
        this.hash = hash;
        this.playerName = playerName;
        this.type = type;
    }

    public final String getPlayerName() { return playerName; }

    public final String toString() { return getKeyString(); }

    // Returns the string in the form "HASH+TYPE" which is used as a key for data recovery
    public final String getKeyString() { return Long.toHexString(hash) + "+" + type.toString(); }

    // Returns the type as a capitalized space-separated string
    public String getTypeString()
    {
        if (type == null || type == RuneScapeProfileType.STANDARD)
        {
            return "";
        }
        return "(" + StringUtils.capitalize(type.toString().replace("_"," ").toLowerCase()) + ")";
    }

    public final boolean equals(Object o)
    {
        if (o == this)
        {
            return true;
        }
        if (!(o instanceof TradeHistoryProfile))
        {
            return false;
        }
        final TradeHistoryProfile other = (TradeHistoryProfile) o;
        return this.hash == other.hash && this.type == other.type;
    }

    public static TradeHistoryProfile parse(final String s)
    {
        final String[] parts = s.split("\\+");
        if (s.length() != 2)
        {
            log.error("Parsed TradeHistoryProfile is missing name or type");
            return null;
        }
        return new TradeHistoryProfile(Long.valueOf(parts[0], 16), null, RuneScapeProfileType.valueOf(parts[1]));
    }

}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr;

import net.runelite.client.config.*;
import org.asundr.recovery.ConfigKey;

import static org.asundr.trade.TradeManager.MAX_HISTORY_COUNT;
import static org.asundr.recovery.SaveManager.SAVE_GROUP;

@ConfigGroup(SAVE_GROUP)
public interface TradeTrackerConfig extends Config
{
	@ConfigSection(
			name = "General",
			description = "General settings",
			position = 0
	)
	String SECTION_GENERAL = "general";

	@ConfigSection(
			name = "Display",
			description = "Change the plugin's visuals",
			position = 1
	)
	String SECTION_DISPLAY = "display";

	@ConfigSection(
			name = "History Limits",
			description = "Settings to manage when the trade history culls old trades",
			position = 2
	)
	String SECTION_HISTORY_LIMITS = "historyLimits";

	@ConfigSection(
			name = "Debug",
			description = "For advanced users or submitting bug reports",
			position = 3,
			closedByDefault = true
	)
	String SECTION_DEBUG = "Debug";

///////////////////////////////

	@ConfigItem(
			keyName = ConfigKey.AUTOLOAD_LAST_PROFILE,
			name = "Auto-load profile on launch",
			description = "If enabled, the last trade profile will be visible on the login screen when RuneLite is launched",
			section = SECTION_GENERAL
	)
	default boolean getAutoLoadLastProfile() { return true; }

	@ConfigItem(
			keyName = ConfigKey.USE_24_HOUR_TIME,
			name = "Display 24-hour time",
			description = "If enabled, displays 13:00 instead of 1:00 pm",
			section = SECTION_DISPLAY
	)
	default boolean use24HourTime() { return false; }

	@ConfigItem(
			keyName = ConfigKey.IGNORE_EMPTY_TRADES,
			name = "Ignore empty trades",
			description = "<html><span>If enabled, accepted trades with no items given or received are not tracked.</span><br><span>Setting to false does not clear exiting empty trades.</span>",
			section = SECTION_GENERAL
	)
	default boolean ignoreEmptyTrades() { return false; }

	@ConfigItem(
			keyName = ConfigKey.FILTER_ITEM_ID,
			name = "Filter matches for Item ID",
			description = "When filtering the trade history, item IDs will also be checked for a match",
			section = SECTION_DEBUG
	)
	default boolean filterMatchItemId() { return false; }

	@ConfigItem(
			keyName = ConfigKey.COPY_TRADE_DATE_MENU,
			name = "Enable copy trade data",
			description = "<html><span>Adds ability to copy trade data by right clicking on trade record</span><br><span>May require restarting RuneLite</span>",
			section = SECTION_DEBUG
	)
	default boolean canCopyTradeData() { return false; }

	@Range (
			min = 1, max = MAX_HISTORY_COUNT
	)
	@ConfigItem(
			keyName = ConfigKey.MAX_HISTORY,
			name = "Maximum trade history",
			description = "<html><span>Maximum number of trade records before the oldest is deleted</span><br><span>Valid range: [1, " + MAX_HISTORY_COUNT+ "]",
			section = SECTION_HISTORY_LIMITS,
			position = 1
	)
	default int maxHistoryCount() { return 256; }

	enum PurgeHistoryType {
		NEVER (Long.MAX_VALUE),
		MINUTE(60000L),
		HOUR (MINUTE.ms*60L),
		DAY (HOUR.ms * 24L),
		YEAR (DAY.ms * 365L);
		public final long ms;
		PurgeHistoryType(long ms) { this.ms = ms; }
	}

	@ConfigItem(
			keyName = ConfigKey.PURGE_HISTORY_TYPE,
			name = "Auto-remove type",
			description = "When should older trades be removed from the history?",
			section = SECTION_HISTORY_LIMITS,
			position = 2
	)
	default PurgeHistoryType getPurgeHistoryType() { return PurgeHistoryType.YEAR; }

	@Range (
			min = 0
	)
	@ConfigItem(
			keyName = ConfigKey.PURGE_HISTORY_MAGNITUDE,
			name = "Auto-remove length",
			description = "After how many of the 'Auto-remove type' should old trades be removed?",
			section =  SECTION_HISTORY_LIMITS,
			position = 3
	)
	default int getPurgeHistoryMagnitude() { return 1; }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.ui;

import org.asundr.trade.TradeItemData;

import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
import java.util.List;

class IconGridPanel extends JPanel
{
    private static final int MAX_COLUMNS = 6;
    private static final int MAX_ROWS = (int)Math.ceil((float)28/MAX_COLUMNS); // max inventory is 28 items, and empty trades should always show at least one row
    public static final int ICON_SIZE = ItemLabel.ICON_SIZE;
    private static final Color COLOR_GRID_BACKGROUND = new Color(18,18,40);
    private static final Color COLOR_ITEM_BORDER = new Color(40,40,40);
    private static final Border BORDER_ITEM = BorderFactory.createCompoundBorder(null, BorderFactory.createLineBorder(COLOR_ITEM_BORDER, 1));
    private static final Dimension PREFERRED_SIZE = new Dimension(230, 36);

    public IconGridPanel()
    {
        setPreferredSize(PREFERRED_SIZE);
        setBackground(COLOR_GRID_BACKGROUND);
    }

    public void updateIcons(List<TradeItemData> items)
    {
        // Calculate the number of visible rows based on the number of icons
        final int totalIcons = Math.min(items.size(), MAX_COLUMNS * MAX_ROWS);
        final int numRows = (int) Math.max(1, Math.ceil((float) totalIcons / MAX_COLUMNS));
        final int emptyIcons = totalIcons == 0 ? MAX_COLUMNS : (MAX_COLUMNS - (totalIcons % MAX_COLUMNS)) % MAX_COLUMNS;
        // Reset contents, layout and dimensions
        removeAll();
        setLayout(new GridLayout(numRows, MAX_COLUMNS));
        setSize(new Dimension(MAX_COLUMNS * ICON_SIZE, numRows * ICON_SIZE));
        // Add the item icons
        for (int i = 0; i < totalIcons; ++i)
        {
            final ItemLabel itemLabel = new ItemLabel(items.get(i));
            itemLabel.setBorder(BORDER_ITEM);
            add(itemLabel);
        }
        // Add empty labels to fill out the last row
        for (int i = 0; i < emptyIcons; ++i)
        {
            final JLabel emptyLabel = new JLabel();
            emptyLabel.setBorder(BORDER_ITEM);
            add(emptyLabel);
        }
        revalidate();
        repaint();
    }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.ui;

import net.runelite.client.util.QuantityFormatter;
import org.asundr.recovery.SaveManager;
import org.asundr.trade.SimpleTradeData;
import org.asundr.trade.TradeData;
import org.asundr.trade.TradeItemData;
import org.asundr.trade.TradeUtils;
import org.asundr.utility.CommonUtils;
import org.asundr.utility.StringUtils;
import org.asundr.utility.TimeUtils;

import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

class TradeRecordPanel extends CollapsiblePanel
{
    private static final ImageIcon ICON_NOTE = CommonUtils.getIconFromName("note_icon.png", 14, 14, Image.SCALE_SMOOTH);
    private static final String TRADE_NAME_TEMPLATE = "<html><body style='color:#A0A0EE;font-size:13px;translate:-100px 0'><b>%s</b></body></html>";
    private static final String TRADE_TIME_TEMPLATE = "<html><body style='color:yellow'>%s</body></html>";
    private static final String TEMPLATE_TRADE_TOTAL = "<html><body style='color:white'><nobr>%s: (<span style='color:%s'> GE: %s </nobr></span>)</body></html>";
    private static final String TRADE_PRICE_PER_TEMPLATE = "<html><span style=''>@</span> %s<span style=''> ea</span></html>";
    private static final Color COLOR_BUTTON_BACKGROUND = new Color(20,20,30);
    private static final Color COLOR_FOOTER_PROFIT = new Color(10, 50, 10);
    private static final Color COLOR_FOOTER_LOSS = new Color(50, 10, 10);
    private static final Color COLOR_FOOTER_EVEN = new Color(20, 20, 20);
    private static final Color COLOR_CONTENT_BACKGROUND = new Color(15, 15, 20);
    private static final Border BORDER_RECORD_PANEL = BorderFactory.createLineBorder(Color.black, 1);
    private static final Border BORDER_ITEM_GRID = BorderFactory.createCompoundBorder(null, BorderFactory.createLineBorder(Color.BLACK, 1));
    private static final Border BORDER_CONTENT = BorderFactory.createCompoundBorder(null, BorderFactory.createLineBorder(Color.BLACK, 1));

    private static TradeRecordPopUpMenu buttonPopup = null;

    private final TradeData tradeData;
    private final SimpleTradeData simpleData;
    private JLabel noteIconLabel = null;
    public Component paddingStrut = null;
    private final JLabel tradeTimeLabel = new JLabel();

    TradeRecordPanel(TradeData tradeData)
    {
        super("");
        this.tradeData = tradeData;
        setBorder(BORDER_RECORD_PANEL);

        // Setting up traded player name and trade time

        JLabel playerNameLabel = new JLabel(String.format(TRADE_NAME_TEMPLATE, tradeData.tradedPlayer.tradeName));
        updateTimeDisplay();
        tradeTimeLabel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                super.mouseEntered(e);
                final String timeString = CommonUtils.getConfig().use24HourTime() ? "HH:mm:ss" : "hh:mm:ss a";
                tradeTimeLabel.setToolTipText(TimeUtils.timestampToString(tradeData.tradeTime, "E dd LLL yyyy @ " +timeString+ " z"));
            }
            @Override
            public void mouseClicked(MouseEvent e)
            {
                super.mouseClicked(e);
                switch (e.getButton())
                {
                    case MouseEvent.BUTTON1:
                        toggleButton.doClick(100);
                        break;
                    case MouseEvent.BUTTON3:
                        buttonPopup.setTradeRecordPanel(TradeRecordPanel.this);
                        buttonPopup.show(e.getComponent(), e.getX(), e.getY());
                        break;
                }
            }
        });
        if (buttonPopup == null)
        {
            buttonPopup = new TradeRecordPopUpMenu();
        }

        // Setting up header button

        toggleButton.setLayout(new BorderLayout());
        toggleButton.add(playerNameLabel, BorderLayout.CENTER);
        toggleButton.add(tradeTimeLabel, BorderLayout.EAST);
        toggleButton.setBackground(COLOR_BUTTON_BACKGROUND);
        toggleButton.setBorder(BorderFactory.createLineBorder(COLOR_BUTTON_BACKGROUND, 4));
        toggleButton.addMouseListener(new MouseAdapter() { @Override public void mouseClicked(MouseEvent e) {
                super.mouseClicked(e);
                if (e.getButton() == 3)
                {
                    buttonPopup.setTradeRecordPanel(TradeRecordPanel.this);
                    buttonPopup.show(e.getComponent(), e.getX(), e.getY());
                }
            }
        });
        updateNoteUI();

        // Setting up simple trade panel if valid

        simpleData = new SimpleTradeData(tradeData);
        if (simpleData.isValid())
        {
            final JPanel summaryPanel = new JPanel();
            final ItemLabel imgLabel = new ItemLabel(simpleData.getItem(), e-> { // create custom image stack
                if (e.getButton() == MouseEvent.BUTTON1) // spoof mouse events since icon is blocking due to tooltip
                {
                    toggleButton.doClick(100);
                }
                else if (e.getButton() == MouseEvent.BUTTON3)
                {
                    buttonPopup.setTradeRecordPanel(TradeRecordPanel.this);
                    buttonPopup.show(e.getComponent(), e.getX(), e.getY());
                }
            }, simpleData.getQuantity());
            summaryPanel.setBackground(COLOR_BUTTON_BACKGROUND);
            summaryPanel.setOpaque(false);
            String Descriptor = "";
            final SimpleTradeData.Type tradeType = simpleData.getTradeType();
            switch(tradeType)
            {
                case Sold_Item: Descriptor = "Sold"; break;
                case Bought_Item: Descriptor = "Bought"; break;
                case Gift_Giving: Descriptor = "Gave away gift of"; break;
                case Gift_Receiving: Descriptor = "Received gift of"; break;
            }
            summaryPanel.add(new JLabel(Descriptor));
            summaryPanel.add(imgLabel);
            if (tradeType == SimpleTradeData.Type.Sold_Item || simpleData.getTradeType() == SimpleTradeData.Type.Bought_Item)
            {
                final String pricePerString = simpleData.getPricePerItem() < 100f
                        ? Float.toString(Math.round(1000*simpleData.getPricePerItem())/1000.f)
                        : StringUtils.quantityToRSDecimalStackLong((int)simpleData.getPricePerItem(),true);
                JLabel pricePerLabel = new JLabel(String.format(TRADE_PRICE_PER_TEMPLATE, pricePerString));
                pricePerLabel.setToolTipText(QuantityFormatter.formatNumber(simpleData.getPricePerItem()) + " gp each");
                pricePerLabel.addMouseListener(new MouseAdapter() {
                    @Override public void mouseClicked(MouseEvent e) // spoof mouse events since icon is blocking due to tooltip
                    {
                        super.mouseClicked(e);
                        if (e.getButton() == MouseEvent.BUTTON1)
                        {
                            toggleButton.doClick(100);
                        }
                        else if (e.getButton() == MouseEvent.BUTTON3)
                        {
                            buttonPopup.setTradeRecordPanel(TradeRecordPanel.this);
                            buttonPopup.show(e.getComponent(), e.getX(), e.getY());
                        }
                    }
                });
                summaryPanel.add(pricePerLabel);
            }
            toggleButton.add(summaryPanel, BorderLayout.SOUTH);
        }

        // Setting up content panel with trade item grids

        final IconGridPanel myItemGrid = new IconGridPanel();
        myItemGrid.updateIcons(tradeData.givenItems);
        myItemGrid.setBorder(BORDER_ITEM_GRID);
        final IconGridPanel otherItemGrid = new IconGridPanel();
        otherItemGrid.updateIcons(tradeData.receivedItems);
        otherItemGrid.setBorder(BORDER_ITEM_GRID);

        contentPanel.setBackground(COLOR_CONTENT_BACKGROUND);
        contentPanel.setBorder(BORDER_CONTENT);
        contentPanel.setLayout(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.NONE;
        gbc.weightx = 1;
        gbc.weighty = 1;
        gbc.gridx = 0;

        gbc.gridy = 0;
        final QuantityLabel myLabel = new QuantityLabel(
                tradeData.givenTotalValueGE,
                String.format(TEMPLATE_TRADE_TOTAL, "Given items", "#FF9090", "%s"),
                "Total Grand Exchange value of items you gave away: %s"
        );
        contentPanel.add(myLabel, gbc);

        gbc.gridy = 1;
        contentPanel.add(myItemGrid, gbc);

        gbc.gridy = 2;
        QuantityLabel otherLabel = new QuantityLabel(
                tradeData.receivedTotalValueGE,
                String.format(TEMPLATE_TRADE_TOTAL, "Received items", "#90FF90", "%s"),
                "Total Grand Exchange value of items you were given: %s"
        );
        contentPanel.add(otherLabel, gbc);

        gbc.gridy = 3;
        contentPanel.add(otherItemGrid, gbc);

        final long netTransfer = tradeData.receivedTotalValueGE - tradeData.givenTotalValueGE;
        final Color footerColor = netTransfer > 0 ? COLOR_FOOTER_PROFIT : netTransfer < 0 ? COLOR_FOOTER_LOSS : COLOR_FOOTER_EVEN;
        footerPanel.setBackground(footerColor);
        if (tradeData.givenItems.isEmpty() && tradeData.receivedItems.isEmpty())
        {
            footerPanel.add(new JLabel("No items traded"));
        }
        else if (netTransfer == 0)
        {
            footerPanel.add(new JLabel("GE values matched exactly"));
        }
        else
        {
            String footerPrefix = netTransfer < 0 ? "You lost" : "You gained";
            QuantityLabel footerLabel = new QuantityLabel(netTransfer, "<html>" + footerPrefix + ": %s  <span style='color:#909090'>[GE]</span></html>", "%s");
            footerPanel.add(footerLabel);
        }
        updatePreferredSize();
    }

    // Collapses the entire panel to zero height to prevent it form taking space in the history
    private void updatePreferredSize()
    {
        double contentSize = 0d;
        if (!isCollapsed())
        {
            int rows = (int)(Math.ceil(tradeData.givenItems.size() / 6f) + Math.ceil(tradeData.receivedItems.size() / 6f));
            contentSize = ItemLabel.ICON_SIZE * Math.max(2, rows) + 42d;
        }
        final double height = toggleButton.getPreferredSize().getHeight() + footerPanel.getPreferredSize().getHeight() + contentSize;
        final Dimension size = new Dimension(TradeTrackerPluginPanel.PANEL_WIDTH + 2, (int)height);
        setPreferredSize(size);
        setMaximumSize(size);
    }

    public final long getTradeTime() { return tradeData.tradeTime; }
    public final TradeData getTradeData() { return tradeData; }

    public final String getNote() { return tradeData.note; }
    public void setNote(String note)
    {
        if (!note.trim().equals(tradeData.note))
        {
            tradeData.note = note.trim();
            updateNoteUI();
            SaveManager.requestTradeHistorySave();
        }
    }

    // Updates the visuals and tooltip for note icon
    private void updateNoteUI()
    {
        if (tradeData.note.isBlank())
        {
            if (noteIconLabel != null)
            {
                noteIconLabel.setToolTipText("");
                noteIconLabel.setVisible(false);
            }
        }
        else
        {
            if (noteIconLabel == null)
            {
                noteIconLabel = new JLabel();
                noteIconLabel.setIcon(ICON_NOTE);
                noteIconLabel.setSize(new Dimension(6 , 7));
                toggleButton.add(noteIconLabel, BorderLayout.WEST);
            }
            noteIconLabel.setToolTipText(tradeData.note);
            noteIconLabel.setVisible(true);
        }
    }

    public void toggleHidden(final boolean hide)
    {
        setVisible(hide);
        paddingStrut.setVisible(hide);
    }

    // Updates the text for the time label. Used when toggling the config for 24 hour time.
    public void updateTimeDisplay()
    {
        tradeTimeLabel.setText(String.format(TRADE_TIME_TEMPLATE, TimeUtils.timestampToStringTime(tradeData.tradeTime)));
    }

    @Override
    protected void onToggleCollapsed()
    {
        updatePreferredSize();
    }

    // Returns true if any strings or quantities in this trade record match the passed string.
    // Ignores case.
    public boolean match(String query)
    {
        query = query.trim().toLowerCase();
        // check if traded player's name contains query
        if (tradeData.tradedPlayer.tradeName.toLowerCase().contains(query.toLowerCase()))
            return true;
        // check if any words in notes start with query
        if (tradeData.note != null && !tradeData.note.isBlank())
        {
            final int noteLength = tradeData.note.length(), queryLength = query.length();
            final HashMap<Character, ArrayList<Integer>> wordIndexes = StringUtils.getIndexesOfFirstLetterOfWord(tradeData.note);
            for (final char key : wordIndexes.keySet())
            {
                for (final int index : wordIndexes.get(key))
                {
                    final int subStrLength = Math.min(queryLength, noteLength - index);
                    if (queryLength <= subStrLength)
                    {
                        if (query.equals(tradeData.note.substring(index, index + subStrLength)))
                        {
                            return true;
                        }
                    }
                }
            }
        }
        // float numeric queries
        if (simpleData != null && simpleData.isValid())
        {
            if (Float.toString(simpleData.getPricePerItem()).startsWith(query))
                return true;
        }
        // int/long numeric queries
        if (StringUtils.isStringLong(query) || query.equals("-"))
        {
            // searching for balance values
            if (Long.toString(tradeData.receivedTotalValueGE).startsWith(query))
                return true;
            if (Long.toString(tradeData.givenTotalValueGE).startsWith(query))
                return true;
            if (Long.toString(tradeData.receivedTotalValueGE-tradeData.givenTotalValueGE).startsWith(query))
                return true;

            // query simple trade values
            if (simpleData != null && simpleData.isValid())
            {
                if (Long.toString(simpleData.getQuantity()).startsWith(query))
                    return true;
                if (Long.toString(simpleData.getQuantity() * simpleData.getItem().getGEValue()).startsWith(query))
                    return true;
            }

            // query properties on given and received items
            for (var list : new ArrayList<>(Arrays.asList(tradeData.givenItems, tradeData.receivedItems)))
            {
                // query individual item counts and values
                for (final TradeItemData item : list)
                {
                    if (CommonUtils.getConfig().filterMatchItemId())
                    {
                        if (Integer.toString(item.getUnnotedID()).startsWith(query))
                            return true;
                        if (item.isNoted() && Integer.toString(item.getID()).startsWith(query))
                            return true;
                    }
                    if (Integer.toString(item.getQuantity()).startsWith(query))
                        return true;
                    if (Integer.toString(item.getGEValue()).startsWith(query))
                        return true;
                }

                // query cumulative item quantities (if simple trade, this has already been done)
                if (simpleData != null && simpleData.isValid())
                {
                    final var itemCountSums = TradeUtils.getItemCounts(list);
                    for (final int key : itemCountSums.keySet())
                    {
                        if (Long.toString(itemCountSums.get(key)).startsWith(query))
                        {
                            return true;
                        }
                    }
                }
            }
        }
        // Text queries
        else
        {
            // check item names
            for (var list : new ArrayList<>(Arrays.asList(tradeData.givenItems, tradeData.receivedItems)))
            {
                for (final TradeItemData item : list)
                {
                    final String itemName = TradeUtils.getOrDefaultCachedItemName(item.getUnnotedID(), null);
                    if (itemName != null && itemName.toLowerCase().contains(query))
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }

}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.ui;

import javax.swing.*;
import java.awt.*;

class CollapsiblePanel extends JPanel
{
    protected final JPanel contentPanel;
    protected final JPanel footerPanel;
    protected final JButton toggleButton;
    private boolean isExpanded = false;

    CollapsiblePanel(String title)
    {
        setLayout(new BorderLayout());
        toggleButton = new JButton(title);
        contentPanel = new JPanel();
        footerPanel = new JPanel();
        toggleButton.addActionListener(e -> toggleCollapsed());
        add(toggleButton, BorderLayout.NORTH);
        add(contentPanel, BorderLayout.CENTER);
        add(footerPanel, BorderLayout.SOUTH);
        contentPanel.setVisible(isExpanded);
    }

    // Explicitly set the collapsed state. Does nothing if already in the passed state
    public void setCollapsed(boolean newCollapsed)
    {
        if (newCollapsed == !isExpanded)
        {
            return;
        }
        toggleCollapsed();
    }

    // Changes the collapsed state of the panel to open if closed, and closed if open
    public void toggleCollapsed()
    {
        isExpanded = !isExpanded;
        onToggleCollapsed();
        contentPanel.setVisible(isExpanded);
        revalidate();
        repaint();
    }

    // Overrideable function to respond to when the panel changes its collapsed state
    protected void onToggleCollapsed(){}

    public final boolean isCollapsed() { return !isExpanded; }

}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.ui;

import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.QuantityFormatter;
import org.asundr.trade.TradeItemData;
import org.asundr.trade.TradeUtils;
import org.asundr.utility.CommonUtils;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.Consumer;

class ItemLabel extends JLabel
{
    private static final String ITEM_TOOLTIP_TEMPLATE = "<html><body style><b style='color:#A0A0FF'>%s</b><br>Quantity: %s<br>GE: %s<br>Total: %s</body></html>";
    public static final int ICON_SIZE = 36;
    private static final Dimension PREFERRED_SIZE = new Dimension(ICON_SIZE, ICON_SIZE);
    private final TradeItemData itemData;
    private final long quantityOverride;

    private static JPopupMenu popupMenu = null;
    private static String popupItemName = null;


    ItemLabel(final TradeItemData itemData, final Consumer<MouseEvent> mouseClickedCallback, final long quantityOverride)
    {
        this.itemData = itemData;
        this.quantityOverride = quantityOverride;
        final int displayId = itemData.getID();
        final AsyncBufferedImage img = TradeUtils.getItemImage(displayId, itemData.getQuantity(), true);
        img.addTo(this);
        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                super.mouseEntered(e);
                ToolTipManager.sharedInstance().setEnabled(true);
                final String tipStr = String.format(
                        ITEM_TOOLTIP_TEMPLATE,
                        TradeUtils.getOrDefaultCachedItemName(itemData.getUnnotedID(), "Item"),
                        QuantityFormatter.formatNumber(GetTrueQuantity()),
                        QuantityFormatter.formatNumber(itemData.getGEValue()),
                        QuantityFormatter.formatNumber((long)itemData.getGEValue() * GetTrueQuantity())
                );
                setToolTipText(tipStr);
            }
            @Override
            public void mouseClicked(MouseEvent e)
            {
                super.mouseClicked(e);
                if (e.getButton() == MouseEvent.BUTTON3)
                {
                    popupItemName = TradeUtils.getStoredItemName(itemData.getUnnotedID());
                    if (popupItemName != null)
                    {
                        if (popupMenu == null)
                        {
                            popupMenu = new JPopupMenu();
                            final JMenuItem openWiki = new JMenuItem("Open in Wiki");
                            openWiki.addActionListener(evt -> CommonUtils.openItemWiki(getCurrentItemName()));
                            popupMenu.add(openWiki);
                        }
                        popupMenu.show(e.getComponent(),e.getX(),e.getY());
                    }
                    return;
                }
                if (mouseClickedCallback != null)
                {
                    mouseClickedCallback.accept(e);
                }
            }
        });
        setPreferredSize(PREFERRED_SIZE);
        setMinimumSize(PREFERRED_SIZE);
    }

    private static String getCurrentItemName() { return popupItemName; }

    ItemLabel(TradeItemData itemData) { this(itemData, null, -1L); }

    public long GetTrueQuantity() { return quantityOverride == -1 ? itemData.getQuantity() : quantityOverride; }

}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.ui;

import org.asundr.utility.CommonUtils;

import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
import java.util.function.Consumer;
import java.util.function.Predicate;

// Button used for the main panel toolbar that toggles its state when clicked
class ToolbarButton extends JButton
{
    private final ImageIcon iconEnabled, iconDisabled;
    private final static int HEADER_ICON_SIZE = 32;
    private final static Border BORDER_TOOLBAR_BUTTON = BorderFactory.createLineBorder(new Color(30,30,35), 1, true);
    private final static Color COLOR_TOOLBAR_BUTTON_BACKGROUND = new Color(15, 15, 35);

    private final String enabledToolTipText;
    private final String disabledToolTipText;
    private Consumer<Boolean> onToggledActive;      // Called whenever the active state is toggled
    private Predicate<Boolean> onToggledValidate;   // Called to check if a click should toggle the state
    private boolean active;

    public ToolbarButton(final String enabledIconPath, final String disabledIconPath, final String enabledToolTipText, final String disabledToolTipText, final boolean startActive, Consumer<Boolean> onToggledActive)
    {
        super();
        this.active = startActive;
        this.onToggledActive = onToggledActive;
        this.iconEnabled = CommonUtils.getIconFromName(enabledIconPath, HEADER_ICON_SIZE, HEADER_ICON_SIZE, Image.SCALE_SMOOTH);
        this.iconDisabled = disabledIconPath == null ? this.iconEnabled : CommonUtils.getIconFromName(disabledIconPath, HEADER_ICON_SIZE, HEADER_ICON_SIZE, Image.SCALE_SMOOTH);
        setBackground(COLOR_TOOLBAR_BUTTON_BACKGROUND);
        setBorder(BORDER_TOOLBAR_BUTTON);
        setIcon(active ? iconEnabled : iconDisabled);
        this.enabledToolTipText = enabledToolTipText;
        this.disabledToolTipText = disabledToolTipText == null ? this.enabledToolTipText : disabledToolTipText;
        setToolTipText(active ? enabledToolTipText : disabledToolTipText);
        addActionListener(e -> toggleActive());
    }

    // Sets the state of the button conditional on onToggledValidate if set
    public void setActive(final boolean newActive)
    {
        if (active == newActive || onToggledValidate != null && !onToggledValidate.test(newActive))
        {
            return;
        }
        active = newActive;
        setIcon(active ? iconEnabled : iconDisabled);
        setToolTipText(active ? enabledToolTipText : disabledToolTipText);
        if (onToggledActive != null)
        {
            onToggledActive.accept(active);
        }
    }
    // Flips the state of the button conditional on onToggledValidate if set
    public void toggleActive()
    {
        setActive(!active);
    }

    public final boolean isActive() { return active; }

    // Sets the callback for when the active state changes
    public void setOnToggledActive(final Consumer<Boolean> onToggledActive)
    {
        this.onToggledActive = onToggledActive;
    }

    // Sets the predicate for determine if changing the active state if valid
    public void setOnToggledValidate(final Predicate<Boolean> onToggledValidate)
    {
        this.onToggledValidate = onToggledValidate;
    }

}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.ui;

import net.runelite.client.util.QuantityFormatter;
import org.asundr.utility.StringUtils;

import javax.swing.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

class QuantityLabel extends JLabel
{

    private static final String TEXT_MENU_ITEM_COPY = "Copy";
    private static JPopupMenu menu = null;
    private static long activeQuantity = 0L;

    private static String getActiveQuantityString() { return Long.toString(activeQuantity); }

    QuantityLabel(long quantity, final String template, final String tooltipFormat)
    {
        super(String.format(template, StringUtils.quantityToRSDecimalStackLong(quantity, true)));
        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                super.mouseClicked(e);
                if (e.getButton() == MouseEvent.BUTTON3)
                {
                    if (menu == null)
                    {
                        menu = new JPopupMenu();
                        final JMenuItem copyValue = new JMenuItem(TEXT_MENU_ITEM_COPY);
                        copyValue.addActionListener(evt -> StringUtils.copyToClipboard(getActiveQuantityString()));
                        menu.add(copyValue);
                    }
                    activeQuantity = quantity;
                    menu.show(e.getComponent(), e.getX(), e.getY());
                } else {
                    super.mouseClicked(e);
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                super.mouseEntered(e);
                setToolTipText(String.format(tooltipFormat, QuantityFormatter.formatNumber(quantity)));
                getToolTipLocation(e);
            }
        });
    }

}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.ui;

import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.QuantityFormatter;

import org.asundr.*;
import org.asundr.recovery.EventTradeTrackerProfileChanged;
import org.asundr.recovery.ConfigKey;
import org.asundr.recovery.SaveManager;
import org.asundr.trade.*;
import org.asundr.utility.CommonUtils;
import org.asundr.utility.StringUtils;
import org.asundr.utility.TimeUtils;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

public class TradeTrackerPluginPanel extends PluginPanel
{
    private final static int TRADE_RECORD_PADDING = 10;
    private final static int HEADER_PADDING = 7;
    private final static int HEADER_FILTER_ENTRY_HEIGHT = 25;
    private final static int HEADER_HEIGHT_DEFAULT = 100;
    private final static int HEADER_HEIGHT_FILTERING = HEADER_HEIGHT_DEFAULT + HEADER_FILTER_ENTRY_HEIGHT + 4;
    private final static Color COLOR_HEADER_BACKGROUND = new Color(15, 15, 25);
    private final static Color COLOR_FILTER_TEXT_BACKGROUND = new Color(10, 10, 10);
    private final static Color COLOR_TOOLBAR_BACKGROUND = new Color(40, 40, 0);
    private final static String TEMPLATE_EMPTY_LIST = "<html><body style='text-align:center'><span style='font-size:12px;color:white'>%s</span><br><span style='font-size:10px;color:#939393'>%s</span></body></html>";
    private final static String TEMPLATE_SUBTITLE = "<html><span style='font-size:13;color:white'><nobr>%s <span style='color:#909090'>%s</span></nobr></span><html>";
    private final static String TEMPLATE_PURGE_TOOLTIP = "<html><span>%s auto-remove old trades</span></html>";
    private final static String TEMPLATE_PURGE_TOOLTIP_AUTO = "<html><span>%s auto-remove old trades</span><br><span>Lifetime: %s %s</span></html>";
    private final static Border BORDER_EMPTY = BorderFactory.createEmptyBorder(0, 0, 0, 0);
    private final static Border BORDER_FILTER_TEXT = BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(new Color(90,90,30), 1), BorderFactory.createEmptyBorder(0, 5, 0, 5));
    private final static Border BORDER_HISTORY_PANEL = BorderFactory.createEmptyBorder(4, 2, 2, 3);
    private final static Border BORDER_TOOLBAR = BorderFactory.createLineBorder(new Color(40, 40, 0), 3);


    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    private ScheduledFuture<?> scheduledUpdateTimeFuture = null;

    private final JPanel headerPanel = new JPanel();
    private final JPanel tradeHistoryPanel = new JPanel();
    private final JPanel emptyHistoryPanel = new JPanel();
    private final JLabel emptyHistoryLabel = new JLabel(String.format(TEMPLATE_EMPTY_LIST, "Trade History", "No trades have been recorded"));
    private final JLabel emptyFilterLabel = new JLabel(String.format(TEMPLATE_EMPTY_LIST, "Filter Results", "No recorded trades match your filter"));
    private final JLabel profileNameLabel = new JLabel();
    final private JPopupMenu subtitlePopup = new JPopupMenu();
    private ToolbarButton btnSchedulePurge;
    private ToolbarButton btnFilter;


    public TradeTrackerPluginPanel()
    {
        super(false); // disables scrolling
        final int panelWidth = getPreferredSize().width;
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        // Setup header panel
        headerPanel.setPreferredSize(new Dimension(panelWidth, HEADER_HEIGHT_DEFAULT));
        headerPanel.setMinimumSize(new Dimension(panelWidth, HEADER_HEIGHT_DEFAULT));
        buildHeader();

        // Setup history panel
        tradeHistoryPanel.setLayout(new BoxLayout(tradeHistoryPanel, BoxLayout.Y_AXIS));
        tradeHistoryPanel.setBorder(BORDER_HISTORY_PANEL);
        JScrollPane tradeHistoryScroll = new JScrollPane(tradeHistoryPanel);
        tradeHistoryScroll.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        tradeHistoryScroll.setPreferredSize(new Dimension(panelWidth, 2000));
        // Create custom scroll bar
        JScrollBar customScrollBar = new JScrollBar(JScrollBar.VERTICAL);
        Dimension preferredSize = new Dimension(6, Integer.MAX_VALUE);
        customScrollBar.setPreferredSize(preferredSize);
        tradeHistoryScroll.setVerticalScrollBar(customScrollBar);
        // Set empty trade history visibility
        updateEmptyHistoryMessages();

        add(headerPanel);
        add(emptyHistoryPanel);
        add(tradeHistoryScroll);

        // Schedule recurring update for time labels at midnight
        scheduler.scheduleAtFixedRate(
                () -> getTradeRecordPanels().forEach(TradeRecordPanel::updateTimeDisplay),
                TimeUtils.getTimeUntilMidnight() + 1000L,
                TimeUtils.MILLISECONDS_IN_DAY,
                TimeUnit.MILLISECONDS);
    }

    @Subscribe
    private void onEventTradeTrackerProfileChanged(EventTradeTrackerProfileChanged evt)
    {
        profileNameLabel.setVisible(evt.newProfile != null);
        if (evt.newProfile != null)
        {
            profileNameLabel.setText(String.format(TEMPLATE_SUBTITLE, evt.newProfile.getPlayerName(), evt.newProfile.getTypeString()));
        }
    }

    @Subscribe
    private void onConfigChanged(ConfigChanged e)
    {
        if (e.getGroup().equals(SaveManager.SAVE_GROUP))
        {
            switch (e.getKey())
            {
            case ConfigKey.USE_24_HOUR_TIME:
                getTradeRecordPanels().forEach(TradeRecordPanel::updateTimeDisplay);
                break;
            case ConfigKey.PURGE_HISTORY_TYPE: case ConfigKey.PURGE_HISTORY_MAGNITUDE:
                if (TradeManager.isPurgingExpiredTrades())
                {
                    btnSchedulePurge.setActive(false);
                    JOptionPane.showMessageDialog(
                        null,
                        "Auto-remove as been disabled, re-enable it on the toolbar",
                        "Enable auto-removing expired trades?",
                        JOptionPane.PLAIN_MESSAGE
                    );
                }
                break;
            }
        }

    }

    @Subscribe
    private void onEventTradeAdded(EventTradeAdded e)
    {
        addTradeRecord(e.tradeData);
    }

    @Subscribe
    private void onEventTradeRemoved(EventTradeRemoved e)
    {
        removeTradeRecord(e.tradeData);
    }

    @Subscribe
    private void onEventTradeResetHistory(EventTradeResetHistory e)
    {
        replaceAllTradeRecords(e.newTradeHistory);
    }

    public final Collection<TradeRecordPanel> getTradeRecordPanels()
    {
        return Arrays.stream(tradeHistoryPanel.getComponents()).filter(e -> e instanceof TradeRecordPanel).map(e -> (TradeRecordPanel)e).collect(Collectors.toList());
    }

    private void buildHeader()
    {
        headerPanel.setLayout(new BoxLayout(headerPanel, BoxLayout.Y_AXIS));
        headerPanel.setBackground(COLOR_HEADER_BACKGROUND);

        headerPanel.add(Box.createVerticalStrut(HEADER_PADDING));

        // Create title panel
        final JPanel titleWrapper = new JPanel();
        final JLabel titleLabel = new JLabel("<html><span style='font-size:16;color:yellow'><b><nobr>Trade Tracker</nobr></b></span><html><br>");
        titleLabel.setBorder(BORDER_EMPTY);
        titleWrapper.add(titleLabel);
        titleWrapper.setBackground(COLOR_HEADER_BACKGROUND);
        titleLabel.setToolTipText("Created by asundr");
        titleWrapper.setBorder(BORDER_EMPTY);
        titleWrapper.setPreferredSize(new Dimension(PANEL_WIDTH, 20));
        headerPanel.add(titleWrapper, CENTER_ALIGNMENT);

        // Create popup items for saving and loading history to disk
        final JMenuItem saveHistoryMenu = new JMenuItem("Save profile to file");
        saveHistoryMenu.addActionListener(a -> SaveManager.saveTradeHistoryToFile());
        final JMenuItem loadHistoryMenu = new JMenuItem(("Load profile from file"));
        loadHistoryMenu.addActionListener(a ->SaveManager.loadTradeHistoryFromFile());
        final JMenuItem saveCurrentMenu = new JMenuItem("Save current trade history");
        saveCurrentMenu.addActionListener(a -> SaveManager.requestTradeHistorySave());
        subtitlePopup.add(saveHistoryMenu);
        subtitlePopup.add(loadHistoryMenu);
        subtitlePopup.add(saveCurrentMenu);

        // Create subtitle panel and setup popup events
        final JPanel subtitleWrapper = new JPanel();
        profileNameLabel.setVisible(false);
        if (SaveManager.getActiveProfile() != null && CommonUtils.getConfig().getAutoLoadLastProfile())
        {
            profileNameLabel.setText(String.format(TEMPLATE_SUBTITLE, SaveManager.getActiveProfile().getPlayerName(), SaveManager.getActiveProfile().getTypeString()));
            profileNameLabel.setVisible(true);
        }
        subtitleWrapper.addMouseListener(new MouseAdapter() {
            @Override public void mouseClicked(MouseEvent e) {
                super.mouseClicked(e);
                if (e.getButton() == MouseEvent.BUTTON3)
                {
                    subtitlePopup.show(subtitleWrapper, e.getX(), e.getY());
                }
            }
            @Override public void mouseEntered(MouseEvent e) {
                super.mouseEntered(e);
                subtitleWrapper.setToolTipText(String.format("%s trades logged", QuantityFormatter.formatNumber(TradeManager.getTradeHistoryCount())));
            }
        });
        subtitleWrapper.setBackground(COLOR_HEADER_BACKGROUND);
        subtitleWrapper.add(profileNameLabel);
        profileNameLabel.setBorder(BORDER_EMPTY);
        subtitleWrapper.setBorder(BORDER_EMPTY);
        headerPanel.add(subtitleWrapper);

        // Setting up the toolbar panel
        buildToolbar();
    }

    private void buildToolbar()
    {
        final JPanel toolbarPanel = new JPanel();
        toolbarPanel.setBackground(COLOR_TOOLBAR_BACKGROUND);
        toolbarPanel.setBorder(BORDER_TOOLBAR);
        headerPanel.add(toolbarPanel);

        final GridBagConstraints gbc = new GridBagConstraints();
        toolbarPanel.setLayout(new GridBagLayout());
        gbc.fill = GridBagConstraints.NONE;
        gbc.weightx = 1;
        gbc.weighty = 1;
        gbc.gridx = 1;

        // Adding button to clear all trades
        final ToolbarButton btnClearAll = new ToolbarButton(
                "clear_all.png", null,
                "Clear trade history", "Clear trade history",
                false, null);
        btnClearAll.setOnToggledActive(active -> {
            final int response = JOptionPane.showConfirmDialog(
                    btnClearAll,
                    "Are you sure you want to permanently remove all trades?",
                    "Clear all trades?",
                    JOptionPane.YES_NO_OPTION
            );
            if (response == JOptionPane.YES_OPTION)
            {
                TradeManager.requestClearAllTradeRecords();
            }
        });
        gbc.gridy = 1;
        toolbarPanel.add(btnClearAll, gbc);

        // Adding button to toggle auto-removing expired trades
        final boolean isPurgingExpired = TradeManager.isPurgingExpiredTrades();
        btnSchedulePurge = new ToolbarButton(
                "schedule_purge_on.png", "schedule_purge_off.png",
                String.format(TEMPLATE_PURGE_TOOLTIP, "Disable"), String.format(TEMPLATE_PURGE_TOOLTIP, "Enable"),
                isPurgingExpired, TradeManager::setPurgingExpiredTrades);
        btnSchedulePurge.setOnToggledValidate(active -> {
            if (!active)
            {
                return true;
            }
            if(CommonUtils.getConfig().getPurgeHistoryType() == TradeTrackerConfig.PurgeHistoryType.NEVER)
            {
                JOptionPane.showMessageDialog(
                        btnSchedulePurge,
                        "'Auto-remove type' is set to Never, or 'Auto-remove length' less than one.\n\nChange this in the TradeTracker config.",
                        "Enable auto-removing expired trades?",
                        JOptionPane.PLAIN_MESSAGE
                );
                return false;
            }
            final long numExpired = getTradeRecordPanels().stream().filter(e -> e.getTradeData().isExpired()).count();
            if (numExpired == 0)
            {
                return true;
            }
            final int response = JOptionPane.showConfirmDialog(
                    btnSchedulePurge,
                    "Enabling this will immediately remove " + numExpired + " trades that have already expired.\n\nTrade lifetime can be updated in the Trade Tracker config.\n\nContinue?",
                    "Enable auto-removing expired trades?",
                    JOptionPane.YES_NO_OPTION
            );
            return response == JOptionPane.YES_OPTION;
        });
        btnSchedulePurge.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                super.mouseEntered(e);
                var purgeType = CommonUtils.getConfig().getPurgeHistoryType();
                final int purgeMag = CommonUtils.getConfig().getPurgeHistoryMagnitude();
                final boolean isNever = purgeType == TradeTrackerConfig.PurgeHistoryType.NEVER || purgeMag < 1;
                if (isNever) purgeType = TradeTrackerConfig.PurgeHistoryType.NEVER;
                btnSchedulePurge.setToolTipText(String.format(TEMPLATE_PURGE_TOOLTIP_AUTO,
                        btnSchedulePurge.isActive() ? "Disable" : "Enable",
                        isNever ? "" : purgeMag,
                        StringUtils.formatEnum(purgeType, isNever) + (!isNever && purgeMag > 1 ? "s" : ""))
                );
            }
        });
        gbc.gridx += 2;
        toolbarPanel.add(btnSchedulePurge, gbc);

        // Adding button to collapse / expand trade panels
        ToolbarButton btnToggleCollapseAll = new ToolbarButton(
                "expand_all.png", "collapse_all.png",
                "Collapse all", "Expand all", false, null);
        btnToggleCollapseAll.setOnToggledActive(active ->  getTradeRecordPanels().forEach(panel -> panel.setCollapsed(!active)) );
        gbc.gridx += 2;
        toolbarPanel.add(btnToggleCollapseAll, gbc);

        // Setting up text entry field for filtering trades
        final JTextField filterText = new JTextField();
        headerPanel.add(filterText);
        headerPanel.add(Box.createVerticalStrut(HEADER_PADDING/2));
        filterText.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) { updateFilter(filterText.getText()); }
            @Override
            public void removeUpdate(DocumentEvent e) { updateFilter(filterText.getText()); }
            @Override
            public void changedUpdate(DocumentEvent e) {}
        });
        filterText.setVisible(false);
        filterText.setBackground(COLOR_FILTER_TEXT_BACKGROUND);
        filterText.setBorder(BORDER_FILTER_TEXT);
        filterText.setPreferredSize(new Dimension(PANEL_WIDTH, HEADER_FILTER_ENTRY_HEIGHT));

        // Setting up button for toggling the filter
        btnFilter = new ToolbarButton(
                "filter_on.png", "filter_off.png",
                "Disable filter", "Enable filter", false, active -> {
            filterText.setVisible(active);
            final int headerHeight = active ? HEADER_HEIGHT_FILTERING : HEADER_HEIGHT_DEFAULT;
            headerPanel.setPreferredSize(new Dimension(PANEL_WIDTH, headerHeight));
            headerPanel.setMinimumSize(new Dimension(PANEL_WIDTH, headerHeight));
            updateFilter(active ? filterText.getText() : "");
            if (active)
            {
                filterText.grabFocus();
            }
            revalidate();
            repaint();
        });
        gbc.gridx += 2;
        toolbarPanel.add(btnFilter, gbc);
    }

    // Adds new trade panel to the history in response to new trade being added
    private void addTradeRecord(TradeData tradeData)
    {
        CommonUtils.getClientThread().invokeLater(() -> {
            final TradeRecordPanel tradeRecordPanel = new TradeRecordPanel(tradeData);
            tradeRecordPanel.paddingStrut = Box.createVerticalStrut(TRADE_RECORD_PADDING);
            tradeHistoryPanel.add(tradeRecordPanel.paddingStrut, 0);
            tradeHistoryPanel.add(tradeRecordPanel,0);
            updateEmptyHistoryMessages();
        });
    }

    // Removes a trade panel with the passed trade data in response to trade history removing trade
    private void removeTradeRecord(TradeData tradeData)
    {
        TradeRecordPanel toRemove = null;
        for(Component component : tradeHistoryPanel.getComponents())
        {
            if (component instanceof TradeRecordPanel)
            {
                final TradeRecordPanel curr = (TradeRecordPanel) component;
                if (curr.getTradeTime() == tradeData.tradeTime)
                {
                    toRemove = curr;
                    break;
                }
            }
        }
        if (toRemove == null)
        {
            return;
        }
        tradeHistoryPanel.remove(toRemove.paddingStrut);
        tradeHistoryPanel.remove(toRemove);
        updateEmptyHistoryMessages();
        updateUI();
    }

    // Removes all trade panels
    private void clearAllTradeRecords()
    {
        tradeHistoryPanel.removeAll();
        updateEmptyHistoryMessages();
        updateUI();
    }

    // Batch adds all trade panels from a trade history collection, replacing existing panels
    private void replaceAllTradeRecords(final Collection<TradeData> tradeHistory)
    {
        clearAllTradeRecords();
        if (tradeHistory == null || tradeHistory.isEmpty())
        {
            return;
        }
        CommonUtils.getClientThread().invokeLater(() ->
        {
            tradeHistoryPanel.setVisible(false);
            for (final TradeData tradeData : tradeHistory)
            {
                TradeUtils.fetchItemNames(tradeData.givenItems);
                TradeUtils.fetchItemNames(tradeData.receivedItems);
                tradeData.calculateAggregateValues();
            }
            for (final TradeData tradeData : tradeHistory)
            {
                TradeRecordPanel tradeRecordPanel = new TradeRecordPanel(tradeData);
                tradeRecordPanel.paddingStrut = Box.createVerticalStrut(TRADE_RECORD_PADDING);
                tradeHistoryPanel.add(tradeRecordPanel.paddingStrut, 0);
                tradeHistoryPanel.add(tradeRecordPanel, 0);
            }
            tradeHistoryPanel.setVisible(true);
            updateEmptyHistoryMessages();
        });
    }

    // Toggles the hidden status of trade panels depending on if they match the filter query
    private void updateFilter(final String query)
    {
        if (query.isBlank())
        {
            Arrays.stream(tradeHistoryPanel.getComponents())
                    .filter(e -> e instanceof TradeRecordPanel)
                    .forEach(e -> ((TradeRecordPanel)e).toggleHidden(true));
            updateEmptyHistoryMessages();
            return;
        }
        Arrays.stream(tradeHistoryPanel.getComponents()).parallel()
                .filter(e -> e instanceof TradeRecordPanel)
                .map(e -> (TradeRecordPanel)e)
                .forEach(e -> e.toggleHidden(e.match(query)));
        updateEmptyHistoryMessages();
        revalidate();
        repaint();
    }

    // Toggles the visibility of empty trade history messages in cases where there are
    // no trades or when all existing trades have been filtered out
    private void updateEmptyHistoryMessages()
    {
        emptyHistoryPanel.removeAll();
        emptyHistoryPanel.setVisible(false);
        if (tradeHistoryPanel.getComponents().length == 0)
        {
            emptyHistoryPanel.add(emptyHistoryLabel);
            emptyHistoryPanel.setVisible(true);
        }
        else if (btnFilter != null && btnFilter.isActive())
        {
            boolean noneVisible = true;
            for (final Component comp: tradeHistoryPanel.getComponents())
            {
                if (comp.isVisible())
                {
                    noneVisible = false;
                    break;
                }
            }
            if (noneVisible)
            {
                emptyHistoryPanel.add(emptyFilterLabel);
                emptyHistoryPanel.setVisible(true);
            }
        }
    }

}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.ui;

import net.runelite.api.GameState;
import org.asundr.recovery.SaveManager;
import org.asundr.trade.TradeManager;
import org.asundr.utility.CommonUtils;
import org.asundr.utility.StringUtils;

import net.runelite.api.Player;

import javax.swing.*;
import java.awt.*;

class TradeRecordPopUpMenu extends JPopupMenu
{
    private static final String TEXT_TOGGLE_COLLAPSE = "Toggle collapsed";
    private static final String TEXT_DELETE_ITEM = "<html><body style='color:red'>Delete</style></html>";
    private static final String TEMPLATE_EDIT_NOTE = "Edit note for trade with %s";
    private TradeRecordPanel tradeRecordPanel;
    private final JMenuItem editNote = new JMenuItem("Edit note");
    private final JMenuItem copyTrade = new JMenuItem("Copy trade data");
    private final JMenuItem highlightPlayer = new JMenuItem("Highlight player");

    TradeRecordPopUpMenu()
    {
        final JMenuItem toggleCollapse = new JMenuItem(TEXT_TOGGLE_COLLAPSE);
        toggleCollapse.addActionListener(e -> { if (tradeRecordPanel != null) tradeRecordPanel.toggleCollapsed(); });
        add(toggleCollapse);

        editNote.addActionListener(e -> {
            if (tradeRecordPanel == null)
                return;
            CommonUtils.promptTextEntry(
                    String.format(TEMPLATE_EDIT_NOTE, tradeRecordPanel.getTradeData().tradedPlayer.tradeName),
                    tradeRecordPanel.getNote(),
                    input -> { if (tradeRecordPanel != null ) tradeRecordPanel.setNote(input); }
            );
        });
        add(editNote);

        copyTrade.addActionListener( e -> { if (tradeRecordPanel != null) StringUtils.copyToClipboard(
                StringUtils.stringify(tradeRecordPanel.getTradeData()).replaceAll(SaveManager.REGEX_EMPTY_NOTES, "")
        ); });
        add(copyTrade);

        final JMenuItem deleteItem = new JMenuItem(TEXT_DELETE_ITEM);
        deleteItem.addActionListener(e -> { if (tradeRecordPanel != null) TradeManager.requestRemoveTradeRecord(tradeRecordPanel.getTradeData()); });
        add(deleteItem);
    }

    public void setTradeRecordPanel(TradeRecordPanel tradeRecordPanel)
    {
        this.tradeRecordPanel = tradeRecordPanel;
    }

    @Override
    public void show(Component invoker, int x, int y)
    {
        copyTrade.setVisible(CommonUtils.getConfig().canCopyTradeData());
        editNote.setVisible(CommonUtils.getClient().getGameState() == GameState.LOGGED_IN);
        highlightPlayer.setVisible(CommonUtils.getClient().getGameState() == GameState.LOGGED_IN);
        super.show(invoker, x, y);
    }

}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr;

import com.google.gson.Gson;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import org.asundr.recovery.SaveManager;
import org.asundr.trade.TradeManager;
import org.asundr.ui.TradeTrackerPluginPanel;
import org.asundr.trade.TradeUtils;
import org.asundr.utility.CommonUtils;
import org.asundr.utility.StringUtils;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;

@Slf4j
@PluginDescriptor(
	name = "Trade Tracker",
	description = "Records a searchable history of past trades with players",
	tags = {"trade", "history", "track", "item", "log", "logger", "memory"},
	enabledByDefault = true
)
public class TradeTrackerPlugin extends Plugin
{
	@Inject
	private Client client;
	@Inject
	private ClientToolbar clientToolbar;
	@Inject
	private ItemManager itemManager;
	@Inject
	private TradeTrackerConfig config;
	@Inject
	private ClientThread clientThread;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private ConfigManager configManager;
	@Inject
	private ChatboxPanelManager chatboxPanelManager;
	@Inject
	private EventBus eventBus;
	@Inject
	private Gson gson;

	private final SaveManager saveManager = new SaveManager();
	private NavigationButton navigationButton;
	private Collection<Object> eventSubscribers;

	@Provides TradeTrackerConfig provideConfig(ConfigManager configManager) { return configManager.getConfig(TradeTrackerConfig.class); }

	@Override
	protected void startUp() throws Exception
	{
		CommonUtils.initialize(config, client, clientThread, this, chatboxPanelManager, eventBus, overlayManager);
		StringUtils.initialize(gson);
		SaveManager.initialize(configManager);
		TradeUtils.initialize(itemManager);
		SaveManager.restoreCommonData();
		TradeTrackerPluginPanel mainPanel = new TradeTrackerPluginPanel();
		eventSubscribers = Arrays.asList(mainPanel, TradeManager.getInstance(), saveManager);
		eventSubscribers.forEach(e -> eventBus.register(e));
		if (!config.getAutoLoadLastProfile())
		{
			SaveManager.forgetActiveHistoryProfile();
		}
		SaveManager.restoreTradeHistoryData();
		addNavigationButton(mainPanel);
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(navigationButton);
		eventSubscribers.forEach(e -> eventBus.unregister(e));
		TradeManager.getInstance().shutdown();
	}

	private void addNavigationButton(final TradeTrackerPluginPanel mainPanel) throws IOException
	{
		navigationButton = NavigationButton.builder()
				.tooltip("Trade Tracker")
				.icon(CommonUtils.getImageFromName("nav_icon.png"))
				.priority(3)
				.panel(mainPanel)
				.build();
		clientToolbar.addNavigation(navigationButton);
	}

}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.recovery;

import org.asundr.trade.TradeData;

import java.util.ArrayDeque;

// Fired when a fresh trade history is loaded from config
final public class EventTradeHistoryProfileRestored
{
    public final String profileKey;
    public final ArrayDeque<TradeData> tradeHistory;

    EventTradeHistoryProfileRestored(final String profileKey, final ArrayDeque<TradeData> tradeHistory)
    {
        this.profileKey = profileKey;
        this.tradeHistory = tradeHistory;
    }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.recovery;

import javax.swing.*;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.io.*;

class FileUtils
{
    final static String FILE_EXTENSION_PROFILE_HISTORY = "rtth";
    final static String FILE_DESCRIPTION_PROFILE_HISTORY = "RuneLite Trade Tracker history";

    public static void writeStringToFile(final String defaultFileName, final String str)
    {
        final JFileChooser fileChooser = new JFileChooser();
        fileChooser.setSelectedFile(new File(defaultFileName + "." + FILE_EXTENSION_PROFILE_HISTORY));
        final FileNameExtensionFilter filter = new FileNameExtensionFilter(FILE_DESCRIPTION_PROFILE_HISTORY, FILE_EXTENSION_PROFILE_HISTORY);
        fileChooser.setFileFilter(filter);
        final int returnValue = fileChooser.showSaveDialog(null);
        if (returnValue == JFileChooser.APPROVE_OPTION)
        {
            final File selectedFile = fileChooser.getSelectedFile();
            try (final BufferedWriter writer = new BufferedWriter(new FileWriter(selectedFile)))
            {
                writer.write(str);
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public static String readStringFromFile(final String defaultFileName)
    {
        final JFileChooser fileChooser = new JFileChooser();
        fileChooser.setSelectedFile(new File(defaultFileName + "." + FILE_EXTENSION_PROFILE_HISTORY));
        final FileNameExtensionFilter filter = new FileNameExtensionFilter(FILE_DESCRIPTION_PROFILE_HISTORY, FILE_EXTENSION_PROFILE_HISTORY);
        fileChooser.setFileFilter(filter);
        final int returnValue = fileChooser.showOpenDialog(null);
        if (returnValue == JFileChooser.APPROVE_OPTION) {
            final File selectedFile = fileChooser.getSelectedFile();
            final StringBuilder jsonString = new StringBuilder();
            try (final BufferedReader reader = new BufferedReader(new FileReader(selectedFile)))
            {
                String line;
                while ((line = reader.readLine()) != null)
                {
                    jsonString.append(line);
                }
                return jsonString.toString();
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }
        return null;
    }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.recovery;

import lombok.extern.slf4j.Slf4j;

import java.io.ByteArrayOutputStream;
import java.util.Base64;
import java.util.zip.Deflater;
import java.util.zip.Inflater;

@Slf4j
public class CompressionUtils
{
    private final static int BUFFER_SIZE = 1024 * 32;

    public static byte[] compress(final String str)
    {
        final byte[] input = str.getBytes();
        final Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION);
        deflater.setStrategy(Deflater.FILTERED);
        deflater.setInput(input);
        deflater.finish();
        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(input.length);
        final byte[] buffer = new byte[BUFFER_SIZE];
        while (!deflater.finished())
        {
            final int len = deflater.deflate(buffer);
            byteArrayOutputStream.write(buffer, 0, len);
        }
        deflater.end();
        return byteArrayOutputStream.toByteArray();
    }

    public static String decompress(final byte[] compressed)
    {
        final Inflater inflater = new Inflater();
        inflater.setInput(compressed);
        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(compressed.length);
        final byte[] buffer = new byte[BUFFER_SIZE];
        try
        {
            while (!inflater.finished())
            {
                final int len = inflater.inflate(buffer);
                byteArrayOutputStream.write(buffer, 0, len);
            }
        }
        catch (Exception e)
        {
            log.error("failed to decompress trade history save data");
        }
        finally
        {
            inflater.end();
        }
        return byteArrayOutputStream.toString();
    }

    // Compresses the passed string, then encodes in Base64. ~16% of original size
    public static String compressToEncode(final String str)
    {
        return Base64.getEncoder().encodeToString(compress(str));
    }

    // Given a compressed string encoded in Base64, returns the original string
    public static String decompressFromEncode(final String compressed)
    {
        return decompress(Base64.getDecoder().decode(compressed));
    }

}

package org.asundr.recovery;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class SaveUpgradeUtils {

    static String version1to2json(final String decoded)
    {
        final Pattern nodedIdPattern = Pattern.compile( "\"id\":(\\d+),\"notedID\":(\\d+)");
        Matcher m = nodedIdPattern.matcher(decoded);
        String converted = decoded;
        while (m.find())
        {
            final String originalID = m.group(2).equals("-1") ? m.group(1) : m.group(2);
            converted = converted.replace(m.group(0), "\"id\":" + originalID);
            m = nodedIdPattern.matcher(converted);
        }
//        final Pattern quantityPattern = Pattern.compile("\"quantity\":");
        converted = converted.replaceAll("\"quantity\":", "num:");
        converted = converted.replaceAll("\"geValue\":", "ge:");
        return converted;
    }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.recovery;

public final class ConfigKey
{
    public static final String COMMON = "Common";
    public static final String AUTOLOAD_LAST_PROFILE = "autoLoadLastProfile";
    public static final String MAX_HISTORY = "maxHistoryCount";
    public static final String USE_24_HOUR_TIME = "use24HourTime";
    public static final String PLAYER_HIGHLIGHT_COLOR = "playerHighlightColor";
    public static final String PLAYER_HIGHLIGHT_DURATION = "playerHighlightDuration";
    public static final String PLAYER_HIGHLIGHT_SHOW_LINE = "playerHighlightShowLine";
    public static final String PLAYER_HIGHLIGHT_SHOW_MINIMAP = "playerHighlightShowMinimap";
    public static final String IGNORE_EMPTY_TRADES = "ignoreEmptyTrades";
    public static final String FILTER_ITEM_ID = "filterItemID";
    public static final String COPY_TRADE_DATE_MENU = "debugCopyTradeData";
    public static final String PURGE_HISTORY_TYPE = "purgeHistoryType";
    public static final String PURGE_HISTORY_MAGNITUDE = "purgeHistoryMagnitude";
    public static final String SCHEDULED_PURGE = "SchedulePurge";
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.recovery;

import org.asundr.TradeHistoryProfile;

import java.util.ArrayList;

// Serializable data used to store and maintain data common to all profiles
public class SaveData_Common
{
    private int saveVersion;
    private TradeHistoryProfile activeProfile;
    final private ArrayList<TradeHistoryProfile> savedProfiles = new ArrayList<>();

    SaveData_Common(final int version, final TradeHistoryProfile activeProfile)
    {
        this.saveVersion = version;
        this.activeProfile = activeProfile;
        savedProfiles.add(activeProfile);
    }

    public void updateSaveVersion(final int newSaveVersion)
    {
        assert(newSaveVersion > this.saveVersion);
        this.saveVersion = newSaveVersion;
    }

    public void setActiveProfile(final TradeHistoryProfile activeProfile)
    {
        if (this.activeProfile == activeProfile)
        {
            return;
        }
        if (activeProfile != null)
        {
            final int existingIndex = savedProfiles.indexOf(activeProfile);
            if (existingIndex == -1)
            {
                savedProfiles.add(activeProfile);
            }
            else
            {
                savedProfiles.set(existingIndex, activeProfile);
            }
        }
        this.activeProfile = activeProfile;
    }

    public final TradeHistoryProfile getActiveProfile() { return activeProfile; }

    public final ArrayList<TradeHistoryProfile> getSavedProfiles() { return new ArrayList<>(savedProfiles); }

    public void removeSavedProfile(final TradeHistoryProfile profile)
    {
        savedProfiles.removeIf(e -> e == profile);
    }

}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.recovery;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.Subscribe;
import org.asundr.trade.TradeData;
import org.asundr.TradeHistoryProfile;
import org.asundr.trade.TradeManager;
import org.asundr.utility.CommonUtils;
import org.asundr.utility.StringUtils;

import java.lang.reflect.Type;
import java.util.ArrayDeque;
import java.util.concurrent.atomic.AtomicInteger;

@Slf4j
public class SaveManager
{
    public final static String REGEX_EMPTY_NOTES = ",\"note\":(?:null|\"\")";

    // used to schedule saves and prevent save operations from being interrupted
    private static final class SaveState
    {
        static final int INACTIVE = 0;
        static final int REQUESTED = 1;
        static final int ACTIVE = 1 << 1;
        static final int ACTIVE_REQUESTED = REQUESTED | ACTIVE;

    }
    public final static int SAVE_VERSION = 2; // This should increase whenever save data or method changes
    public final static String SAVE_GROUP = "TradeTracker";
    private final static String DEFAULT_SAVE_FILENAME = "profile";
    private static ConfigManager configManager;
    private static SaveData_Common saveDataCommon;
    private final static AtomicInteger tradeHistorySaveState = new AtomicInteger(SaveState.INACTIVE); // flags for trade history

    @Subscribe
    private void onGameStateChanged(GameStateChanged evt)
    {
        if (evt.getGameState() == GameState.LOGGED_IN)
        {
            attemptGetPlayer();
        }
    }

    // repeatedly tries to get the player, then sets the active profile
    private void attemptGetPlayer()
    {
        final Client client = CommonUtils.getClient();
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return;
        }
        final String playerName = client.getLocalPlayer().getName();
        if (playerName == null)
        {
            CommonUtils.getClientThread().invokeLater(this::attemptGetPlayer);
        }
        else
        {
            setActiveHistoryProfile(new TradeHistoryProfile(client.getAccountHash(), playerName, RuneScapeProfileType.getCurrent(client)));
        }
    }

    // Sets the history associated with the passed profile
    private void setActiveHistoryProfile(final TradeHistoryProfile profile)
    {
        if (profile == null)
        {
            return;
        }
        final SaveData_Common saveData = getSaveDataCommon();
        final TradeHistoryProfile oldProfile = saveData.getActiveProfile();
        saveData.setActiveProfile(profile);
        CommonUtils.postEvent(new EventTradeTrackerProfileChanged(oldProfile, profile));
        SaveManager.restoreTradeHistoryData();
        SaveManager.saveCommonData();
    }

    // Sets the active profile to null without updating the UI or saving
    public static void forgetActiveHistoryProfile()
    {
        saveDataCommon.setActiveProfile(null);
    }

    public static void initialize(ConfigManager configManager)
    {
        SaveManager.configManager = configManager;
    }

    private static SaveData_Common getSaveDataCommon()
    {
        if (saveDataCommon == null)
        {
            saveDataCommon = new SaveData_Common(SAVE_VERSION, null);
        }
        return saveDataCommon;
    }

    public static TradeHistoryProfile getActiveProfile() { return saveDataCommon == null ? null : saveDataCommon.getActiveProfile(); }

    public static boolean isSaving() { return tradeHistorySaveState.get() != 0; }

    // serializes and saves common data
    private static void saveCommonData()
    {

        Gson gson = StringUtils.getGsonBuilder();
        String json = gson.toJson(getSaveDataCommon());
        configManager.setConfiguration(SAVE_GROUP, ConfigKey.COMMON, json);
    }

    // Converts the active profile's trade history to a json string, or null if there is not a populated history
    public static String getTradeHistoryAsJson()
    {
        if (saveDataCommon == null || saveDataCommon.getActiveProfile() == null)
        {
            return null;
        }
        final ArrayDeque<TradeData> tradeHistory = TradeManager.getTradeHistory();
        if (tradeHistory.isEmpty())
        {
            return null;
        }
        final Gson gson = StringUtils.getGsonBuilder();
        String historyJson = gson.toJson(tradeHistory);
        historyJson = historyJson.replaceAll(REGEX_EMPTY_NOTES, ""); // remove empty notes
        final SaveData_Profile saveData = new SaveData_Profile(
                SAVE_VERSION,
                SaveManager.saveDataCommon.getActiveProfile().getKeyString(),
                CompressionUtils.compressToEncode(historyJson));
        return gson.toJson(saveData);
    }

    // Saves the current trade history to the config using the profile's hash and account type as a key
    private static void saveTradeHistoryData()
    {
        tradeHistorySaveState.set(tradeHistorySaveState.get() ^ SaveState.ACTIVE_REQUESTED); // removed requested, add enabled active
        try
        {
            final String json = getTradeHistoryAsJson();
            if (saveDataCommon == null || saveDataCommon.getActiveProfile() == null)
            {
                return;
            }
            if (json == null)
            {
                configManager.unsetConfiguration(SAVE_GROUP, saveDataCommon.getActiveProfile().getKeyString());
                return;
            }
            configManager.setConfiguration(SAVE_GROUP, SaveManager.saveDataCommon.getActiveProfile().getKeyString(), json);
        }
        finally
        {
            tradeHistorySaveState.set(tradeHistorySaveState.get() & ~SaveState.ACTIVE); // remove active state
        }
    }

    // Reads the common save data from config and sets that as the active save data
    public static void restoreCommonData()
    {
        final Gson gson = StringUtils.getGsonBuilder();
        final String json = configManager.getConfiguration(SAVE_GROUP, ConfigKey.COMMON);
        if (json == null || json.isBlank())
        {
            saveDataCommon = new SaveData_Common(SAVE_VERSION, null);
            return;
        }
        saveDataCommon = gson.fromJson(json, SaveData_Common.class);
    }

    // Restores the history of trades from the config entry associated with the currently active account
    public static void restoreTradeHistoryData()
    {
        if (saveDataCommon == null || saveDataCommon.getActiveProfile() == null)
        {
            return;
        }
        final String json = configManager.getConfiguration(SAVE_GROUP, saveDataCommon.getActiveProfile().getKeyString());
        restoreTradeHistoryData(json);
    }

    // Restores the trade history using a json string serialized from SaveData_Profile
    private static void restoreTradeHistoryData(final String json)
    {
        final Gson gson = StringUtils.getGsonBuilder();
        if (json == null || json.equals(""))
        {
            return;
        }
        final Type dequeType = new TypeToken<ArrayDeque<TradeData>>(){}.getType();
        try
        {
            final SaveData_Profile saveData = gson.fromJson(json, SaveData_Profile.class);
            if (saveData == null)
            {
                log.error("Failed to parse trade history json");
                return;
            }
            String decompressedHistory = CompressionUtils.decompressFromEncode(saveData.encodedTradeHistory);
            if (saveData.saveVersion == 1)
            {
                decompressedHistory = SaveUpgradeUtils.version1to2json(decompressedHistory);
            }
            final String profileKey = getSaveDataCommon().getActiveProfile() == null ? null : saveDataCommon.getActiveProfile().getKeyString();
            CommonUtils.postEvent(new EventTradeHistoryProfileRestored(
                    profileKey,
                    gson.fromJson(decompressedHistory, dequeType)
            ));
        }
        catch (Exception e)
        {
            log.error("Failed to parse trade history json");
        }
    }

    // Repeatedly attempts to start a new save thread while a queued save is pending
    private static void scheduleSave()
    {
        if (tradeHistorySaveState.get() == SaveState.REQUESTED)
        {
            new Thread(SaveManager::saveTradeHistoryData).start();
        }
        if ((tradeHistorySaveState.get() & SaveState.REQUESTED) > 0)
        {
            CommonUtils.getClientThread().invokeLater(SaveManager::scheduleSave);
        }
    }

    // The public method that should be called to save the current trade history
    public static void requestTradeHistorySave()
    {
        tradeHistorySaveState.set(tradeHistorySaveState.get() | SaveState.REQUESTED);
        CommonUtils.getClientThread().invokeLater(SaveManager::scheduleSave);
    }

    // Saves to the plugin's default group with the passed key
    public static void saveWithKey(final String key, Object data)
    {
        final Gson gson = StringUtils.getGsonBuilder();
        configManager.setConfiguration(SAVE_GROUP, key, gson.toJson(data));
    }

    // Restores from the plugin's default group with the passed key.
    // Return type matches that of the variable this function output is assigned to.
    public static <T> T restoreFromKey(final String key)
    {
        final Gson gson = StringUtils.getGsonBuilder();
        final String value = configManager.getConfiguration(SAVE_GROUP, key);
        if (value == null)
        {
            return null;
        }
        return gson.fromJson(value, new TypeToken<T>(){}.getType());
    }

    // Exports the active profile's trade history profile as json to the file specified by the user
    public static void saveTradeHistoryToFile()
    {
        final String json = getTradeHistoryAsJson();
        if (json != null)
        {
            FileUtils.writeStringToFile(saveDataCommon.getActiveProfile().getKeyString(), json);
        }
    }

    // Imports a trade history profile to the active profile from a file specified by the user
    public static void loadTradeHistoryFromFile()
    {
        String filename = DEFAULT_SAVE_FILENAME;
        if (saveDataCommon != null && saveDataCommon.getActiveProfile() != null)
        {
            filename = saveDataCommon.getActiveProfile().getKeyString();
        }
        final String json = FileUtils.readStringFromFile(filename);
        if (json == null || json.isBlank())
        {
            return;
        }
        restoreTradeHistoryData(json);
    }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.recovery;

import org.asundr.TradeHistoryProfile;

// Fires when the active player profile changes
final public class EventTradeTrackerProfileChanged
{
    public final TradeHistoryProfile oldProfile;
    public final TradeHistoryProfile newProfile;

    EventTradeTrackerProfileChanged(TradeHistoryProfile oldProfile, TradeHistoryProfile newProfile)
    {
        this.oldProfile = oldProfile;
        this.newProfile = newProfile;
    }

}
/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.recovery;

// Serializable data used to save and restore trade history. Save version should be used to determine how to decode the tradeHistory string.
public class SaveData_Profile
{
    public final int saveVersion;
    public final String profileName;
    public final String encodedTradeHistory;

    SaveData_Profile(final int saveVersion, final String profile, String encodedTradeHistory)
    {
        this.saveVersion = saveVersion;
        profileName = profile;
        this.encodedTradeHistory = encodedTradeHistory;
    }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.trade;

// contains data used to describe an item stack at the time of a trade
public class TradeItemData
{
    private final int id;                   // original id (may be noted)
    private transient int unnotedId = 0;    // Optional unnoted id if this.id is noted. Dwarf remains (id=0) can never be noted so this should be ok
    private final int num;                  // the item quantity
    private int ge = -1;                    // this is the GE value at the time of the trade and should not be updated

    TradeItemData(int id, int quantity, int value)
    {
        this.id = id;
        this.num = quantity;
        this.ge = value;
    }

    public TradeItemData(int id, int quantity)
    {
        this(id, quantity, -1);
    }

    TradeItemData(TradeItemData other)
    {
        this.id = other.id;
        this.num = other.num;
        this.ge = other.ge;
        this.unnotedId = other.unnotedId;
    }

    public final boolean isNoted() { return unnotedId > 0; }

    public final int getID() { return id; }

    public final int getUnnotedID() { return isNoted() ? unnotedId : id; }

    //public final int getNotedID() { return id; }

    public final int getQuantity() { return num; }

    public final int getGEValue() { return ge; }

    private void setGEValue(final int value, final boolean override)
    {
        if (ge == -1 || override)
        {
            ge = value;
        }
    }
    public void setGEValue(final int value) { setGEValue(value, false); }

    public void setUnnotedId(final int unnotedId)
    {
        if (isNoted())
        {
            return;
        }
        this.unnotedId = unnotedId;
    }

}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.trade;

import java.util.Collection;

// Event fired when the trade history is completely replaced. Listened to by the UI.
final public class EventTradeResetHistory
{
    public final Collection<TradeData> newTradeHistory;

    EventTradeResetHistory(final Collection<TradeData> newTradeHistory)
    {
        this.newTradeHistory = newTradeHistory;
    }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.trade;

import java.util.ArrayList;

import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import org.asundr.utility.CommonUtils;

// Contains all data to describe a trade between players
public class TradeData
{
    public long tradeTime = 0L;                                     // timestamp in seconds
    public TradePlayerData tradedPlayer = new TradePlayerData();    // Data from the other player such as name at time of trade
    public ArrayList<TradeItemData> givenItems =  new ArrayList<>();
    public ArrayList<TradeItemData> receivedItems = new ArrayList<>();
    transient public long givenTotalValueGE = 0L;                             // aggregate grand exchange value of given items in coins at the time of trade
    transient public long receivedTotalValueGE = 0L;                          // aggregate grand exchange value of received items in coins at the time of trade
    public String note = "";                                        // player-authored note

    // Refreshes the tracked items of this player, or the traded player by querying their respective trade container
    public void updateItems(boolean isCurrentPlayer, ItemContainer itemContainer)
    {
        final ArrayList<TradeItemData> updatedItems = isCurrentPlayer ? givenItems : receivedItems;
        updatedItems.clear();
        if (itemContainer == null)
        {
            return;
        }
        for (Item item : itemContainer.getItems())
        {
            if (item == null)
            {
                continue;
            }
            updatedItems.add(new TradeItemData(item.getId(), item.getQuantity()));
        }
    }

    // Calculates the total value of items given and received. Should only be called after ge prices for all items have been fetched.
    public void calculateAggregateValues()
    {
        givenTotalValueGE = TradeUtils.totalGEValue(givenItems);
        receivedTotalValueGE = TradeUtils.totalGEValue(receivedItems);
    }

    public final boolean isEmpty()
    {
        return givenItems.isEmpty() && receivedItems.isEmpty();
    }

    public final boolean isExpired()
    {
        if (!CommonUtils.isValidPurgeConfig())
        {
            return false;
        }
        return tradeTime*1000L + CommonUtils.getRecordLifetime() < System.currentTimeMillis();
    }

}

package org.asundr.trade;

import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;

final public class TradeUtils
{
    public enum ItemID
    {
        COINS(995),
        PLATINUM(13204);
        public final int id;
        ItemID(int id) {this.id = id;}
    }

    private final static HashMap<Integer, String> itemNameCache = new HashMap<>();

    private static ItemManager itemManager;

    public static void initialize(final ItemManager itemManager)
    {
        TradeUtils.itemManager = itemManager;
    }

    public static String getStoredItemName(final int id)
    {
        return itemNameCache.get(id);
    }
    public static String getOrDefaultCachedItemName(final int id, final String defaultValue) { return itemNameCache.getOrDefault(id, defaultValue); }

    // Returns the price of the item with the passed ID
    // Note: Should be called via clientThread.invokeLater()
    public static int getItemPrice(final int itemID)
    {
        return itemManager.getItemPrice(itemID);
    }

    // Fetches and assigns the Grand Exchange prices of the passed items
    // Note: Should be called via clientThread.invokeLater()
    public static void fetchGePrices(final Collection<TradeItemData> itemDataList)
    {
        for (TradeItemData itemData : itemDataList)
        {
            itemData.setGEValue(getItemPrice(itemData.getUnnotedID()));
        }
    }

    // Fetches item names and will update the id of noted items
    // Note: Should be called via clientThread.invokeLater()
    public static void fetchItemNames(final Collection<TradeItemData> itemDataList)
    {
        for (final TradeItemData itemData : itemDataList)
        {
            if (!itemNameCache.containsKey(itemData.getID()))
            {
                final ItemComposition comp = itemManager.getItemComposition(itemData.getID());
                if (comp.getNote() != -1)
                {
                    itemData.setUnnotedId(comp.getLinkedNoteId());
                    if (itemNameCache.containsKey(itemData.getUnnotedID()))
                    {
                        continue;
                    }
                }
                itemNameCache.put(itemData.getUnnotedID(), comp.getMembersName());
            }
        }
    }

    // Returns the image for the passed item with the quantity count
    public static AsyncBufferedImage getItemImage(final int itemId, final int quantity, final boolean stackable)
    {
        return itemManager.getImage(itemId, quantity, stackable);
    }

    // Returns the aggregate quantity of all items with the specified ID in the passed item collection
    public static long getTotalItemQuantity(final Collection<TradeItemData> items, int id)
    {
        return items.stream().filter(i->i.getUnnotedID() == id).reduce(0L, (a, i) -> a + i.getQuantity(), Long::sum);
    }

    // Evaluates the aggregate Grand Exchange value of all passed item stacks
    public static long totalGEValue(final Collection<TradeItemData> items)
    {
        return items.stream().reduce(0L, (Acc, item) -> Acc + (item.getGEValue() * (long)item.getQuantity()), Long::sum);
    }

    // Returns true if the only items in the passed collection currency such as coins or platinum
    public static boolean isOnlyCurrency(final Collection<TradeItemData> items)
    {
        if (items.isEmpty())
        {
            return false;
        }
        for (TradeItemData itemData : items)
        {
            if (itemData.getUnnotedID() != ItemID.PLATINUM.id && itemData.getUnnotedID() != ItemID.COINS.id)
            {
                return false;
            }
        }
        return true;
    }

    // Returns true if all items in the passed collection have the same ID.
    public static boolean hasOnlyOneTypeOfItem(final Collection<TradeItemData> items)
    {
        if (items.isEmpty())
        {
            return false;
        }
        Iterator<TradeItemData> itr = items.iterator();
        final int id = itr.next().getUnnotedID();
        while (itr.hasNext())
        {
            if (id != itr.next().getUnnotedID())
            {
                return false;
            }
        }
        return true;
    }

    // Returns a map of item IDs to the aggregate quantity of items with that id in the passed collection
    public static HashMap<Integer, Long> getItemCounts(final Collection<TradeItemData> items)
    {
        final HashMap<Integer, Long> counts = new HashMap<>();
        for (final TradeItemData item : items)
        {
            final int id = item.getUnnotedID();
            Long count = counts.getOrDefault(id, 0L);
            counts.put(id, count + item.getQuantity());
        }
        return counts;
    }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.trade;

import lombok.Getter;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Optional;

// Contains additional data for trades of coins/platinum for a single type of items
public class SimpleTradeData
{
    public enum Type
    {
        Invalid,        // This is not a simple trade
        Bought_Item,    // A single type of item bought by the player for currency
        Sold_Item,       // A single type of item sold by the player for currency
        Gift_Giving,    // Giving single type of item or currency and receiving nothing
        Gift_Receiving; // Giving nothing and receiving single type of item or currency
    }

    @Getter
    private final Type tradeType;
    private TradeItemData item = null;
    private long quantity = 0;
    private float pricePerItem = 0f;

    public SimpleTradeData(final TradeData tradeData)
    {
        tradeType = determineTradeType(tradeData.givenItems, tradeData.receivedItems);
        switch (tradeType)
        {
            case Bought_Item:
                calculateTradeData(tradeData.receivedItems, tradeData.givenTotalValueGE);
                break;
            case Sold_Item:
                calculateTradeData(tradeData.givenItems, tradeData.receivedTotalValueGE);
                break;
            case Gift_Giving:
                calculateTradeData(tradeData.givenItems, 0);
                break;
            case Gift_Receiving:
                calculateTradeData(tradeData.receivedItems, 0);
                break;
            case Invalid: default:
                return;
        }
    }

    private void calculateTradeData(Collection<TradeItemData> itemsTraded, final long currencyExchanged)
    {
        final Optional<TradeItemData> sampleItem = itemsTraded.stream().findFirst();
        if (sampleItem.isEmpty())
        {
            return;
        }
        quantity = TradeUtils.getTotalItemQuantity(itemsTraded, sampleItem.get().getUnnotedID());
        pricePerItem = currencyExchanged / (float)quantity;
        item = new TradeItemData(sampleItem.get().getUnnotedID(), (int)Math.min(quantity, Integer.MAX_VALUE), sampleItem.get().getGEValue());
    }

    private Type determineTradeType(final ArrayList<TradeItemData> given, final ArrayList<TradeItemData> received)
    {
        if (given.isEmpty() && received.isEmpty())
        {
            return Type.Invalid;
        }
        final boolean isReceivingOneTypeOfItem = TradeUtils.hasOnlyOneTypeOfItem(received);
        if (given.isEmpty() && isReceivingOneTypeOfItem)
        {
            return Type.Gift_Receiving;
        }
        final boolean isGivingOneTypeOfItem = TradeUtils.hasOnlyOneTypeOfItem(given);
        if (received.isEmpty() && isGivingOneTypeOfItem)
        {
            return Type.Gift_Giving;
        }
        final boolean isGivingCurrency = TradeUtils.isOnlyCurrency(given);
        if (isGivingCurrency && isReceivingOneTypeOfItem)
        {
            return Type.Bought_Item;
        }
        final boolean isReceivingCurrency = TradeUtils.isOnlyCurrency(received);
        if (isReceivingCurrency && isGivingOneTypeOfItem)
        {
            return Type.Sold_Item;
        }
        return Type.Invalid;
    }

    public final boolean isValid() { return tradeType != Type.Invalid; }
    public final boolean isType(final Type type) { return tradeType == type; }
    public final long getQuantity() { return quantity; }
    public final TradeItemData getItem() { return new TradeItemData(item); }
    public final float getPricePerItem() { return pricePerItem; }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.trade;

// Contains data to describe a player that was traded with
public class TradePlayerData
{
    final private static String NULL_NAME = "__NULL__NAME__";

    public String tradeName = NULL_NAME;    // The name of the other player at the time of the trade

    public TradePlayerData() {}

    public TradePlayerData(final String Name)
    {
        this.tradeName = Name;
    }

    public boolean isValid()
    {
        return tradeName != null && !tradeName.equals(NULL_NAME);
    }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.trade;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import org.asundr.utility.CommonUtils;
import org.asundr.recovery.EventTradeHistoryProfileRestored;
import org.asundr.recovery.ConfigKey;
import org.asundr.recovery.SaveManager;
import org.asundr.utility.MathUtils;

import java.util.ArrayDeque;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

@Slf4j
public class TradeManager
{
	public final static int MAX_HISTORY_COUNT = 512;

	private static final String MESSAGE_ACCEPTED_TRADE = "Accepted trade.";
	private static final String MESSAGE_DECLINED_TRADE = "Other player declined trade.";
	private final static Pattern PATTERN_TRADE_USERNAME = Pattern.compile("^Trading [Ww]ith:\\s*(.*)$");
	private final static int CHILD_TRADE_USERNAME = 31;
	private final static int CHILD_TRADE_CONFIRMATION_USERNAME = 30;

	private static final class TradeMenuId
	{
		public static final int TRADE_MENU = 335;
		public static final int TRADE_CONFIRMATION_MENU = 334;
	}

	private static final class TradeContainerId
	{
		public static final int GIVEN = InventoryID.TRADEOFFER;
		public static final int RECEIVED = InventoryID.TRADEOFFER | 0x8000;
	}

	public enum TradeState
	{
		NOT_TRADING,
		TRADING,
		TRADE_CONFIRMATION,
		TRADE_ACCEPTED
	}

	private final static TradeManager instance = new TradeManager();

	private TradeData currentTrade = null;
	private ArrayDeque<TradeData> tradeHistory = new ArrayDeque<>();
	private TradeState tradeState = TradeState.NOT_TRADING;
	private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
	private ScheduledFuture<?> scheduledPurgeFuture = null;

	@Subscribe
	private void onWidgetLoaded(final WidgetLoaded event)
	{
		final int groupId = event.getGroupId();
		if (groupId == TradeMenuId.TRADE_MENU)
		{
			if (currentTrade == null)
			{
				currentTrade = new TradeData();
			}
			setTradeState(TradeState.TRADING);
			fetchTradedPlayerName();
		}
		else if (groupId == TradeMenuId.TRADE_CONFIRMATION_MENU)
		{
			setTradeState(TradeState.TRADE_CONFIRMATION);
		}
	}

	@Subscribe
	private void onWidgetClosed(final WidgetClosed event)
	{
		final int groupId = event.getGroupId();
		if (groupId == TradeMenuId.TRADE_MENU)
		{
			CommonUtils.getClientThread().invokeLater(() -> {
				if (tradeState != TradeState.TRADE_CONFIRMATION)
				{
					setTradeState(TradeState.NOT_TRADING);
				}
			});
		}
		else if (groupId == TradeMenuId.TRADE_CONFIRMATION_MENU)
		{
			setTradeState(TradeState.NOT_TRADING);
		}
	}

	@Subscribe
	private void onItemContainerChanged(ItemContainerChanged event)
	{
		if (currentTrade == null)
		{
			return;
		}
		final int inventoryId = event.getContainerId();
		if (inventoryId == TradeContainerId.GIVEN)
		{
			currentTrade.updateItems(true, CommonUtils.getItemContainer(inventoryId));
		}
		else if (inventoryId == TradeContainerId.RECEIVED)
		{
			currentTrade.updateItems(false, CommonUtils.getItemContainer(inventoryId));
		}
	}

	@Subscribe
	private void onChatMessage(ChatMessage chatMessage)
	{
		if (chatMessage.getType() != ChatMessageType.TRADE || currentTrade == null)
		{
			return;
		}
		switch (chatMessage.getMessage())
		{
			case MESSAGE_ACCEPTED_TRADE:
				if (CommonUtils.getConfig().ignoreEmptyTrades() && currentTrade.isEmpty())
				{
					return;
				}
				currentTrade.tradeTime = chatMessage.getTimestamp();
				addTradeRecord(currentTrade);
				setTradeState(TradeState.TRADE_ACCEPTED);
				break;
			case MESSAGE_DECLINED_TRADE:
				setTradeState(TradeState.NOT_TRADING);
				break;
			default:
				return;
		}
		currentTrade = null;
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged configChanged)
	{
		if (configChanged.getGroup().equals(SaveManager.SAVE_GROUP))
		{
			if (configChanged.getKey().equals(ConfigKey.MAX_HISTORY))
			{
				removeOverflowRecords(0);
			}
		}
	}

	@Subscribe
	private void onEventTradeHistoryProfileRestored(EventTradeHistoryProfileRestored e)
	{
		setTradeHistory(e.tradeHistory);
		updateRemoveExpiredRecordTimer();
	}

	// Should be called when plugin shuts down to cancel potentially scheduled purge timers
	public void shutdown()
	{
		scheduler.shutdown();
	}

	public static TradeManager getInstance()
	{
		return instance;
	}

	// returns a copy of the current trade history
	public static ArrayDeque<TradeData> getTradeHistory() { return new ArrayDeque<>(instance.tradeHistory); }

	// get total number of recorded trades
	public static int getTradeHistoryCount() { return instance.tradeHistory.size(); }

	// Updates what stage of a trade the player is in, and fires relevant events
	private void setTradeState(TradeState newState)
	{
		if (tradeState == newState)
		{
			return;
		}
		switch (newState)
		{
			case TRADE_ACCEPTED:
				CommonUtils.getClientThread().invokeLater(() -> setTradeState(TradeState.NOT_TRADING));
			case TRADING:
				CommonUtils.postEvent(new EventTradeBegan(currentTrade == null ? null : currentTrade.tradedPlayer));
				break;
			case NOT_TRADING:
			if (tradeState != TradeState.TRADE_ACCEPTED)
					CommonUtils.postEvent(new EventTradeDeclined(currentTrade == null ? null : currentTrade.tradedPlayer));
				break;
		}
		//log.debug(String.format("%s  --->  %s", tradeState, newState));
		tradeState = newState;
	}

	// Repeatedly tries to find the name of the traded player in the trade window, then updates the current trade data
	private void fetchTradedPlayerName()
	{
		if (tradeState != TradeState.NOT_TRADING && currentTrade != null && (currentTrade.tradedPlayer == null || !currentTrade.tradedPlayer.isValid()))
		{
			if (tradeState == TradeState.TRADING)
			{
				currentTrade.tradedPlayer =  new TradePlayerData(CommonUtils.extractPatternFromWidget(TradeMenuId.TRADE_MENU, CHILD_TRADE_USERNAME, PATTERN_TRADE_USERNAME));
			}
			else
			{
				currentTrade.tradedPlayer =  new TradePlayerData(CommonUtils.extractPatternFromWidget(TradeMenuId.TRADE_CONFIRMATION_MENU, CHILD_TRADE_CONFIRMATION_USERNAME, PATTERN_TRADE_USERNAME));
			}
			if (!currentTrade.tradedPlayer.isValid())
			{
				CommonUtils.getClientThread().invokeLater(this::fetchTradedPlayerName);
			}
		}
	}

	// Adds passed trade data as new trade to history, fetching relevant data, removing overflow trades, firing traded added events and saving the updated history
	// This is the function to call to add any new trades to the history
	private void addTradeRecord(TradeData tradeData)
	{
		removeOverflowRecords(1);
		tradeHistory.addLast(tradeData);
		CommonUtils.getClientThread().invokeLater(() -> {
			TradeUtils.fetchItemNames(tradeData.givenItems);
			TradeUtils.fetchItemNames(tradeData.receivedItems);
			TradeUtils.fetchGePrices(tradeData.givenItems);
			TradeUtils.fetchGePrices(tradeData.receivedItems);
			tradeData.calculateAggregateValues();
			CommonUtils.postEvent(new EventTradeAdded(tradeData));
			SaveManager.requestTradeHistorySave();
			if (tradeHistory.size() == 1)
			{
				updateRemoveExpiredRecordTimer();
			}
		});
	}

	// Removes the passed trade data if it is found inn the history, and fires a corresponding event
	private void removeTradeRecord(TradeData tradeData)
	{
		tradeHistory.removeIf(e -> e.tradeTime == tradeData.tradeTime);
		CommonUtils.postEvent(new EventTradeRemoved(tradeData));
		SaveManager.requestTradeHistorySave();
		if (!tradeHistory.isEmpty())
		{
			updateRemoveExpiredRecordTimer();
		}
	}

	public static void requestRemoveTradeRecord(TradeData tradeData) { instance.removeTradeRecord(tradeData); }

	// Removes all trades from the current history
	private void clearAllTradeRecords()
	{
		tradeHistory.clear();
		CommonUtils.postEvent(new EventTradeResetHistory(tradeHistory));
		SaveManager.requestTradeHistorySave();
	}

	public static void requestClearAllTradeRecords() { instance.clearAllTradeRecords();}

	// Overrides the current history
	private void setTradeHistory(ArrayDeque<TradeData> tradeHistory)
	{
		this.tradeHistory = tradeHistory;
		CommonUtils.postEvent(new EventTradeResetHistory(tradeHistory));
	}

	// Removes the oldest trades in excess of the user-specified max history count
	// extra param is useful to preemptively remove if you know you're going to add another record
	private void removeOverflowRecords(int extra)
	{
		final int maxRecords = MathUtils.clamp(CommonUtils.getConfig().maxHistoryCount(), 1, TradeManager.MAX_HISTORY_COUNT);
		int overflow = Math.min(tradeHistory.size() - maxRecords + extra, Math.max(0, tradeHistory.size() - 1));
		removeOldestRecords(overflow);
	}

	// Called whenever the timer to purge expired trades needs to be changed or cancelled
	private void updateRemoveExpiredRecordTimer()
	{
		if (scheduledPurgeFuture != null && !scheduledPurgeFuture.isCancelled() && !scheduledPurgeFuture.isDone())
		{
			//log.debug("Cancelled scheduled removal of expired trade.");
			scheduledPurgeFuture.cancel(false);
		}
		if (tradeHistory.isEmpty())
		{
			//log.debug("No trade set to expire.");
			return;
		}
		if (!isPurgingExpiredTrades())
		{
			//log.debug("Removing expired records currently disabled");
			return;
		}
		final long lifetime = CommonUtils.getRecordLifetime();
		if (lifetime <= 0L)
		{
			//log.debug("No trade set to expire.");
			return;
		}
		final long expireTime = tradeHistory.getFirst().tradeTime*1000L + lifetime;
		final long destroyDelay = Math.max(1000, expireTime - System.currentTimeMillis());
		scheduledPurgeFuture = scheduler.schedule(this::removeExpiredRecords, destroyDelay, TimeUnit.MILLISECONDS);
		//log.debug("Scheduled to remove expired trade at: " + TradeUtils.timeStampToString(expireTime/1000));
	}

	// Removes all trades from history that are older than the user-configured lifetime
	private void removeExpiredRecords()
	{
		final long lifetime = CommonUtils.getRecordLifetime();
		if (lifetime <= 0L)
		{
			return;
		}
		while (!tradeHistory.isEmpty() && tradeHistory.getFirst().isExpired())
		{
			removeOldestRecords(1);
		}
		updateRemoveExpiredRecordTimer();
	}

	// Removes the passed number of oldest trades from the history
	private void removeOldestRecords(int count)
	{
		count = Math.min(count, tradeHistory.size());
		while (count > 0)
		{
			CommonUtils.postEvent(new EventTradeRemoved(tradeHistory.getFirst()));
			tradeHistory.removeFirst();
			--count;
		}
	}

	// Returns true if expired trades are set to be auto-removed after they expire
	public static boolean isPurgingExpiredTrades()
	{
		Boolean isPurging = SaveManager.restoreFromKey(ConfigKey.SCHEDULED_PURGE);
		return isPurging != null && isPurging;
	}

	// Sets the active state of the auto-remove for expired trades, potentially starting or cancelling the timer
	public static void setPurgingExpiredTrades(boolean enabled)
	{
		SaveManager.saveWithKey(ConfigKey.SCHEDULED_PURGE, enabled);
		instance.updateRemoveExpiredRecordTimer();
	}

}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.trade;

// Event fired when a new trade is added (typically as a result of accepting a trade). Listened to by the UI.
final public class EventTradeAdded
{
    public final TradeData tradeData;

    EventTradeAdded(final TradeData tradeData)
    {
        this.tradeData = tradeData;
    }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.trade;

// Fired when a trade is declined
final public class EventTradeDeclined
{
    final public TradePlayerData tradePlayer;
    EventTradeDeclined(final TradePlayerData tradePlayer) { this.tradePlayer = tradePlayer; }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.trade;

// Event fired when a trade begins
final public class EventTradeBegan
{
    final public TradePlayerData tradePlayer;
    EventTradeBegan(final TradePlayerData tradePlayer) { this.tradePlayer = tradePlayer; }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.trade;

// Event fired when a trade is removed from the history. Listened to by the UI.
final public class EventTradeRemoved
{
    public final TradeData tradeData;
    EventTradeRemoved(final TradeData tradeData)
    {
        this.tradeData = tradeData;
    }
}

package org.asundr.utility;

import com.google.gson.Gson;
import net.runelite.client.util.QuantityFormatter;

import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Locale;

public class StringUtils
{
    private static Gson gson;

    public static void initialize(final Gson gson) { StringUtils.gson = gson; }

    // Note: from Quantity formatter
    private static final NumberFormat DECIMAL_FORMATTER = new DecimalFormat("#,###.#", DecimalFormatSymbols.getInstance(Locale.ENGLISH) );
    private static final NumberFormat PRECISE_DECIMAL_FORMATTER = new DecimalFormat("#,###.###", DecimalFormatSymbols.getInstance(Locale.ENGLISH) );
    private static final String[] QUANTITY_SUFFIXES = {"", "K", "M", "B", "T", "Q", "Qt"}; // 2^32 * 2^32 * 28 = 5.165 quintillion.

    // Returns an abbreviated string representation of the passed long in the style of QuantityFormatter but is capable of handling quantities up to Long.MAX_VALUE
    public static String quantityToRSDecimalStackLong(long quantity, boolean precise)
    {
        final String quantityStr = QuantityFormatter.formatNumber(quantity);
        if (quantityStr.length() <= 6 || (quantity < 0 && quantityStr.length() == 7))
        {
            return quantityStr;
        }
        final int power = (int) Math.log10(Math.abs(quantity));
        final NumberFormat numberFormat = precise && power >= 6 ? PRECISE_DECIMAL_FORMATTER : DECIMAL_FORMATTER;
        return numberFormat.format(quantity / (Math.pow(10, power - power%3))) + QUANTITY_SUFFIXES[power / 3];
    }

    public static Gson getGsonBuilder()
    {
        return gson.newBuilder().create();
    }

    // Converts the passed object to a json string
    public static <T> String stringify(T object)
    {
        return gson.newBuilder().create().toJson(object);
    }

    // Returns true if the passed String is a Long type
    public static boolean isStringLong(final String str) {
        try
        {
            Long.parseLong(str);
        }
        catch (NumberFormatException e)
        {
            return false;
        }
        return true;
    }

    // Maps characters of to a list of all indexes where that character is the first letter of a word
    // note: converts all to lower case
    public static HashMap<Character, ArrayList<Integer>> getIndexesOfFirstLetterOfWord(final String str)
    {
        HashMap<Character, ArrayList<Integer>> indexMap = new HashMap<>();
        boolean addNextChar = true;
        final char[] characters = str.trim().toLowerCase().toCharArray();
        for (int i = 0; i < characters.length; ++i)
        {
            final char c = characters[i];
            if (Character.isWhitespace(c))
            {
                addNextChar = true;
            }
            else if (addNextChar)
            {
                indexMap.putIfAbsent(c, new ArrayList<>());
                indexMap.get(c).add(i);
                addNextChar = false;
            }
        }
        return indexMap;
    }

    // Removes all html tags from widget text
    public static String sanitizeWidgetText(final String s)
    {
        return s.replaceAll("<[^>]*>", "").trim();
    }

    // Copies the passed String to the user's clipboard
    public static void copyToClipboard(final String content)
    {
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(content), null);
    }

    public static String colorToHexString(final Color color, final boolean includeHash)
    {
        return (includeHash?"#":"") + String.format("%02x%02x%02x", color.getRed(), color.getGreen(), color.getBlue());
    }

    public static String capitalize(final String str)
    {
        return org.apache.commons.lang3.StringUtils.capitalize(str.toLowerCase());
    }

    public static String formatEnum(Enum enumValue, boolean capitalized)
    {
        return (capitalized ? capitalize(enumValue.toString()) : enumValue.toString().toLowerCase()).replace("_"," ");
    }

}

package org.asundr.utility;

public final class MathUtils
{
    // Returns the value limited to be no lower than  min or larger than max
    public static <T extends Comparable<T>> T clamp(T val, T min, T max)
    {
        return val.compareTo(min) < 0 ? min : val.compareTo(max) > 0 ? max : val;
    }

    // Returns true if the passed value is inclusively within the range of [min, max]
    public static <T extends Comparable<T>> boolean inRange(T val, T min, T max)
    {
        return val.compareTo(min) >= 0 && val.compareTo(max) <= 0;
    }
}

/*
 * Copyright (c) 2025, Arun <trade-tracker-plugin.acwel@dralias.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package org.asundr.utility;

import com.google.common.base.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import org.asundr.TradeTrackerConfig;
import org.asundr.TradeTrackerPlugin;

import javax.annotation.Nonnull;
import javax.imageio.ImageIO;
import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.net.URI;
import java.util.*;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

// A static function library used for common functionality
@Slf4j
public class CommonUtils
{
    private static TradeTrackerConfig config;
    private static Client client;
    private static ClientThread clientThread;
    private static ChatboxPanelManager chatboxPanelManager;
    private static EventBus eventBus;
    private static OverlayManager overlayManager;

    public static TradeTrackerConfig getConfig() { return config; }
    public static ClientThread getClientThread() { return clientThread; }
    public static Client getClient() { return client; }
    public static OverlayManager getOverlayManager() { return overlayManager;}


    // Prepares the utility class with the various query class instances it needs to function
    public static void initialize(TradeTrackerConfig config, Client client, ClientThread clientThread, TradeTrackerPlugin plugin, ChatboxPanelManager chatboxPanelManager, EventBus eventBus, OverlayManager overlayManager)
    {
        CommonUtils.config = config;
        CommonUtils.client = client;
        CommonUtils.clientThread = clientThread;
        CommonUtils.chatboxPanelManager = chatboxPanelManager;
        CommonUtils.eventBus = eventBus;
        CommonUtils.overlayManager = overlayManager;
    }

    // Forwards the passed event to the event bus
    public static void postEvent(@Nonnull Object event)
    {
        eventBus.post(event);
    }
    public static void registerForEvents(@Nonnull Object object) { eventBus.register(object);}
    public static void unregisterForEvents(@Nonnull Object object) { eventBus.unregister(object);}

    public static final String WIKI_URL_PREFIX = "https://oldschool.runescape.wiki/w/";

    // Given the name of an item, opens the corresponding wiki page
    public static void openItemWiki(String itemName)
    {
        String name = itemName.replace(" (Members)", "").trim().replaceAll(" ", "_");
        try
        {
            Desktop.getDesktop().browse(new URI(WIKI_URL_PREFIX + name));
        }
        catch (Exception e)
        {
            log.error("Invalid item wiki url: " + WIKI_URL_PREFIX + name);
        }
    }

    // Prompts the player to enter text using the in-game message box and sends the input to the response
    public static void promptTextEntry(final String prompt, final String initialText, final Consumer<String> response)
    {
        chatboxPanelManager.openTextInput(prompt)
            .value(Strings.nullToEmpty(initialText))
            .onDone((content) ->
            {
                if (content == null)
                {
                    return;
                }
                content = Text.removeTags(content).trim();
                response.accept(content);
            }).build();
    }

    // Returns an Icon given a filepath to an image, or null if no such image exists.
    // Image will be resized to the specified dimensions using the passed hint as the algorithm.
    public static ImageIcon getIconFromName(final String filename, int width, int height, final int hints)
    {
        BufferedImage iconImg = getImageFromName(filename);
        if (iconImg == null)
        {
            return null;
        }
        if (width == -1 && height == -1)
        {
            return new ImageIcon(iconImg);
        }
        if (width == -1)
        {
            width = height;
        }
        if (height == -1)
        {
            height = width;
        }
        return new ImageIcon(iconImg.getScaledInstance(width, height, hints));
    }

    // Returns an Icon given a filepath to an image, or null if no such image exists
    public static BufferedImage getImageFromName(final String filename)
    {
        return ImageUtil.loadImageResource(TradeTrackerPlugin.class, "/" + filename);
    }

    // Returns all enums that describe the current world
    public static EnumSet<WorldType> getWorldType()
    {
        return client.getWorldType();
    }

    // Returns a string matching the passed pattern if that pattern finds a match in the widget represented by the group and child IDs
    public static String extractPatternFromWidget(int groupId, int childId, final Pattern p)
    {
        final Widget tradingWithWidget = client.getWidget(groupId, childId);
        if (tradingWithWidget == null)
        {
            return null;
        }
        final String widgetText = StringUtils.sanitizeWidgetText(tradingWithWidget.getText());
        final Matcher m = p.matcher(widgetText);
        if (m.find())
        {
            return m.group(1);
        }
        return null;
    }

    // Returns the items container with the passed id from the client
    public static ItemContainer getItemContainer(final int containerId)
    {
        return client.getItemContainer(containerId);
    }

    // Returns the lifetime in milliseconds of a trade before it is auto-removed
    // If plugin settings for auto-remove are invalid, return -1
    public static long getRecordLifetime()
    {
        if (!isValidPurgeConfig())
        {
            return -1;
        }
        return config.getPurgeHistoryMagnitude() * config.getPurgeHistoryType().ms;
    }

    // Returns true if the plugin config settings are valid values to schedule auto-removing
    public static boolean isValidPurgeConfig()
    {
        return config.getPurgeHistoryType() != TradeTrackerConfig.PurgeHistoryType.NEVER && config.getPurgeHistoryMagnitude() > 0;
    }
}

package org.asundr.utility;

import java.time.*;
import java.time.format.DateTimeFormatter;

final public class TimeUtils
{
    public final static long SECONDS_IN_DAY = 3600*24;
    public final static long MILLISECONDS_IN_DAY = SECONDS_IN_DAY * 1000L;

    // Returns a string representation of the timestamp using the passed pattern
    // https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns
    public static String timestampToString(final long timestamp, final String pattern)
    {
        final Instant instant = Instant.ofEpochSecond(timestamp);
        final ZoneId zoneId = ZoneId.systemDefault();
        final ZonedDateTime dateTime = ZonedDateTime.ofInstant(instant, zoneId);
        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
        return dateTime.format(formatter);
    }

    // Returns a detailed representation of the time without the time zone
    public static String timestampToString(final long timestamp)
    {
        return timestampToString(timestamp, "yyyy-MM-dd H:mm:ss");
    }

    // Returns a string for the time depending on the age of the timestamp.
    // Timestamps from the current day show the time, and Yesterday for the previous day.
    // Timestamps within the year will show the month and date and anything older shows dd/MM/yy
    public static String timestampToStringTime(final long timestamp)
    {
        if (isInCurrentDay(timestamp * 1000))
        {
            return timestampToString(timestamp, CommonUtils.getConfig().use24HourTime() ? "H:mm" : "h:mm a");
        }
        else if (isInCurrentDay((timestamp + SECONDS_IN_DAY) * 1000))
        {
            return "Yesterday";
        }
        else if (isInCurrentYear(timestamp*1000))
        {
            return timestampToString(timestamp, "LLL d");
        }
        else
        {
            return timestampToString(timestamp, "dd/MM/yy");
        }
    }

    // Returns true if the passed timestamp in milliseconds is during the current year in the user's timezone
    public static boolean isInCurrentYear(final long timestamp)
    {
        LocalDate date = Instant.ofEpochMilli(timestamp)
                .atZone(ZoneId.systemDefault())
                .toLocalDate();
        final int currentYear = LocalDate.now().getYear();
        return date.getYear() == currentYear;
    }

    // Returns true if the passed timestamp in milliseconds is during the current day in the user's timezone
    public static boolean isInCurrentDay(final long timestamp)
    {
        final LocalDate date = Instant.ofEpochMilli(timestamp)
                .atZone(ZoneId.systemDefault())
                .toLocalDate();
        final int currentDay = LocalDate.now().getDayOfYear();
        final int currentYear = LocalDate.now().getYear();
        return date.getYear() == currentYear && date.getDayOfYear() == currentDay;
    }

    // Returns the number of milliseconds before midnight in the user's time zone
    public static long getTimeUntilMidnight()
    {
        final LocalDateTime now = LocalDateTime.now();
        final LocalDateTime midnight = now.toLocalDate().plusDays(1).atStartOfDay();
        return Duration.between(now, midnight).toMillis();
    }

}

package org.asundr;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TradeTrackerPlugin.class);
		RuneLite.main(args);
	}
}
