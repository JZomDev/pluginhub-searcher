package com.localconsciousness;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Range;

@ConfigGroup("localconsciousness")
public interface LocalConsciousnessConfig extends Config
{
	@ConfigItem(
		keyName = "showPanelButton",
		name = "Show Panel Button",
		description = "Whether the panel button is shown or not",
		position = 1
	)
	default boolean showPanelButton () { return true; }
	@ConfigItem(
		keyName = "item",
		name = "Overlay item",
		description = "The item to be displayed",
		hidden = true
	)
	default int item() {
		// What up it's me, Monkfish- from RuneScape!
		return 7946;
	}

	@ConfigItem(
		keyName = "size",
		name = "Size",
		description = "The size of the item",
		hidden = true
	)
	default int size() {
		return 60;
	}

	@ConfigItem(
		keyName = "speed",
		name = "Speed",
		description = "The speed of the item",
		hidden = true
	)
	default int speed() {
		return 25;
	}

	@Range(
			max = 60
	)
	@ConfigItem(
		keyName = "opacity",
		name = "Opacity",
		description = "The opacity of the item",
		hidden = true
	)
	default int opacity() {
		return 70;
	}
}

package com.localconsciousness;

import com.google.inject.Provides;
import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;
import java.util.*;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.CanvasSizeChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemClient;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.chatbox.ChatboxItemSearch;
import net.runelite.client.plugins.Plugin;
import net.runelite.api.events.ClientTick;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;


@Slf4j
@PluginDescriptor(
	name = "Local Consciousness", description = "Make an item bounce around your screen!", enabledByDefault = true
)
public class LocalConsciousnessPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private LocalConsciousnessConfig config;

	@Inject
	private LocalConsciousnessOverlay overlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ChatboxItemSearch itemSearch;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ConfigManager configManager;
	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	@Getter
	private ClientThread clientThread;
	@Inject
	private ItemClient itemClient;
	private NavigationButton navButton;

	@Getter
	private BufferedImage currentItem;
	private LocalConsciousnessPanel panel;
	private int size;
	@Getter
	private int width;
	@Getter
	private int height;
	@Getter
	private double x;
	@Getter
	private double y;
	@Getter
	private int currentItemID;
	private double angle;
	private int canvasHeight;
	private int canvasWidth;
	private Random rand;
	private boolean checkedForOversize = false;
    private boolean queuedToolbarUpdate = false;
	private ArrayList<Integer> validIdList = new ArrayList<Integer>();

	@Override
	protected void startUp() throws Exception
	{
		rand = new Random();
		resetMovement();

		currentItem = itemManager.getImage(config.item());
		currentItemID = config.item();
		clientThread.invokeLater(this::updateItem);
		overlayManager.add(overlay);
		// Used in place of a check here for needing to add panel button or not
        updateShowPanelButton();
		if(validIdList.isEmpty()) {
			clientThread.invoke(this::computeValidItemIdList);
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
		clientToolbar.removeNavigation(navButton);
	}

	private void computeValidItemIdList() {
        // Use set to prevent dupes from canonicalization
        Set<Integer> inventoryModelIds = new HashSet<Integer>();
		for (int i = 0; i < client.getItemCount(); i++) {
			ItemComposition itemComposition = itemManager.getItemComposition(itemManager.canonicalize(i));
			if(itemComposition.getName().isEmpty()) continue;
			if(itemComposition.getName().equalsIgnoreCase("null")) continue;
            if(inventoryModelIds.contains(itemComposition.getInventoryModel())) continue;
            // Don't just use i to avoid adding noted items
            validIdList.add(itemComposition.getId());
            // Prevent items with many IDs and duplicate models from spamming the list, like clues and caskets
            inventoryModelIds.add(itemComposition.getInventoryModel());
		}
	}
	private void saveValidItemIdList() {

	}
	private void loadValidItemIdList() {

	}
	private void resetMovement()
	{
		float wiggle = (rand.nextFloat() * 80.0f) + 5.0f;
		angle = (rand.nextInt(4) * 90 ) + wiggle;
		canvasWidth = client.getCanvasWidth();
		canvasHeight = client.getCanvasHeight();
		int sizeOffsetX = width / 2;
		int sizeOffsetY = height / 2;
		x = (double) canvasWidth / 2;
		x -= sizeOffsetX;
		y = (double) canvasHeight / 2;
		y -= sizeOffsetY;
	}

	private BufferedImage cropSpriteByTransparency(BufferedImage sprite)
	{
		// Method from https://stackoverflow.com/a/36938923
		WritableRaster raster = sprite.getAlphaRaster();
		int width = raster.getWidth();
		int height = raster.getHeight();
		int left = 0;
		int top = 0;
		int right = width - 1;
		int bottom = height - 1;
		int minRight = width - 1;
		int minBottom = height - 1;

		top:
		for (;top <= bottom; top++){
			for (int x = 0; x < width; x++){
				if (raster.getSample(x, top, 0) != 0){
					minRight = x;
					minBottom = top;
					break top;
				}
			}
		}

		left:
		for (;left < minRight; left++){
			for (int y = height - 1; y > top; y--){
				if (raster.getSample(left, y, 0) != 0){
					minBottom = y;
					break left;
				}
			}
		}

		bottom:
		for (;bottom > minBottom; bottom--){
			for (int x = width - 1; x >= left; x--){
				if (raster.getSample(x, bottom, 0) != 0){
					minRight = x;
					break bottom;
				}
			}
		}

		right:
		for (;right > minRight; right--){
			for (int y = bottom; y >= top; y--){
				if (raster.getSample(right, y, 0) != 0){
					break right;
				}
			}
		}

		return sprite.getSubimage(left, top, right - left + 1, bottom - top + 1);
	}

	@Subscribe
	protected void onCanvasSizeChanged(CanvasSizeChanged canvasSizeChanged) {
        resetMovement();
    }

	@Subscribe
	protected void onClientTick(ClientTick tick) {

        if(queuedToolbarUpdate) {
            if(!panel.isOpened()) {
                updateShowPanelButton();
            }
        }

        double speed = config.speed() / 10.0d;

		if(x > canvasWidth) x = canvasWidth;
		if(x < 0) x = 0;
		if(x >= canvasWidth - width || x <= 0) {
			angle = 180 - angle;
		}

		if(y > canvasHeight) y = canvasHeight;
		if(y < 0) y = 0;
		if(y >= canvasHeight - height || y <= 0) {
			angle = 360 - angle;
		}

		angle %= 360;

		double cosComponent = Math.cos(Math.toRadians(angle));
		double sinComponent = Math.sin(Math.toRadians(angle));

		double nextX = cosComponent * speed;
		double nextY = sinComponent * speed;

		x += nextX;
		y += nextY;

		if(!checkedForOversize) {
			if(width >= canvasWidth
				|| height >= canvasHeight) {
				client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
						"Your local consciousness sprite may be too big! Consider reducing its size.", "");
			}
			checkedForOversize = true;
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if(!Objects.equals(event.getGroup(), "localconsciousness")) return;
		switch(event.getKey()) {
			case "item":
				clientThread.invokeLater(this::updateItem);
				break;
			case "size":
				updateSize();
				resetMovement();
				break;
			case "speed":
				break;
			case "opacity":
				break;
			case "showPanelButton":
                queuedToolbarUpdate = true;
				break;
			default: break;
		}
	}

	private boolean updateItem() {
		if(client.getGameState() != GameState.LOGGED_IN) {
            return false;
		}
		currentItemID = config.item();

		clientThread.invokeLater(() -> {
			BufferedImage item = itemManager.getImage(currentItemID);
			try {
				currentItem = cropSpriteByTransparency(item);
			} catch (Exception e) {
				// This is just here to catch weird empty items, such as 798, 12897, 12898, etc.
			}
            queuedToolbarUpdate = true;
			if(config.showPanelButton()) updatePanelItem();
			// Must be run after updating item image
			updateSize();
		});
		resetMovement();

		checkedForOversize = false;
		return true;
	}
	private void updateSize() {
		size = config.size();
		float sizeMult = size / 100.0f;
		width = (int)(currentItem.getWidth() * sizeMult);
		height = (int)(currentItem.getHeight() * sizeMult);
	}
	private void updateSpeed() {
	}
	private void updateOpacity() {
	}
	private void updateShowPanelButton() {
		clientThread.invoke(() -> {
			try {
				clientToolbar.removeNavigation(navButton);
			} catch(Exception ignored) {}

			if(config.showPanelButton()) {
				navButton = buildNavigationButton();
				clientToolbar.addNavigation(navButton);

				updatePanelItem();
			}
            queuedToolbarUpdate = false;
		});
	}
	// Must only be run on clientThread
	private void updatePanelItem()
	{
		String name = itemManager.getItemComposition(currentItemID).getName();
		panel.updateItemName(name);
        panel.updateItemIcon(currentItem);
	}
	public void updateFromSearch()
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			JOptionPane.showMessageDialog(panel,
					"You must be logged in to search.",
					"Cannot Search for Item",
					JOptionPane.ERROR_MESSAGE);
			return;
		}

		itemSearch
				.tooltipText("Set item to")
				.onItemSelected((itemId) -> {
					clientThread.invokeLater(() ->
					{
						int finalId = itemManager.canonicalize(itemId);
						configManager.setConfiguration("localconsciousness", "item", finalId);
					});
				})
				.build();
	}

	public void randomizeItem() {
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			JOptionPane.showMessageDialog(panel,
					"You must be logged in to randomize.",
					"Cannot Randomize Item",
					JOptionPane.ERROR_MESSAGE);
			return;
		}

		int randomId = validIdList.get(rand.nextInt(validIdList.size()));

        configManager.setConfiguration("localconsciousness", "item", randomId);
	}

	@Provides
	LocalConsciousnessConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(LocalConsciousnessConfig.class);
	}

	private NavigationButton buildNavigationButton() {
		panel = new LocalConsciousnessPanel(client, config, this, configManager);
		navButton = NavigationButton.builder()
				.tooltip("Local Consciousness")
				.priority(6)
				.panel(panel)
				.icon(currentItem)
				.build();
		return navButton;
	}
}
package com.localconsciousness;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.image.BufferedImage;

@Slf4j
public class LocalConsciousnessPanel extends PluginPanel {
    protected final LocalConsciousnessPlugin plugin;
    protected final LocalConsciousnessConfig config;
    protected final ConfigManager configManager;

    @Getter
    private boolean opened = false;

    private JPanel fullPanel;
    private JPanel titlePanel;
    private JPanel currentItemPanel;
    private JPanel buttonsPanel;
    private JPanel optionsPanel;

    JLabel pluginTitleLabel;

    JLabel currentItemLabel;
    JLabel currentItemIcon;
    JLabel currentItemName;

    JButton searchButton;
    JButton randomButton;

    JLabel scaleLabel;
    JSpinner scaleSpinner;
    SpinnerNumberModel scaleSpinnerModel;
    JLabel speedLabel;
    JSpinner speedSpinner;
    SpinnerNumberModel speedSpinnerModel;
    JLabel opacityLabel;
    JSpinner opacitySpinner;
    SpinnerNumberModel opacitySpinnerModel;

    Color borderColor = new Color(220, 138, 0);


    public LocalConsciousnessPanel(Client client, LocalConsciousnessConfig config, final LocalConsciousnessPlugin plugin, ConfigManager configManager) {
        this.plugin = plugin;
        this.config = config;
        this.configManager = configManager;

        this.fullPanel = new JPanel();
        this.titlePanel = new JPanel();
        this.currentItemPanel = new JPanel();
        this.buttonsPanel = new JPanel();
        this.optionsPanel = new JPanel();

        this.fullPanel = new JPanel();
        this.titlePanel = new JPanel();
        this.currentItemPanel = new JPanel();
        this.buttonsPanel = new JPanel();
        this.optionsPanel = new JPanel();
        initJLabels();
        /*JButton reloadButton = new JButton("reload");
        reloadButton.setFocusable(false);
        reloadButton.addActionListener(e -> {
            reloadButton.setFocusable(false);
            render();
            reloadButton.setFocusable(true);
        });*/

        this.fullPanel.add(buildTitlePanel());
        this.fullPanel.add(buildCurrentItemPanel());
        this.fullPanel.add(buildButtonsPanel());
        this.fullPanel.add(buildOptionsPanel());

        //this.fullPanel.add(reloadButton);

        this.setLayout(new BorderLayout());
        this.setBorder(new EmptyBorder(10, 10, 10, 10));
        this.fullPanel.setLayout(new BoxLayout(this.fullPanel, BoxLayout.Y_AXIS));
        this.add(fullPanel, "North");
    }

    @Override
    public void onActivate() {
        opened = true;
    }

    @Override
    public void onDeactivate() {
        opened = false;
    }

    void render() {
        removeAll();
    }

    private JPanel buildTitlePanel() {
        titlePanel.setLayout(new BorderLayout());
        titlePanel.setBorder(new CompoundBorder(new MatteBorder(0, 0, 1, 0, borderColor),
                                                new EmptyBorder(5, 0, 10, 0)));
        pluginTitleLabel.setHorizontalAlignment(SwingConstants.CENTER);
        titlePanel.add(pluginTitleLabel);
        return titlePanel;
    }

    private JPanel buildCurrentItemPanel() {
        currentItemPanel.setLayout(new BoxLayout(this.currentItemPanel, BoxLayout.Y_AXIS));
        currentItemPanel.setBorder(new CompoundBorder(new MatteBorder(0, 0, 1, 0, borderColor),
                                                      new EmptyBorder(5, 0, 10, 0)));

        currentItemLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        currentItemLabel.setHorizontalAlignment(SwingConstants.CENTER);
        currentItemPanel.add(currentItemLabel);

        currentItemIcon.setMinimumSize(new Dimension(64, 64));
        currentItemIcon.setPreferredSize(new Dimension(64, 64));
        currentItemIcon.setMaximumSize(new Dimension(64, 64));
        currentItemIcon.setAlignmentX(Component.CENTER_ALIGNMENT);
        currentItemIcon.setHorizontalAlignment(SwingConstants.CENTER);
        currentItemIcon.setBorder(new MatteBorder(1, 1, 1, 1, Color.gray));
        currentItemPanel.add(currentItemIcon);

        currentItemName.setAlignmentX(Component.CENTER_ALIGNMENT);
        currentItemName.setHorizontalAlignment(SwingConstants.CENTER);
        currentItemName.setMinimumSize(new Dimension(192, 1));
        currentItemName.setBorder(new EmptyBorder(5, 0, 0, 0));
        currentItemPanel.add(currentItemName);

        return currentItemPanel;
    }

    private JPanel buildButtonsPanel() {
        buttonsPanel.setLayout(new GridLayout(2, 1, 0, 5));
        buttonsPanel.setBorder(new CompoundBorder(new MatteBorder(0, 0, 1, 0, borderColor),
                                                  new EmptyBorder(10, 0, 10, 0)));

        searchButton.setFocusable(false);
        searchButton.addActionListener(e -> {
            searchButton.setFocusable(false);
            plugin.updateFromSearch();
        });

        randomButton.setFocusable(false);
        randomButton.addActionListener(e -> {
            randomButton.setFocusable(false);
            plugin.randomizeItem();
        });

        buttonsPanel.add(searchButton);
        buttonsPanel.add(randomButton);

        return buttonsPanel;
    }

    private JPanel buildOptionsPanel() {
        this.optionsPanel.setLayout(new GridLayout(3, 2, 2, 10));
        optionsPanel.setBorder(new EmptyBorder(10, 0, 10, 0));

        this.scaleSpinnerModel = new SpinnerNumberModel(config.size(), 1, 50000, 1);
        this.scaleSpinner = new JSpinner(scaleSpinnerModel);
        scaleSpinner.addChangeListener(e -> configManager.setConfiguration("localconsciousness", "size", (int) scaleSpinner.getValue()));

        this.speedSpinnerModel = new SpinnerNumberModel(config.speed(), 1, 5000, 1);
        this.speedSpinner = new JSpinner(speedSpinnerModel);
        speedSpinner.addChangeListener(e -> configManager.setConfiguration("localconsciousness", "speed", (int) speedSpinner.getValue()));

        this.opacitySpinnerModel = new SpinnerNumberModel(config.opacity(), 0, 100, 5);
        this.opacitySpinner = new JSpinner(opacitySpinnerModel);
        opacitySpinner.addChangeListener(e -> configManager.setConfiguration("localconsciousness", "opacity", (int) opacitySpinner.getValue()));

        this.optionsPanel.add(this.scaleLabel);
        this.optionsPanel.add(this.scaleSpinner);

        this.optionsPanel.add(this.speedLabel);
        this.optionsPanel.add(this.speedSpinner);

        this.optionsPanel.add(this.opacityLabel);
        this.optionsPanel.add(this.opacitySpinner);

        return optionsPanel;
    }

    private void initJLabels() {
        this.pluginTitleLabel = new JLabel("<html><b><h1 align='center'>Local Consciousness</h1></b></html>");
        this.scaleLabel = new JLabel("Icon Scale");
        this.speedLabel = new JLabel("Icon Speed");
        this.opacityLabel = new JLabel("Icon Opacity");
        this.currentItemLabel = new JLabel("<html><b><h2>Current Item</h2></b></html>");
        this.currentItemIcon = new JLabel();
        this.currentItemName = new JLabel("Not Yet Loaded");

        this.searchButton = new JButton("Search For Item");
        this.randomButton = new JButton("Randomize Item");
    }

    public void updateItemIcon(BufferedImage image) {
        currentItemIcon.setIcon(new ImageIcon(image));
    }

    public void updateItemName(String name) {
        if(name.length() > 30) {
            name = name.substring(0, 31);
            name += "...";
        }
        this.currentItemName.setText(name);
    }

}

package com.localconsciousness;

import net.runelite.api.*;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;
import java.awt.geom.AffineTransform;

public class LocalConsciousnessOverlay extends Overlay
{
	private final LocalConsciousnessPlugin plugin;
	private final LocalConsciousnessConfig config;



	@Inject
	private LocalConsciousnessOverlay(Client client, LocalConsciousnessPlugin plugin, LocalConsciousnessConfig config)
	{
		super(plugin);
		this.plugin = plugin;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
		setPriority(PRIORITY_MED);
	}

	@Override
	public Dimension render(Graphics2D graphics) {
		graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, config.opacity() / 100.0f));
		// https://stackoverflow.com/a/27166209
		AffineTransform originalTransform = graphics.getTransform();

		AffineTransform t = new AffineTransform();
		t.translate(plugin.getX(), plugin.getY());
		double scaleMult = (double) plugin.getHeight() / plugin.getCurrentItem().getHeight();
		t.scale(scaleMult, scaleMult);
		graphics.drawImage(plugin.getCurrentItem(), t, null);

		graphics.setTransform(originalTransform);
		return null;
	}
}

package com.localconsciousness;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LocalConsciousnessPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LocalConsciousnessPlugin.class);
		RuneLite.main(args);
	}
}
