package com.nexsplittracker;

import javax.swing.table.JTableHeader;
import javax.swing.table.TableColumnModel;
import java.awt.event.MouseEvent;

class ToolTipHeader extends JTableHeader
{
    public ToolTipHeader(TableColumnModel model)
    {
        super(model);
    }

    @Override
    public String getToolTipText(MouseEvent e)
    {
        int index = columnAtPoint(e.getPoint());
        int realIndex = getTable().convertColumnIndexToModel(index);

        // Get the column name to determine what tooltip to show
        String columnName = getTable().getColumnName(realIndex);

        switch (realIndex)
        {
            case 0: return "Item Name";
            case 1: return "Split amount in millions";
            case 2:
                if ("Kill Count".equals(columnName)) {
                    return "Kill count when this drop occurred";
                } else {
                    return "Date the drop was added to the tracker";
                }
            case 3: return "Team Size";
            case 4: return "<html>R: Received<br>S: Seen</html>";
            default: return "";
        }
    }
}

package com.nexsplittracker;

import javax.swing.*;
import java.awt.*;

public class CustomTextField extends JTextField
{
    private String suffix = "";
    private Color suffixColor = new Color(150, 150, 150); // Light gray

    public CustomTextField(int columns) {super(columns);}

    @Override
    protected void paintComponent(Graphics g)
    {
        super.paintComponent(g);

        int suffixWidth = g.getFontMetrics().stringWidth(suffix);
        int textX = getWidth() - suffixWidth - 5; // 5 pixels padding from the right
        int textY = getBaseline(getWidth(), getHeight());

        g.setColor(suffixColor);
        g.drawString(suffix, textX, textY);
    }

    public void setSuffix(String suffix)
    {this.suffix = suffix;}

}

package com.nexsplittracker;

public class ItemDataV2
{
    private String itemName;
    private double splitAmount;
    private String date;
    private int teamSize;
    private boolean isReceived;
    private Integer killCount; // null for legacy data

    public ItemDataV2(String itemName, double splitAmount, String date, int teamSize, boolean isReceived)
    {
        this.itemName = itemName;
        this.splitAmount = splitAmount;
        this.date = date;
        this.teamSize = teamSize;
        this.isReceived = isReceived;
        this.killCount = null; // Default to null for backward compatibility
    }

    public ItemDataV2(String itemName, double splitAmount, String date, int teamSize, boolean isReceived, Integer killCount)
    {
        this.itemName = itemName;
        this.splitAmount = splitAmount;
        this.date = date;
        this.teamSize = teamSize;
        this.isReceived = isReceived;
        this.killCount = killCount;
    }

    // Constructor for migration from ItemData
    public ItemDataV2(ItemData oldData)
    {
        this.itemName = oldData.getItemName();
        this.splitAmount = oldData.getSplitAmount();
        this.date = oldData.getDate();
        this.teamSize = oldData.getTeamSize();
        this.isReceived = oldData.isReceived();
        this.killCount = null; // Legacy data won't have kill count
    }

    public String getItemName()
    {
        return itemName;
    }

    public void setItemName(String itemName)
    {
        this.itemName = itemName;
    }

    public double getSplitAmount()
    {
        return splitAmount;
    }

    public void setSplitAmount(double splitAmount)
    {
        this.splitAmount = splitAmount;
    }

    public String getDate()
    {
        return date;
    }

    public void setDate(String date)
    {
        this.date = date;
    }

    public int getTeamSize()
    {
        return teamSize;
    }

    public void setTeamSize(int teamSize)
    {
        this.teamSize = teamSize;
    }

    public boolean isReceived()
    {
        return isReceived;
    }

    public void setReceived(boolean received)
    {
        isReceived = received;
    }

    public Integer getKillCount()
    {
        return killCount;
    }

    public void setKillCount(Integer killCount)
    {
        this.killCount = killCount;
    }

    public boolean hasKillCount()
    {
        return killCount != null;
    }

    @Override
    public String toString()
    {
        return "ItemDataV2{" +
                "itemName='" + itemName + '\'' +
                ", splitAmount=" + splitAmount +
                ", date='" + date + '\'' +
                ", teamSize=" + teamSize +
                ", isReceived=" + isReceived +
                ", killCount=" + killCount +
                '}';
    }
}
package com.nexsplittracker;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;

public class EditEntryDialog extends JDialog
{
    private final ItemDataV2 originalItem;
    private final NexSplitTrackerConfig config;
    private final ItemDataV2 editedItem;

    private JComboBox<String> itemComboBox;
    private CustomTextField splitTextField;
    private JTextField teamSizeField;
    private JTextField dateField;
    private JTextField killCountField;
    private JCheckBox receivedCheckBox;

    private boolean confirmed = false;

    public EditEntryDialog(Frame parent, ItemDataV2 item, NexSplitTrackerConfig config)
    {
        super(parent, "Edit Drop Entry", true);
        this.originalItem = item;
        this.config = config;
        this.editedItem = new ItemDataV2(
            item.getItemName(),
            item.getSplitAmount(),
            item.getDate(),
            item.getTeamSize(),
            item.isReceived(),
            item.getKillCount()
        );

        initializeDialog();
        populateFields();
    }

    private void initializeDialog()
    {
        setDefaultCloseOperation(DISPOSE_ON_CLOSE);
        setLayout(new BorderLayout());

        // Main panel
        JPanel mainPanel = new JPanel(new GridBagLayout());
        mainPanel.setBorder(new EmptyBorder(15, 15, 15, 15));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5);
        gbc.anchor = GridBagConstraints.WEST;

        // Item selection
        gbc.gridx = 0; gbc.gridy = 0;
        mainPanel.add(new JLabel("Item:"), gbc);
        gbc.gridx = 1;
        itemComboBox = new JComboBox<>(NexUniques.names());
        itemComboBox.setPreferredSize(new Dimension(200, 25));
        mainPanel.add(itemComboBox, gbc);

        // Split amount
        gbc.gridx = 0; gbc.gridy = 1;
        mainPanel.add(new JLabel("Split Amount (M):"), gbc);
        gbc.gridx = 1;
        splitTextField = new CustomTextField(15);
        splitTextField.setSuffix("M");
        mainPanel.add(splitTextField, gbc);

        // Team size
        gbc.gridx = 0; gbc.gridy = 2;
        mainPanel.add(new JLabel("Team Size:"), gbc);
        gbc.gridx = 1;
        teamSizeField = new JTextField(15);
        mainPanel.add(teamSizeField, gbc);

        // Date
        gbc.gridx = 0; gbc.gridy = 3;
        mainPanel.add(new JLabel("Date (MM/dd/yy):"), gbc);
        gbc.gridx = 1;
        dateField = new JTextField(15);
        dateField.setToolTipText("Format: MM/dd/yy (e.g., 12/25/23)");
        mainPanel.add(dateField, gbc);

        // Kill count (if enabled)
        if (config.enableKillCountEntry())
        {
            gbc.gridx = 0; gbc.gridy = 4;
            mainPanel.add(new JLabel("Kill Count:"), gbc);
            gbc.gridx = 1;
            killCountField = new JTextField(15);
            killCountField.setToolTipText("Leave empty if unknown");
            mainPanel.add(killCountField, gbc);
        }

        // Received checkbox
        gbc.gridx = 0; gbc.gridy = config.enableKillCountEntry() ? 5 : 4;
        mainPanel.add(new JLabel("Received by Me:"), gbc);
        gbc.gridx = 1;
        receivedCheckBox = new JCheckBox();
        mainPanel.add(receivedCheckBox, gbc);

        add(mainPanel, BorderLayout.CENTER);

        // Button panel
        JPanel buttonPanel = new JPanel(new FlowLayout());
        JButton saveButton = new JButton("Save");
        JButton cancelButton = new JButton("Cancel");

        saveButton.addActionListener(new SaveActionListener());
        cancelButton.addActionListener(e -> dispose());

        buttonPanel.add(saveButton);
        buttonPanel.add(cancelButton);
        add(buttonPanel, BorderLayout.SOUTH);

        // Dialog properties
        pack();
        setLocationRelativeTo(getParent());
        setResizable(false);
    }

    private void populateFields()
    {
        // Set item selection
        itemComboBox.setSelectedItem(originalItem.getItemName());

        // Set split amount
        splitTextField.setText(String.valueOf(originalItem.getSplitAmount()));

        // Set team size
        teamSizeField.setText(String.valueOf(originalItem.getTeamSize()));

        // Set date
        dateField.setText(originalItem.getDate());

        // Set kill count (if field exists and item has kill count)
        if (killCountField != null)
        {
            if (originalItem.hasKillCount())
            {
                killCountField.setText(originalItem.getKillCount().toString());
            }
            else
            {
                killCountField.setText("");
            }
        }

        // Set received status
        receivedCheckBox.setSelected(originalItem.isReceived());
    }

    private class SaveActionListener implements ActionListener
    {
        @Override
        public void actionPerformed(ActionEvent e)
        {
            try
            {
                // Validate and update item data
                String selectedItem = (String) itemComboBox.getSelectedItem();
                double splitAmount = validateAndParseDouble(splitTextField.getText(), "Split Amount");
                int teamSize = validateAndParseInt(teamSizeField.getText(), "Team Size");
                String date = validateDate(dateField.getText());
                boolean isReceived = receivedCheckBox.isSelected();

                Integer killCount = null;
                if (killCountField != null && !killCountField.getText().trim().isEmpty())
                {
                    killCount = validateAndParseInt(killCountField.getText(), "Kill Count");
                }

                // Update the edited item
                editedItem.setItemName(selectedItem);
                editedItem.setSplitAmount(splitAmount);
                editedItem.setTeamSize(teamSize);
                editedItem.setDate(date);
                editedItem.setReceived(isReceived);
                editedItem.setKillCount(killCount);

                confirmed = true;
                dispose();

            }
            catch (Exception ex)
            {
                JOptionPane.showMessageDialog(
                    EditEntryDialog.this,
                    ex.getMessage(),
                    "Invalid Input",
                    JOptionPane.ERROR_MESSAGE
                );
            }
        }
    }

    private double validateAndParseDouble(String text, String fieldName) throws NumberFormatException
    {
        if (text == null || text.trim().isEmpty())
        {
            throw new NumberFormatException(fieldName + " cannot be empty");
        }
        try
        {
            double value = Double.parseDouble(text.trim());
            if (value < 0)
            {
                throw new NumberFormatException(fieldName + " must be a positive number");
            }
            return value;
        }
        catch (NumberFormatException e)
        {
            throw new NumberFormatException("Invalid " + fieldName + ": Please enter a valid positive number");
        }
    }

    private int validateAndParseInt(String text, String fieldName) throws NumberFormatException
    {
        if (text == null || text.trim().isEmpty())
        {
            throw new NumberFormatException(fieldName + " cannot be empty");
        }
        try
        {
            int value = Integer.parseInt(text.trim());
            if (value < 0)
            {
                throw new NumberFormatException(fieldName + " must be a positive number");
            }
            return value;
        }
        catch (NumberFormatException e)
        {
            throw new NumberFormatException("Invalid " + fieldName + ": Please enter a valid positive integer");
        }
    }

    private String validateDate(String text) throws IllegalArgumentException
    {
        if (text == null || text.trim().isEmpty())
        {
            throw new IllegalArgumentException("Date cannot be empty");
        }

        try
        {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yy");
            LocalDate.parse(text.trim(), formatter);
            return text.trim();
        }
        catch (DateTimeParseException e)
        {
            throw new IllegalArgumentException("Invalid date format. Please use MM/dd/yy format (e.g., 12/25/23)");
        }
    }

    public boolean isConfirmed()
    {
        return confirmed;
    }

    public ItemDataV2 getEditedItem()
    {
        return editedItem;
    }
}
package com.nexsplittracker;

import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@Slf4j
public class DataManager
{
    private static final File PLUGIN_DIR = new File(RuneLite.RUNELITE_DIR, "NexSplitTracker");
    private static final String DATA_FILE_NAME = "data.json";

    private final Gson gson;
    private final DataMigrationUtil migrationUtil;
    private List<ItemDataV2> itemDataList;

    public DataManager(Gson gson)
    {
        this.gson = gson;
        this.migrationUtil = new DataMigrationUtil(gson);
        this.itemDataList = new ArrayList<>();

        createPluginDirectory();
    }

    public void loadData()
    {
        try
        {
            String dataFilePath = getDataFilePath();
            itemDataList = migrationUtil.loadData(dataFilePath);
            log.debug("Loaded " + itemDataList.size() + " items from data file");
        }
        catch (IOException e)
        {
            log.error("Error loading data file", e);
            itemDataList = new ArrayList<>();
        }
    }

    public void saveData()
    {
        try
        {
            String dataFilePath = getDataFilePath();
            migrationUtil.saveData(itemDataList, dataFilePath);
            log.debug("Saved " + itemDataList.size() + " items to data file");
        }
        catch (IOException e)
        {
            log.error("Error saving data file", e);
        }
    }

    public void addItem(ItemDataV2 item)
    {
        itemDataList.add(item);
        saveData();
    }

    public void removeItem(ItemDataV2 item)
    {
        itemDataList.remove(item);
        saveData();
    }


    public void updateItem(ItemDataV2 oldItem, ItemDataV2 newItem)
    {
        int index = itemDataList.indexOf(oldItem);
        if (index != -1)
        {
            itemDataList.set(index, newItem);
            saveData();
        }
    }

    public ItemDataV2 findItemByTableRowData(String displayName, double splitAmount, String dateOrKillCount, int teamSize, NexSplitTrackerConfig config)
    {
        // Convert display name back to full name
        String fullName = convertDisplayNameToFullName(displayName);

        for (ItemDataV2 item : itemDataList)
        {
            if (item.getItemName().equals(fullName) &&
                item.getSplitAmount() == splitAmount &&
                item.getTeamSize() == teamSize)
            {
                // Check date/kill count match based on current display mode
                if (config.showKillCount())
                {
                    // Comparing kill count
                    if (item.hasKillCount() && item.getKillCount().toString().equals(dateOrKillCount))
                    {
                        return item;
                    }
                    else if (!item.hasKillCount() && "N/A".equals(dateOrKillCount))
                    {
                        return item;
                    }
                }
                else
                {
                    // Comparing date
                    if (item.getDate().equals(dateOrKillCount))
                    {
                        return item;
                    }
                }
            }
        }
        return null;
    }

    private String convertDisplayNameToFullName(String displayName)
    {
        for (NexUniques unique : NexUniques.values())
        {
            if (unique.getShortName().equals(displayName))
            {
                return unique.getFullName();
            }
        }
        return displayName; // Fallback
    }

    public List<ItemDataV2> getAllItems()
    {
        return new ArrayList<>(itemDataList); // Return copy to prevent external modification
    }


    private void createPluginDirectory()
    {
        if (!PLUGIN_DIR.exists())
        {
            boolean created = PLUGIN_DIR.mkdirs();
            if (created)
            {
                log.debug("Created plugin directory: " + PLUGIN_DIR.getAbsolutePath());
            }
            else
            {
                log.warn("Failed to create plugin directory: " + PLUGIN_DIR.getAbsolutePath());
            }
        }
    }

    private String getDataFilePath()
    {
        return new File(PLUGIN_DIR, DATA_FILE_NAME).getAbsolutePath();
    }

}
package com.nexsplittracker;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

@Slf4j
public class DataMigrationUtil
{
    private static final String CURRENT_VERSION = "2.0";
    private final Gson gson;

    public DataMigrationUtil(Gson gson)
    {
        this.gson = gson;
    }

    public static class DataFile
    {
        public String version;
        public List<ItemDataV2> data;


        public DataFile(String version, List<ItemDataV2> data)
        {
            this.version = version;
            this.data = data;
        }
    }

    public List<ItemDataV2> loadData(String filePath) throws IOException
    {
        File file = new File(filePath);
        if (!file.exists())
        {
            log.debug("Data file does not exist, starting with empty data: " + filePath);
            return new ArrayList<>();
        }

        try (FileReader reader = new FileReader(filePath))
        {
            // First determine if this is a versioned file or legacy format
            JsonElement jsonElement = gson.fromJson(reader, JsonElement.class);

            if (jsonElement == null)
            {
                log.debug("Empty or invalid JSON file, starting with empty data");
                return new ArrayList<>();
            }

            if (jsonElement.isJsonObject())
            {
                // New versioned format
                JsonObject jsonObject = jsonElement.getAsJsonObject();
                if (jsonObject.has("version") && jsonObject.has("data"))
                {
                    return loadVersionedData(jsonObject);
                }
            }

            if (jsonElement.isJsonArray())
            {
                // Legacy format - array of ItemData objects
                log.debug("Detected legacy data format, performing migration");
                return migrateLegacyData(jsonElement.getAsJsonArray(), filePath);
            }

            log.warn("Unknown data format, starting with empty data");
            return new ArrayList<>();
        }
        catch (JsonParseException e)
        {
            log.error("Error parsing JSON data file: " + filePath, e);
            throw new IOException("Failed to parse data file", e);
        }
    }

    private List<ItemDataV2> loadVersionedData(JsonObject jsonObject)
    {
        String version = jsonObject.get("version").getAsString();
        log.debug("Loading data file version: " + version);

        JsonArray dataArray = jsonObject.getAsJsonArray("data");
        Type listType = new TypeToken<ArrayList<ItemDataV2>>(){}.getType();
        List<ItemDataV2> data = gson.fromJson(dataArray, listType);

        return data != null ? data : new ArrayList<>();
    }

    private List<ItemDataV2> migrateLegacyData(JsonArray jsonArray, String filePath) throws IOException
    {
        // Create backup before migration
        createBackup(filePath);

        // Parse legacy data
        Type legacyListType = new TypeToken<ArrayList<ItemData>>(){}.getType();
        List<ItemData> legacyData = gson.fromJson(jsonArray, legacyListType);

        if (legacyData == null)
        {
            return new ArrayList<>();
        }

        // Convert to new format
        List<ItemDataV2> migratedData = new ArrayList<>();
        for (ItemData oldItem : legacyData)
        {
            migratedData.add(new ItemDataV2(oldItem));
        }

        log.debug("Migrated " + migratedData.size() + " items from legacy format");

        // Save in new format
        saveData(migratedData, filePath);

        return migratedData;
    }

    public void saveData(List<ItemDataV2> data, String filePath) throws IOException
    {
        DataFile dataFile = new DataFile(CURRENT_VERSION, data);

        try (FileWriter writer = new FileWriter(filePath))
        {
            gson.toJson(dataFile, writer);
            writer.flush();
            log.debug("Data saved to file: " + filePath + " (version: " + CURRENT_VERSION + ")");
        }
        catch (IOException e)
        {
            log.error("Error saving data to file: " + filePath, e);
            throw e;
        }
    }

    private void createBackup(String originalFilePath) throws IOException
    {
        File originalFile = new File(originalFilePath);
        if (!originalFile.exists())
        {
            return;
        }

        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
        String backupPath = originalFilePath.replace(".json", "_backup_" + timestamp + ".json");
        File backupFile = new File(backupPath);

        try
        {
            Files.copy(originalFile.toPath(), backupFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
            log.debug("Created backup: " + backupPath);
        }
        catch (IOException e)
        {
            log.warn("Failed to create backup before migration", e);
            throw new IOException("Failed to create backup before migration", e);
        }
    }

    public boolean isLegacyFormat(String filePath)
    {
        try (FileReader reader = new FileReader(filePath))
        {
            JsonElement jsonElement = gson.fromJson(reader, JsonElement.class);
            return jsonElement != null && jsonElement.isJsonArray();
        }
        catch (Exception e)
        {
            return false;
        }
    }
}
package com.nexsplittracker;

import net.runelite.client.game.ItemManager;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumnModel;
import java.awt.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TableManager
{
    private final ItemManager itemManager;
    private final NexSplitTrackerConfig config;

    // Primary table (overview)
    private DefaultTableModel primaryTableModel;
    private JTable primaryTable;

    // Secondary table (details)
    private DefaultTableModel secondaryTableModel;
    private JTable secondaryTable;

    public TableManager(ItemManager itemManager, NexSplitTrackerConfig config)
    {
        this.itemManager = itemManager;
        this.config = config;
    }

    public JTable initializePrimaryTable()
    {
        String[] columnNames = {"Drop", "Received", "Seen", "Split"};
        primaryTableModel = new DefaultTableModel(columnNames, 0)
        {
            @Override
            public boolean isCellEditable(int row, int column)
            {
                return false;
            }
        };

        primaryTable = new JTable(primaryTableModel);

        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(JLabel.CENTER);

        primaryTable.setFillsViewportHeight(true);
        primaryTable.setDefaultEditor(Object.class, null);
        primaryTable.setRowHeight(30);
        primaryTable.setShowGrid(true);
        primaryTable.setGridColor(Color.BLACK);
        primaryTable.setShowHorizontalLines(true);
        primaryTable.setShowVerticalLines(false);

        primaryTable.getColumnModel().getColumn(0).setCellRenderer(new ImageRenderer());
        primaryTable.getColumnModel().getColumn(1).setCellRenderer(centerRenderer);
        primaryTable.getColumnModel().getColumn(2).setCellRenderer(centerRenderer);
        primaryTable.getColumnModel().getColumn(3).setCellRenderer(centerRenderer);

        // Add header row
        primaryTableModel.addRow(new Object[]{"Drop", "Received", "Seen", "Split"});

        // Add rows for each unique item
        for (NexUniques unique : NexUniques.values())
        {
            ImageIcon icon = new ImageIcon(itemManager.getImage(unique.getItemId()));
            icon.setDescription(unique.getFullName());
            Object[] row = {icon, 0, 0, 0.0};
            primaryTableModel.addRow(row);
        }

        // Add totals row
        primaryTableModel.addRow(new Object[]{"Total", 0, 0, 0});

        return primaryTable;
    }

    public JTable initializeSecondaryTable()
    {
        String[] detailColumnNames = getSecondaryTableColumnNames();
        secondaryTableModel = new DefaultTableModel(detailColumnNames, 0);
        secondaryTable = new JTable(secondaryTableModel);
        secondaryTable.setTableHeader(new ToolTipHeader(secondaryTable.getColumnModel()));
        secondaryTable.setToolTipText("Double-click to edit an entry, right-click for options");

        // Center cell text
        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(JLabel.CENTER);

        // Set the renderer to each column
        for (int i = 0; i < secondaryTableModel.getColumnCount(); i++)
        {
            secondaryTable.getColumnModel().getColumn(i).setCellRenderer(centerRenderer);
        }

        // Schedule the adjustment of column widths
        SwingUtilities.invokeLater(this::adjustSecondaryTableColumnWidths);

        return secondaryTable;
    }

    private String[] getSecondaryTableColumnNames()
    {
        if (config.showKillCount())
        {
            return new String[]{"Item", "Split", "Kill Count", "Team", "Drop"};
        }
        else
        {
            return new String[]{"Item", "Split", "Date", "Team", "Drop"};
        }
    }

    public void updatePrimaryTable(List<ItemDataV2> allItems)
    {
        resetPrimaryTableData();

        // Aggregate counts and splits for each unique item
        Map<String, ItemAggregatedData> aggregatedDataMap = new HashMap<>();
        for (ItemDataV2 item : allItems)
        {
            String itemName = item.getItemName();
            aggregatedDataMap.putIfAbsent(itemName, new ItemAggregatedData());
            ItemAggregatedData aggregatedData = aggregatedDataMap.get(itemName);

            if (item.isReceived())
            {
                aggregatedData.increaseReceived();
            }
            else
            {
                aggregatedData.increaseSeen();
            }
            aggregatedData.increaseSplit(item.getSplitAmount());
        }

        // Update the primary table with aggregated data
        for (Map.Entry<String, ItemAggregatedData> entry : aggregatedDataMap.entrySet())
        {
            String itemName = entry.getKey();
            ItemAggregatedData aggregatedData = entry.getValue();

            int index = findRowIndexByItemName(itemName);
            if (index != -1)
            {
                primaryTableModel.setValueAt(aggregatedData.getReceivedCount(), index, 1);
                primaryTableModel.setValueAt(aggregatedData.getSeenCount(), index, 2);
                primaryTableModel.setValueAt(aggregatedData.getTotalSplit(), index, 3);
            }
        }

        updateTotals();
    }

    public void updateSecondaryTable(List<ItemDataV2> allItems)
    {
        // Check if column structure needs to change
        String[] expectedColumns = getSecondaryTableColumnNames();
        String[] currentColumns = new String[secondaryTableModel.getColumnCount()];
        for (int i = 0; i < currentColumns.length; i++)
        {
            currentColumns[i] = secondaryTableModel.getColumnName(i);
        }

        boolean needsRestructure = false;
        if (expectedColumns.length != currentColumns.length)
        {
            needsRestructure = true;
        }
        else
        {
            for (int i = 0; i < expectedColumns.length; i++)
            {
                if (!expectedColumns[i].equals(currentColumns[i]))
                {
                    needsRestructure = true;
                    break;
                }
            }
        }

        if (needsRestructure)
        {
            // Rebuild table with new column structure
            secondaryTableModel.setColumnIdentifiers(expectedColumns);
        }

        secondaryTableModel.setRowCount(0); // Clear the table

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yy");

        for (ItemDataV2 item : allItems)
        {
            String drop = item.isReceived() ? "R" : "S";
            String displayName = getShortNameForItem(item.getItemName());

            Object[] rowData;
            if (config.showKillCount())
            {
                String killCountValue = item.hasKillCount() ? item.getKillCount().toString() : "N/A";
                rowData = new Object[]{
                        displayName,
                        item.getSplitAmount(),
                        killCountValue,
                        item.getTeamSize(),
                        drop
                };
            }
            else
            {
                LocalDate date = LocalDate.parse(item.getDate(), formatter);
                String formattedDate = date.format(DateTimeFormatter.ofPattern("MM/dd/yy"));
                rowData = new Object[]{
                        displayName,
                        item.getSplitAmount(),
                        formattedDate,
                        item.getTeamSize(),
                        drop
                };
            }

            secondaryTableModel.addRow(rowData);
        }

        if (needsRestructure)
        {
            adjustSecondaryTableColumnWidths();
        }
    }

    private void resetPrimaryTableData()
    {
        // Reset the counts and splits for all items (skip header and total rows)
        for (int i = 1; i < primaryTableModel.getRowCount() - 1; i++)
        {
            primaryTableModel.setValueAt(0, i, 1); // Reset 'Received' count
            primaryTableModel.setValueAt(0, i, 2); // Reset 'Seen' count
            primaryTableModel.setValueAt(0.0, i, 3); // Reset 'Split' value
        }
    }

    private void updateTotals()
    {
        int totalReceived = 0;
        int totalSeen = 0;
        double totalSplit = 0.0;

        // Calculate totals (skip header and total rows)
        for (int i = 1; i < primaryTableModel.getRowCount() - 1; i++)
        {
            totalReceived += (Integer) primaryTableModel.getValueAt(i, 1);
            totalSeen += (Integer) primaryTableModel.getValueAt(i, 2);
            totalSplit += (Double) primaryTableModel.getValueAt(i, 3);
        }

        int lastRowIndex = primaryTableModel.getRowCount() - 1;
        primaryTableModel.setValueAt("Total Drops", lastRowIndex, 0);
        primaryTableModel.setValueAt(totalReceived, lastRowIndex, 1);
        primaryTableModel.setValueAt(totalSeen, lastRowIndex, 2);
        primaryTableModel.setValueAt(totalSplit, lastRowIndex, 3);
    }

    private int findRowIndexByItemName(String itemName)
    {
        for (int i = 0; i < primaryTableModel.getRowCount(); i++)
        {
            Object cellValue = primaryTableModel.getValueAt(i, 0);
            if (cellValue instanceof ImageIcon)
            {
                ImageIcon icon = (ImageIcon) cellValue;
                if (icon.getDescription().equals(itemName))
                {
                    return i;
                }
            }
        }
        return -1;
    }

    private void adjustSecondaryTableColumnWidths()
    {
        if (secondaryTable == null) return;

        TableColumnModel columnModel = secondaryTable.getColumnModel();
        if (columnModel.getColumnCount() == 5)
        {
            columnModel.getColumn(0).setPreferredWidth(50); // Item
            columnModel.getColumn(1).setPreferredWidth(50); // Split
            columnModel.getColumn(2).setPreferredWidth(100); // Date/Kill Count
            columnModel.getColumn(3).setPreferredWidth(40); // Team Size
            columnModel.getColumn(4).setPreferredWidth(40); // Received/Seen
        }
    }

    public String convertShortNameToFullName(String shortName)
    {
        for (NexUniques unique : NexUniques.values())
        {
            if (unique.getShortName().equals(shortName))
            {
                return unique.getFullName();
            }
        }
        return shortName; // Fallback
    }

    private String getShortNameForItem(String fullName)
    {
        for (NexUniques unique : NexUniques.values())
        {
            if (unique.getFullName().equals(fullName))
            {
                return unique.getShortName();
            }
        }
        return fullName; // Fallback if no match found
    }

    public DefaultTableModel getSecondaryTableModel()
    {
        return secondaryTableModel;
    }

    public JTable getSecondaryTable()
    {
        return secondaryTable;
    }

    public DefaultTableModel getPrimaryTableModel()
    {
        return primaryTableModel;
    }

    public JTable getPrimaryTable()
    {
        return primaryTable;
    }

    public static class ItemAggregatedData
    {
        private int receivedCount = 0;
        private int seenCount = 0;
        private double totalSplit = 0.0;

        public void increaseReceived()
        {
            receivedCount++;
        }

        public void increaseSeen()
        {
            seenCount++;
        }

        public void increaseSplit(double split)
        {
            totalSplit += split;
        }

        public int getReceivedCount()
        {
            return receivedCount;
        }

        public int getSeenCount()
        {
            return seenCount;
        }

        public double getTotalSplit()
        {
            return totalSplit;
        }
    }

    private static class ImageRenderer extends DefaultTableCellRenderer
    {
        @Override
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column)
        {
            if (value instanceof ImageIcon)
            {
                JLabel label = new JLabel((ImageIcon) value);
                label.setHorizontalAlignment(JLabel.CENTER);
                return label;
            }
            return super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
        }
    }
}
package com.nexsplittracker;

/**
 * Legacy data model - kept for backward compatibility during data migration.
 * New code should use ItemDataV2 instead.
 * @deprecated Use ItemDataV2 for new implementations
 */
@Deprecated
class ItemData
{
    private String itemName;
    private double splitAmount;
    private String date;
    private int teamSize;
    private boolean isReceived;



    public ItemData(String itemName, double splitAmount, String date, int teamSize, boolean isReceived)
    {
        this.itemName = itemName;
        this.splitAmount = splitAmount;
        this.date = date;
        this.teamSize = teamSize;
        this.isReceived = isReceived;
    }


    public String getItemName()
    {
        return itemName;
    }

    public double getSplitAmount()
    {
        return splitAmount;
    }

    public String getDate()
    {
        return date;
    }

    public int getTeamSize()
    {
        return teamSize;
    }

    public boolean isReceived()
    {
        return isReceived;
    }



    @Override
    public String toString()
    {
        return "ItemData{" +
                "itemName='" + itemName + '\'' +
                ", splitAmount=" + splitAmount +
                ", date=" + date +
                ", teamSize=" + teamSize +
                '}';
    }



}


package com.nexsplittracker;

import net.runelite.api.ItemID;
import java.util.Arrays;

public enum NexUniques
{
    ZVAMBS("Zaryte Vambraces", "Vambs", ItemID.ZARYTE_VAMBRACES),
    NIHIL_HORN("Nihil Horn", "Horn", ItemID.NIHIL_HORN),
    TORVA_HELM("Torva Full Helm", "Helm", ItemID.TORVA_FULL_HELM),
    TORVA_PLATE("Torva Platebody", "Plate", ItemID.TORVA_PLATEBODY),
    TORVA_LEGS("Torva Platelegs", "Legs", ItemID.TORVA_PLATELEGS),
    ANCIENT_HILT("Ancient Hilt", "Hilt", ItemID.ANCIENT_HILT);

    private final String fullName;
    private final String shortName;
    private final int itemId;

    NexUniques(String fullName, String shortName, int itemId)
    {
        this.fullName = fullName;
        this.shortName = shortName;
        this.itemId = itemId;
    }

    public String getFullName()
    {
        return fullName;
    }

    public String getShortName()
    {
        return shortName;
    }

    public int getItemId()
    {
        return itemId;
    }

    // Static method to get names array
    public static String[] names()
    {
        return Arrays.stream(NexUniques.values()).map(NexUniques::getFullName).toArray(String[]::new);
    }

}

package com.nexsplittracker;

import com.google.gson.Gson;
import com.google.inject.Provides;
import javax.inject.Inject;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import java.awt.image.BufferedImage;

@PluginDescriptor(
		name = "Nex Split Tracker",
		description = "Track Nex uniques and GP split among teams"
)
public class NexSplitTrackerPlugin extends Plugin
{
	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private NexSplitTrackerConfig config;

	@Inject
	private Gson gson;

	@Inject
	private ItemManager itemManager;


	private NexSplitTrackerPanel panel;
	private NavigationButton navButton;

    @Provides
	NexSplitTrackerConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(NexSplitTrackerConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		panel = new NexSplitTrackerPanel(itemManager, gson, config);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/nex16v2.png");

		navButton = NavigationButton.builder()
				.tooltip("Nex Split Tracker")
				.icon(icon)
				.priority(6)
				.panel(panel)
				.build();

		clientToolbar.addNavigation(navButton);
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(navButton);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (configChanged.getGroup().equals("nexsplittracker") && panel != null)
		{
			panel.onConfigChanged();
		}
	}

}

package com.nexsplittracker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("nexsplittracker")
public interface NexSplitTrackerConfig extends Config
{
	// Example configuration item
	@ConfigItem(
			keyName = "increaseDropRate",
			name = "Increase Drop Rate",
			description = "Might do something if you really believe"
	)
	default boolean dropRateBoost()
	{
		return false;
	}

	@ConfigItem(
			keyName = "showKillCount",
			name = "Show Kill Count",
			description = "Display kill count instead of date in the details table"
	)
	default boolean showKillCount()
	{
		return false;
	}

	@ConfigItem(
			keyName = "enableKillCountEntry",
			name = "Enable Kill Count Entry",
			description = "Show kill count input field when adding drops"
	)
	default boolean enableKillCountEntry()
	{
		return true;
	}

}

package com.nexsplittracker;

import com.google.gson.Gson;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.logging.Logger;

public class NexSplitTrackerPanel extends PluginPanel
{
    private final ItemManager itemManager;
    private final NexSplitTrackerConfig config;
    private JComboBox<String> itemComboBox;
    private CustomTextField splitTextField;
    private JTextField killCountField;
    private JLabel killCountLabel;
    private JCheckBox receivedCheckBox;
    private JTextField teamSizeField;
    private JPanel userInputPanel;

    private final DataManager dataManager;
    private final TableManager tableManager;
    private static final Logger logger = Logger.getLogger(NexSplitTrackerPanel.class.getName());

    public NexSplitTrackerPanel(ItemManager itemManager, Gson gson, NexSplitTrackerConfig config)
    {
        super();
        this.itemManager = itemManager;
        this.config = config;
        this.dataManager = new DataManager(gson);
        this.tableManager = new TableManager(itemManager, config);

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        initializeUI();
        loadData();
    }


    private void initializeUI()
    {
        createHeader();
        add(tableManager.initializePrimaryTable(), BorderLayout.CENTER);
        createUserInputPanel();

        JScrollPane secondaryScrollPane = new JScrollPane(tableManager.initializeSecondaryTable());
        secondaryScrollPane.setPreferredSize(new Dimension(400, 250));
        add(secondaryScrollPane, BorderLayout.SOUTH);

        setupSecondaryTableMouseListener();
    }

    private void createHeader()
    {
        JPanel headerPanel = new JPanel();
        headerPanel.setLayout(new BorderLayout());
        headerPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        headerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JLabel headerLabel = new JLabel("Nex Split Tracker", SwingConstants.CENTER);
        headerLabel.setForeground(Color.WHITE);
        headerLabel.setFont(new Font("Dialog", Font.BOLD, 16));
        headerPanel.add(headerLabel, BorderLayout.CENTER);

        add(headerPanel);
    }

    private void loadData()
    {
        dataManager.loadData();
        updateTables();
    }

    private void updateTables()
    {
        tableManager.updatePrimaryTable(dataManager.getAllItems());
        tableManager.updateSecondaryTable(dataManager.getAllItems());
    }

    public void onConfigChanged()
    {
        // Update the secondary table to reflect any config changes (show kc/date)
        updateTables();

        // Update kill count field visibility
        updateKillCountFieldVisibility();
    }

    private void updateKillCountFieldVisibility()
    {
        if (killCountField != null && killCountLabel != null)
        {
            boolean shouldShow = config.enableKillCountEntry();
            killCountField.setVisible(shouldShow);
            killCountLabel.setVisible(shouldShow);

            // Refresh the layout
            if (userInputPanel != null)
            {
                userInputPanel.revalidate();
                userInputPanel.repaint();
            }
        }
    }

    private void addNewDrop()
    {
        try
        {
            String selectedItem = (String) itemComboBox.getSelectedItem();
            boolean isReceived = receivedCheckBox.isSelected();
            double splitAmount = validateAndParseDouble(splitTextField.getText(), "Split Amount");
            int teamSize = validateAndParseInt(teamSizeField.getText(), "Team Size");

            Integer killCount = null;
            if (config.enableKillCountEntry() && killCountField != null &&
                killCountField.isVisible() && !killCountField.getText().trim().isEmpty())
            {
                killCount = validateAndParseInt(killCountField.getText(), "Kill Count");
            }

            String formattedDate = LocalDate.now().format(DateTimeFormatter.ofPattern("MM/dd/yy"));
            ItemDataV2 newItem = new ItemDataV2(selectedItem, splitAmount, formattedDate, teamSize, isReceived, killCount);

            dataManager.addItem(newItem);
            updateTables();
            clearInputFields();

        }
        catch (NumberFormatException e)
        {
            JOptionPane.showMessageDialog(this, e.getMessage(), "Invalid Input", JOptionPane.ERROR_MESSAGE);
        }
    }

    private double validateAndParseDouble(String text, String fieldName) throws NumberFormatException
    {
        if (text == null || text.trim().isEmpty())
        {
            throw new NumberFormatException(fieldName + " cannot be empty");
        }
        try
        {
            return Double.parseDouble(text.trim());
        }
        catch (NumberFormatException e)
        {
            throw new NumberFormatException("Invalid " + fieldName + ": Please enter a valid number");
        }
    }

    private int validateAndParseInt(String text, String fieldName) throws NumberFormatException
    {
        if (text == null || text.trim().isEmpty())
        {
            throw new NumberFormatException(fieldName + " cannot be empty");
        }
        try
        {
            int value = Integer.parseInt(text.trim());
            if (value < 0)
            {
                throw new NumberFormatException(fieldName + " must be a positive number");
            }
            return value;
        }
        catch (NumberFormatException e)
        {
            throw new NumberFormatException("Invalid " + fieldName + ": Please enter a valid positive integer");
        }
    }

    private void clearInputFields()
    {
        splitTextField.setText("");
        teamSizeField.setText("");
        if (killCountField != null)
        {
            killCountField.setText("");
        }
        receivedCheckBox.setSelected(false);
    }

    private void setupSecondaryTableMouseListener()
    {
        tableManager.getSecondaryTable().addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent e)
            {
                int row = tableManager.getSecondaryTable().rowAtPoint(e.getPoint());
                if (row >= 0 && row < tableManager.getSecondaryTable().getRowCount())
                {
                    tableManager.getSecondaryTable().setRowSelectionInterval(row, row);

                    if (SwingUtilities.isRightMouseButton(e))
                    {
                        showDeletePopup(e.getX(), e.getY(), row);
                    }
                }
            }

            @Override
            public void mouseClicked(MouseEvent e)
            {
                if (e.getClickCount() == 2 && SwingUtilities.isLeftMouseButton(e))
                {
                    int row = tableManager.getSecondaryTable().rowAtPoint(e.getPoint());
                    if (row >= 0 && row < tableManager.getSecondaryTable().getRowCount())
                    {
                        editTableEntry(row);
                    }
                }
            }
        });
    }

    private void createUserInputPanel()
    {
        userInputPanel = new JPanel(new GridBagLayout());
        userInputPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridwidth = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 0.5;
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.anchor = GridBagConstraints.WEST;

        // Item selection
        String[] itemNames = NexUniques.names();
        itemComboBox = new JComboBox<>(itemNames);
        userInputPanel.add(new JLabel("Select Item:"), gbc);
        gbc.gridx = 1;
        userInputPanel.add(itemComboBox, gbc);
        itemComboBox.setToolTipText("Select the item you want to add");

        // Received checkbox
        gbc.gridx = 0;
        gbc.gridy = 1;
        userInputPanel.add(new JLabel("Received by Me:"), gbc);
        gbc.gridx = 1;
        receivedCheckBox = new JCheckBox();
        userInputPanel.add(receivedCheckBox, gbc);
        receivedCheckBox.setToolTipText("Check this box if you received the drop in your name");

        // Split amount input
        gbc.gridx = 0;
        gbc.gridy = 2;
        splitTextField = new CustomTextField(10);
        splitTextField.setSuffix("M");
        userInputPanel.add(new JLabel("Split Amount:"), gbc);
        gbc.gridx = 1;
        userInputPanel.add(splitTextField, gbc);
        splitTextField.setToolTipText("Enter the split amount in Millions. Example:'50' or '65.5'");

        // Team size input
        gbc.gridx = 0;
        gbc.gridy = 3;
        teamSizeField = new JTextField(10);
        userInputPanel.add(new JLabel("Team Size:"), gbc);
        gbc.gridx = 1;
        userInputPanel.add(teamSizeField, gbc);
        teamSizeField.setToolTipText("Enter the team size");

        // Kill count input (always create but conditionally show)
        gbc.gridx = 0;
        gbc.gridy = 4;
        killCountLabel = new JLabel("Kill Count:");
        killCountField = new JTextField(10);
        killCountField.setToolTipText("Enter the kill count when this drop occurred (optional)");

        // Add kill count components to panel
        userInputPanel.add(killCountLabel, gbc);
        gbc.gridx = 1;
        userInputPanel.add(killCountField, gbc);

        // Set initial visibility based on config
        updateKillCountFieldVisibility();

        // Add Drop button
        gbc.gridx = 0;
        gbc.gridy = 5;
        gbc.gridwidth = 2;
        JButton addButton = new JButton("Add Drop");
        addButton.setToolTipText("Click to add a new drop");
        addButton.addActionListener(e -> addNewDrop());
        userInputPanel.add(addButton, gbc);

        add(userInputPanel, BorderLayout.SOUTH);
    }

    private void showDeletePopup(int x, int y, int row)
    {
        JPopupMenu popupMenu = new JPopupMenu();

        JMenuItem editItem = new JMenuItem("Edit");
        editItem.addActionListener(e -> editTableEntry(row));
        popupMenu.add(editItem);

        popupMenu.addSeparator();

        JMenuItem deleteItem = new JMenuItem("Delete");
        deleteItem.addActionListener(e -> {
            int result = JOptionPane.showConfirmDialog(
                this,
                "Are you sure you want to delete this entry?",
                "Confirm Delete",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.WARNING_MESSAGE
            );
            if (result == JOptionPane.YES_OPTION) {
                deleteItemFromTable(row);
            }
        });
        popupMenu.add(deleteItem);
        popupMenu.show(tableManager.getSecondaryTable(), x, y);
    }

    private void editTableEntry(int row)
    {
        try {
            // Get the item details from the table
            String displayName = (String) tableManager.getSecondaryTableModel().getValueAt(row, 0);
            double splitAmount = (Double) tableManager.getSecondaryTableModel().getValueAt(row, 1);
            String dateOrKillCount = (String) tableManager.getSecondaryTableModel().getValueAt(row, 2);
            int teamSize = (Integer) tableManager.getSecondaryTableModel().getValueAt(row, 3);

            // Find the actual item in the data
            ItemDataV2 itemToEdit = dataManager.findItemByTableRowData(displayName, splitAmount, dateOrKillCount, teamSize, config);

            if (itemToEdit != null) {
                // Create and show edit dialog
                Frame parentFrame = (Frame) SwingUtilities.getWindowAncestor(this);
                EditEntryDialog editDialog = new EditEntryDialog(parentFrame, itemToEdit, config);
                editDialog.setVisible(true);

                // If user confirmed the edit, update the data
                if (editDialog.isConfirmed()) {
                    ItemDataV2 editedItem = editDialog.getEditedItem();
                    dataManager.updateItem(itemToEdit, editedItem);
                    updateTables();
                }
            } else {
                JOptionPane.showMessageDialog(this, "Could not find the selected item to edit.", "Error", JOptionPane.ERROR_MESSAGE);
            }
        } catch (Exception ex) {
            logger.severe("Error editing item: " + ex.getMessage());
            JOptionPane.showMessageDialog(this, "Error editing item: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void deleteItemFromTable(int row)
    {
        try {
            // Get the item details from the table
            String itemName = (String) tableManager.getSecondaryTableModel().getValueAt(row, 0);
            double splitAmount = (Double) tableManager.getSecondaryTableModel().getValueAt(row, 1);
            String dateOrKillCount = (String) tableManager.getSecondaryTableModel().getValueAt(row, 2);
            int teamSize = (Integer) tableManager.getSecondaryTableModel().getValueAt(row, 3);

            // Convert short name back to full name for matching
            String fullName = tableManager.convertShortNameToFullName(itemName);

            // Find the matching item in the data
            ItemDataV2 toRemove = null;
            for (ItemDataV2 item : dataManager.getAllItems()) {
                if (item.getItemName().equals(fullName) &&
                    item.getSplitAmount() == splitAmount &&
                    item.getTeamSize() == teamSize) {

                    // Additional check for date match
                    if (!config.showKillCount() && item.getDate().equals(dateOrKillCount)) {
                        toRemove = item;
                        break;
                    }
                    // Additional check for kill count match
                    else if (config.showKillCount() && item.hasKillCount() &&
                             item.getKillCount().toString().equals(dateOrKillCount)) {
                        toRemove = item;
                        break;
                    }
                    // If no kill count or N/A displayed
                    else if (config.showKillCount() && !item.hasKillCount() && "N/A".equals(dateOrKillCount)) {
                        toRemove = item;
                        break;
                    }
                }
            }

            if (toRemove != null) {
                dataManager.removeItem(toRemove);
                updateTables();
            }
        } catch (Exception e) {
            logger.severe("Error deleting item: " + e.getMessage());
            JOptionPane.showMessageDialog(this, "Error deleting item: " + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

}
package com.nexsplittracker;

import java.awt.Color;

public class ColorScheme
{
    public static final Color DARK_GRAY_COLOR = new Color(42, 42, 42);

    private ColorScheme()
    {
        throw new IllegalStateException("Utility class");
    }
}

package com.nexsplittracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(NexSplitTrackerPlugin.class);
		RuneLite.main(args);
	}
}
