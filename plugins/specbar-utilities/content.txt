package com.specbar;

import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.awt.Color;

@ConfigGroup("specbar")
public interface SpecBarConfig extends Config
{
    @ConfigSection(
        name = "Color Presets",
        description = "Pre-configured color themes for all states",
        position = 0
    )
    String colorPresetsSection = "colorPresets";

    @ConfigSection(
        name = "Visual Effects",
        description = "Configure the visual feedback effects",
        position = 1
    )
    String visualEffectsSection = "visualEffects";

    @ConfigSection(
        name = "Hover Colors",
        description = "Customize the colors for hover state",
        position = 2
    )
    String hoverColorsSection = "hoverColors";

    @ConfigSection(
        name = "Click Colors",
        description = "Customize colors for click state",
        position = 2
    )
    String clickColorsSection = "clickColors";

    @ConfigSection(
        name = "Idle State",
        description = "Persistent border when not hovering or clicking",
        position = 4
    )
    String idleStateSection = "idleState";

    @ConfigItem(
        keyName = "colorPreset",
        name = "Color Preset",
        description = "Choose from pre-configured color themes for all states",
        section = colorPresetsSection,
        position = 0
    )
    default ColorPreset colorPreset()
    {
        return ColorPreset.CUSTOM;
    }

    @ConfigItem(
        keyName = "enableHoverEffect",
        name = "Enable Hover Effect",
        description = "Show visual feedback when hovering over the special attack bar",
        section = visualEffectsSection,
        position = 0
    )
    default boolean enableHoverEffect()
    {
        return true;
    }

    @ConfigItem(
        keyName = "enableClickEffect",
        name = "Enable Click Effect",
        description = "Show visual feedback when clicking the special attack bar",
        section = visualEffectsSection,
        position = 1
    )
    default boolean enableClickEffect()
    {
        return true;
    }

    @ConfigItem(
        keyName = "enableIdleBorder",
        name = "Enable Idle Border",
        description = "Show a persistent border around the special attack bar when not interacting",
        section = visualEffectsSection,
        position = 2
    )
    default boolean enableIdleBorder()
    {
        return false;
    }

    @ConfigItem(
        keyName = "hideSpecBarText",
        name = "Hide Spec Bar Text",
        description = "Hide the percentage text on the special attack bar for a cleaner look",
        section = visualEffectsSection,
        position = 3
    )
    default boolean hideSpecBarText()
    {
        return false;
    }

    // Hover State Settings
    @Alpha
    @ConfigItem(
        keyName = "hoverAreaColor",
        name = "Hover Area Color",
        description = "Color and opacity for the hover area fill of the special attack bar",
        section = hoverColorsSection,
        position = 0
    )
    default Color hoverAreaColor()
    {
        return new Color(135, 206, 250, 60); // Light sky blue with transparency
    }

    @Alpha
    @ConfigItem(
        keyName = "hoverBorderColor",
        name = "Hover Border Color",
        description = "Color and opacity for the border when hovering over the special attack bar",
        section = hoverColorsSection,
        position = 1
    )
    default Color hoverBorderColor()
    {
        return new Color(30, 144, 255, 180); // Dodger blue with higher opacity
    }

    // Click State Settings
    @Alpha
    @ConfigItem(
        keyName = "clickAreaColor",
        name = "Click Area Color",
        description = "Color and opacity for the area fill when clicking the special attack bar",
        section = clickColorsSection,
        position = 0
    )
    default Color clickAreaColor()
    {
        return new Color(255, 165, 0, 100); // Orange with transparency for high contrast
    }

    @Alpha
    @ConfigItem(
        keyName = "clickBorderColor",
        name = "Click Border Color",
        description = "Color and opacity for the border when clicking the special attack bar",
        section = clickColorsSection,
        position = 1
    )
    default Color clickBorderColor()
    {
        return new Color(255, 69, 0, 220); // Red-orange with high opacity for visibility
    }

    // Idle State Settings
    @Alpha
    @ConfigItem(
        keyName = "idleAreaColor",
        name = "Idle Area Color",
        description = "Color and opacity for the idle area fill of the special attack bar",
        section = idleStateSection,
        position = 0
    )
    default Color idleAreaColor()
    {
        return new Color(128, 128, 128, 30); // Very subtle gray fill
    }

    @Alpha
    @ConfigItem(
        keyName = "idleBorderColor",
        name = "Idle Border Color",
        description = "Color and opacity for the idle border around the special attack bar",
        section = idleStateSection,
        position = 1
    )
    default Color idleBorderColor()
    {
        return new Color(128, 128, 128, 100); // Light gray with low opacity for subtle indication
    }



    enum ColorPreset
    {
        CUSTOM("Custom"),
        CLASSIC_BLUE("Classic Blue"),
        WARM_ORANGE("Warm Orange"),
        NATURE_GREEN("Nature Green"),
        ROYAL_PURPLE("Royal Purple"),
        DARK_THEME("Dark Theme");

        private final String displayName;

        ColorPreset(String displayName)
        {
            this.displayName = displayName;
        }

        @Override
        public String toString()
        {
            return displayName;
        }
    }
}

package com.specbar;

import net.runelite.api.Client;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;

public class SpecBarOverlay extends Overlay
{
    private final Client client;
    private final SpecBarPlugin plugin;

    @Inject
    private SpecBarOverlay(Client client, SpecBarPlugin plugin)
    {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        // Use proper RuneLite constants instead of hardcoded widget ID
        Widget specBarWidget = client.getWidget(InterfaceID.COMBAT, 42);
        if (specBarWidget == null || specBarWidget.isHidden())
        {
            return null;
        }

        Rectangle bounds = specBarWidget.getBounds();
        if (bounds == null)
        {
            return null;
        }

        // Check if any effect should be rendered
        boolean hasClickEffect = plugin.isClicked();
        boolean hasHoverEffect = plugin.isHovering();
        boolean hasIdleEffect = plugin.isIdleBorderEnabled() && !hasClickEffect && !hasHoverEffect;
        
        // Early exit if no effects are active
        if (!hasClickEffect && !hasHoverEffect && !hasIdleEffect)
        {
            return null;
        }

        // Create a graphics context only when needed
        Graphics2D g2d = (Graphics2D) graphics.create();
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        // Render effects in priority order: Click > Hover > Idle
        if (hasClickEffect)
        {
            renderEffect(g2d, bounds, plugin.getClickAreaColor(), plugin.getClickBorderColor());
        }
        else if (hasHoverEffect)
        {
            renderEffect(g2d, bounds, plugin.getHoverAreaColor(), plugin.getHoverBorderColor());
        }
        else if (hasIdleEffect)
        {
            renderEffect(g2d, bounds, plugin.getIdleAreaColor(), plugin.getIdleBorderColor());
        }

        g2d.dispose();
        return null;
    }

    private void renderEffect(Graphics2D g2d, Rectangle bounds, 
                             Color areaColor, Color borderColor)
    {
        // Draw area fill (color already includes opacity from @Alpha annotation)
        g2d.setColor(areaColor);
        g2d.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);

        // Draw border (color already includes opacity from @Alpha annotation)
        g2d.setColor(borderColor);
        g2d.setStroke(new BasicStroke(2));
        g2d.drawRect(bounds.x, bounds.y, bounds.width - 1, bounds.height - 1);
    }
    
    private void renderIdleBorder(Graphics2D g2d, Rectangle bounds, Color borderColor)
    {
        // Draw only border for idle state (no area fill)
        g2d.setColor(borderColor);
        g2d.setStroke(new BasicStroke(1)); // Thinner stroke for subtle idle indication
        g2d.drawRect(bounds.x, bounds.y, bounds.width - 1, bounds.height - 1);
    }
}

package com.specbar;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GraphicChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import java.awt.*;

@Slf4j
@PluginDescriptor(
    name = "Spec Bar Utilities",
    description = "Enhances the special attack bar with visual feedback for hover and click states",
    tags = {"combat", "ui", "special attack"}
)
public class SpecBarPlugin extends Plugin
{
    @Inject
    private Client client;

    @Inject
    private SpecBarConfig config;

    @Inject
    private ConfigManager configManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private SpecBarOverlay specBarOverlay;

    private boolean isHovering = false;
    private boolean isClicked = false;
    private int tickCounter = 0;
    private int lastSpecialAttackEnergy = -1; // Track spec energy to detect usage
    private long lastClickClearTime = 0; // Track when click state was cleared
    private static final long HOVER_SUPPRESS_DURATION_MS = 300; // Suppress hover for 300ms after click clear
    
    // Enhanced special attack detection
    private long lastSpecClickTime = 0; // Track when spec bar was clicked
    private static final long SPEC_DETECTION_WINDOW_MS = 3000; // 3 second window to detect spec usage after click
    
    // Widget caching for performance
    private Widget cachedSpecBarWidget = null;
    private long lastWidgetSearchTime = 0;
    private static final long WIDGET_CACHE_DURATION_MS = 10000; // Cache for 10 seconds

    @Override
    protected void startUp() throws Exception
    {
        overlayManager.add(specBarOverlay);
        log.info("Spec Bar Utilities started!");
    }

    @Override
    protected void shutDown() throws Exception
    {
        overlayManager.remove(specBarOverlay);
        isHovering = false;
        isClicked = false;
        log.info("Spec Bar Utilities stopped!");
    }

    @Subscribe
    public void onClientTick(ClientTick event)
    {
        // Track special attack energy to detect when spec is used
        int currentSpecEnergy = client.getVarpValue(301); // Varp 301 is special attack energy
        
        // If we're in clicked state and spec energy decreased, the spec was used
        if (isClicked && lastSpecialAttackEnergy != -1 && currentSpecEnergy < lastSpecialAttackEnergy)
        {
            clearClickState(); // Remove click effect when spec is actually used
        }
        
        lastSpecialAttackEnergy = currentSpecEnergy;
        
        // Throttle hover detection to every 3rd tick for performance (still responsive at ~50fps)
        tickCounter++;
        if (tickCounter % 3 != 0)
        {
            return;
        }
        
        // Check if mouse is hovering over the special attack bar
        Widget specBarWidget = getCachedSpecialAttackWidget();
        if (specBarWidget != null && !specBarWidget.isHidden())
        {
            // Hide spec bar text if option is enabled
            if (config.hideSpecBarText())
            {
                String currentText = specBarWidget.getText();
                if (currentText != null && !currentText.isEmpty())
                {
                    specBarWidget.setText("");
                }
            }
            
            Rectangle bounds = specBarWidget.getBounds();
            if (bounds != null)
            {
                net.runelite.api.Point mousePos = client.getMouseCanvasPosition();
                boolean mouseInBounds = bounds.contains(mousePos.getX(), mousePos.getY());
                
                // Suppress hover effect for a short time after click state is cleared
                long currentTime = System.currentTimeMillis();
                boolean hoverSuppressed = (currentTime - lastClickClearTime) < HOVER_SUPPRESS_DURATION_MS;
                
                isHovering = mouseInBounds && !hoverSuppressed;
            }
            else
            {
                isHovering = false;
            }
        }
        else
        {
            isHovering = false;
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event)
    {
        // Optimized click detection with minimal string operations
        String menuTarget = event.getMenuTarget();
        
        // Fast path: check if we're hovering and any relevant click happens
        if (isHovering)
        {
            String menuOption = event.getMenuOption();
            if (menuOption != null && !menuOption.equals("Walk here") && !menuOption.equals("Examine"))
            {
                // If already clicked, instantly destroy the clicked box
                if (isClicked)
                {
                    clearClickState();
                }
                else
                {
                    triggerClickState();
                }
                return;
            }
        }
        
        // Check for specific special attack clicks (reduced string comparisons)
        if (menuTarget != null && menuTarget.length() < 50) // Performance: skip very long targets
        {
            if (menuTarget.contains("Special Attack") || 
                (menuTarget.contains("%") && menuTarget.length() < 30))
            {
                String menuOption = event.getMenuOption();
                if (menuOption != null && (menuOption.equals("Use") || menuOption.equals("Activate")))
                {
                    triggerClickState();
                }
            }
        }
    }
    
    @Subscribe
    public void onAnimationChanged(AnimationChanged event)
    {
        // Only process player animations
        if (!(event.getActor() instanceof Player))
        {
            return;
        }
        
        Player player = (Player) event.getActor();
        
        // Only process local player
        if (player != client.getLocalPlayer())
        {
            return;
        }
        
        // If we're in clicked state and within detection window, check for special attack animations
        if (isClicked && isWithinSpecDetectionWindow())
        {
            int animationId = player.getAnimation();
            
            // Check if this is a special attack animation
            if (isSpecialAttackAnimation(animationId))
            {
                // Special attack animation detected - clear the click state
                clearClickState();
                log.debug("Special attack animation detected: {}", animationId);
            }
        }
    }
    
    @Subscribe
    public void onGraphicChanged(GraphicChanged event)
    {
        // Only process local player graphics
        if (event.getActor() != client.getLocalPlayer())
        {
            return;
        }
        
        // If we're in clicked state and within detection window, any graphic change might indicate spec usage
        if (isClicked && isWithinSpecDetectionWindow())
        {
            // For now, we'll rely primarily on animation detection
            // Graphics can be added later with proper IDs if needed
            log.debug("Graphic changed during spec detection window");
        }
    }
    
    @Subscribe
    public void onChatMessage(ChatMessage event)
    {
        // Only process game messages
        if (event.getType() != ChatMessageType.GAMEMESSAGE)
        {
            return;
        }
        
        // Check for the "not enough power" message when in clicked state
        if (isClicked && event.getMessage().equals("You don't have enough power left."))
        {
            // Failed special attack attempt - clear the click state immediately
            clearClickState();
            log.debug("Special attack failed - not enough power");
        }
    }

    private void updateSpecBarState()
    {
        // Use cached widget detection for performance
        Widget specBarWidget = getCachedSpecialAttackWidget();
        if (specBarWidget == null || specBarWidget.isHidden())
        {
            isHovering = false;
            return;
        }

        net.runelite.api.Point mousePos = client.getMouseCanvasPosition();
        Rectangle specBarBounds = specBarWidget.getBounds();
        
        if (mousePos != null && specBarBounds != null)
        {
            Point awtMousePos = new Point(mousePos.getX(), mousePos.getY());
            isHovering = specBarBounds.contains(awtMousePos);
        }
        else
        {
            isHovering = false;
        }
    }
    
    private Widget getCachedSpecialAttackWidget()
    {
        long currentTime = System.currentTimeMillis();
        
        // Check if we have a valid cached widget
        if (cachedSpecBarWidget != null && 
            currentTime - lastWidgetSearchTime < WIDGET_CACHE_DURATION_MS)
        {
            // Verify cached widget is still valid
            if (!cachedSpecBarWidget.isHidden())
            {
                return cachedSpecBarWidget;
            }
        }
        
        // Cache expired or invalid, get the special attack widget using proper constants
        Widget specBarWidget = client.getWidget(InterfaceID.COMBAT, 42); // Special attack bar component
        if (specBarWidget != null && !specBarWidget.isHidden())
        {
            cachedSpecBarWidget = specBarWidget;
            lastWidgetSearchTime = currentTime;
            return specBarWidget;
        }
        
        return null;
    }
    
    private boolean isWithinSpecDetectionWindow()
    {
        return (System.currentTimeMillis() - lastSpecClickTime) < SPEC_DETECTION_WINDOW_MS;
    }
    
    private boolean isSpecialAttackAnimation(int animationId)
    {
        // Verified animation IDs from RuneLite source code
        // These are the actual special attack animations, not regular skilling animations
        switch (animationId)
        {
            // Dragon skilling tool special attacks (boost animations)
            case 2876: // Dragon axe special attack (stat boost)
            case 8347: // Dragon pickaxe special attack (stat boost)
            case 1167: // Dragon harpoon special attack (stat boost)
            
            // Infernal tool special attacks (same as dragon variants)
            case 2117: // Infernal axe special attack (verified from AnimationID.WOODCUTTING_INFERNAL)
            case 8348: // Infernal pickaxe special attack
            
            // Crystal tool special attacks
            case 8324: // Crystal axe special attack (verified from AnimationID.WOODCUTTING_CRYSTAL)
            case 8789: // Crystal pickaxe special attack
            case 8790: // Crystal harpoon special attack
            
            // Felling axe variants (2H axes with special attacks)
            case 10071: // Dragon felling axe special attack
            case 10072: // Crystal felling axe special attack
            case 10073: // Crystal felling axe (inactive) special attack
            case 10074: // 3rd age felling axe special attack
            

                return true;
            default:
                return false;
        }
    }

    private void triggerClickState()
    {
        isClicked = true;
        lastSpecClickTime = System.currentTimeMillis();
        // Click state will persist until spec is used (tracked by multiple methods)
    }
    
    private void clearClickState()
    {
        isClicked = false;
        lastClickClearTime = System.currentTimeMillis();
        // Hover effect will be suppressed for HOVER_SUPPRESS_DURATION_MS
    }

    public boolean isHovering()
    {
        return isHovering && config.enableHoverEffect();
    }

    public boolean isClicked()
    {
        return isClicked && config.enableClickEffect();
    }

    // Hover state getters (integrated color+opacity)
    public Color getHoverAreaColor()
    {
        return config.hoverAreaColor();
    }

    public Color getHoverBorderColor()
    {
        return config.hoverBorderColor();
    }

    // Click state getters (integrated color+opacity)
    public Color getClickAreaColor()
    {
        return config.clickAreaColor();
    }

    public Color getClickBorderColor()
    {
        return config.clickBorderColor();
    }

    // Idle state getters
    public boolean isIdleBorderEnabled()
    {
        return config.enableIdleBorder();
    }

    public Color getIdleAreaColor()
    {
        return config.idleAreaColor();
    }

    public Color getIdleBorderColor()
    {
        return config.idleBorderColor();
    }

    // Color preset getter
    public SpecBarConfig.ColorPreset getColorPreset()
    {
        return config.colorPreset();
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (!event.getGroup().equals("specbar"))
        {
            return;
        }

        // Check if the color preset was changed
        if (event.getKey().equals("colorPreset"))
        {
            SpecBarConfig.ColorPreset newPreset = SpecBarConfig.ColorPreset.valueOf(event.getNewValue());
            loadPresetToUI(newPreset);
        }
    }

    private enum ColorType
    {
        HOVER_AREA, HOVER_BORDER,
        CLICK_AREA, CLICK_BORDER,
        IDLE_AREA, IDLE_BORDER
    }

    private Color getPresetColor(SpecBarConfig.ColorPreset preset, ColorType colorType)
    {
        if (preset == SpecBarConfig.ColorPreset.CUSTOM)
        {
            // Return default colors for custom preset
            switch (colorType)
            {
                case HOVER_AREA: return new Color(135, 206, 250, 60);
                case HOVER_BORDER: return new Color(30, 144, 255, 150);
                case CLICK_AREA: return new Color(255, 69, 0, 80);
                case CLICK_BORDER: return new Color(220, 20, 60, 180);
                case IDLE_AREA: return new Color(128, 128, 128, 30);
                case IDLE_BORDER: return new Color(128, 128, 128, 100);
                default: return new Color(128, 128, 128, 100);
            }
        }

        // Return preset-specific colors
        switch (preset)
        {
            case CUSTOM:
                // Already handled above, but include for completeness
                return getPresetColor(SpecBarConfig.ColorPreset.CUSTOM, colorType);
            case CLASSIC_BLUE:
                switch (colorType)
                {
                    case HOVER_AREA: return new Color(100, 149, 237, 120);
                    case HOVER_BORDER: return new Color(65, 105, 225, 220);
                    case CLICK_AREA: return new Color(0, 100, 200, 160);
                    case CLICK_BORDER: return new Color(0, 50, 150, 255);
                    case IDLE_AREA: return new Color(173, 216, 230, 25);
                    case IDLE_BORDER: return new Color(135, 206, 250, 80);
                }
                break;
            case WARM_ORANGE:
                switch (colorType)
                {
                    case HOVER_AREA: return new Color(255, 165, 0, 120);
                    case HOVER_BORDER: return new Color(255, 140, 0, 220);
                    case CLICK_AREA: return new Color(220, 20, 60, 160);
                    case CLICK_BORDER: return new Color(180, 0, 0, 255);
                    case IDLE_AREA: return new Color(255, 218, 185, 25);
                    case IDLE_BORDER: return new Color(255, 160, 122, 80);
                }
                break;
            case NATURE_GREEN:
                switch (colorType)
                {
                    case HOVER_AREA: return new Color(144, 238, 144, 120);
                    case HOVER_BORDER: return new Color(34, 139, 34, 220);
                    case CLICK_AREA: return new Color(0, 128, 0, 160);
                    case CLICK_BORDER: return new Color(0, 100, 0, 255);
                    case IDLE_AREA: return new Color(240, 255, 240, 25);
                    case IDLE_BORDER: return new Color(152, 251, 152, 80);
                }
                break;
            case ROYAL_PURPLE:
                switch (colorType)
                {
                    case HOVER_AREA: return new Color(147, 112, 219, 120);
                    case HOVER_BORDER: return new Color(138, 43, 226, 220);
                    case CLICK_AREA: return new Color(128, 0, 128, 160);
                    case CLICK_BORDER: return new Color(75, 0, 130, 255);
                    case IDLE_AREA: return new Color(221, 160, 221, 25);
                    case IDLE_BORDER: return new Color(186, 85, 211, 80);
                }
                break;
            case DARK_THEME:
                switch (colorType)
                {
                    case HOVER_AREA: return new Color(96, 96, 96, 120);
                    case HOVER_BORDER: return new Color(160, 160, 160, 220);
                    case CLICK_AREA: return new Color(32, 32, 32, 160);
                    case CLICK_BORDER: return new Color(220, 220, 220, 255);
                    case IDLE_AREA: return new Color(48, 48, 48, 25);
                    case IDLE_BORDER: return new Color(80, 80, 80, 80);
                }
                break;
        }
        
        // Fallback to custom colors
        return getPresetColor(SpecBarConfig.ColorPreset.CUSTOM, colorType);
    }

    // Backup storage for custom settings
    private Color customHoverArea = null;
    private Color customHoverBorder = null;
    private Color customClickArea = null;
    private Color customClickBorder = null;
    private Color customIdleArea = null;
    private Color customIdleBorder = null;
    private SpecBarConfig.ColorPreset lastPreset = SpecBarConfig.ColorPreset.CUSTOM;

    /**
     * Loads preset values into the UI fields while preserving custom settings.
     * This allows users to switch between presets and custom without losing their custom values.
     */
    private void loadPresetToUI(SpecBarConfig.ColorPreset preset)
    {
        // If switching from CUSTOM to a preset, backup the current custom values
        if (lastPreset == SpecBarConfig.ColorPreset.CUSTOM && preset != SpecBarConfig.ColorPreset.CUSTOM)
        {
            backupCustomSettings();
        }
        
        // If switching to CUSTOM from a preset, restore the backed up custom values
        if (preset == SpecBarConfig.ColorPreset.CUSTOM && lastPreset != SpecBarConfig.ColorPreset.CUSTOM)
        {
            restoreCustomSettings();
            lastPreset = preset;
            return;
        }
        
        // If switching between presets (not involving CUSTOM), just load the new preset
        if (preset != SpecBarConfig.ColorPreset.CUSTOM)
        {
            loadPresetValues(preset);
        }
        
        lastPreset = preset;
    }
    
    /**
     * Backs up the current custom color settings before switching to a preset
     */
    private void backupCustomSettings()
    {
        customHoverArea = config.hoverAreaColor();
        customHoverBorder = config.hoverBorderColor();
        customClickArea = config.clickAreaColor();
        customClickBorder = config.clickBorderColor();
        customIdleArea = config.idleAreaColor();
        customIdleBorder = config.idleBorderColor();
        
        log.debug("Backed up custom settings before switching to preset");
    }
    
    /**
     * Restores the previously backed up custom settings
     */
    private void restoreCustomSettings()
    {
        if (customHoverArea != null)
        {
            configManager.setConfiguration("specbar", "hoverAreaColor", customHoverArea);
            configManager.setConfiguration("specbar", "hoverBorderColor", customHoverBorder);
            configManager.setConfiguration("specbar", "clickAreaColor", customClickArea);
            configManager.setConfiguration("specbar", "clickBorderColor", customClickBorder);
            configManager.setConfiguration("specbar", "idleAreaColor", customIdleArea);
            configManager.setConfiguration("specbar", "idleBorderColor", customIdleBorder);
            
            log.debug("Restored custom settings");
        }
    }
    
    /**
     * Loads preset values into the UI configuration
     */
    private void loadPresetValues(SpecBarConfig.ColorPreset preset)
    {
        Color hoverArea = getPresetColor(preset, ColorType.HOVER_AREA);
        Color hoverBorder = getPresetColor(preset, ColorType.HOVER_BORDER);
        Color clickArea = getPresetColor(preset, ColorType.CLICK_AREA);
        Color clickBorder = getPresetColor(preset, ColorType.CLICK_BORDER);
        Color idleArea = getPresetColor(preset, ColorType.IDLE_AREA);
        Color idleBorder = getPresetColor(preset, ColorType.IDLE_BORDER);

        configManager.setConfiguration("specbar", "hoverAreaColor", hoverArea);
        configManager.setConfiguration("specbar", "hoverBorderColor", hoverBorder);
        configManager.setConfiguration("specbar", "clickAreaColor", clickArea);
        configManager.setConfiguration("specbar", "clickBorderColor", clickBorder);
        configManager.setConfiguration("specbar", "idleAreaColor", idleArea);
        configManager.setConfiguration("specbar", "idleBorderColor", idleBorder);
        
        log.debug("Loaded preset values for: {}", preset);
    }

    @Provides
    SpecBarConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(SpecBarConfig.class);
    }
}

package com.specbar;

import org.junit.Test;
import java.awt.Color;

import static org.junit.Assert.*;

/**
 * Test class for SpecBarPlugin - compatible with IntelliJ RuneLite project
 * These tests verify basic functionality without requiring RuneLite runtime dependencies
 */
public class SpecBarPluginTest
{
    @Test
    public void testPluginCreation()
    {
        // Simple test to verify the plugin can be instantiated
        SpecBarPlugin plugin = new SpecBarPlugin();
        assertNotNull("Plugin should be created successfully", plugin);
    }

    @Test
    public void testConfigDefaults()
    {
        // Test that config interface has proper default values
        SpecBarConfig config = new SpecBarConfig() {};
        
        assertTrue("Hover effect should be enabled by default", config.enableHoverEffect());
        assertTrue("Click effect should be enabled by default", config.enableClickEffect());
        
        // Test hover settings (integrated color+opacity)
        assertEquals(new Color(135, 206, 250, 60), config.hoverAreaColor());
        assertEquals(new Color(30, 144, 255, 180), config.hoverBorderColor());
        
        // Test click settings (integrated color+opacity)
        assertEquals(new Color(255, 165, 0, 100), config.clickAreaColor());
        assertEquals(new Color(255, 69, 0, 220), config.clickBorderColor());
        
        // Test effect settings
        assertTrue(config.enableHoverEffect());
        assertTrue(config.enableClickEffect());
        assertFalse(config.hideSpecBarText()); // Should be disabled by default
        assertFalse(config.enableIdleBorder()); // Should be disabled by default
        
        // Test idle state settings
        assertEquals(new Color(128, 128, 128, 30), config.idleAreaColor());
        assertEquals(new Color(128, 128, 128, 100), config.idleBorderColor());
        
        // Test color preset setting
        assertEquals(SpecBarConfig.ColorPreset.CUSTOM, config.colorPreset());
    }

    @Test
    public void testOverlayClassExists()
    {
        // Simple test to verify overlay class structure exists
        try {
            Class<?> overlayClass = Class.forName("com.specbar.SpecBarOverlay");
            assertNotNull("SpecBarOverlay class should exist", overlayClass);
        } catch (ClassNotFoundException e) {
            fail("SpecBarOverlay class should be found and loadable");
        }
    }

    @Test
    public void testPluginDescriptor()
    {
        // Verify the plugin has the required RuneLite plugin descriptor
        Class<SpecBarPlugin> pluginClass = SpecBarPlugin.class;
        assertTrue("Plugin should have PluginDescriptor annotation",
                pluginClass.isAnnotationPresent(net.runelite.client.plugins.PluginDescriptor.class));
        
        net.runelite.client.plugins.PluginDescriptor descriptor = 
                pluginClass.getAnnotation(net.runelite.client.plugins.PluginDescriptor.class);
        
        assertEquals("Plugin name should match", "Spec Bar Utilities", descriptor.name());
        assertFalse("Plugin should have a description", descriptor.description().isEmpty());
        assertTrue("Plugin should have tags", descriptor.tags().length > 0);
    }
}

package com.specbar;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import com.specbar.SpecBarPlugin;

public class SpecBarTest
{
    public static void main(String[] args) throws Exception
    {
        ExternalPluginManager.loadBuiltin(SpecBarPlugin.class);
        RuneLite.main(args);
    }
}

