package com.github.m0bilebtw.eastereggs;

import com.github.m0bilebtw.CEngineerCompletedConfig;
import com.github.m0bilebtw.player.CEngineerPlayer;
import com.github.m0bilebtw.player.LoggedInState;
import com.github.m0bilebtw.sound.Sound;
import com.github.m0bilebtw.sound.SoundEngine;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.Scene;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GrandExchangeOfferChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Easter eggs that normal accounts can trigger in normal gameplay.
 * These are separate to the trolls that C Engineer can trigger.
 */
public class EasterEggTriggers {
    private static final int ID_OBJECT_LUMCASTLE_GROUND_LEVEL_STAIRCASE = 16671;
    private static final int WORLD_POINT_LUMCASTLE_STAIRCASE_NORTH_X = 3204;
    private static final int WORLD_POINT_LUMCASTLE_STAIRCASE_NORTH_Y = 3229;

    private static final String ZULRAH = "Zulrah";
    private static final int ZULRAH_KILL_TO_PB_MESSAGE_LENIENCY = 1;
    // Killcount and new pb patterns originally from runelite/ChatCommandsPlugin
    private static final Pattern KILLCOUNT_PATTERN = Pattern.compile("Your (?:completion count for |subdued |completed )?(.+?) (?:(?:kill|harvest|lap|completion) )?(?:count )?is: <col=ff0000>(\\d+)</col>");
    private static final Pattern NEW_PB_PATTERN = Pattern.compile("(?i)(?:(?:Fight |Lap |Challenge |Corrupted challenge )?duration:|Subdued in) <col=[0-9a-f]{6}>[0-9:]+(?:\\.\\d+)?</col> \\(new personal best\\)");
    private static final Pattern STRAY_DOG_GIVEN_BONES_REGEX = Pattern.compile("You give the dog some nice.*bones.*");

    @Inject
    private Client client;

    @Inject
    private CEngineerCompletedConfig config;

    @Inject
    private ScheduledExecutorService executor;

    @Inject
    private SoundEngine soundEngine;

    @Inject
    private CEngineerPlayer cEngineer;

    @Inject
    private LoggedInState loggedInState;

    private int lastGEOfferTick = -1;
    private int lastZulrahKillTick = -1;

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked) {
        if (!config.easterEggs())
            return;

        if (menuOptionClicked.getId() == ID_OBJECT_LUMCASTLE_GROUND_LEVEL_STAIRCASE && menuOptionClicked.getMenuOption().equals("Climb-up")) {
            Scene scene = client.getWorldView(menuOptionClicked.getMenuEntry().getWorldViewId()).getScene();
            LocalPoint lp = LocalPoint.fromScene(menuOptionClicked.getParam0(), menuOptionClicked.getParam1(), scene);
            WorldPoint wp = WorldPoint.fromLocal(client, lp);
            if (wp.getX() == WORLD_POINT_LUMCASTLE_STAIRCASE_NORTH_X && wp.getY() == WORLD_POINT_LUMCASTLE_STAIRCASE_NORTH_Y) {
                // Now we know this is the northern staircase only in Lumbridge castle ground floor
                cEngineer.sendChatIfEnabled("Please do not use the northern staircase, use the southern one instead.");
                soundEngine.playClip(Sound.EASTER_EGG_STAIRCASE, executor);
            }
        }
    }

    @Subscribe
    public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged offerEvent) {
        if (!config.easterEggs())
            return;

        if (loggedInState.isLoggedOut() || loggedInState.onlyJustLoggedIn(3)) {
            return; // Ignoring offer change as likely simply because user just logged in
        }

        GrandExchangeOffer offer = offerEvent.getOffer();
        if (offer.getItemId() == ItemID.TWISTED_BOW &&
                offer.getPrice() == 1 &&
                offer.getState() == GrandExchangeOfferState.SELLING &&
                // check ticks to avoid double detection because we get sent each offer twice
                (lastGEOfferTick == -1 || client.getTickCount() - lastGEOfferTick > 4)) {
            cEngineer.sendChatIfEnabled("Are you stupid? Did you just try to sell a twisted bow for 1gp?");
            soundEngine.playClip(Sound.EASTER_EGG_TWISTED_BOW_1GP, executor);
        }

        // save tick so that next time we get an offer, we can check it isn't the duplicate of this offer
        lastGEOfferTick = client.getTickCount();
    }

    @Subscribe
    public void onChatMessage(ChatMessage chatMessage) {
        if (chatMessage.getType() != ChatMessageType.GAMEMESSAGE && chatMessage.getType() != ChatMessageType.SPAM)
            return;

        if (!config.easterEggs())
            return;

        if (STRAY_DOG_GIVEN_BONES_REGEX.matcher(chatMessage.getMessage()).matches()) {
            cEngineer.sendChatIfEnabled("I love you.");
            soundEngine.playClip(Sound.EASTER_EGG_STRAYDOG_BONE, executor);
        } else {
            checkForZulrahPB(chatMessage);
        }
    }

    private void checkForZulrahPB(ChatMessage chatMessage) {
        Matcher kcMatcher = KILLCOUNT_PATTERN.matcher(chatMessage.getMessage());
        if (kcMatcher.find() && ZULRAH.equals(kcMatcher.group(1))) {
            lastZulrahKillTick = client.getTickCount();
            return;
        }

        Matcher pbMatcher = NEW_PB_PATTERN.matcher(chatMessage.getMessage());
        if (pbMatcher.find() && client.getTickCount() - lastZulrahKillTick <= ZULRAH_KILL_TO_PB_MESSAGE_LENIENCY) {
            // Player just got pb, and last zulrah kill was within a tick from now
            cEngineer.sendChatIfEnabled("Gz on the new personal best! Last time I got a pb here, I died on my HCIM!");
            soundEngine.playClip(Sound.EASTER_EGG_ZULRAH_PB, executor);
        }
    }
}

package com.github.m0bilebtw;

import com.github.m0bilebtw.announce.AnnouncementTriggers;
import com.github.m0bilebtw.eastereggs.EasterEggTriggers;
import com.github.m0bilebtw.player.CEngineerPlayer;
import com.github.m0bilebtw.player.LoggedInState;
import com.github.m0bilebtw.qol.QualityOfLifeTriggers;
import com.github.m0bilebtw.sound.SoundFileManager;
import com.github.m0bilebtw.trolls.TrollTriggers;
import com.google.inject.Provides;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import java.util.concurrent.ScheduledExecutorService;

@Slf4j
@PluginDescriptor(
        name = "C Engineer: Completed",
        description = "C Engineer announces when you complete an achievement",
        tags = {"c engineer", "stats", "levels", "quests", "diary", "announce"}
)

public class CEngineerCompletedPlugin extends Plugin {
    @Inject
    private Client client;

    @Getter(AccessLevel.PACKAGE)
    @Inject
    private ClientThread clientThread;

    @Inject
    private CEngineerCompletedConfig config;

    @Inject
    private ScheduledExecutorService executor;

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private EventBus eventBus;

    @Inject
    private CEngineerPlayer cEngineer;

    @Inject
    private AnnouncementTriggers announcementTriggers;

    @Inject
    private EasterEggTriggers easterEggTriggers;

    @Inject
    private TrollTriggers trollTriggers;

    @Inject
    private QualityOfLifeTriggers qolTriggers;

    @Inject
    private LoggedInState loggedInState;

    @Override
    protected void startUp() throws Exception {
        eventBus.register(cEngineer);
        eventBus.register(announcementTriggers);
        eventBus.register(easterEggTriggers);
        eventBus.register(trollTriggers);
        eventBus.register(qolTriggers);
        eventBus.register(loggedInState);
        loggedInState.setForCurrentGameState(client.getGameState());
        announcementTriggers.initialise();

        executor.submit(() -> SoundFileManager.prepareSoundFiles(okHttpClient, config.downloadStreamerTrolls()));
    }

    @Override
    protected void shutDown() throws Exception {
        eventBus.unregister(cEngineer);
        eventBus.unregister(announcementTriggers);
        eventBus.unregister(easterEggTriggers);
        eventBus.unregister(trollTriggers);
        eventBus.unregister(qolTriggers);
        eventBus.unregister(loggedInState);

        announcementTriggers.shutDown();
    }

    @Provides
    CEngineerCompletedConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(CEngineerCompletedConfig.class);
    }
}

package com.github.m0bilebtw.qol;

import com.github.m0bilebtw.CEngineerCompletedConfig;
import com.github.m0bilebtw.player.CEngineerPlayer;
import com.github.m0bilebtw.player.LoggedInState;
import com.github.m0bilebtw.sound.Sound;
import com.github.m0bilebtw.sound.SoundEngine;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.api.Player;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;

public class QualityOfLifeTriggers {
    private static final int INFERNAL_PARCHMENT_WARN_COOLDOWN = 36;
    private static final Set<Integer> BOUNTY_HUNTER_REGIONS = Set.of(13374, 13375, 13376, 13630, 13631, 13632, 13886, 13887, 13888);

    @Inject
    private Client client;

    @Inject
    private CEngineerCompletedConfig config;

    @Inject
    private ScheduledExecutorService executor;

    @Inject
    private SoundEngine soundEngine;

    @Inject
    private CEngineerPlayer cEngineer;

    @Inject
    private LoggedInState loggedInState;

    private int lastInfernalParchmentWarningTick = -1;

    @Subscribe
    public void onVarbitChanged(VarbitChanged varbitChanged) {
        if (varbitChanged.getVarbitId() == VarbitID.INSIDE_WILDERNESS && varbitChanged.getValue() == 1) {
            checkAndWarnForUnparchmentedInfernal();
        }
    }

    private void checkAndWarnForUnparchmentedInfernal() {
        if (!config.announceNonTrouverInfernal())
            return;

        if (loggedInState.isLoggedOut())
            return;

        if (lastInfernalParchmentWarningTick != -1 && client.getTickCount() - lastInfernalParchmentWarningTick < INFERNAL_PARCHMENT_WARN_COOLDOWN)
            return;

        if (atBountyHunter())
            return;

        ItemContainer equipment = client.getItemContainer(InventoryID.WORN);
        boolean warnForEquip = equipment != null &&
                (equipment.contains(ItemID.INFERNAL_CAPE) || equipment.contains(ItemID.SKILLCAPE_MAX_INFERNALCAPE_DUMMY));
        ItemContainer inventory = client.getItemContainer(InventoryID.INV);
        boolean warnForInvent = inventory != null &&
                (inventory.contains(ItemID.INFERNAL_CAPE) || inventory.contains(ItemID.SKILLCAPE_MAX_INFERNALCAPE_DUMMY));

        if (warnForEquip || warnForInvent) {
            lastInfernalParchmentWarningTick = client.getTickCount();
            cEngineer.sendChatIfEnabled("Your infernal cape is not parched!");
            soundEngine.playClip(Sound.QOL_NON_PARCH_INFERNAL, executor);
        }
    }

    private boolean atBountyHunter() {
        Player player = client.getLocalPlayer();
        if (player == null)
            return false;

        int regionId = player.getWorldLocation().getRegionID();
        return BOUNTY_HUNTER_REGIONS.contains(regionId);
    }
}

package com.github.m0bilebtw.announce;

import com.github.m0bilebtw.CEngineerCompletedConfig;
import com.github.m0bilebtw.player.CEngineerPlayer;
import com.github.m0bilebtw.player.LoggedInState;
import com.github.m0bilebtw.sound.Sound;
import com.github.m0bilebtw.sound.SoundEngine;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Experience;
import net.runelite.api.GameState;
import net.runelite.api.Skill;
import net.runelite.api.annotations.Varbit;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.ItemStack;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.util.Collection;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Pattern;

@Slf4j
public class AnnouncementTriggers {
    private static final Pattern COLLECTION_LOG_ITEM_REGEX = Pattern.compile("New item added to your collection log:.*");
    private static final Pattern COMBAT_TASK_REGEX = Pattern.compile("CA_ID:\\d+\\|Congratulations, you've completed an? \\w+ combat task:.*");
    private static final Pattern LEAGUES_TASK_REGEX = Pattern.compile("Congratulations, you've completed an? \\w+ task:.*");
    private static final Pattern GRID_TILE_REGEX = Pattern.compile("Congratulations, you've completed the Grid Tile:.*");
    private static final Pattern QUEST_REGEX = Pattern.compile("Congratulations, you've completed a quest:.*");
    private static final Pattern SLAYER_TASK_REGEX = Pattern.compile("You have completed your task! You killed .*. You gained .* xp.");
    private static final String HUNTER_RUMOUR_MESSAGE = Text.standardize("You find a rare piece of the creature! You should take it back to the Hunter Guild.");
    private static final String HUNTER_RUMOUR_FULL_INV_MESSAGE = Text.standardize("You find a rare piece of the creature! Though without space in your inventory, it drops to the ground.");
    private static final String HUNTER_RUMOUR_FULL_INV_DISCARDED_MESSAGE = Text.standardize("You have found a rare piece of the creature! You then discard it as you had no inventory space to pick it up.");
    private static final String FARMING_CONTRACT_MESSAGE = Text.standardize("You've completed a Farming Guild Contract. You should return to Guildmaster Jane.");

    private static final Random random = new Random();

    private static final int[] VARBIT_IDS_ACHIEVEMENT_DIARIES = {
            VarbitID.ARDOUGNE_DIARY_EASY_COMPLETE,   VarbitID.ARDOUGNE_DIARY_MEDIUM_COMPLETE,   VarbitID.ARDOUGNE_DIARY_HARD_COMPLETE,   VarbitID.ARDOUGNE_DIARY_ELITE_COMPLETE,
            VarbitID.DESERT_DIARY_EASY_COMPLETE, 	 VarbitID.DESERT_DIARY_MEDIUM_COMPLETE, 	VarbitID.DESERT_DIARY_HARD_COMPLETE, 	 VarbitID.DESERT_DIARY_ELITE_COMPLETE,
            VarbitID.FALADOR_DIARY_EASY_COMPLETE,    VarbitID.FALADOR_DIARY_MEDIUM_COMPLETE,    VarbitID.FALADOR_DIARY_HARD_COMPLETE,    VarbitID.FALADOR_DIARY_ELITE_COMPLETE,
            VarbitID.KANDARIN_DIARY_EASY_COMPLETE,   VarbitID.KANDARIN_DIARY_MEDIUM_COMPLETE,   VarbitID.KANDARIN_DIARY_HARD_COMPLETE,   VarbitID.KANDARIN_DIARY_ELITE_COMPLETE,
            VarbitID.ATJUN_EASY_DONE,                VarbitID.ATJUN_MED_DONE,                   VarbitID.ATJUN_HARD_DONE,                VarbitID.KARAMJA_DIARY_ELITE_COMPLETE,
            VarbitID.KOUREND_DIARY_EASY_COMPLETE,    VarbitID.KOUREND_DIARY_MEDIUM_COMPLETE,    VarbitID.KOUREND_DIARY_HARD_COMPLETE,    VarbitID.KOUREND_DIARY_ELITE_COMPLETE,
            VarbitID.LUMBRIDGE_DIARY_EASY_COMPLETE,  VarbitID.LUMBRIDGE_DIARY_MEDIUM_COMPLETE,  VarbitID.LUMBRIDGE_DIARY_HARD_COMPLETE,  VarbitID.LUMBRIDGE_DIARY_ELITE_COMPLETE,
            VarbitID.MORYTANIA_DIARY_EASY_COMPLETE,  VarbitID.MORYTANIA_DIARY_MEDIUM_COMPLETE,  VarbitID.MORYTANIA_DIARY_HARD_COMPLETE,  VarbitID.MORYTANIA_DIARY_ELITE_COMPLETE,
            VarbitID.VARROCK_DIARY_EASY_COMPLETE,    VarbitID.VARROCK_DIARY_MEDIUM_COMPLETE,    VarbitID.VARROCK_DIARY_HARD_COMPLETE,    VarbitID.VARROCK_DIARY_ELITE_COMPLETE,
            VarbitID.WESTERN_DIARY_EASY_COMPLETE,    VarbitID.WESTERN_DIARY_MEDIUM_COMPLETE,    VarbitID.WESTERN_DIARY_HARD_COMPLETE,    VarbitID.WESTERN_DIARY_ELITE_COMPLETE,
            VarbitID.WILDERNESS_DIARY_EASY_COMPLETE, VarbitID.WILDERNESS_DIARY_MEDIUM_COMPLETE, VarbitID.WILDERNESS_DIARY_HARD_COMPLETE, VarbitID.WILDERNESS_DIARY_ELITE_COMPLETE,
            VarbitID.FREMENNIK_DIARY_EASY_COMPLETE,  VarbitID.FREMENNIK_DIARY_MEDIUM_COMPLETE,  VarbitID.FREMENNIK_DIARY_HARD_COMPLETE,  VarbitID.FREMENNIK_DIARY_ELITE_COMPLETE
    };

    private static final Set<Integer> badCollectionLogNotificationSettingValues = Set.of(0, 2);

    @Inject
    private Client client;

    @Getter(AccessLevel.PACKAGE)
    @Inject
    private ClientThread clientThread;

    @Inject
    private ChatMessageManager chatMessageManager;

    @Inject
    private ScheduledExecutorService executor;

    @Inject
    private CEngineerCompletedConfig config;

    @Inject
    private ConfigManager configManager;

    @Inject
    private SoundEngine soundEngine;

    @Inject
    private CEngineerPlayer cEngineer;

    @Inject
    private LoggedInState loggedInState;

    private final Map<Skill, Integer> oldExperience = new EnumMap<>(Skill.class);
    private final Map<Integer, Integer> oldAchievementDiaries = new HashMap<>();

    private int lastColLogSettingWarning = -1;
    private boolean delayedCoXColLogAnnouncementPending = false;

    public void initialise() {
        clientThread.invoke(this::initialiseOldXPAndDiaryMaps);
    }

    public void shutDown() {
        oldExperience.clear();
        oldAchievementDiaries.clear();
    }

    private void initialiseOldXPAndDiaryMaps() {
        if (loggedInState.isLoggedOut()) {
            oldExperience.clear();
            oldAchievementDiaries.clear();
            return;
        }
        for (final Skill skill : Skill.values()) {
            oldExperience.put(skill, client.getSkillExperience(skill));
        }
        for (@Varbit int diary : VARBIT_IDS_ACHIEVEMENT_DIARIES) {
            int value = client.getVarbitValue(diary);
            oldAchievementDiaries.put(diary, value);
        }
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        if (delayedCoXColLogAnnouncementPending) {
            delayedCoXColLogAnnouncementPending = isInChambersOfXeric();
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        GameState gameState = event.getGameState();

        if (gameState != GameState.LOGGED_IN) {
            if (gameState != GameState.CONNECTION_LOST) {
                oldExperience.clear();
                oldAchievementDiaries.clear();
            }
            lastColLogSettingWarning = client.getTickCount(); // avoid warning during DC
        } else if (config.needToInformAboutDelayedCoXColLog()) {
            configManager.setConfiguration(CEngineerCompletedConfig.GROUP, CEngineerCompletedConfig.DELAY_COX_COL_LOG_HIDDEN_NOTIFY_CONFIG, false);
            sendHighlightedMessageForDelayedCoXColLogSetting();
        }
    }

    @Subscribe
    public void onStatChanged(StatChanged statChanged) {
        final Skill skill = statChanged.getSkill();

        // Modified from Nightfirecat's virtual level ups plugin as this info isn't (yet?) built in to statChanged event
        final int xpAfter = client.getSkillExperience(skill);
        final int levelAfter = Experience.getLevelForXp(xpAfter);
        final int xpBefore = oldExperience.getOrDefault(skill, -1);
        final int levelBefore = xpBefore == -1 ? -1 : Experience.getLevelForXp(xpBefore);

        oldExperience.put(skill, xpAfter);

        // Do not proceed if any of the following are true:
        //  * xpBefore == -1              (don't fire when first setting new known value)
        //  * xpAfter <= xpBefore         (do not allow 200m -> 200m exp drops)
        //  * levelBefore >= levelAfter   (stop if if we're not actually reaching a new level)
        //  * levelAfter > MAX_REAL_LEVEL && config says don't include virtual (level is virtual and config ignores virtual)
        if (xpBefore == -1 || xpAfter <= xpBefore || levelBefore >= levelAfter ||
                (levelAfter > Experience.MAX_REAL_LEVEL && !config.announceLevelUpIncludesVirtual())) {
            return;
        }

        // If we get here, 'skill' was leveled up!
        if (config.announceLevelUp()) {
            cEngineer.sendChatIfEnabled("Level up: completed.");
            soundEngine.playClip(Sound.LEVEL_UP, executor);
        }
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged varbitChanged) {
        if (varbitChanged.getVarbitId() == VarbitID.OPTION_COLLECTION_NEW_ITEM) {
            checkAndWarnForCollectionLogNotificationSetting(varbitChanged.getValue());
        }

        // As we can't listen to specific varbits, we get a tonne of events BEFORE the game has even set the player's
        // diary varbits correctly, meaning it assumes every diary is on 0, then suddenly every diary that has been
        // completed gets updated to the true value and tricks the plugin into thinking they only just finished it.
        // To avoid this behaviour, we make sure the current tick count is sufficiently high that we've already passed
        // the initial wave of varbit changes from logging in.
        if (loggedInState.isLoggedOut() || loggedInState.onlyJustLoggedIn(8)) {
            return; // Ignoring varbit change as only just logged in
        }

        // Apparently I can't check if it's a particular varbit using the names from Varbits enum, so this is the way
        for (@Varbit int diary : VARBIT_IDS_ACHIEVEMENT_DIARIES) {
            int newValue = client.getVarbitValue(diary);
            int previousValue = oldAchievementDiaries.getOrDefault(diary, -1);
            oldAchievementDiaries.put(diary, newValue);
            if (config.announceAchievementDiary() && previousValue != -1 && previousValue != newValue && isAchievementDiaryCompleted(diary, newValue)) {
                // value was not unknown (we know the previous value), value has changed, and value indicates diary is completed now
                cEngineer.sendChatIfEnabled("Achievement diary: completed.");
                soundEngine.playClip(Sound.ACHIEVEMENT_DIARY, executor);
            }
        }
    }

    private void checkAndWarnForCollectionLogNotificationSetting(int newVarbitValue) {
        if (!config.announceCollectionLog() ||
                loggedInState.isLoggedOut() ||
                !badCollectionLogNotificationSettingValues.contains(newVarbitValue))
            return;

        if (lastColLogSettingWarning == -1 || client.getTickCount() - lastColLogSettingWarning > 16) {
            lastColLogSettingWarning = client.getTickCount();
            sendHighlightedMessageForColLogNotifSetting();
        }
    }

    private void sendHighlightedMessageForColLogNotifSetting() {
        sendHighlightedMessage("Please enable \"Collection log - New addition notification\" in your game settings for C Engineer to know when to announce it! (The chat message one, pop-up doesn't matter)");
    }

    private void sendHighlightedMessageForLeaguesTaskSetting() {
        sendHighlightedMessage("C Engineer announcing leagues tasks might get spammy, but remember you can disable these announcements while keeping the others active in the plugin settings!");
    }

    private void sendHighlightedMessageForDelayedCoXColLogSetting() {
        sendHighlightedMessage("C Engineer announcing CoX collection log slots now delays until you open the chest, but you can change it back in the plugin settings!");
    }

    private void sendHighlightedMessage(String message) {
        String highlightedMessage = new ChatMessageBuilder()
                .append(ChatColorType.HIGHLIGHT)
                .append(message)
                .build();

        chatMessageManager.queue(QueuedMessage.builder()
                .type(ChatMessageType.CONSOLE)
                .runeLiteFormattedMessage(highlightedMessage)
                .build());
    }

    private boolean isAchievementDiaryCompleted(int diary, int value) {
        switch (diary) {
            case VarbitID.ATJUN_EASY_DONE:
            case VarbitID.ATJUN_MED_DONE:
            case VarbitID.ATJUN_HARD_DONE:
                return value == 2; // jagex, why?
            default:
                return value == 1;
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (CEngineerCompletedConfig.GROUP.equals(event.getGroup())) {

			if ("announcementVolume".equals(event.getKey()) || "selectAnySoundToTestPlayIt".equals(event.getKey())) {
				soundEngine.playClip(config.selectAnySoundToTestPlayIt(), executor);
			} else if ("announceCollectionLog".equals(event.getKey())) {
                clientThread.invokeLater(() ->
                        checkAndWarnForCollectionLogNotificationSetting(client.getVarbitValue(VarbitID.OPTION_COLLECTION_NEW_ITEM)));
            }
        }
    }

    @Subscribe
    public void onChatMessage(ChatMessage chatMessage) {
        if (chatMessage.getType() != ChatMessageType.GAMEMESSAGE && chatMessage.getType() != ChatMessageType.SPAM)
            return;

        if (config.announceCollectionLog() && COLLECTION_LOG_ITEM_REGEX.matcher(chatMessage.getMessage()).matches()) {
            if (config.delayCoXCollectionLogAnnouncements() && isInChambersOfXeric()) {
                delayedCoXColLogAnnouncementPending = true;
            } else {
                announceColLog();
            }

        } else if (config.announceQuestCompletion() && QUEST_REGEX.matcher(chatMessage.getMessage()).matches()) {
            cEngineer.sendChatIfEnabled("Quest: completed.");
            soundEngine.playClip(Sound.QUEST, executor);

        } else if (config.announceCombatAchievement() && COMBAT_TASK_REGEX.matcher(chatMessage.getMessage()).matches()) {
            cEngineer.sendChatIfEnabled("Combat task: completed.");
            soundEngine.playClip(Sound.COMBAT_TASK, executor);

        } else if (config.announceLeaguesTasks() && LEAGUES_TASK_REGEX.matcher(chatMessage.getMessage()).matches()) {
            cEngineer.sendChatIfEnabled("Leagues task: completed.");
            soundEngine.playClip(Sound.LEAGUES_TASK, executor);

            if (config.needToRemindAboutDisablingLeaguesTasks()) {
                configManager.setConfiguration(CEngineerCompletedConfig.GROUP, CEngineerCompletedConfig.LEAGUES_TASK_HIDDEN_REMINDER_CONFIG, false);
                sendHighlightedMessageForLeaguesTaskSetting();
            }

        } else if (config.announceGridTiles() && GRID_TILE_REGEX.matcher(chatMessage.getMessage()).matches()) {
            cEngineer.sendChatIfEnabled("Grid task: completed.");
            soundEngine.playClip(Sound.GRID_TASK, executor);

        } else if (config.announceSlayerTasks() && SLAYER_TASK_REGEX.matcher(Text.removeTags(chatMessage.getMessage())).matches()) {
            cEngineer.sendChatIfEnabled("Slayer task: completed.");
            soundEngine.playClip(Sound.SLAYER_TASK, executor);
            return;
        }

        String standardizedMessage = Text.standardize(chatMessage.getMessage());
        if (config.announceHunterRumours() && (
                HUNTER_RUMOUR_MESSAGE.equals(standardizedMessage) || HUNTER_RUMOUR_FULL_INV_MESSAGE.equals(standardizedMessage)
        )) {
            cEngineer.sendChatIfEnabled("Hunter Rumour: completed.");
            soundEngine.playClip(Sound.HUNTER_RUMOUR, executor);

        } else if (config.announceHunterRumours() && HUNTER_RUMOUR_FULL_INV_DISCARDED_MESSAGE.equals(standardizedMessage)) {
            cEngineer.sendChatIfEnabled("Hunter Rumour: not completed! You need more inventory space!");
            soundEngine.playClip(Sound.HUNTER_RUMOUR_NOT_COMPLETED, executor);

        } else if (config.announceFarmingContracts() && FARMING_CONTRACT_MESSAGE.equals(standardizedMessage)) {
            cEngineer.sendChatIfEnabled("Farming Contract: completed.");
            soundEngine.playClip(Sound.FARMING_CONTRACT, executor);
        }
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded widgetLoaded) {
        if (delayedCoXColLogAnnouncementPending && widgetLoaded.getGroupId() == InterfaceID.RAIDS_REWARDS) {
            delayedCoXColLogAnnouncementPending = false;
            announceColLog();
        }
    }

    private void announceColLog() {
        cEngineer.sendChatIfEnabled("Collection log slot: completed.");
        soundEngine.playClip(Sound.COLLECTION_LOG_SLOT, executor);
    }

    @Subscribe
    public void onNpcLootReceived(NpcLootReceived npcLootReceived) {
        Collection<ItemStack> loot = npcLootReceived.getItems();
        for (ItemStack itemStack : loot) {
            int itemId = itemStack.getId();

            if (itemId == ItemID.HOSDUN_GRUBBY_KEY && config.announceGrubbyKeyDrop()) {
                cEngineer.sendChatIfEnabled("Another grubby key.");
                soundEngine.playClip(Sound.GRUBBY_KEY, executor);

            } else if (itemId == ItemID.SLAYER_WILDERNESS_KEY && config.announceLarransKeyDrop()) {
                cEngineer.sendChatIfEnabled("Another Larran's key.");
                soundEngine.playClip(Sound.LARRANS_KEY, executor);

            } else if (itemId == ItemID.KONAR_KEY && config.announceBrimstoneKeyDrop()) {
                cEngineer.sendChatIfEnabled("Another brimstone key.");
                soundEngine.playClip(Sound.BRIMSTONE_KEY, executor);
            }
        }
    }

    @Subscribe
    public void onActorDeath(ActorDeath actorDeath) {
        if (actorDeath.getActor() != client.getLocalPlayer())
            return;

        // Death easter egg and normal announcement kept together to make it one or the other, never both
        if (config.easterEggs() && cEngineer.wasFightingMeRecently()) {
            diedToCEngineer();
        } else if (config.announceDeath()) {
            diedToAnythingElse();
        }
    }

    private void diedToCEngineer() {
        if (random.nextBoolean()) {
            cEngineer.sendChatIfEnabled("Dying to " + CEngineerPlayer.RSN + ": completed.");
        } else {
            cEngineer.sendChatIfEnabled("Sit");
        }
        soundEngine.playClip(Sound.DEATH_TO_C_ENGINEER, executor);
    }

    private void diedToAnythingElse() {
        cEngineer.sendChatIfEnabled("Dying on my HCIM: completed.");
        soundEngine.playClip(Sound.DEATH, executor);
    }

    private boolean isInChambersOfXeric() {
        return client.getVarbitValue(VarbitID.RAIDS_CLIENT_INDUNGEON) == 1;
    }
}

package com.github.m0bilebtw.sound;

import com.github.m0bilebtw.CEngineerCompletedConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.audio.AudioPlayer;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;
import java.io.IOException;
import java.time.Duration;
import java.util.concurrent.Executor;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Singleton
@Slf4j
public class SoundEngine {

    @Inject
    private CEngineerCompletedConfig config;

    @Inject
    private AudioPlayer audioPlayer;

    public void playClip(Sound sound, Executor executor) {
        executor.execute(() -> playClip(sound));
    }

    public void playClip(Sound sound, ScheduledExecutorService executor, Duration initialDelay) {
        executor.schedule(() -> playClip(sound), initialDelay.toMillis(), TimeUnit.MILLISECONDS);
    }

    private void playClip(Sound sound) {
        float gain = 20f * (float) Math.log10(config.announcementVolume() / 100f);

        try {
            audioPlayer.play(SoundFileManager.getSoundFile(sound), gain);
        } catch (IOException | UnsupportedAudioFileException | LineUnavailableException e) {
            log.warn("Failed to load C Engineer sound {}", sound, e);
        }
    }
}

package com.github.m0bilebtw.sound;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.util.function.Predicate.not;

@Slf4j
public class SoundFileManager {
    private SoundFileManager() {}

    private static final Path DOWNLOAD_DIR = Path.of(RuneLite.RUNELITE_DIR.getPath(), "c-engineer-sounds");
    private static final String DELETE_WARNING_FILENAME = "_EXTRA_FILES_WILL_BE_DELETED_BUT_FOLDERS_WILL_REMAIN";
    private static final Path DELETE_WARNING_FILE = DOWNLOAD_DIR.resolve(DELETE_WARNING_FILENAME);

    private static final HttpUrl RAW_GITHUB = HttpUrl.parse("https://raw.githubusercontent.com/m0bilebtw/c-engineer-completed/sounds");

    public static File getSoundFile(Sound sound) {
        return DOWNLOAD_DIR.resolve(sound.getResourceName()).toFile();
    }

    public static void prepareSoundFiles(OkHttpClient okHttpClient, boolean downloadStreamerTrolls) {
        ensureDownloadDirectoryExists();
        deleteUndesiredFilesIgnoringFolders(downloadStreamerTrolls);
        downloadNotYetPresentSounds(okHttpClient, downloadStreamerTrolls);
    }

    private static void ensureDownloadDirectoryExists() {
       try {
           if (!Files.exists(DOWNLOAD_DIR))
                Files.createDirectories(DOWNLOAD_DIR);
            Files.createFile(DELETE_WARNING_FILE);
        } catch (FileAlreadyExistsException ignored) {
            /* ignored */
        } catch (IOException e) {
            log.error("Could not create download directory or warning file", e);
        }
    }

    private static void deleteUndesiredFilesIgnoringFolders(boolean keepStreamerTrolls) {
        Set<String> desiredSoundFileNames = getDesiredSounds(keepStreamerTrolls)
                .map(Sound::getResourceName)
                .collect(Collectors.toSet());

        Set<Path> toDelete = getFilesPresent().stream()
                .filter(not(desiredSoundFileNames::contains))
                .map(DOWNLOAD_DIR::resolve)
                .collect(Collectors.toSet());
        try {
            for (Path pathToDelete : toDelete) {
                Files.delete(pathToDelete);
            }
        } catch (IOException e) {
            log.error("Failed to delete disused sound files", e);
        }
    }

    private static void downloadNotYetPresentSounds(OkHttpClient okHttpClient, boolean downloadStreamerTrolls) {
        getFilesToDownload(downloadStreamerTrolls)
                .forEach(filename -> downloadFilename(okHttpClient, filename));
    }

    private static void downloadFilename(OkHttpClient okHttpClient, String filename) {
        if (RAW_GITHUB == null) {
            // Hush intellij, it's okay, the potential NPE can't hurt you now
            log.error("C Engineer Completed could not download sounds due to an unexpected null RAW_GITHUB value");
            return;
        }
        HttpUrl soundUrl = RAW_GITHUB.newBuilder().addPathSegment(filename).build();
        Request request = new Request.Builder().url(soundUrl).build();
        try (Response res = okHttpClient.newCall(request).execute()) {
            if (res.body() != null)
                Files.copy(new BufferedInputStream(res.body().byteStream()), DOWNLOAD_DIR.resolve(filename), StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            log.error("C Engineer Completed could not download sounds", e);
        }
    }

    private static Stream<String> getFilesToDownload(boolean downloadStreamerTrolls) {
        Set<String> filesAlreadyPresent = getFilesPresent();

        return getDesiredSounds(downloadStreamerTrolls)
                .map(Sound::getResourceName)
                .filter(not(filesAlreadyPresent::contains));
    }

    private static Set<String> getFilesPresent() {
        try (Stream<Path> paths = Files.list(DOWNLOAD_DIR)) {
            return paths
                    .filter(path -> !Files.isDirectory(path))
                    .map(Path::toFile)
                    .map(File::getName)
                    .filter(filename -> !DELETE_WARNING_FILENAME.equals(filename))
                    .collect(Collectors.toSet());
        } catch (IOException e) {
            log.warn("Could not list files in {}, assuming it to be empty", DOWNLOAD_DIR);
            return Set.of();
        }
    }

    private static Stream<Sound> getDesiredSounds(boolean includeStreamerTrolls) {
        return Arrays.stream(Sound.values())
                .filter(sound -> includeStreamerTrolls || !sound.isStreamerTroll());
    }
}

package com.github.m0bilebtw.sound;

import lombok.Getter;

import java.util.Random;

public enum Sound {
    LEVEL_UP("LevelUpCompleted_r2.wav"),
    QUEST("QuestCompleted_r2.wav"),
    COLLECTION_LOG_SLOT("ColLogSlotCompleted_r1.wav"),
    COMBAT_TASK("CombatTaskCompleted_r1.wav"),
    ACHIEVEMENT_DIARY("AchieveDiaryCompleted_r1.wav"),
    SLAYER_TASK("slayer_task_r2.wav"),
    HUNTER_RUMOUR("hunter_rumour_r2.wav"),
    HUNTER_RUMOUR_NOT_COMPLETED("hunter_rumour_not_completed_r1.wav"),
    FARMING_CONTRACT("farming_contract_r2.wav"),
    LEAGUES_TASK("leagues_task_r2.wav"),
    GRID_TASK("grid_task_r1.wav"),
    GRUBBY_KEY("grubby_key_r1.wav"),
    LARRANS_KEY("larrans_key_r1.wav"),
    BRIMSTONE_KEY("brimstone_key_r1.wav"),
    DEATH("DyingHCIMCompleted_r1.wav"),
    DEATH_TO_C_ENGINEER("Sit_r1.wav"),

    QOL_NON_PARCH_INFERNAL("Parched_Infernal_r1.wav"),

    EASTER_EGG_STAIRCASE("Staircase_r1.wav"),
    EASTER_EGG_STRAYDOG_BONE("ILoveYou_r2.wav"),
    EASTER_EGG_TWISTED_BOW_1GP("TwistedBow1GP_r1.wav"),
    EASTER_EGG_ZULRAH_PB("ZulrahPB_r1.wav"),

    ESCAPE_CRYSTAL("Escape_Crystal_r1.wav", true),

    SNOWBALL_CONSOLIDATED_V1_1("SnowballTrollV2_steamPings_r1.wav", true),
    SNOWBALL_CONSOLIDATED_V1_2("SnowballTrollV2_farts_r1.wav", true),
    SNOWBALL_CONSOLIDATED_V1_3("SnowballV3_Notif_r1.wav", true),
    SNOWBALL_CONSOLIDATED_V1_4("SnowballTrollV2_epicNotifSpam_r1.wav", true),
    SNOWBALL_CONSOLIDATED_V1_5("SnowballV3_Sus_r1.wav", true),
    SNOWBALL_CONSOLIDATED_V1_6("SnowballV4_7_r1.wav", true),
    SNOWBALL_CONSOLIDATED_V1_7("SnowballV3_Bits_r1.wav", true),
    SNOWBALL_CONSOLIDATED_V1_8("SnowballV3_Battery_r1.wav", true),
    SNOWBALL_CONSOLIDATED_V1_9("SnowballV4_6_r1.wav", true),
    SNOWBALL_CONSOLIDATED_V1_10("SnowballTroll3_r1.wav", true),
    SNOWBALL_CONSOLIDATED_V1_11("SnowballTroll1_r1.wav", true),
    SNOWBALL_CONSOLIDATED_V1_12("SnowballV3_Knock_r1.wav", true),
    SNOWBALL_CONSOLIDATED_V1_13("SnowballTroll8_r1.wav", true),

    SNOWBALL_GAUNTLET_LOBBY("SnowballV4_NR_Gauntlet_r1.wav", true),

    SNOWBALL_EQUIPPING_BUCKET_HELM_G_OR_FUNNY_FEEL("SnowballV4_NR_BucketHelmG_r1.wav", true),
    SNOWBALL_EQUIPPING_GIANT_BOOT("SnowballV4_NR_GiantBoot_r1.wav", true),
    SNOWBALL_EQUIPPING_SAGACIOUS_SPECTACLES("SnowballV4_NR_SagaciousSpectacles_r1.wav", true),
    SNOWBALL_EQUIPPING_MASK_OF_REBIRTH("SnowballV4_NR_MaskOfRebirth_r1.wav", true),

    EMOTE_TROLL_AKKHA("Akkha_r1.wav", true),

    EMOTE_TROLL_BABA_1("BaBa_1_r1.wav", true),
    EMOTE_TROLL_BABA_2("BaBa_2_r1.wav", true),
    EMOTE_TROLL_BABA_3("BaBa_3_r1.wav", true),

    EMOTE_TROLL_WE("Emote_We_r1.wav", true),
    EMOTE_TROLL_EL("Emote_El_r2.wav", true),
    EMOTE_TROLL_AF("AFriend2_Bye_r1.wav", true),

    ATTACK_TROLL_IB("attack_troll_IB_r1.wav", true),
    ATTACK_TROLL_DC("attack_troll_DC_r2.wav", true),

    CHAT_TROLL_SKILL_SPECS_HELLO("SkillSpecs_Hello_r1.wav", true),
    CHAT_TROLL_SKILL_SPECS_OK("SkillSpecs_OK_r1.wav", true),
    CHAT_TROLL_SKILL_SPECS_OOPS("SkillSpecs_Oops_r1.wav", true),

    TOB_GREEN_BALL("GreenBall_r1.wav", true),

    STAT_SPY_SOUP("StatSpy_Soup_r1.wav", true),
    ;

    @Getter
    private final String resourceName;
    private final boolean isStreamerTroll;

    Sound(String resNam) {
        this(resNam, false);
    }

    Sound(String resNam, boolean streamTroll) {
        resourceName = resNam;
        isStreamerTroll = streamTroll;
    }

    boolean isStreamerTroll() {
        return isStreamerTroll;
    }

    @Override
    public String toString() {
        return resourceName;
    }

    private static final Random random = new Random();

    public static Sound randomSnowballSoundNotFromEquippedItem() {
        return SNOWBALL_SOUNDS_NOT_FROM_EQUIPPED_ITEMS[random.nextInt(SNOWBALL_SOUNDS_NOT_FROM_EQUIPPED_ITEMS.length)];
    }

    private static final Sound[] SNOWBALL_SOUNDS_NOT_FROM_EQUIPPED_ITEMS = new Sound[] {
            SNOWBALL_CONSOLIDATED_V1_1,
            SNOWBALL_CONSOLIDATED_V1_2,
            SNOWBALL_CONSOLIDATED_V1_3,
            SNOWBALL_CONSOLIDATED_V1_4,
            SNOWBALL_CONSOLIDATED_V1_5,
            SNOWBALL_CONSOLIDATED_V1_6,
            SNOWBALL_CONSOLIDATED_V1_7,
            SNOWBALL_CONSOLIDATED_V1_8,
            SNOWBALL_CONSOLIDATED_V1_9,
            SNOWBALL_CONSOLIDATED_V1_10,
            SNOWBALL_CONSOLIDATED_V1_11,
            SNOWBALL_CONSOLIDATED_V1_12,
            SNOWBALL_CONSOLIDATED_V1_13
    };

    public static Sound randomBabaEmoteSound() {
        return BABA_EMOTE_SOUNDS[random.nextInt(BABA_EMOTE_SOUNDS.length)];
    }

    private static final Sound[] BABA_EMOTE_SOUNDS = new Sound[] {
            Sound.EMOTE_TROLL_BABA_1,
            Sound.EMOTE_TROLL_BABA_2,
            Sound.EMOTE_TROLL_BABA_3,
    };
}

package com.github.m0bilebtw.player;

import com.github.m0bilebtw.CEngineerCompletedConfig;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.HitsplatID;
import net.runelite.api.Player;
import net.runelite.api.Projectile;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.PlayerDespawned;
import net.runelite.api.events.PlayerSpawned;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Arrays;
import java.util.List;

import static net.runelite.api.PlayerComposition.ITEM_OFFSET;

@Singleton
public class CEngineerPlayer {
    public static final String RSN = "C Engineer";

    private static final int FIGHT_INTERACT_OR_DAMAGE_COOLDOWN = 8;

    private static final List<Integer> AHRIMS_HOODS = List.of(ItemID.BARROWS_AHRIM_HEAD, ItemID.BARROWS_AHRIM_HEAD_100, ItemID.BARROWS_AHRIM_HEAD_75, ItemID.BARROWS_AHRIM_HEAD_50, ItemID.BARROWS_AHRIM_HEAD_25, ItemID.BARROWS_AHRIM_HEAD_BROKEN);
    private static final List<Integer> AHRIMS_TOPS = List.of(ItemID.BARROWS_AHRIM_BODY, ItemID.BARROWS_AHRIM_BODY_100, ItemID.BARROWS_AHRIM_BODY_75, ItemID.BARROWS_AHRIM_BODY_50, ItemID.BARROWS_AHRIM_BODY_25, ItemID.BARROWS_AHRIM_BODY_BROKEN);
    private static final List<Integer> AHRIMS_BOTTOMS = List.of(ItemID.BARROWS_AHRIM_LEGS, ItemID.BARROWS_AHRIM_LEGS_100, ItemID.BARROWS_AHRIM_LEGS_75, ItemID.BARROWS_AHRIM_LEGS_50, ItemID.BARROWS_AHRIM_LEGS_25, ItemID.BARROWS_AHRIM_LEGS_BROKEN);

    @Inject
    private Client client;

    @Inject
    private CEngineerCompletedConfig config;

    @Inject
    private CEngineerChatTrolls cEngineerChatTrolls;

    private Player player = null;
    private int lastTickOfFightIncludingCEngi = -1;

    @Subscribe
    public void onPlayerSpawned(PlayerSpawned playerSpawned) {
        Player spawnedPlayer = playerSpawned.getPlayer();
        if (RSN.equals(spawnedPlayer.getName())) {
            this.player = spawnedPlayer;
        }
    }

    @Subscribe
    public void onPlayerDespawned(PlayerDespawned playerDespawned) {
        Player despawnedPlayer = playerDespawned.getPlayer();
        if (RSN.equals(despawnedPlayer.getName())) {
            this.player = null;
        }
    }

    @Subscribe
    public void onChatMessage(ChatMessage chatMessage) {
        if (!config.easterEggs())
            return;

        if (isOutOfRenderDistance() ||
                chatMessage.getType() != ChatMessageType.PUBLICCHAT ||
                !Text.standardize(RSN).equals(Text.standardize(chatMessage.getName())))
            return;

        cEngineerChatTrolls.runTriggers(chatMessage);
    }

    @Subscribe
    public void onInteractingChanged(InteractingChanged interactingChanged) {
        if (isOutOfRenderDistance())
            return;

        if (actorEquals(interactingChanged.getSource()) && interactingChanged.getTarget() == client.getLocalPlayer()) {
            lastTickOfFightIncludingCEngi = client.getTickCount();
        }
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied hitsplatApplied) {
        if (isOutOfRenderDistance())
            return;

        if (hitsplatApplied.getActor() != client.getLocalPlayer())
            return;

        int hitType = hitsplatApplied.getHitsplat().getHitsplatType();
        boolean isRelevantHitType = hitType == HitsplatID.DAMAGE_ME
                || hitType == HitsplatID.DAMAGE_ME_ORANGE
                || hitType == HitsplatID.DAMAGE_MAX_ME
                || hitType == HitsplatID.DAMAGE_MAX_ME_ORANGE
                || hitType == HitsplatID.POISON
                || hitType == HitsplatID.VENOM;
        if (isRelevantHitType && wasFightingMeRecently()) {
            // We want to keep tracking even if the hitsplats aren't from C anymore so we can still play the sound for a kill C contributed to
            lastTickOfFightIncludingCEngi = client.getTickCount();
        }
    }

    public boolean wasFightingMeRecently() {
        return client.getTickCount() - lastTickOfFightIncludingCEngi <= FIGHT_INTERACT_OR_DAMAGE_COOLDOWN;
    }

    public boolean isOutOfRenderDistance() {
        return player == null;
    }

    public boolean isWearing(int itemId) {
        if (player == null)
            return false;

        int[] equipmentIds = player.getPlayerComposition().getEquipmentIds();
        return Arrays.stream(equipmentIds)
                .filter(i -> i > ITEM_OFFSET)
                .map(i -> i - ITEM_OFFSET)
                .anyMatch(i -> i == itemId);
    }

    public boolean isWearingAttackTrollRequirements() {
        return isWearing(ItemID.TRAIL_MAGE_AMULET) &&
                isWearing(ItemID.DRAGON_CLAWS) &&
                AHRIMS_HOODS.stream().anyMatch(this::isWearing) &&
                AHRIMS_TOPS.stream().anyMatch(this::isWearing) &&
                AHRIMS_BOTTOMS.stream().anyMatch(this::isWearing);
    }

    public boolean isFollowingMe() {
        return isInteracting(client.getLocalPlayer());
    }

    public boolean isInteracting(Actor actor) {
        if (actor == null)
            return false;

        if (isOutOfRenderDistance())
            return false;

        Actor cEngineerInteractTarget = player.getInteracting();
        return cEngineerInteractTarget == actor;
    }

    public boolean actorEquals(Actor other) {
        return player == other;
    }

    public boolean couldHaveThrownProjectileFrom(Projectile projectile) {
        WorldPoint cEngineerWP = player.getWorldLocation();
        WorldPoint projectileWP = WorldPoint.fromLocal(player.getWorldView(), projectile.getX1(), projectile.getY1(), cEngineerWP.getPlane());

        // check projectile is *roughly* from C's tile, while allowing for drive-by/moving while the projectile spawns
        return cEngineerWP.distanceTo2D(projectileWP) <= 2;
    }

    public int tilesFrom(Actor actor) {
        if (actor == null || player == null)
            return Integer.MAX_VALUE;

        WorldPoint cEngineerWP = player.getWorldLocation();
        WorldPoint actorWP = actor.getWorldLocation();

        return cEngineerWP.distanceTo2D(actorWP);
    }

    public void sendChatIfEnabled(String message) {
        if (config.showChatMessages()) {
            client.addChatMessage(ChatMessageType.PUBLICCHAT, RSN, message, null);
        }
    }
}

package com.github.m0bilebtw.player;

import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class LoggedInState {
    private static final int LOGGED_OUT = -1;

    @Inject
    private Client client;

    private int lastLoggedInTick = LOGGED_OUT;

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        setForCurrentGameState(event.getGameState());
    }

    public void setForCurrentGameState(GameState gameState) {
        if (gameState == GameState.LOGGED_IN) {
            setLastLoginTick(client.getTickCount());
        } else {
            setLoggedOut();
        }
    }

    public boolean isLoggedOut() {
        return this.lastLoggedInTick == LOGGED_OUT;
    }

    public boolean onlyJustLoggedIn(int tickWindow) {
        return client.getTickCount() - this.lastLoggedInTick < tickWindow;
    }

    public void setLoggedOut() {
        this.lastLoggedInTick = LOGGED_OUT;
    }

    public void setLastLoginTick(int lastLoggedInTick) {
        this.lastLoggedInTick = lastLoggedInTick;
    }
}

package com.github.m0bilebtw.player;

import com.github.m0bilebtw.sound.Sound;
import com.github.m0bilebtw.sound.SoundEngine;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;

import javax.inject.Inject;
import java.util.Optional;
import java.util.concurrent.ScheduledExecutorService;

public class CEngineerChatTrolls {

    @Inject
    private Client client;

    @Inject
    private SoundEngine soundEngine;

    @Inject
    private ScheduledExecutorService executor;

    public void runTriggers(ChatMessage chatMessageFromC) {
        Optional<String> standardisedNameOpt = LocalPlayer.getStandardisedName(client);
        if (standardisedNameOpt.isEmpty()) return;

        String standardisedName = standardisedNameOpt.get();
        if ("skill specs".equals(standardisedName))
            skillSpecsChatTrolls(chatMessageFromC);
    }

    private void skillSpecsChatTrolls(ChatMessage chatMessageFromC) {
        switch (chatMessageFromC.getMessage().toLowerCase()) {
            case "hello skill specs":
                soundEngine.playClip(Sound.CHAT_TROLL_SKILL_SPECS_HELLO, executor);
                break;
            case "are you ok":
                soundEngine.playClip(Sound.CHAT_TROLL_SKILL_SPECS_OK, executor);
                break;
            case "oops":
                soundEngine.playClip(Sound.CHAT_TROLL_SKILL_SPECS_OOPS, executor);
                break;
            default: break;
        }
    }
}

package com.github.m0bilebtw.player;

import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.client.util.Text;

import java.util.Optional;

public class LocalPlayer {
    private LocalPlayer () {}

    public static Optional<String> getStandardisedName(Client client) {
        Player localPlayer = client.getLocalPlayer();
        if (localPlayer == null)
            return Optional.empty();

        String localName = localPlayer.getName();
        if (localName == null)
            return Optional.empty();

        return Optional.of(Text.standardize(localName));
    }
}

package com.github.m0bilebtw;

import com.github.m0bilebtw.sound.Sound;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup(CEngineerCompletedConfig.GROUP)
public interface CEngineerCompletedConfig extends Config {
    String GROUP = "cengineercompleted";
    String LEAGUES_TASK_HIDDEN_REMINDER_CONFIG = "needToRemindAboutDisablingLeaguesTasks";
    String DELAY_COX_COL_LOG_HIDDEN_NOTIFY_CONFIG = "needToInformAboutDelayedCoxColLogs";

    @ConfigSection(
            name = "Announce Achievements",
            description = "Which sounds that are achievements should play.",
            position = 0
    )
    String SECTION_ACHIEVEMENT_ANNOUNCEMENTS = "Announce Achievements";

    @ConfigItem(
            keyName = "announceLevelUp",
            name = "Level ups",
            description = "Should C Engineer announce when you gain a level in a skill?",
            section = SECTION_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 1
    )
    default boolean announceLevelUp() {
        return true;
    }

    @ConfigItem(
            keyName = "announceLevelUpIncludesVirtual",
            name = "Include virtual level ups",
            description = "Should C Engineer announce when you gain a virtual (>99) level in a skill?",
            section = SECTION_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 2
    )
    default boolean announceLevelUpIncludesVirtual() {
        return false;
    }

    @ConfigItem(
            keyName = "announceQuestCompletion",
            name = "Quest completions",
            description = "Should C Engineer announce when you complete a quest?",
            section = SECTION_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 3
    )
    default boolean announceQuestCompletion() {
        return true;
    }

    @ConfigItem(
            keyName = "announceCollectionLog",
            name = "New collection log entry",
            description = "Should C Engineer announce when you fill in a new slot in your collection log? This one relies on you having chat messages (included with the popup option) enabled in game settings!",
            section = SECTION_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 4
    )
    default boolean announceCollectionLog() {
        return true;
    }

    @ConfigItem(
            keyName = "announceAchievementDiary",
            name = "Completed achievement diaries",
            description = "Should C Engineer announce when you complete a new achievement diary?",
            section = SECTION_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 5
    )
    default boolean announceAchievementDiary() {
        return true;
    }

    @ConfigItem(
            keyName = "announceCombatAchievement",
            name = "Completed combat achievement tasks",
            description = "Should C Engineer announce when you complete a new combat achievement task?",
            section = SECTION_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 6
    )
    default boolean announceCombatAchievement() {
        return true;
    }

    @ConfigItem(
            keyName = "announceSlayerTasks",
            name = "Completed Slayer Tasks",
            description = "Should C Engineer announce when you complete a slayer task?",
            section = SECTION_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 7
    )
    default boolean announceSlayerTasks() {
        return true;
    }

    @ConfigItem(
            keyName = "announceFarmingContracts",
            name = "Completed Farming Contracts",
            description = "Should C Engineer announce when you complete a farming contract?",
            section = SECTION_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 8
    )
    default boolean announceFarmingContracts() {
        return true;
    }

    @ConfigItem(
            keyName = "announceHunterRumours",
            name = "Completed Hunter Rumours",
            description = "Should C Engineer announce when you receive the required creature part for a hunter rumour?",
            section = SECTION_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 9
    )
    default boolean announceHunterRumours() {
        return true;
    }

    @ConfigItem(
            keyName = "announceLeaguesTasks",
            name = "Completed Leagues Tasks",
            description = "Should C Engineer announce when you complete a leagues task?",
            section = SECTION_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 10
    )
    default boolean announceLeaguesTasks() {
        return true;
    }

    @ConfigItem(
            keyName = LEAGUES_TASK_HIDDEN_REMINDER_CONFIG,
            name = "Need to remind user they can disable leagues tasks announcements if they want",
            description = "Leagues tasks can get spammy, and some users might not know they can toggle individual announcements instead of the whole plugin",
            section = SECTION_ACHIEVEMENT_ANNOUNCEMENTS,
            hidden = true
    )
    default boolean needToRemindAboutDisablingLeaguesTasks() {
        return true;
    }

    @ConfigItem(
            keyName = "announceGridTiles",
            name = "Completed Grid Tiles",
            description = "Should C Engineer announce when you complete a grid tile?",
            section = SECTION_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 11
    )
    default boolean announceGridTiles() {
        return true;
    }

    @ConfigSection(
            name = "Announce Other",
            description = "Which sounds that are not necessarily achievements (and not easter eggs) should play.",
            position = 20
    )
    String SECTION_NON_ACHIEVEMENT_ANNOUNCEMENTS = "Announce Other";

    @ConfigItem(
            keyName = "announceDeath",
            name = "When you die",
            description = "Should C Engineer relive his PvP HCIM death when you die?",
            section = SECTION_NON_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 21
    )
    default boolean announceDeath() {
        return true;
    }

    @ConfigItem(
            keyName = "announceNonTrouverInfernal",
            name = "Non-locked infernal in wildy (once per plugin session)",
            description = "Should C Engineer warn you when you enter the wilderness (only once per plugin session) with an infernal cape that has not been locked with a trouver parchment?",
            section = SECTION_NON_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 22
    )
    default boolean announceNonTrouverInfernal() {
        return true;
    }

    @ConfigItem(
            keyName = "announceGrubbyKeyDrop",
            name = "Announce Grubby Key Drop",
            description = "Should C Engineer announce when you receive a grubby key?",
            section = SECTION_NON_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 23
    )
    default boolean announceGrubbyKeyDrop() {
        return true;
    }

    @ConfigItem(
            keyName = "announceLarransKeyDrop",
            name = "Announce Larran's Key Drop",
            description = "Should C Engineer announce when you receive a Larran's key?",
            section = SECTION_NON_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 24
    )
    default boolean announceLarransKeyDrop() {
        return true;
    }

    @ConfigItem(
            keyName = "announceBrimstoneKeyDrop",
            name = "Announce Brimstone Key Drop",
            description = "Should C Engineer announce when you receive a brimstone key?",
            section = SECTION_NON_ACHIEVEMENT_ANNOUNCEMENTS,
            position = 25
    )
    default boolean announceBrimstoneKeyDrop() {
        return true;
    }

    @ConfigSection(
            name = "General Announcement Settings",
            description = "Settings for other details when achievement sounds play.",
            position = 40
    )
    String SECTION_GENERAL_ANNOUNCEMENT_SETTINGS = "General Announcement Settings";

    @ConfigItem(
            keyName = "showChatMessages",
            name = "Show fake public chat message (only you will see it)",
            description = "Should C Engineer announce your achievements in game chat as well as audibly?",
            section = SECTION_GENERAL_ANNOUNCEMENT_SETTINGS,
            position = 41
    )
    default boolean showChatMessages() {
        return true;
    }

    @Range(
            min = 0,
            max = 200
    )
    @ConfigItem(
            keyName = "announcementVolume",
            name = "Announcement volume",
            description = "Adjust how loud the audio announcements are played!",
            section = SECTION_GENERAL_ANNOUNCEMENT_SETTINGS,
            position = 42
    )
    default int announcementVolume() {
        return 100;
    }

    @ConfigItem(
            keyName = "delayCoXCollectionLogAnnouncements",
            name = "Delay CoX collection log announcements",
            description = "Wait until you open the reward chest at CoX before announcing new collection log slots (also delays Olmlet announcement)",
            section = SECTION_GENERAL_ANNOUNCEMENT_SETTINGS,
            position = 43
    )
    default boolean delayCoXCollectionLogAnnouncements() {
        return true;
    }

    @ConfigItem(
            keyName = DELAY_COX_COL_LOG_HIDDEN_NOTIFY_CONFIG,
            name = "Need to inform users CoX col log announcements will now be delayed until opening chest by default",
            description = "This was requested because a lot of people turn off the plugin during CoX to avoid spoiling if the item is new until they open the chest",
            section = SECTION_ACHIEVEMENT_ANNOUNCEMENTS,
            hidden = true
    )
    default boolean needToInformAboutDelayedCoXColLog() {
        return true;
    }

    @ConfigSection(
            name = "Easter Eggs and Streamer Trolls",
            description = "Settings for non-achievement sounds.",
            position = 60,
            closedByDefault = true
    )
    String SECTION_EASTER_EGGS_AND_STREAMERS = "Easter Eggs and Streamer Trolls";

    @ConfigItem(
            keyName = "easterEggs",
            name = "Easter eggs",
            description = "Should C Engineer comment on your gameplay? And maybe do a little trolling?",
            section = SECTION_EASTER_EGGS_AND_STREAMERS,
            position = 61
    )
    default boolean easterEggs() {
        return true;
    }

    @ConfigItem(
            keyName = "downloadStreamerSounds",
            name = "Include streamer troll sounds (requires plugin restart)",
            description = "Restart plugin to take effect! If disabled, will remove and no longer download sounds that are streamer trolls",
            section = SECTION_EASTER_EGGS_AND_STREAMERS,
            position = 62
    )
    default boolean downloadStreamerTrolls() {
        return true;
    }

    @ConfigItem(
            keyName = "muteSnowballsIfCEngineerIsNear",
            name = "Stealthy snowballs when C Engineer is nearby",
            description = "Mute snowball sound effects if C Engineer is nearby to allow for stealthier trolling",
            section = SECTION_EASTER_EGGS_AND_STREAMERS,
            position = 63
    )
    default boolean muteSnowballsIfCEngineerIsNear() {
        return true;
    }

    @ConfigItem(
            keyName = "selectAnySoundToTestPlayIt",
            name = "(SPOILERS) Test any sound",
            description = "(SPOILERS) Choose a sound to play it to test it works and its volume. This will also be the sound played when changing volume",
            section = SECTION_EASTER_EGGS_AND_STREAMERS,
            position = 64
    )
    default Sound selectAnySoundToTestPlayIt() {
        return Sound.LEVEL_UP;
    }
}

package com.github.m0bilebtw.trolls;

import com.github.m0bilebtw.CEngineerCompletedConfig;
import com.github.m0bilebtw.animation.AnimationTriggers;
import com.github.m0bilebtw.player.CEngineerPlayer;
import com.github.m0bilebtw.projectile.ProjectileID;
import com.github.m0bilebtw.sound.Sound;
import com.github.m0bilebtw.sound.SoundEngine;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.Projectile;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.AreaSoundEffectPlayed;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GraphicChanged;
import net.runelite.api.events.ProjectileMoved;
import net.runelite.api.events.SoundEffectPlayed;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.SpotanimID;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.time.Duration;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Pattern;

import static com.github.m0bilebtw.projectile.ProjectileSoundID.SNOWBALL_SOUND_IDS;

public class TrollTriggers {
    private static final Pattern STAT_SPY_REGEX = Pattern.compile(Text.standardize(CEngineerPlayer.RSN + " is reading your skill stats!"));
    private static final Pattern ESCAPE_CRYSTAL_REGEX = Pattern.compile(Text.standardize(CEngineerPlayer.RSN + " activated your crystal\\."));
    private static final Pattern TOB_GREEN_BALL_BOUNCE_REGEX = Pattern.compile(Text.standardize("<col=0a721f>A powerful projectile bounces into your direction\\.\\.\\.</col>"));

    private static final int SNOWBALL_COOLDOWN_TICKS = 50;
    private static final Duration SNOWBALL_DELAY_GAUNTLET_SOUND = Duration.ofMinutes(9);
    private static final Duration SNOWBALL_DELAY_SOUNDS = Duration.ofSeconds(20);

    private static final WorldArea GAUNTLET_LOBBY = new WorldArea(new WorldPoint(3026, 6117, 1), 14, 14);

    @Inject
    private Client client;

    @Inject
    private CEngineerCompletedConfig config;

    @Inject
    private ScheduledExecutorService executor;

    @Inject
    private SoundEngine soundEngine;

    @Inject
    private CEngineerPlayer cEngineer;

    @Inject
    private AnimationTriggers animationTriggers;

    private int lastSnowballTriggerTick = -1;

    @Subscribe
    public void onChatMessage(ChatMessage chatMessage) {
        if (chatMessage.getType() != ChatMessageType.GAMEMESSAGE && chatMessage.getType() != ChatMessageType.SPAM)
            return;

        if (!config.easterEggs())
            return;

        String standardisedMessage = Text.standardize(chatMessage.getMessage());
        if (STAT_SPY_REGEX.matcher(standardisedMessage).matches()) {
            soundEngine.playClip(Sound.STAT_SPY_SOUP, executor);

        } else if (ESCAPE_CRYSTAL_REGEX.matcher(standardisedMessage).matches()) {
            soundEngine.playClip(Sound.ESCAPE_CRYSTAL, executor);

        } else if (cEngineer.isFollowingMe() && TOB_GREEN_BALL_BOUNCE_REGEX.matcher(standardisedMessage).matches()) {
            soundEngine.playClip(Sound.TOB_GREEN_BALL, executor);
        }
    }

    @Subscribe
    public void onGraphicChanged(GraphicChanged graphicChanged) {
        if (!config.easterEggs())
            return;

        if (!cEngineer.isWearingAttackTrollRequirements())
            return;

        iceBarrageTroll(graphicChanged.getActor());
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged animationChanged) {
        if (!config.easterEggs())
            return;

        Player localPlayer = client.getLocalPlayer();
        if (localPlayer == animationChanged.getActor() && localPlayer.getAnimation() != -1) {
            animationTriggers.runTriggersForLocalPlayerAnimation(localPlayer.getAnimation());
            return;
        }

        if (cEngineer.isOutOfRenderDistance())
            return;

        Actor actor = animationChanged.getActor();
        if (!cEngineer.actorEquals(actor))
            return;

        int actorAnimationId = actor.getAnimation();
        if (actorAnimationId == -1)
            return;

        animationTriggers.runTriggersForCEngiAnimation(actorAnimationId);
    }

    @Subscribe
    public void onSoundEffectPlayed(SoundEffectPlayed soundEffectPlayed) {
        if (shouldMuteSnowballs() && SNOWBALL_SOUND_IDS.contains(soundEffectPlayed.getSoundId())) {
            soundEffectPlayed.consume();
        }
    }

    @Subscribe
    public void onAreaSoundEffectPlayed(AreaSoundEffectPlayed areaSoundEffectPlayed) {
        if (shouldMuteSnowballs() && SNOWBALL_SOUND_IDS.contains(areaSoundEffectPlayed.getSoundId())) {
            areaSoundEffectPlayed.consume();
        }
    }

    @Subscribe
    public void onProjectileMoved(ProjectileMoved projectileMoved) {
        if (cEngineer.isOutOfRenderDistance())
            return;

        if (!config.easterEggs())
            return;

        Projectile projectile = projectileMoved.getProjectile();
        if (projectile.getId() != ProjectileID.SNOWBALL)
            return;

        int currentTick = client.getTickCount();
        if (currentTick - lastSnowballTriggerTick < SNOWBALL_COOLDOWN_TICKS)
            return;

        Actor myself = client.getLocalPlayer();
        if (myself == null)
            return;

        Actor projectileInteracting = projectile.getInteracting();
        if (!myself.equals(projectileInteracting))
            return;

        if (cEngineer.couldHaveThrownProjectileFrom(projectile)) {
            lastSnowballTriggerTick = currentTick;
            playSoundFromSnowball();
        }
    }

    private void playSoundFromSnowball() {
        WorldPoint currentLocation = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());
        if (GAUNTLET_LOBBY.contains(currentLocation)) {
            soundEngine.playClip(Sound.SNOWBALL_GAUNTLET_LOBBY, executor, SNOWBALL_DELAY_GAUNTLET_SOUND);
            return;
        }

        Sound sound = pickSnowballSoundBasedOnEquipment();
        if (cEngineer.isWearing(ItemID.TRAIL_MAGE_AMULET)) {
            soundEngine.playClip(sound, executor);
        } else {
            soundEngine.playClip(sound, executor, SNOWBALL_DELAY_SOUNDS);
        }
    }

    private Sound pickSnowballSoundBasedOnEquipment() {
        if (cEngineer.isWearing(ItemID.BUCKET_HELM_GOLD))
            return Sound.SNOWBALL_EQUIPPING_BUCKET_HELM_G_OR_FUNNY_FEEL;

        if (cEngineer.isWearing(ItemID.GIANT_BOOT))
            return Sound.SNOWBALL_EQUIPPING_GIANT_BOOT;

        if (cEngineer.isWearing(ItemID.WISE_SPECTACLES))
            return Sound.SNOWBALL_EQUIPPING_SAGACIOUS_SPECTACLES;

        if (cEngineer.isWearing(ItemID.TOA_AMASCUT_MASK))
            return Sound.SNOWBALL_EQUIPPING_MASK_OF_REBIRTH;

        return Sound.randomSnowballSoundNotFromEquippedItem();
    }

    private boolean shouldMuteSnowballs() {
        if (cEngineer.isOutOfRenderDistance())
            return false;

        return config.muteSnowballsIfCEngineerIsNear();
    }

    private void iceBarrageTroll(Actor actorFromGraphicChanged) {
        if (!(actorFromGraphicChanged instanceof NPC))
            return;

        NPC npc = (NPC) actorFromGraphicChanged;
        if (!npc.hasSpotAnim(SpotanimID.ICE_BARRAGE_IMPACT))
            return;
        if (!cEngineer.isInteracting(npc))
            return;
        if (cEngineer.tilesFrom(client.getLocalPlayer()) > 10)
            return;

        soundEngine.playClip(Sound.ATTACK_TROLL_IB, executor);
    }
}

package com.github.m0bilebtw.animation;

public class AnimationID {
    private AnimationID() {}

    public static final int TRICK = 10503;
    public static final int SMOOTH_DANCE = 7533;
    public static final int PREMIER_SHIELD = 7751;
    public static final int DIANGO_CLAWS = 5283;

    public static final int GENERIC_CHEST_OPEN = 832;
}

package com.github.m0bilebtw.animation;

import com.github.m0bilebtw.player.CEngineerPlayer;
import com.github.m0bilebtw.player.LocalPlayer;
import com.github.m0bilebtw.sound.Sound;
import com.github.m0bilebtw.sound.SoundEngine;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;

import javax.inject.Inject;
import java.util.Optional;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import static com.github.m0bilebtw.animation.AnimationID.DIANGO_CLAWS;
import static com.github.m0bilebtw.animation.AnimationID.GENERIC_CHEST_OPEN;
import static com.github.m0bilebtw.animation.AnimationID.PREMIER_SHIELD;
import static com.github.m0bilebtw.animation.AnimationID.SMOOTH_DANCE;
import static com.github.m0bilebtw.animation.AnimationID.TRICK;

public class AnimationTriggers {

    @Inject
    private Client client;

    @Inject
    private SoundEngine soundEngine;

    @Inject
    private ScheduledExecutorService executor;

    @Inject
    private ChatMessageManager chatMessageManager;

    @Inject
    private CEngineerPlayer cEngineer;

    private static final WorldArea AKKHA_ROOM = new WorldArea(new WorldPoint(3671, 5398, 1), 29, 20);
    private static final WorldArea BABA_PUZZLE_ROOM = new WorldArea(new WorldPoint(3788, 5264, 0), 42, 31);

    private static final WorldArea TOA_CHEST_ROOM = new WorldArea(new WorldPoint(3673, 5138, 0), 15, 13);
    private static final WorldArea TOB_CHEST_ROOM = new WorldArea(new WorldPoint(3225, 4320, 0), 18, 14);

    public void runTriggersForLocalPlayerAnimation(int animationId) {
        checkFunnyFeelingTrollTrigger(animationId);
    }

    private void checkFunnyFeelingTrollTrigger(int animationId) {
        if (animationId != GENERIC_CHEST_OPEN)
            return;

        if (!cEngineer.isFollowingMe())
            return;

        WorldPoint currentLocation = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());
        if (TOA_CHEST_ROOM.contains(currentLocation) || TOB_CHEST_ROOM.contains(currentLocation)) {
            executor.schedule(this::funnyFeelingTroll, 600, TimeUnit.MILLISECONDS);
        }
    }

    private void funnyFeelingTroll() {
        String highlightedMessage = new ChatMessageBuilder()
                .append(ChatColorType.HIGHLIGHT)
                .append("You have a funny feeling like you're being followed.")
                .build();

        chatMessageManager.queue(QueuedMessage.builder()
                .type(ChatMessageType.CONSOLE)
                .runeLiteFormattedMessage(highlightedMessage)
                .build());

        soundEngine.playClip(Sound.SNOWBALL_EQUIPPING_BUCKET_HELM_G_OR_FUNNY_FEEL, executor);
    }

    public void runTriggersForCEngiAnimation(int animationId) {
        if (animationId == TRICK) {
            akkhaTroll();
        } else if (animationId == PREMIER_SHIELD) {
            babaTroll();
        } else if (animationId == SMOOTH_DANCE) {
            smoothDanceTrolls();
        } else if (animationId == DIANGO_CLAWS) {
            diangoClawsTroll();
        }
    }

    private void akkhaTroll() {
        WorldPoint currentLocation = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());
        if (AKKHA_ROOM.contains(currentLocation)) {
            soundEngine.playClip(Sound.EMOTE_TROLL_AKKHA, executor);
        }
    }

    private void babaTroll() {
        WorldPoint currentLocation = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());
        if (BABA_PUZZLE_ROOM.contains(currentLocation)) {
            soundEngine.playClip(Sound.randomBabaEmoteSound(), executor);
        }
    }

    private void smoothDanceTrolls() {
        Optional<String> standardisedNameOpt = LocalPlayer.getStandardisedName(client);
        if (standardisedNameOpt.isEmpty()) return;

        String standardisedName = standardisedNameOpt.get();
        switch (standardisedName) {
            case "a friend 2":
                soundEngine.playClip(Sound.EMOTE_TROLL_AF, executor);
                break;
            case "taint licka":
                soundEngine.playClip(Sound.EMOTE_TROLL_EL, executor);
                break;
            case "westham":
            case "debiedobies":
            case "saund":
                soundEngine.playClip(Sound.EMOTE_TROLL_WE, executor);
                break;
            case "scoutzone": // C's alt for testing
                soundEngine.playClip(Sound.QUEST, executor);
                break;
            default: break;
        }
    }

    private void diangoClawsTroll() {
        if (cEngineer.tilesFrom(client.getLocalPlayer()) > 10)
            return;

        if (cEngineer.isWearingAttackTrollRequirements()) {
            soundEngine.playClip(Sound.ATTACK_TROLL_DC, executor);
        }
    }
}

package com.github.m0bilebtw.projectile;

public class ProjectileID {
    private ProjectileID() {}

    public static final int SNOWBALL = 861;
}

package com.github.m0bilebtw.projectile;

import java.util.Set;

public class ProjectileSoundID {
    private ProjectileSoundID() {}

    public static final Set<Integer> SNOWBALL_SOUND_IDS = Set.of(2708, 3292);
}

package com.github.m0bilebtw;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CEngineerCompletedPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CEngineerCompletedPlugin.class);
		RuneLite.main(args);
	}
}
package com.github.m0bilebtw.sound;

import org.junit.Test;

import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.UnsupportedAudioFileException;
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

public class SoundTest {

    @Test
    public void valuesPopulated() {
        for (Sound sound : Sound.values()) {
            String message = "Sound " + sound.name() + " should have a non-blank resource name";
            assertFalse(message, sound.getResourceName().isBlank());
        }
    }

    @Test
    public void noDuplicateValues() {
        Set<String> uniqueResourceNames = Arrays.stream(Sound.values())
                .map(Sound::getResourceName)
                .collect(Collectors.toSet());

        assertEquals(Sound.values().length, uniqueResourceNames.size());
    }

    /**
     * Bash snippets to also help in identifying and automatically fixing such files.
     * It's better to run these in the sounds folder in .runelite rather than the sounds branch of the repo,
     * because then you automatically ignore any previous revisions of a sound.
     * <p>
     * Identify sounds that will cut off:
     * <p>
     * {@code for f in *.wav; do duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$f"); echo "$f $duration"; done}
     * <p>
     * Create new sounds that are padded to prevent cut off where needed:
     * <p>
     * {@code for f in *.wav; do duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$f"); if (( $(echo "$duration >= 1.491 && $duration < 2" | bc -l) )); then padding=$(echo "2 - $duration" | bc -l); ffmpeg -i "$f" -af "apad=pad_dur=0$padding" -y "${f%.wav}_PADDED.wav"; fi; done}
     */
    @Test
    public void soundsAvoidDurationRangeThatPipeWireCutsOff() throws UnsupportedAudioFileException, IOException {
        // bounds found by manually testing to 3 d.p. - both 1.492 and 1.999 (and all in-between) get cut off
        final double lowerBoundExc = 1.491;
        final double upperBoundExc = 2.0;

        Set<Sound> cutOffSounds = new HashSet<>();
        for (Sound sound : Sound.values()) {
            final double duration = getDurationInSeconds(sound);
            if (duration > lowerBoundExc && duration < upperBoundExc) {
                cutOffSounds.add(sound);
            }
        }

        assertTrue(
                cutOffSounds.size() + " sounds will get cut off on PipeWire\n" +
                cutOffSounds.stream().map(s -> s.name() + ": " + s.getResourceName()).collect(Collectors.joining("\n")) + "\n",
                cutOffSounds.isEmpty()
        );
    }

    private double getDurationInSeconds(Sound sound) throws UnsupportedAudioFileException, IOException {
        File file = SoundFileManager.getSoundFile(sound);
        AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(file);
        AudioFormat format = audioInputStream.getFormat();
        long frames = audioInputStream.getFrameLength();
        return (double) frames / format.getFrameRate();
    }
}

