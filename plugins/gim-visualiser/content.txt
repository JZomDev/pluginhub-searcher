package com.gimvisualiser;

import com.gimvisualiser.models.ItemStack;
import com.gimvisualiser.models.SkillData;
import com.gimvisualiser.models.SyncPayload;
import net.runelite.api.Client;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.Player;
import net.runelite.api.Skill;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Singleton
public class DataCollector
{
    private static final Logger log = LoggerFactory.getLogger(DataCollector.class);
    private static final int LOOTING_BAG_CONTAINER_ID = 516;

    private final Client client;

    // Cached data that persists between syncs
    private List<ItemStack> cachedBank = new ArrayList<>();
    private List<Integer> cachedCollectionLog = new ArrayList<>();
    private List<ItemStack> cachedLootingBag = new ArrayList<>();

    @Inject
    public DataCollector(Client client)
    {
        this.client = client;
    }

    public SyncPayload collectFullPayload()
    {
        Player localPlayer = client.getLocalPlayer();
        if (localPlayer == null)
        {
            return null;
        }

        String rsn = localPlayer.getName();
        if (rsn == null || rsn.isEmpty())
        {
            return null;
        }

        return SyncPayload.builder()
            .rsn(rsn)
            .timestamp(System.currentTimeMillis())
            .combatLevel(localPlayer.getCombatLevel())
            .bank(cachedBank)
            .inventory(collectInventory())
            .equipment(collectEquipment())
            .skills(collectSkills())
            .collectionLog(cachedCollectionLog)
            .lootingBag(cachedLootingBag)
            .build();
    }

    public void updateBank()
    {
        ItemContainer bankContainer = client.getItemContainer(InventoryID.BANK);
        if (bankContainer == null)
        {
            return;
        }

        cachedBank = collectFromContainer(bankContainer);
        log.debug("Updated bank cache with {} items", cachedBank.size());
    }

    public List<ItemStack> collectInventory()
    {
        ItemContainer container = client.getItemContainer(InventoryID.INVENTORY);
        if (container == null)
        {
            return new ArrayList<>();
        }
        return collectFromContainer(container);
    }

    public Map<String, ItemStack> collectEquipment()
    {
        ItemContainer container = client.getItemContainer(InventoryID.EQUIPMENT);
        Map<String, ItemStack> equipment = new HashMap<>();

        if (container == null)
        {
            return equipment;
        }

        Item[] items = container.getItems();

        // Map equipment slots to their names
        for (EquipmentInventorySlot slot : EquipmentInventorySlot.values())
        {
            int slotIdx = slot.getSlotIdx();
            if (slotIdx < items.length)
            {
                Item item = items[slotIdx];
                if (item != null && item.getId() > 0)
                {
                    equipment.put(slot.name().toLowerCase(), new ItemStack(item.getId(), item.getQuantity(), slotIdx));
                }
            }
        }

        return equipment;
    }

    public Map<String, SkillData> collectSkills()
    {
        Map<String, SkillData> skills = new HashMap<>();

        for (Skill skill : Skill.values())
        {
            if (skill == Skill.OVERALL)
            {
                continue;
            }

            int level = client.getRealSkillLevel(skill);
            int xp = client.getSkillExperience(skill);
            skills.put(skill.getName().toLowerCase(), new SkillData(level, xp));
        }

        return skills;
    }

    public void updateLootingBag(int containerId)
    {
        if (containerId == LOOTING_BAG_CONTAINER_ID)
        {
            ItemContainer container = client.getItemContainer(containerId);
            if (container != null)
            {
                cachedLootingBag = collectFromContainer(container);
                log.debug("Updated looting bag cache with {} items", cachedLootingBag.size());
            }
        }
    }

    public void updateCollectionLog(List<Integer> itemIds)
    {
        if (itemIds != null && !itemIds.isEmpty())
        {
            cachedCollectionLog = new ArrayList<>(itemIds);
            log.debug("Updated collection log cache with {} items", cachedCollectionLog.size());
        }
    }

    public void addCollectionLogItem(int itemId)
    {
        if (!cachedCollectionLog.contains(itemId))
        {
            cachedCollectionLog.add(itemId);
            log.debug("Added item {} to collection log cache", itemId);
        }
    }

    private List<ItemStack> collectFromContainer(ItemContainer container)
    {
        List<ItemStack> items = new ArrayList<>();
        Item[] containerItems = container.getItems();

        for (int slot = 0; slot < containerItems.length; slot++)
        {
            Item item = containerItems[slot];
            if (item != null && item.getId() > 0)
            {
                items.add(new ItemStack(item.getId(), item.getQuantity(), slot));
            }
        }

        return items;
    }

    public boolean hasData()
    {
        return client.getLocalPlayer() != null && client.getLocalPlayer().getName() != null;
    }

    public void clearCache()
    {
        cachedBank.clear();
        cachedCollectionLog.clear();
        cachedLootingBag.clear();
    }
}

package com.gimvisualiser;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("gimvisualiser")
public interface GimVisualiserConfig extends Config
{
    @ConfigItem(
        keyName = "apiSyncKey",
        name = "API Sync Key",
        description = "The API key used to authenticate with the GIM Visualiser webapp",
        position = 1
    )
    default String apiSyncKey()
    {
        return "";
    }

    @ConfigItem(
        keyName = "apiBaseUrl",
        name = "API Base URL",
        description = "The base URL of the GIM Visualiser webapp API",
        position = 2
    )
    default String apiBaseUrl()
    {
        return "http://localhost:3000";
    }

    @ConfigItem(
        keyName = "syncEnabled",
        name = "Enable Sync",
        description = "Enable or disable automatic data syncing",
        position = 3
    )
    default boolean syncEnabled()
    {
        return true;
    }
}

package com.gimvisualiser;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.text.SimpleDateFormat;
import java.util.Date;

public class GimVisualiserPanel extends PluginPanel implements SyncService.SyncStatusListener
{
    private final GimVisualiserPlugin plugin;
    private final GimVisualiserConfig config;

    private final JLabel statusLabel;
    private final JLabel lastSyncLabel;
    private final JLabel errorLabel;
    private final JButton syncButton;
    private final JPanel statusIndicator;

    private static final Color STATUS_CONNECTED = new Color(0, 200, 83);
    private static final Color STATUS_SYNCING = new Color(255, 193, 7);
    private static final Color STATUS_DISCONNECTED = new Color(158, 158, 158);
    private static final Color STATUS_ERROR = new Color(244, 67, 54);

    private static final SimpleDateFormat TIME_FORMAT = new SimpleDateFormat("HH:mm:ss");

    public GimVisualiserPanel(GimVisualiserPlugin plugin, GimVisualiserConfig config)
    {
        this.plugin = plugin;
        this.config = config;

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(10, 10, 10, 10));
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Header
        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JLabel titleLabel = new JLabel("GIM Visualiser");
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 16f));
        headerPanel.add(titleLabel, BorderLayout.WEST);

        add(headerPanel, BorderLayout.NORTH);

        // Status section
        JPanel statusPanel = new JPanel();
        statusPanel.setLayout(new BoxLayout(statusPanel, BoxLayout.Y_AXIS));
        statusPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        statusPanel.setBorder(new EmptyBorder(20, 0, 20, 0));

        // Status indicator row
        JPanel statusRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        statusRow.setBackground(ColorScheme.DARK_GRAY_COLOR);
        statusRow.setAlignmentX(Component.LEFT_ALIGNMENT);

        statusIndicator = new JPanel();
        statusIndicator.setPreferredSize(new Dimension(12, 12));
        statusIndicator.setBackground(STATUS_DISCONNECTED);
        statusRow.add(statusIndicator);

        statusLabel = new JLabel("Disconnected");
        statusLabel.setForeground(Color.WHITE);
        statusRow.add(statusLabel);

        statusPanel.add(statusRow);
        statusPanel.add(Box.createVerticalStrut(10));

        // Last sync row
        JPanel lastSyncRow = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        lastSyncRow.setBackground(ColorScheme.DARK_GRAY_COLOR);
        lastSyncRow.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel lastSyncTitleLabel = new JLabel("Last sync: ");
        lastSyncTitleLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        lastSyncRow.add(lastSyncTitleLabel);

        lastSyncLabel = new JLabel("Never");
        lastSyncLabel.setForeground(Color.WHITE);
        lastSyncRow.add(lastSyncLabel);

        statusPanel.add(lastSyncRow);
        statusPanel.add(Box.createVerticalStrut(10));

        // Error label
        errorLabel = new JLabel("");
        errorLabel.setForeground(STATUS_ERROR);
        errorLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        errorLabel.setVisible(false);
        statusPanel.add(errorLabel);

        add(statusPanel, BorderLayout.CENTER);

        // Sync button
        JPanel buttonPanel = new JPanel(new BorderLayout());
        buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        buttonPanel.setBorder(new EmptyBorder(10, 0, 0, 0));

        syncButton = new JButton("Sync Now");
        syncButton.setFocusPainted(false);
        syncButton.addActionListener(e -> {
            syncButton.setEnabled(false);
            syncButton.setText("Syncing...");
            plugin.forceSync();

            // Re-enable after a short delay
            Timer timer = new Timer(2000, evt -> {
                syncButton.setEnabled(true);
                syncButton.setText("Sync Now");
            });
            timer.setRepeats(false);
            timer.start();
        });
        buttonPanel.add(syncButton, BorderLayout.CENTER);

        add(buttonPanel, BorderLayout.SOUTH);

        // Configuration info
        JPanel configPanel = new JPanel();
        configPanel.setLayout(new BoxLayout(configPanel, BoxLayout.Y_AXIS));
        configPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        configPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

        JLabel configTitle = new JLabel("Configuration");
        configTitle.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        configTitle.setFont(configTitle.getFont().deriveFont(Font.BOLD));
        configTitle.setAlignmentX(Component.LEFT_ALIGNMENT);
        configPanel.add(configTitle);
        configPanel.add(Box.createVerticalStrut(5));

        String apiKeyStatus = config.apiSyncKey().isEmpty() ? "Not set" : "Configured";
        JLabel apiKeyLabel = new JLabel("API Key: " + apiKeyStatus);
        apiKeyLabel.setForeground(config.apiSyncKey().isEmpty() ? STATUS_ERROR : STATUS_CONNECTED);
        apiKeyLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        configPanel.add(apiKeyLabel);

        JLabel syncEnabledLabel = new JLabel("Sync: " + (config.syncEnabled() ? "Enabled" : "Disabled"));
        syncEnabledLabel.setForeground(config.syncEnabled() ? STATUS_CONNECTED : STATUS_DISCONNECTED);
        syncEnabledLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
        configPanel.add(syncEnabledLabel);

        // Insert config panel before button panel
        JPanel centerWrapper = new JPanel(new BorderLayout());
        centerWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
        centerWrapper.add(statusPanel, BorderLayout.NORTH);
        centerWrapper.add(configPanel, BorderLayout.CENTER);

        remove(statusPanel);
        add(centerWrapper, BorderLayout.CENTER);
    }

    @Override
    public void onStatusChange(SyncService.SyncStatus status, long lastSyncTime, String error)
    {
        SwingUtilities.invokeLater(() -> {
            switch (status)
            {
                case CONNECTED:
                    statusIndicator.setBackground(STATUS_CONNECTED);
                    statusLabel.setText("Connected");
                    errorLabel.setVisible(false);
                    break;
                case SYNCING:
                    statusIndicator.setBackground(STATUS_SYNCING);
                    statusLabel.setText("Syncing...");
                    break;
                case DISCONNECTED:
                    statusIndicator.setBackground(STATUS_DISCONNECTED);
                    statusLabel.setText("Disconnected");
                    break;
                case ERROR:
                    statusIndicator.setBackground(STATUS_ERROR);
                    statusLabel.setText("Error");
                    if (error != null)
                    {
                        errorLabel.setText("<html><body style='width: 150px'>" + error + "</body></html>");
                        errorLabel.setVisible(true);
                    }
                    break;
            }

            if (lastSyncTime > 0)
            {
                lastSyncLabel.setText(TIME_FORMAT.format(new Date(lastSyncTime)));
            }
        });
    }
}

package com.gimvisualiser;

import com.gimvisualiser.models.SyncPayload;
import com.google.gson.Gson;
import com.google.inject.Provides;
import net.runelite.api.Client;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import java.awt.image.BufferedImage;

@PluginDescriptor(
    name = "GIM Visualiser",
    description = "Syncs Group Ironman player data to a web dashboard",
    tags = {"gim", "group", "ironman", "sync", "visualiser"}
)
public class GimVisualiserPlugin extends Plugin
{
    private static final Logger log = LoggerFactory.getLogger(GimVisualiserPlugin.class);
    private static final int LOOTING_BAG_CONTAINER_ID = 516;

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private GimVisualiserConfig config;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private Gson gson;

    private DataCollector dataCollector;
    private SyncService syncService;
    private GimVisualiserPanel panel;
    private NavigationButton navButton;

    private boolean bankOpen = false;

    @Override
    protected void startUp() throws Exception
    {
        log.info("GIM Visualiser starting up");

        dataCollector = new DataCollector(client);
        syncService = new SyncService(config, gson, okHttpClient);

        panel = new GimVisualiserPanel(this, config);
        syncService.setStatusListener(panel);

        BufferedImage icon;
        try
        {
            icon = ImageUtil.loadImageResource(getClass(), "/com/gimvisualiser/icon.png");
        }
        catch (Exception e)
        {
            log.debug("Could not load icon, using default");
            icon = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
        }

        navButton = NavigationButton.builder()
            .tooltip("GIM Visualiser")
            .icon(icon)
            .priority(10)
            .panel(panel)
            .build();

        clientToolbar.addNavigation(navButton);
    }

    @Override
    protected void shutDown() throws Exception
    {
        log.info("GIM Visualiser shutting down");

        clientToolbar.removeNavigation(navButton);
        syncService.shutdown();
        dataCollector.clearCache();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        if (event.getGameState() == GameState.LOGGED_IN)
        {
            // Slight delay to ensure player data is available
            clientThread.invokeLater(() -> {
                if (dataCollector.hasData())
                {
                    log.debug("Logged in, scheduling initial sync");
                    scheduleSync();
                }
            });
        }
        else if (event.getGameState() == GameState.LOGIN_SCREEN)
        {
            dataCollector.clearCache();
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        int containerId = event.getContainerId();

        if (containerId == InventoryID.BANK.getId())
        {
            if (bankOpen)
            {
                dataCollector.updateBank();
            }
        }
        else if (containerId == InventoryID.INVENTORY.getId())
        {
            scheduleSync();
        }
        else if (containerId == InventoryID.EQUIPMENT.getId())
        {
            scheduleSync();
        }
        else if (containerId == LOOTING_BAG_CONTAINER_ID)
        {
            dataCollector.updateLootingBag(containerId);
            scheduleSync();
        }
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event)
    {
        if (event.getGroupId() == InterfaceID.BANK)
        {
            bankOpen = true;
            dataCollector.updateBank();
        }
        else if (event.getGroupId() == InterfaceID.COLLECTION_LOG)
        {
            // Collection log opened - would need additional logic to extract items
            // This is a placeholder for collection log integration
            log.debug("Collection log opened");
        }
    }

    @Subscribe
    public void onWidgetClosed(WidgetClosed event)
    {
        if (event.getGroupId() == InterfaceID.BANK)
        {
            bankOpen = false;
            scheduleSync();
        }
    }

    @Subscribe
    public void onStatChanged(StatChanged event)
    {
        scheduleSync();
    }

    private void scheduleSync()
    {
        if (!config.syncEnabled() || !dataCollector.hasData())
        {
            return;
        }

        SyncPayload payload = dataCollector.collectFullPayload();
        if (payload != null)
        {
            syncService.scheduleSync(payload);
        }
    }

    public void forceSync()
    {
        if (!dataCollector.hasData())
        {
            log.warn("Cannot sync - no player data available");
            return;
        }

        SyncPayload payload = dataCollector.collectFullPayload();
        if (payload != null)
        {
            syncService.forceSync(payload);
        }
    }

    public SyncService.SyncStatus getSyncStatus()
    {
        return syncService.getStatus();
    }

    public long getLastSyncTime()
    {
        return syncService.getLastSyncTime();
    }

    public String getLastError()
    {
        return syncService.getLastError();
    }

    @Provides
    GimVisualiserConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(GimVisualiserConfig.class);
    }
}

package com.gimvisualiser.models;

public class ItemStack
{
    private int id;
    private int quantity;
    private int slot;

    public ItemStack() {}

    public ItemStack(int id, int quantity, int slot)
    {
        this.id = id;
        this.quantity = quantity;
        this.slot = slot;
    }

    public int getId() { return id; }
    public void setId(int id) { this.id = id; }

    public int getQuantity() { return quantity; }
    public void setQuantity(int quantity) { this.quantity = quantity; }

    public int getSlot() { return slot; }
    public void setSlot(int slot) { this.slot = slot; }
}

package com.gimvisualiser.models;

public class SkillData
{
    private int level;
    private int xp;

    public SkillData() {}

    public SkillData(int level, int xp)
    {
        this.level = level;
        this.xp = xp;
    }

    public int getLevel() { return level; }
    public void setLevel(int level) { this.level = level; }

    public int getXp() { return xp; }
    public void setXp(int xp) { this.xp = xp; }
}

package com.gimvisualiser.models;

import java.util.List;
import java.util.Map;

public class SyncPayload
{
    private String rsn;
    private long timestamp;
    private int combatLevel;
    private List<ItemStack> bank;
    private List<ItemStack> inventory;
    private Map<String, ItemStack> equipment;
    private Map<String, SkillData> skills;
    private List<Integer> collectionLog;
    private List<ItemStack> lootingBag;

    public SyncPayload() {}

    public String getRsn() { return rsn; }
    public void setRsn(String rsn) { this.rsn = rsn; }

    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }

    public int getCombatLevel() { return combatLevel; }
    public void setCombatLevel(int combatLevel) { this.combatLevel = combatLevel; }

    public List<ItemStack> getBank() { return bank; }
    public void setBank(List<ItemStack> bank) { this.bank = bank; }

    public List<ItemStack> getInventory() { return inventory; }
    public void setInventory(List<ItemStack> inventory) { this.inventory = inventory; }

    public Map<String, ItemStack> getEquipment() { return equipment; }
    public void setEquipment(Map<String, ItemStack> equipment) { this.equipment = equipment; }

    public Map<String, SkillData> getSkills() { return skills; }
    public void setSkills(Map<String, SkillData> skills) { this.skills = skills; }

    public List<Integer> getCollectionLog() { return collectionLog; }
    public void setCollectionLog(List<Integer> collectionLog) { this.collectionLog = collectionLog; }

    public List<ItemStack> getLootingBag() { return lootingBag; }
    public void setLootingBag(List<ItemStack> lootingBag) { this.lootingBag = lootingBag; }

    public static Builder builder() { return new Builder(); }

    public static class Builder
    {
        private final SyncPayload payload = new SyncPayload();

        public Builder rsn(String rsn) { payload.rsn = rsn; return this; }
        public Builder timestamp(long timestamp) { payload.timestamp = timestamp; return this; }
        public Builder combatLevel(int combatLevel) { payload.combatLevel = combatLevel; return this; }
        public Builder bank(List<ItemStack> bank) { payload.bank = bank; return this; }
        public Builder inventory(List<ItemStack> inventory) { payload.inventory = inventory; return this; }
        public Builder equipment(Map<String, ItemStack> equipment) { payload.equipment = equipment; return this; }
        public Builder skills(Map<String, SkillData> skills) { payload.skills = skills; return this; }
        public Builder collectionLog(List<Integer> collectionLog) { payload.collectionLog = collectionLog; return this; }
        public Builder lootingBag(List<ItemStack> lootingBag) { payload.lootingBag = lootingBag; return this; }
        public SyncPayload build() { return payload; }
    }
}

package com.gimvisualiser;

import com.gimvisualiser.models.SyncPayload;
import com.google.gson.Gson;
import okhttp3.Call;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import okhttp3.Callback;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.zip.GZIPOutputStream;

@Singleton
public class SyncService
{
    private static final Logger log = LoggerFactory.getLogger(SyncService.class);

    private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
    private static final MediaType GZIP_JSON = MediaType.get("application/json");
    private static final int GZIP_THRESHOLD = 5 * 1024; // 5KB
    private static final long DEBOUNCE_MS = 500;
    private static final int MAX_RETRY_QUEUE_SIZE = 10;
    private static final long RETRY_INTERVAL_MS = 30000; // 30 seconds

    private final OkHttpClient httpClient;
    private final Gson gson;
    private final GimVisualiserConfig config;
    private final ScheduledExecutorService scheduler;
    private final Queue<SyncPayload> retryQueue;

    private ScheduledFuture<?> pendingSync;
    private SyncPayload pendingPayload;
    private volatile SyncStatus status = SyncStatus.DISCONNECTED;
    private volatile long lastSyncTime = 0;
    private volatile String lastError = null;

    private SyncStatusListener statusListener;

    public enum SyncStatus
    {
        CONNECTED,
        SYNCING,
        DISCONNECTED,
        ERROR
    }

    public interface SyncStatusListener
    {
        void onStatusChange(SyncStatus status, long lastSyncTime, String error);
    }

    @Inject
    public SyncService(GimVisualiserConfig config, Gson gson, OkHttpClient httpClient)
    {
        this.config = config;
        this.gson = gson;
        this.httpClient = httpClient;
        this.scheduler = Executors.newSingleThreadScheduledExecutor();
        this.retryQueue = new ConcurrentLinkedQueue<>();

        // Start retry processor
        scheduler.scheduleAtFixedRate(this::processRetryQueue, RETRY_INTERVAL_MS, RETRY_INTERVAL_MS, TimeUnit.MILLISECONDS);
    }

    public void setStatusListener(SyncStatusListener listener)
    {
        this.statusListener = listener;
    }

    public void scheduleSync(SyncPayload payload)
    {
        if (!config.syncEnabled() || config.apiSyncKey().isEmpty())
        {
            log.debug("Sync disabled or no API key configured");
            return;
        }

        synchronized (this)
        {
            pendingPayload = payload;

            if (pendingSync != null && !pendingSync.isDone())
            {
                pendingSync.cancel(false);
            }

            pendingSync = scheduler.schedule(this::executeSync, DEBOUNCE_MS, TimeUnit.MILLISECONDS);
        }
    }

    private void executeSync()
    {
        SyncPayload payload;
        synchronized (this)
        {
            payload = pendingPayload;
            pendingPayload = null;
        }

        if (payload == null)
        {
            return;
        }

        sendSync(payload, false);
    }

    private void sendSync(SyncPayload payload, boolean isRetry)
    {
        updateStatus(SyncStatus.SYNCING, null);

        String json = gson.toJson(payload);
        byte[] body = json.getBytes(StandardCharsets.UTF_8);
        boolean useGzip = body.length > GZIP_THRESHOLD;

        RequestBody requestBody;
        Request.Builder requestBuilder = new Request.Builder()
            .url(config.apiBaseUrl() + "/api/sync")
            .addHeader("Authorization", "Bearer " + config.apiSyncKey());

        if (useGzip)
        {
            try
            {
                byte[] gzipped = gzip(body);
                requestBody = RequestBody.create(GZIP_JSON, gzipped);
                requestBuilder.addHeader("Content-Encoding", "gzip");
                log.debug("Using GZIP compression: {} -> {} bytes", body.length, gzipped.length);
            }
            catch (IOException e)
            {
                log.error("Failed to GZIP payload", e);
                requestBody = RequestBody.create(JSON, body);
            }
        }
        else
        {
            requestBody = RequestBody.create(JSON, body);
        }

        Request request = requestBuilder.post(requestBody).build();

        httpClient.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.error("Sync failed", e);
                handleSyncFailure(payload, isRetry, e.getMessage());
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                try
                {
                    if (response.isSuccessful())
                    {
                        lastSyncTime = System.currentTimeMillis();
                        updateStatus(SyncStatus.CONNECTED, null);
                        log.info("Sync successful for {}", payload.getRsn());
                    }
                    else
                    {
                        String errorBody = response.body() != null ? response.body().string() : "Unknown error";
                        log.error("Sync failed with status {}: {}", response.code(), errorBody);
                        handleSyncFailure(payload, isRetry, "HTTP " + response.code() + ": " + errorBody);
                    }
                }
                catch (IOException e)
                {
                    log.error("Error reading response", e);
                    handleSyncFailure(payload, isRetry, e.getMessage());
                }
                finally
                {
                    response.close();
                }
            }
        });
    }

    private void handleSyncFailure(SyncPayload payload, boolean isRetry, String error)
    {
        updateStatus(SyncStatus.ERROR, error);

        if (!isRetry && retryQueue.size() < MAX_RETRY_QUEUE_SIZE)
        {
            retryQueue.offer(payload);
            log.debug("Added payload to retry queue. Queue size: {}", retryQueue.size());
        }
    }

    private void processRetryQueue()
    {
        SyncPayload payload = retryQueue.poll();
        if (payload != null)
        {
            log.debug("Retrying sync from queue. Remaining: {}", retryQueue.size());
            // Update timestamp for retry
            payload = SyncPayload.builder()
                .rsn(payload.getRsn())
                .timestamp(System.currentTimeMillis())
                .combatLevel(payload.getCombatLevel())
                .bank(payload.getBank())
                .inventory(payload.getInventory())
                .equipment(payload.getEquipment())
                .skills(payload.getSkills())
                .collectionLog(payload.getCollectionLog())
                .lootingBag(payload.getLootingBag())
                .build();
            sendSync(payload, true);
        }
    }

    private void updateStatus(SyncStatus newStatus, String error)
    {
        this.status = newStatus;
        this.lastError = error;

        if (statusListener != null)
        {
            statusListener.onStatusChange(status, lastSyncTime, lastError);
        }
    }

    private byte[] gzip(byte[] data) throws IOException
    {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try (GZIPOutputStream gzos = new GZIPOutputStream(baos))
        {
            gzos.write(data);
        }
        return baos.toByteArray();
    }

    public SyncStatus getStatus()
    {
        return status;
    }

    public long getLastSyncTime()
    {
        return lastSyncTime;
    }

    public String getLastError()
    {
        return lastError;
    }

    public void forceSync(SyncPayload payload)
    {
        sendSync(payload, false);
    }

    public void shutdown()
    {
        scheduler.shutdownNow();
    }
}

package com.gimvisualiser;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

@SuppressWarnings("ALL")
public class GimVisualiserPluginTest
{
    public static void main(String[] args) throws Exception
    {
        // Enable assertions programmatically isn't possible, so we pass -ea via VM options
        // Or use the workaround below
        ExternalPluginManager.loadBuiltin(GimVisualiserPlugin.class);
        RuneLite.main(args);
    }
}

