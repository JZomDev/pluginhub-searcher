package gg.embargo;

import net.runelite.client.config.*;

import java.awt.Color;

@ConfigGroup("embargo")
public interface EmbargoConfig extends Config
{
    @ConfigSection(
            name = "Raid Notice Boards",
            description = "Section that houses Notice Board options",
            position = 1
    )
    String noticeBoardSettings = "NoticeBoardSettings";

    @ConfigItem(
            keyName = "highlightClan",
            name = "Highlight Embargo Members",
            description = "Whether or not to highlight clan chat members' names on notice boards (ToA, Tob)",
            position = 1,
            section = noticeBoardSettings
    )
    default boolean highlightClan()
    {
        return true;
    }

    @ConfigItem(
            keyName = "clanColor",
            name = "Highlight Color",
            description = "The color with which to highlight names from your current clan chat",
            position = 2,
            section = noticeBoardSettings
    )
    default Color clanColor()
    {
        return new Color(53, 201, 255);
    }

    @ConfigSection(
            name = "Collection Log Sync Button",
            description = "Add a button to the collection log interface to sync your collection log with Embargo",
            position = 2
    )
    String collectionLogSettings = "CollectionLogSettings";

    @ConfigItem(
            keyName = "showCollectionLogSyncButton",
            name = "Show Collection Log Sync Button",
            description = "Whether or not to render the Embargo collection log sync button",
            position = 1,
            section = collectionLogSettings
    )
    default boolean showCollectionLogSyncButton() { return true; }

    @ConfigSection(
            name = "Clan Easter Eggs",
            description = "Enables fun item name replacements like 'Dragon warhammer' to 'Bonker'",
            position = 3
    )
    String easterEggSettings = "EasterEggSettings";

    @ConfigItem(
        keyName = "enableClanEasterEggs",
        name = "Enable Easter Eggs",
        description = "A top level control to enable/disable the feature",
        position = 3,
        section = easterEggSettings
    )
    default boolean enableClanEasterEggs() {
        return true;
    }


    @ConfigItem(
            keyName = "enableItemRenames",
            name = "Enable Item Renames",
            description = "Enables item name replacements like 'Dragon warhammer' to 'Bonker'",
            position = 4,
            section = easterEggSettings
    )
    default boolean enableItemRenames() {
        return true;
    }

    @ConfigItem(
            keyName = "enableNpcRenames",
            name = "Enable NPC Renames",
            description = "Enables NPC name changes, like 'Pestilent Bloat' to 'Dr D1sconnect'",
            position = 5,
            section = easterEggSettings
    )
    default boolean enableNpcRenames() {
        return true;
    }

    @ConfigSection(
            name = "Chat Commands",
            description = "Section that houses Chat Command options",
            position = 4
    )
    String chatCommandSettings = "ChatCommandSettings";

    @ConfigItem(
            keyName = "chatCommandOutputColor",
            name = "Output Text Color",
            description = "The color that highlighted text will be when using clan chat commands.",
            position = 1,
            section = chatCommandSettings
    )
    default Color chatCommandOutputColor()
    {
        return new Color(255, 116, 0);
    }

}


package gg.embargo;

import com.google.inject.Provides;
import gg.embargo.collections.*;
import gg.embargo.commands.CommandManager;
import gg.embargo.eastereggs.NPCRenameManager;
import gg.embargo.manifest.ManifestManager;
import gg.embargo.ui.EmbargoPanel;
import gg.embargo.eastereggs.ItemRenameManager;
import gg.embargo.ui.MissingRequirementsPanel;
import gg.embargo.ui.SyncButtonManager;
import gg.embargo.noticeboard.NoticeBoardManager;
import gg.embargo.untrackables.UntrackableItemManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import net.runelite.http.api.loottracker.LootRecordType;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BiConsumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@PluginDescriptor(name = "Embargo Clan", description = "A plugin to sync your account with Embargo", tags = { "embargo",
		"clan", "embargo.gg", "ironman" })
public class EmbargoPlugin extends Plugin {

	private static final String CONFIG_GROUP = "embargo";
	private static final int SECONDS_BETWEEN_UPLOADS = 30;
	private static final int SECONDS_BETWEEN_PROFILE_UPDATES = 15;
	private static final Pattern COLLECTION_LOG_ITEM_REGEX = Pattern
			.compile("New item added to your collection log: (.*)");

	@Inject
	private DataManager dataManager;

	@Inject
	private ClientThread clientThread;

	@Inject
	private Client client;

	@Inject
	private EmbargoConfig config;

	@Inject
	private EmbargoPanel embargoPanel;

	@Inject
	private NoticeBoardManager noticeBoardManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private SyncButtonManager syncButtonManager;

	@Inject
	private CollectionLogManager clogManager;

	@Inject
	private UntrackableItemManager untrackableItemManager;

	@Inject
	private ItemRenameManager itemRenameManager;

	@Inject
	private NPCRenameManager npcRenameManager;

	@Inject
	public ManifestManager manifestManager;

	@Inject
	public CommandManager commandManager;

	private RuneScapeProfileType lastProfile;

	private NavigationButton navButton;

	private final Map<String, Integer> skillLevelCache = new HashMap<>();

	AtomicBoolean isUsernameRegistered = new AtomicBoolean(false);

	@Provides
	EmbargoConfig getConfig(ConfigManager configManager) {
		return configManager.getConfig(EmbargoConfig.class);
	}

	@Override
	protected void startUp() {
		log.info("Embargo Clan plugin started!");

		if (dataManager.stopTryingForAccount.get()) {
			return;
		}

		initializePanel();
		initializeManagers();

		lastProfile = null;
		dataManager.resetVarbsAndVarpsToCheck();
		skillLevelCache.clear();
		dataManager.getManifest();

		itemRenameManager.setupMenuRenames();

		if (client != null) {
			if (client.getGameState() == GameState.LOGGED_IN) {
				dataManager.isUserRegisteredAsync(client.getLocalPlayer().getName(), isRegistered -> {
					if (isRegistered) {
						embargoPanel.updateLoggedIn(false);
					}
				});
			}
		}
	}

	private void initializePanel() {
		embargoPanel = injector.getInstance(EmbargoPanel.class);
		embargoPanel.init();
		embargoPanel.updateLoggedIn(false);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");
		navButton = NavigationButton.builder()
				.tooltip("Embargo Clan")
				.icon(icon)
				.priority(0)
				.panel(embargoPanel)
				.build();

		clientToolbar.addNavigation(navButton);
	}

	private void initializeManagers() {
		if (config != null && config.showCollectionLogSyncButton()) {
			syncButtonManager.startUp();
		}

		clogManager.startUp(syncButtonManager);
		untrackableItemManager.startUp();
		noticeBoardManager.startUp();
		commandManager.startUp();

		if (config != null && config.highlightClan()) {
			noticeBoardManager.setNoticeBoards();
		}

		if (config != null && config.enableClanEasterEggs()) {
			itemRenameManager.startUp();
			npcRenameManager.startUp();
		}
	}

	@Inject
	private MissingRequirementsPanel missingRequirementsPanel;

	@Override
	protected void shutDown() {
		log.info("Embargo Clan plugin stopped!");

		dataManager.clearData();
		embargoPanel.reset();
		clientToolbar.removeNavigation(navButton);

		// Cleanup MissingRequirementsPanel to prevent timer and cache leaks
		if (missingRequirementsPanel != null) {
			missingRequirementsPanel.shutdown();
		}

		shutDownManagers();

		embargoPanel = null;
		navButton = null;
	}

	private void shutDownManagers() {
		noticeBoardManager.shutDown();
		clogManager.shutDown();
		untrackableItemManager.shutDown();
		syncButtonManager.shutDown();
		itemRenameManager.shutDown();
		npcRenameManager.shutDown();
		commandManager.shutDown();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		GameState gameState = event.getGameState();
		if (gameState == GameState.LOADING)
			return;

		if (gameState == GameState.LOGGED_IN && !embargoPanel.isLoggedIn) {
			log.debug("inside of condition, handling loggedIn");
			handleLoggedIn();
		} else if (gameState == GameState.LOGIN_SCREEN) {
			handleLoggedOut();
		}
	}

	private void handleLoggedIn() {
		clientThread.invokeLater(() -> {
			if (client == null || dataManager.stopTryingForAccount.get()) {
				return false;
			}

			if (isUsernameRegistered.get()) {
				embargoPanel.updateLoggedIn(true);
				return true;
			}

			Player localPlayer = client.getLocalPlayer();
			if (localPlayer != null) {
				String username = localPlayer.getName();

				dataManager.isUserRegisteredAsync(username, isRegistered -> {
					if (isRegistered) {
						embargoPanel.updateLoggedIn(true);
						isUsernameRegistered.set(true);
					}
				});
			}
			return isUsernameRegistered.get();
		});
	}

	private void handleLoggedOut() {
		log.debug("User logged out");

		// Clear both panel references
		if (embargoPanel != null) {
			SwingUtilities.invokeLater(() -> embargoPanel.logOut());
		} else {
			log.debug("embargoPanel is null!!!");
		}

		// Also clear the panel reference (which is different from embargoPanel)
		if (embargoPanel != null) {
			embargoPanel.reset();
			embargoPanel.updateLoggedIn(false);
		}

		// Clear data in DataManager to ensure complete reset
		dataManager.clearData();

		// Reset skill cache
		skillLevelCache.clear();
	}

	@Schedule(period = SECONDS_BETWEEN_UPLOADS, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void ensureLatestManifest() {
		if (manifestManager.getLatestManifest() != null) {
			if (!(manifestManager.getLastCheckedManifestVersion() == manifestManager.getLatestManifest()
					.getVersion())) {
				manifestManager.getLatestManifest();
			}
		}
	}

	@Schedule(period = SECONDS_BETWEEN_UPLOADS, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void submitToAPI() {
		if (client == null) {
			return;
		}

		GameState gameState = client.getGameState();
		if (gameState != GameState.HOPPING && gameState != GameState.LOGIN_SCREEN) {
			dataManager.submitToAPI();
			updatePlayerRegistrationStatus();
		} else {
			// log.debug("User is hopping or logged out, do not send data");
			embargoPanel.logOut();
		}
	}

	private void updatePlayerRegistrationStatus() {
		if (dataManager.stopTryingForAccount.get()) {
			return;
		}
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer != null) {
			String username = localPlayer.getName();
			dataManager.isUserRegisteredAsync(username, isRegistered -> {
				if (isRegistered) {
					log.debug("updateProfileAfterLoggedIn Member registered");
					embargoPanel.updateLoggedIn(true);
				}
			});
		}
	}

	@Schedule(period = SECONDS_BETWEEN_PROFILE_UPDATES, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void checkProfileChanged() {
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer != null && client.getGameState() == GameState.LOGGED_IN) {
			embargoPanel.updateLoggedIn(true);
			clientThread.invokeLater(this::checkProfileChange);
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage) {
		if (client == null || manifestManager.getLatestManifest() == null)
			return;

		Player player = client.getLocalPlayer();
		if (player == null)
			return;

		String message = chatMessage.getMessage();

		ChatMessageType messageType = chatMessage.getType();
		RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);

		// Only process for standard profile
		if (profileType != RuneScapeProfileType.STANDARD) {
			return;
		}

		// Check for collection log items
		if (messageType == ChatMessageType.GAMEMESSAGE) {
			Matcher matcher = COLLECTION_LOG_ITEM_REGEX.matcher(message);
			if (matcher.matches()) {
				String obtainedItemName = Text.removeTags(matcher.group(1));
				dataManager.uploadCollectionLogUnlock(obtainedItemName, player.getName());
			}
		}

		// Check for activity completions
		if (messageType == ChatMessageType.GAMEMESSAGE ||
				messageType == ChatMessageType.FRIENDSCHATNOTIFICATION ||
				messageType == ChatMessageType.SPAM) {

			if (processCompletionMessages(manifestManager.getLatestManifest().getRaidCompletionMessages(), message,
					(name, _message) -> dataManager.uploadRaidCompletion(name, _message))) {
				// return early as it saves time in case it gets processed here, otherwise it's
				// most likely a minigame completion message or unrelated
				return;
			}

			processCompletionMessages(manifestManager.getLatestManifest().minigameCompletionMessages, message,
					(name, _message) -> dataManager.uploadMinigameCompletion(name, _message));
		}
	}

	private boolean processCompletionMessages(Map<String, String> messageMap, String chatMessage,
			BiConsumer<String, String> uploadAction) {
		for (Map.Entry<String, String> entry : messageMap.entrySet()) {
			String name = entry.getKey();
			String completionMessage = entry.getValue();

			if (chatMessage.contains(completionMessage)) {
				log.debug("Sending API request for completed activity");
				uploadAction.accept(name, chatMessage);
				return true;
			}
		}
		return false;
	}

	public void checkProfileChange() {
		if (client == null) {
			return;
		}

		RuneScapeProfileType currentProfile = RuneScapeProfileType.getCurrent(client);
		boolean isStandardProfile = currentProfile == RuneScapeProfileType.STANDARD;
		boolean profileChanged = isStandardProfile && currentProfile != lastProfile;
		boolean dataAvailable = dataManager.getVarbitsToCheck() != null && dataManager.getVarpsToCheck() != null;
		boolean isLoggedIn = client.getGameState() == GameState.LOGGED_IN;

		if (profileChanged && dataAvailable && isLoggedIn) {
			// Profile change, we should clear the dataManager and do a new initial dump
			log.debug("Profile changed to standard. Reloading all data and updating profile");
			lastProfile = currentProfile;
			dataManager.clearData();
			dataManager.loadInitialData();
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged statChanged) {
		Skill skill = statChanged.getSkill();
		if (skill == null) {
			return;
		}

		String skillName = skill.getName();
		int newLevel = statChanged.getLevel();
		Integer cachedLevel = skillLevelCache.get(skillName);

		if (cachedLevel == null || cachedLevel != newLevel) {
			skillLevelCache.put(skillName, newLevel);
			dataManager.storeSkillChanged(skillName, newLevel);
		}
	}

	@Subscribe
	public void onLootReceived(final LootReceived event) {
		LootRecordType eventType = event.getType();
		if (eventType != LootRecordType.NPC && eventType != LootRecordType.EVENT) {
			return;
		}

		String npcName = event.getName();
		if (dataManager.shouldTrackLoot(npcName)) {
			log.debug("Player killed {}", npcName);
			dataManager.uploadLoot(event);
		} else {
			log.debug("Player killed {}, nothing to log", npcName);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals(CONFIG_GROUP)) {
			return;
		}

		// Update notice boards based on config
		noticeBoardManager.unsetNoticeBoards();
		if (config.highlightClan()) {
			noticeBoardManager.setTOBNoticeBoard();
			noticeBoardManager.setTOANoticeBoard();
		}

		// Update sync button based on config
		if (config.showCollectionLogSyncButton()) {
			syncButtonManager.startUp();
		} else {
			syncButtonManager.shutDown();
		}

		// Handle item rename config changes
		if (event.getKey().equals("enableClanEasterEggs")) {
			if (config.enableClanEasterEggs()) {
				itemRenameManager.startUp();
				npcRenameManager.startUp();
			} else {
				itemRenameManager.shutDown();
				npcRenameManager.shutDown();
			}
		}
	}

}

package gg.embargo.eastereggs;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import gg.embargo.EmbargoConfig;
import gg.embargo.manifest.ManifestManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

@Slf4j
public class NPCRenameManager {

    private final EventBus eventBus;
    private final EmbargoConfig config;
    private final ManifestManager manifestManager;

    @Inject
    public NPCRenameManager(EventBus eventBus, EmbargoConfig config, ManifestManager manifestManager) {
        this.eventBus = eventBus;
        this.config = config;
        this.manifestManager = manifestManager;
    }

    private static final Set<MenuAction> NPC_MENU_ACTIONS = ImmutableSet.of(
            MenuAction.NPC_FIRST_OPTION,
            MenuAction.NPC_SECOND_OPTION,
            MenuAction.NPC_THIRD_OPTION,
            MenuAction.NPC_FOURTH_OPTION,
            MenuAction.NPC_FIFTH_OPTION,
            MenuAction.WIDGET_TARGET_ON_NPC,
            MenuAction.EXAMINE_NPC);

    private static final ImmutableMap<String, String> DEFAULT_NPC_RENAMES = ImmutableMap.<String, String>builder().build();
    private final Map<String, String> customNPCRemaps = new HashMap<>();

    private boolean manifestFetchAttempted = false;

    public boolean featureEnabled() {
        return config.enableClanEasterEggs() && config.enableNpcRenames();
    }

    @Subscribe
    protected void onMenuEntryAdded(MenuEntryAdded event) {

        if (!featureEnabled()) {
            return;
        }

        if (manifestManager.getManifest() == null) {
            manifestManager.getLatestManifest();
            return;
        }

        // Check if manifest is empty and fetch if needed
        if (manifestManager.getManifest().getItemRenames() == null) {
            manifestManager.getLatestManifest();
        }

        parseManifest();
        MenuEntry entry = event.getMenuEntry();


        if (NPC_MENU_ACTIONS.contains(entry.getType())) {
            remapMenuEntryText(entry, (HashMap<String, String>) customNPCRemaps);  // Use customNPCRemaps instead of npcListHashMap
        }
    }

    public void startUp() {
        eventBus.register(this);

        if (!featureEnabled()) return;

        setupMenuRenames();
        manifestManager.getLatestManifest(); // Fetch manifest on startup
    }

    public void shutDown() {
        customNPCRemaps.clear();
        eventBus.unregister(this);
    }

    public void setupMenuRenames() {
        customNPCRemaps.clear();
        customNPCRemaps.putAll(DEFAULT_NPC_RENAMES);
    }

    public void parseManifest() {
        if (manifestManager.getManifest().getNpcRenames() == null || manifestManager.getManifest().getNpcRenames().isEmpty()) {
            if (!manifestFetchAttempted) {
                manifestFetchAttempted = true;
                manifestManager.getLatestManifest();
                log.debug("manifest.npcRenames is empty, attempting to refetch");
            }
            return;
        }

        // Clear and repopulate custom remaps
        customNPCRemaps.clear();
        customNPCRemaps.putAll(DEFAULT_NPC_RENAMES);

        // Add manifest renames
        for (Map.Entry<String, String> entry : manifestManager.getManifest().getNpcRenames().entrySet()) {
            String originalName = entry.getKey();
            String newName = entry.getValue();
            customNPCRemaps.put(originalName, newName);
        }
    }

    private void remapMenuEntryText(MenuEntry menuEntry, HashMap<String, String> map) {
        String target = menuEntry.getTarget();
        String cleanTarget;
        
        NPC npc = menuEntry.getNpc();
        cleanTarget = npc != null ? Text.removeTags(npc.getName()) : Text.removeTags(target);
        
        String replacement = customNPCRemaps.get(cleanTarget);
        if (replacement != null) {
            menuEntry.setTarget(target.replace(cleanTarget, replacement));
        }
    }
}



package gg.embargo.eastereggs;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import gg.embargo.EmbargoConfig;
import gg.embargo.manifest.ManifestManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;
import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

@Slf4j
@Singleton
public class ItemRenameManager {

    private final EventBus eventBus;
    private final EmbargoConfig config;
    private final ManifestManager manifestManager;

    @Inject
    public ItemRenameManager(EventBus eventBus, EmbargoConfig config, ManifestManager manifestManager) {
        this.eventBus = eventBus;
        this.config = config;
        this.manifestManager = manifestManager;
    }

    private boolean manifestFetchAttempted = false;

    private static final Set<MenuAction> ITEM_MENU_ACTIONS = ImmutableSet.of(
            MenuAction.GROUND_ITEM_FIRST_OPTION, MenuAction.GROUND_ITEM_SECOND_OPTION,
            MenuAction.GROUND_ITEM_THIRD_OPTION, MenuAction.GROUND_ITEM_FOURTH_OPTION,
            MenuAction.GROUND_ITEM_FIFTH_OPTION, MenuAction.EXAMINE_ITEM_GROUND,
            // Inventory + Using Item on Players/NPCs/Objects
            MenuAction.CC_OP, MenuAction.CC_OP_LOW_PRIORITY, MenuAction.WIDGET_TARGET,
            MenuAction.WIDGET_TARGET_ON_PLAYER, MenuAction.WIDGET_TARGET_ON_NPC,
            MenuAction.WIDGET_TARGET_ON_GAME_OBJECT, MenuAction.WIDGET_TARGET_ON_GROUND_ITEM,
            MenuAction.WIDGET_TARGET_ON_WIDGET);

    // Default item name remappings
    private static final ImmutableMap<String, String> DEFAULT_ITEM_REMAP = ImmutableMap.<String, String>builder().build();

    // Map for custom renamings
    private final Map<String, String> customItemRemap = new HashMap<>();

    public boolean featureEnabled() {
        return config.enableClanEasterEggs() && config.enableItemRenames();
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event) {
        // Only process if easter eggs are enabled
        if (!featureEnabled()) {
            return;
        }

        if (manifestManager.getManifest() == null) {
            manifestManager.getLatestManifest();
            return;
        }

        // Check if manifest is empty and fetch if needed
        if (manifestManager.getManifest().getItemRenames() == null) {
            manifestManager.getLatestManifest();
        }

        parseManifest();
        
        MenuEntry entry = event.getMenuEntry();
        if (ITEM_MENU_ACTIONS.contains(entry.getType())) {
            remapMenuEntryText(entry, customItemRemap);
        }
    }

    public void startUp() {
        eventBus.register(this);

        if (!featureEnabled()) return;

        setupMenuRenames();
        manifestManager.getLatestManifest(); // Fetch manifest on startup
    }

    public void shutDown() {
        customItemRemap.clear();
        eventBus.unregister(this);
    }

    public void setupMenuRenames() {
        customItemRemap.clear();
        customItemRemap.putAll(DEFAULT_ITEM_REMAP);
    }

    public void parseManifest() {
        if (manifestManager.getManifest().getItemRenames() == null || manifestManager.getManifest().getItemRenames().isEmpty()) {
            if (!manifestFetchAttempted) {
                log.debug("manifest.itemRenames is empty, attempting to refetch");
            }
            return;
        }

        // Clear and repopulate to prevent unbounded accumulation
        customItemRemap.clear();
        customItemRemap.putAll(DEFAULT_ITEM_REMAP);

        for (Map.Entry<String, String> entry : manifestManager.getManifest().getItemRenames().entrySet()) {
            String originalName = entry.getKey();
            String newName = entry.getValue();
            customItemRemap.put(originalName, newName);
        }
    }

    /**
     * Remaps a menu entry's text if the target matches an entry in the provided map.
     * 
     * @param menuEntry The menu entry to modify
     * @param map The map of item names to replacement item names
     */
    private void remapMenuEntryText(MenuEntry menuEntry, Map<String, String> map) {
        String target = menuEntry.getTarget();
        String cleanTarget;
        
        NPC npc = menuEntry.getNpc();
        cleanTarget = npc != null ? Text.removeTags(npc.getName()) : Text.removeTags(target);
        
        String replacement = map.get(cleanTarget);
        if (replacement != null) {
            menuEntry.setTarget(target.replace(cleanTarget, replacement));
        }
    }
}

package gg.embargo.untrackables;

import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;


@Slf4j
@Singleton
public class UntrackableItemManager {

    @Inject
    private Client client;

    private final EventBus eventBus;

    @Inject
    private UntrackableItemManager(Client client, EventBus eventBus) {
        this.client = client;
        this.eventBus = eventBus;
    }

    @Inject
    private OkHttpClient okHttpClient;

    private static final String UNTRACKABLE_ENDPOINT = "https://embargo.gg/api/untrackables";

    // Limit size to prevent unbounded growth - LRU eviction for player loot timestamps
    private static final int MAX_LOOT_TIME_CACHE_SIZE = 50;
    private final Map<String, LocalDateTime> lastLootTime = new LinkedHashMap<String, LocalDateTime>(MAX_LOOT_TIME_CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<String, LocalDateTime> eldest) {
            return size() > MAX_LOOT_TIME_CACHE_SIZE;
        }
    };

    @Getter
    enum UntrackableItems {

        BOOK_OF_THE_DEAD(25818),
        MUSIC_CAPE(13221),
        MUSIC_CAPE_T(13222),
        BARROWS_GLOVES(7462),
        IMBUED_SARADOMIN_CAPE(21791),
        IMBUED_GUTHIX_CAPE(21793),
        IMBUED_ZAMORAK_CAPE(21795),
        IMBUED_SARADOMIN_MAX_CAPE(21776),
        IMBUED_ZAMORAK_MAX_CAPE(21780),
        IMBUED_GUTHIX_MAX_CAPE(21784),
        IMBUED_SARADOMIN_MAX_CAPE_I(24232),
        IMBUED_ZAMORAK_MAX_CAPE_I(24233),
        IMBUED_GUTHIX_MAX_CAPE_I(24234),

        //BINGO #1 ITEMS FOR START COUNTS
        BEGINNER_REWARD_CASKET(23245),
        EASY_REWARD_CASKET(20546),
        MEDIUM_REWARD_CASKET(20545),
        HARD_REWARD_CASKET(20544),
        ELITE_REWARD_CASKET(20543),
        MASTER_REWARD_CASKET(19836),

        MOSSY_KEY(22374),
        GIANT_KEY(20754);


        private final int itemId;

        UntrackableItems(int itemId) {
            this.itemId = itemId;
        }
    }

    void getUntrackableItems(String username) {
        Widget widget = client.getWidget(786445);
        ItemContainer itemContainer = client.getItemContainer(InventoryID.BANK);
        Widget[] children;
        if (widget != null) {
            children = widget.getChildren();
        } else {
            return;
        }
        if (itemContainer != null && children != null) {

            //Convert itemMap to use manifest.untrackableItems (which is a list of integers) instead of hardcoded enum
            var itemMap = Arrays.stream(UntrackableItems.values()).map(UntrackableItems::getItemId).collect(Collectors.toCollection(HashSet::new));
            List<Integer> playerItems = new ArrayList<>();
            java.util.Map<Integer, Integer> itemQuantities = new java.util.HashMap<>();
            for (int i = 0; i < itemContainer.size(); ++i) {

                Widget child = children[i];
                var currentItem = child.getItemId();
                if (itemMap.contains(currentItem)) {
                    playerItems.add(currentItem);
                    int quantity = child.getItemQuantity();
                    itemQuantities.put(currentItem, quantity);
                }
            }

            var RequestBody = new FormBody.Builder();
            for (int i=0; i < playerItems.size(); i++) {
                RequestBody.add("itemIds[" + i + "]", String.valueOf(playerItems.get(i)));
                RequestBody.add("quantities[" + i + "]", String.valueOf(itemQuantities.get(playerItems.get(i))));
            }

            RequestBody.add("username", username);

            Request request = new Request.Builder()
                    .url(UNTRACKABLE_ENDPOINT)
                    .post(RequestBody.build())
                    .addHeader("Content-Type", "application/json")
                    .build();

            try {
                okHttpClient.newCall(request).enqueue(new Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        log.error("Something went wrong inside of getUntrackableItems: {}", e.getLocalizedMessage());
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) {
                        if (response.isSuccessful()) {
                            log.debug("Successfully submitted getUntrackableItems");
                        }
                        response.close();
                    }
                });
            } catch (IllegalArgumentException e) {
                log.error("Bad URL given: {}", e.getLocalizedMessage());
            }
        }
    }

    public void startUp() {
        eventBus.register(this);
    }

    public void shutDown() {
        eventBus.unregister(this);
        lastLootTime.clear();
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event) {
        if (event.getScriptId() == 277) {
            if (client == null || client.getLocalPlayer() == null) {
                return;
            }

            var username = client.getLocalPlayer().getName();

            if (lastLootTime.containsKey(username)) {
                LocalDateTime lastLootTimestamp = lastLootTime.get(username);

                if (LocalDateTime.now().isBefore(lastLootTimestamp)) {
                    log.debug("Player has opened bank within the last 3 minutes, not checking for untrackable items");
                    return;
                }

            }
            getUntrackableItems(username);
            lastLootTime.put(username, LocalDateTime.now().plusMinutes(3));
        }
    }
}

/*
 * Copyright (c) 2021, andmcadams
 * modified by Sharpienero, Contronym
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package gg.embargo;

import com.google.common.collect.HashMultimap;
import com.google.gson.*;
import gg.embargo.manifest.ManifestManager;
import gg.embargo.ui.EmbargoPanel;
import gg.embargo.untrackables.UntrackableItemManager;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.task.Schedule;
import okhttp3.*;
import okio.BufferedSource;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Consumer;

@Slf4j
@Singleton
public class DataManager {
    @Inject
    private Client client;

    @Inject
    private ItemManager itemManager;

    @Inject
    private ClientThread clientThread;

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private EmbargoPanel embargoPanel;

    @Inject
    private Gson gson;

    @Getter
    @Setter
    private HashSet<Integer> varpsToCheck;

    @Getter
    @Setter
    private HashSet<Integer> varbitsToCheck;

    @Inject
    private ManifestManager manifestManager;

    @Getter
    @Setter
    private int lastManifestVersion = -1;

    AtomicBoolean isUsernameRegistered = new AtomicBoolean(false);
    public AtomicBoolean stopTryingForAccount = new AtomicBoolean(false);

    private int[] oldVarps;

    private final HashMultimap<Integer, Integer> varpToVarbitMapping = HashMultimap.create();

    private final HashMap<Integer, Integer> varbData = new HashMap<>();
    private final HashMap<Integer, Integer> varpData = new HashMap<>();
    private final HashMap<String, Integer> levelData = new HashMap<>();

    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    enum APIRoutes {
        MANIFEST("runelite/manifest"),
        UNTRACKABLES("untrackables"),
        CHECKREGISTRATION("checkregistration"),
        GET_PROFILE("getgear"),
        SUBMIT_LOOT("loot"),
        GET_RAID_MONSTERS_TO_TRACK_LOOT("lootBosses"),
        PREPARE_RAID("raid"),
        UPLOAD_CLOG("collectionlog"),
        MINIGAME_COMPLETE("minigame"),
        GET_MEMBER_INFO("embargo-profile");

        APIRoutes(String route) {
            this.route = route;
        }

        private final String route;

        @Override
        public String toString() {
            return route;
        }
    }

    // private static final String MOCK_API_URI =
    // "https://a278d141-927f-433b-8e4b-6d994067900d.mock.pstmn.io/api/";
    private static final String API_URI = "https://embargo.gg/api/";
    private static final String MANIFEST_ENDPOINT = API_URI + APIRoutes.MANIFEST;
    private static final String UNTRACKABLE_POST_ENDPOINT = API_URI + APIRoutes.UNTRACKABLES;
    private static final String CHECK_REGISTRATION_ENDPOINT = API_URI + APIRoutes.CHECKREGISTRATION;
    private static final String GET_PROFILE_ENDPOINT = API_URI + APIRoutes.GET_PROFILE;
    private static final String SUBMIT_LOOT_ENDPOINT = API_URI + APIRoutes.SUBMIT_LOOT;
    private static final String TRACK_MONSTERS_ENDPOINT = API_URI + APIRoutes.GET_RAID_MONSTERS_TO_TRACK_LOOT;
    private static final String PREPARE_RAID_ENDPOINT = API_URI + APIRoutes.PREPARE_RAID;
    private static final String MINIGAME_COMPLETION_ENDPOINT = API_URI + APIRoutes.MINIGAME_COMPLETE;
    private static final String CLOG_UNLOCK_ENDPOINT = API_URI + APIRoutes.UPLOAD_CLOG;
    private static final String GET_MEMBER_INFO_ENDPOINT = API_URI + APIRoutes.GET_MEMBER_INFO;

    // Boss list from API - use volatile for thread safety and instance field for proper cleanup
    private volatile List<String> bossesToTrack = null;

    public void storeVarbitChanged(int varbIndex, int varbValue) {
        synchronized (this) {
            varbData.put(varbIndex, varbValue);
        }
    }

    public void resetVarbsAndVarpsToCheck() {
        varbitsToCheck = null;
        varpsToCheck = null;
    }

    public List<Player> getSurroundingPlayers() {
        return client.getPlayers();
    }

    public boolean shouldTrackLoot(String bossName) {
        if (bossName == null || bossName.isEmpty()) {
            return false;
        }

        List<String> bosses = getTrackableBosses();
        if (bosses == null) {
            return false;
        }

        return bosses.contains(bossName);
    }

    public List<String> getTrackableBosses() {
        if (bossesToTrack != null) {
            return bossesToTrack;
        }
        okHttpClient.newCall(new Request.Builder().url(TRACK_MONSTERS_ENDPOINT).build()).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.debug("Failed to get raid boss list", e);
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                try {
                    if (response.isSuccessful() && response.body() != null) {
                        String json = response.body().string();
                        // Parse as List<String> with proper type safety
                        List<String> parsed = gson.fromJson(json, new com.google.gson.reflect.TypeToken<List<String>>(){}.getType());
                        if (parsed != null) {
                            bossesToTrack = parsed;
                        }
                    }
                } finally {
                    response.close();
                }
            }
        });
        return null;
    }

    /**
     * Clears the cached boss list. Called during cleanup.
     */
    public void clearBossCache() {
        bossesToTrack = null;
    }

    public void uploadCollectionLogUnlock(String item, String player) {
        JsonObject payload = getClogUploadPayload(item, player);
        // log.debug(String.valueOf(payload));

        okHttpClient.newCall(new Request.Builder().url(CLOG_UNLOCK_ENDPOINT)
                .post(RequestBody.create(JSON, payload.toString())).build()).enqueue(new Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        log.debug("Failed to upload new clog slot to Embargo", e);
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                        // Update what we want to track on the fly
                        if (response.isSuccessful()) {
                            log.debug("Successfully uploaded new collection log slot");
                            response.close();
                            return;
                        }

                        response.close();
                    }
                });
    }

    public void uploadRaidCompletion(String raid, String message) {
        if (client == null || client.getLocalPlayer() == null) {
            return;
        }

        JsonObject payload = getRaidCompletionPayload(raid, message);
        okHttpClient.newCall(new Request.Builder().url(PREPARE_RAID_ENDPOINT)
                .post(RequestBody.create(JSON, payload.toString())).build()).enqueue(new Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        log.debug("Failed to upload upload raid completion", e);
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                        if (response.isSuccessful()) {
                            log.debug("Successfully uploaded raid preparation");
                        }

                        response.close();
                    }
                });
    }

    public void uploadMinigameCompletion(String minigameName, String message) {
        if (client == null || client.getLocalPlayer() == null) {
            return;
        }

        JsonObject payload = getMinigamePayload(minigameName, message);
        okHttpClient.newCall(new Request.Builder().url(MINIGAME_COMPLETION_ENDPOINT)
                .post(RequestBody.create(JSON, payload.toString())).build()).enqueue(new Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        log.debug("Failed to upload upload minigame completion", e);
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                        if (response.isSuccessful()) {
                            log.debug("Successfully uploaded minigame preparation");
                        }

                        response.close();
                    }
                });
    }

    private JsonObject getClogUploadPayload(String itemName, String username) {

        JsonObject payload = new JsonObject();
        payload.addProperty("playerName", username);
        payload.addProperty("itemName", itemName);

        return payload;
    }

    @NonNull
    private JsonObject getMinigamePayload(String minigame, String message) {
        var user = client.getLocalPlayer().getName();
        var world = client.getWorld();
        List<Player> players = getSurroundingPlayers();

        // convert List<Player> to JSON
        JsonArray playersJson = new JsonArray();
        for (Player player : players) {
            JsonObject playerJson = new JsonObject();
            playerJson.addProperty("name", player.getName());
            playersJson.add(playerJson);
        }

        JsonObject payload = new JsonObject();
        payload.addProperty("minigame", minigame);
        payload.addProperty("world", world);
        payload.addProperty("message", message);
        payload.addProperty("user", user);
        payload.add("players", playersJson);
        return payload;
    }

    @NonNull
    private JsonObject getRaidCompletionPayload(String raid, String message) {
        var user = client.getLocalPlayer().getName();
        List<Player> players = getSurroundingPlayers();

        // convert List<Player> to JSON
        JsonArray playersJson = new JsonArray();
        for (Player player : players) {
            JsonObject playerJson = new JsonObject();
            playerJson.addProperty("name", player.getName());
            playersJson.add(playerJson);
        }

        JsonObject payload = new JsonObject();
        payload.addProperty("raid", raid);
        payload.addProperty("message", message);
        payload.addProperty("user", user);
        payload.add("players", playersJson);
        return payload;
    }

    public CompletableFuture<JsonObject> getProfileAsync(String username, boolean isMemberInfoCall) {
        CompletableFuture<JsonObject> future = new CompletableFuture<>();
        Request request = null;

        if (isMemberInfoCall) {
            request = new Request.Builder()
                    .url(GET_MEMBER_INFO_ENDPOINT + '/' + username)
                    .get()
                    .build();
        } else {
            request = new Request.Builder()
                    .url(GET_PROFILE_ENDPOINT + '/' + username)
                    .get()
                    .build();
        }

        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                future.complete(new JsonObject()); // Complete with empty object on failure
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                if (response.isSuccessful()) {
                    BufferedSource source = response.body().source();
                    String json = source.readUtf8();
                    response.close();
                    future.complete(gson.fromJson(json, JsonObject.class));
                } else {
                    response.close();
                    future.complete(new JsonObject()); // Complete with empty object on unsuccessful response
                }
            }
        });

        return future;
    }

    private final AtomicBoolean apiFailureMode = new AtomicBoolean(false);
    private final AtomicLong lastApiFailure = new AtomicLong(0);
    private static final long API_RETRY_DELAY_MINUTES = 1;

    /**
     * Checks if a user is registered with Embargo asynchronously
     * @param username The username to check
     * @param callback Callback to handle the result
     */
    public void isUserRegisteredAsync(String username, Consumer<Boolean> callback) {
        if (username == null) {
            callback.accept(false);
            return;
        }

        if (stopTryingForAccount.get()) {
            callback.accept(false);
            return;
        }

        if (isUsernameRegistered.get()) {
            callback.accept(true);
            return;
        }

        log.debug("Checking if {} is registered with Embargo", username);

        // If we're in API failure mode, only retry after the delay period
        long currentTime = Instant.now().getEpochSecond();
        long failureTime = lastApiFailure.get();
        long elapsedMinutes = TimeUnit.SECONDS.toMinutes(currentTime - failureTime);

        if (apiFailureMode.get() && elapsedMinutes < API_RETRY_DELAY_MINUTES) {
            log.debug("apiFailureMode is true, skipping execution for {} minute(s)", API_RETRY_DELAY_MINUTES);
            callback.accept(false);
            return;
        }

        apiFailureMode.set(false);

        try {
            Request request = new Request.Builder()
                    .url(CHECK_REGISTRATION_ENDPOINT + "/" + username)
                    .get()
                    .build();

            okHttpClient.newCall(request).enqueue(new Callback() {
                @Override
                public void onFailure(@NonNull Call call, @NonNull IOException e) {
                    log.error("Failed to check if {} is registered with Embargo's database", username);
                    apiFailureMode.set(true);
                    lastApiFailure.set(Instant.now().getEpochSecond());
                    callback.accept(false);
                }

                @Override
                public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                    try (response) {
                        if (response.isSuccessful()) {
                            String responseBody = response.body().string();
                            JsonObject jsonResponse = gson.fromJson(responseBody, JsonObject.class);
                            if (jsonResponse != null && jsonResponse.has("message") && "registered".equals(jsonResponse.get("message").getAsString())) {
                                log.debug("{} is registered, return true", username);
                                isUsernameRegistered.set(true);
                                callback.accept(true);
                            } else {
                                log.debug("{} is NOT registered, return false", username);
                                stopTryingForAccount.set(true);
                                callback.accept(false);
                            }
                            apiFailureMode.set(false);

                        } else {
                            String responseBody = response.body().string();
                            JsonObject jsonResponse = gson.fromJson(responseBody, JsonObject.class);
                            if (jsonResponse != null && jsonResponse.has("message") && "not registered".equals(jsonResponse.get("message").getAsString())) {
                                stopTryingForAccount.set(true);
                                callback.accept(false);
                                return;
                            }
                            log.error("Failed to check if {} is registered with Embargo's database. Status: {}",
                                    username, response.code());
                            apiFailureMode.set(true);
                            lastApiFailure.set(Instant.now().getEpochSecond());
                            callback.accept(false);
                            isUsernameRegistered.set(false);
                        }
                    }
                }
            });
        } catch (Exception e) {
            // Log once and enter failure mode
            if (!apiFailureMode.get()) {
                log.error("Failed to check if user is registered. API may be down. Will retry in {} minutes.",
                        API_RETRY_DELAY_MINUTES, e);
                apiFailureMode.set(true);
                lastApiFailure.set(Instant.now().getEpochSecond());
                isUsernameRegistered.set(false);
            }
            callback.accept(false);
        }
    }


    public void uploadLoot(LootReceived event) {
        JsonObject payload = getJsonObject(event);

        log.debug("Uploading payload: " + payload);

        Request request = new Request.Builder()
                .url(SUBMIT_LOOT_ENDPOINT)
                .post(RequestBody.create(JSON, payload.toString()))
                .build();

        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.error("Error uploading loot", e);
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                if (response.isSuccessful()) {
                    log.debug("Loot uploaded successfully");
                } else {
                    log.error("Loot upload failed with status " + response.code());
                }
                response.close();
            }
        });
    }

    @NonNull
    private JsonObject getJsonObject(LootReceived event) {
        Collection<ItemStack> itemStacks = event.getItems();

        var user = client.getLocalPlayer().getName();
        List<Player> players = getSurroundingPlayers();

        // convert List<Player> to JSON
        JsonArray playersJson = new JsonArray();
        for (Player player : players) {
            JsonObject playerJson = new JsonObject();
            playerJson.addProperty("name", player.getName());
            playersJson.add(playerJson);
        }

        // convert itemStacks to JSON using gson
        JsonArray itemStacksJson = new JsonArray();
        for (ItemStack itemStack : itemStacks) {
            JsonObject itemStackJson = new JsonObject();
            itemStackJson.addProperty("id", itemStack.getId());
            itemStackJson.addProperty("quantity", itemStack.getQuantity());
            itemStackJson.addProperty("price", itemManager.getItemPrice(itemStack.getId()));
            itemStackJson.addProperty("name", itemManager.getItemComposition(itemStack.getId()).getName());

            itemStacksJson.add(itemStackJson);
        }

        // convert json array to String
        String itemStacksJsonString = itemStacksJson.toString();

        // build payload with bossName and itemStacks
        JsonObject payload = new JsonObject();
        payload.addProperty("bossName", event.getName());
        payload.addProperty("user", user);
        payload.addProperty("itemStacks", itemStacksJsonString);
        payload.add("players", playersJson);
        return payload;
    }

    public void storeVarbitChangedIfNotStored(int varbIndex, int varbValue) {
        synchronized (this) {
            if (!varbData.containsKey(varbIndex))
                this.storeVarbitChanged(varbIndex, varbValue);
        }
    }

    public void storeVarpChanged(int varpIndex, int varpValue) {
        synchronized (this) {
            varpData.put(varpIndex, varpValue);
        }
    }

    public void storeVarpChangedIfNotStored(int varpIndex, int varpValue) {
        synchronized (this) {
            if (!varpData.containsKey(varpIndex))
                this.storeVarpChanged(varpIndex, varpValue);
        }
    }

    public void storeSkillChanged(String skill, int skillLevel) {
        synchronized (this) {
            levelData.put(skill, skillLevel);
        }
    }

    public void storeSkillChangedIfNotChanged(String skill, int skillLevel) {
        synchronized (this) {
            if (!levelData.containsKey(skill))
                storeSkillChanged(skill, skillLevel);
        }
    }

    private <K, V> HashMap<K, V> clearChanges(HashMap<K, V> h) {
        HashMap<K, V> temp;
        synchronized (this) {
            if (h.isEmpty()) {
                return new HashMap<>();
            }
            temp = new HashMap<>(h);
            h.clear();
        }
        return temp;
    }

    public void clearData() {
        synchronized (this) {
            varbData.clear();
            varpData.clear();
            levelData.clear();
        }
    }

    private boolean hasDataToPush() {
        return !(varbData.isEmpty() && varpData.isEmpty() && levelData.isEmpty());
    }

    private JsonObject convertToJson() {
        JsonObject j = new JsonObject();
        JsonObject parent = new JsonObject();
        // We need to synchronize this to handle the case where the RuneScapeProfileType
        // changes
        synchronized (this) {
            RuneScapeProfileType r = RuneScapeProfileType.getCurrent(client);
            HashMap<Integer, Integer> tempVarbData = clearChanges(varbData);
            HashMap<Integer, Integer> tempVarpData = clearChanges(varpData);
            HashMap<String, Integer> tempLevelData = clearChanges(levelData);

            j.add("varb", gson.toJsonTree(tempVarbData));
            j.add("varp", gson.toJsonTree(tempVarpData));
            j.add("level", gson.toJsonTree(tempLevelData));

            parent.addProperty("username", client.getLocalPlayer().getName());
            parent.addProperty("profile", r.name());
            parent.addProperty("version", manifestManager.getLastCheckedManifestVersion());
            parent.add("data", j);
        }
        return parent;
    }

    private void restoreData(JsonObject jObj) {
        synchronized (this) {
            if (!jObj.get("profile").getAsString().equals(RuneScapeProfileType.getCurrent(client).name())) {
                log.error("Not restoring data from failed call since the profile type has changed");
                return;
            }
            JsonObject dataObj = jObj.getAsJsonObject("data");
            JsonObject varbObj = dataObj.getAsJsonObject("varb");
            JsonObject varpObj = dataObj.getAsJsonObject("varp");
            JsonObject levelObj = dataObj.getAsJsonObject("level");
            for (String k : varbObj.keySet()) {
                this.storeVarbitChangedIfNotStored(Integer.parseInt(k), varbObj.get(k).getAsInt());
            }
            for (String k : varpObj.keySet()) {
                this.storeVarpChangedIfNotStored(Integer.parseInt(k), varpObj.get(k).getAsInt());
            }
            for (String k : levelObj.keySet()) {
                this.storeSkillChangedIfNotChanged(k, levelObj.get(k).getAsInt());
            }
        }
    }

    protected void submitToAPI() {
        if (!hasDataToPush() || client.getLocalPlayer() == null || client.getLocalPlayer().getName() == null || stopTryingForAccount.get())
            return;

        if (RuneScapeProfileType.getCurrent(client) != RuneScapeProfileType.STANDARD)
            return;

        isUserRegisteredAsync(client.getLocalPlayer().getName(), isRegistered -> {
            if (!isRegistered) {
                return;
            }

        if (client.getGameState() == GameState.LOGIN_SCREEN || client.getGameState() == GameState.HOPPING) {
            return;
        }

        try {
            JsonObject payload = convertToJson();

            okHttpClient.newCall(new Request.Builder().url(UNTRACKABLE_POST_ENDPOINT)
                    .post(RequestBody.create(JSON, payload.toString())).build()).enqueue(new Callback() {
                        @Override
                        public void onFailure(@NonNull Call call, @NonNull IOException e) {
                            log.error(e.getLocalizedMessage());
                            restoreData(payload);
                            log.error("Failed to submit player in submitToAPI, restoring data. Cause of failure:", e);
                        }

                        @Override
                        public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                            if (response.isSuccessful()) {
                                log.debug("Successfully uploaded untrackable items");
                                response.close();
                                return;
                            } else {
                                response.close();
                                log.error("submitToAPI onResponse returned, but without success");
                            }

                            response.close();
                        }
                    });
        } catch (Exception e) {
            log.error("Error preparing data for API submission", e);
        }
    });
    }

    private HashSet<Integer> parseSet(JsonArray j) {
        HashSet<Integer> h = new HashSet<>();
        for (JsonElement jObj : j) {
            h.add(jObj.getAsInt());
        }
        return h;
    }

    public void loadInitialData() {
        manifestManager.getLatestManifest();

        for (int varbIndex : varbitsToCheck) {
            storeVarbitChanged(varbIndex, client.getVarbitValue(varbIndex));
        }

        for (int varpIndex : varpsToCheck) {
            storeVarpChanged(varpIndex, client.getVarpValue(varpIndex));
        }
        for (Skill s : Skill.values()) {
            storeSkillChanged(s.getName(), client.getRealSkillLevel(s));
        }
    }

    // NEEDS TO BE MODIFIED TO USE NEW MANIFEST OBJECT STUFF
    protected void getManifest() {
        // log.debug("Getting manifest file...");
        try {
            Request r = new Request.Builder()
                    .url(MANIFEST_ENDPOINT)
                    .build();
            okHttpClient.newCall(r).enqueue(new Callback() {
                @Override
                public void onFailure(@NonNull Call call, @NonNull IOException e) {
                    log.error("Error retrieving manifest", e);
                }

                @Override
                public void onResponse(@NonNull Call call, @NonNull Response response) {
                    if (response.isSuccessful()) {
                        try {
                            // We want to be able to change the varbs and varps we get on the fly. To do so,
                            // we tell
                            // the client what to send the server on startup via the manifest.
                            if (response.body() == null) {
                                log.error("Manifest request succeeded but returned empty body");
                                response.close();
                            }

                            JsonObject j = gson.fromJson(response.body().string(), JsonObject.class);
                            try {
                                setVarbitsToCheck(parseSet(j.getAsJsonArray("varbits")));
                                setVarpsToCheck(parseSet(j.getAsJsonArray("varps")));
                                try {
                                    int manifestVersion = j.get("version").getAsInt();
                                    if (getLastManifestVersion() != manifestVersion) {
                                        setLastManifestVersion(manifestVersion);
                                        clientThread.invoke(() -> loadInitialData());
                                    }
                                } catch (UnsupportedOperationException | NullPointerException exception) {
                                    setLastManifestVersion(-1);
                                }
                            } catch (NullPointerException e) {
                                log.error("Manifest possibly missing varbits or varps entry from /manifest call");
                                log.error(e.getLocalizedMessage());
                            } catch (ClassCastException e) {
                                log.error("Manifest from /manifest call might have varbits or varps as not a list");
                                log.error(e.getLocalizedMessage());
                            }
                        } catch (IOException | JsonSyntaxException e) {
                            log.error(e.getLocalizedMessage());
                        } finally {
                            response.close();
                        }
                    } else {
                        log.error("Manifest request returned with status " + response.code());
                        if (response.body() == null) {
                            log.error("Manifest request returned empty body");
                        } else {
                            log.error(response.body().toString());
                        }
                    }
                    response.close();
                }
            });
        } catch (IllegalArgumentException e) {
            log.error("Bad URL given: " + e.getLocalizedMessage());
        }
    }

    // NEEDS TO BE MODIFIED TO USE NEW MANIFEST OBJECT STUFF
    protected int getVersion() {
        // log.debug("Attempting to get manifest version...");
        Request request = new Request.Builder()
                .url(MANIFEST_ENDPOINT)
                .build();

        try {
            okHttpClient.newCall(request).enqueue(new Callback() {
                @Override
                public void onFailure(@NonNull Call call, IOException e) {
                    log.error("Error retrieving manifest", e);
                }

                @Override
                public void onResponse(@NonNull Call call, Response response) throws IOException {
                    if (response.isSuccessful()) {
                        try {
                            // We want to be able to change the varbs and varps we get on the fly. To do so,
                            // we tell
                            // the client what to send the server on startup via the manifest.
                            if (response.body() == null) {
                                log.error("Manifest request succeeded but returned empty body");
                                response.close();
                            }

                            JsonObject j = gson.fromJson(response.body().string(), JsonObject.class);

                            try {
                                try {
                                    int manifestVersion = j.get("version").getAsInt();
                                    if (manifestManager.getLatestManifest().getVersion() != manifestVersion) {
                                        // update to use new manifest stuff
                                        clientThread.invoke(() -> loadInitialData());
                                    }
                                } catch (UnsupportedOperationException | NullPointerException exception) {
                                    setLastManifestVersion(-1);
                                }
                            } catch (NullPointerException | ClassCastException e) {
                                log.error(e.getLocalizedMessage());
                            }
                        } catch (IOException | JsonSyntaxException e) {
                            log.error(e.getLocalizedMessage());
                        } finally {
                            response.close();
                        }
                    } else {
                        log.error("Manifest request returned with status " + response.code());
                        if (response.body() == null) {
                            log.error("Manifest request returned empty body");
                        } else {
                            log.error(response.body().toString());
                        }
                    }
                    response.close();
                }
            });
        } catch (IllegalArgumentException e) {
            log.error("asd");
        }
        return -1;
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged varbitChanged) {
        if (client == null || varbitsToCheck == null || varpsToCheck == null)
            return;
        if (oldVarps == null)
            setupVarpTracking();

        int varpIndexChanged = varbitChanged.getVarpId();
        if (varpsToCheck.contains(varpIndexChanged)) {
            storeVarpChanged(varpIndexChanged, client.getVarpValue(varpIndexChanged));
        }
        for (Integer i : varpToVarbitMapping.get(varpIndexChanged)) {
            if (!varbitsToCheck.contains(i))
                continue;
            // For each varbit index, see if it changed.
            int oldValue = client.getVarbitValue(oldVarps, i);
            int newValue = client.getVarbitValue(i);
            if (oldValue != newValue)
                storeVarbitChanged(i, newValue);
        }
        oldVarps[varpIndexChanged] = client.getVarpValue(varpIndexChanged);
    }

    // Need to keep track of old varps and what varps each varb is in.
    // On change
    // Get varp, if varp in hashset, queue it.
    // Get each varb index in varp. If varb changed and varb in hashset, queue it.
    // Checking if varb has changed requires us to keep track of old varps
    private void setupVarpTracking() {
        final int VARBITS_ARCHIVE_ID = 14;
        // Init stuff to keep track of varb changes
        varpToVarbitMapping.clear();

        if (oldVarps == null) {
            oldVarps = new int[client.getVarps().length];
        }

        // Set oldVarps to be the current varps
        System.arraycopy(client.getVarps(), 0, oldVarps, 0, oldVarps.length);

        // For all varbits, add their ids to the multimap with the varp index as their
        // key
        clientThread.invoke(() -> {
            if (client.getIndexConfig() == null) {
                return false;
            }
            IndexDataBase indexVarbits = client.getIndexConfig();
            final int[] varbitIds = indexVarbits.getFileIds(VARBITS_ARCHIVE_ID);
            for (int id : varbitIds) {
                VarbitComposition varbit = client.getVarbit(id);
                if (varbit != null) {
                    varpToVarbitMapping.put(varbit.getIndex(), id);
                }
            }
            return true;
        });
    }

    @Schedule(period = 5 * 60, unit = ChronoUnit.SECONDS, asynchronous = true)
    public void resyncManifest() {
        // log.debug("Attempting to resync manifest");
        if (manifestManager.getManifest().getVersion() != getLastManifestVersion()) {
            getManifest();
        }
    }

    @Schedule(period = 10, unit = ChronoUnit.SECONDS, asynchronous = true)
    public void scheduledSubmit() {
        if (stopTryingForAccount.get()) {
            return;
        }
        if (client != null
                && (client.getGameState() != GameState.HOPPING && client.getGameState() != GameState.LOGIN_SCREEN)) {
            submitToAPI();
            if (client.getLocalPlayer() != null) {
                String username = client.getLocalPlayer().getName();

                isUserRegisteredAsync(username, isRegistered -> {
                    if (isRegistered) {
                        embargoPanel.updateLoggedIn(true);
                    } else {
                        embargoPanel.isLoggedIn = false;
                        embargoPanel.updateLoggedIn(false);
                        embargoPanel.logOut();
                    }
                });
            }
        } else {
            // log.debug("User is hopping or logged out, do not send data");
            embargoPanel.isLoggedIn = false;
            embargoPanel.updateLoggedIn(false);
            embargoPanel.logOut();
        }
    }

}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gg.embargo.ui;

import com.google.inject.Inject;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.annotations.Component;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
public class SyncButtonManager {

    private static final int COLLECTION_LOG_SETUP = 7797;
    private static final int[] SPRITE_IDS_INACTIVE = {
            SpriteID.DIALOG_BACKGROUND,
            SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_TOP_LEFT,
            SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_TOP_RIGHT,
            SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_BOTTOM_LEFT,
            SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_BOTTOM_RIGHT,
            SpriteID.WORLD_MAP_BUTTON_EDGE_LEFT,
            SpriteID.WORLD_MAP_BUTTON_EDGE_TOP,
            SpriteID.WORLD_MAP_BUTTON_EDGE_RIGHT,
            SpriteID.WORLD_MAP_BUTTON_EDGE_BOTTOM,
    };

    private static final int[] SPRITE_IDS_ACTIVE = {
            SpriteID.RESIZEABLE_MODE_SIDE_PANEL_BACKGROUND,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_TOP_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM_HOVERED,
    };

    private static final int FONT_COLOUR_INACTIVE = 0xd6d6d6;
    private static final int FONT_COLOUR_ACTIVE = 0xffffff;
    private static final int CLOSE_BUTTON_OFFSET = 28;
    private static final int BUTTON_WIDTH = 71;
    private static final int BUTTON_OFFSET = CLOSE_BUTTON_OFFSET + 5;

    private final Client client;
    private final ClientThread clientThread;
    private final EventBus eventBus;

    @Getter
    @Setter
    private boolean syncAllowed;

    @Inject
    private SyncButtonManager(
            Client client,
            ClientThread clientThread,
            EventBus eventBus
    )
    {
        this.client = client;
        this.clientThread = clientThread;
        this.eventBus = eventBus;
    }

    public void startUp()
    {
        setSyncAllowed(false);
        eventBus.register(this);
        clientThread.invokeLater(() -> tryAddButton(this::onButtonClick));
    }

    public void shutDown()
    {
        eventBus.unregister(this);
        clientThread.invokeLater(this::removeButton);
    }

    @Getter
    @RequiredArgsConstructor
    enum Screen
    {
        // First number is col log container (inner) and second is search button id
        COLLECTION_LOG(40697944, 40697932, InterfaceID.Collection.INFINITY),
        ;

        @Getter(onMethod_ = @Component)
        private final int parentId;

        @Getter(onMethod_ = @Component)
        private final int searchButtonId;

        @Getter(onMethod_ = @Component)
        private final int collectionLogContainer;
    }

    void tryAddButton(Runnable onClick)
    {
        for (Screen screen : Screen.values())
        {
            addButton(screen, onClick);
        }
    }
    @Subscribe
    public void onScriptPostFired(ScriptPostFired scriptPostFired)
    {
        if (scriptPostFired.getScriptId() == COLLECTION_LOG_SETUP)
        {
            removeButton();
            addButton(Screen.COLLECTION_LOG, this::onButtonClick);
        }
    }

    void onButtonClick() {
        setSyncAllowed(true);
        client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
        client.runScript(2240);
        client.addChatMessage(ChatMessageType.CONSOLE, "Embargo", "Your collection log data is being sent to Embargo...", "Embargo");
    }

    void addButton(Screen screen, Runnable onClick)
    {
        Widget parent = client.getWidget(screen.getParentId());
        Widget searchButton = client.getWidget(screen.getSearchButtonId());
        Widget collectionLogContainer = client.getWidget(screen.getCollectionLogContainer());
        Widget[] containerChildren;
        Widget draggableTopbar;
        if (parent == null || searchButton == null || collectionLogContainer == null ||
                (containerChildren = collectionLogContainer.getChildren()) == null ||
                (draggableTopbar = containerChildren[0]) == null)
        {
            return;
        }

        final int w = BUTTON_WIDTH;
        final int h = searchButton.getOriginalHeight();
        final int x = BUTTON_OFFSET;
        final int y = searchButton.getOriginalY();
        final int cornerDim = 9;

        final Widget[] spriteWidgets = new Widget[9];

        spriteWidgets[0] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[0])
                .setPos(x, y)
                .setSize(w, h)
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setYPositionMode(searchButton.getYPositionMode());

        spriteWidgets[1] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[1])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x + (w - cornerDim), y);
        spriteWidgets[2] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[2])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x, y);
        spriteWidgets[3] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[3])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x + (w - cornerDim), y + h - cornerDim);
        spriteWidgets[4] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[4])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x, y + h - cornerDim);
        // Left and right edges
        int sideWidth = 9;
        int sideHeight = 4;
        spriteWidgets[5] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[5])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(sideWidth, sideHeight)
                .setPos(x + (w - sideWidth), y + cornerDim);
        spriteWidgets[7] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[7])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(sideWidth, sideHeight)
                .setPos(x, y + cornerDim);

        // Top and bottom edges
        int topWidth = 53;
        int topHeight = 9;
        spriteWidgets[6] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[6])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(topWidth, topHeight)
                .setPos(x + cornerDim, y);
        spriteWidgets[8] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[8])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(topWidth, topHeight)
                .setPos(x + cornerDim, y + h - topHeight);
        for (int i = 0; i < 9; i++)
        {
            spriteWidgets[i].revalidate();
        }

        final Widget text = parent.createChild(-1, WidgetType.TEXT)
                .setText("Embargo")
                .setTextColor(FONT_COLOUR_INACTIVE)
                .setFontId(FontID.PLAIN_11)
                .setTextShadowed(true)
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setXTextAlignment(WidgetTextAlignment.CENTER)
                .setYTextAlignment(WidgetTextAlignment.CENTER)
                .setPos(x, y)
                .setSize(w, h)
                .setYPositionMode(searchButton.getYPositionMode());
        text.revalidate();

        // We'll give the text layer the listeners since it covers the whole area
        text.setHasListener(true);
        text.setOnMouseOverListener((JavaScriptCallback) ev ->
        {
            for (int i = 0; i <= 8; i++)
            {
                spriteWidgets[i].setSpriteId(SPRITE_IDS_ACTIVE[i]);
            }
            text.setTextColor(FONT_COLOUR_ACTIVE);
        });
        text.setOnMouseLeaveListener((JavaScriptCallback) ev ->
        {
            for (int i = 0; i <= 8; i++)
            {
                spriteWidgets[i].setSpriteId(SPRITE_IDS_INACTIVE[i]);
            }
            text.setTextColor(FONT_COLOUR_INACTIVE);
        });

        // Register a click listener
        text.setAction(0, "Sync your collection log with Embargo");
        text.setOnOpListener((JavaScriptCallback) ev -> onClick.run());


        // Shrink the top bar to avoid overlapping the new button
        draggableTopbar.setOriginalWidth(draggableTopbar.getOriginalWidth() - (w + (x - CLOSE_BUTTON_OFFSET)));
        draggableTopbar.revalidate();

        // recompute locations / sizes on parent
        parent.revalidate();
    }

    void removeButton()
    {
        for (Screen screen : Screen.values())
        {
            Widget parent = client.getWidget(screen.getParentId());
            if (parent != null)
            {
                parent.deleteAllChildren();
                parent.revalidate();
            }
        }
    }
}
package gg.embargo.ui;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.http.api.item.ItemPrice;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

@Slf4j
public class MissingRequirementsPanel extends PluginPanel {
    private static final String OSRS_WIKI_BASE_URL = "https://oldschool.runescape.wiki/w/";
    private static final int ITEMS_PER_ROW = 5;
    private static final int CELL_SIZE = 32;
    private static final int TOOLTIP_PADDING = 3;
    private static final Color HOVER_COLOR = ColorScheme.DARKER_GRAY_HOVER_COLOR;
    private static final Color NORMAL_COLOR = ColorScheme.DARKER_GRAY_COLOR;

    // Cache for item icons to avoid recreating them - bounded LRU cache to prevent memory bloat
    private static final int MAX_ICON_CACHE_SIZE = 100;
    private static final int MAX_LETTER_ICON_CACHE_SIZE = 50;
    private final Map<Integer, BufferedImage> iconCache = Collections.synchronizedMap(
            new LinkedHashMap<Integer, BufferedImage>(MAX_ICON_CACHE_SIZE, 0.75f, true) {
                @Override
                protected boolean removeEldestEntry(Map.Entry<Integer, BufferedImage> eldest) {
                    return size() > MAX_ICON_CACHE_SIZE;
                }
            });
    private final Map<String, BufferedImage> letterIconCache = Collections.synchronizedMap(
            new LinkedHashMap<String, BufferedImage>(MAX_LETTER_ICON_CACHE_SIZE, 0.75f, true) {
                @Override
                protected boolean removeEldestEntry(Map.Entry<String, BufferedImage> eldest) {
                    return size() > MAX_LETTER_ICON_CACHE_SIZE;
                }
            });
    private volatile boolean isUpdating = false;

    // Track scheduled futures for cleanup to prevent memory leaks
    private final List<ScheduledFuture<?>> scheduledFutures = Collections.synchronizedList(new ArrayList<>());

    private final ItemManager itemManager;
    private final ScheduledExecutorService executorService;
    private final JPanel itemsContainer;
    private final List<MissingItem> missingItems = new ArrayList<>();
    private final MouseAdapter itemMouseAdapter = createMouseAdapter();
    private final Object lock = new Object();

    private static final BufferedImage EHB_ICON = ImageUtil.loadImageResource(MissingRequirementsPanel.class,
            "/ehb_icon.png");
    private static final BufferedImage COMMUNITY_POINTS_ICON = ImageUtil.resizeImage(
            ImageUtil.loadImageResource(MissingRequirementsPanel.class, "/community_points_icon.png"), 24, 24);
    private static final BufferedImage ACCOUNT_POINTS_ICON =
            ImageUtil.loadImageResource(MissingRequirementsPanel.class,  "/account_points_icon.png");
    private static final BufferedImage OVERALL_ICON = ImageUtil.loadImageResource(MissingRequirementsPanel.class,
            "/overall_icon.png");

    @Getter
    public enum DynamicItems {
        ACCOUNT_POINTS("account points"),
        EHB("EHB"),
        COMMUNITY_POINTS("community points"),
        TOTAL_LEVEL("total level");

        private final String label;

        DynamicItems(String label) {
            this.label = label;
        }
    }

    @Inject
    public MissingRequirementsPanel(ItemManager itemManager, ScheduledExecutorService executorService) {
        super(false);
        this.itemManager = itemManager;
        this.executorService = executorService;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(new EmptyBorder(10, 10, 10, 10));

        // Create title panel
        add(createTitlePanel(), BorderLayout.NORTH);

        // Create items container
        itemsContainer = new JPanel();
        itemsContainer.setLayout(new GridLayout(0, ITEMS_PER_ROW, 2, 2));
        itemsContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JScrollPane scrollPane = new JScrollPane(itemsContainer);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setBorder(null);
        add(scrollPane, BorderLayout.CENTER);
    }

    private JPanel createTitlePanel() {
        JPanel titlePanel = new JPanel(new BorderLayout());
        titlePanel.setBorder(new EmptyBorder(0, 0, 10, 0));
        titlePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JLabel title = new JLabel("Missing Requirements");
        title.setForeground(Color.WHITE);
        title.setFont(new Font("SansSerif", Font.BOLD, 16));
        titlePanel.add(title, BorderLayout.NORTH);

        JLabel subtitle = new JLabel("Hover for details, click to open wiki");
        subtitle.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        subtitle.setFont(new Font("SansSerif", Font.ITALIC, 10));
        titlePanel.add(subtitle, BorderLayout.SOUTH);

        return titlePanel;
    }

    /**
     * Adds a missing item to the panel if it doesn't already exist
     * 
     * @param itemName The name of the item
     * @param itemId   The item ID in RuneScape
     */
    public void addMissingItem(String itemName, int itemId) {
        synchronized (lock) {
            // Clean up the item name
            String cleanedName = itemName.replace("\"", "").replace(" (uncharged)", "");

            // Handle case where itemName is empty but we have an itemId
            if (itemName.isEmpty() && itemId != -1) {
                ItemComposition ic = itemManager.getItemComposition(itemId);
                String itemNameFromId = ic.getName();

                // Check if this item already exists in our list
                if (missingItems.stream().anyMatch(item -> Objects.equals(item.getItemName(), itemNameFromId))) {
                    log.debug("Item {} already exists, skipping", itemNameFromId);
                    return;
                }

                // Add the item with name from ItemComposition
                BufferedImage itemIcon = getItemIcon(itemId, itemNameFromId);
                log.debug("Adding untrackable item: {}", itemNameFromId);
                missingItems.add(new MissingItem(itemNameFromId, itemId, itemIcon));
                updatePanel();
                return;
            }

            // Check if this is a dynamic item that already exists by type, not exact name
            boolean isDynamicItem = false;
            EnumSet<DynamicItems> dynamicItemsSet = EnumSet.of(
                    DynamicItems.ACCOUNT_POINTS,
                    DynamicItems.EHB,
                    DynamicItems.TOTAL_LEVEL,
                    DynamicItems.COMMUNITY_POINTS);

            for (DynamicItems dynamicItem : dynamicItemsSet) {
                if (cleanedName.contains(dynamicItem.getLabel())) {
                    isDynamicItem = true;
                    // Use getSpecialIcon for dynamic items
                    BufferedImage specialIcon = getSpecialIcon(cleanedName);
                    boolean didRefreshItem;
                    if (specialIcon != null) {
                        // Remove any existing dynamic item of this type and add with special icon
                        missingItems.removeIf(item -> item.getItemName().contains(dynamicItem.getLabel()));
                        missingItems.add(new MissingItem(cleanedName, -1, specialIcon));
                        log.debug("Added new dynamic item with special icon: {}", cleanedName);
                        updatePanel();
                        didRefreshItem = true;
                    } else {
                        didRefreshItem = refreshDynamicItems(itemName, dynamicItemsSet);
                    }
                    if (didRefreshItem) {
                        return; // Successfully refreshed the dynamic item
                    }
                    break;
                }
            }

            // If not a dynamic item, check for exact match as before
            if (!isDynamicItem && !cleanedName.isEmpty() && missingItems.stream()
                    .anyMatch(item -> Objects.equals(item.getItemName(), cleanedName))) {
                log.debug("Item {} already exists, returning", cleanedName);
                return;
            }

            // Handle special cases for specific items
            int finalItemId = itemId;
            if (cleanedName.toLowerCase().contains("quiver")) {
                finalItemId = 28947;
            } else if (cleanedName.toLowerCase().contains("infernal cape")) {
                finalItemId = 21295;
            }

            // Process the item and add it to the panel
            BufferedImage itemIcon;
            if (itemName.contains("Combat Achievement")) {
                finalItemId = getHiltIdFromName(itemName);
                itemIcon = getHiltImageFromName(itemName.split(" ")[0]);
            } else {
                itemIcon = getItemIcon(finalItemId, cleanedName);
            }
            missingItems.add(new MissingItem(cleanedName, finalItemId, itemIcon));
            log.debug("Added new item to panel: {}", cleanedName);
            updatePanel();
        }
    }

    public boolean refreshDynamicItems(String itemName, EnumSet<DynamicItems> dynamicItemsEnumSet) {
        synchronized (lock) {
            String cleanedItemName = itemName.replaceAll("^\"|\"$", "");
            boolean itemRemoved = false;

            // First, remove any existing items that match the dynamic type
            Iterator<MissingItem> iterator = missingItems.iterator();
            while (iterator.hasNext()) {
                MissingItem item = iterator.next();

                // Check if this existing item matches any of our dynamic types
                for (DynamicItems dynamicItem : dynamicItemsEnumSet) {
                    if (item.itemName.contains(dynamicItem.getLabel()) &&
                            cleanedItemName.contains(dynamicItem.getLabel())) {
                        // Found a match - remove the old item
                        iterator.remove();
                        itemRemoved = true;
                        log.debug("Removed dynamic item {} to be replaced with {}",
                                item.itemName, cleanedItemName);
                        break;
                    }
                }
            }

            // Now add the new item if we removed an old one
            if (itemRemoved) {
                // Add the new item with updated value
                missingItems.add(new MissingItem(cleanedItemName, -1,
                        getItemIcon(-1, cleanedItemName)));
                log.debug("Added new dynamic item: {}", cleanedItemName);
                updatePanel(); // Make sure to update the panel to reflect changes
                return true;
            } else {
                return false;
            }
        }
    }

    @Getter
    public enum AchievementHilts {
        EASY(25926),
        MEDIUM(25928),
        HARD(25930),
        ELITE(25932),
        MASTER(25934),
        GRANDMASTER(25936);

        private final int itemId;

        AchievementHilts(int itemId) {
            this.itemId = itemId;
        }
    }

    public BufferedImage getHiltImageFromName(String name) {
        String lowercaseName = name.toLowerCase();
        // Strip out extra "'s
        lowercaseName = lowercaseName.replace("\"", "");

        for (AchievementHilts hilt : AchievementHilts.values()) {
            // Shortcut to bypass conflicting name with "Master" being in "Grandmaster"
            if (lowercaseName.contains("grand")) {
                return getItemIcon(AchievementHilts.GRANDMASTER.getItemId(), "Ghommal's_avernic_defender_6");
            }

            if (lowercaseName.contains(hilt.name().toLowerCase())) {
                return getItemIcon(hilt.getItemId(), "Ghommal's_avernic_defender_" + (hilt.ordinal() + 1));
            }
        }
        return getItemIcon(882, "Bronze arrow");
    }

    public int getHiltIdFromName(String name) {
        String lowercaseName = name.toLowerCase();

        // Special case for Grandmaster since conflicting master in name
        if (lowercaseName.contains("grand")) {
            return AchievementHilts.GRANDMASTER.getItemId();
        }

        // Check for other hilt types
        for (AchievementHilts hilt : AchievementHilts.values()) {
            if (lowercaseName.contains(hilt.name().toLowerCase())) {
                return hilt.getItemId();
            }
        }

        return 882;
    }

    /**
     * Clears all missing items from the panel
     */
    public void clearItems() {
        synchronized (lock) {
            cancelAllScheduledFutures();
            if (!missingItems.isEmpty()) {
                missingItems.clear();
                updatePanel();
            }
        }
    }

    /**
     * Cancels all scheduled futures to prevent memory leaks.
     * Must be called before recreating panels or during cleanup.
     */
    private void cancelAllScheduledFutures() {
        synchronized (scheduledFutures) {
            for (ScheduledFuture<?> future : scheduledFutures) {
                future.cancel(true);
            }
            scheduledFutures.clear();
        }
    }

    /**
     * Cleanup method to be called when the plugin is shutting down.
     * Cancels all scheduled futures and clears caches to prevent memory leaks.
     */
    public void shutdown() {
        synchronized (lock) {
            cancelAllScheduledFutures();
            missingItems.clear();
            iconCache.clear();
            letterIconCache.clear();
            itemsContainer.removeAll();
        }
    }

    /**
     * Updates the panel with the current list of missing items
     */
    private void updatePanel() {
        if (isUpdating) {
            return; // Prevent concurrent updates
        }

        try {
            isUpdating = true;
            SwingUtilities.invokeLater(() -> {
                synchronized (lock) {
                    // Cancel existing scheduled futures before rebuilding panels to prevent leaks
                    cancelAllScheduledFutures();
                    itemsContainer.removeAll();
                    for (MissingItem item : missingItems) {
                        JPanel itemPanel = createItemPanel(item);
                        itemsContainer.add(itemPanel);
                    }
                    revalidate();
                    repaint();
                }
            });
        } finally {
            isUpdating = false;
        }
    }

    /**
     * Creates a panel for a single item with icon and hover/click functionality
     */
    private JPanel createItemPanel(MissingItem item) {
        if (item instanceof DynamicMissingItem) {
            DynamicMissingItem dyn = (DynamicMissingItem) item;
            JPanel dynamicPanel = new JPanel(new BorderLayout());
            dynamicPanel.setBackground(NORMAL_COLOR);
            dynamicPanel.setBorder(new LineBorder(Color.BLACK, 1));
            dynamicPanel.setPreferredSize(new Dimension(CELL_SIZE, CELL_SIZE));
            dynamicPanel.setMinimumSize(new Dimension(CELL_SIZE, CELL_SIZE));
            dynamicPanel.setMaximumSize(new Dimension(CELL_SIZE, CELL_SIZE));

            JLabel iconLabel = new JLabel();
            iconLabel.setHorizontalAlignment(SwingConstants.CENTER);
            iconLabel.setIcon(getIconForItemId(dyn.itemIds[0]));
            iconLabel.setToolTipText(buildTooltipText(new MissingItem(dyn.names[0], dyn.itemIds[0], dyn.icons.get(0))));
            dynamicPanel.add(iconLabel, BorderLayout.CENTER);

            // Track the current index for click events
            final AtomicInteger currentIdx = new AtomicInteger(0);

            ScheduledFuture<?> future = executorService.scheduleAtFixedRate(() -> {
                SwingUtilities.invokeLater(() -> {
                    int idx = currentIdx.updateAndGet(i -> (i + 1) % dyn.names.length);
                    iconLabel.setIcon(new ImageIcon(dyn.icons.get(idx)));
                    String tooltip = buildTooltipText(
                            new MissingItem(dyn.names[idx], dyn.itemIds[idx], dyn.icons.get(idx)));
                    iconLabel.setToolTipText(tooltip);
                    dynamicPanel.setToolTipText(tooltip);
                    dynamicPanel.revalidate();
                    dynamicPanel.repaint();
                });
            }, dyn.intervalMs, dyn.intervalMs, TimeUnit.MILLISECONDS);

            // Track future for cleanup when panel is rebuilt or cleared
            scheduledFutures.add(future);

            MouseAdapter hoverAndClick = new MouseAdapter() {
                @Override
                public void mouseEntered(MouseEvent e) {
                    dynamicPanel.setBackground(HOVER_COLOR);
                    dynamicPanel.setCursor(new Cursor(Cursor.HAND_CURSOR));
                }

                @Override
                public void mouseExited(MouseEvent e) {
                    dynamicPanel.setBackground(NORMAL_COLOR);
                    dynamicPanel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
                }

                @Override
                public void mouseClicked(MouseEvent e) {
                    int idx = currentIdx.get();
                    int itemId = dyn.itemIds[idx];
                    String itemName = dyn.names[idx];
                    if (itemId == -1) {
                        return;
                    }
                    String wikiUrl = OSRS_WIKI_BASE_URL + itemName.replace(" ", "_");
                    LinkBrowser.browse(wikiUrl);
                }
            };

            // Attach to both panel and label
            dynamicPanel.addMouseListener(hoverAndClick);
            iconLabel.addMouseListener(hoverAndClick);

            return dynamicPanel;
        }

        JPanel panel = new JPanel(new BorderLayout());
        panel.setBackground(NORMAL_COLOR);
        panel.setBorder(new LineBorder(Color.BLACK, 1));
        panel.setPreferredSize(new Dimension(CELL_SIZE, CELL_SIZE));
        panel.setMinimumSize(new Dimension(CELL_SIZE, CELL_SIZE));
        panel.setMaximumSize(new Dimension(CELL_SIZE, CELL_SIZE));

        JLabel iconLabel = new JLabel(new ImageIcon(item.getIcon()));
        iconLabel.setHorizontalAlignment(SwingConstants.CENTER);
        panel.add(iconLabel, BorderLayout.CENTER);
        panel.setToolTipText(buildTooltipText(item));

        // Add hover effect and click handler to the panel
        panel.addMouseListener(itemMouseAdapter);

        return panel;
    }

    private MouseAdapter createMouseAdapter() {
        return new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                JPanel panel = (JPanel) e.getSource();
                panel.setBackground(HOVER_COLOR);
                panel.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                JPanel panel = (JPanel) e.getSource();
                panel.setBackground(NORMAL_COLOR);
                panel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            }

            @Override
            public void mouseClicked(MouseEvent e) {
                JPanel panel = (JPanel) e.getSource();
                Component[] components = itemsContainer.getComponents();
                int index = -1;

                for (int i = 0; i < components.length; i++) {
                    if (components[i] == panel) {
                        index = i;
                        break;
                    }
                }

                if (index >= 0 && index < missingItems.size()) {
                    MissingItem item = missingItems.get(index);
                    if (item.getItemId() == -1) {
                        return;
                    }
                    String wikiUrl = OSRS_WIKI_BASE_URL + item.getItemName().replace(" ", "_");
                    LinkBrowser.browse(wikiUrl);
                }
            }
        };
    }

    /**
     * Gets the item icon from the ItemManager or a default icon if not found
     */
    private BufferedImage getItemIcon(int itemId, String itemName) {
        // Check cache first
        if (itemId != -1) {
            BufferedImage cachedIcon = iconCache.get(itemId);
            if (cachedIcon != null) {
                return cachedIcon;
            }

            BufferedImage icon = itemManager.getImage(itemId);
            BufferedImage resizedIcon = ImageUtil.resizeImage(icon, CELL_SIZE, CELL_SIZE);
            iconCache.put(itemId, resizedIcon);
            return resizedIcon;
        } else {
            // For letter-based icons, create a cache key
            String letter = getLetterForItem(itemName);
            String cacheKey = letter + "_" + CELL_SIZE;

            BufferedImage cachedIcon = letterIconCache.get(cacheKey);
            if (cachedIcon != null) {
                return cachedIcon;
            }

            BufferedImage icon = createLetterIcon(letter);
            letterIconCache.put(cacheKey, icon);
            return icon;
        }
    }

    private String getLetterForItem(String itemName) {
        if (itemName.contains("community")) {
            return "CP";
        } else if (itemName.contains("account")) {
            return "AP";
        } else if (itemName.contains("EHB")) {
            return "EHB";
        } else if (itemName.contains("EHP")) {
            return "EHP";
        }
        return itemName.substring(0, 1).toUpperCase();
    }

    private BufferedImage createLetterIcon(String letter) {
        BufferedImage icon = new BufferedImage(CELL_SIZE, CELL_SIZE, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = icon.createGraphics();

        // Fill the entire image with the background color
        g2d.setColor(ColorScheme.MEDIUM_GRAY_COLOR);
        g2d.fillRect(0, 0, CELL_SIZE, CELL_SIZE);
        g2d.setColor(Color.WHITE);

        // Calculate appropriate font size based on text length
        int fontSize = 16; // Default font size
        if (letter.length() > 1) {
            // Reduce font size for longer text
            fontSize = Math.max(8, 16 - (letter.length() - 1) * 2);
        }

        g2d.setFont(new Font("SansSerif", Font.BOLD, fontSize));

        // Ensure text fits within the cell
        FontMetrics fm = g2d.getFontMetrics();
        while (fm.stringWidth(letter) > CELL_SIZE - 2 && fontSize > 8) {
            fontSize--;
            g2d.setFont(new Font("SansSerif", Font.BOLD, fontSize));
            fm = g2d.getFontMetrics();
        }

        int x = (CELL_SIZE - fm.stringWidth(letter)) / 2;
        int y = ((CELL_SIZE - fm.getHeight()) / 2) + fm.getAscent();
        g2d.drawString(letter, x, y);
        g2d.dispose();

        return icon;
    }

    /**
     * Builds the tooltip text for an item
     */
    private String buildTooltipText(MissingItem item) {
        StringBuilder sb = new StringBuilder("<html><body style='padding: ");
        sb.append(TOOLTIP_PADDING).append("px;");

        if (item.getItemId() == -1) {
            sb.append(" text-align: center;");
        }

        sb.append("'><div style='font-weight: bold;");

        if (item.getItemId() != -1) {
            sb.append(" margin-bottom: 3px;");
        }

        sb.append("'>").append(item.getItemName()).append("</div>");

        if (item.getItemId() != -1) {
            sb.append("<div style='color: #99FFFF; font-style: italic;'>Click to open wiki</div>");
        }

        sb.append("</body></html>");
        return sb.toString();
    }

    /**
     * Attempts to find an item ID by name using the ItemManager
     */
    public int findItemIdByName(String itemName) {
        String searchName = itemName.replace("\"", "");
        List<ItemPrice> itemPrices = itemManager.search(searchName);
        if (itemPrices.isEmpty()) {
            return -1;
        }

        return itemPrices.get(0).getId();
    }

    /**
     * Class to represent a missing item
     */
    @Getter
    private static class MissingItem {
        private final String itemName;
        private final int itemId;

        @Setter
        private BufferedImage icon;

        public MissingItem(String itemName, int itemId, BufferedImage icon) {
            this.itemName = itemName;
            this.itemId = itemId;
            this.icon = icon;
        }
    }

    /**
     * Adds a dynamic missing item that rotates its icon and name every intervalMs
     * milliseconds.
     * 
     * @param names      Array of item names to display.
     * @param itemIds    Array of item IDs corresponding to the names.
     * @param intervalMs Interval in milliseconds to rotate the icon/name.
     */
    public void addDynamicMissingItem(String[] names, int[] itemIds, int intervalMs) {
        synchronized (lock) {
            // Clean all names like addMissingItem does
            String[] cleanedNames = Arrays.stream(names)
                    .map(n -> n.replace("\"", "").replace(" (uncharged)", ""))
                    .toArray(String[]::new);

            // Remove any existing DynamicMissingItem with the same cleaned names
            Set<String> newNamesSet = new HashSet<>(Arrays.asList(cleanedNames));
            Iterator<MissingItem> iterator = missingItems.iterator();
            while (iterator.hasNext()) {
                MissingItem item = iterator.next();
                if (item instanceof DynamicMissingItem) {
                    DynamicMissingItem dyn = (DynamicMissingItem) item;
                    Set<String> existingNamesSet = new HashSet<>(Arrays.asList(dyn.names));
                    if (existingNamesSet.equals(newNamesSet)) {
                        iterator.remove();
                    }
                }
            }
            List<BufferedImage> icons = new ArrayList<>();
            for (int i = 0; i < itemIds.length; i++) {
                String name = names[i].trim().toLowerCase();
                BufferedImage special = null;
                // Only use special icon for exact matches
                if (name.equals("ehb") || name.equals("ehp") || name.equals("community points")
                        || name.equals("account points") || name.equals("total level")) {
                    special = getSpecialIcon(name);
                }
                if (special != null) {
                    icons.add(special);
                } else {
                    icons.add(getItemIcon(itemIds[i], names[i]));
                }
            }
            missingItems.add(new DynamicMissingItem(cleanedNames, itemIds, intervalMs, icons));
            updatePanel();
        }
    }

    // Helper method to get an icon for an item ID
    private Icon getIconForItemId(int itemId) {
        if (itemId == -1) {
            // Return a default icon or a placeholder if itemId is invalid
            BufferedImage icon = createLetterIcon("?");
            return new ImageIcon(icon);
        }
        // Use the same logic as getItemIcon to get and cache the icon
        BufferedImage cachedIcon = iconCache.get(itemId);
        if (cachedIcon != null) {

            return new ImageIcon(cachedIcon);
        }
        BufferedImage icon = itemManager.getImage(itemId);
        if (icon == null) {
            log.warn("No icon found for itemId: {}", itemId);
            icon = createLetterIcon("?");
        }
        BufferedImage resizedIcon = ImageUtil.resizeImage(icon, CELL_SIZE, CELL_SIZE);
        iconCache.put(itemId, resizedIcon);
        return new ImageIcon(resizedIcon);
    }

    private static class DynamicMissingItem extends MissingItem {
        private final String[] names;
        private final int[] itemIds;
        private final int intervalMs;
        private final List<BufferedImage> icons;

        public DynamicMissingItem(String[] names, int[] itemIds, int intervalMs, List<BufferedImage> icons) {
            super(names[0], itemIds[0], icons != null && !icons.isEmpty() ? icons.get(0) : null);
            this.names = names;
            this.itemIds = itemIds;
            this.intervalMs = intervalMs;
            this.icons = icons;
        }
    }

    private BufferedImage getSpecialIcon(String name) {
        String n = name.trim().toLowerCase();
        if (n.contains("ehb"))
            return EHB_ICON;
        if (n.contains("community points"))
            return COMMUNITY_POINTS_ICON;
        if (n.contains("account points"))
            return ACCOUNT_POINTS_ICON;
        if (n.contains("total level"))
            return OVERALL_ICON;
        return null;
    }
}

package gg.embargo.ui;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import gg.embargo.DataManager;
import gg.embargo.EmbargoPlugin;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.plugins.info.JRichTextPane;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;

@Slf4j
public class EmbargoPanel extends PluginPanel {
    @Inject
    @Nullable
    private Client client;
    @Inject
    private EventBus eventBus;

    @Inject
    private DataManager dataManager;

    @Inject
    private MissingRequirementsPanel missingRequirementsPanelX;

    @Inject
    private ClientThread clientThread;

    @Setter
    public boolean isLoggedIn = false;

    // Keep track of all boxes
    // private final ArrayList<ItemID> items = new ArrayList<>();
    JPanel versionPanel = new JPanel();
    JPanel missingRequirementsPanel = new JPanel();
    private static final ImageIcon ARROW_RIGHT_ICON = new ImageIcon(
            ImageUtil.loadImageResource(EmbargoPanel.class, "/util/arrow_right.png"));
    private static final ImageIcon DISCORD_ICON = new ImageIcon(
            ImageUtil.loadImageResource(EmbargoPanel.class, "/discord_icon.png"));
    static ImageIcon GITHUB_ICON = new ImageIcon(ImageUtil.loadImageResource(EmbargoPanel.class, "/github_icon.png"));
    static ImageIcon WEBSITE_ICON = new ImageIcon(ImageUtil.loadImageResource(EmbargoPanel.class, "/website_icon.png"));
    private final JRichTextPane emailLabel = new JRichTextPane();
    private final JLabel loggedLabel = new JLabel();
    private final JLabel embargoScoreLabel = new JLabel(htmlLabel("Embargo Score:", " N/A"));
    private final JLabel accountScoreLabel = new JLabel(htmlLabel("Account Score:", " N/A"));
    private final JLabel communityScoreLabel = new JLabel(htmlLabel("Community Score:", " N/A"));
    private final JLabel currentRankLabel = new JLabel(htmlLabel("Current Rank:", " N/A"));
    private final JLabel isRegisteredWithClanLabel = new JLabel(htmlLabel("Account registered:", " No"));
    private final JLabel currentCALabel = new JLabel(htmlLabel("Current TA Tier:", " N/A"));
    final JLabel missingRequiredItemsLabel = new JLabel(
            htmlLabel("Sign in to see what requirements", " you are missing for rank up"));
    private final Font smallFont = FontManager.getRunescapeSmallFont();
    final JPanel missingRequirementsContainer = new JPanel(new BorderLayout(5, 0));

    @Inject
    private EmbargoPanel() {
    }

    private String htmlLabel(String key, String value) {
        return "<html><body style = 'color:#a5a5a5'>" + key + "<span style = 'color:white'>" + value
                + "</span></body></html>";
    }

    void setupVersionPanel() {
        // Set up Embargo Clan Version at top of Version panel
        JLabel version = new JLabel(htmlLabel("Embargo Clan Version: ", "1.4.8"));
        version.setFont(smallFont);

        // Set version's font
        JLabel revision = new JLabel();
        revision.setFont(smallFont);

        // Set up versionPanel
        versionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        versionPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        versionPanel.setLayout(new GridLayout(0, 1));

        // Set up custom embargo labels
        isRegisteredWithClanLabel.setFont(smallFont);
        isRegisteredWithClanLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        embargoScoreLabel.setFont(smallFont);
        embargoScoreLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        accountScoreLabel.setFont(smallFont);
        accountScoreLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        communityScoreLabel.setFont(smallFont);
        communityScoreLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        currentCALabel.setFont(smallFont);
        currentCALabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        loggedLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        loggedLabel.setFont(smallFont);

        currentRankLabel.setFont(smallFont);
        currentRankLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        emailLabel.setForeground(Color.WHITE);
        emailLabel.setFont(smallFont);

        versionPanel.add(version);
        versionPanel.add(Box.createGlue());
        versionPanel.add(loggedLabel);
        versionPanel.add(emailLabel);
        versionPanel.add(isRegisteredWithClanLabel);
        versionPanel.add(embargoScoreLabel);
        versionPanel.add(accountScoreLabel);
        versionPanel.add(communityScoreLabel);
        versionPanel.add(currentCALabel);
    }

    JPanel setUpQuickLinks() {
        JPanel actionsContainer = new JPanel();
        actionsContainer.setBorder(new EmptyBorder(10, 0, 0, 0));
        actionsContainer.setLayout(new GridLayout(0, 1, 0, 10));

        actionsContainer.add(buildLinkPanel(DISCORD_ICON, "Join us on our", "Discord", "https://discord.gg/YDGGyP3VEq"));
        actionsContainer.add(buildLinkPanel(WEBSITE_ICON, "Go to our", "clan website", "https://embargo.gg/"));
        actionsContainer.add(buildLinkPanel(GITHUB_ICON, "Report a bug or", "inspect the plugin code",
                "https://github.com/Sharpienero/Embargo-Plugin"));

        return actionsContainer;
    }

    void setupMissingItemsPanel() {
        // Clear any existing content
        missingRequirementsContainer.removeAll();
        missingRequirementsPanel.removeAll();

        // Set up container styling
        missingRequirementsContainer.setBorder(new EmptyBorder(7, 7, 7, 7));
        missingRequirementsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        missingRequirementsContainer.setFont(FontManager.getRunescapeSmallFont());
        missingRequirementsContainer.setForeground(Color.WHITE);

        // Set up panel styling
        missingRequirementsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        missingRequirementsPanel.setBorder(new EmptyBorder(10, 0, 10, 0));
        missingRequirementsPanel.setLayout(new GridLayout(1, 1));

        // Always add the default message initially
        missingRequiredItemsLabel
                .setText(htmlLabel("Sign in to see what requirements", " you are missing for rank up"));
        missingRequiredItemsLabel.setFont(smallFont);
        missingRequiredItemsLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        missingRequirementsPanel.add(missingRequiredItemsLabel);

        // Add panel to container
        missingRequirementsContainer.add(missingRequirementsPanel, BorderLayout.CENTER);

        // Add container to main panel
        this.add(missingRequirementsContainer, BorderLayout.NORTH);
        this.revalidate();
    }

    void addSidePanel() {
        // Add the panels to the side plugin
        this.add(versionPanel, BorderLayout.NORTH);
        setupMissingItemsPanel();
        this.add(this.setUpQuickLinks(), BorderLayout.SOUTH);
    }

    void setupSidePanel() {
        this.setupVersionPanel();
        this.setUpQuickLinks();
        this.addSidePanel();

        // Update version panel with Embargo plugin information
        updateLoggedIn(false);
    }

    public void init() {
        this.setupSidePanel();
        logOut();
    }

    public void updateLoggedIn(boolean scheduled) {
        if (dataManager.stopTryingForAccount.get()) {
            emailLabel.setText("Account not registered with Embargo");
            missingRequirementsPanelX.removeAll();
            missingRequirementsContainer.removeAll();
            missingRequirementsPanel.removeAll();
            missingRequiredItemsLabel.removeAll();
            missingRequirementsContainer.removeAll();
            missingRequirementsContainer.revalidate();
            missingRequirementsContainer.repaint();
            return;
        }
        if (!isLoggedIn || scheduled) {
            if (client != null && client.getLocalPlayer() != null) {
                this.isLoggedIn = true;
                var username = client.getLocalPlayer().getName();

                loggedLabel.setText(htmlLabel("Signed in as ", " " + username));

                dataManager.isUserRegisteredAsync(username, isRegistered -> {
                    if (!isRegistered) {
                        emailLabel.setText("Account not registered with Embargo");
                        return;
                    }
                });

                // remove "Sign in to send..."
                versionPanel.remove(emailLabel);

                // re-register labels with panel
                versionPanel.add(isRegisteredWithClanLabel);
                versionPanel.add(embargoScoreLabel);
                versionPanel.add(accountScoreLabel);
                versionPanel.add(communityScoreLabel);
                versionPanel.add(currentRankLabel);
                versionPanel.add(currentCALabel);

                isRegisteredWithClanLabel.setText(htmlLabel("Account registered:", " Yes"));

                // get gear asynchronously
                dataManager.getProfileAsync(username, false).thenAccept(embargoProfileData -> {
                    // This code runs when the profile data is received
                    // We need to run UI updates on the client thread
                    clientThread.invokeLater(() -> {
                        JsonElement currentAccountPoints = embargoProfileData.get("accountPoints");
                        JsonElement currentCommunityPoints = embargoProfileData
                                .getAsJsonPrimitive("communityPoints");

                        embargoScoreLabel.setText((htmlLabel("Embargo Score:", " " +
                                (Integer.parseInt(String.valueOf(currentAccountPoints)) +
                                        Integer.parseInt(String.valueOf(currentCommunityPoints))))));

                        JsonElement getCurrentCAName = embargoProfileData.get("currentHighestCAName");
                        accountScoreLabel.setText(htmlLabel("Account Score: ",
                                String.valueOf(Integer.parseInt(String.valueOf(currentAccountPoints)))));

                        communityScoreLabel.setText(htmlLabel("Community Score: ",
                                String.valueOf(Integer.parseInt(String.valueOf(currentCommunityPoints)))));

                        JsonArray missingGearReqs = embargoProfileData.getAsJsonArray("missingGearRequirements");
                        JsonArray missingUntradableItemIdReqs = embargoProfileData
                                .getAsJsonArray("missingUntradableItemIds");

                        JsonObject currentRank = embargoProfileData.getAsJsonObject("currentRank");
                        JsonElement currentRankName = currentRank.get("name");

                        var currentRankDisplay = String.valueOf(currentRankName).replace("\"", "");
                        currentRankLabel.setText(htmlLabel("Current Rank:", " " + currentRankDisplay));

                        var displayCAName = String.valueOf(getCurrentCAName).replace("\"", "");
                        displayCAName = displayCAName.replace(" Combat Achievement", "");

                        currentCALabel.setText(htmlLabel("Current CA Tier:", " " + displayCAName));

                        ArrayList<String> alreadyProcessed = new ArrayList<>();

                        // Build out the missing requirements panel
                        if (missingGearReqs.size() > 0 || missingUntradableItemIdReqs.size() > 0) {
                            for (JsonElement mi : missingGearReqs) {
                                String itemName = mi.getAsString();
                                alreadyProcessed.add(itemName);
                                log.debug("Processing {} in missingGearReqs", itemName);

                                if (itemName.contains("|")) {
                                    // DynamicMissingItem: rotate between items every 3 seconds
                                    String[] dynamicNames = itemName.split("\\|");
                                    int[] itemIds = new int[dynamicNames.length];
                                    for (int i = 0; i < dynamicNames.length; i++) {
                                        itemIds[i] = missingRequirementsPanelX.findItemIdByName(dynamicNames[i].trim());
                                    }
                                    clientThread.invokeLater(() -> missingRequirementsPanelX
                                            .addDynamicMissingItem(dynamicNames, itemIds, 3000));
                                } else {
                                    clientThread.invokeLater(() -> missingRequirementsPanelX.addMissingItem(itemName,
                                            missingRequirementsPanelX.findItemIdByName(itemName)));
                                }
                            }

                            for (JsonElement mu : missingUntradableItemIdReqs) {
                                if (alreadyProcessed.contains(mu.getAsString())) {
                                    log.debug("{} already added, skipping missingUntradableItemIdReqs",
                                            mu.getAsString());
                                    continue;
                                }
                                missingRequirementsPanelX.addMissingItem("", mu.getAsInt());
                            }

                            // Clear the panel first
                            missingRequirementsPanel.removeAll();

                            // Add only the missingRequirementsPanelX (not the label)
                            missingRequirementsPanel.add(missingRequirementsPanelX);

                            // Refresh the panel
                            missingRequirementsPanel.revalidate();
                            missingRequirementsPanel.repaint();
                        } else {
                            missingRequiredItemsLabel.setText(htmlLabel("Missing Requirements: ", "None"));
                        }
                    });
                }).exceptionally(ex -> {
                    log.error("Error fetching profile data", ex);
                    return null;
                });

                this.isLoggedIn = true;

            }
        }
    }

    public void logOut() {
        // log.debug("inside of logOut()");
        this.isLoggedIn = false;

        // Update labels
        emailLabel.setContentType("text/html");
        emailLabel.setText("Sign in to send data to Embargo.");
        loggedLabel.setText("Not signed in");

        // Reset missing gear requirements
        missingRequiredItemsLabel
                .setText(htmlLabel("Sign in to see what requirements", " you are missing for rank up"));
        missingRequiredItemsLabel.setFont(smallFont);
        missingRequiredItemsLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        missingRequirementsPanelX.clearItems();

        // Rebuild missing requirements panel
        missingRequirementsContainer.removeAll();
        missingRequirementsPanel.removeAll();
        missingRequirementsPanel.add(missingRequiredItemsLabel);
        missingRequirementsContainer.add(missingRequirementsPanel, BorderLayout.CENTER);

        // Set to NA
        isRegisteredWithClanLabel.setText(htmlLabel("Account registered:", " No"));
        embargoScoreLabel.setText(htmlLabel("Embargo Score:", " N/A"));
        currentRankLabel.setText(htmlLabel("Current Rank:", " N/A"));
        accountScoreLabel.setText(htmlLabel("Account Score:", " N/A"));
        communityScoreLabel.setText(htmlLabel("Community Score:", " N/A"));
        currentCALabel.setText(htmlLabel("Current TA Tier:", " N/A"));

        // Rebuild version panel
        versionPanel.remove(isRegisteredWithClanLabel);
        versionPanel.remove(embargoScoreLabel);
        versionPanel.remove(accountScoreLabel);
        versionPanel.remove(communityScoreLabel);
        versionPanel.remove(currentRankLabel);
        versionPanel.remove(currentCALabel);

        // Make sure email label is added
        if (!containsComponent(versionPanel, emailLabel)) {
            versionPanel.add(emailLabel);
        }

        // Refresh UI
        versionPanel.revalidate();
        versionPanel.repaint();
        missingRequirementsPanel.revalidate();
        missingRequirementsPanel.repaint();
        missingRequirementsContainer.revalidate();
        missingRequirementsContainer.repaint();
        this.revalidate();
        this.repaint();
    }

    // Helper method to check if a container contains a component
    private boolean containsComponent(Container container, Component component) {
        Component[] components = container.getComponents();
        for (Component c : components) {
            if (c.equals(component)) {
                return true;
            }
        }
        return false;
    }

    public void reset() {
        eventBus.unregister(this);
        missingRequirementsPanelX.shutdown();
        this.updateLoggedIn(false);
    }

    /**
     * Builds a link panel with a given icon, text and url to redirect to.
     */
    private static JPanel buildLinkPanel(ImageIcon icon, String topText, String bottomText, String url) {
        return buildLinkPanel(icon, topText, bottomText, () -> LinkBrowser.browse(url));
    }

    /**
     * Builds a link panel with a given icon, text and callable to call.
     */
    private static JPanel buildLinkPanel(ImageIcon icon, String topText, String bottomText, Runnable callback) {
        JPanel container = new JPanel();
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        container.setLayout(new BorderLayout());
        container.setBorder(new EmptyBorder(10, 10, 10, 10));

        final Color hoverColor = ColorScheme.DARKER_GRAY_HOVER_COLOR;
        final Color pressedColor = ColorScheme.DARKER_GRAY_COLOR.brighter();

        JLabel iconLabel = new JLabel(icon);
        container.add(iconLabel, BorderLayout.WEST);

        JPanel textContainer = new JPanel();
        textContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        textContainer.setLayout(new GridLayout(2, 1));
        textContainer.setBorder(new EmptyBorder(5, 10, 5, 10));

        container.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent mouseEvent) {
                container.setBackground(pressedColor);
                textContainer.setBackground(pressedColor);
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                callback.run();
                container.setBackground(hoverColor);
                textContainer.setBackground(hoverColor);
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                container.setBackground(hoverColor);
                textContainer.setBackground(hoverColor);
                container.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                textContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                container.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            }
        });

        JLabel topLine = new JLabel(topText);
        topLine.setForeground(Color.WHITE);
        topLine.setFont(FontManager.getRunescapeSmallFont());

        JLabel bottomLine = new JLabel(bottomText);
        bottomLine.setForeground(Color.WHITE);
        bottomLine.setFont(FontManager.getRunescapeSmallFont());

        textContainer.add(topLine);
        textContainer.add(bottomLine);

        container.add(textContainer, BorderLayout.CENTER);

        JLabel arrowLabel = new JLabel(ARROW_RIGHT_ICON);
        container.add(arrowLabel, BorderLayout.EAST);

        return container;
    }
}

/*
Almost all of this code was taken from the tob-notice-board plugin by Broooklyn
https://github.com/Broooklyn/runelite-external-plugins/tree/tob-notice-board
Modifications were made to work with clans by Sharpienero/Embargo

Added TOA code
 13/04/2025 - Converted to use gamevals
 */


package gg.embargo.noticeboard;

import gg.embargo.EmbargoConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.clan.ClanChannelMember;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.util.Text;
import net.runelite.client.callback.ClientThread;


import javax.inject.Inject;

@Slf4j
public class NoticeBoardManager {
    @Inject
    private Client client;

    @Inject
    private EmbargoConfig config;

    @Inject
    private ClientThread clientThread;

    private final EventBus eventBus;



    @Inject
    public NoticeBoardManager(Client client, ClientThread clientThread, EventBus eventBus) {
        this.client = client;
        this.clientThread = clientThread;
        this.eventBus = eventBus;
    }

    private static final int DEFAULT_RGB = 0xff981f;
    private static final int STARTING_PARTY_CHILD_ID = 17;
    private static final int ENDING_PARTY_CHILD_ID = 62;

    private void setNoticeBoardWidget(int parent, int index, int clanColor) {
        for (int childID = STARTING_PARTY_CHILD_ID; childID < ENDING_PARTY_CHILD_ID; ++childID) {
            Widget noticeBoard = client.getWidget(parent, childID);

            if (noticeBoard != null && noticeBoard.getName() != null && noticeBoard.getChildren() != null) {
                for (Widget noticeBoardChild : noticeBoard.getChildren()) {
                    if (noticeBoardChild.getIndex() == index) {
                        if (client.getClanChannel() != null) {
                            for (ClanChannelMember member : client.getClanChannel().getMembers()) {
                                if (Text.toJagexName(member.getName()).equals(Text.removeTags(noticeBoard.getName()))) {
                                    noticeBoardChild.setTextColor(config.highlightClan() ? clanColor : DEFAULT_RGB);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    private void setApplicationWidget(int parent, int child, int clanColor) {
        Widget acceptWidgetMembers = client.getWidget(parent, child);
        if (acceptWidgetMembers != null && acceptWidgetMembers.getChildren() != null) {
            Widget[] acceptWidgetChildren = acceptWidgetMembers.getChildren();
            for (Widget w : acceptWidgetChildren) {
                if (client != null && client.getClanChannel() != null) {
                    for (ClanChannelMember member : client.getClanChannel().getMembers()) {
                        if (w.getText().contains(member.getName())) {
                            String hex = Integer.toHexString(clanColor).substring(2);
                            String builtName = "<col=" + hex + ">" + member.getName() + "</col>";
                            w.setName("<col=" + hex + ">" + member.getName() + "</col>");
                            w.setText(builtName);
                        }
                    }

                }
            }
        }
    }

    private void setTOBNameColors(int clanColor) {
        setApplicationWidget(50, 42, clanColor);
        setNoticeBoardWidget(364, 3, clanColor);
    }

    private void setTOANameColors(int clanColor) {
        setApplicationWidget(774, 48, clanColor);
        setNoticeBoardWidget(772, 2, clanColor);
    }

    public void startUp()
    {
        eventBus.register(this);
    }
    public void shutDown()
    {
        unsetNoticeBoards();
        eventBus.unregister(this);
    }

    public void setTOBNoticeBoard()
    {

        setTOBNameColors(config.clanColor().getRGB());
    }

    public void setTOANoticeBoard() {
        setTOANameColors(config.clanColor().getRGB());
    }

    public void setNoticeBoards() {
        if (config.highlightClan()) {
            setTOBNoticeBoard();
            setTOANoticeBoard();
        }
    }

    public void unsetNoticeBoards()
    {
        setTOBNameColors(DEFAULT_RGB);
        setTOANameColors(DEFAULT_RGB);
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded widgetLoaded)
    {
        clientThread.invokeLater(() ->
        {
            // TOB
            if (widgetLoaded.getGroupId() == InterfaceID.TOB_PARTYLIST || widgetLoaded.getGroupId() == InterfaceID.TOB_PARTYDETAILS)
            {
                setTOBNoticeBoard();
            }

            // TOA
            if (widgetLoaded.getGroupId() == InterfaceID.TOA_PARTYLIST|| widgetLoaded.getGroupId() == InterfaceID.TOA_PARTYDETAILS) {
                setTOANoticeBoard();
            }
        });
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        String CONFIG_GROUP = "embargo";
        if (!event.getGroup().equals(CONFIG_GROUP))
        {
            return;
        }

        unsetNoticeBoards();
        if (config.highlightClan()) {
            setTOBNoticeBoard();
            setTOANoticeBoard();
        }
    }
}

package gg.embargo.commands;

import gg.embargo.DataManager;
import gg.embargo.EmbargoConfig;
import gg.embargo.commands.embargo.Rank;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;
import java.awt.*;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

@Slf4j
public class CommandManager {
    @Inject
    private ClientThread clientThread;

    @Inject
    private EmbargoConfig config;

    @Inject
    private Client client;

    @Inject
    private DataManager dataManager;

    @Inject
    private ChatCommandManager chatCommandManager;

    private final EventBus eventBus;

    private static final String EMBARGO_COMMAND = "!embargo";

    @Inject
    public CommandManager(Client client, ClientThread clientThread, EventBus eventBus, EmbargoConfig config) {
        this.client = client;
        this.clientThread = clientThread;
        this.eventBus = eventBus;
        this.config = config;
    }

    public void startUp() {
        eventBus.register(this);
        chatCommandManager.registerCommandAsync(EMBARGO_COMMAND, this::processEmbargoLookupChatCommand);
    }

    public void shutDown() {
        eventBus.unregister(this);
        chatCommandManager.unregisterCommand(EMBARGO_COMMAND);
    }

    // Helper method to update chat message safely on the client thread
    private void updateChatMessage(ChatMessage chatMessage, String message) {
        clientThread.invokeLater(() -> {
            chatMessage.getMessageNode().setRuneLiteFormatMessage(message);
            client.refreshChat();
        });
    }

    public void processEmbargoLookupChatCommand(ChatMessage chatMessage, String message) {
        int firstWhitespace = message.indexOf(' ');
        String memberName = (firstWhitespace != -1 && firstWhitespace + 1 < message.length())
                ? message.substring(firstWhitespace + 1)
                : chatMessage.getName().replaceAll("<[^>]*>", "");

        String loadingMessage = new ChatMessageBuilder()
                .append(ChatColorType.HIGHLIGHT)
                .append("Looking up Embargo member...")
                .build();

        updateChatMessage(chatMessage, loadingMessage);

        String finalMemberName = memberName.replace('\u00A0', ' ').trim();
        dataManager.getProfileAsync(finalMemberName, true).thenAccept(embargoProfileData -> {
            // Null checks for safety
            if (embargoProfileData == null
                    || embargoProfileData.get("accountPoints") == null
                    || embargoProfileData.getAsJsonPrimitive("communityPoints") == null
                    || embargoProfileData.getAsJsonPrimitive("currentRank") == null) {
                String memberNotFound = new ChatMessageBuilder()
                        .append(ChatColorType.HIGHLIGHT)
                        .append("Error retrieving data for member: " + finalMemberName)
                        .build();
                updateChatMessage(chatMessage, memberNotFound);
                return;
            }

            String currentRankName = embargoProfileData.getAsJsonPrimitive("currentRank").getAsString();
            String leaderboardPosition = embargoProfileData.getAsJsonObject("leaderboardRank").get("currentPosition")
                    + "/"
                    + embargoProfileData.getAsJsonObject("leaderboardRank").get("totalPositions");
            Color rankColor = Rank.getColorByName(currentRankName);
            Color labelColor = config.chatCommandOutputColor();

            String outputMessage = new ChatMessageBuilder()
                    .append(labelColor, "Member: ")
                    .append(finalMemberName)
                    .append(labelColor, " Rank: ")
                    .append(rankColor, currentRankName)
                    .append(labelColor, " Account Points: ")
                    .append(ChatColorType.HIGHLIGHT)
                    .append(String.valueOf(embargoProfileData.get("accountPoints")))
                    .append(labelColor, " Community Points: ")
                    .append(ChatColorType.HIGHLIGHT)
                    .append(String.valueOf(embargoProfileData.getAsJsonPrimitive("communityPoints")))
                    .append(labelColor, " Leaderboard Rank: ")
                    .append(ChatColorType.HIGHLIGHT)
                    .append(leaderboardPosition)
                    .build();

            updateChatMessage(chatMessage, outputMessage);
        }).exceptionally(ex -> {
            String memberNotFound = new ChatMessageBuilder()
                    .append(ChatColorType.HIGHLIGHT)
                    .append("Member " + finalMemberName + " not found.")
                    .build();
            updateChatMessage(chatMessage, memberNotFound);
            return null;
        });
    }

}

package gg.embargo.commands.embargo;

import lombok.Getter;

import java.awt.*;

public enum Rank {
    BRONZE("Bronze", Color.orange),
    IRON("Iron", Color.darkGray),
    STEEL("Steel", Color.lightGray),
    MITHRIL("Mithril", Color.blue),
    ADAMANT("Adamant", Color.green),
    RUNE("Rune", Color.cyan),
    DRAGON("Dragon", Color.red),
    BEAST("Beast", Color.yellow);

    private final String name;
    @Getter
    private final Color color;

    Rank(String name, Color color) {
        this.name = name;
        this.color = color;
    }

    public static Color getColorByName(String name) {
        for (Rank rank : values()) {
            if (rank.name.equalsIgnoreCase(name)) {
                return rank.color;
            }
        }
        return Color.WHITE;
    }
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gg.embargo.collections;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class PlayerDataSubmission
{
    private String username;
    private String profile;
    private PlayerData data;
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gg.embargo.collections;

import lombok.Value;
import net.runelite.client.config.RuneScapeProfileType;

@Value
public class PlayerProfile
{
    String username;
    RuneScapeProfileType profileType;
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gg.embargo.collections;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PlayerData
{
    public List<Map<String, Map<String, Object>>> rawClogItems = new ArrayList<>();
}
package gg.embargo.collections;

/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.google.gson.Gson;
import com.google.gson.JsonParseException;
import gg.embargo.EmbargoConfig;
import gg.embargo.manifest.Manifest;
import gg.embargo.manifest.ManifestManager;
import gg.embargo.ui.EmbargoPanel;
import gg.embargo.ui.SyncButtonManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import okhttp3.*;

import javax.inject.Inject;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Slf4j
public class CollectionLogManager {

    private final int VARBITS_ARCHIVE_ID = 14;
    private static final String PLUGIN_USER_AGENT = "Embargo Runelite Plugin";

    private static final String SUBMIT_URL = "https://embargo.gg/api/runelite/uploadcollectionlog";
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    // Limit playerDataMap size to prevent unbounded growth - LRU eviction
    private static final int MAX_PLAYER_DATA_CACHE_SIZE = 10;
    private final Map<PlayerProfile, PlayerData> playerDataMap = new LinkedHashMap<PlayerProfile, PlayerData>(MAX_PLAYER_DATA_CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<PlayerProfile, PlayerData> eldest) {
            return size() > MAX_PLAYER_DATA_CACHE_SIZE;
        }
    };
    private int cyclesSinceSuccessfulCall = 0;
    // Use instance field instead of static to allow proper cleanup per instance
    private final List<Map<String, Map<String, Object>>> rawClogItems = new ArrayList<>();
    private int tickCollectionLogScriptFired = -1;

    private SyncButtonManager syncButtonManager;

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private ScheduledExecutorService scheduledExecutorService;

    @Inject
    private EmbargoPanel embargoPanel;

    @Inject
    private Gson gson;

    @Inject
    private EmbargoConfig config;

    @Inject
    private Manifest manifest;

    @Inject
    private ManifestManager manifestManager;

    @Inject
    private ItemManager itemManager;

    private final Client client;
    private final ClientThread clientThread;
    private final EventBus eventBus;

    @Inject
    private CollectionLogManager(
            Client client,
            ClientThread clientThread,
            EventBus eventBus) {
        this.client = client;
        this.clientThread = clientThread;
        this.eventBus = eventBus;
    }

    public void startUp(SyncButtonManager mainSyncButtonManager) {
        eventBus.register(this);
        manifestManager.getLatestManifest();
        syncButtonManager = mainSyncButtonManager;

        clientThread.invoke(() -> {
            if (client.getIndexConfig() == null || client.getGameState().ordinal() < GameState.LOGIN_SCREEN.ordinal()) {
                return false;
            }
            manifestManager.getLatestManifest();
            return true;
        });

    }

    public void shutDown() {
        eventBus.unregister(this);
        rawClogItems.clear();
        playerDataMap.clear();
        syncButtonManager.shutDown();
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        // Submit the collection log data two ticks after the first script prefires
        if (tickCollectionLogScriptFired != -1 &&
                tickCollectionLogScriptFired + 2 < client.getTickCount()) {
            tickCollectionLogScriptFired = -1;
            if (manifestManager.getManifest() == null) {
                client.addChatMessage(ChatMessageType.CONSOLE, "Embargo",
                        "Failed to sync collection log. Try restarting the Embargo plugin.", "Embargo");
                return;
            }
            scheduledExecutorService.execute(this::submitTask);
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState state = gameStateChanged.getGameState();
        switch (state) {
            // When hopping or logging out, we need to clear any state related to the player
            case HOPPING:
            case LOGGING_IN:
            case CONNECTION_LOST:
            case LOGIN_SCREEN: // Add this case to handle explicit logout
                rawClogItems.clear();
                embargoPanel.logOut();
                break;
        }
    }

    // CollectionLog Subscribe
    @Subscribe
    public void onScriptPreFired(ScriptPreFired preFired) {
        if (syncButtonManager.isSyncAllowed() && preFired.getScriptId() == 4100) {
            tickCollectionLogScriptFired = client.getTickCount();
            Object[] args = preFired.getScriptEvent().getArguments();
            int itemId = (int) args[1];
            int itemCount = (int) args[2];

            String itemName;
            try {
                ItemComposition ic = itemManager.getItemComposition(itemId);
                itemName = ic.getName();
            } catch (Exception e) {
                itemName = String.valueOf(itemId);
            }

            // Remove any existing entry for this itemName
            String finalItemName = itemName;
            rawClogItems.removeIf(map -> map.containsKey(finalItemName));

            // Add the new entry
            Map<String, Object> itemData = new HashMap<>();
            itemData.put("id", itemId);
            itemData.put("quantity", itemCount);

            Map<String, Map<String, Object>> entry = new HashMap<>();
            entry.put(itemName, itemData);

            rawClogItems.add(entry);
        }
    }

    synchronized public void submitTask() {
        // If sync hasn't been toggled to be allowed
        if (!syncButtonManager.isSyncAllowed()) {
            return;
        }

        // TODO: do we want other GameStates?
        if (client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        if (client.getLocalPlayer() == null) {
            log.debug("Skipped due to local player being null");
            return;
        }

        String username = client.getLocalPlayer().getName();
        RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);
        PlayerProfile profileKey = new PlayerProfile(username, profileType);

        PlayerData newPlayerData = getPlayerData();
        PlayerData oldPlayerData = playerDataMap.computeIfAbsent(profileKey, k -> new PlayerData());

        // Do not send if slot data wasn't generated
        if (newPlayerData.rawClogItems.isEmpty()) {
            return;
        }

        submitPlayerData(profileKey, newPlayerData, oldPlayerData);
    }

    private PlayerData getPlayerData() {
        PlayerData out = new PlayerData();
        out.rawClogItems = rawClogItems;
        return out;
    }

    private void merge(PlayerData oldPlayerData, PlayerData delta) {
        oldPlayerData.rawClogItems = delta.rawClogItems;
    }

    private void submitPlayerData(PlayerProfile profileKey, PlayerData delta, PlayerData old) {
        // If cyclesSinceSuccessfulCall is not a perfect square, we should not try to
        // submit.
        // This gives us quadratic backoff.
        cyclesSinceSuccessfulCall += 1;
        if (Math.pow((int) Math.sqrt(cyclesSinceSuccessfulCall), 2) != cyclesSinceSuccessfulCall) {
            return;
        }

        PlayerDataSubmission submission = new PlayerDataSubmission(
                profileKey.getUsername(),
                profileKey.getProfileType().name(),
                delta);

        Request request = new Request.Builder()
                .addHeader("User-Agent", PLUGIN_USER_AGENT)
                .url(SUBMIT_URL)
                .post(RequestBody.create(JSON, gson.toJson(submission)))
                .build();

        Call call = okHttpClient.newCall(request);
        call.timeout().timeout(3, TimeUnit.SECONDS);
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.debug("Failed to submit: ", e);
            }

            @Override
            public void onResponse(Call call, Response response) {
                try (response) {
                    if (!response.isSuccessful()) {
                        log.debug("Failed to submit: {}", response.code());
                        return;
                    }
                    merge(old, delta);
                    cyclesSinceSuccessfulCall = 0;
                } finally {
                    response.close();
                }
            }
        });
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        String CONFIG_GROUP = "embargo";
        if (!event.getGroup().equals(CONFIG_GROUP)) {
            return;
        }

        if (config.showCollectionLogSyncButton()) {
            syncButtonManager.startUp();
        } else {
            syncButtonManager.shutDown();
        }
    }
}

/*
 * Copyright (c) 2025, andmcadams
 * Modified by Sharpienero for Embargo
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gg.embargo.manifest;

import lombok.Data;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.List;

@Data
public class Manifest
{
    // misc
    final float version = -1;

    //Varp/varb trackable items
    final int[] varbits = new int[0];
    final int[] varps = new int[0];

    //Untrackable items
    public final List<Integer> untrackableItems = new ArrayList<>();

    //Raid/Minigame completion messages
    public Map<String, String> raidCompletionMessages = new HashMap<>();
    public Map<String, String> minigameCompletionMessages = new HashMap<>();

    //Collection log
    public final ArrayList<Integer> collections = new ArrayList<>();

    //Easter egg
    public Map<String, String> itemRenames = new HashMap<>();
    public Map<String, String> npcRenames = new HashMap<>();

}
package gg.embargo.manifest;

import com.google.gson.*;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
@Singleton
public class ManifestManager {

    @Inject
    private Gson gson;

    @Inject
    private OkHttpClient okHttpClient;

    @Getter
    @Setter
    private Manifest manifest;

    @Getter
    @Setter
    private float lastCheckedManifestVersion = -1;

    // Add timestamp for last check
    private long lastCheckTimestamp = 0;

    // Add a flag to track if a request is in progress
    private final AtomicBoolean requestInProgress = new AtomicBoolean(false);

    // 3 minutes in milliseconds
    private static final long CHECK_INTERVAL = 3 * 60 * 1000;

    //private static final String MOCK_API_URI = "https://a278d141-927f-433b-8e4b-6d994067900d.mock.pstmn.io/api/";
    private static final String API_URI = "https://embargo.gg/api/";
    private static final String MANIFEST_ENDPOINT = API_URI + "runelite/manifest";

    public Manifest getLatestManifest() {
        long currentTime = System.currentTimeMillis();

        // Only proceed if 3 minutes have passed since the last check AND no request is
        // in progress
        if (currentTime - lastCheckTimestamp < CHECK_INTERVAL || !requestInProgress.compareAndSet(false, true)) {
            log.debug(
                    "Skipping manifest check - last check was less than 3 minutes ago or request already in progress");
            return manifest; // Return the current manifest instead of null
        }

        try {
            Request r = new Request.Builder()
                    .url(MANIFEST_ENDPOINT)
                    .header("Cache-Control", "no-cache, no-store")
                    .header("Pragma", "no-cache")
                    .cacheControl(new CacheControl.Builder().noCache().noStore().build())
                    .build();

            okHttpClient.newCall(r).enqueue(new Callback() {
                @Override
                public void onFailure(@NonNull Call call, @NonNull IOException e) {
                    log.error("Error retrieving manifest", e);
                    requestInProgress.set(false); // Reset the flag
                }

                @Override
                public void onResponse(@NonNull Call call, @NonNull Response response) {
                    try (response; response) {
                        if (response.isSuccessful()) {
                            try {
                                if (response.body() == null) {
                                    log.error("Manifest request succeeded but returned empty body");
                                    return;
                                }

                                setManifest(gson.fromJson(
                                        new StringReader(new String(response.body().bytes(), StandardCharsets.UTF_8)),
                                        Manifest.class));
                                log.debug("Set manifest");

                                // Update the timestamp
                                lastCheckTimestamp = currentTime;

                                if (lastCheckedManifestVersion != manifest.getVersion()) {
                                    log.debug("Setting manifest version to {}", manifest.getVersion());
                                    lastCheckedManifestVersion = manifest.getVersion();
                                }
                            } catch (JsonSyntaxException e) {
                                log.error(e.getLocalizedMessage());
                            } catch (IOException e) {
                                log.error("Error reading response body", e);
                            }
                        } else {
                            log.error("Manifest request returned with status {}", response.code());
                            if (response.body() == null) {
                                log.error("Manifest request returned empty body");
                            } else {
                                log.error(response.body().toString());
                            }
                        }
                    } finally {
                        requestInProgress.set(false); // Reset the flag
                    }
                }
            });
        } catch (IllegalArgumentException e) {
            log.error("Bad URL given: {}", e.getLocalizedMessage());
            requestInProgress.set(false); // Reset the flag
        }

        log.debug("Returning set manifest (not null)");
        return manifest; // Return current manifest instead of null
    }
}
package gg.embargo;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class Embargo
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(EmbargoPlugin.class);
		RuneLite.main(args);
	}
}
