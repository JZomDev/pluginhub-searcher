package gg.embargo;

import net.runelite.client.config.*;

import java.awt.Color;

@ConfigGroup("embargo")
public interface EmbargoConfig extends Config
{
    @ConfigSection(
            name = "Raid Notice Boards",
            description = "Section that houses Notice Board options",
            position = 1
    )
    String noticeBoardSettings = "NoticeBoardSettings";

    @ConfigItem(
            keyName = "highlightClan",
            name = "Highlight Embargo Members",
            description = "Whether or not to highlight clan chat members' names on notice boards (ToA, Tob)",
            position = 1,
            section = noticeBoardSettings
    )
    default boolean highlightClan()
    {
        return true;
    }

    @ConfigItem(
            keyName = "clanColor",
            name = "Highlight Color",
            description = "The color with which to highlight names from your current clan chat",
            position = 2,
            section = noticeBoardSettings
    )
    default Color clanColor()
    {
        return new Color(53, 201, 255);
    }

    @ConfigSection(
            name = "Collection Log Sync Button",
            description = "Add a button to the collection log interface to sync your collection log with Embargo",
            position = 2
    )
    String collectionLogSettings = "CollectionLogSettings";

    @ConfigItem(
            keyName = "showCollectionLogSyncButton",
            name = "Show Collection Log Sync Button",
            description = "Whether or not to render the Embargo collection log sync button",
            position = 1,
            section = collectionLogSettings
    )
    default boolean showCollectionLogSyncButton() { return true; }

    @ConfigSection(
            name = "Clan Easter Eggs",
            description = "Enables fun item name replacements like 'Dragon warhammer' to 'Bonker'",
            position = 3
    )
    String easterEggSettings = "EasterEggSettings";

    @ConfigItem(
        keyName = "enableClanEasterEggs",
        name = "Enable Easter Eggs",
        description = "A top level control to enable/disable the feature",
        position = 3,
        section = easterEggSettings
    )
    default boolean enableClanEasterEggs() {
        return true;
    }


    @ConfigItem(
            keyName = "enableItemRenames",
            name = "Enable Item Renames",
            description = "Enables item name replacements like 'Dragon warhammer' to 'Bonker'",
            position = 4,
            section = easterEggSettings
    )
    default boolean enableItemRenames() {
        return true;
    }

    @ConfigItem(
            keyName = "enableNpcRenames",
            name = "Enable NPC Renames",
            description = "Enables NPC name changes, like 'Pestilent Bloat' to 'Dr D1sconnect'",
            position = 5,
            section = easterEggSettings
    )
    default boolean enableNpcRenames() {
        return true;
    }

    @ConfigSection(
            name = "Chat Alerts",
            description = "Control which notifications appear in your chat box",
            position = 4
    )
    String chatAlertSettings = "ChatAlertSettings";

    @ConfigItem(
            keyName = "enableBountyAlerts",
            name = "Bounty Alerts",
            description = "Show a chat message when a new bounty becomes active",
            position = 1,
            section = chatAlertSettings
    )
    default boolean enableBountyAlerts() {
        return true;
    }

    @ConfigItem(
            keyName = "enableEventAlerts",
            name = "Event Alerts",
            description = "Show a chat message when a new Of The Week event starts",
            position = 2,
            section = chatAlertSettings
    )
    default boolean enableEventAlerts() {
        return true;
    }

    @ConfigItem(
            keyName = "enablePollAlerts",
            name = "Poll Alerts",
            description = "Show a chat message when a new poll is available",
            position = 3,
            section = chatAlertSettings
    )
    default boolean enablePollAlerts() {
        return true;
    }

    @ConfigSection(
            name = "Chat Commands",
            description = "Section that houses Chat Command options",
            position = 5
    )
    String chatCommandSettings = "ChatCommandSettings";

    @ConfigItem(
            keyName = "chatCommandOutputColor",
            name = "Output Text Color",
            description = "The color that highlighted text will be when using clan chat commands.",
            position = 1,
            section = chatCommandSettings
    )
    default Color chatCommandOutputColor()
    {
        return new Color(255, 116, 0);
    }

}


package gg.embargo;

import com.google.inject.Provides;
import gg.embargo.collections.*;
import gg.embargo.commands.CommandManager;
import gg.embargo.eastereggs.NPCRenameManager;
import gg.embargo.manifest.ManifestManager;
import gg.embargo.ui.EmbargoPanel;
import gg.embargo.eastereggs.ItemRenameManager;
import gg.embargo.ui.MissingRequirementsPanel;
import gg.embargo.ui.SyncButtonManager;
import gg.embargo.noticeboard.NoticeBoardManager;
import gg.embargo.untrackables.UntrackableItemManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import net.runelite.http.api.loottracker.LootRecordType;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BiConsumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@PluginDescriptor(name = "Embargo Clan", description = "A plugin to sync your account with Embargo", tags = { "embargo",
		"clan", "embargo.gg", "ironman" })
public class EmbargoPlugin extends Plugin {

	private static final String CONFIG_GROUP = "embargo";
	private static final int SECONDS_BETWEEN_UPLOADS = 30;
	private static final int SECONDS_BETWEEN_PROFILE_UPDATES = 15;
	private static final Pattern COLLECTION_LOG_ITEM_REGEX = Pattern
			.compile("New item added to your collection log: (.*)");

	@Inject
	private DataManager dataManager;

	@Inject
	private ClientThread clientThread;

	@Inject
	private Client client;

	@Inject
	private EmbargoConfig config;

	@Inject
	private EmbargoPanel embargoPanel;

	@Inject
	private NoticeBoardManager noticeBoardManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private SyncButtonManager syncButtonManager;

	@Inject
	private CollectionLogManager clogManager;

	@Inject
	private UntrackableItemManager untrackableItemManager;

	@Inject
	private ItemRenameManager itemRenameManager;

	@Inject
	private NPCRenameManager npcRenameManager;

	@Inject
	public ManifestManager manifestManager;

	@Inject
	public CommandManager commandManager;

	private RuneScapeProfileType lastProfile;

	private NavigationButton navButton;

	private final Map<String, Integer> skillLevelCache = new HashMap<>();

	AtomicBoolean isUsernameRegistered = new AtomicBoolean(false);

	@Provides
	EmbargoConfig getConfig(ConfigManager configManager) {
		return configManager.getConfig(EmbargoConfig.class);
	}

	@Override
	protected void startUp() {
		log.info("Embargo Clan plugin started!");

		if (dataManager.stopTryingForAccount.get()) {
			return;
		}

		initializePanel();
		initializeManagers();

		lastProfile = null;
		dataManager.resetVarbsAndVarpsToCheck();
		skillLevelCache.clear();
		dataManager.getManifest();

		itemRenameManager.setupMenuRenames();

		if (client != null) {
			if (client.getGameState() == GameState.LOGGED_IN) {
				dataManager.isUserRegisteredAsync(client.getLocalPlayer().getName(), isRegistered -> {
					if (isRegistered) {
						embargoPanel.updateLoggedIn(false);
					}
				});
			}
		}
	}

	private void initializePanel() {
		embargoPanel = injector.getInstance(EmbargoPanel.class);
		embargoPanel.init();
		embargoPanel.updateLoggedIn(false);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");
		navButton = NavigationButton.builder()
				.tooltip("Embargo Clan")
				.icon(icon)
				.priority(0)
				.panel(embargoPanel)
				.build();

		clientToolbar.addNavigation(navButton);
	}

	private void initializeManagers() {
		if (config != null && config.showCollectionLogSyncButton()) {
			syncButtonManager.startUp();
		}

		clogManager.startUp(syncButtonManager);
		untrackableItemManager.startUp();
		noticeBoardManager.startUp();
		commandManager.startUp();

		if (config != null && config.highlightClan()) {
			noticeBoardManager.setNoticeBoards();
		}

		if (config != null && config.enableClanEasterEggs()) {
			itemRenameManager.startUp();
			npcRenameManager.startUp();
		}
	}

	@Inject
	private MissingRequirementsPanel missingRequirementsPanel;

	@Override
	protected void shutDown() {
		log.info("Embargo Clan plugin stopped!");

		dataManager.clearData();
		embargoPanel.reset();
		clientToolbar.removeNavigation(navButton);

		// Cleanup MissingRequirementsPanel to prevent timer and cache leaks
		if (missingRequirementsPanel != null) {
			missingRequirementsPanel.shutdown();
		}

		shutDownManagers();

		embargoPanel = null;
		navButton = null;
	}

	private void shutDownManagers() {
		noticeBoardManager.shutDown();
		clogManager.shutDown();
		untrackableItemManager.shutDown();
		syncButtonManager.shutDown();
		itemRenameManager.shutDown();
		npcRenameManager.shutDown();
		commandManager.shutDown();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		GameState gameState = event.getGameState();
		if (gameState == GameState.LOADING)
			return;

		if (gameState == GameState.LOGGED_IN && !embargoPanel.isLoggedIn) {
			log.debug("inside of condition, handling loggedIn");
			handleLoggedIn();
		} else if (gameState == GameState.LOGIN_SCREEN) {
			handleLoggedOut();
		}
	}

	private void handleLoggedIn() {
		clientThread.invokeLater(() -> {
			if (client == null || dataManager.stopTryingForAccount.get()) {
				return false;
			}

			if (isUsernameRegistered.get()) {
				embargoPanel.updateLoggedIn(true);
				return true;
			}

			Player localPlayer = client.getLocalPlayer();
			if (localPlayer != null) {
				String username = localPlayer.getName();

				dataManager.isUserRegisteredAsync(username, isRegistered -> {
					if (isRegistered) {
						embargoPanel.updateLoggedIn(true);
						isUsernameRegistered.set(true);
					}
				});
			}
			return isUsernameRegistered.get();
		});
	}

	private void handleLoggedOut() {
		log.debug("User logged out");

		// Clear both panel references
		if (embargoPanel != null) {
			SwingUtilities.invokeLater(() -> embargoPanel.logOut());
		} else {
			log.debug("embargoPanel is null!!!");
		}

		// Also clear the panel reference (which is different from embargoPanel)
		if (embargoPanel != null) {
			embargoPanel.reset();
			embargoPanel.updateLoggedIn(false);
		}

		// Clear data in DataManager to ensure complete reset
		dataManager.clearData();

		// Reset skill cache
		skillLevelCache.clear();
	}

	@Schedule(period = SECONDS_BETWEEN_UPLOADS, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void ensureLatestManifest() {
		if (manifestManager.getLatestManifest() != null) {
			if (!(manifestManager.getLastCheckedManifestVersion() == manifestManager.getLatestManifest()
					.getVersion())) {
				manifestManager.getLatestManifest();
			}
		}
	}

	@Schedule(period = SECONDS_BETWEEN_UPLOADS, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void submitToAPI() {
		if (client == null) {
			return;
		}

		GameState gameState = client.getGameState();
		if (gameState != GameState.HOPPING && gameState != GameState.LOGIN_SCREEN) {
			dataManager.submitToAPI();
			updatePlayerRegistrationStatus();
		} else {
			// log.debug("User is hopping or logged out, do not send data");
			embargoPanel.logOut();
		}
	}

	private void updatePlayerRegistrationStatus() {
		if (dataManager.stopTryingForAccount.get()) {
			return;
		}
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer != null) {
			String username = localPlayer.getName();
			dataManager.isUserRegisteredAsync(username, isRegistered -> {
				if (isRegistered) {
					log.debug("updateProfileAfterLoggedIn Member registered");
					embargoPanel.updateLoggedIn(true);
				}
			});
		}
	}

	@Schedule(period = SECONDS_BETWEEN_PROFILE_UPDATES, unit = ChronoUnit.SECONDS, asynchronous = true)
	public void checkProfileChanged() {
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer != null && client.getGameState() == GameState.LOGGED_IN) {
			embargoPanel.updateLoggedIn(true);
			clientThread.invokeLater(this::checkProfileChange);
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage) {
		if (client == null || manifestManager.getLatestManifest() == null)
			return;

		Player player = client.getLocalPlayer();
		if (player == null)
			return;

		String message = chatMessage.getMessage();

		ChatMessageType messageType = chatMessage.getType();
		RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);

		// Only process for standard profile
		if (profileType != RuneScapeProfileType.STANDARD) {
			return;
		}

		// Check for collection log items
		if (messageType == ChatMessageType.GAMEMESSAGE) {
			Matcher matcher = COLLECTION_LOG_ITEM_REGEX.matcher(message);
			if (matcher.matches()) {
				String obtainedItemName = Text.removeTags(matcher.group(1));
				dataManager.uploadCollectionLogUnlock(obtainedItemName, player.getName());
			}
		}

		// Check for activity completions
		if (messageType == ChatMessageType.GAMEMESSAGE ||
				messageType == ChatMessageType.FRIENDSCHATNOTIFICATION ||
				messageType == ChatMessageType.SPAM) {

			if (processCompletionMessages(manifestManager.getLatestManifest().getRaidCompletionMessages(), message,
					(name, _message) -> dataManager.uploadRaidCompletion(name, _message))) {
				// return early as it saves time in case it gets processed here, otherwise it's
				// most likely a minigame completion message or unrelated
				return;
			}

			processCompletionMessages(manifestManager.getLatestManifest().minigameCompletionMessages, message,
					(name, _message) -> dataManager.uploadMinigameCompletion(name, _message));
		}
	}

	private boolean processCompletionMessages(Map<String, String> messageMap, String chatMessage,
			BiConsumer<String, String> uploadAction) {
		for (Map.Entry<String, String> entry : messageMap.entrySet()) {
			String name = entry.getKey();
			String completionMessage = entry.getValue();

			if (chatMessage.contains(completionMessage)) {
				log.debug("Sending API request for completed activity");
				uploadAction.accept(name, chatMessage);
				return true;
			}
		}
		return false;
	}

	public void checkProfileChange() {
		if (client == null) {
			return;
		}

		RuneScapeProfileType currentProfile = RuneScapeProfileType.getCurrent(client);
		boolean isStandardProfile = currentProfile == RuneScapeProfileType.STANDARD;
		boolean profileChanged = isStandardProfile && currentProfile != lastProfile;
		boolean dataAvailable = dataManager.getVarbitsToCheck() != null && dataManager.getVarpsToCheck() != null;
		boolean isLoggedIn = client.getGameState() == GameState.LOGGED_IN;

		if (profileChanged && dataAvailable && isLoggedIn) {
			// Profile change, we should clear the dataManager and do a new initial dump
			log.debug("Profile changed to standard. Reloading all data and updating profile");
			lastProfile = currentProfile;
			dataManager.clearData();
			dataManager.loadInitialData();
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged statChanged) {
		Skill skill = statChanged.getSkill();
		if (skill == null) {
			return;
		}

		String skillName = skill.getName();
		int newLevel = statChanged.getLevel();
		Integer cachedLevel = skillLevelCache.get(skillName);

		if (cachedLevel == null || cachedLevel != newLevel) {
			skillLevelCache.put(skillName, newLevel);
			dataManager.storeSkillChanged(skillName, newLevel);
		}
	}

	@Subscribe
	public void onLootReceived(final LootReceived event) {
		LootRecordType eventType = event.getType();
		if (eventType != LootRecordType.NPC && eventType != LootRecordType.EVENT) {
			return;
		}

		String npcName = event.getName();
		if (dataManager.shouldTrackLoot(npcName)) {
			log.debug("Player killed {}", npcName);
			dataManager.uploadLoot(event);
		} else {
			log.debug("Player killed {}, nothing to log", npcName);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals(CONFIG_GROUP)) {
			return;
		}

		// Update notice boards based on config
		noticeBoardManager.unsetNoticeBoards();
		if (config.highlightClan()) {
			noticeBoardManager.setTOBNoticeBoard();
			noticeBoardManager.setTOANoticeBoard();
		}

		// Update sync button based on config
		if (config.showCollectionLogSyncButton()) {
			syncButtonManager.startUp();
		} else {
			syncButtonManager.shutDown();
		}

		// Handle item rename config changes
		if (event.getKey().equals("enableClanEasterEggs")) {
			if (config.enableClanEasterEggs()) {
				itemRenameManager.startUp();
				npcRenameManager.startUp();
			} else {
				itemRenameManager.shutDown();
				npcRenameManager.shutDown();
			}
		}
	}

}

package gg.embargo.eastereggs;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import gg.embargo.EmbargoConfig;
import gg.embargo.manifest.ManifestManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

@Slf4j
public class NPCRenameManager {

    private final EventBus eventBus;
    private final EmbargoConfig config;
    private final ManifestManager manifestManager;

    @Inject
    public NPCRenameManager(EventBus eventBus, EmbargoConfig config, ManifestManager manifestManager) {
        this.eventBus = eventBus;
        this.config = config;
        this.manifestManager = manifestManager;
    }

    private static final Set<MenuAction> NPC_MENU_ACTIONS = ImmutableSet.of(
            MenuAction.NPC_FIRST_OPTION,
            MenuAction.NPC_SECOND_OPTION,
            MenuAction.NPC_THIRD_OPTION,
            MenuAction.NPC_FOURTH_OPTION,
            MenuAction.NPC_FIFTH_OPTION,
            MenuAction.WIDGET_TARGET_ON_NPC,
            MenuAction.EXAMINE_NPC);

    private static final ImmutableMap<String, String> DEFAULT_NPC_RENAMES = ImmutableMap.<String, String>builder()
            .build();
    private final Map<String, String> customNPCRemaps = new HashMap<>();

    private boolean manifestFetchAttempted = false;

    public boolean featureEnabled() {
        return config.enableClanEasterEggs() && config.enableNpcRenames();
    }

    @Subscribe
    protected void onMenuEntryAdded(MenuEntryAdded event) {

        if (!featureEnabled()) {
            return;
        }

        if (manifestManager.getManifest() == null) {
            manifestManager.getLatestManifest();
            return;
        }

        // Check if manifest is empty and fetch if needed
        if (manifestManager.getManifest().getItemRenames() == null) {
            manifestManager.getLatestManifest();
        }

        parseManifest();
        MenuEntry entry = event.getMenuEntry();

        if (NPC_MENU_ACTIONS.contains(entry.getType())) {
            remapMenuEntryText(entry, (HashMap<String, String>) customNPCRemaps); // Use customNPCRemaps instead of
                                                                                  // npcListHashMap
        }
    }

    public void startUp() {
        eventBus.register(this);

        if (!featureEnabled())
            return;

        setupMenuRenames();
        manifestManager.getLatestManifest(); // Fetch manifest on startup
    }

    public void shutDown() {
        customNPCRemaps.clear();
        eventBus.unregister(this);
    }

    public void setupMenuRenames() {
        customNPCRemaps.clear();
        customNPCRemaps.putAll(DEFAULT_NPC_RENAMES);
    }

    public void parseManifest() {
        if (manifestManager.getManifest().getNpcRenames() == null
                || manifestManager.getManifest().getNpcRenames().isEmpty()) {
            if (!manifestFetchAttempted) {
                manifestFetchAttempted = true;
                manifestManager.getLatestManifest();
                log.debug("manifest.npcRenames is empty, attempting to refetch");
            }
            return;
        }

        // Clear and repopulate custom remaps
        customNPCRemaps.clear();
        customNPCRemaps.putAll(DEFAULT_NPC_RENAMES);

        // Add manifest renames
        for (Map.Entry<String, String> entry : manifestManager.getManifest().getNpcRenames().entrySet()) {
            String originalName = entry.getKey();
            String newName = entry.getValue();
            customNPCRemaps.put(originalName, newName);
        }
    }

    private void remapMenuEntryText(MenuEntry menuEntry, HashMap<String, String> map) {
        String target = menuEntry.getTarget();
        String cleanTarget;

        NPC npc = menuEntry.getNpc();
        cleanTarget = npc != null ? Text.removeTags(npc.getName()) : Text.removeTags(target);

        String replacement = customNPCRemaps.get(cleanTarget);
        if (replacement != null) {
            menuEntry.setTarget(target.replace(cleanTarget, replacement));
        }
    }
}

package gg.embargo.eastereggs;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import gg.embargo.EmbargoConfig;
import gg.embargo.manifest.ManifestManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;
import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

@Slf4j
@Singleton
public class ItemRenameManager {

    private final EventBus eventBus;
    private final EmbargoConfig config;
    private final ManifestManager manifestManager;

    @Inject
    public ItemRenameManager(EventBus eventBus, EmbargoConfig config, ManifestManager manifestManager) {
        this.eventBus = eventBus;
        this.config = config;
        this.manifestManager = manifestManager;
    }

    private boolean manifestFetchAttempted = false;

    private static final Set<MenuAction> ITEM_MENU_ACTIONS = ImmutableSet.of(
            MenuAction.GROUND_ITEM_FIRST_OPTION, MenuAction.GROUND_ITEM_SECOND_OPTION,
            MenuAction.GROUND_ITEM_THIRD_OPTION, MenuAction.GROUND_ITEM_FOURTH_OPTION,
            MenuAction.GROUND_ITEM_FIFTH_OPTION, MenuAction.EXAMINE_ITEM_GROUND,
            // Inventory + Using Item on Players/NPCs/Objects
            MenuAction.CC_OP, MenuAction.CC_OP_LOW_PRIORITY, MenuAction.WIDGET_TARGET,
            MenuAction.WIDGET_TARGET_ON_PLAYER, MenuAction.WIDGET_TARGET_ON_NPC,
            MenuAction.WIDGET_TARGET_ON_GAME_OBJECT, MenuAction.WIDGET_TARGET_ON_GROUND_ITEM,
            MenuAction.WIDGET_TARGET_ON_WIDGET);

    // Default item name remappings
    private static final ImmutableMap<String, String> DEFAULT_ITEM_REMAP = ImmutableMap.<String, String>builder()
            .build();

    // Map for custom renamings
    private final Map<String, String> customItemRemap = new HashMap<>();

    public boolean featureEnabled() {
        return config.enableClanEasterEggs() && config.enableItemRenames();
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event) {
        // Only process if easter eggs are enabled
        if (!featureEnabled()) {
            return;
        }

        if (manifestManager.getManifest() == null) {
            manifestManager.getLatestManifest();
            return;
        }

        // Check if manifest is empty and fetch if needed
        if (manifestManager.getManifest().getItemRenames() == null) {
            manifestManager.getLatestManifest();
        }

        parseManifest();

        MenuEntry entry = event.getMenuEntry();
        if (ITEM_MENU_ACTIONS.contains(entry.getType())) {
            remapMenuEntryText(entry, customItemRemap);
        }
    }

    public void startUp() {
        eventBus.register(this);

        if (!featureEnabled())
            return;

        setupMenuRenames();
        manifestManager.getLatestManifest(); // Fetch manifest on startup
    }

    public void shutDown() {
        customItemRemap.clear();
        eventBus.unregister(this);
    }

    public void setupMenuRenames() {
        customItemRemap.clear();
        customItemRemap.putAll(DEFAULT_ITEM_REMAP);
    }

    public void parseManifest() {
        if (manifestManager.getManifest().getItemRenames() == null
                || manifestManager.getManifest().getItemRenames().isEmpty()) {
            if (!manifestFetchAttempted) {
                log.debug("manifest.itemRenames is empty, attempting to refetch");
            }
            return;
        }

        // Clear and repopulate to prevent unbounded accumulation
        customItemRemap.clear();
        customItemRemap.putAll(DEFAULT_ITEM_REMAP);

        for (Map.Entry<String, String> entry : manifestManager.getManifest().getItemRenames().entrySet()) {
            String originalName = entry.getKey();
            String newName = entry.getValue();
            customItemRemap.put(originalName, newName);
        }
    }

    /**
     * Remaps a menu entry's text if the target matches an entry in the provided
     * map.
     * 
     * @param menuEntry The menu entry to modify
     * @param map       The map of item names to replacement item names
     */
    private void remapMenuEntryText(MenuEntry menuEntry, Map<String, String> map) {
        String target = menuEntry.getTarget();
        String cleanTarget;

        NPC npc = menuEntry.getNpc();
        cleanTarget = npc != null ? Text.removeTags(npc.getName()) : Text.removeTags(target);

        String replacement = map.get(cleanTarget);
        if (replacement != null) {
            menuEntry.setTarget(target.replace(cleanTarget, replacement));
        }
    }
}

package gg.embargo.untrackables;

import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.stream.Collectors;

@Slf4j
@Singleton
public class UntrackableItemManager {

    @Inject
    private Client client;

    private final EventBus eventBus;

    @Inject
    private UntrackableItemManager(Client client, EventBus eventBus) {
        this.client = client;
        this.eventBus = eventBus;
    }

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private ScheduledExecutorService executorService;

    private static final String UNTRACKABLE_ENDPOINT = "https://embargo.gg/api/untrackables";

    // Limit size to prevent unbounded growth - LRU eviction for player loot
    // timestamps
    private static final int MAX_LOOT_TIME_CACHE_SIZE = 50;
    private final Map<String, LocalDateTime> lastLootTime = new LinkedHashMap<String, LocalDateTime>(
            MAX_LOOT_TIME_CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<String, LocalDateTime> eldest) {
            return size() > MAX_LOOT_TIME_CACHE_SIZE;
        }
    };

    @Getter
    enum UntrackableItems {

        BOOK_OF_THE_DEAD(25818),
        MUSIC_CAPE(13221),
        MUSIC_CAPE_T(13222),
        BARROWS_GLOVES(7462),
        IMBUED_SARADOMIN_CAPE(21791),
        IMBUED_GUTHIX_CAPE(21793),
        IMBUED_ZAMORAK_CAPE(21795),
        IMBUED_SARADOMIN_MAX_CAPE(21776),
        IMBUED_ZAMORAK_MAX_CAPE(21780),
        IMBUED_GUTHIX_MAX_CAPE(21784),
        IMBUED_SARADOMIN_MAX_CAPE_I(24232),
        IMBUED_ZAMORAK_MAX_CAPE_I(24233),
        IMBUED_GUTHIX_MAX_CAPE_I(24234),

        // BINGO #1 ITEMS FOR START COUNTS
        BEGINNER_REWARD_CASKET(23245),
        EASY_REWARD_CASKET(20546),
        MEDIUM_REWARD_CASKET(20545),
        HARD_REWARD_CASKET(20544),
        ELITE_REWARD_CASKET(20543),
        MASTER_REWARD_CASKET(19836),

        MOSSY_KEY(22374),
        GIANT_KEY(20754);

        private final int itemId;

        UntrackableItems(int itemId) {
            this.itemId = itemId;
        }
    }

    void getUntrackableItems(String username) {
        Widget widget = client.getWidget(786445);
        ItemContainer itemContainer = client.getItemContainer(InventoryID.BANK);
        Widget[] children;
        if (widget != null) {
            children = widget.getChildren();
        } else {
            return;
        }
        if (itemContainer == null || children == null) {
            return;
        }

        // Build the set of trackable item IDs once (small, constant size)
        var itemMap = Arrays.stream(UntrackableItems.values()).map(UntrackableItems::getItemId)
                .collect(Collectors.toCollection(HashSet::new));

        // Quickly capture item data from widgets on client thread
        int bankSize = Math.min(itemContainer.size(), children.length);
        int[] itemIds = new int[bankSize];
        int[] quantities = new int[bankSize];
        for (int i = 0; i < bankSize; i++) {
            Widget child = children[i];
            itemIds[i] = child.getItemId();
            quantities[i] = child.getItemQuantity();
        }

        // Process and send off the client thread to prevent stutter
        executorService.execute(() -> {
            List<Integer> playerItems = new ArrayList<>();
            Map<Integer, Integer> itemQuantities = new HashMap<>();

            for (int i = 0; i < itemIds.length; i++) {
                if (itemMap.contains(itemIds[i])) {
                    playerItems.add(itemIds[i]);
                    itemQuantities.put(itemIds[i], quantities[i]);
                }
            }

            if (playerItems.isEmpty()) {
                return;
            }

            var requestBody = new FormBody.Builder();
            for (int i = 0; i < playerItems.size(); i++) {
                requestBody.add("itemIds[" + i + "]", String.valueOf(playerItems.get(i)));
                requestBody.add("quantities[" + i + "]", String.valueOf(itemQuantities.get(playerItems.get(i))));
            }
            requestBody.add("username", username);

            Request request = new Request.Builder()
                    .url(UNTRACKABLE_ENDPOINT)
                    .post(requestBody.build())
                    .addHeader("Content-Type", "application/json")
                    .build();

            try {
                okHttpClient.newCall(request).enqueue(new Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        log.error("Something went wrong inside of getUntrackableItems: {}", e.getLocalizedMessage());
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) {
                        if (response.isSuccessful()) {
                            log.debug("Successfully submitted getUntrackableItems");
                        }
                        response.close();
                    }
                });
            } catch (IllegalArgumentException e) {
                log.error("Bad URL given: {}", e.getLocalizedMessage());
            }
        });
    }

    public void startUp() {
        eventBus.register(this);
    }

    public void shutDown() {
        eventBus.unregister(this);
        lastLootTime.clear();
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event) {
        if (event.getScriptId() == 277) {
            if (client == null || client.getLocalPlayer() == null) {
                return;
            }

            var username = client.getLocalPlayer().getName();

            if (lastLootTime.containsKey(username)) {
                LocalDateTime lastLootTimestamp = lastLootTime.get(username);

                if (LocalDateTime.now().isBefore(lastLootTimestamp)) {
                    log.debug("Player has opened bank within the last 3 minutes, not checking for untrackable items");
                    return;
                }

            }
            getUntrackableItems(username);
            lastLootTime.put(username, LocalDateTime.now().plusMinutes(3));
        }
    }
}

/*
 * Copyright (c) 2021, andmcadams
 * modified by Sharpienero, Contronym
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package gg.embargo;

import com.google.common.collect.HashMultimap;
import com.google.gson.*;
import gg.embargo.manifest.ManifestManager;
import gg.embargo.ui.EmbargoPanel;
import gg.embargo.untrackables.UntrackableItemManager;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.task.Schedule;
import okhttp3.*;
import okio.BufferedSource;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Consumer;

@Slf4j
@Singleton
public class DataManager {
    @Inject
    private Client client;

    @Inject
    private ItemManager itemManager;

    @Inject
    private ClientThread clientThread;

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private EmbargoPanel embargoPanel;

    @Inject
    private Gson gson;

    @Getter
    @Setter
    private HashSet<Integer> varpsToCheck;

    @Getter
    @Setter
    private HashSet<Integer> varbitsToCheck;

    @Inject
    private ManifestManager manifestManager;

    @Getter
    @Setter
    private int lastManifestVersion = -1;

    AtomicBoolean isUsernameRegistered = new AtomicBoolean(false);
    public AtomicBoolean stopTryingForAccount = new AtomicBoolean(false);

    private int[] oldVarps;

    private final HashMultimap<Integer, Integer> varpToVarbitMapping = HashMultimap.create();

    private final HashMap<Integer, Integer> varbData = new HashMap<>();
    private final HashMap<Integer, Integer> varpData = new HashMap<>();
    private final HashMap<String, Integer> levelData = new HashMap<>();

    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    enum APIRoutes {
        MANIFEST("runelite/manifest"),
        UNTRACKABLES("untrackables"),
        CHECKREGISTRATION("checkregistration"),
        GET_PROFILE("getgear"),
        SUBMIT_LOOT("loot"),
        GET_RAID_MONSTERS_TO_TRACK_LOOT("lootBosses"),
        PREPARE_RAID("raid"),
        UPLOAD_CLOG("collectionlog"),
        MINIGAME_COMPLETE("minigame"),
        GET_MEMBER_INFO("embargo-profile"),
        BOUNTIES("bounties"),
        EVENTS("events"),
        LAST_POLL("lastpoll");

        APIRoutes(String route) {
            this.route = route;
        }

        private final String route;

        @Override
        public String toString() {
            return route;
        }
    }

    // private static final String MOCK_API_URI =
    // "https://a278d141-927f-433b-8e4b-6d994067900d.mock.pstmn.io/api/";
    private static final String API_URI = "https://embargo.gg/api/";
    private static final String MANIFEST_ENDPOINT = API_URI + APIRoutes.MANIFEST;
    private static final String UNTRACKABLE_POST_ENDPOINT = API_URI + APIRoutes.UNTRACKABLES;
    private static final String CHECK_REGISTRATION_ENDPOINT = API_URI + APIRoutes.CHECKREGISTRATION;
    private static final String GET_PROFILE_ENDPOINT = API_URI + APIRoutes.GET_PROFILE;
    private static final String SUBMIT_LOOT_ENDPOINT = API_URI + APIRoutes.SUBMIT_LOOT;
    private static final String TRACK_MONSTERS_ENDPOINT = API_URI + APIRoutes.GET_RAID_MONSTERS_TO_TRACK_LOOT;
    private static final String PREPARE_RAID_ENDPOINT = API_URI + APIRoutes.PREPARE_RAID;
    private static final String MINIGAME_COMPLETION_ENDPOINT = API_URI + APIRoutes.MINIGAME_COMPLETE;
    private static final String CLOG_UNLOCK_ENDPOINT = API_URI + APIRoutes.UPLOAD_CLOG;
    private static final String GET_MEMBER_INFO_ENDPOINT = API_URI + APIRoutes.GET_MEMBER_INFO;
    private static final String BOUNTIES_ENDPOINT = API_URI + APIRoutes.BOUNTIES;
    private static final String EVENTS_ENDPOINT = API_URI + APIRoutes.EVENTS;
    private static final String LAST_POLL_ENDPOINT = API_URI + APIRoutes.LAST_POLL;

    // Boss list from API - use volatile for thread safety and instance field for proper cleanup
    private volatile List<String> bossesToTrack = null;

    public void storeVarbitChanged(int varbIndex, int varbValue) {
        synchronized (this) {
            varbData.put(varbIndex, varbValue);
        }
    }

    public void resetVarbsAndVarpsToCheck() {
        varbitsToCheck = null;
        varpsToCheck = null;
    }

    public List<Player> getSurroundingPlayers() {
        WorldView worldView = client.getTopLevelWorldView();
        if (worldView == null) {
            return Collections.emptyList();
        }
        List<Player> players = new ArrayList<>();
        for (Player player : worldView.players()) {
            players.add(player);
        }
        return players;
    }

    public boolean shouldTrackLoot(String bossName) {
        if (bossName == null || bossName.isEmpty()) {
            return false;
        }

        List<String> bosses = getTrackableBosses();
        if (bosses == null) {
            return false;
        }

        return bosses.contains(bossName);
    }

    public List<String> getTrackableBosses() {
        if (bossesToTrack != null) {
            return bossesToTrack;
        }
        okHttpClient.newCall(new Request.Builder().url(TRACK_MONSTERS_ENDPOINT).build()).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.debug("Failed to get raid boss list", e);
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                try {
                    if (response.isSuccessful() && response.body() != null) {
                        String json = response.body().string();
                        // Parse as List<String> with proper type safety
                        List<String> parsed = gson.fromJson(json,
                                new com.google.gson.reflect.TypeToken<List<String>>() {
                                }.getType());
                        if (parsed != null) {
                            bossesToTrack = parsed;
                        }
                    }
                } finally {
                    response.close();
                }
            }
        });
        return null;
    }

    /**
     * Clears the cached boss list. Called during cleanup.
     */
    public void clearBossCache() {
        bossesToTrack = null;
    }

    public void uploadCollectionLogUnlock(String item, String player) {
        JsonObject payload = getClogUploadPayload(item, player);
        // log.debug(String.valueOf(payload));

        okHttpClient.newCall(new Request.Builder().url(CLOG_UNLOCK_ENDPOINT)
                .post(RequestBody.create(JSON, payload.toString())).build()).enqueue(new Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        log.debug("Failed to upload new clog slot to Embargo", e);
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                        // Update what we want to track on the fly
                        if (response.isSuccessful()) {
                            log.debug("Successfully uploaded new collection log slot");
                            response.close();
                            return;
                        }

                        response.close();
                    }
                });
    }

    public void uploadRaidCompletion(String raid, String message) {
        if (client == null || client.getLocalPlayer() == null) {
            return;
        }

        JsonObject payload = getRaidCompletionPayload(raid, message);
        okHttpClient.newCall(new Request.Builder().url(PREPARE_RAID_ENDPOINT)
                .post(RequestBody.create(JSON, payload.toString())).build()).enqueue(new Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        log.debug("Failed to upload upload raid completion", e);
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                        if (response.isSuccessful()) {
                            log.debug("Successfully uploaded raid preparation");
                        }

                        response.close();
                    }
                });
    }

    public void uploadMinigameCompletion(String minigameName, String message) {
        if (client == null || client.getLocalPlayer() == null) {
            return;
        }

        JsonObject payload = getMinigamePayload(minigameName, message);
        okHttpClient.newCall(new Request.Builder().url(MINIGAME_COMPLETION_ENDPOINT)
                .post(RequestBody.create(JSON, payload.toString())).build()).enqueue(new Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        log.debug("Failed to upload upload minigame completion", e);
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                        if (response.isSuccessful()) {
                            log.debug("Successfully uploaded minigame preparation");
                        }

                        response.close();
                    }
                });
    }

    private JsonObject getClogUploadPayload(String itemName, String username) {

        JsonObject payload = new JsonObject();
        payload.addProperty("playerName", username);
        payload.addProperty("itemName", itemName);

        return payload;
    }

    @NonNull
    private JsonObject getMinigamePayload(String minigame, String message) {
        var user = client.getLocalPlayer().getName();
        var world = client.getWorld();
        List<Player> players = getSurroundingPlayers();

        // convert List<Player> to JSON
        JsonArray playersJson = new JsonArray();
        for (Player player : players) {
            JsonObject playerJson = new JsonObject();
            playerJson.addProperty("name", player.getName());
            playersJson.add(playerJson);
        }

        JsonObject payload = new JsonObject();
        payload.addProperty("minigame", minigame);
        payload.addProperty("world", world);
        payload.addProperty("message", message);
        payload.addProperty("user", user);
        payload.add("players", playersJson);
        return payload;
    }

    @NonNull
    private JsonObject getRaidCompletionPayload(String raid, String message) {
        var user = client.getLocalPlayer().getName();
        List<Player> players = getSurroundingPlayers();

        // convert List<Player> to JSON
        JsonArray playersJson = new JsonArray();
        for (Player player : players) {
            JsonObject playerJson = new JsonObject();
            playerJson.addProperty("name", player.getName());
            playersJson.add(playerJson);
        }

        JsonObject payload = new JsonObject();
        payload.addProperty("raid", raid);
        payload.addProperty("message", message);
        payload.addProperty("user", user);
        payload.add("players", playersJson);
        return payload;
    }

    public CompletableFuture<JsonObject> getProfileAsync(String username, boolean isMemberInfoCall) {
        String endpoint = isMemberInfoCall
                ? GET_MEMBER_INFO_ENDPOINT + '/' + username
                : GET_PROFILE_ENDPOINT + '/' + username;
        return fetchJsonAsync(endpoint, JsonObject.class, new JsonObject(), false);
    }

    /**
     * Generic helper method to fetch JSON data from an API endpoint asynchronously
     *
     * @param endpoint     The API endpoint URL
     * @param type         The class type to parse the response into (JsonObject.class or JsonArray.class)
     * @param defaultValue The default value to return on failure or empty response
     * @param allowNull    Whether to treat null/empty responses as valid (returns null instead of defaultValue)
     * @param <T>          The type of JSON element (JsonObject or JsonArray)
     * @return CompletableFuture containing the parsed JSON response
     */
    private <T extends JsonElement> CompletableFuture<T> fetchJsonAsync(
            String endpoint, Class<T> type, T defaultValue, boolean allowNull) {
        CompletableFuture<T> future = new CompletableFuture<>();

        Request request = new Request.Builder()
                .url(endpoint)
                .get()
                .build();

        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.debug("Failed to fetch from {}: {}", endpoint, e.getMessage());
                future.complete(allowNull ? null : defaultValue);
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                if (response.isSuccessful()) {
                    BufferedSource source = response.body().source();
                    String json = source.readUtf8();
                    response.close();
                    if (allowNull && (json == null || json.equals("null") || json.isEmpty())) {
                        future.complete(null);
                    } else {
                        future.complete(gson.fromJson(json, type));
                    }
                } else {
                    response.close();
                    future.complete(allowNull ? null : defaultValue);
                }
            }
        });

        return future;
    }

    /**
     * Fetches bounties from the API asynchronously
     *
     * @return CompletableFuture containing the bounties JSON response
     */
    public CompletableFuture<JsonObject> getBountiesAsync() {
        return fetchJsonAsync(BOUNTIES_ENDPOINT, JsonObject.class, new JsonObject(), false);
    }

    /**
     * Fetches events from the API asynchronously
     *
     * @return CompletableFuture containing the events JSON array response
     */
    public CompletableFuture<JsonArray> getEventsAsync() {
        return fetchJsonAsync(EVENTS_ENDPOINT, JsonArray.class, new JsonArray(), false);
    }

    /**
     * Fetches the last active poll from the API asynchronously
     *
     * @return CompletableFuture containing the poll JSON object, or null if no active poll
     */
    public CompletableFuture<JsonObject> getLastPollAsync() {
        return fetchJsonAsync(LAST_POLL_ENDPOINT, JsonObject.class, null, true);
    }

    private final AtomicBoolean apiFailureMode = new AtomicBoolean(false);
    private final AtomicLong lastApiFailure = new AtomicLong(0);
    private static final long API_RETRY_DELAY_MINUTES = 1;

    /**
     * Checks if a user is registered with Embargo asynchronously
     * 
     * @param username The username to check
     * @param callback Callback to handle the result
     */
    public void isUserRegisteredAsync(String username, Consumer<Boolean> callback) {
        if (username == null) {
            callback.accept(false);
            return;
        }

        if (stopTryingForAccount.get()) {
            callback.accept(false);
            return;
        }

        if (isUsernameRegistered.get()) {
            callback.accept(true);
            return;
        }

        log.debug("Checking if {} is registered with Embargo", username);

        // If we're in API failure mode, only retry after the delay period
        long currentTime = Instant.now().getEpochSecond();
        long failureTime = lastApiFailure.get();
        long elapsedMinutes = TimeUnit.SECONDS.toMinutes(currentTime - failureTime);

        if (apiFailureMode.get() && elapsedMinutes < API_RETRY_DELAY_MINUTES) {
            log.debug("apiFailureMode is true, skipping execution for {} minute(s)", API_RETRY_DELAY_MINUTES);
            callback.accept(false);
            return;
        }

        apiFailureMode.set(false);

        try {
            Request request = new Request.Builder()
                    .url(CHECK_REGISTRATION_ENDPOINT + "/" + username)
                    .get()
                    .build();

            okHttpClient.newCall(request).enqueue(new Callback() {
                @Override
                public void onFailure(@NonNull Call call, @NonNull IOException e) {
                    log.error("Failed to check if {} is registered with Embargo's database", username);
                    apiFailureMode.set(true);
                    lastApiFailure.set(Instant.now().getEpochSecond());
                    callback.accept(false);
                }

                @Override
                public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                    try (response) {
                        if (response.isSuccessful()) {
                            String responseBody = response.body().string();
                            JsonObject jsonResponse = gson.fromJson(responseBody, JsonObject.class);
                            if (jsonResponse != null && jsonResponse.has("message")
                                    && "registered".equals(jsonResponse.get("message").getAsString())) {
                                log.debug("{} is registered, return true", username);
                                isUsernameRegistered.set(true);
                                callback.accept(true);
                            } else {
                                log.debug("{} is NOT registered, return false", username);
                                stopTryingForAccount.set(true);
                                callback.accept(false);
                            }
                            apiFailureMode.set(false);

                        } else {
                            String responseBody = response.body().string();
                            JsonObject jsonResponse = gson.fromJson(responseBody, JsonObject.class);
                            if (jsonResponse != null && jsonResponse.has("message")
                                    && "not registered".equals(jsonResponse.get("message").getAsString())) {
                                stopTryingForAccount.set(true);
                                callback.accept(false);
                                return;
                            }
                            log.error("Failed to check if {} is registered with Embargo's database. Status: {}",
                                    username, response.code());
                            apiFailureMode.set(true);
                            lastApiFailure.set(Instant.now().getEpochSecond());
                            callback.accept(false);
                            isUsernameRegistered.set(false);
                        }
                    }
                }
            });
        } catch (Exception e) {
            // Log once and enter failure mode
            if (!apiFailureMode.get()) {
                log.error("Failed to check if user is registered. API may be down. Will retry in {} minutes.",
                        API_RETRY_DELAY_MINUTES, e);
                apiFailureMode.set(true);
                lastApiFailure.set(Instant.now().getEpochSecond());
                isUsernameRegistered.set(false);
            }
            callback.accept(false);
        }
    }

    public void uploadLoot(LootReceived event) {
        JsonObject payload = getJsonObject(event);

        log.debug("Uploading payload: " + payload);

        Request request = new Request.Builder()
                .url(SUBMIT_LOOT_ENDPOINT)
                .post(RequestBody.create(JSON, payload.toString()))
                .build();

        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.error("Error uploading loot", e);
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                if (response.isSuccessful()) {
                    log.debug("Loot uploaded successfully");
                } else {
                    log.error("Loot upload failed with status " + response.code());
                }
                response.close();
            }
        });
    }

    @NonNull
    private JsonObject getJsonObject(LootReceived event) {
        Collection<ItemStack> itemStacks = event.getItems();

        var user = client.getLocalPlayer().getName();
        List<Player> players = getSurroundingPlayers();

        // convert List<Player> to JSON
        JsonArray playersJson = new JsonArray();
        for (Player player : players) {
            JsonObject playerJson = new JsonObject();
            playerJson.addProperty("name", player.getName());
            playersJson.add(playerJson);
        }

        // convert itemStacks to JSON using gson
        JsonArray itemStacksJson = new JsonArray();
        for (ItemStack itemStack : itemStacks) {
            JsonObject itemStackJson = new JsonObject();
            itemStackJson.addProperty("id", itemStack.getId());
            itemStackJson.addProperty("quantity", itemStack.getQuantity());
            itemStackJson.addProperty("price", itemManager.getItemPrice(itemStack.getId()));
            itemStackJson.addProperty("name", itemManager.getItemComposition(itemStack.getId()).getName());

            itemStacksJson.add(itemStackJson);
        }

        // convert json array to String
        String itemStacksJsonString = itemStacksJson.toString();

        // build payload with bossName and itemStacks
        JsonObject payload = new JsonObject();
        payload.addProperty("bossName", event.getName());
        payload.addProperty("user", user);
        payload.addProperty("itemStacks", itemStacksJsonString);
        payload.add("players", playersJson);
        return payload;
    }

    public void storeVarbitChangedIfNotStored(int varbIndex, int varbValue) {
        synchronized (this) {
            if (!varbData.containsKey(varbIndex))
                this.storeVarbitChanged(varbIndex, varbValue);
        }
    }

    public void storeVarpChanged(int varpIndex, int varpValue) {
        synchronized (this) {
            varpData.put(varpIndex, varpValue);
        }
    }

    public void storeVarpChangedIfNotStored(int varpIndex, int varpValue) {
        synchronized (this) {
            if (!varpData.containsKey(varpIndex))
                this.storeVarpChanged(varpIndex, varpValue);
        }
    }

    public void storeSkillChanged(String skill, int skillLevel) {
        synchronized (this) {
            levelData.put(skill, skillLevel);
        }
    }

    public void storeSkillChangedIfNotChanged(String skill, int skillLevel) {
        synchronized (this) {
            if (!levelData.containsKey(skill))
                storeSkillChanged(skill, skillLevel);
        }
    }

    private <K, V> HashMap<K, V> clearChanges(HashMap<K, V> h) {
        HashMap<K, V> temp;
        synchronized (this) {
            if (h.isEmpty()) {
                return new HashMap<>();
            }
            temp = new HashMap<>(h);
            h.clear();
        }
        return temp;
    }

    public void clearData() {
        synchronized (this) {
            varbData.clear();
            varpData.clear();
            levelData.clear();
        }
    }

    private boolean hasDataToPush() {
        return !(varbData.isEmpty() && varpData.isEmpty() && levelData.isEmpty());
    }

    private JsonObject convertToJson() {
        JsonObject j = new JsonObject();
        JsonObject parent = new JsonObject();
        // We need to synchronize this to handle the case where the RuneScapeProfileType
        // changes
        synchronized (this) {
            RuneScapeProfileType r = RuneScapeProfileType.getCurrent(client);
            HashMap<Integer, Integer> tempVarbData = clearChanges(varbData);
            HashMap<Integer, Integer> tempVarpData = clearChanges(varpData);
            HashMap<String, Integer> tempLevelData = clearChanges(levelData);

            j.add("varb", gson.toJsonTree(tempVarbData));
            j.add("varp", gson.toJsonTree(tempVarpData));
            j.add("level", gson.toJsonTree(tempLevelData));

            parent.addProperty("username", client.getLocalPlayer().getName());
            parent.addProperty("profile", r.name());
            parent.addProperty("version", manifestManager.getLastCheckedManifestVersion());
            parent.add("data", j);
        }
        return parent;
    }

    private void restoreData(JsonObject jObj) {
        synchronized (this) {
            if (!jObj.get("profile").getAsString().equals(RuneScapeProfileType.getCurrent(client).name())) {
                log.error("Not restoring data from failed call since the profile type has changed");
                return;
            }
            JsonObject dataObj = jObj.getAsJsonObject("data");
            JsonObject varbObj = dataObj.getAsJsonObject("varb");
            JsonObject varpObj = dataObj.getAsJsonObject("varp");
            JsonObject levelObj = dataObj.getAsJsonObject("level");
            for (String k : varbObj.keySet()) {
                this.storeVarbitChangedIfNotStored(Integer.parseInt(k), varbObj.get(k).getAsInt());
            }
            for (String k : varpObj.keySet()) {
                this.storeVarpChangedIfNotStored(Integer.parseInt(k), varpObj.get(k).getAsInt());
            }
            for (String k : levelObj.keySet()) {
                this.storeSkillChangedIfNotChanged(k, levelObj.get(k).getAsInt());
            }
        }
    }

    protected void submitToAPI() {
        if (!hasDataToPush() || client.getLocalPlayer() == null || client.getLocalPlayer().getName() == null
                || stopTryingForAccount.get())
            return;

        if (RuneScapeProfileType.getCurrent(client) != RuneScapeProfileType.STANDARD)
            return;

        isUserRegisteredAsync(client.getLocalPlayer().getName(), isRegistered -> {
            if (!isRegistered) {
                return;
            }

            if (client.getGameState() == GameState.LOGIN_SCREEN || client.getGameState() == GameState.HOPPING) {
                return;
            }

            try {
                JsonObject payload = convertToJson();

                okHttpClient.newCall(new Request.Builder().url(UNTRACKABLE_POST_ENDPOINT)
                        .post(RequestBody.create(JSON, payload.toString())).build()).enqueue(new Callback() {
                            @Override
                            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                                log.error(e.getLocalizedMessage());
                                restoreData(payload);
                                log.error("Failed to submit player in submitToAPI, restoring data. Cause of failure:",
                                        e);
                            }

                            @Override
                            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                                if (response.isSuccessful()) {
                                    log.debug("Successfully uploaded untrackable items");
                                    response.close();
                                    return;
                                } else {
                                    response.close();
                                    log.error("submitToAPI onResponse returned, but without success");
                                }

                                response.close();
                            }
                        });
            } catch (Exception e) {
                log.error("Error preparing data for API submission", e);
            }
        });
    }

    private HashSet<Integer> parseSet(JsonArray j) {
        HashSet<Integer> h = new HashSet<>();
        for (JsonElement jObj : j) {
            h.add(jObj.getAsInt());
        }
        return h;
    }

    public void loadInitialData() {
        manifestManager.getLatestManifest();

        for (int varbIndex : varbitsToCheck) {
            storeVarbitChanged(varbIndex, client.getVarbitValue(varbIndex));
        }

        for (int varpIndex : varpsToCheck) {
            storeVarpChanged(varpIndex, client.getVarpValue(varpIndex));
        }
        for (Skill s : Skill.values()) {
            storeSkillChanged(s.getName(), client.getRealSkillLevel(s));
        }
    }

    // NEEDS TO BE MODIFIED TO USE NEW MANIFEST OBJECT STUFF
    protected void getManifest() {
        // log.debug("Getting manifest file...");
        try {
            Request r = new Request.Builder()
                    .url(MANIFEST_ENDPOINT)
                    .build();
            okHttpClient.newCall(r).enqueue(new Callback() {
                @Override
                public void onFailure(@NonNull Call call, @NonNull IOException e) {
                    log.error("Error retrieving manifest", e);
                }

                @Override
                public void onResponse(@NonNull Call call, @NonNull Response response) {
                    if (response.isSuccessful()) {
                        try {
                            // We want to be able to change the varbs and varps we get on the fly. To do so,
                            // we tell
                            // the client what to send the server on startup via the manifest.
                            if (response.body() == null) {
                                log.error("Manifest request succeeded but returned empty body");
                                response.close();
                            }

                            JsonObject j = gson.fromJson(response.body().string(), JsonObject.class);
                            try {
                                setVarbitsToCheck(parseSet(j.getAsJsonArray("varbits")));
                                setVarpsToCheck(parseSet(j.getAsJsonArray("varps")));
                                try {
                                    int manifestVersion = j.get("version").getAsInt();
                                    if (getLastManifestVersion() != manifestVersion) {
                                        setLastManifestVersion(manifestVersion);
                                        clientThread.invoke(() -> loadInitialData());
                                    }
                                } catch (UnsupportedOperationException | NullPointerException exception) {
                                    setLastManifestVersion(-1);
                                }
                            } catch (NullPointerException e) {
                                log.error("Manifest possibly missing varbits or varps entry from /manifest call");
                                log.error(e.getLocalizedMessage());
                            } catch (ClassCastException e) {
                                log.error("Manifest from /manifest call might have varbits or varps as not a list");
                                log.error(e.getLocalizedMessage());
                            }
                        } catch (IOException | JsonSyntaxException e) {
                            log.error(e.getLocalizedMessage());
                        } finally {
                            response.close();
                        }
                    } else {
                        log.error("Manifest request returned with status " + response.code());
                        if (response.body() == null) {
                            log.error("Manifest request returned empty body");
                        } else {
                            log.error(response.body().toString());
                        }
                    }
                    response.close();
                }
            });
        } catch (IllegalArgumentException e) {
            log.error("Bad URL given: " + e.getLocalizedMessage());
        }
    }

    // NEEDS TO BE MODIFIED TO USE NEW MANIFEST OBJECT STUFF
    protected int getVersion() {
        // log.debug("Attempting to get manifest version...");
        Request request = new Request.Builder()
                .url(MANIFEST_ENDPOINT)
                .build();

        try {
            okHttpClient.newCall(request).enqueue(new Callback() {
                @Override
                public void onFailure(@NonNull Call call, IOException e) {
                    log.error("Error retrieving manifest", e);
                }

                @Override
                public void onResponse(@NonNull Call call, Response response) throws IOException {
                    if (response.isSuccessful()) {
                        try {
                            // We want to be able to change the varbs and varps we get on the fly. To do so,
                            // we tell
                            // the client what to send the server on startup via the manifest.
                            if (response.body() == null) {
                                log.error("Manifest request succeeded but returned empty body");
                                response.close();
                            }

                            JsonObject j = gson.fromJson(response.body().string(), JsonObject.class);

                            try {
                                try {
                                    int manifestVersion = j.get("version").getAsInt();
                                    if (manifestManager.getLatestManifest().getVersion() != manifestVersion) {
                                        // update to use new manifest stuff
                                        clientThread.invoke(() -> loadInitialData());
                                    }
                                } catch (UnsupportedOperationException | NullPointerException exception) {
                                    setLastManifestVersion(-1);
                                }
                            } catch (NullPointerException | ClassCastException e) {
                                log.error(e.getLocalizedMessage());
                            }
                        } catch (IOException | JsonSyntaxException e) {
                            log.error(e.getLocalizedMessage());
                        } finally {
                            response.close();
                        }
                    } else {
                        log.error("Manifest request returned with status " + response.code());
                        if (response.body() == null) {
                            log.error("Manifest request returned empty body");
                        } else {
                            log.error(response.body().toString());
                        }
                    }
                    response.close();
                }
            });
        } catch (IllegalArgumentException e) {
            log.error("asd");
        }
        return -1;
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged varbitChanged) {
        if (client == null || varbitsToCheck == null || varpsToCheck == null)
            return;
        if (oldVarps == null)
            setupVarpTracking();

        int varpIndexChanged = varbitChanged.getVarpId();
        if (varpsToCheck.contains(varpIndexChanged)) {
            storeVarpChanged(varpIndexChanged, client.getVarpValue(varpIndexChanged));
        }
        for (Integer i : varpToVarbitMapping.get(varpIndexChanged)) {
            if (!varbitsToCheck.contains(i))
                continue;
            // For each varbit index, see if it changed.
            int oldValue = client.getVarbitValue(oldVarps, i);
            int newValue = client.getVarbitValue(i);
            if (oldValue != newValue)
                storeVarbitChanged(i, newValue);
        }
        oldVarps[varpIndexChanged] = client.getVarpValue(varpIndexChanged);
    }

    // Need to keep track of old varps and what varps each varb is in.
    // On change
    // Get varp, if varp in hashset, queue it.
    // Get each varb index in varp. If varb changed and varb in hashset, queue it.
    // Checking if varb has changed requires us to keep track of old varps
    private void setupVarpTracking() {
        final int VARBITS_ARCHIVE_ID = 14;
        // Init stuff to keep track of varb changes
        varpToVarbitMapping.clear();

        if (oldVarps == null) {
            oldVarps = new int[client.getVarps().length];
        }

        // Set oldVarps to be the current varps
        System.arraycopy(client.getVarps(), 0, oldVarps, 0, oldVarps.length);

        // For all varbits, add their ids to the multimap with the varp index as their
        // key
        clientThread.invoke(() -> {
            if (client.getIndexConfig() == null) {
                return false;
            }
            IndexDataBase indexVarbits = client.getIndexConfig();
            final int[] varbitIds = indexVarbits.getFileIds(VARBITS_ARCHIVE_ID);
            for (int id : varbitIds) {
                VarbitComposition varbit = client.getVarbit(id);
                if (varbit != null) {
                    varpToVarbitMapping.put(varbit.getIndex(), id);
                }
            }
            return true;
        });
    }

    @Schedule(period = 5 * 60, unit = ChronoUnit.SECONDS, asynchronous = true)
    public void resyncManifest() {
        // log.debug("Attempting to resync manifest");
        if (manifestManager.getManifest().getVersion() != getLastManifestVersion()) {
            getManifest();
        }
    }

    @Schedule(period = 10, unit = ChronoUnit.SECONDS, asynchronous = true)
    public void scheduledSubmit() {
        if (stopTryingForAccount.get()) {
            return;
        }
        if (client != null
                && (client.getGameState() != GameState.HOPPING && client.getGameState() != GameState.LOGIN_SCREEN)) {
            submitToAPI();
            if (client.getLocalPlayer() != null) {
                String username = client.getLocalPlayer().getName();

                isUserRegisteredAsync(username, isRegistered -> {
                    if (isRegistered) {
                        embargoPanel.updateLoggedIn(true);
                    } else {
                        embargoPanel.isLoggedIn = false;
                        embargoPanel.updateLoggedIn(false);
                        embargoPanel.logOut();
                    }
                });
            }
        } else {
            // log.debug("User is hopping or logged out, do not send data");
            embargoPanel.isLoggedIn = false;
            embargoPanel.updateLoggedIn(false);
            embargoPanel.logOut();
        }
    }

}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Thanks to RuneProfile (https://github.com/ReinhardtR/runeprofile-plugin) for Hamburger Button logic
 */

package gg.embargo.ui;

import com.google.inject.Inject;
import gg.embargo.EmbargoConfig;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.*;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import java.util.*;

import static java.lang.Math.round;

@Slf4j
public class SyncButtonManager {

    private static final int DRAW_BURGER_MENU = 7812;
    private static final int FONT_COLOR = 0xFF981F;
    private static final int FONT_COLOR_ACTIVE = 0xFFFFFF;
    private static final String BUTTON_TEXT = "Embargo";
    private static final int COOLDOWN_TICKS = 50; // ~30 seconds

    private final Client client;
    private final EventBus eventBus;
    private final EmbargoConfig config;

    private int baseMenuHeight = -1;
    private int lastAttemptedSync = -1;

    @Getter
    @Setter
    private boolean syncAllowed;

    @Inject
    private SyncButtonManager(
            Client client,
            EventBus eventBus,
            EmbargoConfig config) {
        this.client = client;
        this.eventBus = eventBus;
        this.config = config;
    }

    public void startUp() {
        setSyncAllowed(false);
        eventBus.register(this);
    }

    public void shutDown() {
        eventBus.unregister(this);
    }

    @Subscribe
    public void onScriptPreFired(ScriptPreFired event) {
        if (!config.showCollectionLogSyncButton() || event.getScriptId() != DRAW_BURGER_MENU) {
            return;
        }

        Object[] args = event.getScriptEvent().getArguments();
        int menuId = (int) args[3];

        try {
            log.debug("Adding Embargo button to burger menu with ID: {}", menuId);
            addButton(menuId, this::onButtonClick);
        } catch (Exception e) {
            log.debug("Failed to add Embargo button to menu: {}", e.getMessage());
        }
    }

    private void onButtonClick() {
        // Check cooldown
        if (lastAttemptedSync != -1 && lastAttemptedSync + COOLDOWN_TICKS > client.getTickCount()) {
            int ticksRemaining = lastAttemptedSync + COOLDOWN_TICKS - client.getTickCount();
            int secondsRemaining = (int) round(ticksRemaining * 0.6);
            client.addChatMessage(
                    ChatMessageType.GAMEMESSAGE,
                    "",
                    "<col=ff9000>[Embargo]</col> Sync on cooldown. Try again in " + secondsRemaining + " seconds.",
                    null);
            return;
        }
        lastAttemptedSync = client.getTickCount();

        // Set sync allowed flag and trigger search to iterate collection log
        setSyncAllowed(true);
        client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
        client.runScript(2240);

        client.addChatMessage(
                ChatMessageType.GAMEMESSAGE,
                "",
                "<col=ff9000>[Embargo]</col> Syncing your collection log...",
                null);
    }

    private void addButton(int menuId, Runnable onClick) throws NullPointerException, NoSuchElementException {
        // Disallow syncing from the adventure log to prevent players from syncing
        // while viewing other players' collection logs via the POH adventure log
        boolean isOpenedFromAdventureLog = client.getVarbitValue(VarbitID.COLLECTION_POH_HOST_BOOK_OPEN) == 1;
        if (isOpenedFromAdventureLog) {
            return;
        }

        Widget menu = Objects.requireNonNull(client.getWidget(menuId));
        Widget[] menuChildren = Objects.requireNonNull(menu.getChildren());

        if (baseMenuHeight == -1) {
            baseMenuHeight = menu.getOriginalHeight();
        }

        // Find the last rectangle and text widgets to copy their styling
        List<Widget> reversedMenuChildren = new ArrayList<>(Arrays.asList(menuChildren));
        Collections.reverse(reversedMenuChildren);

        Widget lastRectangle = reversedMenuChildren.stream()
                .filter(w -> w.getType() == WidgetType.RECTANGLE)
                .findFirst()
                .orElseThrow(() -> new NoSuchElementException("No RECTANGLE widget found in menu"));

        Widget lastText = reversedMenuChildren.stream()
                .filter(w -> w.getType() == WidgetType.TEXT)
                .findFirst()
                .orElseThrow(() -> new NoSuchElementException("No TEXT widget found in menu"));

        final int buttonHeight = lastRectangle.getHeight();
        final int buttonY = lastRectangle.getOriginalY() + buttonHeight;

        // Check if button already exists
        final boolean existingButton = Arrays.stream(menuChildren)
                .anyMatch(w -> w.getText().equals(BUTTON_TEXT));

        if (!existingButton) {
            // Create background rectangle matching the existing menu style
            final Widget background = menu.createChild(WidgetType.RECTANGLE)
                    .setOriginalWidth(lastRectangle.getOriginalWidth())
                    .setOriginalHeight(lastRectangle.getOriginalHeight())
                    .setOriginalX(lastRectangle.getOriginalX())
                    .setOriginalY(buttonY)
                    .setOpacity(lastRectangle.getOpacity())
                    .setFilled(lastRectangle.isFilled());
            background.revalidate();

            // Create text widget with hover effects
            final Widget text = menu.createChild(WidgetType.TEXT)
                    .setText(BUTTON_TEXT)
                    .setTextColor(FONT_COLOR)
                    .setFontId(lastText.getFontId())
                    .setTextShadowed(lastText.getTextShadowed())
                    .setOriginalWidth(lastText.getOriginalWidth())
                    .setOriginalHeight(lastText.getOriginalHeight())
                    .setOriginalX(lastText.getOriginalX())
                    .setOriginalY(buttonY)
                    .setXTextAlignment(lastText.getXTextAlignment())
                    .setYTextAlignment(lastText.getYTextAlignment());

            text.setHasListener(true);
            text.setOnMouseOverListener((JavaScriptCallback) ev -> text.setTextColor(FONT_COLOR_ACTIVE));
            text.setOnMouseLeaveListener((JavaScriptCallback) ev -> text.setTextColor(FONT_COLOR));
            text.setAction(0, "Sync your collection log with Embargo");
            text.setOnOpListener((JavaScriptCallback) ev -> onClick.run());
            text.revalidate();
        }

        // Expand the menu height to accommodate the new button
        if (menu.getOriginalHeight() <= baseMenuHeight) {
            menu.setOriginalHeight(menu.getOriginalHeight() + buttonHeight);
        }

        menu.revalidate();
        for (Widget child : menuChildren) {
            child.revalidate();
        }
    }
}

package gg.embargo.ui;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.http.api.item.ItemPrice;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

@Slf4j
public class MissingRequirementsPanel extends PluginPanel {
    private static final String OSRS_WIKI_BASE_URL = "https://oldschool.runescape.wiki/w/";
    private static final int ITEMS_PER_ROW = 5;
    private static final int CELL_SIZE = 32;
    private static final int TOOLTIP_PADDING = 3;
    private static final Color HOVER_COLOR = ColorScheme.DARKER_GRAY_HOVER_COLOR;
    private static final Color NORMAL_COLOR = ColorScheme.DARKER_GRAY_COLOR;

    // Cache for item icons to avoid recreating them - bounded LRU cache to prevent memory bloat
    private static final int MAX_ICON_CACHE_SIZE = 100;
    private static final int MAX_LETTER_ICON_CACHE_SIZE = 50;
    private final Map<Integer, BufferedImage> iconCache = Collections.synchronizedMap(
            new LinkedHashMap<Integer, BufferedImage>(MAX_ICON_CACHE_SIZE, 0.75f, true) {
                @Override
                protected boolean removeEldestEntry(Map.Entry<Integer, BufferedImage> eldest) {
                    return size() > MAX_ICON_CACHE_SIZE;
                }
            });
    private final Map<String, BufferedImage> letterIconCache = Collections.synchronizedMap(
            new LinkedHashMap<String, BufferedImage>(MAX_LETTER_ICON_CACHE_SIZE, 0.75f, true) {
                @Override
                protected boolean removeEldestEntry(Map.Entry<String, BufferedImage> eldest) {
                    return size() > MAX_LETTER_ICON_CACHE_SIZE;
                }
            });

    // Cache for item name -> item ID lookups to avoid repeated itemManager.search() calls
    private final Map<String, Integer> itemIdCache = new ConcurrentHashMap<>();

    // Use AtomicBoolean to properly track update state across threads
    private final AtomicBoolean isUpdating = new AtomicBoolean(false);

    // Flag to support batched updates - when true, updatePanel() is deferred
    private volatile boolean batchingUpdates = false;

    // Track scheduled futures for cleanup to prevent memory leaks
    private final List<ScheduledFuture<?>> scheduledFutures = Collections.synchronizedList(new ArrayList<>());

    private final ItemManager itemManager;
    private final ScheduledExecutorService executorService;
    private final JPanel itemsContainer;
    private final List<MissingItem> missingItems = new ArrayList<>();
    private final MouseAdapter itemMouseAdapter = createMouseAdapter();
    private final Object lock = new Object();

    private static final BufferedImage EHB_ICON = ImageUtil.loadImageResource(MissingRequirementsPanel.class,
            "/ehb_icon.png");
    private static final BufferedImage COMMUNITY_POINTS_ICON = ImageUtil.resizeImage(
            ImageUtil.loadImageResource(MissingRequirementsPanel.class, "/community_points_icon.png"), 24, 24);
    private static final BufferedImage ACCOUNT_POINTS_ICON =
            ImageUtil.loadImageResource(MissingRequirementsPanel.class,  "/account_points_icon.png");
    private static final BufferedImage OVERALL_ICON = ImageUtil.loadImageResource(MissingRequirementsPanel.class,
            "/overall_icon.png");

    @Getter
    public enum DynamicItems {
        ACCOUNT_POINTS("account points"),
        EHB("EHB"),
        COMMUNITY_POINTS("community points"),
        TOTAL_LEVEL("total level");

        private final String label;

        DynamicItems(String label) {
            this.label = label;
        }
    }

    @Inject
    public MissingRequirementsPanel(ItemManager itemManager, ScheduledExecutorService executorService) {
        super(false);
        this.itemManager = itemManager;
        this.executorService = executorService;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(new EmptyBorder(5, 0, 5, 0));

        // Create subtitle panel with instructions
        JPanel subtitlePanel = new JPanel(new BorderLayout());
        subtitlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        subtitlePanel.setBorder(new EmptyBorder(0, 0, 8, 0));

        JLabel subtitle = new JLabel("Hover for details, click to open wiki");
        subtitle.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        subtitle.setFont(new Font("SansSerif", Font.BOLD, 10));
        subtitlePanel.add(subtitle, BorderLayout.WEST);

        add(subtitlePanel, BorderLayout.NORTH);

        // Create items container with increased gap for better spacing
        itemsContainer = new JPanel();
        itemsContainer.setLayout(new GridLayout(0, ITEMS_PER_ROW, 4, 4));
        itemsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JScrollPane scrollPane = new JScrollPane(itemsContainer);
        scrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        scrollPane.setBorder(null);
        scrollPane.getViewport().setBackground(ColorScheme.DARKER_GRAY_COLOR);
        add(scrollPane, BorderLayout.CENTER);
    }

    /**
     * Adds a missing item to the panel if it doesn't already exist
     * 
     * @param itemName The name of the item
     * @param itemId   The item ID in RuneScape
     */
    public void addMissingItem(String itemName, int itemId) {
        synchronized (lock) {
            // Clean up the item name
            String cleanedName = itemName.replace("\"", "").replace(" (uncharged)", "");

            // Handle case where itemName is empty but we have an itemId
            if (itemName.isEmpty() && itemId != -1) {
                ItemComposition ic = itemManager.getItemComposition(itemId);
                String itemNameFromId = ic.getName();

                // Check if this item already exists in our list
                if (missingItems.stream().anyMatch(item -> Objects.equals(item.getItemName(), itemNameFromId))) {
                    log.debug("Item {} already exists, skipping", itemNameFromId);
                    return;
                }

                // Add the item with name from ItemComposition
                BufferedImage itemIcon = getItemIcon(itemId, itemNameFromId);
                log.debug("Adding untrackable item: {}", itemNameFromId);
                missingItems.add(new MissingItem(itemNameFromId, itemId, itemIcon));
                updatePanel();
                return;
            }

            // Check if this is a dynamic item that already exists by type, not exact name
            boolean isDynamicItem = false;
            EnumSet<DynamicItems> dynamicItemsSet = EnumSet.of(
                    DynamicItems.ACCOUNT_POINTS,
                    DynamicItems.EHB,
                    DynamicItems.TOTAL_LEVEL,
                    DynamicItems.COMMUNITY_POINTS);

            for (DynamicItems dynamicItem : dynamicItemsSet) {
                if (cleanedName.contains(dynamicItem.getLabel())) {
                    isDynamicItem = true;
                    // Use getSpecialIcon for dynamic items
                    BufferedImage specialIcon = getSpecialIcon(cleanedName);
                    boolean didRefreshItem;
                    if (specialIcon != null) {
                        // Remove any existing dynamic item of this type and add with special icon
                        missingItems.removeIf(item -> item.getItemName().contains(dynamicItem.getLabel()));
                        missingItems.add(new MissingItem(cleanedName, -1, specialIcon));
                        log.debug("Added new dynamic item with special icon: {}", cleanedName);
                        updatePanel();
                        didRefreshItem = true;
                    } else {
                        didRefreshItem = refreshDynamicItems(itemName, dynamicItemsSet);
                    }
                    if (didRefreshItem) {
                        return; // Successfully refreshed the dynamic item
                    }
                    break;
                }
            }

            // If not a dynamic item, check for exact match as before
            if (!isDynamicItem && !cleanedName.isEmpty() && missingItems.stream()
                    .anyMatch(item -> Objects.equals(item.getItemName(), cleanedName))) {
                log.debug("Item {} already exists, returning", cleanedName);
                return;
            }

            // Handle special cases for specific items
            int finalItemId = itemId;
            if (cleanedName.toLowerCase().contains("quiver")) {
                finalItemId = 28947;
            } else if (cleanedName.toLowerCase().contains("infernal cape")) {
                finalItemId = 21295;
            }

            // Process the item and add it to the panel
            BufferedImage itemIcon;
            if (itemName.contains("Combat Achievement")) {
                finalItemId = getHiltIdFromName(itemName);
                itemIcon = getHiltImageFromName(itemName.split(" ")[0]);
            } else {
                itemIcon = getItemIcon(finalItemId, cleanedName);
            }
            missingItems.add(new MissingItem(cleanedName, finalItemId, itemIcon));
            log.debug("Added new item to panel: {}", cleanedName);
            updatePanel();
        }
    }

    public boolean refreshDynamicItems(String itemName, EnumSet<DynamicItems> dynamicItemsEnumSet) {
        synchronized (lock) {
            String cleanedItemName = itemName.replaceAll("^\"|\"$", "");
            boolean itemRemoved = false;

            // First, remove any existing items that match the dynamic type
            Iterator<MissingItem> iterator = missingItems.iterator();
            while (iterator.hasNext()) {
                MissingItem item = iterator.next();

                // Check if this existing item matches any of our dynamic types
                for (DynamicItems dynamicItem : dynamicItemsEnumSet) {
                    if (item.itemName.contains(dynamicItem.getLabel()) &&
                            cleanedItemName.contains(dynamicItem.getLabel())) {
                        // Found a match - remove the old item
                        iterator.remove();
                        itemRemoved = true;
                        log.debug("Removed dynamic item {} to be replaced with {}",
                                item.itemName, cleanedItemName);
                        break;
                    }
                }
            }

            // Now add the new item if we removed an old one
            if (itemRemoved) {
                // Add the new item with updated value
                missingItems.add(new MissingItem(cleanedItemName, -1,
                        getItemIcon(-1, cleanedItemName)));
                log.debug("Added new dynamic item: {}", cleanedItemName);
                updatePanel(); // Make sure to update the panel to reflect changes
                return true;
            } else {
                return false;
            }
        }
    }

    @Getter
    public enum AchievementHilts {
        EASY(25926),
        MEDIUM(25928),
        HARD(25930),
        ELITE(25932),
        MASTER(25934),
        GRANDMASTER(25936);

        private final int itemId;

        AchievementHilts(int itemId) {
            this.itemId = itemId;
        }
    }

    public BufferedImage getHiltImageFromName(String name) {
        String lowercaseName = name.toLowerCase();
        // Strip out extra "'s
        lowercaseName = lowercaseName.replace("\"", "");

        for (AchievementHilts hilt : AchievementHilts.values()) {
            // Shortcut to bypass conflicting name with "Master" being in "Grandmaster"
            if (lowercaseName.contains("grand")) {
                return getItemIcon(AchievementHilts.GRANDMASTER.getItemId(), "Ghommal's_avernic_defender_6");
            }

            if (lowercaseName.contains(hilt.name().toLowerCase())) {
                return getItemIcon(hilt.getItemId(), "Ghommal's_avernic_defender_" + (hilt.ordinal() + 1));
            }
        }
        return getItemIcon(882, "Bronze arrow");
    }

    public int getHiltIdFromName(String name) {
        String lowercaseName = name.toLowerCase();

        // Special case for Grandmaster since conflicting master in name
        if (lowercaseName.contains("grand")) {
            return AchievementHilts.GRANDMASTER.getItemId();
        }

        // Check for other hilt types
        for (AchievementHilts hilt : AchievementHilts.values()) {
            if (lowercaseName.contains(hilt.name().toLowerCase())) {
                return hilt.getItemId();
            }
        }

        return 882;
    }

    /**
     * Clears all missing items from the panel
     */
    public void clearItems() {
        synchronized (lock) {
            cancelAllScheduledFutures();
            if (!missingItems.isEmpty()) {
                missingItems.clear();
                updatePanel();
            }
        }
    }

    /**
     * Cancels all scheduled futures to prevent memory leaks.
     * Must be called before recreating panels or during cleanup.
     */
    private void cancelAllScheduledFutures() {
        synchronized (scheduledFutures) {
            for (ScheduledFuture<?> future : scheduledFutures) {
                future.cancel(true);
            }
            scheduledFutures.clear();
        }
    }

    /**
     * Cleanup method to be called when the plugin is shutting down.
     * Cancels all scheduled futures and clears caches to prevent memory leaks.
     */
    public void shutdown() {
        synchronized (lock) {
            cancelAllScheduledFutures();
            missingItems.clear();
            iconCache.clear();
            letterIconCache.clear();
            itemIdCache.clear();
            itemsContainer.removeAll();
        }
    }

    /**
     * Begins a batch update session. While batching is active, individual
     * addMissingItem/addDynamicMissingItem calls will not trigger panel rebuilds.
     * Call {@link #endBatchUpdate()} when done adding items to trigger a single rebuild.
     */
    public void beginBatchUpdate() {
        synchronized (lock) {
            batchingUpdates = true;
        }
    }

    /**
     * Ends a batch update session and triggers a single panel rebuild.
     * This should be called after all items have been added via addMissingItem/addDynamicMissingItem.
     */
    public void endBatchUpdate() {
        synchronized (lock) {
            batchingUpdates = false;
            updatePanel();
        }
    }

    /**
     * Updates the panel with the current list of missing items.
     * Uses AtomicBoolean to properly track update state across threads.
     */
    private void updatePanel() {
        // Skip updates if we're in batching mode
        if (batchingUpdates) {
            return;
        }

        // Use compareAndSet for thread-safe check-and-set
        if (!isUpdating.compareAndSet(false, true)) {
            return; // Another update is already in progress
        }

        SwingUtilities.invokeLater(() -> {
            try {
                synchronized (lock) {
                    // Cancel existing scheduled futures before rebuilding panels to prevent leaks
                    cancelAllScheduledFutures();
                    itemsContainer.removeAll();
                    for (MissingItem item : missingItems) {
                        JPanel itemPanel = createItemPanel(item);
                        itemsContainer.add(itemPanel);
                    }
                    revalidate();
                    repaint();
                }
            } finally {
                // Reset the flag AFTER the work is done, inside the SwingUtilities.invokeLater
                isUpdating.set(false);
            }
        });
    }

    /**
     * Creates a panel for a single item with icon and hover/click functionality
     */
    private JPanel createItemPanel(MissingItem item) {
        if (item instanceof DynamicMissingItem) {
            DynamicMissingItem dyn = (DynamicMissingItem) item;
            JPanel dynamicPanel = createBaseItemPanel();

            JLabel iconLabel = new JLabel();
            iconLabel.setHorizontalAlignment(SwingConstants.CENTER);
            iconLabel.setIcon(getIconForItemId(dyn.itemIds[0]));
            iconLabel.setToolTipText(buildTooltipText(new MissingItem(dyn.names[0], dyn.itemIds[0], dyn.icons.get(0))));
            dynamicPanel.add(iconLabel, BorderLayout.CENTER);

            // Track the current index for click events
            final AtomicInteger currentIdx = new AtomicInteger(0);

            ScheduledFuture<?> future = executorService.scheduleAtFixedRate(() -> {
                SwingUtilities.invokeLater(() -> {
                    int idx = currentIdx.updateAndGet(i -> (i + 1) % dyn.names.length);
                    iconLabel.setIcon(new ImageIcon(dyn.icons.get(idx)));
                    String tooltip = buildTooltipText(
                            new MissingItem(dyn.names[idx], dyn.itemIds[idx], dyn.icons.get(idx)));
                    iconLabel.setToolTipText(tooltip);
                    dynamicPanel.setToolTipText(tooltip);
                    dynamicPanel.revalidate();
                    dynamicPanel.repaint();
                });
            }, dyn.intervalMs, dyn.intervalMs, TimeUnit.MILLISECONDS);

            // Track future for cleanup when panel is rebuilt or cleared
            scheduledFutures.add(future);

            MouseAdapter hoverAndClick = new MouseAdapter() {
                @Override
                public void mouseEntered(MouseEvent e) {
                    dynamicPanel.setBackground(HOVER_COLOR);
                    dynamicPanel.setCursor(new Cursor(Cursor.HAND_CURSOR));
                }

                @Override
                public void mouseExited(MouseEvent e) {
                    dynamicPanel.setBackground(NORMAL_COLOR);
                    dynamicPanel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
                }

                @Override
                public void mouseClicked(MouseEvent e) {
                    int idx = currentIdx.get();
                    int itemId = dyn.itemIds[idx];
                    String itemName = dyn.names[idx];
                    if (itemId == -1) {
                        return;
                    }
                    String wikiUrl = OSRS_WIKI_BASE_URL + itemName.replace(" ", "_");
                    LinkBrowser.browse(wikiUrl);
                }
            };

            // Attach to both panel and label
            dynamicPanel.addMouseListener(hoverAndClick);
            iconLabel.addMouseListener(hoverAndClick);

            return dynamicPanel;
        }

        JPanel panel = createBaseItemPanel();

        JLabel iconLabel = new JLabel(new ImageIcon(item.getIcon()));
        iconLabel.setHorizontalAlignment(SwingConstants.CENTER);
        panel.add(iconLabel, BorderLayout.CENTER);
        panel.setToolTipText(buildTooltipText(item));

        // Add hover effect and click handler to the panel
        panel.addMouseListener(itemMouseAdapter);

        return panel;
    }

    private JPanel createBaseItemPanel() {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBackground(NORMAL_COLOR);
        panel.setBorder(new LineBorder(Color.BLACK, 1));
        panel.setPreferredSize(new Dimension(CELL_SIZE, CELL_SIZE));
        panel.setMinimumSize(new Dimension(CELL_SIZE, CELL_SIZE));
        panel.setMaximumSize(new Dimension(CELL_SIZE, CELL_SIZE));
        return panel;
    }

    private MouseAdapter createMouseAdapter() {
        return new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                JPanel panel = (JPanel) e.getSource();
                panel.setBackground(HOVER_COLOR);
                panel.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                JPanel panel = (JPanel) e.getSource();
                panel.setBackground(NORMAL_COLOR);
                panel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            }

            @Override
            public void mouseClicked(MouseEvent e) {
                JPanel panel = (JPanel) e.getSource();
                Component[] components = itemsContainer.getComponents();
                int index = -1;

                for (int i = 0; i < components.length; i++) {
                    if (components[i] == panel) {
                        index = i;
                        break;
                    }
                }

                if (index >= 0 && index < missingItems.size()) {
                    MissingItem item = missingItems.get(index);
                    if (item.getItemId() == -1) {
                        return;
                    }
                    String wikiUrl = OSRS_WIKI_BASE_URL + item.getItemName().replace(" ", "_");
                    LinkBrowser.browse(wikiUrl);
                }
            }
        };
    }

    /**
     * Gets the item icon from the ItemManager or a default icon if not found
     */
    private BufferedImage getItemIcon(int itemId, String itemName) {
        // Check cache first
        if (itemId != -1) {
            BufferedImage cachedIcon = iconCache.get(itemId);
            if (cachedIcon != null) {
                return cachedIcon;
            }

            BufferedImage icon = itemManager.getImage(itemId);
            BufferedImage resizedIcon = ImageUtil.resizeImage(icon, CELL_SIZE, CELL_SIZE);
            iconCache.put(itemId, resizedIcon);
            return resizedIcon;
        } else {
            // For letter-based icons, create a cache key
            String letter = getLetterForItem(itemName);
            String cacheKey = letter + "_" + CELL_SIZE;

            BufferedImage cachedIcon = letterIconCache.get(cacheKey);
            if (cachedIcon != null) {
                return cachedIcon;
            }

            BufferedImage icon = createLetterIcon(letter);
            letterIconCache.put(cacheKey, icon);
            return icon;
        }
    }

    private String getLetterForItem(String itemName) {
        if (itemName.contains("community")) {
            return "CP";
        } else if (itemName.contains("account")) {
            return "AP";
        } else if (itemName.contains("EHB")) {
            return "EHB";
        } else if (itemName.contains("EHP")) {
            return "EHP";
        }
        return itemName.substring(0, 1).toUpperCase();
    }

    private BufferedImage createLetterIcon(String letter) {
        BufferedImage icon = new BufferedImage(CELL_SIZE, CELL_SIZE, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = icon.createGraphics();

        // Fill the entire image with the background color
        g2d.setColor(ColorScheme.MEDIUM_GRAY_COLOR);
        g2d.fillRect(0, 0, CELL_SIZE, CELL_SIZE);
        g2d.setColor(Color.WHITE);

        // Calculate appropriate font size based on text length
        int fontSize = 16; // Default font size
        if (letter.length() > 1) {
            // Reduce font size for longer text
            fontSize = Math.max(8, 16 - (letter.length() - 1) * 2);
        }

        g2d.setFont(new Font("SansSerif", Font.BOLD, fontSize));

        // Ensure text fits within the cell
        FontMetrics fm = g2d.getFontMetrics();
        while (fm.stringWidth(letter) > CELL_SIZE - 2 && fontSize > 8) {
            fontSize--;
            g2d.setFont(new Font("SansSerif", Font.BOLD, fontSize));
            fm = g2d.getFontMetrics();
        }

        int x = (CELL_SIZE - fm.stringWidth(letter)) / 2;
        int y = ((CELL_SIZE - fm.getHeight()) / 2) + fm.getAscent();
        g2d.drawString(letter, x, y);
        g2d.dispose();

        return icon;
    }

    /**
     * Builds the tooltip text for an item
     */
    private String buildTooltipText(MissingItem item) {
        StringBuilder sb = new StringBuilder("<html><body style='padding: ");
        sb.append(TOOLTIP_PADDING).append("px;");

        if (item.getItemId() == -1) {
            sb.append(" text-align: center;");
        }

        sb.append("'><div style='font-weight: bold;");

        if (item.getItemId() != -1) {
            sb.append(" margin-bottom: 3px;");
        }

        sb.append("'>").append(item.getItemName()).append("</div>");

        if (item.getItemId() != -1) {
            sb.append("<div style='color: #99FFFF; font-style: italic;'>Click to open wiki</div>");
        }

        sb.append("</body></html>");
        return sb.toString();
    }

    /**
     * Attempts to find an item ID by name using the ItemManager.
     * Results are cached to avoid repeated blocking searches.
     */
    public int findItemIdByName(String itemName) {
        String searchName = itemName.replace("\"", "").trim();

        // Check cache first to avoid blocking search call
        Integer cachedId = itemIdCache.get(searchName.toLowerCase());
        if (cachedId != null) {
            return cachedId;
        }

        // Perform the search (blocking call)
        List<ItemPrice> itemPrices = itemManager.search(searchName);
        int itemId = itemPrices.isEmpty() ? -1 : itemPrices.get(0).getId();

        // Cache the result (including -1 for not found)
        itemIdCache.put(searchName.toLowerCase(), itemId);

        return itemId;
    }

    /**
     * Class to represent a missing item
     */
    @Getter
    private static class MissingItem {
        private final String itemName;
        private final int itemId;

        @Setter
        private BufferedImage icon;

        public MissingItem(String itemName, int itemId, BufferedImage icon) {
            this.itemName = itemName;
            this.itemId = itemId;
            this.icon = icon;
        }
    }

    /**
     * Adds a dynamic missing item that rotates its icon and name every intervalMs
     * milliseconds.
     * 
     * @param names      Array of item names to display.
     * @param itemIds    Array of item IDs corresponding to the names.
     * @param intervalMs Interval in milliseconds to rotate the icon/name.
     */
    public void addDynamicMissingItem(String[] names, int[] itemIds, int intervalMs) {
        synchronized (lock) {
            // Clean all names like addMissingItem does
            String[] cleanedNames = Arrays.stream(names)
                    .map(n -> n.replace("\"", "").replace(" (uncharged)", ""))
                    .toArray(String[]::new);

            // Remove any existing DynamicMissingItem with the same cleaned names
            Set<String> newNamesSet = new HashSet<>(Arrays.asList(cleanedNames));
            Iterator<MissingItem> iterator = missingItems.iterator();
            while (iterator.hasNext()) {
                MissingItem item = iterator.next();
                if (item instanceof DynamicMissingItem) {
                    DynamicMissingItem dyn = (DynamicMissingItem) item;
                    Set<String> existingNamesSet = new HashSet<>(Arrays.asList(dyn.names));
                    if (existingNamesSet.equals(newNamesSet)) {
                        iterator.remove();
                    }
                }
            }
            List<BufferedImage> icons = new ArrayList<>();
            for (int i = 0; i < itemIds.length; i++) {
                String name = names[i].trim().toLowerCase();
                BufferedImage special = null;
                // Only use special icon for exact matches
                if (name.equals("ehb") || name.equals("ehp") || name.equals("community points")
                        || name.equals("account points") || name.equals("total level")) {
                    special = getSpecialIcon(name);
                }
                if (special != null) {
                    icons.add(special);
                } else {
                    icons.add(getItemIcon(itemIds[i], names[i]));
                }
            }
            missingItems.add(new DynamicMissingItem(cleanedNames, itemIds, intervalMs, icons));
            updatePanel();
        }
    }

    // Helper method to get an icon for an item ID
    private Icon getIconForItemId(int itemId) {
        if (itemId == -1) {
            // Return a default icon or a placeholder if itemId is invalid
            BufferedImage icon = createLetterIcon("?");
            return new ImageIcon(icon);
        }
        // Use the same logic as getItemIcon to get and cache the icon
        BufferedImage cachedIcon = iconCache.get(itemId);
        if (cachedIcon != null) {

            return new ImageIcon(cachedIcon);
        }
        BufferedImage icon = itemManager.getImage(itemId);
        if (icon == null) {
            log.warn("No icon found for itemId: {}", itemId);
            icon = createLetterIcon("?");
        }
        BufferedImage resizedIcon = ImageUtil.resizeImage(icon, CELL_SIZE, CELL_SIZE);
        iconCache.put(itemId, resizedIcon);
        return new ImageIcon(resizedIcon);
    }

    private static class DynamicMissingItem extends MissingItem {
        private final String[] names;
        private final int[] itemIds;
        private final int intervalMs;
        private final List<BufferedImage> icons;

        public DynamicMissingItem(String[] names, int[] itemIds, int intervalMs, List<BufferedImage> icons) {
            super(names[0], itemIds[0], icons != null && !icons.isEmpty() ? icons.get(0) : null);
            this.names = names;
            this.itemIds = itemIds;
            this.intervalMs = intervalMs;
            this.icons = icons;
        }
    }

    private BufferedImage getSpecialIcon(String name) {
        String n = name.trim().toLowerCase();
        if (n.contains("ehb"))
            return EHB_ICON;
        if (n.contains("community points"))
            return COMMUNITY_POINTS_ICON;
        if (n.contains("account points"))
            return ACCOUNT_POINTS_ICON;
        if (n.contains("total level"))
            return OVERALL_ICON;
        return null;
    }
}

package gg.embargo.ui;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import gg.embargo.DataManager;
import gg.embargo.EmbargoConfig;
import gg.embargo.EmbargoPlugin;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.plugins.info.JRichTextPane;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.Instant;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

@Slf4j
public class EmbargoPanel extends PluginPanel {
    @Inject
    @Nullable
    private Client client;
    @Inject
    private EventBus eventBus;

    @Inject
    private DataManager dataManager;

    @Inject
    private MissingRequirementsPanel missingRequirementsPanelX;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ScheduledExecutorService executorService;

    @Inject
    private EmbargoConfig config;

    @Setter
    public boolean isLoggedIn = false;

    // Keep track of all boxes
    // private final ArrayList<ItemID> items = new ArrayList<>();
    JPanel versionPanel = new JPanel();
    JPanel missingRequirementsPanel = new JPanel();
    private static final ImageIcon ARROW_RIGHT_ICON = new ImageIcon(
            ImageUtil.loadImageResource(EmbargoPanel.class, "/util/arrow_right.png"));
    private static final ImageIcon DISCORD_ICON = new ImageIcon(
            ImageUtil.loadImageResource(EmbargoPanel.class, "/discord_icon.png"));
    static ImageIcon GITHUB_ICON = new ImageIcon(ImageUtil.loadImageResource(EmbargoPanel.class, "/github_icon.png"));
    static ImageIcon WEBSITE_ICON = new ImageIcon(ImageUtil.loadImageResource(EmbargoPanel.class, "/website_icon.png"));
    private final JRichTextPane emailLabel = new JRichTextPane();
    private final JLabel loggedLabel = new JLabel();
    private final JLabel embargoScoreLabel = new JLabel(htmlLabel("Embargo Score:", " N/A"));
    private final JLabel accountScoreLabel = new JLabel(htmlLabel("Account Score:", " N/A"));
    private final JLabel communityScoreLabel = new JLabel(htmlLabel("Community Score:", " N/A"));
    private final JLabel currentRankLabel = new JLabel(htmlLabel("Current Rank:", " N/A"));
    private final JLabel isRegisteredWithClanLabel = new JLabel(htmlLabel("Account registered:", " No"));
    private final JLabel currentCALabel = new JLabel(htmlLabel("Current TA Tier:", " N/A"));
    final JLabel missingRequiredItemsLabel = new JLabel(
            htmlLabel("Sign in to see what requirements", " you are missing for rank up"));
    private final Font smallFont = FontManager.getRunescapeSmallFont();
    final JPanel missingRequirementsContainer = new JPanel(new BorderLayout(5, 0));
    private final JLabel missingItemCountLabel = new JLabel();
    private boolean missingRequirementsCollapsed = false;
    private JPanel missingRequirementsHeader;
    private JPanel collapsibleContent;
    private JLabel collapseIndicator;
    private JPanel accountInfoSection;
    private JPanel loggedOutSection;
    private JLabel refreshButton;
    private boolean refreshOnCooldown = false;
    private static final int REFRESH_COOLDOWN_SECONDS = 30;

    // Events section (contains Of The Week and Bounties subsections)
    private JPanel eventsContainer;

    // Of The Week subsection - dynamic panels for ongoing/upcoming
    private JPanel ofTheWeekOngoingPanel;
    private JPanel ofTheWeekUpcomingPanel;

    // Bounties subsection - dynamic panel for multiple bounties
    private JPanel bountiesListPanel;
    private final Set<Integer> alertedBountyIds = new HashSet<>();

    // Polls subsection
    private JPanel pollsPanel;
    private final Set<Integer> alertedPollIds = new HashSet<>();

    // Of The Week event alerts
    private final Set<Integer> alertedEventIds = new HashSet<>();

    // Periodic refresh for events/bounties/polls
    private static final int EVENTS_REFRESH_INTERVAL_MINUTES = 1;
    private ScheduledFuture<?> eventsRefreshTask;

    @Inject
    private EmbargoPanel() {
    }

    private String htmlLabel(String key, String value) {
        return "<html><body style = 'color:#a5a5a5'>" + key + "<span style = 'color:white'>" + value
                + "</span></body></html>";
    }

    /**
     * Creates a styled label with smallFont, light gray color, and left alignment
     */
    private JLabel createSmallLabel(String text) {
        JLabel label = new JLabel(text);
        label.setFont(smallFont);
        label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        label.setAlignmentX(Component.LEFT_ALIGNMENT);
        return label;
    }

    /**
     * Creates a styled label with smallFont, specified color, and left alignment
     */
    private JLabel createSmallLabel(String text, Color color) {
        JLabel label = new JLabel(text);
        label.setFont(smallFont);
        label.setForeground(color);
        label.setAlignmentX(Component.LEFT_ALIGNMENT);
        return label;
    }

    /**
     * Creates a section header label (bold, 12pt for main headers, 11pt for
     * subsections)
     */
    private JLabel createHeader(String text, boolean isMain) {
        JLabel header = new JLabel(text);
        header.setFont(new Font("SansSerif", Font.BOLD, isMain ? 12 : 11));
        header.setForeground(isMain ? Color.WHITE : ColorScheme.LIGHT_GRAY_COLOR);
        header.setAlignmentX(Component.LEFT_ALIGNMENT);
        return header;
    }

    /**
     * Creates a panel with vertical BoxLayout and dark background
     */
    private JPanel createVerticalPanel() {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setAlignmentX(Component.LEFT_ALIGNMENT);
        return panel;
    }

    /**
     * Makes a label clickable, opening the given URL on click
     */
    private void makeClickable(JLabel label, String url, String tooltip) {
        label.setCursor(new Cursor(Cursor.HAND_CURSOR));
        label.setToolTipText(tooltip);
        label.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                LinkBrowser.browse(url);
            }
        });
    }

    /**
     * Formats minutes remaining into a human-readable string (e.g., "2d 5h", "3h
     * 30m", "45 min")
     */
    private String formatTimeRemaining(long minutesRemaining) {
        if (minutesRemaining > 1440) { // More than 24 hours
            long days = minutesRemaining / 1440;
            return days + "d " + ((minutesRemaining % 1440) / 60) + "h";
        } else if (minutesRemaining > 60) {
            long hours = minutesRemaining / 60;
            return hours + "h " + (minutesRemaining % 60) + "m";
        } else if (minutesRemaining > 0) {
            return minutesRemaining + " min";
        } else {
            return "Ending soon";
        }
    }

    /**
     * Applies standard styling to a label (smallFont, light gray, left aligned)
     */
    private void styleLabel(JLabel label) {
        label.setFont(smallFont);
        label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        label.setAlignmentX(Component.LEFT_ALIGNMENT);
    }

    void setupVersionPanel() {
        // Set up versionPanel with BoxLayout for better control
        versionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        versionPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        versionPanel.setLayout(new BoxLayout(versionPanel, BoxLayout.Y_AXIS));

        // Set up Embargo Clan Version at top of Version panel
        JLabel version = new JLabel(htmlLabel("Embargo Clan Version: ", "1.5.0"));
        version.setFont(smallFont);
        version.setAlignmentX(Component.LEFT_ALIGNMENT);

        // Apply standard styling to all info labels
        for (JLabel label : new JLabel[] { isRegisteredWithClanLabel, embargoScoreLabel, accountScoreLabel,
                communityScoreLabel, currentCALabel, loggedLabel, currentRankLabel }) {
            styleLabel(label);
        }

        emailLabel.setForeground(Color.WHITE);
        emailLabel.setFont(smallFont);

        versionPanel.add(version);
        versionPanel.add(Box.createVerticalStrut(4));
        versionPanel.add(loggedLabel);

        // Create logged out section (shown when not logged in)
        loggedOutSection = new JPanel();
        loggedOutSection.setLayout(new BoxLayout(loggedOutSection, BoxLayout.Y_AXIS));
        loggedOutSection.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        loggedOutSection.setAlignmentX(Component.LEFT_ALIGNMENT);
        loggedOutSection.add(emailLabel);

        // Create account info section (shown when logged in)
        accountInfoSection = new JPanel();
        accountInfoSection.setLayout(new BoxLayout(accountInfoSection, BoxLayout.Y_AXIS));
        accountInfoSection.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        accountInfoSection.setAlignmentX(Component.LEFT_ALIGNMENT);
        accountInfoSection.setVisible(false);

        // Add separator before Account Info section
        accountInfoSection.add(Box.createVerticalStrut(8));
        JSeparator sep = createSeparator();
        accountInfoSection.add(sep);
        accountInfoSection.add(Box.createVerticalStrut(8));

        // Add Account Info section header with refresh button
        JPanel accountInfoHeaderPanel = new JPanel(new BorderLayout());
        accountInfoHeaderPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        accountInfoHeaderPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        accountInfoHeaderPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 20));

        JLabel accountInfoHeader = new JLabel("Account Info");
        accountInfoHeader.setFont(new Font("SansSerif", Font.BOLD, 12));
        accountInfoHeader.setForeground(Color.WHITE);
        accountInfoHeaderPanel.add(accountInfoHeader, BorderLayout.WEST);

        // Refresh button
        refreshButton = new JLabel("\u21BB"); // Refresh symbol
        refreshButton.setFont(new Font("SansSerif", Font.BOLD, 14));
        refreshButton.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        refreshButton.setCursor(new Cursor(Cursor.HAND_CURSOR));
        refreshButton.setToolTipText("Refresh account data");
        refreshButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (!refreshOnCooldown) {
                    refreshAccountData();
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                if (!refreshOnCooldown) {
                    refreshButton.setForeground(Color.WHITE);
                }
            }

            @Override
            public void mouseExited(MouseEvent e) {
                if (!refreshOnCooldown) {
                    refreshButton.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                }
            }
        });
        accountInfoHeaderPanel.add(refreshButton, BorderLayout.EAST);

        accountInfoSection.add(accountInfoHeaderPanel);
        accountInfoSection.add(Box.createVerticalStrut(6));

        accountInfoSection.add(isRegisteredWithClanLabel);
        accountInfoSection.add(embargoScoreLabel);
        accountInfoSection.add(accountScoreLabel);
        accountInfoSection.add(communityScoreLabel);
        accountInfoSection.add(currentRankLabel);
        accountInfoSection.add(currentCALabel);

        versionPanel.add(loggedOutSection);
        versionPanel.add(accountInfoSection);
    }

    /**
     * Creates a horizontal separator line
     */
    private JSeparator createSeparator() {
        JSeparator separator = new JSeparator(SwingConstants.HORIZONTAL);
        separator.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        separator.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        separator.setMaximumSize(new Dimension(Integer.MAX_VALUE, 1));
        separator.setAlignmentX(Component.LEFT_ALIGNMENT);
        return separator;
    }

    JPanel setUpQuickLinks() {
        JPanel wrapper = new JPanel();
        wrapper.setLayout(new BoxLayout(wrapper, BoxLayout.Y_AXIS));
        wrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        wrapper.setBorder(BorderFactory.createCompoundBorder(
                new MatteBorder(1, 0, 0, 0, ColorScheme.LIGHT_GRAY_COLOR),
                new EmptyBorder(10, 10, 10, 10)));

        // Links Header
        JLabel linksHeader = new JLabel("Links");
        linksHeader.setFont(new Font("SansSerif", Font.BOLD, 12));
        linksHeader.setForeground(Color.WHITE);
        linksHeader.setAlignmentX(Component.LEFT_ALIGNMENT);
        wrapper.add(linksHeader);
        wrapper.add(Box.createVerticalStrut(8));

        JPanel actionsContainer = new JPanel();
        actionsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        actionsContainer.setLayout(new GridLayout(0, 1, 0, 8));
        actionsContainer.setAlignmentX(Component.LEFT_ALIGNMENT);

        actionsContainer
                .add(buildLinkPanel(DISCORD_ICON, "Join us on our", "Discord", "https://discord.gg/YDGGyP3VEq"));
        actionsContainer.add(buildLinkPanel(WEBSITE_ICON, "Go to our", "clan website", "https://embargo.gg/"));
        actionsContainer.add(buildLinkPanel(GITHUB_ICON, "Report a bug or", "inspect the plugin code",
                "https://github.com/EmbargoOSRS/Embargo-Plugin"));

        wrapper.add(actionsContainer);
        return wrapper;
    }

    void setupMissingItemsPanel() {
        // Clear any existing content
        missingRequirementsContainer.removeAll();
        missingRequirementsPanel.removeAll();

        // Set up container styling with top border as separator
        missingRequirementsContainer.setBorder(BorderFactory.createCompoundBorder(
                new MatteBorder(1, 0, 0, 0, ColorScheme.LIGHT_GRAY_COLOR),
                new EmptyBorder(10, 10, 10, 10)));
        missingRequirementsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        missingRequirementsContainer.setFont(FontManager.getRunescapeSmallFont());
        missingRequirementsContainer.setForeground(Color.WHITE);
        missingRequirementsContainer.setLayout(new BorderLayout());

        // Create collapsible header
        missingRequirementsHeader = createMissingRequirementsHeader();
        missingRequirementsContainer.add(missingRequirementsHeader, BorderLayout.NORTH);

        // Set up collapsible content panel
        collapsibleContent = new JPanel(new BorderLayout());
        collapsibleContent.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Set up panel styling
        missingRequirementsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        missingRequirementsPanel.setBorder(new EmptyBorder(8, 0, 8, 0));
        missingRequirementsPanel.setLayout(new GridLayout(1, 1));

        // Always add the default message initially
        missingRequiredItemsLabel
                .setText(htmlLabel("Sign in to see what requirements", " you are missing for rank up"));
        missingRequiredItemsLabel.setFont(smallFont);
        missingRequiredItemsLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        missingRequirementsPanel.add(missingRequiredItemsLabel);

        // Add panel to collapsible content
        collapsibleContent.add(missingRequirementsPanel, BorderLayout.CENTER);

        // Add collapsible content to container
        missingRequirementsContainer.add(collapsibleContent, BorderLayout.CENTER);

        // Add container to main panel
        this.add(missingRequirementsContainer, BorderLayout.NORTH);
        this.revalidate();
    }

    /**
     * Sets up the Events section panel with Of The Week and Bounties subsections
     */
    void setupEventsPanel() {
        eventsContainer = createVerticalPanel();
        eventsContainer.setBorder(BorderFactory.createCompoundBorder(
                new MatteBorder(1, 0, 0, 0, ColorScheme.LIGHT_GRAY_COLOR),
                new EmptyBorder(10, 10, 10, 10)));

        // Main Events Header
        eventsContainer.add(createHeader("Events", true));
        eventsContainer.add(Box.createVerticalStrut(8));

        // === Of The Week Subsection ===
        eventsContainer.add(createHeader("Of The Week", false));
        eventsContainer.add(Box.createVerticalStrut(4));

        ofTheWeekOngoingPanel = createVerticalPanel();
        ofTheWeekOngoingPanel.add(createSmallLabel("Loading..."));
        eventsContainer.add(ofTheWeekOngoingPanel);

        ofTheWeekUpcomingPanel = createVerticalPanel();
        ofTheWeekUpcomingPanel.setVisible(false);
        eventsContainer.add(ofTheWeekUpcomingPanel);

        eventsContainer.add(Box.createVerticalStrut(8));

        // === Bounties Subsection ===
        eventsContainer.add(createHeader("Bounties", false));
        eventsContainer.add(Box.createVerticalStrut(4));

        bountiesListPanel = createVerticalPanel();
        bountiesListPanel.add(createSmallLabel("Loading..."));
        eventsContainer.add(bountiesListPanel);

        eventsContainer.add(Box.createVerticalStrut(8));

        // === Polls Subsection ===
        eventsContainer.add(createHeader("Polls", false));
        eventsContainer.add(Box.createVerticalStrut(4));

        pollsPanel = createVerticalPanel();
        pollsPanel.add(createSmallLabel("Loading..."));
        eventsContainer.add(pollsPanel);

        // Fetch events, bounties, and polls
        fetchAndUpdateEvents();
        fetchAndUpdateBounties();
        fetchAndUpdatePoll();
    }

    /**
     * Fetches events from API and updates the Of The Week panel
     */
    private void fetchAndUpdateEvents() {
        dataManager.getEventsAsync().thenAccept(response -> {
            SwingUtilities.invokeLater(() -> {
                updateOfTheWeekPanel(response);
            });
        });
    }

    private static final Color COLOR_GREEN = new Color(0x00, 0xc8, 0x00);
    private static final Color COLOR_ORANGE = new Color(0xff, 0xc0, 0x00);

    /**
     * Updates the Of The Week panel with the API response
     */
    private void updateOfTheWeekPanel(JsonArray events) {
        ofTheWeekOngoingPanel.removeAll();
        ofTheWeekUpcomingPanel.removeAll();

        if (events == null || events.size() == 0) {
            ofTheWeekOngoingPanel.add(createSmallLabel("No events"));
            ofTheWeekUpcomingPanel.setVisible(false);
            eventsContainer.revalidate();
            eventsContainer.repaint();
            return;
        }

        // Separate ongoing and upcoming events
        java.util.List<JsonObject> ongoingEvents = new ArrayList<>();
        java.util.List<JsonObject> upcomingEvents = new ArrayList<>();

        for (JsonElement element : events) {
            JsonObject event = element.getAsJsonObject();
            boolean started = event.has("started") && event.get("started").getAsBoolean();
            boolean completed = event.has("completed") && event.get("completed").getAsBoolean();

            if (started && !completed) {
                ongoingEvents.add(event);
            } else if (!started && !completed) {
                upcomingEvents.add(event);
            }
        }

        // Display ongoing events
        if (ongoingEvents.isEmpty()) {
            ofTheWeekOngoingPanel.add(createSmallLabel("No ongoing events"));
        } else {
            ofTheWeekOngoingPanel.add(createSmallLabel("Ongoing", COLOR_GREEN));

            for (JsonObject event : ongoingEvents) {
                addEventToPanel(ofTheWeekOngoingPanel, event, true);

                // Alert user if this is a new ongoing event they haven't been alerted about
                int eventId = event.has("wiseOldManId") ? event.get("wiseOldManId").getAsInt()
                        : (event.has("id") ? event.get("id").getAsInt() : 0);
                if (eventId > 0 && isLoggedIn && !alertedEventIds.contains(eventId)) {
                    alertedEventIds.add(eventId);
                    sendEventAlert(event);
                }
            }
        }

        // Display upcoming events
        if (!upcomingEvents.isEmpty()) {
            ofTheWeekUpcomingPanel.add(Box.createVerticalStrut(6));
            ofTheWeekUpcomingPanel.add(createSmallLabel("Upcoming", COLOR_ORANGE));

            for (JsonObject event : upcomingEvents) {
                addEventToPanel(ofTheWeekUpcomingPanel, event, false);
            }
            ofTheWeekUpcomingPanel.setVisible(true);
        } else {
            ofTheWeekUpcomingPanel.setVisible(false);
        }

        eventsContainer.revalidate();
        eventsContainer.repaint();
    }

    /**
     * Adds a single event entry to the given panel
     */
    private void addEventToPanel(JPanel panel, JsonObject event, boolean isOngoing) {
        panel.add(Box.createVerticalStrut(4));

        String name = event.has("name") ? event.get("name").getAsString() : "Unknown";
        String metric = event.has("metric") ? event.get("metric").getAsString() : "";
        int participants = event.has("participantCount") ? event.get("participantCount").getAsInt() : 0;
        int eventId = event.has("wiseOldManId") ? event.get("wiseOldManId").getAsInt()
                : (event.has("id") ? event.get("id").getAsInt() : 0);

        // Shorten event name: "Boss Of The Week #X |" -> "BOTW |", "Skill Of The Week
        // #X |" -> "SOTW |"
        String displayName = name
                .replaceFirst("Boss Of The Week #\\d+\\s*\\|", "BOTW |")
                .replaceFirst("Skill Of The Week #\\d+\\s*\\|", "SOTW |")
                .trim();

        // Event name as clickable link
        JLabel nameLabel = createSmallLabel(displayName, Color.WHITE);
        if (eventId > 0) {
            makeClickable(nameLabel, "https://embargo.gg/competition/" + eventId, "Click to view on embargo.gg");
        }
        panel.add(nameLabel);

        // Metric (using "Metric:" as label since it could be skill or boss)
        if (!metric.isEmpty()) {
            String formattedMetric = metric.substring(0, 1).toUpperCase() + metric.substring(1).replace("_", " ");
            JLabel metricLabel = new JLabel(htmlLabel("Metric:", " " + formattedMetric));
            styleLabel(metricLabel);
            panel.add(metricLabel);
        }

        // Participants (only for ongoing)
        if (isOngoing) {
            JLabel participantsLabel = new JLabel(htmlLabel("Participants:", " " + participants));
            styleLabel(participantsLabel);
            panel.add(participantsLabel);
        }
    }

    /**
     * Fetches bounties from API and updates the panel
     */
    private void fetchAndUpdateBounties() {
        dataManager.getBountiesAsync().thenAccept(response -> {
            SwingUtilities.invokeLater(() -> {
                updateBountyPanel(response);
            });
        });
    }

    /**
     * Updates the bounty panel with the API response
     * Shows: ongoing bounty (if any) + 2 most recent completed bounties
     */
    private void updateBountyPanel(JsonObject response) {
        bountiesListPanel.removeAll();

        if (response == null || !response.has("bounties")) {
            bountiesListPanel.add(createSmallLabel("No bounties"));
            eventsContainer.revalidate();
            eventsContainer.repaint();
            return;
        }

        JsonArray bounties = response.getAsJsonArray("bounties");
        java.util.List<JsonObject> activeBounties = new ArrayList<>();
        java.util.List<JsonObject> recentBounties = new ArrayList<>();

        // Separate active and completed bounties
        for (JsonElement element : bounties) {
            JsonObject bounty = element.getAsJsonObject();
            String status = bounty.has("status") ? bounty.get("status").getAsString() : "";

            if ("active".equalsIgnoreCase(status)) {
                activeBounties.add(bounty);
            } else if ("completed".equalsIgnoreCase(status) || "expired".equalsIgnoreCase(status)) {
                recentBounties.add(bounty);
            }
        }

        boolean hasContent = false;

        // Display active bounties first
        if (!activeBounties.isEmpty()) {
            hasContent = true;
            bountiesListPanel.add(createSmallLabel("Active", COLOR_GREEN));

            for (JsonObject activeBounty : activeBounties) {
                addBountyToPanel(bountiesListPanel, activeBounty, true);

                // Alert user if this is a new bounty they haven't been alerted about
                int bountyId = activeBounty.get("id").getAsInt();
                if (isLoggedIn && !alertedBountyIds.contains(bountyId)) {
                    alertedBountyIds.add(bountyId);
                    sendBountyAlert(activeBounty);
                }
            }
        }

        // Display up to 2 most recent completed bounties
        if (!recentBounties.isEmpty()) {
            if (hasContent) {
                bountiesListPanel.add(Box.createVerticalStrut(6));
            }

            bountiesListPanel.add(createSmallLabel("Recent"));

            int count = 0;
            for (JsonObject bounty : recentBounties) {
                if (count >= 2)
                    break;
                addBountyToPanel(bountiesListPanel, bounty, false);
                count++;
            }
            hasContent = true;
        }

        if (!hasContent) {
            bountiesListPanel.add(createSmallLabel("No bounties"));
        }

        eventsContainer.revalidate();
        eventsContainer.repaint();
    }

    /**
     * Adds a single bounty entry to the given panel
     */
    private void addBountyToPanel(JPanel panel, JsonObject bounty, boolean isActive) {
        panel.add(Box.createVerticalStrut(4));

        String name = bounty.has("name") ? bounty.get("name").getAsString() : "Unknown";
        String target = name.replaceFirst("Bounty #\\d+ - ", "");
        int bountyId = bounty.has("id") ? bounty.get("id").getAsInt() : 0;

        // Target name as clickable link
        JLabel targetLabel = createSmallLabel(target, Color.WHITE);
        if (bountyId > 0) {
            makeClickable(targetLabel, "https://embargo.gg/bounties/" + bountyId, "Click to view on embargo.gg");
        }
        panel.add(targetLabel);

        // Time remaining (for active)
        if (isActive && bounty.has("endTime")) {
            try {
                String endTimeStr = bounty.get("endTime").getAsString();
                ZonedDateTime endTime = ZonedDateTime.parse(endTimeStr);
                long minutesRemaining = Instant.now().until(endTime.toInstant(), ChronoUnit.MINUTES);

                JLabel timeLabel = new JLabel(htmlLabel("Time left:", " " + formatTimeRemaining(minutesRemaining)));
                styleLabel(timeLabel);
                panel.add(timeLabel);
            } catch (Exception e) {
                // Skip time label if parsing fails
            }
        }
    }

    /**
     * Sends a chat message alert for an active bounty
     */
    private void sendBountyAlert(JsonObject bounty) {
        if (client == null || client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        if (!config.enableBountyAlerts()) {
            return;
        }

        String name = bounty.get("name").getAsString();
        String target = name.replaceFirst("Bounty #\\d+ - ", "");

        clientThread.invokeLater(() -> {
            client.addChatMessage(
                    net.runelite.api.ChatMessageType.GAMEMESSAGE,
                    "",
                    "<col=ff9000>[Embargo]</col> Active bounty: <col=ffffff>" + target
                            + "</col>! Check the side panel for details.",
                    null);
        });
    }

    /**
     * Clears all alerted IDs (call on logout to allow re-alerting on next login)
     */
    public void clearAlertedIds() {
        alertedBountyIds.clear();
        alertedPollIds.clear();
        alertedEventIds.clear();
    }

    /**
     * Starts the periodic background refresh for events, bounties, and polls.
     * Runs every minute while the user is logged in.
     */
    private void startPeriodicEventsRefresh() {
        // Cancel any existing task first
        stopPeriodicEventsRefresh();

        eventsRefreshTask = executorService.scheduleAtFixedRate(() -> {
            if (isLoggedIn) {
                log.debug("Periodic refresh: fetching events, bounties, and polls");
                fetchAndUpdateEvents();
                fetchAndUpdateBounties();
                fetchAndUpdatePoll();
            }
        }, EVENTS_REFRESH_INTERVAL_MINUTES, EVENTS_REFRESH_INTERVAL_MINUTES, TimeUnit.MINUTES);
    }

    /**
     * Stops the periodic background refresh for events, bounties, and polls.
     */
    private void stopPeriodicEventsRefresh() {
        if (eventsRefreshTask != null && !eventsRefreshTask.isCancelled()) {
            eventsRefreshTask.cancel(false);
            eventsRefreshTask = null;
        }
    }

    /**
     * Fetches the last active poll from API and updates the panel
     */
    private void fetchAndUpdatePoll() {
        dataManager.getLastPollAsync().thenAccept(response -> {
            SwingUtilities.invokeLater(() -> {
                updatePollPanel(response);
            });
        });
    }

    /**
     * Updates the poll panel with the API response
     */
    private void updatePollPanel(JsonObject poll) {
        pollsPanel.removeAll();

        if (poll == null) {
            pollsPanel.add(createSmallLabel("No active polls"));
            eventsContainer.revalidate();
            eventsContainer.repaint();
            return;
        }

        // Alert user if this is a new poll they haven't been alerted about
        int pollId = poll.has("id") ? poll.get("id").getAsInt() : 0;
        if (pollId > 0 && isLoggedIn && !alertedPollIds.contains(pollId)) {
            alertedPollIds.add(pollId);
            sendPollAlert(poll);
        }

        pollsPanel.add(Box.createVerticalStrut(4));
        pollsPanel.add(createSmallLabel("Active", COLOR_GREEN));
        pollsPanel.add(Box.createVerticalStrut(4));

        // Poll title as clickable link
        String title = poll.has("title") ? poll.get("title").getAsString() : "Unknown Poll";
        String discordUrl = poll.has("discordUrl") ? poll.get("discordUrl").getAsString() : null;

        JLabel titleLabel = createSmallLabel(title, Color.WHITE);
        if (discordUrl != null && !discordUrl.isEmpty()) {
            makeClickable(titleLabel, discordUrl, "Click to view poll on Discord");
        }
        pollsPanel.add(titleLabel);

        // Time remaining
        if (poll.has("endsAt")) {
            try {
                String endsAtStr = poll.get("endsAt").getAsString();
                ZonedDateTime endsAt = ZonedDateTime.parse(endsAtStr);
                long minutesRemaining = Instant.now().until(endsAt.toInstant(), ChronoUnit.MINUTES);

                JLabel timeLabel = new JLabel(htmlLabel("Ends in:", " " + formatTimeRemaining(minutesRemaining)));
                styleLabel(timeLabel);
                pollsPanel.add(timeLabel);
            } catch (Exception e) {
                // Skip time label if parsing fails
            }
        }

        eventsContainer.revalidate();
        eventsContainer.repaint();
    }

    /**
     * Sends a chat message alert for an active poll
     */
    private void sendPollAlert(JsonObject poll) {
        if (client == null || client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        if (!config.enablePollAlerts()) {
            return;
        }

        String title = poll.has("title") ? poll.get("title").getAsString() : "New Poll";

        clientThread.invokeLater(() -> {
            client.addChatMessage(
                    net.runelite.api.ChatMessageType.GAMEMESSAGE,
                    "",
                    "<col=ff9000>[Embargo]</col> New poll: <col=ffffff>" + title
                            + "</col>! Check the side panel or Discord to vote.",
                    null);
        });
    }

    /**
     * Sends a chat message alert for an ongoing Of The Week event
     */
    private void sendEventAlert(JsonObject event) {
        if (client == null || client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        if (!config.enableEventAlerts()) {
            return;
        }

        String name = event.has("name") ? event.get("name").getAsString() : "New Event";
        String metric = event.has("metric") ? event.get("metric").getAsString() : "";
        String formattedMetric = metric.isEmpty() ? "Unknown"
                : metric.substring(0, 1).toUpperCase() + metric.substring(1).replace("_", " ");

        // Determine event type (BOTW or SOTW)
        String eventType = name.contains("Boss") ? "BOTW" : "SOTW";

        clientThread.invokeLater(() -> {
            client.addChatMessage(
                    net.runelite.api.ChatMessageType.GAMEMESSAGE,
                    "",
                    "<col=ff9000>[Embargo]</col> Active " + eventType + ": <col=ffffff>" + formattedMetric
                            + "</col>. Check the side panel for details.",
                    null);
        });
    }

    /**
     * Creates the collapsible header for missing requirements section
     */
    private JPanel createMissingRequirementsHeader() {
        JPanel header = new JPanel(new BorderLayout());
        header.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        header.setBorder(new EmptyBorder(0, 0, 8, 0));
        header.setCursor(new Cursor(Cursor.HAND_CURSOR));

        // Left side: title and collapse indicator
        JPanel titlePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        collapseIndicator = new JLabel("\u25BC "); // Down arrow
        collapseIndicator.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        collapseIndicator.setFont(new Font("SansSerif", Font.PLAIN, 10));
        titlePanel.add(collapseIndicator);

        JLabel title = new JLabel("Missing Requirements");
        title.setFont(new Font("SansSerif", Font.BOLD, 12));
        title.setForeground(Color.WHITE);
        titlePanel.add(title);

        header.add(titlePanel, BorderLayout.WEST);

        // Right side: item count
        missingItemCountLabel.setFont(smallFont);
        missingItemCountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        header.add(missingItemCountLabel, BorderLayout.EAST);

        // Add click listener for collapse/expand
        MouseAdapter collapseListener = new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                toggleMissingRequirementsCollapse();
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                header.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
                titlePanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                header.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }
        };

        header.addMouseListener(collapseListener);

        return header;
    }

    /**
     * Toggles the collapsed state of the missing requirements section
     */
    private void toggleMissingRequirementsCollapse() {
        missingRequirementsCollapsed = !missingRequirementsCollapsed;
        collapsibleContent.setVisible(!missingRequirementsCollapsed);
        collapseIndicator.setText(missingRequirementsCollapsed ? "\u25B6 " : "\u25BC "); // Right arrow / Down arrow
        missingRequirementsContainer.revalidate();
        missingRequirementsContainer.repaint();
    }

    /**
     * Updates the missing item count label
     */
    private void updateMissingItemCount(int count) {
        if (count > 0) {
            missingItemCountLabel.setText(count + " item" + (count != 1 ? "s" : ""));
        } else {
            missingItemCountLabel.setText("");
        }
    }

    /**
     * Refreshes account data from the server
     */
    private void refreshAccountData() {
        if (client == null || client.getLocalPlayer() == null) {
            return;
        }

        // Start cooldown
        startRefreshCooldown();

        // Show loading state for manual refresh
        embargoScoreLabel.setText(htmlLabel("Embargo Score:", " Loading..."));
        accountScoreLabel.setText(htmlLabel("Account Score:", " Loading..."));
        communityScoreLabel.setText(htmlLabel("Community Score:", " Loading..."));
        currentRankLabel.setText(htmlLabel("Current Rank:", " Loading..."));
        currentCALabel.setText(htmlLabel("Current CA Tier:", " Loading..."));

        // Clear existing missing items
        missingRequirementsPanelX.clearItems();
        updateMissingItemCount(0);

        // Refresh events (includes Of The Week and Bounties)
        fetchAndUpdateEvents();
        fetchAndUpdateBounties();

        // Force refresh by calling updateLoggedIn with scheduled=true
        updateLoggedIn(true);
    }

    /**
     * Starts the refresh cooldown timer
     */
    private void startRefreshCooldown() {
        refreshOnCooldown = true;
        refreshButton.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
        refreshButton.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
        refreshButton.setToolTipText("Refresh on cooldown...");

        // Schedule cooldown end
        executorService.schedule(() -> {
            SwingUtilities.invokeLater(() -> {
                refreshOnCooldown = false;
                refreshButton.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                refreshButton.setCursor(new Cursor(Cursor.HAND_CURSOR));
                refreshButton.setToolTipText("Refresh account data");
            });
        }, REFRESH_COOLDOWN_SECONDS, java.util.concurrent.TimeUnit.SECONDS);
    }

    void addSidePanel() {
        // Add the panels to the side plugin
        this.add(versionPanel, BorderLayout.NORTH);

        // Create center panel to hold missing requirements and events
        JPanel centerWrapper = new JPanel();
        centerWrapper.setLayout(new BoxLayout(centerWrapper, BoxLayout.Y_AXIS));
        centerWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Setup and add missing items panel
        setupMissingItemsPanel();
        missingRequirementsContainer.setAlignmentX(Component.LEFT_ALIGNMENT);
        missingRequirementsContainer.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));

        // Remove from NORTH (setupMissingItemsPanel adds it there) and add to wrapper
        this.remove(missingRequirementsContainer);
        centerWrapper.add(missingRequirementsContainer);

        // Setup and add events panel (contains Of The Week and Bounties)
        setupEventsPanel();
        eventsContainer.setAlignmentX(Component.LEFT_ALIGNMENT);
        eventsContainer.setMaximumSize(new Dimension(Integer.MAX_VALUE, eventsContainer.getPreferredSize().height));
        centerWrapper.add(eventsContainer);

        this.add(centerWrapper, BorderLayout.CENTER);
        this.add(this.setUpQuickLinks(), BorderLayout.SOUTH);
    }

    void setupSidePanel() {
        this.setupVersionPanel();
        this.setUpQuickLinks();
        this.addSidePanel();

        // Update version panel with Embargo plugin information
        updateLoggedIn(false);
    }

    public void init() {
        this.setupSidePanel();
        logOut();
    }

    public void updateLoggedIn(boolean scheduled) {
        if (dataManager.stopTryingForAccount.get()) {
            emailLabel.setText("Account not registered with Embargo");
            missingRequirementsPanelX.removeAll();
            missingRequirementsContainer.removeAll();
            missingRequirementsPanel.removeAll();
            missingRequiredItemsLabel.removeAll();
            missingRequirementsContainer.removeAll();
            missingRequirementsContainer.revalidate();
            missingRequirementsContainer.repaint();
            return;
        }
        if (!isLoggedIn || scheduled) {
            if (client != null && client.getLocalPlayer() != null) {
                var username = client.getLocalPlayer().getName();

                // If username isn't available yet, bail out and let scheduled retry handle it
                if (username == null || username.isEmpty()) {
                    return;
                }

                // Only show loading state on first login, not on scheduled refreshes
                boolean isFirstLogin = !this.isLoggedIn;
                this.isLoggedIn = true;

                loggedLabel.setText(htmlLabel("Signed in as ", " " + username));

                dataManager.isUserRegisteredAsync(username, isRegistered -> {
                    if (!isRegistered) {
                        emailLabel.setText("Account not registered with Embargo");
                        return;
                    }
                });

                // Toggle section visibility
                loggedOutSection.setVisible(false);
                accountInfoSection.setVisible(true);

                // Only show "Loading..." on first login
                if (isFirstLogin) {
                    // Refresh events (Of The Week and Bounties) on login
                    fetchAndUpdateEvents();
                    fetchAndUpdateBounties();
                    fetchAndUpdatePoll();

                    // Start periodic refresh for events/bounties/polls
                    startPeriodicEventsRefresh();

                    embargoScoreLabel.setText(htmlLabel("Embargo Score:", " Loading..."));
                    accountScoreLabel.setText(htmlLabel("Account Score:", " Loading..."));
                    communityScoreLabel.setText(htmlLabel("Community Score:", " Loading..."));
                    currentRankLabel.setText(htmlLabel("Current Rank:", " Loading..."));
                    currentCALabel.setText(htmlLabel("Current CA Tier:", " Loading..."));
                }

                isRegisteredWithClanLabel.setText(htmlLabel("Account registered:", " Yes"));

                // get gear asynchronously
                dataManager.getProfileAsync(username, false).thenAccept(embargoProfileData -> {
                    // This code runs when the profile data is received
                    // We need to run UI updates on the client thread
                    clientThread.invokeLater(() -> {
                        // Check if profile data is valid before processing
                        if (embargoProfileData == null) {
                            return;
                        }

                        JsonElement currentAccountPoints = embargoProfileData.get("accountPoints");
                        JsonElement currentCommunityPoints = embargoProfileData.get("communityPoints");

                        // Parse points safely, defaulting to 0 if null
                        int accountPoints = (currentAccountPoints != null && !currentAccountPoints.isJsonNull())
                                ? currentAccountPoints.getAsInt()
                                : 0;
                        int communityPoints = (currentCommunityPoints != null && !currentCommunityPoints.isJsonNull())
                                ? currentCommunityPoints.getAsInt()
                                : 0;

                        embargoScoreLabel.setText(htmlLabel("Embargo Score:", " " + (accountPoints + communityPoints)));
                        accountScoreLabel.setText(htmlLabel("Account Score:", " " + accountPoints));
                        communityScoreLabel.setText(htmlLabel("Community Score:", " " + communityPoints));

                        JsonElement getCurrentCAName = embargoProfileData.get("currentHighestCAName");
                        JsonObject currentRank = embargoProfileData.getAsJsonObject("currentRank");

                        String currentRankDisplay = "N/A";
                        if (currentRank != null) {
                            JsonElement currentRankName = currentRank.get("name");
                            if (currentRankName != null && !currentRankName.isJsonNull()) {
                                currentRankDisplay = currentRankName.getAsString();
                            }
                        }
                        currentRankLabel.setText(htmlLabel("Current Rank:", " " + currentRankDisplay));

                        String displayCAName = "N/A";
                        if (getCurrentCAName != null && !getCurrentCAName.isJsonNull()) {
                            displayCAName = getCurrentCAName.getAsString().replace(" Combat Achievement", "");
                        }
                        currentCALabel.setText(htmlLabel("Current CA Tier:", " " + displayCAName));

                        JsonArray missingGearReqs = embargoProfileData.getAsJsonArray("missingGearRequirements");
                        JsonArray missingUntradableItemIdReqs = embargoProfileData
                                .getAsJsonArray("missingUntradableItemIds");

                        ArrayList<String> alreadyProcessed = new ArrayList<>();

                        // Build out the missing requirements panel
                        if (missingGearReqs.size() > 0 || missingUntradableItemIdReqs.size() > 0) {
                            // Process items off the client thread to avoid blocking chunk loading
                            // Use executorService to perform all item ID lookups asynchronously
                            executorService.execute(() -> {
                                // Pre-resolve all item IDs off the client thread (these are blocking calls)
                                java.util.List<Object[]> dynamicItemsData = new ArrayList<>();
                                java.util.List<Object[]> regularItemsData = new ArrayList<>();

                                for (JsonElement mi : missingGearReqs) {
                                    String itemName = mi.getAsString();
                                    alreadyProcessed.add(itemName);
                                    log.debug("Processing {} in missingGearReqs", itemName);

                                    if (itemName.contains("|")) {
                                        // DynamicMissingItem: pre-resolve all item IDs
                                        String[] dynamicNames = itemName.split("\\|");
                                        int[] itemIds = new int[dynamicNames.length];
                                        for (int i = 0; i < dynamicNames.length; i++) {
                                            itemIds[i] = missingRequirementsPanelX
                                                    .findItemIdByName(dynamicNames[i].trim());
                                        }
                                        dynamicItemsData.add(new Object[] { dynamicNames, itemIds });
                                    } else {
                                        // Regular item: pre-resolve item ID
                                        int itemId = missingRequirementsPanelX.findItemIdByName(itemName);
                                        regularItemsData.add(new Object[] { itemName, itemId });
                                    }
                                }

                                java.util.List<Integer> untradableIds = new ArrayList<>();
                                for (JsonElement mu : missingUntradableItemIdReqs) {
                                    if (alreadyProcessed.contains(mu.getAsString())) {
                                        log.debug("{} already added, skipping missingUntradableItemIdReqs",
                                                mu.getAsString());
                                        continue;
                                    }
                                    untradableIds.add(mu.getAsInt());
                                }

                                // Now add all items on the client thread with batching enabled
                                clientThread.invokeLater(() -> {
                                    // Begin batching to prevent multiple panel rebuilds
                                    missingRequirementsPanelX.beginBatchUpdate();

                                    try {
                                        // Add all dynamic items
                                        for (Object[] data : dynamicItemsData) {
                                            String[] names = (String[]) data[0];
                                            int[] ids = (int[]) data[1];
                                            missingRequirementsPanelX.addDynamicMissingItem(names, ids, 3000);
                                        }

                                        // Add all regular items
                                        for (Object[] data : regularItemsData) {
                                            String name = (String) data[0];
                                            int id = (int) data[1];
                                            missingRequirementsPanelX.addMissingItem(name, id);
                                        }

                                        // Add untradable items
                                        for (int itemId : untradableIds) {
                                            missingRequirementsPanelX.addMissingItem("", itemId);
                                        }
                                    } finally {
                                        // End batching - this triggers a single panel rebuild
                                        missingRequirementsPanelX.endBatchUpdate();
                                    }

                                    // Update the container panel
                                    missingRequirementsPanel.removeAll();
                                    missingRequirementsPanel.add(missingRequirementsPanelX);
                                    missingRequirementsPanel.revalidate();
                                    missingRequirementsPanel.repaint();

                                    // Update item count
                                    int totalItems = dynamicItemsData.size() + regularItemsData.size()
                                            + untradableIds.size();
                                    updateMissingItemCount(totalItems);
                                });
                            });
                        } else {
                            missingRequiredItemsLabel.setText(htmlLabel("Missing Requirements: ", "None"));
                            updateMissingItemCount(0);
                        }
                    });
                }).exceptionally(ex -> {
                    log.error("Error fetching profile data", ex);
                    return null;
                });

                this.isLoggedIn = true;

            }
        }
    }

    public void logOut() {
        this.isLoggedIn = false;

        // Stop periodic refresh
        stopPeriodicEventsRefresh();

        // Clear alerted IDs so users get re-alerted on next login
        clearAlertedIds();

        // Panel may not be initialized yet if logout event fires early
        if (loggedOutSection == null || accountInfoSection == null) {
            return;
        }

        // Update labels
        emailLabel.setContentType("text/html");
        emailLabel.setText("Sign in to send data to Embargo.");
        loggedLabel.setText("Not signed in");

        // Toggle section visibility
        loggedOutSection.setVisible(true);
        accountInfoSection.setVisible(false);

        // Reset missing gear requirements
        missingRequiredItemsLabel
                .setText(htmlLabel("Sign in to see what requirements", " you are missing for rank up"));
        missingRequiredItemsLabel.setFont(smallFont);
        missingRequiredItemsLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        missingRequirementsPanelX.clearItems();
        updateMissingItemCount(0);

        // Rebuild missing requirements panel content (preserve header)
        missingRequirementsPanel.removeAll();
        missingRequirementsPanel.add(missingRequiredItemsLabel);

        // Reset collapse state
        missingRequirementsCollapsed = false;
        if (collapseIndicator != null) {
            collapseIndicator.setText("\u25BC "); // Down arrow
        }
        if (collapsibleContent != null) {
            collapsibleContent.setVisible(true);
        }

        // Set to NA
        isRegisteredWithClanLabel.setText(htmlLabel("Account registered:", " No"));
        embargoScoreLabel.setText(htmlLabel("Embargo Score:", " N/A"));
        currentRankLabel.setText(htmlLabel("Current Rank:", " N/A"));
        accountScoreLabel.setText(htmlLabel("Account Score:", " N/A"));
        communityScoreLabel.setText(htmlLabel("Community Score:", " N/A"));
        currentCALabel.setText(htmlLabel("Current TA Tier:", " N/A"));

        // Refresh UI
        versionPanel.revalidate();
        versionPanel.repaint();
        missingRequirementsPanel.revalidate();
        missingRequirementsPanel.repaint();
        missingRequirementsContainer.revalidate();
        missingRequirementsContainer.repaint();
        this.revalidate();
        this.repaint();
    }

    public void reset() {
        stopPeriodicEventsRefresh();
        eventBus.unregister(this);
        missingRequirementsPanelX.shutdown();
        this.updateLoggedIn(false);
    }

    /**
     * Builds a link panel with a given icon, text and url to redirect to.
     */
    private static JPanel buildLinkPanel(ImageIcon icon, String topText, String bottomText, String url) {
        return buildLinkPanel(icon, topText, bottomText, () -> LinkBrowser.browse(url));
    }

    /**
     * Builds a link panel with a given icon, text and callable to call.
     */
    private static JPanel buildLinkPanel(ImageIcon icon, String topText, String bottomText, Runnable callback) {
        JPanel container = new JPanel();
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        container.setLayout(new BorderLayout());
        container.setBorder(new EmptyBorder(10, 10, 10, 10));

        final Color hoverColor = ColorScheme.DARKER_GRAY_HOVER_COLOR;
        final Color pressedColor = ColorScheme.DARKER_GRAY_COLOR.brighter();

        JLabel iconLabel = new JLabel(icon);
        container.add(iconLabel, BorderLayout.WEST);

        JPanel textContainer = new JPanel();
        textContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        textContainer.setLayout(new GridLayout(2, 1));
        textContainer.setBorder(new EmptyBorder(5, 10, 5, 10));

        container.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent mouseEvent) {
                container.setBackground(pressedColor);
                textContainer.setBackground(pressedColor);
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                callback.run();
                container.setBackground(hoverColor);
                textContainer.setBackground(hoverColor);
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                container.setBackground(hoverColor);
                textContainer.setBackground(hoverColor);
                container.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                textContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                container.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            }
        });

        JLabel topLine = new JLabel(topText);
        topLine.setForeground(Color.WHITE);
        topLine.setFont(FontManager.getRunescapeSmallFont());

        JLabel bottomLine = new JLabel(bottomText);
        bottomLine.setForeground(Color.WHITE);
        bottomLine.setFont(FontManager.getRunescapeSmallFont());

        textContainer.add(topLine);
        textContainer.add(bottomLine);

        container.add(textContainer, BorderLayout.CENTER);

        JLabel arrowLabel = new JLabel(ARROW_RIGHT_ICON);
        container.add(arrowLabel, BorderLayout.EAST);

        return container;
    }
}

/*
Almost all of this code was taken from the tob-notice-board plugin by Broooklyn
https://github.com/Broooklyn/runelite-external-plugins/tree/tob-notice-board
Modifications were made to work with clans by Sharpienero/Embargo

Added TOA code
 13/04/2025 - Converted to use gamevals
 */


package gg.embargo.noticeboard;

import gg.embargo.EmbargoConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.clan.ClanChannelMember;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.util.Text;
import net.runelite.client.callback.ClientThread;


import javax.inject.Inject;

@Slf4j
public class NoticeBoardManager {
    @Inject
    private Client client;

    @Inject
    private EmbargoConfig config;

    @Inject
    private ClientThread clientThread;

    private final EventBus eventBus;



    @Inject
    public NoticeBoardManager(Client client, ClientThread clientThread, EventBus eventBus) {
        this.client = client;
        this.clientThread = clientThread;
        this.eventBus = eventBus;
    }

    private static final int DEFAULT_RGB = 0xff981f;
    private static final int STARTING_PARTY_CHILD_ID = 17;
    private static final int ENDING_PARTY_CHILD_ID = 62;

    private void setNoticeBoardWidget(int parent, int index, int clanColor) {
        for (int childID = STARTING_PARTY_CHILD_ID; childID < ENDING_PARTY_CHILD_ID; ++childID) {
            Widget noticeBoard = client.getWidget(parent, childID);

            if (noticeBoard != null && noticeBoard.getName() != null && noticeBoard.getChildren() != null) {
                for (Widget noticeBoardChild : noticeBoard.getChildren()) {
                    if (noticeBoardChild.getIndex() == index) {
                        if (client.getClanChannel() != null) {
                            for (ClanChannelMember member : client.getClanChannel().getMembers()) {
                                if (Text.toJagexName(member.getName()).equals(Text.removeTags(noticeBoard.getName()))) {
                                    noticeBoardChild.setTextColor(config.highlightClan() ? clanColor : DEFAULT_RGB);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    private void setApplicationWidget(int parent, int child, int clanColor) {
        Widget acceptWidgetMembers = client.getWidget(parent, child);
        if (acceptWidgetMembers != null && acceptWidgetMembers.getChildren() != null) {
            Widget[] acceptWidgetChildren = acceptWidgetMembers.getChildren();
            for (Widget w : acceptWidgetChildren) {
                if (client != null && client.getClanChannel() != null) {
                    for (ClanChannelMember member : client.getClanChannel().getMembers()) {
                        if (w.getText().contains(member.getName())) {
                            String hex = Integer.toHexString(clanColor).substring(2);
                            String builtName = "<col=" + hex + ">" + member.getName() + "</col>";
                            w.setName("<col=" + hex + ">" + member.getName() + "</col>");
                            w.setText(builtName);
                        }
                    }

                }
            }
        }
    }

    private void setTOBNameColors(int clanColor) {
        setApplicationWidget(50, 42, clanColor);
        setNoticeBoardWidget(364, 3, clanColor);
    }

    private void setTOANameColors(int clanColor) {
        setApplicationWidget(774, 48, clanColor);
        setNoticeBoardWidget(772, 2, clanColor);
    }

    public void startUp()
    {
        eventBus.register(this);
    }
    public void shutDown()
    {
        unsetNoticeBoards();
        eventBus.unregister(this);
    }

    public void setTOBNoticeBoard()
    {

        setTOBNameColors(config.clanColor().getRGB());
    }

    public void setTOANoticeBoard() {
        setTOANameColors(config.clanColor().getRGB());
    }

    public void setNoticeBoards() {
        if (config.highlightClan()) {
            setTOBNoticeBoard();
            setTOANoticeBoard();
        }
    }

    public void unsetNoticeBoards()
    {
        setTOBNameColors(DEFAULT_RGB);
        setTOANameColors(DEFAULT_RGB);
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded widgetLoaded)
    {
        clientThread.invokeLater(() ->
        {
            // TOB
            if (widgetLoaded.getGroupId() == InterfaceID.TOB_PARTYLIST || widgetLoaded.getGroupId() == InterfaceID.TOB_PARTYDETAILS)
            {
                setTOBNoticeBoard();
            }

            // TOA
            if (widgetLoaded.getGroupId() == InterfaceID.TOA_PARTYLIST|| widgetLoaded.getGroupId() == InterfaceID.TOA_PARTYDETAILS) {
                setTOANoticeBoard();
            }
        });
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        String CONFIG_GROUP = "embargo";
        if (!event.getGroup().equals(CONFIG_GROUP))
        {
            return;
        }

        unsetNoticeBoards();
        if (config.highlightClan()) {
            setTOBNoticeBoard();
            setTOANoticeBoard();
        }
    }
}

package gg.embargo.commands;

import gg.embargo.DataManager;
import gg.embargo.EmbargoConfig;
import gg.embargo.commands.embargo.Rank;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;
import java.awt.*;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

@Slf4j
public class CommandManager {
    @Inject
    private ClientThread clientThread;

    @Inject
    private EmbargoConfig config;

    @Inject
    private Client client;

    @Inject
    private DataManager dataManager;

    @Inject
    private ChatCommandManager chatCommandManager;

    private final EventBus eventBus;

    private static final String EMBARGO_COMMAND = "!embargo";

    @Inject
    public CommandManager(Client client, ClientThread clientThread, EventBus eventBus, EmbargoConfig config) {
        this.client = client;
        this.clientThread = clientThread;
        this.eventBus = eventBus;
        this.config = config;
    }

    public void startUp() {
        eventBus.register(this);
        chatCommandManager.registerCommandAsync(EMBARGO_COMMAND, this::processEmbargoLookupChatCommand);
    }

    public void shutDown() {
        eventBus.unregister(this);
        chatCommandManager.unregisterCommand(EMBARGO_COMMAND);
    }

    // Helper method to update chat message safely on the client thread
    private void updateChatMessage(ChatMessage chatMessage, String message) {
        clientThread.invokeLater(() -> {
            chatMessage.getMessageNode().setRuneLiteFormatMessage(message);
            client.refreshChat();
        });
    }

    public void processEmbargoLookupChatCommand(ChatMessage chatMessage, String message) {
        int firstWhitespace = message.indexOf(' ');
        String memberName = (firstWhitespace != -1 && firstWhitespace + 1 < message.length())
                ? message.substring(firstWhitespace + 1)
                : chatMessage.getName().replaceAll("<[^>]*>", "");

        String loadingMessage = new ChatMessageBuilder()
                .append(ChatColorType.HIGHLIGHT)
                .append("Looking up Embargo member...")
                .build();

        updateChatMessage(chatMessage, loadingMessage);

        String finalMemberName = memberName.replace('\u00A0', ' ').trim();
        dataManager.getProfileAsync(finalMemberName, true).thenAccept(embargoProfileData -> {
            // Null checks for safety
            if (embargoProfileData == null
                    || embargoProfileData.get("accountPoints") == null
                    || embargoProfileData.getAsJsonPrimitive("communityPoints") == null
                    || embargoProfileData.getAsJsonPrimitive("currentRank") == null) {
                String memberNotFound = new ChatMessageBuilder()
                        .append(ChatColorType.HIGHLIGHT)
                        .append("Error retrieving data for member: " + finalMemberName)
                        .build();
                updateChatMessage(chatMessage, memberNotFound);
                return;
            }

            String currentRankName = embargoProfileData.getAsJsonPrimitive("currentRank").getAsString();
            String leaderboardPosition = embargoProfileData.getAsJsonObject("leaderboardRank").get("currentPosition")
                    + "/"
                    + embargoProfileData.getAsJsonObject("leaderboardRank").get("totalPositions");
            Color rankColor = Rank.getColorByName(currentRankName);
            Color labelColor = config.chatCommandOutputColor();

            String outputMessage = new ChatMessageBuilder()
                    .append(labelColor, "Member: ")
                    .append(finalMemberName)
                    .append(labelColor, " Rank: ")
                    .append(rankColor, currentRankName)
                    .append(labelColor, " Account Points: ")
                    .append(ChatColorType.HIGHLIGHT)
                    .append(String.valueOf(embargoProfileData.get("accountPoints")))
                    .append(labelColor, " Community Points: ")
                    .append(ChatColorType.HIGHLIGHT)
                    .append(String.valueOf(embargoProfileData.getAsJsonPrimitive("communityPoints")))
                    .append(labelColor, " Leaderboard Rank: ")
                    .append(ChatColorType.HIGHLIGHT)
                    .append(leaderboardPosition)
                    .build();

            updateChatMessage(chatMessage, outputMessage);
        }).exceptionally(ex -> {
            String memberNotFound = new ChatMessageBuilder()
                    .append(ChatColorType.HIGHLIGHT)
                    .append("Member " + finalMemberName + " not found.")
                    .build();
            updateChatMessage(chatMessage, memberNotFound);
            return null;
        });
    }

}

package gg.embargo.commands.embargo;

import lombok.Getter;

import java.awt.*;

public enum Rank {
    BRONZE("Bronze", Color.orange),
    IRON("Iron", Color.darkGray),
    STEEL("Steel", Color.lightGray),
    MITHRIL("Mithril", Color.blue),
    ADAMANT("Adamant", Color.green),
    RUNE("Rune", Color.cyan),
    DRAGON("Dragon", Color.red),
    BEAST("Beast", Color.yellow);

    private final String name;
    @Getter
    private final Color color;

    Rank(String name, Color color) {
        this.name = name;
        this.color = color;
    }

    public static Color getColorByName(String name) {
        for (Rank rank : values()) {
            if (rank.name.equalsIgnoreCase(name)) {
                return rank.color;
            }
        }
        return Color.WHITE;
    }
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gg.embargo.collections;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class PlayerDataSubmission
{
    private String username;
    private String profile;
    private PlayerData data;
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gg.embargo.collections;

import lombok.Value;
import net.runelite.client.config.RuneScapeProfileType;

@Value
public class PlayerProfile
{
    String username;
    RuneScapeProfileType profileType;
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gg.embargo.collections;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PlayerData
{
    public List<Map<String, Map<String, Object>>> rawClogItems = new ArrayList<>();
}
package gg.embargo.collections;

/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.google.gson.Gson;
import com.google.gson.JsonParseException;
import gg.embargo.EmbargoConfig;
import gg.embargo.manifest.Manifest;
import gg.embargo.manifest.ManifestManager;
import gg.embargo.ui.EmbargoPanel;
import gg.embargo.ui.SyncButtonManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import okhttp3.*;

import javax.inject.Inject;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Slf4j
public class CollectionLogManager {

    private final int VARBITS_ARCHIVE_ID = 14;
    private static final String PLUGIN_USER_AGENT = "Embargo Runelite Plugin";

    private static final String SUBMIT_URL = "https://embargo.gg/api/runelite/uploadcollectionlog";
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    // Limit playerDataMap size to prevent unbounded growth - LRU eviction
    private static final int MAX_PLAYER_DATA_CACHE_SIZE = 10;
    private final Map<PlayerProfile, PlayerData> playerDataMap = new LinkedHashMap<PlayerProfile, PlayerData>(
            MAX_PLAYER_DATA_CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<PlayerProfile, PlayerData> eldest) {
            return size() > MAX_PLAYER_DATA_CACHE_SIZE;
        }
    };
    private int cyclesSinceSuccessfulCall = 0;
    // Use instance field instead of static to allow proper cleanup per instance
    private final List<Map<String, Map<String, Object>>> rawClogItems = new ArrayList<>();
    private int tickCollectionLogScriptFired = -1;

    private SyncButtonManager syncButtonManager;

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private ScheduledExecutorService scheduledExecutorService;

    @Inject
    private EmbargoPanel embargoPanel;

    @Inject
    private Gson gson;

    @Inject
    private EmbargoConfig config;

    @Inject
    private Manifest manifest;

    @Inject
    private ManifestManager manifestManager;

    @Inject
    private ItemManager itemManager;

    private final Client client;
    private final ClientThread clientThread;
    private final EventBus eventBus;

    @Inject
    private CollectionLogManager(
            Client client,
            ClientThread clientThread,
            EventBus eventBus) {
        this.client = client;
        this.clientThread = clientThread;
        this.eventBus = eventBus;
    }

    public void startUp(SyncButtonManager mainSyncButtonManager) {
        eventBus.register(this);
        manifestManager.getLatestManifest();
        syncButtonManager = mainSyncButtonManager;

        clientThread.invoke(() -> {
            if (client.getIndexConfig() == null || client.getGameState().ordinal() < GameState.LOGIN_SCREEN.ordinal()) {
                return false;
            }
            manifestManager.getLatestManifest();
            return true;
        });

    }

    public void shutDown() {
        eventBus.unregister(this);
        rawClogItems.clear();
        playerDataMap.clear();
        syncButtonManager.shutDown();
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        // Submit the collection log data two ticks after the first script prefires
        if (tickCollectionLogScriptFired != -1 &&
                tickCollectionLogScriptFired + 2 < client.getTickCount()) {
            tickCollectionLogScriptFired = -1;
            if (manifestManager.getManifest() == null) {
                client.addChatMessage(ChatMessageType.GAMEMESSAGE, "Embargo",
                        "Failed to sync collection log. Try restarting the Embargo plugin.", "Embargo");
                return;
            }
            scheduledExecutorService.execute(this::submitTask);
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState state = gameStateChanged.getGameState();
        switch (state) {
            // When hopping or logging out, we need to clear any state related to the player
            case HOPPING:
            case LOGGING_IN:
            case CONNECTION_LOST:
            case LOGIN_SCREEN: // Add this case to handle explicit logout
                rawClogItems.clear();
                embargoPanel.logOut();
                break;
        }
    }

    // CollectionLog Subscribe
    @Subscribe
    public void onScriptPreFired(ScriptPreFired preFired) {
        if (syncButtonManager.isSyncAllowed() && preFired.getScriptId() == 4100) {
            tickCollectionLogScriptFired = client.getTickCount();
            Object[] args = preFired.getScriptEvent().getArguments();
            int itemId = (int) args[1];
            int itemCount = (int) args[2];

            String itemName;
            try {
                ItemComposition ic = itemManager.getItemComposition(itemId);
                itemName = ic.getName();
            } catch (Exception e) {
                itemName = String.valueOf(itemId);
            }

            // Remove any existing entry for this itemName
            String finalItemName = itemName;
            rawClogItems.removeIf(map -> map.containsKey(finalItemName));

            // Add the new entry
            Map<String, Object> itemData = new HashMap<>();
            itemData.put("id", itemId);
            itemData.put("quantity", itemCount);

            Map<String, Map<String, Object>> entry = new HashMap<>();
            entry.put(itemName, itemData);

            rawClogItems.add(entry);
        }
    }

    synchronized public void submitTask() {
        // If sync hasn't been toggled to be allowed
        if (!syncButtonManager.isSyncAllowed()) {
            return;
        }

        // TODO: do we want other GameStates?
        if (client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        if (client.getLocalPlayer() == null) {
            log.debug("Skipped due to local player being null");
            return;
        }

        String username = client.getLocalPlayer().getName();
        RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);
        PlayerProfile profileKey = new PlayerProfile(username, profileType);

        PlayerData newPlayerData = getPlayerData();
        PlayerData oldPlayerData = playerDataMap.computeIfAbsent(profileKey, k -> new PlayerData());

        // Do not send if slot data wasn't generated
        if (newPlayerData.rawClogItems.isEmpty()) {
            return;
        }

        submitPlayerData(profileKey, newPlayerData, oldPlayerData);
    }

    private PlayerData getPlayerData() {
        PlayerData out = new PlayerData();
        out.rawClogItems = rawClogItems;
        return out;
    }

    private void merge(PlayerData oldPlayerData, PlayerData delta) {
        oldPlayerData.rawClogItems = delta.rawClogItems;
    }

    private void submitPlayerData(PlayerProfile profileKey, PlayerData delta, PlayerData old) {
        // If cyclesSinceSuccessfulCall is not a perfect square, we should not try to
        // submit.
        // This gives us quadratic backoff.
        cyclesSinceSuccessfulCall += 1;
        if (Math.pow((int) Math.sqrt(cyclesSinceSuccessfulCall), 2) != cyclesSinceSuccessfulCall) {
            return;
        }

        PlayerDataSubmission submission = new PlayerDataSubmission(
                profileKey.getUsername(),
                profileKey.getProfileType().name(),
                delta);

        Request request = new Request.Builder()
                .addHeader("User-Agent", PLUGIN_USER_AGENT)
                .url(SUBMIT_URL)
                .post(RequestBody.create(JSON, gson.toJson(submission)))
                .build();

        Call call = okHttpClient.newCall(request);
        call.timeout().timeout(3, TimeUnit.SECONDS);
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.debug("Failed to submit: ", e);
                clientThread.invokeLater(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "Embargo",
                        "Failed to upload data to Embargo.", "Embargo"));
            }

            @Override
            public void onResponse(Call call, Response response) {
                try (response) {
                    if (!response.isSuccessful()) {
                        log.debug("Failed to submit: {}", response.code());
                        clientThread.invokeLater(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
                                "<col=ff9000>[Embargo]</col> Failed to upload collection log data.", null));
                        return;
                    }
                    merge(old, delta);
                    cyclesSinceSuccessfulCall = 0;
                    clientThread.invokeLater(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
                            "<col=ff9000>[Embargo]</col> Collection log synced successfully.", null));
                } finally {
                    response.close();
                }
            }
        });
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        String CONFIG_GROUP = "embargo";
        if (!event.getGroup().equals(CONFIG_GROUP)) {
            return;
        }

        if (config.showCollectionLogSyncButton()) {
            syncButtonManager.startUp();
        } else {
            syncButtonManager.shutDown();
        }
    }
}

/*
 * Copyright (c) 2025, andmcadams
 * Modified by Sharpienero for Embargo
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gg.embargo.manifest;

import lombok.Data;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.List;

@Data
public class Manifest
{
    // misc
    final float version = -1;

    //Varp/varb trackable items
    final int[] varbits = new int[0];
    final int[] varps = new int[0];

    //Untrackable items
    public final List<Integer> untrackableItems = new ArrayList<>();

    //Raid/Minigame completion messages
    public Map<String, String> raidCompletionMessages = new HashMap<>();
    public Map<String, String> minigameCompletionMessages = new HashMap<>();

    //Collection log
    public final ArrayList<Integer> collections = new ArrayList<>();

    //Easter egg
    public Map<String, String> itemRenames = new HashMap<>();
    public Map<String, String> npcRenames = new HashMap<>();

}
package gg.embargo.manifest;

import com.google.gson.*;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
@Singleton
public class ManifestManager {

    @Inject
    private Gson gson;

    @Inject
    private OkHttpClient okHttpClient;

    @Getter
    @Setter
    private Manifest manifest;

    @Getter
    @Setter
    private float lastCheckedManifestVersion = -1;

    // Add timestamp for last check
    private long lastCheckTimestamp = 0;

    // Add a flag to track if a request is in progress
    private final AtomicBoolean requestInProgress = new AtomicBoolean(false);

    // 3 minutes in milliseconds
    private static final long CHECK_INTERVAL = 3 * 60 * 1000;

    //private static final String MOCK_API_URI = "https://a278d141-927f-433b-8e4b-6d994067900d.mock.pstmn.io/api/";
    private static final String API_URI = "https://embargo.gg/api/";
    private static final String MANIFEST_ENDPOINT = API_URI + "runelite/manifest";

    public Manifest getLatestManifest() {
        long currentTime = System.currentTimeMillis();

        // Only proceed if 3 minutes have passed since the last check AND no request is
        // in progress
        if (currentTime - lastCheckTimestamp < CHECK_INTERVAL || !requestInProgress.compareAndSet(false, true)) {
            log.debug(
                    "Skipping manifest check - last check was less than 3 minutes ago or request already in progress");
            return manifest; // Return the current manifest instead of null
        }

        try {
            Request r = new Request.Builder()
                    .url(MANIFEST_ENDPOINT)
                    .header("Cache-Control", "no-cache, no-store")
                    .header("Pragma", "no-cache")
                    .cacheControl(new CacheControl.Builder().noCache().noStore().build())
                    .build();

            okHttpClient.newCall(r).enqueue(new Callback() {
                @Override
                public void onFailure(@NonNull Call call, @NonNull IOException e) {
                    log.error("Error retrieving manifest", e);
                    requestInProgress.set(false); // Reset the flag
                }

                @Override
                public void onResponse(@NonNull Call call, @NonNull Response response) {
                    try (response; response) {
                        if (response.isSuccessful()) {
                            try {
                                if (response.body() == null) {
                                    log.error("Manifest request succeeded but returned empty body");
                                    return;
                                }

                                setManifest(gson.fromJson(
                                        new StringReader(new String(response.body().bytes(), StandardCharsets.UTF_8)),
                                        Manifest.class));
                                log.debug("Set manifest");

                                // Update the timestamp
                                lastCheckTimestamp = currentTime;

                                if (lastCheckedManifestVersion != manifest.getVersion()) {
                                    log.debug("Setting manifest version to {}", manifest.getVersion());
                                    lastCheckedManifestVersion = manifest.getVersion();
                                }
                            } catch (JsonSyntaxException e) {
                                log.error(e.getLocalizedMessage());
                            } catch (IOException e) {
                                log.error("Error reading response body", e);
                            }
                        } else {
                            log.error("Manifest request returned with status {}", response.code());
                            if (response.body() == null) {
                                log.error("Manifest request returned empty body");
                            } else {
                                log.error(response.body().toString());
                            }
                        }
                    } finally {
                        requestInProgress.set(false); // Reset the flag
                    }
                }
            });
        } catch (IllegalArgumentException e) {
            log.error("Bad URL given: {}", e.getLocalizedMessage());
            requestInProgress.set(false); // Reset the flag
        }

        log.debug("Returning set manifest (not null)");
        return manifest; // Return current manifest instead of null
    }
}
package gg.embargo;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class Embargo
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(EmbargoPlugin.class);
		RuneLite.main(args);
	}
}
