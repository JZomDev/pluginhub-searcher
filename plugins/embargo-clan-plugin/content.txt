package gg.embargo;

import net.runelite.client.config.*;

import java.awt.Color;

@ConfigGroup("embargo")
public interface EmbargoConfig extends Config
{
    @ConfigSection(
            name = "Raid Notice Boards",
            description = "Section that houses Notice Board options",
            position = 1
    )
    String noticeBoardSettings = "NoticeBoardSettings";


    @ConfigItem(
            keyName = "highlightClan",
            name = "Highlight Embargo Members",
            description = "Whether or not to highlight clan chat members' names on notice boards (ToA, Tob)",
            position = 1,
            section = noticeBoardSettings
    )
    default boolean highlightClan()
    {
        return true;
    }

    @ConfigItem(
            keyName = "clanColor",
            name = "Highlight Color",
            description = "The color with which to highlight names from your current clan chat",
            position = 2,
            section = noticeBoardSettings
    )
    default Color clanColor()
    {
        return new Color(53, 201, 255);
    }

    @ConfigSection(
            name = "Collection Log Sync Button",
            description = "Add a button to the collection log interface to sync your collection log with Embargo",
            position = 2
    )
    String collectionLogSettings = "CollectionLogSettings";

    @ConfigItem(
            keyName = "showCollectionLogSyncButton",
            name = "Show Collection Log Sync Button",
            description = "Whether or not to render the Embargo collection log sync button",
            position = 1,
            section = collectionLogSettings
    )
    default boolean showCollectionLogSyncButton() { return true; }

    @ConfigSection(
            name = "Clan Easter Eggs",
            description = "Enables fun item name replacements like 'Dragon warhammer' to 'Bonker'",
            position = 3
    )
    String easterEggSettings = "EasterEggSettings";

    @ConfigItem(
        keyName = "enableClanEasterEggs",
        name = "Enable Easter Eggs",
        description = "A top level control to enable/disable the feature",
        position = 3,
        section = easterEggSettings
    )
    default boolean enableClanEasterEggs() {
        return true;
    }


    @ConfigItem(
            keyName = "enableItemRenames",
            name = "Enable Item Renames",
            description = "Enables item name replacements like 'Dragon warhammer' to 'Bonker'",
            position = 4,
            section = easterEggSettings
    )
    default boolean enableItemRenames() {
        return true;
    }

    @ConfigItem(
            keyName = "enableNpcRenames",
            name = "Enable NPC Renames",
            description = "Enables NPC name changes, like 'Pestilent Bloat' to 'Dr D1sconnect'",
            position = 5,
            section = easterEggSettings
    )
    default boolean enableNpcRenames() {
        return true;
    }

    @ConfigItem(
            keyName = "enableCustomSounds",
            name = "Enable Custom Sounds",
            description = "Enables custom sounds; e.g white light @ tob/purple @ tob",
            position = 6,
            section = easterEggSettings
    )
    default boolean enableCustomSounds() {
        return true;
    }

    @Range(
            min=0,
            max=200
    )
    @ConfigItem(
            keyName = "easterEggVolume",
            name = "Sound volume",
            description = "Controls the volume",
            position = 7,
            section = easterEggSettings
    )
    default int announcementVolume()
    {
        return 60;
    }

}


package gg.embargo;

import com.google.inject.Provides;
import gg.embargo.collections.*;
import gg.embargo.eastereggs.NPCRenameManager;
import gg.embargo.eastereggs.SoundManager;
import gg.embargo.manifest.ManifestManager;
import gg.embargo.ui.EmbargoPanel;
import gg.embargo.eastereggs.ItemRenameManager;
import gg.embargo.ui.SyncButtonManager;
import gg.embargo.noticeboard.NoticeBoardManager;
import gg.embargo.untrackables.UntrackableItemManager;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import net.runelite.http.api.loottracker.LootRecordType;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BiConsumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@PluginDescriptor(
	name = "Embargo Clan",
	description = "A plugin to sync your account with Embargo",
	tags = {"embargo", "clan", "embargo.gg", "ironman"}
)
public class EmbargoPlugin extends Plugin {

	private static final String CONFIG_GROUP = "embargo";
	private static final int SECONDS_BETWEEN_UPLOADS = 30;
	private static final int SECONDS_BETWEEN_PROFILE_UPDATES = 15;
	private static final Pattern COLLECTION_LOG_ITEM_REGEX = Pattern.compile("New item added to your collection log: (.*)");

	@Inject
	private DataManager dataManager;

	@Inject
	private ClientThread clientThread;

	@Inject
	private Client client;

	@Inject
	private EmbargoConfig config;

	@Inject
	private EmbargoPanel embargoPanel;

	@Inject
	private NoticeBoardManager noticeBoardManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private SyncButtonManager syncButtonManager;

	@Inject
	private CollectionLogManager clogManager;

	@Inject
	private UntrackableItemManager untrackableItemManager;

	@Inject
	private ItemRenameManager itemRenameManager;

	@Inject
	private NPCRenameManager npcRenameManager;

	@Inject
	private SoundManager soundManager;

	@Inject
	public ManifestManager manifestManager;

	private RuneScapeProfileType lastProfile;

	private NavigationButton navButton;

	private final Map<String, Integer> skillLevelCache = new HashMap<>();

	AtomicBoolean isUsernameRegistered = new AtomicBoolean(false);

	@Provides
	EmbargoConfig getConfig(ConfigManager configManager) {
		return configManager.getConfig(EmbargoConfig.class);
	}

	@Override
	protected void startUp() {
		log.info("Embargo Clan plugin started!");

		if (dataManager.stopTryingForAccount.get()) {
			return;
		}

		initializePanel();
		initializeManagers();
		
		lastProfile = null;
		dataManager.resetVarbsAndVarpsToCheck();
		skillLevelCache.clear();
		dataManager.getManifest();

		itemRenameManager.setupMenuRenames();

		if (client != null) {
			if (client.getGameState() == GameState.LOGGED_IN) {
				dataManager.isUserRegisteredAsync(client.getLocalPlayer().getName(), isRegistered -> {
					if (isRegistered) {
						embargoPanel.updateLoggedIn(false);
					}
				});
			}
		}
	}

	private void initializePanel() {
		embargoPanel = injector.getInstance(EmbargoPanel.class);
		embargoPanel.init();
		embargoPanel.updateLoggedIn(false);
		
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");
		navButton = NavigationButton.builder()
				.tooltip("Embargo Clan")
				.icon(icon)
				.priority(0)
				.panel(embargoPanel)
				.build();

		clientToolbar.addNavigation(navButton);
	}
	
	private void initializeManagers() {
		if (config != null && config.showCollectionLogSyncButton()) {
			syncButtonManager.startUp();
		}

		clogManager.startUp(syncButtonManager);
		untrackableItemManager.startUp();
		noticeBoardManager.startUp();

		if (config != null && config.highlightClan()) {
			noticeBoardManager.setNoticeBoards();
		}

		if (config != null && config.enableClanEasterEggs()) {
			itemRenameManager.startUp();
			npcRenameManager.startUp();
			soundManager.startUp();
		}
	}

	@Override
	protected void shutDown() {
		log.info("Embargo Clan plugin stopped!");
		
		dataManager.clearData();
		embargoPanel.reset();
		clientToolbar.removeNavigation(navButton);
		
		shutDownManagers();

		embargoPanel = null;
		navButton = null;
	}
	
	private void shutDownManagers() {
		noticeBoardManager.shutDown();
		clogManager.shutDown();
		untrackableItemManager.shutDown();
		syncButtonManager.shutDown();
		itemRenameManager.shutDown();
		npcRenameManager.shutDown();
		soundManager.shutDown();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		GameState gameState = event.getGameState();
		if (gameState == GameState.LOADING) return;
		
		if (gameState == GameState.LOGGED_IN && !embargoPanel.isLoggedIn) {
			log.debug("inside of condition, handling loggedIn");
			handleLoggedIn();
		} else if (gameState == GameState.LOGIN_SCREEN) {
			handleLoggedOut();
		}
	}
	
	private void handleLoggedIn() {
		clientThread.invokeLater(() -> {
			if (client == null || dataManager.stopTryingForAccount.get()) {
				return false;
			}

			if (isUsernameRegistered.get()) {
				embargoPanel.updateLoggedIn(true);
				return true;
			}

			Player localPlayer = client.getLocalPlayer();
			if (localPlayer != null) {
				String username = localPlayer.getName();

				dataManager.isUserRegisteredAsync(username, isRegistered -> {
					if (isRegistered) {
						embargoPanel.updateLoggedIn(true);
						isUsernameRegistered.set(true);
					}
				});
			}
			return isUsernameRegistered.get();
		});
	}
	
	private void handleLoggedOut() {
		log.debug("User logged out");
    
		// Clear both panel references
		if (embargoPanel != null) {
			SwingUtilities.invokeLater(() -> embargoPanel.logOut());
		} else {
			log.debug("embargoPanel is null!!!");
		}
    
		// Also clear the panel reference (which is different from embargoPanel)
		if (embargoPanel != null) {
			embargoPanel.reset();
			embargoPanel.updateLoggedIn(false);
		}
    
		// Clear data in DataManager to ensure complete reset
		dataManager.clearData();
    
		// Reset skill cache
		skillLevelCache.clear();
	}

	@Schedule(
			period = SECONDS_BETWEEN_UPLOADS,
			unit = ChronoUnit.SECONDS,
			asynchronous = true
	)
	public void ensureLatestManifest() {
		if (manifestManager.getLatestManifest() != null) {
			if (!(manifestManager.getLastCheckedManifestVersion() == manifestManager.getLatestManifest().getVersion())) {
				manifestManager.getLatestManifest();
			}
		}
	}

	@Schedule(
			period = SECONDS_BETWEEN_UPLOADS,
			unit = ChronoUnit.SECONDS,
			asynchronous = true
	)
	public void submitToAPI() {
		if (client == null) {
			return;
		}
		
		GameState gameState = client.getGameState();
		if (gameState != GameState.HOPPING && gameState != GameState.LOGIN_SCREEN) {
			dataManager.submitToAPI();
			updatePlayerRegistrationStatus();
		} else {
			//log.debug("User is hopping or logged out, do not send data");
			embargoPanel.logOut();
		}
	}
	
	private void updatePlayerRegistrationStatus() {
		if (dataManager.stopTryingForAccount.get()) {
			return;
		}
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer != null) {
			String username = localPlayer.getName();
			dataManager.isUserRegisteredAsync(username, isRegistered -> {
				if (isRegistered) {
					log.debug("updateProfileAfterLoggedIn Member registered");
					embargoPanel.updateLoggedIn(true);
				}
			});
		}
	}

	@Schedule(
		period = SECONDS_BETWEEN_PROFILE_UPDATES,
		unit = ChronoUnit.SECONDS,
		asynchronous = true
	)
	public void checkProfileChanged() {
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer != null && client.getGameState() == GameState.LOGGED_IN) {
			embargoPanel.updateLoggedIn(true);
			clientThread.invokeLater(this::checkProfileChange);
		}
	}

	@Getter
	public enum MinigameCompletionMessages {
		WINTERTODT("Your subdued Wintertodt count is:"),
		TEMPOROSS("Your Tempoross kill count is:"),
		GOTR("Amount of rifts you have closed:"),
		SOUL_WARS("team has defeated the Avatar"),
		BARBARIAN_ASSAULT("Wave 10 duration"),
		VOLCANIC_MINE("Your fragments disintegrate");

		private final String completionMessage;

		MinigameCompletionMessages(String completionMessage) {
			this.completionMessage = completionMessage;
		}
	}

	@Getter
	public enum RaidCompletionMessages {
		COX("Congratulations - your raid is complete!"),
		COX_CM("Your completed Chambers of Xeric Challenge Mode count is:"),
		TOB("Theatre of Blood total completion time:"),
		HM_TOB("Your completed Theatre of Blood: Hard Mode count is:"),
		TOA("Tombs of Amascut total completion time:"),
		TOA_EXPERT("Tombs of Amascut: Expert Mode total completion time:");

		private final String completionMessage;

		RaidCompletionMessages(String completionMessage) {
			this.completionMessage = completionMessage;
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage) {
		if (client == null || manifestManager.getLatestManifest() == null) return;

		Player player = client.getLocalPlayer();
		if (player == null) return;

		String message = chatMessage.getMessage();
		ChatMessageType messageType = chatMessage.getType();
		RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);
		
		// Only process for standard profile
		if (profileType != RuneScapeProfileType.STANDARD) {
			return;
		}
		
		// Check for collection log items
		if (messageType == ChatMessageType.GAMEMESSAGE) {
			Matcher matcher = COLLECTION_LOG_ITEM_REGEX.matcher(message);
			if (matcher.matches()) {
				String obtainedItemName = Text.removeTags(matcher.group(1));
				dataManager.uploadCollectionLogUnlock(obtainedItemName, player.getName());
			}
		}
		
		// Check for activity completions
		if (messageType == ChatMessageType.GAMEMESSAGE || 
			messageType == ChatMessageType.FRIENDSCHATNOTIFICATION || 
			messageType == ChatMessageType.SPAM) {

			if (processCompletionMessages(manifestManager.getLatestManifest().getRaidCompletionMessages(), message,
					(name, _message) -> dataManager.uploadRaidCompletion(name, _message))) {
				//return early as it saves time in case it gets processed here, otherwise it's most likely a minigame completion message or unrelated
				return;
			}

			processCompletionMessages(manifestManager.getLatestManifest().minigameCompletionMessages, message,
					(name, _message) -> dataManager.uploadMinigameCompletion(name, _message));
		}
	}

	private boolean processCompletionMessages(Map<String, String> messageMap, String chatMessage, 
											 BiConsumer<String, String> uploadAction) {
		for (Map.Entry<String, String> entry : messageMap.entrySet()) {
			String name = entry.getKey();
			String completionMessage = entry.getValue();
			
			if (chatMessage.contains(completionMessage)) {
				log.debug("Sending API request for completed activity");
				uploadAction.accept(name, chatMessage);
				return true;
			}
		}
		return false;
	}

	public void checkProfileChange() {
		if (client == null) {
			return;
		}

		RuneScapeProfileType currentProfile = RuneScapeProfileType.getCurrent(client);
		boolean isStandardProfile = currentProfile == RuneScapeProfileType.STANDARD;
		boolean profileChanged = isStandardProfile && currentProfile != lastProfile;
		boolean dataAvailable = dataManager.getVarbitsToCheck() != null && dataManager.getVarpsToCheck() != null;
		boolean isLoggedIn = client.getGameState() == GameState.LOGGED_IN;
		
		if (profileChanged && dataAvailable && isLoggedIn) {
			// Profile change, we should clear the dataManager and do a new initial dump
			log.debug("Profile changed to standard. Reloading all data and updating profile");
			lastProfile = currentProfile;
			dataManager.clearData();
			dataManager.loadInitialData();
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged statChanged) {
		Skill skill = statChanged.getSkill();
		if (skill == null) {
			return;
		}
		
		String skillName = skill.getName();
		int newLevel = statChanged.getLevel();
		Integer cachedLevel = skillLevelCache.get(skillName);
		
		if (cachedLevel == null || cachedLevel != newLevel) {
			skillLevelCache.put(skillName, newLevel);
			dataManager.storeSkillChanged(skillName, newLevel);
		}
	}

	@Subscribe
	public void onLootReceived(final LootReceived event) {
		LootRecordType eventType = event.getType();
		if (eventType != LootRecordType.NPC && eventType != LootRecordType.EVENT) {
			return;
		}

		String npcName = event.getName();
		if (dataManager.shouldTrackLoot(npcName)) {
			log.debug("Player killed {}", npcName);
			dataManager.uploadLoot(event);
		} else {
			log.debug("Player killed {}, nothing to log", npcName);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals(CONFIG_GROUP)) {
			return;
		}

		// Update notice boards based on config
		noticeBoardManager.unsetNoticeBoards();
		if (config.highlightClan()) {
			noticeBoardManager.setTOBNoticeBoard();
			noticeBoardManager.setTOANoticeBoard();
		}

		// Update sync button based on config
		if (config.showCollectionLogSyncButton()) {
			syncButtonManager.startUp();
		} else {
			syncButtonManager.shutDown();
		}
		
		// Handle item rename config changes
		if (event.getKey().equals("enableClanEasterEggs")) {
			if (config.enableClanEasterEggs()) {
				itemRenameManager.startUp();
				npcRenameManager.startUp();
			} else {
				itemRenameManager.shutDown();
				npcRenameManager.shutDown();
			}
		}
	}


}

package gg.embargo.eastereggs;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import gg.embargo.EmbargoConfig;
import gg.embargo.manifest.ManifestManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

@Slf4j
public class NPCRenameManager {

    private final EventBus eventBus;
    private final EmbargoConfig config;
    private final ManifestManager manifestManager;

    @Inject
    public NPCRenameManager(EventBus eventBus, EmbargoConfig config, ManifestManager manifestManager) {
        this.eventBus = eventBus;
        this.config = config;
        this.manifestManager = manifestManager;
    }

    private final HashMap<String, String> npcListHashMap = new HashMap<>();
    private static final Set<MenuAction> NPC_MENU_ACTIONS = ImmutableSet.of(
            MenuAction.NPC_FIRST_OPTION,
            MenuAction.NPC_SECOND_OPTION,
            MenuAction.NPC_THIRD_OPTION,
            MenuAction.NPC_FOURTH_OPTION,
            MenuAction.NPC_FIFTH_OPTION,
            MenuAction.WIDGET_TARGET_ON_NPC,
            MenuAction.EXAMINE_NPC);

    private static final ImmutableMap<String, String> DEFAULT_NPC_RENAMES = ImmutableMap.<String, String>builder().build();
    private final Map<String, String> customNPCRemaps = new HashMap<>();

    private boolean manifestFetchAttempted = false;

    public boolean featureEnabled() {
        return config.enableClanEasterEggs() && config.enableNpcRenames();
    }

    @Subscribe
    protected void onMenuEntryAdded(MenuEntryAdded event) {

        if (!featureEnabled()) {
            return;
        }

        if (manifestManager.getManifest() == null) {
            manifestManager.getLatestManifest();
            return;
        }

        // Check if manifest is empty and fetch if needed
        if (manifestManager.getManifest().getItemRenames() == null) {
            manifestManager.getLatestManifest();
        }

        parseManifest();
        MenuEntry entry = event.getMenuEntry();


        if (NPC_MENU_ACTIONS.contains(entry.getType())) {
            remapMenuEntryText(entry, (HashMap<String, String>) customNPCRemaps);  // Use customNPCRemaps instead of npcListHashMap
        }
    }

    public void startUp() {
        eventBus.register(this);

        if (!featureEnabled()) return;

        setupMenuRenames();
        manifestManager.getLatestManifest(); // Fetch manifest on startup
    }

    public void shutDown() {
        customNPCRemaps.clear();
        eventBus.unregister(this);
    }

    public void setupMenuRenames() {
        customNPCRemaps.clear();
        customNPCRemaps.putAll(DEFAULT_NPC_RENAMES);
    }

    public void parseManifest() {
        if (manifestManager.getManifest().getNpcRenames() == null || manifestManager.getManifest().getNpcRenames().isEmpty()) {
            if (!manifestFetchAttempted) {
                manifestFetchAttempted = true;
                manifestManager.getLatestManifest();
                log.debug("manifest.npcRenames is empty, attempting to refetch");
            }
            return;
        }

        // Clear both maps
        customNPCRemaps.clear();
        npcListHashMap.clear();
        
        // Add default renames
        customNPCRemaps.putAll(DEFAULT_NPC_RENAMES);

        // Add manifest renames to both maps
        for (Map.Entry<String, String> entry : manifestManager.getManifest().getNpcRenames().entrySet()) {
            String originalName = entry.getKey();
            String newName = entry.getValue();
            customNPCRemaps.put(originalName, newName);
            npcListHashMap.put(originalName, newName);
            //log.debug("NPCRename: Setting {} to {}", originalName, newName);
        }
    }

    private void remapMenuEntryText(MenuEntry menuEntry, HashMap<String, String> map) {
        String target = menuEntry.getTarget();
        String cleanTarget;
        
        NPC npc = menuEntry.getNpc();
        cleanTarget = npc != null ? Text.removeTags(npc.getName()) : Text.removeTags(target);
        
        String replacement = customNPCRemaps.get(cleanTarget);
        if (replacement != null) {
            menuEntry.setTarget(target.replace(cleanTarget, replacement));
        }
    }
}



package gg.embargo.eastereggs;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import gg.embargo.EmbargoConfig;
import gg.embargo.manifest.ManifestManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;
import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

@Slf4j
@Singleton
public class ItemRenameManager {

    private final EventBus eventBus;
    private final EmbargoConfig config;
    private final ManifestManager manifestManager;

    @Inject
    public ItemRenameManager(EventBus eventBus, EmbargoConfig config, ManifestManager manifestManager) {
        this.eventBus = eventBus;
        this.config = config;
        this.manifestManager = manifestManager;
    }

    private boolean manifestFetchAttempted = false;

    private static final Set<MenuAction> ITEM_MENU_ACTIONS = ImmutableSet.of(
            MenuAction.GROUND_ITEM_FIRST_OPTION, MenuAction.GROUND_ITEM_SECOND_OPTION,
            MenuAction.GROUND_ITEM_THIRD_OPTION, MenuAction.GROUND_ITEM_FOURTH_OPTION,
            MenuAction.GROUND_ITEM_FIFTH_OPTION, MenuAction.EXAMINE_ITEM_GROUND,
            // Inventory + Using Item on Players/NPCs/Objects
            MenuAction.CC_OP, MenuAction.CC_OP_LOW_PRIORITY, MenuAction.WIDGET_TARGET,
            MenuAction.WIDGET_TARGET_ON_PLAYER, MenuAction.WIDGET_TARGET_ON_NPC,
            MenuAction.WIDGET_TARGET_ON_GAME_OBJECT, MenuAction.WIDGET_TARGET_ON_GROUND_ITEM,
            MenuAction.WIDGET_TARGET_ON_WIDGET);

    // Default item name remappings
    private static final ImmutableMap<String, String> DEFAULT_ITEM_REMAP = ImmutableMap.<String, String>builder().build();

    // Map for custom renamings
    private final Map<String, String> customItemRemap = new HashMap<>();

    public boolean featureEnabled() {
        return config.enableClanEasterEggs() && config.enableItemRenames();
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event) {
        // Only process if easter eggs are enabled
        if (!featureEnabled()) {
            return;
        }

        if (manifestManager.getManifest() == null) {
            manifestManager.getLatestManifest();
            return;
        }

        // Check if manifest is empty and fetch if needed
        if (manifestManager.getManifest().getItemRenames() == null) {
            manifestManager.getLatestManifest();
        }

        parseManifest();
        
        MenuEntry entry = event.getMenuEntry();
        if (ITEM_MENU_ACTIONS.contains(entry.getType())) {
            remapMenuEntryText(entry, customItemRemap);
        }
    }

    public void startUp() {
        eventBus.register(this);

        if (!featureEnabled()) return;

        setupMenuRenames();
        manifestManager.getLatestManifest(); // Fetch manifest on startup
    }

    public void shutDown() {
        customItemRemap.clear();
        eventBus.unregister(this);
    }

    public void setupMenuRenames() {
        customItemRemap.clear();
        customItemRemap.putAll(DEFAULT_ITEM_REMAP);
    }

    public void parseManifest() {
        if (manifestManager.getManifest().getItemRenames() == null || manifestManager.getManifest().getItemRenames().isEmpty()) {
            if (!manifestFetchAttempted) {
                log.debug("manifest.itemRenames is empty, attempting to refetch");
            }
            return;
        }

        for (Map.Entry<String, String> entry : manifestManager.getManifest().getItemRenames().entrySet()) {
            String originalName = entry.getKey();
            String newName = entry.getValue();
            customItemRemap.put(originalName, newName);
        }
    }

    /**
     * Remaps a menu entry's text if the target matches an entry in the provided map.
     * 
     * @param menuEntry The menu entry to modify
     * @param map The map of item names to replacement item names
     */
    private void remapMenuEntryText(MenuEntry menuEntry, Map<String, String> map) {
        String target = menuEntry.getTarget();
        String cleanTarget;
        
        NPC npc = menuEntry.getNpc();
        cleanTarget = npc != null ? Text.removeTags(npc.getName()) : Text.removeTags(target);
        
        String replacement = map.get(cleanTarget);
        if (replacement != null) {
            menuEntry.setTarget(target.replace(cleanTarget, replacement));
        }
    }
}

package gg.embargo.eastereggs;

import java.io.FileWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import gg.embargo.eastereggs.sounds.RandomSoundUtility;
import gg.embargo.eastereggs.sounds.Sound;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.util.Text;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

@Slf4j
public abstract class SoundFileManager
{

    private static final File DOWNLOAD_DIR = new File(RuneLite.RUNELITE_DIR.getPath() + File.separator + "embargo-sounds");
    private static final String DELETE_WARNING_FILENAME = "EXTRA_FILES_WILL_BE_DELETED_BUT_FOLDERS_WILL_REMAIN";
    private static final String SOUNDVERSION_FILENAME = "SOUNDVERSION";
    private static final File DELETE_WARNING_FILE = new File(DOWNLOAD_DIR, DELETE_WARNING_FILENAME);
    private static final HttpUrl RAW_GITHUB = HttpUrl.parse("https://raw.githubusercontent.com/sharpienero/embargo-plugin/sounds");

    private static boolean isUpdating = false;

    private static Map<String, String[]> soundDirectoryMap = new HashMap<>();

    @SuppressWarnings("ResultOfMethodCallIgnored")
    public static void ensureDownloadDirectoryExists()
    {
        if (!DOWNLOAD_DIR.exists())
        {
            DOWNLOAD_DIR.mkdirs();
        }
        try
        {
            DELETE_WARNING_FILE.createNewFile();
        }
        catch (IOException ignored)
        {
        }
    }

    @SuppressWarnings("ResultOfMethodCallIgnored")
    public static void ensureSoundDirectoryExists(File soundDirectory)
    {
        if (!soundDirectory.exists())
        {
            soundDirectory.mkdirs();
        }
        try
        {
            soundDirectory.createNewFile();
        }
        catch (IOException ignored)
        {
        }
    }

    public static void downloadAllMissingSounds(final OkHttpClient okHttpClient)
    {
        // Get set of existing files in our dir - existing sounds will be skipped, unexpected files (not dirs, some sounds depending on config) will be deleted
        assert RAW_GITHUB != null;
        HttpUrl versionUrl = RAW_GITHUB.newBuilder().addPathSegment(SOUNDVERSION_FILENAME).build();
        int latestVersion = getLatestVersion(okHttpClient, versionUrl);
        if (latestVersion == -1)
        {
            return;
        }

        int currentVersion = getCurrentVersion();

        if (latestVersion == currentVersion)
        {
            isUpdating = true;
            downloadMissingSounds(okHttpClient);
            isUpdating = false;
            return;
        }
        isUpdating = true;
        writeLatestVersion(latestVersion);

        for (String filename : getFilesPresent(DOWNLOAD_DIR))
        {
            File toDelete = new File(DOWNLOAD_DIR, filename);
            //noinspection ResultOfMethodCallIgnored
            toDelete.delete();
            log.warn("Embargo plugin deleted {}", filename);
        }

        List<String> cleanedDirectories = new ArrayList<>();

        // Download any sounds that are not yet present but desired
        for (Sound sound : Sound.values())
        {
            String soundDirectory = sound.getDirectoryName();
            File soundDirectoryFile = new File(DOWNLOAD_DIR, soundDirectory);

            ensureSoundDirectoryExists(soundDirectoryFile);

            if (!cleanedDirectories.contains(soundDirectory))
            {
                Set<String> filesPresent = getFilesPresent(soundDirectoryFile);

                for (String filename : filesPresent)
                {
                    File toDelete = new File(soundDirectoryFile, filename);
                    //noinspection ResultOfMethodCallIgnored
                    toDelete.delete();
                    log.warn("Embargo plugin deleted {}", filename);
                }

                cleanedDirectories.add(soundDirectory);
            }

            // End early if the sound couldn't be downloaded
            if (hasNotDownloadedSound(sound, okHttpClient))
            {
                return;
            }
        }

        isUpdating = false;
    }

    private static int getCurrentVersion()
    {
        int currentVersion = -1;
        try
        {
            currentVersion = getSoundVersion();
        }
        catch (IOException e)
        {
            // No current version available
            var soundVersionFile = new File(DOWNLOAD_DIR, SOUNDVERSION_FILENAME);
            try
            {
                //noinspection ResultOfMethodCallIgnored
                soundVersionFile.createNewFile();
            }
            catch (IOException e2)
            {
                log.error("Couldn't create soundversion file");
            }
        }
        return currentVersion;
    }

    private static int getLatestVersion(OkHttpClient okHttpClient, HttpUrl versionUrl)
    {
        int latestVersion = -1;
        try (Response res = okHttpClient.newCall(new Request.Builder().url(versionUrl).build()).execute())
        {
            if (res.body() != null)
            {
                latestVersion = Integer.parseInt(Text.standardize(res.body().string()));
            }
        }
        catch (IOException e)
        {
            log.error("Embargo Plugin could not download sound version", e);
        }
        return latestVersion;
    }

    private static boolean hasNotDownloadedSound(Sound sound, OkHttpClient okHttpClient)
    {
        String soundDirectory = sound.getDirectoryName();
        String soundResourceName = sound.getResourceName();
        File soundDirectoryFile = new File(DOWNLOAD_DIR.getPath(), sound.getDirectoryName());
        assert RAW_GITHUB != null;
        HttpUrl soundUrl = RAW_GITHUB.newBuilder().addPathSegment(soundDirectory).addPathSegment(soundResourceName).build();
        Path outputPath = Paths.get(soundDirectoryFile.getPath(), soundResourceName);
        ensureSoundDirectoryExists(soundDirectoryFile);
        try (Response res = okHttpClient.newCall(new Request.Builder().url(soundUrl).build()).execute())
        {
            if (res.body() != null)
            {
                Files.copy(new BufferedInputStream(res.body().byteStream()), outputPath, StandardCopyOption.REPLACE_EXISTING);
                log.warn("Embargo plugin downloaded " + sound.getResourceName());
                return false;
            }
            return true;
        }
        catch (IOException e)
        {
            log.error("Embargo Plugin could not download sounds", e);
            isUpdating = false;
            return true;
        }
    }

    private static void downloadMissingSounds(OkHttpClient okHttpClient)
    {
        for (Sound sound : Sound.values())
        {
            File soundFile = Paths.get(DOWNLOAD_DIR.getPath(), sound.getDirectoryName(), sound.getResourceName()).toFile();
            if (soundFile.exists())
            {
                continue;
            }
            // Download sound and if a sound couldn't get downloaded, return early.
            if (hasNotDownloadedSound(sound, okHttpClient))
            {
                return;
            }
        }
    }

    private static Set<String> getFilesPresent(File directory)
    {
        File[] downloadDirFiles = directory.listFiles();
        if (downloadDirFiles == null || downloadDirFiles.length == 0)
        {
            return new HashSet<>();
        }

        return Arrays.stream(downloadDirFiles)
                .filter(file -> !file.isDirectory())
                .map(File::getName)
                .filter(filename -> !DELETE_WARNING_FILENAME.equals(filename))
                .filter(filename -> !SOUNDVERSION_FILENAME.equals(filename))
                .collect(Collectors.toSet());
    }

    public static InputStream getSoundStream(Sound sound) throws FileNotFoundException
    {
        if (!soundDirectoryMap.containsKey(sound.getDirectoryName()))
        {
            File soundDirectoryPath = Paths.get(DOWNLOAD_DIR.getPath(), sound.getDirectoryName()).toFile();
            File customSoundDirectoryPath = Paths.get(soundDirectoryPath.getPath(), "custom").toFile();

            File[] files = customSoundDirectoryPath.listFiles();
            if (files == null || files.length == 0)
            {
                files = soundDirectoryPath.listFiles();
            }

            if (files == null || files.length == 0)
            {
                return null;
            }

            var soundFileArray = Arrays.stream(files)
                    .filter(file -> !file.isDirectory())
                    .map(File::getAbsolutePath).distinct().toArray(String[]::new);

            soundDirectoryMap.put(sound.getDirectoryName(), soundFileArray);
        }
        String soundFile = RandomSoundUtility.getRandomSound(soundDirectoryMap.get(sound.getDirectoryName()));
        return new FileInputStream(soundFile);
    }

    public static int getSoundVersion() throws IOException
    {
        File soundVersionFile = new File(DOWNLOAD_DIR, SOUNDVERSION_FILENAME);
        String soundVersionContent = Files.readString(soundVersionFile.toPath());
        return Integer.parseInt(soundVersionContent);
    }

    public static boolean getIsUpdating()
    {
        return isUpdating;
    }

    private static void writeLatestVersion(int version)
    {
        var soundVersionFile = new File(DOWNLOAD_DIR, SOUNDVERSION_FILENAME);
        try
        {
            FileWriter myWriter = new FileWriter(soundVersionFile);
            myWriter.write(String.valueOf(version));
            myWriter.close();
        }
        catch (IOException e)
        {
            log.error("Couldn't write latest soundversion");
        }
    }
}
package gg.embargo.eastereggs.sounds;

public enum SoundIds
{
    AGS_SPEC(3869),
    DDS_SPEC(2537),
    ACB_SPEC(3892),
    PRAYER_DOWN(2672),
    REDEMPTION_PROC(2681),
    BANK_PIN(1041),
    RUBY_BOLT_PROC(2911);

    public final int Id;

    SoundIds(int id)
    {
        Id = id;
    }
}

// Most code taken from https://github.com/DapperMickie/odablock-sounds

package gg.embargo.eastereggs.sounds;

import gg.embargo.EmbargoConfig;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.gameval.ObjectID;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;

@Singleton
@Slf4j
public class TobChestLight
{

    @Inject
    private Client client;

    @Inject
    private EmbargoConfig config;

    @Inject
    private SoundEngine soundEngine;

    @Inject
    private ScheduledExecutorService executor;

    private static final int YOUR_TOB_CHEST_PURPLE_OBJ = ObjectID.TOB_TREASUREROOM_CHEST_MINE_RARE;
    private static final int YOUR_TOB_CHEST_NORMAL_OBJ = ObjectID.TOB_TREASUREROOM_CHEST_MINE_STANDARD;
    private static final int OTHER_TOB_CHEST_PURPLE_OBJ = ObjectID.TOB_TREASUREROOM_CHEST_NOTMINE_RARE;

    private static final List<Integer> REWARD_CHEST_IDS = Arrays.asList(ObjectID.TOB_TREASUREROOM_CHEST_LOC0, ObjectID.TOB_TREASUREROOM_CHEST_LOC1, ObjectID.TOB_TREASUREROOM_CHEST_LOC2, ObjectID.TOB_TREASUREROOM_CHEST_LOC3, ObjectID.TOB_TREASUREROOM_CHEST_LOC4);

    private boolean isPurple = false;
    private boolean isMine = false;
    private boolean inRaid = false;
    private boolean loadedPlayers = false;
    private int playerCount = 0;
    private int loadedObjectCount = 0;


    public static final int THEATRE_RAIDERS_VARP = 330;
    public static final int MAX_RAIDERS = 5;

    public static final int STATE_NO_PARTY = 0;
    public static final int STATE_IN_PARTY = 1;

    int raidState;

    public void onGameObjectSpawned(GameObjectSpawned event)
    {
        if (!config.enableClanEasterEggs())
        {
            return;
        }

        int objId = event.getGameObject().getId();
        if (REWARD_CHEST_IDS.contains(objId))
        {
            int impostorId = client.getObjectDefinition(objId).getImpostor().getId();

            if (impostorId == YOUR_TOB_CHEST_PURPLE_OBJ)
            {
                isPurple = true;
                isMine = true;
            }
            else if (impostorId == OTHER_TOB_CHEST_PURPLE_OBJ)
            {
                isPurple = true;
                isMine = false;
            }
            else if (impostorId == YOUR_TOB_CHEST_NORMAL_OBJ)
            {
                isMine = false;
            }
            loadedObjectCount++;

            if (loadedObjectCount == playerCount)
            {
                if (isPurple) {
                    // TODO: Maybe change sound if it's yours
                    if (isMine) {
                        soundEngine.playClip(Sound.MY_TOB_PURPLE, executor);
//                      } else {
//                          soundEngine.playClip(Sound.GETTING_PURPLE_1, executor);
//                      }
                    }
                else {
                    soundEngine.playClip(Sound.TOB_WHITE_LIGHT, executor);
                    }
                }
            }
        }
    }

    public void onGameTick(GameTick event)
    {
        if (inRaid && !loadedPlayers)
        {
            Map<Integer, Object> varcmap = client.getVarcMap();
            for (int i = 0; i < MAX_RAIDERS; i++)
            {
                Integer playervarp = THEATRE_RAIDERS_VARP + i;
                if (varcmap.containsKey(playervarp) && !varcmap.get(playervarp).equals(""))
                {
                    playerCount++;
                }
            }

            loadedPlayers = true;
        }
    }

    // Yoinked from https://github.com/Adam-/runelite-plugins/blob/tob-drop-chance/src/main/java/com/tobdropchance/TobDropChancePlugin.java
    public void onVarbitChanged(VarbitChanged event)
    {
        int nextState = client.getVarbitValue(VarbitID.TOB_VERZIK_THRONE_VISIBLE);
        if (raidState != nextState)
        {
            if (nextState == STATE_NO_PARTY || nextState == STATE_IN_PARTY)
            { // Player is not in a raid.
                reset();
                raidState = nextState;
            }
            else
            { // Player has entered the theatre.
                if (raidState == STATE_IN_PARTY)
                { // Player was in a party. They are a raider.
                    reset();
                    inRaid = true;
                }

                raidState = nextState;
            }
        }
    }

    private void reset()
    {
        isPurple = false;
        isMine = false;
        inRaid = false;
        loadedPlayers = false;
        playerCount = 0;
        loadedObjectCount = 0;
    }

    public void onGameObjectDespawned(GameObjectDespawned event)
    {
        int objId = event.getGameObject().getId();
        if (REWARD_CHEST_IDS.contains(objId))
        {
            isMine = false;
            isPurple = false;
            loadedObjectCount--;
        }
    }
}
package gg.embargo.eastereggs.sounds;

import gg.embargo.EmbargoConfig;
import gg.embargo.eastereggs.SoundFileManager;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.*;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.Duration;
import java.util.Objects;
import java.util.concurrent.Executor;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Singleton
@Slf4j
public class SoundEngine
{

    @Inject
    private EmbargoConfig config;

    private static final long CLIP_MTIME_UNLOADED = -2;

    private long lastClipMTime = CLIP_MTIME_UNLOADED;
    private Clip clip = null;

    private boolean loadClip(Sound sound)
    {
        try (InputStream stream = new BufferedInputStream(Objects.requireNonNull(SoundFileManager.getSoundStream(sound)));
             AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(stream))
        {
            clip.open(audioInputStream); // liable to error with pulseaudio, works on windows, one user informs me mac works
            return true;
        }
        catch (UnsupportedAudioFileException | IOException | LineUnavailableException e)
        {
            log.warn("Failed to load Embargo sound " + sound, e);
        }
        return false;
    }

    public void playClip(Sound sound, Executor executor)
    {
        executor.execute(() -> playClip(sound));
    }

    public void playClip(Sound sound, ScheduledExecutorService executor, Duration initialDelay)
    {
        executor.schedule(() -> playClip(sound), initialDelay.toMillis(), TimeUnit.MILLISECONDS);
    }

    private void playClip(Sound sound)
    {
        if (SoundFileManager.getIsUpdating())
        {
            return;
        }
        long currentMTime = System.currentTimeMillis();
        if (clip == null || currentMTime != lastClipMTime || !clip.isOpen())
        {
            if (clip != null && clip.isOpen())
            {
                clip.close();
            }

            try
            {
                clip = AudioSystem.getClip();
            }
            catch (LineUnavailableException e)
            {
                lastClipMTime = CLIP_MTIME_UNLOADED;
                log.warn("Failed to get clip for Embargo sound " + sound, e);
                return;
            }

            lastClipMTime = currentMTime;
            if (!loadClip(sound))
            {
                return;
            }
        }

        // User configurable volume
        FloatControl volume = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);
        float gain = 20f * (float) Math.log10(config.announcementVolume() / 100f);
        gain = Math.min(gain, volume.getMaximum());
        gain = Math.max(gain, volume.getMinimum());
        volume.setValue(gain);

        // From RuneLite base client Notifier class:
        // Using loop instead of start + setFramePosition prevents the clip
        // from not being played sometimes, presumably a race condition in the
        // underlying line driver
        clip.loop(0);
    }

    public void close()
    {
        if (clip != null && clip.isOpen())
        {
            clip.close();
        }
    }
}
package gg.embargo.eastereggs.sounds;

import java.util.Random;

public class RandomSoundUtility
{
    private static Random random = new Random();

    public static String getRandomSound(String[] sounds)
    {
        return sounds[random.nextInt(sounds.length)];
    }
}


package gg.embargo.eastereggs.sounds;

import lombok.Getter;


@Getter
public enum Sound {
    MY_TOB_PURPLE("tob", "my_tob_purple.wav"),
    TOB_WHITE_LIGHT("tob", "my_tob_white.wav");

    private final String directoryName;
    private final String resourceName;


    Sound(String directoryName, String resourceName)
    {
        this.directoryName = directoryName;
        this.resourceName = resourceName;
    }
}
package gg.embargo.eastereggs;

import gg.embargo.EmbargoConfig;
import gg.embargo.eastereggs.sounds.TobChestLight;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.RuneLite;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import java.io.File;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;

import javax.inject.Inject;

public class SoundManager {

    private static final File DOWNLOAD_DIR = new File(RuneLite.RUNELITE_DIR.getPath() + File.separator + "embargo-sounds");
    private static final String DELETE_WARNING_FILENAME = "EXTRA_FILES_WILL_BE_DELETED_BUT_FOLDERS_WILL_REMAIN";
    private static final String SOUNDVERSION_FILENAME = "SOUNDVERSION";
    private static final File DELETE_WARNING_FILE = new File(DOWNLOAD_DIR, DELETE_WARNING_FILENAME);
    private static final HttpUrl RAW_GITHUB = HttpUrl.parse("https://raw.githubusercontent.com/sharpienero/embargo-plugin/sounds");

    private final EventBus eventBus;
    private final EmbargoConfig config;

    @Inject
    public OkHttpClient okHttpClient;

    @Inject
    public SoundManager(EventBus eventBus, EmbargoConfig config) {
        this.eventBus = eventBus;
        this.config = config;
    }

    public void startUp() {
        eventBus.register(this);
        SoundFileManager.ensureDownloadDirectoryExists();
        SoundFileManager.downloadAllMissingSounds(okHttpClient);
    }

    public void shutDown() {
        eventBus.unregister(this);
    }

    public boolean featureEnabled() {
        return config.enableClanEasterEggs() && config.enableCustomSounds();
    }

    @Inject
    private TobChestLight tobChestLight;

    @Subscribe
    public void onVarbitChanged(VarbitChanged event)
    {
        if (featureEnabled())
            tobChestLight.onVarbitChanged(event);
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        if (featureEnabled())
            tobChestLight.onGameTick(event);
    }

    @Subscribe
    private void onGameObjectSpawned(GameObjectSpawned event)
    {
        if (featureEnabled())
            tobChestLight.onGameObjectSpawned(event);
    }

    @Subscribe
    private void onGameObjectDespawned(GameObjectDespawned event)
    {
        if (featureEnabled())
            tobChestLight.onGameObjectDespawned(event);
    }
}

package gg.embargo.untrackables;

import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;


@Slf4j
@Singleton
public class UntrackableItemManager {

    @Inject
    private Client client;

    private final EventBus eventBus;

    @Inject
    private UntrackableItemManager(Client client, EventBus eventBus) {
        this.client = client;
        this.eventBus = eventBus;
    }

    @Inject
    private OkHttpClient okHttpClient;

    private static final String UNTRACKABLE_ENDPOINT = "https://embargo.gg/api/untrackables";

    private final HashMap<String, LocalDateTime> lastLootTime = new HashMap<>();

    @Getter
    enum UntrackableItems {

        BOOK_OF_THE_DEAD(25818),
        MUSIC_CAPE(13221),
        MUSIC_CAPE_T(13222),
        BARROWS_GLOVES(7462),
        IMBUED_SARADOMIN_CAPE(21791),
        IMBUED_GUTHIX_CAPE(21793),
        IMBUED_ZAMORAK_CAPE(21795),
        IMBUED_SARADOMIN_MAX_CAPE(21776),
        IMBUED_ZAMORAK_MAX_CAPE(21780),
        IMBUED_GUTHIX_MAX_CAPE(21784),
        IMBUED_SARADOMIN_MAX_CAPE_I(24232),
        IMBUED_ZAMORAK_MAX_CAPE_I(24233),
        IMBUED_GUTHIX_MAX_CAPE_I(24234),

        //BINGO #1 ITEMS FOR START COUNTS
        BEGINNER_REWARD_CASKET(23245),
        EASY_REWARD_CASKET(20546),
        MEDIUM_REWARD_CASKET(20545),
        HARD_REWARD_CASKET(20544),
        ELITE_REWARD_CASKET(20543),
        MASTER_REWARD_CASKET(19836),

        MOSSY_KEY(22374),
        GIANT_KEY(20754);


        private final int itemId;

        UntrackableItems(int itemId) {
            this.itemId = itemId;
        }
    }

    void getUntrackableItems(String username) {
        Widget widget = client.getWidget(786445);
        ItemContainer itemContainer = client.getItemContainer(InventoryID.BANK);
        Widget[] children;
        if (widget != null) {
            children = widget.getChildren();
        } else {
            return;
        }
        if (itemContainer != null && children != null) {

            //Convert itemMap to use manifest.untrackableItems (which is a list of integers) instead of hardcoded enum
            var itemMap = Arrays.stream(UntrackableItems.values()).map(UntrackableItems::getItemId).collect(Collectors.toCollection(HashSet::new));
            List<Integer> playerItems = new ArrayList<>();
            java.util.Map<Integer, Integer> itemQuantities = new java.util.HashMap<>();
            for (int i = 0; i < itemContainer.size(); ++i) {

                Widget child = children[i];
                var currentItem = child.getItemId();
                if (itemMap.contains(currentItem)) {
                    playerItems.add(currentItem);
                    int quantity = child.getItemQuantity();
                    itemQuantities.put(currentItem, quantity);
                }
            }

            var RequestBody = new FormBody.Builder();
            for (int i=0; i < playerItems.size(); i++) {
                RequestBody.add("itemIds[" + i + "]", String.valueOf(playerItems.get(i)));
                RequestBody.add("quantities[" + i + "]", String.valueOf(itemQuantities.get(playerItems.get(i))));
            }

            RequestBody.add("username", username);

            Request request = new Request.Builder()
                    .url(UNTRACKABLE_ENDPOINT)
                    .post(RequestBody.build())
                    .addHeader("Content-Type", "application/json")
                    .build();

            try {
                okHttpClient.newCall(request).enqueue(new Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        log.error("Something went wrong inside of getUntrackableItems: {}", e.getLocalizedMessage());
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) {
                        if (response.isSuccessful()) {
                            log.debug("Successfully submitted getUntrackableItems");
                        }
                        response.close();
                    }
                });
            } catch (IllegalArgumentException e) {
                log.error("Bad URL given: {}", e.getLocalizedMessage());
            }
        }
    }

    public void startUp() {
        eventBus.register(this);
    }
    public void shutDown() { eventBus.unregister(this);}

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event) {
        if (event.getScriptId() == 277) {
            if (client == null || client.getLocalPlayer() == null) {
                return;
            }

            var username = client.getLocalPlayer().getName();

            if (lastLootTime.containsKey(username)) {
                LocalDateTime lastLootTimestamp = lastLootTime.get(username);

                if (LocalDateTime.now().isBefore(lastLootTimestamp)) {
                    log.debug("Player has opened bank within the last 3 minutes, not checking for untrackable items");
                    return;
                }

            }
            getUntrackableItems(username);
            lastLootTime.put(username, LocalDateTime.now().plusMinutes(3));
        }
    }
}

/*
 * Copyright (c) 2021, andmcadams
 * modified by Sharpienero, Contronym
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package gg.embargo;

import com.google.common.collect.HashMultimap;
import com.google.gson.*;
import gg.embargo.manifest.ManifestManager;
import gg.embargo.ui.EmbargoPanel;
import gg.embargo.untrackables.UntrackableItemManager;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.task.Schedule;
import okhttp3.*;
import okio.BufferedSource;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Consumer;

@Slf4j
@Singleton
public class DataManager {
    @Inject
    private Client client;

    @Inject
    private ItemManager itemManager;

    @Inject
    private ClientThread clientThread;

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private EmbargoPanel embargoPanel;

    @Inject
    private Gson gson;

    @Getter
    @Setter
    private HashSet<Integer> varpsToCheck;

    @Getter
    @Setter
    private HashSet<Integer> varbitsToCheck;

    @Inject
    private ManifestManager manifestManager;

    @Getter
    @Setter
    private int lastManifestVersion = -1;

    AtomicBoolean isUsernameRegistered = new AtomicBoolean(false);
    public AtomicBoolean stopTryingForAccount = new AtomicBoolean(false);

    private int[] oldVarps;

    private final HashMultimap<Integer, Integer> varpToVarbitMapping = HashMultimap.create();

    private final HashMap<Integer, Integer> varbData = new HashMap<>();
    private final HashMap<Integer, Integer> varpData = new HashMap<>();
    private final HashMap<String, Integer> levelData = new HashMap<>();

    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    enum APIRoutes {
        MANIFEST("runelite/manifest"),
        UNTRACKABLES("untrackables"),
        CHECKREGISTRATION("checkregistration"),
        GET_PROFILE("getgear"),
        SUBMIT_LOOT("loot"),
        GET_RAID_MONSTERS_TO_TRACK_LOOT("lootBosses"),
        PREPARE_RAID("raid"),
        UPLOAD_CLOG("collectionlog"),
        MINIGAME_COMPLETE("minigame");

        APIRoutes(String route) {
            this.route = route;
        }

        private final String route;

        @Override
        public String toString() {
            return route;
        }
    }

    // private static final String MOCK_API_URI =
    // "https://a278d141-927f-433b-8e4b-6d994067900d.mock.pstmn.io/api/";
    private static final String API_URI = "https://embargo.gg/api/";
    private static final String MANIFEST_ENDPOINT = API_URI + APIRoutes.MANIFEST;
    private static final String UNTRACKABLE_POST_ENDPOINT = API_URI + APIRoutes.UNTRACKABLES;
    private static final String CHECK_REGISTRATION_ENDPOINT = API_URI + APIRoutes.CHECKREGISTRATION;
    private static final String GET_PROFILE_ENDPOINT = API_URI + APIRoutes.GET_PROFILE;
    private static final String SUBMIT_LOOT_ENDPOINT = API_URI + APIRoutes.SUBMIT_LOOT;
    private static final String TRACK_MONSTERS_ENDPOINT = API_URI + APIRoutes.GET_RAID_MONSTERS_TO_TRACK_LOOT;
    private static final String PREPARE_RAID_ENDPOINT = API_URI + APIRoutes.PREPARE_RAID;
    private static final String MINIGAME_COMPLETION_ENDPOINT = API_URI + APIRoutes.MINIGAME_COMPLETE;
    private static final String CLOG_UNLOCK_ENDPOINT = API_URI + APIRoutes.UPLOAD_CLOG;

    public static ArrayList BossesToTrack = null;

    public void storeVarbitChanged(int varbIndex, int varbValue) {
        synchronized (this) {
            varbData.put(varbIndex, varbValue);
        }
    }

    public void resetVarbsAndVarpsToCheck() {
        varbitsToCheck = null;
        varpsToCheck = null;
    }

    public List<Player> getSurroundingPlayers() {
        List<Player> pl = new ArrayList<>();
        if (client == null || client.getTopLevelWorldView() == null
                || client.getTopLevelWorldView().players() == null) {
            return pl;
        }

        return (List<Player>) client.getTopLevelWorldView().players();
    }

    public boolean shouldTrackLoot(String bossName) {
        if (bossName == null || bossName.isEmpty()) {
            return false;
        }

        var bosses = getTrackableBosses();

        for (Object boss : bosses) {
            if (boss.equals(bossName)) {
                return true;
            }
        }

        return false;
    }

    public ArrayList getTrackableBosses() {
        if (BossesToTrack != null) {
            return BossesToTrack;
        }
        okHttpClient.newCall(new Request.Builder().url(TRACK_MONSTERS_ENDPOINT).build()).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.debug("Failed to get raid boss list", e);
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                // Update what we want to track on the fly
                if (response.isSuccessful()) {
                    // convert response.body().string() to ArrayList<String>
                    BufferedSource source = response.body().source();
                    String json = source.readUtf8();
                    response.close();

                    // convert json to an ArrayList<String>
                    BossesToTrack = gson.fromJson(json, ArrayList.class);
                }

                response.close();
            }
        });
        return null;
    }

    public void uploadCollectionLogUnlock(String item, String player) {
        JsonObject payload = getClogUploadPayload(item, player);
        // log.debug(String.valueOf(payload));

        okHttpClient.newCall(new Request.Builder().url(CLOG_UNLOCK_ENDPOINT)
                .post(RequestBody.create(JSON, payload.toString())).build()).enqueue(new Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        log.debug("Failed to upload new clog slot to Embargo", e);
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                        // Update what we want to track on the fly
                        if (response.isSuccessful()) {
                            log.debug("Successfully uploaded new collection log slot");
                            response.close();
                            return;
                        }

                        response.close();
                    }
                });
    }

    public void uploadRaidCompletion(String raid, String message) {
        if (client == null || client.getLocalPlayer() == null) {
            return;
        }

        JsonObject payload = getRaidCompletionPayload(raid, message);
        okHttpClient.newCall(new Request.Builder().url(PREPARE_RAID_ENDPOINT)
                .post(RequestBody.create(JSON, payload.toString())).build()).enqueue(new Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        log.debug("Failed to upload upload raid completion", e);
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                        if (response.isSuccessful()) {
                            log.debug("Successfully uploaded raid preparation");
                        }

                        response.close();
                    }
                });
    }

    public void uploadMinigameCompletion(String minigameName, String message) {
        if (client == null || client.getLocalPlayer() == null) {
            return;
        }

        JsonObject payload = getMinigamePayload(minigameName, message);
        okHttpClient.newCall(new Request.Builder().url(MINIGAME_COMPLETION_ENDPOINT)
                .post(RequestBody.create(JSON, payload.toString())).build()).enqueue(new Callback() {
                    @Override
                    public void onFailure(@NonNull Call call, @NonNull IOException e) {
                        log.debug("Failed to upload upload minigame completion", e);
                    }

                    @Override
                    public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                        if (response.isSuccessful()) {
                            log.debug("Successfully uploaded minigame preparation");
                        }

                        response.close();
                    }
                });
    }

    private JsonObject getClogUploadPayload(String itemName, String username) {

        JsonObject payload = new JsonObject();
        payload.addProperty("playerName", username);
        payload.addProperty("itemName", itemName);

        return payload;
    }

    @NonNull
    private JsonObject getMinigamePayload(String minigame, String message) {
        var user = client.getLocalPlayer().getName();
        var world = client.getWorld();
        List<Player> players = getSurroundingPlayers();

        // convert List<Player> to JSON
        JsonArray playersJson = new JsonArray();
        for (Player player : players) {
            JsonObject playerJson = new JsonObject();
            playerJson.addProperty("name", player.getName());
            playersJson.add(playerJson);
        }

        JsonObject payload = new JsonObject();
        payload.addProperty("minigame", minigame);
        payload.addProperty("world", world);
        payload.addProperty("message", message);
        payload.addProperty("user", user);
        payload.add("players", playersJson);
        return payload;
    }

    @NonNull
    private JsonObject getRaidCompletionPayload(String raid, String message) {
        var user = client.getLocalPlayer().getName();
        List<Player> players = getSurroundingPlayers();

        // convert List<Player> to JSON
        JsonArray playersJson = new JsonArray();
        for (Player player : players) {
            JsonObject playerJson = new JsonObject();
            playerJson.addProperty("name", player.getName());
            playersJson.add(playerJson);
        }

        JsonObject payload = new JsonObject();
        payload.addProperty("raid", raid);
        payload.addProperty("message", message);
        payload.addProperty("user", user);
        payload.add("players", playersJson);
        return payload;
    }

    public CompletableFuture<JsonObject> getProfileAsync(String username) {
        CompletableFuture<JsonObject> future = new CompletableFuture<>();

        Request request = new Request.Builder()
                .url(GET_PROFILE_ENDPOINT + '/' + username)
                .get()
                .build();

        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                future.complete(new JsonObject()); // Complete with empty object on failure
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                if (response.isSuccessful()) {
                    BufferedSource source = response.body().source();
                    String json = source.readUtf8();
                    response.close();
                    future.complete(gson.fromJson(json, JsonObject.class));
                } else {
                    response.close();
                    future.complete(new JsonObject()); // Complete with empty object on unsuccessful response
                }
            }
        });

        return future;
    }

    private final AtomicBoolean apiFailureMode = new AtomicBoolean(false);
    private final AtomicLong lastApiFailure = new AtomicLong(0);
    private static final long API_RETRY_DELAY_MINUTES = 1;

    /**
     * Checks if a user is registered with Embargo asynchronously
     * @param username The username to check
     * @param callback Callback to handle the result
     */
    public void isUserRegisteredAsync(String username, Consumer<Boolean> callback) {
        if (username == null) {
            callback.accept(false);
            return;
        }

        if (stopTryingForAccount.get()) {
            callback.accept(false);
            return;
        }

        if (isUsernameRegistered.get()) {
            callback.accept(true);
            return;
        }

        log.debug("Checking if {} is registered with Embargo", username);

        // If we're in API failure mode, only retry after the delay period
        long currentTime = Instant.now().getEpochSecond();
        long failureTime = lastApiFailure.get();
        long elapsedMinutes = TimeUnit.SECONDS.toMinutes(currentTime - failureTime);

        if (apiFailureMode.get() && elapsedMinutes < API_RETRY_DELAY_MINUTES) {
            log.debug("apiFailureMode is true, skipping execution for {} minute(s)", API_RETRY_DELAY_MINUTES);
            callback.accept(false);
            return;
        }

        apiFailureMode.set(false);

        try {
            Request request = new Request.Builder()
                    .url(CHECK_REGISTRATION_ENDPOINT + "/" + username)
                    .get()
                    .build();

            // Create a client with shorter timeout for this specific check
            OkHttpClient shortTimeoutClient = okHttpClient.newBuilder()
                    .callTimeout(5, TimeUnit.SECONDS)
                    .build();

            shortTimeoutClient.newCall(request).enqueue(new Callback() {
                @Override
                public void onFailure(@NonNull Call call, @NonNull IOException e) {
                    log.error("Failed to check if {} is registered with Embargo's database", username);
                    apiFailureMode.set(true);
                    lastApiFailure.set(Instant.now().getEpochSecond());
                    callback.accept(false);
                }

                @Override
                public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                    try (response) {
                        if (response.isSuccessful()) {
                            String responseBody = response.body().string();
                            JsonObject jsonResponse = gson.fromJson(responseBody, JsonObject.class);
                            if (jsonResponse != null && jsonResponse.has("message") && "registered".equals(jsonResponse.get("message").getAsString())) {
                                log.debug("{} is registered, return true", username);
                                isUsernameRegistered.set(true);
                                callback.accept(true);
                            } else {
                                log.debug("{} is NOT registered, return false", username);
                                stopTryingForAccount.set(true);
                                callback.accept(false);
                            }
                            apiFailureMode.set(false);

                        } else {
                            String responseBody = response.body().string();
                            JsonObject jsonResponse = gson.fromJson(responseBody, JsonObject.class);
                            if (jsonResponse != null && jsonResponse.has("message") && "not registered".equals(jsonResponse.get("message").getAsString())) {
                                stopTryingForAccount.set(true);
                                callback.accept(false);
                                return;
                            }
                            log.error("Failed to check if {} is registered with Embargo's database. Status: {}",
                                    username, response.code());
                            apiFailureMode.set(true);
                            lastApiFailure.set(Instant.now().getEpochSecond());
                            callback.accept(false);
                            isUsernameRegistered.set(false);
                        }
                    }
                }
            });
        } catch (Exception e) {
            // Log once and enter failure mode
            if (!apiFailureMode.get()) {
                log.error("Failed to check if user is registered. API may be down. Will retry in {} minutes.",
                        API_RETRY_DELAY_MINUTES, e);
                apiFailureMode.set(true);
                lastApiFailure.set(Instant.now().getEpochSecond());
                isUsernameRegistered.set(false);
            }
            callback.accept(false);
        }
    }


    public void uploadLoot(LootReceived event) {
        JsonObject payload = getJsonObject(event);

        log.debug("Uploading payload: " + payload);

        Request request = new Request.Builder()
                .url(SUBMIT_LOOT_ENDPOINT)
                .post(RequestBody.create(JSON, payload.toString()))
                .build();

        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.error("Error uploading loot", e);
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                if (response.isSuccessful()) {
                    log.debug("Loot uploaded successfully");
                } else {
                    log.error("Loot upload failed with status " + response.code());
                }
                response.close();
            }
        });
    }

    @NonNull
    private JsonObject getJsonObject(LootReceived event) {
        Collection<ItemStack> itemStacks = event.getItems();

        var user = client.getLocalPlayer().getName();
        List<Player> players = getSurroundingPlayers();

        // convert List<Player> to JSON
        JsonArray playersJson = new JsonArray();
        for (Player player : players) {
            JsonObject playerJson = new JsonObject();
            playerJson.addProperty("name", player.getName());
            playersJson.add(playerJson);
        }

        // convert itemStacks to JSON using gson
        JsonArray itemStacksJson = new JsonArray();
        for (ItemStack itemStack : itemStacks) {
            JsonObject itemStackJson = new JsonObject();
            itemStackJson.addProperty("id", itemStack.getId());
            itemStackJson.addProperty("quantity", itemStack.getQuantity());
            itemStackJson.addProperty("price", itemManager.getItemPrice(itemStack.getId()));
            itemStackJson.addProperty("name", itemManager.getItemComposition(itemStack.getId()).getName());

            itemStacksJson.add(itemStackJson);
        }

        // convert json array to String
        String itemStacksJsonString = itemStacksJson.toString();

        // build payload with bossName and itemStacks
        JsonObject payload = new JsonObject();
        payload.addProperty("bossName", event.getName());
        payload.addProperty("user", user);
        payload.addProperty("itemStacks", itemStacksJsonString);
        payload.add("players", playersJson);
        return payload;
    }

    public void storeVarbitChangedIfNotStored(int varbIndex, int varbValue) {
        synchronized (this) {
            if (!varbData.containsKey(varbIndex))
                this.storeVarbitChanged(varbIndex, varbValue);
        }
    }

    public void storeVarpChanged(int varpIndex, int varpValue) {
        synchronized (this) {
            varpData.put(varpIndex, varpValue);
        }
    }

    public void storeVarpChangedIfNotStored(int varpIndex, int varpValue) {
        synchronized (this) {
            if (!varpData.containsKey(varpIndex))
                this.storeVarpChanged(varpIndex, varpValue);
        }
    }

    public void storeSkillChanged(String skill, int skillLevel) {
        synchronized (this) {
            levelData.put(skill, skillLevel);
        }
    }

    public void storeSkillChangedIfNotChanged(String skill, int skillLevel) {
        synchronized (this) {
            if (!levelData.containsKey(skill))
                storeSkillChanged(skill, skillLevel);
        }
    }

    private <K, V> HashMap<K, V> clearChanges(HashMap<K, V> h) {
        HashMap<K, V> temp;
        synchronized (this) {
            if (h.isEmpty()) {
                return new HashMap<>();
            }
            temp = new HashMap<>(h);
            h.clear();
        }
        return temp;
    }

    public void clearData() {
        synchronized (this) {
            varbData.clear();
            varpData.clear();
            levelData.clear();
        }
    }

    private boolean hasDataToPush() {
        return !(varbData.isEmpty() && varpData.isEmpty() && levelData.isEmpty());
    }

    private JsonObject convertToJson() {
        JsonObject j = new JsonObject();
        JsonObject parent = new JsonObject();
        // We need to synchronize this to handle the case where the RuneScapeProfileType
        // changes
        synchronized (this) {
            RuneScapeProfileType r = RuneScapeProfileType.getCurrent(client);
            HashMap<Integer, Integer> tempVarbData = clearChanges(varbData);
            HashMap<Integer, Integer> tempVarpData = clearChanges(varpData);
            HashMap<String, Integer> tempLevelData = clearChanges(levelData);

            j.add("varb", gson.toJsonTree(tempVarbData));
            j.add("varp", gson.toJsonTree(tempVarpData));
            j.add("level", gson.toJsonTree(tempLevelData));

            parent.addProperty("username", client.getLocalPlayer().getName());
            parent.addProperty("profile", r.name());
            parent.addProperty("version", manifestManager.getLastCheckedManifestVersion());
            parent.add("data", j);
        }
        return parent;
    }

    private void restoreData(JsonObject jObj) {
        synchronized (this) {
            if (!jObj.get("profile").getAsString().equals(RuneScapeProfileType.getCurrent(client).name())) {
                log.error("Not restoring data from failed call since the profile type has changed");
                return;
            }
            JsonObject dataObj = jObj.getAsJsonObject("data");
            JsonObject varbObj = dataObj.getAsJsonObject("varb");
            JsonObject varpObj = dataObj.getAsJsonObject("varp");
            JsonObject levelObj = dataObj.getAsJsonObject("level");
            for (String k : varbObj.keySet()) {
                this.storeVarbitChangedIfNotStored(Integer.parseInt(k), varbObj.get(k).getAsInt());
            }
            for (String k : varpObj.keySet()) {
                this.storeVarpChangedIfNotStored(Integer.parseInt(k), varpObj.get(k).getAsInt());
            }
            for (String k : levelObj.keySet()) {
                this.storeSkillChangedIfNotChanged(k, levelObj.get(k).getAsInt());
            }
        }
    }

    protected void submitToAPI() {
        if (!hasDataToPush() || client.getLocalPlayer() == null || client.getLocalPlayer().getName() == null || stopTryingForAccount.get())
            return;

        if (RuneScapeProfileType.getCurrent(client) != RuneScapeProfileType.STANDARD)
            return;

        isUserRegisteredAsync(client.getLocalPlayer().getName(), isRegistered -> {
            if (!isRegistered) {
                return;
            }

        if (client.getGameState() == GameState.LOGIN_SCREEN || client.getGameState() == GameState.HOPPING) {
            return;
        }

        try {
            JsonObject payload = convertToJson();

            okHttpClient.newCall(new Request.Builder().url(UNTRACKABLE_POST_ENDPOINT)
                    .post(RequestBody.create(JSON, payload.toString())).build()).enqueue(new Callback() {
                        @Override
                        public void onFailure(@NonNull Call call, @NonNull IOException e) {
                            log.error(e.getLocalizedMessage());
                            restoreData(payload);
                            log.error("Failed to submit player in submitToAPI, restoring data. Cause of failure:", e);
                        }

                        @Override
                        public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                            if (response.isSuccessful()) {
                                log.debug("Successfully uploaded untrackable items");
                                response.close();
                                return;
                            } else {
                                response.close();
                                log.error("submitToAPI onResponse returned, but without success");
                            }

                            response.close();
                        }
                    });
        } catch (Exception e) {
            log.error("Error preparing data for API submission", e);
        }
    });
    }

    private HashSet<Integer> parseSet(JsonArray j) {
        HashSet<Integer> h = new HashSet<>();
        for (JsonElement jObj : j) {
            h.add(jObj.getAsInt());
        }
        return h;
    }

    public void loadInitialData() {
        manifestManager.getLatestManifest();

        for (int varbIndex : varbitsToCheck) {
            storeVarbitChanged(varbIndex, client.getVarbitValue(varbIndex));
        }

        for (int varpIndex : varpsToCheck) {
            storeVarpChanged(varpIndex, client.getVarpValue(varpIndex));
        }
        for (Skill s : Skill.values()) {
            storeSkillChanged(s.getName(), client.getRealSkillLevel(s));
        }
    }

    // NEEDS TO BE MODIFIED TO USE NEW MANIFEST OBJECT STUFF
    protected void getManifest() {
        // log.debug("Getting manifest file...");
        try {
            Request r = new Request.Builder()
                    .url(MANIFEST_ENDPOINT)
                    .build();
            okHttpClient.newCall(r).enqueue(new Callback() {
                @Override
                public void onFailure(@NonNull Call call, @NonNull IOException e) {
                    log.error("Error retrieving manifest", e);
                }

                @Override
                public void onResponse(@NonNull Call call, @NonNull Response response) {
                    if (response.isSuccessful()) {
                        try {
                            // We want to be able to change the varbs and varps we get on the fly. To do so,
                            // we tell
                            // the client what to send the server on startup via the manifest.
                            if (response.body() == null) {
                                log.error("Manifest request succeeded but returned empty body");
                                response.close();
                            }

                            JsonObject j = gson.fromJson(response.body().string(), JsonObject.class);
                            try {
                                setVarbitsToCheck(parseSet(j.getAsJsonArray("varbits")));
                                setVarpsToCheck(parseSet(j.getAsJsonArray("varps")));
                                try {
                                    int manifestVersion = j.get("version").getAsInt();
                                    if (getLastManifestVersion() != manifestVersion) {
                                        setLastManifestVersion(manifestVersion);
                                        clientThread.invoke(() -> loadInitialData());
                                    }
                                } catch (UnsupportedOperationException | NullPointerException exception) {
                                    setLastManifestVersion(-1);
                                }
                            } catch (NullPointerException e) {
                                log.error("Manifest possibly missing varbits or varps entry from /manifest call");
                                log.error(e.getLocalizedMessage());
                            } catch (ClassCastException e) {
                                log.error("Manifest from /manifest call might have varbits or varps as not a list");
                                log.error(e.getLocalizedMessage());
                            }
                        } catch (IOException | JsonSyntaxException e) {
                            log.error(e.getLocalizedMessage());
                        } finally {
                            response.close();
                        }
                    } else {
                        log.error("Manifest request returned with status " + response.code());
                        if (response.body() == null) {
                            log.error("Manifest request returned empty body");
                        } else {
                            log.error(response.body().toString());
                        }
                    }
                    response.close();
                }
            });
        } catch (IllegalArgumentException e) {
            log.error("Bad URL given: " + e.getLocalizedMessage());
        }
    }

    // NEEDS TO BE MODIFIED TO USE NEW MANIFEST OBJECT STUFF
    protected int getVersion() {
        // log.debug("Attempting to get manifest version...");
        Request request = new Request.Builder()
                .url(MANIFEST_ENDPOINT)
                .build();

        try {
            okHttpClient.newCall(request).enqueue(new Callback() {
                @Override
                public void onFailure(@NonNull Call call, IOException e) {
                    log.error("Error retrieving manifest", e);
                }

                @Override
                public void onResponse(@NonNull Call call, Response response) throws IOException {
                    if (response.isSuccessful()) {
                        try {
                            // We want to be able to change the varbs and varps we get on the fly. To do so,
                            // we tell
                            // the client what to send the server on startup via the manifest.
                            if (response.body() == null) {
                                log.error("Manifest request succeeded but returned empty body");
                                response.close();
                            }

                            JsonObject j = gson.fromJson(response.body().string(), JsonObject.class);

                            try {
                                try {
                                    int manifestVersion = j.get("version").getAsInt();
                                    if (manifestManager.getLatestManifest().getVersion() != manifestVersion) {
                                        // update to use new manifest stuff
                                        clientThread.invoke(() -> loadInitialData());
                                    }
                                } catch (UnsupportedOperationException | NullPointerException exception) {
                                    setLastManifestVersion(-1);
                                }
                            } catch (NullPointerException | ClassCastException e) {
                                log.error(e.getLocalizedMessage());
                            }
                        } catch (IOException | JsonSyntaxException e) {
                            log.error(e.getLocalizedMessage());
                        } finally {
                            response.close();
                        }
                    } else {
                        log.error("Manifest request returned with status " + response.code());
                        if (response.body() == null) {
                            log.error("Manifest request returned empty body");
                        } else {
                            log.error(response.body().toString());
                        }
                    }
                    response.close();
                }
            });
        } catch (IllegalArgumentException e) {
            log.error("asd");
        }
        return -1;
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged varbitChanged) {
        if (client == null || varbitsToCheck == null || varpsToCheck == null)
            return;
        if (oldVarps == null)
            setupVarpTracking();

        int varpIndexChanged = varbitChanged.getVarpId();
        if (varpsToCheck.contains(varpIndexChanged)) {
            storeVarpChanged(varpIndexChanged, client.getVarpValue(varpIndexChanged));
        }
        for (Integer i : varpToVarbitMapping.get(varpIndexChanged)) {
            if (!varbitsToCheck.contains(i))
                continue;
            // For each varbit index, see if it changed.
            int oldValue = client.getVarbitValue(oldVarps, i);
            int newValue = client.getVarbitValue(i);
            if (oldValue != newValue)
                storeVarbitChanged(i, newValue);
        }
        oldVarps[varpIndexChanged] = client.getVarpValue(varpIndexChanged);
    }

    // Need to keep track of old varps and what varps each varb is in.
    // On change
    // Get varp, if varp in hashset, queue it.
    // Get each varb index in varp. If varb changed and varb in hashset, queue it.
    // Checking if varb has changed requires us to keep track of old varps
    private void setupVarpTracking() {
        final int VARBITS_ARCHIVE_ID = 14;
        // Init stuff to keep track of varb changes
        varpToVarbitMapping.clear();

        if (oldVarps == null) {
            oldVarps = new int[client.getVarps().length];
        }

        // Set oldVarps to be the current varps
        System.arraycopy(client.getVarps(), 0, oldVarps, 0, oldVarps.length);

        // For all varbits, add their ids to the multimap with the varp index as their
        // key
        clientThread.invoke(() -> {
            if (client.getIndexConfig() == null) {
                return false;
            }
            IndexDataBase indexVarbits = client.getIndexConfig();
            final int[] varbitIds = indexVarbits.getFileIds(VARBITS_ARCHIVE_ID);
            for (int id : varbitIds) {
                VarbitComposition varbit = client.getVarbit(id);
                if (varbit != null) {
                    varpToVarbitMapping.put(varbit.getIndex(), id);
                }
            }
            return true;
        });
    }

    @Schedule(period = 5 * 60, unit = ChronoUnit.SECONDS, asynchronous = true)
    public void resyncManifest() {
        // log.debug("Attempting to resync manifest");
        if (manifestManager.getManifest().getVersion() != getLastManifestVersion()) {
            getManifest();
        }
    }

    @Schedule(period = 10, unit = ChronoUnit.SECONDS, asynchronous = true)
    public void scheduledSubmit() {
        if (stopTryingForAccount.get()) {
            return;
        }
        if (client != null
                && (client.getGameState() != GameState.HOPPING && client.getGameState() != GameState.LOGIN_SCREEN)) {
            submitToAPI();
            if (client.getLocalPlayer() != null) {
                String username = client.getLocalPlayer().getName();

                isUserRegisteredAsync(username, isRegistered -> {
                    if (isRegistered) {
                        embargoPanel.updateLoggedIn(true);
                    } else {
                        embargoPanel.isLoggedIn = false;
                        embargoPanel.updateLoggedIn(false);
                        embargoPanel.logOut();
                    }
                });
            }
        } else {
            // log.debug("User is hopping or logged out, do not send data");
            embargoPanel.isLoggedIn = false;
            embargoPanel.updateLoggedIn(false);
            embargoPanel.logOut();
        }
    }

}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gg.embargo.ui;

import com.google.inject.Inject;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.annotations.Component;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
public class SyncButtonManager {

    private static final int COLLECTION_LOG_SETUP = 7797;
    private static final int[] SPRITE_IDS_INACTIVE = {
            SpriteID.DIALOG_BACKGROUND,
            SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_TOP_LEFT,
            SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_TOP_RIGHT,
            SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_BOTTOM_LEFT,
            SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_BOTTOM_RIGHT,
            SpriteID.WORLD_MAP_BUTTON_EDGE_LEFT,
            SpriteID.WORLD_MAP_BUTTON_EDGE_TOP,
            SpriteID.WORLD_MAP_BUTTON_EDGE_RIGHT,
            SpriteID.WORLD_MAP_BUTTON_EDGE_BOTTOM,
    };

    private static final int[] SPRITE_IDS_ACTIVE = {
            SpriteID.RESIZEABLE_MODE_SIDE_PANEL_BACKGROUND,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_TOP_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM_HOVERED,
    };

    private static final int FONT_COLOUR_INACTIVE = 0xd6d6d6;
    private static final int FONT_COLOUR_ACTIVE = 0xffffff;
    private static final int CLOSE_BUTTON_OFFSET = 28;
    private static final int BUTTON_WIDTH = 71;
    private static final int BUTTON_OFFSET = CLOSE_BUTTON_OFFSET + 5;

    private final Client client;
    private final ClientThread clientThread;
    private final EventBus eventBus;

    @Getter
    @Setter
    private boolean syncAllowed;

    @Inject
    private SyncButtonManager(
            Client client,
            ClientThread clientThread,
            EventBus eventBus
    )
    {
        this.client = client;
        this.clientThread = clientThread;
        this.eventBus = eventBus;
    }

    public void startUp()
    {
        setSyncAllowed(false);
        eventBus.register(this);
        clientThread.invokeLater(() -> tryAddButton(this::onButtonClick));
    }

    public void shutDown()
    {
        eventBus.unregister(this);
        clientThread.invokeLater(this::removeButton);
    }

    @Getter
    @RequiredArgsConstructor
    enum Screen
    {
        // First number is col log container (inner) and second is search button id
        COLLECTION_LOG(40697944, 40697932, InterfaceID.Collection.INFINITY),
        ;

        @Getter(onMethod_ = @Component)
        private final int parentId;

        @Getter(onMethod_ = @Component)
        private final int searchButtonId;

        @Getter(onMethod_ = @Component)
        private final int collectionLogContainer;
    }

    void tryAddButton(Runnable onClick)
    {
        for (Screen screen : Screen.values())
        {
            addButton(screen, onClick);
        }
    }
    @Subscribe
    public void onScriptPostFired(ScriptPostFired scriptPostFired)
    {
        if (scriptPostFired.getScriptId() == COLLECTION_LOG_SETUP)
        {
            removeButton();
            addButton(Screen.COLLECTION_LOG, this::onButtonClick);
        }
    }

    void onButtonClick() {
        setSyncAllowed(true);
        client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
        client.runScript(2240);
        client.addChatMessage(ChatMessageType.CONSOLE, "Embargo", "Your collection log data is being sent to Embargo...", "Embargo");
    }

    void addButton(Screen screen, Runnable onClick)
    {
        Widget parent = client.getWidget(screen.getParentId());
        Widget searchButton = client.getWidget(screen.getSearchButtonId());
        Widget collectionLogContainer = client.getWidget(screen.getCollectionLogContainer());
        Widget[] containerChildren;
        Widget draggableTopbar;
        if (parent == null || searchButton == null || collectionLogContainer == null ||
                (containerChildren = collectionLogContainer.getChildren()) == null ||
                (draggableTopbar = containerChildren[0]) == null)
        {
            return;
        }

        final int w = BUTTON_WIDTH;
        final int h = searchButton.getOriginalHeight();
        final int x = BUTTON_OFFSET;
        final int y = searchButton.getOriginalY();
        final int cornerDim = 9;

        final Widget[] spriteWidgets = new Widget[9];

        spriteWidgets[0] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[0])
                .setPos(x, y)
                .setSize(w, h)
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setYPositionMode(searchButton.getYPositionMode());

        spriteWidgets[1] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[1])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x + (w - cornerDim), y);
        spriteWidgets[2] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[2])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x, y);
        spriteWidgets[3] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[3])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x + (w - cornerDim), y + h - cornerDim);
        spriteWidgets[4] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[4])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x, y + h - cornerDim);
        // Left and right edges
        int sideWidth = 9;
        int sideHeight = 4;
        spriteWidgets[5] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[5])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(sideWidth, sideHeight)
                .setPos(x + (w - sideWidth), y + cornerDim);
        spriteWidgets[7] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[7])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(sideWidth, sideHeight)
                .setPos(x, y + cornerDim);

        // Top and bottom edges
        int topWidth = 53;
        int topHeight = 9;
        spriteWidgets[6] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[6])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(topWidth, topHeight)
                .setPos(x + cornerDim, y);
        spriteWidgets[8] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[8])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(topWidth, topHeight)
                .setPos(x + cornerDim, y + h - topHeight);
        for (int i = 0; i < 9; i++)
        {
            spriteWidgets[i].revalidate();
        }

        final Widget text = parent.createChild(-1, WidgetType.TEXT)
                .setText("Embargo")
                .setTextColor(FONT_COLOUR_INACTIVE)
                .setFontId(FontID.PLAIN_11)
                .setTextShadowed(true)
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setXTextAlignment(WidgetTextAlignment.CENTER)
                .setYTextAlignment(WidgetTextAlignment.CENTER)
                .setPos(x, y)
                .setSize(w, h)
                .setYPositionMode(searchButton.getYPositionMode());
        text.revalidate();

        // We'll give the text layer the listeners since it covers the whole area
        text.setHasListener(true);
        text.setOnMouseOverListener((JavaScriptCallback) ev ->
        {
            for (int i = 0; i <= 8; i++)
            {
                spriteWidgets[i].setSpriteId(SPRITE_IDS_ACTIVE[i]);
            }
            text.setTextColor(FONT_COLOUR_ACTIVE);
        });
        text.setOnMouseLeaveListener((JavaScriptCallback) ev ->
        {
            for (int i = 0; i <= 8; i++)
            {
                spriteWidgets[i].setSpriteId(SPRITE_IDS_INACTIVE[i]);
            }
            text.setTextColor(FONT_COLOUR_INACTIVE);
        });

        // Register a click listener
        text.setAction(0, "Sync your collection log with Embargo");
        text.setOnOpListener((JavaScriptCallback) ev -> onClick.run());


        // Shrink the top bar to avoid overlapping the new button
        draggableTopbar.setOriginalWidth(draggableTopbar.getOriginalWidth() - (w + (x - CLOSE_BUTTON_OFFSET)));
        draggableTopbar.revalidate();

        // recompute locations / sizes on parent
        parent.revalidate();
    }

    void removeButton()
    {
        for (Screen screen : Screen.values())
        {
            Widget parent = client.getWidget(screen.getParentId());
            if (parent != null)
            {
                parent.deleteAllChildren();
                parent.revalidate();
            }
        }
    }
}
package gg.embargo.ui;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.http.api.item.ItemPrice;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
public class MissingRequirementsPanel extends PluginPanel {
    private static final String OSRS_WIKI_BASE_URL = "https://oldschool.runescape.wiki/w/";
    private static final int ITEMS_PER_ROW = 5;
    private static final int CELL_SIZE = 32;
    private static final int TOOLTIP_PADDING = 3;
    private static final Color HOVER_COLOR = ColorScheme.DARKER_GRAY_HOVER_COLOR;
    private static final Color NORMAL_COLOR = ColorScheme.DARKER_GRAY_COLOR;

    // Cache for item icons to avoid recreating them
    private final Map<Integer, BufferedImage> iconCache = new ConcurrentHashMap<>();
    private final Map<String, BufferedImage> letterIconCache = new ConcurrentHashMap<>();
    private volatile boolean isUpdating = false;

    private final ItemManager itemManager;
    private final JPanel itemsContainer;
    private final List<MissingItem> missingItems = new ArrayList<>();
    private final MouseAdapter itemMouseAdapter = createMouseAdapter();
    private final Object lock = new Object();

    @Getter
    private enum DynamicItems {
        ACCOUNT_POINTS("account points"),
        EHB("EHB"),
        COMMUNITY_POINTS("community points"),
        TOTAL_LEVEL("total level");

        private final String label;

        DynamicItems(String label) {
            this.label = label;
        }

    }

    @Inject
    public MissingRequirementsPanel(ItemManager itemManager) {
        super(false);
        this.itemManager = itemManager;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(new EmptyBorder(10, 10, 10, 10));

        // Create title panel
        add(createTitlePanel(), BorderLayout.NORTH);

        // Create items container
        itemsContainer = new JPanel();
        itemsContainer.setLayout(new GridLayout(0, ITEMS_PER_ROW, 2, 2));
        itemsContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JScrollPane scrollPane = new JScrollPane(itemsContainer);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setBorder(null);
        add(scrollPane, BorderLayout.CENTER);
    }

    private JPanel createTitlePanel() {
        JPanel titlePanel = new JPanel(new BorderLayout());
        titlePanel.setBorder(new EmptyBorder(0, 0, 10, 0));
        titlePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JLabel title = new JLabel("Missing Requirements");
        title.setForeground(Color.WHITE);
        title.setFont(new Font("SansSerif", Font.BOLD, 16));
        titlePanel.add(title, BorderLayout.NORTH);

        JLabel subtitle = new JLabel("Hover for details, click to open wiki");
        subtitle.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        subtitle.setFont(new Font("SansSerif", Font.ITALIC, 10));
        titlePanel.add(subtitle, BorderLayout.SOUTH);

        return titlePanel;
    }

    /**
     * Adds a missing item to the panel if it doesn't already exist
     * 
     * @param itemName The name of the item
     * @param itemId   The item ID in RuneScape
     */
    public void addMissingItem(String itemName, int itemId) {
        synchronized (lock) {
            // Clean up the item name
            String cleanedName = itemName.replace("\"", "").replace(" (uncharged)", "");

            // Handle case where itemName is empty but we have an itemId
            if (itemName.isEmpty() && itemId != -1) {
                ItemComposition ic = itemManager.getItemComposition(itemId);
                String itemNameFromId = ic.getName();

                // Check if this item already exists in our list
                if (missingItems.stream().anyMatch(item -> Objects.equals(item.getItemName(), itemNameFromId))) {
                    log.debug("Item {} already exists, skipping", itemNameFromId);
                    return;
                }

                // Add the item with name from ItemComposition
                BufferedImage itemIcon = getItemIcon(itemId, itemNameFromId);
                log.debug("Adding untrackable item: {}", itemNameFromId);
                missingItems.add(new MissingItem(itemNameFromId, itemId, itemIcon));
                updatePanel();
                return;
            }

            // Check if this is a dynamic item that already exists by type, not exact name
            boolean isDynamicItem = false;
            EnumSet<DynamicItems> dynamicItemsSet = EnumSet.of(
                    DynamicItems.ACCOUNT_POINTS,
                    DynamicItems.EHB,
                    DynamicItems.TOTAL_LEVEL,
                    DynamicItems.COMMUNITY_POINTS);

            for (DynamicItems dynamicItem : dynamicItemsSet) {
                if (cleanedName.contains(dynamicItem.getLabel())) {
                    isDynamicItem = true;
                    boolean didRefreshItem = refreshDynamicItems(itemName, dynamicItemsSet);
                    if (didRefreshItem) {
                        return; // Successfully refreshed the dynamic item
                    }
                    break;
                }
            }

            // If not a dynamic item, check for exact match as before
            if (!isDynamicItem && !cleanedName.isEmpty() && missingItems.stream()
                    .anyMatch(item -> Objects.equals(item.getItemName(), cleanedName))) {
                log.debug("Item {} already exists, returning", cleanedName);
                return;
            }

            // Handle special cases for specific items
            int finalItemId = itemId;
            if (cleanedName.toLowerCase().contains("quiver")) {
                finalItemId = 28947;
            } else if (cleanedName.toLowerCase().contains("infernal cape")) {
                finalItemId = 21295;
            }

            // Process the item and add it to the panel
            BufferedImage itemIcon;
            if (itemName.contains("Combat Achievement")) {
                finalItemId = getHiltIdFromName(itemName);
                itemIcon = getHiltImageFromName(itemName.split(" ")[0]);
            } else {
                itemIcon = getItemIcon(finalItemId, cleanedName);
            }
            missingItems.add(new MissingItem(cleanedName, finalItemId, itemIcon));
            log.debug("Added new item to panel: {}", cleanedName);
            updatePanel();
        }
    }

    public boolean refreshDynamicItems(String itemName, EnumSet<DynamicItems> dynamicItemsEnumSet) {
        synchronized (lock) {
            String cleanedItemName = itemName.replaceAll("^\"|\"$", "");
            boolean itemRemoved = false;

            // First, remove any existing items that match the dynamic type
            Iterator<MissingItem> iterator = missingItems.iterator();
            while (iterator.hasNext()) {
                MissingItem item = iterator.next();

                // Check if this existing item matches any of our dynamic types
                for (DynamicItems dynamicItem : dynamicItemsEnumSet) {
                    if (item.itemName.contains(dynamicItem.getLabel()) &&
                            cleanedItemName.contains(dynamicItem.getLabel())) {
                        // Found a match - remove the old item
                        iterator.remove();
                        itemRemoved = true;
                        log.debug("Removed dynamic item {} to be replaced with {}",
                                item.itemName, cleanedItemName);
                        break;
                    }
                }
            }

            // Now add the new item if we removed an old one
            if (itemRemoved) {
                // Add the new item with updated value
                missingItems.add(new MissingItem(cleanedItemName, -1,
                        getItemIcon(-1, cleanedItemName)));
                log.debug("Added new dynamic item: {}", cleanedItemName);
                updatePanel(); // Make sure to update the panel to reflect changes
                return true;
            } else {
                return false;
            }
        }
    }

    @Getter
    public enum AchievementHilts {
        EASY(25926),
        MEDIUM(25928),
        HARD(25930),
        ELITE(25932),
        MASTER(25934),
        GRANDMASTER(25936);

        private final int itemId;

        AchievementHilts(int itemId) {
            this.itemId = itemId;
        }
    }

    public BufferedImage getHiltImageFromName(String name) {
        String lowercaseName = name.toLowerCase();
        // Strip out extra "'s
        lowercaseName = lowercaseName.replace("\"", "");

        for (AchievementHilts hilt : AchievementHilts.values()) {
            // Shortcut to bypass conflicting name with "Master" being in "Grandmaster"
            if (lowercaseName.contains("grand")) {
                return getItemIcon(AchievementHilts.GRANDMASTER.getItemId(), "Ghommal's_avernic_defender_6");
            }

            if (lowercaseName.contains(hilt.name().toLowerCase())) {
                return getItemIcon(hilt.getItemId(), "Ghommal's_avernic_defender_" + (hilt.ordinal() + 1));
            }
        }
        return getItemIcon(882, "Bronze arrow");
    }

    public int getHiltIdFromName(String name) {
        String lowercaseName = name.toLowerCase();

        // Special case for Grandmaster since conflicting master in name
        if (lowercaseName.contains("grand")) {
            return AchievementHilts.GRANDMASTER.getItemId();
        }

        // Check for other hilt types
        for (AchievementHilts hilt : AchievementHilts.values()) {
            if (lowercaseName.contains(hilt.name().toLowerCase())) {
                return hilt.getItemId();
            }
        }

        return 882;
    }

    /**
     * Clears all missing items from the panel
     */
    public void clearItems() {
        synchronized (lock) {

            if (!missingItems.isEmpty()) {
                missingItems.clear();
                updatePanel();
            }
        }
    }

    /**
     * Updates the panel with the current list of missing items
     */
    private void updatePanel() {

        if (isUpdating) {
            return; // Prevent concurrent updates
        }

        try {
            isUpdating = true;
            SwingUtilities.invokeLater(() -> {
                synchronized (lock) {
                    itemsContainer.removeAll();
                    for (MissingItem item : missingItems) {
                        JPanel itemPanel = createItemPanel(item);
                        itemsContainer.add(itemPanel);
                    }
                    revalidate();
                    repaint();
                }
            });
        } finally {
            isUpdating = false;
        }
    }

    /**
     * Creates a panel for a single item with icon and hover/click functionality
     */
    private JPanel createItemPanel(MissingItem item) {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBackground(NORMAL_COLOR);
        panel.setBorder(new LineBorder(Color.BLACK, 1));
        panel.setPreferredSize(new Dimension(CELL_SIZE, CELL_SIZE));
        panel.setMinimumSize(new Dimension(CELL_SIZE, CELL_SIZE));
        panel.setMaximumSize(new Dimension(CELL_SIZE, CELL_SIZE));

        // Get the item icon
        JLabel iconLabel = new JLabel(new ImageIcon(item.getIcon()));
        iconLabel.setHorizontalAlignment(SwingConstants.CENTER);
        panel.add(iconLabel, BorderLayout.CENTER);
        panel.setToolTipText(buildTooltipText(item));

        // Add hover effect and click handler to the panel
        panel.addMouseListener(itemMouseAdapter);

        return panel;
    }

    private MouseAdapter createMouseAdapter() {
        return new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                JPanel panel = (JPanel) e.getSource();
                panel.setBackground(HOVER_COLOR);
                panel.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                JPanel panel = (JPanel) e.getSource();
                panel.setBackground(NORMAL_COLOR);
                panel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            }

            @Override
            public void mouseClicked(MouseEvent e) {
                JPanel panel = (JPanel) e.getSource();
                Component[] components = itemsContainer.getComponents();
                int index = -1;

                for (int i = 0; i < components.length; i++) {
                    if (components[i] == panel) {
                        index = i;
                        break;
                    }
                }

                if (index >= 0 && index < missingItems.size()) {
                    MissingItem item = missingItems.get(index);
                    if (item.getItemId() == -1) {
                        return;
                    }
                    String wikiUrl = OSRS_WIKI_BASE_URL + item.getItemName().replace(" ", "_");
                    LinkBrowser.browse(wikiUrl);
                }
            }
        };
    }

    /**
     * Gets the item icon from the ItemManager or a default icon if not found
     */
    private BufferedImage getItemIcon(int itemId, String itemName) {
        // Check cache first
        if (itemId != -1) {
            BufferedImage cachedIcon = iconCache.get(itemId);
            if (cachedIcon != null) {
                return cachedIcon;
            }

            BufferedImage icon = itemManager.getImage(itemId);
            BufferedImage resizedIcon = ImageUtil.resizeImage(icon, CELL_SIZE, CELL_SIZE);
            iconCache.put(itemId, resizedIcon);
            return resizedIcon;
        } else {
            // For letter-based icons, create a cache key
            String letter = getLetterForItem(itemName);
            String cacheKey = letter + "_" + CELL_SIZE;

            BufferedImage cachedIcon = letterIconCache.get(cacheKey);
            if (cachedIcon != null) {
                return cachedIcon;
            }

            BufferedImage icon = createLetterIcon(letter);
            letterIconCache.put(cacheKey, icon);
            return icon;
        }
    }

    private String getLetterForItem(String itemName) {
        if (itemName.contains("community")) {
            return "CP";
        } else if (itemName.contains("account")) {
            return "AP";
        } else if (itemName.contains("EHB")) {
            return "EHB";
        } else if (itemName.contains("EHP")) {
            return "EHP";
        }
        return itemName.substring(0, 1).toUpperCase();
    }

    private BufferedImage createLetterIcon(String letter) {
        BufferedImage icon = new BufferedImage(CELL_SIZE, CELL_SIZE, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = icon.createGraphics();

        // Fill the entire image with the background color
        g2d.setColor(ColorScheme.MEDIUM_GRAY_COLOR);
        g2d.fillRect(0, 0, CELL_SIZE, CELL_SIZE);
        g2d.setColor(Color.WHITE);

        // Calculate appropriate font size based on text length
        int fontSize = 16; // Default font size
        if (letter.length() > 1) {
            // Reduce font size for longer text
            fontSize = Math.max(8, 16 - (letter.length() - 1) * 2);
        }

        g2d.setFont(new Font("SansSerif", Font.BOLD, fontSize));

        // Ensure text fits within the cell
        FontMetrics fm = g2d.getFontMetrics();
        while (fm.stringWidth(letter) > CELL_SIZE - 2 && fontSize > 8) {
            fontSize--;
            g2d.setFont(new Font("SansSerif", Font.BOLD, fontSize));
            fm = g2d.getFontMetrics();
        }

        int x = (CELL_SIZE - fm.stringWidth(letter)) / 2;
        int y = ((CELL_SIZE - fm.getHeight()) / 2) + fm.getAscent();
        g2d.drawString(letter, x, y);
        g2d.dispose();

        return icon;
    }

    /**
     * Builds the tooltip text for an item
     */
    private String buildTooltipText(MissingItem item) {
        StringBuilder sb = new StringBuilder("<html><body style='padding: ");
        sb.append(TOOLTIP_PADDING).append("px;");

        if (item.getItemId() == -1) {
            sb.append(" text-align: center;");
        }

        sb.append("'><div style='font-weight: bold;");

        if (item.getItemId() != -1) {
            sb.append(" margin-bottom: 3px;");
        }

        sb.append("'>").append(item.getItemName()).append("</div>");

        if (item.getItemId() != -1) {
            sb.append("<div style='color: #99FFFF; font-style: italic;'>Click to open wiki</div>");
        }

        sb.append("</body></html>");
        return sb.toString();
    }

    /**
     * Attempts to find an item ID by name using the ItemManager
     */
    public int findItemIdByName(String itemName) {
        String searchName = itemName.replace("\"", "");
        List<ItemPrice> itemPrices = itemManager.search(searchName);
        if (itemPrices.isEmpty()) {
            return -1;
        }

        return itemPrices.get(0).getId();
    }

    /**
     * Class to represent a missing item
     */
    @Getter
    private static class MissingItem {
        private final String itemName;
        private final int itemId;

        @Setter
        private BufferedImage icon;

        public MissingItem(String itemName, int itemId, BufferedImage icon) {
            this.itemName = itemName;
            this.itemId = itemId;
            this.icon = icon;
        }
    }
}

package gg.embargo.ui;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import gg.embargo.DataManager;
import gg.embargo.EmbargoPlugin;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.plugins.info.JRichTextPane;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;

@Slf4j
public class EmbargoPanel extends PluginPanel {
    @Inject
    @Nullable
    private Client client;
    @Inject
    private EventBus eventBus;

    @Inject
    private DataManager dataManager;

    @Inject
    private MissingRequirementsPanel missingRequirementsPanelX;

    @Inject
    private ClientThread clientThread;

    @Setter
    public boolean isLoggedIn = false;

    // Keep track of all boxes
    // private final ArrayList<ItemID> items = new ArrayList<>();
    JPanel versionPanel = new JPanel();
    JPanel missingRequirementsPanel = new JPanel();
    private static final ImageIcon ARROW_RIGHT_ICON = new ImageIcon(
            ImageUtil.loadImageResource(EmbargoPanel.class, "/util/arrow_right.png"));
    private static final ImageIcon DISCORD_ICON = new ImageIcon(
            ImageUtil.loadImageResource(EmbargoPanel.class, "/discord_icon.png"));
    static ImageIcon GITHUB_ICON = new ImageIcon(ImageUtil.loadImageResource(EmbargoPanel.class, "/github_icon.png"));
    static ImageIcon WEBSITE_ICON = new ImageIcon(ImageUtil.loadImageResource(EmbargoPanel.class, "/website_icon.png"));
    private final JRichTextPane emailLabel = new JRichTextPane();
    private final JLabel loggedLabel = new JLabel();
    private final JLabel embargoScoreLabel = new JLabel(htmlLabel("Embargo Score:", " N/A"));
    private final JLabel accountScoreLabel = new JLabel(htmlLabel("Account Score:", " N/A"));
    private final JLabel communityScoreLabel = new JLabel(htmlLabel("Community Score:", " N/A"));
    private final JLabel currentRankLabel = new JLabel(htmlLabel("Current Rank:", " N/A"));
    private final JLabel isRegisteredWithClanLabel = new JLabel(htmlLabel("Account registered:", " No"));
    private final JLabel currentCALabel = new JLabel(htmlLabel("Current TA Tier:", " N/A"));
    final JLabel missingRequiredItemsLabel = new JLabel(
            htmlLabel("Sign in to see what requirements", " you are missing for rank up"));
    private final Font smallFont = FontManager.getRunescapeSmallFont();
    final JPanel missingRequirementsContainer = new JPanel(new BorderLayout(5, 0));

    @Inject
    private EmbargoPanel() {
    }

    private String htmlLabel(String key, String value) {
        return "<html><body style = 'color:#a5a5a5'>" + key + "<span style = 'color:white'>" + value
                + "</span></body></html>";
    }

    void setupVersionPanel() {
        // Set up Embargo Clan Version at top of Version panel
        JLabel version = new JLabel(htmlLabel("Embargo Clan Version: ", "1.4.5"));
        version.setFont(smallFont);

        // Set version's font
        JLabel revision = new JLabel();
        revision.setFont(smallFont);

        // Set up versionPanel
        versionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        versionPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        versionPanel.setLayout(new GridLayout(0, 1));

        // Set up custom embargo labels
        isRegisteredWithClanLabel.setFont(smallFont);
        isRegisteredWithClanLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        embargoScoreLabel.setFont(smallFont);
        embargoScoreLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        accountScoreLabel.setFont(smallFont);
        accountScoreLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        communityScoreLabel.setFont(smallFont);
        communityScoreLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        currentCALabel.setFont(smallFont);
        currentCALabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        loggedLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        loggedLabel.setFont(smallFont);

        currentRankLabel.setFont(smallFont);
        currentRankLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        emailLabel.setForeground(Color.WHITE);
        emailLabel.setFont(smallFont);

        versionPanel.add(version);
        versionPanel.add(Box.createGlue());
        versionPanel.add(loggedLabel);
        versionPanel.add(emailLabel);
        versionPanel.add(isRegisteredWithClanLabel);
        versionPanel.add(embargoScoreLabel);
        versionPanel.add(accountScoreLabel);
        versionPanel.add(communityScoreLabel);
        versionPanel.add(currentCALabel);
    }

    JPanel setUpQuickLinks() {
        JPanel actionsContainer = new JPanel();
        actionsContainer.setBorder(new EmptyBorder(10, 0, 0, 0));
        actionsContainer.setLayout(new GridLayout(0, 1, 0, 10));

        actionsContainer.add(buildLinkPanel(DISCORD_ICON, "Join us on our", "Discord", "https://discord.gg/embargo"));
        actionsContainer.add(buildLinkPanel(WEBSITE_ICON, "Go to our", "clan website", "https://embargo.gg/"));
        actionsContainer.add(buildLinkPanel(GITHUB_ICON, "Report a bug or", "inspect the plugin code",
                "https://github.com/Sharpienero/Embargo-Plugin"));

        return actionsContainer;
    }

    void setupMissingItemsPanel() {
        // Clear any existing content
        missingRequirementsContainer.removeAll();
        missingRequirementsPanel.removeAll();

        // Set up container styling
        missingRequirementsContainer.setBorder(new EmptyBorder(7, 7, 7, 7));
        missingRequirementsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        missingRequirementsContainer.setFont(FontManager.getRunescapeSmallFont());
        missingRequirementsContainer.setForeground(Color.WHITE);

        // Set up panel styling
        missingRequirementsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        missingRequirementsPanel.setBorder(new EmptyBorder(10, 0, 10, 0));
        missingRequirementsPanel.setLayout(new GridLayout(1, 1));

        // Always add the default message initially
        missingRequiredItemsLabel
                .setText(htmlLabel("Sign in to see what requirements", " you are missing for rank up"));
        missingRequiredItemsLabel.setFont(smallFont);
        missingRequiredItemsLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        missingRequirementsPanel.add(missingRequiredItemsLabel);

        // Add panel to container
        missingRequirementsContainer.add(missingRequirementsPanel, BorderLayout.CENTER);

        // Add container to main panel
        this.add(missingRequirementsContainer, BorderLayout.NORTH);
        this.revalidate();
    }

    void addSidePanel() {
        // Add the panels to the side plugin
        this.add(versionPanel, BorderLayout.NORTH);
        setupMissingItemsPanel();
        this.add(this.setUpQuickLinks(), BorderLayout.SOUTH);
    }

    void setupSidePanel() {
        this.setupVersionPanel();
        this.setUpQuickLinks();
        this.addSidePanel();

        // Update version panel with Embargo plugin information
        updateLoggedIn(false);
    }

    public void init() {
        this.setupSidePanel();
        logOut();
    }

    public void updateLoggedIn(boolean scheduled) {
        if (dataManager.stopTryingForAccount.get()) {
            emailLabel.setText("Account not registered with Embargo");
            missingRequirementsPanelX.removeAll();
            missingRequirementsContainer.removeAll();
            missingRequirementsPanel.removeAll();
            missingRequiredItemsLabel.removeAll();
            missingRequirementsContainer.removeAll();
            missingRequirementsContainer.revalidate();
            missingRequirementsContainer.repaint();
            return;
        }
        if (!isLoggedIn || scheduled) {
            if (client != null && client.getLocalPlayer() != null) {
                this.isLoggedIn = true;
                var username = client.getLocalPlayer().getName();

                loggedLabel.setText(htmlLabel("Signed in as ", " " + username));


                dataManager.isUserRegisteredAsync(username, isRegistered -> {
                    if (!isRegistered) {
                        emailLabel.setText("Account not registered with Embargo");
                        return;
                    }
                });

                // remove "Sign in to send..."
                versionPanel.remove(emailLabel);

                // re-register labels with panel
                versionPanel.add(isRegisteredWithClanLabel);
                versionPanel.add(embargoScoreLabel);
                versionPanel.add(accountScoreLabel);
                versionPanel.add(communityScoreLabel);
                versionPanel.add(currentRankLabel);
                versionPanel.add(currentCALabel);

                isRegisteredWithClanLabel.setText(htmlLabel("Account registered:", " Yes"));

                // get gear asynchronously
                dataManager.getProfileAsync(username).thenAccept(embargoProfileData -> {
                    // This code runs when the profile data is received
                    // We need to run UI updates on the client thread
                    clientThread.invokeLater(() -> {
                        JsonElement currentAccountPoints = embargoProfileData.get("accountPoints");
                        JsonElement currentCommunityPoints = embargoProfileData
                                .getAsJsonPrimitive("communityPoints");

                        embargoScoreLabel.setText((htmlLabel("Embargo Score:", " " +
                                (Integer.parseInt(String.valueOf(currentAccountPoints)) +
                                        Integer.parseInt(String.valueOf(currentCommunityPoints))))));

                        JsonElement getCurrentCAName = embargoProfileData.get("currentHighestCAName");
                        accountScoreLabel.setText(htmlLabel("Account Score: ",
                                String.valueOf(Integer.parseInt(String.valueOf(currentAccountPoints)))));

                        communityScoreLabel.setText(htmlLabel("Community Score: ",
                                String.valueOf(Integer.parseInt(String.valueOf(currentCommunityPoints)))));

                        JsonArray missingGearReqs = embargoProfileData.getAsJsonArray("missingGearRequirements");
                        JsonArray missingUntradableItemIdReqs = embargoProfileData
                                .getAsJsonArray("missingUntradableItemIds");

                        JsonObject currentRank = embargoProfileData.getAsJsonObject("currentRank");
                        JsonElement currentRankName = currentRank.get("name");

                        var currentRankDisplay = String.valueOf(currentRankName).replace("\"", "");
                        currentRankLabel.setText(htmlLabel("Current Rank:", " " + currentRankDisplay));

                        var displayCAName = String.valueOf(getCurrentCAName).replace("\"", "");
                        displayCAName = displayCAName.replace(" Combat Achievement", "");

                        currentCALabel.setText(htmlLabel("Current CA Tier:", " " + displayCAName));

                        ArrayList<String> alreadyProcessed = new ArrayList<>();

                        // Build out the missing requirements panel
                        if (missingGearReqs.size() > 0 || missingUntradableItemIdReqs.size() > 0) {
                            for (JsonElement mi : missingGearReqs) {
                                alreadyProcessed.add(mi.getAsString());
                                log.debug("Processing {} in missingGearReqs", mi.getAsString());
                                clientThread.invokeLater(
                                        () -> missingRequirementsPanelX.addMissingItem(String.valueOf(mi),
                                                missingRequirementsPanelX.findItemIdByName(String.valueOf(mi))));
                            }

                            for (JsonElement mu : missingUntradableItemIdReqs) {
                                if (alreadyProcessed.contains(mu.getAsString())) {
                                    log.debug("{} already added, skipping missingUntradableItemIdReqs",
                                            mu.getAsString());
                                    continue;
                                }
                                missingRequirementsPanelX.addMissingItem("", mu.getAsInt());
                            }

                            // Clear the panel first
                            missingRequirementsPanel.removeAll();

                            // Add only the missingRequirementsPanelX (not the label)
                            missingRequirementsPanel.add(missingRequirementsPanelX);

                            // Refresh the panel
                            missingRequirementsPanel.revalidate();
                            missingRequirementsPanel.repaint();
                        } else {
                            missingRequiredItemsLabel.setText(htmlLabel("Missing Requirements: ", "None"));
                        }
                    });
                }).exceptionally(ex -> {
                    log.error("Error fetching profile data", ex);
                    return null;
                });

                this.isLoggedIn = true;

            }
        }
    }

    public void logOut() {
        // log.debug("inside of logOut()");
        this.isLoggedIn = false;

        // Update labels
        emailLabel.setContentType("text/html");
        emailLabel.setText("Sign in to send data to Embargo.");
        loggedLabel.setText("Not signed in");

        // Reset missing gear requirements
        missingRequiredItemsLabel
                .setText(htmlLabel("Sign in to see what requirements", " you are missing for rank up"));
        missingRequiredItemsLabel.setFont(smallFont);
        missingRequiredItemsLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        missingRequirementsPanelX.clearItems();

        // Rebuild missing requirements panel
        missingRequirementsContainer.removeAll();
        missingRequirementsPanel.removeAll();
        missingRequirementsPanel.add(missingRequiredItemsLabel);
        missingRequirementsContainer.add(missingRequirementsPanel, BorderLayout.CENTER);

        // Set to NA
        isRegisteredWithClanLabel.setText(htmlLabel("Account registered:", " No"));
        embargoScoreLabel.setText(htmlLabel("Embargo Score:", " N/A"));
        currentRankLabel.setText(htmlLabel("Current Rank:", " N/A"));
        accountScoreLabel.setText(htmlLabel("Account Score:", " N/A"));
        communityScoreLabel.setText(htmlLabel("Community Score:", " N/A"));
        currentCALabel.setText(htmlLabel("Current TA Tier:", " N/A"));

        // Rebuild version panel
        versionPanel.remove(isRegisteredWithClanLabel);
        versionPanel.remove(embargoScoreLabel);
        versionPanel.remove(accountScoreLabel);
        versionPanel.remove(communityScoreLabel);
        versionPanel.remove(currentRankLabel);
        versionPanel.remove(currentCALabel);

        // Make sure email label is added
        if (!containsComponent(versionPanel, emailLabel)) {
            versionPanel.add(emailLabel);
        }

        // Refresh UI
        versionPanel.revalidate();
        versionPanel.repaint();
        missingRequirementsPanel.revalidate();
        missingRequirementsPanel.repaint();
        missingRequirementsContainer.revalidate();
        missingRequirementsContainer.repaint();
        this.revalidate();
        this.repaint();
    }

    // Helper method to check if a container contains a component
    private boolean containsComponent(Container container, Component component) {
        Component[] components = container.getComponents();
        for (Component c : components) {
            if (c.equals(component)) {
                return true;
            }
        }
        return false;
    }

    public void reset() {
        eventBus.unregister(this);
        this.updateLoggedIn(false);
    }

    /**
     * Builds a link panel with a given icon, text and url to redirect to.
     */
    private static JPanel buildLinkPanel(ImageIcon icon, String topText, String bottomText, String url) {
        return buildLinkPanel(icon, topText, bottomText, () -> LinkBrowser.browse(url));
    }

    /**
     * Builds a link panel with a given icon, text and callable to call.
     */
    private static JPanel buildLinkPanel(ImageIcon icon, String topText, String bottomText, Runnable callback) {
        JPanel container = new JPanel();
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        container.setLayout(new BorderLayout());
        container.setBorder(new EmptyBorder(10, 10, 10, 10));

        final Color hoverColor = ColorScheme.DARKER_GRAY_HOVER_COLOR;
        final Color pressedColor = ColorScheme.DARKER_GRAY_COLOR.brighter();

        JLabel iconLabel = new JLabel(icon);
        container.add(iconLabel, BorderLayout.WEST);

        JPanel textContainer = new JPanel();
        textContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        textContainer.setLayout(new GridLayout(2, 1));
        textContainer.setBorder(new EmptyBorder(5, 10, 5, 10));

        container.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent mouseEvent) {
                container.setBackground(pressedColor);
                textContainer.setBackground(pressedColor);
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                callback.run();
                container.setBackground(hoverColor);
                textContainer.setBackground(hoverColor);
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                container.setBackground(hoverColor);
                textContainer.setBackground(hoverColor);
                container.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                textContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                container.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            }
        });

        JLabel topLine = new JLabel(topText);
        topLine.setForeground(Color.WHITE);
        topLine.setFont(FontManager.getRunescapeSmallFont());

        JLabel bottomLine = new JLabel(bottomText);
        bottomLine.setForeground(Color.WHITE);
        bottomLine.setFont(FontManager.getRunescapeSmallFont());

        textContainer.add(topLine);
        textContainer.add(bottomLine);

        container.add(textContainer, BorderLayout.CENTER);

        JLabel arrowLabel = new JLabel(ARROW_RIGHT_ICON);
        container.add(arrowLabel, BorderLayout.EAST);

        return container;
    }
}

/*
Almost all of this code was taken from the tob-notice-board plugin by Broooklyn
https://github.com/Broooklyn/runelite-external-plugins/tree/tob-notice-board
Modifications were made to work with clans by Sharpienero/Embargo

Added TOA code
 13/04/2025 - Converted to use gamevals
 */


package gg.embargo.noticeboard;

import gg.embargo.EmbargoConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.clan.ClanChannelMember;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.util.Text;
import net.runelite.client.callback.ClientThread;


import javax.inject.Inject;

@Slf4j
public class NoticeBoardManager {
    @Inject
    private Client client;

    @Inject
    private EmbargoConfig config;

    @Inject
    private ClientThread clientThread;

    private final EventBus eventBus;



    @Inject
    public NoticeBoardManager(Client client, ClientThread clientThread, EventBus eventBus) {
        this.client = client;
        this.clientThread = clientThread;
        this.eventBus = eventBus;
    }

    private static final int DEFAULT_RGB = 0xff981f;
    private static final int STARTING_PARTY_CHILD_ID = 17;
    private static final int ENDING_PARTY_CHILD_ID = 62;

    private void setNoticeBoardWidget(int parent, int index, int clanColor) {
        for (int childID = STARTING_PARTY_CHILD_ID; childID < ENDING_PARTY_CHILD_ID; ++childID) {
            Widget noticeBoard = client.getWidget(parent, childID);

            if (noticeBoard != null && noticeBoard.getName() != null && noticeBoard.getChildren() != null) {
                for (Widget noticeBoardChild : noticeBoard.getChildren()) {
                    if (noticeBoardChild.getIndex() == index) {
                        if (client.getClanChannel() != null) {
                            for (ClanChannelMember member : client.getClanChannel().getMembers()) {
                                if (Text.toJagexName(member.getName()).equals(Text.removeTags(noticeBoard.getName()))) {
                                    noticeBoardChild.setTextColor(config.highlightClan() ? clanColor : DEFAULT_RGB);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    private void setApplicationWidget(int parent, int child, int clanColor) {
        Widget acceptWidgetMembers = client.getWidget(parent, child);
        if (acceptWidgetMembers != null && acceptWidgetMembers.getChildren() != null) {
            Widget[] acceptWidgetChildren = acceptWidgetMembers.getChildren();
            for (Widget w : acceptWidgetChildren) {
                if (client != null && client.getClanChannel() != null) {
                    for (ClanChannelMember member : client.getClanChannel().getMembers()) {
                        if (w.getText().contains(member.getName())) {
                            String hex = Integer.toHexString(clanColor).substring(2);
                            String builtName = "<col=" + hex + ">" + member.getName() + "</col>";
                            w.setName("<col=" + hex + ">" + member.getName() + "</col>");
                            w.setText(builtName);
                        }
                    }

                }
            }
        }
    }

    private void setTOBNameColors(int clanColor) {
        setApplicationWidget(50, 42, clanColor);
        setNoticeBoardWidget(364, 3, clanColor);
    }

    private void setTOANameColors(int clanColor) {
        setApplicationWidget(774, 48, clanColor);
        setNoticeBoardWidget(772, 2, clanColor);
    }

    public void startUp()
    {
        eventBus.register(this);
    }
    public void shutDown()
    {
        unsetNoticeBoards();
        eventBus.unregister(this);
    }

    public void setTOBNoticeBoard()
    {

        setTOBNameColors(config.clanColor().getRGB());
    }

    public void setTOANoticeBoard() {
        setTOANameColors(config.clanColor().getRGB());
    }

    public void setNoticeBoards() {
        if (config.highlightClan()) {
            setTOBNoticeBoard();
            setTOANoticeBoard();
        }
    }

    public void unsetNoticeBoards()
    {
        setTOBNameColors(DEFAULT_RGB);
        setTOANameColors(DEFAULT_RGB);
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded widgetLoaded)
    {
        clientThread.invokeLater(() ->
        {
            // TOB
            if (widgetLoaded.getGroupId() == InterfaceID.TOB_PARTYLIST || widgetLoaded.getGroupId() == InterfaceID.TOB_PARTYDETAILS)
            {
                setTOBNoticeBoard();
            }

            // TOA
            if (widgetLoaded.getGroupId() == InterfaceID.TOA_PARTYLIST|| widgetLoaded.getGroupId() == InterfaceID.TOA_PARTYDETAILS) {
                setTOANoticeBoard();
            }
        });
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        String CONFIG_GROUP = "embargo";
        if (!event.getGroup().equals(CONFIG_GROUP))
        {
            return;
        }

        unsetNoticeBoards();
        if (config.highlightClan()) {
            setTOBNoticeBoard();
            setTOANoticeBoard();
        }
    }
}

/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gg.embargo.collections;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class PlayerDataSubmission
{
    private String username;
    private String profile;
    private PlayerData data;
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gg.embargo.collections;

import lombok.Value;
import net.runelite.client.config.RuneScapeProfileType;

@Value
public class PlayerProfile
{
    String username;
    RuneScapeProfileType profileType;
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gg.embargo.collections;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.HashMap;
import java.util.Map;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PlayerData
{
    public Integer collectionLogItemCount = null;
    public String collectionLogSlots = "";
    public Map<Integer, Integer> collectionLogCounts = new HashMap<>();

}
package gg.embargo.collections;

/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.google.gson.Gson;
import com.google.gson.JsonParseException;
import gg.embargo.EmbargoConfig;
import gg.embargo.manifest.Manifest;
import gg.embargo.manifest.ManifestManager;
import gg.embargo.ui.EmbargoPanel;
import gg.embargo.ui.SyncButtonManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import okhttp3.*;

import javax.inject.Inject;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Slf4j
public class CollectionLogManager {

    private final int VARBITS_ARCHIVE_ID = 14;
    private static final String PLUGIN_USER_AGENT = "Embargo Runelite Plugin";

    private static final String SUBMIT_URL = "https://embargo.gg/api/runelite/uploadcollectionlog";
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
    private final Map<Integer, VarbitComposition> varbitCompositions = new HashMap<>();

    private final Map<PlayerProfile, PlayerData> playerDataMap = new HashMap<>();
    private int cyclesSinceSuccessfulCall = 0;

    // Keeps track of what collection log slots the user has set and map for their counts
    private static final BitSet clogItemsBitSet = new BitSet();
    private final Map<Integer, Integer> clogItemsCountSet = new HashMap<>();

    private static Integer clogItemsCount = null;

    // Map item ids to bit index in the bitset
    private static final HashMap<Integer, Integer> collectionLogItemIdToBitsetIndex = new HashMap<>();
    private int tickCollectionLogScriptFired = -1;
    private final HashSet<Integer> collectionLogItemIdsFromCache = new HashSet<>();

    private SyncButtonManager syncButtonManager;

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private ScheduledExecutorService scheduledExecutorService;

    @Inject
    private EmbargoPanel embargoPanel;

    @Inject
    private Gson gson;

    @Inject
    private EmbargoConfig config;

    @Inject
    private Manifest manifest;

    @Inject
    private ManifestManager manifestManager;

    private final Client client;
    private final ClientThread clientThread;
    private final EventBus eventBus;

    @Inject
    private CollectionLogManager(
            Client client,
            ClientThread clientThread,
            EventBus eventBus) {
        this.client = client;
        this.clientThread = clientThread;
        this.eventBus = eventBus;
    }

    public void startUp(SyncButtonManager mainSyncButtonManager) {
        eventBus.register(this);
        manifestManager.getLatestManifest();
        syncButtonManager = mainSyncButtonManager;

        clientThread.invoke(() -> {
            if (client.getIndexConfig() == null || client.getGameState().ordinal() < GameState.LOGIN_SCREEN.ordinal()) {
                return false;
            }
            manifestManager.getLatestManifest();
            collectionLogItemIdsFromCache.addAll(parseCacheForClog());
            populateCollectionLogItemIdToBitsetIndex();
            final int[] varbitIds = client.getIndexConfig().getFileIds(VARBITS_ARCHIVE_ID);
            for (int id : varbitIds) {
                varbitCompositions.put(id, client.getVarbit(id));
            }
            return true;
        });

    }

    public void shutDown() {
        eventBus.unregister(this);

        clogItemsBitSet.clear();
        clogItemsCountSet.clear();
        clogItemsCount = null;
        syncButtonManager.shutDown();
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        // Submit the collection log data two ticks after the first script prefires
        if (tickCollectionLogScriptFired != -1 &&
                tickCollectionLogScriptFired + 2 < client.getTickCount()) {
            tickCollectionLogScriptFired = -1;
            if (manifestManager.getManifest() == null) {
                client.addChatMessage(ChatMessageType.CONSOLE, "Embargo",
                        "Failed to sync collection log. Try restarting the Embargo plugin.", "Embargo");
                return;
            }
            scheduledExecutorService.execute(this::submitTask);
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState state = gameStateChanged.getGameState();
        switch (state) {
            // When hopping or logging out, we need to clear any state related to the player
            case HOPPING:
            case LOGGING_IN:
            case CONNECTION_LOST:
            case LOGIN_SCREEN: // Add this case to handle explicit logout
                clogItemsBitSet.clear();
                clogItemsCountSet.clear();
                clogItemsCount = null;
                embargoPanel.logOut();
                break;
        }
    }

    /**
     * Finds the index this itemId is assigned to in the collections mapping.
     *
     * @param itemId: The itemId to look up
     * @return The index of the bit that represents the given itemId, if it is in
     *         the map. -1 otherwise.
     */
    private int lookupCollectionLogItemIndex(int itemId) {
        // The map has not loaded yet, or failed to load.
        if (collectionLogItemIdToBitsetIndex.isEmpty()) {
            return -1;
        }
        Integer result = collectionLogItemIdToBitsetIndex.get(itemId);
        if (result == null) {
            log.debug("Item id {} not found in the mapping of items", itemId);
            return -1;
        }
        return result;
    }

    // CollectionLog Subscribe
    @Subscribe
    public void onScriptPreFired(ScriptPreFired preFired) {
        if (syncButtonManager.isSyncAllowed() && preFired.getScriptId() == 4100) {
            tickCollectionLogScriptFired = client.getTickCount();
            if (collectionLogItemIdToBitsetIndex.isEmpty()) {
                return;
            }
            clogItemsCount = collectionLogItemIdsFromCache.size();
            Object[] args = preFired.getScriptEvent().getArguments();
            int itemId = (int) args[1];
            int itemCount = (int) args[2];

            int idx = lookupCollectionLogItemIndex(itemId);
            // We should never return -1 under normal circumstances
            if (idx != -1) {
                clogItemsBitSet.set(idx);
                clogItemsCountSet.put(idx, itemCount);
            }
        }
    }

    synchronized public void submitTask() {
        // If sync hasn't been toggled to be allowed
        if (!syncButtonManager.isSyncAllowed()) {
            return;
        }

        // TODO: do we want other GameStates?
        if (client.getGameState() != GameState.LOGGED_IN || varbitCompositions.isEmpty()) {
            return;
        }

        if (manifestManager.getManifest() == null || client.getLocalPlayer() == null) {
            log.debug("Skipped due to bad manifest: {}", manifest);
            return;
        }

        String username = client.getLocalPlayer().getName();
        RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);
        PlayerProfile profileKey = new PlayerProfile(username, profileType);

        PlayerData newPlayerData = getPlayerData();
        PlayerData oldPlayerData = playerDataMap.computeIfAbsent(profileKey, k -> new PlayerData());

        // Do not send if slot data wasn't generated
        if (newPlayerData.collectionLogSlots.isEmpty()) {
            return;
        }

        submitPlayerData(profileKey, newPlayerData, oldPlayerData);
    }

    private PlayerData getPlayerData() {
        PlayerData out = new PlayerData();

        out.collectionLogSlots = Base64.getEncoder().encodeToString(clogItemsBitSet.toByteArray());
        out.collectionLogCounts = clogItemsCountSet;

        out.collectionLogItemCount = clogItemsCount;
        return out;
    }

    private void merge(PlayerData oldPlayerData, PlayerData delta) {
        oldPlayerData.collectionLogSlots = delta.collectionLogSlots;
        oldPlayerData.collectionLogItemCount = delta.collectionLogItemCount;
    }

    private void submitPlayerData(PlayerProfile profileKey, PlayerData delta, PlayerData old) {
        // If cyclesSinceSuccessfulCall is not a perfect square, we should not try to
        // submit.
        // This gives us quadratic backoff.
        cyclesSinceSuccessfulCall += 1;
        if (Math.pow((int) Math.sqrt(cyclesSinceSuccessfulCall), 2) != cyclesSinceSuccessfulCall) {
            return;
        }

        PlayerDataSubmission submission = new PlayerDataSubmission(
                profileKey.getUsername(),
                profileKey.getProfileType().name(),
                delta);

        Request request = new Request.Builder()
                .addHeader("User-Agent", PLUGIN_USER_AGENT)
                .url(SUBMIT_URL)
                .post(RequestBody.create(JSON, gson.toJson(submission)))
                .build();

        Call call = okHttpClient.newCall(request);
        call.timeout().timeout(3, TimeUnit.SECONDS);
        call.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.debug("Failed to submit: ", e);
            }

            @Override
            public void onResponse(Call call, Response response) {
                try (response) {
                    if (!response.isSuccessful()) {
                        log.debug("Failed to submit: {}", response.code());
                        return;
                    }
                    merge(old, delta);
                    cyclesSinceSuccessfulCall = 0;
                } finally {
                    response.close();
                }
            }
        });
    }

    private void populateCollectionLogItemIdToBitsetIndex() {
        if (manifestManager.getManifest() == null) {
            log.debug("populateCollectionLogItemIdToBitsetIndex manifest is NULL");

            // Only log this message once every few seconds to avoid spam
            if (System.currentTimeMillis() % 5000 < 100) { // Log roughly once every 5 seconds
                log.debug(
                        "Manifest is not present so the collection log bitset index will not be updated, will try again");
            }

            // Request the manifest if needed
            manifestManager.getLatestManifest();

            // Schedule a retry with a longer delay to reduce spam
            scheduledExecutorService.schedule(() -> {
                clientThread.invoke(this::populateCollectionLogItemIdToBitsetIndex);
            }, 1, TimeUnit.SECONDS);

            return;
        }

        log.debug("populateCollectionLogItemIdToBitsetIndex manifest is set as intended, continuing");

        clientThread.invoke(() -> {
            // Add missing keys in order to the map. Order is extremely important here, so
            // we get a stable map given the same cache data.
            List<Integer> itemIdsMissingFromManifest = collectionLogItemIdsFromCache
                    .stream()
                    .filter((t) -> !manifestManager.getManifest().collections.contains(t))
                    .sorted()
                    .collect(Collectors.toList());

            int currentIndex = 0;
            collectionLogItemIdToBitsetIndex.clear();
            for (Integer itemId : manifestManager.getManifest().collections)
                collectionLogItemIdToBitsetIndex.put(itemId, currentIndex++);
            for (Integer missingItemId : itemIdsMissingFromManifest) {
                collectionLogItemIdToBitsetIndex.put(missingItemId, currentIndex++);
            }
        });
    }

    /**
     * Parse the enums and structs in the cache to figure out which item ids
     * exist in the collection log. This can be diffed with the manifest to
     * determine the item ids that need to be appended to the end of the
     * bitset we send to the Embargo server.
     */
    private HashSet<Integer> parseCacheForClog() {
        HashSet<Integer> itemIds = new HashSet<>();
        // 2102 - Struct that contains the highest level tabs in the collection log
        // (Bosses, Raids, etc)
        // https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2102
        int[] topLevelTabStructIds = client.getEnum(2102).getIntVals();
        for (int topLevelTabStructIndex : topLevelTabStructIds) {
            // The collection log top level tab structs contain a param that points to the
            // enum
            // that contains the pointers to sub tabs.
            // ex: https://chisel.weirdgloop.org/structs/index.html?type=structs&id=471
            StructComposition topLevelTabStruct = client.getStructComposition(topLevelTabStructIndex);

            // Param 683 contains the pointer to the enum that contains the subtabs ids
            // ex: https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2103
            int[] subtabStructIndices = client.getEnum(topLevelTabStruct.getIntValue(683)).getIntVals();
            for (int subtabStructIndex : subtabStructIndices) {

                // The subtab structs are for subtabs in the collection log (Commander Zilyana,
                // Chambers of Xeric, etc.)
                // and contain a pointer to the enum that contains all the item ids for that
                // tab.
                // ex subtab struct:
                // https://chisel.weirdgloop.org/structs/index.html?type=structs&id=476
                // ex subtab enum:
                // https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2109
                StructComposition subtabStruct = client.getStructComposition(subtabStructIndex);
                int[] clogItems = client.getEnum(subtabStruct.getIntValue(690)).getIntVals();
                for (int clogItemId : clogItems)
                    itemIds.add(clogItemId);
            }
        }

        // Some items with data saved on them have replacements to fix a duping issue
        // (satchels, flamtaer bag)
        // Enum 3721 contains a mapping of the item ids to replace -> ids to replace
        // them with
        EnumComposition replacements = client.getEnum(3721);
        for (int badItemId : replacements.getKeys())
            itemIds.remove(badItemId);
        for (int goodItemId : replacements.getIntVals())
            itemIds.add(goodItemId);

        return itemIds;
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        String CONFIG_GROUP = "embargo";
        if (!event.getGroup().equals(CONFIG_GROUP)) {
            return;
        }

        if (config.showCollectionLogSyncButton()) {
            syncButtonManager.startUp();
        } else {
            syncButtonManager.shutDown();
        }
    }
}

/*
 * Copyright (c) 2025, andmcadams
 * Modified by Sharpienero for Embargo
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gg.embargo.manifest;

import lombok.Data;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.List;

@Data
public class Manifest
{
    // misc
    final float version = -1;

    //Varp/varb trackable items
    final int[] varbits = new int[0];
    final int[] varps = new int[0];

    //Untrackable items
    public final List<Integer> untrackableItems = new ArrayList<>();

    //Raid/Minigame completion messages
    public Map<String, String> raidCompletionMessages = new HashMap<>();
    public Map<String, String> minigameCompletionMessages = new HashMap<>();

    //Collection log
    public final ArrayList<Integer> collections = new ArrayList<>();

    //Easter egg
    public Map<String, String> itemRenames = new HashMap<>();
    public Map<String, String> npcRenames = new HashMap<>();

}
package gg.embargo.manifest;

import com.google.gson.*;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
@Singleton
public class ManifestManager {

    @Inject
    private Gson gson;

    @Inject
    private OkHttpClient okHttpClient;

    @Getter
    @Setter
    private Manifest manifest;

    @Getter
    @Setter
    private float lastCheckedManifestVersion = -1;

    // Add timestamp for last check
    private long lastCheckTimestamp = 0;

    // Add a flag to track if a request is in progress
    private final AtomicBoolean requestInProgress = new AtomicBoolean(false);

    // 3 minutes in milliseconds
    private static final long CHECK_INTERVAL = 3 * 60 * 1000;

    //private static final String MOCK_API_URI = "https://a278d141-927f-433b-8e4b-6d994067900d.mock.pstmn.io/api/";
    private static final String API_URI = "https://embargo.gg/api/";
    private static final String MANIFEST_ENDPOINT = API_URI + "runelite/manifest";

    public Manifest getLatestManifest() {
        long currentTime = System.currentTimeMillis();

        // Only proceed if 3 minutes have passed since the last check AND no request is
        // in progress
        if (currentTime - lastCheckTimestamp < CHECK_INTERVAL || !requestInProgress.compareAndSet(false, true)) {
            log.debug(
                    "Skipping manifest check - last check was less than 3 minutes ago or request already in progress");
            return manifest; // Return the current manifest instead of null
        }

        try {
            Request r = new Request.Builder()
                    .url(MANIFEST_ENDPOINT)
                    .header("Cache-Control", "no-cache, no-store")
                    .header("Pragma", "no-cache")
                    .cacheControl(new CacheControl.Builder().noCache().noStore().build())
                    .build();

            okHttpClient.newCall(r).enqueue(new Callback() {
                @Override
                public void onFailure(@NonNull Call call, @NonNull IOException e) {
                    log.error("Error retrieving manifest", e);
                    requestInProgress.set(false); // Reset the flag
                }

                @Override
                public void onResponse(@NonNull Call call, @NonNull Response response) {
                    try (response; response) {
                        if (response.isSuccessful()) {
                            try {
                                if (response.body() == null) {
                                    log.error("Manifest request succeeded but returned empty body");
                                    return;
                                }

                                setManifest(gson.fromJson(
                                        new StringReader(new String(response.body().bytes(), StandardCharsets.UTF_8)),
                                        Manifest.class));
                                log.debug("Set manifest");

                                // Update the timestamp
                                lastCheckTimestamp = currentTime;

                                if (lastCheckedManifestVersion != manifest.getVersion()) {
                                    log.debug("Setting manifest version to {}", manifest.getVersion());
                                    lastCheckedManifestVersion = manifest.getVersion();
                                }
                            } catch (JsonSyntaxException e) {
                                log.error(e.getLocalizedMessage());
                            } catch (IOException e) {
                                log.error("Error reading response body", e);
                            }
                        } else {
                            log.error("Manifest request returned with status {}", response.code());
                            if (response.body() == null) {
                                log.error("Manifest request returned empty body");
                            } else {
                                log.error(response.body().toString());
                            }
                        }
                    } finally {
                        requestInProgress.set(false); // Reset the flag
                    }
                }
            });
        } catch (IllegalArgumentException e) {
            log.error("Bad URL given: {}", e.getLocalizedMessage());
            requestInProgress.set(false); // Reset the flag
        }

        log.debug("Returning set manifest (not null)");
        return manifest; // Return current manifest instead of null
    }
}
package gg.embargo;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class Embargo
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(EmbargoPlugin.class);
		RuneLite.main(args);
	}
}
