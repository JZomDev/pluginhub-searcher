package com.barrowspotential;

import com.google.common.collect.ImmutableMap;
import lombok.NonNull;
import lombok.val;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.ProgressBarComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.annotation.Nonnegative;
import javax.inject.Inject;
import java.awt.*;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

public final class BarrowsPotentialOverlay extends Overlay
{
	// Brothers are already tracked by the game/built-in plugin. We don't need to add to that.
	private static final Set<Monster> ignoredNpcs = Monster.brothers;

	private static final int REWARD_POTENTIAL_MAX = 1012;

	private final PanelComponent panelComponent = new PanelComponent();

	private final TitleComponent titleComponent = TitleComponent.builder()
			.text( "Barrows Potential" )
			.color( Color.white )
			.build();

	private final AtomicBoolean isVisible = new AtomicBoolean( false );
	private final AtomicBoolean isInCrypt = new AtomicBoolean( false );
	private final OverlayManager overlayManager;

	// https://stackoverflow.com/questions/3964211/when-to-use-atomicreference-in-java
	// Supposedly reference assignment is already atomic so use of AtomicReference shouldn't be necessary.
	// Use of volatile keyword ensures compiler does not make read/write optimizations.

	private volatile ProgressBarComponent progressBarComponent = new ProgressBarComponent();
	private volatile Map<Monster, Integer> plan = ImmutableMap.of();

	@Inject
	public BarrowsPotentialOverlay( @NonNull OverlayManager overlayManager )
	{
		this.setPriority( 1.f );
		this.setPosition( OverlayPosition.TOP_LEFT );
		this.panelComponent.setPreferredSize( new Dimension( 150, 0 ) );
		this.overlayManager = overlayManager;
	}

	public BarrowsPotentialOverlay connect()
	{
		overlayManager.add( this );

		return this;
	}

	public BarrowsPotentialOverlay dispose()
	{
		overlayManager.remove( this );

		return this;
	}

	public BarrowsPotentialOverlay clear()
	{
		plan = ImmutableMap.of();

		return this;
	}

	public BarrowsPotentialOverlay setOptimalMonsters( @NonNull Map<Monster, Integer> monsters )
	{
		plan = ImmutableMap.copyOf( monsters );

		return this;
	}

	public BarrowsPotentialOverlay setRewardDisplay(
			@Nonnegative int rewardPotential,
			@NonNull RewardTarget rewardTarget )
	{
		val component = new ProgressBarComponent();

		component.setMinimum( 0 );
		component.setMaximum( Math.min( REWARD_POTENTIAL_MAX, rewardTarget.getMaxValue() ) );
		component.setValue( rewardPotential );
		component.setForegroundColor( Color.blue );

		component.setLabelDisplayMode( ProgressBarComponent.LabelDisplayMode.TEXT_ONLY );
		component.setCenterLabel( Integer.toString( rewardPotential ) );

		if ( rewardPotential > rewardTarget.getMaxValue() )
		{
			component.setFontColor( Color.red );
		}
		else if ( rewardPotential >= rewardTarget.getMinValue() )
		{
			component.setFontColor( Color.white );
		}
		else
		{
			component.setFontColor( Color.yellow );
		}

		progressBarComponent = component;

		return this;
	}

	public BarrowsPotentialOverlay setVisibility( boolean value )
	{
		isVisible.set( value );

		return this;
	}

	public BarrowsPotentialOverlay setIsInCrypt( boolean value )
	{
		isInCrypt.set( value );

		return this;
	}

	@Override
	public Dimension render( Graphics2D graphics )
	{
		if ( !isVisible.get() || !isInCrypt.get() )
		{
			return null;
		}

		val currentPlan = plan;

		if ( currentPlan.isEmpty() )
		{
			return null;
		}

		panelComponent.getChildren().clear();
		panelComponent.getChildren().add( titleComponent );
		panelComponent.getChildren().add( progressBarComponent );

		for ( final Map.Entry<Monster, Integer> entry : currentPlan.entrySet() )
		{
			if ( ignoredNpcs.contains( entry.getKey() ) )
			{
				continue;
			}

			panelComponent.getChildren().add( LineComponent.builder()
					.left( String.format( "x%d:", entry.getValue() ) )
					.right( entry.getKey().getDisplayName() )
					.build() );
		}

		return panelComponent.render( graphics );
	}
}
package com.barrowspotential;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import lombok.val;
import net.runelite.api.*;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

import javax.annotation.Nonnull;
import javax.inject.Inject;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
@PluginDescriptor(
		name = "Barrows Potential",
		description = "Highlights optimal NPCs in the Barrows Crypts",
		tags = {"barrows", "overlay", "pve", "pvm"}
)
public class BarrowsPotentialPlugin extends Plugin
{
	private static final int CRYPT_REGION_ID = 14231;

	private static final int PLANNER_ITERATIONS_MAX = 20;
	private static final int PLANNER_TOLERANCE = 3;

	private static final int REWARD_POTENTIAL_MAX = 1012;

	private static final int PLUGIN_VERSION = 5;
	private static final int PLUGIN_VERSION_RELEASE = 1;

	@Inject
	private Client client;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ClientThread clientThread;

	@Inject
	private BarrowsPotentialConfig config;

	@Inject
	private BarrowsPotentialHighlight npcOverlay;

	@Inject
	private BarrowsPotentialOverlay screenOverlay;

	private final AtomicBoolean updatePending = new AtomicBoolean( false );

	private void queueUpdatePlan()
	{
		if ( !updatePending.getAndSet( true ) )
		{
			clientThread.invokeLater( this::updatePlan );
		}
	}

	@Override
	protected void startUp()
	{
		// startUp/shutDown run on the ??? (I'm not actually sure, but it trips isClientThread checks) thread

		npcOverlay
				.setHighlightColor( config.highlightNpc() ? config.highlightColor() : null )
				.setHighlightOptimalColor( config.highlightOptimal() ? config.optimalColor() : null )
				.connect();

		screenOverlay
				.setIsInCrypt( isInCrypt() )
				.setVisibility( config.overlayOptimal() )
				.connect();
	}

	@Override
	protected void shutDown()
	{
		// Remove the overlay/highlight objects from the client.
		// There might still be an update queued, but it won't affect the client after this point.

		npcOverlay.dispose();
		screenOverlay.dispose();
	}

	@Subscribe
	public void onVarbitChanged( VarbitChanged event )
	{
		boolean wantsUpdate = event.getVarbitId() == Varbits.BARROWS_REWARD_POTENTIAL;

		if ( event.getVarbitId() == Varbits.BARROWS_REWARD_POTENTIAL )
		{
			log.debug( "reward potential changed" );
			wantsUpdate = true;
		}
		else
		{
			Monster monster = Monster.brothersByVarbit.get( event.getVarbitId() );
			if ( monster != null )
			{
				log.debug( "killed {}", monster.getDisplayName() );
				wantsUpdate = true;
			}
		}

		if ( wantsUpdate )
		{
			queueUpdatePlan();
		}
	}

	@Subscribe
	public void onGameStateChanged( GameStateChanged event )
	{
		// runs when loading into the crypt, check region id
		if ( event.getGameState() == GameState.LOGGED_IN )
		{
			log.debug( "logged in" );

			updateCheck();

			screenOverlay.setIsInCrypt( isInCrypt() );

			queueUpdatePlan();
		}
		else
		{
			screenOverlay.setIsInCrypt( false );
		}
	}

	@Subscribe
	public void onConfigChanged( ConfigChanged event )
	{
		// onConfigChanged gets run from the UI thread, not the client thread.
		// Must take care touching data that could be in use on another thread.
		// Trying to avoid scope-locks so generally this means atomic operations only.

		if ( event.getGroup().equals( "barrowspotential" ) )
		{
			log.debug( "config changed" );

			npcOverlay
					.rebuild()
					.setHighlightColor( config.highlightNpc() ? config.highlightColor() : null )
					.setHighlightOptimalColor( config.highlightOptimal() ? config.optimalColor() : null );

			screenOverlay
					.setVisibility( config.overlayOptimal() );

			queueUpdatePlan();
		}
	}

	// Get the current game state as a plan
	private RewardPlan getCurrentPlan()
	{
		// In order to avoid tracking every single NPC the player defeats we just track brothers.
		// We then use that information to calculate the player's current reward potential.
		// These together result in an initial world state we can plan off of.

		int rewardPotential = client.getVarbitValue( Varbits.BARROWS_REWARD_POTENTIAL );

		val brothers = new ArrayList<Monster>();

		for ( val brother : Monster.brothers )
		{
			assert brother.getVarbit() != 0;

			val isDefeated = client.getVarbitValue( brother.getVarbit() ) == 1;

			if ( isDefeated )
			{
				// The bonus for each brother killed isn't included in the varbit.
				// Add it here so we're working with the actual final result.
				rewardPotential += 2;

				brothers.add( brother );
			}
		}

		return RewardPlan.create( brothers, rewardPotential );
	}

	// Get the expected plan, appending any brothers the user plans on defeating
	private RewardPlan getConfigPlan( @Nonnull RewardPlan currentPlan )
	{
		val rewardPlan = config.rewardPlan();

		if ( !rewardPlan.isEmpty() )
		{
			val configPlan = EnumSet.copyOf( rewardPlan );

			configPlan.retainAll( Monster.brothers );

			return currentPlan.insert( configPlan );
		}
		else
		{
			return RewardPlan.empty;
		}
	}

	private void updatePlan()
	{
		assert client.isClientThread();

		npcOverlay.clear();
		screenOverlay.clear();

		val currentPlan = getCurrentPlan();

		val targetReward = config.rewardTarget();
		val targetMonsters = config.rewardPlan();

		val targetPotentialClamped = Math.min( REWARD_POTENTIAL_MAX, targetReward.getMaxValue() );
		val targetPotentialMet = currentPlan.getRewardPotential() >= targetPotentialClamped;

		log.debug( "reward potential {}", currentPlan.getRewardPotential() );
		log.debug( "target potential {}", targetPotentialClamped );

		val configPlan = getConfigPlan( currentPlan );

		if ( !configPlan.isEmpty() )
		{
			for ( val monster : targetMonsters )
			{
				val expectedRewardPotential = configPlan.getRewardPotential() + monster.getCombatLevel();

				if ( expectedRewardPotential > targetReward.getMaxValue() )
				{
					// Don't highlight monsters that would put us over the target
					continue;
				}

				npcOverlay.add( monster );
			}

			if ( !targetPotentialMet )
			{
				val planner = new RewardPlanner();

				// Find a plan that gets us from our current reward potential to the target
				// This plan must only include the monsters/brothers we have selected

				planner.reset( configPlan, targetPotentialClamped );
				planner.setTargetMonsters( config.rewardPlan() );
				planner.setSmallerPlanTolerance( PLANNER_TOLERANCE );

				val plan = planner.search( PLANNER_ITERATIONS_MAX );

				if ( plan == null )
				{
					// In theory this will never happen
					// At the very least the base plan we fed in will be returned
					log.error( "plan was null" );
				}
				else
				{
					val planValue = plan.getRewardPotential();

					log.debug( "planned reward potential: {}", planValue );

					if ( planValue < targetReward.getMinValue() )
					{
						// In theory this will never happen
						log.warn( "plan does not meet target" );
					}

					for ( val entry : plan.getMonsters().entrySet() )
					{
						val count = entry.getValue();
						val name = entry.getKey().getDisplayName();
						val value = entry.getKey().getRewardPotential() * count;
						log.debug( "x{} {} ({})", count, name, value );

						npcOverlay.addOptimal( entry.getKey() );
					}

					screenOverlay.setOptimalMonsters( plan.getMonsters() );
				}
			}
		}

		npcOverlay.rebuild();

		screenOverlay.setRewardDisplay( currentPlan.getRewardPotential(), config.rewardTarget() );

		updatePending.set( false );
	}

	public int getRegionID()
	{
		final Player localPlayer = client.getLocalPlayer();

		if ( localPlayer == null )
		{
			return 0;
		}

		return localPlayer.getWorldLocation().getRegionID();
	}

	public boolean isInCrypt()
	{
		return getRegionID() == CRYPT_REGION_ID;
	}

	// Check if the plugin has updated since the last time the user logged in
	// queue a message notifying of changes if so
	private void updateCheck()
	{
		Integer version = configManager.getRSProfileConfiguration(
				BarrowsPotentialConfig.CONFIG_GROUP,
				BarrowsPotentialConfig.CONFIG_VERSION,
				int.class );

		if ( version == null )
		{
			log.warn( "last plugin version unknown. assuming release." );

			version = PLUGIN_VERSION_RELEASE;
		}

		log.debug( "last plugin version: {}", version );
		log.debug( "latest plugin version: {}", PLUGIN_VERSION );

		if ( version >= PLUGIN_VERSION )
		{
			return;
		}

		log.warn( "plugin version changed. queuing update message." );

		final String message = "Barrows Potential has been updated. See Github page for details.";

		final String chatMessage = new ChatMessageBuilder()
				.append( ChatColorType.HIGHLIGHT )
				.append( message )
				.build();

		chatMessageManager.queue( QueuedMessage.builder()
				.type( ChatMessageType.CONSOLE )
				.runeLiteFormattedMessage( chatMessage )
				.build() );

		configManager.setRSProfileConfiguration(
				BarrowsPotentialConfig.CONFIG_GROUP,
				BarrowsPotentialConfig.CONFIG_VERSION,
				PLUGIN_VERSION );
	}

	@Provides
	BarrowsPotentialConfig provideConfig( ConfigManager configManager )
	{
		return configManager.getConfig( BarrowsPotentialConfig.class );
	}
}
package com.barrowspotential;

import com.google.common.collect.ImmutableMap;
import lombok.Getter;
import lombok.val;

import javax.annotation.Nonnegative;
import javax.annotation.Nonnull;
import java.util.HashMap;
import java.util.Map;

@Getter
public final class RewardPlan
{
	public static RewardPlan create( @Nonnull Iterable<Monster> monsters, @Nonnegative int rewardPotential )
	{
		val map = new HashMap<Monster,Integer>();

		for ( val monster : monsters )
		{
			map.compute( monster, ( key, value ) -> value == null ? 1 : value + 1 );
		}

		return new RewardPlan( map, rewardPotential );
	}

	public static RewardPlan create( @Nonnull Iterable<Monster> monsters )
	{
		val map = new HashMap<Monster,Integer>();

		for ( val monster : monsters )
		{
			map.compute( monster, ( key, value ) -> value == null ? 1 : value + 1 );
		}

		return new RewardPlan( map );
	}

	public static RewardPlan create( @Nonnull Monster... monsters )
	{
		val map = new HashMap<Monster,Integer>();

		for ( val monster : monsters )
		{
			map.compute( monster, ( key, value ) -> value == null ? 1 : value + 1 );
		}

		return new RewardPlan( map );
	}

	private static int calculateRewardPotential( @Nonnull Map<Monster,Integer> monsters )
	{
		return monsters.entrySet()
				.stream()
				.mapToInt( entry -> entry.getValue() * entry.getKey().getRewardPotential() )
				.sum();
	}

	public static final RewardPlan empty = new RewardPlan();

	private final ImmutableMap<Monster,Integer> monsters;

	// Won't always match the total reward potential of the above map.
	// We don't track non-brother monsters the player has previously defeated.
	// This results in the score going up but the known monsters defeated not changing.
	private final int rewardPotential;

	public RewardPlan( @Nonnull Map<Monster,Integer> monsters, @Nonnegative int rewardPotential )
	{
		this.monsters = ImmutableMap.copyOf( monsters );
		this.rewardPotential = rewardPotential;
	}

	public RewardPlan( @Nonnull Map<Monster,Integer> monsters )
	{
		this.monsters = ImmutableMap.copyOf( monsters );
		this.rewardPotential = calculateRewardPotential( this.monsters );
	}

	private RewardPlan()
	{
		this.monsters = ImmutableMap.of();
		this.rewardPotential = 0;
	}

	public boolean contains( @Nonnull Monster monster )
	{
		return monsters.containsKey( monster );
	}

	public RewardPlan append( @Nonnull Monster monster )
	{
		val map = new HashMap<>( this.monsters );

		map.compute( monster, ( key, value ) -> value == null ? 1 : value + 1 );

		val newRewardPotential = this.rewardPotential + monster.getRewardPotential();

		return new RewardPlan( map, newRewardPotential );
	}

	public RewardPlan insert( @Nonnull Iterable<Monster> monsters )
	{
		// Calc how much reward potential is from defeated monsters that we didn't track
		val rewardPotentialPlanned = calculateRewardPotential( this.monsters );
		val rewardPotentialBonus = this.rewardPotential - rewardPotentialPlanned;

		val map = new HashMap<>( this.monsters );

		for ( val monster : monsters )
		{
			map.putIfAbsent( monster, 1 );
		}

		val rewardPotentialNew = calculateRewardPotential( map ) + rewardPotentialBonus;

		return new RewardPlan( map, rewardPotentialNew );
	}

	public int getSize()
	{
		int i = 0;

		Map<Monster, Integer> monstersMap = this.getMonsters();

		if ( monstersMap != null )
		{
			for ( Map.Entry<Monster, Integer> entry : monstersMap.entrySet() )
			{
				i += entry.getValue();
			}
		}

		return i;
	}

	@Override
	public int hashCode()
	{
		// Intentionally not including the rewardPotential in the hash.
		// We just want to quickly check if we've already encountered this plan.
		return monsters.hashCode();
	}

	@Override
	public boolean equals( Object obj )
	{
		// Intentionally not including the rewardPotential in the hash.
		// We just to quickly check if we've already encountered this plan.

		if ( obj instanceof RewardPlan )
		{
			return monsters.equals( ( (RewardPlan) obj ).monsters );
		}

		return false;
	}

	@Override
	public String toString()
	{
		return String.format( "Potential: %d", rewardPotential );
	}

	public boolean isEmpty()
	{
		return this.monsters.isEmpty();
	}
}
package com.barrowspotential;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.NpcID;
import net.runelite.api.Varbits;

import java.util.*;

@RequiredArgsConstructor
@Getter
public enum Monster
{
	// Brothers
	Ahrim( "Ahrim the Blighted", 98, NpcID.AHRIM_THE_BLIGHTED, Varbits.BARROWS_KILLED_AHRIM ),
	Dharok( "Dharok the Wretched", 115, NpcID.DHAROK_THE_WRETCHED, Varbits.BARROWS_KILLED_DHAROK ),
	Guthan( "Guthan the Infested", 115, NpcID.GUTHAN_THE_INFESTED, Varbits.BARROWS_KILLED_GUTHAN ),
	Karil( "Karil the Tainted", 98, NpcID.KARIL_THE_TAINTED, Varbits.BARROWS_KILLED_KARIL ),
	Torag( "Torag the Corrupted", 115, NpcID.TORAG_THE_CORRUPTED, Varbits.BARROWS_KILLED_TORAG ),
	Verac( "Verac the Defiled", 115, NpcID.VERAC_THE_DEFILED, Varbits.BARROWS_KILLED_VERAC ),

	// Crypt Monsters
	CryptRat( "Crypt rat", 43, NpcID.CRYPT_RAT ),
	Bloodworm( "Bloodworm", 52, NpcID.BLOODWORM ),
	CryptSpider( "Crypt spider", 56, NpcID.CRYPT_SPIDER ),
	GiantCryptRat( "Giant crypt rat", 76, new int[]
		{
			NpcID.GIANT_CRYPT_RAT,
			NpcID.GIANT_CRYPT_RAT_1681,
			NpcID.GIANT_CRYPT_RAT_1682
		} ),
	Skeleton( "Skeleton", 77, new int[]
		{
			NpcID.SKELETON_1685,
			NpcID.SKELETON_1686,
			NpcID.SKELETON_1687,
			NpcID.SKELETON_1688
		} ),
	GiantCryptSpider( "Giant crypt spider", 79, NpcID.GIANT_CRYPT_SPIDER );

	// constructor for monsters with only one npcID
	Monster( String displayName, int combatLevel, int npcID )
	{
		this( displayName, combatLevel, npcID, 0 );
	}

	// constructor for crypt monsters with multiple npcIDs
	Monster( String displayName, int combatLevel, int[] npcIDs )
	{
		this( displayName, combatLevel, npcIDs, 0 );
	}

	// constructor for brothers
	Monster( String displayName, int combatLevel, int npcID, int varbit )
	{
		this( displayName, combatLevel, new int[] { npcID }, varbit );
	}

	@Override
	public String toString()
	{
		return displayName;
	}

	private final String displayName;
	private final int combatLevel;
	private final int[] npcIDs;
	private final int varbit;

	public final boolean isBrother()
	{
		return getVarbit() != 0;
	}

	public final int getRewardPotential()
	{
		if ( isBrother() )
		{
			// The game adds 2 potential for each brother killed
			return getCombatLevel() + 2;
		}

		return getCombatLevel();
	}

	private static Map<Integer, Monster> getCryptMonstersByNpcID()
	{
		HashMap<Integer, Monster> map = new HashMap<>();

		for ( Monster monster : Monster.cryptMonsters )
		{
			assert !monster.isBrother();

			for ( int npcID : monster.getNpcIDs() )
			{
				map.put( npcID, monster );
			}
		}

		return ImmutableMap.copyOf( map );
	}

	private static Map<Integer, Monster> getBrothersByVarbit()
	{
		HashMap<Integer, Monster> map = new HashMap<>();

		for ( Monster monster : Monster.brothers )
		{
			assert monster.isBrother();

			map.put( monster.getVarbit(), monster );
		}

		return ImmutableMap.copyOf( map );
	}

	public static final Set<Monster> brothers = ImmutableSet.of(
		Ahrim,
		Dharok,
		Guthan,
		Karil,
		Torag,
		Verac
	);

	public static final Set<Monster> cryptMonsters = ImmutableSet.of(
		CryptRat,
		Bloodworm,
		CryptSpider,
		GiantCryptRat,
		Skeleton,
		GiantCryptSpider
	);

	public static final Map<Integer, Monster> cryptMonsterByNpcID = getCryptMonstersByNpcID();
	public static final Map<Integer, Monster> brothersByVarbit = getBrothersByVarbit();
}
package com.barrowspotential;

import lombok.val;

import javax.annotation.Nonnull;
import java.util.*;

// A basic implementation of A*, as seen in https://en.wikipedia.org/wiki/A*_search_algorithm
public abstract class AStar<TNode, TGoal>
{
	// Used to glue the fScore and the priority queue together
	// ALWAYS REMOVE AND RE-ADD NODES WHEN THEIR FSCORE CHANGES
	private class NodeCompare implements Comparator<TNode>
	{
		private final AStar<TNode,TGoal> _planner;

		public NodeCompare( AStar<TNode,TGoal> planner )
		{
			_planner = planner;
		}

		@Override
		public int compare( TNode lhs, TNode rhs )
		{
			assert ( _planner._fScore.containsKey( lhs ) );
			assert ( _planner._fScore.containsKey( rhs ) );
			val l = _planner._fScore.get( lhs );
			val r = _planner._fScore.get( rhs );
			return _planner._comparator.compare( l, r );
		}
	}

	private final PriorityQueue<TNode> _openSet;
	private final Hashtable<TNode,Integer> _gScore;
	private final Hashtable<TNode,Integer> _fScore;
	private final Hashtable<TNode,Integer> _hScore;

	private final int _gScoreInfinite;
	private final Comparator<Integer> _comparator;

	private TGoal _goal;
	private TNode _best;

	protected AStar(
			int gScoreInfinite,
			@Nonnull Comparator<Integer> comparator )
	{
		_gScoreInfinite = gScoreInfinite;
		_comparator = comparator;

		val nodeCompare = new NodeCompare( this );

		_openSet = new PriorityQueue<>( nodeCompare );
		_gScore = new Hashtable<>();
		_fScore = new Hashtable<>();
		_hScore = new Hashtable<>();

		_goal = null;
		_best = null;
	}

	protected AStar()
	{
		// Default sort logic, as seen in pretty much any A* example
		this( Integer.MAX_VALUE, Comparator.naturalOrder() );
	}

	public final void reset(
			@Nonnull TNode start,
			@Nonnull TGoal goal )
	{
		_openSet.clear();
		_gScore.clear();
		_fScore.clear();
		_hScore.clear();

		val score = getHScore( start, goal );

		_openSet.add( start );
		_gScore.put( start, 0 );
		_hScore.put( start, score );
		_fScore.put( start, score );

		_goal = goal;
		_best = start;
	}

	public TNode search()
	{
		assert ( _goal != null );
		assert ( _best != null );

		if ( _openSet.isEmpty() )
		{
			// Exhausted all possible iterations
			return _best;
		}

		final TNode current = _openSet.remove();

		if ( isGoal( current, _goal ) )
		{
			// Found perfect solution
			return current;
		}

		if ( _comparator.compare( _fScore.get( _best ), _fScore.get( current ) ) > 0 )
		{
			// This isn't part of the basic A* setup
			// We want to support partial plans here since we don't _need_ a perfect match, we just prefer it
			// If, after a number of iterations, no perfect plan is found the code can just take the best partial plan
			_best = current;
		}

		for ( final TNode neighbor : getNeighbors( current, _goal ) )
		{
			int gScoreTemp = _gScore.get( current ) + getDScore( current, neighbor );

			gScoreTemp = getModifiedScore( _best, neighbor, _goal, gScoreTemp );

			int gScoreOld = _gScore.getOrDefault( neighbor, _gScoreInfinite );

			if ( _comparator.compare( gScoreTemp, gScoreOld ) >= 0 )
				continue;

			int hScore = getHScore( neighbor, _goal );

			_gScore.put( neighbor, gScoreTemp );
			_hScore.put( neighbor, hScore );
			_fScore.put( neighbor, gScoreTemp + hScore );

			// Priority queue calculates priority on add
			// The fScore might have changed, so remove and re-add it to force the queue to update
			_openSet.remove( neighbor );
			_openSet.add( neighbor );
		}

		return null;
	}

	public TNode takeBest()
	{
		return _best;
	}

	// gets the modified score to adjust plan's weight depending on potential tolerance
	protected int getModifiedScore(@Nonnull TNode best, @Nonnull TNode neighbor, @Nonnull TGoal goal, @Nonnull Integer gScoreTemp)
	{
		return gScoreTemp;
	}

	// estimated cost to reach goal from current
	protected abstract int getHScore( @Nonnull TNode current, @Nonnull TGoal goal );

	// the weight of the edge from current to neighbor
	protected abstract int getDScore( @Nonnull TNode current, @Nonnull TNode neighbor );

	// does the current node reach the goal node
	protected abstract boolean isGoal( @Nonnull TNode current, @Nonnull TGoal goal );

	// get a list of all nodes the current node can lead into
	protected abstract Collection<TNode> getNeighbors( @Nonnull TNode current, @Nonnull TGoal goal );
}
package com.barrowspotential;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum RewardTarget
{
    Coins("Coins",1, 380),
    MindRune("Mind Rune",381, 505),
    ChaosRune("Chaos Rune", 506, 630),
    DeathRune("Death Rune", 631, 755),
    BloodRune("Blood Rune", 756, 880),
    BoltRack("Bolt Rack", 881, 1005),

    // The min-max range on these are so small that the planner could fail if we limit it to a max score
    KeyHalf("Crystal Key", 1006, Integer.MAX_VALUE),
    DragonMed("Dragon Med Helm", 1012, Integer.MAX_VALUE);

    private final String displayName;
    private final int minValue;
    private final int maxValue;

    @Override
    public String toString()
    {
        return getDisplayName();
    }
}
package com.barrowspotential;

import com.google.common.collect.ImmutableSet;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import lombok.val;

import javax.annotation.Nonnull;
import javax.inject.Inject;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Set;

// an implementation of A* used to plan which crypt monsters to kill to reach the desired reward potential.
// this only considers crypt monsters as possible nodes.
// any brothers the player wants to kill should be fed to Reset() as the starting plan.
@Slf4j
public final class RewardPlanner extends AStar<RewardPlan, Integer>
{
	@Nonnull
	private Set<Monster> targetMonsters = ImmutableSet.of();

	@Getter
	@Setter
	private int smallerPlanTolerance = 0;

	@Inject
	public RewardPlanner()
	{
		// inverse sort simplifies the math a bit
		super( Integer.MIN_VALUE, Comparator.reverseOrder() );
	}

	public void setTargetMonsters( @Nonnull Set<Monster> monsters )
	{
		targetMonsters = ImmutableSet.copyOf( monsters );
	}

	@Override
	protected int getModifiedScore( @Nonnull RewardPlan best, @Nonnull RewardPlan neighbor, @Nonnull Integer goal, @Nonnull Integer gScoreTemp )
	{
		final int tolerance = getSmallerPlanTolerance();

		if ( tolerance > 0 )
		{
			int i = getSize( best );
			int j = getSize( neighbor );

			// if the neighbor plan is bigger than the best plan and the reward potential difference
			// between the two plans is within the set tolerance, adjust the score of the bigger
			// plan lower. This allows the shorter plan within the tolerance to end up with a higher score.
			if ( j > i && Math.abs( getHScore( neighbor, goal ) - getHScore( best, goal )) < tolerance )
			{
				// using logarithmic scaling for calculating the weighting. Example:
				// best 874 (size 8), neighbor 876 (size 9). Tolerance 3.
				// 9-8+3=4. Log(4) = 1.3, Log(1.5) = 0.4 1.3/0.4 = 3.4. 3.4*3=10.2 rounded up.
				// this results in 11 being removed from the gScore for the bigger plan.
				// change the tolerance to 53 and it sets the plan to just 2 skeleton (822 potential)
				// which is the next smallest plan with the highest reward.
				gScoreTemp -= (int) Math.ceil((( Math.log( j - i + tolerance ) / Math.log( 1.5 )) * tolerance ));
			}
		}

		// regular logic runs if tolerance is not set or the
		// tolerance amounts/size conditions are not met
		return gScoreTemp;
	}

	private int getSize( @Nonnull RewardPlan current )
	{
		return current.getSize();
	}

	@Override
	protected int getHScore( @Nonnull RewardPlan current, @Nonnull Integer target )
	{
		// hScore becomes the total reward potential of the current plan
		return current.getRewardPotential();
	}

	@Override
	protected int getDScore( @Nonnull RewardPlan current, @Nonnull RewardPlan neighbor )
	{
		// dScore becomes the increase in reward potential compared to the current plan
		return neighbor.getRewardPotential() - current.getRewardPotential();
	}

	@Override
	protected boolean isGoal( @Nonnull RewardPlan current, @Nonnull Integer target )
	{
		return current.getRewardPotential() >= target;
	}

	@Override
	protected Collection<RewardPlan> getNeighbors( @Nonnull RewardPlan current, @Nonnull Integer target )
	{
		// generate a list of all possible crypt monsters we could kill
		val neighbors = new ArrayList<RewardPlan>();

		for ( val brother : Monster.brothers )
		{
			if ( current.contains( brother ) )
			{
				// skip brothers that have already been killed
				continue;
			}

			if ( targetMonsters.contains( brother ) )
			{
				neighbors.add( current.append( brother ) );
			}
		}

		if ( !neighbors.isEmpty() )
		{
			// If there are any brothers remaining always plan for those first
			return neighbors;
		}

		for ( val monster : Monster.cryptMonsters )
		{
			val expectedRewardPotential = current.getRewardPotential() + monster.getCombatLevel();

			if ( expectedRewardPotential > target )
			{
				// skip crypt monsters that would put us over the target score
				continue;
			}

			if ( targetMonsters.contains( monster ) )
			{
				neighbors.add( current.append( monster ) );
			}
		}

		return neighbors;
	}

	public RewardPlan search( final int iterationsMax )
	{
		RewardPlan plan = null;

		int iterations = 0;

		// There's generally not a reason to let the planner run for a bunch of iterations
		// We generally know within ~20 iterations if a perfect plan (exactly the target score) is possible
		for ( ; iterations < iterationsMax; ++iterations )
		{
			plan = search();

			if ( plan != null )
				break;
		}

		log.debug( "planner ran for {} iterations", iterations );

		if ( plan == null )
		{
			// We failed to get a plan that _exactly_ matches the target within the iteration limit
			// Just take the best plan the planner could come up with
			log.debug( "taking partial plan" );

			plan = takeBest();
		}

		return plan;
	}
}
package com.barrowspotential;

import net.runelite.client.config.*;

import java.awt.*;
import java.util.EnumSet;
import java.util.Set;

@ConfigGroup( BarrowsPotentialConfig.CONFIG_GROUP )
public interface BarrowsPotentialConfig extends Config
{
	String CONFIG_GROUP = "barrowspotential";

	String CONFIG_VERSION = "version";

	@ConfigSection(
			name = "Planner",
			description = "",
			position = 0
	)
	String plannerSection = "plannerSection";

	@ConfigSection(
			name = "Highlight",
			description = "",
			position = 1
	)
	String highlightSection = "highlightSection";

	@ConfigItem(
			keyName = "rewardTarget",
			name = "Reward Target",
			description = "",
			section = plannerSection,
			position = 0
	)
	default RewardTarget rewardTarget() { return RewardTarget.BloodRune; }

	@ConfigItem(
			keyName = "rewardPlan",
			name = "Reward Plan",
			description = "Which monsters do you plan on defeating? Ctrl+Click to select.",
			section = plannerSection,
			position = 1
	)
	default Set<Monster> rewardPlan() { return EnumSet.allOf( Monster.class ); }

	@ConfigItem(
			keyName = "highlightNpcs",
			name = "Highlight NPCs",
			description = "Highlight any NPC that would not exceed the target score",
			section = highlightSection,
			position = 0
	)
	default boolean highlightNpc() { return true; }

	@ConfigItem(
			keyName = "highlightColor",
			name = "Highlight Color",
			description = "",
			section = highlightSection,
			position = 1
	)
	default Color highlightColor() { return Color.gray; }

	@ConfigItem(
			keyName = "highlightOptimal",
			name = "Highlight Optimal NPCs",
			description = "Highlight the NPCs that would best reach the target score",
			section = highlightSection,
			position = 2
	)
	default boolean highlightOptimal() { return true; }

	@ConfigItem(
			keyName = "overlayOptimal",
			name = "Overlay Optimal NPCs",
			description = "List optimal NPCs in an overlay",
			section = highlightSection,
			position = 3
	)
	default boolean overlayOptimal() { return true; }

	@ConfigItem(
			keyName = "optimalColor",
			name = "Optimal Color",
			description = "",
			section = highlightSection,
			position = 4
	)
	default Color optimalColor() { return Color.white; }
}
package com.barrowspotential;

import lombok.NonNull;
import lombok.val;
import net.runelite.api.NPC;
import net.runelite.client.game.npcoverlay.HighlightedNpc;
import net.runelite.client.game.npcoverlay.NpcOverlayService;

import javax.annotation.Nullable;
import javax.inject.Inject;
import java.awt.*;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

public final class BarrowsPotentialHighlight
{
	// Brothers are already highlighted by the game/built-in plugin. We don't need to add to that.
	private static final Set<Monster> ignoredNpcs = Monster.brothers;

	private final Set<Integer> npcHighlightsOptimal = ConcurrentHashMap.newKeySet();
	private final Set<Integer> npcHighlights = ConcurrentHashMap.newKeySet();
	// The highlight function must be stored as a Function<>, the same type the overlayService uses.
	// Function<> equality is just object reference equality. We need to have the original object to remove it.
	private final Function<NPC, HighlightedNpc> highlightFunction;
	private final NpcOverlayService overlayService;

	// https://stackoverflow.com/questions/3964211/when-to-use-atomicreference-in-java
	// Supposedly reference assignment is already atomic so use of AtomicReference shouldn't be necessary.
	// Use of volatile keyword ensures compiler does not make read/write optimizations.

	private volatile Color highlightColorOptimal = null;
	private volatile Color highlightColor = null;

	@Inject
	public BarrowsPotentialHighlight( @NonNull NpcOverlayService overlayService )
	{
		this.highlightFunction = this::getNpcHighlight;
		this.overlayService = overlayService;
	}

	public BarrowsPotentialHighlight connect()
	{
		overlayService.registerHighlighter( highlightFunction );

		return this;
	}

	public BarrowsPotentialHighlight dispose()
	{
		overlayService.unregisterHighlighter( highlightFunction );

		return this;
	}

	private Color getNpcHighlightColor( @NonNull NPC npc )
	{
		// get-check-return pattern to avoid race conditions

		if ( npcHighlightsOptimal.contains( npc.getId() ) )
		{
			val color = this.highlightColorOptimal;

			if ( color != null )
			{
				return color;
			}
		}

		if ( npcHighlights.contains( npc.getId() ) )
		{
			val color = this.highlightColor;

			if ( color != null )
			{
				return color;
			}
		}

		return null;
	}

	private HighlightedNpc getNpcHighlight( @NonNull NPC npc )
	{
		val color = getNpcHighlightColor( npc );

		if ( color != null )
		{
			return HighlightedNpc.builder()
					.hull( true )
					.highlightColor( color )
					.npc( npc )
					.build();
		}

		return null;
	}

	public BarrowsPotentialHighlight setHighlightColor( @Nullable Color color )
	{
		highlightColor = color;

		return this;
	}

	public BarrowsPotentialHighlight setHighlightOptimalColor( @Nullable Color color )
	{
		highlightColorOptimal = color;

		return this;
	}

	public BarrowsPotentialHighlight add( @NonNull Monster monster )
	{
		if ( !ignoredNpcs.contains( monster ) )
		{
			for ( val npcId : monster.getNpcIDs() )
			{
				npcHighlights.add( npcId );
			}
		}

		return this;
	}

	public BarrowsPotentialHighlight addOptimal( @NonNull Monster monster )
	{
		if ( !ignoredNpcs.contains( monster ) )
		{
			for ( val npcId : monster.getNpcIDs() )
			{
				npcHighlightsOptimal.add( npcId );
			}
		}

		return this;
	}

	public BarrowsPotentialHighlight addAll( @NonNull Iterable<Monster> monsters )
	{
		for ( val monster : monsters )
		{
			add( monster );
		}

		return this;
	}

	public BarrowsPotentialHighlight addAllOptimal( @NonNull Iterable<Monster> monsters )
	{
		for ( val monster : monsters )
		{
			addOptimal( monster );
		}

		return this;
	}

	public BarrowsPotentialHighlight clear()
	{
		npcHighlightsOptimal.clear();
		npcHighlights.clear();

		return this;
	}

	public BarrowsPotentialHighlight rebuild()
	{
		overlayService.rebuild();

		return this;
	}
}
package com.barrowspotential;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BarrowsPotentialPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BarrowsPotentialPlugin.class);
		RuneLite.main(args);
	}
}
package com.barrowspotentialtest;

import com.barrowspotential.*;
import com.google.common.collect.ImmutableMap;
import junit.framework.TestCase;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;

public class RewardPlannerTest extends TestCase
{
	private static final int maxIterations = 20;

	private static final int planTolerance = 3;

	private final Logger logger = LoggerFactory.getLogger( RewardPlannerTest.class );

	private static RewardPlan AllBrothers()
	{
		return RewardPlan.create( Monster.brothers );
	}

	private static RewardPlan AllBrothersOptimalBloodRune()
	{
		// The optimal plan is 1 giant crypt spider, 1 skeleton, and 1 crypt spider (880 points)
		// 3 bloodworms and 1 crypt spider is also 880 points but is more steps, and therefor not optimal

		return AllBrothers()
				.append( Monster.GiantCryptSpider )
				.append( Monster.Skeleton )
				.append( Monster.CryptSpider );
	}

	private static RewardPlan AllBrothersSkeletonBloodwormBloodRuneOptimal()
	{
		return AllBrothers()
				.append( Monster.Bloodworm )
				.append( Monster.Bloodworm )
				.append( Monster.Bloodworm )
				.append( Monster.Bloodworm );
	}

	private static RewardPlan AllBrothersSkeletonBloodwormBloodRuneShortest()
	{
		return AllBrothers()
				.append( Monster.Skeleton )
				.append( Monster.Skeleton )
				.append( Monster.Bloodworm );
	}

	private static void LogPlan( @Nonnull Logger logger, @Nonnull RewardPlan plan )
	{
		final int score = plan.getRewardPotential();
		final int steps = plan.getMonsters().values().stream()
				.mapToInt( i -> i )
				.sum();

		for ( final Map.Entry<Monster, Integer> entry : plan.getMonsters().entrySet() )
		{
			final int count = entry.getValue();
			final int value = entry.getKey().getCombatLevel() * count;
			final String displayName = entry.getKey().getDisplayName();
			logger.info( "x{} {} ({})", count, displayName, value );
		}

		logger.info( "Steps: {}", steps );
		logger.info( "Score: {}", score );
	}

	private static void LogTarget( @Nonnull Logger logger, @Nonnull RewardTarget rewardTarget )
	{
		logger.info( "Target    : {}", rewardTarget.getDisplayName() );
		logger.info( "Target Min: {}", rewardTarget.getMinValue() );
		logger.info( "Target Max: {}", rewardTarget.getMaxValue() );
	}

	private static RewardPlan RunPlanner( Logger logger, RewardPlanner planner, int maxIterations )
	{
		int iteration = 0;

		RewardPlan plan = null;

		for ( ; iteration < maxIterations; ++iteration )
		{
			plan = planner.search();
			if ( plan != null )
				break;
		}

		logger.info( "Ran {}/{} iterations", iteration, maxIterations );

		return plan;
	}

	// assert that for the given base plan there is an optimal plan to reach the target
	private static RewardPlan assertOptimalPlan( RewardPlanner planner,
												 Logger logger,
												 RewardTarget rewardTarget,
												 RewardPlan basePlan )
	{
		assert planner != null;

		logger.info( "searching for optimal plan" );

		planner.reset( basePlan, rewardTarget.getMaxValue() );
		planner.setTargetMonsters( EnumSet.allOf( Monster.class ) );

		// allow a lot of iterations here since this isn't runtime code
		RewardPlan plan = RunPlanner( logger, planner, 1000 );

		// do not accept partial solution

		assertNotNull( plan );

		LogPlan( logger, plan );

		assertEquals( rewardTarget.getMaxValue(), plan.getRewardPotential() );

		return plan;
	}

	// assert that for the given base plan there is a valid plan to reach the target within 20 iterations
	private static RewardPlan assertValidPlan(
			@Nonnull RewardPlanner planner,
			@Nonnull Logger logger,
			@Nonnull RewardTarget rewardTarget,
			@Nonnull RewardPlan basePlan )
	{
		logger.info( "searching for valid plan" );

		planner.reset( basePlan, rewardTarget.getMaxValue() );

		// at runtime the number of iterations is limited, test that here
		RewardPlan plan = RunPlanner( logger, planner, RewardPlannerTest.maxIterations );

		if ( plan == null )
		{
			logger.info( "taking partial plan" );

			plan = planner.takeBest();
		}

		assertNotNull( plan );

		LogPlan( logger, plan );
		LogTarget( logger, rewardTarget );

		assertTrue( "planned potential < minimum value",
				plan.getRewardPotential() >= rewardTarget.getMinValue() );
		assertTrue( "planned potential > maximum value value",
				plan.getRewardPotential() <= rewardTarget.getMaxValue() );

		return plan;
	}

	public void testBaseIsBest()
	{
		logger.info("Test case: testBaseIsBest");

		RewardPlan basePlan = new RewardPlan( ImmutableMap.of() );

		RewardPlanner planner = new RewardPlanner();

		planner.reset( basePlan, RewardTarget.Coins.getMaxValue() );

		// At minimum the best plan should be the base plan
		assertEquals( basePlan, planner.takeBest() );
	}

	public void testOptimalKillAll()
	{
		logger.info("Test case: testOptiomalKillAll");

		RewardPlanner planner = new RewardPlanner();

		RewardPlan allBrothers = AllBrothers();

		RewardPlan plan = null;

		plan = assertOptimalPlan( planner, logger, RewardTarget.BloodRune, allBrothers );

		assertEquals( "plan does not match known optimal plan",
				AllBrothersOptimalBloodRune(),
				plan );

		assertValidPlan( planner, logger, RewardTarget.DragonMed, allBrothers );
	}

	public void testOptimalKillSingle()
	{
		logger.info("Test case: testOptimalKillSingle");

		RewardPlanner planner = new RewardPlanner();

		RewardPlan combatLevel98 = RewardPlan.create( Monster.Ahrim );
		RewardPlan combatLevel115 = RewardPlan.create( Monster.Dharok );

		assertOptimalPlan( planner, logger, RewardTarget.BloodRune, combatLevel98 );
		assertOptimalPlan( planner, logger, RewardTarget.BloodRune, combatLevel115 );
		assertValidPlan( planner, logger, RewardTarget.BloodRune, combatLevel98 );
		assertValidPlan( planner, logger, RewardTarget.BloodRune, combatLevel115 );
		assertValidPlan( planner, logger, RewardTarget.DragonMed, combatLevel98 );
		assertValidPlan( planner, logger, RewardTarget.DragonMed, combatLevel115 );
	}

	public void testOptimalKillPartial()
	{
		logger.info("Test case: testOptimalKillPartial");

		RewardPlanner planner = new RewardPlanner();

		RewardPlan combatLevel98 = RewardPlan.create(
				//Monster.Ahrim, // combat level 98
				Monster.Dharok,
				Monster.Guthan,
				Monster.Karil,
				Monster.Torag,
				Monster.Verac
		);

		RewardPlan combatLevel115 = RewardPlan.create(
				Monster.Ahrim,
				//Monster.Dharok, // combat level 115
				Monster.Guthan,
				Monster.Karil,
				Monster.Torag,
				Monster.Verac
		);

		assertOptimalPlan( planner, logger, RewardTarget.BloodRune, combatLevel98 );
		assertOptimalPlan( planner, logger, RewardTarget.BloodRune, combatLevel115 );
		assertValidPlan( planner, logger, RewardTarget.BloodRune, combatLevel98 );
		assertValidPlan( planner, logger, RewardTarget.BloodRune, combatLevel115 );
		assertValidPlan( planner, logger, RewardTarget.DragonMed, combatLevel98 );
		assertValidPlan( planner, logger, RewardTarget.DragonMed, combatLevel115 );
	}

	// this is here because I was trying to figure out why restricting to skele+blood was planning blood x4
	// it's because blood x4 is 876, skele x2 + blood x1 is only 874. blood x4 is "more optimal"
	// leaving it here because it's useful for debugging if I decide to change the heuristic
	public void testSkeletonBloodwormOptimal()
	{
		logger.info("Test case: testSkeletonBloodworm - OPTIMAL");

		RewardPlanner planner = new RewardPlanner();

		planner.setTargetMonsters( EnumSet.of(
				Monster.Ahrim,
				Monster.Dharok,
				Monster.Guthan,
				Monster.Karil,
				Monster.Torag,
				Monster.Verac,
				Monster.Skeleton,
				Monster.Bloodworm
		) );

		RewardPlan basePlan = RewardPlan.create( Monster.brothers );

		RewardPlan plan = assertValidPlan( planner, logger, RewardTarget.BloodRune, basePlan );

		// Confirm plan is as expected for max bloodrunes when bloodworms and skeletons are selected
		assertEquals(plan, RewardPlannerTest.AllBrothersSkeletonBloodwormBloodRuneOptimal());
	}

	public void testSkeletonBloodwormShortest()
	{
		logger.info("Test case: testSkeletonBloodworm - SHORTEST");

		RewardPlanner planner = new RewardPlanner();
		// setting plan tolerance manually to (default 3), which is the best
		// potential difference for shortest plan
		planner.setSmallerPlanTolerance(planTolerance);

		planner.setTargetMonsters( EnumSet.of(
				Monster.Ahrim,
				Monster.Dharok,
				Monster.Guthan,
				Monster.Karil,
				Monster.Torag,
				Monster.Verac,
				Monster.Skeleton,
				Monster.Bloodworm
		) );

		RewardPlan basePlan = RewardPlan.create( Monster.brothers );

		RewardPlan plan = assertValidPlan( planner, logger, RewardTarget.BloodRune, basePlan );

		// Confirm plan is as expected for max bloodrunes when bloodworms and skeletons
		// are selected and shortest approach is preferred
		assertEquals(plan, RewardPlannerTest.AllBrothersSkeletonBloodwormBloodRuneShortest());
	}

	// If there is a brother missing always plan for it first.
	// Avoids case where plan goes over score because we did mob then brother instead of brother than mob.
	public void testOneMissing()
	{
		logger.info("Test case: testOneMissing");

		int potential = 0;

		RewardPlanner planner = new RewardPlanner();

		planner.setTargetMonsters( EnumSet.of(
				Monster.Ahrim,
				Monster.Dharok,
				Monster.Guthan,
				Monster.Karil,
				Monster.Torag,
				Monster.Verac,
				Monster.Bloodworm,
				Monster.GiantCryptRat,
				Monster.Skeleton,
				Monster.GiantCryptSpider
		) );

		final Map<Monster, Integer> map = new HashMap<>();

		map.put( Monster.Ahrim, 1 ); // 98
//		map.put( Monster.Dharok, 1 ); // 115
		map.put( Monster.Guthan, 1 ); // 115
		map.put( Monster.Karil, 1 ); // 98
		map.put( Monster.Torag, 1 ); // 115
		map.put( Monster.Verac, 1 ); // 115

		for (Map.Entry<Monster, Integer> entry : map.entrySet())
		{
			Monster monster = entry.getKey();
			potential += monster.getRewardPotential();
		}

		final RewardPlan basePlan = new RewardPlan( map, potential );

		assertValidPlan( planner, logger, RewardTarget.BloodRune, basePlan );
	}
}
