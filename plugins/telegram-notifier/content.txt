package com.telegramnotifier;

import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import java.io.IOException;
import java.net.*;
import java.nio.charset.StandardCharsets;

@Slf4j

public class TelegramNotifierService
{
    private final TelegramNotifierConfig config;

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    public TelegramNotifierService(TelegramNotifierConfig config)
    {
        this.config = config;
    }

    public void sendMessage(String message)
    {
        String TELEGRAM_BOT_TOKEN = config.telegramBotToken();
        String CHAT_ID = config.telegramChatId();

        String urlStr = String.format(
                "https://api.telegram.org/bot%s/sendMessage?chat_id=%s&text=%s",
                TELEGRAM_BOT_TOKEN,
                CHAT_ID,
                URLEncoder.encode(message, StandardCharsets.UTF_8)
        );

        Request request = new Request.Builder()
                .url(urlStr)
                .build();

        okHttpClient.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to send Telegram message: ", e);
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                try (response) {
                    if (!response.isSuccessful()) {
                        log.debug("Failed to send Telegram message: {}", response.code());
                    }
                }
            }
        });
    }
}

package com.telegramnotifier;

import com.google.inject.Provides;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import javax.inject.Inject;
import net.runelite.client.eventbus.Subscribe;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

@Slf4j
@PluginDescriptor(
		name = "Telegram Notifier",
		description = "Sends Telegram messages on valuable drops",
		tags = {"drop", "telegram", "loot", "notify"}
)
public class TelegramNotifierPlugin extends Plugin
{
	@Inject
	private ScheduledExecutorService executor;

	@SuppressWarnings("unused")
	@Provides
	TelegramNotifierConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TelegramNotifierConfig.class);
	}

	@Inject
	private TelegramNotifierConfig config;

	@Inject
	private TelegramNotifierService telegramService;

	private Pattern cachedPattern;

	@Override
	protected void startUp() throws Exception
	{
		rebuildPattern();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals("telegramnotifier") && event.getKey().equals("keywords"))
		{
			rebuildPattern();
		}
	}

	private void rebuildPattern()
	{
		try {
			cachedPattern = buildPattern();
		} catch (PatternSyntaxException e) {
			cachedPattern = Pattern.compile("a^"); // Match nothing as fallback
		}
	}

	private Pattern buildPattern() throws PatternSyntaxException {
		String keywords = config.keywords().trim();
		if (keywords.isEmpty()) {
			return Pattern.compile("a^"); // Match nothing if no keywords specified
		}
		
		String[] keywordArray = keywords.split(",");
		StringBuilder patternString = new StringBuilder("(?i).*?\\b(");
		
		for (int i = 0; i < keywordArray.length; i++) {
			String keyword = keywordArray[i].trim();
			if (!keyword.isEmpty()) {
				// Escape special regex characters in the keyword
				keyword = keyword.replaceAll("[\\[\\](){}.*+?^$|\\\\]", "\\\\$0");
				patternString.append(keyword);
				if (i < keywordArray.length - 1) {
					patternString.append("|");
				}
			}
		}
		
		patternString.append(")\\b.*?");
		return Pattern.compile(patternString.toString());
	}

	@SuppressWarnings("unused")
	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		String rawMessage = event.getMessage();
		
		final String message = rawMessage.replaceAll("<[^>]*>", "");

		if (cachedPattern.matcher(message).matches())
		{
			executor.execute(() -> telegramService.sendMessage(message));
		}
	}
}

package com.telegramnotifier;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("telegramnotifier")
public interface TelegramNotifierConfig extends Config
{
	@ConfigItem(
			keyName = "keywords",
			name = "Keywords",
			description = "Comma-separated list of keywords to match in messages (e.g., 'superior, granite maul, abyssal whip')"
	)
	default String keywords() {
		return "superior, granite maul, abyssal whip, abyssal dagger, low prayer, goading potion";
	}

	@ConfigItem(
			keyName = "telegramBotToken",
			name = "Telegram Bot Token",
			description = "Your bot token from BotFather"
	)
	default String telegramBotToken()
	{
		return "";
	}

	@ConfigItem(
			keyName = "telegramChatId",
			name = "Telegram Chat ID",
			description = "Your Telegram chat ID"
	)
	default String telegramChatId()
	{
		return "";
	}

}

package com.telegramnotifier;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

@SuppressWarnings("unchecked")
public class TelegramNotifierPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TelegramNotifierPlugin.class);
		RuneLite.main(args);
	}
}
