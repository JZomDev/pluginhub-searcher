package com.adamk33n3r.runelite.watchdog;

import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ClientUI;

import jaco.mp3.player.MP3Player;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.*;
import javax.swing.SwingUtilities;
import java.awt.Toolkit;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.Queue;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
@Singleton
public class SoundPlayer {
    @Inject
    private ClientUI clientUI;

    @Inject
    private Client client;

    @Inject
    private transient ClientThread clientThread;

    @Inject
    private WatchdogConfig config;

    private final MP3Player mp3Player;

    private final Queue<SoundItem> queue = new ConcurrentLinkedQueue<>();

    private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);
    private ScheduledFuture<?> soundPlayerFuture;
    private Timeout soundTimeout;

    private boolean mp3IsPlaying = false;
    private boolean clipIsPlaying = false;
    private long mouseLastPressedMillis;

    public SoundPlayer() {
        this.mp3Player = new MP3Player();
    }

    public void startUp() {
        this.soundPlayerFuture = this.executor.scheduleAtFixedRate(
                this::processQueue,
                0,
                100,
                TimeUnit.MILLISECONDS
        );
    }

    public void shutDown() {
        this.soundPlayerFuture.cancel(false);
        this.stop();
    }

    public void processQueue() {
        // Handle mp3 being over
        if (!this.clipIsPlaying && this.mp3IsPlaying && this.mp3Player.isStopped()) {
            if (this.mp3Player.isRepeat()) {
                this.mp3Player.play();
                return;
            } else {
                this.mp3IsPlaying = false;
            }
        }
        if (mp3IsPlaying || clipIsPlaying) {
            return;
        }

        this.playNext(this.mp3Player);
    }

    public void stop() {
        if (this.soundTimeout != null) {
            this.soundTimeout.stopAndRunNow();
            this.soundTimeout = null;
        }
        this.queue.clear();
    }

    public void play(File soundFile, int volume) {
        this.play(soundFile, volume, 0);
    }

    public void play(File soundFile, int volume, int repeatTime) {
        this.queue.add(new SoundItem(soundFile, volume, repeatTime));
        if (!WatchdogPlugin.getInstance().getConfig().putSoundsIntoQueue()) {
            SwingUtilities.invokeLater(() -> this.playNext(this.mp3Player));
        }
    }

    private void playNext(MP3Player mp3Player) {
        SoundItem nextSound = this.queue.poll();
        if (nextSound == null) {
            return;
        }

        if (!nextSound.getFile().exists()) {
            log.error(String.format("File not found: %s", nextSound.getFile().getAbsolutePath()));
            this.clipIsPlaying = true;
            Toolkit.getDefaultToolkit().beep();
            this.executor.schedule(() -> this.clipIsPlaying = false, 1, TimeUnit.SECONDS);
            return;
        }

        mouseLastPressedMillis = client.getMouseLastPressedMillis();

        log.debug(String.format("Now playing: %s", nextSound.getFile().getAbsolutePath()));

        if (nextSound.getFile().getName().endsWith(".mp3")) {
            mp3Player.clearPlayList();
            mp3Player.add(nextSound.getFile());
            mp3Player.setVolume(nextSound.getGain() * 10);
            this.mp3IsPlaying = true;
            if (this.soundTimeout != null) {
                this.soundTimeout.stopAndRunNow();
                this.soundTimeout = null;
            }
            mp3Player.play();
            // jaco.mp3 repeat functionality is broken as it only loops when skipping, but we are using it to signal to ourselves to repeat on loop
            mp3Player.setRepeat(true);
            setTimeout(() -> {
                mp3Player.setRepeat(false);
            }, nextSound.getRepeatSeconds());
        } else {
            try {
                Clip clip = AudioSystem.getClip();
                try (InputStream fileStream = new BufferedInputStream(new FileInputStream(nextSound.getFile()));
                     AudioInputStream sound = AudioSystem.getAudioInputStream(fileStream)) {
                    clip.open(sound);
                    FloatControl volumeFC = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);
                    int decibels = Util.scale(nextSound.getGain(), 0, 10, -25, 5);
                    volumeFC.setValue(decibels);
                    this.clipIsPlaying = true;
                    clip.loop(0);
                    AtomicBoolean isLooping = new AtomicBoolean(true);
                    clip.addLineListener(event -> {
                        if (event.getType() == LineEvent.Type.STOP) {
                            if (isLooping.get()) {
                                clip.setFramePosition(0);
                                clip.loop(0);
                            } else {
                                this.clipIsPlaying = false;
                                clip.close();
                            }
                        }
                    });

                    if (this.soundTimeout != null) {
                        this.soundTimeout.stopAndRunNow();
                        this.soundTimeout = null;
                    }

                    setTimeout(() -> {
                        isLooping.set(false);
                    }, nextSound.getRepeatSeconds());
                } catch (Exception e) {
//                } catch (UnsupportedAudioFileException | IOException | LineUnavailableException e) {
                    log.warn("Unable to load sound", e);
                    clip.close();
                }
            } catch (Exception e) {
                log.error("Error trying to create clip", e);
            }
        }
    }

    /**
     * Runs a method after a delay
     * <p>
     * Internally polls for user interaction if the delay is < 0
     */
    private void setTimeout(Runnable runnable, int delaySeconds) {
        if (delaySeconds == 0) {
            runnable.run();
            return;
        }

        if (delaySeconds < 0) {
            this.soundTimeout = new Interval(this.executor, (interval, stop) -> {
                if (this.hasUserInteraction() || stop) {
                    interval.stop();
                    runnable.run();
                }
            }, Constants.CLIENT_TICK_LENGTH, TimeUnit.MILLISECONDS);
            return;
        }
        this.soundTimeout = new Timeout(this.executor, (timeout, stop) -> runnable.run(), delaySeconds, TimeUnit.SECONDS);
    }

    private boolean hasUserInteraction() {
        // We poll this every client tick, if there was any activity in the past second, that counts
        int clientTicksSinceActivity = 1000 / Constants.CLIENT_TICK_LENGTH;
        if (((client.getMouseIdleTicks() < clientTicksSinceActivity && this.config.mouseMovementCancels())
                || client.getKeyboardIdleTicks() < clientTicksSinceActivity
                || client.getMouseLastPressedMillis() > mouseLastPressedMillis) && clientUI.isFocused()
        ) {
            return true;
        }
        return false;
    }

    private MP3Player createMP3Player() {
        MP3Player mp3Player = new MP3Player();
        mp3Player.setRepeat(false);
        return mp3Player;
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.*;
import com.adamk33n3r.runelite.watchdog.hub.AlertHubPanel;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.ImportExportDialog;
import com.adamk33n3r.runelite.watchdog.ui.MessagePickerDialog;
import com.adamk33n3r.runelite.watchdog.ui.alerts.*;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertListPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.HistoryPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;
import com.adamk33n3r.runelite.watchdog.ui.panels.ToolsPanel;

import net.runelite.api.Client;
import net.runelite.api.MessageNode;
import net.runelite.client.events.NotificationFired;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Provider;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.Arrays;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Slf4j
@Singleton
public class WatchdogPanel extends PluginPanel {
    @Inject
    @Named("watchdog.helpURL")
    private String HELP_URL;

    @Inject
    @Named("watchdog.discordURL")
    private String DISCORD_URL;

    @Inject
    @Named("watchdog.kofiURL")
    private String KOFI_URL;

    @Inject
    @Named("watchdog.pluginVersion")
    private String PLUGIN_VERSION;

    @Inject
    @Named("watchdog.pluginVersionFull")
    private String PLUGIN_VERSION_FULL;

    @Inject
    @Named("VERSION_PHASE")
    private String PLUGIN_VERSION_PHASE;

    @Getter
    private final WatchdogMuxer muxer = new WatchdogMuxer(this);

    @Getter
    @Inject
    private Provider<HistoryPanel> historyPanelProvider;

    @Inject
    private Provider<ToolsPanel> toolsPanelProvider;

    @Inject
    private Provider<AlertHubPanel> alertHubPanelProvider;

    @Inject
    private AlertManager alertManager;

    @Inject
    private WatchdogConfig watchdogConfig;

    @Inject
    private Client client;

    @Inject
    private OkHttpClient httpClient;

    private AlertListPanel alertListPanel;

    public WatchdogPanel() {
        super(false);
    }

    public void rebuild() {
        this.removeAll();
        this.setLayout(new BorderLayout(0, 3));
        this.setBorder(new EmptyBorder(0, 5, 0, 5));
        this.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBorder(new EmptyBorder(5, 0, 0, 0));
        JPanel titlePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 3));
        JLabel title = new JLabel(WatchdogPlugin.getInstance().getName());
        title.setFont(title.getFont().deriveFont(Font.BOLD));
        title.setHorizontalAlignment(JLabel.LEFT);
        title.setForeground(Color.WHITE);
        if (WatchdogPlugin.getInstance().isInBannedArea()) {
            title.setForeground(Color.RED);
            String tooltip = "You are in a banned area. Watchdog is disabled in the following areas:\n";
            tooltip += Arrays.stream(Region.values()).map(Region::name).collect(Collectors.joining(", "));
            title.setToolTipText(tooltip);
        } else {
            title.setForeground(Color.WHITE);
            boolean isPreRelease = !PLUGIN_VERSION_PHASE.equals("release") && !PLUGIN_VERSION_PHASE.isEmpty();
            title.setToolTipText("Watchdog v" + (isPreRelease ? PLUGIN_VERSION_FULL : PLUGIN_VERSION));
        }
        titlePanel.add(title);

        JLabel version = new JLabel("v"+PLUGIN_VERSION);
        version.setFont(version.getFont().deriveFont(Font.BOLD, 10f));
        version.setBorder(new EmptyBorder(5, 0, 0, 0));
        titlePanel.add(version);
        topPanel.add(titlePanel);

        JPanel actionButtons = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));

        JButton discordButton = PanelUtils.createActionButton(Icons.DISCORD, Icons.DISCORD_HOVER, "Discord", (btn, modifiers) -> {
            LinkBrowser.browse(DISCORD_URL);
        });
        actionButtons.add(discordButton);

        JButton kofiButton = PanelUtils.createActionButton(Icons.KOFI, Icons.KOFI_HOVER, "Buy me a coffee :)", (btn, modifiers) -> {
            LinkBrowser.browse(KOFI_URL);
        });
        kofiButton.setPreferredSize(new Dimension(17, 17));
        actionButtons.add(kofiButton);

        JButton helpButton = PanelUtils.createActionButton(Icons.HELP, Icons.HELP_HOVER, "Wiki", (btn, modifiers) -> {
            LinkBrowser.browse(HELP_URL);
        });
        actionButtons.add(helpButton);

        JButton configButton = PanelUtils.createActionButton(Icons.CONFIG, Icons.CONFIG_HOVER, "Config", (btn, modifiers) -> {
            WatchdogPlugin.getInstance().openConfiguration();
        });
        actionButtons.add(configButton);

        JButton historyButton = PanelUtils.createActionButton(Icons.TOOLS, Icons.TOOLS_HOVER, "Tools", (btn, modifiers) -> {
            this.muxer.pushState(this.toolsPanelProvider.get());
        });
        actionButtons.add(historyButton);

        JButton alertDropDownButton = PanelUtils.createAlertDropDownButton(createdAlert -> {
            this.alertManager.addAlert(createdAlert, false);
            this.openAlert(createdAlert);
        });
        JPanel addAlertWrapper = new JPanel(new BorderLayout());
        addAlertWrapper.setBorder(new EmptyBorder(0, 5, 0, 0));
        addAlertWrapper.add(alertDropDownButton);
        actionButtons.add(addAlertWrapper);

        topPanel.add(actionButtons, BorderLayout.EAST);

        this.add(topPanel, BorderLayout.NORTH);

        this.alertListPanel = new AlertListPanel(this.alertManager.getAlerts(), null, this::rebuild);
        this.add(this.alertListPanel, BorderLayout.CENTER);

        JPanel importExportGroup = new JPanel(new GridLayout(1, 2, 5, 0));
        JButton importButton = new JButton("Import", Icons.IMPORT);
        importButton.setHorizontalTextPosition(SwingConstants.LEFT);
        importButton.addActionListener(ev -> {
            ImportExportDialog importExportDialog = new ImportExportDialog(
                SwingUtilities.getWindowAncestor(this),
                (json, append) -> this.alertManager.importAlerts(json, this.alertManager.getAlerts(), append, true, this.watchdogConfig.overrideImportsWithDefaults())
            );
            importExportDialog.setVisible(true);
        });
        importExportGroup.add(importButton);
        JButton exportButton = new JButton("Export", Icons.EXPORT);
        exportButton.setHorizontalTextPosition(SwingConstants.LEFT);
        exportButton.addActionListener(ev -> {
            ImportExportDialog importExportDialog = new ImportExportDialog(SwingUtilities.getWindowAncestor(this), this.alertManager.getAlerts());
            importExportDialog.setVisible(true);
        });
        importExportGroup.add(exportButton);

        JPanel bottomPanel = new JPanel(new GridLayout(0, 1, 3, 3));
        bottomPanel.add(importExportGroup);
        JButton hubButton = new JButton("Alert Hub", Icons.DOWNLOAD);
        hubButton.setHorizontalTextPosition(SwingConstants.LEFT);
        hubButton.addActionListener(ev -> {
            AlertHubPanel alertHubPanel = this.alertHubPanelProvider.get();
            this.muxer.pushState(alertHubPanel);
        });
        bottomPanel.add(hubButton);
        this.add(bottomPanel, BorderLayout.SOUTH);

        this.revalidate();
    }

    public void openAlert(Alert alert) {
        PluginPanel panel = this.createPluginPanel(alert);
        if (panel != null) {
            this.muxer.pushState(panel);
        } else {
            log.error(String.format("Tried to open an alert of type %s that doesn't have a panel.", alert.getClass()));
        }
    }

    private PluginPanel createPluginPanel(Alert alert) {
        if (alert instanceof PlayerChatAlert) {
            return new PlayerChatAlertPanel(this, (PlayerChatAlert) alert);
        } else if (alert instanceof ChatAlert) {
            return new GameMessageAlertPanel(this, (ChatAlert) alert);
        } else if (alert instanceof NotificationFiredAlert) {
            return new NotificationFiredAlertPanel(this, (NotificationFiredAlert) alert);
        } else if (alert instanceof StatChangedAlert) {
            return new StatChangedAlertPanel(this, (StatChangedAlert) alert);
        } else if (alert instanceof XPDropAlert) {
            return new XPDropAlertPanel(this, (XPDropAlert) alert);
        } else if (alert instanceof SoundFiredAlert) {
            return new SoundFiredAlertPanel(this, (SoundFiredAlert) alert);
        } else if (alert instanceof SpawnedAlert) {
            return new SpawnedAlertPanel(this, (SpawnedAlert) alert);
        } else if (alert instanceof InventoryAlert) {
            return new InventoryAlertPanel(this, (InventoryAlert) alert);
        } else if (alert instanceof AlertGroup) {
            return new AlertGroupPanel(this, (AlertGroup) alert);
        } else if (alert instanceof LocationAlert) {
            return new LocationAlertPanel(this, (LocationAlert) alert, this.client);
        }

        return null;
    }

    @Override
    public void onActivate() {
        this.rebuild();
    }

    @Override
    public void onDeactivate() {
        WatchdogPlugin.getInstance().getScreenMarkerUtil().finishCreation(true);
    }

    public void scrollToBottom() {
        JScrollBar scrollBar = this.alertListPanel.getScrollPane().getVerticalScrollBar();
        scrollBar.setValue(scrollBar.getMaximum());
    }

    public void pickMessage(Consumer<String> callback, Predicate<MessageNode> filter) {
        Stream<MessageNode> messageStream = WatchdogPlugin.getInstance().getMessageQueue().stream();
        if (filter != null) {
            messageStream = messageStream.filter(filter);
        }
        MessagePickerDialog messagePickerDialog = new MessagePickerDialog(
            SwingUtilities.getWindowAncestor(this),
            messageStream.map(MessageNode::getValue),
            callback
        );
        messagePickerDialog.setVisible(true);
    }

    public void pickNotification(Consumer<String> callback) {
        MessagePickerDialog messagePickerDialog = new MessagePickerDialog(
            SwingUtilities.getWindowAncestor(this),
            WatchdogPlugin.getInstance().getNotificationsQueue().stream()
                .map(NotificationFired::getMessage),
            callback
        );
        messagePickerDialog.setVisible(true);
    }
}

package com.adamk33n3r.runelite.watchdog;

import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DocumentFilter;

public class LengthLimitFilter extends DocumentFilter {
    private final int limit;

    public LengthLimitFilter(int limit) {
        this.limit = limit;
    }

    @Override
    public void replace(FilterBypass filterBypass, int offset, int length, String text, AttributeSet attributeSet) throws BadLocationException {
        int currentLength = filterBypass.getDocument().getLength();
        int overLimit = (currentLength + text.length()) - this.limit - length;
        if (overLimit > 0) {
            text = text.substring(0, text.length() - overLimit);
        }

        super.replace(filterBypass, offset, length, text, attributeSet);
    }
}

package com.adamk33n3r.runelite.watchdog;

public interface Displayable {
    String getName();
    String getTooltip();
}

package com.adamk33n3r.runelite.watchdog.elevenlabs;

import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;

import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.annotation.Nonnull;
import java.io.*;
import java.util.Objects;
import java.util.function.Consumer;

import static net.runelite.http.api.RuneLiteAPI.JSON;

@Slf4j
public class ElevenLabs {
    private static final String BASE_URL = "https://api.elevenlabs.io/";

    public static void getVoice(OkHttpClient client, String voiceID, Consumer<Voice> callback) {
        if (voiceID == null) {
            return;
        }
        Request request = new Request.Builder()
            .url(BASE_URL + "v1/voices/" + voiceID)
            .addHeader("accept", "application/json")
            .addHeader("xi-api-key", WatchdogPlugin.getInstance().getConfig().elevenLabsAPIKey())
            .build();
        makeRequest(client, request, Voice.class, callback);
    }

    public static void getVoices(OkHttpClient client, Consumer<Voices> callback) {
        Request request = new Request.Builder()
            .url(BASE_URL + "v1/voices")
            .addHeader("accept", "application/json")
            .addHeader("xi-api-key", WatchdogPlugin.getInstance().getConfig().elevenLabsAPIKey())
            .build();
        makeRequest(client, request, Voices.class, callback);
    }

    public static void generateTTS(OkHttpClient client, Voice voice, String message, Consumer<File> callback) {
//        String body = WatchdogPlugin.getInstance().getAlertManager().getGson().toJson("");
        Request request = new Request.Builder()
            .url(BASE_URL + "v1/text-to-speech/" + voice.getVoiceId())
            .post(RequestBody.create(JSON, "{\n" +
                "  \"text\": \""+message+"\",\n" +
                "  \"model_id\": \"eleven_monolingual_v1\",\n" +
                "  \"voice_settings\": {\n" +
                "    \"stability\": 0.5,\n" +
                "    \"similarity_boost\": 0.5,\n" +
                "    \"style\": 0.5,\n" +
                "    \"use_speaker_boost\": true\n" +
                "  }\n" +
                "}"))
            .addHeader("xi-api-key", WatchdogPlugin.getInstance().getConfig().elevenLabsAPIKey())
            .build();
        makeRequest(client, request, File.class, callback);
//        download(client, "U4OFqla1WHSBijg88mGB", callback);
    }

    public static void download(OkHttpClient client, String id, Consumer<File> callback) {
        Request request = new Request.Builder()
            .url(BASE_URL + "v1/history/download")
            .post(RequestBody.create(JSON, "{\n" +
                "  \"history_item_ids\": [\n" +
                "    \""+id+"\"\n" +
                "  ]\n" +
                "}"))
            .addHeader("xi-api-key", WatchdogPlugin.getInstance().getConfig().elevenLabsAPIKey())
            .build();
        makeRequest(client, request, File.class, callback);
    }

    private static <T> void makeRequest(OkHttpClient client, Request request, Class<T> rType, Consumer<T> callback) {
        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@Nonnull Call call, @Nonnull IOException e) {
                log.error("Error with request at: {}", request.url(), e);
            }

            @Override
            public void onResponse(@Nonnull Call call, @Nonnull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        log.error("Unexpected error code: {}", response);
                        return;
                    }

                    if (responseBody == null) {
                        log.error("Response body is null: {}", response);
                        return;
                    }

                    if (Objects.requireNonNull(response.header("content-type")).contains("application/json")) {
                        callback.accept(WatchdogPlugin.getInstance().getAlertManager().getGson().fromJson(responseBody.charStream(), rType));
    //                    Voice voice = voices.getVoices().get(voices.getVoices().size() - 1);
    //                    generateTTS(client, voice, "This is a test of the playback sound system");
    //                    download(client, "U4OFqla1WHSBijg88mGB");
                    } else if (rType.isAssignableFrom(File.class)) {
                        log.debug("got audio stream");
                        File tmpFile = File.createTempFile("watchdog", ".mp3");
    //                    BufferedInputStream bufferedInputStream = new BufferedInputStream(response.body().byteStream());
                        InputStream inputStream = responseBody.byteStream();
                        try (FileOutputStream fileOutputStream = new FileOutputStream(tmpFile)) {
                            byte[] buffer = new byte[8192];
                            int bytesRead;
                            while ((bytesRead = inputStream.read(buffer, 0, buffer.length)) != -1) {
                                fileOutputStream.write(buffer, 0, bytesRead);
                            }
                        }

                        log.debug("tmp file: {}", tmpFile);
//                        WatchdogPlugin.getInstance().getSoundPlayer().play(tmpFile, 10);
//                        WatchdogPlugin.getInstance().getSoundPlayer().play(tmpFile, 5);
//                        WatchdogPlugin.getInstance().getSoundPlayer().play(tmpFile, 2);
//                        WatchdogPlugin.getInstance().getSoundPlayer().play(new File("C:\\Users\\adamg\\Music\\airplane_seatbelt.wav"), 10);
//                        WatchdogPlugin.getInstance().getSoundPlayer().play(tmpFile, 10);
                        callback.accept(rType.cast(tmpFile));
                    }
                } catch (Exception e) {
                    log.error("error while hitting eleven labs api");
                }
            }
        });
    }
}

package com.adamk33n3r.runelite.watchdog.elevenlabs;

import lombok.Data;

import java.util.List;

@Data
public class Voices {
    private List<Voice> voices;
}

package com.adamk33n3r.runelite.watchdog.elevenlabs;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

import java.util.Map;

@Data
public class Voice {
    @SerializedName("voice_id")
    private String voiceId;
    private String name;
    private String category;
    private String description;
    @SerializedName("preview_url")
    private String previewUrl;
    private Map<String, String> labels;
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker.ScreenMarkerUtil;

import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.MessageNode;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NotificationFired;
import net.runelite.client.events.OverlayMenuClicked;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.config.ConfigPlugin;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.util.AsyncBufferedImage;

import com.google.common.collect.EvictingQueue;
import com.google.inject.Binder;
import com.google.inject.Provides;
import com.google.inject.name.Names;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import javax.inject.Provider;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import java.util.Properties;
import java.util.Queue;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;

@Slf4j
@PluginDescriptor(
    name = "Watchdog",
    description = "Create custom alerts for different events like messages, stats, or built-in notifications",
    tags = {"alert", "notification","custom","advanced","overlay","sound","drop","afk","tracker","reminder","notify","notifier","helper","timer","message"}
)
public class WatchdogPlugin extends Plugin {
    @Getter
    @Inject
    private WatchdogConfig config;
    @Inject
    private ConfigManager configManager;
    @Inject
    private ItemManager itemManager;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private OverlayManager overlayManager;

    @Getter
    @Inject
    private AlertManager alertManager;

    @Getter
    @Inject
    private PopupManager popupManager;

    @Inject
    private Client client;

    @Inject
    private EventBus eventBus;

    @Inject
    private EventHandler eventHandler;

    @Getter
    @Inject
    private FlashOverlay flashOverlay;

    @Getter
    @Inject
    private NotificationOverlay notificationOverlay;

    @Getter
    @Inject
    private ScreenMarkerUtil screenMarkerUtil;

    @Getter
    @Inject
    private WatchdogPanel panel;

    @Getter
    @Inject
    private SoundPlayer soundPlayer;

    @Getter
    @Inject
    private OkHttpClient httpClient;

    private AsyncBufferedImage icon;
    private AsyncBufferedImage iconDisabled;
    private NavigationButton navButton;
    private NavigationButton navButtonDisabled;

    @Getter
    private static WatchdogPlugin instance;

    @Getter
    private final Queue<MessageNode> messageQueue = EvictingQueue.create(200);

    @Getter
    private final Queue<NotificationFired> notificationsQueue = EvictingQueue.create(20);

    @Getter
    private boolean isInBannedArea = false;

    public WatchdogPlugin() {
        instance = this;
    }

    @Override
    public void configure(Binder binder) {
        Properties properties = WatchdogProperties.getProperties();
        Names.bindProperties(binder, properties);
        binder.bind(WatchdogMuxer.class).toProvider(() -> this.panel.getMuxer());
    }

    @Override
    protected void startUp() throws Exception {
        this.eventBus.register(this.eventHandler);

        this.overlayManager.add(this.flashOverlay);
        this.overlayManager.add(this.notificationOverlay);
        this.screenMarkerUtil.startUp();

        this.alertManager.loadAlerts();

        this.icon = this.itemManager.getImage(ItemID.BELL_BAUBLE);
        this.iconDisabled = this.itemManager.getImage(ItemID.BELL_BAUBLE_6848);

        this.rebuildSidePanelButtons();

        this.soundPlayer.startUp();

        ToolTipManager.sharedInstance().setDismissDelay(Integer.MAX_VALUE);
    }

    private void rebuildSidePanelButtons() {
        if (this.navButton != null) {
            this.clientToolbar.removeNavigation(this.navButton);
        }
        if (this.navButtonDisabled != null) {
            this.clientToolbar.removeNavigation(this.navButtonDisabled);
        }
        this.navButton = NavigationButton.builder()
            .tooltip("Watchdog")
            .icon(icon)
            .priority(this.config.sidePanelPriority())
            .panel(this.panel.getMuxer())
            .build();
        this.navButtonDisabled = NavigationButton.builder()
            .tooltip("Watchdog (In disabled area)")
            .icon(iconDisabled)
            .priority(this.config.sidePanelPriority())
            .panel(this.panel.getMuxer())
            .build();
        this.icon.onLoaded(() -> {
            if (this.isInBannedArea) {
                this.clientToolbar.addNavigation(this.navButtonDisabled);
            } else {
                this.clientToolbar.addNavigation(this.navButton);
            }
        });
    }

    @Override
    protected void shutDown() throws Exception {
        this.eventBus.unregister(this.eventHandler);
        this.clientToolbar.removeNavigation(this.navButton);
        this.clientToolbar.removeNavigation(this.navButtonDisabled);
        this.overlayManager.remove(this.flashOverlay);
        this.overlayManager.remove(this.notificationOverlay);
        this.soundPlayer.shutDown();
        this.screenMarkerUtil.shutDown();
    }

    public void openConfiguration() {
        // We don't have access to the ConfigPlugin so let's just emulate an overlay click
        this.eventBus.post(new OverlayMenuClicked(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, null, null), this.notificationOverlay));
    }

    @Subscribe
    private void onGameTick(GameTick gameTick) {
        int regionID = WorldPoint.fromLocalInstance(this.client, this.client.getLocalPlayer().getLocalLocation()).getRegionID();
        boolean before = this.isInBannedArea;
        this.isInBannedArea = Region.isBannedRegion(this.client.getLocalPlayer().getWorldView().isInstance(), regionID);
//            || this.client.getVarbitValue(Varbits.IN_RAID) > 0
//            || this.client.getVarbitValue(Varbits.TOA_RAID_LEVEL) > 0
//            || this.client.getVarbitValue(Varbits.THEATRE_OF_BLOOD) > 0;

        // State changed so switch panel icon
        if (before != this.isInBannedArea) {
            if (this.isInBannedArea) {
                this.clientToolbar.removeNavigation(this.navButton);
                this.clientToolbar.addNavigation(this.navButtonDisabled);
                if (this.panel.getMuxer().isActive()) {
                    SwingUtilities.invokeLater(() -> this.clientToolbar.openPanel(this.navButtonDisabled));
                }
            } else {
                this.clientToolbar.removeNavigation(this.navButtonDisabled);
                this.clientToolbar.addNavigation(this.navButton);
                if (this.panel.getMuxer().isActive()) {
                    SwingUtilities.invokeLater(() -> this.clientToolbar.openPanel(this.navButton));
                }
            }
        }

        this.popupManager.processPopupQueue();
    }

    @Subscribe
    private void onGameStateChanged(GameStateChanged gameStateChanged) {
        this.soundPlayer.stop();
    }

    @Subscribe
    private void onChatMessage(ChatMessage chatMessage) {
        this.messageQueue.offer(chatMessage.getMessageNode());
    }
    @Subscribe
    private void onNotificationFired(NotificationFired notificationFired) {
        this.notificationsQueue.offer(notificationFired);
    }

    @Subscribe
    private void onConfigChanged(ConfigChanged configChanged) {
        if (configChanged.getGroup().equals(WatchdogConfig.CONFIG_GROUP_NAME)) {
            if (configChanged.getKey().equals(WatchdogConfig.ENABLE_TTS)) {
                // To the top!
                while (this.panel.getMuxer().getComponentCount() > 1) {
                    this.panel.getMuxer().popState();
                }
                this.panel.rebuild();
            } else if (configChanged.getKey().equals(WatchdogConfig.SIDE_PANEL_PRIORITY)) {
                this.rebuildSidePanelButtons();
            }
        }
    }

    @Subscribe
    private void onProfileChanged(ProfileChanged profileChanged) {
        this.alertManager.loadAlerts();
    }

    @Provides
    WatchdogConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(WatchdogConfig.class);
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.notifications.*;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum NotificationType {
    GAME_MESSAGE("Game Message", "Put a game message in your chat", NotificationCategory.TEXT, GameMessage.class),
    SCREEN_FLASH("Screen Flash", "Flash your screen a custom color", NotificationCategory.OVERLAY, ScreenFlash.class),
    SOUND_EFFECT("Sound Effect", "Play a builtin sound effect", NotificationCategory.AUDIO, SoundEffect.class),
    SOUND("Custom Sound", "Play a custom sound", NotificationCategory.AUDIO, Sound.class),
    TEXT_TO_SPEECH("Text to Speech", "Synthesize speech", NotificationCategory.AUDIO, TextToSpeech.class),
    TRAY_NOTIFICATION("Tray Notification", "Create a tray notification", NotificationCategory.TEXT, TrayNotification.class),
    OVERHEAD("Overhead", "Display overhead text", NotificationCategory.TEXT, Overhead.class),
    OVERLAY("Overlay", "Create an overlay notification", NotificationCategory.OVERLAY, Overlay.class),
    POPUP("Popup", "Create a popup notification (like collection log or league task)", NotificationCategory.OVERLAY, Popup.class),
    SCREEN_MARKER("Screen Marker", "Show a screen marker", NotificationCategory.OVERLAY, ScreenMarker.class),
    DINK("Dink", "Tell Dink to send a custom notification to your webhook", NotificationCategory.ADVANCED, Dink.class),
    PLUGIN_MESSAGE("Plugin Message", "Send a message to another plugin", NotificationCategory.ADVANCED, PluginMessage.class),
    DISMISS_OVERLAY("Dismiss Overlay", "Dismiss a sticky overlay by ID", NotificationCategory.ADVANCED, DismissOverlay.class),
    DISMISS_SCREEN_MARKER("Dismiss Screen Marker", "Dismiss a sticky screen marker by ID", NotificationCategory.ADVANCED, DismissScreenMarker.class),
    REQUEST_FOCUS("Request Focus", "Requests focus on the window", NotificationCategory.ADVANCED, RequestFocus.class),
    NOTIFICATION_EVENT("Notification Event", "Fire a NotificationFired event so that other plugins may hook into it e.g. RL Tray Notifications", NotificationCategory.ADVANCED, NotificationEvent.class),
    ;

    private final String name;
    private final String tooltip;
    private final NotificationCategory category;
    private final Class<? extends Notification> implClass;
}

package com.adamk33n3r.runelite.watchdog;

import lombok.Getter;

public class Version implements Comparable<Version> {
    @Getter
    private final String version;

    public Version(String version) {
        if (version != null && !version.matches("[0-9]+(\\.[0-9]+)*(-\\w+)?")) {
            throw new IllegalArgumentException("Invalid version format");
        }
        this.version = version;
    }

    @Override
    public int compareTo(Version o) {
        if (o == null || o.version == null) {
            return 1;
        }

        if (this.version == null) {
            return -1;
        }

        String thisVer = this.version.lastIndexOf('-') < 0 ? this.version : this.version.substring(0, this.version.lastIndexOf("-"));
        String thatVer = o.version.lastIndexOf('-') < 0 ? o.version : o.version.substring(0, o.version.lastIndexOf("-"));
        String[] thisParts = thisVer.split("\\.");
        String[] thatParts = thatVer.split("\\.");
        int length = Math.max(thisParts.length, thatParts.length);
        for (int i = 0; i < length; i++) {
            int thisPart = i < thisParts.length ? Integer.parseInt(thisParts[i]) : 0;
            int thatPart = i < thatParts.length ? Integer.parseInt(thatParts[i]) : 0;
            if (thisPart < thatPart) {
                return -1;
            }
            if (thisPart > thatPart) {
                return 1;
            }
        }

        return 0;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null) {
            return false;
        }
        if (this.getClass() != o.getClass()) {
            return false;
        }

        return this.compareTo((Version) o) == 0;
    }

    @Override
    public String toString() {
        return this.version == null ? null : "v" + this.version;
    }
}

package com.adamk33n3r.runelite.watchdog.hub;

import com.adamk33n3r.runelite.watchdog.alerts.Alert;

import lombok.Data;
import lombok.Setter;

import java.net.URL;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Data
public class AlertManifest {
    @Setter
    private String internalName;
    private URL repo;
    private String commit;

    private final String displayName;
    private final String description;
    private final String compatibleVersion;
    private final String author;
    private final AlertHubCategory category;
    private final List<String> tags;
    private final List<String> dependsOn;
    private final Alert alert;
    private final boolean hasIcon;

    @Override
    public String toString()
    {
        return this.displayName;
    }

    public List<String> getKeywords() {
        Stream<String> keywords = Stream.of(
            this.getDisplayName(),
            this.getInternalName(),
            this.getAuthor(),
            this.getCategory().getName()
        ).filter(Objects::nonNull);
        if (this.getTags() != null) {
            keywords = Stream.concat(keywords, this.getTags().stream());
        }
        if (this.getDependsOn() != null) {
            keywords = Stream.concat(keywords, this.getDependsOn().stream());
        }
        return keywords.collect(Collectors.toList());
    }
}

package com.adamk33n3r.runelite.watchdog.hub;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.WrappingLabel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.RuneLite;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import lombok.Getter;

import javax.swing.*;
import javax.swing.border.LineBorder;
import java.awt.Color;
import java.awt.image.BufferedImage;

@Getter
public class AlertHubItem extends JPanel {
    private static final int LINE_HEIGHT = 16;

    private final AlertHubClient.AlertDisplayInfo alertDisplayInfo;

    public AlertHubItem(AlertHubClient.AlertDisplayInfo alertDisplayInfo, WatchdogConfig watchdogConfig) {
        this.alertDisplayInfo = alertDisplayInfo;
        this.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);

        AlertManifest manifest = this.alertDisplayInfo.getManifest();
        JLabel alertName = new JLabel(manifest.getDisplayName());
        alertName.setFont(FontManager.getRunescapeBoldFont());
        alertName.setToolTipText(manifest.getDisplayName());
        JLabel alertAuthor = new JLabel(manifest.getAuthor());
        alertAuthor.setFont(FontManager.getRunescapeSmallFont());
        alertAuthor.setToolTipText(manifest.getAuthor());

        try {
            alertName.setIcon(new ImageIcon(ImageUtil.loadImageResource(RuneLite.class, manifest.getCategory().getIcon())));
        } catch (Exception e) {
            // error loading icon
            alertName.setIcon(Icons.HELP);
        }

        JLabel compatVersion = new JLabel(manifest.getCompatibleVersion());
        compatVersion.setHorizontalAlignment(JLabel.RIGHT);
        compatVersion.setFont(FontManager.getRunescapeSmallFont());
        compatVersion.setToolTipText("Compatible with Watchdog v" + manifest.getCompatibleVersion());

        WrappingLabel alertDescLabel = new WrappingLabel(manifest.getDescription());

        JButton moreInfoButton = PanelUtils.createActionButton(Icons.HELP, Icons.HELP_HOVER, "More info", (btn, mod) -> {
            LinkBrowser.browse(manifest.getRepo().toString());
        });
        if (manifest.getRepo() == null) {
            moreInfoButton.setVisible(false);
        }

        JButton addButton = new JButton();
        addButton.setText("Add");
        BufferedImage addIcon = ImageUtil.recolorImage(Icons.ADD.getImage(), Color.WHITE);
        addButton.setIcon(new ImageIcon(addIcon));
        addButton.setHorizontalTextPosition(SwingConstants.LEFT);
        addButton.setBackground(new Color(0x28BE28));
        addButton.setBorder(new LineBorder(addButton.getBackground().darker()));
        addButton.setFocusPainted(false);
        addButton.addActionListener((ev) -> {
            WatchdogPlugin.getInstance().getAlertManager().addAlert(manifest.getAlert(), watchdogConfig.overrideImportsWithDefaults());
            JOptionPane.showMessageDialog(this, "Added " + manifest.getDisplayName() + " to your alerts", "Successfully Added", JOptionPane.INFORMATION_MESSAGE);
        });

        JLabel dependsOn = new JLabel();
        dependsOn.setFont(FontManager.getRunescapeSmallFont());
        if (manifest.getDependsOn() != null && !manifest.getDependsOn().isEmpty()) {
            dependsOn.setText("Depends On: " + String.join(", ", manifest.getDependsOn()));
        }

        layout.setVerticalGroup(layout.createSequentialGroup()
            .addGap(5)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                    .addComponent(alertName, LINE_HEIGHT, LINE_HEIGHT, LINE_HEIGHT)
                    .addComponent(moreInfoButton, LINE_HEIGHT, LINE_HEIGHT, LINE_HEIGHT)
                    .addComponent(addButton, LINE_HEIGHT, LINE_HEIGHT, LINE_HEIGHT)
                )
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.PREFERRED_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                    .addComponent(alertAuthor, LINE_HEIGHT, LINE_HEIGHT, LINE_HEIGHT)
                    .addComponent(compatVersion, LINE_HEIGHT, LINE_HEIGHT, LINE_HEIGHT)
                )
                .addComponent(alertDescLabel, 0, GroupLayout.DEFAULT_SIZE, 96)
                .addComponent(dependsOn, 0, GroupLayout.DEFAULT_SIZE, LINE_HEIGHT)
                .addGap(5)
            )
        );

        layout.setHorizontalGroup(layout.createParallelGroup()
            // Info group
            .addGroup(layout.createSequentialGroup()
                .addGap(5)
                .addGroup(layout.createParallelGroup()
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(alertName, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.PREFERRED_SIZE, Short.MAX_VALUE)
                        .addComponent(moreInfoButton, 24, 24, 24)
                        .addComponent(addButton, 50, 50, GroupLayout.PREFERRED_SIZE)
                    )
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(alertAuthor, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.PREFERRED_SIZE, 100)
                        .addComponent(compatVersion, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    )
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(alertDescLabel, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    )
                    .addComponent(dependsOn)
                )
                .addGap(5)
            )
        );
    }
}

package com.adamk33n3r.runelite.watchdog.hub;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum AlertHubCategory {
    COMBAT("Combat", "Combat", "/skill_icons_small/combat.png"),
    SKILLING("Skilling", "Skilling", "/skill_icons_small/mining.png"),
    BOSSES("Bosses", "Bosses", "/skill_icons_small/slayer.png"),
    AFK("AFK", "AFK", "/skill_icons_small/fishing.png"),
    MISC("Misc", "Misc", "/net/runelite/client/plugins/hiscore/activities/clue_scroll_all.png")
    ;

    private final String name;
    private final String tooltip;
    private final String icon;
}

package com.adamk33n3r.runelite.watchdog.hub;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogMuxer;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.SearchBar;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;
import com.adamk33n3r.runelite.watchdog.ui.panels.ScrollablePanel;

import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Provider;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.stream.Collectors;

@Slf4j
public class AlertHubPanel extends PluginPanel {
    private final Provider<WatchdogMuxer> muxer;
    private final AlertHubClient alertHubClient;
    private final ScheduledExecutorService executor;
    private final WatchdogConfig watchdogConfig;

    private List<AlertHubItem> alertHubItems = new ArrayList<>();
    private final IconTextField searchBar;
    private final JPanel container;
    private final JLabel loading;
    private final JScrollPane scrollPane;

    @Inject
    public AlertHubPanel(Provider<WatchdogMuxer> muxer, AlertHubClient alertHubClient, ScheduledExecutorService executor, WatchdogConfig watchdogConfig) {
        super(false);
        this.muxer = muxer;
        this.alertHubClient = alertHubClient;
        this.executor = executor;
        this.watchdogConfig = watchdogConfig;

        JButton backButton = PanelUtils.createActionButton(
            Icons.BACK,
            Icons.BACK_HOVER,
            "Back",
            (btn, modifiers) -> this.muxer.get().popState()
        );
        backButton.setPreferredSize(new Dimension(22, 16));
        backButton.setBorder(new EmptyBorder(0, 0, 0, 5));

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        this.searchBar = new SearchBar(this::updateFilter);
        Arrays.stream(AlertHubCategory.values()).map(AlertHubCategory::getName).forEach(this.searchBar.getSuggestionListModel()::addElement);

        this.container = new JPanel(new DynamicGridLayout(0, 1, 0, 5));
//        this.container.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

        ScrollablePanel wrapper = new ScrollablePanel(new BorderLayout());
        wrapper.add(this.container, BorderLayout.NORTH);
        this.loading = new JLabel("Loading...");
        this.loading.setVisible(false);
        this.loading.setHorizontalAlignment(JLabel.CENTER);
        wrapper.add(this.loading, BorderLayout.CENTER);
        wrapper.setScrollableWidth(ScrollablePanel.ScrollableSizeHint.FIT);
        wrapper.setScrollableHeight(ScrollablePanel.ScrollableSizeHint.STRETCH);
        wrapper.setScrollableBlockIncrement(SwingConstants.VERTICAL, ScrollablePanel.IncrementType.PERCENT, 10);
        wrapper.setScrollableUnitIncrement(SwingConstants.VERTICAL, ScrollablePanel.IncrementType.PERCENT, 10);
        this.scrollPane = new JScrollPane(wrapper, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

        JButton refresh = PanelUtils.createActionButton(Icons.REFRESH, Icons.REFRESH_HOVER, "Refresh", (btn, mod) -> {
            this.reloadList(true);
        });

        layout.setVerticalGroup(layout.createSequentialGroup()
            .addGap(5)
            .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                .addComponent(backButton, 24, 24, 24)
                .addComponent(this.searchBar, 24, 24, 24)
                .addComponent(refresh, 24, 24, 24))
            .addGap(5)
            .addComponent(this.scrollPane)
        );

        layout.setHorizontalGroup(layout.createParallelGroup()
            .addGroup(layout.createSequentialGroup()
                .addComponent(backButton)
                .addComponent(this.searchBar)
                .addComponent(refresh))
            .addGroup(layout.createSequentialGroup()
                .addGap(5)
                .addComponent(this.scrollPane)
                .addGap(5)
            )
        );

        this.reloadList(false);
    }

    public void reloadList(boolean forceDownload) {
        if (this.loading.isVisible()) {
            return;
        }

        this.container.removeAll();
        this.loading.setVisible(true);
        this.executor.submit(() -> {
            try {
                List<AlertHubClient.AlertDisplayInfo> alerts = this.alertHubClient.downloadManifest(forceDownload);
                this.reloadList(alerts);
            } catch (IOException e) {
                log.error("Failed to download alert hub manifest", e);
            }
        });
    }

    private void reloadList(List<AlertHubClient.AlertDisplayInfo> alerts) {
        SwingUtilities.invokeLater(() -> {
            this.loading.setVisible(false);
            this.alertHubItems = alerts.stream()
                .map(alertDisplayInfo -> new AlertHubItem(alertDisplayInfo, this.watchdogConfig))
                .collect(Collectors.toList());
            this.updateFilter(this.searchBar.getText());
        });
    }

    private void updateFilter(String search) {
        this.container.removeAll();
        this.alertHubItems.stream().filter(alertHubItem -> {
            AlertManifest manifest = alertHubItem.getAlertDisplayInfo().getManifest();
            return Util.searchText(search, manifest.getKeywords());
        }).forEach(this.container::add);
        this.container.revalidate();
        this.scrollPane.getVerticalScrollBar().setValue(0);
    }
}

package com.adamk33n3r.runelite.watchdog.hub;

import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;

import net.runelite.client.util.ImageUtil;

import com.google.common.base.Charsets;
import com.google.common.io.CharStreams;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.annotation.Nonnull;
import javax.imageio.ImageIO;
import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

@Slf4j
public class AlertHubClient {
    private final OkHttpClient cachingClient;
    private static final HttpUrl GITHUB = Objects.requireNonNull(HttpUrl.parse("https://github.com/adamk33n3r/runelite-watchdog"));

    @Inject
    public AlertHubClient(OkHttpClient cachingClient) {
        this.cachingClient = cachingClient.newBuilder()
            .addInterceptor(new CacheInterceptor(15))
            .build();
    }

    public List<AlertDisplayInfo> downloadManifest(boolean forceDownload) throws IOException {
        HttpUrl allAlerts = GITHUB.newBuilder()
            .addPathSegment("archive")
            .addPathSegment("alert-hub.zip")
            .build();

        HashMap<String, AlertDisplayInfo> alerts = new HashMap<>();
        Request.Builder reqBuilder = new Request.Builder().url(allAlerts);
        if (forceDownload) {
            reqBuilder.cacheControl(CacheControl.FORCE_NETWORK);
        }
        try (Response res  = this.cachingClient.newCall(reqBuilder.build()).execute()) {
            if (res.code() != 200) {
                throw new IOException("Non-OK response code: " + res.code());
            }

            BufferedInputStream is = new BufferedInputStream(Objects.requireNonNull(res.body()).byteStream());
            ZipInputStream zipInputStream = new ZipInputStream(is);
            ZipEntry entry;
            while ((entry = zipInputStream.getNextEntry()) != null) {
                String filePath = entry.getName().replaceAll("runelite-watchdog-alert-hub/", "");
                String[] splitPath = filePath.split("/", 2);
                if (splitPath.length == 2) {
                    String alertName = splitPath[0];
                    // Don't need to show the example in the panel
                    if (alertName.equals("example") || alertName.equals(".vscode")) {
                        continue;
                    }
                    if (!alerts.containsKey(alertName)) {
                        alerts.put(alertName, new AlertDisplayInfo());
                    }
                    AlertDisplayInfo alertDisplayInfo = alerts.get(alertName);
                    String alertFile = splitPath[1];
                    if (alertFile.equals("alert.json")) {
                        String json = CharStreams.toString(new InputStreamReader(zipInputStream, Charsets.UTF_8));
                        AlertManifest alertManifest = WatchdogPlugin.getInstance().getAlertManager().getGson().fromJson(json, AlertManifest.class);
                        alertManifest.setInternalName(alertName);
                        HttpUrl repoPage = GITHUB.newBuilder()
                            .addPathSegment("tree")
                            .addPathSegment("alert-hub")
                            .addPathSegment(alertName)
                            .build();
                        alertManifest.setRepo(repoPage.url());
                        alertDisplayInfo.manifest = alertManifest;
                    } else if (alertFile.equals("icon.png")) {
                        BufferedImage icon = ImageIO.read(zipInputStream);
                        alertDisplayInfo.icon = ImageUtil.resizeImage(icon, 242, 182, true);
                    }
                }
            }

            return alerts.values().stream().sorted(Comparator.comparing(alert -> alert.manifest.getDisplayName()))
                .collect(Collectors.toList());
        }


//        return Arrays.asList(new AlertManifest(
//            "testAlert",
//            "284hfu43hhfiu24rf",
//            "Test Alert",
//            "This is a test alert on the hub",
//            "4",
//            "adamk33n3r",
//            AlertHubCategory.COMBAT,
//            Arrays.asList("afk", "combat"),
//            new URL("https://github.com/adamk33n3r/runelite-watchdog"),
//            null,
//            false
//        ), new AlertManifest(
//            "testAlert",
//            "284hfu43hhfiu24rf",
//            "Test Alert",
//            "This is a test alert on the hub",
//            "4",
//            "adamk33n3r",
//            AlertHubCategory.COMBAT,
//            Arrays.asList("afk", "combat"),
//            new URL("https://github.com/adamk33n3r/runelite-watchdog"),
//            null,
//            false
//        ), new AlertManifest(
//            "testAlert",
//            "284hfu43hhfiu24rf",
//            "Test Alert",
//            "This is a test alert on the hub",
//            "4",
//            "adamk33n3r",
//            AlertHubCategory.COMBAT,
//            Arrays.asList("afk", "combat"),
//            new URL("https://github.com/adamk33n3r/runelite-watchdog"),
//            null,
//            false
//        ), new AlertManifest(
//            "testAlert2",
//            "284hfu43hhfiu24rf",
//            "Test Alert 2",
//            "This is a test alert on the hub with an extra long description to test wrapping",
//            "4",
//            "adamk33n3r",
//            AlertHubCategory.SKILLING,
//            Arrays.asList("mining", "tts"),
//            new URL("https://github.com/adamk33n3r/runelite-watchdog"),
//            null,
//            false
//        ));
    }

    static class CacheInterceptor implements Interceptor {
        private final int minutes;
        public CacheInterceptor(int minutes) {
            this.minutes = minutes;
        }

        @Override
        @Nonnull
        public Response intercept(Chain chain) throws IOException {
            Response response = chain.proceed(chain.request());

            CacheControl cacheControl = new CacheControl.Builder()
                .maxAge(this.minutes, TimeUnit.MINUTES)
                .build();

            return response.newBuilder()
                .removeHeader("Pragma")
                .removeHeader("Cache-Control")
                .header("Cache-Control", cacheControl.toString())
                .build();
        }
    }

    @Getter
    public static class AlertDisplayInfo {
        private AlertManifest manifest;
        private BufferedImage icon;
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.FlashMode;
import com.adamk33n3r.runelite.watchdog.notifications.tts.TTSSource;
import com.adamk33n3r.runelite.watchdog.notifications.tts.Voice;

import net.runelite.api.SoundEffectID;
import net.runelite.client.config.*;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.util.ColorUtil;

import java.awt.Color;

@ConfigGroup(WatchdogConfig.CONFIG_GROUP_NAME)
public interface WatchdogConfig extends Config {
    String CONFIG_GROUP_NAME = "watchdog";
    Color DEFAULT_NOTIFICATION_COLOR = ColorUtil.fromHex("#46FF0000");
    Color DEFAULT_NOTIFICATION_TEXT_COLOR = Color.WHITE;

    // Hidden
    String ALERTS = "alerts";
    String PLUGIN_VERSION = "pluginVersion";

    // Core
    String ENABLE_TTS = "enableTTS";
    String OVERRIDE_IMPORTS_WITH_DEFAULTS = "overrideImportsWithDefaults";
    String SIDE_PANEL_PRIORITY = "sidePanelPriority";
    String ENABLE_NOTIFICATION_CATEGORIES = "enableNotificationCategories";

    // AFK Notification
    String DEFAULT_AFK_MODE = "defaultAFKMode";
    String DEFAULT_AFK_SECONDS = "defaultAFKSeconds";

    // Overhead
    String DEFAULT_OVERHEAD_DISPLAY_TIME = "defaultOverheadDisplayTime";

    // Overlay
    String OVERLAY_LAYER = "overlayLayer";
    String OVERLAY_FONT_TYPE = "overlayFontType";
    String OVERLAY_SHOW_TIME = "overlayShowTime";
    String DEFAULT_OVERLAY_STICKY = "defaultOverlaySticky";
    String DEFAULT_OVERLAY_TEXT_COLOR = "defaultOverlayTextColor";
    String DEFAULT_OVERLAY_COLOR = "defaultOverlayColor";
    String DEFAULT_OVERLAY_TTL = "defaultOverlayTTL";
    String DEFAULT_OVERLAY_IMAGE_PATH = "defaultOverlayImagePath";

    // Popup
    String DEFAULT_POPUP_COLOR = "defaultPopupColor";
    String DEFAULT_POPUP_TEXT_COLOR = "defaultPopupTextColor";

    // Screen Flash
    String MOUSE_MOVEMENT_CANCELS_FLASH = "mouseMovementCancelsFlash";
    String DEFAULT_SCREEN_FLASH_COLOR = "defaultScreenFlashColor";
    String DEFAULT_SCREEN_FLASH_TYPE = "defaultScreenFlashType";
    String DEFAULT_SCREEN_FLASH_MODE = "defaultScreenFlashMode";
    String DEFAULT_SCREEN_FLASH_DURATION = "defaultScreenFlashDuration";

    // Sound
    String PUT_SOUNDS_INTO_QUEUE = "putSoundsIntoQueue";
    String DEFAULT_SOUND_VOLUME = "defaultSoundVolume";
    String DEFAULT_SOUND_PATH = "defaultSoundPath";

    // Sound Effect
    String DEFAULT_SOUND_EFFECT_ID = "defaultSoundEffectID";
    String DEFAULT_SOUND_EFFECT_VOLUME = "defaultSoundEffectVolume";

    // TTS
    String DEFAULT_TTS_VOLUME = "defaultTTSVolume";
    String DEFAULT_TTS_SOURCE = "defaultTTSSource";
    String DEFAULT_TTS_VOICE = "defaultTTSVoice";
    String DEFAULT_TTS_RATE = "defaultTTSRate";
    String ELEVEN_LABS_API_KEY = "elevenLabsAPIKey";
    String DEFAULT_ELEVEN_LABS_VOICE = "defaultElevenLabsVoice";

    // Request Focus
    String DEFAULT_FORCE_FOCUS = "defaultForceFocus";

    //region Hidden
    @ConfigItem(
        keyName = ALERTS,
        name = "Alerts",
        description = "Serialized Alerts as a JSON string",
        hidden = true
    )
    default String alerts() { return "[]"; }

    @ConfigItem(
        keyName = PLUGIN_VERSION,
        name = "Plugin Version",
        description = "Last version of the plugin loaded",
        hidden = true
    )
    default String pluginVersion() { return null; }
    //endregion

    @ConfigItem(
        keyName = ENABLE_TTS,
        name = "Enable TTS",
        description = "Enables the TTS Notification Type",
        warning = "Using TTS will submit your IP address to a 3rd party website not controlled or verified by the RuneLite Developers."
    )
    default boolean ttsEnabled() { return false; }

    @ConfigItem(
        keyName = MOUSE_MOVEMENT_CANCELS_FLASH,
        name = "Mouse Movement Cancels",
        description = "Cancel the repeated sounds/flashes with mouse movement as well as click and keyboard"
    )
    default boolean mouseMovementCancels() { return true; }

    @ConfigItem(
        keyName = OVERRIDE_IMPORTS_WITH_DEFAULTS,
        name = "Override Imports with Defaults",
        description = "Will override imported alerts with your defaults set here"
    )
    default boolean overrideImportsWithDefaults() { return false; }

    @ConfigItem(
        keyName = PUT_SOUNDS_INTO_QUEUE,
        name = "Put Sounds Into Queue",
        description = "When this is on, all sounds will be queued up so that they will not overlap"
    )
    default boolean putSoundsIntoQueue() { return true; }

    @ConfigItem(
        keyName = SIDE_PANEL_PRIORITY,
        name = "Side Panel Priority",
        description = "Panel icon priority, Lower # = higher pos, Higher # = lower pos "
    )
    @Range(min = Integer.MIN_VALUE)
    default int sidePanelPriority() { return 1; }

    @ConfigItem(
        keyName = ENABLE_NOTIFICATION_CATEGORIES,
        name = "Enable Notification Categories",
        description = "Enables the notification categories in the side panel"
    )
    default boolean enableNotificationCategories() { return true; }

    //region AFK Notification
    @ConfigSection(
        name = "AFK Notification",
        description = "The options that control the afk notification settings",
        position = 0
    )
    String afkNotificationSection = "afkNotificationSection";

    @ConfigItem(
        keyName = DEFAULT_AFK_MODE,
        name = "Default AFK Mode",
        description = "The default AFK mode on/off",
        section = afkNotificationSection
    )
    default boolean defaultAFKMode() { return false; }

    @ConfigItem(
        keyName = DEFAULT_AFK_SECONDS,
        name = "Default AFK Seconds",
        description = "The default AFK seconds value",
        section = afkNotificationSection
    )
    @Units(Units.SECONDS)
    @Range(min = 1)
    default int defaultAFKSeconds() { return 5; }
    //endregion

    //region Overhead
    @ConfigSection(
        name = "Overhead",
        description = "The options that control the overhead notifications",
        position = 1,
        closedByDefault = true
    )
    String overheadSection = "overheadSection";

    @ConfigItem(
        keyName = DEFAULT_OVERHEAD_DISPLAY_TIME,
        name = "Default Display Time",
        description = "The default display time",
        section = overheadSection
    )
    @Units(Units.SECONDS)
    default int defaultOverHeadDisplayTime() { return 3; };
    //endregion

    //region Overlay
    @ConfigSection(
        name = "Overlay",
        description = "The options that control the overlay notifications",
        position = 2,
        closedByDefault = true
    )
    String overlaySection = "overlaySection";

    @ConfigItem(
        keyName = OVERLAY_LAYER,
        name = "Overlay Layer",
        description = "Which layer the overlay renders on. ABOVE_WIDGETS is default",
        section = overlaySection,
        position = 0
    )
    default OverlayLayer overlayLayer() { return OverlayLayer.ABOVE_WIDGETS; }

    @ConfigItem(
        keyName = OVERLAY_FONT_TYPE,
        name = "Overlay Font Type",
        description = "Configures which font type is used for the overlay notifications",
        section = overlaySection,
        position = 1
    )
    default FontType overlayFontType() { return FontType.BOLD; }

    @ConfigItem(
        keyName = OVERLAY_SHOW_TIME,
        name = "Overlay Show Time",
        description = "Shows how long ago the notification was fired on the overlay",
        section = overlaySection,
        position = 2
    )
    default boolean overlayShowTime() { return true; }

    @ConfigItem(
        keyName = DEFAULT_OVERLAY_STICKY,
        name = "Default Sticky",
        description = "The default sticky",
        section = overlaySection,
        position = 3
    )
    default boolean defaultOverlaySticky() { return false; }

    @ConfigItem(
        keyName = DEFAULT_OVERLAY_TTL,
        name = "Default Display Time",
        description = "The default time to display",
        section = overlaySection,
        position = 4
    )
    @Units(Units.SECONDS)
    default int defaultOverlayTTL() { return 5; }

    @ConfigItem(
        keyName = DEFAULT_OVERLAY_TEXT_COLOR,
        name = "Default Text Color",
        description = "The default text color",
        section = overlaySection,
        position = 5
    )
    default Color defaultOverlayTextColor() { return DEFAULT_NOTIFICATION_TEXT_COLOR; }

    @ConfigItem(
        keyName = DEFAULT_OVERLAY_COLOR,
        name = "Default Background Color",
        description = "The default background color",
        section = overlaySection,
        position = 6
    )
    @Alpha
    default Color defaultOverlayColor() { return DEFAULT_NOTIFICATION_COLOR; }

    @ConfigItem(
        keyName = DEFAULT_OVERLAY_IMAGE_PATH,
        name = "Default Image Path",
        description = "The default image path",
        section = overlaySection,
        position = 7
    )
    default String defaultOverlayImagePath() { return ""; }
    //endregion

    //region Popup
    @ConfigSection(
        name = "Popup",
        description = "The options that control the popup notifications",
        position = 3,
        closedByDefault = true
    )
    String popupSection = "popupSection";

    @ConfigItem(
        keyName = DEFAULT_POPUP_TEXT_COLOR,
        name = "Default Text Color",
        description = "The default text color",
        section = popupSection,
        position = 1
    )
    default Color defaultPopupTextColor() { return null; }
    //endregion

    //region Screen Flash
    @ConfigSection(
        name = "Screen Flash",
        description = "The options that control the screen flash notifications",
        position = 4,
        closedByDefault = true
    )
    String screenFlashSection = "screenFlashSection";

    @ConfigItem(
        keyName = DEFAULT_SCREEN_FLASH_COLOR,
        name = "Default Color",
        description = "The default color",
        section = screenFlashSection,
        position = 1
    )
    @Alpha
    default Color defaultScreenFlashColor() { return DEFAULT_NOTIFICATION_COLOR; }

    @ConfigItem(
        keyName = DEFAULT_SCREEN_FLASH_TYPE,
        name = "Default Flash Type",
        description = "The default flash type",
        section = screenFlashSection,
        position = 2
    )
    default FlashNotification defaultScreenFlashType() { return FlashNotification.SOLID_TWO_SECONDS; }

    @ConfigItem(
        keyName = DEFAULT_SCREEN_FLASH_MODE,
        name = "Default Flash Mode",
        description = "The default flash mode",
        section = screenFlashSection,
        position = 3
    )
    default FlashMode defaultScreenFlashMode() { return FlashMode.FLASH; }

    @ConfigItem(
        keyName = DEFAULT_SCREEN_FLASH_DURATION,
        name = "Default Flash Duration",
        description = "The default flash duration in seconds",
        section = screenFlashSection,
        position = 3
    )
    @Units(Units.SECONDS)
    default int defaultScreenFlashDuration() { return 2; }
    //endregion

    //region Sound
    @ConfigSection(
        name = "Custom Sound",
        description = "The options that control the custom sound notifications",
        position = 5,
        closedByDefault = true
    )
    String soundSection = "soundSection";

    @ConfigItem(
        keyName = DEFAULT_SOUND_VOLUME,
        name = "Default Volume",
        description = "The default volume",
        section = soundSection
    )
    @Range(min = 0, max = 10)
    default int defaultSoundVolume() { return 8; }

    @ConfigItem(
        keyName = DEFAULT_SOUND_PATH,
        name = "Default Path",
        description = "The default path",
        section = soundSection
    )
    default String defaultSoundPath() { return null; }
    //endregion

    //region Sound Effect
    @ConfigSection(
        name = "Sound Effect",
        description = "The options that control the custom sound notifications",
        position = 6,
        closedByDefault = true
    )
    String soundEffectSection = "soundEffectSection";

    @ConfigItem(
        keyName = DEFAULT_SOUND_EFFECT_ID,
        name = "Default Sound Effect",
        description = "The default sound effect ID",
        section = soundEffectSection
    )
    default int defaultSoundEffectID() { return SoundEffectID.GE_ADD_OFFER_DINGALING; }

    @ConfigItem(
        keyName = DEFAULT_SOUND_EFFECT_VOLUME,
        name = "Default Volume",
        description = "The default volume",
        section = soundEffectSection
    )
    @Range(min = 0, max = 10)
    default int defaultSoundEffectVolume() { return 8; }
    //endregion

    //region TTS
    @ConfigSection(
        name = "Text to Speech",
        description = "The options that control the text to speech notifications",
        position = 7,
        closedByDefault = true
    )
    String ttsSection = "ttsSection";

    @ConfigItem(
        keyName = DEFAULT_TTS_VOLUME,
        name = "Default Volume",
        description = "The default volume",
        section = ttsSection
    )
    @Range(min = 0, max = 10)
    default int defaultTTSVolume() { return 5; }

    @ConfigItem(
        keyName = DEFAULT_TTS_SOURCE,
        name = "Default Source",
        description = "The default source (Eleven Labs needs your own API Key)",
        section = ttsSection
    )
    default TTSSource defaultTTSSource() { return TTSSource.LEGACY; }

    @ConfigItem(
        keyName = DEFAULT_TTS_VOICE,
        name = "Default Legacy Voice",
        description = "The default legacy voice",
        section = ttsSection
    )
    default Voice defaultTTSVoice() { return Voice.GEORGE; }

    @ConfigItem(
        keyName = DEFAULT_TTS_RATE,
        name = "Default Rate",
        description = "The default rate",
        section = ttsSection
    )
    @Range(min = 1, max = 5)
    default int defaultTTSRate() { return 1; }

    @ConfigItem(
        keyName = ELEVEN_LABS_API_KEY,
        name = "Eleven Labs API Key",
        description = "Enter your API key",
        section = ttsSection
    )
    default String elevenLabsAPIKey() { return ""; }

    @ConfigItem(
        keyName = DEFAULT_ELEVEN_LABS_VOICE,
        name = "Default Eleven Labs Voice",
        description = "Matches on the name of the voice exactly",
        section = ttsSection
    )
    default String defaultElevenLabsVoice() { return null; }
    //endregion

    //region Request Focus
    @ConfigSection(
        name = "Request Focus",
        description = "The options that control the request focus notifications",
        position = 8,
        closedByDefault = true
    )
    String requestFocusSection = "requestFocusSection";

    @ConfigItem(
        keyName = DEFAULT_FORCE_FOCUS,
        name = "Force Focus",
        description = "Sets the default focus mode to force",
        section = requestFocusSection
    )
    default boolean defaultRequestFocusForce() { return false; }
    //endregion
}

package com.adamk33n3r.runelite.watchdog;

import lombok.Getter;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

public class WatchdogProperties {
    @Getter()
    private static final Properties properties = new Properties();

    static {
        try (InputStream in = WatchdogProperties.class.getResourceAsStream("watchdog.properties")) {
            properties.load(in);
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }

        try (InputStream in = WatchdogProperties.class.getResourceAsStream("version.properties")) {
            properties.load(in);
            String pluginVersion = String.format(
                "%s.%s.%s",
                properties.getProperty("VERSION_MAJOR"),
                properties.getProperty("VERSION_MINOR"),
                properties.getProperty("VERSION_PATCH"));
            properties.put("watchdog.pluginVersion", pluginVersion);
            String phase = properties.getProperty("VERSION_PHASE");
            String pluginVersionFull = String.format("%s-%s", pluginVersion, phase);
            properties.put("watchdog.pluginVersionFull", pluginVersionFull);
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.api.GameObject;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.util.Text;

import com.google.common.base.Splitter;

import javax.swing.*;
import java.awt.Color;
import java.text.Normalizer;
import java.util.List;
import java.util.stream.Collectors;

public class Util {
    public static <T> T defaultArg(T thing, T defaultValue) {
        if (thing instanceof String) {
            String string = (String) thing;
            return string.isEmpty() ? defaultValue : thing;
        }
        return thing != null ? thing : defaultValue;
    }

    // https://stackoverflow.com/a/17369948
    public static String createRegexFromGlob(String pattern) {
        StringBuilder sb = new StringBuilder(pattern.length());
        int inGroup = 0;
        int inClass = 0;
        int firstIndexInClass = -1;
        char[] arr = pattern.toCharArray();
        for (int i = 0; i < arr.length; i++) {
            char ch = arr[i];
            switch (ch) {
                case '\\':
                    if (++i >= arr.length) {
                        sb.append('\\');
                    } else {
                        char next = arr[i];
                        switch (next) {
                            case ',':
                                // escape not needed
                                break;
                            case 'Q':
                            case 'E':
                                // extra escape needed
                                sb.append('\\');
                            default:
                                sb.append('\\');
                        }
                        sb.append(next);
                    }
                    break;
                case '*':
                    if (inClass == 0)
                        sb.append(".*");
                    else
                        sb.append('*');
                    break;
                case '?':
                    if (inClass == 0)
                        sb.append('.');
                    else
                        sb.append('?');
                    break;
                case '[':
                    inClass++;
                    firstIndexInClass = i+1;
                    sb.append('[');
                    break;
                case ']':
                    inClass--;
                    sb.append(']');
                    break;
                case '.':
                case '(':
                case ')':
                case '+':
                case '|':
                case '^':
                case '$':
                case '@':
                case '%':
                    if (inClass == 0 || (firstIndexInClass == i && ch == '^'))
                        sb.append('\\');
                    sb.append(ch);
                    break;
                case '!':
                    if (firstIndexInClass == i)
                        sb.append('^');
                    else
                        sb.append('!');
                    break;
                case '{':
                    inGroup++;
                    sb.append('(');
                    break;
                case '}':
                    inGroup--;
                    sb.append(')');
                    break;
                case ',':
                    if (inGroup > 0)
                        sb.append('|');
                    else
                        sb.append(',');
                    break;
                default:
                    sb.append(ch);
            }
        }
        return sb.toString();
    }

    public static String splitCamelCase(String s) {
        return s.replaceAll(
            String.format("%s|%s|%s",
                "(?<=[A-Z])(?=[A-Z][a-z])",
                "(?<=[^A-Z])(?=[A-Z])",
                "(?<=[A-Za-z])(?=[^A-Za-z])"
            ),
            " "
        );
    }

    public static String humanReadableClass(Object obj) {
        return splitCamelCase(obj.getClass().getSimpleName());
    }

    public static String processTriggerValues(String string, String[] triggerValues) {
        if (string == null) {
            return null;
        }

        for (int i = 0; i < triggerValues.length; i++) {
            string = string.replaceAll("\\$"+(i+1), triggerValues[i]);
        }

        return string;
    }

    /**
     * Scale a number from one range to another
     * @param val the number to scale
     * @param srcMin min source range
     * @param srcMax max source range
     * @param destMin min dest range
     * @param destMax max dest range
     * @return the scaled number
     */
    public static int scale(int val, float srcMin, float srcMax, float destMin, float destMax) {
        return Math.round(((val - srcMin) / (srcMax - srcMin)) * (destMax - destMin) + destMin);
    }

    private static final Splitter SPLITTER = Splitter.on(" ").trimResults().omitEmptyStrings();
    public static boolean searchText(String search, List<String> keywords) {
        String normalizedSearch = Normalizer.normalize(search, Normalizer.Form.NFD).replaceAll("\\p{InCombiningDiacriticalMarks}+", "").toLowerCase();
        return Text.matchesSearchTerms(
            SPLITTER.split(normalizedSearch),
            keywords.stream().map(term -> Normalizer.normalize(term, Normalizer.Form.NFD).replaceAll("\\p{InCombiningDiacriticalMarks}+", "").toLowerCase()).collect(Collectors.toList()));
    }

    public static Color colorAlpha(Color color, int alpha) {
        if (alpha < 0 || alpha > 255) {
            throw new IllegalArgumentException("alpha must be >= 0 and <= 255");
        }

        return new Color((alpha << 24) | (color.getRGB() & 0xFFFFFF), true);
    }

    public static WorldPoint getClosestTile(WorldPoint playerLocation, GameObject gameObject) {
        int sizeX = gameObject.sizeX();
        int sizeY = gameObject.sizeY();
        WorldPoint worldLocation = gameObject.getWorldLocation();

        // given that the object is larger than 1 tile, the location is the center most tile, rounded to the south-west,
        // calculate the rectangle of all the tiles the object is in
        WorldPoint southWest = new WorldPoint(worldLocation.getX() - (sizeX - 1) / 2, worldLocation.getY() - (sizeY - 1) / 2, worldLocation.getPlane());
        WorldPoint northEast = new WorldPoint(worldLocation.getX() + sizeX / 2, worldLocation.getY() + sizeY / 2, worldLocation.getPlane());

        // calculate the closest tile on the edge of the rect made from southWest to northEast
        return new WorldPoint(
            Math.min(Math.max(playerLocation.getX(), southWest.getX()), northEast.getX()),
            Math.min(Math.max(playerLocation.getY(), southWest.getY()), northEast.getY()),
            worldLocation.getPlane()
        );
    }

    public static void syncAlwaysOnTop(JDialog dialog) {
        RuneLiteConfig runeLiteConfig = WatchdogPlugin.getInstance().getInjector().getInstance(RuneLiteConfig.class);
        if (runeLiteConfig.gameAlwaysOnTop() && dialog.isAlwaysOnTopSupported()) {
            dialog.setAlwaysOnTop(true);
        }
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.Displayable;
import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter
@Setter
@Accessors(chain = true)
public class SpawnedAlert extends Alert implements RegexMatcher {
    private SpawnedDespawned spawnedDespawned = SpawnedDespawned.SPAWNED;
    private SpawnedType spawnedType = SpawnedType.ITEM;
    private String spawnedName = "";
    private boolean regexEnabled = false;
    private int distance = -1;
    private ComparableNumber.Comparator distanceComparator = ComparableNumber.Comparator.LESS_THAN_OR_EQUALS;

    @Override
    public String getPattern() {
        return this.spawnedName;
    }

    @Override
    public void setPattern(String pattern) {
        this.spawnedName = pattern;
    }

    public SpawnedAlert() {
        super("New Spawned Alert");
    }

    public SpawnedAlert(String name) {
        super(name);
        // some drops
        // enemies spawn
        // trees/ore comes back
    }

    @Getter
    @AllArgsConstructor
    public enum SpawnedDespawned implements Displayable {
        SPAWNED("Spawned", "Object has spawned"),
        DESPAWNED("Despawned", "Object has despawned"),
        ;

        public final String name;
        public final String tooltip;
    }

    @Getter
    @AllArgsConstructor
    public enum SpawnedType implements Displayable {
        DECORATIVE_OBJECT("Decorative Object", "Decorative Object"),
        GAME_OBJECT("Game Object", "Something interactable, like a Tree"),
        GROUND_OBJECT("Ground Object", "Ground Object"),
        ITEM("Item", "Bones on the ground"),
        NPC("NPC", "An NPC, like the Wise Old Man"),
        PLAYER("Player", "Another player"),
        WALL_OBJECT("Wall Object", "Wall Object"),
        ;

        public final String name;
        public final String tooltip;
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.Displayable;
import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter
@Setter
@Accessors(chain = true)
public class InventoryAlert extends Alert implements RegexMatcher {
    private InventoryAlertType inventoryAlertType = InventoryAlertType.FULL;
    private String itemName = "";
    private boolean isRegexEnabled = false;
    private int itemQuantity = 1;
    private ComparableNumber.Comparator quantityComparator = ComparableNumber.Comparator.GREATER_THAN_OR_EQUALS;

    @Override
    public String getPattern() {
        return this.itemName;
    }

    @Override
    public void setPattern(String pattern) {
        this.itemName = pattern;
    }

    public InventoryAlert() {
        super("New Inventory Alert");
    }

    public InventoryAlert(String name) {
        super(name);
    }

    @Getter
    @AllArgsConstructor
    public enum InventoryAlertType implements Displayable {
        EMPTY("Empty", "Triggers on an empty inventory"),
        FULL("Full", "Triggers on a full inventory"),
        ITEM("Item Count", "Triggers when an item hits a certain count"),
        ITEM_CHANGE("Item Change", "Triggers when an item is added or removed")
        ;

        private final String name;
        private final String tooltip;
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import net.runelite.api.Skill;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Deprecated
public class StatDrainAlert extends Alert {
    private Skill skill = Skill.ATTACK;
    private int drainAmount = 1;

    public StatDrainAlert() {
        super("New Stat Drained Alert");
    }

    public StatDrainAlert(String name) {
        super(name);
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.PlayerChatType;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter
@Setter
@Accessors(chain = true)
public class PlayerChatAlert extends Alert implements RegexMatcher {
    private String message = "";
    private boolean regexEnabled = false;
    private PlayerChatType playerChatType = PlayerChatType.ANY;

    @Override
    public String getPattern() {
        return this.message;
    }

    @Override
    public void setPattern(String pattern) {
        this.message = pattern;
    }

    public PlayerChatAlert() {
        super("New Player Chat Message Alert");
    }

    public PlayerChatAlert(String name) {
        super(name);
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum FlashMode {
    FLASH("Flash", "Will flash the screen over an interval"),
    SMOOTH_FLASH("Smooth Flash", "Flashes the screen over an interval smoothly"),
    SOLID("Solid", "Will be a solid overlay on the screen")
    ;

    private final String name;
    private final String tooltip;

    @Override
    public String toString() {
        return this.name;
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SoundFiredAlert extends Alert {
    private int soundID = 2739;

    public SoundFiredAlert() {
        super("New Sound Fired Alert");
    }
}
package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.Displayable;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum StatChangedMode implements Displayable {
    RELATIVE("Relative", "Relative to the player's current level. Negative values will be treated as a drain, positive values as a boost"),
    ABSOLUTE("Absolute", "Absolute level"),
    ;

    private final String name;
    private final String tooltip;
}

package com.adamk33n3r.runelite.watchdog.alerts;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;

import javax.inject.Inject;

@Getter
@Setter
public class LocationAlert extends Alert {
    private WorldPoint worldPoint = new WorldPoint(3223, 3219, 0);
    private int distance;
    private boolean repeat = false;
    private boolean cardinalOnly = false;
//    private boolean showTileMarker;

    @Inject
    private transient Client client;

    public LocationAlert() {
        super("New Location Alert");
    }
    public LocationAlert(String name) {
        super(name);
    }

    public boolean shouldFire(WorldPoint currentPoint) {
        if (this.worldPoint == null) {
            return false;
        }
        if (this.cardinalOnly && !this.isCardinal(currentPoint)) {
            return false;
        }
        return this.worldPoint.distanceTo(currentPoint) <= this.distance;
    }

    private boolean isCardinal(WorldPoint otherPoint) {
        return this.worldPoint.getX() == otherPoint.getX() || this.worldPoint.getY() == otherPoint.getY();
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.GameMessageType;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter
@Setter
@Accessors(chain = true)
public class ChatAlert extends Alert implements RegexMatcher {
    private String message = "";
    private boolean regexEnabled = false;
    private GameMessageType gameMessageType = GameMessageType.ANY;

    @Override
    public String getPattern() {
        return this.message;
    }

    @Override
    public void setPattern(String pattern) {
        this.message = pattern;
    }

    public ChatAlert() {
        super("New Game Message Alert");
    }

    public ChatAlert(String name) {
        super(name);
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

public interface RegexMatcher {
    boolean isRegexEnabled();
    Alert setRegexEnabled(boolean regexEnabled);
    String getPattern();
    void setPattern(String pattern);
}

package com.adamk33n3r.runelite.watchdog.alerts;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@Accessors(chain = true)
public class AlertGroup extends Alert {
    private List<Alert> alerts = new ArrayList<>();

    public AlertGroup() {
        this("New Alert Group");
    }

    public AlertGroup(String name) {
        super(name);
        // So that we don't serialize the empty array
        this.setNotifications(null);
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import net.runelite.api.Skill;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class StatChangedAlert extends Alert {
    private Skill skill = Skill.HITPOINTS;
    private int changedAmount = -5;
    private ComparableNumber.Comparator changedComparator = ComparableNumber.Comparator.LESS_THAN_OR_EQUALS;
    private StatChangedMode changedMode = StatChangedMode.RELATIVE;

    public StatChangedAlert() {
        super("New Stat Changed Alert");
    }

    public StatChangedAlert(String name) {
        super(name);
    }

    public boolean isRelative() {
        return this.changedMode == StatChangedMode.RELATIVE;
    }

    public boolean isAbsolute() {
        return this.changedMode == StatChangedMode.ABSOLUTE;
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import net.runelite.api.Skill;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class XPDropAlert extends Alert {
    private Skill skill = Skill.ATTACK;
    private int gainedAmount = 1;
    private ComparableNumber.Comparator gainedComparator = ComparableNumber.Comparator.GREATER_THAN_OR_EQUALS;

    public XPDropAlert() {
        super("New XP Drop Alert");
    }

    public XPDropAlert(String name) {
        super(name);
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.TriggerType;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.notifications.MessageNotification;
import com.adamk33n3r.runelite.watchdog.notifications.Notification;

import lombok.*;
import lombok.experimental.Accessors;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Getter
@Setter
@Accessors(chain = true)
public abstract class Alert {
    private boolean enabled = true;
    private String name;
    private int debounceTime;
    private boolean randomNotifications = false;

    @Nullable
    private transient AlertGroup parent;
    public AlertGroup getParent() {
        if (this.parent == null) {
            this.parent = WatchdogPlugin.getInstance()
                .getAlertManager()
                .getAllAlertGroups()
                .filter(alertGroup -> alertGroup.getAlerts().contains(this))
                .findFirst()
                .orElse(null);
        }

        return this.parent;
    }

    @Setter(AccessLevel.PROTECTED)
    private List<Notification> notifications = new ArrayList<>();

    public Alert addNotification(Notification notification) {
        this.notifications.add(notification);
        return this;
    }

    public Alert addNotifications(Notification... notifications) {
        this.notifications.addAll(Arrays.asList(notifications));
        return this;
    }

    public Alert(String name) {
        this.name = name;
        this.debounceTime = 0;
    }

    public TriggerType getType() {
        return Arrays.stream(TriggerType.values())
            .filter(tType -> tType.getImplClass() == this.getClass())
            .findFirst()
            .orElse(null);
    }

    public void moveNotificationTo(Notification notification, int pos) {
        this.notifications.remove(notification);
        this.notifications.add(pos, notification);
    }

    public void moveNotificationToTop(Notification notification) {
        this.notifications.remove(notification);
        this.notifications.add(0, notification);
    }

    public void moveNotificationToBottom(Notification notification) {
        this.notifications.remove(notification);
        this.notifications.add(notification);
    }

    public void moveNotificationUp(Notification notification) {
        int curIdx = this.notifications.indexOf(notification);
        int newIdx = curIdx - 1;

        if (newIdx < 0) {
            return;
        }

        this.notifications.remove(notification);
        this.notifications.add(newIdx, notification);
    }

    public void moveNotificationDown(Notification notification) {
        int curIdx = this.notifications.indexOf(notification);
        int newIdx = curIdx + 1;

        if (newIdx >= this.notifications.size()) {
            return;
        }

        this.notifications.remove(notification);
        this.notifications.add(newIdx, notification);
    }

    @Nullable
    public List<AlertGroup> getAncestors() {
        if (this.getParent() == null) {
            return null;
        }

        ArrayList<AlertGroup> ancestors = new ArrayList<>();
        AlertGroup alertGroup = this.getParent();
        do {
            ancestors.add(0, alertGroup);
        } while ((alertGroup = alertGroup.getParent()) != null);

        return ancestors;
    }

    public List<String> getKeywords() {
        Stream<String> selfKeywords = Stream.of(
            this.getName(),
            this.getType().getName()
        );

        if (this instanceof AlertGroup) {
            return Stream.concat(selfKeywords, ((AlertGroup) this).getAlerts().stream().flatMap(alert -> alert.getKeywords().stream()))
                .collect(Collectors.toList());
        } else {
            return Stream.concat(
                selfKeywords,
                this.getNotifications().stream()
                    .flatMap(notification -> {
                        if (notification instanceof MessageNotification) {
                            return Stream.of(notification.getType().getName(), ((MessageNotification) notification).getMessage());
                        }
                        return Stream.of(notification.getType().getName());
                    }))
                .collect(Collectors.toList());
        }
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter
@Setter
@Accessors(chain = true)
public class NotificationFiredAlert extends Alert implements RegexMatcher {
    private String message = "";
    private boolean regexEnabled = false;

    @Override
    public String getPattern() {
        return this.message;
    }

    @Override
    public void setPattern(String pattern) {
        this.message = pattern;
    }

    public NotificationFiredAlert() {
        super("New Notification Fired Alert");
    }

    public NotificationFiredAlert(String name) {
        super(name);
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.FlashMode;
import com.adamk33n3r.runelite.watchdog.notifications.ScreenFlash;

import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.time.Instant;

@Slf4j
public class FlashOverlay extends Overlay {
    @Inject
    private Client client;

    @Inject
    private ClientUI clientUI;

    @Inject
    private WatchdogConfig config;

    private Instant flashStart;
    private int gameCycleStart;
    private long mouseLastPressedMillis;

    private ScreenFlash screenFlash;

    private static final int MIN_MILLISECONDS_BEFORE_CANCELLED = 2000;

    public FlashOverlay() {
        this.setPosition(OverlayPosition.DYNAMIC);
        this.setLayer(OverlayLayer.ALWAYS_ON_TOP);
    }

    public void flash(ScreenFlash screenFlash) {
        this.screenFlash = screenFlash;
        this.flashStart = Instant.now();
        this.gameCycleStart = this.client.getGameCycle();
        this.mouseLastPressedMillis = client.getMouseLastPressedMillis();
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        // Adapted from Notifier
        if (this.flashStart == null) {
            return null;
        }

        if (this.screenFlash.getFlashDuration() == 0) {
            // Any interaction with the client since the notification started will cancel it after the minimum duration
            if (Instant.now().minusMillis(MIN_MILLISECONDS_BEFORE_CANCELLED).isAfter(this.flashStart)
                && ((client.getMouseIdleTicks() < MIN_MILLISECONDS_BEFORE_CANCELLED / Constants.CLIENT_TICK_LENGTH && this.config.mouseMovementCancels())
                || client.getKeyboardIdleTicks() < MIN_MILLISECONDS_BEFORE_CANCELLED / Constants.CLIENT_TICK_LENGTH
                || client.getMouseLastPressedMillis() > mouseLastPressedMillis) && clientUI.isFocused()
            ) {
                flashStart = null;
                return null;
            }
        } else if (Instant.now().minusSeconds(this.screenFlash.getFlashDuration()).isAfter(this.flashStart)) {
            flashStart = null;
            return null;
        }

        // Me: This can be weird depending on which game cycle the flash is fired
        if ((this.client.getGameCycle() - this.gameCycleStart) % 40 >= 20
            // For solid colour, fall through every time.
            && this.screenFlash.getFlashMode() == FlashMode.FLASH)
        {
            return null;
        }
        Color color = this.screenFlash.getColor();
        if (this.screenFlash.getFlashMode() == FlashMode.SMOOTH_FLASH) {
            color = Util.colorAlpha(color, this.getAlpha(color.getAlpha()));
        }
        graphics.setColor(color);
        graphics.fill(new Rectangle(this.client.getCanvas().getSize()));
        return null;
    }

    private int getAlpha(int maxAlpha) {
        int scaledAlpha = Util.scale((this.client.getGameCycle() - this.gameCycleStart) % 40, 0, 40, 0, maxAlpha*2);
        return scaledAlpha <= maxAlpha ? scaledAlpha : maxAlpha*2 - scaledAlpha;
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;


@RequiredArgsConstructor
@Setter
public class CenteredImageComponent implements LayoutableRenderableEntity {

    private final BufferedImage image;

    @Getter
    private final Rectangle bounds = new Rectangle();

    private Point preferredLocation = new Point();
    private Dimension preferredSize = new Dimension();

    @Override
    public Dimension render(Graphics2D graphics) {
        if (image == null) {
            return null;
        }

        graphics.drawImage(image, preferredLocation.x + preferredSize.width / 2 - this.image.getWidth() / 2, preferredLocation.y, null);
        final Dimension dimension = new Dimension(image.getWidth(), image.getHeight());
        bounds.setLocation(preferredLocation);
        bounds.setSize(dimension);
        return dimension;
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.*;
import com.adamk33n3r.runelite.watchdog.alerts.InventoryAlert.InventoryAlertType;
import com.adamk33n3r.runelite.watchdog.ui.panels.HistoryPanel;

import lombok.AllArgsConstructor;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.NotificationFired;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.Text;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Provider;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import java.awt.TrayIcon;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static com.adamk33n3r.runelite.watchdog.alerts.SpawnedAlert.SpawnedDespawned.DESPAWNED;
import static com.adamk33n3r.runelite.watchdog.alerts.SpawnedAlert.SpawnedDespawned.SPAWNED;
import static com.adamk33n3r.runelite.watchdog.alerts.SpawnedAlert.SpawnedType.*;

@Slf4j
@Singleton
public class EventHandler {
    @Inject
    private Client client;

    @Inject
    private ItemManager itemManager;

    @Inject
    private AlertManager alertManager;

    @Inject
    private EventBus eventBus;

    @Inject
    private Provider<HistoryPanel> historyPanelProvider;

    @Inject
    private WatchdogPlugin plugin;

    private final Map<Alert, Instant> lastTriggered = new HashMap<>();

    private final Map<Skill, Integer> previousSkillLevelTable = new EnumMap<>(Skill.class);
    private final Map<Skill, Integer> previousSkillXPTable = new EnumMap<>(Skill.class);
    private final Map<Integer, String> itemNameCache = new ConcurrentHashMap<>();
    private Map<String, Integer> previousItemsTable = new ConcurrentHashMap<>();
    private WorldPoint previousLocation = null;

    private boolean ignoreNotificationFired = false;

    public synchronized void notify(String message) {
        this.ignoreNotificationFired = true;
        // The event bus is synchronous
        this.eventBus.post(new NotificationFired(null, message, TrayIcon.MessageType.NONE));
        this.ignoreNotificationFired = false;
    }

    //region Chat Message
    @Subscribe
    public void onChatMessage(ChatMessage chatMessage) {
        // Don't process messages sent by this plugin
        if (chatMessage.getName().equals(this.plugin.getName())) {
            return;
        }

        log.debug("{}: {}", chatMessage.getType().name(), chatMessage.getMessage());
        String unformattedMessage = Text.removeFormattingTags(chatMessage.getMessage());

        // Send player messages to a different handler
        if (PlayerChatType.ANY.isOfType(chatMessage.getType())) {
            this.alertManager.getAllEnabledAlertsOfType(PlayerChatAlert.class)
                .filter(chatAlert -> chatAlert.getPlayerChatType() == PlayerChatType.ANY || chatAlert.getPlayerChatType().isOfType(chatMessage.getType()))
                .forEach(chatAlert -> {
                    String[] groups = this.matchPattern(chatAlert, unformattedMessage);
                    if (groups == null) return;

                    this.fireAlert(chatAlert, groups);
                });
            return;
        }

        this.alertManager.getAllEnabledAlertsOfType(ChatAlert.class)
            .filter(chatAlert -> chatAlert.getGameMessageType() == GameMessageType.ANY || chatAlert.getGameMessageType().isOfType(chatMessage.getType()))
            .forEach(gameAlert -> {
                String[] groups = this.matchPattern(gameAlert, unformattedMessage);
                if (groups == null) return;

                this.fireAlert(gameAlert, groups);
            });
    }
    //endregion

    //region Notification
    @Subscribe
    public void onNotificationFired(NotificationFired notificationFired) {
        // This flag is set when we are firing our own events, so we don't cause an infinite loop/stack overflow
        if (this.ignoreNotificationFired) {
            return;
        }

        this.alertManager.getAllEnabledAlertsOfType(NotificationFiredAlert.class)
            .forEach(notificationFiredAlert -> {
                String[] groups = this.matchPattern(notificationFiredAlert, notificationFired.getMessage());
                if (groups == null) return;

                this.fireAlert(notificationFiredAlert, groups);
            });
    }
    //endregion

    //region Stat Changed
    @Subscribe
    private void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN) {
            this.previousSkillLevelTable.clear();
            this.previousSkillXPTable.clear();
            this.previousItemsTable.clear();
        }
    }

    @Subscribe
    public void onStatChanged(StatChanged statChanged) {
//        log.debug(String.format("%s: %s/%s", statChanged.getSkill().getName(), statChanged.getBoostedLevel(), statChanged.getLevel()));
        this.handleStatChanged(statChanged);
        this.handleXPDrop(statChanged);
    }

    private void handleStatChanged(StatChanged statChanged) {
        Integer previousLevel = this.previousSkillLevelTable.put(statChanged.getSkill(), statChanged.getBoostedLevel());
        if (previousLevel == null) {
            return;
        }

        this.alertManager.getAllEnabledAlertsOfType(StatChangedAlert.class)
            .filter(alert -> {
                boolean isSkill = alert.getSkill() == statChanged.getSkill();
                if (!isSkill) {
                    return false;
                }

                int targetLevel = alert.isRelative() ? statChanged.getLevel() + alert.getChangedAmount() : alert.getChangedAmount();
                boolean currentIs = alert.getChangedComparator().compare(statChanged.getBoostedLevel(), targetLevel);
                boolean prevWasNot = alert.getChangedComparator().converse().compare(previousLevel, targetLevel);
                return currentIs && prevWasNot;
            })
            .forEach(alert -> this.fireAlert(alert, statChanged.getSkill().getName()));
    }

    private void handleXPDrop(StatChanged statChanged) {
        Integer previousXP = this.previousSkillXPTable.put(statChanged.getSkill(), statChanged.getXp());
        if (previousXP == null) {
            return;
        }

        this.alertManager.getAllEnabledAlertsOfType(XPDropAlert.class)
            .filter(alert -> {
                boolean isSkill = alert.getSkill() == statChanged.getSkill();
                int gainedXP = statChanged.getXp() - previousXP;
                return isSkill && alert.getGainedComparator().compare(gainedXP, alert.getGainedAmount());
            })
            .forEach(alert -> this.fireAlert(alert, statChanged.getSkill().getName()));
    }
    //endregion

    //region Sound Effects
    @Subscribe
    private void onSoundEffectPlayed(SoundEffectPlayed soundEffectPlayed) {
        this.handleSoundEffectPlayed(soundEffectPlayed.getSoundId());
    }

    @Subscribe
    private void onAreaSoundEffectPlayed(AreaSoundEffectPlayed areaSoundEffectPlayed) {
        this.handleSoundEffectPlayed(areaSoundEffectPlayed.getSoundId());
    }

    private void handleSoundEffectPlayed(int soundID) {
        this.alertManager.getAllEnabledAlertsOfType(SoundFiredAlert.class)
            .filter(soundFiredAlert -> soundFiredAlert.getSoundID() == soundID)
            .forEach(alert -> this.fireAlert(alert, "" + soundID));
    }
    //endregion

    //region Inventory
    @Subscribe
    private void onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
        // Ignore everything but inventory
        if (itemContainerChanged.getItemContainer().getId() != InventoryID.INVENTORY.getId())
            return;
        Item[] items = itemContainerChanged.getItemContainer().getItems();
        long itemCount = Arrays.stream(items).filter(item -> item.getId() > -1).count();
        Map<String, Integer> currentItems = new HashMap<>();
        Map<String, Integer> allItems = new HashMap<>();
        Arrays.stream(items)
            .forEach(item -> {
                String itemName = this.itemNameCache.computeIfAbsent(item.getId(), id -> this.itemManager.getItemComposition(id).getName());
                currentItems.merge(itemName, item.getQuantity(), Integer::sum);
                allItems.merge(itemName, item.getQuantity(), Integer::sum);
            });
        this.previousItemsTable.keySet().forEach((item) -> allItems.putIfAbsent(item, 0));
        // Skip firing alerts if there are no previous items, since we just logged in. Even an empty inventory will have a map of -1 itemIds.
        if (!this.previousItemsTable.isEmpty()) {
            this.alertManager.getAllEnabledAlertsOfType(InventoryAlert.class)
                .forEach(inventoryAlert -> {
                    InventoryAlertType alertType = inventoryAlert.getInventoryAlertType();
                    switch (alertType) {
                        case FULL:
                            if (itemCount == 28) this.fireAlert(inventoryAlert, alertType.getName());
                            break;
                        case EMPTY:
                            if (itemCount == 0) this.fireAlert(inventoryAlert, alertType.getName());
                            break;
                        case ITEM:
                        case ITEM_CHANGE:
                            Optional<MatchedItem> matchedItems = this.getMatchedItems(inventoryAlert, allItems);
                            matchedItems.ifPresent((matched) -> {
                                int change = alertType == InventoryAlertType.ITEM ? 0 : matchedItems.get().previousQuantity;
                                if (inventoryAlert.getQuantityComparator().compare(matched.currentQuantity - change, inventoryAlert.getItemQuantity())) {
                                    this.fireAlert(inventoryAlert, matchedItems.get().groups.toArray(new String[0]));
                                }
                            });
                            break;
                    }
                });
        }
        this.previousItemsTable = currentItems;
    }

    private Optional<MatchedItem> getMatchedItems(InventoryAlert inventoryAlert, Map<String, Integer> allItems) {
        return allItems.entrySet().stream()
            .map(itemWithCount -> {
                String[] groups = this.matchPattern(inventoryAlert, itemWithCount.getKey());
                if (groups == null) return null;
                return new MatchedItem(
                    new ArrayList<>(List.of(groups)),
                    this.previousItemsTable.getOrDefault(itemWithCount.getKey(), 0),
                    itemWithCount.getValue()
                );
            })
            .filter(Objects::nonNull)
            .reduce((acc, b) -> {
                acc.groups = IntStream.range(0, Math.min(acc.groups.size(), b.groups.size()))
                    .mapToObj(i -> acc.groups.get(i) + ", " + b.groups.get(i))
                    .collect(Collectors.toList());
                acc.previousQuantity = acc.previousQuantity + b.previousQuantity;
                acc.currentQuantity = acc.currentQuantity + b.currentQuantity;
                return acc;
            });
    }
    //endregion

    //region Spawned
    @Subscribe
    private void onItemSpawned(ItemSpawned itemSpawned) {
        ItemComposition comp = this.itemManager.getItemComposition(itemSpawned.getItem().getId());
        this.onSpawned(comp.getName(), itemSpawned.getTile().getWorldLocation(), SPAWNED, ITEM);
    }
    @Subscribe
    private void onItemDespawned(ItemDespawned itemDespawned) {
        ItemComposition comp = this.itemManager.getItemComposition(itemDespawned.getItem().getId());
        this.onSpawned(comp.getName(), itemDespawned.getTile().getWorldLocation(), DESPAWNED, ITEM);
    }
    @Subscribe
    private void onNpcSpawned(NpcSpawned npcSpawned) {
        this.onActorSpawned(npcSpawned.getNpc(), NPC);
    }
    @Subscribe
    private void onNpcDespawned(NpcDespawned npcDespawned) {
        this.onActorDespawned(npcDespawned.getNpc(), NPC);
    }
    @Subscribe
    private void onPlayerSpawned(PlayerSpawned playerSpawned) {
        this.onActorSpawned(playerSpawned.getPlayer(), PLAYER);
    }
    @Subscribe
    private void onPlayerDespawned(PlayerDespawned playerDespawned) {
        this.onActorDespawned(playerDespawned.getPlayer(), PLAYER);
    }
    private void onActorSpawned(Actor actor, SpawnedAlert.SpawnedType type) {
        this.onSpawned(actor.getName(), actor.getWorldLocation(), SPAWNED, type);
    }
    private void onActorDespawned(Actor actor, SpawnedAlert.SpawnedType type) {
        this.onSpawned(actor.getName(), actor.getWorldLocation(), DESPAWNED, type);
    }

    @Subscribe
    private void onGroundObjectSpawned(GroundObjectSpawned groundObjectSpawned) {
        this.onTileObjectSpawned(groundObjectSpawned.getGroundObject(), SPAWNED, GROUND_OBJECT);
    }
    @Subscribe
    private void onGroundObjectDespawned(GroundObjectDespawned groundObjectDespawned) {
        this.onTileObjectSpawned(groundObjectDespawned.getGroundObject(), DESPAWNED, GROUND_OBJECT);
    }

    @Subscribe
    private void onDecorativeObjectSpawned(DecorativeObjectSpawned decorativeObjectSpawned) {
        this.onTileObjectSpawned(decorativeObjectSpawned.getDecorativeObject(), SPAWNED, DECORATIVE_OBJECT);
    }
    @Subscribe
    private void onDecorativeObjectDespawned(DecorativeObjectDespawned decorativeObjectDespawned) {
        this.onTileObjectSpawned(decorativeObjectDespawned.getDecorativeObject(), DESPAWNED, DECORATIVE_OBJECT);
    }

    @Subscribe
    private void onGameObjectSpawned(GameObjectSpawned gameObjectSpawned) {
        this.onTileObjectSpawned(gameObjectSpawned.getGameObject(), SPAWNED, GAME_OBJECT);
    }
    @Subscribe
    private void onGameObjectDespawned(GameObjectDespawned gameObjectDespawned) {
        this.onTileObjectSpawned(gameObjectDespawned.getGameObject(), DESPAWNED, GAME_OBJECT);
    }

    @Subscribe
    private void onWallObjectSpawned(WallObjectSpawned wallObjectSpawned) {
        this.onTileObjectSpawned(wallObjectSpawned.getWallObject(), SPAWNED, WALL_OBJECT);
    }
    @Subscribe
    private void onWallObjectDespawned(WallObjectDespawned wallObjectDespawned) {
        this.onTileObjectSpawned(wallObjectDespawned.getWallObject(), DESPAWNED, WALL_OBJECT);
    }

    private void onTileObjectSpawned(TileObject tileObject, SpawnedAlert.SpawnedDespawned mode, SpawnedAlert.SpawnedType type) {
        final ObjectComposition comp = this.client.getObjectDefinition(tileObject.getId());
        final ObjectComposition impostor = comp.getImpostorIds() != null ? comp.getImpostor() : comp;
        if (impostor == null) {
            return;
        }
        WorldPoint location = tileObject.getWorldLocation();
        if (tileObject instanceof GameObject) {
            WorldPoint playerLocation = this.client.getLocalPlayer().getWorldLocation();
            location = Util.getClosestTile(playerLocation, (GameObject) tileObject);
        }
        this.onSpawned(impostor.getName(), location, mode, type);
    }

    private void onSpawned(String name, WorldPoint location, SpawnedAlert.SpawnedDespawned mode, SpawnedAlert.SpawnedType type) {
        String unformattedName = Text.removeFormattingTags(name);
        int distanceToObject = location.distanceTo(this.client.getLocalPlayer().getWorldLocation());
        this.alertManager.getAllEnabledAlertsOfType(SpawnedAlert.class)
            .filter(spawnedAlert -> spawnedAlert.getSpawnedDespawned() == mode)
            .filter(spawnedAlert -> spawnedAlert.getSpawnedType() == type)
            .filter(spawnedAlert -> spawnedAlert.getDistance() == -1 || spawnedAlert.getDistanceComparator().compare(distanceToObject, spawnedAlert.getDistance()))
            .forEach(spawnedAlert -> {
                String[] groups = this.matchPattern(spawnedAlert, unformattedName);
                if (groups == null) return;

                this.fireAlert(spawnedAlert, groups);
            });
    }
    //endregion

    @Subscribe
    private void onGameTick(GameTick gameTick) {
        // Location alerts
        var world = this.client.getLocalPlayer().getWorldLocation();
        var worldView = this.client.getLocalPlayer().getWorldView();
        var localWorld = LocalPoint.fromWorld(worldView, world);
        // Should never be null
        if (localWorld == null) {
            return;
        }
        var worldLocation = WorldPoint.fromLocalInstance(this.client, localWorld);
//        log.debug("local: {} | world: {} | localWorld: {} | newWorld: {}", this.client.getLocalPlayer().getLocalLocation(), world, localWorld, worldLocation);
        this.alertManager.getAllEnabledAlertsOfType(LocationAlert.class)
            .filter(locationAlert -> locationAlert.shouldFire(worldLocation))
            .forEach(locationAlert -> {
                // If we're not repeating, don't fire if previous location is within the area
                if (!locationAlert.isRepeat() && locationAlert.shouldFire(this.previousLocation)) {
                    return;
                }
                this.fireAlert(locationAlert, new String[] { String.valueOf(worldLocation.getX()), String.valueOf(worldLocation.getY()) });
            });
        this.previousLocation = worldLocation;
    }

    private String[] matchPattern(RegexMatcher regexMatcher, String input) {
        String regex = regexMatcher.isRegexEnabled() ? regexMatcher.getPattern() : Util.createRegexFromGlob(regexMatcher.getPattern());
        Matcher matcher = Pattern.compile(regex, regexMatcher.isRegexEnabled() ? 0 : Pattern.CASE_INSENSITIVE).matcher(input);
        if (!matcher.matches()) return null;

        String[] groups = new String[matcher.groupCount()];
        for (int i = 0; i < matcher.groupCount(); i++) {
            groups[i] = matcher.group(i+1);
        }
        return groups;
    }

    private void fireAlert(Alert alert, String triggerValue) {
        this.fireAlert(alert, new String[] { triggerValue });
    }

    private void fireAlert(Alert alert, String[] triggerValues) {
        // Don't fire if it is disabled
        if (!alert.isEnabled()) return;

        List<AlertGroup> ancestors = alert.getAncestors();
        // Don't fire if any of the ancestors are disabled
        if (ancestors != null && !ancestors.stream().allMatch(Alert::isEnabled)) {
            return;
        }

        Alert alertToDebounceWith = ancestors == null ? alert : Stream.concat(ancestors.stream(), Stream.of(alert))
            .filter(ancestor -> ancestor.getDebounceTime() > 0)
            .max(Comparator.comparingInt(Alert::getDebounceTime))
            .orElse(alert);

        // If the alert hasn't been fired yet, or has been enough time, set the last trigger time to now and fire.
        if (!this.lastTriggered.containsKey(alertToDebounceWith) || Instant.now().compareTo(this.lastTriggered.get(alertToDebounceWith).plusMillis(alertToDebounceWith.getDebounceTime())) >= 0) {
            SwingUtilities.invokeLater(() -> {
                this.historyPanelProvider.get().addEntry(alert, triggerValues);
            });
            this.lastTriggered.put(alertToDebounceWith, Instant.now());
            new AlertProcessor(alert, triggerValues).start();
        }
    }

    @AllArgsConstructor
    private static class MatchedItem {
        List<String> groups;
        int previousQuantity;
        int currentQuantity;
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Type;

@Slf4j
public class MixedCaseEnumAdapter implements JsonDeserializer<Enum> {
    @Override
    public Enum deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException {
        try {
            if (type instanceof Class && ((Class<?>) type).isEnum()) {
                return Enum.valueOf((Class<Enum>) type, jsonElement.getAsString().toUpperCase());
            }
            return null;
        } catch (Exception e) {
            log.error("Failed to deserialize enum", e);
            return null;
        }
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.*;
import com.adamk33n3r.runelite.watchdog.elevenlabs.ElevenLabs;
import com.adamk33n3r.runelite.watchdog.hub.AlertHubCategory;
import com.adamk33n3r.runelite.watchdog.notifications.*;
import com.adamk33n3r.runelite.watchdog.notifications.tts.TTSSource;
import com.adamk33n3r.runelite.watchdog.notifications.tts.Voice;
import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.FlashNotification;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import joptsimple.internal.Strings;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import java.awt.Color;
import java.lang.reflect.Type;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Supplier;
import java.util.stream.Stream;

@Slf4j
@Singleton
public class AlertManager {
    @Inject
    private ConfigManager configManager;
    @Inject
    private Gson clientGson;
    @Getter
    private Gson gson;

    @Inject
    private WatchdogConfig watchdogConfig;

    @Getter
    private final List<Alert> alerts = new CopyOnWriteArrayList<>();

    // TODO: Kinda weird this is in here...
    @Getter
    @Inject
    private WatchdogPanel watchdogPanel;

    @Inject
    private WatchdogPlugin plugin;

    @Inject
    @Named("watchdog.pluginVersion")
    private String pluginVersion;

    public static final Type ALERT_TYPE;
    public static final Type ALERT_LIST_TYPE;

    static {
        ALERT_TYPE = new TypeToken<Alert>() {}.getType();
        ALERT_LIST_TYPE = new TypeToken<List<Alert>>() {}.getType();
    }

    @Inject
    private void init() {
        // Add new alert types here
        final RuntimeTypeAdapterFactory<Alert> alertTypeFactory = RuntimeTypeAdapterFactory.of(Alert.class)
            .ignoreSubtype("IdleAlert")
            .ignoreSubtype("ResourceAlert")
            .recognizeSubtypes()
            .registerSubtype(ChatAlert.class)
            .registerSubtype(PlayerChatAlert.class)
            .registerSubtype(NotificationFiredAlert.class)
            .registerSubtype(StatDrainAlert.class)
            .registerSubtype(StatChangedAlert.class)
            .registerSubtype(XPDropAlert.class)
            .registerSubtype(SoundFiredAlert.class)
            .registerSubtype(SpawnedAlert.class)
            .registerSubtype(InventoryAlert.class)
            .registerSubtype(AlertGroup.class)
            .registerSubtype(LocationAlert.class);
        // Add new notification types here
        final RuntimeTypeAdapterFactory<Notification> notificationTypeFactory = RuntimeTypeAdapterFactory.of(Notification.class)
            .registerSubtype(TrayNotification.class)
            .registerSubtype(TextToSpeech.class)
            .registerSubtype(Sound.class)
            .registerSubtype(SoundEffect.class)
            .registerSubtype(ScreenFlash.class)
            .registerSubtype(GameMessage.class)
            .registerSubtype(Overhead.class)
            .registerSubtype(Overlay.class)
            .registerSubtype(Popup.class)
            .registerSubtype(RequestFocus.class)
            .registerSubtype(NotificationEvent.class)
            .registerSubtype(ScreenMarker.class)
            .registerSubtype(Dink.class)
            .registerSubtype(PluginMessage.class)
            .registerSubtype(DismissOverlay.class)
            .registerSubtype(DismissScreenMarker.class);
        this.gson = this.clientGson.newBuilder()
//            .serializeNulls()
            .registerTypeAdapterFactory(alertTypeFactory)
            .registerTypeAdapterFactory(notificationTypeFactory)
            .registerTypeAdapter(AlertHubCategory.class, new MixedCaseEnumAdapter())
            .create();
    }

    public void createStarterAlertsIfEmpty() {
        if (!alerts.isEmpty()) {
            return;
        }

        AlertGroup kraken = new AlertGroup("Kraken");
        kraken.setAlerts(List.of(
            new SpawnedAlert("Kraken Dies")
                .setSpawnedDespawned(SpawnedAlert.SpawnedDespawned.DESPAWNED)
                .setSpawnedType(SpawnedAlert.SpawnedType.NPC)
                .setSpawnedName("Kraken")
                .addNotifications(
                    this.plugin.getInjector().getInstance(Overhead.class)
                        .setDisplayTime(3)
                        .setTextColor(Color.CYAN)
                        .setMessage("Sit Krak"),
                    this.plugin.getInjector().getInstance(ScreenMarker.class)
                        .setDisplayTime(8)
                        .setScreenMarkerProperties("Get Fishing Explosive Ready", Color.MAGENTA, Color.BLUE, 2),
                    this.plugin.getInjector().getInstance(RequestFocus.class)
                        .setForceFocus(true)
                ),
            new SpawnedAlert("Whirlpool Appears")
                .setSpawnedDespawned(SpawnedAlert.SpawnedDespawned.DESPAWNED)
                .setSpawnedType(SpawnedAlert.SpawnedType.NPC)
                .setSpawnedName("Whirlpool")
                .setDebounceTime(15000)
                .addNotifications(
                    this.plugin.getInjector().getInstance(ScreenFlash.class)
                        .setColor(ColorUtil.fromHex("#6D0030"))
                        .setFlashMode(FlashMode.SMOOTH_FLASH)
                        .setFlashDuration(1),
                    this.plugin.getInjector().getInstance(Overhead.class)
                        .setDisplayTime(3)
                        .setTextColor(Color.GREEN)
                        .setMessage("Throw Explosive!")
                ),
            new InventoryAlert("Fishing Explosive Used")
                .setInventoryAlertType(InventoryAlert.InventoryAlertType.ITEM_CHANGE)
                .setItemName("Fishing explosive")
                .setItemQuantity(-1)
                .setQuantityComparator(ComparableNumber.Comparator.EQUALS)
                .addNotifications(
                    this.plugin.getInjector().getInstance(Overhead.class)
                        .setDisplayTime(2)
                        .setTextColor(Color.RED)
                        .setMessage("Attack!"),
                    this.plugin.getInjector().getInstance(ScreenFlash.class)
                        .setColor(ColorUtil.fromHex("#46FF00"))
                        .setFlashMode(FlashMode.FLASH)
                        .setFlashDuration(2)
                )
        ));

        AlertGroup chatboxTTS = new AlertGroup("Chatbox TTS");
        chatboxTTS.setEnabled(false);
        chatboxTTS.setAlerts(List.of(
            new PlayerChatAlert("Clan Chat TTS")
                .setPlayerChatType(PlayerChatType.CLAN)
                .setMessage("{*}")
                .addNotification(
                    this.plugin.getInjector().getInstance(TextToSpeech.class)
                        .setGain(5).setRate(2)
                        .setLegacyVoice(Voice.GEORGE)
                        .setSource(TTSSource.LEGACY)
                        .setMessage("$1")
                ),
            new PlayerChatAlert("Friends Chat TTS")
                .setPlayerChatType(PlayerChatType.FRIENDS)
                .setMessage("{*}")
                .addNotification(
                    this.plugin.getInjector().getInstance(TextToSpeech.class)
                        .setGain(5).setRate(2)
                        .setLegacyVoice(Voice.GEORGE)
                        .setSource(TTSSource.LEGACY)
                        .setMessage("$1")
                ),
            new PlayerChatAlert("Guest Clan Chat TTS")
                .setPlayerChatType(PlayerChatType.GUEST_CLAN)
                .setMessage("{*}")
                .addNotification(
                    this.plugin.getInjector().getInstance(TextToSpeech.class)
                        .setGain(5).setRate(2)
                        .setLegacyVoice(Voice.GEORGE)
                        .setSource(TTSSource.LEGACY)
                        .setMessage("$1")
                ),
            new PlayerChatAlert("GIM Chat TTS")
                .setPlayerChatType(PlayerChatType.GIM)
                .setMessage("{*}")
                .addNotification(
                    this.plugin.getInjector().getInstance(TextToSpeech.class)
                        .setGain(5).setRate(2)
                        .setLegacyVoice(Voice.GEORGE)
                        .setSource(TTSSource.LEGACY)
                        .setMessage("$1")
                ),
            new PlayerChatAlert("Private Chat TTS")
                .setPlayerChatType(PlayerChatType.PRIVATE)
                .setMessage("{*}")
                .addNotification(
                    this.plugin.getInjector().getInstance(TextToSpeech.class)
                        .setGain(5).setRate(2)
                        .setLegacyVoice(Voice.GEORGE)
                        .setSource(TTSSource.LEGACY)
                        .setMessage("$1")
                ),
            new PlayerChatAlert("Public Chat TTS - ENABLE AT OWN RISK")
                .setPlayerChatType(PlayerChatType.PUBLIC)
                .setMessage("{*}")
                .addNotification(
                    this.plugin.getInjector().getInstance(TextToSpeech.class)
                        .setGain(5).setRate(2)
                        .setLegacyVoice(Voice.GEORGE)
                        .setSource(TTSSource.LEGACY)
                        .setMessage("$1")
                )
        ));

        ChatAlert cannonReload = new ChatAlert("Reload Cannon");
        cannonReload.setMessage("Your cannon has * cannon balls remaining!");
        cannonReload.setGameMessageType(GameMessageType.ANY);
        cannonReload.addNotifications(
            this.plugin.getInjector().getInstance(ScreenFlash.class)
                .setColor(ColorUtil.fromHex("#46FF00"))
                .setFlashMode(FlashMode.SMOOTH_FLASH)
                .setFlashDuration(2),
            this.plugin.getInjector().getInstance(TextToSpeech.class)
                .setGain(5)
                .setElevenLabsVoiceId("2EiwWnXFnvU5JabPnv8n")
                .setSource(TTSSource.ELEVEN_LABS)
                .setMessage("Reload!")
        );

        ChatAlert readyToHarvest = new ChatAlert("Ready to Harvest");
        readyToHarvest.setMessage("Your {*} is ready to harvest in {*}.");
        readyToHarvest.setDebounceTime(100);
        readyToHarvest.addNotification(
            this.plugin.getInjector().getInstance(TextToSpeech.class)
                .setGain(5).setRate(1)
                .setLegacyVoice(Voice.LUCAS)
                .setSource(TTSSource.LEGACY)
                .setMessage("Your $1 patch in $2 is ready to harvest!")
        );

        AlertGroup starterAlerts = new AlertGroup("Starter Alerts");
        starterAlerts.setAlerts(List.of(
            kraken,
            chatboxTTS,
            cannonReload,
            readyToHarvest
        )).setEnabled(false);

        this.addAlert(starterAlerts, false);
    }

    public Stream<Alert> getAllEnabledAlerts() {
        return this.getAllAlerts().filter(Alert::isEnabled);
    }

    public <T extends Alert> Stream<T> getAllEnabledAlertsOfType(Class<T> type) {
        return this.getAllEnabledAlerts()
            .filter(type::isInstance)
            .map(type::cast);
    }

    public Stream<Alert> getAllAlerts() {
        return this.getAllAlertsFrom(this.alerts.stream(), false);
    }

    public <T extends Alert> Stream<T> getAllAlertsOfType(Class<T> type) {
        return this.getAllAlerts()
            .filter(type::isInstance)
            .map(type::cast);
    }

    public Stream<AlertGroup> getAllAlertGroups() {
        return this.getAllAlertsFrom(this.alerts.stream(), true)
            .filter(AlertGroup.class::isInstance)
            .map(AlertGroup.class::cast);
    }

    public Stream<Alert> getAllAlertsFrom(Stream<Alert> alerts, boolean includeGroups) {
        return alerts.flatMap(alert -> {
            if (alert instanceof AlertGroup) {
                Stream<Alert> children = this.getAllAlertsFrom(((AlertGroup) alert).getAlerts().stream(), includeGroups);
                if (includeGroups) {
                    return Stream.concat(Stream.of(alert), children);
                }
                return children;
            }
            return Stream.of(alert);
        });
    }

    public <T extends Alert> T createAlert(Class<T> alertClass) {
        return this.plugin.getInjector().getInstance(alertClass);
    }

    public void addAlert(Alert alert, boolean overrideWithDefaults) {
        this.alerts.add(alert);
        this.setUpAlert(alert, overrideWithDefaults);
        this.saveAlerts();

        SwingUtilities.invokeLater(this.watchdogPanel::rebuild);
    }

    public void removeAlert(Alert alert) {
        this.removeAlert(alert, true);
    }

    public void removeAlert(Alert alert, boolean rebuildPanel) {
        AlertGroup parent = alert.getParent();
        if (parent != null) {
            parent.getAlerts().remove(alert);
        } else {
            this.alerts.remove(alert);
        }
        this.saveAlerts();

        if (rebuildPanel) {
            SwingUtilities.invokeLater(this.watchdogPanel::rebuild);
        }
    }

    public Alert cloneAlert(Alert alert) {
        String json = this.gson.toJson(alert, ALERT_TYPE);
        Alert clonedAlert = this.gson.fromJson(json, ALERT_TYPE);
        this.setUpAlert(clonedAlert, false);
        clonedAlert.setName(clonedAlert.getName() + " Clone");
        return clonedAlert;
    }

    public void moveAlertTo(Alert alert, int pos) {
        AlertGroup parent = alert.getParent();
        if (parent != null) {
            parent.getAlerts().remove(alert);
            parent.getAlerts().add(pos, alert);
        } else {
            this.alerts.remove(alert);
            this.alerts.add(pos, alert);
        }
        this.saveAlerts();
    }

    public void loadAlerts() {
        final String json = this.configManager.getConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.ALERTS);
        this.importAlerts(json, this.alerts, false, false, false);
        this.createStarterAlertsIfEmpty();
        this.handleUpgrades();
    }

    public boolean importAlerts(String json, List<Alert> alerts, boolean append, boolean checkRegex, boolean overrideWithDefaults) throws JsonSyntaxException {
        if (Strings.isNullOrEmpty(json)) {
            return false;
        }

        if (!append) {
            alerts.clear();
        }

        Supplier<Stream<Alert>> alertStream = this.tryImport(json);

        // Validate regex properties
        if (checkRegex && !alertStream.get().allMatch(alert -> {
            if (alert instanceof RegexMatcher) {
                RegexMatcher matcher = (RegexMatcher) alert;
                return PanelUtils.isPatternValid(this.watchdogPanel, matcher.getPattern(), matcher.isRegexEnabled());
            }

            return true;
        })) {
            return false;
        }

        alertStream.get().forEach(alerts::add);

        // Save immediately to save new properties
        this.saveAlerts();

        // Inject dependencies
        this.getAllAlertsFrom(alertStream.get(), false)
            .forEach(alert -> this.setUpAlert(alert, overrideWithDefaults));

        SwingUtilities.invokeLater(() -> {
            this.watchdogPanel.rebuild();
            SwingUtilities.invokeLater(this.watchdogPanel::scrollToBottom);
        });
        return true;
    }

    public void saveAlerts() {
        String json = this.gson.toJson(this.alerts, ALERT_LIST_TYPE);
        this.configManager.setConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.ALERTS, json);
    }

    public String toJSON() {
        return this.gson.toJson(this.alerts, ALERT_LIST_TYPE);
    }

    private Supplier<Stream<Alert>> tryImport(String json) throws JsonSyntaxException {
        // Single
        try {
            Alert importedAlert = this.gson.fromJson(json, ALERT_TYPE);
            return () -> Stream.of(importedAlert).filter(Objects::nonNull);
        } catch (JsonSyntaxException ignored) {
        }

        // Multiple
        List<Alert> importedAlerts = this.gson.fromJson(json, ALERT_LIST_TYPE);
        return () -> importedAlerts.stream().filter(Objects::nonNull);
    }

    private void setUpAlert(Alert alert, boolean overrideWithDefaults) {
        this.plugin.getInjector().injectMembers(alert);
        if (alert instanceof AlertGroup) {
            ((AlertGroup) alert).getAlerts().forEach(subAlert -> this.setUpAlert(subAlert, overrideWithDefaults));
        } else {
            if (alert.getNotifications() == null) {
                return;
            }
            for (INotification notification : alert.getNotifications()) {
                if (notification instanceof TextToSpeech) {
                    TextToSpeech tts = (TextToSpeech) notification;
                    if (tts.getSource() == TTSSource.ELEVEN_LABS && tts.getElevenLabsVoiceId() != null) {
                        ElevenLabs.getVoice(this.plugin.getHttpClient(), tts.getElevenLabsVoiceId(), tts::setElevenLabsVoice);
                    }
                }
                this.plugin.getInjector().injectMembers(notification);
                if (overrideWithDefaults) {
                    notification.setDefaults();
                }
                notification.setAlert(alert);
            }
        }
    }

    private void handleUpgrades() {
        Version currentVersion = new Version(this.pluginVersion);
        Version configVersion = new Version(this.configManager.getConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.PLUGIN_VERSION));
        log.debug("currentVersion: " + currentVersion);
        log.debug("configVersion: " + configVersion);
        if (currentVersion.compareTo(configVersion) > 0) {
            log.debug("Checking if data migration needed");
            // Changed Stat Drain to Stat Change in v2.4.0, so need to swap sign of drainAmount and move to new alert
            if (configVersion.compareTo(new Version("2.4.0")) < 0) {
                log.debug("Need to convert StatDrainAlerts to StatChangedAlerts");
                this.alerts.replaceAll(alert -> {
                    if (alert instanceof StatDrainAlert) {
                        StatDrainAlert statDrainAlert = (StatDrainAlert) alert;
                        StatChangedAlert statChangedAlert = new StatChangedAlert();
                        statChangedAlert.setName(statDrainAlert.getName());
                        statChangedAlert.setEnabled(statDrainAlert.isEnabled());
                        statChangedAlert.setDebounceTime(statDrainAlert.getDebounceTime());
                        statChangedAlert.setSkill(statDrainAlert.getSkill());
                        statChangedAlert.setChangedAmount(-statDrainAlert.getDrainAmount());
                        statChangedAlert.getNotifications().addAll(statDrainAlert.getNotifications());
                        return statChangedAlert;
                    }

                    return alert;
                });

                // Not sure why I thought it was a good idea to store the decibels in the JSON
                log.debug("Need to convert all Sound and TTS gain back to 0,10 scale.");
                this.alerts.stream()
                    .filter(alert -> !(alert instanceof AlertGroup))
                    .flatMap(alert -> alert.getNotifications().stream())
                    .filter(notification -> notification instanceof IAudioNotification)
                    .map(notification -> (IAudioNotification) notification)
                    .forEach(sound -> sound.setGain(Util.scale(sound.getGain(), -25, 5, 0, 10)));
            }

            if (configVersion.compareTo(new Version("2.8.0")) < 0) {
                log.debug("Need to convert flash notifications to new properties");
                this.alerts.stream()
                    .filter(alert -> !(alert instanceof AlertGroup))
                    .flatMap(alert -> alert.getNotifications().stream())
                    .filter(notification -> notification instanceof ScreenFlash)
                    .map(notification -> (ScreenFlash) notification)
                    .forEach(screenFlash -> {
                        FlashNotification oldEnum = screenFlash.getFlashNotification();
                        screenFlash.setFlashMode((oldEnum == FlashNotification.SOLID_TWO_SECONDS || oldEnum == FlashNotification.SOLID_UNTIL_CANCELLED) ? FlashMode.SOLID : FlashMode.FLASH);
                        screenFlash.setFlashDuration((oldEnum == FlashNotification.FLASH_TWO_SECONDS || oldEnum == FlashNotification.SOLID_TWO_SECONDS) ? 2 : 0);
                        screenFlash.setFlashNotification(null);
                    });
            }

            if (configVersion.compareTo(new Version("2.13.0")) < 0) {
                log.debug("Need to set default overlay notification text color");
                this.alerts.stream()
                    .filter(alert -> !(alert instanceof AlertGroup))
                    .flatMap(alert -> alert.getNotifications().stream())
                    .filter(notification -> notification instanceof Overlay)
                    .map(notification -> (Overlay) notification)
                    .forEach(overlay -> {
                        if (overlay.getTextColor() == null) {
                            overlay.setTextColor(WatchdogConfig.DEFAULT_NOTIFICATION_TEXT_COLOR);
                        }
                    });
            }

            this.configManager.setConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.PLUGIN_VERSION, currentVersion.getVersion());
            this.saveAlerts();
        }
    }
}

package com.adamk33n3r.runelite.watchdog;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

import java.io.File;

@Getter
@RequiredArgsConstructor
public class SoundItem {
    private final File file;
    private final int gain;
    private final int repeatSeconds;
}

/*
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.adamk33n3r.runelite.watchdog;

import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.gson.*;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Adapts values whose runtime type may differ from their declaration type. This
 * is necessary when a field's type is not the same type that GSON should create
 * when deserializing that field. For example, consider these types:
 * <pre>   {@code
 *   abstract class Shape {
 *     int x;
 *     int y;
 *   }
 *   class Circle extends Shape {
 *     int radius;
 *   }
 *   class Rectangle extends Shape {
 *     int width;
 *     int height;
 *   }
 *   class Diamond extends Shape {
 *     int width;
 *     int height;
 *   }
 *   class Drawing {
 *     Shape bottomShape;
 *     Shape topShape;
 *   }
 * }</pre>
 * <p>Without additional type information, the serialized JSON is ambiguous. Is
 * the bottom shape in this drawing a rectangle or a diamond? <pre>   {@code
 *   {
 *     "bottomShape": {
 *       "width": 10,
 *       "height": 5,
 *       "x": 0,
 *       "y": 0
 *     },
 *     "topShape": {
 *       "radius": 2,
 *       "x": 4,
 *       "y": 1
 *     }
 *   }}</pre>
 * This class addresses this problem by adding type information to the
 * serialized JSON and honoring that type information when the JSON is
 * deserialized: <pre>   {@code
 *   {
 *     "bottomShape": {
 *       "type": "Diamond",
 *       "width": 10,
 *       "height": 5,
 *       "x": 0,
 *       "y": 0
 *     },
 *     "topShape": {
 *       "type": "Circle",
 *       "radius": 2,
 *       "x": 4,
 *       "y": 1
 *     }
 *   }}</pre>
 * Both the type field name ({@code "type"}) and the type labels ({@code
 * "Rectangle"}) are configurable.
 *
 * <h2>Registering Types</h2>
 * Create a {@code RuntimeTypeAdapterFactory} by passing the base type and type field
 * name to the {@link #of} factory method. If you don't supply an explicit type
 * field name, {@code "type"} will be used. <pre>   {@code
 *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory
 *       = RuntimeTypeAdapterFactory.of(Shape.class, "type");
 * }</pre>
 * Next register all of your subtypes. Every subtype must be explicitly
 * registered. This protects your application from injection attacks. If you
 * don't supply an explicit type label, the type's simple name will be used.
 * <pre>   {@code
 *   shapeAdapterFactory.registerSubtype(Rectangle.class, "Rectangle");
 *   shapeAdapterFactory.registerSubtype(Circle.class, "Circle");
 *   shapeAdapterFactory.registerSubtype(Diamond.class, "Diamond");
 * }</pre>
 * Finally, register the type adapter factory in your application's GSON builder:
 * <pre>   {@code
 *   Gson gson = new GsonBuilder()
 *       .registerTypeAdapterFactory(shapeAdapterFactory)
 *       .create();
 * }</pre>
 * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code
 *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory = RuntimeTypeAdapterFactory.of(Shape.class)
 *       .registerSubtype(Rectangle.class)
 *       .registerSubtype(Circle.class)
 *       .registerSubtype(Diamond.class);
 * }</pre>
 *
 * <h2>Serialization and deserialization</h2>
 * In order to serialize and deserialize a polymorphic object,
 * you must specify the base type explicitly.
 * <pre>   {@code
 *   Diamond diamond = new Diamond();
 *   String json = gson.toJson(diamond, Shape.class);
 * }</pre>
 * And then:
 * <pre>   {@code
 *   Shape shape = gson.fromJson(json, Shape.class);
 * }</pre>
 */
public final class RuntimeTypeAdapterFactory<T> implements TypeAdapterFactory {
    private final Class<?> baseType;
    private final String typeFieldName;
    private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<>();
    private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<>();
    private final List<String> labelsToIgnore = new ArrayList<>();
    private final boolean maintainType;
    private boolean recognizeSubtypes;

    private RuntimeTypeAdapterFactory(
        Class<?> baseType, String typeFieldName, boolean maintainType) {
        if (typeFieldName == null || baseType == null) {
            throw new NullPointerException();
        }
        this.baseType = baseType;
        this.typeFieldName = typeFieldName;
        this.maintainType = maintainType;
    }

    /**
     * Creates a new runtime type adapter using for {@code baseType} using {@code
     * typeFieldName} as the type field name. Type field names are case sensitive.
     *
     * @param maintainType true if the type field should be included in deserialized objects
     */
    public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName, boolean maintainType) {
        return new RuntimeTypeAdapterFactory<>(baseType, typeFieldName, maintainType);
    }

    /**
     * Creates a new runtime type adapter using for {@code baseType} using {@code
     * typeFieldName} as the type field name. Type field names are case sensitive.
     */
    public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName) {
        return new RuntimeTypeAdapterFactory<>(baseType, typeFieldName, false);
    }

    /**
     * Creates a new runtime type adapter for {@code baseType} using {@code "type"} as
     * the type field name.
     */
    public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType) {
        return new RuntimeTypeAdapterFactory<>(baseType, "type", false);
    }

    /**
     * Ensures that this factory will handle not just the given {@code baseType}, but any subtype
     * of that type.
     */
    @CanIgnoreReturnValue
    public RuntimeTypeAdapterFactory<T> recognizeSubtypes() {
        this.recognizeSubtypes = true;
        return this;
    }

    /**
     * Registers {@code type} identified by {@code label}. Labels are case
     * sensitive.
     *
     * @throws IllegalArgumentException if either {@code type} or {@code label}
     *     have already been registered on this type adapter.
     */
    @CanIgnoreReturnValue
    public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type, String label) {
        if (type == null || label == null) {
            throw new NullPointerException();
        }
        if (subtypeToLabel.containsKey(type) || labelToSubtype.containsKey(label)) {
            throw new IllegalArgumentException("types and labels must be unique");
        }
        labelToSubtype.put(label, type);
        subtypeToLabel.put(type, label);
        return this;
    }

    /**
     * Registers {@code type} identified by its {@link Class#getSimpleName simple
     * name}. Labels are case sensitive.
     *
     * @throws IllegalArgumentException if either {@code type} or its simple name
     *     have already been registered on this type adapter.
     */
    @CanIgnoreReturnValue
    public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type) {
        return registerSubtype(type, type.getSimpleName());
    }

    public RuntimeTypeAdapterFactory<T> ignoreSubtype(String label) {
        labelsToIgnore.add(label);
        return this;
    }

    @Override
    public <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {
        if (type == null) {
            return null;
        }
        Class<?> rawType = type.getRawType();
        boolean handle =
            recognizeSubtypes ? baseType.isAssignableFrom(rawType) : baseType.equals(rawType);
        if (!handle) {
            return null;
        }

        final TypeAdapter<JsonElement> jsonElementAdapter = gson.getAdapter(JsonElement.class);
        final Map<String, TypeAdapter<?>> labelToDelegate = new LinkedHashMap<>();
        final Map<Class<?>, TypeAdapter<?>> subtypeToDelegate = new LinkedHashMap<>();
        for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {
            TypeAdapter<?> delegate = gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));
            labelToDelegate.put(entry.getKey(), delegate);
            subtypeToDelegate.put(entry.getValue(), delegate);
        }

        return new TypeAdapter<R>() {
            @Override public R read(JsonReader in) throws IOException {
                JsonElement jsonElement = jsonElementAdapter.read(in);
                JsonElement labelJsonElement;
                if (maintainType) {
                    labelJsonElement = jsonElement.getAsJsonObject().get(typeFieldName);
                } else {
                    labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);
                }

                if (labelJsonElement == null) {
                    throw new JsonParseException("cannot deserialize " + baseType
                        + " because it does not define a field named " + typeFieldName);
                }
                String label = labelJsonElement.getAsString();
                @SuppressWarnings("unchecked") // registration requires that subtype extends T
                TypeAdapter<R> delegate = (TypeAdapter<R>) labelToDelegate.get(label);
                if (delegate == null) {
                    if (labelsToIgnore.contains(label)) {
                        return null;
                    } else {
                        throw new JsonParseException("cannot deserialize " + baseType + " subtype named "
                            + label + "; did you forget to register a subtype?");
                    }
                }
                return delegate.fromJsonTree(jsonElement);
            }

            @Override public void write(JsonWriter out, R value) throws IOException {
                Class<?> srcType = value.getClass();
                String label = subtypeToLabel.get(srcType);
                @SuppressWarnings("unchecked") // registration requires that subtype extends T
                TypeAdapter<R> delegate = (TypeAdapter<R>) subtypeToDelegate.get(srcType);
                if (delegate == null) {
                    throw new JsonParseException("cannot serialize " + srcType.getName()
                        + "; did you forget to register a subtype?");
                }
                JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();

                if (maintainType) {
                    jsonElementAdapter.write(out, jsonObject);
                    return;
                }

                JsonObject clone = new JsonObject();

                if (jsonObject.has(typeFieldName)) {
                    throw new JsonParseException("cannot serialize " + srcType.getName()
                        + " because it already defines a field named " + typeFieldName);
                }
                clone.add(typeFieldName, new JsonPrimitive(label));

                for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {
                    clone.add(e.getKey(), e.getValue());
                }
                jsonElementAdapter.write(out, clone);
            }
        }.nullSafe();
    }
}
package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.notifications.Overlay;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.runelite.client.util.ImageUtil;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.stream.Collectors;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY;
import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;
import static org.apache.commons.lang3.time.DurationFormatUtils.formatDuration;

@Slf4j
public class NotificationOverlay extends OverlayPanel {
    @Inject
    private Client client;
    @Inject
    private ClientUI clientUI;
    @Inject
    private WatchdogConfig config;

    private final ConcurrentLinkedQueue<OverlayNotificationData> overlayNotificationQueue = new ConcurrentLinkedQueue<>();
    static final private Dimension DEFAULT_SIZE = new Dimension(250, 60);
    static final String CLEAR = "Clear All";

    private class OverlayNotificationData extends PanelComponent {
        private final Instant timeStarted;
        private final Overlay overlayNotification;
        private final String message;
        private BufferedImage image;

        public OverlayNotificationData(Overlay overlayNotification, String message) {
            this.overlayNotification = overlayNotification;
            if (overlayNotification.getImagePath() != null && !overlayNotification.getImagePath().isEmpty()) {
                try {
                    this.image = ImageUtil.resizeImage(ImageIO.read(new File(overlayNotification.getImagePath())), 128, 128, true);
                } catch(IOException e) {
                    log.error("Failed to load image", e);
                }
            }
            this.message = message;
            this.timeStarted = Instant.now();
            this.setWrap(false);
        }

        public boolean isExpired() {
            return !this.overlayNotification.isSticky() && this.timeStarted.plus(Duration.ofSeconds(this.overlayNotification.getTimeToLive())).isBefore(Instant.now());
        }

        @Override
        public Dimension render(Graphics2D graphics) {
            this.setBackgroundColor(this.overlayNotification.getColor());
            this.getChildren().clear();
            this.getChildren().add(WrappedTitleComponent.builder()
                .text(this.message)
                .color(this.overlayNotification.getTextColor())
                .preferredSize(this.getPreferredSize())
                .build());
            if (this.image != null) {
                this.getChildren().add(new CenteredImageComponent(this.image));
            }
            if (config.overlayShowTime()) {
                this.getChildren().add(WrappedTitleComponent.builder()
                    .text(formatDuration(ChronoUnit.MILLIS.between(this.timeStarted, Instant.now()), "m'm' s's' 'ago'"))
                    .color(this.overlayNotification.getTextColor())
                    .preferredSize(this.getPreferredSize())
                    .build());
            }

            return super.render(graphics);
        }
    }

    @Inject
    public NotificationOverlay(WatchdogPlugin plugin) {
        super(plugin);
        this.setPosition(OverlayPosition.TOP_LEFT);
        this.setResizable(true);
        this.setPriority(0);
        this.setClearChildren(true);
        this.setPreferredSize(DEFAULT_SIZE);

        this.panelComponent.setWrap(false);
        this.panelComponent.setBorder(new Rectangle(0, 0, 0, 0));
        this.panelComponent.setGap(new Point(0, 6));
        this.panelComponent.setBackgroundColor(new Color(0, 0, 0, 0));

        this.addMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Watchdog Notification overlay");
        this.addMenuEntry(RUNELITE_OVERLAY, CLEAR, "Watchdog Notification overlay", (me) -> this.clear());
    }

    public void add(Overlay overlayNotification, String message) {
        this.overlayNotificationQueue.add(new OverlayNotificationData(overlayNotification, message));
    }

    public void clear() {
        this.overlayNotificationQueue.clear();
    }

    public void clearById(String id) {
        List<OverlayNotificationData> stickiesToDismiss = this.overlayNotificationQueue.stream()
            .filter(notif -> notif.overlayNotification.isSticky() && notif.overlayNotification.getId().equals(id))
            .collect(Collectors.toList());
        this.overlayNotificationQueue.removeAll(stickiesToDismiss);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        this.setLayer(this.config.overlayLayer());
        graphics.setFont(this.config.overlayFontType().getFont());

        this.panelComponent.getChildren().add(TitleComponent.builder().text("").build());
        if (this.overlayNotificationQueue.isEmpty()) {
            return super.render(graphics);
        }

        // Keep default width
        if (getPreferredSize() == null) {
            this.setPreferredSize(DEFAULT_SIZE);
        }
        this.overlayNotificationQueue.removeIf(OverlayNotificationData::isExpired);

        while (this.overlayNotificationQueue.size() > 5) {
            this.overlayNotificationQueue.poll();
        }

        this.overlayNotificationQueue.forEach(notif -> this.panelComponent.getChildren().add(notif));

        return super.render(graphics);
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.util.Text;

import com.google.common.base.MoreObjects;
import lombok.Builder;
import lombok.Getter;
import lombok.Setter;

import java.awt.*;

/**
 * Adapted from LineComponent and TitleComponent
 */
@Setter
@Builder
public class WrappedTitleComponent implements LayoutableRenderableEntity {
    @Builder.Default
    private String text = "";
    @Builder.Default
    private Color color = Color.WHITE;
    private Font font;

    @Builder.Default
    private Point preferredLocation = new Point();

    @Builder.Default
    private Dimension preferredSize = new Dimension(ComponentConstants.STANDARD_WIDTH, 0);

    @Builder.Default
    @Getter
    private Rectangle bounds = new Rectangle();

    private final int LINE_GAP = 2;
    private final int WIDTH_PADDING = 20;
    private final int HEIGHT_PADDING = 8;
    private final int TEXT_PADDING = 20;

    @Override
    public Dimension render(Graphics2D graphics) {
        final Font font = MoreObjects.firstNonNull(this.font, graphics.getFont());
        final FontMetrics fontMetrics = graphics.getFontMetrics(font);
        final int fmHeight = fontMetrics.getHeight();
        final int baseX = preferredLocation.x;
        final int baseY = preferredLocation.y + fmHeight;
        int x = baseX;
        int y = baseY;
        final int smallWidth = this.preferredSize.width;
        final int fullWidth = getLineWidth(this.text, fontMetrics);
        final TextComponent textComponent = new TextComponent();

        if (smallWidth < fullWidth) {
            final String[] splitLines = lineBreakText(this.text, smallWidth, fontMetrics);

            for (final String text : splitLines) {
                textComponent.setPosition(new Point(x + ((smallWidth - fontMetrics.stringWidth(text) + TEXT_PADDING) / 2), y + LINE_GAP));
                textComponent.setText(text);
                textComponent.setColor(this.color);
                textComponent.setFont(font);
                textComponent.render(graphics);

                y += fmHeight;
            }

            final Dimension dimension = new Dimension(this.preferredSize.width + WIDTH_PADDING, y - baseY + HEIGHT_PADDING);
            this.bounds.setLocation(preferredLocation);
            this.bounds.setSize(dimension);
            return dimension;
        }

        if (!this.text.isEmpty()) {
            textComponent.setPosition(new Point(x + ((smallWidth - fontMetrics.stringWidth(Text.removeTags(this.text)) + TEXT_PADDING) / 2), y + LINE_GAP));
            textComponent.setText(this.text);
            textComponent.setColor(this.color);
            textComponent.setFont(font);
            textComponent.render(graphics);
        }

        y += fmHeight;

        final Dimension dimension = new Dimension(this.preferredSize.width + WIDTH_PADDING, y - baseY + HEIGHT_PADDING);
        this.bounds.setLocation(this.preferredLocation);
        this.bounds.setSize(dimension);
        return dimension;
    }

    private static int getLineWidth(final String line, final FontMetrics metrics) {
        return metrics.stringWidth(Text.removeTags(line));
    }

    private static String[] lineBreakText(String text, int maxWidth, FontMetrics metrics) {
        final String[] words = text.split(" ");

        if (words.length == 0) {
            return new String[0];
        }

        final StringBuilder wrapped = new StringBuilder(words[0]);
        int spaceLeft = maxWidth - metrics.stringWidth(wrapped.toString());

        for (int i = 1; i < words.length; i++) {
            final String word = words[i];
            final int wordLen = metrics.stringWidth(word);
            final int spaceWidth = metrics.stringWidth(" ");

            if (wordLen + spaceWidth > spaceLeft) {
                wrapped.append("\n").append(word);
                spaceLeft = maxWidth - wordLen;
            } else {
                wrapped.append(" ").append(word);
                spaceLeft -= spaceWidth + wordLen;
            }
        }

        return wrapped.toString().split("\n");
    }
}

package com.adamk33n3r.runelite.watchdog;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum NotificationCategory implements Displayable {
    AUDIO("Audio", "Sound, text to speech, etc"),
    TEXT("Text", "Game message, overhead, etc"), // Game message, overhead, tray
    OVERLAY("Overlay", "Screen marker, flash, popup, etc"), // Overlay, popup, screen flash, screen marker
    ADVANCED("Advanced", "Dismissals, notification event, plugin message, etc"), // Dismissals, request focus, notification event, plugin message
    ;

    private final String name;
    private final String tooltip;
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;

import net.runelite.client.ui.MultiplexingPluginPanel;
import net.runelite.client.ui.PluginPanel;

import lombok.Getter;

public class WatchdogMuxer extends MultiplexingPluginPanel {
    @Getter
    private boolean isActive;

    public WatchdogMuxer(PluginPanel root) {
        super(root);
    }

    @Override
    protected void onAdd(PluginPanel p) {
        // TODO remove if it ever gets fixed https://github.com/runelite/runelite/issues/17712
        if (p instanceof AlertPanel) {
            ((AlertPanel<?>) p).rebuild();
        }
    }

    @Override
    public void onActivate() {
        super.onActivate();
        this.isActive = true;
    }

    @Override
    public void onDeactivate() {
        super.onDeactivate();
        this.isActive = false;
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import lombok.Getter;
import lombok.Setter;

import javax.swing.JTextField;
import javax.swing.text.Document;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.util.Map;

public class PlaceholderTextField extends JTextField {
    @Getter
    @Setter
    private String placeholder;

    private static final Map<?, ?> hints = (Map<?, ?>) Toolkit.getDefaultToolkit().getDesktopProperty("awt.font.desktophints");

    public PlaceholderTextField() {
        super();
    }

    public PlaceholderTextField(final Document pDoc, final String pText, final int pColumns) {
        super(pDoc, pText, pColumns);
    }

    public PlaceholderTextField(final String pText) {
        super(pText);
    }

    @Override
    protected void paintComponent(final Graphics pG) {
        super.paintComponent(pG);

        if (this.placeholder == null || this.placeholder.length() == 0 || this.getText().length() > 0) {
            return;
        }

        final Graphics2D g = (Graphics2D) pG;
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setColor(this.getDisabledTextColor());
        g.drawString(this.placeholder, this.getInsets().left, g.getFontMetrics().getMaxAscent() + this.getInsets().top);
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import com.google.common.base.Strings;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

/**
 * This component is a JTextArea with a flat design look.
 */
@Getter
public class FlatTextAreaNamespace extends FlatTextArea {
    private final PlaceholderTextArea prefixTextArea;
    private final String splitter;

    public FlatTextAreaNamespace(String firstPlaceholder, String splitter, String secondPlaceholder) {
        this(firstPlaceholder, splitter, secondPlaceholder, false);
    }

    public FlatTextAreaNamespace(String prefixPlaceholder, String splitter, String secondPlaceholder, boolean preventNewline) {
        super(secondPlaceholder, preventNewline);
        this.setLayout(new DynamicGridLayout(1, 3));
        this.splitter = splitter;

        this.prefixTextArea = new PlaceholderTextArea();
        this.prefixTextArea.setPlaceholder(prefixPlaceholder);
        this.prefixTextArea.setOpaque(false);
        this.prefixTextArea.setSelectedTextColor(Color.WHITE);
        this.prefixTextArea.setSelectionColor(ColorScheme.BRAND_ORANGE_TRANSPARENT);
        this.prefixTextArea.setLineWrap(true);
        this.prefixTextArea.setWrapStyleWord(true);
        this.prefixTextArea.setMargin(new Insets(4, 6, 5, 6));
//        this.prefixTextArea.setPreferredSize(new Dimension(60, 0));

        this.removeAll();
        this.add(this.prefixTextArea);

        this.prefixTextArea.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent mouseEvent) {
                if (blocked) {
                    return;
                }

                if (hoverBackgroundColor != null) {
                    setBackground(hoverBackgroundColor, false);
                }
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent) {
                setBackground(backgroundColor);
            }
        });

        var splitterLabel = new JLabel(":");
        splitterLabel.setMaximumSize(new Dimension(10, 0));
        this.add(splitterLabel);
        this.add(this.textArea);

        this.setUpKeymaps(preventNewline);
        this.setUpKeymaps(preventNewline, this.prefixTextArea);
    }

    public String getText() {
        if (this.prefixTextArea.getText().isEmpty() && this.textArea.getText().isEmpty()) {
            return "";
        }
        return this.prefixTextArea.getText() + this.splitter + this.textArea.getText();
    }

    public void setText(String text) {
        if (Strings.isNullOrEmpty(text)) {
            return;
        }
        String[] split = text.split(this.splitter);
        if (split.length != 2) {
            return;
        }
        this.prefixTextArea.setText(split[0]);
        this.textArea.setText(split[1]);
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Insets;

public class HorizontalRuleBorder extends EtchedBorder {
    private final int size;
    private final Border outsideBorder;
    public HorizontalRuleBorder(int size) {
        super();
        this.size = size;
        this.outsideBorder = new EmptyBorder(this.size, 0, 0, 0);
    }

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets) {
        Insets outerInsets = this.outsideBorder.getBorderInsets(c);
        insets.set(this.size + outerInsets.top, 0, 0, 0);
        return insets;
    }

    /**
     * Paints the border for the specified component with the
     * specified position and size.
     *
     * @param c the component for which this border is being painted
     * @param g the paint graphics
     * @param x the x position of the painted border
     * @param y the y position of the painted border
     * @param width the width of the painted border
     * @param height the height of the painted border
     */
    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {
        Insets  nextInsets;
        int px, py, pw, ph;

        px = x;
        py = y;
        pw = width;
        ph = height;

        outsideBorder.paintBorder(c, g, px, py, pw, ph);

        nextInsets = outsideBorder.getBorderInsets(c);
        px += nextInsets.left;
        py += nextInsets.top;
        pw = pw - nextInsets.right - nextInsets.left;
        ph = ph - nextInsets.bottom - nextInsets.top;

        g.translate(px, py);

        g.setColor(etchType == LOWERED? getShadowColor(c) : getHighlightColor(c));
        g.drawLine(0, 0, pw - 2, 0);

        g.setColor(etchType == LOWERED? getHighlightColor(c) : getShadowColor(c));
        g.drawLine(1, 1, pw-3, 1);

        g.translate(-px, -py);
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.util.Text;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.GridLayout;
import java.util.function.Consumer;
import java.util.stream.Stream;

public class MessagePickerDialog extends JDialog {
    public MessagePickerDialog(Component parent, Stream<String> messageQueue, Consumer<String> callback) {
        this.setTitle("Pick Message");
        this.setSize(500, 250);
        this.setLocationRelativeTo(parent);
        this.setModal(true);
        this.setUndecorated(true);
        Util.syncAlwaysOnTop(this);

        JPanel wrapper = new JPanel(new BorderLayout());
        wrapper.setBorder(new EmptyBorder(10, 10, 10, 10));
        this.add(wrapper);
        wrapper.add(new JLabel("Pick a message"), BorderLayout.NORTH);

        String[] messageArray = messageQueue
            .map(Text::removeFormattingTags)
            .toArray(String[]::new);
        JList<String> messageList = new JList<>(messageArray);
        messageList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        if (messageList.getModel().getSize() > 0) {
            JScrollPane scroll = new JScrollPane(messageList);
            wrapper.add(scroll, BorderLayout.CENTER);
            SwingUtilities.invokeLater(() -> {
                scroll.getVerticalScrollBar().setValue(scroll.getVerticalScrollBar().getMaximum());
            });
        } else {
            wrapper.add(new JLabel("No messages in history"));
        }

        JPanel btnGroup = new JPanel(new GridLayout(1, 0, 25, 0));
        JButton selectBtn = new JButton("Select");
        selectBtn.addActionListener((al) -> {
            callback.accept(messageList.getSelectedValue());
            this.setVisible(false);
        });
        btnGroup.add(selectBtn);
        JButton closeBtn = new JButton("Cancel");
        closeBtn.addActionListener(ev -> {
            this.setVisible(false);
        });
        btnGroup.add(closeBtn);
        wrapper.add(btnGroup, BorderLayout.SOUTH);
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import com.adamk33n3r.runelite.watchdog.Displayable;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.DynamicGridLayout;

import lombok.AllArgsConstructor;
import lombok.Getter;

import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import java.awt.Dimension;
import java.util.function.Consumer;

public class ComparableNumber extends JPanel {
    private final JComboBox<Comparator> comparator;
    private final JSpinner number;
    public ComparableNumber(
        int val, Consumer<Integer> onNumChange, int min, int max, int step,
        Comparator comparatorVal, Consumer<Comparator> onComparatorChange
    ) {
        this.comparator = PanelUtils.createSelect(Comparator.values(), comparatorVal, onComparatorChange);
        this.number = PanelUtils.createSpinner(val, min, max, step, onNumChange);

        this.setLayout(new DynamicGridLayout(1, 2, 5, 5));
        this.number.setPreferredSize(new Dimension(70, 0));
        this.add(this.comparator);
        this.add(this.number);
    }

    @Getter
    @AllArgsConstructor
    public enum Comparator implements Displayable {
        EQUALS("==", "Equals"),
        NOT_EQUALS("!=", "Not Equals"),
        LESS_THAN("<", "Less Than"),
        GREATER_THAN(">", "Greater Than"),
        LESS_THAN_OR_EQUALS("<=", "Less Than or Equals"),
        GREATER_THAN_OR_EQUALS(">=", "Greater Than or Equals"),
        ;

        private final String name;
        private final String tooltip;

        public boolean compare(int a, int b) {
            switch (this) {
                case EQUALS:
                    return a == b;
                case NOT_EQUALS:
                    return a != b;
                case LESS_THAN:
                    return a < b;
                case GREATER_THAN:
                    return a > b;
                case LESS_THAN_OR_EQUALS:
                    return a <= b;
                case GREATER_THAN_OR_EQUALS:
                    return a >= b;
                default:
                    return false;
            }
        }

        public Comparator converse() {
            switch (this) {
                case EQUALS:
                    return NOT_EQUALS;
                case NOT_EQUALS:
                    return EQUALS;
                case LESS_THAN:
                    return GREATER_THAN_OR_EQUALS;
                case GREATER_THAN:
                    return LESS_THAN_OR_EQUALS;
                case LESS_THAN_OR_EQUALS:
                    return GREATER_THAN;
                case GREATER_THAN_OR_EQUALS:
                    return LESS_THAN;
                default:
                    throw new IllegalArgumentException();
            }
        }
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import com.adamk33n3r.runelite.watchdog.AlertManager;
import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.alerts.AlertGroup;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.plugins.config.ConfigPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.MouseDragEventForwarder;
import net.runelite.client.util.ImageUtil;

import lombok.Getter;
import lombok.Setter;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.List;

public class AlertListItem extends JPanel {
    private static final ImageIcon SECTION_EXPAND_ICON;
    private static final ImageIcon SECTION_EXPAND_ICON_HOVER;
    private static final ImageIcon SECTION_RETRACT_ICON;
    private static final ImageIcon SECTION_RETRACT_ICON_HOVER;

    static {
        BufferedImage sectionRetractIcon = ImageUtil.loadImageResource(ConfigPlugin.class, "/util/arrow_right.png");
        sectionRetractIcon = ImageUtil.luminanceOffset(sectionRetractIcon, -121);
        SECTION_EXPAND_ICON = new ImageIcon(sectionRetractIcon);
        SECTION_EXPAND_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(sectionRetractIcon, -100));
        final BufferedImage sectionExpandIcon = ImageUtil.rotateImage(sectionRetractIcon, Math.PI / 2);
        SECTION_RETRACT_ICON = new ImageIcon(sectionExpandIcon);
        SECTION_RETRACT_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(sectionExpandIcon, -100));
    }

    private static final int ROW_HEIGHT = 30;
    private static final int PADDING = 2;
    private final MouseDragEventForwarder mouseDragEventForwarder;
    private final AlertManager alertManager;
    private final WatchdogPanel panel;

    private boolean collapsed = true;

    @Getter
    private final Alert alert;
    private final Runnable onChange;

    @Getter @Setter
    private boolean selected = false;
    private boolean selectMode = false;

    public AlertListItem(WatchdogPanel panel, AlertManager alertManager, Alert alert, JComponent parent, Runnable onChange) {
        this.panel = panel;
        this.alert = alert;
        this.alertManager = alertManager;
        this.onChange = onChange;
        this.setLayout(new BorderLayout(5, 0));
        this.setBorder(new EmptyBorder(PADDING, 0, PADDING, 0));
        this.setBackground(ColorScheme.DARK_GRAY_COLOR);
        this.mouseDragEventForwarder = new MouseDragEventForwarder(parent);

        this.rebuild();
    }

    public void setSelectMode(boolean selectMode) {
        this.selectMode = selectMode;
        this.rebuild();
    }

    public void rebuild() {
        this.removeAll();

        final JPanel container = new JPanel(new StretchedStackedLayout(3));
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        final JPanel topWrapper = new JPanel(new BorderLayout(3, 3));
        container.add(topWrapper);

        topWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        topWrapper.setBorder(new CompoundBorder(
            BorderFactory.createMatteBorder(0, 0, this.collapsed ? 0 : 2, 0, ColorScheme.DARK_GRAY_COLOR),
            BorderFactory.createMatteBorder(5, 10, 5, 0, ColorScheme.DARKER_GRAY_COLOR)));

        final ToggleButton toggleButton;
        if (selectMode) {
            toggleButton = new ToggleButton("Deselect", "Select");
            toggleButton.addItemListener((ev) -> this.selected = toggleButton.isSelected());
        } else {
            toggleButton = new ToggleButton();
            toggleButton.setSelected(this.alert.isEnabled());
            toggleButton.addItemListener(i -> {
                this.alert.setEnabled(toggleButton.isSelected());
                this.alertManager.saveAlerts();
            });
        }
        topWrapper.add(toggleButton, BorderLayout.WEST);

        final JPanel nameWrapper = new JPanel(new BorderLayout());
        nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        topWrapper.add(nameWrapper, BorderLayout.CENTER);

        if (this.alert instanceof AlertGroup) {
            final JButton collapseButton = PanelUtils.createActionButton(
                this.collapsed ? SECTION_EXPAND_ICON : SECTION_RETRACT_ICON,
                this.collapsed ? SECTION_EXPAND_ICON_HOVER : SECTION_RETRACT_ICON_HOVER,
                this.collapsed ? "Expand" : "Collapse",
                (btn, evt) -> {
                    this.collapsed = !this.collapsed;
                    this.rebuild();
                    this.revalidate();
                }
            );
            nameWrapper.add(collapseButton, BorderLayout.WEST);
        }

        final JLabel nameLabel = new JLabel(this.alert.getName());
        nameLabel.setToolTipText(this.alert.getName());
        nameWrapper.add(nameLabel);

        topWrapper.addMouseListener(this.mouseDragEventForwarder);
        topWrapper.addMouseMotionListener(this.mouseDragEventForwarder);
        nameWrapper.addMouseListener(this.mouseDragEventForwarder);
        nameWrapper.addMouseMotionListener(this.mouseDragEventForwarder);
        nameLabel.addMouseListener(this.mouseDragEventForwarder);
        if (alert instanceof AlertGroup) {
            nameLabel.addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    if (e.getButton() == MouseEvent.BUTTON1) {
                        collapsed = !collapsed;
                        rebuild();
                        revalidate();
                    }
                }
            });
        }
        nameLabel.addMouseMotionListener(this.mouseDragEventForwarder);

        final JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 3, 0));
        rightActions.setBorder(new EmptyBorder(4, 0, 0, 0));
        rightActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        topWrapper.add(rightActions, BorderLayout.EAST);

        rightActions.add(PanelUtils.createActionButton(Icons.EDIT, Icons.EDIT_HOVER, "Edit Alert", (btn, modifiers) -> {
            this.panel.openAlert(this.alert);
        })).setEnabled(!selectMode);

        rightActions.add(PanelUtils.createActionButton(Icons.CLONE, Icons.CLONE_HOVER, "Clone Alert", (btn, modifiers) -> {
            Alert cloned = this.alertManager.cloneAlert(this.alert);
            AlertGroup parent = this.alert.getParent();
            if (parent != null) {
                cloned.setParent(parent);
                parent.getAlerts().add(cloned);
            } else {
                this.alertManager.getAlerts().add(cloned);
            }
            this.alertManager.saveAlerts();
            this.onChange.run();
        })).setEnabled(!selectMode);

        rightActions.add(PanelUtils.createActionButton(Icons.DELETE, Icons.DELETE_HOVER, "Delete Alert", (btn, modifiers) -> {
            int result = JOptionPane.showConfirmDialog(this, "Are you sure you want to delete the " + this.alert.getName() + " alert?", "Delete?", JOptionPane.YES_NO_OPTION, JOptionPane.ERROR_MESSAGE);
            if (result == JOptionPane.YES_OPTION) {
                this.alertManager.removeAlert(this.alert);
                this.onChange.run();
            }
        })).setEnabled(!selectMode);

        if (this.alert instanceof AlertGroup && !this.collapsed) {
            final JPanel settings = new JPanel(new StretchedStackedLayout(3));
            settings.setBorder(new EmptyBorder(0, 10, 5, 10));
            settings.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            List<Alert> subAlerts = ((AlertGroup) this.alert).getAlerts();
            for (Alert subAlert : subAlerts) {
                String labelStr = String.format("%s (%s)", subAlert.getName(), subAlert.getType().getName());
                JLabel alertLabel = new JLabel(labelStr);
                alertLabel.setToolTipText(labelStr);
                settings.add(alertLabel);
            }
            if (subAlerts.isEmpty()) {
                settings.add(new JLabel("No alerts in group"));
            }
            container.add(settings);
        }

        this.add(container, BorderLayout.CENTER);
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;

import javax.swing.ImageIcon;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.Dimension;
import java.util.Objects;
import java.util.function.Consumer;

public class SearchBar extends IconTextField {
    public SearchBar(Consumer<String> onSearch) {
        super();
        this.setIcon(new ImageIcon(Objects.requireNonNull(IconTextField.class.getResource(Icon.SEARCH.getFile()))));
        this.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - PluginPanel.SCROLLBAR_WIDTH, 30));
        this.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        this.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        this.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) {
                onSearch.accept(getText());
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                onSearch.accept(getText());
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                onSearch.accept(getText());
            }
        });
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.AlertManager;
import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.alerts.AlertGroup;
import com.adamk33n3r.runelite.watchdog.ui.HorizontalRuleBorder;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertListPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;

public class AlertGroupPanel extends AlertPanel<AlertGroup> {
    public AlertGroupPanel(WatchdogPanel watchdogPanel, AlertGroup alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        AlertManager alertManager = WatchdogPlugin.getInstance().getAlertManager();
        this.addAlertDefaults();
        JPanel buttonPanel = new JPanel(new BorderLayout());
        buttonPanel.add(new JLabel("Alerts"), BorderLayout.WEST);
        buttonPanel.setBorder(new EmptyBorder(0, 5, 8, 0));

        JButton alertDropDownButton = PanelUtils.createAlertDropDownButton(createdAlert -> {
            this.alert.getAlerts().add(createdAlert);
            alertManager.saveAlerts();
            this.rebuild();
            this.watchdogPanel.openAlert(createdAlert);
        });

        buttonPanel.add(alertDropDownButton, BorderLayout.EAST);
        JPanel subGroupPanel = new JPanel(new BorderLayout());
        subGroupPanel.setBorder(new CompoundBorder(new EmptyBorder(0, 5, 0, 5), new HorizontalRuleBorder(10)));
        subGroupPanel.add(buttonPanel, BorderLayout.NORTH);

        AlertListPanel alertListPanel = new AlertListPanel(this.alert.getAlerts(), this.alert, this::rebuild);

        subGroupPanel.add(alertListPanel);
        this.addSubPanel(subGroupPanel);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.GameMessageType;
import com.adamk33n3r.runelite.watchdog.PlayerChatType;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import javax.swing.JButton;
import java.util.function.Consumer;
import java.util.function.Supplier;

public class MessagePickerButton {
    public static JButton createNotificationPickerButton(Consumer<String> callback) {
        return PanelUtils.createActionButton(Icons.PICKER, Icons.PICKER_HOVER, "Pick a recent notification", (btn, mod) -> WatchdogPlugin.getInstance().getPanel().pickNotification(callback));
    }

    public static JButton createGameMessagePickerButton(Consumer<String> callback, Supplier<GameMessageType> typeFilter) {
        return PanelUtils.createActionButton(Icons.PICKER, Icons.PICKER_HOVER, "Pick a message from chat", (btn, mod) -> WatchdogPlugin.getInstance().getPanel().pickMessage(callback, (msg) -> typeFilter.get().isOfType(msg.getType())));
    }

    public static JButton createPlayerChatPickerButton(Consumer<String> callback, Supplier<PlayerChatType> typeFilter) {
        return PanelUtils.createActionButton(Icons.PICKER, Icons.PICKER_HOVER, "Pick a message from chat", (btn, mod) -> WatchdogPlugin.getInstance().getPanel().pickMessage(callback, (msg) -> typeFilter.get().isOfType(msg.getType())));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.WatchdogProperties;
import com.adamk33n3r.runelite.watchdog.alerts.SoundFiredAlert;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;

public class SoundFiredAlertPanel extends AlertPanel<SoundFiredAlert> {
    public SoundFiredAlertPanel(WatchdogPanel watchdogPanel, SoundFiredAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addRichTextPane("<html>Go to <a href='" + WatchdogProperties.getProperties().getProperty("watchdog.wikiPage.soundIDs") + "'>this wiki page</a> to get a list<br>of sound ids</html>")
            .addSpinner("Sound ID", "The ID of the sound", this.alert.getSoundID(), this.alert::setSoundID)
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.XPDropAlert;
import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.api.Skill;

public class XPDropAlertPanel extends AlertPanel<XPDropAlert> {
    public XPDropAlertPanel(WatchdogPanel watchdogPanel, XPDropAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addSelect("Skill", "The skill to track", Skill.class, this.alert.getSkill(), this.alert::setSkill)
            .addSubPanelControl(PanelUtils.createLabeledComponent(
                "Gained Amount",
                "How much xp needed to trigger this alert",
                new ComparableNumber(this.alert.getGainedAmount(), this.alert::setGainedAmount, 0, Integer.MAX_VALUE, 1, this.alert.getGainedComparator(), this.alert::setGainedComparator)))
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.GameMessageType;
import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.ChatAlert;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;

public class GameMessageAlertPanel extends AlertPanel<ChatAlert> {
    public GameMessageAlertPanel(WatchdogPanel watchdogPanel, ChatAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addRegexMatcher(this.alert, "Enter the message to trigger on...", "The message to trigger on. Supports glob (*)", MessagePickerButton.createGameMessagePickerButton((selected) -> {
                this.alert.setPattern(selected);
                this.rebuild();
            }, this.alert::getGameMessageType))
            .addSelect("Chat Type", "The type of message", GameMessageType.class, this.alert.getGameMessageType(), this.alert::setGameMessageType)
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import javax.swing.JButton;
import javax.swing.JPanel;
import java.util.function.Consumer;

public class NotificationPickerButton extends JPanel {
    public NotificationPickerButton(Consumer<String> callback) {
        JButton picker = PanelUtils.createActionButton(Icons.PICKER, Icons.PICKER_HOVER, "Pick a recent notification", (btn, mod) -> WatchdogPlugin.getInstance().getPanel().pickNotification(callback));
        this.add(picker);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.NotificationFiredAlert;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;

public class NotificationFiredAlertPanel extends AlertPanel<NotificationFiredAlert> {
    public NotificationFiredAlertPanel(WatchdogPanel watchdogPanel, NotificationFiredAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addRegexMatcher(this.alert, "Enter the message to trigger on...", "The message to trigger on. Supports glob (*)", MessagePickerButton.createNotificationPickerButton((selected) -> {
                this.alert.setPattern(selected);
                this.rebuild();
            }))
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.InventoryAlert;
import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

public class InventoryAlertPanel extends AlertPanel<InventoryAlert> {
    public InventoryAlertPanel(WatchdogPanel watchdogPanel, InventoryAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        boolean isItemChange = this.alert.getInventoryAlertType() == InventoryAlert.InventoryAlertType.ITEM_CHANGE;
        this.addAlertDefaults()
            .addSelect("Type", "Type", InventoryAlert.InventoryAlertType.class, this.alert.getInventoryAlertType(), (val) -> {
                this.alert.setInventoryAlertType(val);
                this.rebuild();
            })
            .addIf(
                panel -> panel.addRegexMatcher(this.alert, "Enter the name of the item to trigger on...", "The name to trigger on. Supports glob (*)")
                    .addSubPanelControl(PanelUtils.createLabeledComponent(
                        isItemChange ? "Change" : "Quantity",
                        isItemChange ? "The quantity change of the item (in one tick) to trigger on. Negative for loss, positive for gain, 0 for no change" : "The quantity of item to trigger on",
                        new ComparableNumber(this.alert.getItemQuantity(), this.alert::setItemQuantity, isItemChange ? Integer.MIN_VALUE : 0, Integer.MAX_VALUE, 1, this.alert.getQuantityComparator(), this.alert::setQuantityComparator))),
                () -> this.alert.getInventoryAlertType() == InventoryAlert.InventoryAlertType.ITEM || isItemChange
            )
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.StatChangedAlert;
import com.adamk33n3r.runelite.watchdog.alerts.StatChangedMode;
import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.api.Skill;

import javax.swing.*;

public class StatChangedAlertPanel extends AlertPanel<StatChangedAlert> {
    public StatChangedAlertPanel(WatchdogPanel watchdogPanel, StatChangedAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addSelect("Skill", "The skill to track.", Skill.class, this.alert.getSkill(), this.alert::setSkill)
            .addSelect("Changed Mode", "The mode to compare the skill to the amount with.", StatChangedMode.class, this.alert.getChangedMode(), (val) -> {
                this.alert.setChangedMode(val);
                this.rebuild();
            })
            .addSubPanelControl(this.alert.getChangedMode() == StatChangedMode.RELATIVE ?
                this.createRelativeLevelPanel() :
                this.createAbsoluteLevelPanel())
            .addNotifications();
    }

    private JPanel createRelativeLevelPanel() {
        return PanelUtils.createLabeledComponent(
            "Changed Amount",
            "The difference in level to trigger the alert. Can be positive for boost and negative for drain.",
            new ComparableNumber(this.alert.getChangedAmount(), this.alert::setChangedAmount, -99, 99, 1, this.alert.getChangedComparator(), this.alert::setChangedComparator));
    }

    private JPanel createAbsoluteLevelPanel() {
        return PanelUtils.createLabeledComponent(
            "Level",
            "The level to trigger the alert.",
            new ComparableNumber(this.alert.getChangedAmount(), this.alert::setChangedAmount, 0, 99, 1, this.alert.getChangedComparator(), this.alert::setChangedComparator));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.PlayerChatType;
import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.PlayerChatAlert;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;

public class PlayerChatAlertPanel extends AlertPanel<PlayerChatAlert> {
    public PlayerChatAlertPanel(WatchdogPanel watchdogPanel, PlayerChatAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addRegexMatcher(this.alert, "Enter the message to trigger on...", "The message to trigger on. Supports glob (*)", MessagePickerButton.createPlayerChatPickerButton((selected) -> {
                this.alert.setPattern(selected);
                this.rebuild();
            }, this.alert::getPlayerChatType))
            .addSelect("Chat Type", "The type of message", PlayerChatType.class, this.alert.getPlayerChatType(), this.alert::setPlayerChatType)
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.LocationAlert;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;

import javax.swing.JPanel;
import java.awt.GridLayout;

public class LocationAlertPanel extends AlertPanel<LocationAlert> {
    private final Client client;

    public LocationAlertPanel(WatchdogPanel watchdogPanel, LocationAlert alert, Client client) {
        super(watchdogPanel, alert);
        this.client = client;
    }

    @Override
    protected void build() {
        JPanel pointPanel = new JPanel(new GridLayout(1, 3, 5, 5));
        JPanel xPos = PanelUtils.createLabeledComponent(
            "X Pos",
            "The X position",
            PanelUtils.createSpinner(this.alert.getWorldPoint().getX(),
                Integer.MIN_VALUE,
                Integer.MAX_VALUE,
                1,
                (val) -> this.alert.setWorldPoint(this.alert.getWorldPoint().dx(val - this.alert.getWorldPoint().getX())))
        , true);
        JPanel yPos = PanelUtils.createLabeledComponent(
            "Y Pos",
            "The Y position",
            PanelUtils.createSpinner(this.alert.getWorldPoint().getY(),
                Integer.MIN_VALUE,
                Integer.MAX_VALUE,
                1,
                (val) -> this.alert.setWorldPoint(this.alert.getWorldPoint().dy(val - this.alert.getWorldPoint().getY())))
        , true);
        JPanel plane = PanelUtils.createLabeledComponent(
            "Plane",
            "The plane number",
            PanelUtils.createSpinner(this.alert.getWorldPoint().getPlane(),
                Integer.MIN_VALUE,
                Integer.MAX_VALUE,
                1,
                (val) -> this.alert.setWorldPoint(this.alert.getWorldPoint().dz(val - this.alert.getWorldPoint().getPlane())))
            , true);
        pointPanel.add(xPos);
        pointPanel.add(yPos);
        pointPanel.add(plane);

        JPanel checkboxes = new JPanel(new GridLayout(1, 0, 5, 5));
        checkboxes.add(PanelUtils.createCheckbox("Cardinal Only", "Only fire on cardinal directions", this.alert.isCardinalOnly(), this.alert::setCardinalOnly));
        checkboxes.add(PanelUtils.createCheckbox("Repeat", "Repeat alert while standing in area", this.alert.isRepeat(), this.alert::setRepeat));

        this.addAlertDefaults()
            .addSubPanelControl(pointPanel)
            .addButton("Set to Current", "Set world point to current position", (btn, mod) -> {
                if (this.client.getLocalPlayer() != null) {
                    WorldPoint worldPoint = WorldPoint.fromLocalInstance(this.client, this.client.getLocalPlayer().getLocalLocation());
                    this.alert.setWorldPoint(worldPoint);
                    this.rebuild();
                }
            })
            .addSpinner("Distance", "Minimum distance to the set location to trigger this alert", this.alert.getDistance(), this.alert::setDistance, 0, Integer.MAX_VALUE, 1)
            .addSubPanelControl(checkboxes)
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.SpawnedAlert;
import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

public class SpawnedAlertPanel extends AlertPanel<SpawnedAlert> {
    public SpawnedAlertPanel(WatchdogPanel watchdogPanel, SpawnedAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addSelect("Spawned/Despawned", "Spawned or Despawned", SpawnedAlert.SpawnedDespawned.class, this.alert.getSpawnedDespawned(), this.alert::setSpawnedDespawned)
            .addSelect("Type", "The type of object to trigger on", SpawnedAlert.SpawnedType.class, this.alert.getSpawnedType(), this.alert::setSpawnedType)
            .addSubPanelControl(PanelUtils.createLabeledComponent(
                "Distance Limit",
                "Limit to a distance from the player. Use -1 for no limit. For objects which are larger than 1 tile, the location is the center most tile, rounded to the south-west",
                new ComparableNumber(this.alert.getDistance(), this.alert::setDistance, -1, Integer.MAX_VALUE, 1, this.alert.getDistanceComparator(), this.alert::setDistanceComparator)))
            .addRegexMatcher(this.alert, "Enter the object to trigger on...", "The name to trigger on. Supports glob (*)")
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import com.adamk33n3r.runelite.watchdog.WatchdogMuxer;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.StretchedStackedLayout;

import net.runelite.client.ui.PluginPanel;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Provider;
import javax.inject.Singleton;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Dimension;

@Slf4j
@Singleton
public class ToolsPanel extends PluginPanel {
    @Inject
    private Provider<HistoryPanel> historyPanelProvider;
    private final Provider<WatchdogMuxer> muxer;

    @Inject
    public ToolsPanel(Provider<WatchdogMuxer> muxer) {
        super(false);
        this.muxer = muxer;

        this.setLayout(new BorderLayout());

        JButton backButton = PanelUtils.createActionButton(
            Icons.BACK,
            Icons.BACK_HOVER,
            "Back",
            (btn, modifiers) -> this.muxer.get().popState()
        );
        backButton.setPreferredSize(new Dimension(22, 16));
        backButton.setBorder(new EmptyBorder(0, 0, 0, 5));

        JPanel nameGroup = new JPanel(new BorderLayout());
        this.add(nameGroup, BorderLayout.NORTH);
        nameGroup.setBorder(new EmptyBorder(10, 5, 10, 5));
        nameGroup.add(new JLabel("Tools"), BorderLayout.CENTER);
        nameGroup.add(backButton, BorderLayout.WEST);

        JPanel tools = new JPanel(new StretchedStackedLayout(3));

        tools.add(PanelUtils.createButton("Alert History", "Alert History", (btn, mods) -> {
            this.muxer.get().pushState(this.historyPanelProvider.get());
        }));

        tools.add(PanelUtils.createButton("Stop All Sounds", "Stop All Sounds", (btn, mods) -> {
            WatchdogPlugin.getInstance().getSoundPlayer().stop();
        }));
        tools.add(PanelUtils.createButton("Dismiss All Overlays", "Dismiss All Overlays", (btn, mods) -> {
            WatchdogPlugin.getInstance().getNotificationOverlay().clear();
        }));
        tools.add(PanelUtils.createButton("Dismiss All Screen Markers", "Dismiss All Screen Markers", (btn, mods) -> {
            WatchdogPlugin.getInstance().getScreenMarkerUtil().removeAllMarkers();
        }));
        this.add(tools);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import com.adamk33n3r.runelite.watchdog.*;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextAreaNamespace;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.dropdownbutton.DropDownButtonFactory;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.components.ColorJButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

import org.apache.commons.text.WordUtils;

import javax.annotation.Nullable;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.filechooser.FileFilter;
import javax.swing.text.AbstractDocument;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.Arrays;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import java.util.stream.Collectors;

public class PanelUtils {
    private static final ImageIcon FOLDER;
    static {
        final BufferedImage folderImg = ImageUtil.loadImageResource(Icons.class, "mdi_folder-open.png");

        FOLDER = new ImageIcon(folderImg);
    }

    private PanelUtils () {}

    public static JPanel createLabeledComponent(String label, String tooltip, Component component) {
        return createLabeledComponent(label, tooltip, component, false);
    }

    public static JPanel createLabeledComponent(String label, String tooltip, Component component, boolean twoLines) {
        JPanel panel = new JPanel();
        if (twoLines) {
            panel.setLayout(new DynamicGridLayout(2, 0, 5, 5));
        } else {
            panel.setBorder(new EmptyBorder(0, 5, 0, 0));
            panel.setLayout(new BorderLayout(5, 0));
        }
        JLabel jLabel = new JLabel(label);
        jLabel.setToolTipText(tooltip);
        panel.add(jLabel, BorderLayout.WEST);
        panel.add(component);
        return panel;
    }

    public static JPanel createIconComponent(ImageIcon icon, String tooltip, Component component) {
        JPanel panel = new JPanel(new BorderLayout(5, 0));
        panel.setBackground(null);
        JLabel jLabel = new JLabel(icon);
        jLabel.setToolTipText(tooltip);
        panel.add(jLabel, BorderLayout.WEST);
        panel.add(component);
        return panel;
    }

    public static JPanel createFileChooser(String label, String tooltip, ActionListener actionListener, String path, String filterLabel, String... filters) {
        JPanel panel = new JPanel(new GridLayout(1, 1));
        panel.setBackground(null);
        if (label != null) {
            panel.setLayout(new GridLayout(2, 1));
            JLabel jLabel = new JLabel(label);
            jLabel.setToolTipText(tooltip);
            panel.add(jLabel);
        }
        JPanel chooserPanel = new JPanel(new BorderLayout(5, 0));
        chooserPanel.setBackground(null);
        panel.add(chooserPanel);
        JTextField pathField = new JTextField(path);
        pathField.setToolTipText(path);
        pathField.setEditable(false);
        chooserPanel.add(pathField);
        JFileChooser fileChooser = new JFileChooser(path);
        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
        fileChooser.setAcceptAllFileFilterUsed(false);
        fileChooser.setFileFilter(new FileFilter() {
            @Override
            public boolean accept(File file) {
                if (file.isDirectory()) {
                    return true;
                }
                String fileName = file.getName();
                int i = fileName.lastIndexOf('.');
                String extension = null;
                if (i > 0 &&  i < fileName.length() - 1) {
                    extension = fileName.substring(i+1).toLowerCase();
                }
                if (extension != null) {
                    return Arrays.asList(filters).contains(extension);
                }
                return false;
            }

            @Override
            public String getDescription() {
                return filterLabel + Arrays.stream(filters).map(ft -> "*." + ft).collect(Collectors.joining(", ", " (", ")"));
            }
        });
        JButton fileChooserButton = new JButton(null, FOLDER);
        fileChooserButton.setToolTipText(tooltip);
        fileChooserButton.addActionListener(e -> {
            int result = fileChooser.showOpenDialog(panel);
            if (result == JFileChooser.APPROVE_OPTION) {
                String absPath = fileChooser.getSelectedFile().getAbsolutePath();
                pathField.setText(absPath);
                pathField.setToolTipText(absPath);
                actionListener.actionPerformed(new ActionEvent(fileChooser, result, "selected"));
            }
        });
        chooserPanel.add(fileChooserButton, BorderLayout.EAST);
        return panel;
    }

    public static JButton createButton(String label, String tooltip, ButtonClickListener listener) {
        JButton button = new JButton(label);
        button.setToolTipText(tooltip);
        button.addActionListener(ev -> listener.clickPerformed(button, ev.getModifiers()));
        return button;
    }

    public static JButton createActionButton(ImageIcon icon, ImageIcon rolloverIcon, String tooltip, ButtonClickListener listener) {
        JButton actionButton = new JButton();
        SwingUtil.removeButtonDecorations(actionButton);
        actionButton.setPreferredSize(new Dimension(16, 16));
        actionButton.setIcon(icon);
        actionButton.setRolloverIcon(rolloverIcon);
        actionButton.setToolTipText(tooltip);
        actionButton.addActionListener(ev -> listener.clickPerformed(actionButton, ev.getModifiers()));
        return actionButton;
    }

    public interface ButtonClickListener {
        void clickPerformed(JButton button, int modifiers);
    }

    public interface OnRemove {
        void elementRemoved(JComponent removed);
    }

    public static JButton createToggleActionButton(ImageIcon onIcon, ImageIcon onRolloverIcon, ImageIcon offIcon, ImageIcon offRolloverIcon, String onTooltip, String offTooltip, boolean initialValue, ButtonClickListener listener) {
        JButton actionButton = createActionButton(offIcon, offRolloverIcon, offTooltip, (btn, modifiers) -> {
            btn.setSelected(!btn.isSelected());
            listener.clickPerformed(btn, modifiers);
        });
        SwingUtil.addModalTooltip(actionButton, onTooltip, offTooltip);
        actionButton.setSelectedIcon(onIcon);
        actionButton.setRolloverSelectedIcon(onRolloverIcon);
        actionButton.setSelected(initialValue);
        return actionButton;
    }

    public static JCheckBox createCheckbox(String name, String tooltip, boolean initialValue, Consumer<Boolean> onChange) {
        JCheckBox checkbox = new JCheckBox(name, initialValue);
        checkbox.setToolTipText(tooltip);
        checkbox.addItemListener(ev -> {
            onChange.accept(checkbox.isSelected());
        });
        return checkbox;
    }

    public static FlatTextAreaNamespace createTextFieldNamespace(
        String firstPlaceholder,
        String firstTooltip,
        String firstInitialValue,
        String secondPlaceholder,
        String secondTooltip,
        String secondInitialValue,
        BiConsumer<String, String> onChange
    ) {
        FlatTextAreaNamespace flatTextArea = new FlatTextAreaNamespace(firstPlaceholder, ":", secondPlaceholder, true);
        flatTextArea.getPrefixTextArea().setToolTipText(firstTooltip);
        flatTextArea.getTextArea().setToolTipText(secondTooltip);
        flatTextArea.getPrefixTextArea().setText(firstInitialValue);
        flatTextArea.getTextArea().setText(secondInitialValue);
        ((AbstractDocument) flatTextArea.getDocument()).setDocumentFilter(new LengthLimitFilter(4096));
        flatTextArea.getDocument().addDocumentListener((SimpleDocumentListener) ev -> {
            onChange.accept(flatTextArea.getPrefixTextArea().getText(), flatTextArea.getTextArea().getText());
        });
        flatTextArea.getPrefixTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                flatTextArea.getPrefixTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChange.accept(flatTextArea.getPrefixTextArea().getText(), flatTextArea.getTextArea().getText());
            }
        });
        flatTextArea.getTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                flatTextArea.getTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChange.accept(flatTextArea.getPrefixTextArea().getText(), flatTextArea.getTextArea().getText());
            }
        });
        return flatTextArea;
    }

    public static FlatTextArea createTextField(String placeholder, String tooltip, String initialValue, Consumer<String> onChange) {
        FlatTextArea flatTextArea = new FlatTextArea(placeholder, true);
        flatTextArea.setText(initialValue);
        flatTextArea.getTextArea().setToolTipText(tooltip);
        ((AbstractDocument) flatTextArea.getDocument()).setDocumentFilter(new LengthLimitFilter(4096));
        flatTextArea.getDocument().addDocumentListener((SimpleDocumentListener) ev -> {
            onChange.accept(flatTextArea.getText());
        });
        flatTextArea.getTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                flatTextArea.getTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChange.accept(flatTextArea.getText());
            }
        });
        return flatTextArea;
    }

    public static FlatTextArea createTextArea(String placeholder, String tooltip, String initialValue, Consumer<String> onChange) {
        FlatTextArea textArea = new FlatTextArea(placeholder, false);
        textArea.setText(initialValue);
        textArea.setToolTipText(tooltip);
//        textArea.setSelectedTextColor(Color.WHITE);
//        textArea.setSelectionColor(ColorScheme.BRAND_ORANGE_TRANSPARENT);
//        textArea.setLineWrap(true);
//        textArea.setWrapStyleWord(true);
//        textArea.setMargin(new Insets(4, 6, 5, 6));
        textArea.getTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                textArea.getTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChange.accept(textArea.getText());
            }
        });

        return textArea;
    }

    public static JSpinner createSpinner(int initialValue, int min, int max, int step, Consumer<Integer> onChange) {
        int value = Math.min(Math.max(min, initialValue), max);
        JSpinner spinner = new JSpinner(new SpinnerNumberModel(value, min, max, step));
        spinner.addChangeListener(e -> {
            onChange.accept((Integer) spinner.getValue());
        });
        JFormattedTextField spinnerText = (JFormattedTextField) spinner.getEditor().getComponent(0);
        spinnerText.setSelectedTextColor(Color.WHITE);
        spinnerText.setSelectionColor(ColorScheme.BRAND_ORANGE_TRANSPARENT);

        return spinner;
    }

    public static ColorJButton createColorPicker(String placeholder, String tooltip, String windowTitle, Component parentComponent, Color initialValue, ColorPickerManager colorPickerManager, boolean showAlpha, Consumer<Color> onChange) {
        ColorJButton colorPickerBtn = new ColorJButton(placeholder, Color.BLACK);
        if (initialValue != null) {
            String colorHex = "#" + (showAlpha ? ColorUtil.colorToAlphaHexCode(initialValue) : ColorUtil.colorToHexCode(initialValue)).toUpperCase();
            colorPickerBtn.setText(colorHex);
            colorPickerBtn.setColor(initialValue);
        }
        colorPickerBtn.setToolTipText(tooltip);
        colorPickerBtn.setFocusable(false);
        colorPickerBtn.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getButton() == MouseEvent.BUTTON3) {
                    colorPickerBtn.setColor(Color.BLACK);
                    colorPickerBtn.setText(placeholder);
                    onChange.accept(null);
                    return;
                }
                RuneliteColorPicker colorPicker = colorPickerManager.create(
                    SwingUtilities.getWindowAncestor(colorPickerBtn),
                    colorPickerBtn.getColor(),
                    windowTitle,
                    !showAlpha);
                colorPicker.setLocation(parentComponent.getLocationOnScreen());
                colorPicker.setOnColorChange(c -> {
                    colorPickerBtn.setColor(c);
                    colorPickerBtn.setText("#" + (showAlpha ? ColorUtil.colorToAlphaHexCode(c) : ColorUtil.colorToHexCode(c)).toUpperCase());
                });
                colorPicker.setOnClose(onChange);
                colorPicker.setVisible(true);
            }
        });

        return colorPickerBtn;
    }

    public static <T extends Enum<T>> JComboBox<T> createSelect(T[] items, T initialValue, Consumer<T> onChange) {
        JComboBox<T> select = new JComboBox<>(items);
        select.setSelectedItem(initialValue);
        select.setRenderer((list, value, index, isSelected, cellHasFocus) -> {
            if (value instanceof Displayable) {
                list.setToolTipText(((Displayable) value).getTooltip());
                return new DefaultListCellRenderer().getListCellRendererComponent(list, ((Displayable) value).getName(), index, isSelected, cellHasFocus);
            }
            String titleized = value == null ? "null" : WordUtils.capitalizeFully(value.name());
            list.setToolTipText(titleized);
            return new DefaultListCellRenderer().getListCellRendererComponent(list, titleized, index, isSelected, cellHasFocus);
        });
        select.addActionListener(e -> {
            onChange.accept(select.getItemAt(select.getSelectedIndex()));
        });

        return select;
    }

    public static <T> JComboBox<T> createSelect(T[] items, T initialValue, @Nullable Function<T, String> onRender, Consumer<T> onChange) {
        JComboBox<T> select = new JComboBox<>(items);
        select.setSelectedItem(initialValue);
        select.setRenderer((list, value, index, isSelected, cellHasFocus) -> {
            if (onRender != null) {
                String title = value == null ? "Loading..." : onRender.apply(value);
                return new DefaultListCellRenderer().getListCellRendererComponent(list, title, index, isSelected, cellHasFocus);
            }

            if (value instanceof Displayable) {
                list.setToolTipText(((Displayable) value).getTooltip());
                return new DefaultListCellRenderer().getListCellRendererComponent(list, ((Displayable) value).getName(), index, isSelected, cellHasFocus);
            }
            String titleized = value == null ? "null" : WordUtils.capitalizeFully(value.toString());
            list.setToolTipText(titleized);
            return new DefaultListCellRenderer().getListCellRendererComponent(list, titleized, index, isSelected, cellHasFocus);
        });
        select.addActionListener(e -> {
            onChange.accept(select.getItemAt(select.getSelectedIndex()));
        });

        return select;
    }

    public static boolean isPatternValid(Component parent, String pattern, boolean isRegex) {
        try {
            Pattern.compile(isRegex ? pattern : Util.createRegexFromGlob(pattern));
            return true;
        } catch (PatternSyntaxException ex) {
            JLabel errorLabel = new JLabel("<html>" + ex.getMessage().replaceAll("\n", "<br/>").replaceAll(" ", "&nbsp;") + "</html>");
            errorLabel.setFont(new Font("Monospaced", Font.PLAIN, 12));
            JOptionPane.showMessageDialog(parent, errorLabel, "Error in regex/pattern", JOptionPane.ERROR_MESSAGE);
            return false;
        }
    }

    public static JButton createAlertDropDownButton(Consumer<Alert> onCreate) {
        ActionListener actionListener = e -> {
            JMenuItem menuItem = (JMenuItem) e.getSource();
            TriggerType tType = (TriggerType) menuItem.getClientProperty(TriggerType.class);
            Alert createdAlert = WatchdogPlugin.getInstance().getInjector().getInstance(tType.getImplClass());
            onCreate.accept(createdAlert);
        };

        JPopupMenu popupMenu = new JPopupMenu();
        JMenuItem alertGroupMenuItem = new JMenuItem(TriggerType.ALERT_GROUP.getName());
        alertGroupMenuItem.setToolTipText(TriggerType.ALERT_GROUP.getTooltip());
        alertGroupMenuItem.putClientProperty(TriggerType.class, TriggerType.ALERT_GROUP);
        alertGroupMenuItem.addActionListener(actionListener);
        popupMenu.add(alertGroupMenuItem);
        popupMenu.addSeparator();
        Arrays.stream(TriggerType.values())
            .filter(tType -> tType != TriggerType.ALERT_GROUP)
            .forEach(tType -> {
                JMenuItem c = new JMenuItem(tType.getName());
                c.setToolTipText(tType.getTooltip());
                c.putClientProperty(TriggerType.class, tType);
                c.addActionListener(actionListener);
                popupMenu.add(c);
            });
        JButton addDropDownButton = DropDownButtonFactory.createDropDownButton(Icons.ADD, popupMenu);
        addDropDownButton.setPreferredSize(new Dimension(40, addDropDownButton.getPreferredSize().height));
        addDropDownButton.setToolTipText("Create New Alert");
        return addDropDownButton;
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogMuxer;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.notifications.IMessageNotification;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.SearchBar;
import com.adamk33n3r.runelite.watchdog.ui.StretchedStackedLayout;

import net.runelite.client.ui.PluginPanel;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Provider;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Slf4j
@Singleton
public class HistoryPanel extends PluginPanel {
    private final Provider<WatchdogMuxer> muxer;
    private final ScrollablePanel historyItems;
    private final List<HistoryEntryPanel> previousAlerts = new ArrayList<>();
    private final JLabel noHistory;

    private static final int MAX_HISTORY_ITEMS = 100;

    @Inject
    public HistoryPanel(Provider<WatchdogMuxer> muxer) {
        super(false);
        this.muxer = muxer;

        this.setLayout(new BorderLayout());

        JPanel topPanel = new JPanel(new BorderLayout(0, 5));
        topPanel.setBorder(new EmptyBorder(0, 0, 5, 0));
        JButton backButton = PanelUtils.createActionButton(
            Icons.BACK,
            Icons.BACK_HOVER,
            "Back",
            (btn, modifiers) -> this.muxer.get().popState()
        );
        backButton.setPreferredSize(new Dimension(22, 16));
        backButton.setBorder(new EmptyBorder(0, 0, 0, 5));
        topPanel.add(backButton, BorderLayout.WEST);
        topPanel.add(new SearchBar(this::updateFilter));
        this.noHistory = new JLabel("No history items");
        this.noHistory.setHorizontalAlignment(SwingConstants.CENTER);
        topPanel.add(this.noHistory, BorderLayout.SOUTH);
        this.add(topPanel, BorderLayout.NORTH);

        this.historyItems = new ScrollablePanel(new StretchedStackedLayout(3));
        this.historyItems.setBorder(new EmptyBorder(0, 10, 0, 10));
        this.historyItems.setScrollableWidth(ScrollablePanel.ScrollableSizeHint.FIT);
        this.historyItems.setScrollableHeight(ScrollablePanel.ScrollableSizeHint.STRETCH);
        this.historyItems.setScrollableBlockIncrement(ScrollablePanel.VERTICAL, ScrollablePanel.IncrementType.PERCENT, 10);
        JScrollPane scroll = new JScrollPane(this.historyItems, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

        this.add(scroll, BorderLayout.CENTER);
    }

    public void addEntry(Alert alert, String[] triggerValues) {
        this.noHistory.setVisible(false);
        HistoryEntryPanel historyEntryPanel = new HistoryEntryPanel(alert, triggerValues);
        this.previousAlerts.add(0, historyEntryPanel);
        this.historyItems.add(historyEntryPanel, 0);
        if (this.historyItems.getComponents().length > MAX_HISTORY_ITEMS) {
            this.previousAlerts.remove(this.previousAlerts.size() - 1);
            this.historyItems.remove(this.historyItems.getComponents().length - 1);
        }
        this.revalidate();
        this.repaint();
    }

    // TODO: Abstract this out into a filterpanel type thing
    private void updateFilter(String search) {
        this.historyItems.removeAll();
        this.previousAlerts.stream().filter(historyEntryPanel -> {
            Alert alert = historyEntryPanel.getAlert();
            Stream<String> keywords = Stream.concat(Stream.of(
                alert.getName(),
                alert.getType().getName()
            ), alert.getNotifications().stream().flatMap(notification -> {
                Stream<String> notificationType = Stream.of(notification.getType().getName());
                if (notification instanceof IMessageNotification) {
                    return Stream.concat(notificationType, Stream.of(((IMessageNotification) notification).getMessage()));
                }
                return notificationType;
            }));
            return Util.searchText(search, keywords.collect(Collectors.toList()));
        }).forEach(this.historyItems::add);
        this.revalidate();
        // Idk why I need to repaint sometimes and the PluginListPanel doesn't
        this.repaint();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import com.adamk33n3r.runelite.watchdog.*;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.notifications.*;
import com.adamk33n3r.runelite.watchdog.notifications.Popup;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.StretchedStackedLayout;
import com.adamk33n3r.runelite.watchdog.ui.dropdownbutton.DropDownButtonFactory;
import com.adamk33n3r.runelite.watchdog.ui.notifications.panels.PluginMessageNotificationPanel;
import com.adamk33n3r.runelite.watchdog.ui.notifications.panels.*;

import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.components.DragAndDropReorderPane;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

import com.google.inject.Injector;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionListener;
import java.util.Arrays;
import java.util.Comparator;

@Slf4j
public class NotificationsPanel extends JPanel {
    private Alert alert;

    @Inject
    private ColorPickerManager colorPickerManager;

    @Inject
    private ConfigManager configManager;

    @Inject
    private WatchdogConfig config;

    @Inject
    private AlertManager alertManager;

    @Getter
    private final DragAndDropReorderPane notificationContainer;

    public NotificationsPanel() {
        this.setLayout(new BorderLayout(0, 5));
        this.notificationContainer = new DragAndDropReorderPane();
        this.notificationContainer.addDragListener((c) -> {
            int pos = this.notificationContainer.getPosition(c);
            NotificationPanel notificationPanel = (NotificationPanel) c;
            Notification notification = notificationPanel.getNotification();
//            log.debug("drag listener: " + notification.getType().getName() + " to " + pos);
            notification.getAlert().moveNotificationTo(notification, pos);
            this.alertManager.saveAlerts();
        });
    }

    public void init(Alert alert) {
        this.alert = alert;

        JPopupMenu popupMenu = new JPopupMenu();
        ActionListener actionListener = e -> {
            JMenuItem menuItem = (JMenuItem) e.getSource();
            NotificationType nType = (NotificationType) menuItem.getClientProperty(NotificationType.class);
            this.addPanel(this.createNotification(nType));
            this.notificationContainer.revalidate();
            this.alertManager.saveAlerts();
        };

        if (this.config.enableNotificationCategories()) {
            Arrays.stream(NotificationCategory.values()).forEach(cat -> {
                JMenu subMenu = new JMenu(cat.getName());
                subMenu.setToolTipText(cat.getTooltip());
                popupMenu.add(subMenu);
                popupMenu.putClientProperty(cat.name(), subMenu);
            });
        }
        Arrays.stream(NotificationType.values()).sorted(Comparator.comparing(NotificationType::getName)).forEach(nType -> {
            JMenuItem c = new JMenuItem(nType.getName());
            c.setToolTipText(nType.getTooltip());
            c.putClientProperty(NotificationType.class, nType);
            c.addActionListener(actionListener);
            if (this.config.enableNotificationCategories()) {
                JMenu subMenu = (JMenu) popupMenu.getClientProperty(nType.getCategory().name());
                subMenu.add(c);
            } else {
                popupMenu.add(c);
            }
        });
        JButton addDropDownButton = DropDownButtonFactory.createDropDownButton(Icons.ADD, popupMenu);
        addDropDownButton.setPreferredSize(new Dimension(40, addDropDownButton.getPreferredSize().height));
        addDropDownButton.setToolTipText("Create New Notification");
        JPanel headerPanel = new JPanel(new BorderLayout());
        JPanel leftPanel = new JPanel(new DynamicGridLayout(1, 0, 5, 5));
        headerPanel.add(leftPanel, BorderLayout.WEST);
        leftPanel.add(new JLabel("Notifications"));
        JButton randomBtn = PanelUtils.createToggleActionButton(
            Icons.DICE_MULTIPLE,
            Icons.DICE_MULTIPLE_HOVER,
            Icons.DICE_MULTIPLE_OFF,
            Icons.DICE_MULTIPLE_OFF_HOVER,
            "Fire all notifications in sequence",
            "Fire a random notification",
            alert.isRandomNotifications(),
            (btn, mods) -> {
                alert.setRandomNotifications(!alert.isRandomNotifications());
                this.alertManager.saveAlerts();
            }
        );
        leftPanel.add(randomBtn);
        JPanel buttonPanel = new JPanel(new DynamicGridLayout(1, 0));
        buttonPanel.add(addDropDownButton);
        headerPanel.add(buttonPanel, BorderLayout.EAST);
        headerPanel.setBorder(new EmptyBorder(0, 5, 0, 0));

        this.add(headerPanel, BorderLayout.NORTH);

        ScrollablePanel scrollablePanel = new ScrollablePanel(new StretchedStackedLayout(3));
        scrollablePanel.setScrollableWidth(ScrollablePanel.ScrollableSizeHint.FIT);
        scrollablePanel.setScrollableHeight(ScrollablePanel.ScrollableSizeHint.STRETCH);
        scrollablePanel.setScrollableBlockIncrement(ScrollablePanel.VERTICAL, ScrollablePanel.IncrementType.PERCENT, 10);
        scrollablePanel.add(this.notificationContainer);
        JScrollPane scrollPane = new JScrollPane(scrollablePanel, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        this.add(scrollPane, BorderLayout.CENTER);

        for (Notification notification : this.alert.getNotifications()) {
            this.addPanel(notification);
        }
    }

    private void addPanel(Notification notification) {
        PanelUtils.OnRemove removeNotification = (removedPanel) -> {
            this.alert.getNotifications().remove(notification);
            this.notificationContainer.remove(removedPanel);
            this.notificationContainer.revalidate();
            this.alertManager.saveAlerts();
        };

        NotificationPanel notificationPanel = null;
        if (notification instanceof GameMessage) {
            notificationPanel = new MessageNotificationPanel((GameMessage) notification, true, this, this.alertManager::saveAlerts, removeNotification);
        } else if (notification instanceof TextToSpeech)
            notificationPanel = new TextToSpeechNotificationPanel((TextToSpeech) notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof Sound)
            notificationPanel = new SoundNotificationPanel((Sound)notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof SoundEffect)
            notificationPanel = new SoundEffectNotificationPanel((SoundEffect)notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof TrayNotification)
            notificationPanel = new MessageNotificationPanel((TrayNotification)notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof ScreenFlash)
            notificationPanel = new ScreenFlashNotificationPanel((ScreenFlash) notification, this, this.colorPickerManager, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof Overhead)
            notificationPanel = new OverheadNotificationPanel((Overhead) notification, this, this.colorPickerManager, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof Overlay)
            notificationPanel = new OverlayNotificationPanel((Overlay) notification, this, this.colorPickerManager, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof Popup)
            notificationPanel = new PopupNotificationPanel((Popup) notification, this, this.colorPickerManager, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof RequestFocus)
            notificationPanel = new RequestFocusNotificationPanel((RequestFocus) notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof NotificationEvent)
            notificationPanel = new MessageNotificationPanel((NotificationEvent) notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof DismissOverlay)
            notificationPanel = new DismissOverlayNotificationPanel((DismissOverlay) notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof DismissScreenMarker)
            notificationPanel = new DismissScreenMarkerNotificationPanel((DismissScreenMarker) notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof ScreenMarker)
            notificationPanel = new ScreenMarkerNotificationPanel((ScreenMarker) notification, this, this.colorPickerManager, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof Dink)
            notificationPanel = new DinkNotificationPanel((Dink) notification, this, this.configManager, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof PluginMessage)
            notificationPanel = new PluginMessageNotificationPanel((PluginMessage) notification, this, this.alertManager::saveAlerts, removeNotification);

        if (notificationPanel != null)
            this.notificationContainer.add(notificationPanel);
    }

    private Notification createNotification(NotificationType notificationType) {
        Injector injector = WatchdogPlugin.getInstance().getInjector();
        Notification notification = injector.getInstance(notificationType.getImplClass());
        notification.setAlert(this.alert);
        this.alert.getNotifications().add(notification);
        return notification;
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import com.adamk33n3r.runelite.watchdog.AlertManager;
import com.adamk33n3r.runelite.watchdog.TriggerType;
import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.alerts.AlertGroup;
import com.adamk33n3r.runelite.watchdog.ui.*;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.components.DragAndDropReorderPane;

import com.google.common.base.Splitter;
import lombok.Getter;

import javax.annotation.Nullable;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class AlertListPanel extends JPanel {
    private String filterText = "";
    private static final Splitter SPLITTER = Splitter.on(" ").trimResults().omitEmptyStrings();
    private final List<AlertListItem> alertListItems = new ArrayList<>();
    private final DragAndDropReorderPane dragAndDropReorderPane = new DragAndDropReorderPane();
    @Getter
    private final JScrollPane scrollPane;
    private boolean selectMode = false;
    private final AlertManager alertManager;
    private final Runnable onChange;
    private final List<Alert> alerts;
    private final AlertGroup parent;

    public AlertListPanel(List<Alert> alerts, @Nullable AlertGroup parent, Runnable onChange) {
        this.alerts = alerts;
        this.parent = parent;
        this.onChange = onChange;
        this.alertManager = WatchdogPlugin.getInstance().getAlertManager();
        this.dragAndDropReorderPane.setBackground(ColorScheme.GRAND_EXCHANGE_LIMIT);
        this.dragAndDropReorderPane.addDragListener((c) -> {
            int pos = this.dragAndDropReorderPane.getPosition(c);
            AlertListItem alertListItem = (AlertListItem) c;
            this.alertManager.moveAlertTo(alertListItem.getAlert(), pos);
        });

        this.setLayout(new BorderLayout());

        ScrollablePanel scrollablePanel = new ScrollablePanel(new StretchedStackedLayout(3));
        scrollablePanel.setScrollableWidth(ScrollablePanel.ScrollableSizeHint.FIT);
        scrollablePanel.setScrollableHeight(ScrollablePanel.ScrollableSizeHint.STRETCH);
        scrollablePanel.setScrollableBlockIncrement(ScrollablePanel.VERTICAL, ScrollablePanel.IncrementType.PERCENT, 10);
        scrollablePanel.add(this.dragAndDropReorderPane);
        this.scrollPane = new JScrollPane(scrollablePanel, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);

        this.rebuild();
    }

    private void rebuild() {
        this.removeAll();
        this.dragAndDropReorderPane.removeAll();

        SearchBar searchBar = new SearchBar(this::filter);
        Arrays.stream(TriggerType.values()).map(TriggerType::getName).forEach(searchBar.getSuggestionListModel()::addElement);
        JPanel searchWrapper = new JPanel(new BorderLayout());
        searchWrapper.add(searchBar);
        SwingUtilities.invokeLater(() -> {
            searchWrapper.setBorder(new EmptyBorder(0, 0, 2, this.scrollPane.getVerticalScrollBar().isVisible() ? 7 : 0));
        });
        this.add(searchWrapper, BorderLayout.NORTH);
        this.add(this.scrollPane, BorderLayout.CENTER);

        final JPanel multiSelect = new JPanel(new BorderLayout());
        multiSelect.setPreferredSize(new Dimension(0, 25));
        multiSelect.setBorder(new EmptyBorder(0, 10, 0, 0));
        final JPanel toggleGroup = new JPanel(new DynamicGridLayout(1, 2, 3, 3));
        toggleGroup.setBorder(new EmptyBorder(4, 0, 0, 0));
        final ToggleButton selectModeToggle = new ToggleButton("Disable Select Mode", "Enable Select Mode");
        selectModeToggle.setSelected(this.selectMode);
        selectModeToggle.addItemListener((i) -> {
            this.selectMode = selectModeToggle.isSelected();
            // Unselect all alerts when leaving select mode
            if (!this.selectMode) {
                this.alertListItems.forEach((ali) -> ali.setSelected(false));
            }
            this.rebuild();
        });
        toggleGroup.add(selectModeToggle);
        JLabel selectModeLabel = new JLabel("Select Mode");
        selectModeLabel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                selectModeToggle.setSelected(!selectModeToggle.isSelected());
                AlertListPanel.this.revalidate();
            }
        });
        toggleGroup.add(selectModeLabel);
        multiSelect.add(toggleGroup, BorderLayout.WEST);

        final JPanel multiSelectActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 3, 0));
        multiSelectActions.setBorder(new EmptyBorder(6, 0, 0, 0));
        multiSelectActions.add(PanelUtils.createActionButton(Icons.IMPORT, Icons.IMPORT_HOVER, "Move selected Alerts to new Alert Group", (btn, modifiers) -> {
            long count = this.alertListItems.stream()
                .filter(AlertListItem::isSelected)
                .count();
            if (count == 0) {
                return;
            }
            AlertGroup group = this.alertManager.createAlert(AlertGroup.class);
            if (this.parent == null) {
                this.alertManager.addAlert(group, false);
            } else {
                this.parent.getAlerts().add(group);
            }
            this.alertListItems.stream()
                .filter(AlertListItem::isSelected)
                .forEach((ali) -> {
                    this.alertManager.removeAlert(ali.getAlert(), false);
                    group.getAlerts().add(ali.getAlert());
                });
            WatchdogPlugin.getInstance().getPanel().openAlert(group);
        })).setEnabled(this.selectMode);
        if (this.parent != null) {
            multiSelectActions.add(PanelUtils.createActionButton(Icons.BACK, Icons.BACK_HOVER, "Move selected Alerts back a level", (btn, modifiers) -> {
                long count = this.alertListItems.stream()
                    .filter(AlertListItem::isSelected)
                    .count();
                if (count == 0) {
                    return;
                }
                AlertGroup alertGroupParent = this.parent.getParent();
                this.alertListItems.stream()
                    .filter(AlertListItem::isSelected)
                    .forEach((ali) -> {
                        this.alertManager.removeAlert(ali.getAlert(), false);
                        if (alertGroupParent == null) {
                            this.alertManager.addAlert(ali.getAlert(), false);
                        } else {
                            alertGroupParent.getAlerts().add(ali.getAlert());
                        }
                    });
                WatchdogPlugin.getInstance().getPanel().getMuxer().popState();
            })).setEnabled(this.selectMode);
        }
        multiSelectActions.add(PanelUtils.createActionButton(Icons.EXPORT, Icons.EXPORT_HOVER, "Export selected Alerts", (btn, modifiers) -> {
            List<Alert> selectedAlerts = this.alertListItems.stream()
                .filter(AlertListItem::isSelected)
                .map(AlertListItem::getAlert)
                .collect(Collectors.toList());
            if (selectedAlerts.isEmpty()) {
                return;
            }
            ImportExportDialog importExportDialog = new ImportExportDialog(SwingUtilities.getWindowAncestor(this), selectedAlerts);
            importExportDialog.setVisible(true);
        })).setEnabled(this.selectMode);
        multiSelectActions.add(PanelUtils.createActionButton(Icons.DELETE, Icons.DELETE_HOVER, "Delete selected Alerts", (btn, modifiers) -> {
            long count = this.alertListItems.stream()
                .filter(AlertListItem::isSelected)
                .count();
            if (count == 0) {
                return;
            }
            int result = JOptionPane.showConfirmDialog(this, "Are you sure you want to delete the " + count + " selected alerts?", "Delete?", JOptionPane.YES_NO_OPTION, JOptionPane.ERROR_MESSAGE);
            if (result == JOptionPane.YES_OPTION) {
                this.alertListItems.stream()
                    .filter(AlertListItem::isSelected)
                    .forEach((ali) -> this.alertManager.removeAlert(ali.getAlert()));
                onChange.run();
            }
        })).setEnabled(this.selectMode);
        multiSelect.add(multiSelectActions, BorderLayout.EAST);
        searchWrapper.add(multiSelect, BorderLayout.SOUTH);

        this.alerts.stream()
            .map(alert -> new AlertListItem(WatchdogPlugin.getInstance().getPanel(), this.alertManager, alert, this.dragAndDropReorderPane, onChange))
            .forEach(alertListItem -> {
                alertListItem.setSelectMode(this.selectMode);
                this.alertListItems.add(alertListItem);
                this.dragAndDropReorderPane.add(alertListItem);
            });
    }

    private void filter(String text) {
        this.filterText = text;
        this.dragAndDropReorderPane.removeAll();
        this.alertListItems.stream()
            .filter(alertListItem -> Util.searchText(this.filterText, alertListItem.getAlert().getKeywords()))
            .forEach(this.dragAndDropReorderPane::add);
        this.revalidate();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.notifications.MessageNotification;

import net.runelite.client.ui.DynamicGridLayout;

import lombok.Getter;

import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.border.EtchedBorder;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;

public class HistoryEntryPanel extends JPanel {
    @Getter
    private final Alert alert;

    public HistoryEntryPanel(Alert alert, String[] triggerValues) {
        super(new DynamicGridLayout(0, 1, 3, 3));
        this.alert = alert;
        this.setBorder(new EtchedBorder());

        JLabel alertType = new JLabel(alert.getType().getName());
        this.add(alertType);
        JLabel alertName = new JLabel(alert.getName());
        this.add(alertName);
        alert.getNotifications().stream()
            .filter(notification -> notification instanceof MessageNotification)
            .map(notification -> (MessageNotification) notification)
            .forEach(notification -> {
                String message = Util.processTriggerValues(notification.getMessage(), triggerValues);
                JTextArea wrappingTextArea = new JTextArea(notification.getType().getName() + ": " + message);
                wrappingTextArea.setLineWrap(true);
                wrappingTextArea.setWrapStyleWord(true);
                wrappingTextArea.setOpaque(false);
                wrappingTextArea.setEditable(false);
                wrappingTextArea.setFocusable(false);
                this.add(wrappingTextArea);
            });
        String formattedTime = DateTimeFormatter.ofPattern("HH:mm:ss").withZone(ZoneId.systemDefault()).format(Instant.now());
        this.add(new JLabel(formattedTime));
    }
}

/**
 *  A panel that implements the Scrollable interface. This class allows you
 *  to customize the scrollable features by using newly provided setter methods
 *  so you don't have to extend this class every time.
 *
 *  Scrollable amounts can be specifed as a percentage of the viewport size or
 *  as an actual pixel value. The amount can be changed for both unit and block
 *  scrolling for both horizontal and vertical scrollbars.
 *
 *  The Scrollable interface only provides a boolean value for determining whether
 *  or not the viewport size (width or height) should be used by the scrollpane
 *  when determining if scrollbars should be made visible. This class supports the
 *  concept of dynamically changing this value based on the size of the viewport.
 *  In this case the viewport size will only be used when it is larger than the
 *  panels size. This has the effect of ensuring the viewport is always full as
 *  components added to the panel will be size to fill the area available,
 *  based on the rules of the applicable layout manager of course.
 */
package com.adamk33n3r.runelite.watchdog.ui.panels;

import javax.swing.JPanel;
import javax.swing.JViewport;
import javax.swing.Scrollable;
import javax.swing.SwingConstants;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.LayoutManager;
import java.awt.Rectangle;

public class ScrollablePanel extends JPanel
    implements Scrollable, SwingConstants
{
    public enum ScrollableSizeHint
    {
        NONE,
        FIT,
        STRETCH;
    }

    public enum IncrementType
    {
        PERCENT,
        PIXELS;
    }

    private ScrollableSizeHint scrollableHeight = ScrollableSizeHint.NONE;
    private ScrollableSizeHint scrollableWidth  = ScrollableSizeHint.NONE;

    private IncrementInfo horizontalBlock;
    private IncrementInfo horizontalUnit;
    private IncrementInfo verticalBlock;
    private IncrementInfo verticalUnit;

    /**
     *  Default constructor that uses a FlowLayout
     */
    public ScrollablePanel()
    {
        this( new FlowLayout() );
    }

    /**
     *  Constuctor for specifying the LayoutManager of the panel.
     *
     *  @param layout the LayountManger for the panel
     */
    public ScrollablePanel(LayoutManager layout)
    {
        super( layout );

        IncrementInfo block = new IncrementInfo(IncrementType.PERCENT, 100);
        IncrementInfo unit = new IncrementInfo(IncrementType.PERCENT, 10);

        setScrollableBlockIncrement(HORIZONTAL, block);
        setScrollableBlockIncrement(VERTICAL, block);
        setScrollableUnitIncrement(HORIZONTAL, unit);
        setScrollableUnitIncrement(VERTICAL, unit);
    }

    /**
     *  Get the height ScrollableSizeHint enum
     *
     *  @return the ScrollableSizeHint enum for the height
     */
    public ScrollableSizeHint getScrollableHeight()
    {
        return scrollableHeight;
    }

    /**
     *  Set the ScrollableSizeHint enum for the height. The enum is used to
     *  determine the boolean value that is returned by the
     *  getScrollableTracksViewportHeight() method. The valid values are:
     *
     *  ScrollableSizeHint.NONE - return "false", which causes the height
     *      of the panel to be used when laying out the children
     *  ScrollableSizeHint.FIT - return "true", which causes the height of
     *      the viewport to be used when laying out the children
     *  ScrollableSizeHint.STRETCH - return "true" when the viewport height
     *      is greater than the height of the panel, "false" otherwise.
     *
     *  @param scrollableHeight as represented by the ScrollableSizeHint enum.
     */
    public void setScrollableHeight(ScrollableSizeHint scrollableHeight)
    {
        this.scrollableHeight = scrollableHeight;
        revalidate();
    }

    /**
     *  Get the width ScrollableSizeHint enum
     *
     *  @return the ScrollableSizeHint enum for the width
     */
    public ScrollableSizeHint getScrollableWidth()
    {
        return scrollableWidth;
    }

    /**
     *  Set the ScrollableSizeHint enum for the width. The enum is used to
     *  determine the boolean value that is returned by the
     *  getScrollableTracksViewportWidth() method. The valid values are:
     *
     *  ScrollableSizeHint.NONE - return "false", which causes the width
     *      of the panel to be used when laying out the children
     *  ScrollableSizeHint.FIT - return "true", which causes the width of
     *      the viewport to be used when laying out the children
     *  ScrollableSizeHint.STRETCH - return "true" when the viewport width
     *      is greater than the width of the panel, "false" otherwise.
     *
     *  @param scrollableWidth as represented by the ScrollableSizeHint enum.
     */
    public void setScrollableWidth(ScrollableSizeHint scrollableWidth)
    {
        this.scrollableWidth = scrollableWidth;
        revalidate();
    }

    /**
     *  Get the block IncrementInfo for the specified orientation
     *
     *  @return the block IncrementInfo for the specified orientation
     */
    public IncrementInfo getScrollableBlockIncrement(int orientation)
    {
        return orientation == SwingConstants.HORIZONTAL ? horizontalBlock : verticalBlock;
    }

    /**
     *  Specify the information needed to do block scrolling.
     *
     *  @param orientation  specify the scrolling orientation. Must be either:
     *      SwingContants.HORIZONTAL or SwingContants.VERTICAL.
     *  @paran type  specify how the amount parameter in the calculation of
     *      the scrollable amount. Valid values are:
     *		IncrementType.PERCENT - treat the amount as a % of the viewport size
     *      IncrementType.PIXEL - treat the amount as the scrollable amount
     *  @param amount  a value used with the IncrementType to determine the
     *      scrollable amount
     */
    public void setScrollableBlockIncrement(int orientation, IncrementType type, int amount)
    {
        IncrementInfo info = new IncrementInfo(type, amount);
        setScrollableBlockIncrement(orientation, info);
    }

    /**
     *  Specify the information needed to do block scrolling.
     *
     *  @param orientation  specify the scrolling orientation. Must be either:
     *      SwingContants.HORIZONTAL or SwingContants.VERTICAL.
     *  @param info  An IncrementInfo object containing information of how to
     *      calculate the scrollable amount.
     */
    public void setScrollableBlockIncrement(int orientation, IncrementInfo info)
    {
        switch(orientation)
        {
            case SwingConstants.HORIZONTAL:
                horizontalBlock = info;
                break;
            case SwingConstants.VERTICAL:
                verticalBlock = info;
                break;
            default:
                throw new IllegalArgumentException("Invalid orientation: " + orientation);
        }
    }

    /**
     *  Get the unit IncrementInfo for the specified orientation
     *
     *  @return the unit IncrementInfo for the specified orientation
     */
    public IncrementInfo getScrollableUnitIncrement(int orientation)
    {
        return orientation == SwingConstants.HORIZONTAL ? horizontalUnit : verticalUnit;
    }

    /**
     *  Specify the information needed to do unit scrolling.
     *
     *  @param orientation  specify the scrolling orientation. Must be either:
     *      SwingContants.HORIZONTAL or SwingContants.VERTICAL.
     *  @paran type  specify how the amount parameter in the calculation of
     *               the scrollable amount. Valid values are:
     *				 IncrementType.PERCENT - treat the amount as a % of the viewport size
     *               IncrementType.PIXEL - treat the amount as the scrollable amount
     *  @param amount  a value used with the IncrementType to determine the
     *                 scrollable amount
     */
    public void setScrollableUnitIncrement(int orientation, IncrementType type, int amount)
    {
        IncrementInfo info = new IncrementInfo(type, amount);
        setScrollableUnitIncrement(orientation, info);
    }

    /**
     *  Specify the information needed to do unit scrolling.
     *
     *  @param orientation  specify the scrolling orientation. Must be either:
     *      SwingContants.HORIZONTAL or SwingContants.VERTICAL.
     *  @param info  An IncrementInfo object containing information of how to
     *               calculate the scrollable amount.
     */
    public void setScrollableUnitIncrement(int orientation, IncrementInfo info)
    {
        switch(orientation)
        {
            case SwingConstants.HORIZONTAL:
                horizontalUnit = info;
                break;
            case SwingConstants.VERTICAL:
                verticalUnit = info;
                break;
            default:
                throw new IllegalArgumentException("Invalid orientation: " + orientation);
        }
    }

//  Implement Scrollable interface

    public Dimension getPreferredScrollableViewportSize()
    {
        return getPreferredSize();
    }

    public int getScrollableUnitIncrement(
        Rectangle visible, int orientation, int direction)
    {
        switch(orientation)
        {
            case SwingConstants.HORIZONTAL:
                return getScrollableIncrement(horizontalUnit, visible.width);
            case SwingConstants.VERTICAL:
                return getScrollableIncrement(verticalUnit, visible.height);
            default:
                throw new IllegalArgumentException("Invalid orientation: " + orientation);
        }
    }

    public int getScrollableBlockIncrement(
        Rectangle visible, int orientation, int direction)
    {
        switch(orientation)
        {
            case SwingConstants.HORIZONTAL:
                return getScrollableIncrement(horizontalBlock, visible.width);
            case SwingConstants.VERTICAL:
                return getScrollableIncrement(verticalBlock, visible.height);
            default:
                throw new IllegalArgumentException("Invalid orientation: " + orientation);
        }
    }

    protected int getScrollableIncrement(IncrementInfo info, int distance)
    {
        if (info.getIncrement() == IncrementType.PIXELS)
            return info.getAmount();
        else
            return distance * info.getAmount() / 100;
    }

    public boolean getScrollableTracksViewportWidth()
    {
        if (scrollableWidth == ScrollableSizeHint.NONE)
            return false;

        if (scrollableWidth == ScrollableSizeHint.FIT)
            return true;

        //  STRETCH sizing, use the greater of the panel or viewport width

        if (getParent() instanceof JViewport)
        {
            return (((JViewport)getParent()).getWidth() > getPreferredSize().width);
        }

        return false;
    }

    public boolean getScrollableTracksViewportHeight()
    {
        if (scrollableHeight == ScrollableSizeHint.NONE)
            return false;

        if (scrollableHeight == ScrollableSizeHint.FIT)
            return true;

        //  STRETCH sizing, use the greater of the panel or viewport height


        if (getParent() instanceof JViewport)
        {
            return (((JViewport)getParent()).getHeight() > getPreferredSize().height);
        }

        return false;
    }

    /**
     *  Helper class to hold the information required to calculate the scroll amount.
     */
    static class IncrementInfo
    {
        private IncrementType type;
        private int amount;

        public IncrementInfo(IncrementType type, int amount)
        {
            this.type = type;
            this.amount = amount;
        }

        public IncrementType getIncrement()
        {
            return type;
        }

        public int getAmount()
        {
            return amount;
        }

        public String toString()
        {
            return
                "ScrollablePanel[" +
                    type + ", " +
                    amount + "]";
        }
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import com.adamk33n3r.runelite.watchdog.*;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.alerts.AlertGroup;
import com.adamk33n3r.runelite.watchdog.alerts.RegexMatcher;
import com.adamk33n3r.runelite.watchdog.ui.*;

import net.runelite.client.plugins.info.JRichTextPane;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.MultiplexingPluginPanel;
import net.runelite.client.ui.PluginPanel;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.text.WordUtils;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Supplier;

@Slf4j
public abstract class AlertPanel<T extends Alert> extends PluginPanel {
    private final JPanel controlContainer;
    private final JPanel centerContainer;
    protected final WatchdogPanel watchdogPanel;
    protected final MultiplexingPluginPanel muxer;
    protected final T alert;

    private final AlertManager alertManager;

    public AlertPanel(WatchdogPanel watchdogPanel, T alert) {
        super(false);

        this.watchdogPanel = watchdogPanel;
        this.muxer = watchdogPanel.getMuxer();
        this.alert = alert;
        this.alertManager = WatchdogPlugin.getInstance().getAlertManager();

        this.setLayout(new BorderLayout());

        JPanel northPanel = new JPanel(new StretchedStackedLayout(3));
        this.add(northPanel, BorderLayout.NORTH);

        JPanel nameGroup = new JPanel(new BorderLayout());
        nameGroup.setBorder(new EmptyBorder(10, 5, 10, 5));

        TriggerType triggerType = this.alert.getType();
        JLabel nameLabel = new JLabel(triggerType.getName());
        nameLabel.setToolTipText(triggerType.getTooltip());
        nameLabel.setForeground(Color.WHITE);
        nameGroup.add(nameLabel, BorderLayout.CENTER);

        JPanel rightButtons = new JPanel(new GridLayout(1, 0));

        if (alert instanceof AlertGroup) {
            JButton importAlertBtn = PanelUtils.createActionButton(
                Icons.IMPORT,
                Icons.IMPORT_HOVER,
                "Import alert into this group",
                (btn, modifiers) -> {
                    ImportExportDialog importExportDialog = new ImportExportDialog(
                        SwingUtilities.getWindowAncestor(this),
                        (json, append) -> {
                            boolean result = this.alertManager.importAlerts(json, ((AlertGroup) alert).getAlerts(), append, true, WatchdogPlugin.getInstance().getConfig().overrideImportsWithDefaults());
                            // Delay for layout. Without this, it would sometimes make the search/actions narrower.
                            SwingUtilities.invokeLater(this::rebuild);
                            return result;
                        }
                    );
                    importExportDialog.setVisible(true);
                }
            );
            rightButtons.add(importAlertBtn);
        } else {
            JButton testAlert = PanelUtils.createActionButton(
                Icons.TEST,
                Icons.TEST_HOVER,
                "Test the whole alert",
                (btn, modifiers) -> {
                    String[] triggerValues = {"1", "2", "3", "4", "5"};
                    this.watchdogPanel.getHistoryPanelProvider().get().addEntry(alert, triggerValues);
                    new AlertProcessor(alert, triggerValues, true).start();
//                    alert.getNotifications().forEach(notification -> notification.fireForced(triggerValues));
                }
            );
            rightButtons.add(testAlert);
        }

        JButton exportAlertBtn = PanelUtils.createActionButton(
            Icons.EXPORT,
            Icons.EXPORT_HOVER,
            "Export this alert",
            (btn, modifiers) -> {
                ImportExportDialog importExportDialog = new ImportExportDialog(
                    SwingUtilities.getWindowAncestor(this),
                    alert
                );
                importExportDialog.setVisible(true);
            }
        );
        rightButtons.add(exportAlertBtn);

        ToggleButton toggleButton = new ToggleButton();
        toggleButton.setSelected(alert.isEnabled());
        toggleButton.addItemListener(i -> {
            alert.setEnabled(toggleButton.isSelected());
            this.alertManager.saveAlerts();
        });
        rightButtons.add(toggleButton);

        nameGroup.add(rightButtons, BorderLayout.EAST);

        JButton backButton = PanelUtils.createActionButton(
            Icons.BACK,
            Icons.BACK_HOVER,
            "Back",
            (btn, modifiers) -> {
                WatchdogPlugin.getInstance().getScreenMarkerUtil().finishCreation(true);
                this.alertManager.saveAlerts();
                this.muxer.popState();

                // Workaround for the onActivate rebuild issue
                // TODO remove if it ever gets fixed https://github.com/runelite/runelite/issues/17712
                int componentCount = this.muxer.getComponentCount();
                Component component = this.muxer.getComponent(componentCount - 1);
                if (component instanceof AlertPanel) {
                    ((AlertPanel<?>) component).rebuild();
                }
            }
        );
        backButton.setPreferredSize(new Dimension(22, 16));
        backButton.setBorder(new EmptyBorder(0, 0, 0, 5));
        nameGroup.add(backButton, BorderLayout.WEST);

        northPanel.add(nameGroup);

        this.controlContainer = new JPanel(new StretchedStackedLayout(3));
        this.controlContainer.setBorder(new EmptyBorder(0, 5, 0, 5));
        northPanel.add(this.controlContainer);

        this.centerContainer = new JPanel(new BorderLayout());
        this.add(this.centerContainer, BorderLayout.CENTER);
    }

    public AlertPanel<T> addLabel(String label) {
        JLabel labelComp = new JLabel(label);
        this.controlContainer.add(labelComp);
        return this;
    }

    public AlertPanel<T> addRichTextPane(String text) {
        JRichTextPane richTextPane = new JRichTextPane();
        richTextPane.setContentType("text/html");
        richTextPane.setText(text);
        richTextPane.setForeground(Color.WHITE);
        this.controlContainer.add(richTextPane);
        return this;
    }

    public AlertPanel<T> addTextField(String placeholder, String tooltip, String initialValue, Consumer<String> saveAction) {
        PlaceholderTextField textField = new PlaceholderTextField(initialValue);
        textField.setSelectedTextColor(Color.WHITE);
        textField.setSelectionColor(ColorScheme.BRAND_ORANGE_TRANSPARENT);
        textField.setPlaceholder(placeholder);
        textField.setToolTipText(tooltip);
        textField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                textField.selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                saveAction.accept(textField.getText());
                alertManager.saveAlerts();
            }
        });
        this.controlContainer.add(textField);
        return this;
    }

    public AlertPanel<T> addTextArea(String placeholder, String tooltip, String initialValue, Consumer<String> saveAction) {
        FlatTextArea textArea = PanelUtils.createTextArea(placeholder, tooltip, initialValue, val -> {
            saveAction.accept(val);
            this.alertManager.saveAlerts();
        });
        this.controlContainer.add(textArea);
        return this;
    }

    public AlertPanel<T> addSpinner(String name, String tooltip, int initialValue, Consumer<Integer> saveAction) {
        return this.addSpinner(name, tooltip, initialValue, saveAction, 0, Integer.MAX_VALUE, 1);
    }

    public AlertPanel<T> addSpinner(String name, String tooltip, int initialValue, Consumer<Integer> saveAction, int min, int max, int step) {
        JSpinner spinner = PanelUtils.createSpinner(initialValue, min, max, step, val -> {
            saveAction.accept(val);
            this.alertManager.saveAlerts();
        });
        this.controlContainer.add(PanelUtils.createLabeledComponent(name, tooltip, spinner));
        return this;
    }

    public <E extends Enum<E>> AlertPanel<T> addSelect(String name, String tooltip, Class<E> enumType, E initialValue, Consumer<E> saveAction) {
        JComboBox<E> select = new JComboBox<>(enumType.getEnumConstants());
        select.setSelectedItem(initialValue);
        select.setRenderer((list, value, index, isSelected, cellHasFocus) -> {
            if (value instanceof Displayable) {
                list.setToolTipText(((Displayable) value).getTooltip());
                return new DefaultListCellRenderer().getListCellRendererComponent(list, ((Displayable) value).getName(), index, isSelected, cellHasFocus);
            }
            String titleized = WordUtils.capitalizeFully(value.name());
            list.setToolTipText(titleized);
            return new DefaultListCellRenderer().getListCellRendererComponent(list, titleized, index, isSelected, cellHasFocus);
        });
        select.addActionListener(e -> {
            saveAction.accept(select.getItemAt(select.getSelectedIndex()));
            this.alertManager.saveAlerts();
        });
        this.controlContainer.add(PanelUtils.createLabeledComponent(name, tooltip, select));
        return this;
    }

    public AlertPanel<T> addCheckbox(String name, String tooltip, boolean initialValue, Consumer<Boolean> saveAction) {
        JCheckBox checkbox = PanelUtils.createCheckbox(name, tooltip, initialValue, val -> {
            saveAction.accept(val);
            this.alertManager.saveAlerts();
        });
        this.controlContainer.add(checkbox);
        return this;
    }

    public AlertPanel<T> addInputGroupWithSuffix(JComponent mainComponent, JComponent suffix) {
        return this.addInputGroup(mainComponent, null, Collections.singletonList(suffix));
    }

    public AlertPanel<T> addInputGroup(JComponent mainComponent, List<JComponent> prefixes, List<JComponent> suffixes) {
        InputGroup textFieldGroup = new InputGroup(mainComponent)
            .addPrefixes(prefixes)
            .addSuffixes(suffixes);
        this.controlContainer.add(textFieldGroup);
        return this;
    }

    public AlertPanel<T> addAlertDefaults() {
        return this.addTextField("Enter the alert name...", "Name of Alert", this.alert.getName(), this.alert::setName)
            .addSpinner(
                "Debounce Time (ms)",
                "How long to wait before allowing this alert to trigger again in milliseconds",
                this.alert.getDebounceTime(),
                this.alert::setDebounceTime,
                0,
                8640000, // 6 hours - max time a player can be logged in
                100
            );
    }

    public AlertPanel<T> addIf(Consumer<AlertPanel<T>> panel, Supplier<Boolean> ifFunc) {
        if (ifFunc.get()) {
            panel.accept(this);
        }
        return this;
    }

    public AlertPanel<T> addRegexMatcher(RegexMatcher regexMatcher, String placeholder, String tooltip) {
        return this.addRegexMatcher(regexMatcher, placeholder, tooltip, null);
    }

    public AlertPanel<T> addRegexMatcher(RegexMatcher regexMatcher, String placeholder, String tooltip, JComponent suffixAppend) {
        JPanel btnGroup = new JPanel(new GridLayout(1, 0, 5, 5));
        JButton regex = PanelUtils.createToggleActionButton(
            Icons.REGEX_SELECTED,
            Icons.REGEX_SELECTED_HOVER,
            Icons.REGEX,
            Icons.REGEX_HOVER,
            "Disable regex",
            "Enable regex",
            regexMatcher.isRegexEnabled(),
            (btn, modifiers) -> {
                regexMatcher.setRegexEnabled(btn.isSelected());
                this.alertManager.saveAlerts();
            }
        );
        btnGroup.add(regex);
        if (suffixAppend != null) {
            btnGroup.add(suffixAppend);
        }
        return this.addInputGroupWithSuffix(
            PanelUtils.createTextArea(placeholder, tooltip, regexMatcher.getPattern(), msg -> {
                if (!PanelUtils.isPatternValid(this, msg, regexMatcher.isRegexEnabled()))
                    return;
                regexMatcher.setPattern(msg);
                this.alertManager.saveAlerts();
            }),
            btnGroup
        );
    }

    public AlertPanel<T> addNotifications() {
        NotificationsPanel notificationPanel = WatchdogPlugin.getInstance().getInjector().getInstance(NotificationsPanel.class);
        notificationPanel.init(this.alert);
        notificationPanel.setBorder(new CompoundBorder(new EmptyBorder(0, 5, 0, 5), new HorizontalRuleBorder(10)));
        this.centerContainer.add(notificationPanel);

        return this;
    }

    public AlertPanel<T> addSubPanel(JPanel sub) {
        this.centerContainer.add(sub);
        return this;
    }

    public AlertPanel<T> addSubPanelControl(JPanel sub) {
        this.controlContainer.add(sub);
        return this;
    }

    public AlertPanel<T> addButton(String text, String tooltip, PanelUtils.ButtonClickListener clickListener) {
        JButton button = new JButton(text);
        button.setToolTipText(tooltip);
        button.addActionListener((ev) -> clickListener.clickPerformed(button, ev.getModifiers()));
        this.controlContainer.add(button);
        return this;
    }

    protected abstract void build();
    public void rebuild() {
        this.controlContainer.removeAll();
        this.centerContainer.removeAll();
        this.build();
    }

    @Override
    public void onActivate() {
        // Getting some weird resizing issues when this is called when switching tabs or collapsing the side panel
        // if there is lots of text in a text area? idk
        // Moved to the muxer.onAdd

        // this causes it to resize on collapse/restore
//        this.rebuild();
//        SwingUtilities.invokeLater(() -> {
//            // this causes it to resize on edit
//            this.rebuild();
//        });
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import javax.swing.JComponent;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.util.List;

class InputGroup extends JPanel {
    private final JPanel prefixes = new JPanel(new GridLayout(1, 0, 0, 0));
    private final JPanel suffixes = new JPanel(new GridLayout(1, 0, 0, 0));
    public InputGroup(JComponent mainComponent) {
        super(new BorderLayout());
        this.add(mainComponent);
        this.add(this.prefixes, BorderLayout.WEST);
        this.add(this.suffixes, BorderLayout.EAST);
    }

    public InputGroup addPrefix(JComponent component) {
        this.prefixes.add(component);
        return this;
    }

    public InputGroup addPrefixes(List<JComponent> components) {
        if (components != null) {
            components.forEach(this.prefixes::add);
        }
        return this;
    }

    public InputGroup addSuffix(JComponent component) {
        this.suffixes.add(component);
        return this;
    }

    public InputGroup addSuffixes(List<JComponent> components) {
        if (components != null) {
            components.forEach(this.suffixes::add);
        }
        return this;
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import lombok.Getter;
import lombok.Setter;

import javax.swing.JTextArea;
import javax.swing.text.Document;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.util.Map;

public class PlaceholderTextArea extends JTextArea {
    @Getter
    @Setter
    private String placeholder;

    private static final Map<?, ?> hints = (Map<?, ?>) Toolkit.getDefaultToolkit().getDesktopProperty("awt.font.desktophints");

    public PlaceholderTextArea() {
        super();
    }

    public PlaceholderTextArea(final Document pDoc, final String pText, final int pRows, final int pColumns) {
        super(pDoc, pText, pRows, pColumns);
    }

    public PlaceholderTextArea(final String pText) {
        super(pText);
    }

    @Override
    protected void paintComponent(final Graphics pG) {
        super.paintComponent(pG);

        if (this.placeholder == null || this.placeholder.length() == 0 || this.getText().length() > 0) {
            return;
        }

        final Graphics2D g = (Graphics2D) pG;
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setColor(this.getDisabledTextColor());
        g.drawString(this.placeholder, this.getInsets().left, g.getFontMetrics().getMaxAscent() + this.getInsets().top);
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.config.RuneLiteConfig;

import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.GridLayout;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.ActionListener;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Function;

@Slf4j
public class ImportExportDialog extends JDialog {
    // Import
    public ImportExportDialog(Component parent, BiFunction<String, Boolean, Boolean> onImport) {
        this.setTitle("Import");
        this.setSize(500, 250);
        this.setLocationRelativeTo(parent);
        this.setModal(true);
        this.setUndecorated(true);
        Util.syncAlwaysOnTop(this);

        JPanel wrapper = this.createWrapper();
        this.add(wrapper);

        wrapper.add(new JLabel("Paste the Alert JSON here"), BorderLayout.NORTH);

        JTextArea textArea = new JTextArea();
        textArea.setLineWrap(true);
        JScrollPane scrollPane = new JScrollPane(textArea);
        wrapper.add(scrollPane, BorderLayout.CENTER);

        JPanel btnGroup = new JPanel(new GridLayout(1, 0, 25, 0));
        Function<Boolean, ActionListener> importAlertFn = append -> ev -> {
            if (!append && JOptionPane.showConfirmDialog(this, "Are you sure you wish to overwrite your alerts?", "Confirm Overwrite?", JOptionPane.YES_NO_OPTION) != JOptionPane.YES_OPTION) {
                return;
            }
            String json = textArea.getText();
            try {
                if (onImport.apply(json, append)) {
                    this.setVisible(false);
                }
            } catch (Exception ex) {
                log.error("Error parsing json: " + ex);
                JOptionPane.showMessageDialog(this, "There was an error parsing the alert json", "Error parsing JSON", JOptionPane.ERROR_MESSAGE);
            }
        };
        JButton importOverwriteBtn = new JButton("Import (Overwrite)");
        importOverwriteBtn.addActionListener(importAlertFn.apply(false));
        btnGroup.add(importOverwriteBtn);
        JButton importAppendBtn = new JButton("Import (Append)");
        importAppendBtn.addActionListener(importAlertFn.apply(true));
        btnGroup.add(importAppendBtn);
        JButton closeBtn = new JButton("Cancel");
        closeBtn.addActionListener(ev -> {
            this.setVisible(false);
        });
        btnGroup.add(closeBtn);
        wrapper.add(btnGroup, BorderLayout.SOUTH);
    }

    // Export
    public ImportExportDialog(Component parent, Alert alert) {
        Gson gson = WatchdogPlugin.getInstance().getAlertManager().getGson();
        String json = gson.toJson(alert);
        String pretty = gson.newBuilder().setPrettyPrinting().create().toJson(alert);
        this.show(parent, json, pretty);
    }

    public ImportExportDialog(Component parent, List<Alert> alerts) {
        Gson gson = WatchdogPlugin.getInstance().getAlertManager().getGson();
        String json = gson.toJson(alerts);
        String pretty = gson.newBuilder().setPrettyPrinting().create().toJson(alerts);
        this.show(parent, json, pretty);
    }

    public void show(Component parent, String exportString, String prettyExportString) {
        this.setTitle("Export");
        this.setSize(500, 250);
        this.setLocationRelativeTo(parent);
        this.setModal(true);
        this.setUndecorated(true);
        Util.syncAlwaysOnTop(this);

        JTextArea textArea = new JTextArea(exportString);
        textArea.setLineWrap(true);
        textArea.setEditable(false);
        SwingUtilities.invokeLater(textArea::requestFocusInWindow);

        JPanel wrapper = this.createWrapper();
        this.add(wrapper);
        JPanel top = new JPanel(new BorderLayout());
        top.add(new JLabel("Exported Alert JSON"), BorderLayout.WEST);
        JCheckBox prettyPrint = PanelUtils.createCheckbox("Pretty Print", "Pretty Print", false, (selected) -> {
            textArea.setText(selected ? prettyExportString : exportString);
            textArea.setCaretPosition(0);
            textArea.requestFocusInWindow();
        });
        top.add(prettyPrint, BorderLayout.EAST);
        wrapper.add(top, BorderLayout.NORTH);
        JPanel btnGroup = new JPanel(new GridLayout(1, 2, 25, 0));
        JButton copyBtn = new JButton("Copy to Clipboard");
        copyBtn.addActionListener(ev -> {
            Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            clipboard.setContents(new StringSelection(prettyPrint.isSelected() ? prettyExportString : exportString), null);
            this.setVisible(false);
        });
        btnGroup.add(copyBtn);
        JButton closeBtn = new JButton("Close");
        btnGroup.add(closeBtn);
        closeBtn.addActionListener(ev -> {
            this.setVisible(false);
        });
        wrapper.add(btnGroup, BorderLayout.SOUTH);

        JScrollPane scrollPane = new JScrollPane(textArea);
        wrapper.add(scrollPane, BorderLayout.CENTER);
    }

    private JPanel createWrapper() {
        JPanel wrapper = new JPanel(new BorderLayout(5, 5));
        wrapper.setBorder(new EmptyBorder(10, 10, 10, 10));
        return wrapper;
    }
}

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.adamk33n3r.runelite.watchdog.ui.dropdownbutton;

import javax.swing.Icon;
import java.awt.*;
import java.awt.geom.AffineTransform;
import java.io.Serializable;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * A scalable icon that can be drawn at any resolution, for use with HiDPI displays. Implementations
 * will typically use hand-crafted painting code that may take special care to align graphics to
 * device pixels, and which may perform small tweaks to make the icon look good at all resolutions.
 * The API of this class intends to make this straightforward.
 *
 * <p>HiDPI support now exists on MacOS, Windows, and Linux. On MacOS, scaling is 200% for Retina
 * displays, while on Windows 10, the "Change display settings" panel provides the options 100%,
 * 125%, 150%, 175%, 200%, and 225%, as well as the option to enter an arbitrary scaling factor.
 * Non-integral scaling factors can lead to various alignment problems that makes otherwise
 * well-aligned icons look unsharp; this class takes special care to avoid such problems.
 *
 * <p>Hand-crafted painting code is a good design choice for icons that are simple, ubiqutious in
 * the UI (e.g. part of the Look-and-Feel), or highly parameterized. Swing's native Windows L&amp;F
 * uses this approach for many of its basic icons; see
 * {@link com.sun.java.swing.plaf.windows.WindowsIconFactory}.
 *
 * <p>When developing new icons, or adjusting existing ones, use the {@code VectorIconTester}
 * utility found in
 * {@code o.n.swing.tabcontrol/test/unit/src/org/netbeans/swing/tabcontrol/plaf/VectorIconTester.java}
 * to preview and compare icons at different resolutions.
 *
 * @since 9.12
 * @author Eirik Bakke
 */
public abstract class VectorIcon implements Icon, Serializable {
    private final int width;
    private final int height;

    protected VectorIcon(int width, int height) {
        if (width < 0 || height < 0)
            throw new IllegalArgumentException();
        this.width = width;
        this.height = height;
    }

    @Override
    public final int getIconWidth() {
        return width;
    }

    @Override
    public final int getIconHeight() {
        return height;
    }

    /* We can't use org.openide.awt.GraphicsUtils.configureDefaultRenderingHints here, since this module
    is not allowed to depend on it. But in any case, the rendering hints for VectorIcon are intended
    to remain standardized, unaffected by settings elsewhere. */
    private static Graphics2D createGraphicsWithRenderingHintsConfigured(Graphics basedOn) {
        Graphics2D ret = (Graphics2D) basedOn.create();
        Object desktopHints =
            Toolkit.getDefaultToolkit().getDesktopProperty("awt.font.desktophints");
        Map<Object, Object> hints = new LinkedHashMap<Object, Object>();
        if (desktopHints != null && desktopHints instanceof Map<?, ?>)
            hints.putAll((Map<?, ?>) desktopHints);
        /* Enable antialiasing by default. Adding this is required in order to get non-text
        antialiasing on Windows. */
        hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        /* In case a subclass decides to render text inside an icon, standardize the text
        antialiasing setting as well. Don't try to follow the editor's anti-aliasing setting, or
        to do subpixel rendering. It's more important that icons render in a predictable fashion, so
        the icon designer can get can review the appearance at design time. */
        hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        // Make stroke behavior as predictable as possible.
        hints.put(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);
        ret.addRenderingHints(hints);
        return ret;
    }

    /**
     * Selectively enable or disable antialiasing during painting. Certain shapes may look slightly
     * better without antialiasing, e.g. entirely regular diagonal lines in very small icons when
     * there is no HiDPI scaling. Text antialiasing is unaffected by this setting.
     *
     * @param g the graphics to set antialiasing setting for
     * @param enabled whether antialiasing should be enabled or disabled
     */
    protected static final void setAntiAliasing(Graphics2D g, boolean enabled) {
        Map<Object, Object> hints = new LinkedHashMap<Object, Object>();
        hints.put(RenderingHints.KEY_ANTIALIASING, enabled
            ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
        g.addRenderingHints(hints);
    }

    protected static final int round(double d) {
        int ret = (int) Math.round(d);
        return d > 0 && ret == 0 ? 1 : ret;
    }

    @Override
    public final void paintIcon(Component c, Graphics g0, int x, int y) {
        final Graphics2D g2 = createGraphicsWithRenderingHintsConfigured(g0);
        try {
            // Make sure the subclass can't paint outside its stated dimensions.
            g2.clipRect(x, y, getIconWidth(), getIconHeight());
            g2.translate(x, y);
            /**
             * On HiDPI monitors, the Graphics object will have a default transform that maps
             * logical pixels, like those you'd pass to Graphics.drawLine, to a higher number of
             * device pixels on the screen. For instance, painting a line 10 pixels long on the
             * current Graphics object would actually produce a line 20 device pixels long on a
             * MacOS retina screen, which has a DPI scaling factor of 2.0. On Windows 10, many
             * different scaling factors may be encountered, including non-integral ones such as
             * 1.5. Detect the scaling factor here so we can use it to inform the drawing routines.
             */
            final double scaling;
            final AffineTransform tx = g2.getTransform();
            int txType = tx.getType();
            if (txType == AffineTransform.TYPE_UNIFORM_SCALE ||
                txType == (AffineTransform.TYPE_UNIFORM_SCALE | AffineTransform.TYPE_TRANSLATION))
            {
                scaling = tx.getScaleX();
            } else {
                // Unrecognized transform type. Don't do any custom scaling handling.
                paintIcon(c, g2, getIconWidth(), getIconHeight(), 1.0);
                return;
            }
            /* When using a non-integral scaling factor, such as 175%, preceding Swing components
            often end up being a non-integral number of device pixels tall or wide. This will cause
            our initial position to be "off the grid" with respect to device pixels, causing blurry
            graphics even if we subsequently take care to use only integral numbers of device pixels
            during painting. Fix this here by consuming a little bit of the top and left of the
            icon's dimensions to offset any error. */
            // The initial position, in device pixels.
            final double previousDevicePosX = tx.getTranslateX();
            final double previousDevicePosY = tx.getTranslateY();
            /* The new, aligned position, after a small portion of the icon's dimensions may have
            been consumed to correct it. */
            final double alignedDevicePosX = Math.ceil(previousDevicePosX);
            final double alignedDevicePosY = Math.ceil(previousDevicePosY);
            // Use the aligned position.
            g2.setTransform(new AffineTransform(
                1, 0, 0, 1, alignedDevicePosX, alignedDevicePosY));
            /* The portion of the icon's dimensions that was consumed to correct any initial
            translation misalignment, in device pixels. May be zero. */
            final double transDeviceAdjX = alignedDevicePosX - previousDevicePosX;
            final double transDeviceAdjY = alignedDevicePosY - previousDevicePosY;
            /* Now calculate the dimensions available for painting, also aligned to an integral
            number of device pixels. */
            final int deviceWidth  = (int) Math.floor(getIconWidth()  * scaling - transDeviceAdjX);
            final int deviceHeight = (int) Math.floor(getIconHeight() * scaling - transDeviceAdjY);
            paintIcon(c, g2, deviceWidth, deviceHeight, scaling);
        } finally {
            g2.dispose();
        }
    }

    /**
     * Paint the icon at the given width and height. The dimensions given are the device pixels onto
     * which the icon must be drawn after it has been scaled up from its originally constant logical
     * dimensions and aligned onto the device pixel grid. Painting onto the supplied
     * {@code Graphics2D} instance using whole number coordinates (for horizontal and vertical
     * lines) will encourage sharp and well-aligned icons.
     *
     * <p>The icon should be painted with its upper left-hand corner at position (0, 0). Icons need
     * not be opaque. Due to rounding errors and alignment correction, the aspect ratio of the
     * device dimensions supplied here may not be exactly the same as that of the logical pixel
     * dimensions specified in the constructor.
     *
     * @param c may be used to get properties useful for painting, as in
     *        {@link Icon#paintIcon(Component,Graphics,int,int)}
     * @param width the target width of the icon, after scaling and alignment adjustments, in device
     *        pixels
     * @param height the target height of the icon, after scaling and alignment adjustments, in
     *        device pixels
     * @param scaling the scaling factor that was used to scale the icon dimensions up to their
     *        stated value
     * @param g need <em>not</em> be cleaned up or restored to its previous state after use; will
     *        have anti-aliasing already enabled by default
     */
    protected abstract void paintIcon(
        Component c, Graphics2D g, int width, int height, double scaling);
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package com.adamk33n3r.runelite.watchdog.ui.dropdownbutton;

import javax.swing.*;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.beans.PropertyChangeEvent;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * JButton with a small arrow that displays popup menu when clicked.
 *
 * @author S. Aubrecht
 * @since 6.11
 */
class DropDownButton extends JButton {

    private boolean mouseInButton = false;
    private boolean mouseInArrowArea = false;
    private boolean popupClosingInProgress = false;

    private Map<String,Icon> regIcons = new HashMap<String,Icon>( 5 );
    private Map<String,Icon> arrowIcons = new HashMap<String,Icon>( 5 );

    private static final String ICON_NORMAL = "normal"; //NOI18N
    private static final String ICON_PRESSED = "pressed"; //NOI18N
    private static final String ICON_ROLLOVER = "rollover"; //NOI18N
    private static final String ICON_ROLLOVER_SELECTED = "rolloverSelected"; //NOI18N
    private static final String ICON_SELECTED = "selected"; //NOI18N
    private static final String ICON_DISABLED = "disabled"; //NOI18N
    private static final String ICON_DISABLED_SELECTED = "disabledSelected"; //NOI18N

    private static final String ICON_ROLLOVER_LINE = "rolloverLine"; //NOI18N
    private static final String ICON_ROLLOVER_SELECTED_LINE = "rolloverSelectedLine"; //NOI18N

    private PopupMenuListener menuListener;

    /** Creates a new instance of MenuToggleButton */
    public DropDownButton( Icon icon, JPopupMenu popup) {
//        Parameters.notNull("icon", icon); //NOI18N

        putClientProperty( "dropDownMenu", popup );

        setIcon( icon );
//        setDisabledIcon(ImageUtilities.createDisabledIcon(icon));

        resetIcons();

        addPropertyChangeListener("dropDownMenu", (PropertyChangeEvent e) -> {
            resetIcons();
        });

        addMouseMotionListener(new MouseMotionAdapter() {
            @Override
            public void mouseMoved(MouseEvent e) {
                if (null != getPopupMenu()) {
                    mouseInArrowArea = isInArrowArea(e.getPoint());
                    updateRollover(_getRolloverIcon(), _getRolloverSelectedIcon());
                }
            }
        });

        addMouseListener( new MouseAdapter() {
            private boolean popupMenuOperation = false;

            @Override
            public void mousePressed( MouseEvent e ) {
                if (popupClosingInProgress) {
                    return;
                }
                popupMenuOperation = false;
                JPopupMenu menu = getPopupMenu();
                if ( menu != null && getModel() instanceof Model ) {
                    Model model = (Model) getModel();
                    if ( !model._isPressed() ) {
                        if( (isInArrowArea( e.getPoint() )) && menu.getComponentCount() > 0 &&
                            model.isEnabled() )
                        {
                            model._press();
                            menu.addPopupMenuListener( getMenuListener() );
                            menu.show( DropDownButton.this, 0, getHeight() );
                            popupMenuOperation = true;
                        }
                    } else {
                        model._release();
                        menu.removePopupMenuListener( getMenuListener() );
                        popupMenuOperation = true;
                    }
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                // If we done something with the popup menu, we should consume
                // the event, otherwise the button's action will be triggered.
                if (popupMenuOperation) {
                    popupMenuOperation = false;
                    e.consume();
                }
            }

            @Override
            public void mouseEntered( MouseEvent e ) {
                mouseInButton = true;
                if( hasPopupMenu() ) {
                    mouseInArrowArea = isInArrowArea( e.getPoint() );
                    updateRollover( _getRolloverIcon(), _getRolloverSelectedIcon() );
                }
            }

            @Override
            public void mouseExited( MouseEvent e ) {
                mouseInButton = false;
                mouseInArrowArea = false;
                if( hasPopupMenu() ) {
                    updateRollover( _getRolloverIcon(), _getRolloverSelectedIcon() );
                }
            }
        });

        setModel( new Model() );
    }

    private PopupMenuListener getMenuListener() {
        if( null == menuListener ) {
            menuListener = new PopupMenuListener() {
                @Override
                public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
                }

                @Override
                public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
                    if( getModel() instanceof Model ) {
                        ((Model)getModel())._release();
                    }
                    JPopupMenu menu = getPopupMenu();
                    if( null != menu ) {
                        menu.removePopupMenuListener( this );
                    }
                    /* If the popup was closed by a mouse click inside the button area, the button
                    may also receive a mousePressed event, although this seems not to be guaranteed.
                    Ignore any such button press while the popup is closing, to avoid interpreting
                    the press as a click to open the menu again. */
                    popupClosingInProgress = true;
                    SwingUtilities.invokeLater(() -> {
                        popupClosingInProgress = false;
                    });
                }

                @Override
                public void popupMenuCanceled(PopupMenuEvent e) {
                }
            };
        }
        return menuListener;
    }

    private void updateRollover( Icon rollover, Icon rolloverSelected ) {
        super.setRolloverIcon( rollover );
        super.setRolloverSelectedIcon( rolloverSelected );
    }

    private void resetIcons() {
        Icon icon = regIcons.get( ICON_NORMAL );
        if( null != icon )
            setIcon( icon );

        icon = regIcons.get( ICON_PRESSED );
        if( null != icon )
            setPressedIcon( icon );

        icon = regIcons.get( ICON_ROLLOVER );
        if( null != icon )
            setRolloverIcon( icon );

        icon = regIcons.get( ICON_ROLLOVER_SELECTED );
        if( null != icon )
            setRolloverSelectedIcon( icon );

        icon = regIcons.get( ICON_SELECTED );
        if( null != icon )
            setSelectedIcon( icon );

        icon = regIcons.get( ICON_DISABLED );
        if( null != icon )
            setDisabledIcon( icon );

        icon = regIcons.get( ICON_DISABLED_SELECTED );
        if( null != icon )
            setDisabledSelectedIcon( icon );
    }

    private Icon _getRolloverIcon() {
        Icon icon = null;
        icon = arrowIcons.get( mouseInArrowArea ? ICON_ROLLOVER : ICON_ROLLOVER_LINE );
        if( null == icon ) {
            Icon orig = regIcons.get( ICON_ROLLOVER );
            if( null == orig )
                orig = regIcons.get( ICON_NORMAL );
            icon = new IconWithArrow( orig, !mouseInArrowArea, false );
            arrowIcons.put( mouseInArrowArea ? ICON_ROLLOVER : ICON_ROLLOVER_LINE, icon );
        }
        return icon;
    }

    private Icon _getRolloverSelectedIcon() {
        Icon icon = null;
        icon = arrowIcons.get( mouseInArrowArea ? ICON_ROLLOVER_SELECTED : ICON_ROLLOVER_SELECTED_LINE );
        if( null == icon ) {
            Icon orig = regIcons.get( ICON_ROLLOVER_SELECTED );
            if( null == orig )
                orig = regIcons.get( ICON_ROLLOVER );
            if( null == orig )
                orig = regIcons.get( ICON_NORMAL );
            icon = new IconWithArrow( orig, !mouseInArrowArea, false );
            arrowIcons.put( mouseInArrowArea ? ICON_ROLLOVER_SELECTED : ICON_ROLLOVER_SELECTED_LINE, icon );
        }
        return icon;
    }

    JPopupMenu getPopupMenu() {
        Object menu = getClientProperty( "dropDownMenu");
        if( menu instanceof JPopupMenu ) {
            return (JPopupMenu)menu;
        }
        return null;
    }

    boolean hasPopupMenu() {
        return null != getPopupMenu();
    }

    private boolean isInArrowArea( Point p ) {
        /* If no one is listening for button presses, treat the entire button as a dropdown menu
        trigger. This also means we do not paint the IconWithArrow.paintRollOver separator. */
        if (getActionListeners().length == 0) {
            return true;
        }
        return p.getLocation().x >= getWidth() - IconWithArrow.getArrowAreaWidth() - getInsets().right;
    }

    @Override
    public void setIcon(Icon icon) {
        assert null != icon;
        Icon arrow = updateIcons( icon, ICON_NORMAL );
        arrowIcons.remove( ICON_ROLLOVER_LINE );
        arrowIcons.remove( ICON_ROLLOVER_SELECTED_LINE );
        arrowIcons.remove( ICON_ROLLOVER );
        arrowIcons.remove( ICON_ROLLOVER_SELECTED );
        super.setIcon( hasPopupMenu() ? arrow : icon );
        updateRollover( _getRolloverIcon(), _getRolloverSelectedIcon() );
    }

    private Icon updateIcons( Icon orig, String iconType ) {
        Icon arrow = null;
        if( null == orig ) {
            regIcons.remove( iconType );
            arrowIcons.remove( iconType );
        } else {
            regIcons.put( iconType, orig );
            arrow = new IconWithArrow( orig, false,
                iconType.equals(ICON_DISABLED) || iconType.equals(ICON_DISABLED_SELECTED));
            arrowIcons.put( iconType, arrow );
        }
        return arrow;
    }

    @Override
    public void setPressedIcon(Icon icon) {
        Icon arrow = updateIcons( icon, ICON_PRESSED );
        super.setPressedIcon( hasPopupMenu() ? arrow : icon );
    }

    @Override
    public void setSelectedIcon(Icon icon) {
        Icon arrow = updateIcons( icon, ICON_SELECTED );
        super.setSelectedIcon( hasPopupMenu() ? arrow : icon );
    }

    @Override
    public void setRolloverIcon(Icon icon) {
        Icon arrow = updateIcons( icon, ICON_ROLLOVER );
        arrowIcons.remove( ICON_ROLLOVER_LINE );
        arrowIcons.remove( ICON_ROLLOVER_SELECTED_LINE );
        super.setRolloverIcon( hasPopupMenu() ? arrow : icon );
    }

    @Override
    public void setRolloverSelectedIcon(Icon icon) {
        Icon arrow = updateIcons( icon, ICON_ROLLOVER_SELECTED );
        arrowIcons.remove( ICON_ROLLOVER_SELECTED_LINE );
        super.setRolloverSelectedIcon( hasPopupMenu() ? arrow : icon );
    }

    @Override
    public void setDisabledIcon(Icon icon) {
        Icon arrow = updateIcons( icon, ICON_DISABLED );
        super.setDisabledIcon( hasPopupMenu() ? arrow : icon );
    }

    @Override
    public void setDisabledSelectedIcon(Icon icon) {
        Icon arrow = updateIcons( icon, ICON_DISABLED_SELECTED );
        super.setDisabledSelectedIcon( hasPopupMenu() ? arrow : icon );
    }

    @Override
    public void setText( String text ) {
        //does nothing
        Logger.getLogger(DropDownButton.class.getName()).log(Level.FINER, "DropDownButton cannot display text."); //NOI18N
    }

    @Override
    public String getText() {
        return null;
    }

    private class Model extends DefaultButtonModel {
        private boolean _pressed = false;

        @Override
        public void setPressed(boolean b) {
            if( _pressed || b && mouseInArrowArea)
                return;
            super.setPressed( b );
        }

        public void _press() {
            if((_pressed && isPressed()) || !isEnabled()) {
                return;
            }

            stateMask |= PRESSED + ARMED;

            fireStateChanged();
            _pressed = true;
        }

        public void _release() {
            _pressed = false;
            setArmed( false );
            setPressed( false );
            setRollover( false );
            setSelected( false );
        }

        public boolean _isPressed() {
            return _pressed;
        }

        @Override
        protected void fireStateChanged() {
            if( _pressed )
                return;
            super.fireStateChanged();
        }

        @Override
        public void setArmed(boolean b) {
            if( _pressed )
                return;
            super.setArmed(b);
        }

        @Override
        public void setEnabled(boolean b) {
            if( _pressed )
                return;
            super.setEnabled(b);
        }

        @Override
        public void setSelected(boolean b) {
            if( _pressed )
                return;
            super.setSelected(b);
        }

        @Override
        public void setRollover(boolean b) {
            if( _pressed )
                return;
            super.setRollover(b);
        }
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package com.adamk33n3r.runelite.watchdog.ui.dropdownbutton;

import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JPopupMenu;

/**
 * Factory creating buttons with a small arrow icon that shows a popup menu when clicked.
 * The default button behavior hasn't changed except that the button doesn't
 * display any text, just the icon.
 *
 * @author S. Aubrecht
 * @since 6.11
 */
public final class DropDownButtonFactory {

    /**
     * Use this property name to assign or remove popup menu to/from buttons created by this factory,
     * e.g. <code>dropDownButton.putClientProperty( PROP_DROP_DOWN_MENU, new JPopupMenu() )</code>
     * The property value must be <code>JPopupMenu</code>, removing this property removes the arrow from the button.
     */
    public static final String PROP_DROP_DOWN_MENU = "dropDownMenu";

    /** Creates a new instance of DropDownButtonFactory */
    private DropDownButtonFactory() {
    }

    /**
     * Creates JButton with a small arrow that shows the provided popup menu when clicked.
     *
     * @param icon The default icon, cannot be null
     * @param dropDownMenu Popup menu to display when the arrow is clicked. If this parameter is null
     * then the button doesn't show any arrow and behaves like a regular JButton. It is possible to add
     * the popup menu later using PROP_DROP_DOWN_MENU client property.
     * @return A button that is capable of displaying an 'arrow' in its icon to open a popup menu.
     */
    public static JButton createDropDownButton( Icon icon, JPopupMenu dropDownMenu ) {
        return new DropDownButton( icon, dropDownMenu );
    }

    /**
     * Creates JToggleButton with a small arrow that shows the provided popup menu when clicked.
     *
     * @param icon The default icon, cannot be null
     * @param dropDownMenu Popup menu to display when the arrow is clicked. If this parameter is null
     * then the button doesn't show any arrow and behaves like a regular JToggleButton. It is possible to add
     * the popup menu later using PROP_DROP_DOWN_MENU client property.
     * @return A toggle-button that is capable of displaying an 'arrow' in its icon to open a popup menu.
     */
//    public static JToggleButton createDropDownToggleButton( Icon icon, JPopupMenu dropDownMenu ) {
//        return new DropDownToggleButton( icon, dropDownMenu );
//    }

    /**
     * Get a dropdown button icon that is identical to those used in the dropdown buttons returned
     * by other methods in this class. The returned icon scales properly on HiDPI screens.
     *
     * @since 7.74
     * @param disabled whether to get a disabled version of the icon or not
     * @return a dropdown arrow icon
     */
    public static Icon getArrowIcon(boolean disabled) {
        return disabled ? IconWithArrow.ArrowIcon.INSTANCE_DEFAULT : IconWithArrow.ArrowIcon.INSTANCE_DISABLED;
    }
}

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package com.adamk33n3r.runelite.watchdog.ui.dropdownbutton;

import javax.swing.Icon;
import javax.swing.UIManager;
import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Path2D;

/**
 * An icon that paints a small arrow to the right of the provided icon.
 *
 * @author S. Aubrecht
 * @since 6.11
 */
class IconWithArrow implements Icon {
    private Icon orig;
    private Icon arrow;
    private boolean paintRollOver;

    private static final int GAP = 6;

    /** Creates a new instance of IconWithArrow */
    public IconWithArrow(  Icon orig, boolean paintRollOver, boolean disabledArrow ) {
        this.orig = orig;
        this.paintRollOver = paintRollOver;
        this.arrow = disabledArrow ? ArrowIcon.INSTANCE_DISABLED : ArrowIcon.INSTANCE_DEFAULT;
    }

    @Override
    public void paintIcon( Component c, Graphics g, int x, int y ) {
        int height = getIconHeight();
        orig.paintIcon( c, g, x, y+(height-orig.getIconHeight())/2 );

        arrow.paintIcon( c, g, x+GAP+orig.getIconWidth(), y+(height-arrow.getIconHeight())/2 );

        if( paintRollOver ) {
            Color brighter = UIManager.getColor( "controlHighlight" ); //NOI18N
            Color darker = UIManager.getColor( "controlShadow" ); //NOI18N
            if( null == brighter || null == darker ) {
                brighter = c.getBackground().brighter();
                darker = c.getBackground().darker();
            }
            if( null != brighter && null != darker ) {
                g.setColor( brighter );
                g.drawLine( x+orig.getIconWidth()+1, y,
                    x+orig.getIconWidth()+1, y+getIconHeight() );
                g.setColor( darker );
                g.drawLine( x+orig.getIconWidth()+2, y,
                    x+orig.getIconWidth()+2, y+getIconHeight() );
            }
        }
    }

    @Override
    public int getIconWidth() {
        return orig.getIconWidth() + GAP + arrow.getIconWidth();
    }

    @Override
    public int getIconHeight() {
        return Math.max( orig.getIconHeight(), arrow.getIconHeight() );
    }

    public static int getArrowAreaWidth() {
        return GAP/2 + 5;
    }

    static class ArrowIcon extends VectorIcon {
        public static final Icon INSTANCE_DEFAULT = new ArrowIcon(false);
        public static final Icon INSTANCE_DISABLED = new ArrowIcon(true);
        private final boolean disabled;

        private ArrowIcon(boolean disabled) {
            super(5, 4);
            this.disabled = disabled;
        }

        @Override
        protected void paintIcon(Component c, Graphics2D g, int width, int height, double scaling) {
            final Color color;
            if (UIManager.getBoolean("nb.dark.theme")) {
                // Foreground brightness level taken from the combobox dropdown on Darcula.
                color = disabled ? new Color(90, 90, 90, 255) : new Color(187, 187, 187, 255);
            } else {
                color = disabled ? new Color(201, 201, 201, 255) : new Color(86, 86, 86, 255);
            }
            g.setColor(color);
            final double overshoot = 2.0 / scaling;
            final double arrowWidth = width + overshoot * scaling;
            final double arrowHeight = height - 0.2 * scaling;
            final double arrowMidX = arrowWidth / 2.0 - (overshoot / 2.0) * scaling;
            g.clipRect(0, 0, width, height);
            Path2D.Double arrowPath = new Path2D.Double();
            arrowPath.moveTo(arrowMidX - arrowWidth / 2.0, 0);
            arrowPath.lineTo(arrowMidX, arrowHeight);
            arrowPath.lineTo(arrowMidX + arrowWidth / 2.0, 0);
            arrowPath.closePath();
            g.fill(arrowPath);
        }
    }
}
/*
 * Adapted from net.runelite.client.plugins.config.PluginToggleButton
 */

package com.adamk33n3r.runelite.watchdog.ui;

import net.runelite.client.plugins.config.ConfigPlugin;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

import javax.swing.ImageIcon;
import javax.swing.JToggleButton;
import java.awt.Dimension;
import java.awt.image.BufferedImage;

public class ToggleButton extends JToggleButton {
    private static final ImageIcon ON_SWITCHER;
    private static final ImageIcon OFF_SWITCHER;
    private final String selectedTooltip;
    private final String unSelectedTooltip;

    static {
        BufferedImage onSwitcher = ImageUtil.loadImageResource(ConfigPlugin.class, "switcher_on.png");
        ON_SWITCHER = new ImageIcon(onSwitcher);
        OFF_SWITCHER = new ImageIcon(ImageUtil.flipImage(
            ImageUtil.luminanceScale(
                ImageUtil.grayscaleImage(onSwitcher),
                0.61f
            ),
            true,
            false
        ));
    }

    public ToggleButton() {
        this("Disable alert", "Enable alert");
    }

    public ToggleButton(String selectedTooltip, String unSelectedTooltip) {
        super(OFF_SWITCHER);
        this.selectedTooltip = selectedTooltip;
        this.unSelectedTooltip = unSelectedTooltip;
        this.setSelectedIcon(ON_SWITCHER);
        SwingUtil.removeButtonDecorations(this);
        this.setPreferredSize(new Dimension(25, 0));
        this.addItemListener(l -> this.updateTooltip());
        this.updateTooltip();
    }

    private void updateTooltip() {
        this.setToolTipText(this.isSelected() ? this.selectedTooltip :  this.unSelectedTooltip);
    }
}


package com.adamk33n3r.runelite.watchdog.ui;

import net.runelite.client.ui.ColorScheme;

import lombok.Getter;

import javax.swing.*;
import javax.swing.text.Document;
import java.awt.*;
import java.awt.event.*;

/**
 * This component is a JTextArea with a flat design look.
 */
@Getter
public class FlatTextArea extends JPanel {
    protected final PlaceholderTextArea textArea;

    //the default background color, this needs to be stored for hover effects
    protected Color backgroundColor = ColorScheme.DARKER_GRAY_COLOR;

    //the default hover background color, this needs to be stored for hover effects
    protected Color hoverBackgroundColor;

    // the input can be blocked (no clicking, no editing, no hover effects)
    protected boolean blocked;

    public FlatTextArea(String placeholder) {
        this(placeholder, false);
    }

    public FlatTextArea(String placeholder, boolean preventNewline) {
        this.setLayout(new BorderLayout());
//        this.setBorder(new EmptyBorder(0, 10, 0, 0));
        this.setBackground(this.backgroundColor);
//        setBorder(null);

        this.textArea = new PlaceholderTextArea();
        this.textArea.setPlaceholder(placeholder);
//        this.textArea.setBorder(null);
        this.textArea.setOpaque(false);
        this.textArea.setSelectedTextColor(Color.WHITE);
        this.textArea.setSelectionColor(ColorScheme.BRAND_ORANGE_TRANSPARENT);
        this.textArea.setLineWrap(true);
        this.textArea.setWrapStyleWord(true);
        this.textArea.setMargin(new Insets(4, 6, 5, 6));

        this.add(textArea, BorderLayout.CENTER);

        textArea.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent mouseEvent) {
                if (blocked) {
                    return;
                }

                if (hoverBackgroundColor != null) {
                    setBackground(hoverBackgroundColor, false);
                }
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent) {
                setBackground(backgroundColor);
            }
        });

        this.setUpKeymaps(preventNewline);
    }

    protected void setUpKeymaps(boolean preventNewline) {
        this.setUpKeymaps(preventNewline, this.textArea);
    }

    protected void setUpKeymaps(boolean preventNewline, PlaceholderTextArea textArea) {
        KeyStroke enterKey = KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0);
        KeyStroke tabKey = KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0);
        InputMap inputMap = textArea.getInputMap(JComponent.WHEN_FOCUSED);
        ActionMap actionMap = textArea.getActionMap();
        if (preventNewline) {
            inputMap.put(enterKey, enterKey.toString());
            actionMap.put(enterKey.toString(), new AbstractAction() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    JTextArea textArea = (JTextArea) e.getSource();
                    textArea.getParent().getParent().requestFocusInWindow();
                }
            });
        }
        inputMap.put(tabKey, tabKey.toString());
        actionMap.put(tabKey.toString(), new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().focusNextComponent();
            }
        });
    }

    public String getText()
    {
        return this.textArea.getText();
    }

    public void setText(String text)
    {
        this.textArea.setText(text);
    }

    @Override
    public void addKeyListener(KeyListener keyListener)
    {
        this.textArea.addKeyListener(keyListener);
    }

    @Override
    public void removeKeyListener(KeyListener keyListener)
    {
        this.textArea.removeKeyListener(keyListener);
    }

    @Override
    public void setBackground(Color color)
    {
        this.setBackground(color, true);
    }

    @Override
    public boolean requestFocusInWindow()
    {
        return this.textArea.requestFocusInWindow();
    }

    public void setBackground(Color color, boolean saveColor)
    {
        if (color == null)
        {
            return;
        }

        super.setBackground(color);

        if (saveColor)
        {
            this.backgroundColor = color;
        }
    }

    public void setHoverBackgroundColor(Color color)
    {
        if (color == null)
        {
            return;
        }

        this.hoverBackgroundColor = color;
    }

    public void setEditable(boolean editable)
    {
        this.blocked = !editable;
        this.textArea.setEditable(editable);
        this.textArea.setFocusable(editable);
        if (!editable)
        {
            super.setBackground(this.backgroundColor);
        }
    }

    public Document getDocument()
    {
        return this.textArea.getDocument();
    }

}

package com.adamk33n3r.runelite.watchdog.ui;

import javax.swing.JTextArea;
import javax.swing.text.DefaultCaret;

public class WrappingLabel extends JTextArea {
    public WrappingLabel(String text) {
        super();

        this.setOpaque(false);
        this.setEditable(false);
        this.setFocusable(false);
        this.setLineWrap(true);
        this.setWrapStyleWord(true);

        // Need to update this before setting the text, or it will cause the scroll pane to scroll to this component
        ((DefaultCaret)this.getCaret()).setUpdatePolicy(DefaultCaret.NEVER_UPDATE);
        this.setText(text);
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import java.awt.*;
import java.util.function.Function;

/**
 * Modified DynamicGridLayout to not resize components vertically.
 */
public class StretchedStackedLayout extends GridLayout
{
    public StretchedStackedLayout(int vgap)
    {
        super(0, 1, 0, vgap);
    }

    @Override
    public Dimension preferredLayoutSize(Container parent)
    {
        synchronized (parent.getTreeLock())
        {
            return calculateSize(parent, Component::getPreferredSize);
        }
    }

    @Override
    public Dimension minimumLayoutSize(Container parent)
    {
        synchronized (parent.getTreeLock())
        {
            return calculateSize(parent, Component::getMinimumSize);
        }
    }

    @Override
    public void layoutContainer(Container parent)
    {
        synchronized (parent.getTreeLock())
        {
            final Insets insets = parent.getInsets();
            final int ncomponents = parent.getComponentCount();
            int nrows = getRows();
            int ncols = getColumns();

            if (ncomponents == 0)
            {
                return;
            }

            if (nrows > 0)
            {
                ncols = (ncomponents + nrows - 1) / nrows;
            }
            else
            {
                nrows = (ncomponents + ncols - 1) / ncols;
            }

            final int hgap = getHgap();
            final int vgap = getVgap();

            // scaling factors
            final Dimension pd = preferredLayoutSize(parent);
            final Insets parentInsets = parent.getInsets();
            int wborder = parentInsets.left + parentInsets.right;
//            int hborder = parentInsets.top + parentInsets.bottom;
            final double sw = (1.0 * parent.getWidth() - wborder) / (pd.width - wborder);
//            final double sh = (1.0 * parent.getHeight() - hborder) / (pd.height - hborder);

            final int[] w = new int[ncols];
            final int[] h = new int[nrows];

            // calculate dimensions for all components + apply scaling
            for (int i = 0; i < ncomponents; i++)
            {
                final int r = i / ncols;
                final int c = i % ncols;
                final Component comp = parent.getComponent(i);
                final Dimension d = comp.getPreferredSize();
                d.width = (int) (sw * d.width);
//                d.height = (int) (sh * d.height);

                if (w[c] < d.width)
                {
                    w[c] = d.width;
                }

                if (h[r] < d.height)
                {
                    h[r] = d.height;
                }
            }

            // Apply new bounds to all child components
            for (int c = 0, x = insets.left; c < ncols; c++)
            {
                for (int r = 0, y = insets.top; r < nrows; r++)
                {
                    int i = r * ncols + c;

                    if (i < ncomponents)
                    {
                        parent.getComponent(i).setBounds(x, y, w[c], h[r]);
                    }

                    y += h[r] + vgap;
                }

                x += w[c] + hgap;
            }
        }
    }

    /**
     * Calculate outer size of the layout based on it's children and sizer
     * @param parent parent component
     * @param sizer functioning returning dimension of the child component
     * @return outer size
     */
    private Dimension calculateSize(final Container parent, final Function<Component, Dimension> sizer)
    {
        final int ncomponents = parent.getComponentCount();
        int nrows = getRows();
        int ncols = getColumns();

        if (nrows > 0)
        {
            ncols = (ncomponents + nrows - 1) / nrows;
        }
        else
        {
            nrows = (ncomponents + ncols - 1) / ncols;
        }

        final int[] w = new int[ncols];
        final int[] h = new int[nrows];

        // Calculate dimensions for all components
        for (int i = 0; i < ncomponents; i++)
        {
            final int r = i / ncols;
            final int c = i % ncols;
            final Component comp = parent.getComponent(i);
            final Dimension d = sizer.apply(comp);

            if (w[c] < d.width)
            {
                w[c] = d.width;
            }

            if (h[r] < d.height)
            {
                h[r] = d.height;
            }
        }

        // Calculate total width and height of the layout
        int nw = 0;

        for (int j = 0; j < ncols; j++)
        {
            nw += w[j];
        }

        int nh = 0;

        for (int i = 0; i < nrows; i++)
        {
            nh += h[i];
        }

        final Insets insets = parent.getInsets();

        // Apply insets and horizontal and vertical gap to layout
        return new Dimension(
            insets.left + insets.right + nw + (ncols - 1) * getHgap(),
            insets.top + insets.bottom + nh + (nrows - 1) * getVgap());
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.LengthLimitFilter;
import com.adamk33n3r.runelite.watchdog.SimpleDocumentListener;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.elevenlabs.ElevenLabs;
import com.adamk33n3r.runelite.watchdog.elevenlabs.Voice;
import com.adamk33n3r.runelite.watchdog.notifications.TextToSpeech;
import com.adamk33n3r.runelite.watchdog.notifications.tts.TTSSource;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.notifications.VoiceChooser;
import com.adamk33n3r.runelite.watchdog.ui.notifications.VolumeSlider;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.text.AbstractDocument;
import java.awt.Font;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;

public class TextToSpeechNotificationPanel extends NotificationPanel {
    public TextToSpeechNotificationPanel(TextToSpeech notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);

        this.rebuild();
    }

    private void rebuild() {
        this.settings.removeAll();

        TextToSpeech notification = (TextToSpeech) this.notification;

        if (!WatchdogPlugin.getInstance().getConfig().ttsEnabled()) {
            JLabel ttsLabel = new JLabel("<html>Enable TTS in the config to use this Notification type</html>");
            ttsLabel.setFont(new Font(ttsLabel.getFont().getFontName(), Font.ITALIC | Font.BOLD, ttsLabel.getFont().getSize()));
            this.settings.add(ttsLabel);
            JButton settingsBtn = new JButton("Open Config");
            settingsBtn.addActionListener(ev -> WatchdogPlugin.getInstance().openConfiguration());
            this.settings.add(settingsBtn);
            return;
        }

        FlatTextArea flatTextArea = new FlatTextArea("Enter your message...", true);
        flatTextArea.setText(notification.getMessage());
        ((AbstractDocument) flatTextArea.getDocument()).setDocumentFilter(new LengthLimitFilter(200));
        flatTextArea.getDocument().addDocumentListener((SimpleDocumentListener) ev -> {
            notification.setMessage(flatTextArea.getText());
        });
        flatTextArea.getTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                flatTextArea.getTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChangeListener.run();
            }
        });
        this.settings.add(flatTextArea);

        JComboBox<TTSSource> sourceSelect = PanelUtils.createSelect(TTSSource.values(), notification.getSource(), (selected) -> {
            notification.setSource(selected);
            onChangeListener.run();
            this.rebuild();
            this.revalidate();
        });
        this.settings.add(sourceSelect);

        switch (notification.getSource()) {
            case ELEVEN_LABS:
                if (WatchdogPlugin.getInstance().getConfig().elevenLabsAPIKey().isEmpty()) {
                    JLabel ttsLabel = new JLabel("<html>Add your API key in the config to use Eleven Labs</html>");
                    ttsLabel.setFont(new Font(ttsLabel.getFont().getFontName(), Font.ITALIC | Font.BOLD, ttsLabel.getFont().getSize()));
                    this.settings.add(ttsLabel);
                    JButton settingsBtn = new JButton("Open Config");
                    settingsBtn.addActionListener(ev -> WatchdogPlugin.getInstance().openConfiguration());
                    this.settings.add(settingsBtn);
                    return;
                }
                JComboBox<Voice> voiceSelect = PanelUtils.createSelect(new Voice[]{}, null, Voice::getName, (voice) -> {
                    notification.setElevenLabsVoiceId(voice.getVoiceId());
                    //Not serialized
                    notification.setElevenLabsVoice(voice);
                });

                ElevenLabs.getVoices(WatchdogPlugin.getInstance().getHttpClient(), (voices) -> {
                    SwingUtilities.invokeLater(() -> {
                        // Store the voice id prior to adding to the list because adding the first item will select it
                        String elevenLabsVoiceId = notification.getElevenLabsVoiceId();
                        voices.getVoices().forEach((voice) -> {
                            voiceSelect.addItem(voice);
                            if (elevenLabsVoiceId == null) {
                                if (voice.getName().equals(WatchdogPlugin.getInstance().getConfig().defaultElevenLabsVoice())) {
                                    voiceSelect.setSelectedItem(voice);
                                }
                            } else {
                                if (voice.getVoiceId().equals(elevenLabsVoiceId)) {
                                    voiceSelect.setSelectedItem(voice);
                                }
                            }
                        });
                    });
                });
                this.settings.add(voiceSelect);
                break;
            case LEGACY:
                JLabel deprecatedWarning = new JLabel("<html>The Legacy TTS API is deprecated and will likely be removed in the future.</html>");
                this.settings.add(deprecatedWarning);
                JSlider rateSlider = new JSlider(1, 5, notification.getRate());
                rateSlider.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
                rateSlider.addChangeListener(ev -> {
                    notification.setRate(rateSlider.getValue());
                    onChangeListener.run();
                });
                this.settings.add(PanelUtils.createIconComponent(Icons.SPEED, "The speed of the generated speech", rateSlider));

                VoiceChooser voiceChooser = new VoiceChooser(notification);
                voiceChooser.addActionListener(e -> onChangeListener.run());
                this.settings.add(PanelUtils.createIconComponent(Icons.SPEECH, "The voice to generate speech with", voiceChooser));
                break;
        }

        VolumeSlider volumeSlider = new VolumeSlider(notification);
        volumeSlider.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
        volumeSlider.addChangeListener(e -> onChangeListener.run());
        this.settings.add(PanelUtils.createIconComponent(Icons.VOLUME, "The volume to playback speech", volumeSlider));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.WatchdogProperties;
import com.adamk33n3r.runelite.watchdog.notifications.SoundEffect;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.notifications.VolumeSlider;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.plugins.info.JRichTextPane;
import net.runelite.client.ui.ColorScheme;

import javax.swing.JSpinner;

public class SoundEffectNotificationPanel extends NotificationPanel {

    public SoundEffectNotificationPanel(SoundEffect soundEffect, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(soundEffect, parentPanel, onChangeListener, onRemove);

        JRichTextPane richTextPane = new JRichTextPane();
        richTextPane.setContentType("text/html");
        richTextPane.setText("<html>Go to <a href='" + WatchdogProperties.getProperties().getProperty("watchdog.wikiPage.soundIDs") + "'>this wiki page</a> to get a list<br>of sound ids</html>");
        this.settings.add(richTextPane);
        JSpinner soundID = PanelUtils.createSpinner(soundEffect.getSoundID(), 0, 99999, 1, (val) -> {
            soundEffect.setSoundID(val);
            onChangeListener.run();
        });
        this.settings.add(soundID);

        VolumeSlider volumeSlider = new VolumeSlider(soundEffect);
        volumeSlider.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
        volumeSlider.addChangeListener(e -> onChangeListener.run());
        this.settings.add(PanelUtils.createIconComponent(
            Icons.VOLUME,
            "The volume to playback sound effect (if muted in game, otherwise will use game setting)",
            volumeSlider
        ));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.RequestFocus;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import javax.swing.JCheckBox;

public class RequestFocusNotificationPanel extends NotificationPanel {
    public RequestFocusNotificationPanel(RequestFocus notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);

        JCheckBox force = PanelUtils.createCheckbox(
            "Force",
            "Force window focus (bring to foreground)",
            notification.isForceFocus(),
            (val) -> {
                notification.setForceFocus(val);
                onChangeListener.run();
            }
        );
        this.settings.add(force);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.Overhead;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.components.ColorJButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

import javax.swing.JSpinner;

public class OverheadNotificationPanel extends MessageNotificationPanel {
    public OverheadNotificationPanel(Overhead notification, NotificationsPanel parentPanel, ColorPickerManager colorPickerManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, true, parentPanel, onChangeListener, onRemove);

        ColorJButton colorPickerBtn = PanelUtils.createColorPicker(
            "Pick a color",
            "The color of the overhead text. Right click to reset.",
            "Text Color",
            this,
            notification.getTextColor(),
            colorPickerManager,
            false,
            val -> {
                notification.setTextColor(val);
                onChangeListener.run();
            });
        this.settings.add(colorPickerBtn);

        JSpinner displayTime = PanelUtils.createSpinner(notification.getDisplayTime(), 1, 99, 1, val -> {
            notification.setDisplayTime(val);
            onChangeListener.run();
        });
        this.settings.add(PanelUtils.createIconComponent(Icons.CLOCK, "Time to display overhead in seconds", displayTime));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.LengthLimitFilter;
import com.adamk33n3r.runelite.watchdog.SimpleDocumentListener;
import com.adamk33n3r.runelite.watchdog.notifications.Overlay;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.components.ColorJButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

import javax.swing.JCheckBox;
import javax.swing.JFileChooser;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import javax.swing.text.AbstractDocument;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;

public class OverlayNotificationPanel extends MessageNotificationPanel {
    private JPanel displayTime;
    private JPanel stickyId;

    public OverlayNotificationPanel(Overlay notification, NotificationsPanel parentPanel, ColorPickerManager colorPickerManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, true, parentPanel, onChangeListener, onRemove);

        ColorJButton fgColorPicker = PanelUtils.createColorPicker(
            "Pick a color",
            "The text color of the notification",
            "Text Color",
            this,
            notification.getTextColor(),
            colorPickerManager,
            false,
            val -> {
                notification.setTextColor(val);
                onChangeListener.run();
            }
        );
        this.settings.add(fgColorPicker);

        ColorJButton colorPicker = PanelUtils.createColorPicker(
            "Pick a color",
            "The background color of the notification",
            "Background Color",
            this,
            notification.getColor(),
            colorPickerManager,
            true,
            val -> {
                notification.setColor(val);
                onChangeListener.run();
            }
        );
        this.settings.add(colorPicker);

        this.settings.add(PanelUtils.createFileChooser(null, "Path to the image file", ev -> {
            JFileChooser fileChooser = (JFileChooser) ev.getSource();
            notification.setImagePath(fileChooser.getSelectedFile().getAbsolutePath());
            onChangeListener.run();
        }, notification.getImagePath(), "Image Files", "png", "jpg"));

        JCheckBox sticky = PanelUtils.createCheckbox("Sticky", "Set the notification to not expire", notification.isSticky(), val -> {
            notification.setSticky(val);
            if (val) {
                this.settings.remove(this.displayTime);
                this.settings.add(this.stickyId);
            } else {
                this.settings.remove(this.stickyId);
                this.settings.add(this.displayTime);
            }
            this.revalidate();
            onChangeListener.run();
        });
        this.settings.add(sticky);

        JSpinner displayTime = PanelUtils.createSpinner(notification.getTimeToLive(), 1, 999, 1, val -> {
            notification.setTimeToLive(val);
            onChangeListener.run();
        });
        this.displayTime = PanelUtils.createIconComponent(Icons.CLOCK, "Time to display in seconds", displayTime);

        FlatTextArea flatTextArea = new FlatTextArea("ID to use with Dismiss Overlay...", true);
        flatTextArea.setText(notification.getId());
        ((AbstractDocument) flatTextArea.getDocument()).setDocumentFilter(new LengthLimitFilter(200));
        flatTextArea.getDocument().addDocumentListener((SimpleDocumentListener) ev -> {
            notification.setId(flatTextArea.getText());
        });
        flatTextArea.getTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                flatTextArea.getTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChangeListener.run();
            }
        });
        this.stickyId = flatTextArea;

        if (notification.isSticky()) {
            this.settings.add(this.stickyId);
        } else {
            this.settings.add(this.displayTime);
        }
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.Sound;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.notifications.VolumeSlider;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.ColorScheme;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioSystem;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JSpinner;
import java.util.Arrays;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class SoundNotificationPanel extends NotificationPanel {

    public SoundNotificationPanel(Sound sound, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(sound, parentPanel, onChangeListener, onRemove);

        String[] supportedExtensions = Stream.concat(
            Arrays.stream(AudioSystem.getAudioFileTypes())
                .map(AudioFileFormat.Type::getExtension),
            Stream.of("mp3")
        ).toArray(String[]::new);
        this.settings.add(new JLabel("Choose sound (" + Arrays.stream(supportedExtensions).map(ext -> '.' + ext).collect(Collectors.joining(", ")) + ")"));
        this.settings.add(PanelUtils.createFileChooser(null, "Path to the sound file", ev -> {
            JFileChooser fileChooser = (JFileChooser) ev.getSource();
            sound.setPath(fileChooser.getSelectedFile().getAbsolutePath());
            onChangeListener.run();
        }, sound.getPath(), "Sound Files", supportedExtensions));

        VolumeSlider volumeSlider = new VolumeSlider(sound);
        volumeSlider.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
        volumeSlider.addChangeListener(e -> onChangeListener.run());
        this.settings.add(PanelUtils.createIconComponent(Icons.VOLUME, "The volume to playback sound", volumeSlider));

        JSpinner repeatDuration = PanelUtils.createSpinner(sound.getRepeatDuration(), -1, 120, 1, val -> {
            sound.setRepeatDuration(val);
            onChangeListener.run();
        });
        this.settings.add(PanelUtils.createIconComponent(Icons.CLOCK, "Duration to repeat sound, use -1 to repeat until cancelled", repeatDuration));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.LengthLimitFilter;
import com.adamk33n3r.runelite.watchdog.SimpleDocumentListener;
import com.adamk33n3r.runelite.watchdog.notifications.DismissOverlay;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import javax.swing.text.AbstractDocument;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;

public class DismissOverlayNotificationPanel extends NotificationPanel {
    public DismissOverlayNotificationPanel(DismissOverlay notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);

        FlatTextArea flatTextArea = new FlatTextArea("Enter the ID of the overlay...", true);
        flatTextArea.setText(notification.getDismissId());
        ((AbstractDocument) flatTextArea.getDocument()).setDocumentFilter(new LengthLimitFilter(200));
        flatTextArea.getDocument().addDocumentListener((SimpleDocumentListener) ev -> {
            notification.setDismissId(flatTextArea.getText());
        });
        flatTextArea.getTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                flatTextArea.getTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChangeListener.run();
            }
        });
        this.settings.add(flatTextArea);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.Popup;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;
import net.runelite.client.ui.components.ColorJButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

import java.awt.*;

public class PopupNotificationPanel extends MessageNotificationPanel {
    public PopupNotificationPanel(Popup notification, NotificationsPanel parentPanel, ColorPickerManager colorPickerManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, true, parentPanel, onChangeListener, onRemove);

        Component message = this.settings.getComponent(0);
        this.settings.remove(message);

        FlatTextArea title = PanelUtils.createTextArea(
            "Title. Empty uses the alert's name.",
            "The title of the popup. Leave empty to use the alert's name. Also supports formatting and capture groups.",
            notification.getTitle(),
            notification::setTitle
        );

        this.settings.add(title);
        this.settings.add(message);

        ColorJButton textColorPicker = PanelUtils.createColorPicker(
            "Pick a color",
            "The text color of the notification",
            "Text Color",
            this,
            notification.getTextColor(),
            colorPickerManager,
            false,
            val -> {
                notification.setTextColor(val);
                onChangeListener.run();
            }
        );
        this.settings.add(textColorPicker);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.alerts.FlashMode;
import com.adamk33n3r.runelite.watchdog.notifications.ScreenFlash;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.components.ColorJButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

import javax.swing.DefaultListCellRenderer;
import javax.swing.JComboBox;
import javax.swing.JSpinner;

public class ScreenFlashNotificationPanel extends NotificationPanel {
    public ScreenFlashNotificationPanel(ScreenFlash screenFlash, NotificationsPanel parentPanel, ColorPickerManager colorPickerManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(screenFlash, parentPanel, onChangeListener, onRemove);

        ColorJButton colorPickerBtn = PanelUtils.createColorPicker(
            "Pick a color",
            "The color to flash the screen",
            "Flash Color",
            this,
            screenFlash.getColor(),
            colorPickerManager,
            true,
            val -> {
                screenFlash.setColor(val);
                onChangeListener.run();
            });
        this.settings.add(colorPickerBtn);

        JComboBox<FlashMode> flashModeSelect = new JComboBox<>(FlashMode.values());
        flashModeSelect.setToolTipText("The screen flash mode");
        // TODO: Would be nice to move this somewhere else on import or something
        if (screenFlash.getFlashMode() == null) {
            screenFlash.setFlashMode(FlashMode.FLASH);
            if (screenFlash.getFlashDuration() == 0) {
                screenFlash.setFlashDuration(2);
            }
        }
        flashModeSelect.setSelectedItem(screenFlash.getFlashMode());
        flashModeSelect.setRenderer((list, value, index, isSelected, cellHasFocus) -> {
            list.setToolTipText(value.getTooltip());
            return new DefaultListCellRenderer().getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
        });
        flashModeSelect.addActionListener(e -> {
            screenFlash.setFlashMode(flashModeSelect.getItemAt(flashModeSelect.getSelectedIndex()));
            onChangeListener.run();
        });
        this.settings.add(flashModeSelect);

        JSpinner flashDuration = PanelUtils.createSpinner(screenFlash.getFlashDuration(), 0, 120, 1, val -> {
            screenFlash.setFlashDuration(val);
            onChangeListener.run();
        });
        this.settings.add(PanelUtils.createIconComponent(Icons.CLOCK, "Duration of flash, use 0 to flash until cancelled", flashDuration));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.LengthLimitFilter;
import com.adamk33n3r.runelite.watchdog.SimpleDocumentListener;
import com.adamk33n3r.runelite.watchdog.notifications.DismissScreenMarker;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import javax.swing.text.AbstractDocument;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;

public class DismissScreenMarkerNotificationPanel extends NotificationPanel {
    public DismissScreenMarkerNotificationPanel(DismissScreenMarker notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);

        FlatTextArea flatTextArea = new FlatTextArea("Enter the ID of the screen marker...", true);
        flatTextArea.setText(notification.getDismissId());
        ((AbstractDocument) flatTextArea.getDocument()).setDocumentFilter(new LengthLimitFilter(200));
        flatTextArea.getDocument().addDocumentListener((SimpleDocumentListener) ev -> {
            notification.setDismissId(flatTextArea.getText());
        });
        flatTextArea.getTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                flatTextArea.getTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChangeListener.run();
            }
        });
        this.settings.add(flatTextArea);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.LengthLimitFilter;
import com.adamk33n3r.runelite.watchdog.SimpleDocumentListener;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.notifications.ScreenMarker;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker.ScreenMarkerOverlay;
import com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker.ScreenMarkerUtil;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

import javax.swing.*;
import javax.swing.text.AbstractDocument;
import java.awt.GridLayout;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;

public class ScreenMarkerNotificationPanel extends NotificationPanel {
    private ScreenMarkerOverlay screenMarkerOverlay;
    private JButton setMarkerButton;
    private JPanel displayTime;
    private JPanel stickyId;

    public ScreenMarkerNotificationPanel(ScreenMarker notification, NotificationsPanel parentPanel, ColorPickerManager colorPickerManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);
        // Rebind onRemove to hook into it so that we can delete the screen marker when this notification is deleted
        // Perhaps this should be refactored
        this.onRemove = (ele) -> {
            ScreenMarkerUtil screenMarkerUtil = WatchdogPlugin.getInstance().getScreenMarkerUtil();
            if (this.screenMarkerOverlay != null) {
                screenMarkerUtil.deleteMarker(this.screenMarkerOverlay);
            }
            screenMarkerUtil.finishCreation(true);
            onRemove.elementRemoved(ele);
        };

        net.runelite.client.plugins.screenmarkers.ScreenMarker screenMarker = notification.getScreenMarker();

        FlatTextArea markerLabel = new FlatTextArea("Optional marker label...", true);
        markerLabel.setText(screenMarker.getName());
        ((AbstractDocument) markerLabel.getDocument()).setDocumentFilter(new LengthLimitFilter(200));
        markerLabel.getDocument().addDocumentListener((SimpleDocumentListener) ev -> {
            screenMarker.setName(markerLabel.getText());
            screenMarker.setLabelled(!markerLabel.getText().isEmpty());
        });
        markerLabel.getTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                markerLabel.getTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChangeListener.run();
            }
        });
        this.settings.add(markerLabel);

        this.settings.add(PanelUtils.createColorPicker(
            "Border Color",
            "The color of the border",
            "Border Color",
            this,
            notification.getScreenMarker().getColor(),
            colorPickerManager,
            true,
            val -> {
               screenMarker.setColor(val);
               onChangeListener.run();
            }));

        this.settings.add(PanelUtils.createColorPicker(
            "Fill Color",
            "The color of the interior",
            "Fill Color",
            this,
            notification.getScreenMarker().getFill(),
            colorPickerManager,
            true,
            val -> {
                screenMarker.setFill(val);
                onChangeListener.run();
            }));

        this.setMarkerButton = PanelUtils.createButton("Set Marker", "Set Marker", (btn, modifiers) -> {
            ScreenMarkerUtil screenMarkerUtil = WatchdogPlugin.getInstance().getScreenMarkerUtil();
            // Done
            if (screenMarkerUtil.isCreatingScreenMarker()) {
                this.screenMarkerOverlay = screenMarkerUtil.finishCreation(false);
                this.setMarkerButton.setText("Set Marker");
                this.setMarkerButton.setToolTipText("Set Marker");
                // Start
            } else {
                if (this.screenMarkerOverlay != null) {
                    screenMarkerUtil.deleteMarker(this.screenMarkerOverlay);
                }
                screenMarkerUtil.setMouseListenerEnabled(true);
                screenMarkerUtil.setCreatingScreenMarker(true);
                screenMarkerUtil.setCurrentMarker(notification);
                this.setMarkerButton.setText("Finish");
                this.setMarkerButton.setToolTipText("Finish");
            }
        });
        this.settings.add(this.setMarkerButton);

        JSpinner thickness = PanelUtils.createSpinner(
            screenMarker.getBorderThickness(),
            0,
            Integer.MAX_VALUE,
            1,
            val -> {
                screenMarker.setBorderThickness(val);
                onChangeListener.run();
            }
        );

        JCheckBox sticky = PanelUtils.createCheckbox("Sticky", "Set the notification to not expire", notification.isSticky(), val -> {
            notification.setSticky(val);
            if (val) {
                this.settings.remove(this.displayTime);
                this.settings.add(this.stickyId);
            } else {
                this.settings.remove(this.stickyId);
                this.settings.add(this.displayTime);
            }
            this.revalidate();
            onChangeListener.run();
        });

        JSpinner displayTime = PanelUtils.createSpinner(notification.getDisplayTime(), 0, 99, 1, val -> {
            notification.setDisplayTime(val);
            onChangeListener.run();
        });
        JPanel borderThickness = PanelUtils.createIconComponent(Icons.BORDER_OUTSIDE, "Border thickness", thickness);
        this.displayTime = PanelUtils.createIconComponent(Icons.CLOCK, "Time to display the marker in seconds.", displayTime);
        JPanel sub = new JPanel(new GridLayout(1, 2, 3, 3));
        sub.add(borderThickness);
        sub.add(sticky);
        sub.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        this.settings.add(sub);

        FlatTextArea stickyId = new FlatTextArea("ID to use with Dismiss Overlay...", true);
        stickyId.setText(notification.getId());
        ((AbstractDocument) stickyId.getDocument()).setDocumentFilter(new LengthLimitFilter(200));
        stickyId.getDocument().addDocumentListener((SimpleDocumentListener) ev -> {
            notification.setId(stickyId.getText());
        });
        stickyId.getTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                stickyId.getTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChangeListener.run();
            }
        });
        this.stickyId = stickyId;

        if (notification.isSticky()) {
            this.settings.add(this.stickyId);
        } else {
            this.settings.add(this.displayTime);
        }
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.LengthLimitFilter;
import com.adamk33n3r.runelite.watchdog.SimpleDocumentListener;
import com.adamk33n3r.runelite.watchdog.notifications.MessageNotification;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import javax.swing.text.AbstractDocument;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;

public class MessageNotificationPanel extends NotificationPanel {
    public MessageNotificationPanel(MessageNotification notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        this(notification, false, parentPanel, onChangeListener, onRemove);
    }

    public MessageNotificationPanel(MessageNotification notification, boolean supportsFormattingTags, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);

        FlatTextArea flatTextArea = new FlatTextArea(supportsFormattingTags ? "Enter your formatted message..." : "Enter your message...", true);
        flatTextArea.setText(notification.getMessage());
        ((AbstractDocument) flatTextArea.getDocument()).setDocumentFilter(new LengthLimitFilter(200));
        flatTextArea.getDocument().addDocumentListener((SimpleDocumentListener) ev -> {
            notification.setMessage(flatTextArea.getText());
        });
        flatTextArea.getTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                flatTextArea.getTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChangeListener.run();
            }
        });
        this.settings.add(flatTextArea);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.LengthLimitFilter;
import com.adamk33n3r.runelite.watchdog.SimpleDocumentListener;
import com.adamk33n3r.runelite.watchdog.notifications.Dink;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;
import net.runelite.client.config.ConfigManager;

import javax.swing.*;
import javax.swing.text.AbstractDocument;
import java.awt.*;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;

public class DinkNotificationPanel extends NotificationPanel {
    private final ConfigManager configManager;

    public DinkNotificationPanel(Dink notification, NotificationsPanel parentPanel, ConfigManager configManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);
        this.configManager = configManager;

        this.rebuild();
    }

    private void rebuild() {
        this.settings.removeAll();

        Dink notification = (Dink) this.notification;

        String installedPlugins = configManager.getConfiguration("runelite", "externalPlugins");
        if (!installedPlugins.contains("dink")) {
            JLabel installDinkLabel = new JLabel("<html>Install the Dink plugin to use this Notification type</html>");
            installDinkLabel.setFont(new Font(installDinkLabel.getFont().getFontName(), Font.ITALIC | Font.BOLD, installDinkLabel.getFont().getSize()));
            this.settings.add(installDinkLabel);
            return;
        }

        boolean externalEnabled = configManager.getConfiguration("dinkplugin", "notifyExternal").equals("true");
        if (!externalEnabled) {
            JLabel enableExternalLabel = new JLabel("<html>Enable External Plugin Notifications in Dink's config to use this Notification type</html>");
            enableExternalLabel.setFont(new Font(enableExternalLabel.getFont().getFontName(), Font.ITALIC | Font.BOLD, enableExternalLabel.getFont().getSize()));
            this.settings.add(enableExternalLabel);
            return;
        }

        FlatTextArea flatTextArea = new FlatTextArea("Enter your message...", true);
        flatTextArea.setText(notification.getMessage());
        ((AbstractDocument) flatTextArea.getDocument()).setDocumentFilter(new LengthLimitFilter(4096));
        flatTextArea.getDocument().addDocumentListener((SimpleDocumentListener) ev -> {
            notification.setMessage(flatTextArea.getText());
        });
        flatTextArea.getTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                flatTextArea.getTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChangeListener.run();
            }
        });
        this.settings.add(flatTextArea);

        JCheckBox includeScreenshot = PanelUtils.createCheckbox("Include Screenshot", "Whether or not to include a screenshot in the discord message", notification.isIncludeScreenshot(), (selected) -> {
            notification.setIncludeScreenshot(selected);
            onChangeListener.run();
        });
        this.settings.add(includeScreenshot);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.NotificationType;
import com.adamk33n3r.runelite.watchdog.notifications.Notification;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.StretchedStackedLayout;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.MouseDragEventForwarder;

import lombok.Getter;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

public abstract class NotificationPanel extends JPanel {
    // worldhopper - arrow down
    // screenmarker - border color icon - pencil
    // screenmarker/timetracking - delete icon - X
    // timetracking - notify - bell
    // timetracking - reset - circle arrow - used for in-focus?
    // timetracking - start - right chevron
    // loottracker - back arrow
    // loottracker - collapsed/expanded
    // info - import cloud
    // info - github
    // config - edit/back

    @Getter
    protected Notification notification;
    private final NotificationsPanel parentPanel;
    protected Runnable onChangeListener;
    protected PanelUtils.OnRemove onRemove;
    protected JPanel settings = new JPanel(new StretchedStackedLayout(3));

    private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
        BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
        BorderFactory.createMatteBorder(5, 10, 5, 0, ColorScheme.DARKER_GRAY_COLOR));

    public NotificationPanel(Notification notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        this.notification = notification;
        this.parentPanel = parentPanel;
        this.onChangeListener = onChangeListener;
        this.onRemove = onRemove;

        this.setLayout(new BorderLayout());
        this.setBorder(new EmptyBorder(3, 0, 0, 0));
        this.settings.setBorder(new EmptyBorder(5, 10, 5, 10));
        this.settings.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        this.rebuild();
    }
    private void rebuild() {
        this.removeAll();

        JPanel container = new JPanel(new StretchedStackedLayout(3));
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel nameWrapper = new JPanel(new BorderLayout(3, 3));
        container.add(nameWrapper);

        nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameWrapper.setBorder(NAME_BOTTOM_BORDER);
        NotificationType notificationType = notification.getType();
        JLabel nameLabel = new JLabel(notificationType.getName());
        nameLabel.setToolTipText(notificationType.getTooltip());
        nameWrapper.add(nameLabel, BorderLayout.WEST);

        MouseDragEventForwarder mouseDragEventForwarder = new MouseDragEventForwarder(this.parentPanel.getNotificationContainer());
        nameWrapper.addMouseListener(mouseDragEventForwarder);
        nameWrapper.addMouseMotionListener(mouseDragEventForwarder);
        nameLabel.addMouseListener(mouseDragEventForwarder);
        nameLabel.addMouseMotionListener(mouseDragEventForwarder);

        // Right buttons
        JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 6, 0));
        rightActions.setBorder(new EmptyBorder(4, 0, 0, 0));
        rightActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameWrapper.add(rightActions, BorderLayout.EAST);

        JPanel afkTimerConfigRow = new JPanel(new GridLayout(1, 2));
        afkTimerConfigRow.setBorder(new EmptyBorder(0, 10, 0, 5));
        afkTimerConfigRow.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        JLabel afkTimerLabel = new JLabel("AFK Seconds:");
        afkTimerLabel.setToolTipText("Number of seconds for which the client doesn't get any mouse or keyboard inputs.");
        AtomicInteger previousAFKSeconds = new AtomicInteger(notification.getFireWhenAFKForSeconds());

        JSpinner afkTimerSpinner = PanelUtils.createSpinner(Math.max(notification.getFireWhenAFKForSeconds(), 1),
            1,
            25 * 60,
            1,
            (val) -> {
                notification.setFireWhenAFKForSeconds(val);
                previousAFKSeconds.set(val);
                onChangeListener.run();
            });

        afkTimerConfigRow.add(afkTimerLabel);
        afkTimerConfigRow.add(afkTimerSpinner);
        if (notification.isFireWhenAFK()) {
            container.add(afkTimerConfigRow);
        }

        JButton afkButton = PanelUtils.createToggleActionButton(
            Icons.AFK,
            Icons.AFK_HOVER,
            Icons.NON_AFK,
            Icons.NON_AFK_HOVER,
            "Enable notification even when you are active",
            "Switch to only fire notification when you have been AFK for a certain amount of time",
            notification.isFireWhenAFK(),
            (btn, modifiers) -> {
                notification.setFireWhenAFK(btn.isSelected());
                notification.setFireWhenAFKForSeconds(previousAFKSeconds.get());
                if (notification.isFireWhenAFK()) {
                    afkTimerSpinner.setValue(notification.getFireWhenAFKForSeconds());
                }
                this.rebuild();
                this.revalidate();
                onChangeListener.run();
            });
        rightActions.add(afkButton);

        JPanel delayConfigRow = new JPanel(new GridLayout(1, 2));
        delayConfigRow.setBorder(new EmptyBorder(0, 10, 0, 5));
        delayConfigRow.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        JLabel delayLabel = new JLabel("Delay Time (ms):");
        delayLabel.setToolTipText("Number of milliseconds to wait before firing this notification");
        AtomicInteger previousDelayMilliseconds = new AtomicInteger(notification.getDelayMilliseconds());

        JSpinner delaySpinner = PanelUtils.createSpinner(Math.max(notification.getDelayMilliseconds(), 100),
            100,
            5 * 60000,
            100,
            (val) -> {
                notification.setDelayMilliseconds(val);
                previousDelayMilliseconds.set(val);
                onChangeListener.run();
            });

        delayConfigRow.add(delayLabel);
        delayConfigRow.add(delaySpinner);
        if (notification.isDelayed()) {
            container.add(delayConfigRow);
        }

        AtomicBoolean showDelayMilliseconds = new AtomicBoolean(notification.isDelayed());

        JButton delayButton = PanelUtils.createToggleActionButton(
            Icons.TIMER_REMOVE,
            Icons.TIMER_REMOVE_HOVER,
            Icons.TIMER_PLUS,
            Icons.TIMER_PLUS_HOVER,
            "Turn off delay",
            "Delay notification",
            showDelayMilliseconds.get(),
            (btn, modifiers) -> {
                showDelayMilliseconds.set(!showDelayMilliseconds.get());
                if (showDelayMilliseconds.get()) {
                    notification.setDelayMilliseconds(Math.max(previousDelayMilliseconds.get(), 100));
                    delaySpinner.setValue(notification.getDelayMilliseconds());
                } else {
                    notification.setDelayMilliseconds(0);
                }
                this.rebuild();
                this.revalidate();
                onChangeListener.run();
            });
        rightActions.add(delayButton);

        JButton focusBtn = PanelUtils.createToggleActionButton(
            Icons.FOREGROUND,
            Icons.FOREGROUND_HOVER,
            Icons.BACKGROUND,
            Icons.BACKGROUND_HOVER,
            "Switch to only fire notification while the game is in the background",
            "Switch to fire notifications while the game is in the background and foreground",
            notification.isFireWhenFocused(),
            (btn, modifiers) -> {
                notification.setFireWhenFocused(btn.isSelected());
                onChangeListener.run();
            });
        rightActions.add(focusBtn);

        JButton testBtn = PanelUtils.createActionButton(
            Icons.TEST,
            Icons.TEST_HOVER,
            "Test the notification",
            (btn, modifiers) -> new Thread(() -> {
                this.notification.fireForced(new String[]{ "1", "2", "3", "4", "5" });
            }).start());
        rightActions.add(testBtn);

        JButton deleteBtn = PanelUtils.createActionButton(
            Icons.DELETE,
            Icons.DELETE_HOVER,
            "Remove this notification",
            (btn, modifiers) -> this.onRemove.elementRemoved(this));
        rightActions.add(deleteBtn);


        container.add(this.settings);

        this.add(container, BorderLayout.CENTER);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.PluginMessage;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextAreaNamespace;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;

public class PluginMessageNotificationPanel extends NotificationPanel {
    public PluginMessageNotificationPanel(PluginMessage notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);

        this.rebuild();
    }
    private void rebuild() {
        this.settings.removeAll();

        PluginMessage notification = (PluginMessage) this.notification;

        FlatTextAreaNamespace fullText = PanelUtils.createTextFieldNamespace(
            "Namespace",
            "The namespace of the plugin message. Usually the name of the plugin.",
            notification.getNamespace(),
            "Method",
            "The method or action of the plugin message.",
            notification.getName(),
            (val1, val2) -> {
                notification.setNamespace(val1);
                notification.setName(val2);
                onChangeListener.run();
            }
        );
        fullText.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        this.settings.add(fullText);

        FlatTextArea dataText = PanelUtils.createTextField(
            "Data (JSON)",
            "The data of the plugin message as a JSON object string. Leave empty if not needed.",
            notification.getData(),
            val -> {
                notification.setData(val);
                onChangeListener.run();
            }
        );
        this.settings.add(dataText);
    }
}

/*
 * Copyright (c) 2018, Jasper <Jasper0781@gmail.com>
 * Copyright (c) 2020, melky <https://github.com/melkypie>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker;

import net.runelite.api.Client;
import net.runelite.api.MenuEntry;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;

class ScreenMarkerWidgetHighlightOverlay extends Overlay
{
    private final ScreenMarkerUtil util;
    private final Client client;

    @Inject
    private ScreenMarkerWidgetHighlightOverlay(final ScreenMarkerUtil util, final Client client)
    {
        this.util = util;
        this.client = client;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(PRIORITY_HIGH);
        setMovable(true);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!util.isCreatingScreenMarker() || util.isDrawingScreenMarker())
        {
            return null;
        }

        final MenuEntry[] menuEntries = client.getMenuEntries();
        if (client.isMenuOpen() || menuEntries.length == 0)
        {
            util.setSelectedWidgetBounds(null);
            return null;
        }

        final MenuEntry menuEntry = menuEntries[menuEntries.length - 1];
        final int childIdx = menuEntry.getParam0();
        final int widgetId = menuEntry.getParam1();

        final Widget widget = client.getWidget(widgetId);
        if (widget == null)
        {
            util.setSelectedWidgetBounds(null);
            return null;
        }

        Rectangle bounds = null;
        if (childIdx > -1)
        {
            final Widget child = widget.getChild(childIdx);
            if (child != null)
            {
                bounds = child.getBounds();
            }
        }
        else
        {
            bounds = widget.getBounds();
        }

        if (bounds == null)
        {
            util.setSelectedWidgetBounds(null);
            return null;
        }

        drawHighlight(graphics, bounds);
        util.setSelectedWidgetBounds(bounds);

        return null;
    }

    private static void drawHighlight(Graphics2D graphics, Rectangle bounds)
    {
        graphics.setColor(Color.GREEN);
        graphics.draw(bounds);
    }
}

/*
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.notifications.ScreenMarker;

import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import lombok.Getter;
import lombok.NonNull;

import javax.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.time.Duration;
import java.time.Instant;

public class ScreenMarkerOverlay extends Overlay {
    @Getter
    private final ScreenMarker marker;
    private final ScreenMarkerRenderable screenMarkerRenderable;
    private final Instant timeStarted;

    @Inject
    private Client client;

    @Inject
    private ClientUI clientUI;

    @Inject
    private WatchdogConfig config;

    private long mouseLastPressedMillis;

    ScreenMarkerOverlay(@NonNull ScreenMarker marker)
    {
        this.marker = marker;
        this.screenMarkerRenderable = new ScreenMarkerRenderable();
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ALWAYS_ON_TOP);
        setPriority(PRIORITY_HIGH);
        setMovable(true);
        setResizable(true);
        setMinimumSize(16);
        setResettable(false);
        this.addMenuEntry(MenuAction.RUNELITE_OVERLAY, "Dismiss", "Watchdog screen marker", (me) -> WatchdogPlugin.getInstance().getScreenMarkerUtil().removeScreenMarker(marker));
        this.timeStarted = Instant.now();
    }

    public boolean isExpired() {
        return this.timeStarted.plus(Duration.ofSeconds(this.marker.getDisplayTime())).isBefore(Instant.now());
    }

    @Override
    public String getName()
    {
        return "watchdog.marker" + marker.getScreenMarker().getId();
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        net.runelite.client.plugins.screenmarkers.ScreenMarker marker = this.marker.getScreenMarker();

        if (!this.marker.isSticky() && this.isExpired()) {
            WatchdogPlugin.getInstance().getScreenMarkerUtil().removeScreenMarker(this.marker);
            return null;
        }

        if (!marker.isVisible())
        {
            return null;
        }

        Dimension preferredSize = getPreferredSize();
        if (preferredSize == null)
        {
            // overlay has no preferred size in the renderer configuration!
            return null;
        }

        screenMarkerRenderable.setBorderThickness(marker.getBorderThickness());
        screenMarkerRenderable.setColor(marker.getColor());
        screenMarkerRenderable.setFill(marker.getFill());
        screenMarkerRenderable.setStroke(new BasicStroke(marker.getBorderThickness()));
        screenMarkerRenderable.setSize(preferredSize);
        screenMarkerRenderable.setLabel(marker.isLabelled() ? marker.getName() : "");
        return screenMarkerRenderable.render(graphics);
    }
}

/*
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker;

import com.adamk33n3r.runelite.watchdog.notifications.ScreenMarker;

import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Stroke;

class ScreenMarkerCreationOverlay extends Overlay
{
    private final ScreenMarkerUtil plugin;

    @Inject
    private ScreenMarkerCreationOverlay(final ScreenMarkerUtil plugin)
    {
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(PRIORITY_HIGH);
        setMovable(true);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        ScreenMarker screenMarker = plugin.getCurrentMarker();

        if (screenMarker == null)
        {
            return null;
        }

        int thickness = screenMarker.getScreenMarker().getBorderThickness();
        int offset = thickness / 2;
        int width = getBounds().width - thickness;
        int height = getBounds().height - thickness;

        graphics.setStroke(createStripedStroke(thickness));
        graphics.setColor(screenMarker.getScreenMarker().getColor());
        graphics.drawRect(offset, offset, width, height);

        return getBounds().getSize();
    }

    private Stroke createStripedStroke(int thickness)
    {
        return new BasicStroke(thickness, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{9}, 0);
    }
}

/*
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker;

import net.runelite.client.input.MouseAdapter;

import javax.swing.SwingUtilities;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;

class ScreenMarkerMouseListener extends MouseAdapter
{
    private final ScreenMarkerUtil util;

    ScreenMarkerMouseListener(ScreenMarkerUtil util)
    {
        this.util = util;
    }

    @Override
    public MouseEvent mouseClicked(MouseEvent event)
    {
        if (SwingUtilities.isMiddleMouseButton(event))
        {
            return event;
        }

        event.consume();
        return event;
    }

    @Override
    public MouseEvent mousePressed(MouseEvent event)
    {
        if (SwingUtilities.isMiddleMouseButton(event))
        {
            return event;
        }

        if (SwingUtilities.isLeftMouseButton(event))
        {
            final Rectangle bounds = util.getSelectedWidgetBounds();

            if (bounds != null)
            {
                util.startCreation(bounds.getLocation(), bounds.getSize());
            }
            else
            {
                util.startCreation(event.getPoint());
            }
        }
        else if (util.isCreatingScreenMarker())
        {
            util.finishCreation(true);
        }

        event.consume();
        return event;
    }

    @Override
    public MouseEvent mouseReleased(MouseEvent event)
    {
        if (SwingUtilities.isMiddleMouseButton(event))
        {
            return event;
        }

        if (SwingUtilities.isLeftMouseButton(event) && util.isCreatingScreenMarker())
        {
            /* Set the creation panel as "ready" (because the marker area as been drawn) */
            // Was probably a widget misclick, reset drawing state
            if (util.getOverlay().getPreferredSize().height == 2 && util.getOverlay().getPreferredSize().width == 2) {
                util.setDrawingScreenMarker(false);
            } else {
                util.completeSelection();
            }
        }

        event.consume();
        return event;
    }

    @Override
    public MouseEvent mouseDragged(MouseEvent event)
    {
        if (!util.isCreatingScreenMarker())
        {
            return event;
        }

        if (SwingUtilities.isLeftMouseButton(event))
        {
            util.resizeMarker(event.getPoint());
        }

        return event;
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker;

import com.adamk33n3r.runelite.watchdog.notifications.ScreenMarker;

import net.runelite.client.config.ConfigManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.overlay.OverlayManager;

import com.google.gson.Gson;
import lombok.Getter;
import lombok.Setter;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class ScreenMarkerUtil {
    private static final Dimension DEFAULT_SIZE = new Dimension(2, 2);

    @Getter
    private final List<ScreenMarkerOverlay> screenMarkers = new ArrayList<>();

    @Inject
    private ConfigManager configManager;

    @Inject
    private MouseManager mouseManager;

    @Inject
    private OverlayManager overlayManager;

    @Getter
    @Inject
    private ScreenMarkerCreationOverlay overlay;

    @Inject
    private Gson gson;

    @Getter
    @Inject
    private ColorPickerManager colorPickerManager;

    @Inject
    private ScreenMarkerWidgetHighlightOverlay widgetHighlight;

    private final ScreenMarkerMouseListener mouseListener;

    @Getter @Setter
    private ScreenMarker currentMarker;

    @Getter @Setter
    private boolean creatingScreenMarker = false;
    @Getter @Setter
    private boolean drawingScreenMarker = false;

    @Getter @Setter
    private Rectangle selectedWidgetBounds = null;
    private Point startLocation = null;

    public ScreenMarkerUtil() {
        this.mouseListener = new ScreenMarkerMouseListener(this);
    }

    public void startUp() {
        this.overlayManager.add(this.overlay);
        this.overlayManager.add(this.widgetHighlight);
    }

    public void setMouseListenerEnabled(boolean enabled) {
        if (enabled) {
            this.mouseManager.registerMouseListener(this.mouseListener);
        } else {
            this.mouseManager.unregisterMouseListener(this.mouseListener);
        }
    }

    public void startCreation(Point location)
    {
        startCreation(location, DEFAULT_SIZE);

        // Stop the highlighting so we don't get rectangles around widgets while trying to make normal screen markers
        if (selectedWidgetBounds == null)
        {
            drawingScreenMarker = true;
        }
    }

    public void startCreation(Point location, Dimension size)
    {
//        currentMarker = new ScreenMarker(
//            Instant.now().toEpochMilli(),
//            "Marker " + (screenMarkers.size() + 1),
//            3,
//            Color.GREEN,
//            new Color(0, 255, 0, 0),
////            pluginPanel.getSelectedBorderThickness(),
////            pluginPanel.getSelectedColor(),
////            pluginPanel.getSelectedFillColor(),
//            true,
//            false //marker.name.length > 1
//        );

        // Set overlay creator bounds to current position and default size
        startLocation = location;
        overlay.setPreferredLocation(location);
        overlay.setPreferredSize(size);
    }

    public ScreenMarkerOverlay finishCreation(boolean aborted)
    {
        ScreenMarker marker = currentMarker;
        ScreenMarkerOverlay screenMarkerOverlay = null;
        if (!aborted && marker != null)
        {
            screenMarkerOverlay = new ScreenMarkerOverlay(marker);
            screenMarkerOverlay.setPreferredLocation(overlay.getBounds().getLocation());
            screenMarkerOverlay.setPreferredSize(overlay.getBounds().getSize());

            screenMarkers.add(screenMarkerOverlay);
            overlayManager.saveOverlay(screenMarkerOverlay);
            overlayManager.add(screenMarkerOverlay);
//            pluginPanel.rebuild();
        }

        creatingScreenMarker = false;
        drawingScreenMarker = false;
        selectedWidgetBounds = null;
        startLocation = null;
        currentMarker = null;
        setMouseListenerEnabled(false);

//        pluginPanel.setCreation(false);
        return screenMarkerOverlay;
    }

    public void completeSelection()
    {
//        pluginPanel.getCreationPanel().unlockConfirm();
    }

    public void deleteMarker(final ScreenMarkerOverlay marker)
    {
        screenMarkers.remove(marker);
        overlayManager.remove(marker);
        overlayManager.resetOverlay(marker);
//        pluginPanel.rebuild();
    }

    void resizeMarker(Point point)
    {
        drawingScreenMarker = true;
        Rectangle bounds = new Rectangle(startLocation);
        bounds.add(point);
        overlay.setPreferredLocation(bounds.getLocation());
        overlay.setPreferredSize(bounds.getSize());
    }

    public void addScreenMarker(ScreenMarker screenMarker) {
        ScreenMarkerOverlay screenMarkerOverlay = new ScreenMarkerOverlay(screenMarker);
        this.screenMarkers.add(screenMarkerOverlay);
        this.overlayManager.add(screenMarkerOverlay);
    }

    public void removeScreenMarker(ScreenMarker screenMarker) {
        this.screenMarkers.removeIf(overlay -> overlay.getMarker() == screenMarker);
        this.overlayManager.removeIf(overlay -> overlay instanceof ScreenMarkerOverlay && ((ScreenMarkerOverlay) overlay).getMarker() == screenMarker);
    }

    public void removeScreenMarkerById(String id) {
        this.screenMarkers.removeIf(overlay -> overlay.getMarker().getId().equals(id));
        this.overlayManager.removeIf(overlay -> overlay instanceof ScreenMarkerOverlay && ((ScreenMarkerOverlay) overlay).getMarker().getId().equals(id));
    }

    public void removeAllMarkers() {
        this.screenMarkers.clear();
        this.overlayManager.removeIf(ScreenMarkerOverlay.class::isInstance);
    }

    public void shutDown() {
        overlayManager.remove(overlay);
        overlayManager.remove(widgetHighlight);
        overlayManager.removeIf(ScreenMarkerOverlay.class::isInstance);
        screenMarkers.clear();
        this.setMouseListenerEnabled(false);
        this.creatingScreenMarker = false;
        this.drawingScreenMarker = false;

        currentMarker = null;
        selectedWidgetBounds = null;
    }
}

/*
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker;

import net.runelite.client.ui.overlay.RenderableEntity;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Stroke;

@Getter(AccessLevel.PACKAGE)
@Setter(AccessLevel.PACKAGE)
class ScreenMarkerRenderable implements RenderableEntity
{
    private Dimension size;
    private int borderThickness;
    private Color color;
    private Color fill;
    private Stroke stroke;
    private String label;

    @Override
    public Dimension render(Graphics2D graphics)
    {
        int thickness = borderThickness;
        int width = size.width;
        int height = size.height;

        //draw the fill
        graphics.setColor(fill);
        graphics.fillRect(thickness, thickness, width - thickness * 2, height - thickness * 2);

        //because the stroke is centered on the rectangle we draw, we need to translate where we draw the rectangle
        //this is to ensure that the rectangle we draw is our preferred size
        int offset = thickness / 2;
        graphics.setColor(color);
        graphics.setStroke(stroke);
        graphics.drawRect(offset, offset, width - thickness, height - thickness);

        if (!label.isEmpty())
        {
            graphics.drawString(label, 0, 0);
        }

        return size;
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications;

import com.adamk33n3r.runelite.watchdog.notifications.TextToSpeech;
import com.adamk33n3r.runelite.watchdog.notifications.tts.Voice;

import javax.swing.DefaultListCellRenderer;
import javax.swing.JComboBox;

public class VoiceChooser extends JComboBox<Voice> {
    public VoiceChooser(TextToSpeech notification) {
        super(Voice.values());
        this.setSelectedItem(notification.getLegacyVoice());
        this.setRenderer((list, value, index, isSelected, cellHasFocus) -> {
            list.setToolTipText(value.toString());
            return new DefaultListCellRenderer().getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
        });
        this.addActionListener(ev -> notification.setLegacyVoice(this.getItemAt(this.getSelectedIndex())));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications;

import com.adamk33n3r.runelite.watchdog.notifications.IAudioNotification;

import javax.swing.JSlider;

public class VolumeSlider extends JSlider {

    public VolumeSlider(IAudioNotification audioNotification) {
        super(0, 10, audioNotification.getGain());
        this.setSnapToTicks(true);
        this.addChangeListener(ev -> audioNotification.setGain(this.getValue()));
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import net.runelite.client.plugins.config.ConfigPlugin;
import net.runelite.client.plugins.info.InfoPanel;
import net.runelite.client.plugins.timetracking.TimeTrackingPlugin;
import net.runelite.client.util.ImageUtil;

import javax.swing.ImageIcon;

public abstract class Icons {
    public static final ImageIcon ADD = new ImageIcon(ImageUtil.loadImageResource(TimeTrackingPlugin.class, "add_icon.png"));

    public static final ImageIcon HELP = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "help_icon.png"), 80));
    public static final ImageIcon HELP_HOVER = new ImageIcon(ImageUtil.luminanceOffset(HELP.getImage(), -80));

    public static final ImageIcon HISTORY = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_history.png"));
    public static final ImageIcon HISTORY_HOVER = new ImageIcon(ImageUtil.luminanceOffset(HISTORY.getImage(), -80));
    public static final ImageIcon TOOLS = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_tools.png"));
    public static final ImageIcon TOOLS_HOVER = new ImageIcon(ImageUtil.luminanceOffset(TOOLS.getImage(), -80));

    public static final ImageIcon DISCORD = new ImageIcon(ImageUtil.loadImageResource(InfoPanel.class, "discord_icon.png"));
    public static final ImageIcon DISCORD_HOVER = new ImageIcon(ImageUtil.luminanceOffset(DISCORD.getImage(), -100));

    public static final ImageIcon KOFI = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "kofi_icon.png"));
    public static final ImageIcon KOFI_HOVER = new ImageIcon(ImageUtil.luminanceOffset(KOFI.getImage(), -100));

    public static final ImageIcon CONFIG = new ImageIcon(ImageUtil.resizeImage(ImageUtil.loadImageResource(Icons.class, "mdi_cog.png"), 14, 14));
    public static final ImageIcon CONFIG_HOVER = new ImageIcon(ImageUtil.luminanceOffset(CONFIG.getImage(), -100));

    public static final ImageIcon EXPORT = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_export-variant.png"));
    public static final ImageIcon EXPORT_HOVER = new ImageIcon(ImageUtil.alphaOffset(EXPORT.getImage(), -120));
    public static final ImageIcon IMPORT = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_import.png"));
    public static final ImageIcon IMPORT_HOVER = new ImageIcon(ImageUtil.alphaOffset(IMPORT.getImage(), -120));
    public static final ImageIcon DELETE = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_delete.png"));
    public static final ImageIcon DELETE_HOVER = new ImageIcon(ImageUtil.luminanceOffset(DELETE.getImage(), -80));
    public static final ImageIcon DOWNLOAD = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_download.png"));

    public static final ImageIcon CLONE = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_content-duplicate.png"));
    public static final ImageIcon CLONE_HOVER = new ImageIcon(ImageUtil.alphaOffset(CLONE.getImage(), -120));
    public static final ImageIcon EDIT = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_pencil.png"));
    public static final ImageIcon EDIT_HOVER = new ImageIcon(ImageUtil.alphaOffset(EDIT.getImage(), -120));
    public static final ImageIcon DRAG_VERT = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_drag-vertical.png"));

    public static final ImageIcon REFRESH = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_refresh.png"));
    public static final ImageIcon REFRESH_HOVER = new ImageIcon(ImageUtil.luminanceOffset(REFRESH.getImage(), -80));

    /*
     * Alerts
     */
    public static final ImageIcon BACK = new ImageIcon(ImageUtil.loadImageResource(ConfigPlugin.class, "config_back_icon.png"));
    public static final ImageIcon BACK_HOVER = new ImageIcon(ImageUtil.alphaOffset(BACK.getImage(), -120));
    public static final ImageIcon REGEX = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_regex.png"), -80));
    public static final ImageIcon REGEX_HOVER = new ImageIcon(ImageUtil.luminanceOffset(REGEX.getImage(), -40));
    public static final ImageIcon REGEX_SELECTED = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_regex-outline.png"));
    public static final ImageIcon REGEX_SELECTED_HOVER = new ImageIcon(ImageUtil.luminanceOffset(REGEX_SELECTED.getImage(), -80));
    public static final ImageIcon PICKER = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_eyedropper.png"));
    public static final ImageIcon PICKER_HOVER = new ImageIcon(ImageUtil.luminanceOffset(PICKER.getImage(), -120));

    /*
     * Notifications
     */
    public static final ImageIcon FOREGROUND = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_flip-to-front.png"));
    public static final ImageIcon FOREGROUND_HOVER = new ImageIcon(ImageUtil.luminanceOffset(FOREGROUND.getImage(), -80));
    public static final ImageIcon BACKGROUND = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_flip-to-back.png"));
    public static final ImageIcon BACKGROUND_HOVER = new ImageIcon(ImageUtil.luminanceOffset(BACKGROUND.getImage(), -80));
    public static final ImageIcon AFK = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "afk_icon.png"));
    public static final ImageIcon AFK_HOVER = new ImageIcon(ImageUtil.luminanceOffset(AFK.getImage(), -80));
    public static final ImageIcon NON_AFK = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "non_afk_icon.png"));
    public static final ImageIcon NON_AFK_HOVER = new ImageIcon(ImageUtil.luminanceOffset(NON_AFK.getImage(), -80));
    public static final ImageIcon TEST = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_flask.png"));
    public static final ImageIcon TEST_HOVER = new ImageIcon(ImageUtil.luminanceOffset(TEST.getImage(), -80));
    public static final ImageIcon VOLUME = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_volume-high.png"), -80));
    public static final ImageIcon CLOCK = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_clock-outline.png"), -80));
    public static final ImageIcon SPEECH = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_account-voice.png"), -80));
    public static final ImageIcon SPEED = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_speedometer.png"), -80));
    public static final ImageIcon TIMER_PLUS = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_timer-plus-outline.png"));
    public static final ImageIcon TIMER_PLUS_HOVER = new ImageIcon(ImageUtil.luminanceOffset(TIMER_PLUS.getImage(), -80));
    public static final ImageIcon TIMER_REMOVE = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_timer-remove-outline.png"));
    public static final ImageIcon TIMER_REMOVE_HOVER = new ImageIcon(ImageUtil.luminanceOffset(TIMER_REMOVE.getImage(), -80));
    public static final ImageIcon BORDER_OUTSIDE = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_border-outside.png"), -80));
    public static final ImageIcon DICE_MULTIPLE = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_dice-multiple.png"));
    public static final ImageIcon DICE_MULTIPLE_HOVER = new ImageIcon(ImageUtil.luminanceOffset(DICE_MULTIPLE.getImage(), -80));
    public static final ImageIcon DICE_MULTIPLE_OFF = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_dice-multiple-outline.png"), -80));
    public static final ImageIcon DICE_MULTIPLE_OFF_HOVER = new ImageIcon(ImageUtil.luminanceOffset(DICE_MULTIPLE_OFF.getImage(), -40));
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.*;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum TriggerType {
    ALERT_GROUP("Alert Group", "Group alerts together", AlertGroup.class),
    GAME_MESSAGE("Game Message", "Game messages sent in chat", ChatAlert.class),
    PLAYER_CHAT_MESSAGE("Player Chat Message", "Player messages sent in chat", PlayerChatAlert.class),
    STAT_CHANGED("Stat Changed", "Stat changes like boosts or drains", StatChangedAlert.class),
    XP_DROP("XP Drop", "Get an xp drop", XPDropAlert.class),
    SOUND_FIRED("Sound Fired", "When a sound effect plays", SoundFiredAlert.class),
    SPAWNED_OBJECT("Spawned Object", "When an object, player, or npc spawns or despawns", SpawnedAlert.class),
    INVENTORY("Inventory", "When your inventory is full, empty, or contains certain items", InventoryAlert.class),
    LOCATION("Location", "Triggers when you near a set location", LocationAlert.class),
    // Keep this last so that people maybe won't try to use it over the chat one
    NOTIFICATION_FIRED("Notification Fired", "When other plugins fire notifications", NotificationFiredAlert.class),
    ;

    private final String name;
    private final String tooltip;
    private final Class<? extends Alert> implClass;
}

package com.adamk33n3r.runelite.watchdog;

import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;

public class Interval extends Timeout {
    public Interval(ScheduledExecutorService executor, BiConsumer<Timeout, Boolean> task, long delay, TimeUnit unit) {
        super();
        this.task = task;
        this.future = executor.scheduleAtFixedRate(() -> task.accept(this, false), 0, delay, unit);
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.client.RuneLite;
import net.runelite.client.RuneLiteProperties;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.util.OSType;

import com.google.common.base.Strings;
import com.google.common.escape.Escaper;
import com.google.common.escape.Escapers;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import java.awt.TrayIcon;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * This file is as-much-as-possible a copy of {@link net.runelite.client.Notifier}
 * The copied functions can be run through a differ on Notifier's versions of the functions
 */
@Slf4j
@Singleton
public class TrayNotifier {
    // Copied from RuneLite's Notifier class
    private final RuneLiteConfig runeLiteConfig;
    private final ClientUI clientUI;
    private final ScheduledExecutorService executorService;
    private final String appName;
    private final Path notifyIconPath;
    private transient boolean terminalNotifierAvailable;
    private static final String DOUBLE_QUOTE = "\"";
    private static final Escaper SHELL_ESCAPE = Escapers.builder()
            .addEscape('"', "'")
            .build();

    @Inject
    public TrayNotifier(
        final ClientUI clientUI,
        final RuneLiteConfig runeliteConfig,
        final ScheduledExecutorService executorService,
        final ChatMessageManager chatMessageManager,
        final EventBus eventBus,
        @Named("runelite.title") final String appName
    ) {
        this.clientUI = clientUI;
        this.runeLiteConfig = runeliteConfig;
        this.executorService = executorService;
        this.appName = appName;
        this.notifyIconPath = RuneLite.RUNELITE_DIR.toPath().resolve("icon.png");

        // Check if we are running in the launcher because terminal-notifier notifications don't work
        // if the group/sender are unknown to it.
        if (!Strings.isNullOrEmpty(RuneLiteProperties.getLauncherVersion()) && OSType.getOSType() == OSType.MacOS)
        {
            executorService.execute(() -> {
                terminalNotifierAvailable = isTerminalNotifierAvailable();
            });
        }
    }

    public void notify(
            final String title,
            final String message,
            final TrayIcon.MessageType type)
    {
        this.sendNotification(title, message, type);
    }

    // Copy of RuneLite's Notifier::sendNotification
    private void sendNotification(
            final String title,
            final String message,
            final TrayIcon.MessageType type)
    {
        final String escapedTitle = SHELL_ESCAPE.escape(title);
        final String escapedMessage = SHELL_ESCAPE.escape(message);

        switch (OSType.getOSType())
        {
            case Linux:
                sendLinuxNotification(escapedTitle, escapedMessage, type);
                break;
            case MacOS:
                sendMacNotification(escapedTitle, escapedMessage);
                break;
            default:
                sendTrayNotification(title, message, type);
        }
    }

    // Copy of RuneLite's Notifier::sendTrayNotification
    private void sendTrayNotification(
            final String title,
            final String message,
            final TrayIcon.MessageType type)
    {
        if (clientUI.getTrayIcon() != null)
        {
            clientUI.getTrayIcon().displayMessage(title, message, type);
        }
    }

    // Copy of RuneLite's Notifier::sendLinuxNotification
    private void sendLinuxNotification(
            final String title,
            final String message,
            final TrayIcon.MessageType type)
    {
        final List<String> commands = new ArrayList<>();
        commands.add("notify-send");
        commands.add(title);
        commands.add(message);
        commands.add("-a");
        commands.add(SHELL_ESCAPE.escape(appName));
        commands.add("-i");
        commands.add(SHELL_ESCAPE.escape(notifyIconPath.toAbsolutePath().toString()));
        commands.add("-u");
        commands.add(toUrgency(type));
        if (runeLiteConfig.notificationTimeout() > 0)
        {
            commands.add("-t");
            commands.add(String.valueOf(runeLiteConfig.notificationTimeout()));
        }

        executorService.submit(() ->
        {
            try
            {
                Process notificationProcess = sendCommand(commands);

                boolean exited = notificationProcess.waitFor(500, TimeUnit.MILLISECONDS);
                if (exited && notificationProcess.exitValue() == 0)
                {
                    return;
                }
            }
            catch (IOException | InterruptedException ex)
            {
                log.debug("error sending notification", ex);
            }

            // fall back to tray notification
            sendTrayNotification(title, message, type);
        });
    }

    // Copy of RuneLite's Notifier::sendMacNotification
    private void sendMacNotification(final String title, final String message)
    {
        final List<String> commands = new ArrayList<>();

        if (terminalNotifierAvailable)
        {
            Collections.addAll(commands,
                    "sh", "-lc", "\"$@\"", "--",
                    "terminal-notifier",
                    "-title", title,
                    "-message", message,
                    "-group", "net.runelite.launcher",
                    "-sender", "net.runelite.launcher"
            );
        }
        else
        {
            commands.add("osascript");
            commands.add("-e");

            final String script = "display notification " + DOUBLE_QUOTE +
                    message +
                    DOUBLE_QUOTE +
                    " with title " +
                    DOUBLE_QUOTE +
                    title +
                    DOUBLE_QUOTE;

            commands.add(script);
        }

        try
        {
            sendCommand(commands);
        }
        catch (IOException ex)
        {
            log.warn("error sending notification", ex);
        }
    }

    // Copy of RuneLite's Notifier::sendCommand
    private static Process sendCommand(final List<String> commands) throws IOException
    {
        return new ProcessBuilder(commands)
                .redirectErrorStream(true)
                .start();
    }

    // Copy of RuneLite's Notifier::isTerminalNotifierAvailable
    private boolean isTerminalNotifierAvailable()
    {
        try
        {
            // The PATH seen by Cocoa apps does not resemble that seen by the shell, so we defer to the latter.
            final Process exec = Runtime.getRuntime().exec(new String[]{"sh", "-lc", "terminal-notifier -help"});
            if (!exec.waitFor(2, TimeUnit.SECONDS))
            {
                return false;
            }
            return exec.exitValue() == 0;
        }
        catch (IOException | InterruptedException e)
        {
            return false;
        }
    }

    // Copy of RuneLite's Notifier::toUrgency
    private static String toUrgency(TrayIcon.MessageType type)
    {
        switch (type)
        {
            case WARNING:
            case ERROR:
                return "critical";
            default:
                return "normal";
        }
    }

}

package com.adamk33n3r.runelite.watchdog;

import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

@FunctionalInterface
public interface SimpleDocumentListener extends DocumentListener {
    void update(DocumentEvent e);

    @Override
    default void insertUpdate(DocumentEvent e) {
        update(e);
    }
    @Override
    default void removeUpdate(DocumentEvent e) {
        update(e);
    }
    @Override
    default void changedUpdate(DocumentEvent e) {
        update(e);
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.notifications.Popup;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.WidgetNode;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetModalMode;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayDeque;
import java.util.Queue;

@Getter
@Singleton
public class PopupManager {
    private static final int SCRIPT_ID = 3343; // NOTIFICATION_DISPLAY_INIT

    private static final int RESIZABLE_CLASSIC_LAYOUT = WidgetUtil.packComponentId(161, 13);
    private static final int RESIZABLE_MODERN_LAYOUT = WidgetUtil.packComponentId(164, 13);
    private static final int FIXED_CLASSIC_LAYOUT = WidgetUtil.packComponentId(548, 42);

    private static final int INTERFACE_ID = 660;

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    private final Queue<Popup.PopupData> popupQueue = new ArrayDeque<>();

    public void processPopupQueue() {
        // Wait for there to not be any popups
        if (this.client.getWidget(INTERFACE_ID, 1) != null) {
            return;
        }

        if (!this.popupQueue.isEmpty()) {
            Popup.PopupData popupData = this.popupQueue.poll();

            WidgetNode widgetNode = this.client.openInterface(this.getComponentID(), INTERFACE_ID, WidgetModalMode.MODAL_CLICKTHROUGH);
            Widget widget = this.client.getWidget(INTERFACE_ID, 1);

            // Doing this instead of textColor.getRGB() so that it doesn't use the alpha channel and cause WHITE to be -1
            int color = popupData.color == null ? -1 : popupData.color.getRed() << 16 | popupData.color.getGreen() << 8 | popupData.color.getBlue();
            this.client.runScript(SCRIPT_ID, popupData.title, popupData.message, color);

            this.clientThread.invokeLater(() -> {
                assert widget != null;

                // Wait until the popup has closed
                if (widget.getWidth() > 0) {
                    return false;
                }

                this.client.closeInterface(widgetNode, true);
                return true;
            });
        }
    }

    private int getComponentID() {
        return this.client.isResized()
            ? (client.getVarbitValue(Varbits.SIDE_PANELS) == 1
            ? RESIZABLE_MODERN_LAYOUT
            : RESIZABLE_CLASSIC_LAYOUT)
            : FIXED_CLASSIC_LAYOUT;

    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.google.common.base.Strings;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;
import java.awt.Color;

import static com.adamk33n3r.runelite.watchdog.WatchdogConfig.DEFAULT_NOTIFICATION_TEXT_COLOR;

@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class Popup extends MessageNotification {
    private String title = "";
    private Color textColor = DEFAULT_NOTIFICATION_TEXT_COLOR;

    @Inject
    public Popup(WatchdogConfig config) {
        super(config);
        this.setDefaults();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        String titleString = Strings.isNullOrEmpty(this.title) ? this.getAlert().getName() : this.title;
        String title = Util.processTriggerValues(titleString, triggerValues);
        String message = Util.processTriggerValues(this.message, triggerValues);
        WatchdogPlugin.getInstance().getPopupManager().getPopupQueue().offer(new PopupData(
            title,
            message,
            this.getTextColor()
        ));
    }

    @Override
    public void setDefaults() {
        super.setDefaults();
        this.setTextColor(this.watchdogConfig.defaultPopupTextColor());
    }

    @AllArgsConstructor
    public static class PopupData {
        public String title;
        public String message;
        public Color color;
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;
import java.awt.Color;
import java.time.Instant;

@Getter
@Accessors(chain = true)
public class ScreenMarker extends Notification {
    private net.runelite.client.plugins.screenmarkers.ScreenMarker screenMarker;
    @Setter
    private int displayTime = 5;
    @Setter
    private boolean sticky = false;
    @Setter
    private String id;

    @Inject
    public ScreenMarker(WatchdogConfig config) {
        super(config);
        this.screenMarker = new net.runelite.client.plugins.screenmarkers.ScreenMarker(
            Instant.now().toEpochMilli(),
            "",
            3,
            Color.GREEN,
            new Color(0, 255, 0, 0),
            true,
            false
        );
    }

    public ScreenMarker setScreenMarkerProperties(String name, Color color, Color fill, int borderThickness) {
        this.screenMarker.setId(Instant.now().toEpochMilli());
        this.screenMarker.setName(name);
        this.screenMarker.setBorderThickness(borderThickness);
        this.screenMarker.setColor(color);
        this.screenMarker.setFill(fill);
        this.screenMarker.setLabelled(name != null && !name.isEmpty());
        return this;
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        WatchdogPlugin.getInstance().getScreenMarkerUtil().addScreenMarker(this);
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;

import net.runelite.api.Client;
import net.runelite.api.SoundEffectVolume;
import net.runelite.client.callback.ClientThread;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;

@Getter
@Setter
@Accessors(chain = true)
public class SoundEffect extends AudioNotification {
    private int soundID;

    @Inject
    private transient Client client;

    @Inject
    private transient ClientThread clientThread;

    public SoundEffect() {
        this.gain = 8;
    }

    @Inject
    public SoundEffect(WatchdogConfig config) {
        super(config);
        this.gain = config.defaultSoundEffectVolume();
        this.soundID = config.defaultSoundEffectID();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        this.clientThread.invokeLater(() -> {
            this.client.playSoundEffect(this.soundID, Util.scale(this.gain, 0, 10, SoundEffectVolume.MUTED, SoundEffectVolume.HIGH));
        });
    }

    @Override
    public void setDefaults() {
        super.setDefaults();
        this.setSoundID(this.watchdogConfig.defaultSoundEffectID());
        this.setGain(this.watchdogConfig.defaultSoundEffectVolume());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.google.common.base.Strings;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import com.google.gson.Gson;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;
import java.util.HashMap;

@Slf4j
@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class PluginMessage extends Notification {
    private String namespace;
    private String name;
    private String data;

    @Inject
    private transient EventBus eventBus;

    @Inject
    private transient ClientThread clientThread;

    @Inject
    private transient Gson gson;

    @Override
    protected void fireImpl(String[] triggerValues) {
        // Wrapping in client thread for safety
        this.clientThread.invoke(() -> {
            if (Strings.isNullOrEmpty(this.data)) {
                this.eventBus.post(new net.runelite.client.events.PluginMessage(this.namespace, this.name));
                return;
            }

            try {
                HashMap<String, Object> dataObj = gson.fromJson(
                    Util.processTriggerValues(this.data, triggerValues),
                    new TypeToken<HashMap<String, Object>>() {
                    }.getType()
                );
                this.eventBus.post(new net.runelite.client.events.PluginMessage(this.namespace, this.name, dataObj));
            } catch (JsonSyntaxException ex) {
                log.error("Invalid plugin message data. sending empty data", ex);
                this.eventBus.post(new net.runelite.client.events.PluginMessage(this.namespace, this.name));
            }
        });
    }
}

package com.adamk33n3r.runelite.watchdog.notifications.tts;

public enum Language {
    ENGLISH(),
    SPANISH(),
    FINNISH(),
    FRENCH(),
    JAPANESE(),
    SWEDISH(),
    DUTCH(),
    NORWEGIAN(),
}
package com.adamk33n3r.runelite.watchdog.notifications.tts;

import com.adamk33n3r.runelite.watchdog.Displayable;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum TTSSource implements Displayable {
    LEGACY("Legacy", "Legacy"),
    ELEVEN_LABS("Eleven Labs", "Eleven Labs (Supply your API Key in Config)"),
    ;
    private final String name;
    private final String tooltip;
}

package com.adamk33n3r.runelite.watchdog.notifications.tts;

import org.apache.commons.text.WordUtils;

public enum Voice {
    LUCAS(0, Language.ENGLISH, Gender.MALE),
    JAMES(1, Language.ENGLISH, Gender.MALE),
    LINDA(2, Language.ENGLISH, Gender.FEMALE),
    RICHARD(3, Language.ENGLISH, Gender.MALE),
    GEORGE(4, Language.ENGLISH, Gender.MALE),
    //SUSAN(5, Language.ENGLISH, Gender.FEMALE), Same as Hazel
    HEERA(6, Language.ENGLISH, Gender.FEMALE),
    RAVI(7, Language.ENGLISH, Gender.MALE),
    MARK(8, Language.ENGLISH, Gender.MALE),
    LAURA(9, Language.SPANISH, Gender.FEMALE),
    PABLO(10, Language.SPANISH, Gender.MALE),
    HEIDI(11, Language.FINNISH, Gender.FEMALE),
    JULIE(12, Language.FRENCH, Gender.FEMALE),
    PAUL(13, Language.FRENCH, Gender.MALE),
    AYUMI(14, Language.JAPANESE, Gender.FEMALE),
    ICHIRO(15, Language.JAPANESE, Gender.MALE),
    SAYAKA(16, Language.JAPANESE, Gender.FEMALE),
    JON(17, Language.NORWEGIAN, Gender.MALE),
    FRANK(18, Language.DUTCH, Gender.MALE),
    BENGT(19, Language.SWEDISH, Gender.MALE),
    HAZEL(20, Language.ENGLISH, Gender.FEMALE),
    EMMA(21, Language.ENGLISH, Gender.FEMALE),
    ZIRA(22, Language.ENGLISH, Gender.FEMALE),
    HELENA(23, Language.SPANISH, Gender.FEMALE),
    HORTENSE(24, Language.FRENCH, Gender.FEMALE),
    HARUKA(25, Language.JAPANESE, Gender.FEMALE);

    public final int id;
    public final Language language;
    public final Gender gender;
    Voice(int id, Language language, Gender gender) {
        this.id = id;
        this.language = language;
        this.gender = gender;
    }

    @Override
    public String toString() {
        return WordUtils.capitalizeFully(String.format("%s %s %s", this.name(), this.language.name(), this.gender.name()));
    }
}

package com.adamk33n3r.runelite.watchdog.notifications.tts;

public enum Gender {
    FEMALE(),
    MALE(),
    UNKNOWN();

    public boolean isFemale() {
        return this.equals(FEMALE);
    }

    public Gender reverse() {
        if (this == FEMALE) {
            return MALE;
        } else {
            return FEMALE;
        }
    }

    public static Gender get(boolean female) {
        if (female) {
            return FEMALE;
        } else {
            return MALE;
        }
    }
}
package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.elevenlabs.ElevenLabs;
import com.adamk33n3r.runelite.watchdog.notifications.tts.TTSSource;
import com.adamk33n3r.runelite.watchdog.notifications.tts.Voice;

import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.nio.file.Files;

import static net.runelite.client.RuneLite.CACHE_DIR;

@Slf4j
@Getter @Setter
@NoArgsConstructor
@Accessors(chain = true)
public class TextToSpeech extends MessageNotification implements IAudioNotification {
    private int gain = 5;
    private int rate = 1;
    @SerializedName("voice")
    private Voice legacyVoice = Voice.GEORGE;
    private TTSSource source = TTSSource.LEGACY;
    private String elevenLabsVoiceId;
    private transient com.adamk33n3r.runelite.watchdog.elevenlabs.Voice elevenLabsVoice;

    @Inject
    public TextToSpeech(WatchdogConfig config) {
        super(config);
        this.gain = config.defaultTTSVolume();
        this.rate = config.defaultTTSRate();
        this.legacyVoice = config.defaultTTSVoice();
        this.source = config.defaultTTSSource();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        if (!WatchdogPlugin.getInstance().getConfig().ttsEnabled()) {
            return;
        }

        String processedMessage = Util.processTriggerValues(this.message, triggerValues);

        try {
            String encodedMessage = URLEncoder.encode(processedMessage, "UTF-8");
            File watchdogPath = new File(CACHE_DIR, "watchdog");
            //noinspection ResultOfMethodCallIgnored
            watchdogPath.mkdirs();

            if (this.source == TTSSource.ELEVEN_LABS) {
                File soundFile = new File(watchdogPath, String.format("el-%s-%s.mp3", encodedMessage, this.elevenLabsVoiceId));
                if (soundFile.exists()) {
                    log.debug("Using cached file");
                    WatchdogPlugin.getInstance().getSoundPlayer().play(soundFile, this.gain);
                    return;
                }
                log.debug("generating tts");
                ElevenLabs.generateTTS(WatchdogPlugin.getInstance().getHttpClient(), this.elevenLabsVoice, processedMessage, (file) -> {
                    try {
                        Files.move(file.toPath(), soundFile.toPath());
                        WatchdogPlugin.getInstance().getSoundPlayer().play(soundFile, this.gain);
                    } catch (IOException e) {
                        log.error("Could not move tmp file to cache, playing from tmp", e);
                        WatchdogPlugin.getInstance().getSoundPlayer().play(file, this.gain);
                    }
                });
                return;
            }

            File soundFile = new File(watchdogPath, String.format("%s-%d-%d.wav", encodedMessage, this.rate, this.legacyVoice.id));

            // If the cache file exists, load and play it. Else fetch it from the server and cache it.
            if (soundFile.exists()) {
                log.debug("Using cached file");
            } else {
                String request = String.format("https://ttsplugin.com?m=%s&r=%d&v=%d", encodedMessage, this.rate, this.legacyVoice.id);
                URLConnection conn = new URL(request).openConnection();
                if (conn.getContentLength() < 0) {
                    log.error("Issue with tts plugin service, content length invalid");
                    return;
                }
                byte[] bytes = new byte[conn.getContentLength()];
                try (InputStream stream = conn.getInputStream()) {
                    for (int i = 0; i < conn.getContentLength(); i++) {
                        bytes[i] = (byte) stream.read();
                    }
                }
                // Write bytes to file in cache
                try (FileOutputStream fileOutputStream = new FileOutputStream(soundFile)) {
                    fileOutputStream.write(bytes);
                }
            }
            WatchdogPlugin.getInstance().getSoundPlayer().play(soundFile, this.gain);
        } catch (Exception ex) {
            log.error("Exception occurred while playing text to speech", ex);
        }
    }

    @Override
    public void setDefaults() {
        super.setDefaults();
        this.setSource(this.watchdogConfig.defaultTTSSource());
        this.setLegacyVoice(this.watchdogConfig.defaultTTSVoice());
        // This will cause the tts panel to set the default
        this.setElevenLabsVoiceId(null);
        this.setGain(this.watchdogConfig.defaultTTSVolume());
        this.setRate(this.watchdogConfig.defaultTTSRate());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;
import java.awt.Color;

import static com.adamk33n3r.runelite.watchdog.WatchdogConfig.DEFAULT_NOTIFICATION_COLOR;
import static com.adamk33n3r.runelite.watchdog.WatchdogConfig.DEFAULT_NOTIFICATION_TEXT_COLOR;

@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class Overlay extends MessageNotification {
    private Color color = DEFAULT_NOTIFICATION_COLOR;
    private Color textColor = DEFAULT_NOTIFICATION_TEXT_COLOR;
    private boolean sticky = false;
    private int timeToLive = 5;
    private String imagePath;
    private String id;

    @Inject
    public Overlay(WatchdogConfig config) {
        super(config);
        this.color = config.defaultOverlayColor();
        this.textColor = config.defaultOverlayTextColor();
        this.sticky = config.defaultOverlaySticky();
        this.timeToLive = config.defaultOverlayTTL();
        this.imagePath = config.defaultOverlayImagePath();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        WatchdogPlugin.getInstance().getNotificationOverlay()
            .add(this, Util.processTriggerValues(this.message, triggerValues));
    }

    @Override
    public void setDefaults() {
        super.setDefaults();
        this.setColor(this.watchdogConfig.defaultOverlayColor());
        this.setTextColor(this.watchdogConfig.defaultOverlayTextColor());
        this.setSticky(this.watchdogConfig.defaultOverlaySticky());
        this.setTimeToLive(this.watchdogConfig.defaultOverlayTTL());
        this.setImagePath(this.watchdogConfig.defaultOverlayImagePath());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

public interface IAudioNotification extends INotification {
    int getGain();
    IAudioNotification setGain(int gain);
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.events.PluginMessage;
import okhttp3.HttpUrl;
import org.apache.commons.lang3.StringUtils;

import javax.annotation.Nullable;
import javax.inject.Inject;
import java.util.HashMap;
import java.util.List;

@Slf4j
@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class Dink extends MessageNotification {
    private boolean includeScreenshot = false;

    @Inject
    private transient EventBus eventBus;

    @Inject
    private transient ClientThread clientThread;

    @Override
    protected void fireImpl(String[] triggerValues) {
        HashMap<String, Object> dinkData = new HashMap<>();
        String processedMessage = Util.processTriggerValues(this.message, triggerValues);
        dinkData.put("text", processedMessage);
        dinkData.put("sourcePlugin", WatchdogPlugin.getInstance().getName());
        dinkData.put("title", this.getAlert().getName());
        dinkData.put("imageRequested", this.includeScreenshot);

        log.debug("Sending dink notification with data: {}", dinkData);

        // Workaround for https://github.com/pajlads/DinkPlugin/pull/701
        // Tracked at https://github.com/pajlads/DinkPlugin/issues/758
        this.clientThread.invoke(() -> {
            this.eventBus.post(new PluginMessage("dink", "notify", dinkData));
        });
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.alerts.FlashMode;

import net.runelite.client.config.FlashNotification;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;
import java.awt.Color;

import static com.adamk33n3r.runelite.watchdog.WatchdogConfig.DEFAULT_NOTIFICATION_COLOR;

@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class ScreenFlash extends Notification {
    private Color color = DEFAULT_NOTIFICATION_COLOR;
    private FlashMode flashMode = FlashMode.FLASH;
    private int flashDuration = 2;

    @Deprecated
    private FlashNotification flashNotification;

    @Inject
    public ScreenFlash(WatchdogConfig config) {
        super(config);
        this.color = config.defaultScreenFlashColor();
        this.flashMode = config.defaultScreenFlashMode();
        this.flashDuration = config.defaultScreenFlashDuration();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        WatchdogPlugin.getInstance().getFlashOverlay().flash(this);
    }

    @Override
    public void setDefaults() {
        super.setDefaults();
        this.setFlashDuration(this.watchdogConfig.defaultScreenFlashDuration());
        this.setFlashMode(this.watchdogConfig.defaultScreenFlashMode());
        this.setColor(this.watchdogConfig.defaultScreenFlashColor());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;

@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public abstract class AudioNotification extends Notification implements IAudioNotification {
    protected int gain = 8;

    @Inject
    public AudioNotification(WatchdogConfig config) {
        super(config);
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter @Setter
@Accessors(chain = true)
public class DismissOverlay extends Notification {
    private String dismissId;

    @Override
    protected void fireImpl(String[] triggerValues) {
        WatchdogPlugin.getInstance().getNotificationOverlay().clearById(this.dismissId);
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.TrayNotifier;
import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;

import lombok.NoArgsConstructor;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.awt.TrayIcon;

@Slf4j
@NoArgsConstructor
@Accessors(chain = true)
public class TrayNotification extends MessageNotification {
    @Inject
    protected transient TrayNotifier trayNotifier;

    @Inject
    public TrayNotification(WatchdogConfig config) {
        super(config);
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        this.trayNotifier.notify(
                "Watchdog",
                Util.processTriggerValues(this.message, triggerValues),
                TrayIcon.MessageType.NONE);
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.alerts.Alert;

public interface INotification {
    Alert getAlert();
    void setAlert(Alert alert);
    void fire(String[] triggerValues);
    void setDefaults();
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter @Setter
@Accessors(chain = true)
public class DismissScreenMarker extends Notification {
    private String dismissId;

    @Override
    protected void fireImpl(String[] triggerValues) {
        WatchdogPlugin.getInstance().getScreenMarkerUtil().removeScreenMarkerById(this.dismissId);
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;
import java.io.File;

@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class Sound extends AudioNotification {
    private String path;
    private int repeatDuration = 0;

    @Inject
    public Sound(WatchdogConfig config) {
        super(config);
        this.gain = config.defaultSoundVolume();
        this.path = config.defaultSoundPath();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        String processedPath = Util.processTriggerValues(path, triggerValues);
        WatchdogPlugin.getInstance().getSoundPlayer().play(new File(processedPath), gain, repeatDuration);
    }

    @Override
    public void setDefaults() {
        super.setDefaults();
        this.setGain(this.watchdogConfig.defaultSoundVolume());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.EventHandler;
import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;

import lombok.NoArgsConstructor;
import lombok.experimental.Accessors;

import javax.inject.Inject;

@NoArgsConstructor
@Accessors(chain = true)
public class NotificationEvent extends MessageNotification {
    @Inject
    private transient EventHandler eventHandler;

    @Inject
    public NotificationEvent(WatchdogConfig config) {
        super(config);
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        this.eventHandler.notify(Util.processTriggerValues(this.message, triggerValues));
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;

import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;

import lombok.NoArgsConstructor;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;

@Slf4j
@NoArgsConstructor
@Accessors(chain = true)
public class GameMessage extends MessageNotification {
    @Inject
    private transient ChatMessageManager chatMessageManager;

    @Inject
    public GameMessage(WatchdogConfig config) {
        super(config);
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        String formattedMessage = "<col" + ChatColorType.HIGHLIGHT.name() + ">" +
            Util.processTriggerValues(this.message, triggerValues);
        this.chatMessageManager.queue(QueuedMessage.builder()
            .type(ChatMessageType.CONSOLE)
            .name(WatchdogPlugin.getInstance().getName())
            .runeLiteFormattedMessage(formattedMessage)
            .build());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

public interface IMessageNotification extends INotification {
    String getMessage();
    IMessageNotification setMessage(String message);
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;

import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.Player;
import net.runelite.client.util.ColorUtil;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;
import java.awt.Color;
import java.util.concurrent.ScheduledExecutorService;

@NoArgsConstructor
@Accessors(chain = true)
public class Overhead extends MessageNotification {
    @Getter @Setter
    private int displayTime = 3;
    @Getter @Setter
    private Color textColor = null;

    @Inject
    private transient Client client;
    @Inject
    private transient ScheduledExecutorService executor;

    @Inject
    public Overhead(WatchdogConfig config) {
        super(config);
        this.displayTime = config.defaultOverHeadDisplayTime();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        String message = Util.processTriggerValues(this.message, triggerValues);
        Player localPlayer = this.client.getLocalPlayer();
        if (localPlayer == null) {
            return;
        }
        StringBuilder sb = new StringBuilder();
        if (this.textColor != null) {
            sb.append("<col=")
                .append(ColorUtil.colorToHexCode(this.textColor))
                .append(">")
                .append(message)
                .append("</col>");
        } else {
            sb.append(message);
        }
        localPlayer.setOverheadText(sb.toString());
        localPlayer.setOverheadCycle(this.displayTime * 1000 / Constants.CLIENT_TICK_LENGTH);
    }

    @Override
    public void setDefaults() {
        super.setDefaults();
        this.setDisplayTime(this.watchdogConfig.defaultOverHeadDisplayTime());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.AlertManager;
import com.adamk33n3r.runelite.watchdog.NotificationType;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;

import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.client.ui.ClientUI;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import javax.inject.Inject;
import java.util.Arrays;

@NoArgsConstructor
public abstract class Notification implements INotification {
    @Inject
    protected transient ClientUI clientUI;

    @Inject
    protected transient Client client;

    @Inject
    protected transient AlertManager alertManager;

    protected transient WatchdogConfig watchdogConfig;

    @Getter @Setter
    private boolean fireWhenFocused = true;

    @Getter @Setter
    private boolean fireWhenAFK = false;
    @Getter @Setter
    private int fireWhenAFKForSeconds = 5;

    @Getter @Setter
    private int delayMilliseconds = 0;

    public boolean isDelayed() {
        return this.delayMilliseconds > 0;
    }

    @Setter
    private transient Alert alert;
    public Alert getAlert() {
        if (this.alert == null) {
            this.alert = this.alertManager.getAllAlerts()
                .filter(a -> a.getNotifications().contains(this)).findFirst().orElse(null);
        }

        return this.alert;
    }

    @Inject
    public Notification(WatchdogConfig config) {
        this.watchdogConfig = config;
        this.fireWhenAFK = config.defaultAFKMode();
        this.fireWhenAFKForSeconds = config.defaultAFKSeconds();
    }

    public boolean shouldFire() {
        if (WatchdogPlugin.getInstance().isInBannedArea()) {
            return false;
        }

        int afkTime = (int)Math.floor(Math.min(client.getKeyboardIdleTicks(), client.getMouseIdleTicks()) * Constants.CLIENT_TICK_LENGTH / 1000f);
        if (this.fireWhenAFK && afkTime < this.fireWhenAFKForSeconds) {
            return false;
        }
        return !this.clientUI.isFocused() || this.fireWhenFocused;
    }

    @Override
    public void fire(String[] triggerValues) {
        if (this.shouldFire()) {
            this.fireImpl(triggerValues);
        }
    }

    public void fireForced(String[] triggerValues) {
        this.fireImpl(triggerValues);
    }

    protected abstract void fireImpl(String[] triggerValues);

    public NotificationType getType() {
        return Arrays.stream(NotificationType.values())
            .filter(nType -> nType.getImplClass() == this.getClass())
            .findFirst()
            .orElse(null);
    }

    public void setDefaults() {
        this.setFireWhenAFK(this.watchdogConfig.defaultAFKMode());
        this.setFireWhenAFKForSeconds(this.watchdogConfig.defaultAFKSeconds());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;

@Setter
@Getter
@Accessors(chain = true)
@NoArgsConstructor
public abstract class MessageNotification extends Notification implements IMessageNotification {
    protected String message = "";

    @Inject
    public MessageNotification(WatchdogConfig config) {
        super(config);
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;

import net.runelite.client.ui.ClientUI;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;

@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class RequestFocus extends Notification {
    private boolean forceFocus = false;

    @Inject
    private transient ClientUI clientUI;

    @Inject
    public RequestFocus(WatchdogConfig config) {
        super(config);
        this.forceFocus = config.defaultRequestFocusForce();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        if (this.forceFocus) {
            this.clientUI.forceFocus();
        } else {
            this.clientUI.requestFocus();
        }
    }
}

package com.adamk33n3r.runelite.watchdog;

import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;

public class Timeout {
    BiConsumer<Timeout, Boolean> task;
    ScheduledFuture<?> future;
    public Timeout(ScheduledExecutorService executor, BiConsumer<Timeout, Boolean> task, long delay, TimeUnit unit) {
        this.task = task;
        this.future = executor.schedule(() -> this.task.accept(this, false), delay, unit);
    }
    protected Timeout() {}

    public void stop() {
        if (this.future.isDone()) {
            return;
        }
        this.future.cancel(true);
    }

    public void stopAndRunNow() {
        if (this.future.isDone()) {
            return;
        }
        this.future.cancel(true);
        this.task.accept(this, true);
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.api.ChatMessageType;

import lombok.Getter;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Getter
public enum GameMessageType implements Displayable {
    ANY("Any", "Any message", (ChatMessageType[]) null),
    BROADCAST("Broadcast", "Broadcast from the server", ChatMessageType.BROADCAST, ChatMessageType.WELCOME),
    DIALOG("Dialog", "Dialog messages", ChatMessageType.DIALOG, ChatMessageType.MESBOX),
    DUEL("Duel", "Duel messages", ChatMessageType.CHALREQ_TRADE, ChatMessageType.CHALREQ_FRIENDSCHAT, ChatMessageType.CHALREQ_CLANCHAT),
    EXAMINE("Examine", "Examine text", ChatMessageType.ITEM_EXAMINE, ChatMessageType.NPC_EXAMINE, ChatMessageType.OBJECT_EXAMINE),
    GAME_MESSAGE("Game Message", "Game messages", ChatMessageType.GAMEMESSAGE, ChatMessageType.CONSOLE, ChatMessageType.ENGINE),
    LOGIN_LOGOUT("Login/Logout", "Friend Login/Logout messages", ChatMessageType.LOGINLOGOUTNOTIFICATION),
    NPC_SAY("NPC Dialogue", "Overhead text from some NPCs", ChatMessageType.NPC_SAY),
    SPAM("Spam", "Filtered game messages", ChatMessageType.SPAM),
    TRADE("Trade", "Trade messages", ChatMessageType.TRADE, ChatMessageType.TRADE_SENT, ChatMessageType.TRADEREQ),
    ;

    private final String name;
    private final String tooltip;
    private final ChatMessageType[] chatMessageTypes;
    private static final List<ChatMessageType> ANY_TYPES;

    static {
        ANY_TYPES = Arrays.stream(values())
            .filter(gameMessageType -> gameMessageType != ANY)
            .flatMap((gameMessageType) -> Arrays.stream(gameMessageType.chatMessageTypes))
            .collect(Collectors.toList());
    }

    GameMessageType(String name, String tooltip, ChatMessageType... chatMessageTypes) {
        this.name = name;
        this.tooltip = tooltip;
        this.chatMessageTypes = chatMessageTypes;
    }

    public boolean isOfType(ChatMessageType chatMessageType) {
        return this.chatMessageTypes == null ? ANY_TYPES.contains(chatMessageType) : Arrays.asList(this.chatMessageTypes).contains(chatMessageType);
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.api.ChatMessageType;

import lombok.Getter;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Getter
public enum PlayerChatType implements Displayable {
    ANY("Any", "Any message", (ChatMessageType[]) null),
    PUBLIC("Public", "Public", ChatMessageType.PUBLICCHAT, ChatMessageType.MODCHAT),
    PRIVATE("Private", "Private message", ChatMessageType.PRIVATECHAT, ChatMessageType.PRIVATECHATOUT, ChatMessageType.MODPRIVATECHAT),
    FRIENDS("Friends", "Friends Chat", ChatMessageType.FRIENDSCHAT, ChatMessageType.FRIENDSCHATNOTIFICATION),
    CLAN("Clan", "Clan Chat", ChatMessageType.CLAN_CHAT, ChatMessageType.CLAN_MESSAGE),
    GUEST_CLAN("Guest Clan", "Guest Clan Chat", ChatMessageType.CLAN_GUEST_CHAT, ChatMessageType.CLAN_GUEST_MESSAGE),
    GIM("GIM", "Group Iron Man Chat", ChatMessageType.CLAN_GIM_CHAT, ChatMessageType.CLAN_GIM_MESSAGE, ChatMessageType.CLAN_GIM_FORM_GROUP, ChatMessageType.CLAN_GIM_GROUP_WITH),
    AUTOTYPER("Autochat", "Autochat messages", ChatMessageType.AUTOTYPER, ChatMessageType.MODAUTOTYPER),
    ;

    private final String name;
    private final String tooltip;
    private final ChatMessageType[] chatMessageTypes;
    private static final List<ChatMessageType> ANY_TYPES;

    static {
        ANY_TYPES = Arrays.stream(values())
            .filter(playerChatType -> playerChatType != ANY)
            .flatMap((playerChatType) -> Arrays.stream(playerChatType.chatMessageTypes))
            .collect(Collectors.toList());
    }

    PlayerChatType(String name, String tooltip, ChatMessageType... chatMessageTypes) {
        this.name = name;
        this.tooltip = tooltip;
        this.chatMessageTypes = chatMessageTypes;
    }

    public boolean isOfType(ChatMessageType chatMessageType) {
        return this.chatMessageTypes == null ? ANY_TYPES.contains(chatMessageType) : Arrays.asList(this.chatMessageTypes).contains(chatMessageType);
    }
}

package com.adamk33n3r.runelite.watchdog;

import java.util.Arrays;

// Use https://explv.github.io to find region ids
public enum Region {
    ALCHEMICAL_HYDRA(true, 5536),
    VARDORVIS(4405),
    LEVIATHAN(8291),
    WHISPERER(10595),
    SUCELLUS(12132),
    VORKATH(9023),
    INFERNO(9043),
    FIGHT_CAVE(9551),
    COLOSSEUM(7216),
    KALPHITE_QUEEN(13972),
    COX(
        13136, // End of floor
        13137, 13393, // Lobbies/Room transitions
        13138, 13394, // Vasa/Tekton/Vespula Lizardmen/Skeletal Mystics/Guardian
        13139, 13395, 13140, 13396, // Puzzle rooms/bosses
        13141, 13397, // Rest room
        13145, // New floor
        13401, // New floor?
        12889 // Olm
    ),
    TOB(
//        12869, // Lobby
        12613, // Maiden
        13125, // Bloat
        13122, // Nylocas
        13123, 13379, // Sotetseg/maze
        12612, // Xarpus
        12611 // Verzik
//        12867 // Loot room

//        // Outside
//        14386,
//        14642
    ),
    TOA(
//        13454, // Lobby
        14160, // Nexus Lobby
        15698, // Crondis
        15700, // Zebak
        14162, // Scabaras
        14164, // Kephri
        15186, // Apmeken
        15188, // Ba-Ba
        14674, // Het
        14676, // Akkha
        15184, 15696 // Wardens
//        14672 // Chest room
    ),
    YAMA(6045)
//    LUMBRIDGE_CASTLE(
//        12850
//    )
    ;

    public final boolean onlyInInstance;
    public final int[] regionIDs;

    Region(int... regionIDs) {
        this(false, regionIDs);
    }

    Region(boolean onlyInInstance, int... regionIDs) {
        this.onlyInInstance = onlyInInstance;
        this.regionIDs = regionIDs;
    }

    public static boolean isBannedRegion(boolean inInstance, int regionID) {
        return Arrays.stream(values())
            .filter(r -> inInstance || !r.onlyInInstance)
            .flatMapToInt(r -> Arrays.stream(r.regionIDs))
            .anyMatch(id -> id == regionID);
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.notifications.Notification;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;

public class AlertProcessor extends Thread {
    private final String[] triggerValues;
    private final boolean forceFire;
    private final Queue<Notification> notificationQueue = new LinkedList<>();

    public AlertProcessor(Alert alert, String[] triggerValues) {
        this(alert, triggerValues, false);
    }

    public AlertProcessor(Alert alert, String[] triggerValues, boolean forceFire) {
        this.triggerValues = triggerValues;
        this.forceFire = forceFire;
        if (alert.isRandomNotifications()) {
            this.notificationQueue.add(alert.getNotifications().get(new Random().nextInt(alert.getNotifications().size())));
        } else {
            this.notificationQueue.addAll(alert.getNotifications());
        }
    }

    @Override
    public void run() {
        while (!this.notificationQueue.isEmpty()) {
            Notification nextNotification = this.notificationQueue.poll();
            // This is checked in .fire(), but we don't want to delay if it won't fire
            if (!nextNotification.shouldFire() && !this.forceFire) {
                continue;
            }
            int delayMilliseconds = nextNotification.getDelayMilliseconds();
            if (delayMilliseconds > 0) {
                try {
                    Thread.sleep(delayMilliseconds);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }

            if (this.forceFire) {
                nextNotification.fireForced(this.triggerValues);
            } else {
                nextNotification.fire(this.triggerValues);
            }
        }
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class WatchdogPluginLauncher {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(WatchdogPlugin.class);
        RuneLite.main(args);
    }
}
package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.notifications.Notification;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;

import java.util.List;

import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.*;

public class AlertProcessorTest {
    private Alert alert;
    private Notification notification;
    private Notification notification2;
    private AlertProcessor alertProcessor;

    @Before
    public void setup() {
        alert = mock(Alert.class);
        notification = mock(Notification.class);
        notification2 = mock(Notification.class);
        when(alert.getNotifications()).thenReturn(List.of(notification, notification2));
    }

    @Test
    public void shouldProcessNotificationsWhenForceFireIsFalseAndShouldFireIsTrue() throws InterruptedException {
        when(notification.shouldFire()).thenReturn(true);
        alertProcessor = new AlertProcessor(alert, new String[0], false);
        alertProcessor.start();
        alertProcessor.join();
        verify(notification, times(1)).fire(any());
    }

    @Test
    public void shouldNotProcessNotificationsWhenForceFireIsFalseAndShouldFireIsFalse() throws InterruptedException {
        when(notification.shouldFire()).thenReturn(false);
        alertProcessor = new AlertProcessor(alert, new String[0], false);
        alertProcessor.start();
        alertProcessor.join();
        verify(notification, times(0)).fire(any());
    }

    @Test
    public void shouldProcessNotificationsWhenForceFireIsTrueRegardlessOfShouldFire() throws InterruptedException {
        when(notification.shouldFire()).thenReturn(false);
        alertProcessor = new AlertProcessor(alert, new String[0], true);
        alertProcessor.start();
        alertProcessor.join();
        verify(notification, times(1)).fireForced(any());
    }

    @Test
    public void shouldProcessMultipleNotifications() throws InterruptedException {
        when(alert.isRandomNotifications()).thenReturn(false);
        when(notification.shouldFire()).thenReturn(true);
        when(notification2.shouldFire()).thenReturn(true);
        alertProcessor = new AlertProcessor(alert, new String[0], false);
        alertProcessor.start();
        alertProcessor.join();
        verify(notification, times(1)).fire(any());
        verify(notification2, times(1)).fire(any());
    }

    @Test
    public void shouldOnlyProcessOneNotification() throws InterruptedException {
        when(alert.isRandomNotifications()).thenReturn(true);
        when(notification.shouldFire()).thenReturn(true);
        when(notification2.shouldFire()).thenReturn(true);
        alertProcessor = new AlertProcessor(alert, new String[0], false);
        alertProcessor.start();
        alertProcessor.join();
        // verify that either notification or notification2 is fired, but not both
        ArgumentCaptor<String[]> argumentCaptor = ArgumentCaptor.forClass(String[].class);
        verify(notification, atLeast(0)).fire(argumentCaptor.capture());
        ArgumentCaptor<String[]> argumentCaptor2 = ArgumentCaptor.forClass(String[].class);
        verify(notification2, atLeast(0)).fire(argumentCaptor2.capture());

        assertTrue(!argumentCaptor.getAllValues().isEmpty() || !argumentCaptor2.getAllValues().isEmpty());
    }
}
package com.adamk33n3r.runelite.watchdog;

import net.runelite.api.SoundEffectVolume;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class NumberScaleTest {
    @Test
    public void test_scaling_decibels() {
        assertEquals(-25, Util.scale(0, 0, 10, -25, 5));
        assertEquals(5, Util.scale(10, 0, 10, -25, 5));

        assertEquals(0, Util.scale(-25, -25, 5, 0, 10));
        assertEquals(10, Util.scale(5, -25, 5, 0, 10));
    }

    @Test
    public void test_sound_effect_volume() {
        assertEquals(SoundEffectVolume.MUTED, Util.scale(0, 0, 10, SoundEffectVolume.MUTED, SoundEffectVolume.HIGH));
        assertEquals(SoundEffectVolume.HIGH, Util.scale(10, 0, 10, SoundEffectVolume.MUTED, SoundEffectVolume.HIGH));

        assertEquals(0, Util.scale(SoundEffectVolume.MUTED, SoundEffectVolume.MUTED, SoundEffectVolume.HIGH, 0, 10));
        assertEquals(10, Util.scale(SoundEffectVolume.HIGH, SoundEffectVolume.MUTED, SoundEffectVolume.HIGH, 0, 10));
        assertEquals(5, Util.scale(SoundEffectVolume.MEDIUM_LOW, SoundEffectVolume.MUTED, SoundEffectVolume.HIGH, 0, 10));
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.ui.panels.HistoryPanel;
import com.google.inject.testing.fieldbinder.Bind;
import net.runelite.client.eventbus.EventBus;
import org.junit.Before;
import org.mockito.Mock;
import org.mockito.Mockito;

import javax.inject.Provider;

public abstract class AlertTestBase extends TestBase {
    @Mock
    @Bind
    EventBus eventBus;

    @Mock
    HistoryPanel historyPanel;
    @Mock
    Provider<HistoryPanel> historyPanelProvider;


    @Before
    public void before() throws NoSuchFieldException {
        super.before();

        Mockito.when(historyPanelProvider.get()).thenReturn(this.historyPanel);
    }
}

package com.adamk33n3r.runelite.watchdog;

import org.junit.Assert;
import org.junit.Test;

import java.util.Arrays;
import java.util.List;

public class SearchTextTest {
    @Test
    public void test_simple_search() {
        List<String> keywords = Arrays.asList("me", "you", "adamk33n3r");
        Assert.assertTrue(Util.searchText("k33n3r", keywords));
        Assert.assertTrue(Util.searchText("Adam", keywords));
        Assert.assertFalse(Util.searchText("frank", keywords));
    }

    @Test
    public void test_accented_characters() {
        List<String> keywords = Arrays.asList("adamk33n3r", "Ðomé");
        Assert.assertTrue(Util.searchText("Ðome", keywords));
    }
}

package com.adamk33n3r.runelite.watchdog;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;


public class VersionTest {
    @Test
    public void compare_versions() throws Exception {
        Version a = new Version("1.1");
        Version b = new Version("1.1.1");
        assert(a.compareTo(b) < 0);
        assert(!a.equals(b));

        a = new Version("2.0");
        b = new Version("1.9.9");
        assert(a.compareTo(b) > 0);
        assert(!a.equals(b));

        a = new Version("1.0");
        b = new Version("1");
        assert(a.compareTo(b) == 0);
        assert(a.equals(b));

        a = new Version("1");
        b = new Version(null);
        assert(a.compareTo(b) > 0);
        assert(!a.equals(b));

        List<Version> versions = new ArrayList<Version>();
        versions.add(new Version("2"));
        versions.add(new Version("1.0.5"));
        versions.add(new Version("1.01.0"));
        versions.add(new Version("1.00.1"));
        assert(Collections.min(versions).equals(new Version("1.0.1")));
        assert(Collections.max(versions).equals(new Version("2.0.0")));
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.alerts.ChatAlert;
import com.adamk33n3r.runelite.watchdog.notifications.Notification;
import com.adamk33n3r.runelite.watchdog.notifications.Overlay;

import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;

import javax.inject.Inject;

@RunWith(MockitoJUnitRunner.class)
public class AlertManagerTest extends TestBase {

    @Inject
    AlertManager alertManager;

    @Test
    public void test_import() {
        String json = "[{\"type\":\"ChatAlert\",\"message\":\"*is ready to harvest*\",\"regexEnabled\":false,\"enabled\":true,\"name\":\"Ready to Harvest\",\"debounceTime\":500,\"notifications\":[{\"type\":\"TrayNotification\",\"message\":\"Time to harvest your crops!\",\"fireWhenFocused\":true},{\"type\":\"Sound\",\"path\":\"C:\\\\Users\\\\adamg\\\\Music\\\\airplane_seatbelt.mp3\",\"gain\":10,\"fireWhenFocused\":true},{\"type\":\"TextToSpeech\",\"gain\":5,\"rate\":1,\"voice\":\"GEORGE\",\"source\":\"LEGACY\",\"message\":\"\",\"fireWhenFocused\":true},{\"type\":\"Overhead\",\"displayTime\":3,\"message\":\"\",\"fireWhenFocused\":true}]},{\"type\":\"NotificationFiredAlert\",\"message\":\"You are now out of combat!\",\"regexEnabled\":false,\"enabled\":true,\"name\":\"Out of Combat\",\"debounceTime\":0,\"notifications\":[{\"type\":\"ScreenFlash\",\"color\":\"#46FF0000\",\"flashMode\":\"FLASH\",\"flashDuration\":0,\"fireWhenFocused\":true}]},{\"type\":\"SpawnedAlert\",\"spawnedDespawned\":\"SPAWNED\",\"spawnedType\":\"ITEM\",\"spawnedName\":\"Bones\",\"regexEnabled\":false,\"enabled\":false,\"name\":\"Bones Spawned\",\"debounceTime\":0,\"notifications\":[{\"type\":\"SoundEffect\",\"soundID\":3925,\"gain\":10,\"fireWhenFocused\":true},{\"type\":\"ScreenFlash\",\"color\":\"#46FF0000\",\"flashMode\":\"FLASH\",\"flashDuration\":0,\"fireWhenFocused\":true}]},{\"type\":\"SpawnedAlert\",\"spawnedDespawned\":\"SPAWNED\",\"spawnedType\":\"NPC\",\"spawnedName\":\"Gee\",\"regexEnabled\":false,\"enabled\":false,\"name\":\"NPC Spawn\",\"debounceTime\":0,\"notifications\":[{\"type\":\"Overhead\",\"displayTime\":3,\"message\":\"The dude is here\",\"fireWhenFocused\":true},{\"type\":\"TextToSpeech\",\"gain\":10,\"rate\":1,\"voice\":\"GEORGE\",\"source\":\"LEGACY\",\"message\":\"\",\"fireWhenFocused\":true}]},{\"type\":\"SpawnedAlert\",\"spawnedDespawned\":\"SPAWNED\",\"spawnedType\":\"GAME_OBJECT\",\"spawnedName\":\"Tree\",\"regexEnabled\":false,\"enabled\":false,\"name\":\"New Spawned Alert\",\"debounceTime\":0,\"notifications\":[{\"type\":\"Overhead\",\"displayTime\":3,\"message\":\"CHOP THE TREE\",\"fireWhenFocused\":true},{\"type\":\"SoundEffect\",\"soundID\":3924,\"gain\":10,\"fireWhenFocused\":true}]},{\"type\":\"ChatAlert\",\"message\":\"\",\"regexEnabled\":false,\"enabled\":true,\"name\":\"test 11labs lag\",\"debounceTime\":0,\"notifications\":[{\"type\":\"TextToSpeech\",\"gain\":10,\"rate\":1,\"voice\":\"GEORGE\",\"source\":\"LEGACY\",\"message\":\"this is a test\",\"fireWhenFocused\":true}]}]";
        Mockito.when(this.configManager.getConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.ALERTS))
            .thenReturn(json);
        Mockito.when(this.configManager.getConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.PLUGIN_VERSION))
            .thenReturn(this.pluginVersion);
        Assert.assertEquals(0, alertManager.getAlerts().size());
        alertManager.loadAlerts();
        Assert.assertEquals(6, alertManager.getAlerts().size());
    }

    @Test
    public void test_upgrade() {
        String json = "[{\"type\":\"ChatAlert\",\"message\":\"\",\"regexEnabled\":false,\"enabled\":true,\"name\":\"Upgrade Test\",\"debounceTime\":0,\"notifications\":[{\"type\":\"Overlay\",\"color\":\"#46FF0000\",\"sticky\":false,\"timeToLive\":5,\"imagePath\":\"\",\"message\":\"Overlay notification\",\"fireWhenFocused\":true}]}]";
        Mockito.when(this.configManager.getConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.ALERTS))
            .thenReturn(json);
        Mockito.when(this.configManager.getConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.PLUGIN_VERSION))
            .thenReturn("2.12.0");
        alertManager.loadAlerts();
        Alert alert = alertManager.getAlerts().get(0);
        Assert.assertTrue(alert instanceof ChatAlert);
        Notification notification = alert.getNotifications().get(0);
        Assert.assertTrue(notification instanceof Overlay);
        Assert.assertNotNull(((Overlay) notification).getTextColor());
    }
}

package com.adamk33n3r.runelite.watchdog;

import org.junit.Test;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class GlobTest {
    @Test
    public void star_becomes_dot_star() throws Exception {
        assertEquals("gl.*b", Util.createRegexFromGlob("gl*b"));
    }

    @Test
    public void escaped_star_is_unchanged() throws Exception {
        assertEquals("gl\\*b", Util.createRegexFromGlob("gl\\*b"));
    }

    @Test
    public void question_mark_becomes_dot() throws Exception {
        assertEquals("gl.b", Util.createRegexFromGlob("gl?b"));
    }

    @Test
    public void escaped_question_mark_is_unchanged() throws Exception {
        assertEquals("gl\\?b", Util.createRegexFromGlob("gl\\?b"));
    }

    @Test
    public void character_classes_dont_need_conversion() throws Exception {
        assertEquals("gl[-o]b", Util.createRegexFromGlob("gl[-o]b"));
    }

    @Test
    public void escaped_classes_are_unchanged() throws Exception {
        assertEquals("gl\\[-o\\]b", Util.createRegexFromGlob("gl\\[-o\\]b"));
    }

    @Test
    public void negation_in_character_classes() throws Exception {
        assertEquals("gl[^a-n!p-z]b", Util.createRegexFromGlob("gl[!a-n!p-z]b"));
    }

    @Test
    public void nested_negation_in_character_classes() throws Exception {
        assertEquals("gl[[^a-n]!p-z]b", Util.createRegexFromGlob("gl[[!a-n]!p-z]b"));
    }

    @Test
    public void escape_carat_if_it_is_the_first_char_in_a_character_class() throws Exception {
        assertEquals("gl[\\^o]b", Util.createRegexFromGlob("gl[^o]b"));
    }

    @Test
    public void metachars_are_escaped() throws Exception {
        assertEquals("gl..*\\.\\(\\)\\+\\|\\^\\$\\@\\%b", Util.createRegexFromGlob("gl?*.()+|^$@%b"));
    }

    @Test
    public void metachars_in_character_classes_dont_need_escaping() throws Exception {
        assertEquals("gl[?*.()+|^$@%]b", Util.createRegexFromGlob("gl[?*.()+|^$@%]b"));
    }

    @Test
    public void escaped_backslash_is_unchanged() throws Exception {
        assertEquals("gl\\\\b", Util.createRegexFromGlob("gl\\\\b"));
    }

    @Test
    public void slashQ_and_slashE_are_escaped() throws Exception {
        assertEquals("\\\\Qglob\\\\E", Util.createRegexFromGlob("\\Qglob\\E"));
    }

    @Test
    public void braces_are_turned_into_groups() throws Exception {
        assertEquals("(glob|regex)", Util.createRegexFromGlob("{glob,regex}"));
    }

    @Test
    public void escaped_braces_are_unchanged() throws Exception {
        assertEquals("\\{glob\\}", Util.createRegexFromGlob("\\{glob\\}"));
    }

    @Test
    public void commas_dont_need_escaping() throws Exception {
        assertEquals("(glob,regex),", Util.createRegexFromGlob("{glob\\,regex},"));
    }

    @Test
    public void test_real_example() throws Exception {
        String regex = Util.createRegexFromGlob("Your {*} {are,is} ready to harvest");
        assertEquals("Your (.*) (are|is) ready to harvest", regex);
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher("Your tomatoes are ready to harvest");
        assertTrue(matcher.matches());
        assertEquals(2, matcher.groupCount());
        assertEquals("tomatoes", matcher.group(1));
    }

    @Test
    public void test_character_classes() throws Exception {
        String regex = Util.createRegexFromGlob("Jan [4-9]th");
        assertEquals("Jan [4-9]th", regex);
        assertTrue("Jan 8th".matches(regex));
    }

    @Test
    public void test_valuable_drop() throws Exception {
        String regex = Util.createRegexFromGlob("*Valuable drop: *\\([5-9],??? coins\\)*");
        assertEquals(".*Valuable drop: .*\\([5-9],... coins\\).*", regex);
        assertTrue("Valuable drop: (5,001 coins)".matches(regex));
    }

    @Test
    public void test_valuable_drop_all() throws Exception {
        String regex = Util.createRegexFromGlob("*drop*");
        assertEquals(".*drop.*", regex);
        assertTrue("Valuable drop: (5,001 coins)".matches(regex));
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.ChatAlert;
import com.adamk33n3r.runelite.watchdog.notifications.Dink;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.events.PluginMessage;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;

import java.util.Map;
import java.util.function.BooleanSupplier;
import java.util.stream.Stream;

@RunWith(MockitoJUnitRunner.class)
public class DinkNotificationTest extends AlertTestBase {

    @InjectMocks
    EventHandler eventHandler;

    @Test
    public void testDinkNotification() {
        String alertName = "Test Alert";
        ChatAlert chatAlert = new ChatAlert(alertName);
        chatAlert.setGameMessageType(GameMessageType.GAME_MESSAGE);
        chatAlert.setPattern("*");
        Dink dink = new Dink();
        chatAlert.addNotification(dink);
        String dinkMessage = "Test Message";
        dink.setMessage(dinkMessage);
        dink.setIncludeScreenshot(true);

        watchdogPlugin.getInjector().injectMembers(chatAlert);
        watchdogPlugin.getInjector().injectMembers(dink);

        Mockito.when(alertManager.getAllAlerts()).thenAnswer(invocation -> Stream.of(chatAlert));
        Mockito.when(alertManager.getAllEnabledAlertsOfType(ChatAlert.class)).thenAnswer(invocation -> Stream.of(chatAlert));

        ChatMessage testMessage = Mockito.mock(ChatMessage.class);
        Mockito.when(testMessage.getName()).thenReturn("Test");
        Mockito.when(testMessage.getMessage()).thenReturn("Test Message");
        Mockito.when(testMessage.getType()).thenReturn(ChatMessageType.GAMEMESSAGE);
        Mockito.when(client.isClientThread()).thenReturn(true);
        Mockito.doCallRealMethod().when(clientThread).invoke(Mockito.any(Runnable.class));
        Mockito.doCallRealMethod().when(clientThread).invoke(Mockito.any(BooleanSupplier.class));
        eventHandler.onChatMessage(testMessage);
        Mockito.verify(eventBus, Mockito.timeout(100)).post(new PluginMessage("dink", "notify", Map.of(
            "text", dinkMessage,
            "title", alertName,
            "sourcePlugin", watchdogPlugin.getName(),
            "imageRequested", true
        )));
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.google.gson.Gson;
import com.google.inject.Guice;
import com.google.inject.Injector;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.MultiplexingPluginPanel;
import net.runelite.http.api.RuneLiteAPI;
import org.junit.Before;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.internal.util.reflection.FieldSetter;

import javax.inject.Named;
import javax.inject.Provider;
import java.util.concurrent.ScheduledExecutorService;

public abstract class TestBase {
    @Bind
    @Named("watchdog.pluginVersion")
    final String pluginVersion = "3.0.0-TEST";
    @Bind
    @Named("watchdog.helpURL")
    private final String HELP_URL = "";
    @Bind
    @Named("watchdog.discordURL")
    private final String DISCORD_URL = "";
    @Bind
    @Named("watchdog.kofiURL")
    private final String KOFI_URL = "";
    @Bind
    @Named("watchdog.pluginVersionFull")
    private final String PLUGIN_VERSION_FULL = "";
    @Bind
    @Named("VERSION_PHASE")
    private final String PLUGIN_VERSION_PHASE = "";
    @Bind
    @Named("runelite.title")
    private final String RUNELITE_TITLE = "RuneLite";

    @Bind
    @Spy
    WatchdogPlugin watchdogPlugin;
    @Bind
    @Mock
    WatchdogConfig watchdogConfig;
    @Bind
    @Spy
    AlertManager alertManager;
    @Mock
    @Bind
    WatchdogPanel watchdogPanel;
    @Bind
    Provider<WatchdogMuxer> muxerProvider = () -> this.watchdogPanel.getMuxer();
    @Bind
    Provider<MultiplexingPluginPanel> multiplexingPluginPanelProvider = () -> alertManager.getWatchdogPanel().getMuxer();


    @Bind
    Gson clientGson = RuneLiteAPI.GSON;
    @Mock
    @Bind
    ScheduledExecutorService executor;
    @Mock
    @Bind
    RuneLiteConfig runeliteConfig;
    @Mock
    @Bind
    ConfigManager configManager;
    @Mock
    @Bind
    Client client;
    @Mock
    @Bind
    ClientThread clientThread;
    @Mock
    @Bind
    ClientUI clientUI;
    @Mock
    @Bind
    ItemManager itemManager;
    @Mock
    @Bind
    ChatMessageManager chatMessageManager;

    @Before
    public void before() throws NoSuchFieldException {
        BoundFieldModule module = BoundFieldModule.of(this);
        Injector injector = Guice.createInjector(module);
        injector.injectMembers(this);

        // can't mock the getInjector method because it's final
        FieldSetter.setField(watchdogPlugin, Plugin.class.getDeclaredField("injector"), injector);
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.*;
import com.adamk33n3r.runelite.watchdog.notifications.*;
import com.adamk33n3r.runelite.watchdog.notifications.tts.TTSSource;

import com.google.gson.Gson;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class GSONTest {
    @Test
    public void json_missing_property_with_initializer_test() throws Exception {
        final RuntimeTypeAdapterFactory<Alert> alertTypeFactory = RuntimeTypeAdapterFactory.of(Alert.class)
            .ignoreSubtype("IdleAlert")
            .ignoreSubtype("ResourceAlert")
            .recognizeSubtypes()
            .registerSubtype(ChatAlert.class)
            .registerSubtype(PlayerChatAlert.class)
            .registerSubtype(NotificationFiredAlert.class)
            .registerSubtype(StatDrainAlert.class)
            .registerSubtype(StatChangedAlert.class)
            .registerSubtype(XPDropAlert.class)
            .registerSubtype(SoundFiredAlert.class)
            .registerSubtype(SpawnedAlert.class)
            .registerSubtype(InventoryAlert.class)
            .registerSubtype(AlertGroup.class)
            .registerSubtype(LocationAlert.class);
        // Add new notification types here
        final RuntimeTypeAdapterFactory<Notification> notificationTypeFactory = RuntimeTypeAdapterFactory.of(Notification.class)
            .registerSubtype(TrayNotification.class)
            .registerSubtype(TextToSpeech.class)
            .registerSubtype(Sound.class)
            .registerSubtype(SoundEffect.class)
            .registerSubtype(ScreenFlash.class)
            .registerSubtype(GameMessage.class)
            .registerSubtype(Overhead.class)
            .registerSubtype(Overlay.class)
            .registerSubtype(RequestFocus.class)
            .registerSubtype(NotificationEvent.class)
            .registerSubtype(ScreenMarker.class)
            .registerSubtype(DismissOverlay.class);
        Gson gson = new Gson().newBuilder()
//            .serializeNulls()
            .registerTypeAdapterFactory(alertTypeFactory)
            .registerTypeAdapterFactory(notificationTypeFactory)
            .create();
        TextToSpeech tts = gson.fromJson("{\"type\":\"TextToSpeech\", \"message\":\"this is a test\",\"gain\":10,\"rate\":1,\"voice\":\"GEORGE\"}", TextToSpeech.class);

        assertEquals(TTSSource.LEGACY, tts.getSource());
        assertEquals(10, tts.getGain());
    }
}

