package com.adamk33n3r.runelite.watchdog;

import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ClientUI;

import jaco.mp3.player.MP3Player;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.*;
import javax.swing.SwingUtilities;
import java.awt.Toolkit;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.Queue;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
@Singleton
public class SoundPlayer {
    @Inject
    private ClientUI clientUI;

    @Inject
    private Client client;

    @Inject
    private transient ClientThread clientThread;

    @Inject
    private WatchdogConfig config;

    private final MP3Player mp3Player;

    private final Queue<SoundItem> queue = new ConcurrentLinkedQueue<>();

    private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);
    private ScheduledFuture<?> soundPlayerFuture;
    private Timeout soundTimeout;

    private boolean mp3IsPlaying = false;
    private boolean clipIsPlaying = false;
    private long mouseLastPressedMillis;

    public SoundPlayer() {
        this.mp3Player = new MP3Player();
    }

    public void startUp() {
        this.soundPlayerFuture = this.executor.scheduleAtFixedRate(
                this::processQueue,
                0,
                100,
                TimeUnit.MILLISECONDS
        );
    }

    public void shutDown() {
        this.soundPlayerFuture.cancel(false);
        this.stop();
    }

    public void processQueue() {
        // Handle mp3 being over
        if (!this.clipIsPlaying && this.mp3IsPlaying && this.mp3Player.isStopped()) {
            if (this.mp3Player.isRepeat()) {
                this.mp3Player.play();
                return;
            } else {
                this.mp3IsPlaying = false;
            }
        }
        if (mp3IsPlaying || clipIsPlaying) {
            return;
        }

        this.playNext(this.mp3Player);
    }

    public void stop() {
        if (this.soundTimeout != null) {
            this.soundTimeout.stopAndRunNow();
            this.soundTimeout = null;
        }
        this.queue.clear();
    }

    public void play(File soundFile, int volume) {
        this.play(soundFile, volume, 0);
    }

    public void play(File soundFile, int volume, int repeatTime) {
        this.queue.add(new SoundItem(soundFile, volume, repeatTime));
        if (!WatchdogPlugin.getInstance().getConfig().putSoundsIntoQueue()) {
            SwingUtilities.invokeLater(() -> this.playNext(this.mp3Player));
        }
    }

    private void playNext(MP3Player mp3Player) {
        SoundItem nextSound = this.queue.poll();
        if (nextSound == null) {
            return;
        }

        if (!nextSound.getFile().exists()) {
            log.error(String.format("File not found: %s", nextSound.getFile().getAbsolutePath()));
            this.clipIsPlaying = true;
            Toolkit.getDefaultToolkit().beep();
            this.executor.schedule(() -> this.clipIsPlaying = false, 1, TimeUnit.SECONDS);
            return;
        }

        mouseLastPressedMillis = client.getMouseLastPressedMillis();

        log.debug(String.format("Now playing: %s", nextSound.getFile().getAbsolutePath()));

        if (nextSound.getFile().getName().endsWith(".mp3")) {
            mp3Player.clearPlayList();
            mp3Player.add(nextSound.getFile());
            mp3Player.setVolume(nextSound.getGain() * 10);
            this.mp3IsPlaying = true;
            if (this.soundTimeout != null) {
                this.soundTimeout.stopAndRunNow();
                this.soundTimeout = null;
            }
            mp3Player.play();
            // jaco.mp3 repeat functionality is broken as it only loops when skipping, but we are using it to signal to ourselves to repeat on loop
            mp3Player.setRepeat(true);
            setTimeout(() -> {
                mp3Player.setRepeat(false);
            }, nextSound.getRepeatSeconds());
        } else {
            try {
                Clip clip = AudioSystem.getClip();
                try (InputStream fileStream = new BufferedInputStream(new FileInputStream(nextSound.getFile()));
                     AudioInputStream sound = AudioSystem.getAudioInputStream(fileStream)) {
                    clip.open(sound);
                    FloatControl volumeFC = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);
                    int decibels = Util.scale(nextSound.getGain(), 0, 10, -25, 5);
                    volumeFC.setValue(decibels);
                    this.clipIsPlaying = true;
                    clip.loop(0);
                    AtomicBoolean isLooping = new AtomicBoolean(true);
                    clip.addLineListener(event -> {
                        if (event.getType() == LineEvent.Type.STOP) {
                            if (isLooping.get()) {
                                clip.setFramePosition(0);
                                clip.loop(0);
                            } else {
                                this.clipIsPlaying = false;
                                clip.close();
                            }
                        }
                    });

                    if (this.soundTimeout != null) {
                        this.soundTimeout.stopAndRunNow();
                        this.soundTimeout = null;
                    }

                    setTimeout(() -> {
                        isLooping.set(false);
                    }, nextSound.getRepeatSeconds());
                } catch (Exception e) {
//                } catch (UnsupportedAudioFileException | IOException | LineUnavailableException e) {
                    log.warn("Unable to load sound", e);
                    clip.close();
                }
            } catch (Exception e) {
                log.error("Error trying to create clip", e);
            }
        }
    }

    /**
     * Runs a method after a delay
     * <p>
     * Internally polls for user interaction if the delay is < 0
     */
    private void setTimeout(Runnable runnable, int delaySeconds) {
        if (delaySeconds == 0) {
            runnable.run();
            return;
        }

        if (delaySeconds < 0) {
            this.soundTimeout = new Interval(this.executor, (interval, stop) -> {
                if (this.hasUserInteraction() || stop) {
                    interval.stop();
                    runnable.run();
                }
            }, Constants.CLIENT_TICK_LENGTH, TimeUnit.MILLISECONDS);
            return;
        }
        this.soundTimeout = new Timeout(this.executor, (timeout, stop) -> runnable.run(), delaySeconds, TimeUnit.SECONDS);
    }

    private boolean hasUserInteraction() {
        // We poll this every client tick, if there was any activity in the past second, that counts
        int clientTicksSinceActivity = 1000 / Constants.CLIENT_TICK_LENGTH;
        if (((client.getMouseIdleTicks() < clientTicksSinceActivity && this.config.mouseMovementCancels())
                || client.getKeyboardIdleTicks() < clientTicksSinceActivity
                || client.getMouseLastPressedMillis() > mouseLastPressedMillis) && clientUI.isFocused()
        ) {
            return true;
        }
        return false;
    }

    private MP3Player createMP3Player() {
        MP3Player mp3Player = new MP3Player();
        mp3Player.setRepeat(false);
        return mp3Player;
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.*;
import com.adamk33n3r.runelite.watchdog.hub.AlertHubPanel;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.ImportExportDialog;
import com.adamk33n3r.runelite.watchdog.ui.MessagePickerDialog;
import com.adamk33n3r.runelite.watchdog.ui.alerts.*;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertListPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.HistoryPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;
import com.adamk33n3r.runelite.watchdog.ui.panels.ToolsPanel;

import net.runelite.api.Client;
import net.runelite.api.MessageNode;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.client.events.NotificationFired;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;
import org.apache.commons.text.WordUtils;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Provider;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Slf4j
@Singleton
public class WatchdogPanel extends PluginPanel {
    @Inject
    @Named("watchdog.helpURL")
    private String HELP_URL;

    @Inject
    @Named("watchdog.discordURL")
    private String DISCORD_URL;

    @Inject
    @Named("watchdog.kofiURL")
    private String KOFI_URL;

    @Inject
    @Named("watchdog.pluginVersion")
    private String PLUGIN_VERSION;

    @Inject
    @Named("watchdog.pluginVersionFull")
    private String PLUGIN_VERSION_FULL;

    @Inject
    @Named("VERSION_PHASE")
    private String PLUGIN_VERSION_PHASE;

    @Getter
    private final WatchdogMuxer muxer = new WatchdogMuxer(this);

    @Getter
    @Inject
    private Provider<HistoryPanel> historyPanelProvider;

    @Inject
    private Provider<ToolsPanel> toolsPanelProvider;

    @Inject
    private Provider<AlertHubPanel> alertHubPanelProvider;

    @Inject
    private AlertManager alertManager;

    @Inject
    private WatchdogConfig watchdogConfig;

    @Inject
    private Client client;

    @Inject
    private OkHttpClient httpClient;

    private AlertListPanel alertListPanel;

    public WatchdogPanel() {
        super(false);
    }

    public void rebuild() {
        this.removeAll();
        this.setLayout(new BorderLayout(0, 3));
        this.setBorder(new EmptyBorder(0, 5, 0, 5));
        this.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBorder(new EmptyBorder(5, 0, 0, 0));
        JPanel titlePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 3));
        JLabel title = new JLabel(WatchdogPlugin.getInstance().getName());
        title.setFont(title.getFont().deriveFont(Font.BOLD));
        title.setHorizontalAlignment(JLabel.LEFT);
        title.setForeground(Color.WHITE);
        if (WatchdogPlugin.getInstance().isInBannedArea()) {
            title.setForeground(Color.RED);
            List<String> regions = Arrays.stream(Region.values())
                .map(Region::toString)
                .collect(Collectors.toList());
            StringBuilder tooltip = new StringBuilder("You are in a banned area. Watchdog is disabled in the following areas:\n");
            StringBuilder line = new StringBuilder();
            for (String region : regions) {
                if (line.length() + region.length() > 60) {
                    tooltip.append(line).append("\n");
                    line = new StringBuilder();
                }
                line.append(region).append(", ");
            }
            line.delete(line.length() - 2, line.length());
            tooltip.append(line);
            title.setToolTipText(tooltip.toString());
        } else {
            title.setForeground(Color.WHITE);
            boolean isPreRelease = !PLUGIN_VERSION_PHASE.equals("release") && !PLUGIN_VERSION_PHASE.isEmpty();
            title.setToolTipText("Watchdog v" + (isPreRelease ? PLUGIN_VERSION_FULL : PLUGIN_VERSION));
        }
        titlePanel.add(title);

        JLabel version = new JLabel("v"+PLUGIN_VERSION);
        version.setFont(version.getFont().deriveFont(Font.BOLD, 10f));
        version.setBorder(new EmptyBorder(5, 0, 0, 0));
        titlePanel.add(version);
        topPanel.add(titlePanel);

        JPanel actionButtons = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));

        JButton discordButton = PanelUtils.createActionButton(Icons.DISCORD, Icons.DISCORD_HOVER, "Discord", (btn, modifiers) -> {
            LinkBrowser.browse(DISCORD_URL);
        });
        actionButtons.add(discordButton);

        JButton kofiButton = PanelUtils.createActionButton(Icons.KOFI, Icons.KOFI_HOVER, "Buy me a coffee :)", (btn, modifiers) -> {
            LinkBrowser.browse(KOFI_URL);
        });
        kofiButton.setPreferredSize(new Dimension(17, 17));
        actionButtons.add(kofiButton);

        JButton helpButton = PanelUtils.createActionButton(Icons.HELP, Icons.HELP_HOVER, "Wiki", (btn, modifiers) -> {
            LinkBrowser.browse(HELP_URL);
        });
        actionButtons.add(helpButton);

        JButton configButton = PanelUtils.createActionButton(Icons.CONFIG, Icons.CONFIG_HOVER, "Config", (btn, modifiers) -> {
            WatchdogPlugin.getInstance().openConfiguration();
        });
        actionButtons.add(configButton);

        JButton historyButton = PanelUtils.createActionButton(Icons.TOOLS, Icons.TOOLS_HOVER, "Tools", (btn, modifiers) -> {
            this.muxer.pushState(this.toolsPanelProvider.get());
        });
        actionButtons.add(historyButton);

        JButton alertDropDownButton = PanelUtils.createAlertDropDownButton(createdAlert -> {
            this.alertManager.addAlert(createdAlert, false);
            this.openAlert(createdAlert);
        });
        JPanel addAlertWrapper = new JPanel(new BorderLayout());
        addAlertWrapper.setBorder(new EmptyBorder(0, 5, 0, 0));
        addAlertWrapper.add(alertDropDownButton);
        actionButtons.add(addAlertWrapper);

        topPanel.add(actionButtons, BorderLayout.EAST);

        this.add(topPanel, BorderLayout.NORTH);

        this.alertListPanel = new AlertListPanel(this.alertManager.getAlerts(), null, this::rebuild);
        this.add(this.alertListPanel, BorderLayout.CENTER);

        JPanel importExportGroup = new JPanel(new GridLayout(1, 2, 5, 0));
        JButton importButton = new JButton("Import", Icons.IMPORT);
        importButton.setHorizontalTextPosition(SwingConstants.LEFT);
        importButton.addActionListener(ev -> {
            ImportExportDialog importExportDialog = new ImportExportDialog(
                SwingUtilities.getWindowAncestor(this),
                (json, append) -> this.alertManager.importAlerts(json, this.alertManager.getAlerts(), append, true, this.watchdogConfig.overrideImportsWithDefaults())
            );
            importExportDialog.setVisible(true);
        });
        importExportGroup.add(importButton);
        JButton exportButton = new JButton("Export", Icons.EXPORT);
        exportButton.setHorizontalTextPosition(SwingConstants.LEFT);
        exportButton.addActionListener(ev -> {
            ImportExportDialog importExportDialog = new ImportExportDialog(SwingUtilities.getWindowAncestor(this), this.alertManager.getAlerts());
            importExportDialog.setVisible(true);
        });
        importExportGroup.add(exportButton);

        JPanel bottomPanel = new JPanel(new GridLayout(0, 1, 3, 3));
        bottomPanel.add(importExportGroup);
        JButton hubButton = new JButton("Alert Hub", Icons.DOWNLOAD);
        hubButton.setHorizontalTextPosition(SwingConstants.LEFT);
        hubButton.addActionListener(ev -> {
            AlertHubPanel alertHubPanel = this.alertHubPanelProvider.get();
            this.muxer.pushState(alertHubPanel);
        });
        bottomPanel.add(hubButton);
        this.add(bottomPanel, BorderLayout.SOUTH);

        this.revalidate();
    }

    public void openAlert(Alert alert) {
        PluginPanel panel = this.createPluginPanel(alert);
        if (panel != null) {
            this.muxer.pushState(panel);
        } else {
            log.error(String.format("Tried to open an alert of type %s that doesn't have a panel.", alert.getClass()));
        }
    }

    private PluginPanel createPluginPanel(Alert alert) {
        if (alert instanceof PlayerChatAlert) {
            return new PlayerChatAlertPanel(this, (PlayerChatAlert) alert);
        } else if (alert instanceof ChatAlert) {
            return new GameMessageAlertPanel(this, (ChatAlert) alert);
        } else if (alert instanceof NotificationFiredAlert) {
            return new NotificationFiredAlertPanel(this, (NotificationFiredAlert) alert);
        } else if (alert instanceof StatChangedAlert) {
            return new StatChangedAlertPanel(this, (StatChangedAlert) alert);
        } else if (alert instanceof XPDropAlert) {
            return new XPDropAlertPanel(this, (XPDropAlert) alert);
        } else if (alert instanceof SoundFiredAlert) {
            return new SoundFiredAlertPanel(this, (SoundFiredAlert) alert);
        } else if (alert instanceof SpawnedAlert) {
            return new SpawnedAlertPanel(this, (SpawnedAlert) alert);
        } else if (alert instanceof InventoryAlert) {
            return new InventoryAlertPanel(this, (InventoryAlert) alert);
        } else if (alert instanceof AlertGroup) {
            return new AlertGroupPanel(this, (AlertGroup) alert);
        } else if (alert instanceof LocationAlert) {
            return new LocationAlertPanel(this, (LocationAlert) alert, this.client);
        } else if (alert instanceof OverheadTextAlert) {
            return new OverheadTextAlertPanel(this, (OverheadTextAlert) alert);
        }

        return null;
    }

    @Override
    public void onActivate() {
        this.rebuild();
    }

    @Override
    public void onDeactivate() {
        WatchdogPlugin.getInstance().getScreenMarkerUtil().finishCreation(true);
    }

    public void scrollToBottom() {
        JScrollBar scrollBar = this.alertListPanel.getScrollPane().getVerticalScrollBar();
        scrollBar.setValue(scrollBar.getMaximum());
    }

    public void pickMessage(Consumer<String> callback, Predicate<MessageNode> filter) {
        Stream<MessageNode> messageStream = WatchdogPlugin.getInstance().getMessageQueue().stream();
        if (filter != null) {
            messageStream = messageStream.filter(filter);
        }
        MessagePickerDialog messagePickerDialog = new MessagePickerDialog(
            SwingUtilities.getWindowAncestor(this),
            messageStream.map(MessageNode::getValue),
            callback
        );
        messagePickerDialog.setVisible(true);
    }

    public void pickNotification(Consumer<String> callback) {
        MessagePickerDialog messagePickerDialog = new MessagePickerDialog(
            SwingUtilities.getWindowAncestor(this),
            WatchdogPlugin.getInstance().getNotificationsQueue().stream()
                .map(NotificationFired::getMessage),
            callback
        );
        messagePickerDialog.setVisible(true);
    }

    public void pickOverheadText(Consumer<String> callback) {
        MessagePickerDialog messagePickerDialog = new MessagePickerDialog(
            SwingUtilities.getWindowAncestor(this),
            WatchdogPlugin.getInstance().getOverheadTextQueue().stream()
                .map(OverheadTextChanged::getOverheadText),
            callback
        );
        messagePickerDialog.setVisible(true);
    }
}

package com.adamk33n3r.runelite.watchdog;

import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DocumentFilter;

public class LengthLimitFilter extends DocumentFilter {
    private final int limit;

    public LengthLimitFilter(int limit) {
        this.limit = limit;
    }

    @Override
    public void replace(FilterBypass filterBypass, int offset, int length, String text, AttributeSet attributeSet) throws BadLocationException {
        int currentLength = filterBypass.getDocument().getLength();
        int overLimit = (currentLength + text.length()) - this.limit - length;
        if (overLimit > 0) {
            text = text.substring(0, text.length() - overLimit);
        }

        super.replace(filterBypass, offset, length, text, attributeSet);
    }
}

package com.adamk33n3r.runelite.watchdog;

public interface Displayable {
    String getName();
    String getTooltip();
}

package com.adamk33n3r.runelite.watchdog.elevenlabs;

import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;

import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.annotation.Nonnull;
import java.io.*;
import java.util.Objects;
import java.util.function.Consumer;

import static net.runelite.http.api.RuneLiteAPI.JSON;

@Slf4j
public class ElevenLabs {
    private static final String BASE_URL = "https://api.elevenlabs.io/";

    public static void getVoice(OkHttpClient client, String voiceID, Consumer<Voice> callback, Consumer<String> errorCallback) {
        if (voiceID == null) {
            return;
        }
        Request request = new Request.Builder()
            .url(BASE_URL + "v1/voices/" + voiceID)
            .addHeader("accept", "application/json")
            .addHeader("xi-api-key", WatchdogPlugin.getInstance().getConfig().elevenLabsAPIKey())
            .build();
        makeRequest(client, request, Voice.class, callback, errorCallback);
    }

    public static void getVoices(OkHttpClient client, Consumer<Voices> callback, Consumer<String> errorCallback) {
        Request request = new Request.Builder()
            .url(BASE_URL + "v1/voices")
            .addHeader("accept", "application/json")
            .addHeader("xi-api-key", WatchdogPlugin.getInstance().getConfig().elevenLabsAPIKey())
            .build();
        makeRequest(client, request, Voices.class, callback, errorCallback);
    }

    public static void generateTTS(OkHttpClient client, Voice voice, String message, Consumer<File> callback, Consumer<String> errorCallback) {
//        String body = WatchdogPlugin.getInstance().getAlertManager().getGson().toJson("");
        Request request = new Request.Builder()
            .url(BASE_URL + "v1/text-to-speech/" + voice.getVoiceId())
            .post(RequestBody.create(JSON, "{\n" +
                "  \"text\": \""+message+"\",\n" +
                "  \"voice_settings\": {\n" +
                "    \"stability\": 0.5,\n" +
                "    \"similarity_boost\": 0.5,\n" +
                "    \"style\": 0.5,\n" +
                "    \"use_speaker_boost\": true\n" +
                "  }\n" +
                "}"))
            .addHeader("xi-api-key", WatchdogPlugin.getInstance().getConfig().elevenLabsAPIKey())
            .build();
        makeRequest(client, request, File.class, callback, errorCallback);
//        download(client, "U4OFqla1WHSBijg88mGB", callback);
    }

    public static void download(OkHttpClient client, String id, Consumer<File> callback, Consumer<String> errorCallback) {
        Request request = new Request.Builder()
            .url(BASE_URL + "v1/history/download")
            .post(RequestBody.create(JSON, "{\n" +
                "  \"history_item_ids\": [\n" +
                "    \""+id+"\"\n" +
                "  ]\n" +
                "}"))
            .addHeader("xi-api-key", WatchdogPlugin.getInstance().getConfig().elevenLabsAPIKey())
            .build();
        makeRequest(client, request, File.class, callback, errorCallback);
    }

    private static <T> void makeRequest(OkHttpClient client, Request request, Class<T> rType, Consumer<T> callback, Consumer<String> errorCallback) {
        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@Nonnull Call call, @Nonnull IOException e) {
                log.error("Error with request at: {}", request.url(), e);
            }

            @Override
            public void onResponse(@Nonnull Call call, @Nonnull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        log.error("Unexpected error code: {}", response);
                        errorCallback.accept(response.message() + ": " + (responseBody != null ? responseBody.string() : "no body"));
                        return;
                    }

                    if (responseBody == null) {
                        log.error("Response body is null: {}", response);
                        errorCallback.accept("Response body is null");
                        return;
                    }

                    if (Objects.requireNonNull(response.header("content-type")).contains("application/json")) {
                        callback.accept(WatchdogPlugin.getInstance().getAlertManager().getGson().fromJson(responseBody.charStream(), rType));
    //                    Voice voice = voices.getVoices().get(voices.getVoices().size() - 1);
    //                    generateTTS(client, voice, "This is a test of the playback sound system");
    //                    download(client, "U4OFqla1WHSBijg88mGB");
                    } else if (rType.isAssignableFrom(File.class)) {
                        log.debug("got audio stream");
                        File tmpFile = File.createTempFile("watchdog", ".mp3");
    //                    BufferedInputStream bufferedInputStream = new BufferedInputStream(response.body().byteStream());
                        InputStream inputStream = responseBody.byteStream();
                        try (FileOutputStream fileOutputStream = new FileOutputStream(tmpFile)) {
                            byte[] buffer = new byte[8192];
                            int bytesRead;
                            while ((bytesRead = inputStream.read(buffer, 0, buffer.length)) != -1) {
                                fileOutputStream.write(buffer, 0, bytesRead);
                            }
                        }

                        log.debug("tmp file: {}", tmpFile);
//                        WatchdogPlugin.getInstance().getSoundPlayer().play(tmpFile, 10);
//                        WatchdogPlugin.getInstance().getSoundPlayer().play(tmpFile, 5);
//                        WatchdogPlugin.getInstance().getSoundPlayer().play(tmpFile, 2);
//                        WatchdogPlugin.getInstance().getSoundPlayer().play(new File("C:\\Users\\adamg\\Music\\airplane_seatbelt.wav"), 10);
//                        WatchdogPlugin.getInstance().getSoundPlayer().play(tmpFile, 10);
                        callback.accept(rType.cast(tmpFile));
                    }
                } catch (Exception e) {
                    log.error("error while hitting eleven labs api");
                }
            }
        });
    }
}

package com.adamk33n3r.runelite.watchdog.elevenlabs;

import lombok.Data;

import java.util.List;

@Data
public class Voices {
    private List<Voice> voices;
}

package com.adamk33n3r.runelite.watchdog.elevenlabs;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

import java.util.Map;

@Data
public class Voice {
    @SerializedName("voice_id")
    private String voiceId;
    private String name;
    private String category;
    private String description;
    @SerializedName("preview_url")
    private String previewUrl;
    private Map<String, String> labels;
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.notifications.objectmarkers.ObjectMarkerManager;
import com.adamk33n3r.runelite.watchdog.notifications.objectmarkers.ObjectMarkerOverlay;
import com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker.ScreenMarkerUtil;

import net.runelite.api.Client;
import net.runelite.api.MessageNode;
import net.runelite.api.WorldView;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NotificationFired;
import net.runelite.client.events.OverlayMenuClicked;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.util.AsyncBufferedImage;

import com.google.common.collect.EvictingQueue;
import com.google.inject.Binder;
import com.google.inject.Provides;
import com.google.inject.name.Names;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.HotkeyListener;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.Queue;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;

@Slf4j
@PluginDescriptor(
    name = "Watchdog",
    description = "Create custom alerts for different events like messages, stats, or built-in notifications",
    tags = {"alert", "notification","custom","advanced","overlay","sound","drop","afk","tracker","reminder","notify","notifier","helper","timer","message"}
)
public class WatchdogPlugin extends Plugin {
    @Getter
    @Inject
    private WatchdogConfig config;
    @Inject
    private ConfigManager configManager;
    @Inject
    private ItemManager itemManager;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private OverlayManager overlayManager;

    @Getter
    @Inject
    private ObjectMarkerManager objectMarkerManager;

    @Getter
    @Inject
    private AlertManager alertManager;

    @Getter
    @Inject
    private PopupManager popupManager;

    @Inject
    private KeyManager keyManager;

    @Inject
    private Client client;

    @Inject
    private EventBus eventBus;

    @Inject
    private EventHandler eventHandler;

    @Getter
    @Inject
    private FlashOverlay flashOverlay;

    @Getter
    @Inject
    private NotificationOverlay notificationOverlay;

    @Getter
    @Inject
    private ObjectMarkerOverlay objectMarkerOverlay;

    @Getter
    @Inject
    private ScreenMarkerUtil screenMarkerUtil;

    @Getter
    @Inject
    private WatchdogPanel panel;

    @Getter
    @Inject
    private SoundPlayer soundPlayer;

    @Getter
    @Inject
    private OkHttpClient httpClient;

    private AsyncBufferedImage icon;
    private AsyncBufferedImage iconDisabled;
    private NavigationButton navButton;
    private NavigationButton navButtonDisabled;

    @Getter
    private static WatchdogPlugin instance;

    @Getter
    private final Queue<MessageNode> messageQueue = EvictingQueue.create(200);

    @Getter
    private final Queue<OverheadTextChanged> overheadTextQueue = EvictingQueue.create(200);

    @Getter
    private final Queue<NotificationFired> notificationsQueue = EvictingQueue.create(20);

    private final List<AlertProcessor> alertProcessors = new ArrayList<>();

    @Getter
    private boolean isInBannedArea = false;

    private final List<HotkeyListener> hotkeyListeners = List.of(
        new HotkeyListener(() -> config.clearAllHotkey()) {
            @Override
            public void hotkeyPressed() {
                stopAllAlerts();
                soundPlayer.stop();
                notificationOverlay.clear();
                screenMarkerUtil.removeAllMarkers();
                objectMarkerManager.removeAllMarkers();
            }
        },
        new HotkeyListener(() -> config.stopAllProcessingAlertsHotkey()) {
            @Override
            public void hotkeyPressed() {
                stopAllAlerts();
            }
        },
        new HotkeyListener(() -> config.stopAllQueuedSoundsHotkey()) {
            @Override
            public void hotkeyPressed() {
                soundPlayer.stop();
            }
        },
        new HotkeyListener(() -> config.dismissAllOverlaysHotkey()) {
            @Override
            public void hotkeyPressed() {
                notificationOverlay.clear();
            }
        },
        new HotkeyListener(() -> config.dismissAllScreenMarkersHotkey()) {
            @Override
            public void hotkeyPressed() {
                screenMarkerUtil.removeAllMarkers();
            }
        },
        new HotkeyListener(() -> config.dismissAllObjectMarkersHotkey()) {
            @Override
            public void hotkeyPressed() {
                objectMarkerManager.removeAllMarkers();
            }
        }
    );

    public WatchdogPlugin() {
        instance = this;
    }

    @Override
    public void configure(Binder binder) {
        Properties properties = WatchdogProperties.getProperties();
        Names.bindProperties(binder, properties);
        binder.bind(WatchdogMuxer.class).toProvider(() -> this.panel.getMuxer());
    }

    @Override
    protected void startUp() throws Exception {
        this.eventBus.register(this.eventHandler);
        this.eventBus.register(this.objectMarkerManager);

        this.overlayManager.add(this.flashOverlay);
        this.overlayManager.add(this.notificationOverlay);
        this.overlayManager.add(this.objectMarkerOverlay);
        this.screenMarkerUtil.startUp();

        this.alertManager.loadAlerts();

        this.icon = this.itemManager.getImage(ItemID.WIN05_BELLBAUBLE_UNPAINTED);
        this.iconDisabled = this.itemManager.getImage(ItemID.WIN05_BELLBAUBLE_RED);

        this.rebuildSidePanelButtons();

        this.soundPlayer.startUp();

        ToolTipManager.sharedInstance().setDismissDelay(Integer.MAX_VALUE);

        for (var hotkeyListener : this.hotkeyListeners) {
            this.keyManager.registerKeyListener(hotkeyListener);
        }
    }

    private void rebuildSidePanelButtons() {
        if (this.navButton != null) {
            this.clientToolbar.removeNavigation(this.navButton);
        }
        if (this.navButtonDisabled != null) {
            this.clientToolbar.removeNavigation(this.navButtonDisabled);
        }
        this.navButton = NavigationButton.builder()
            .tooltip("Watchdog")
            .icon(icon)
            .priority(this.config.sidePanelPriority())
            .panel(this.panel.getMuxer())
            .build();
        this.navButtonDisabled = NavigationButton.builder()
            .tooltip("Watchdog (In disabled area)")
            .icon(iconDisabled)
            .priority(this.config.sidePanelPriority())
            .panel(this.panel.getMuxer())
            .build();
        this.icon.onLoaded(() -> {
            if (this.isInBannedArea) {
                this.clientToolbar.addNavigation(this.navButtonDisabled);
            } else {
                this.clientToolbar.addNavigation(this.navButton);
            }
        });
    }

    @Override
    protected void shutDown() throws Exception {
        this.eventBus.unregister(this.eventHandler);
        this.eventBus.unregister(this.objectMarkerManager);
        this.clientToolbar.removeNavigation(this.navButton);
        this.clientToolbar.removeNavigation(this.navButtonDisabled);
        this.overlayManager.remove(this.flashOverlay);
        this.overlayManager.remove(this.notificationOverlay);
        this.overlayManager.remove(this.objectMarkerOverlay);
        this.soundPlayer.shutDown();
        this.screenMarkerUtil.shutDown();
        for (var hotkeyListener : this.hotkeyListeners) {
            this.keyManager.unregisterKeyListener(hotkeyListener);
        }
    }

    public void openConfiguration() {
        // We don't have access to the ConfigPlugin so let's just emulate an overlay click
        this.eventBus.post(new OverlayMenuClicked(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, null, null), this.notificationOverlay));
    }

    public void processAlert(Alert alert, String[] triggerValues, boolean forceFire) {
        var alertProcessor = new AlertProcessor(alert, triggerValues, forceFire, this.alertProcessors::remove);
        this.alertProcessors.add(alertProcessor);
        alertProcessor.start();
    }

    public void stopAllAlerts() {
        for (var alertProcessor : alertProcessors) {
            alertProcessor.interrupt();
        }
        // Just in case it doesn't call the onFinish callback
        this.alertProcessors.clear();
    }

    @Subscribe
    private void onGameTick(GameTick gameTick) {
        int regionID = WorldPoint.fromLocalInstance(this.client, this.client.getLocalPlayer().getLocalLocation()).getRegionID();
        boolean before = this.isInBannedArea;
        WorldView worldView = this.client.getLocalPlayer().getWorldView();
        this.isInBannedArea = Region.isBannedRegion(regionID, worldView);

        // State changed so switch panel icon
        if (before != this.isInBannedArea) {
            if (this.isInBannedArea) {
                this.clientToolbar.removeNavigation(this.navButton);
                this.clientToolbar.addNavigation(this.navButtonDisabled);
                if (this.panel.getMuxer().isActive()) {
                    SwingUtilities.invokeLater(() -> this.clientToolbar.openPanel(this.navButtonDisabled));
                }
            } else {
                this.clientToolbar.removeNavigation(this.navButtonDisabled);
                this.clientToolbar.addNavigation(this.navButton);
                if (this.panel.getMuxer().isActive()) {
                    SwingUtilities.invokeLater(() -> this.clientToolbar.openPanel(this.navButton));
                }
            }
        }

        this.popupManager.processPopupQueue();
    }

    @Subscribe
    private void onGameStateChanged(GameStateChanged gameStateChanged) {
        this.soundPlayer.stop();
    }

    @Subscribe
    private void onChatMessage(ChatMessage chatMessage) {
        this.messageQueue.offer(chatMessage.getMessageNode());
    }
    @Subscribe
    private void onOverheadTextChanged(OverheadTextChanged overheadTextChanged) {
        this.overheadTextQueue.offer(overheadTextChanged);
    }
    @Subscribe
    private void onNotificationFired(NotificationFired notificationFired) {
        this.notificationsQueue.offer(notificationFired);
    }

    @Subscribe
    private void onConfigChanged(ConfigChanged configChanged) {
        if (configChanged.getGroup().equals(WatchdogConfig.CONFIG_GROUP_NAME)) {
            if (configChanged.getKey().equals(WatchdogConfig.ENABLE_TTS)) {
                // To the top!
                while (this.panel.getMuxer().getComponentCount() > 1) {
                    this.panel.getMuxer().popState();
                }
                this.panel.rebuild();
            } else if (configChanged.getKey().equals(WatchdogConfig.SIDE_PANEL_PRIORITY)) {
                this.rebuildSidePanelButtons();
            }
        }
    }

    @Subscribe
    private void onProfileChanged(ProfileChanged profileChanged) {
        this.alertManager.loadAlerts();
    }

    @Provides
    WatchdogConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(WatchdogConfig.class);
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.notifications.*;

import com.adamk33n3r.runelite.watchdog.notifications.objectmarkers.ObjectMarker;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum NotificationType {
    GAME_MESSAGE("Game Message", "Put a game message in your chat", NotificationCategory.TEXT, GameMessage.class),
    SCREEN_FLASH("Screen Flash", "Flash your screen a custom color", NotificationCategory.OVERLAY, ScreenFlash.class),
    SOUND_EFFECT("Sound Effect", "Play a builtin sound effect", NotificationCategory.AUDIO, SoundEffect.class),
    SOUND("Custom Sound", "Play a custom sound", NotificationCategory.AUDIO, Sound.class),
    TEXT_TO_SPEECH("Text to Speech", "Synthesize speech", NotificationCategory.AUDIO, TextToSpeech.class),
    TRAY_NOTIFICATION("Tray Notification", "Create a tray notification", NotificationCategory.TEXT, TrayNotification.class),
    OVERHEAD("Overhead", "Display overhead text", NotificationCategory.TEXT, Overhead.class),
    OVERLAY("Overlay", "Create an overlay notification", NotificationCategory.OVERLAY, Overlay.class),
    POPUP("Popup", "Create a popup notification (like collection log or league task)", NotificationCategory.OVERLAY, Popup.class),
    SCREEN_MARKER("Screen Marker", "Show a screen marker", NotificationCategory.OVERLAY, ScreenMarker.class),
    OBJECT_MARKER("Object Marker", "Show an object marker", NotificationCategory.OVERLAY, ObjectMarker.class),
    DINK("Dink", "Tell Dink to send a custom notification to your webhook", NotificationCategory.ADVANCED, Dink.class),
    SHORTEST_PATH("Shortest Path", "Sets the Shortest Path plugin's path", NotificationCategory.ADVANCED, ShortestPath.class),
    PLUGIN_MESSAGE("Plugin Message", "Send a message to another plugin", NotificationCategory.ADVANCED, PluginMessage.class),
    PLUGIN_TOGGLE("Plugin Toggle", "Toggle a plugin's enabled state", NotificationCategory.ADVANCED, PluginToggle.class),
    DISMISS_OVERLAY("Dismiss Overlay", "Dismiss a sticky overlay by ID", NotificationCategory.ADVANCED, DismissOverlay.class),
    DISMISS_SCREEN_MARKER("Dismiss Screen Marker", "Dismiss a sticky screen marker by ID", NotificationCategory.ADVANCED, DismissScreenMarker.class),
    DISMISS_OBJECT_MARKER("Dismiss Object Marker", "Dismiss a sticky object marker by ID", NotificationCategory.ADVANCED, DismissObjectMarker.class),
    REQUEST_FOCUS("Request Focus", "Requests focus on the window", NotificationCategory.ADVANCED, RequestFocus.class),
    NOTIFICATION_EVENT("Notification Event", "Fire a NotificationFired event so that other plugins may hook into it e.g. RL Tray Notifications", NotificationCategory.ADVANCED, NotificationEvent.class),
    ;

    private final String name;
    private final String tooltip;
    private final NotificationCategory category;
    private final Class<? extends Notification> implClass;
}

package com.adamk33n3r.runelite.watchdog;

import lombok.Getter;

public class Version implements Comparable<Version> {
    @Getter
    private final String version;

    public Version(String version) {
        if (version != null && !version.matches("[0-9]+(\\.[0-9]+)*(-\\w+)?")) {
            throw new IllegalArgumentException("Invalid version format");
        }
        this.version = version;
    }

    @Override
    public int compareTo(Version o) {
        if (o == null || o.version == null) {
            return 1;
        }

        if (this.version == null) {
            return -1;
        }

        String thisVer = this.version.lastIndexOf('-') < 0 ? this.version : this.version.substring(0, this.version.lastIndexOf("-"));
        String thatVer = o.version.lastIndexOf('-') < 0 ? o.version : o.version.substring(0, o.version.lastIndexOf("-"));
        String[] thisParts = thisVer.split("\\.");
        String[] thatParts = thatVer.split("\\.");
        int length = Math.max(thisParts.length, thatParts.length);
        for (int i = 0; i < length; i++) {
            int thisPart = i < thisParts.length ? Integer.parseInt(thisParts[i]) : 0;
            int thatPart = i < thatParts.length ? Integer.parseInt(thatParts[i]) : 0;
            if (thisPart < thatPart) {
                return -1;
            }
            if (thisPart > thatPart) {
                return 1;
            }
        }

        return 0;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null) {
            return false;
        }
        if (this.getClass() != o.getClass()) {
            return false;
        }

        return this.compareTo((Version) o) == 0;
    }

    @Override
    public String toString() {
        return this.version == null ? null : "v" + this.version;
    }
}

package com.adamk33n3r.runelite.watchdog.hub;

import com.adamk33n3r.runelite.watchdog.alerts.Alert;

import lombok.Data;
import lombok.Setter;

import java.net.URL;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Data
public class AlertManifest {
    @Setter
    private String internalName;
    private URL repo;
    private String commit;

    private final String displayName;
    private final String description;
    private final String compatibleVersion;
    private final String author;
    private final AlertHubCategory category;
    private final List<String> tags;
    private final List<String> dependsOn;
    private final Alert alert;
    private final boolean hasIcon;

    @Override
    public String toString()
    {
        return this.displayName;
    }

    public List<String> getKeywords() {
        Stream<String> keywords = Stream.of(
            this.getDisplayName(),
            this.getInternalName(),
            this.getAuthor(),
            this.getCategory().getName()
        ).filter(Objects::nonNull);
        if (this.getTags() != null) {
            keywords = Stream.concat(keywords, this.getTags().stream());
        }
        if (this.getDependsOn() != null) {
            keywords = Stream.concat(keywords, this.getDependsOn().stream());
        }
        return keywords.collect(Collectors.toList());
    }
}

package com.adamk33n3r.runelite.watchdog.hub;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.WrappingLabel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.RuneLite;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import lombok.Getter;

import javax.swing.*;
import javax.swing.border.LineBorder;
import java.awt.Color;
import java.awt.image.BufferedImage;

@Getter
public class AlertHubItem extends JPanel {
    private static final int LINE_HEIGHT = 16;

    private final AlertHubClient.AlertDisplayInfo alertDisplayInfo;

    public AlertHubItem(AlertHubClient.AlertDisplayInfo alertDisplayInfo, WatchdogConfig watchdogConfig) {
        this.alertDisplayInfo = alertDisplayInfo;
        this.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);

        AlertManifest manifest = this.alertDisplayInfo.getManifest();
        JLabel alertName = new JLabel(manifest.getDisplayName());
        alertName.setFont(FontManager.getRunescapeBoldFont());
        alertName.setToolTipText(manifest.getDisplayName());
        JLabel alertAuthor = new JLabel(manifest.getAuthor());
        alertAuthor.setFont(FontManager.getRunescapeSmallFont());
        alertAuthor.setToolTipText(manifest.getAuthor());

        try {
            alertName.setIcon(new ImageIcon(ImageUtil.loadImageResource(RuneLite.class, manifest.getCategory().getIcon())));
        } catch (Exception e) {
            // error loading icon
            alertName.setIcon(Icons.HELP);
        }

        JLabel compatVersion = new JLabel(manifest.getCompatibleVersion());
        compatVersion.setHorizontalAlignment(JLabel.RIGHT);
        compatVersion.setFont(FontManager.getRunescapeSmallFont());
        compatVersion.setToolTipText("Compatible with Watchdog v" + manifest.getCompatibleVersion());

        WrappingLabel alertDescLabel = new WrappingLabel(manifest.getDescription());

        JButton moreInfoButton = PanelUtils.createActionButton(Icons.HELP, Icons.HELP_HOVER, "More info", (btn, mod) -> {
            LinkBrowser.browse(manifest.getRepo().toString());
        });
        if (manifest.getRepo() == null) {
            moreInfoButton.setVisible(false);
        }

        JButton addButton = new JButton();
        addButton.setText("Add");
        BufferedImage addIcon = ImageUtil.recolorImage(Icons.ADD.getImage(), Color.WHITE);
        addButton.setIcon(new ImageIcon(addIcon));
        addButton.setHorizontalTextPosition(SwingConstants.LEFT);
        addButton.setBackground(new Color(0x28BE28));
        addButton.setBorder(new LineBorder(addButton.getBackground().darker()));
        addButton.setFocusPainted(false);
        addButton.addActionListener((ev) -> {
            WatchdogPlugin.getInstance().getAlertManager().addAlert(manifest.getAlert(), watchdogConfig.overrideImportsWithDefaults());
            JOptionPane.showMessageDialog(this, "Added " + manifest.getDisplayName() + " to your alerts", "Successfully Added", JOptionPane.INFORMATION_MESSAGE);
        });

        JLabel dependsOn = new JLabel();
        dependsOn.setFont(FontManager.getRunescapeSmallFont());
        if (manifest.getDependsOn() != null && !manifest.getDependsOn().isEmpty()) {
            dependsOn.setText("Depends On: " + String.join(", ", manifest.getDependsOn()));
        }

        layout.setVerticalGroup(layout.createSequentialGroup()
            .addGap(5)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                    .addComponent(alertName, LINE_HEIGHT, LINE_HEIGHT, LINE_HEIGHT)
                    .addComponent(moreInfoButton, LINE_HEIGHT, LINE_HEIGHT, LINE_HEIGHT)
                    .addComponent(addButton, LINE_HEIGHT, LINE_HEIGHT, LINE_HEIGHT)
                )
                .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.PREFERRED_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                    .addComponent(alertAuthor, LINE_HEIGHT, LINE_HEIGHT, LINE_HEIGHT)
                    .addComponent(compatVersion, LINE_HEIGHT, LINE_HEIGHT, LINE_HEIGHT)
                )
                .addComponent(alertDescLabel, 0, GroupLayout.DEFAULT_SIZE, 96)
                .addComponent(dependsOn, 0, GroupLayout.DEFAULT_SIZE, LINE_HEIGHT)
                .addGap(5)
            )
        );

        layout.setHorizontalGroup(layout.createParallelGroup()
            // Info group
            .addGroup(layout.createSequentialGroup()
                .addGap(5)
                .addGroup(layout.createParallelGroup()
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(alertName, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.PREFERRED_SIZE, Short.MAX_VALUE)
                        .addComponent(moreInfoButton, 24, 24, 24)
                        .addComponent(addButton, 50, 50, GroupLayout.PREFERRED_SIZE)
                    )
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(alertAuthor, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.PREFERRED_SIZE, 100)
                        .addComponent(compatVersion, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    )
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(alertDescLabel, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    )
                    .addComponent(dependsOn)
                )
                .addGap(5)
            )
        );
    }
}

package com.adamk33n3r.runelite.watchdog.hub;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum AlertHubCategory {
    COMBAT("Combat", "Combat", "/skill_icons_small/combat.png"),
    SKILLING("Skilling", "Skilling", "/skill_icons_small/mining.png"),
    BOSSES("Bosses", "Bosses", "/skill_icons_small/slayer.png"),
    AFK("AFK", "AFK", "/skill_icons_small/fishing.png"),
    MISC("Misc", "Misc", "/com/adamk33n3r/runelite/watchdog/ui/clue_scroll_all.png")
    ;

    private final String name;
    private final String tooltip;
    private final String icon;
}

package com.adamk33n3r.runelite.watchdog.hub;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogMuxer;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.SearchBar;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;
import com.adamk33n3r.runelite.watchdog.ui.panels.ScrollablePanel;

import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Provider;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.stream.Collectors;

@Slf4j
public class AlertHubPanel extends PluginPanel {
    private final Provider<WatchdogMuxer> muxer;
    private final AlertHubClient alertHubClient;
    private final ScheduledExecutorService executor;
    private final WatchdogConfig watchdogConfig;

    private List<AlertHubItem> alertHubItems = new ArrayList<>();
    private final IconTextField searchBar;
    private final JPanel container;
    private final JLabel loading;
    private final JScrollPane scrollPane;

    @Inject
    public AlertHubPanel(Provider<WatchdogMuxer> muxer, AlertHubClient alertHubClient, ScheduledExecutorService executor, WatchdogConfig watchdogConfig) {
        super(false);
        this.muxer = muxer;
        this.alertHubClient = alertHubClient;
        this.executor = executor;
        this.watchdogConfig = watchdogConfig;

        JButton backButton = PanelUtils.createActionButton(
            Icons.BACK,
            Icons.BACK_HOVER,
            "Back",
            (btn, modifiers) -> this.muxer.get().popState()
        );
        backButton.setPreferredSize(new Dimension(22, 16));
        backButton.setBorder(new EmptyBorder(0, 0, 0, 5));

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        this.searchBar = new SearchBar(this::updateFilter);
        Arrays.stream(AlertHubCategory.values()).map(AlertHubCategory::getName).forEach(this.searchBar.getSuggestionListModel()::addElement);

        this.container = new JPanel(new DynamicGridLayout(0, 1, 0, 5));
//        this.container.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

        ScrollablePanel wrapper = new ScrollablePanel(new BorderLayout());
        wrapper.add(this.container, BorderLayout.NORTH);
        this.loading = new JLabel("Loading...");
        this.loading.setVisible(false);
        this.loading.setHorizontalAlignment(JLabel.CENTER);
        wrapper.add(this.loading, BorderLayout.CENTER);
        wrapper.setScrollableWidth(ScrollablePanel.ScrollableSizeHint.FIT);
        wrapper.setScrollableHeight(ScrollablePanel.ScrollableSizeHint.STRETCH);
        wrapper.setScrollableBlockIncrement(SwingConstants.VERTICAL, ScrollablePanel.IncrementType.PERCENT, 10);
        wrapper.setScrollableUnitIncrement(SwingConstants.VERTICAL, ScrollablePanel.IncrementType.PERCENT, 10);
        this.scrollPane = new JScrollPane(wrapper, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

        JButton refresh = PanelUtils.createActionButton(Icons.REFRESH, Icons.REFRESH_HOVER, "Refresh", (btn, mod) -> {
            this.reloadList(true);
        });

        layout.setVerticalGroup(layout.createSequentialGroup()
            .addGap(5)
            .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
                .addComponent(backButton, 24, 24, 24)
                .addComponent(this.searchBar, 24, 24, 24)
                .addComponent(refresh, 24, 24, 24))
            .addGap(5)
            .addComponent(this.scrollPane)
        );

        layout.setHorizontalGroup(layout.createParallelGroup()
            .addGroup(layout.createSequentialGroup()
                .addComponent(backButton)
                .addComponent(this.searchBar)
                .addComponent(refresh))
            .addGroup(layout.createSequentialGroup()
                .addGap(5)
                .addComponent(this.scrollPane)
                .addGap(5)
            )
        );

        this.reloadList(false);
    }

    public void reloadList(boolean forceDownload) {
        if (this.loading.isVisible()) {
            return;
        }

        this.container.removeAll();
        this.loading.setVisible(true);
        this.executor.submit(() -> {
            try {
                List<AlertHubClient.AlertDisplayInfo> alerts = this.alertHubClient.downloadManifest(forceDownload);
                this.reloadList(alerts);
            } catch (IOException e) {
                log.error("Failed to download alert hub manifest", e);
            }
        });
    }

    private void reloadList(List<AlertHubClient.AlertDisplayInfo> alerts) {
        SwingUtilities.invokeLater(() -> {
            this.loading.setVisible(false);
            this.alertHubItems = alerts.stream()
                .map(alertDisplayInfo -> new AlertHubItem(alertDisplayInfo, this.watchdogConfig))
                .collect(Collectors.toList());
            this.updateFilter(this.searchBar.getText());
        });
    }

    private void updateFilter(String search) {
        this.container.removeAll();
        this.alertHubItems.stream().filter(alertHubItem -> {
            AlertManifest manifest = alertHubItem.getAlertDisplayInfo().getManifest();
            return Util.searchText(search, manifest.getKeywords());
        }).forEach(this.container::add);
        this.container.revalidate();
        this.scrollPane.getVerticalScrollBar().setValue(0);
    }
}

package com.adamk33n3r.runelite.watchdog.hub;

import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;

import net.runelite.client.util.ImageUtil;

import com.google.common.base.Charsets;
import com.google.common.io.CharStreams;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.annotation.Nonnull;
import javax.imageio.ImageIO;
import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

@Slf4j
public class AlertHubClient {
    private final OkHttpClient cachingClient;
    private static final HttpUrl GITHUB = Objects.requireNonNull(HttpUrl.parse("https://github.com/adamk33n3r/runelite-watchdog"));

    @Inject
    public AlertHubClient(OkHttpClient cachingClient) {
        this.cachingClient = cachingClient.newBuilder()
            .addInterceptor(new CacheInterceptor(15))
            .build();
    }

    public List<AlertDisplayInfo> downloadManifest(boolean forceDownload) throws IOException {
        HttpUrl allAlerts = GITHUB.newBuilder()
            .addPathSegment("archive")
            .addPathSegment("alert-hub.zip")
            .build();

        HashMap<String, AlertDisplayInfo> alerts = new HashMap<>();
        Request.Builder reqBuilder = new Request.Builder().url(allAlerts);
        if (forceDownload) {
            reqBuilder.cacheControl(CacheControl.FORCE_NETWORK);
        }
        try (Response res  = this.cachingClient.newCall(reqBuilder.build()).execute()) {
            if (res.code() != 200) {
                throw new IOException("Non-OK response code: " + res.code());
            }

            BufferedInputStream is = new BufferedInputStream(Objects.requireNonNull(res.body()).byteStream());
            ZipInputStream zipInputStream = new ZipInputStream(is);
            ZipEntry entry;
            while ((entry = zipInputStream.getNextEntry()) != null) {
                String filePath = entry.getName().replaceAll("runelite-watchdog-alert-hub/", "");
                String[] splitPath = filePath.split("/", 2);
                if (splitPath.length == 2) {
                    String alertName = splitPath[0];
                    // Don't need to show the example in the panel
                    if (alertName.equals("example") || alertName.equals(".vscode")) {
                        continue;
                    }
                    if (!alerts.containsKey(alertName)) {
                        alerts.put(alertName, new AlertDisplayInfo());
                    }
                    AlertDisplayInfo alertDisplayInfo = alerts.get(alertName);
                    String alertFile = splitPath[1];
                    if (alertFile.equals("alert.json")) {
                        String json = CharStreams.toString(new InputStreamReader(zipInputStream, Charsets.UTF_8));
                        AlertManifest alertManifest = WatchdogPlugin.getInstance().getAlertManager().getGson().fromJson(json, AlertManifest.class);
                        alertManifest.setInternalName(alertName);
                        HttpUrl repoPage = GITHUB.newBuilder()
                            .addPathSegment("tree")
                            .addPathSegment("alert-hub")
                            .addPathSegment(alertName)
                            .build();
                        alertManifest.setRepo(repoPage.url());
                        alertDisplayInfo.manifest = alertManifest;
                    } else if (alertFile.equals("icon.png")) {
                        BufferedImage icon = ImageIO.read(zipInputStream);
                        alertDisplayInfo.icon = ImageUtil.resizeImage(icon, 242, 182, true);
                    }
                }
            }

            return alerts.values().stream().sorted(Comparator.comparing(alert -> alert.manifest.getDisplayName()))
                .collect(Collectors.toList());
        }


//        return Arrays.asList(new AlertManifest(
//            "testAlert",
//            "284hfu43hhfiu24rf",
//            "Test Alert",
//            "This is a test alert on the hub",
//            "4",
//            "adamk33n3r",
//            AlertHubCategory.COMBAT,
//            Arrays.asList("afk", "combat"),
//            new URL("https://github.com/adamk33n3r/runelite-watchdog"),
//            null,
//            false
//        ), new AlertManifest(
//            "testAlert",
//            "284hfu43hhfiu24rf",
//            "Test Alert",
//            "This is a test alert on the hub",
//            "4",
//            "adamk33n3r",
//            AlertHubCategory.COMBAT,
//            Arrays.asList("afk", "combat"),
//            new URL("https://github.com/adamk33n3r/runelite-watchdog"),
//            null,
//            false
//        ), new AlertManifest(
//            "testAlert",
//            "284hfu43hhfiu24rf",
//            "Test Alert",
//            "This is a test alert on the hub",
//            "4",
//            "adamk33n3r",
//            AlertHubCategory.COMBAT,
//            Arrays.asList("afk", "combat"),
//            new URL("https://github.com/adamk33n3r/runelite-watchdog"),
//            null,
//            false
//        ), new AlertManifest(
//            "testAlert2",
//            "284hfu43hhfiu24rf",
//            "Test Alert 2",
//            "This is a test alert on the hub with an extra long description to test wrapping",
//            "4",
//            "adamk33n3r",
//            AlertHubCategory.SKILLING,
//            Arrays.asList("mining", "tts"),
//            new URL("https://github.com/adamk33n3r/runelite-watchdog"),
//            null,
//            false
//        ));
    }

    static class CacheInterceptor implements Interceptor {
        private final int minutes;
        public CacheInterceptor(int minutes) {
            this.minutes = minutes;
        }

        @Override
        @Nonnull
        public Response intercept(Chain chain) throws IOException {
            Response response = chain.proceed(chain.request());

            CacheControl cacheControl = new CacheControl.Builder()
                .maxAge(this.minutes, TimeUnit.MINUTES)
                .build();

            return response.newBuilder()
                .removeHeader("Pragma")
                .removeHeader("Cache-Control")
                .header("Cache-Control", cacheControl.toString())
                .build();
        }
    }

    @Getter
    public static class AlertDisplayInfo {
        private AlertManifest manifest;
        private BufferedImage icon;
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.FlashMode;
import com.adamk33n3r.runelite.watchdog.notifications.tts.TTSSource;
import com.adamk33n3r.runelite.watchdog.notifications.tts.Voice;

import net.runelite.api.SoundEffectID;
import net.runelite.client.config.*;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.util.ColorUtil;

import java.awt.Color;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;

@ConfigGroup(WatchdogConfig.CONFIG_GROUP_NAME)
public interface WatchdogConfig extends Config {
    String CONFIG_GROUP_NAME = "watchdog";
    Color DEFAULT_NOTIFICATION_COLOR = ColorUtil.fromHex("#46FF0000");
    Color DEFAULT_NOTIFICATION_TEXT_COLOR = Color.WHITE;

    // Hidden
    String ALERTS = "alerts";
    String PLUGIN_VERSION = "pluginVersion";

    // Core
    String ENABLE_TTS = "enableTTS";
    String OVERRIDE_IMPORTS_WITH_DEFAULTS = "overrideImportsWithDefaults";
    String SIDE_PANEL_PRIORITY = "sidePanelPriority";
    String ENABLE_NOTIFICATION_CATEGORIES = "enableNotificationCategories";

    // AFK Notification
    String DEFAULT_AFK_MODE = "defaultAFKMode";
    String DEFAULT_AFK_SECONDS = "defaultAFKSeconds";

    // Overhead
    String DEFAULT_OVERHEAD_DISPLAY_TIME = "defaultOverheadDisplayTime";

    // Overlay
    String OVERLAY_LAYER = "overlayLayer";
    String OVERLAY_FONT_TYPE = "overlayFontType";
    String OVERLAY_SHOW_TIME = "overlayShowTime";
    String DEFAULT_OVERLAY_STICKY = "defaultOverlaySticky";
    String DEFAULT_OVERLAY_TEXT_COLOR = "defaultOverlayTextColor";
    String DEFAULT_OVERLAY_COLOR = "defaultOverlayColor";
    String DEFAULT_OVERLAY_TTL = "defaultOverlayTTL";
    String DEFAULT_OVERLAY_IMAGE_PATH = "defaultOverlayImagePath";
    String DEFAULT_OVERLAY_RESIZE_IMAGE = "defaultOverlayResizeImage";

    // Popup
    String DEFAULT_POPUP_TEXT_COLOR = "defaultPopupTextColor";

    // Screen Flash
    String MOUSE_MOVEMENT_CANCELS_FLASH = "mouseMovementCancelsFlash";
    String DEFAULT_SCREEN_FLASH_COLOR = "defaultScreenFlashColor";
    String DEFAULT_SCREEN_FLASH_TYPE = "defaultScreenFlashType";
    String DEFAULT_SCREEN_FLASH_MODE = "defaultScreenFlashMode";
    String DEFAULT_SCREEN_FLASH_DURATION = "defaultScreenFlashDuration";

    // Sound
    String PUT_SOUNDS_INTO_QUEUE = "putSoundsIntoQueue";
    String DEFAULT_SOUND_VOLUME = "defaultSoundVolume";
    String DEFAULT_SOUND_PATH = "defaultSoundPath";

    // Sound Effect
    String DEFAULT_SOUND_EFFECT_ID = "defaultSoundEffectID";
    String DEFAULT_SOUND_EFFECT_VOLUME = "defaultSoundEffectVolume";

    // TTS
    String DEFAULT_TTS_VOLUME = "defaultTTSVolume";
    String DEFAULT_TTS_SOURCE = "defaultTTSSource";
    String DEFAULT_TTS_VOICE = "defaultTTSVoice";
    String DEFAULT_TTS_RATE = "defaultTTSRate";
    String ELEVEN_LABS_API_KEY = "elevenLabsAPIKey";
    String DEFAULT_ELEVEN_LABS_VOICE = "defaultElevenLabsVoice";

    // Request Focus
    String DEFAULT_FORCE_FOCUS = "defaultForceFocus";

    // Markers
    String DEFAULT_SCREEN_MARKER_BORDER_COLOR = "defaultScreenMarkerBorderColor";
    String DEFAULT_SCREEN_MARKER_FILL_COLOR = "defaultScreenMarkerFillColor";
    String DEFAULT_SCREEN_MARKER_BORDER_THICKNESS = "defaultScreenMarkerBorderThickness";
    String DEFAULT_SCREEN_MARKER_DISPLAY_TIME = "defaultScreenMarkerDisplayTime";
    String DEFAULT_SCREEN_MARKER_STICKY = "defaultScreenMarkerSticky";

    String DEFAULT_OBJECT_MARKER_BORDER_COLOR = "defaultObjectMarkerBorderColor";
    String DEFAULT_OBJECT_MARKER_FILL_COLOR = "defaultObjectMarkerFillColor";
    String DEFAULT_OBJECT_MARKER_HULL = "defaultObjectMarkerHull";
    String DEFAULT_OBJECT_MARKER_OUTLINE = "defaultObjectMarkerOutline";
    String DEFAULT_OBJECT_MARKER_CLICKBOX = "defaultObjectMarkerClickbox";
    String DEFAULT_OBJECT_MARKER_TILE = "defaultObjectMarkerTile";
    String DEFAULT_OBJECT_MARKER_BORDER_THICKNESS = "defaultObjectMarkerBorderThickness";
    String DEFAULT_OBJECT_MARKER_FEATHER = "defaultObjectMarkerFeather";
    String DEFAULT_OBJECT_MARKER_DISPLAY_TIME = "defaultObjectMarkerDisplayTime";
    String DEFAULT_OBJECT_MARKER_STICKY = "defaultObjectMarkerSticky";

    // Hotkeys
    String CLEAR_ALL_HOTKEY = "clearAllHotkey";
    String STOP_ALL_PROCESSING_ALERTS_HOTKEY = "stopAllProcessingAlertsHotkey";
    String STOP_ALL_SOUNDS_HOTKEY = "stopAllSoundsHotkey";
    String DISMISS_ALL_OVERLAYS_HOTKEY = "dismissAllOverlaysHotkey";
    String DISMISS_ALL_SCREEN_MARKERS_HOTKEY = "dismissAllScreenMarkersHotkey";
    String DISMISS_ALL_OBJECT_MARKERS_HOTKEY = "dismissAllObjectMarkersHotkey";

    //region Hidden
    @ConfigItem(
        keyName = ALERTS,
        name = "Alerts",
        description = "Serialized Alerts as a JSON string",
        hidden = true
    )
    default String alerts() { return "[]"; }

    @ConfigItem(
        keyName = PLUGIN_VERSION,
        name = "Plugin Version",
        description = "Last version of the plugin loaded",
        hidden = true
    )
    default String pluginVersion() { return null; }
    //endregion

    @ConfigItem(
        keyName = ENABLE_TTS,
        name = "Enable TTS",
        description = "Enables the TTS Notification Type",
        warning = "Using TTS will submit your IP address to a 3rd party website not controlled or verified by the RuneLite Developers."
    )
    default boolean ttsEnabled() { return false; }

    @ConfigItem(
        keyName = MOUSE_MOVEMENT_CANCELS_FLASH,
        name = "Mouse Movement Cancels",
        description = "Cancel the repeated sounds/flashes with mouse movement as well as click and keyboard"
    )
    default boolean mouseMovementCancels() { return true; }

    @ConfigItem(
        keyName = OVERRIDE_IMPORTS_WITH_DEFAULTS,
        name = "Override Imports with Defaults",
        description = "Will override imported alerts with your defaults set here"
    )
    default boolean overrideImportsWithDefaults() { return false; }

    @ConfigItem(
        keyName = PUT_SOUNDS_INTO_QUEUE,
        name = "Put Sounds Into Queue",
        description = "When this is on, all sounds will be queued up so that they will not overlap"
    )
    default boolean putSoundsIntoQueue() { return true; }

    @ConfigItem(
        keyName = SIDE_PANEL_PRIORITY,
        name = "Side Panel Priority",
        description = "Panel icon priority, Lower # = higher pos, Higher # = lower pos "
    )
    @Range(min = Integer.MIN_VALUE)
    default int sidePanelPriority() { return 1; }

    @ConfigItem(
        keyName = ENABLE_NOTIFICATION_CATEGORIES,
        name = "Enable Notification Categories",
        description = "Enables the notification categories in the side panel"
    )
    default boolean enableNotificationCategories() { return true; }

    //region AFK Notification
    @ConfigSection(
        name = "AFK Notification",
        description = "The options that control the afk notification settings",
        position = 0
    )
    String afkNotificationSection = "afkNotificationSection";

    @ConfigItem(
        keyName = DEFAULT_AFK_MODE,
        name = "Default AFK Mode",
        description = "The default AFK mode on/off",
        section = afkNotificationSection
    )
    default boolean defaultAFKMode() { return false; }

    @ConfigItem(
        keyName = DEFAULT_AFK_SECONDS,
        name = "Default AFK Seconds",
        description = "The default AFK seconds value",
        section = afkNotificationSection
    )
    @Units(Units.SECONDS)
    @Range(min = 1)
    default int defaultAFKSeconds() { return 5; }
    //endregion

    //region Overhead
    @ConfigSection(
        name = "Overhead",
        description = "The options that control the overhead notifications",
        position = 1,
        closedByDefault = true
    )
    String overheadSection = "overheadSection";

    @ConfigItem(
        keyName = DEFAULT_OVERHEAD_DISPLAY_TIME,
        name = "Default Display Time",
        description = "The default display time",
        section = overheadSection
    )
    @Units(Units.SECONDS)
    default int defaultOverHeadDisplayTime() { return 3; };
    //endregion

    //region Overlay
    @ConfigSection(
        name = "Overlay",
        description = "The options that control the overlay notifications",
        position = 2,
        closedByDefault = true
    )
    String overlaySection = "overlaySection";

    @ConfigItem(
        keyName = OVERLAY_LAYER,
        name = "Overlay Layer",
        description = "Which layer the overlay renders on. ABOVE_WIDGETS is default",
        section = overlaySection,
        position = 0
    )
    default OverlayLayer overlayLayer() { return OverlayLayer.ABOVE_WIDGETS; }

    @ConfigItem(
        keyName = OVERLAY_FONT_TYPE,
        name = "Overlay Font Type",
        description = "Configures which font type is used for the overlay notifications",
        section = overlaySection,
        position = 1
    )
    default FontType overlayFontType() { return FontType.BOLD; }

    @ConfigItem(
        keyName = OVERLAY_SHOW_TIME,
        name = "Overlay Show Time",
        description = "Shows how long ago the notification was fired on the overlay",
        section = overlaySection,
        position = 2
    )
    default boolean overlayShowTime() { return true; }

    @ConfigItem(
        keyName = DEFAULT_OVERLAY_STICKY,
        name = "Default Sticky",
        description = "The default sticky",
        section = overlaySection,
        position = 3
    )
    default boolean defaultOverlaySticky() { return false; }

    @ConfigItem(
        keyName = DEFAULT_OVERLAY_TTL,
        name = "Default Display Time",
        description = "The default time to display",
        section = overlaySection,
        position = 4
    )
    @Units(Units.SECONDS)
    default int defaultOverlayTTL() { return 5; }

    @ConfigItem(
        keyName = DEFAULT_OVERLAY_TEXT_COLOR,
        name = "Default Text Color",
        description = "The default text color",
        section = overlaySection,
        position = 5
    )
    default Color defaultOverlayTextColor() { return DEFAULT_NOTIFICATION_TEXT_COLOR; }

    @ConfigItem(
        keyName = DEFAULT_OVERLAY_COLOR,
        name = "Default Background Color",
        description = "The default background color",
        section = overlaySection,
        position = 6
    )
    @Alpha
    default Color defaultOverlayColor() { return DEFAULT_NOTIFICATION_COLOR; }

    @ConfigItem(
        keyName = DEFAULT_OVERLAY_IMAGE_PATH,
        name = "Default Image Path",
        description = "The default image path",
        section = overlaySection,
        position = 7
    )
    default String defaultOverlayImagePath() { return ""; }

    @ConfigItem(
        keyName = DEFAULT_OVERLAY_RESIZE_IMAGE,
        name = "Default Resize Image",
        description = "Whether to resize the image to a standard size",
        section = overlaySection,
        position = 8
    )
    default boolean defaultOverlayResizeImage() { return true; }
    //endregion

    //region Popup
    @ConfigSection(
        name = "Popup",
        description = "The options that control the popup notifications",
        position = 3,
        closedByDefault = true
    )
    String popupSection = "popupSection";

    @ConfigItem(
        keyName = DEFAULT_POPUP_TEXT_COLOR,
        name = "Default Text Color",
        description = "The default text color",
        section = popupSection,
        position = 1
    )
    default Color defaultPopupTextColor() { return null; }
    //endregion

    //region Screen Flash
    @ConfigSection(
        name = "Screen Flash",
        description = "The options that control the screen flash notifications",
        position = 4,
        closedByDefault = true
    )
    String screenFlashSection = "screenFlashSection";

    @ConfigItem(
        keyName = DEFAULT_SCREEN_FLASH_COLOR,
        name = "Default Color",
        description = "The default color",
        section = screenFlashSection,
        position = 1
    )
    @Alpha
    default Color defaultScreenFlashColor() { return DEFAULT_NOTIFICATION_COLOR; }

    @ConfigItem(
        keyName = DEFAULT_SCREEN_FLASH_TYPE,
        name = "Default Flash Type",
        description = "The default flash type",
        section = screenFlashSection,
        position = 2
    )
    default FlashNotification defaultScreenFlashType() { return FlashNotification.SOLID_TWO_SECONDS; }

    @ConfigItem(
        keyName = DEFAULT_SCREEN_FLASH_MODE,
        name = "Default Flash Mode",
        description = "The default flash mode",
        section = screenFlashSection,
        position = 3
    )
    default FlashMode defaultScreenFlashMode() { return FlashMode.FLASH; }

    @ConfigItem(
        keyName = DEFAULT_SCREEN_FLASH_DURATION,
        name = "Default Flash Duration",
        description = "The default flash duration in seconds",
        section = screenFlashSection,
        position = 3
    )
    @Units(Units.SECONDS)
    default int defaultScreenFlashDuration() { return 2; }
    //endregion

    //region Sound
    @ConfigSection(
        name = "Custom Sound",
        description = "The options that control the custom sound notifications",
        position = 5,
        closedByDefault = true
    )
    String soundSection = "soundSection";

    @ConfigItem(
        keyName = DEFAULT_SOUND_VOLUME,
        name = "Default Volume",
        description = "The default volume",
        section = soundSection
    )
    @Range(min = 0, max = 10)
    default int defaultSoundVolume() { return 8; }

    @ConfigItem(
        keyName = DEFAULT_SOUND_PATH,
        name = "Default Path",
        description = "The default path",
        section = soundSection
    )
    default String defaultSoundPath() { return null; }
    //endregion

    //region Sound Effect
    @ConfigSection(
        name = "Sound Effect",
        description = "The options that control the custom sound notifications",
        position = 6,
        closedByDefault = true
    )
    String soundEffectSection = "soundEffectSection";

    @ConfigItem(
        keyName = DEFAULT_SOUND_EFFECT_ID,
        name = "Default Sound Effect",
        description = "The default sound effect ID",
        section = soundEffectSection
    )
    default int defaultSoundEffectID() { return SoundEffectID.GE_ADD_OFFER_DINGALING; }

    @ConfigItem(
        keyName = DEFAULT_SOUND_EFFECT_VOLUME,
        name = "Default Volume",
        description = "The default volume",
        section = soundEffectSection
    )
    @Range(min = 0, max = 10)
    default int defaultSoundEffectVolume() { return 8; }
    //endregion

    //region TTS
    @ConfigSection(
        name = "Text to Speech",
        description = "The options that control the text to speech notifications",
        position = 7,
        closedByDefault = true
    )
    String ttsSection = "ttsSection";

    @ConfigItem(
        keyName = DEFAULT_TTS_VOLUME,
        name = "Default Volume",
        description = "The default volume",
        section = ttsSection
    )
    @Range(min = 0, max = 10)
    default int defaultTTSVolume() { return 5; }

    @ConfigItem(
        keyName = DEFAULT_TTS_SOURCE,
        name = "Default Source",
        description = "The default source (Eleven Labs needs your own API Key)",
        section = ttsSection
    )
    default TTSSource defaultTTSSource() { return TTSSource.ELEVEN_LABS; }

    @ConfigItem(
        keyName = DEFAULT_TTS_VOICE,
        name = "Default Legacy Voice",
        description = "The default legacy voice",
        section = ttsSection
    )
    default Voice defaultTTSVoice() { return Voice.GEORGE; }

    @ConfigItem(
        keyName = DEFAULT_TTS_RATE,
        name = "Default Rate",
        description = "The default rate",
        section = ttsSection
    )
    @Range(min = 1, max = 5)
    default int defaultTTSRate() { return 1; }

    @ConfigItem(
        keyName = ELEVEN_LABS_API_KEY,
        name = "Eleven Labs API Key",
        description = "Enter your API key",
        section = ttsSection
    )
    default String elevenLabsAPIKey() { return ""; }

    @ConfigItem(
        keyName = DEFAULT_ELEVEN_LABS_VOICE,
        name = "Default Eleven Labs Voice",
        description = "Matches on the name of the voice exactly",
        section = ttsSection
    )
    default String defaultElevenLabsVoice() { return null; }
    //endregion

    //region Request Focus
    @ConfigSection(
        name = "Request Focus",
        description = "The options that control the request focus notifications",
        position = 8,
        closedByDefault = true
    )
    String requestFocusSection = "requestFocusSection";

    @ConfigItem(
        keyName = DEFAULT_FORCE_FOCUS,
        name = "Force Focus",
        description = "Sets the default focus mode to force",
        section = requestFocusSection
    )
    default boolean defaultRequestFocusForce() { return false; }
    //endregion

    // region Markers

    @ConfigSection(
        name = "Markers",
        description = "The options that control the markers notifications",
        position = 9,
        closedByDefault = true
    )
    String markersSection = "markersSection";

    @ConfigItem(
        keyName = DEFAULT_SCREEN_MARKER_BORDER_COLOR,
        name = "Default Screen Marker Border Color",
        description = "The default border color",
        section = markersSection,
        position = 1
    )
    @Alpha
    default Color defaultScreenMarkerBorderColor() { return Color.GREEN; }

    @ConfigItem(
        keyName = DEFAULT_SCREEN_MARKER_FILL_COLOR,
        name = "Default Screen Marker Fill Color",
        description = "The default fill color",
        section = markersSection,
        position = 2
    )
    @Alpha
    default Color defaultScreenMarkerFillColor() { return null; }

    @ConfigItem(
        keyName = DEFAULT_SCREEN_MARKER_BORDER_THICKNESS,
        name = "Default Screen Marker Border Thickness",
        description = "The default border thickness",
        section = markersSection,
        position = 3
    )
    default int defaultScreenMarkerBorderThickness() { return 2; }

    @ConfigItem(
        keyName = DEFAULT_SCREEN_MARKER_DISPLAY_TIME,
        name = "Default Screen Marker Display Time",
        description = "The default display time",
        section = markersSection,
        position = 4
    )
    @Units(Units.SECONDS)
    default int defaultScreenMarkerDisplayTime() { return 5; }

    @ConfigItem(
        keyName = DEFAULT_SCREEN_MARKER_STICKY,
        name = "Default Screen Marker Sticky",
        description = "The default sticky",
        section = markersSection,
        position = 5
    )
    default boolean defaultScreenMarkerSticky() { return false; }

    @ConfigItem(
        keyName = DEFAULT_OBJECT_MARKER_BORDER_COLOR,
        name = "Default Object Marker Border Color",
        description = "The default border color",
        section = markersSection,
        position = 6
    )
    @Alpha
    default Color defaultObjectMarkerBorderColor() { return Color.YELLOW; }

    @ConfigItem(
        keyName = DEFAULT_OBJECT_MARKER_FILL_COLOR,
        name = "Default Object Marker Fill Color",
        description = "The default fill color",
        section = markersSection,
        position = 7
    )
    @Alpha
    default Color defaultObjectMarkerFillColor() { return null; }

    @ConfigItem(
        keyName = DEFAULT_OBJECT_MARKER_HULL,
        name = "Default Object Marker Hull",
        description = "The default hull",
        section = markersSection,
        position = 8
    )
    default boolean defaultObjectMarkerHull() { return true; }

    @ConfigItem(
        keyName = DEFAULT_OBJECT_MARKER_OUTLINE,
        name = "Default Object Marker Outline",
        description = "The default outline",
        section = markersSection,
        position = 9
    )
    default boolean defaultObjectMarkerOutline() { return false; }

    @ConfigItem(
        keyName = DEFAULT_OBJECT_MARKER_CLICKBOX,
        name = "Default Object Marker Clickbox",
        description = "The default clickbox",
        section = markersSection,
        position = 10
    )
    default boolean defaultObjectMarkerClickbox() { return false; }

    @ConfigItem(
        keyName = DEFAULT_OBJECT_MARKER_TILE,
        name = "Default Object Marker Tile",
        description = "The default tile",
        section = markersSection,
        position = 11
    )
    default boolean defaultObjectMarkerTile() { return false; }

    @ConfigItem(
        keyName = DEFAULT_OBJECT_MARKER_BORDER_THICKNESS,
        name = "Default Object Marker Border Thickness",
        description = "The default border thickness",
        section = markersSection,
        position = 12
    )
    default double defaultObjectMarkerBorderThickness() { return 2.0d; }

    @ConfigItem(
        keyName = DEFAULT_OBJECT_MARKER_FEATHER,
        name = "Default Object Marker Feather",
        description = "The default feather",
        section = markersSection,
        position = 13
    )
    @Range(min = 0, max = 4)
    default int defaultObjectMarkerFeather() { return 0; }

    @ConfigItem(
        keyName = DEFAULT_OBJECT_MARKER_DISPLAY_TIME,
        name = "Default Object Marker Display Time",
        description = "The default display time",
        section = markersSection,
        position = 14
    )
    @Units(Units.SECONDS)
    default int defaultObjectMarkerDisplayTime() { return 5; }

    @ConfigItem(
        keyName = DEFAULT_OBJECT_MARKER_STICKY,
        name = "Default Object Marker Sticky",
        description = "The default sticky",
        section = markersSection,
        position = 15
    )
    default boolean defaultObjectMarkerSticky() { return false; }


    // endregion

    //region Hotkeys
    @ConfigSection(
        name = "Hotkeys",
        description = "The hotkeys to use for various actions",
        position = 10,
        closedByDefault = true
    )
    String hotkeysSection = "hotkeysSection";

    @ConfigItem(
        keyName = CLEAR_ALL_HOTKEY,
        name = "Clear All",
        description = "The hotkey to clear all clearable alerts and notifications",
        section = hotkeysSection
    )
    default Keybind clearAllHotkey() { return new Keybind(KeyEvent.VK_W, InputEvent.CTRL_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK); }

    @ConfigItem(
        keyName = STOP_ALL_PROCESSING_ALERTS_HOTKEY,
        name = "Stop All Processing Alerts",
        description = "The hotkey to stop all processing alerts",
        section = hotkeysSection
    )
    default Keybind stopAllProcessingAlertsHotkey() { return Keybind.NOT_SET; }

    @ConfigItem(
        keyName = STOP_ALL_SOUNDS_HOTKEY,
        name = "Stop All Queued Sounds",
        description = "The hotkey to stop all queued sounds",
        section = hotkeysSection
    )
    default Keybind stopAllQueuedSoundsHotkey() { return Keybind.NOT_SET; }

    @ConfigItem(
        keyName = DISMISS_ALL_OVERLAYS_HOTKEY,
        name = "Dismiss All Overlays",
        description = "The hotkey to dismiss all overlays",
        section = hotkeysSection
    )
    default Keybind dismissAllOverlaysHotkey() { return Keybind.NOT_SET; }

    @ConfigItem(
        keyName = DISMISS_ALL_SCREEN_MARKERS_HOTKEY,
        name = "Dismiss All Screen Markers",
        description = "The hotkey to dismiss all screen markers",
        section = hotkeysSection
    )
    default Keybind dismissAllScreenMarkersHotkey() { return Keybind.NOT_SET; }

    @ConfigItem(
        keyName = DISMISS_ALL_OBJECT_MARKERS_HOTKEY,
        name = "Dismiss All Object Markers",
        description = "The hotkey to dismiss all object markers",
        section = hotkeysSection
    )
    default Keybind dismissAllObjectMarkersHotkey() { return Keybind.NOT_SET; }
    //endregion
}

package com.adamk33n3r.runelite.watchdog;

import lombok.Getter;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

public class WatchdogProperties {
    @Getter()
    private static final Properties properties = new Properties();

    static {
        try (InputStream in = WatchdogProperties.class.getResourceAsStream("watchdog.properties")) {
            properties.load(in);
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }

        try (InputStream in = WatchdogProperties.class.getResourceAsStream("version.properties")) {
            properties.load(in);
            String pluginVersion = String.format(
                "%s.%s.%s",
                properties.getProperty("VERSION_MAJOR"),
                properties.getProperty("VERSION_MINOR"),
                properties.getProperty("VERSION_PATCH"));
            properties.put("watchdog.pluginVersion", pluginVersion);
            String phase = properties.getProperty("VERSION_PHASE");
            String pluginVersionFull = String.format("%s-%s", pluginVersion, phase);
            properties.put("watchdog.pluginVersionFull", pluginVersionFull);
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.api.GameObject;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.util.Text;

import com.google.common.base.Splitter;

import javax.swing.*;
import java.awt.Color;
import java.text.Normalizer;
import java.util.List;
import java.util.stream.Collectors;

public class Util {
    public static <T> T defaultArg(T thing, T defaultValue) {
        if (thing instanceof String) {
            String string = (String) thing;
            return string.isEmpty() ? defaultValue : thing;
        }
        return thing != null ? thing : defaultValue;
    }

    // https://stackoverflow.com/a/17369948
    public static String createRegexFromGlob(String pattern) {
        StringBuilder sb = new StringBuilder(pattern.length());
        int inGroup = 0;
        int inClass = 0;
        int firstIndexInClass = -1;
        char[] arr = pattern.toCharArray();
        for (int i = 0; i < arr.length; i++) {
            char ch = arr[i];
            switch (ch) {
                case '\\':
                    if (++i >= arr.length) {
                        sb.append('\\');
                    } else {
                        char next = arr[i];
                        switch (next) {
                            case ',':
                                // escape not needed
                                break;
                            case 'Q':
                            case 'E':
                                // extra escape needed
                                sb.append('\\');
                            default:
                                sb.append('\\');
                        }
                        sb.append(next);
                    }
                    break;
                case '*':
                    if (inClass == 0)
                        sb.append(".*");
                    else
                        sb.append('*');
                    break;
                case '?':
                    if (inClass == 0)
                        sb.append('.');
                    else
                        sb.append('?');
                    break;
                case '[':
                    inClass++;
                    firstIndexInClass = i+1;
                    sb.append('[');
                    break;
                case ']':
                    inClass--;
                    sb.append(']');
                    break;
                case '.':
                case '(':
                case ')':
                case '+':
                case '|':
                case '^':
                case '$':
                case '@':
                case '%':
                    if (inClass == 0 || (firstIndexInClass == i && ch == '^'))
                        sb.append('\\');
                    sb.append(ch);
                    break;
                case '!':
                    if (firstIndexInClass == i)
                        sb.append('^');
                    else
                        sb.append('!');
                    break;
                case '{':
                    inGroup++;
                    sb.append('(');
                    break;
                case '}':
                    inGroup--;
                    sb.append(')');
                    break;
                case ',':
                    if (inGroup > 0)
                        sb.append('|');
                    else
                        sb.append(',');
                    break;
                default:
                    sb.append(ch);
            }
        }
        return sb.toString();
    }

    public static String splitCamelCase(String s) {
        return s.replaceAll(
            String.format("%s|%s|%s",
                "(?<=[A-Z])(?=[A-Z][a-z])",
                "(?<=[^A-Z])(?=[A-Z])",
                "(?<=[A-Za-z])(?=[^A-Za-z])"
            ),
            " "
        );
    }

    public static String humanReadableClass(Object obj) {
        return splitCamelCase(obj.getClass().getSimpleName());
    }

    public static String processTriggerValues(String string, String[] triggerValues) {
        if (string == null) {
            return null;
        }

        for (int i = 0; i < triggerValues.length; i++) {
            string = string.replaceAll("\\$"+(i+1), triggerValues[i]);
        }

        return string;
    }

    /**
     * Scale a number from one range to another
     * @param val the number to scale
     * @param srcMin min source range
     * @param srcMax max source range
     * @param destMin min dest range
     * @param destMax max dest range
     * @return the scaled number
     */
    public static int scale(int val, float srcMin, float srcMax, float destMin, float destMax) {
        return Math.round(((val - srcMin) / (srcMax - srcMin)) * (destMax - destMin) + destMin);
    }

    private static final Splitter SPLITTER = Splitter.on(" ").trimResults().omitEmptyStrings();
    public static boolean searchText(String search, List<String> keywords) {
        String normalizedSearch = Normalizer.normalize(search, Normalizer.Form.NFD).replaceAll("\\p{InCombiningDiacriticalMarks}+", "").toLowerCase();
        return Text.matchesSearchTerms(
            SPLITTER.split(normalizedSearch),
            keywords.stream().map(term -> Normalizer.normalize(term, Normalizer.Form.NFD).replaceAll("\\p{InCombiningDiacriticalMarks}+", "").toLowerCase()).collect(Collectors.toList()));
    }

    public static Color colorAlpha(Color color, int alpha) {
        if (alpha < 0 || alpha > 255) {
            throw new IllegalArgumentException("alpha must be >= 0 and <= 255");
        }

        return new Color((alpha << 24) | (color.getRGB() & 0xFFFFFF), true);
    }

    public static WorldPoint getClosestTile(WorldPoint playerLocation, GameObject gameObject) {
        int sizeX = gameObject.sizeX();
        int sizeY = gameObject.sizeY();
        WorldPoint worldLocation = gameObject.getWorldLocation();

        // given that the object is larger than 1 tile, the location is the center most tile, rounded to the south-west,
        // calculate the rectangle of all the tiles the object is in
        WorldPoint southWest = new WorldPoint(worldLocation.getX() - (sizeX - 1) / 2, worldLocation.getY() - (sizeY - 1) / 2, worldLocation.getPlane());
        WorldPoint northEast = new WorldPoint(worldLocation.getX() + sizeX / 2, worldLocation.getY() + sizeY / 2, worldLocation.getPlane());

        // calculate the closest tile on the edge of the rect made from southWest to northEast
        return new WorldPoint(
            Math.min(Math.max(playerLocation.getX(), southWest.getX()), northEast.getX()),
            Math.min(Math.max(playerLocation.getY(), southWest.getY()), northEast.getY()),
            worldLocation.getPlane()
        );
    }

    public static void syncAlwaysOnTop(JDialog dialog) {
        RuneLiteConfig runeLiteConfig = WatchdogPlugin.getInstance().getInjector().getInstance(RuneLiteConfig.class);
        if (runeLiteConfig.gameAlwaysOnTop() && dialog.isAlwaysOnTopSupported()) {
            dialog.setAlwaysOnTop(true);
        }
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.Displayable;
import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter
@Setter
@Accessors(chain = true)
public class SpawnedAlert extends Alert implements RegexMatcher {
    private SpawnedDespawned spawnedDespawned = SpawnedDespawned.SPAWNED;
    private SpawnedType spawnedType = SpawnedType.ITEM;
    private String spawnedName = "";
    private boolean regexEnabled = false;
    private int distance = -1;
    private ComparableNumber.Comparator distanceComparator = ComparableNumber.Comparator.LESS_THAN_OR_EQUALS;

    @Override
    public String getPattern() {
        return this.spawnedName;
    }

    @Override
    public void setPattern(String pattern) {
        this.spawnedName = pattern;
    }

    public SpawnedAlert() {
        super("New Spawned Alert");
    }

    public SpawnedAlert(String name) {
        super(name);
        // some drops
        // enemies spawn
        // trees/ore comes back
    }

    @Getter
    @AllArgsConstructor
    public enum SpawnedDespawned implements Displayable {
        SPAWNED("Spawned", "Object has spawned"),
        DESPAWNED("Despawned", "Object has despawned"),
        ;

        public final String name;
        public final String tooltip;
    }

    @Getter
    @AllArgsConstructor
    public enum SpawnedType implements Displayable {
        DECORATIVE_OBJECT("Decorative Object", "Decorative Object"),
        GAME_OBJECT("Game Object", "Something interactable, like a Tree"),
        GROUND_OBJECT("Ground Object", "Ground Object"),
        ITEM("Item", "Bones on the ground"),
        NPC("NPC", "An NPC, like the Wise Old Man"),
        PLAYER("Player", "Another player"),
        WALL_OBJECT("Wall Object", "Wall Object"),
        ;

        public final String name;
        public final String tooltip;
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.Displayable;
import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter
@Setter
@Accessors(chain = true)
public class InventoryAlert extends Alert implements RegexMatcher {
    private InventoryAlertType inventoryAlertType = InventoryAlertType.FULL;
    private String itemName = "";
    private boolean isRegexEnabled = false;
    private InventoryMatchType inventoryMatchType = InventoryMatchType.BOTH;
    private int itemQuantity = 1;
    private ComparableNumber.Comparator quantityComparator = ComparableNumber.Comparator.GREATER_THAN_OR_EQUALS;

    @Override
    public String getPattern() {
        return this.itemName;
    }

    @Override
    public void setPattern(String pattern) {
        this.itemName = pattern;
    }

    public InventoryAlert() {
        super("New Inventory Alert");
    }

    public InventoryAlert(String name) {
        super(name);
    }

    @Getter
    @AllArgsConstructor
    public enum InventoryAlertType implements Displayable {
        EMPTY("Empty", "Triggers on an empty inventory"),
        FULL("Full", "Triggers on a full inventory"),
        ITEM("Item Count", "Triggers when an item hits a certain count"),
        ITEM_CHANGE("Item Change", "Triggers when an item is added or removed")
        ;

        private final String name;
        private final String tooltip;
    }

    @Getter
    @AllArgsConstructor
    public enum InventoryMatchType implements Displayable {
        BOTH("Both", "Matches both noted and un-noted items"),
        NOTED("Noted", "Matches only noted items"),
        UN_NOTED("Un-noted", "Matches only un-noted items")
        ;

        private final String name;
        private final String tooltip;
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import net.runelite.api.Skill;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Deprecated
public class StatDrainAlert extends Alert {
    private Skill skill = Skill.ATTACK;
    private int drainAmount = 1;

    public StatDrainAlert() {
        super("New Stat Drained Alert");
    }

    public StatDrainAlert(String name) {
        super(name);
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.PlayerChatType;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter
@Setter
@Accessors(chain = true)
public class PlayerChatAlert extends Alert implements RegexMatcher {
    private boolean regexEnabled = false;
    private String message = "";
    private PlayerChatType playerChatType = PlayerChatType.ANY;
    private boolean prependSender = false;

    @Override
    public String getPattern() {
        return this.message;
    }

    @Override
    public void setPattern(String pattern) {
        this.message = pattern;
    }

    public PlayerChatAlert() {
        super("New Player Chat Message Alert");
    }

    public PlayerChatAlert(String name) {
        super(name);
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum FlashMode {
    FLASH("Flash", "Will flash the screen over an interval"),
    SMOOTH_FLASH("Smooth Flash", "Flashes the screen over an interval smoothly"),
    SOLID("Solid", "Will be a solid overlay on the screen")
    ;

    private final String name;
    private final String tooltip;

    @Override
    public String toString() {
        return this.name;
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter
@Setter
@Accessors(chain = true)
public class OverheadTextAlert extends Alert implements RegexMatcher {
    private boolean regexEnabled = false;
    private String message = "";
    private boolean npcRegexEnabled = false;
    private String npcName = "";

    @Override
    public String getPattern() {
        return this.message;
    }

    @Override
    public void setPattern(String pattern) {
        this.message = pattern;
    }

    public OverheadTextAlert() {
        super("New Overhead Text Alert");
    }

    public OverheadTextAlert(String name) {
        super(name);
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SoundFiredAlert extends Alert {
    private int soundID = 2739;

    public SoundFiredAlert() {
        super("New Sound Fired Alert");
    }
}
package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.Displayable;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum StatChangedMode implements Displayable {
    RELATIVE("Relative", "Relative to the player's current level. Negative values will be treated as a drain, positive values as a boost"),
    ABSOLUTE("Absolute", "Absolute level"),
    ;

    private final String name;
    private final String tooltip;
}

package com.adamk33n3r.runelite.watchdog.alerts;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;

import javax.inject.Inject;

@Getter
@Setter
public class LocationAlert extends Alert {
    private WorldPoint worldPoint = new WorldPoint(3223, 3219, 0);
    private int distance;
    private boolean repeat = false;
    private boolean cardinalOnly = false;
//    private boolean showTileMarker;

    @Inject
    private transient Client client;

    public LocationAlert() {
        super("New Location Alert");
    }
    public LocationAlert(String name) {
        super(name);
    }

    public boolean shouldFire(WorldPoint currentPoint) {
        if (this.worldPoint == null) {
            return false;
        }
        if (this.cardinalOnly && !this.isCardinal(currentPoint)) {
            return false;
        }
        return this.worldPoint.distanceTo(currentPoint) <= this.distance;
    }

    private boolean isCardinal(WorldPoint otherPoint) {
        return this.worldPoint.getX() == otherPoint.getX() || this.worldPoint.getY() == otherPoint.getY();
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.GameMessageType;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter
@Setter
@Accessors(chain = true)
public class ChatAlert extends Alert implements RegexMatcher {
    private String message = "";
    private boolean regexEnabled = false;
    private GameMessageType gameMessageType = GameMessageType.ANY;

    @Override
    public String getPattern() {
        return this.message;
    }

    @Override
    public void setPattern(String pattern) {
        this.message = pattern;
    }

    public ChatAlert() {
        super("New Game Message Alert");
    }

    public ChatAlert(String name) {
        super(name);
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

public interface RegexMatcher {
    boolean isRegexEnabled();
    Alert setRegexEnabled(boolean regexEnabled);
    String getPattern();
    void setPattern(String pattern);
}

package com.adamk33n3r.runelite.watchdog.alerts;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@Accessors(chain = true)
public class AlertGroup extends Alert {
    private List<Alert> alerts = new ArrayList<>();

    public AlertGroup() {
        this("New Alert Group");
    }

    public AlertGroup(String name) {
        super(name);
        // So that we don't serialize the empty array
        this.setNotifications(null);
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import net.runelite.api.Skill;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class StatChangedAlert extends Alert {
    private Skill skill = Skill.HITPOINTS;
    private int changedAmount = -5;
    private ComparableNumber.Comparator changedComparator = ComparableNumber.Comparator.LESS_THAN_OR_EQUALS;
    private StatChangedMode changedMode = StatChangedMode.RELATIVE;

    public StatChangedAlert() {
        super("New Stat Changed Alert");
    }

    public StatChangedAlert(String name) {
        super(name);
    }

    public boolean isRelative() {
        return this.changedMode == StatChangedMode.RELATIVE;
    }

    public boolean isAbsolute() {
        return this.changedMode == StatChangedMode.ABSOLUTE;
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import net.runelite.api.Skill;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class XPDropAlert extends Alert {
    private Skill skill = Skill.ATTACK;
    private int gainedAmount = 1;
    private ComparableNumber.Comparator gainedComparator = ComparableNumber.Comparator.GREATER_THAN_OR_EQUALS;

    public XPDropAlert() {
        super("New XP Drop Alert");
    }

    public XPDropAlert(String name) {
        super(name);
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import com.adamk33n3r.runelite.watchdog.TriggerType;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.notifications.MessageNotification;
import com.adamk33n3r.runelite.watchdog.notifications.Notification;

import lombok.*;
import lombok.experimental.Accessors;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Getter
@Setter
@Accessors(chain = true)
public abstract class Alert {
    private boolean enabled = true;
    private String name;
    private int debounceTime;
    private boolean randomNotifications = false;

    @Nullable
    private transient AlertGroup parent;
    public AlertGroup getParent() {
        if (this.parent == null) {
            this.parent = WatchdogPlugin.getInstance()
                .getAlertManager()
                .getAllAlertGroups()
                .filter(alertGroup -> alertGroup.getAlerts().contains(this))
                .findFirst()
                .orElse(null);
        }

        return this.parent;
    }

    @Setter(AccessLevel.PROTECTED)
    private List<Notification> notifications = new ArrayList<>();

    public Alert addNotification(Notification notification) {
        this.notifications.add(notification);
        return this;
    }

    public Alert addNotifications(Notification... notifications) {
        this.notifications.addAll(Arrays.asList(notifications));
        return this;
    }

    public Alert(String name) {
        this.name = name;
        this.debounceTime = 0;
    }

    public TriggerType getType() {
        return Arrays.stream(TriggerType.values())
            .filter(tType -> tType.getImplClass() == this.getClass())
            .findFirst()
            .orElse(null);
    }

    public void moveNotificationTo(Notification notification, int pos) {
        this.notifications.remove(notification);
        this.notifications.add(pos, notification);
    }

    public void moveNotificationToTop(Notification notification) {
        this.notifications.remove(notification);
        this.notifications.add(0, notification);
    }

    public void moveNotificationToBottom(Notification notification) {
        this.notifications.remove(notification);
        this.notifications.add(notification);
    }

    public void moveNotificationUp(Notification notification) {
        int curIdx = this.notifications.indexOf(notification);
        int newIdx = curIdx - 1;

        if (newIdx < 0) {
            return;
        }

        this.notifications.remove(notification);
        this.notifications.add(newIdx, notification);
    }

    public void moveNotificationDown(Notification notification) {
        int curIdx = this.notifications.indexOf(notification);
        int newIdx = curIdx + 1;

        if (newIdx >= this.notifications.size()) {
            return;
        }

        this.notifications.remove(notification);
        this.notifications.add(newIdx, notification);
    }

    @Nullable
    public List<AlertGroup> getAncestors() {
        if (this.getParent() == null) {
            return null;
        }

        ArrayList<AlertGroup> ancestors = new ArrayList<>();
        AlertGroup alertGroup = this.getParent();
        do {
            ancestors.add(0, alertGroup);
        } while ((alertGroup = alertGroup.getParent()) != null);

        return ancestors;
    }

    public List<String> getKeywords() {
        Stream<String> selfKeywords = Stream.of(
            this.getName(),
            this.getType().getName()
        );

        if (this instanceof AlertGroup) {
            return Stream.concat(selfKeywords, ((AlertGroup) this).getAlerts().stream().flatMap(alert -> alert.getKeywords().stream()))
                .collect(Collectors.toList());
        } else {
            return Stream.concat(
                selfKeywords,
                this.getNotifications().stream()
                    .flatMap(notification -> {
                        if (notification instanceof MessageNotification) {
                            return Stream.of(notification.getType().getName(), ((MessageNotification) notification).getMessage());
                        }
                        return Stream.of(notification.getType().getName());
                    }))
                .collect(Collectors.toList());
        }
    }
}

package com.adamk33n3r.runelite.watchdog.alerts;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter
@Setter
@Accessors(chain = true)
public class NotificationFiredAlert extends Alert implements RegexMatcher {
    private String message = "";
    private boolean regexEnabled = false;
    private boolean allowSelf = false;

    @Override
    public String getPattern() {
        return this.message;
    }

    @Override
    public void setPattern(String pattern) {
        this.message = pattern;
    }

    public NotificationFiredAlert() {
        super("New Notification Fired Alert");
    }

    public NotificationFiredAlert(String name) {
        super(name);
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.FlashMode;
import com.adamk33n3r.runelite.watchdog.notifications.ScreenFlash;

import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.time.Instant;

@Slf4j
public class FlashOverlay extends Overlay {
    @Inject
    private Client client;

    @Inject
    private ClientUI clientUI;

    @Inject
    private WatchdogConfig config;

    private Instant flashStart;
    private int gameCycleStart;
    private long mouseLastPressedMillis;

    private ScreenFlash screenFlash;

    private static final int MIN_MILLISECONDS_BEFORE_CANCELLED = 2000;

    public FlashOverlay() {
        this.setPosition(OverlayPosition.DYNAMIC);
        this.setLayer(OverlayLayer.ALWAYS_ON_TOP);
    }

    public void flash(ScreenFlash screenFlash) {
        this.screenFlash = screenFlash;
        this.flashStart = Instant.now();
        this.gameCycleStart = this.client.getGameCycle();
        this.mouseLastPressedMillis = client.getMouseLastPressedMillis();
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        // Adapted from Notifier
        if (this.flashStart == null) {
            return null;
        }

        if (this.screenFlash.getFlashDuration() == 0) {
            // Any interaction with the client since the notification started will cancel it after the minimum duration
            if (Instant.now().minusMillis(MIN_MILLISECONDS_BEFORE_CANCELLED).isAfter(this.flashStart)
                && ((client.getMouseIdleTicks() < MIN_MILLISECONDS_BEFORE_CANCELLED / Constants.CLIENT_TICK_LENGTH && this.config.mouseMovementCancels())
                || client.getKeyboardIdleTicks() < MIN_MILLISECONDS_BEFORE_CANCELLED / Constants.CLIENT_TICK_LENGTH
                || client.getMouseLastPressedMillis() > mouseLastPressedMillis) && clientUI.isFocused()
            ) {
                flashStart = null;
                return null;
            }
        } else if (Instant.now().minusSeconds(this.screenFlash.getFlashDuration()).isAfter(this.flashStart)) {
            flashStart = null;
            return null;
        }

        // Me: This can be weird depending on which game cycle the flash is fired
        if ((this.client.getGameCycle() - this.gameCycleStart) % 40 >= 20
            // For solid colour, fall through every time.
            && this.screenFlash.getFlashMode() == FlashMode.FLASH)
        {
            return null;
        }
        Color color = this.screenFlash.getColor();
        if (this.screenFlash.getFlashMode() == FlashMode.SMOOTH_FLASH) {
            color = Util.colorAlpha(color, this.getAlpha(color.getAlpha()));
        }
        graphics.setColor(color);
        graphics.fill(new Rectangle(this.client.getCanvas().getSize()));
        return null;
    }

    private int getAlpha(int maxAlpha) {
        int scaledAlpha = Util.scale((this.client.getGameCycle() - this.gameCycleStart) % 40, 0, 40, 0, maxAlpha*2);
        return scaledAlpha <= maxAlpha ? scaledAlpha : maxAlpha*2 - scaledAlpha;
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;


@RequiredArgsConstructor
@Setter
public class CenteredImageComponent implements LayoutableRenderableEntity {

    private final BufferedImage image;

    @Getter
    private final Rectangle bounds = new Rectangle();

    private Point preferredLocation = new Point();
    private Dimension preferredSize = new Dimension();

    @Override
    public Dimension render(Graphics2D graphics) {
        if (image == null) {
            return null;
        }

        graphics.drawImage(image, preferredLocation.x + preferredSize.width / 2 - this.image.getWidth() / 2, preferredLocation.y, null);
        final Dimension dimension = new Dimension(image.getWidth(), image.getHeight());
        bounds.setLocation(preferredLocation);
        bounds.setSize(dimension);
        return dimension;
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.*;
import com.adamk33n3r.runelite.watchdog.alerts.InventoryAlert.InventoryAlertType;
import com.adamk33n3r.runelite.watchdog.ui.panels.HistoryPanel;

import lombok.AllArgsConstructor;
import lombok.Builder;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.events.*;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.NotificationFired;
import net.runelite.client.events.PluginMessage;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.Text;

import lombok.extern.slf4j.Slf4j;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Provider;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import java.awt.TrayIcon;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static com.adamk33n3r.runelite.watchdog.alerts.SpawnedAlert.SpawnedDespawned.DESPAWNED;
import static com.adamk33n3r.runelite.watchdog.alerts.SpawnedAlert.SpawnedDespawned.SPAWNED;
import static com.adamk33n3r.runelite.watchdog.alerts.SpawnedAlert.SpawnedType.*;

@Slf4j
@Singleton
public class EventHandler {
    @Inject
    private Client client;

    @Inject
    private ItemManager itemManager;

    @Inject
    private AlertManager alertManager;

    @Inject
    private EventBus eventBus;

    @Inject
    private Provider<HistoryPanel> historyPanelProvider;

    @Inject
    private WatchdogPlugin plugin;

    private final Map<Alert, Instant> lastTriggered = new HashMap<>();

    private final Map<Skill, Integer> previousSkillLevelTable = new EnumMap<>(Skill.class);
    private final Map<Skill, Integer> previousSkillXPTable = new EnumMap<>(Skill.class);
    private final Map<Integer, ItemComposition> itemCompositionCache = new ConcurrentHashMap<>();
    private Map<Integer, InventoryItemData> previousItemsTable = new ConcurrentHashMap<>();
    private WorldPoint previousLocation = null;

    private boolean firedByWatchdog = false;

    public synchronized void notify(String message) {
        this.firedByWatchdog = true;
        // The event bus is synchronous
        this.eventBus.post(new NotificationFired(null, message, TrayIcon.MessageType.NONE));
        this.firedByWatchdog = false;
    }

    //region Chat Message
    @Subscribe
    public void onChatMessage(ChatMessage chatMessage) {
        // Don't process messages sent by this plugin
        if (chatMessage.getName().equals(this.plugin.getName())) {
            return;
        }

        log.debug("{} | {}: {}", chatMessage.getType().name(), chatMessage.getName(), chatMessage.getMessage());
        String unformattedMessage = Text.removeFormattingTags(chatMessage.getMessage());

        // Send player messages to a different handler
        if (PlayerChatType.ANY.isOfType(chatMessage.getType())) {
            this.alertManager.getAllEnabledAlertsOfType(PlayerChatAlert.class)
                .filter(chatAlert -> chatAlert.getPlayerChatType() == PlayerChatType.ANY || chatAlert.getPlayerChatType().isOfType(chatMessage.getType()))
                .forEach(chatAlert -> {
                    var message = unformattedMessage;
                    if (chatAlert.isPrependSender()) {
                        var playerName = Text.sanitize(Text.removeFormattingTags(chatMessage.getName()));
                        message = String.format("%s: %s", playerName, message);
                    }
                    String[] groups = this.matchPattern(chatAlert, message);
                    if (groups == null) return;

                    this.fireAlert(chatAlert, groups);
                });
            return;
        }

        this.alertManager.getAllEnabledAlertsOfType(ChatAlert.class)
            .filter(chatAlert -> chatAlert.getGameMessageType() == GameMessageType.ANY || chatAlert.getGameMessageType().isOfType(chatMessage.getType()))
            .forEach(gameAlert -> {
                String[] groups = this.matchPattern(gameAlert, unformattedMessage);
                if (groups == null) return;

                this.fireAlert(gameAlert, groups);
            });
    }
    //endregion

    //region Notification
    @Subscribe
    public void onNotificationFired(NotificationFired notificationFired) {
        this.alertManager.getAllEnabledAlertsOfType(NotificationFiredAlert.class)
            .filter(notificationFiredAlert -> !this.firedByWatchdog || notificationFiredAlert.isAllowSelf())
            .forEach(notificationFiredAlert -> {
                String[] groups = this.matchPattern(notificationFiredAlert, notificationFired.getMessage());
                if (groups == null) return;

                this.fireAlert(notificationFiredAlert, groups);
            });
    }
    //endregion

    public void onPluginMessage(PluginMessage pluginMessage) {
        if (pluginMessage.getNamespace().equals("watchdog")) {
        }
    }

    //region Stat Changed
    @Subscribe
    private void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN) {
            this.previousSkillLevelTable.clear();
            this.previousSkillXPTable.clear();
            this.previousItemsTable.clear();
        }
    }

    @Subscribe
    public void onStatChanged(StatChanged statChanged) {
//        log.debug(String.format("%s: %s/%s", statChanged.getSkill().getName(), statChanged.getBoostedLevel(), statChanged.getLevel()));
        this.handleStatChanged(statChanged);
        this.handleXPDrop(statChanged);
    }

    private void handleStatChanged(StatChanged statChanged) {
        Integer previousLevel = this.previousSkillLevelTable.put(statChanged.getSkill(), statChanged.getBoostedLevel());
        if (previousLevel == null) {
            return;
        }

        this.alertManager.getAllEnabledAlertsOfType(StatChangedAlert.class)
            .filter(alert -> {
                boolean isSkill = alert.getSkill() == statChanged.getSkill();
                if (!isSkill) {
                    return false;
                }

                int targetLevel = alert.isRelative() ? statChanged.getLevel() + alert.getChangedAmount() : alert.getChangedAmount();
                boolean currentIs = alert.getChangedComparator().compare(statChanged.getBoostedLevel(), targetLevel);
                boolean prevWasNot = alert.getChangedComparator().converse().compare(previousLevel, targetLevel);
                return currentIs && prevWasNot;
            })
            .forEach(alert -> this.fireAlert(alert, statChanged.getSkill().getName()));
    }

    private void handleXPDrop(StatChanged statChanged) {
        Integer previousXP = this.previousSkillXPTable.put(statChanged.getSkill(), statChanged.getXp());
        if (previousXP == null) {
            return;
        }

        this.alertManager.getAllEnabledAlertsOfType(XPDropAlert.class)
            .filter(alert -> {
                boolean isSkill = alert.getSkill() == statChanged.getSkill();
                int gainedXP = statChanged.getXp() - previousXP;
                return isSkill && alert.getGainedComparator().compare(gainedXP, alert.getGainedAmount());
            })
            .forEach(alert -> this.fireAlert(alert, statChanged.getSkill().getName()));
    }
    //endregion

    //region Sound Effects
    @Subscribe
    private void onSoundEffectPlayed(SoundEffectPlayed soundEffectPlayed) {
        this.handleSoundEffectPlayed(soundEffectPlayed.getSoundId());
    }

    @Subscribe
    private void onAreaSoundEffectPlayed(AreaSoundEffectPlayed areaSoundEffectPlayed) {
        this.handleSoundEffectPlayed(areaSoundEffectPlayed.getSoundId());
    }

    private void handleSoundEffectPlayed(int soundID) {
        this.alertManager.getAllEnabledAlertsOfType(SoundFiredAlert.class)
            .filter(soundFiredAlert -> soundFiredAlert.getSoundID() == soundID)
            .forEach(alert -> this.fireAlert(alert, "" + soundID));
    }
    //endregion

    //region Inventory
    @Subscribe
    private void onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
        // Ignore everything but inventory
        if (itemContainerChanged.getItemContainer().getId() != InventoryID.INV)
            return;
        Item[] items = itemContainerChanged.getItemContainer().getItems();
        Map<Integer, InventoryItemData> currentItems = new HashMap<>();
        Arrays.stream(items)
            .filter(item -> item.getId() > -1)
            .forEach(item -> {
                ItemComposition itemComposition = this.itemCompositionCache.computeIfAbsent(item.getId(), id -> this.itemManager.getItemComposition(id));
                InventoryItemData inventoryItemData = InventoryItemData.builder()
                    .itemComposition(itemComposition)
                    .quantity(item.getQuantity())
                    .build();
                currentItems.merge(item.getId(), inventoryItemData, (orig, other) -> InventoryItemData.builder()
                    .itemComposition(itemComposition)
                    .quantity(orig.quantity + other.quantity)
                    .build());
            });
        // Skip firing alerts if there are no previous items, since we just logged in. Even an empty inventory will have a map of -1 itemIds.
        if (!this.previousItemsTable.isEmpty()) {
            Map<Integer, InventoryItemData> itemMap = new HashMap<>(currentItems);
            this.previousItemsTable.forEach((itemID, data) -> itemMap.putIfAbsent(itemID, InventoryItemData.builder()
                .itemComposition(data.itemComposition)
                .build()));
            long itemCount = Arrays.stream(items).filter(item -> item.getId() > -1).count();
            this.alertManager.getAllEnabledAlertsOfType(InventoryAlert.class)
                .forEach(inventoryAlert -> {
                    InventoryAlertType alertType = inventoryAlert.getInventoryAlertType();
                    switch (alertType) {
                        case FULL:
                            if (itemCount == 28) this.fireAlert(inventoryAlert, alertType.getName());
                            break;
                        case EMPTY:
                            if (itemCount == 0) this.fireAlert(inventoryAlert, alertType.getName());
                            break;
                        case ITEM:
                        case ITEM_CHANGE:
                            Optional<MatchedItem> matchedItems = this.getMatchedItems(inventoryAlert, itemMap);
                            matchedItems.ifPresent((matched) -> {
                                int change = alertType == InventoryAlertType.ITEM ? 0 : matched.previousQuantity;
                                if (inventoryAlert.getQuantityComparator().compare(matched.currentQuantity - change, inventoryAlert.getItemQuantity())) {
                                    this.fireAlert(inventoryAlert, matchedItems.get().groups.toArray(new String[0]));
                                }
                            });
                            break;
                    }
                });
        }
        this.previousItemsTable = currentItems;
    }

    private Optional<MatchedItem> getMatchedItems(InventoryAlert inventoryAlert, Map<Integer, InventoryItemData> allItems) {
        return allItems.entrySet().stream()
            .filter(itemData -> inventoryAlert.getInventoryMatchType() == InventoryAlert.InventoryMatchType.BOTH
                || (inventoryAlert.getInventoryMatchType() == InventoryAlert.InventoryMatchType.NOTED && itemData.getValue().isNoted())
                || (inventoryAlert.getInventoryMatchType() == InventoryAlert.InventoryMatchType.UN_NOTED && !itemData.getValue().isNoted()))
            .map(itemData -> {
                String[] groups = this.matchPattern(inventoryAlert, itemData.getValue().itemComposition.getName());
                if (groups == null) return null;
                var prevItem = this.previousItemsTable.get(itemData.getKey());
                return new MatchedItem(
                    new ArrayList<>(List.of(groups)), // so that is mutable
                    prevItem == null ? 0 : prevItem.quantity,
                    itemData.getValue().quantity
                );
            })
            .filter(Objects::nonNull)
            .reduce((acc, b) -> {
                acc.groups = IntStream.range(0, Math.min(acc.groups.size(), b.groups.size()))
                    .mapToObj(i -> acc.groups.get(i) + ", " + b.groups.get(i))
                    .collect(Collectors.toList());
                acc.previousQuantity = acc.previousQuantity + b.previousQuantity;
                acc.currentQuantity = acc.currentQuantity + b.currentQuantity;
                return acc;
            });
    }
    //endregion

    //region Spawned
    @Subscribe
    private void onItemSpawned(ItemSpawned itemSpawned) {
        ItemComposition comp = this.itemManager.getItemComposition(itemSpawned.getItem().getId());
        this.onSpawned(comp.getName(), comp.getId(), itemSpawned.getTile().getWorldLocation(), SPAWNED, ITEM);
    }
    @Subscribe
    private void onItemDespawned(ItemDespawned itemDespawned) {
        ItemComposition comp = this.itemManager.getItemComposition(itemDespawned.getItem().getId());
        this.onSpawned(comp.getName(), comp.getId(), itemDespawned.getTile().getWorldLocation(), DESPAWNED, ITEM);
    }
    @Subscribe
    private void onNpcSpawned(NpcSpawned npcSpawned) {
        this.onActorSpawned(npcSpawned.getNpc(), npcSpawned.getNpc().getId(), NPC);
    }
    @Subscribe
    private void onNpcDespawned(NpcDespawned npcDespawned) {
        this.onActorDespawned(npcDespawned.getNpc(), npcDespawned.getNpc().getId(), NPC);
    }
    @Subscribe
    private void onPlayerSpawned(PlayerSpawned playerSpawned) {
        this.onActorSpawned(playerSpawned.getPlayer(), -1, PLAYER);
    }
    @Subscribe
    private void onPlayerDespawned(PlayerDespawned playerDespawned) {
        this.onActorDespawned(playerDespawned.getPlayer(), -1, PLAYER);
    }
    private void onActorSpawned(Actor actor, int id, SpawnedAlert.SpawnedType type) {
        this.onSpawned(actor.getName(), id, actor.getWorldLocation(), SPAWNED, type);
    }
    private void onActorDespawned(Actor actor, int id, SpawnedAlert.SpawnedType type) {
        this.onSpawned(actor.getName(), id, actor.getWorldLocation(), DESPAWNED, type);
    }

    @Subscribe
    private void onGroundObjectSpawned(GroundObjectSpawned groundObjectSpawned) {
        this.onTileObjectSpawned(groundObjectSpawned.getGroundObject(), SPAWNED, GROUND_OBJECT);
    }
    @Subscribe
    private void onGroundObjectDespawned(GroundObjectDespawned groundObjectDespawned) {
        this.onTileObjectSpawned(groundObjectDespawned.getGroundObject(), DESPAWNED, GROUND_OBJECT);
    }

    @Subscribe
    private void onDecorativeObjectSpawned(DecorativeObjectSpawned decorativeObjectSpawned) {
        this.onTileObjectSpawned(decorativeObjectSpawned.getDecorativeObject(), SPAWNED, DECORATIVE_OBJECT);
    }
    @Subscribe
    private void onDecorativeObjectDespawned(DecorativeObjectDespawned decorativeObjectDespawned) {
        this.onTileObjectSpawned(decorativeObjectDespawned.getDecorativeObject(), DESPAWNED, DECORATIVE_OBJECT);
    }

    @Subscribe
    private void onGameObjectSpawned(GameObjectSpawned gameObjectSpawned) {
        this.onTileObjectSpawned(gameObjectSpawned.getGameObject(), SPAWNED, GAME_OBJECT);
    }
    @Subscribe
    private void onGameObjectDespawned(GameObjectDespawned gameObjectDespawned) {
        this.onTileObjectSpawned(gameObjectDespawned.getGameObject(), DESPAWNED, GAME_OBJECT);
    }

    @Subscribe
    private void onWallObjectSpawned(WallObjectSpawned wallObjectSpawned) {
        this.onTileObjectSpawned(wallObjectSpawned.getWallObject(), SPAWNED, WALL_OBJECT);
    }
    @Subscribe
    private void onWallObjectDespawned(WallObjectDespawned wallObjectDespawned) {
        this.onTileObjectSpawned(wallObjectDespawned.getWallObject(), DESPAWNED, WALL_OBJECT);
    }

    private void onTileObjectSpawned(TileObject tileObject, SpawnedAlert.SpawnedDespawned mode, SpawnedAlert.SpawnedType type) {
        final ObjectComposition comp = this.client.getObjectDefinition(tileObject.getId());
        final ObjectComposition impostor = comp.getImpostorIds() != null ? comp.getImpostor() : comp;
        if (impostor == null) {
            return;
        }
        WorldPoint location = tileObject.getWorldLocation();
        if (tileObject instanceof GameObject) {
            WorldPoint playerLocation = this.client.getLocalPlayer().getWorldLocation();
            location = Util.getClosestTile(playerLocation, (GameObject) tileObject);
        }
        this.onSpawned(impostor.getName(), impostor.getId(), location, mode, type);
    }

    private void onSpawned(@Nullable String name, int id, WorldPoint location, SpawnedAlert.SpawnedDespawned mode, SpawnedAlert.SpawnedType type) {
        if (name == null) {
            return;
        }
        String unformattedName = Text.removeFormattingTags(name);
        int distanceToObject = location.distanceTo(this.client.getLocalPlayer().getWorldLocation());
        this.alertManager.getAllEnabledAlertsOfType(SpawnedAlert.class)
            .filter(spawnedAlert -> spawnedAlert.getSpawnedDespawned() == mode)
            .filter(spawnedAlert -> spawnedAlert.getSpawnedType() == type)
            .filter(spawnedAlert -> spawnedAlert.getDistance() == -1 || spawnedAlert.getDistanceComparator().compare(distanceToObject, spawnedAlert.getDistance()))
            .forEach(spawnedAlert -> {
                try {
                    int parsedID = Integer.parseInt(spawnedAlert.getPattern());
                    if (id == parsedID) {
                        this.fireAlert(spawnedAlert, new String[] { spawnedAlert.getPattern() });
                    }
                } catch (NumberFormatException ignored) {
                    String[] groups = this.matchPattern(spawnedAlert, unformattedName);
                    if (groups == null) return;

                    this.fireAlert(spawnedAlert, groups);
                }
            });
    }
    //endregion

    @Subscribe
    private void onOverheadTextChanged(OverheadTextChanged overheadTextChanged) {
        this.alertManager.getAllEnabledAlertsOfType(OverheadTextAlert.class)
            .filter(alert -> alert.getNpcName().isEmpty() || this.matchPattern(alert::getNpcName, alert::isNpcRegexEnabled, overheadTextChanged.getActor().getName()) != null)
            .forEach(alert -> {
                String[] groups = this.matchPattern(alert, overheadTextChanged.getOverheadText());
                if (groups == null) return;

                this.fireAlert(alert, groups);
            });
    }

    @Subscribe
    private void onGameTick(GameTick gameTick) {
        // Location alerts
        var world = this.client.getLocalPlayer().getWorldLocation();
        var worldView = this.client.getLocalPlayer().getWorldView();
        var localWorld = LocalPoint.fromWorld(worldView, world);
        // Should never be null
        if (localWorld == null) {
            return;
        }
        var worldLocation = WorldPoint.fromLocalInstance(this.client, localWorld);
//        log.debug("local: {} | world: {} | localWorld: {} | newWorld: {} - {}", this.client.getLocalPlayer().getLocalLocation(), world, localWorld, worldLocation, worldLocation.getRegionID());
        this.alertManager.getAllEnabledAlertsOfType(LocationAlert.class)
            .filter(locationAlert -> locationAlert.shouldFire(worldLocation))
            .forEach(locationAlert -> {
                // If we're not repeating, don't fire if previous location is within the area
                if (!locationAlert.isRepeat() && locationAlert.shouldFire(this.previousLocation)) {
                    return;
                }
                this.fireAlert(locationAlert, new String[] { String.valueOf(worldLocation.getX()), String.valueOf(worldLocation.getY()) });
            });
        this.previousLocation = worldLocation;
    }

    private String[] matchPattern(
        Supplier<String> pattern,
        Supplier<Boolean> regexEnabled,
        String input
    ) {
        String regex = regexEnabled.get() ? pattern.get() : Util.createRegexFromGlob(pattern.get());
        Matcher matcher = Pattern.compile(regex, regexEnabled.get() ? 0 : Pattern.CASE_INSENSITIVE).matcher(input);
        if (!matcher.find()) return null;

        String[] groups = new String[matcher.groupCount()];
        for (int i = 0; i < matcher.groupCount(); i++) {
            groups[i] = matcher.group(i+1);
        }
        return groups;
    }

    private String[] matchPattern(RegexMatcher regexMatcher, String input) {
        return this.matchPattern(regexMatcher::getPattern, regexMatcher::isRegexEnabled, input);
    }

    private void fireAlert(Alert alert, String triggerValue) {
        this.fireAlert(alert, new String[] { triggerValue });
    }

    private void fireAlert(Alert alert, String[] triggerValues) {
        // Don't fire if it is disabled
        if (!alert.isEnabled()) return;

        List<AlertGroup> ancestors = alert.getAncestors();
        // Don't fire if any of the ancestors are disabled
        if (ancestors != null && !ancestors.stream().allMatch(Alert::isEnabled)) {
            return;
        }

        Alert alertToDebounceWith = ancestors == null ? alert : Stream.concat(ancestors.stream(), Stream.of(alert))
            .filter(ancestor -> ancestor.getDebounceTime() > 0)
            .max(Comparator.comparingInt(Alert::getDebounceTime))
            .orElse(alert);

        // If the alert hasn't been fired yet, or has been enough time, set the last trigger time to now and fire.
        if (!this.lastTriggered.containsKey(alertToDebounceWith) || Instant.now().compareTo(this.lastTriggered.get(alertToDebounceWith).plusMillis(alertToDebounceWith.getDebounceTime())) >= 0) {
            SwingUtilities.invokeLater(() -> {
                this.historyPanelProvider.get().addEntry(alert, triggerValues);
            });
            this.lastTriggered.put(alertToDebounceWith, Instant.now());
            this.plugin.processAlert(alert, triggerValues, false);
        }
    }

    @AllArgsConstructor
    private static class MatchedItem {
        private List<String> groups;
        private int previousQuantity;
        private int currentQuantity;
    }

    @Builder
    private static class InventoryItemData {
        private ItemComposition itemComposition;
        private int quantity;

        public boolean isNoted() {
            return itemComposition.getNote() != -1;
        }
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Type;

@Slf4j
public class MixedCaseEnumAdapter implements JsonDeserializer<Enum> {
    @Override
    public Enum deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException {
        try {
            if (type instanceof Class && ((Class<?>) type).isEnum()) {
                return Enum.valueOf((Class<Enum>) type, jsonElement.getAsString().toUpperCase());
            }
            return null;
        } catch (Exception e) {
            log.error("Failed to deserialize enum", e);
            return null;
        }
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.*;
import com.adamk33n3r.runelite.watchdog.elevenlabs.ElevenLabs;
import com.adamk33n3r.runelite.watchdog.hub.AlertHubCategory;
import com.adamk33n3r.runelite.watchdog.notifications.*;
import com.adamk33n3r.runelite.watchdog.notifications.tts.TTSSource;
import com.adamk33n3r.runelite.watchdog.notifications.tts.Voice;
import com.adamk33n3r.runelite.watchdog.notifications.objectmarkers.ObjectMarker;
import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.FlashNotification;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import joptsimple.internal.Strings;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import java.awt.Color;
import java.lang.reflect.Type;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Stream;

@Slf4j
@Singleton
public class AlertManager {
    @Inject
    private ConfigManager configManager;
    @Inject
    private Gson clientGson;
    @Getter
    private Gson gson;

    @Inject
    private WatchdogConfig watchdogConfig;

    @Getter
    private final List<Alert> alerts = new CopyOnWriteArrayList<>();

    // TODO: Kinda weird this is in here...
    @Getter
    @Inject
    private WatchdogPanel watchdogPanel;

    @Inject
    private WatchdogPlugin plugin;

    @Inject
    @Named("watchdog.pluginVersion")
    private String pluginVersion;

    public static final Type ALERT_TYPE;
    public static final Type ALERT_LIST_TYPE;

    static {
        ALERT_TYPE = new TypeToken<Alert>() {}.getType();
        ALERT_LIST_TYPE = new TypeToken<List<Alert>>() {}.getType();
    }

    @Inject
    private void init() {
        // Add new alert types here
        final RuntimeTypeAdapterFactory<Alert> alertTypeFactory = RuntimeTypeAdapterFactory.of(Alert.class)
            .ignoreSubtype("IdleAlert")
            .ignoreSubtype("ResourceAlert")
            .recognizeSubtypes()
            .registerSubtype(ChatAlert.class)
            .registerSubtype(PlayerChatAlert.class)
            .registerSubtype(OverheadTextAlert.class)
            .registerSubtype(NotificationFiredAlert.class)
            .registerSubtype(StatDrainAlert.class)
            .registerSubtype(StatChangedAlert.class)
            .registerSubtype(XPDropAlert.class)
            .registerSubtype(SoundFiredAlert.class)
            .registerSubtype(SpawnedAlert.class)
            .registerSubtype(InventoryAlert.class)
            .registerSubtype(AlertGroup.class)
            .registerSubtype(LocationAlert.class);
        // Add new notification types here
        final RuntimeTypeAdapterFactory<Notification> notificationTypeFactory = RuntimeTypeAdapterFactory.of(Notification.class)
            .registerSubtype(TrayNotification.class)
            .registerSubtype(TextToSpeech.class)
            .registerSubtype(Sound.class)
            .registerSubtype(SoundEffect.class)
            .registerSubtype(ScreenFlash.class)
            .registerSubtype(GameMessage.class)
            .registerSubtype(Overhead.class)
            .registerSubtype(Overlay.class)
            .registerSubtype(Popup.class)
            .registerSubtype(RequestFocus.class)
            .registerSubtype(NotificationEvent.class)
            .registerSubtype(ScreenMarker.class)
            .registerSubtype(ObjectMarker.class)
            .registerSubtype(Dink.class)
            .registerSubtype(ShortestPath.class)
            .registerSubtype(PluginMessage.class)
            .registerSubtype(PluginToggle.class)
            .registerSubtype(DismissObjectMarker.class)
            .registerSubtype(DismissOverlay.class)
            .registerSubtype(DismissScreenMarker.class);
        this.gson = this.clientGson.newBuilder()
//            .serializeNulls()
            .registerTypeAdapterFactory(alertTypeFactory)
            .registerTypeAdapterFactory(notificationTypeFactory)
            .registerTypeAdapter(AlertHubCategory.class, new MixedCaseEnumAdapter())
            .create();
    }

    public void createStarterAlertsIfEmpty() {
        if (!alerts.isEmpty()) {
            return;
        }

        AlertGroup kraken = new AlertGroup("Kraken");
        kraken.setAlerts(List.of(
            new SpawnedAlert("Kraken Dies")
                .setSpawnedDespawned(SpawnedAlert.SpawnedDespawned.DESPAWNED)
                .setSpawnedType(SpawnedAlert.SpawnedType.NPC)
                .setSpawnedName("Kraken")
                .addNotifications(
                    this.plugin.getInjector().getInstance(Overhead.class)
                        .setDisplayTime(3)
                        .setTextColor(Color.CYAN)
                        .setMessage("Sit Krak"),
                    this.plugin.getInjector().getInstance(ScreenMarker.class)
                        .setDisplayTime(8)
                        .setScreenMarkerProperties("Get Fishing Explosive Ready", Color.MAGENTA, Color.BLUE, 2),
                    this.plugin.getInjector().getInstance(RequestFocus.class)
                        .setForceFocus(true)
                ),
            new SpawnedAlert("Whirlpool Appears")
                .setSpawnedDespawned(SpawnedAlert.SpawnedDespawned.DESPAWNED)
                .setSpawnedType(SpawnedAlert.SpawnedType.NPC)
                .setSpawnedName("Whirlpool")
                .setDebounceTime(15000)
                .addNotifications(
                    this.plugin.getInjector().getInstance(ScreenFlash.class)
                        .setColor(ColorUtil.fromHex("#6D0030"))
                        .setFlashMode(FlashMode.SMOOTH_FLASH)
                        .setFlashDuration(1),
                    this.plugin.getInjector().getInstance(Overhead.class)
                        .setDisplayTime(3)
                        .setTextColor(Color.GREEN)
                        .setMessage("Throw Explosive!")
                ),
            new InventoryAlert("Fishing Explosive Used")
                .setInventoryAlertType(InventoryAlert.InventoryAlertType.ITEM_CHANGE)
                .setItemName("Fishing explosive")
                .setItemQuantity(-1)
                .setQuantityComparator(ComparableNumber.Comparator.EQUALS)
                .addNotifications(
                    this.plugin.getInjector().getInstance(Overhead.class)
                        .setDisplayTime(2)
                        .setTextColor(Color.RED)
                        .setMessage("Attack!"),
                    this.plugin.getInjector().getInstance(ScreenFlash.class)
                        .setColor(ColorUtil.fromHex("#46FF00"))
                        .setFlashMode(FlashMode.FLASH)
                        .setFlashDuration(2)
                )
        ));

        AlertGroup chatboxTTS = new AlertGroup("Chatbox TTS");
        chatboxTTS.setEnabled(false);
        chatboxTTS.setAlerts(List.of(
            new PlayerChatAlert("Clan Chat TTS")
                .setPlayerChatType(PlayerChatType.CLAN)
                .setMessage("{*}")
                .addNotification(
                    this.plugin.getInjector().getInstance(TextToSpeech.class)
                        .setGain(5).setRate(2)
                        .setLegacyVoice(Voice.GEORGE)
                        .setSource(TTSSource.LEGACY)
                        .setMessage("$1")
                ),
            new PlayerChatAlert("Friends Chat TTS")
                .setPlayerChatType(PlayerChatType.FRIENDS)
                .setMessage("{*}")
                .addNotification(
                    this.plugin.getInjector().getInstance(TextToSpeech.class)
                        .setGain(5).setRate(2)
                        .setLegacyVoice(Voice.GEORGE)
                        .setSource(TTSSource.LEGACY)
                        .setMessage("$1")
                ),
            new PlayerChatAlert("Guest Clan Chat TTS")
                .setPlayerChatType(PlayerChatType.GUEST_CLAN)
                .setMessage("{*}")
                .addNotification(
                    this.plugin.getInjector().getInstance(TextToSpeech.class)
                        .setGain(5).setRate(2)
                        .setLegacyVoice(Voice.GEORGE)
                        .setSource(TTSSource.LEGACY)
                        .setMessage("$1")
                ),
            new PlayerChatAlert("GIM Chat TTS")
                .setPlayerChatType(PlayerChatType.GIM)
                .setMessage("{*}")
                .addNotification(
                    this.plugin.getInjector().getInstance(TextToSpeech.class)
                        .setGain(5).setRate(2)
                        .setLegacyVoice(Voice.GEORGE)
                        .setSource(TTSSource.LEGACY)
                        .setMessage("$1")
                ),
            new PlayerChatAlert("Private Chat TTS")
                .setPlayerChatType(PlayerChatType.PRIVATE)
                .setMessage("{*}")
                .addNotification(
                    this.plugin.getInjector().getInstance(TextToSpeech.class)
                        .setGain(5).setRate(2)
                        .setLegacyVoice(Voice.GEORGE)
                        .setSource(TTSSource.LEGACY)
                        .setMessage("$1")
                ),
            new PlayerChatAlert("Public Chat TTS - ENABLE AT OWN RISK")
                .setPlayerChatType(PlayerChatType.PUBLIC)
                .setMessage("{*}")
                .addNotification(
                    this.plugin.getInjector().getInstance(TextToSpeech.class)
                        .setGain(5).setRate(2)
                        .setLegacyVoice(Voice.GEORGE)
                        .setSource(TTSSource.LEGACY)
                        .setMessage("$1")
                )
        ));

        ChatAlert cannonReload = new ChatAlert("Reload Cannon");
        cannonReload.setMessage("Your cannon has * cannon balls remaining!");
        cannonReload.setGameMessageType(GameMessageType.ANY);
        cannonReload.addNotifications(
            this.plugin.getInjector().getInstance(ScreenFlash.class)
                .setColor(ColorUtil.fromHex("#46FF00"))
                .setFlashMode(FlashMode.SMOOTH_FLASH)
                .setFlashDuration(2),
            this.plugin.getInjector().getInstance(TextToSpeech.class)
                .setGain(5)
                .setElevenLabsVoiceId("2EiwWnXFnvU5JabPnv8n")
                .setSource(TTSSource.ELEVEN_LABS)
                .setMessage("Reload!")
        );

        ChatAlert readyToHarvest = new ChatAlert("Ready to Harvest");
        readyToHarvest.setMessage("Your {*} is ready to harvest in {*}.");
        readyToHarvest.setDebounceTime(100);
        readyToHarvest.addNotification(
            this.plugin.getInjector().getInstance(TextToSpeech.class)
                .setGain(5).setRate(1)
                .setLegacyVoice(Voice.LUCAS)
                .setSource(TTSSource.LEGACY)
                .setMessage("Your $1 patch in $2 is ready to harvest!")
        );

        AlertGroup starterAlerts = new AlertGroup("Starter Alerts");
        starterAlerts.setAlerts(List.of(
            kraken,
            chatboxTTS,
            cannonReload,
            readyToHarvest
        )).setEnabled(false);

        this.addAlert(starterAlerts, false);
    }

    public Stream<Alert> getAllEnabledAlerts() {
        return this.getAllAlerts().filter(Alert::isEnabled);
    }

    public <T extends Alert> Stream<T> getAllEnabledAlertsOfType(Class<T> type) {
        return this.getAllEnabledAlerts()
            .filter(type::isInstance)
            .map(type::cast);
    }

    public Stream<Alert> getAllAlerts() {
        return this.getAllAlertsFrom(this.alerts.stream(), false);
    }

    public <T extends Alert> Stream<T> getAllAlertsOfType(Class<T> type) {
        return this.getAllAlerts()
            .filter(type::isInstance)
            .map(type::cast);
    }

    public Stream<AlertGroup> getAllAlertGroups() {
        return this.getAllAlertsFrom(this.alerts.stream(), true)
            .filter(AlertGroup.class::isInstance)
            .map(AlertGroup.class::cast);
    }

    public Stream<Alert> getAllAlertsFrom(Stream<Alert> alerts, boolean includeGroups) {
        return alerts.flatMap(alert -> {
            if (alert instanceof AlertGroup) {
                Stream<Alert> children = this.getAllAlertsFrom(((AlertGroup) alert).getAlerts().stream(), includeGroups);
                if (includeGroups) {
                    return Stream.concat(Stream.of(alert), children);
                }
                return children;
            }
            return Stream.of(alert);
        });
    }

    public <T extends Alert> T createAlert(Class<T> alertClass) {
        return this.plugin.getInjector().getInstance(alertClass);
    }

    public void addAlert(Alert alert, boolean overrideWithDefaults) {
        this.alerts.add(alert);
        this.setUpAlert(alert, overrideWithDefaults);
        this.saveAlerts();

        SwingUtilities.invokeLater(this.watchdogPanel::rebuild);
    }

    public void removeAlert(Alert alert) {
        this.removeAlert(alert, true);
    }

    public void removeAlert(Alert alert, boolean rebuildPanel) {
        AlertGroup parent = alert.getParent();
        if (parent != null) {
            parent.getAlerts().remove(alert);
        } else {
            this.alerts.remove(alert);
        }
        this.saveAlerts();

        if (rebuildPanel) {
            SwingUtilities.invokeLater(this.watchdogPanel::rebuild);
        }
    }

    public Alert cloneAlert(Alert alert) {
        String json = this.gson.toJson(alert, ALERT_TYPE);
        Alert clonedAlert = this.gson.fromJson(json, ALERT_TYPE);
        this.setUpAlert(clonedAlert, false);
        clonedAlert.setName(clonedAlert.getName() + " Clone");
        return clonedAlert;
    }

    public void moveAlertTo(Alert alert, int pos) {
        AlertGroup parent = alert.getParent();
        if (parent != null) {
            parent.getAlerts().remove(alert);
            parent.getAlerts().add(pos, alert);
        } else {
            this.alerts.remove(alert);
            this.alerts.add(pos, alert);
        }
        this.saveAlerts();
    }

    public void loadAlerts() {
        final String json = this.configManager.getConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.ALERTS);
        this.importAlerts(json, this.alerts, false, false, false);
        this.createStarterAlertsIfEmpty();
        this.handleUpgrades();
    }

    public boolean importAlerts(String json, List<Alert> alerts, boolean append, boolean checkRegex, boolean overrideWithDefaults) throws JsonSyntaxException {
        if (Strings.isNullOrEmpty(json)) {
            return false;
        }

        if (!append) {
            alerts.clear();
        }

        Supplier<Stream<Alert>> alertStream = this.tryImport(json);

        // Validate regex properties
        if (checkRegex && !alertStream.get().allMatch(alert -> {
            if (alert instanceof RegexMatcher) {
                RegexMatcher matcher = (RegexMatcher) alert;
                return PanelUtils.isPatternValid(this.watchdogPanel, matcher.getPattern(), matcher.isRegexEnabled());
            }

            return true;
        })) {
            return false;
        }

        alertStream.get().forEach(alerts::add);

        // Save immediately to save new properties
        this.saveAlerts();

        // Inject dependencies
        this.getAllAlertsFrom(alertStream.get(), false)
            .forEach(alert -> this.setUpAlert(alert, overrideWithDefaults));

        SwingUtilities.invokeLater(() -> {
            this.watchdogPanel.rebuild();
            SwingUtilities.invokeLater(this.watchdogPanel::scrollToBottom);
        });
        return true;
    }

    public void saveAlerts() {
        String json = this.gson.toJson(this.alerts, ALERT_LIST_TYPE);
        this.configManager.setConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.ALERTS, json);
    }

    public String toJSON() {
        return this.gson.toJson(this.alerts, ALERT_LIST_TYPE);
    }

    private Supplier<Stream<Alert>> tryImport(String json) throws JsonSyntaxException {
        // Single
        try {
            Alert importedAlert = this.gson.fromJson(json, ALERT_TYPE);
            return () -> Stream.of(importedAlert).filter(Objects::nonNull);
        } catch (JsonSyntaxException ignored) {
        }

        // Multiple
        List<Alert> importedAlerts = this.gson.fromJson(json, ALERT_LIST_TYPE);
        return () -> importedAlerts.stream().filter(Objects::nonNull);
    }

    private void setUpAlert(Alert alert, boolean overrideWithDefaults) {
        this.plugin.getInjector().injectMembers(alert);
        if (alert instanceof AlertGroup) {
            ((AlertGroup) alert).getAlerts().forEach(subAlert -> this.setUpAlert(subAlert, overrideWithDefaults));
        } else {
            if (alert.getNotifications() == null) {
                return;
            }
            for (INotification notification : alert.getNotifications()) {
                if (notification instanceof TextToSpeech) {
                    TextToSpeech tts = (TextToSpeech) notification;
                    if (tts.getSource() == TTSSource.ELEVEN_LABS && tts.getElevenLabsVoiceId() != null) {
                        ElevenLabs.getVoice(this.plugin.getHttpClient(), tts.getElevenLabsVoiceId(), tts::setElevenLabsVoice, log::error);
                    }
                }
                this.plugin.getInjector().injectMembers(notification);
                if (overrideWithDefaults) {
                    notification.setDefaults();
                }
                notification.setAlert(alert);
            }
        }
    }

    private void handleUpgrades() {
        Version currentVersion = new Version(this.pluginVersion);
        Version configVersion = new Version(this.configManager.getConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.PLUGIN_VERSION));
        log.debug("currentVersion: {}", currentVersion);
        log.debug("configVersion: {}", configVersion);
        if (currentVersion.compareTo(configVersion) > 0) {
            log.debug("Checking if data migration needed");
            // Changed Stat Drain to Stat Change in v2.4.0, so need to swap sign of drainAmount and move to new alert
            if (configVersion.compareTo(new Version("2.4.0")) < 0) {
                log.debug("Need to convert StatDrainAlerts to StatChangedAlerts");
                this.alerts.replaceAll(alert -> {
                    if (alert instanceof StatDrainAlert) {
                        StatDrainAlert statDrainAlert = (StatDrainAlert) alert;
                        StatChangedAlert statChangedAlert = new StatChangedAlert();
                        statChangedAlert.setName(statDrainAlert.getName());
                        statChangedAlert.setEnabled(statDrainAlert.isEnabled());
                        statChangedAlert.setDebounceTime(statDrainAlert.getDebounceTime());
                        statChangedAlert.setSkill(statDrainAlert.getSkill());
                        statChangedAlert.setChangedAmount(-statDrainAlert.getDrainAmount());
                        statChangedAlert.getNotifications().addAll(statDrainAlert.getNotifications());
                        return statChangedAlert;
                    }

                    return alert;
                });

                // Not sure why I thought it was a good idea to store the decibels in the JSON
                log.debug("Need to convert all Sound and TTS gain back to 0,10 scale.");
                this.alerts.stream()
                    .filter(alert -> !(alert instanceof AlertGroup))
                    .flatMap(alert -> alert.getNotifications().stream())
                    .filter(notification -> notification instanceof IAudioNotification)
                    .map(notification -> (IAudioNotification) notification)
                    .forEach(sound -> sound.setGain(Util.scale(sound.getGain(), -25, 5, 0, 10)));
            }

            if (configVersion.compareTo(new Version("2.8.0")) < 0) {
                log.debug("Need to convert flash notifications to new properties");
                this.alerts.stream()
                    .filter(alert -> !(alert instanceof AlertGroup))
                    .flatMap(alert -> alert.getNotifications().stream())
                    .filter(notification -> notification instanceof ScreenFlash)
                    .map(notification -> (ScreenFlash) notification)
                    .forEach(screenFlash -> {
                        FlashNotification oldEnum = screenFlash.getFlashNotification();
                        screenFlash.setFlashMode((oldEnum == FlashNotification.SOLID_TWO_SECONDS || oldEnum == FlashNotification.SOLID_UNTIL_CANCELLED) ? FlashMode.SOLID : FlashMode.FLASH);
                        screenFlash.setFlashDuration((oldEnum == FlashNotification.FLASH_TWO_SECONDS || oldEnum == FlashNotification.SOLID_TWO_SECONDS) ? 2 : 0);
                        screenFlash.setFlashNotification(null);
                    });
            }

            if (configVersion.compareTo(new Version("2.13.0")) < 0) {
                log.debug("Need to set default overlay notification text color");
                this.alerts.stream()
                    .filter(alert -> !(alert instanceof AlertGroup))
                    .flatMap(alert -> alert.getNotifications().stream())
                    .filter(notification -> notification instanceof Overlay)
                    .map(notification -> (Overlay) notification)
                    .forEach(overlay -> {
                        if (overlay.getTextColor() == null) {
                            overlay.setTextColor(WatchdogConfig.DEFAULT_NOTIFICATION_TEXT_COLOR);
                        }
                    });
            }

            if (configVersion.compareTo(new Version("3.14.0")) < 0) {
                log.debug("Need to migrate pattern matchers from matches to find");
                this.getAllAlerts()
                    .filter(alert -> alert instanceof RegexMatcher)
                    .map(alert -> (RegexMatcher) alert)
                    .forEach(alert -> {
                        String prevPattern = alert.getPattern();
                        if (!prevPattern.isEmpty()) {
                            upgrade_3_14_0_patterns(
                                alert::getPattern,
                                alert::isRegexEnabled,
                                alert::setPattern,
                                alert::setRegexEnabled
                            );
                            log.debug("Migrating alert {} from {} to {}", ((Alert) alert).getName(), prevPattern, alert.getPattern());
                        }

                        if (alert instanceof OverheadTextAlert) {
                            var overHeadTextAlert = (OverheadTextAlert) alert;
                            if (overHeadTextAlert.getNpcName().isEmpty()) {
                                return;
                            }
                            upgrade_3_14_0_patterns(
                                overHeadTextAlert::getNpcName,
                                overHeadTextAlert::isNpcRegexEnabled,
                                overHeadTextAlert::setNpcName,
                                overHeadTextAlert::setNpcRegexEnabled
                            );
                        }
                    });
            }

            this.configManager.setConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.PLUGIN_VERSION, currentVersion.getVersion());
            this.saveAlerts();
        }
    }

    private void upgrade_3_14_0_patterns(
        Supplier<String> patternSupplier,
        Supplier<Boolean> regexEnabledSupplier,
        Consumer<String> patternSave,
        Consumer<Boolean> regexEnabledSave
    ) {
        String pattern = patternSupplier.get();
        // If the pattern is not a regex, and it doesn't start with * or end with *
        // then convert it to a regex and proceed with the conversion
        if (!regexEnabledSupplier.get()) {
            if (!pattern.startsWith("*") || !pattern.endsWith("*")) {
                pattern = Util.createRegexFromGlob(pattern);
                regexEnabledSave.accept(true);
            } else if (pattern.length() > 1) {
                pattern = pattern.substring(1, pattern.length() - 1);
            }
        }

        if (regexEnabledSupplier.get()) {
            // if the beginning of the pattern is not a ^ then add one
            if (!pattern.startsWith("^")) {
                pattern = "^" + pattern;
            }
            // if the end of the pattern is not a $ then add one
            if (!pattern.endsWith("$")) {
                pattern = pattern + "$";
            }
        }

        patternSave.accept(pattern);
    };
}

package com.adamk33n3r.runelite.watchdog;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

import java.io.File;

@Getter
@RequiredArgsConstructor
public class SoundItem {
    private final File file;
    private final int gain;
    private final int repeatSeconds;
}

/*
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.adamk33n3r.runelite.watchdog;

import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.gson.*;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Adapts values whose runtime type may differ from their declaration type. This
 * is necessary when a field's type is not the same type that GSON should create
 * when deserializing that field. For example, consider these types:
 * <pre>   {@code
 *   abstract class Shape {
 *     int x;
 *     int y;
 *   }
 *   class Circle extends Shape {
 *     int radius;
 *   }
 *   class Rectangle extends Shape {
 *     int width;
 *     int height;
 *   }
 *   class Diamond extends Shape {
 *     int width;
 *     int height;
 *   }
 *   class Drawing {
 *     Shape bottomShape;
 *     Shape topShape;
 *   }
 * }</pre>
 * <p>Without additional type information, the serialized JSON is ambiguous. Is
 * the bottom shape in this drawing a rectangle or a diamond? <pre>   {@code
 *   {
 *     "bottomShape": {
 *       "width": 10,
 *       "height": 5,
 *       "x": 0,
 *       "y": 0
 *     },
 *     "topShape": {
 *       "radius": 2,
 *       "x": 4,
 *       "y": 1
 *     }
 *   }}</pre>
 * This class addresses this problem by adding type information to the
 * serialized JSON and honoring that type information when the JSON is
 * deserialized: <pre>   {@code
 *   {
 *     "bottomShape": {
 *       "type": "Diamond",
 *       "width": 10,
 *       "height": 5,
 *       "x": 0,
 *       "y": 0
 *     },
 *     "topShape": {
 *       "type": "Circle",
 *       "radius": 2,
 *       "x": 4,
 *       "y": 1
 *     }
 *   }}</pre>
 * Both the type field name ({@code "type"}) and the type labels ({@code
 * "Rectangle"}) are configurable.
 *
 * <h2>Registering Types</h2>
 * Create a {@code RuntimeTypeAdapterFactory} by passing the base type and type field
 * name to the {@link #of} factory method. If you don't supply an explicit type
 * field name, {@code "type"} will be used. <pre>   {@code
 *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory
 *       = RuntimeTypeAdapterFactory.of(Shape.class, "type");
 * }</pre>
 * Next register all of your subtypes. Every subtype must be explicitly
 * registered. This protects your application from injection attacks. If you
 * don't supply an explicit type label, the type's simple name will be used.
 * <pre>   {@code
 *   shapeAdapterFactory.registerSubtype(Rectangle.class, "Rectangle");
 *   shapeAdapterFactory.registerSubtype(Circle.class, "Circle");
 *   shapeAdapterFactory.registerSubtype(Diamond.class, "Diamond");
 * }</pre>
 * Finally, register the type adapter factory in your application's GSON builder:
 * <pre>   {@code
 *   Gson gson = new GsonBuilder()
 *       .registerTypeAdapterFactory(shapeAdapterFactory)
 *       .create();
 * }</pre>
 * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code
 *   RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory = RuntimeTypeAdapterFactory.of(Shape.class)
 *       .registerSubtype(Rectangle.class)
 *       .registerSubtype(Circle.class)
 *       .registerSubtype(Diamond.class);
 * }</pre>
 *
 * <h2>Serialization and deserialization</h2>
 * In order to serialize and deserialize a polymorphic object,
 * you must specify the base type explicitly.
 * <pre>   {@code
 *   Diamond diamond = new Diamond();
 *   String json = gson.toJson(diamond, Shape.class);
 * }</pre>
 * And then:
 * <pre>   {@code
 *   Shape shape = gson.fromJson(json, Shape.class);
 * }</pre>
 */
public final class RuntimeTypeAdapterFactory<T> implements TypeAdapterFactory {
    private final Class<?> baseType;
    private final String typeFieldName;
    private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<>();
    private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<>();
    private final List<String> labelsToIgnore = new ArrayList<>();
    private final boolean maintainType;
    private boolean recognizeSubtypes;

    private RuntimeTypeAdapterFactory(
        Class<?> baseType, String typeFieldName, boolean maintainType) {
        if (typeFieldName == null || baseType == null) {
            throw new NullPointerException();
        }
        this.baseType = baseType;
        this.typeFieldName = typeFieldName;
        this.maintainType = maintainType;
    }

    /**
     * Creates a new runtime type adapter using for {@code baseType} using {@code
     * typeFieldName} as the type field name. Type field names are case sensitive.
     *
     * @param maintainType true if the type field should be included in deserialized objects
     */
    public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName, boolean maintainType) {
        return new RuntimeTypeAdapterFactory<>(baseType, typeFieldName, maintainType);
    }

    /**
     * Creates a new runtime type adapter using for {@code baseType} using {@code
     * typeFieldName} as the type field name. Type field names are case sensitive.
     */
    public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName) {
        return new RuntimeTypeAdapterFactory<>(baseType, typeFieldName, false);
    }

    /**
     * Creates a new runtime type adapter for {@code baseType} using {@code "type"} as
     * the type field name.
     */
    public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType) {
        return new RuntimeTypeAdapterFactory<>(baseType, "type", false);
    }

    /**
     * Ensures that this factory will handle not just the given {@code baseType}, but any subtype
     * of that type.
     */
    @CanIgnoreReturnValue
    public RuntimeTypeAdapterFactory<T> recognizeSubtypes() {
        this.recognizeSubtypes = true;
        return this;
    }

    /**
     * Registers {@code type} identified by {@code label}. Labels are case
     * sensitive.
     *
     * @throws IllegalArgumentException if either {@code type} or {@code label}
     *     have already been registered on this type adapter.
     */
    @CanIgnoreReturnValue
    public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type, String label) {
        if (type == null || label == null) {
            throw new NullPointerException();
        }
        if (subtypeToLabel.containsKey(type) || labelToSubtype.containsKey(label)) {
            throw new IllegalArgumentException("types and labels must be unique");
        }
        labelToSubtype.put(label, type);
        subtypeToLabel.put(type, label);
        return this;
    }

    /**
     * Registers {@code type} identified by its {@link Class#getSimpleName simple
     * name}. Labels are case sensitive.
     *
     * @throws IllegalArgumentException if either {@code type} or its simple name
     *     have already been registered on this type adapter.
     */
    @CanIgnoreReturnValue
    public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type) {
        return registerSubtype(type, type.getSimpleName());
    }

    public RuntimeTypeAdapterFactory<T> ignoreSubtype(String label) {
        labelsToIgnore.add(label);
        return this;
    }

    @Override
    public <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {
        if (type == null) {
            return null;
        }
        Class<?> rawType = type.getRawType();
        boolean handle =
            recognizeSubtypes ? baseType.isAssignableFrom(rawType) : baseType.equals(rawType);
        if (!handle) {
            return null;
        }

        final TypeAdapter<JsonElement> jsonElementAdapter = gson.getAdapter(JsonElement.class);
        final Map<String, TypeAdapter<?>> labelToDelegate = new LinkedHashMap<>();
        final Map<Class<?>, TypeAdapter<?>> subtypeToDelegate = new LinkedHashMap<>();
        for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {
            TypeAdapter<?> delegate = gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));
            labelToDelegate.put(entry.getKey(), delegate);
            subtypeToDelegate.put(entry.getValue(), delegate);
        }

        return new TypeAdapter<R>() {
            @Override public R read(JsonReader in) throws IOException {
                JsonElement jsonElement = jsonElementAdapter.read(in);
                JsonElement labelJsonElement;
                if (maintainType) {
                    labelJsonElement = jsonElement.getAsJsonObject().get(typeFieldName);
                } else {
                    labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);
                }

                if (labelJsonElement == null) {
                    throw new JsonParseException("cannot deserialize " + baseType
                        + " because it does not define a field named " + typeFieldName);
                }
                String label = labelJsonElement.getAsString();
                @SuppressWarnings("unchecked") // registration requires that subtype extends T
                TypeAdapter<R> delegate = (TypeAdapter<R>) labelToDelegate.get(label);
                if (delegate == null) {
                    if (labelsToIgnore.contains(label)) {
                        return null;
                    } else {
                        throw new JsonParseException("cannot deserialize " + baseType + " subtype named "
                            + label + "; did you forget to register a subtype?");
                    }
                }
                return delegate.fromJsonTree(jsonElement);
            }

            @Override public void write(JsonWriter out, R value) throws IOException {
                Class<?> srcType = value.getClass();
                String label = subtypeToLabel.get(srcType);
                @SuppressWarnings("unchecked") // registration requires that subtype extends T
                TypeAdapter<R> delegate = (TypeAdapter<R>) subtypeToDelegate.get(srcType);
                if (delegate == null) {
                    throw new JsonParseException("cannot serialize " + srcType.getName()
                        + "; did you forget to register a subtype?");
                }
                JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();

                if (maintainType) {
                    jsonElementAdapter.write(out, jsonObject);
                    return;
                }

                JsonObject clone = new JsonObject();

                if (jsonObject.has(typeFieldName)) {
                    throw new JsonParseException("cannot serialize " + srcType.getName()
                        + " because it already defines a field named " + typeFieldName);
                }
                clone.add(typeFieldName, new JsonPrimitive(label));

                for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {
                    clone.add(e.getKey(), e.getValue());
                }
                jsonElementAdapter.write(out, clone);
            }
        }.nullSafe();
    }
}
package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.notifications.Overlay;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.runelite.client.util.ImageUtil;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.stream.Collectors;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY;
import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;
import static org.apache.commons.lang3.time.DurationFormatUtils.formatDuration;

@Slf4j
public class NotificationOverlay extends OverlayPanel {
    @Inject
    private Client client;
    @Inject
    private ClientUI clientUI;
    @Inject
    private WatchdogConfig config;

    private final ConcurrentLinkedQueue<OverlayNotificationData> overlayNotificationQueue = new ConcurrentLinkedQueue<>();
    static final private Dimension DEFAULT_SIZE = new Dimension(250, 60);
    static final String CLEAR = "Clear All";

    private class OverlayNotificationData extends PanelComponent {
        private final Instant timeStarted;
        private final Overlay overlayNotification;
        private final String message;
        private BufferedImage image;

        public OverlayNotificationData(Overlay overlayNotification, String message) {
            this.overlayNotification = overlayNotification;
            if (overlayNotification.getImagePath() != null && !overlayNotification.getImagePath().isEmpty()) {
                try {
                    this.image = ImageIO.read(new File(overlayNotification.getImagePath()));
                    if (overlayNotification.isResizeImage()) {
                        this.image = ImageUtil.resizeImage(this.image, 128, 128, true);
                    }
                } catch(IOException e) {
                    log.error("Failed to load image", e);
                }
            }
            this.message = message;
            this.timeStarted = Instant.now();
            this.setWrap(false);
        }

        public boolean isExpired() {
            return !this.overlayNotification.isSticky() && this.timeStarted.plus(Duration.ofSeconds(this.overlayNotification.getTimeToLive())).isBefore(Instant.now());
        }

        @Override
        public Dimension render(Graphics2D graphics) {
            this.setBackgroundColor(this.overlayNotification.getColor());
            this.getChildren().clear();
            this.getChildren().add(WrappedTitleComponent.builder()
                .text(this.message)
                .color(this.overlayNotification.getTextColor())
                .preferredSize(this.getPreferredSize())
                .build());
            if (this.image != null) {
                this.getChildren().add(new CenteredImageComponent(this.image));
            }
            if (config.overlayShowTime()) {
                this.getChildren().add(WrappedTitleComponent.builder()
                    .text(formatDuration(ChronoUnit.MILLIS.between(this.timeStarted, Instant.now()), "m'm' s's' 'ago'"))
                    .color(this.overlayNotification.getTextColor())
                    .preferredSize(this.getPreferredSize())
                    .build());
            }

            return super.render(graphics);
        }
    }

    @Inject
    public NotificationOverlay(WatchdogPlugin plugin) {
        super(plugin);
        this.setPosition(OverlayPosition.TOP_LEFT);
        this.setResizable(true);
        this.setPriority(0);
        this.setClearChildren(true);
        this.setPreferredSize(DEFAULT_SIZE);

        this.panelComponent.setWrap(false);
        this.panelComponent.setBorder(new Rectangle(0, 0, 0, 0));
        this.panelComponent.setGap(new Point(0, 6));
        this.panelComponent.setBackgroundColor(new Color(0, 0, 0, 0));

        this.addMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Watchdog Notification overlay");
        this.addMenuEntry(RUNELITE_OVERLAY, CLEAR, "Watchdog Notification overlay", (me) -> this.clear());
    }

    public void add(Overlay overlayNotification, String message) {
        this.overlayNotificationQueue.add(new OverlayNotificationData(overlayNotification, message));
    }

    public void clear() {
        this.overlayNotificationQueue.clear();
    }

    public void clearById(String id) {
        List<OverlayNotificationData> stickiesToDismiss = this.overlayNotificationQueue.stream()
            .filter(notif -> notif.overlayNotification.isSticky() && Objects.equals(notif.overlayNotification.getId(), id))
            .collect(Collectors.toList());
        this.overlayNotificationQueue.removeAll(stickiesToDismiss);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        this.setLayer(this.config.overlayLayer());
        graphics.setFont(this.config.overlayFontType().getFont());

        this.panelComponent.getChildren().add(TitleComponent.builder().text("").build());
        if (this.overlayNotificationQueue.isEmpty()) {
            return super.render(graphics);
        }

        // Keep default width
        if (getPreferredSize() == null) {
            this.setPreferredSize(DEFAULT_SIZE);
        }
        this.overlayNotificationQueue.removeIf(OverlayNotificationData::isExpired);

        while (this.overlayNotificationQueue.size() > 5) {
            this.overlayNotificationQueue.poll();
        }

        this.overlayNotificationQueue.forEach(notif -> this.panelComponent.getChildren().add(notif));

        return super.render(graphics);
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.util.Text;

import com.google.common.base.MoreObjects;
import lombok.Builder;
import lombok.Getter;
import lombok.Setter;

import java.awt.*;

/**
 * Adapted from LineComponent and TitleComponent
 */
@Setter
@Builder
public class WrappedTitleComponent implements LayoutableRenderableEntity {
    @Builder.Default
    private String text = "";
    @Builder.Default
    private Color color = Color.WHITE;
    private Font font;

    @Builder.Default
    private Point preferredLocation = new Point();

    @Builder.Default
    private Dimension preferredSize = new Dimension(ComponentConstants.STANDARD_WIDTH, 0);

    @Builder.Default
    @Getter
    private Rectangle bounds = new Rectangle();

    private final int LINE_GAP = 2;
    private final int WIDTH_PADDING = 20;
    private final int HEIGHT_PADDING = 8;
    private final int TEXT_PADDING = 20;

    @Override
    public Dimension render(Graphics2D graphics) {
        final Font font = MoreObjects.firstNonNull(this.font, graphics.getFont());
        final FontMetrics fontMetrics = graphics.getFontMetrics(font);
        final int fmHeight = fontMetrics.getHeight();
        final int baseX = preferredLocation.x;
        final int baseY = preferredLocation.y + fmHeight;
        int x = baseX;
        int y = baseY;
        final int smallWidth = this.preferredSize.width;
        final int fullWidth = getLineWidth(this.text, fontMetrics);
        final TextComponent textComponent = new TextComponent();

        if (smallWidth < fullWidth) {
            final String[] splitLines = lineBreakText(this.text, smallWidth, fontMetrics);

            for (final String text : splitLines) {
                textComponent.setPosition(new Point(x + ((smallWidth - fontMetrics.stringWidth(text) + TEXT_PADDING) / 2), y + LINE_GAP));
                textComponent.setText(text);
                textComponent.setColor(this.color);
                textComponent.setFont(font);
                textComponent.render(graphics);

                y += fmHeight;
            }

            final Dimension dimension = new Dimension(this.preferredSize.width + WIDTH_PADDING, y - baseY + HEIGHT_PADDING);
            this.bounds.setLocation(preferredLocation);
            this.bounds.setSize(dimension);
            return dimension;
        }

        if (!this.text.isEmpty()) {
            textComponent.setPosition(new Point(x + ((smallWidth - fontMetrics.stringWidth(Text.removeTags(this.text)) + TEXT_PADDING) / 2), y + LINE_GAP));
            textComponent.setText(this.text);
            textComponent.setColor(this.color);
            textComponent.setFont(font);
            textComponent.render(graphics);
        }

        y += fmHeight;

        final Dimension dimension = new Dimension(this.preferredSize.width + WIDTH_PADDING, y - baseY + HEIGHT_PADDING);
        this.bounds.setLocation(this.preferredLocation);
        this.bounds.setSize(dimension);
        return dimension;
    }

    private static int getLineWidth(final String line, final FontMetrics metrics) {
        return metrics.stringWidth(Text.removeTags(line));
    }

    private static String[] lineBreakText(String text, int maxWidth, FontMetrics metrics) {
        final String[] words = text.split(" ");

        if (words.length == 0) {
            return new String[0];
        }

        final StringBuilder wrapped = new StringBuilder(words[0]);
        int spaceLeft = maxWidth - metrics.stringWidth(wrapped.toString());

        for (int i = 1; i < words.length; i++) {
            final String word = words[i];
            final int wordLen = metrics.stringWidth(word);
            final int spaceWidth = metrics.stringWidth(" ");

            if (wordLen + spaceWidth > spaceLeft) {
                wrapped.append("\n").append(word);
                spaceLeft = maxWidth - wordLen;
            } else {
                wrapped.append(" ").append(word);
                spaceLeft -= spaceWidth + wordLen;
            }
        }

        return wrapped.toString().split("\n");
    }
}

package com.adamk33n3r.runelite.watchdog;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum NotificationCategory implements Displayable {
    AUDIO("Audio", "Sound, text to speech, etc"),
    TEXT("Text", "Game message, overhead, etc"), // Game message, overhead, tray
    OVERLAY("Overlay", "Screen marker, flash, popup, etc"), // Overlay, popup, screen flash, screen marker
    ADVANCED("Advanced", "Dismissals, notification event, plugin message, etc"), // Dismissals, request focus, notification event, plugin message
    ;

    private final String name;
    private final String tooltip;
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;

import net.runelite.client.ui.MultiplexingPluginPanel;
import net.runelite.client.ui.PluginPanel;

import lombok.Getter;

public class WatchdogMuxer extends MultiplexingPluginPanel {
    @Getter
    private boolean isActive;

    public WatchdogMuxer(PluginPanel root) {
        super(root);
    }

    @Override
    protected void onAdd(PluginPanel p) {
        // TODO remove if it ever gets fixed https://github.com/runelite/runelite/issues/17712
        if (p instanceof AlertPanel) {
            ((AlertPanel<?>) p).rebuild();
        }
    }

    @Override
    public void onActivate() {
        super.onActivate();
        this.isActive = true;
    }

    @Override
    public void onDeactivate() {
        super.onDeactivate();
        this.isActive = false;
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import lombok.Getter;
import lombok.Setter;

import javax.swing.JTextField;
import javax.swing.text.Document;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.util.Map;

public class PlaceholderTextField extends JTextField {
    @Getter
    @Setter
    private String placeholder;

    private static final Map<?, ?> hints = (Map<?, ?>) Toolkit.getDefaultToolkit().getDesktopProperty("awt.font.desktophints");

    public PlaceholderTextField() {
        super();
    }

    public PlaceholderTextField(final Document pDoc, final String pText, final int pColumns) {
        super(pDoc, pText, pColumns);
    }

    public PlaceholderTextField(final String pText) {
        super(pText);
    }

    @Override
    protected void paintComponent(final Graphics pG) {
        super.paintComponent(pG);

        if (this.placeholder == null || this.placeholder.length() == 0 || this.getText().length() > 0) {
            return;
        }

        final Graphics2D g = (Graphics2D) pG;
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setColor(this.getDisabledTextColor());
        g.drawString(this.placeholder, this.getInsets().left, g.getFontMetrics().getMaxAscent() + this.getInsets().top);
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import com.google.common.base.Strings;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

/**
 * This component is a JTextArea with a flat design look.
 */
@Getter
public class FlatTextAreaNamespace extends FlatTextArea {
    private final PlaceholderTextArea prefixTextArea;
    private final String splitter;

    public FlatTextAreaNamespace(String firstPlaceholder, String splitter, String secondPlaceholder) {
        this(firstPlaceholder, splitter, secondPlaceholder, false);
    }

    public FlatTextAreaNamespace(String prefixPlaceholder, String splitter, String secondPlaceholder, boolean preventNewline) {
        super(secondPlaceholder, preventNewline);
        this.setLayout(new DynamicGridLayout(1, 3));
        this.splitter = splitter;

        this.prefixTextArea = new PlaceholderTextArea();
        this.prefixTextArea.setPlaceholder(prefixPlaceholder);
        this.prefixTextArea.setOpaque(false);
        this.prefixTextArea.setSelectedTextColor(Color.WHITE);
        this.prefixTextArea.setSelectionColor(ColorScheme.BRAND_ORANGE_TRANSPARENT);
        this.prefixTextArea.setLineWrap(true);
        this.prefixTextArea.setWrapStyleWord(true);
        this.prefixTextArea.setMargin(new Insets(4, 6, 5, 6));
//        this.prefixTextArea.setPreferredSize(new Dimension(60, 0));

        this.removeAll();
        this.add(this.prefixTextArea);

        this.prefixTextArea.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent mouseEvent) {
                if (blocked) {
                    return;
                }

                if (hoverBackgroundColor != null) {
                    setBackground(hoverBackgroundColor, false);
                }
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent) {
                setBackground(backgroundColor);
            }
        });

        var splitterLabel = new JLabel(":");
        splitterLabel.setMaximumSize(new Dimension(10, 0));
        this.add(splitterLabel);
        this.add(this.textArea);

        this.setUpKeymaps(preventNewline);
        this.setUpKeymaps(preventNewline, this.prefixTextArea);
    }

    public String getText() {
        if (this.prefixTextArea.getText().isEmpty() && this.textArea.getText().isEmpty()) {
            return "";
        }
        return this.prefixTextArea.getText() + this.splitter + this.textArea.getText();
    }

    public void setText(String text) {
        if (Strings.isNullOrEmpty(text)) {
            return;
        }
        String[] split = text.split(this.splitter);
        if (split.length != 2) {
            return;
        }
        this.prefixTextArea.setText(split[0]);
        this.textArea.setText(split[1]);
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Insets;

public class HorizontalRuleBorder extends EtchedBorder {
    private final int size;
    private final Border outsideBorder;
    public HorizontalRuleBorder(int size) {
        super();
        this.size = size;
        this.outsideBorder = new EmptyBorder(this.size, 0, 0, 0);
    }

    /**
     * Reinitialize the insets parameter with this Border's current Insets.
     *
     * @param c the component for which this border insets value applies
     * @param insets the object to be reinitialized
     */
    public Insets getBorderInsets(Component c, Insets insets) {
        Insets outerInsets = this.outsideBorder.getBorderInsets(c);
        insets.set(this.size + outerInsets.top, 0, 0, 0);
        return insets;
    }

    /**
     * Paints the border for the specified component with the
     * specified position and size.
     *
     * @param c the component for which this border is being painted
     * @param g the paint graphics
     * @param x the x position of the painted border
     * @param y the y position of the painted border
     * @param width the width of the painted border
     * @param height the height of the painted border
     */
    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {
        Insets  nextInsets;
        int px, py, pw, ph;

        px = x;
        py = y;
        pw = width;
        ph = height;

        outsideBorder.paintBorder(c, g, px, py, pw, ph);

        nextInsets = outsideBorder.getBorderInsets(c);
        px += nextInsets.left;
        py += nextInsets.top;
        pw = pw - nextInsets.right - nextInsets.left;
        ph = ph - nextInsets.bottom - nextInsets.top;

        g.translate(px, py);

        g.setColor(etchType == LOWERED? getShadowColor(c) : getHighlightColor(c));
        g.drawLine(0, 0, pw - 2, 0);

        g.setColor(etchType == LOWERED? getHighlightColor(c) : getShadowColor(c));
        g.drawLine(1, 1, pw-3, 1);

        g.translate(-px, -py);
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import com.adamk33n3r.runelite.watchdog.Util;
import net.runelite.client.util.Text;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.GridLayout;
import java.util.function.Consumer;
import java.util.stream.Stream;

public class MessagePickerDialog extends JDialog {
    public MessagePickerDialog(Component parent, Stream<String> messageQueue, Consumer<String> callback) {
        this.setTitle("Pick Message");
        this.setSize(500, 250);
        this.setLocationRelativeTo(parent);
        this.setModal(true);
        this.setUndecorated(true);
        Util.syncAlwaysOnTop(this);

        JPanel wrapper = new JPanel(new BorderLayout());
        wrapper.setBorder(new EmptyBorder(10, 10, 10, 10));
        this.add(wrapper);
        wrapper.add(new JLabel("Pick a message"), BorderLayout.NORTH);

        String[] messageArray = messageQueue
            .map(Text::removeFormattingTags)
            .toArray(String[]::new);
        JList<String> messageList = new JList<>(messageArray);
        messageList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        if (messageList.getModel().getSize() > 0) {
            JScrollPane scroll = new JScrollPane(messageList);
            wrapper.add(scroll, BorderLayout.CENTER);
            SwingUtilities.invokeLater(() -> {
                scroll.getVerticalScrollBar().setValue(scroll.getVerticalScrollBar().getMaximum());
            });
        } else {
            wrapper.add(new JLabel("No messages in history"));
        }

        JPanel btnGroup = new JPanel(new GridLayout(1, 0, 25, 0));
        JButton selectBtn = new JButton("Select");
        selectBtn.addActionListener((al) -> {
            callback.accept(messageList.getSelectedValue());
            this.setVisible(false);
        });
        btnGroup.add(selectBtn);
        JButton closeBtn = new JButton("Cancel");
        closeBtn.addActionListener(ev -> {
            this.setVisible(false);
        });
        btnGroup.add(closeBtn);
        wrapper.add(btnGroup, BorderLayout.SOUTH);
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import com.adamk33n3r.runelite.watchdog.Displayable;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.DynamicGridLayout;

import lombok.AllArgsConstructor;
import lombok.Getter;

import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import java.awt.Dimension;
import java.util.function.Consumer;

public class ComparableNumber extends JPanel {
    private final JComboBox<Comparator> comparator;
    private final JSpinner number;
    public ComparableNumber(
        int val, Consumer<Integer> onNumChange, int min, int max, int step,
        Comparator comparatorVal, Consumer<Comparator> onComparatorChange
    ) {
        this.comparator = PanelUtils.createSelect(Comparator.values(), comparatorVal, onComparatorChange);
        this.number = PanelUtils.createSpinner(val, min, max, step, onNumChange);

        this.setLayout(new DynamicGridLayout(1, 2, 5, 5));
        this.number.setPreferredSize(new Dimension(70, 0));
        this.add(this.comparator);
        this.add(this.number);
    }

    @Getter
    @AllArgsConstructor
    public enum Comparator implements Displayable {
        EQUALS("==", "Equals"),
        NOT_EQUALS("!=", "Not Equals"),
        LESS_THAN("<", "Less Than"),
        GREATER_THAN(">", "Greater Than"),
        LESS_THAN_OR_EQUALS("<=", "Less Than or Equals"),
        GREATER_THAN_OR_EQUALS(">=", "Greater Than or Equals"),
        ;

        private final String name;
        private final String tooltip;

        public boolean compare(int a, int b) {
            switch (this) {
                case EQUALS:
                    return a == b;
                case NOT_EQUALS:
                    return a != b;
                case LESS_THAN:
                    return a < b;
                case GREATER_THAN:
                    return a > b;
                case LESS_THAN_OR_EQUALS:
                    return a <= b;
                case GREATER_THAN_OR_EQUALS:
                    return a >= b;
                default:
                    return false;
            }
        }

        public Comparator converse() {
            switch (this) {
                case EQUALS:
                    return NOT_EQUALS;
                case NOT_EQUALS:
                    return EQUALS;
                case LESS_THAN:
                    return GREATER_THAN_OR_EQUALS;
                case GREATER_THAN:
                    return LESS_THAN_OR_EQUALS;
                case LESS_THAN_OR_EQUALS:
                    return GREATER_THAN;
                case GREATER_THAN_OR_EQUALS:
                    return LESS_THAN;
                default:
                    throw new IllegalArgumentException();
            }
        }
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import com.adamk33n3r.runelite.watchdog.AlertManager;
import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.alerts.AlertGroup;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.plugins.config.ConfigPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.MouseDragEventForwarder;
import net.runelite.client.util.ImageUtil;

import lombok.Getter;
import lombok.Setter;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.List;

public class AlertListItem extends JPanel {
    private static final ImageIcon SECTION_EXPAND_ICON;
    private static final ImageIcon SECTION_EXPAND_ICON_HOVER;
    private static final ImageIcon SECTION_RETRACT_ICON;
    private static final ImageIcon SECTION_RETRACT_ICON_HOVER;

    static {
        BufferedImage sectionRetractIcon = ImageUtil.loadImageResource(ConfigPlugin.class, "/util/arrow_right.png");
        sectionRetractIcon = ImageUtil.luminanceOffset(sectionRetractIcon, -121);
        SECTION_EXPAND_ICON = new ImageIcon(sectionRetractIcon);
        SECTION_EXPAND_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(sectionRetractIcon, -100));
        final BufferedImage sectionExpandIcon = ImageUtil.rotateImage(sectionRetractIcon, Math.PI / 2);
        SECTION_RETRACT_ICON = new ImageIcon(sectionExpandIcon);
        SECTION_RETRACT_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(sectionExpandIcon, -100));
    }

    private static final int ROW_HEIGHT = 30;
    private static final int PADDING = 2;
    private final MouseDragEventForwarder mouseDragEventForwarder;
    private final AlertManager alertManager;
    private final WatchdogPanel panel;

    private boolean collapsed = true;

    @Getter
    private final Alert alert;
    private final Runnable onChange;

    @Getter @Setter
    private boolean selected = false;
    private boolean selectMode = false;

    public AlertListItem(WatchdogPanel panel, AlertManager alertManager, Alert alert, JComponent parent, Runnable onChange) {
        this.panel = panel;
        this.alert = alert;
        this.alertManager = alertManager;
        this.onChange = onChange;
        this.setLayout(new BorderLayout(5, 0));
        this.setBorder(new EmptyBorder(PADDING, 0, PADDING, 0));
        this.setBackground(ColorScheme.DARK_GRAY_COLOR);
        this.mouseDragEventForwarder = new MouseDragEventForwarder(parent);

        this.rebuild();
    }

    public void setSelectMode(boolean selectMode) {
        this.selectMode = selectMode;
        this.rebuild();
    }

    public void rebuild() {
        this.removeAll();

        final JPanel container = new JPanel(new StretchedStackedLayout(3));
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        final JPanel topWrapper = new JPanel(new BorderLayout(3, 3));
        container.add(topWrapper);

        topWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        topWrapper.setBorder(new CompoundBorder(
            BorderFactory.createMatteBorder(0, 0, this.collapsed ? 0 : 2, 0, ColorScheme.DARK_GRAY_COLOR),
            BorderFactory.createMatteBorder(5, 10, 5, 0, ColorScheme.DARKER_GRAY_COLOR)));

        final ToggleButton toggleButton;
        if (selectMode) {
            toggleButton = new ToggleButton("Deselect", "Select");
            toggleButton.addItemListener((ev) -> this.selected = toggleButton.isSelected());
        } else {
            toggleButton = new ToggleButton();
            toggleButton.setSelected(this.alert.isEnabled());
            toggleButton.addItemListener(i -> {
                this.alert.setEnabled(toggleButton.isSelected());
                this.alertManager.saveAlerts();
            });
        }
        topWrapper.add(toggleButton, BorderLayout.WEST);

        final JPanel nameWrapper = new JPanel(new BorderLayout());
        nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        topWrapper.add(nameWrapper, BorderLayout.CENTER);

        if (this.alert instanceof AlertGroup) {
            final JButton collapseButton = PanelUtils.createActionButton(
                this.collapsed ? SECTION_EXPAND_ICON : SECTION_RETRACT_ICON,
                this.collapsed ? SECTION_EXPAND_ICON_HOVER : SECTION_RETRACT_ICON_HOVER,
                this.collapsed ? "Expand" : "Collapse",
                (btn, evt) -> {
                    this.collapsed = !this.collapsed;
                    this.rebuild();
                    this.revalidate();
                }
            );
            nameWrapper.add(collapseButton, BorderLayout.WEST);
        }

        final JLabel nameLabel = new JLabel(this.alert.getName());
        nameLabel.setToolTipText(this.alert.getName());
        nameWrapper.add(nameLabel);

        topWrapper.addMouseListener(this.mouseDragEventForwarder);
        topWrapper.addMouseMotionListener(this.mouseDragEventForwarder);
        nameWrapper.addMouseListener(this.mouseDragEventForwarder);
        nameWrapper.addMouseMotionListener(this.mouseDragEventForwarder);
        nameLabel.addMouseListener(this.mouseDragEventForwarder);
        if (alert instanceof AlertGroup) {
            nameLabel.addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    if (e.getButton() == MouseEvent.BUTTON1) {
                        collapsed = !collapsed;
                        rebuild();
                        revalidate();
                    }
                }
            });
        }
        nameLabel.addMouseMotionListener(this.mouseDragEventForwarder);

        final JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 3, 0));
        rightActions.setBorder(new EmptyBorder(4, 0, 0, 0));
        rightActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        topWrapper.add(rightActions, BorderLayout.EAST);

        rightActions.add(PanelUtils.createActionButton(Icons.EDIT, Icons.EDIT_HOVER, "Edit Alert", (btn, modifiers) -> {
            this.panel.openAlert(this.alert);
        })).setEnabled(!selectMode);

        rightActions.add(PanelUtils.createActionButton(Icons.CLONE, Icons.CLONE_HOVER, "Clone Alert", (btn, modifiers) -> {
            Alert cloned = this.alertManager.cloneAlert(this.alert);
            AlertGroup parent = this.alert.getParent();
            if (parent != null) {
                cloned.setParent(parent);
                parent.getAlerts().add(cloned);
            } else {
                this.alertManager.getAlerts().add(cloned);
            }
            this.alertManager.saveAlerts();
            this.onChange.run();
        })).setEnabled(!selectMode);

        rightActions.add(PanelUtils.createActionButton(Icons.DELETE, Icons.DELETE_HOVER, "Delete Alert", (btn, modifiers) -> {
            int result = JOptionPane.showConfirmDialog(this, "Are you sure you want to delete the " + this.alert.getName() + " alert?", "Delete?", JOptionPane.YES_NO_OPTION, JOptionPane.ERROR_MESSAGE);
            if (result == JOptionPane.YES_OPTION) {
                this.alertManager.removeAlert(this.alert);
                this.onChange.run();
            }
        })).setEnabled(!selectMode);

        if (this.alert instanceof AlertGroup && !this.collapsed) {
            final JPanel settings = new JPanel(new StretchedStackedLayout(3));
            settings.setBorder(new EmptyBorder(0, 10, 5, 10));
            settings.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            List<Alert> subAlerts = ((AlertGroup) this.alert).getAlerts();
            for (Alert subAlert : subAlerts) {
                String labelStr = String.format("%s (%s)", subAlert.getName(), subAlert.getType().getName());
                JLabel alertLabel = new JLabel(labelStr);
                alertLabel.setToolTipText(labelStr);
                settings.add(alertLabel);
            }
            if (subAlerts.isEmpty()) {
                settings.add(new JLabel("No alerts in group"));
            }
            container.add(settings);
        }

        this.add(container, BorderLayout.CENTER);
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;

import javax.swing.ImageIcon;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.Dimension;
import java.util.Objects;
import java.util.function.Consumer;

public class SearchBar extends IconTextField {
    public SearchBar(Consumer<String> onSearch) {
        super();
        this.setIcon(new ImageIcon(Objects.requireNonNull(IconTextField.class.getResource(Icon.SEARCH.getFile()))));
        this.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - PluginPanel.SCROLLBAR_WIDTH, 30));
        this.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        this.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        this.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) {
                onSearch.accept(getText());
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                onSearch.accept(getText());
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                onSearch.accept(getText());
            }
        });
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.AlertManager;
import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.alerts.AlertGroup;
import com.adamk33n3r.runelite.watchdog.ui.HorizontalRuleBorder;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertListPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;

public class AlertGroupPanel extends AlertPanel<AlertGroup> {
    public AlertGroupPanel(WatchdogPanel watchdogPanel, AlertGroup alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        AlertManager alertManager = WatchdogPlugin.getInstance().getAlertManager();
        this.addAlertDefaults();
        JPanel buttonPanel = new JPanel(new BorderLayout());
        buttonPanel.add(new JLabel("Alerts"), BorderLayout.WEST);
        buttonPanel.setBorder(new EmptyBorder(0, 5, 8, 0));

        JButton alertDropDownButton = PanelUtils.createAlertDropDownButton(createdAlert -> {
            this.alert.getAlerts().add(createdAlert);
            alertManager.saveAlerts();
            this.rebuild();
            this.watchdogPanel.openAlert(createdAlert);
        });

        buttonPanel.add(alertDropDownButton, BorderLayout.EAST);
        JPanel subGroupPanel = new JPanel(new BorderLayout());
        subGroupPanel.setBorder(new CompoundBorder(new EmptyBorder(0, 5, 0, 5), new HorizontalRuleBorder(10)));
        subGroupPanel.add(buttonPanel, BorderLayout.NORTH);

        AlertListPanel alertListPanel = new AlertListPanel(this.alert.getAlerts(), this.alert, this::rebuild);

        subGroupPanel.add(alertListPanel);
        this.addSubPanel(subGroupPanel);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.GameMessageType;
import com.adamk33n3r.runelite.watchdog.PlayerChatType;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import javax.swing.JButton;
import java.util.function.Consumer;
import java.util.function.Supplier;

public class MessagePickerButton {
    public static JButton createNotificationPickerButton(Consumer<String> callback) {
        return PanelUtils.createActionButton(Icons.PICKER, Icons.PICKER_HOVER, "Pick a recent notification", (btn, mod) -> WatchdogPlugin.getInstance().getPanel().pickNotification(callback));
    }

    public static JButton createGameMessagePickerButton(Consumer<String> callback, Supplier<GameMessageType> typeFilter) {
        return PanelUtils.createActionButton(Icons.PICKER, Icons.PICKER_HOVER, "Pick a message from chat", (btn, mod) -> WatchdogPlugin.getInstance().getPanel().pickMessage(callback, (msg) -> typeFilter.get().isOfType(msg.getType())));
    }

    public static JButton createPlayerChatPickerButton(Consumer<String> callback, Supplier<PlayerChatType> typeFilter) {
        return PanelUtils.createActionButton(Icons.PICKER, Icons.PICKER_HOVER, "Pick a message from chat", (btn, mod) -> WatchdogPlugin.getInstance().getPanel().pickMessage(callback, (msg) -> typeFilter.get().isOfType(msg.getType())));
    }

    public static JButton createOverheadTextPickerButton(Consumer<String> callback) {
        return PanelUtils.createActionButton(Icons.PICKER, Icons.PICKER_HOVER, "Pick a recent overhead text", (btn, mod) -> WatchdogPlugin.getInstance().getPanel().pickOverheadText(callback));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.WatchdogProperties;
import com.adamk33n3r.runelite.watchdog.alerts.SoundFiredAlert;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;

public class SoundFiredAlertPanel extends AlertPanel<SoundFiredAlert> {
    public SoundFiredAlertPanel(WatchdogPanel watchdogPanel, SoundFiredAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addRichTextPane("<html>Go to <a href='" + WatchdogProperties.getProperties().getProperty("watchdog.wikiPage.soundIDs") + "'>this wiki page</a> to get a list<br>of sound ids</html>")
            .addSpinner("Sound ID", "The ID of the sound", this.alert.getSoundID(), this.alert::setSoundID)
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.XPDropAlert;
import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.api.Skill;

public class XPDropAlertPanel extends AlertPanel<XPDropAlert> {
    public XPDropAlertPanel(WatchdogPanel watchdogPanel, XPDropAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addSelect("Skill", "The skill to track", Skill.class, this.alert.getSkill(), this.alert::setSkill)
            .addSubPanelControl(PanelUtils.createLabeledComponent(
                "Gained Amount",
                "How much xp needed to trigger this alert",
                new ComparableNumber(this.alert.getGainedAmount(), this.alert::setGainedAmount, 0, Integer.MAX_VALUE, 1, this.alert.getGainedComparator(), this.alert::setGainedComparator)))
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.GameMessageType;
import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.ChatAlert;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;

public class GameMessageAlertPanel extends AlertPanel<ChatAlert> {
    public GameMessageAlertPanel(WatchdogPanel watchdogPanel, ChatAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addRegexMatcher(this.alert, "Enter the message to trigger on...", "The message to trigger on. Supports glob (*)", MessagePickerButton.createGameMessagePickerButton((selected) -> {
                this.alert.setPattern(selected);
                this.rebuild();
            }, this.alert::getGameMessageType))
            .addSelect("Chat Type", "The type of message", GameMessageType.class, this.alert.getGameMessageType(), this.alert::setGameMessageType)
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.OverheadTextAlert;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;

public class OverheadTextAlertPanel extends AlertPanel<OverheadTextAlert> {
    public OverheadTextAlertPanel(WatchdogPanel watchdogPanel, OverheadTextAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addRegexMatcher(this.alert, "Enter the message to trigger on...", "The message to trigger on. Supports glob (*)", MessagePickerButton.createOverheadTextPickerButton((selected) -> {
                this.alert.setPattern(selected);
                this.rebuild();
            }))
            .addRegexMatcher(this.alert::getNpcName, this.alert::setNpcName, this.alert::isNpcRegexEnabled, this.alert::setNpcRegexEnabled, "(Optional) NPC name to filter on...", "The name to trigger on. Supports glob (*)", null)
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import javax.swing.JButton;
import javax.swing.JPanel;
import java.util.function.Consumer;

public class NotificationPickerButton extends JPanel {
    public NotificationPickerButton(Consumer<String> callback) {
        JButton picker = PanelUtils.createActionButton(Icons.PICKER, Icons.PICKER_HOVER, "Pick a recent notification", (btn, mod) -> WatchdogPlugin.getInstance().getPanel().pickNotification(callback));
        this.add(picker);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.NotificationFiredAlert;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;

public class NotificationFiredAlertPanel extends AlertPanel<NotificationFiredAlert> {
    public NotificationFiredAlertPanel(WatchdogPanel watchdogPanel, NotificationFiredAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addRegexMatcher(this.alert, "Enter the message to trigger on...", "The message to trigger on. Supports glob (*)", MessagePickerButton.createNotificationPickerButton((selected) -> {
                this.alert.setPattern(selected);
                this.rebuild();
            }))
            .addCheckbox("Allow Watchdog Notifications", "Allow Watchdog notifications to trigger this alert. Be careful with this, can easily cause an infinite loop", this.alert.isAllowSelf(), this.alert::setAllowSelf)
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.InventoryAlert;
import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

public class InventoryAlertPanel extends AlertPanel<InventoryAlert> {
    public InventoryAlertPanel(WatchdogPanel watchdogPanel, InventoryAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        boolean isItemChange = this.alert.getInventoryAlertType() == InventoryAlert.InventoryAlertType.ITEM_CHANGE;
        this.addAlertDefaults()
            .addSelect("Match", "Match on noted or un-noted", InventoryAlert.InventoryMatchType.class, this.alert.getInventoryMatchType(), this.alert::setInventoryMatchType)
            .addSelect("Type", "Type of inventory alert", InventoryAlert.InventoryAlertType.class, this.alert.getInventoryAlertType(), (val) -> {
                this.alert.setInventoryAlertType(val);
                this.rebuild();
            })
            .addIf(
                panel -> panel.addRegexMatcher(this.alert, "Enter the name of the item to trigger on...", "The name to trigger on. Supports glob (*)")
                    .addSubPanelControl(PanelUtils.createLabeledComponent(
                        isItemChange ? "Change" : "Quantity",
                        isItemChange ? "The quantity change of the item (in one tick) to trigger on. Negative for loss, positive for gain, 0 for no change" : "The quantity of item to trigger on",
                        new ComparableNumber(this.alert.getItemQuantity(), this.alert::setItemQuantity, isItemChange ? Integer.MIN_VALUE : 0, Integer.MAX_VALUE, 1, this.alert.getQuantityComparator(), this.alert::setQuantityComparator))),
                () -> this.alert.getInventoryAlertType() == InventoryAlert.InventoryAlertType.ITEM || isItemChange
            )
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.StatChangedAlert;
import com.adamk33n3r.runelite.watchdog.alerts.StatChangedMode;
import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.api.Skill;

import javax.swing.*;

public class StatChangedAlertPanel extends AlertPanel<StatChangedAlert> {
    public StatChangedAlertPanel(WatchdogPanel watchdogPanel, StatChangedAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addSelect("Skill", "The skill to track.", Skill.class, this.alert.getSkill(), this.alert::setSkill)
            .addSelect("Changed Mode", "The mode to compare the skill to the amount with.", StatChangedMode.class, this.alert.getChangedMode(), (val) -> {
                this.alert.setChangedMode(val);
                this.rebuild();
            })
            .addSubPanelControl(this.alert.getChangedMode() == StatChangedMode.RELATIVE ?
                this.createRelativeLevelPanel() :
                this.createAbsoluteLevelPanel())
            .addNotifications();
    }

    private JPanel createRelativeLevelPanel() {
        return PanelUtils.createLabeledComponent(
            "Changed Amount",
            "The difference in level to trigger the alert. Can be positive for boost and negative for drain.",
            new ComparableNumber(this.alert.getChangedAmount(), this.alert::setChangedAmount, -99, 99, 1, this.alert.getChangedComparator(), this.alert::setChangedComparator));
    }

    private JPanel createAbsoluteLevelPanel() {
        return PanelUtils.createLabeledComponent(
            "Level",
            "The level to trigger the alert.",
            new ComparableNumber(this.alert.getChangedAmount(), this.alert::setChangedAmount, 0, 99, 1, this.alert.getChangedComparator(), this.alert::setChangedComparator));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.PlayerChatType;
import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.PlayerChatAlert;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;

public class PlayerChatAlertPanel extends AlertPanel<PlayerChatAlert> {
    public PlayerChatAlertPanel(WatchdogPanel watchdogPanel, PlayerChatAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addRegexMatcher(this.alert, "Enter the message to trigger on...", "The message to trigger on. Supports glob (*)", MessagePickerButton.createPlayerChatPickerButton((selected) -> {
                this.alert.setPattern(selected);
                this.rebuild();
            }, this.alert::getPlayerChatType))
            .addCheckbox("Prepend Sender", "Prepend the sender's name to the message in the form of '{name}: {message}'", this.alert.isPrependSender(), this.alert::setPrependSender)
            .addSelect("Chat Type", "The type of message", PlayerChatType.class, this.alert.getPlayerChatType(), this.alert::setPlayerChatType)
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.LocationAlert;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;

import javax.swing.JPanel;
import java.awt.GridLayout;

public class LocationAlertPanel extends AlertPanel<LocationAlert> {
    private final Client client;

    public LocationAlertPanel(WatchdogPanel watchdogPanel, LocationAlert alert, Client client) {
        super(watchdogPanel, alert);
        this.client = client;
    }

    @Override
    protected void build() {
        JPanel pointPanel = new JPanel(new GridLayout(1, 3, 5, 5));
        JPanel xPos = PanelUtils.createLabeledComponent(
            "X Pos",
            "The X position",
            PanelUtils.createSpinner(this.alert.getWorldPoint().getX(),
                Integer.MIN_VALUE,
                Integer.MAX_VALUE,
                1,
                (val) -> this.alert.setWorldPoint(this.alert.getWorldPoint().dx(val - this.alert.getWorldPoint().getX())))
        , true);
        JPanel yPos = PanelUtils.createLabeledComponent(
            "Y Pos",
            "The Y position",
            PanelUtils.createSpinner(this.alert.getWorldPoint().getY(),
                Integer.MIN_VALUE,
                Integer.MAX_VALUE,
                1,
                (val) -> this.alert.setWorldPoint(this.alert.getWorldPoint().dy(val - this.alert.getWorldPoint().getY())))
        , true);
        JPanel plane = PanelUtils.createLabeledComponent(
            "Plane",
            "The plane number",
            PanelUtils.createSpinner(this.alert.getWorldPoint().getPlane(),
                Integer.MIN_VALUE,
                Integer.MAX_VALUE,
                1,
                (val) -> this.alert.setWorldPoint(this.alert.getWorldPoint().dz(val - this.alert.getWorldPoint().getPlane())))
            , true);
        pointPanel.add(xPos);
        pointPanel.add(yPos);
        pointPanel.add(plane);

        JPanel checkboxes = new JPanel(new GridLayout(1, 0, 5, 5));
        checkboxes.add(PanelUtils.createCheckbox("Cardinal Only", "Only fire on cardinal directions", this.alert.isCardinalOnly(), this.alert::setCardinalOnly));
        checkboxes.add(PanelUtils.createCheckbox("Repeat", "Repeat alert while standing in area", this.alert.isRepeat(), this.alert::setRepeat));

        this.addAlertDefaults()
            .addSubPanelControl(pointPanel)
            .addButton("Set to Current", "Set world point to current position", (btn, mod) -> {
                if (this.client.getLocalPlayer() != null) {
                    WorldPoint worldPoint = WorldPoint.fromLocalInstance(this.client, this.client.getLocalPlayer().getLocalLocation());
                    this.alert.setWorldPoint(worldPoint);
                    this.rebuild();
                }
            })
            .addSpinner("Distance", "Minimum distance to the set location to trigger this alert", this.alert.getDistance(), this.alert::setDistance, 0, Integer.MAX_VALUE, 1)
            .addSubPanelControl(checkboxes)
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.alerts;

import com.adamk33n3r.runelite.watchdog.WatchdogPanel;
import com.adamk33n3r.runelite.watchdog.alerts.SpawnedAlert;
import com.adamk33n3r.runelite.watchdog.ui.ComparableNumber;
import com.adamk33n3r.runelite.watchdog.ui.panels.AlertPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

public class SpawnedAlertPanel extends AlertPanel<SpawnedAlert> {
    public SpawnedAlertPanel(WatchdogPanel watchdogPanel, SpawnedAlert alert) {
        super(watchdogPanel, alert);
    }

    @Override
    protected void build() {
        this.addAlertDefaults()
            .addSelect("Spawned/Despawned", "Spawned or Despawned", SpawnedAlert.SpawnedDespawned.class, this.alert.getSpawnedDespawned(), this.alert::setSpawnedDespawned)
            .addSelect("Type", "The type of object to trigger on", SpawnedAlert.SpawnedType.class, this.alert.getSpawnedType(), this.alert::setSpawnedType)
            .addSubPanelControl(PanelUtils.createLabeledComponent(
                "Distance Limit",
                "Limit to a distance from the player. Use -1 for no limit. For objects which are larger than 1 tile, the location is the center most tile, rounded to the south-west",
                new ComparableNumber(this.alert.getDistance(), this.alert::setDistance, -1, Integer.MAX_VALUE, 1, this.alert.getDistanceComparator(), this.alert::setDistanceComparator)))
            .addRegexMatcher(this.alert, "Enter the object to trigger on...", "The name to trigger on. Supports glob (*)")
            .addNotifications();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import com.adamk33n3r.runelite.watchdog.WatchdogMuxer;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.StretchedStackedLayout;

import net.runelite.client.ui.PluginPanel;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Provider;
import javax.inject.Singleton;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Dimension;

@Slf4j
@Singleton
public class ToolsPanel extends PluginPanel {
    @Inject
    private Provider<HistoryPanel> historyPanelProvider;
    private final Provider<WatchdogMuxer> muxer;

    @Inject
    public ToolsPanel(Provider<WatchdogMuxer> muxer) {
        super(false);
        this.muxer = muxer;

        this.setLayout(new BorderLayout());

        JButton backButton = PanelUtils.createActionButton(
            Icons.BACK,
            Icons.BACK_HOVER,
            "Back",
            (btn, modifiers) -> this.muxer.get().popState()
        );
        backButton.setPreferredSize(new Dimension(22, 16));
        backButton.setBorder(new EmptyBorder(0, 0, 0, 5));

        JPanel nameGroup = new JPanel(new BorderLayout());
        this.add(nameGroup, BorderLayout.NORTH);
        nameGroup.setBorder(new EmptyBorder(10, 5, 10, 5));
        nameGroup.add(new JLabel("Tools"), BorderLayout.CENTER);
        nameGroup.add(backButton, BorderLayout.WEST);

        JPanel tools = new JPanel(new StretchedStackedLayout(3));

        tools.add(PanelUtils.createButton("Alert History", "Alert History", (btn, mods) -> {
            this.muxer.get().pushState(this.historyPanelProvider.get());
        }));

        tools.add(PanelUtils.createButton("Clear All Processing Alerts", "Clear All Processing Alerts", (btn, mods) -> {
            WatchdogPlugin.getInstance().stopAllAlerts();
        }));
        tools.add(PanelUtils.createButton("Stop All Queued Sounds", "Stop All Queued Sounds", (btn, mods) -> {
            WatchdogPlugin.getInstance().getSoundPlayer().stop();
        }));
        tools.add(PanelUtils.createButton("Dismiss All Overlays", "Dismiss All Overlays", (btn, mods) -> {
            WatchdogPlugin.getInstance().getNotificationOverlay().clear();
        }));
        tools.add(PanelUtils.createButton("Dismiss All Screen Markers", "Dismiss All Screen Markers", (btn, mods) -> {
            WatchdogPlugin.getInstance().getScreenMarkerUtil().removeAllMarkers();
        }));
        tools.add(PanelUtils.createButton("Dismiss All Object Markers", "Dismiss All Object Markers", (btn, mods) -> {
            WatchdogPlugin.getInstance().getObjectMarkerManager().removeAllMarkers();
        }));
        this.add(tools);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import com.adamk33n3r.runelite.watchdog.*;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextAreaNamespace;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.dropdownbutton.DropDownButtonFactory;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.components.ColorJButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

import org.apache.commons.text.WordUtils;

import javax.annotation.Nullable;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.filechooser.FileFilter;
import javax.swing.text.AbstractDocument;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.Arrays;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import java.util.stream.Collectors;

public class PanelUtils {
    private static final ImageIcon FOLDER;
    static {
        final BufferedImage folderImg = ImageUtil.loadImageResource(Icons.class, "mdi_folder-open.png");

        FOLDER = new ImageIcon(folderImg);
    }

    private PanelUtils () {}

    public static JPanel createLabeledComponent(String label, String tooltip, Component component) {
        return createLabeledComponent(label, tooltip, component, false);
    }

    public static JPanel createLabeledComponent(String label, String tooltip, Component component, boolean twoLines) {
        JPanel panel = new JPanel();
        if (twoLines) {
            panel.setLayout(new DynamicGridLayout(2, 0, 5, 5));
        } else {
            panel.setBorder(new EmptyBorder(0, 5, 0, 0));
            panel.setLayout(new BorderLayout(5, 0));
        }
        JLabel jLabel = new JLabel(label);
        jLabel.setToolTipText(tooltip);
        panel.add(jLabel, BorderLayout.WEST);
        panel.add(component);
        return panel;
    }

    public static JPanel createIconComponent(ImageIcon icon, String tooltip, Component component) {
        JPanel panel = new JPanel(new BorderLayout(5, 0));
        panel.setBackground(null);
        JLabel jLabel = new JLabel(icon);
        jLabel.setToolTipText(tooltip);
        panel.add(jLabel, BorderLayout.WEST);
        panel.add(component);
        return panel;
    }

    public static JPanel createFileChooser(String label, String tooltip, ActionListener actionListener, String path, String filterLabel, String... filters) {
        JPanel panel = new JPanel(new GridLayout(1, 1));
        panel.setBackground(null);
        if (label != null) {
            panel.setLayout(new GridLayout(2, 1));
            JLabel jLabel = new JLabel(label);
            jLabel.setToolTipText(tooltip);
            panel.add(jLabel);
        }
        JPanel chooserPanel = new JPanel(new BorderLayout(5, 0));
        chooserPanel.setBackground(null);
        panel.add(chooserPanel);
        JTextField pathField = new JTextField(path);
        pathField.setToolTipText(path);
        pathField.setEditable(false);
        chooserPanel.add(pathField);
        JFileChooser fileChooser = new JFileChooser(path);
        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
        fileChooser.setAcceptAllFileFilterUsed(false);
        fileChooser.setFileFilter(new FileFilter() {
            @Override
            public boolean accept(File file) {
                if (file.isDirectory()) {
                    return true;
                }
                String fileName = file.getName();
                int i = fileName.lastIndexOf('.');
                String extension = null;
                if (i > 0 &&  i < fileName.length() - 1) {
                    extension = fileName.substring(i+1).toLowerCase();
                }
                if (extension != null) {
                    return Arrays.asList(filters).contains(extension);
                }
                return false;
            }

            @Override
            public String getDescription() {
                return filterLabel + Arrays.stream(filters).map(ft -> "*." + ft).collect(Collectors.joining(", ", " (", ")"));
            }
        });
        JButton fileChooserButton = new JButton(null, FOLDER);
        fileChooserButton.setToolTipText(tooltip);
        fileChooserButton.addActionListener(e -> {
            int result = fileChooser.showOpenDialog(panel);
            if (result == JFileChooser.APPROVE_OPTION) {
                String absPath = fileChooser.getSelectedFile().getAbsolutePath();
                pathField.setText(absPath);
                pathField.setToolTipText(absPath);
                actionListener.actionPerformed(new ActionEvent(fileChooser, result, "selected"));
            }
        });
        chooserPanel.add(fileChooserButton, BorderLayout.EAST);
        return panel;
    }

    public static JButton createButton(String label, String tooltip, ButtonClickListener listener) {
        JButton button = new JButton(label);
        button.setToolTipText(tooltip);
        button.addActionListener(ev -> listener.clickPerformed(button, ev.getModifiers()));
        return button;
    }

    public static JButton createActionButton(ImageIcon icon, ImageIcon rolloverIcon, String tooltip, ButtonClickListener listener) {
        JButton actionButton = new JButton();
        SwingUtil.removeButtonDecorations(actionButton);
        actionButton.setPreferredSize(new Dimension(16, 16));
        actionButton.setIcon(icon);
        actionButton.setRolloverIcon(rolloverIcon);
        actionButton.setToolTipText(tooltip);
        actionButton.addActionListener(ev -> listener.clickPerformed(actionButton, ev.getModifiers()));
        return actionButton;
    }

    public interface ButtonClickListener {
        void clickPerformed(JButton button, int modifiers);
    }

    public interface OnRemove {
        void elementRemoved(JComponent removed);
    }

    public static JButton createToggleActionButton(ImageIcon onIcon, ImageIcon onRolloverIcon, ImageIcon offIcon, ImageIcon offRolloverIcon, String onTooltip, String offTooltip, boolean initialValue, ButtonClickListener listener) {
        JButton actionButton = createActionButton(offIcon, offRolloverIcon, offTooltip, (btn, modifiers) -> {
            btn.setSelected(!btn.isSelected());
            listener.clickPerformed(btn, modifiers);
        });
        SwingUtil.addModalTooltip(actionButton, onTooltip, offTooltip);
        actionButton.setSelectedIcon(onIcon);
        actionButton.setRolloverSelectedIcon(onRolloverIcon);
        actionButton.setSelected(initialValue);
        return actionButton;
    }

    public static JCheckBox createCheckbox(String name, String tooltip, boolean initialValue, Consumer<Boolean> onChange) {
        JCheckBox checkbox = new JCheckBox(name, initialValue);
        checkbox.setToolTipText(tooltip);
        checkbox.addItemListener(ev -> {
            onChange.accept(checkbox.isSelected());
        });
        return checkbox;
    }

    public static FlatTextAreaNamespace createTextFieldNamespace(
        String firstPlaceholder,
        String firstTooltip,
        String firstInitialValue,
        String splitter,
        String secondPlaceholder,
        String secondTooltip,
        String secondInitialValue,
        BiConsumer<String, String> onChange
    ) {
        FlatTextAreaNamespace flatTextArea = new FlatTextAreaNamespace(firstPlaceholder, splitter, secondPlaceholder, true);
        flatTextArea.getPrefixTextArea().setToolTipText(firstTooltip);
        flatTextArea.getTextArea().setToolTipText(secondTooltip);
        flatTextArea.getPrefixTextArea().setText(firstInitialValue);
        flatTextArea.getTextArea().setText(secondInitialValue);
        ((AbstractDocument) flatTextArea.getDocument()).setDocumentFilter(new LengthLimitFilter(4096));
        flatTextArea.getDocument().addDocumentListener((SimpleDocumentListener) ev -> {
            onChange.accept(flatTextArea.getPrefixTextArea().getText(), flatTextArea.getTextArea().getText());
        });
        flatTextArea.getPrefixTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                flatTextArea.getPrefixTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChange.accept(flatTextArea.getPrefixTextArea().getText(), flatTextArea.getTextArea().getText());
            }
        });
        flatTextArea.getTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                flatTextArea.getTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChange.accept(flatTextArea.getPrefixTextArea().getText(), flatTextArea.getTextArea().getText());
            }
        });
        return flatTextArea;
    }

    public static FlatTextArea createTextField(String placeholder, String tooltip, String initialValue, Consumer<String> onChange) {
        FlatTextArea flatTextArea = new FlatTextArea(placeholder, true);
        flatTextArea.setText(initialValue);
        flatTextArea.setToolTipText(tooltip);
        ((AbstractDocument) flatTextArea.getDocument()).setDocumentFilter(new LengthLimitFilter(200));
        flatTextArea.getDocument().addDocumentListener((SimpleDocumentListener) ev -> {
            onChange.accept(flatTextArea.getText());
        });
        flatTextArea.getTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                flatTextArea.getTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChange.accept(flatTextArea.getText());
            }
        });
        flatTextArea.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        return flatTextArea;
    }

    public static FlatTextArea createTextArea(String placeholder, String tooltip, String initialValue, Consumer<String> onChange) {
        FlatTextArea textArea = new FlatTextArea(placeholder, false);
        textArea.setText(initialValue);
        textArea.setToolTipText(tooltip);
//        textArea.setSelectedTextColor(Color.WHITE);
//        textArea.setSelectionColor(ColorScheme.BRAND_ORANGE_TRANSPARENT);
//        textArea.setLineWrap(true);
//        textArea.setWrapStyleWord(true);
//        textArea.setMargin(new Insets(4, 6, 5, 6));
        textArea.getTextArea().addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                textArea.getTextArea().selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                onChange.accept(textArea.getText());
            }
        });
        textArea.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        return textArea;
    }

    public static JSpinner createSpinner(int initialValue, int min, int max, int step, Consumer<Integer> onChange) {
        int value = Math.min(Math.max(min, initialValue), max);
        JSpinner spinner = new JSpinner(new SpinnerNumberModel(value, min, max, step));
        spinner.addChangeListener(e -> {
            onChange.accept((Integer) spinner.getValue());
        });
        JFormattedTextField spinnerText = (JFormattedTextField) spinner.getEditor().getComponent(0);
        spinnerText.setSelectedTextColor(Color.WHITE);
        spinnerText.setSelectionColor(ColorScheme.BRAND_ORANGE_TRANSPARENT);

        return spinner;
    }

    public static JSpinner createSpinnerDouble(double initialValue, double min, double max, double step, Consumer<Double> onChange) {
        double value = Math.min(Math.max(min, initialValue), max);
        JSpinner spinner = new JSpinner(new SpinnerNumberModel(value, min, max, step));
        JSpinner.NumberEditor editor = new JSpinner.NumberEditor(spinner, "#0.##");
        spinner.setEditor(editor);
        spinner.addChangeListener(e -> {
            onChange.accept((Double) spinner.getValue());
        });
        JFormattedTextField spinnerText = editor.getTextField();
        spinnerText.setSelectedTextColor(Color.WHITE);
        spinnerText.setSelectionColor(ColorScheme.BRAND_ORANGE_TRANSPARENT);

        return spinner;
    }

    public static ColorJButton createColorPicker(String placeholder, String tooltip, String windowTitle, Component parentComponent, Color initialValue, ColorPickerManager colorPickerManager, boolean showAlpha, Consumer<Color> onChange) {
        ColorJButton colorPickerBtn = new ColorJButton(placeholder, Color.BLACK);
        if (initialValue != null) {
            String colorHex = "#" + (showAlpha ? ColorUtil.colorToAlphaHexCode(initialValue) : ColorUtil.colorToHexCode(initialValue)).toUpperCase();
            colorPickerBtn.setText(colorHex);
            colorPickerBtn.setColor(initialValue);
        }
        colorPickerBtn.setToolTipText(tooltip);
        colorPickerBtn.setFocusable(false);
        colorPickerBtn.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getButton() == MouseEvent.BUTTON3) {
                    colorPickerBtn.setColor(Color.BLACK);
                    colorPickerBtn.setText(placeholder);
                    onChange.accept(null);
                    return;
                }
                RuneliteColorPicker colorPicker = colorPickerManager.create(
                    SwingUtilities.getWindowAncestor(colorPickerBtn),
                    colorPickerBtn.getColor(),
                    windowTitle,
                    !showAlpha);
                colorPicker.setLocation(parentComponent.getLocationOnScreen());
                colorPicker.setOnColorChange(c -> {
                    colorPickerBtn.setColor(c);
                    colorPickerBtn.setText("#" + (showAlpha ? ColorUtil.colorToAlphaHexCode(c) : ColorUtil.colorToHexCode(c)).toUpperCase());
                });
                colorPicker.setOnClose(onChange);
                colorPicker.setVisible(true);
            }
        });

        return colorPickerBtn;
    }

    public static <T extends Enum<T>> JComboBox<T> createSelect(T[] items, T initialValue, Consumer<T> onChange) {
        JComboBox<T> select = new JComboBox<>(items);
        select.setSelectedItem(initialValue);
        select.setRenderer((list, value, index, isSelected, cellHasFocus) -> {
            if (value instanceof Displayable) {
                list.setToolTipText(((Displayable) value).getTooltip());
                return new DefaultListCellRenderer().getListCellRendererComponent(list, ((Displayable) value).getName(), index, isSelected, cellHasFocus);
            }
            String titleized = value == null ? "null" : WordUtils.capitalizeFully(value.name());
            list.setToolTipText(titleized);
            return new DefaultListCellRenderer().getListCellRendererComponent(list, titleized, index, isSelected, cellHasFocus);
        });
        select.addActionListener(e -> {
            onChange.accept(select.getItemAt(select.getSelectedIndex()));
        });

        return select;
    }

    public static <T> JComboBox<T> createSelect(T[] items, T initialValue, @Nullable Function<T, String> onRender, String placeholder, Consumer<T> onChange) {
        JComboBox<T> select = new JComboBox<>(items);
        select.setSelectedItem(initialValue);
        select.setRenderer((list, value, index, isSelected, cellHasFocus) -> {
            if (onRender != null) {
                String title = value == null ? placeholder : onRender.apply(value);
                return new DefaultListCellRenderer().getListCellRendererComponent(list, title, index, isSelected, cellHasFocus);
            }

            if (value instanceof Displayable) {
                list.setToolTipText(((Displayable) value).getTooltip());
                return new DefaultListCellRenderer().getListCellRendererComponent(list, ((Displayable) value).getName(), index, isSelected, cellHasFocus);
            }
            String titleized = value == null ? "null" : WordUtils.capitalizeFully(value.toString());
            list.setToolTipText(titleized);
            return new DefaultListCellRenderer().getListCellRendererComponent(list, titleized, index, isSelected, cellHasFocus);
        });
        select.addActionListener(e -> {
            onChange.accept(select.getItemAt(select.getSelectedIndex()));
        });

        return select;
    }

    public static boolean isPatternValid(Component parent, String pattern, boolean isRegex) {
        try {
            Pattern.compile(isRegex ? pattern : Util.createRegexFromGlob(pattern));
            return true;
        } catch (PatternSyntaxException ex) {
            JLabel errorLabel = new JLabel("<html>" + ex.getMessage().replaceAll("\n", "<br/>").replaceAll(" ", "&nbsp;") + "</html>");
            errorLabel.setFont(new Font("Monospaced", Font.PLAIN, 12));
            JOptionPane.showMessageDialog(parent, errorLabel, "Error in regex/pattern", JOptionPane.ERROR_MESSAGE);
            return false;
        }
    }

    public static JButton createAlertDropDownButton(Consumer<Alert> onCreate) {
        ActionListener actionListener = e -> {
            JMenuItem menuItem = (JMenuItem) e.getSource();
            TriggerType tType = (TriggerType) menuItem.getClientProperty(TriggerType.class);
            Alert createdAlert = WatchdogPlugin.getInstance().getInjector().getInstance(tType.getImplClass());
            onCreate.accept(createdAlert);
        };

        JPopupMenu popupMenu = new JPopupMenu();
        JMenuItem alertGroupMenuItem = new JMenuItem(TriggerType.ALERT_GROUP.getName());
        alertGroupMenuItem.setToolTipText(TriggerType.ALERT_GROUP.getTooltip());
        alertGroupMenuItem.putClientProperty(TriggerType.class, TriggerType.ALERT_GROUP);
        alertGroupMenuItem.addActionListener(actionListener);
        popupMenu.add(alertGroupMenuItem);
        popupMenu.addSeparator();
        Arrays.stream(TriggerType.values())
            .filter(tType -> tType != TriggerType.ALERT_GROUP)
            .forEach(tType -> {
                JMenuItem c = new JMenuItem(tType.getName());
                c.setToolTipText(tType.getTooltip());
                c.putClientProperty(TriggerType.class, tType);
                c.addActionListener(actionListener);
                popupMenu.add(c);
            });
        JButton addDropDownButton = DropDownButtonFactory.createDropDownButton(Icons.ADD, popupMenu);
        addDropDownButton.setPreferredSize(new Dimension(40, addDropDownButton.getPreferredSize().height));
        addDropDownButton.setToolTipText("Create New Alert");
        return addDropDownButton;
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogMuxer;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.notifications.IMessageNotification;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.SearchBar;
import com.adamk33n3r.runelite.watchdog.ui.StretchedStackedLayout;

import net.runelite.client.ui.PluginPanel;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Provider;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Slf4j
@Singleton
public class HistoryPanel extends PluginPanel {
    private final Provider<WatchdogMuxer> muxer;
    private final ScrollablePanel historyItems;
    private final List<HistoryEntryPanel> previousAlerts = new ArrayList<>();
    private final JLabel noHistory;

    private static final int MAX_HISTORY_ITEMS = 100;

    @Inject
    public HistoryPanel(Provider<WatchdogMuxer> muxer) {
        super(false);
        this.muxer = muxer;

        this.setLayout(new BorderLayout());

        JPanel topPanel = new JPanel(new BorderLayout(0, 5));
        topPanel.setBorder(new EmptyBorder(0, 0, 5, 0));
        JButton backButton = PanelUtils.createActionButton(
            Icons.BACK,
            Icons.BACK_HOVER,
            "Back",
            (btn, modifiers) -> this.muxer.get().popState()
        );
        backButton.setPreferredSize(new Dimension(22, 16));
        backButton.setBorder(new EmptyBorder(0, 0, 0, 5));
        topPanel.add(backButton, BorderLayout.WEST);
        topPanel.add(new SearchBar(this::updateFilter));
        this.noHistory = new JLabel("No history items");
        this.noHistory.setHorizontalAlignment(SwingConstants.CENTER);
        topPanel.add(this.noHistory, BorderLayout.SOUTH);
        this.add(topPanel, BorderLayout.NORTH);

        this.historyItems = new ScrollablePanel(new StretchedStackedLayout(3));
        this.historyItems.setBorder(new EmptyBorder(0, 10, 0, 10));
        this.historyItems.setScrollableWidth(ScrollablePanel.ScrollableSizeHint.FIT);
        this.historyItems.setScrollableHeight(ScrollablePanel.ScrollableSizeHint.STRETCH);
        this.historyItems.setScrollableBlockIncrement(ScrollablePanel.VERTICAL, ScrollablePanel.IncrementType.PERCENT, 10);
        JScrollPane scroll = new JScrollPane(this.historyItems, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

        this.add(scroll, BorderLayout.CENTER);
    }

    public void addEntry(Alert alert, String[] triggerValues) {
        this.noHistory.setVisible(false);
        HistoryEntryPanel historyEntryPanel = new HistoryEntryPanel(alert, triggerValues);
        this.previousAlerts.add(0, historyEntryPanel);
        this.historyItems.add(historyEntryPanel, 0);
        if (this.historyItems.getComponents().length > MAX_HISTORY_ITEMS) {
            this.previousAlerts.remove(this.previousAlerts.size() - 1);
            this.historyItems.remove(this.historyItems.getComponents().length - 1);
        }
        this.revalidate();
        this.repaint();
    }

    // TODO: Abstract this out into a filterpanel type thing
    private void updateFilter(String search) {
        this.historyItems.removeAll();
        this.previousAlerts.stream().filter(historyEntryPanel -> {
            Alert alert = historyEntryPanel.getAlert();
            Stream<String> keywords = Stream.concat(Stream.of(
                alert.getName(),
                alert.getType().getName()
            ), alert.getNotifications().stream().flatMap(notification -> {
                Stream<String> notificationType = Stream.of(notification.getType().getName());
                if (notification instanceof IMessageNotification) {
                    return Stream.concat(notificationType, Stream.of(((IMessageNotification) notification).getMessage()));
                }
                return notificationType;
            }));
            return Util.searchText(search, keywords.collect(Collectors.toList()));
        }).forEach(this.historyItems::add);
        this.revalidate();
        // Idk why I need to repaint sometimes and the PluginListPanel doesn't
        this.repaint();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import com.adamk33n3r.runelite.watchdog.*;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.notifications.*;
import com.adamk33n3r.runelite.watchdog.notifications.Popup;
import com.adamk33n3r.runelite.watchdog.notifications.objectmarkers.ObjectMarker;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.StretchedStackedLayout;
import com.adamk33n3r.runelite.watchdog.ui.dropdownbutton.DropDownButtonFactory;
import com.adamk33n3r.runelite.watchdog.ui.notifications.panels.PluginMessageNotificationPanel;
import com.adamk33n3r.runelite.watchdog.ui.notifications.panels.*;

import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.components.DragAndDropReorderPane;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

import com.google.inject.Injector;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionListener;
import java.util.Arrays;
import java.util.Comparator;

@Slf4j
public class NotificationsPanel extends JPanel {
    private Alert alert;

    @Inject
    private ColorPickerManager colorPickerManager;

    @Inject
    private ConfigManager configManager;

    @Inject
    private PluginManager pluginManager;

    @Inject
    private WatchdogConfig config;

    @Inject
    private AlertManager alertManager;

    @Getter
    private final DragAndDropReorderPane notificationContainer;

    public NotificationsPanel() {
        this.setLayout(new BorderLayout(0, 5));
        this.notificationContainer = new DragAndDropReorderPane();
        this.notificationContainer.addDragListener((c) -> {
            int pos = this.notificationContainer.getPosition(c);
            NotificationPanel notificationPanel = (NotificationPanel) c;
            Notification notification = notificationPanel.getNotification();
//            log.debug("drag listener: " + notification.getType().getName() + " to " + pos);
            notification.getAlert().moveNotificationTo(notification, pos);
            this.alertManager.saveAlerts();
        });
    }

    public void init(Alert alert) {
        this.alert = alert;

        JPopupMenu popupMenu = new JPopupMenu();
        ActionListener actionListener = e -> {
            JMenuItem menuItem = (JMenuItem) e.getSource();
            NotificationType nType = (NotificationType) menuItem.getClientProperty(NotificationType.class);
            this.addPanel(this.createNotification(nType));
            this.notificationContainer.revalidate();
            this.alertManager.saveAlerts();
        };

        if (this.config.enableNotificationCategories()) {
            Arrays.stream(NotificationCategory.values()).forEach(cat -> {
                JMenu subMenu = new JMenu(cat.getName());
                subMenu.setToolTipText(cat.getTooltip());
                popupMenu.add(subMenu);
                popupMenu.putClientProperty(cat.name(), subMenu);
            });
        }
        Arrays.stream(NotificationType.values()).sorted(Comparator.comparing(NotificationType::getName)).forEach(nType -> {
            JMenuItem c = new JMenuItem(nType.getName());
            c.setToolTipText(nType.getTooltip());
            c.putClientProperty(NotificationType.class, nType);
            c.addActionListener(actionListener);
            if (this.config.enableNotificationCategories()) {
                JMenu subMenu = (JMenu) popupMenu.getClientProperty(nType.getCategory().name());
                subMenu.add(c);
            } else {
                popupMenu.add(c);
            }
        });
        JButton addDropDownButton = DropDownButtonFactory.createDropDownButton(Icons.ADD, popupMenu);
        addDropDownButton.setPreferredSize(new Dimension(40, addDropDownButton.getPreferredSize().height));
        addDropDownButton.setToolTipText("Create New Notification");
        JPanel headerPanel = new JPanel(new BorderLayout());
        JPanel leftPanel = new JPanel(new DynamicGridLayout(1, 0, 5, 5));
        headerPanel.add(leftPanel, BorderLayout.WEST);
        leftPanel.add(new JLabel("Notifications"));
        JButton randomBtn = PanelUtils.createToggleActionButton(
            Icons.DICE_MULTIPLE,
            Icons.DICE_MULTIPLE_HOVER,
            Icons.DICE_MULTIPLE_OFF,
            Icons.DICE_MULTIPLE_OFF_HOVER,
            "Fire all notifications in sequence",
            "Fire a random notification",
            alert.isRandomNotifications(),
            (btn, mods) -> {
                alert.setRandomNotifications(!alert.isRandomNotifications());
                this.alertManager.saveAlerts();
            }
        );
        leftPanel.add(randomBtn);
        JPanel buttonPanel = new JPanel(new DynamicGridLayout(1, 0));
        buttonPanel.add(addDropDownButton);
        headerPanel.add(buttonPanel, BorderLayout.EAST);
        headerPanel.setBorder(new EmptyBorder(0, 5, 0, 0));

        this.add(headerPanel, BorderLayout.NORTH);

        ScrollablePanel scrollablePanel = new ScrollablePanel(new StretchedStackedLayout(3));
        scrollablePanel.setScrollableWidth(ScrollablePanel.ScrollableSizeHint.FIT);
        scrollablePanel.setScrollableHeight(ScrollablePanel.ScrollableSizeHint.STRETCH);
        scrollablePanel.setScrollableBlockIncrement(ScrollablePanel.VERTICAL, ScrollablePanel.IncrementType.PERCENT, 10);
        scrollablePanel.add(this.notificationContainer);
        JScrollPane scrollPane = new JScrollPane(scrollablePanel, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
        this.add(scrollPane, BorderLayout.CENTER);

        for (Notification notification : this.alert.getNotifications()) {
            this.addPanel(notification);
        }
    }

    private void addPanel(Notification notification) {
        PanelUtils.OnRemove removeNotification = (removedPanel) -> {
            this.alert.getNotifications().remove(notification);
            this.notificationContainer.remove(removedPanel);
            this.notificationContainer.revalidate();
            this.alertManager.saveAlerts();
        };

        NotificationPanel notificationPanel = null;
        if (notification instanceof GameMessage) {
            notificationPanel = new MessageNotificationPanel((GameMessage) notification, true, this, this.alertManager::saveAlerts, removeNotification);
        } else if (notification instanceof TextToSpeech)
            notificationPanel = new TextToSpeechNotificationPanel((TextToSpeech) notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof Sound)
            notificationPanel = new SoundNotificationPanel((Sound)notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof SoundEffect)
            notificationPanel = new SoundEffectNotificationPanel((SoundEffect)notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof TrayNotification)
            notificationPanel = new MessageNotificationPanel((TrayNotification)notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof ScreenFlash)
            notificationPanel = new ScreenFlashNotificationPanel((ScreenFlash) notification, this, this.colorPickerManager, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof Overhead)
            notificationPanel = new OverheadNotificationPanel((Overhead) notification, this, this.colorPickerManager, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof Overlay)
            notificationPanel = new OverlayNotificationPanel((Overlay) notification, this, this.colorPickerManager, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof Popup)
            notificationPanel = new PopupNotificationPanel((Popup) notification, this, this.colorPickerManager, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof RequestFocus)
            notificationPanel = new RequestFocusNotificationPanel((RequestFocus) notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof NotificationEvent)
            notificationPanel = new MessageNotificationPanel((NotificationEvent) notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof DismissOverlay)
            notificationPanel = new DismissOverlayNotificationPanel((DismissOverlay) notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof DismissScreenMarker)
            notificationPanel = new DismissScreenMarkerNotificationPanel((DismissScreenMarker) notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof DismissObjectMarker)
            notificationPanel = new DismissObjectMarkerNotificationPanel((DismissObjectMarker) notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof ScreenMarker)
            notificationPanel = new ScreenMarkerNotificationPanel((ScreenMarker) notification, this, this.colorPickerManager, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof ObjectMarker)
            notificationPanel = new ObjectMarkerNotificationPanel((ObjectMarker) notification, this, this.colorPickerManager, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof Dink)
            notificationPanel = new DinkNotificationPanel((Dink) notification, this, this.configManager, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof ShortestPath)
            notificationPanel = new ShortestPathNotificationPanel((ShortestPath) notification, this, this.configManager, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof PluginMessage)
            notificationPanel = new PluginMessageNotificationPanel((PluginMessage) notification, this, this.alertManager::saveAlerts, removeNotification);
        else if (notification instanceof PluginToggle)
            notificationPanel = new PluginToggleNotificationPanel((PluginToggle) notification, this, this.pluginManager, this.alertManager::saveAlerts, removeNotification);

        if (notificationPanel != null)
            this.notificationContainer.add(notificationPanel);
    }

    private Notification createNotification(NotificationType notificationType) {
        Injector injector = WatchdogPlugin.getInstance().getInjector();
        Notification notification = injector.getInstance(notificationType.getImplClass());
        notification.setAlert(this.alert);
        this.alert.getNotifications().add(notification);
        return notification;
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import com.adamk33n3r.runelite.watchdog.AlertManager;
import com.adamk33n3r.runelite.watchdog.TriggerType;
import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.alerts.AlertGroup;
import com.adamk33n3r.runelite.watchdog.ui.*;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.components.DragAndDropReorderPane;

import com.google.common.base.Splitter;
import lombok.Getter;

import javax.annotation.Nullable;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class AlertListPanel extends JPanel {
    private String filterText = "";
    private static final Splitter SPLITTER = Splitter.on(" ").trimResults().omitEmptyStrings();
    private final List<AlertListItem> alertListItems = new ArrayList<>();
    private final DragAndDropReorderPane dragAndDropReorderPane = new DragAndDropReorderPane();
    @Getter
    private final JScrollPane scrollPane;
    private boolean selectMode = false;
    private final AlertManager alertManager;
    private final Runnable onChange;
    private final List<Alert> alerts;
    private final AlertGroup parent;

    public AlertListPanel(List<Alert> alerts, @Nullable AlertGroup parent, Runnable onChange) {
        this.alerts = alerts;
        this.parent = parent;
        this.onChange = onChange;
        this.alertManager = WatchdogPlugin.getInstance().getAlertManager();
        this.dragAndDropReorderPane.setBackground(ColorScheme.GRAND_EXCHANGE_LIMIT);
        this.dragAndDropReorderPane.addDragListener((c) -> {
            int pos = this.dragAndDropReorderPane.getPosition(c);
            AlertListItem alertListItem = (AlertListItem) c;
            this.alertManager.moveAlertTo(alertListItem.getAlert(), pos);
        });

        this.setLayout(new BorderLayout());

        ScrollablePanel scrollablePanel = new ScrollablePanel(new StretchedStackedLayout(3));
        scrollablePanel.setScrollableWidth(ScrollablePanel.ScrollableSizeHint.FIT);
        scrollablePanel.setScrollableHeight(ScrollablePanel.ScrollableSizeHint.STRETCH);
        scrollablePanel.setScrollableBlockIncrement(ScrollablePanel.VERTICAL, ScrollablePanel.IncrementType.PERCENT, 10);
        scrollablePanel.add(this.dragAndDropReorderPane);
        this.scrollPane = new JScrollPane(scrollablePanel, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);

        this.rebuild();
    }

    private void rebuild() {
        this.removeAll();
        this.dragAndDropReorderPane.removeAll();

        SearchBar searchBar = new SearchBar(this::filter);
        Arrays.stream(TriggerType.values()).map(TriggerType::getName).forEach(searchBar.getSuggestionListModel()::addElement);
        JPanel searchWrapper = new JPanel(new BorderLayout());
        searchWrapper.add(searchBar);
        SwingUtilities.invokeLater(() -> {
            searchWrapper.setBorder(new EmptyBorder(0, 0, 2, this.scrollPane.getVerticalScrollBar().isVisible() ? 7 : 0));
        });
        this.add(searchWrapper, BorderLayout.NORTH);
        this.add(this.scrollPane, BorderLayout.CENTER);

        final JPanel multiSelect = new JPanel(new BorderLayout());
        multiSelect.setPreferredSize(new Dimension(0, 25));
        multiSelect.setBorder(new EmptyBorder(0, 10, 0, 0));
        final JPanel toggleGroup = new JPanel(new DynamicGridLayout(1, 2, 3, 3));
        toggleGroup.setBorder(new EmptyBorder(4, 0, 0, 0));
        final ToggleButton selectModeToggle = new ToggleButton("Disable Select Mode", "Enable Select Mode");
        selectModeToggle.setSelected(this.selectMode);
        selectModeToggle.addItemListener((i) -> {
            this.selectMode = selectModeToggle.isSelected();
            // Unselect all alerts when leaving select mode
            if (!this.selectMode) {
                this.alertListItems.forEach((ali) -> ali.setSelected(false));
            }
            this.rebuild();
        });
        toggleGroup.add(selectModeToggle);
        JLabel selectModeLabel = new JLabel("Select Mode");
        selectModeLabel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                selectModeToggle.setSelected(!selectModeToggle.isSelected());
                AlertListPanel.this.revalidate();
            }
        });
        toggleGroup.add(selectModeLabel);
        multiSelect.add(toggleGroup, BorderLayout.WEST);

        final JPanel multiSelectActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 3, 0));
        multiSelectActions.setBorder(new EmptyBorder(6, 0, 0, 0));
        multiSelectActions.add(PanelUtils.createActionButton(Icons.IMPORT, Icons.IMPORT_HOVER, "Move selected Alerts to new Alert Group", (btn, modifiers) -> {
            long count = this.alertListItems.stream()
                .filter(AlertListItem::isSelected)
                .count();
            if (count == 0) {
                return;
            }
            AlertGroup group = this.alertManager.createAlert(AlertGroup.class);
            if (this.parent == null) {
                this.alertManager.addAlert(group, false);
            } else {
                this.parent.getAlerts().add(group);
            }
            this.alertListItems.stream()
                .filter(AlertListItem::isSelected)
                .forEach((ali) -> {
                    this.alertManager.removeAlert(ali.getAlert(), false);
                    group.getAlerts().add(ali.getAlert());
                });
            WatchdogPlugin.getInstance().getPanel().openAlert(group);
        })).setEnabled(this.selectMode);
        if (this.parent != null) {
            multiSelectActions.add(PanelUtils.createActionButton(Icons.BACK, Icons.BACK_HOVER, "Move selected Alerts back a level", (btn, modifiers) -> {
                long count = this.alertListItems.stream()
                    .filter(AlertListItem::isSelected)
                    .count();
                if (count == 0) {
                    return;
                }
                AlertGroup alertGroupParent = this.parent.getParent();
                this.alertListItems.stream()
                    .filter(AlertListItem::isSelected)
                    .forEach((ali) -> {
                        this.alertManager.removeAlert(ali.getAlert(), false);
                        if (alertGroupParent == null) {
                            this.alertManager.addAlert(ali.getAlert(), false);
                        } else {
                            alertGroupParent.getAlerts().add(ali.getAlert());
                        }
                    });
                WatchdogPlugin.getInstance().getPanel().getMuxer().popState();
            })).setEnabled(this.selectMode);
        }
        multiSelectActions.add(PanelUtils.createActionButton(Icons.EXPORT, Icons.EXPORT_HOVER, "Export selected Alerts", (btn, modifiers) -> {
            List<Alert> selectedAlerts = this.alertListItems.stream()
                .filter(AlertListItem::isSelected)
                .map(AlertListItem::getAlert)
                .collect(Collectors.toList());
            if (selectedAlerts.isEmpty()) {
                return;
            }
            ImportExportDialog importExportDialog = new ImportExportDialog(SwingUtilities.getWindowAncestor(this), selectedAlerts);
            importExportDialog.setVisible(true);
        })).setEnabled(this.selectMode);
        multiSelectActions.add(PanelUtils.createActionButton(Icons.DELETE, Icons.DELETE_HOVER, "Delete selected Alerts", (btn, modifiers) -> {
            long count = this.alertListItems.stream()
                .filter(AlertListItem::isSelected)
                .count();
            if (count == 0) {
                return;
            }
            int result = JOptionPane.showConfirmDialog(this, "Are you sure you want to delete the " + count + " selected alerts?", "Delete?", JOptionPane.YES_NO_OPTION, JOptionPane.ERROR_MESSAGE);
            if (result == JOptionPane.YES_OPTION) {
                this.alertListItems.stream()
                    .filter(AlertListItem::isSelected)
                    .forEach((ali) -> this.alertManager.removeAlert(ali.getAlert()));
                onChange.run();
            }
        })).setEnabled(this.selectMode);
        multiSelect.add(multiSelectActions, BorderLayout.EAST);
        searchWrapper.add(multiSelect, BorderLayout.SOUTH);

        this.alerts.stream()
            .map(alert -> new AlertListItem(WatchdogPlugin.getInstance().getPanel(), this.alertManager, alert, this.dragAndDropReorderPane, onChange))
            .forEach(alertListItem -> {
                alertListItem.setSelectMode(this.selectMode);
                this.alertListItems.add(alertListItem);
                this.dragAndDropReorderPane.add(alertListItem);
            });
    }

    private void filter(String text) {
        this.filterText = text;
        this.dragAndDropReorderPane.removeAll();
        this.alertListItems.stream()
            .filter(alertListItem -> Util.searchText(this.filterText, alertListItem.getAlert().getKeywords()))
            .forEach(this.dragAndDropReorderPane::add);
        this.revalidate();
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.notifications.MessageNotification;

import net.runelite.client.ui.DynamicGridLayout;

import lombok.Getter;

import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.border.EtchedBorder;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;

public class HistoryEntryPanel extends JPanel {
    @Getter
    private final Alert alert;

    public HistoryEntryPanel(Alert alert, String[] triggerValues) {
        super(new DynamicGridLayout(0, 1, 3, 3));
        this.alert = alert;
        this.setBorder(new EtchedBorder());

        JLabel alertType = new JLabel(alert.getType().getName());
        this.add(alertType);
        JLabel alertName = new JLabel(alert.getName());
        this.add(alertName);
        alert.getNotifications().stream()
            .filter(notification -> notification instanceof MessageNotification)
            .map(notification -> (MessageNotification) notification)
            .forEach(notification -> {
                String message = Util.processTriggerValues(notification.getMessage(), triggerValues);
                JTextArea wrappingTextArea = new JTextArea(notification.getType().getName() + ": " + message);
                wrappingTextArea.setLineWrap(true);
                wrappingTextArea.setWrapStyleWord(true);
                wrappingTextArea.setOpaque(false);
                wrappingTextArea.setEditable(false);
                wrappingTextArea.setFocusable(false);
                this.add(wrappingTextArea);
            });
        String formattedTime = DateTimeFormatter.ofPattern("HH:mm:ss").withZone(ZoneId.systemDefault()).format(Instant.now());
        this.add(new JLabel(formattedTime));
    }
}

/**
 *  A panel that implements the Scrollable interface. This class allows you
 *  to customize the scrollable features by using newly provided setter methods
 *  so you don't have to extend this class every time.
 *
 *  Scrollable amounts can be specifed as a percentage of the viewport size or
 *  as an actual pixel value. The amount can be changed for both unit and block
 *  scrolling for both horizontal and vertical scrollbars.
 *
 *  The Scrollable interface only provides a boolean value for determining whether
 *  or not the viewport size (width or height) should be used by the scrollpane
 *  when determining if scrollbars should be made visible. This class supports the
 *  concept of dynamically changing this value based on the size of the viewport.
 *  In this case the viewport size will only be used when it is larger than the
 *  panels size. This has the effect of ensuring the viewport is always full as
 *  components added to the panel will be size to fill the area available,
 *  based on the rules of the applicable layout manager of course.
 */
package com.adamk33n3r.runelite.watchdog.ui.panels;

import javax.swing.JPanel;
import javax.swing.JViewport;
import javax.swing.Scrollable;
import javax.swing.SwingConstants;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.LayoutManager;
import java.awt.Rectangle;

public class ScrollablePanel extends JPanel
    implements Scrollable, SwingConstants
{
    public enum ScrollableSizeHint
    {
        NONE,
        FIT,
        STRETCH;
    }

    public enum IncrementType
    {
        PERCENT,
        PIXELS;
    }

    private ScrollableSizeHint scrollableHeight = ScrollableSizeHint.NONE;
    private ScrollableSizeHint scrollableWidth  = ScrollableSizeHint.NONE;

    private IncrementInfo horizontalBlock;
    private IncrementInfo horizontalUnit;
    private IncrementInfo verticalBlock;
    private IncrementInfo verticalUnit;

    /**
     *  Default constructor that uses a FlowLayout
     */
    public ScrollablePanel()
    {
        this( new FlowLayout() );
    }

    /**
     *  Constuctor for specifying the LayoutManager of the panel.
     *
     *  @param layout the LayountManger for the panel
     */
    public ScrollablePanel(LayoutManager layout)
    {
        super( layout );

        IncrementInfo block = new IncrementInfo(IncrementType.PERCENT, 100);
        IncrementInfo unit = new IncrementInfo(IncrementType.PERCENT, 10);

        setScrollableBlockIncrement(HORIZONTAL, block);
        setScrollableBlockIncrement(VERTICAL, block);
        setScrollableUnitIncrement(HORIZONTAL, unit);
        setScrollableUnitIncrement(VERTICAL, unit);
    }

    /**
     *  Get the height ScrollableSizeHint enum
     *
     *  @return the ScrollableSizeHint enum for the height
     */
    public ScrollableSizeHint getScrollableHeight()
    {
        return scrollableHeight;
    }

    /**
     *  Set the ScrollableSizeHint enum for the height. The enum is used to
     *  determine the boolean value that is returned by the
     *  getScrollableTracksViewportHeight() method. The valid values are:
     *
     *  ScrollableSizeHint.NONE - return "false", which causes the height
     *      of the panel to be used when laying out the children
     *  ScrollableSizeHint.FIT - return "true", which causes the height of
     *      the viewport to be used when laying out the children
     *  ScrollableSizeHint.STRETCH - return "true" when the viewport height
     *      is greater than the height of the panel, "false" otherwise.
     *
     *  @param scrollableHeight as represented by the ScrollableSizeHint enum.
     */
    public void setScrollableHeight(ScrollableSizeHint scrollableHeight)
    {
        this.scrollableHeight = scrollableHeight;
        revalidate();
    }

    /**
     *  Get the width ScrollableSizeHint enum
     *
     *  @return the ScrollableSizeHint enum for the width
     */
    public ScrollableSizeHint getScrollableWidth()
    {
        return scrollableWidth;
    }

    /**
     *  Set the ScrollableSizeHint enum for the width. The enum is used to
     *  determine the boolean value that is returned by the
     *  getScrollableTracksViewportWidth() method. The valid values are:
     *
     *  ScrollableSizeHint.NONE - return "false", which causes the width
     *      of the panel to be used when laying out the children
     *  ScrollableSizeHint.FIT - return "true", which causes the width of
     *      the viewport to be used when laying out the children
     *  ScrollableSizeHint.STRETCH - return "true" when the viewport width
     *      is greater than the width of the panel, "false" otherwise.
     *
     *  @param scrollableWidth as represented by the ScrollableSizeHint enum.
     */
    public void setScrollableWidth(ScrollableSizeHint scrollableWidth)
    {
        this.scrollableWidth = scrollableWidth;
        revalidate();
    }

    /**
     *  Get the block IncrementInfo for the specified orientation
     *
     *  @return the block IncrementInfo for the specified orientation
     */
    public IncrementInfo getScrollableBlockIncrement(int orientation)
    {
        return orientation == SwingConstants.HORIZONTAL ? horizontalBlock : verticalBlock;
    }

    /**
     *  Specify the information needed to do block scrolling.
     *
     *  @param orientation  specify the scrolling orientation. Must be either:
     *      SwingContants.HORIZONTAL or SwingContants.VERTICAL.
     *  @paran type  specify how the amount parameter in the calculation of
     *      the scrollable amount. Valid values are:
     *		IncrementType.PERCENT - treat the amount as a % of the viewport size
     *      IncrementType.PIXEL - treat the amount as the scrollable amount
     *  @param amount  a value used with the IncrementType to determine the
     *      scrollable amount
     */
    public void setScrollableBlockIncrement(int orientation, IncrementType type, int amount)
    {
        IncrementInfo info = new IncrementInfo(type, amount);
        setScrollableBlockIncrement(orientation, info);
    }

    /**
     *  Specify the information needed to do block scrolling.
     *
     *  @param orientation  specify the scrolling orientation. Must be either:
     *      SwingContants.HORIZONTAL or SwingContants.VERTICAL.
     *  @param info  An IncrementInfo object containing information of how to
     *      calculate the scrollable amount.
     */
    public void setScrollableBlockIncrement(int orientation, IncrementInfo info)
    {
        switch(orientation)
        {
            case SwingConstants.HORIZONTAL:
                horizontalBlock = info;
                break;
            case SwingConstants.VERTICAL:
                verticalBlock = info;
                break;
            default:
                throw new IllegalArgumentException("Invalid orientation: " + orientation);
        }
    }

    /**
     *  Get the unit IncrementInfo for the specified orientation
     *
     *  @return the unit IncrementInfo for the specified orientation
     */
    public IncrementInfo getScrollableUnitIncrement(int orientation)
    {
        return orientation == SwingConstants.HORIZONTAL ? horizontalUnit : verticalUnit;
    }

    /**
     *  Specify the information needed to do unit scrolling.
     *
     *  @param orientation  specify the scrolling orientation. Must be either:
     *      SwingContants.HORIZONTAL or SwingContants.VERTICAL.
     *  @paran type  specify how the amount parameter in the calculation of
     *               the scrollable amount. Valid values are:
     *				 IncrementType.PERCENT - treat the amount as a % of the viewport size
     *               IncrementType.PIXEL - treat the amount as the scrollable amount
     *  @param amount  a value used with the IncrementType to determine the
     *                 scrollable amount
     */
    public void setScrollableUnitIncrement(int orientation, IncrementType type, int amount)
    {
        IncrementInfo info = new IncrementInfo(type, amount);
        setScrollableUnitIncrement(orientation, info);
    }

    /**
     *  Specify the information needed to do unit scrolling.
     *
     *  @param orientation  specify the scrolling orientation. Must be either:
     *      SwingContants.HORIZONTAL or SwingContants.VERTICAL.
     *  @param info  An IncrementInfo object containing information of how to
     *               calculate the scrollable amount.
     */
    public void setScrollableUnitIncrement(int orientation, IncrementInfo info)
    {
        switch(orientation)
        {
            case SwingConstants.HORIZONTAL:
                horizontalUnit = info;
                break;
            case SwingConstants.VERTICAL:
                verticalUnit = info;
                break;
            default:
                throw new IllegalArgumentException("Invalid orientation: " + orientation);
        }
    }

//  Implement Scrollable interface

    public Dimension getPreferredScrollableViewportSize()
    {
        return getPreferredSize();
    }

    public int getScrollableUnitIncrement(
        Rectangle visible, int orientation, int direction)
    {
        switch(orientation)
        {
            case SwingConstants.HORIZONTAL:
                return getScrollableIncrement(horizontalUnit, visible.width);
            case SwingConstants.VERTICAL:
                return getScrollableIncrement(verticalUnit, visible.height);
            default:
                throw new IllegalArgumentException("Invalid orientation: " + orientation);
        }
    }

    public int getScrollableBlockIncrement(
        Rectangle visible, int orientation, int direction)
    {
        switch(orientation)
        {
            case SwingConstants.HORIZONTAL:
                return getScrollableIncrement(horizontalBlock, visible.width);
            case SwingConstants.VERTICAL:
                return getScrollableIncrement(verticalBlock, visible.height);
            default:
                throw new IllegalArgumentException("Invalid orientation: " + orientation);
        }
    }

    protected int getScrollableIncrement(IncrementInfo info, int distance)
    {
        if (info.getIncrement() == IncrementType.PIXELS)
            return info.getAmount();
        else
            return distance * info.getAmount() / 100;
    }

    public boolean getScrollableTracksViewportWidth()
    {
        if (scrollableWidth == ScrollableSizeHint.NONE)
            return false;

        if (scrollableWidth == ScrollableSizeHint.FIT)
            return true;

        //  STRETCH sizing, use the greater of the panel or viewport width

        if (getParent() instanceof JViewport)
        {
            return (((JViewport)getParent()).getWidth() > getPreferredSize().width);
        }

        return false;
    }

    public boolean getScrollableTracksViewportHeight()
    {
        if (scrollableHeight == ScrollableSizeHint.NONE)
            return false;

        if (scrollableHeight == ScrollableSizeHint.FIT)
            return true;

        //  STRETCH sizing, use the greater of the panel or viewport height


        if (getParent() instanceof JViewport)
        {
            return (((JViewport)getParent()).getHeight() > getPreferredSize().height);
        }

        return false;
    }

    /**
     *  Helper class to hold the information required to calculate the scroll amount.
     */
    static class IncrementInfo
    {
        private IncrementType type;
        private int amount;

        public IncrementInfo(IncrementType type, int amount)
        {
            this.type = type;
            this.amount = amount;
        }

        public IncrementType getIncrement()
        {
            return type;
        }

        public int getAmount()
        {
            return amount;
        }

        public String toString()
        {
            return
                "ScrollablePanel[" +
                    type + ", " +
                    amount + "]";
        }
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import com.adamk33n3r.runelite.watchdog.*;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.alerts.AlertGroup;
import com.adamk33n3r.runelite.watchdog.alerts.RegexMatcher;
import com.adamk33n3r.runelite.watchdog.ui.*;

import net.runelite.client.plugins.info.JRichTextPane;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.MultiplexingPluginPanel;
import net.runelite.client.ui.PluginPanel;

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.text.WordUtils;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Supplier;

@Slf4j
public abstract class AlertPanel<T extends Alert> extends PluginPanel {
    private final JPanel controlContainer;
    private final JPanel centerContainer;
    protected final WatchdogPanel watchdogPanel;
    protected final WatchdogPlugin plugin;
    protected final MultiplexingPluginPanel muxer;
    protected final T alert;

    private final AlertManager alertManager;

    public AlertPanel(WatchdogPanel watchdogPanel, T alert) {
        super(false);

        this.watchdogPanel = watchdogPanel;
        this.muxer = watchdogPanel.getMuxer();
        this.alert = alert;
        this.plugin = WatchdogPlugin.getInstance();
        this.alertManager = plugin.getAlertManager();

        this.setLayout(new BorderLayout());

        JPanel northPanel = new JPanel(new StretchedStackedLayout(3));
        this.add(northPanel, BorderLayout.NORTH);

        JPanel nameGroup = new JPanel(new BorderLayout());
        nameGroup.setBorder(new EmptyBorder(10, 5, 10, 5));

        TriggerType triggerType = this.alert.getType();
        JLabel nameLabel = new JLabel(triggerType.getName());
        nameLabel.setToolTipText(triggerType.getTooltip());
        nameLabel.setForeground(Color.WHITE);
        nameGroup.add(nameLabel, BorderLayout.CENTER);

        JPanel rightButtons = new JPanel(new GridLayout(1, 0));

        if (alert instanceof AlertGroup) {
            JButton importAlertBtn = PanelUtils.createActionButton(
                Icons.IMPORT,
                Icons.IMPORT_HOVER,
                "Import alert into this group",
                (btn, modifiers) -> {
                    ImportExportDialog importExportDialog = new ImportExportDialog(
                        SwingUtilities.getWindowAncestor(this),
                        (json, append) -> {
                            boolean result = this.alertManager.importAlerts(json, ((AlertGroup) alert).getAlerts(), append, true, WatchdogPlugin.getInstance().getConfig().overrideImportsWithDefaults());
                            // Delay for layout. Without this, it would sometimes make the search/actions narrower.
                            SwingUtilities.invokeLater(this::rebuild);
                            return result;
                        }
                    );
                    importExportDialog.setVisible(true);
                }
            );
            rightButtons.add(importAlertBtn);
        } else {
            JButton testAlert = PanelUtils.createActionButton(
                Icons.TEST,
                Icons.TEST_HOVER,
                "Test the whole alert",
                (btn, modifiers) -> {
                    String[] triggerValues = {"1", "2", "3", "4", "5"};
                    this.watchdogPanel.getHistoryPanelProvider().get().addEntry(alert, triggerValues);
                    this.plugin.processAlert(alert, triggerValues, true);
                }
            );
            rightButtons.add(testAlert);
        }

        JButton exportAlertBtn = PanelUtils.createActionButton(
            Icons.EXPORT,
            Icons.EXPORT_HOVER,
            "Export this alert",
            (btn, modifiers) -> {
                ImportExportDialog importExportDialog = new ImportExportDialog(
                    SwingUtilities.getWindowAncestor(this),
                    alert
                );
                importExportDialog.setVisible(true);
            }
        );
        rightButtons.add(exportAlertBtn);

        ToggleButton toggleButton = new ToggleButton();
        toggleButton.setSelected(alert.isEnabled());
        toggleButton.addItemListener(i -> {
            alert.setEnabled(toggleButton.isSelected());
            this.alertManager.saveAlerts();
        });
        rightButtons.add(toggleButton);

        nameGroup.add(rightButtons, BorderLayout.EAST);

        JButton backButton = PanelUtils.createActionButton(
            Icons.BACK,
            Icons.BACK_HOVER,
            "Back",
            (btn, modifiers) -> {
                WatchdogPlugin.getInstance().getScreenMarkerUtil().finishCreation(true);
                this.alertManager.saveAlerts();
                this.muxer.popState();

                // Workaround for the onActivate rebuild issue
                // TODO remove if it ever gets fixed https://github.com/runelite/runelite/issues/17712
                int componentCount = this.muxer.getComponentCount();
                Component component = this.muxer.getComponent(componentCount - 1);
                if (component instanceof AlertPanel) {
                    ((AlertPanel<?>) component).rebuild();
                }
            }
        );
        backButton.setPreferredSize(new Dimension(22, 16));
        backButton.setBorder(new EmptyBorder(0, 0, 0, 5));
        nameGroup.add(backButton, BorderLayout.WEST);

        northPanel.add(nameGroup);

        this.controlContainer = new JPanel(new StretchedStackedLayout(3));
        this.controlContainer.setBorder(new EmptyBorder(0, 5, 0, 5));
        northPanel.add(this.controlContainer);

        this.centerContainer = new JPanel(new BorderLayout());
        this.add(this.centerContainer, BorderLayout.CENTER);
    }

    public AlertPanel<T> addLabel(String label) {
        JLabel labelComp = new JLabel(label);
        this.controlContainer.add(labelComp);
        return this;
    }

    public AlertPanel<T> addRichTextPane(String text) {
        JRichTextPane richTextPane = new JRichTextPane();
        richTextPane.setContentType("text/html");
        richTextPane.setText(text);
        richTextPane.setForeground(Color.WHITE);
        this.controlContainer.add(richTextPane);
        return this;
    }

    public AlertPanel<T> addTextField(String placeholder, String tooltip, String initialValue, Consumer<String> saveAction) {
        PlaceholderTextField textField = new PlaceholderTextField(initialValue);
        textField.setSelectedTextColor(Color.WHITE);
        textField.setSelectionColor(ColorScheme.BRAND_ORANGE_TRANSPARENT);
        textField.setPlaceholder(placeholder);
        textField.setToolTipText(tooltip);
        textField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                textField.selectAll();
            }

            @Override
            public void focusLost(FocusEvent e) {
                saveAction.accept(textField.getText());
                alertManager.saveAlerts();
            }
        });
        this.controlContainer.add(textField);
        return this;
    }

    public AlertPanel<T> addTextArea(String placeholder, String tooltip, String initialValue, Consumer<String> saveAction) {
        FlatTextArea textArea = PanelUtils.createTextArea(placeholder, tooltip, initialValue, val -> {
            saveAction.accept(val);
            this.alertManager.saveAlerts();
        });
        this.controlContainer.add(textArea);
        return this;
    }

    public AlertPanel<T> addSpinner(String name, String tooltip, int initialValue, Consumer<Integer> saveAction) {
        return this.addSpinner(name, tooltip, initialValue, saveAction, 0, Integer.MAX_VALUE, 1);
    }

    public AlertPanel<T> addSpinner(String name, String tooltip, int initialValue, Consumer<Integer> saveAction, int min, int max, int step) {
        JSpinner spinner = PanelUtils.createSpinner(initialValue, min, max, step, val -> {
            saveAction.accept(val);
            this.alertManager.saveAlerts();
        });
        this.controlContainer.add(PanelUtils.createLabeledComponent(name, tooltip, spinner));
        return this;
    }

    public <E extends Enum<E>> AlertPanel<T> addSelect(String name, String tooltip, Class<E> enumType, E initialValue, Consumer<E> saveAction) {
        JComboBox<E> select = new JComboBox<>(enumType.getEnumConstants());
        select.setSelectedItem(initialValue);
        select.setRenderer((list, value, index, isSelected, cellHasFocus) -> {
            if (value instanceof Displayable) {
                list.setToolTipText(((Displayable) value).getTooltip());
                return new DefaultListCellRenderer().getListCellRendererComponent(list, ((Displayable) value).getName(), index, isSelected, cellHasFocus);
            }
            String titleized = WordUtils.capitalizeFully(value.name());
            list.setToolTipText(titleized);
            return new DefaultListCellRenderer().getListCellRendererComponent(list, titleized, index, isSelected, cellHasFocus);
        });
        select.addActionListener(e -> {
            saveAction.accept(select.getItemAt(select.getSelectedIndex()));
            this.alertManager.saveAlerts();
        });
        this.controlContainer.add(PanelUtils.createLabeledComponent(name, tooltip, select));
        return this;
    }

    public AlertPanel<T> addCheckbox(String name, String tooltip, boolean initialValue, Consumer<Boolean> saveAction) {
        JCheckBox checkbox = PanelUtils.createCheckbox(name, tooltip, initialValue, val -> {
            saveAction.accept(val);
            this.alertManager.saveAlerts();
        });
        this.controlContainer.add(checkbox);
        return this;
    }

    public AlertPanel<T> addInputGroupWithSuffix(JComponent mainComponent, JComponent suffix) {
        return this.addInputGroup(mainComponent, null, Collections.singletonList(suffix));
    }

    public AlertPanel<T> addInputGroup(JComponent mainComponent, List<JComponent> prefixes, List<JComponent> suffixes) {
        InputGroup textFieldGroup = new InputGroup(mainComponent)
            .addPrefixes(prefixes)
            .addSuffixes(suffixes);
        this.controlContainer.add(textFieldGroup);
        return this;
    }

    public AlertPanel<T> addAlertDefaults() {
        return this.addTextField("Enter the alert name...", "Name of Alert", this.alert.getName(), this.alert::setName)
            .addSpinner(
                "Debounce Time (ms)",
                "How long to wait before allowing this alert to trigger again in milliseconds",
                this.alert.getDebounceTime(),
                this.alert::setDebounceTime,
                0,
                8640000, // 6 hours - max time a player can be logged in
                100
            );
    }

    public AlertPanel<T> addIf(Consumer<AlertPanel<T>> panel, Supplier<Boolean> ifFunc) {
        if (ifFunc.get()) {
            panel.accept(this);
        }
        return this;
    }

    public AlertPanel<T> addRegexMatcher(RegexMatcher regexMatcher, String placeholder, String tooltip) {
        return this.addRegexMatcher(regexMatcher, placeholder, tooltip, null);
    }

    public AlertPanel<T> addRegexMatcher(RegexMatcher regexMatcher, String placeholder, String tooltip, JComponent suffixAppend) {
        return this.addRegexMatcher(
            regexMatcher::getPattern,
            regexMatcher::setPattern,
            regexMatcher::isRegexEnabled,
            regexMatcher::setRegexEnabled,
            placeholder,
            tooltip,
            suffixAppend
        );
    }

    public AlertPanel<T> addRegexMatcher(
        Supplier<String> pattern,
        Consumer<String> savePattern,
        Supplier<Boolean> regexEnabled,
        Consumer<Boolean> saveRegexEnabled,
        String placeholder,
        String tooltip,
        JComponent suffixAppend
    ) {
        JPanel btnGroup = new JPanel(new GridLayout(1, 0, 5, 5));
        JButton regex = PanelUtils.createToggleActionButton(
            Icons.REGEX_SELECTED,
            Icons.REGEX_SELECTED_HOVER,
            Icons.REGEX,
            Icons.REGEX_HOVER,
            "Disable regex",
            "Enable regex",
            regexEnabled.get(),
            (btn, modifiers) -> {
                saveRegexEnabled.accept(btn.isSelected());
                this.alertManager.saveAlerts();
            }
        );
        btnGroup.add(regex);
        if (suffixAppend != null) {
            btnGroup.add(suffixAppend);
        }
        return this.addInputGroupWithSuffix(
            PanelUtils.createTextArea(placeholder, tooltip, pattern.get(), msg -> {
                if (!PanelUtils.isPatternValid(this, msg, regexEnabled.get()))
                    return;
                savePattern.accept(msg);
                this.alertManager.saveAlerts();
            }),
            btnGroup
        );
    }

    public AlertPanel<T> addNotifications() {
        NotificationsPanel notificationPanel = WatchdogPlugin.getInstance().getInjector().getInstance(NotificationsPanel.class);
        notificationPanel.init(this.alert);
        notificationPanel.setBorder(new CompoundBorder(new EmptyBorder(0, 5, 0, 5), new HorizontalRuleBorder(10)));
        this.centerContainer.add(notificationPanel);

        return this;
    }

    public AlertPanel<T> addSubPanel(JPanel sub) {
        this.centerContainer.add(sub);
        return this;
    }

    public AlertPanel<T> addSubPanelControl(JPanel sub) {
        this.controlContainer.add(sub);
        return this;
    }

    public AlertPanel<T> addButton(String text, String tooltip, PanelUtils.ButtonClickListener clickListener) {
        JButton button = new JButton(text);
        button.setToolTipText(tooltip);
        button.addActionListener((ev) -> clickListener.clickPerformed(button, ev.getModifiers()));
        this.controlContainer.add(button);
        return this;
    }

    protected abstract void build();
    public void rebuild() {
        this.controlContainer.removeAll();
        this.centerContainer.removeAll();
        this.build();
    }

    @Override
    public void onActivate() {
        // Getting some weird resizing issues when this is called when switching tabs or collapsing the side panel
        // if there is lots of text in a text area? idk
        // Moved to the muxer.onAdd

        // this causes it to resize on collapse/restore
//        this.rebuild();
//        SwingUtilities.invokeLater(() -> {
//            // this causes it to resize on edit
//            this.rebuild();
//        });
    }
}

package com.adamk33n3r.runelite.watchdog.ui.panels;

import javax.swing.JComponent;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.util.List;

class InputGroup extends JPanel {
    private final JPanel prefixes = new JPanel(new GridLayout(1, 0, 0, 0));
    private final JPanel suffixes = new JPanel(new GridLayout(1, 0, 0, 0));
    public InputGroup(JComponent mainComponent) {
        super(new BorderLayout());
        this.add(mainComponent);
        this.add(this.prefixes, BorderLayout.WEST);
        this.add(this.suffixes, BorderLayout.EAST);
    }

    public InputGroup addPrefix(JComponent component) {
        this.prefixes.add(component);
        return this;
    }

    public InputGroup addPrefixes(List<JComponent> components) {
        if (components != null) {
            components.forEach(this.prefixes::add);
        }
        return this;
    }

    public InputGroup addSuffix(JComponent component) {
        this.suffixes.add(component);
        return this;
    }

    public InputGroup addSuffixes(List<JComponent> components) {
        if (components != null) {
            components.forEach(this.suffixes::add);
        }
        return this;
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import lombok.Getter;
import lombok.Setter;

import javax.swing.JTextArea;
import javax.swing.text.Document;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.util.Map;

public class PlaceholderTextArea extends JTextArea {
    @Getter
    @Setter
    private String placeholder;

    private static final Map<?, ?> hints = (Map<?, ?>) Toolkit.getDefaultToolkit().getDesktopProperty("awt.font.desktophints");

    public PlaceholderTextArea() {
        super();
    }

    public PlaceholderTextArea(final Document pDoc, final String pText, final int pRows, final int pColumns) {
        super(pDoc, pText, pRows, pColumns);
    }

    public PlaceholderTextArea(final String pText) {
        super(pText);
    }

    @Override
    protected void paintComponent(final Graphics pG) {
        super.paintComponent(pG);

        if (this.placeholder == null || this.placeholder.length() == 0 || this.getText().length() > 0) {
            return;
        }

        final Graphics2D g = (Graphics2D) pG;
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setColor(this.getDisabledTextColor());
        g.drawString(this.placeholder, this.getInsets().left, g.getFontMetrics().getMaxAscent() + this.getInsets().top);
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.config.RuneLiteConfig;

import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.GridLayout;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Function;

@Slf4j
public class ImportExportDialog extends JDialog {
    // Import
    public ImportExportDialog(Component parent, BiFunction<String, Boolean, Boolean> onImport) {
        this.setTitle("Import");
        this.setSize(500, 250);
        this.setLocationRelativeTo(parent);
        this.setModal(true);
        this.setUndecorated(true);
        Util.syncAlwaysOnTop(this);

        JPanel wrapper = this.createWrapper();
        this.add(wrapper);

        wrapper.add(new JLabel("Paste the Alert JSON here"), BorderLayout.NORTH);

        JTextArea textArea = new JTextArea();
        textArea.setLineWrap(true);
        JScrollPane scrollPane = new JScrollPane(textArea);
        wrapper.add(scrollPane, BorderLayout.CENTER);

        JPanel btnGroup = new JPanel(new GridLayout(1, 0, 25, 0));
        Function<Boolean, ActionListener> importAlertFn = append -> ev -> {
            if (!append && JOptionPane.showConfirmDialog(this, "Are you sure you wish to replace all of the alerts?", "Confirm Replace?", JOptionPane.YES_NO_OPTION) != JOptionPane.YES_OPTION) {
                return;
            }
            String json = textArea.getText();
            try {
                if (onImport.apply(json, append)) {
                    this.setVisible(false);
                }
            } catch (Exception ex) {
                log.error("Error parsing json: " + ex);
                JOptionPane.showMessageDialog(this, "There was an error parsing the alert json", "Error parsing JSON", JOptionPane.ERROR_MESSAGE);
            }
        };
        JButton importOverwriteBtn = new JButton("Delete All & Import");
        importOverwriteBtn.addActionListener(importAlertFn.apply(false));
        btnGroup.add(importOverwriteBtn);
        JButton importAppendBtn = new JButton("Import");
        importAppendBtn.addActionListener(importAlertFn.apply(true));
        btnGroup.add(importAppendBtn);
        JButton closeBtn = new JButton("Cancel");
        closeBtn.addActionListener(ev -> {
            this.setVisible(false);
        });
        btnGroup.add(closeBtn);
        wrapper.add(btnGroup, BorderLayout.SOUTH);
    }

    // Export
    public ImportExportDialog(Component parent, Alert alert) {
        Gson gson = WatchdogPlugin.getInstance().getAlertManager().getGson();
        String json = gson.toJson(alert);
        String pretty = gson.newBuilder().setPrettyPrinting().create().toJson(alert);
        this.show(parent, json, pretty);
    }

    public ImportExportDialog(Component parent, List<Alert> alerts) {
        Gson gson = WatchdogPlugin.getInstance().getAlertManager().getGson();
        String json = gson.toJson(alerts);
        String pretty = gson.newBuilder().setPrettyPrinting().create().toJson(alerts);
        this.show(parent, json, pretty);
    }

    public void show(Component parent, String exportString, String prettyExportString) {
        this.setTitle("Export");
        this.setSize(500, 250);
        this.setLocationRelativeTo(parent);
        this.setModal(true);
        this.setUndecorated(true);
        Util.syncAlwaysOnTop(this);

        JTextArea textArea = new JTextArea(exportString);
        textArea.setLineWrap(true);
        textArea.setEditable(false);
        SwingUtilities.invokeLater(textArea::requestFocusInWindow);

        JPanel wrapper = this.createWrapper();
        this.add(wrapper);
        JPanel top = new JPanel(new BorderLayout());
        top.add(new JLabel("Exported Alert JSON"), BorderLayout.WEST);
        JCheckBox prettyPrint = PanelUtils.createCheckbox("Pretty Print", "Pretty Print", false, (selected) -> {
            textArea.setText(selected ? prettyExportString : exportString);
            textArea.setCaretPosition(0);
            textArea.requestFocusInWindow();
        });
        top.add(prettyPrint, BorderLayout.EAST);
        wrapper.add(top, BorderLayout.NORTH);
        JPanel btnGroup = new JPanel(new GridLayout(1, 2, 25, 0));
        JButton copyBtn = new JButton("Copy to Clipboard");
        copyBtn.addActionListener(ev -> {
            Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
            clipboard.setContents(new StringSelection(prettyPrint.isSelected() ? prettyExportString : exportString), null);
            this.setVisible(false);
        });
        btnGroup.add(copyBtn);
        JButton saveToFileBtn = new JButton("Save to File");
        saveToFileBtn.addActionListener(ev -> {
            JFileChooser fileChooser = new JFileChooser();
            fileChooser.setFileFilter(new FileNameExtensionFilter("JSON Files (*.json)", "json"));
            int userSelection = fileChooser.showSaveDialog(this);
            if (userSelection == JFileChooser.APPROVE_OPTION) {
                File fileToSave = fileChooser.getSelectedFile();

                if (!fileToSave.getName().contains(".")) {
                    fileToSave = new File(fileToSave.getAbsolutePath() + ".json");
                }

                try {
                    try (FileWriter fileWriter = new FileWriter(fileToSave)) {
                        fileWriter.write(prettyPrint.isSelected() ? prettyExportString : exportString);
                    }
                } catch (IOException e) {
                    log.error("Error writing file", e);
                    JOptionPane.showMessageDialog(this, "There was an error saving the file", "Error saving file", JOptionPane.ERROR_MESSAGE);
                }
            }
            this.setVisible(false);
        });
        btnGroup.add(saveToFileBtn);
        JButton closeBtn = new JButton("Close");
        btnGroup.add(closeBtn);
        closeBtn.addActionListener(ev -> {
            this.setVisible(false);
        });
        wrapper.add(btnGroup, BorderLayout.SOUTH);

        JScrollPane scrollPane = new JScrollPane(textArea);
        wrapper.add(scrollPane, BorderLayout.CENTER);
    }

    private JPanel createWrapper() {
        JPanel wrapper = new JPanel(new BorderLayout(5, 5));
        wrapper.setBorder(new EmptyBorder(10, 10, 10, 10));
        return wrapper;
    }
}

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.adamk33n3r.runelite.watchdog.ui.dropdownbutton;

import javax.swing.Icon;
import java.awt.*;
import java.awt.geom.AffineTransform;
import java.io.Serializable;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * A scalable icon that can be drawn at any resolution, for use with HiDPI displays. Implementations
 * will typically use hand-crafted painting code that may take special care to align graphics to
 * device pixels, and which may perform small tweaks to make the icon look good at all resolutions.
 * The API of this class intends to make this straightforward.
 *
 * <p>HiDPI support now exists on MacOS, Windows, and Linux. On MacOS, scaling is 200% for Retina
 * displays, while on Windows 10, the "Change display settings" panel provides the options 100%,
 * 125%, 150%, 175%, 200%, and 225%, as well as the option to enter an arbitrary scaling factor.
 * Non-integral scaling factors can lead to various alignment problems that makes otherwise
 * well-aligned icons look unsharp; this class takes special care to avoid such problems.
 *
 * <p>Hand-crafted painting code is a good design choice for icons that are simple, ubiqutious in
 * the UI (e.g. part of the Look-and-Feel), or highly parameterized. Swing's native Windows L&amp;F
 * uses this approach for many of its basic icons; see
 * {@link com.sun.java.swing.plaf.windows.WindowsIconFactory}.
 *
 * <p>When developing new icons, or adjusting existing ones, use the {@code VectorIconTester}
 * utility found in
 * {@code o.n.swing.tabcontrol/test/unit/src/org/netbeans/swing/tabcontrol/plaf/VectorIconTester.java}
 * to preview and compare icons at different resolutions.
 *
 * @since 9.12
 * @author Eirik Bakke
 */
public abstract class VectorIcon implements Icon, Serializable {
    private final int width;
    private final int height;

    protected VectorIcon(int width, int height) {
        if (width < 0 || height < 0)
            throw new IllegalArgumentException();
        this.width = width;
        this.height = height;
    }

    @Override
    public final int getIconWidth() {
        return width;
    }

    @Override
    public final int getIconHeight() {
        return height;
    }

    /* We can't use org.openide.awt.GraphicsUtils.configureDefaultRenderingHints here, since this module
    is not allowed to depend on it. But in any case, the rendering hints for VectorIcon are intended
    to remain standardized, unaffected by settings elsewhere. */
    private static Graphics2D createGraphicsWithRenderingHintsConfigured(Graphics basedOn) {
        Graphics2D ret = (Graphics2D) basedOn.create();
        Object desktopHints =
            Toolkit.getDefaultToolkit().getDesktopProperty("awt.font.desktophints");
        Map<Object, Object> hints = new LinkedHashMap<Object, Object>();
        if (desktopHints != null && desktopHints instanceof Map<?, ?>)
            hints.putAll((Map<?, ?>) desktopHints);
        /* Enable antialiasing by default. Adding this is required in order to get non-text
        antialiasing on Windows. */
        hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        /* In case a subclass decides to render text inside an icon, standardize the text
        antialiasing setting as well. Don't try to follow the editor's anti-aliasing setting, or
        to do subpixel rendering. It's more important that icons render in a predictable fashion, so
        the icon designer can get can review the appearance at design time. */
        hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        // Make stroke behavior as predictable as possible.
        hints.put(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);
        ret.addRenderingHints(hints);
        return ret;
    }

    /**
     * Selectively enable or disable antialiasing during painting. Certain shapes may look slightly
     * better without antialiasing, e.g. entirely regular diagonal lines in very small icons when
     * there is no HiDPI scaling. Text antialiasing is unaffected by this setting.
     *
     * @param g the graphics to set antialiasing setting for
     * @param enabled whether antialiasing should be enabled or disabled
     */
    protected static final void setAntiAliasing(Graphics2D g, boolean enabled) {
        Map<Object, Object> hints = new LinkedHashMap<Object, Object>();
        hints.put(RenderingHints.KEY_ANTIALIASING, enabled
            ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
        g.addRenderingHints(hints);
    }

    protected static final int round(double d) {
        int ret = (int) Math.round(d);
        return d > 0 && ret == 0 ? 1 : ret;
    }

    @Override
    public final void paintIcon(Component c, Graphics g0, int x, int y) {
        final Graphics2D g2 = createGraphicsWithRenderingHintsConfigured(g0);
        try {
            // Make sure the subclass can't paint outside its stated dimensions.
            g2.clipRect(x, y, getIconWidth(), getIconHeight());
            g2.translate(x, y);
            /**
             * On HiDPI monitors, the Graphics object will have a default transform that maps
             * logical pixels, like those you'd pass to Graphics.drawLine, to a higher number of
             * device pixels on the screen. For instance, painting a line 10 pixels long on the
             * current Graphics object would actually produce a line 20 device pixels long on a
             * MacOS retina screen, which has a DPI scaling factor of 2.0. On Windows 10, many
             * different scaling factors may be encountered, including non-integral ones such as
             * 1.5. Detect the scaling factor here so we can use it to inform the drawing routines.
             */
            final double scaling;
            final AffineTransform tx = g2.getTransform();
            int txType = tx.getType();
            if (txType == AffineTransform.TYPE_UNIFORM_SCALE ||
                txType == (AffineTransform.TYPE_UNIFORM_SCALE | AffineTransform.TYPE_TRANSLATION))
            {
                scaling = tx.getScaleX();
            } else {
                // Unrecognized transform type. Don't do any custom scaling handling.
                paintIcon(c, g2, getIconWidth(), getIconHeight(), 1.0);
                return;
            }
            /* When using a non-integral scaling factor, such as 175%, preceding Swing components
            often end up being a non-integral number of device pixels tall or wide. This will cause
            our initial position to be "off the grid" with respect to device pixels, causing blurry
            graphics even if we subsequently take care to use only integral numbers of device pixels
            during painting. Fix this here by consuming a little bit of the top and left of the
            icon's dimensions to offset any error. */
            // The initial position, in device pixels.
            final double previousDevicePosX = tx.getTranslateX();
            final double previousDevicePosY = tx.getTranslateY();
            /* The new, aligned position, after a small portion of the icon's dimensions may have
            been consumed to correct it. */
            final double alignedDevicePosX = Math.ceil(previousDevicePosX);
            final double alignedDevicePosY = Math.ceil(previousDevicePosY);
            // Use the aligned position.
            g2.setTransform(new AffineTransform(
                1, 0, 0, 1, alignedDevicePosX, alignedDevicePosY));
            /* The portion of the icon's dimensions that was consumed to correct any initial
            translation misalignment, in device pixels. May be zero. */
            final double transDeviceAdjX = alignedDevicePosX - previousDevicePosX;
            final double transDeviceAdjY = alignedDevicePosY - previousDevicePosY;
            /* Now calculate the dimensions available for painting, also aligned to an integral
            number of device pixels. */
            final int deviceWidth  = (int) Math.floor(getIconWidth()  * scaling - transDeviceAdjX);
            final int deviceHeight = (int) Math.floor(getIconHeight() * scaling - transDeviceAdjY);
            paintIcon(c, g2, deviceWidth, deviceHeight, scaling);
        } finally {
            g2.dispose();
        }
    }

    /**
     * Paint the icon at the given width and height. The dimensions given are the device pixels onto
     * which the icon must be drawn after it has been scaled up from its originally constant logical
     * dimensions and aligned onto the device pixel grid. Painting onto the supplied
     * {@code Graphics2D} instance using whole number coordinates (for horizontal and vertical
     * lines) will encourage sharp and well-aligned icons.
     *
     * <p>The icon should be painted with its upper left-hand corner at position (0, 0). Icons need
     * not be opaque. Due to rounding errors and alignment correction, the aspect ratio of the
     * device dimensions supplied here may not be exactly the same as that of the logical pixel
     * dimensions specified in the constructor.
     *
     * @param c may be used to get properties useful for painting, as in
     *        {@link Icon#paintIcon(Component,Graphics,int,int)}
     * @param width the target width of the icon, after scaling and alignment adjustments, in device
     *        pixels
     * @param height the target height of the icon, after scaling and alignment adjustments, in
     *        device pixels
     * @param scaling the scaling factor that was used to scale the icon dimensions up to their
     *        stated value
     * @param g need <em>not</em> be cleaned up or restored to its previous state after use; will
     *        have anti-aliasing already enabled by default
     */
    protected abstract void paintIcon(
        Component c, Graphics2D g, int width, int height, double scaling);
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package com.adamk33n3r.runelite.watchdog.ui.dropdownbutton;

import javax.swing.*;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.beans.PropertyChangeEvent;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * JButton with a small arrow that displays popup menu when clicked.
 *
 * @author S. Aubrecht
 * @since 6.11
 */
class DropDownButton extends JButton {

    private boolean mouseInButton = false;
    private boolean mouseInArrowArea = false;
    private boolean popupClosingInProgress = false;

    private Map<String,Icon> regIcons = new HashMap<String,Icon>( 5 );
    private Map<String,Icon> arrowIcons = new HashMap<String,Icon>( 5 );

    private static final String ICON_NORMAL = "normal"; //NOI18N
    private static final String ICON_PRESSED = "pressed"; //NOI18N
    private static final String ICON_ROLLOVER = "rollover"; //NOI18N
    private static final String ICON_ROLLOVER_SELECTED = "rolloverSelected"; //NOI18N
    private static final String ICON_SELECTED = "selected"; //NOI18N
    private static final String ICON_DISABLED = "disabled"; //NOI18N
    private static final String ICON_DISABLED_SELECTED = "disabledSelected"; //NOI18N

    private static final String ICON_ROLLOVER_LINE = "rolloverLine"; //NOI18N
    private static final String ICON_ROLLOVER_SELECTED_LINE = "rolloverSelectedLine"; //NOI18N

    private PopupMenuListener menuListener;

    /** Creates a new instance of MenuToggleButton */
    public DropDownButton( Icon icon, JPopupMenu popup) {
//        Parameters.notNull("icon", icon); //NOI18N

        putClientProperty( "dropDownMenu", popup );

        setIcon( icon );
//        setDisabledIcon(ImageUtilities.createDisabledIcon(icon));

        resetIcons();

        addPropertyChangeListener("dropDownMenu", (PropertyChangeEvent e) -> {
            resetIcons();
        });

        addMouseMotionListener(new MouseMotionAdapter() {
            @Override
            public void mouseMoved(MouseEvent e) {
                if (null != getPopupMenu()) {
                    mouseInArrowArea = isInArrowArea(e.getPoint());
                    updateRollover(_getRolloverIcon(), _getRolloverSelectedIcon());
                }
            }
        });

        addMouseListener( new MouseAdapter() {
            private boolean popupMenuOperation = false;

            @Override
            public void mousePressed( MouseEvent e ) {
                if (popupClosingInProgress) {
                    return;
                }
                popupMenuOperation = false;
                JPopupMenu menu = getPopupMenu();
                if ( menu != null && getModel() instanceof Model ) {
                    Model model = (Model) getModel();
                    if ( !model._isPressed() ) {
                        if( (isInArrowArea( e.getPoint() )) && menu.getComponentCount() > 0 &&
                            model.isEnabled() )
                        {
                            model._press();
                            menu.addPopupMenuListener( getMenuListener() );
                            menu.show( DropDownButton.this, 0, getHeight() );
                            popupMenuOperation = true;
                        }
                    } else {
                        model._release();
                        menu.removePopupMenuListener( getMenuListener() );
                        popupMenuOperation = true;
                    }
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                // If we done something with the popup menu, we should consume
                // the event, otherwise the button's action will be triggered.
                if (popupMenuOperation) {
                    popupMenuOperation = false;
                    e.consume();
                }
            }

            @Override
            public void mouseEntered( MouseEvent e ) {
                mouseInButton = true;
                if( hasPopupMenu() ) {
                    mouseInArrowArea = isInArrowArea( e.getPoint() );
                    updateRollover( _getRolloverIcon(), _getRolloverSelectedIcon() );
                }
            }

            @Override
            public void mouseExited( MouseEvent e ) {
                mouseInButton = false;
                mouseInArrowArea = false;
                if( hasPopupMenu() ) {
                    updateRollover( _getRolloverIcon(), _getRolloverSelectedIcon() );
                }
            }
        });

        setModel( new Model() );
    }

    private PopupMenuListener getMenuListener() {
        if( null == menuListener ) {
            menuListener = new PopupMenuListener() {
                @Override
                public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
                }

                @Override
                public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
                    if( getModel() instanceof Model ) {
                        ((Model)getModel())._release();
                    }
                    JPopupMenu menu = getPopupMenu();
                    if( null != menu ) {
                        menu.removePopupMenuListener( this );
                    }
                    /* If the popup was closed by a mouse click inside the button area, the button
                    may also receive a mousePressed event, although this seems not to be guaranteed.
                    Ignore any such button press while the popup is closing, to avoid interpreting
                    the press as a click to open the menu again. */
                    popupClosingInProgress = true;
                    SwingUtilities.invokeLater(() -> {
                        popupClosingInProgress = false;
                    });
                }

                @Override
                public void popupMenuCanceled(PopupMenuEvent e) {
                }
            };
        }
        return menuListener;
    }

    private void updateRollover( Icon rollover, Icon rolloverSelected ) {
        super.setRolloverIcon( rollover );
        super.setRolloverSelectedIcon( rolloverSelected );
    }

    private void resetIcons() {
        Icon icon = regIcons.get( ICON_NORMAL );
        if( null != icon )
            setIcon( icon );

        icon = regIcons.get( ICON_PRESSED );
        if( null != icon )
            setPressedIcon( icon );

        icon = regIcons.get( ICON_ROLLOVER );
        if( null != icon )
            setRolloverIcon( icon );

        icon = regIcons.get( ICON_ROLLOVER_SELECTED );
        if( null != icon )
            setRolloverSelectedIcon( icon );

        icon = regIcons.get( ICON_SELECTED );
        if( null != icon )
            setSelectedIcon( icon );

        icon = regIcons.get( ICON_DISABLED );
        if( null != icon )
            setDisabledIcon( icon );

        icon = regIcons.get( ICON_DISABLED_SELECTED );
        if( null != icon )
            setDisabledSelectedIcon( icon );
    }

    private Icon _getRolloverIcon() {
        Icon icon = null;
        icon = arrowIcons.get( mouseInArrowArea ? ICON_ROLLOVER : ICON_ROLLOVER_LINE );
        if( null == icon ) {
            Icon orig = regIcons.get( ICON_ROLLOVER );
            if( null == orig )
                orig = regIcons.get( ICON_NORMAL );
            icon = new IconWithArrow( orig, !mouseInArrowArea, false );
            arrowIcons.put( mouseInArrowArea ? ICON_ROLLOVER : ICON_ROLLOVER_LINE, icon );
        }
        return icon;
    }

    private Icon _getRolloverSelectedIcon() {
        Icon icon = null;
        icon = arrowIcons.get( mouseInArrowArea ? ICON_ROLLOVER_SELECTED : ICON_ROLLOVER_SELECTED_LINE );
        if( null == icon ) {
            Icon orig = regIcons.get( ICON_ROLLOVER_SELECTED );
            if( null == orig )
                orig = regIcons.get( ICON_ROLLOVER );
            if( null == orig )
                orig = regIcons.get( ICON_NORMAL );
            icon = new IconWithArrow( orig, !mouseInArrowArea, false );
            arrowIcons.put( mouseInArrowArea ? ICON_ROLLOVER_SELECTED : ICON_ROLLOVER_SELECTED_LINE, icon );
        }
        return icon;
    }

    JPopupMenu getPopupMenu() {
        Object menu = getClientProperty( "dropDownMenu");
        if( menu instanceof JPopupMenu ) {
            return (JPopupMenu)menu;
        }
        return null;
    }

    boolean hasPopupMenu() {
        return null != getPopupMenu();
    }

    private boolean isInArrowArea( Point p ) {
        /* If no one is listening for button presses, treat the entire button as a dropdown menu
        trigger. This also means we do not paint the IconWithArrow.paintRollOver separator. */
        if (getActionListeners().length == 0) {
            return true;
        }
        return p.getLocation().x >= getWidth() - IconWithArrow.getArrowAreaWidth() - getInsets().right;
    }

    @Override
    public void setIcon(Icon icon) {
        assert null != icon;
        Icon arrow = updateIcons( icon, ICON_NORMAL );
        arrowIcons.remove( ICON_ROLLOVER_LINE );
        arrowIcons.remove( ICON_ROLLOVER_SELECTED_LINE );
        arrowIcons.remove( ICON_ROLLOVER );
        arrowIcons.remove( ICON_ROLLOVER_SELECTED );
        super.setIcon( hasPopupMenu() ? arrow : icon );
        updateRollover( _getRolloverIcon(), _getRolloverSelectedIcon() );
    }

    private Icon updateIcons( Icon orig, String iconType ) {
        Icon arrow = null;
        if( null == orig ) {
            regIcons.remove( iconType );
            arrowIcons.remove( iconType );
        } else {
            regIcons.put( iconType, orig );
            arrow = new IconWithArrow( orig, false,
                iconType.equals(ICON_DISABLED) || iconType.equals(ICON_DISABLED_SELECTED));
            arrowIcons.put( iconType, arrow );
        }
        return arrow;
    }

    @Override
    public void setPressedIcon(Icon icon) {
        Icon arrow = updateIcons( icon, ICON_PRESSED );
        super.setPressedIcon( hasPopupMenu() ? arrow : icon );
    }

    @Override
    public void setSelectedIcon(Icon icon) {
        Icon arrow = updateIcons( icon, ICON_SELECTED );
        super.setSelectedIcon( hasPopupMenu() ? arrow : icon );
    }

    @Override
    public void setRolloverIcon(Icon icon) {
        Icon arrow = updateIcons( icon, ICON_ROLLOVER );
        arrowIcons.remove( ICON_ROLLOVER_LINE );
        arrowIcons.remove( ICON_ROLLOVER_SELECTED_LINE );
        super.setRolloverIcon( hasPopupMenu() ? arrow : icon );
    }

    @Override
    public void setRolloverSelectedIcon(Icon icon) {
        Icon arrow = updateIcons( icon, ICON_ROLLOVER_SELECTED );
        arrowIcons.remove( ICON_ROLLOVER_SELECTED_LINE );
        super.setRolloverSelectedIcon( hasPopupMenu() ? arrow : icon );
    }

    @Override
    public void setDisabledIcon(Icon icon) {
        Icon arrow = updateIcons( icon, ICON_DISABLED );
        super.setDisabledIcon( hasPopupMenu() ? arrow : icon );
    }

    @Override
    public void setDisabledSelectedIcon(Icon icon) {
        Icon arrow = updateIcons( icon, ICON_DISABLED_SELECTED );
        super.setDisabledSelectedIcon( hasPopupMenu() ? arrow : icon );
    }

    @Override
    public void setText( String text ) {
        //does nothing
        Logger.getLogger(DropDownButton.class.getName()).log(Level.FINER, "DropDownButton cannot display text."); //NOI18N
    }

    @Override
    public String getText() {
        return null;
    }

    private class Model extends DefaultButtonModel {
        private boolean _pressed = false;

        @Override
        public void setPressed(boolean b) {
            if( _pressed || b && mouseInArrowArea)
                return;
            super.setPressed( b );
        }

        public void _press() {
            if((_pressed && isPressed()) || !isEnabled()) {
                return;
            }

            stateMask |= PRESSED + ARMED;

            fireStateChanged();
            _pressed = true;
        }

        public void _release() {
            _pressed = false;
            setArmed( false );
            setPressed( false );
            setRollover( false );
            setSelected( false );
        }

        public boolean _isPressed() {
            return _pressed;
        }

        @Override
        protected void fireStateChanged() {
            if( _pressed )
                return;
            super.fireStateChanged();
        }

        @Override
        public void setArmed(boolean b) {
            if( _pressed )
                return;
            super.setArmed(b);
        }

        @Override
        public void setEnabled(boolean b) {
            if( _pressed )
                return;
            super.setEnabled(b);
        }

        @Override
        public void setSelected(boolean b) {
            if( _pressed )
                return;
            super.setSelected(b);
        }

        @Override
        public void setRollover(boolean b) {
            if( _pressed )
                return;
            super.setRollover(b);
        }
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package com.adamk33n3r.runelite.watchdog.ui.dropdownbutton;

import javax.swing.Icon;
import javax.swing.JButton;
import javax.swing.JPopupMenu;

/**
 * Factory creating buttons with a small arrow icon that shows a popup menu when clicked.
 * The default button behavior hasn't changed except that the button doesn't
 * display any text, just the icon.
 *
 * @author S. Aubrecht
 * @since 6.11
 */
public final class DropDownButtonFactory {

    /**
     * Use this property name to assign or remove popup menu to/from buttons created by this factory,
     * e.g. <code>dropDownButton.putClientProperty( PROP_DROP_DOWN_MENU, new JPopupMenu() )</code>
     * The property value must be <code>JPopupMenu</code>, removing this property removes the arrow from the button.
     */
    public static final String PROP_DROP_DOWN_MENU = "dropDownMenu";

    /** Creates a new instance of DropDownButtonFactory */
    private DropDownButtonFactory() {
    }

    /**
     * Creates JButton with a small arrow that shows the provided popup menu when clicked.
     *
     * @param icon The default icon, cannot be null
     * @param dropDownMenu Popup menu to display when the arrow is clicked. If this parameter is null
     * then the button doesn't show any arrow and behaves like a regular JButton. It is possible to add
     * the popup menu later using PROP_DROP_DOWN_MENU client property.
     * @return A button that is capable of displaying an 'arrow' in its icon to open a popup menu.
     */
    public static JButton createDropDownButton( Icon icon, JPopupMenu dropDownMenu ) {
        return new DropDownButton( icon, dropDownMenu );
    }

    /**
     * Creates JToggleButton with a small arrow that shows the provided popup menu when clicked.
     *
     * @param icon The default icon, cannot be null
     * @param dropDownMenu Popup menu to display when the arrow is clicked. If this parameter is null
     * then the button doesn't show any arrow and behaves like a regular JToggleButton. It is possible to add
     * the popup menu later using PROP_DROP_DOWN_MENU client property.
     * @return A toggle-button that is capable of displaying an 'arrow' in its icon to open a popup menu.
     */
//    public static JToggleButton createDropDownToggleButton( Icon icon, JPopupMenu dropDownMenu ) {
//        return new DropDownToggleButton( icon, dropDownMenu );
//    }

    /**
     * Get a dropdown button icon that is identical to those used in the dropdown buttons returned
     * by other methods in this class. The returned icon scales properly on HiDPI screens.
     *
     * @since 7.74
     * @param disabled whether to get a disabled version of the icon or not
     * @return a dropdown arrow icon
     */
    public static Icon getArrowIcon(boolean disabled) {
        return disabled ? IconWithArrow.ArrowIcon.INSTANCE_DEFAULT : IconWithArrow.ArrowIcon.INSTANCE_DISABLED;
    }
}

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package com.adamk33n3r.runelite.watchdog.ui.dropdownbutton;

import javax.swing.Icon;
import javax.swing.UIManager;
import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Path2D;

/**
 * An icon that paints a small arrow to the right of the provided icon.
 *
 * @author S. Aubrecht
 * @since 6.11
 */
class IconWithArrow implements Icon {
    private Icon orig;
    private Icon arrow;
    private boolean paintRollOver;

    private static final int GAP = 6;

    /** Creates a new instance of IconWithArrow */
    public IconWithArrow(  Icon orig, boolean paintRollOver, boolean disabledArrow ) {
        this.orig = orig;
        this.paintRollOver = paintRollOver;
        this.arrow = disabledArrow ? ArrowIcon.INSTANCE_DISABLED : ArrowIcon.INSTANCE_DEFAULT;
    }

    @Override
    public void paintIcon( Component c, Graphics g, int x, int y ) {
        int height = getIconHeight();
        orig.paintIcon( c, g, x, y+(height-orig.getIconHeight())/2 );

        arrow.paintIcon( c, g, x+GAP+orig.getIconWidth(), y+(height-arrow.getIconHeight())/2 );

        if( paintRollOver ) {
            Color brighter = UIManager.getColor( "controlHighlight" ); //NOI18N
            Color darker = UIManager.getColor( "controlShadow" ); //NOI18N
            if( null == brighter || null == darker ) {
                brighter = c.getBackground().brighter();
                darker = c.getBackground().darker();
            }
            if( null != brighter && null != darker ) {
                g.setColor( brighter );
                g.drawLine( x+orig.getIconWidth()+1, y,
                    x+orig.getIconWidth()+1, y+getIconHeight() );
                g.setColor( darker );
                g.drawLine( x+orig.getIconWidth()+2, y,
                    x+orig.getIconWidth()+2, y+getIconHeight() );
            }
        }
    }

    @Override
    public int getIconWidth() {
        return orig.getIconWidth() + GAP + arrow.getIconWidth();
    }

    @Override
    public int getIconHeight() {
        return Math.max( orig.getIconHeight(), arrow.getIconHeight() );
    }

    public static int getArrowAreaWidth() {
        return GAP/2 + 5;
    }

    static class ArrowIcon extends VectorIcon {
        public static final Icon INSTANCE_DEFAULT = new ArrowIcon(false);
        public static final Icon INSTANCE_DISABLED = new ArrowIcon(true);
        private final boolean disabled;

        private ArrowIcon(boolean disabled) {
            super(5, 4);
            this.disabled = disabled;
        }

        @Override
        protected void paintIcon(Component c, Graphics2D g, int width, int height, double scaling) {
            final Color color;
            if (UIManager.getBoolean("nb.dark.theme")) {
                // Foreground brightness level taken from the combobox dropdown on Darcula.
                color = disabled ? new Color(90, 90, 90, 255) : new Color(187, 187, 187, 255);
            } else {
                color = disabled ? new Color(201, 201, 201, 255) : new Color(86, 86, 86, 255);
            }
            g.setColor(color);
            final double overshoot = 2.0 / scaling;
            final double arrowWidth = width + overshoot * scaling;
            final double arrowHeight = height - 0.2 * scaling;
            final double arrowMidX = arrowWidth / 2.0 - (overshoot / 2.0) * scaling;
            g.clipRect(0, 0, width, height);
            Path2D.Double arrowPath = new Path2D.Double();
            arrowPath.moveTo(arrowMidX - arrowWidth / 2.0, 0);
            arrowPath.lineTo(arrowMidX, arrowHeight);
            arrowPath.lineTo(arrowMidX + arrowWidth / 2.0, 0);
            arrowPath.closePath();
            g.fill(arrowPath);
        }
    }
}
/*
 * Adapted from net.runelite.client.plugins.config.PluginToggleButton
 */

package com.adamk33n3r.runelite.watchdog.ui;

import net.runelite.client.plugins.config.ConfigPlugin;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

import javax.swing.ImageIcon;
import javax.swing.JToggleButton;
import java.awt.Dimension;
import java.awt.image.BufferedImage;

public class ToggleButton extends JToggleButton {
    private static final ImageIcon ON_SWITCHER;
    private static final ImageIcon OFF_SWITCHER;
    private final String selectedTooltip;
    private final String unSelectedTooltip;

    static {
        BufferedImage onSwitcher = ImageUtil.loadImageResource(ConfigPlugin.class, "switcher_on.png");
        ON_SWITCHER = new ImageIcon(onSwitcher);
        OFF_SWITCHER = new ImageIcon(ImageUtil.flipImage(
            ImageUtil.luminanceScale(
                ImageUtil.grayscaleImage(onSwitcher),
                0.61f
            ),
            true,
            false
        ));
    }

    public ToggleButton() {
        this("Disable alert", "Enable alert");
    }

    public ToggleButton(String selectedTooltip, String unSelectedTooltip) {
        super(OFF_SWITCHER);
        this.selectedTooltip = selectedTooltip;
        this.unSelectedTooltip = unSelectedTooltip;
        this.setSelectedIcon(ON_SWITCHER);
        SwingUtil.removeButtonDecorations(this);
        this.setPreferredSize(new Dimension(25, 0));
        this.addItemListener(l -> this.updateTooltip());
        this.updateTooltip();
    }

    private void updateTooltip() {
        this.setToolTipText(this.isSelected() ? this.selectedTooltip :  this.unSelectedTooltip);
    }
}


package com.adamk33n3r.runelite.watchdog.ui;

import net.runelite.client.ui.ColorScheme;

import lombok.Getter;

import javax.swing.*;
import javax.swing.text.Document;
import java.awt.*;
import java.awt.event.*;

/**
 * This component is a JTextArea with a flat design look.
 */
@Getter
public class FlatTextArea extends JPanel {
    protected final PlaceholderTextArea textArea;

    //the default background color, this needs to be stored for hover effects
    protected Color backgroundColor = ColorScheme.DARKER_GRAY_COLOR;

    //the default hover background color, this needs to be stored for hover effects
    protected Color hoverBackgroundColor;

    // the input can be blocked (no clicking, no editing, no hover effects)
    protected boolean blocked;

    public FlatTextArea(String placeholder) {
        this(placeholder, false);
    }

    public FlatTextArea(String placeholder, boolean preventNewline) {
        this.setLayout(new BorderLayout());
//        this.setBorder(new EmptyBorder(0, 10, 0, 0));
        this.setBackground(this.backgroundColor);
//        setBorder(null);

        this.textArea = new PlaceholderTextArea();
        this.textArea.setPlaceholder(placeholder);
//        this.textArea.setBorder(null);
        this.textArea.setOpaque(false);
        this.textArea.setSelectedTextColor(Color.WHITE);
        this.textArea.setSelectionColor(ColorScheme.BRAND_ORANGE_TRANSPARENT);
        this.textArea.setLineWrap(true);
        this.textArea.setWrapStyleWord(true);
        this.textArea.setMargin(new Insets(4, 6, 5, 6));

        this.add(textArea, BorderLayout.CENTER);

        textArea.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent mouseEvent) {
                if (blocked) {
                    return;
                }

                if (hoverBackgroundColor != null) {
                    setBackground(hoverBackgroundColor, false);
                }
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent) {
                setBackground(backgroundColor);
            }
        });

        this.setUpKeymaps(preventNewline);
    }

    protected void setUpKeymaps(boolean preventNewline) {
        this.setUpKeymaps(preventNewline, this.textArea);
    }

    protected void setUpKeymaps(boolean preventNewline, PlaceholderTextArea textArea) {
        KeyStroke enterKey = KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0);
        KeyStroke tabKey = KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0);
        InputMap inputMap = textArea.getInputMap(JComponent.WHEN_FOCUSED);
        ActionMap actionMap = textArea.getActionMap();
        if (preventNewline) {
            inputMap.put(enterKey, enterKey.toString());
            actionMap.put(enterKey.toString(), new AbstractAction() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    JTextArea textArea = (JTextArea) e.getSource();
                    textArea.getParent().getParent().requestFocusInWindow();
                }
            });
        }
        inputMap.put(tabKey, tabKey.toString());
        actionMap.put(tabKey.toString(), new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                KeyboardFocusManager.getCurrentKeyboardFocusManager().focusNextComponent();
            }
        });
    }

    public String getText()
    {
        return this.textArea.getText();
    }

    public void setText(String text)
    {
        this.textArea.setText(text);
    }

    @Override
    public void setToolTipText(String tooltipText) {
        this.textArea.setToolTipText(tooltipText);
    }

    @Override
    public void addKeyListener(KeyListener keyListener)
    {
        this.textArea.addKeyListener(keyListener);
    }

    @Override
    public void removeKeyListener(KeyListener keyListener)
    {
        this.textArea.removeKeyListener(keyListener);
    }

    @Override
    public void setBackground(Color color)
    {
        this.setBackground(color, true);
    }

    @Override
    public boolean requestFocusInWindow()
    {
        return this.textArea.requestFocusInWindow();
    }

    public void setBackground(Color color, boolean saveColor)
    {
        if (color == null)
        {
            return;
        }

        super.setBackground(color);

        if (saveColor)
        {
            this.backgroundColor = color;
        }
    }

    public void setHoverBackgroundColor(Color color)
    {
        if (color == null)
        {
            return;
        }

        this.hoverBackgroundColor = color;
    }

    public void setEditable(boolean editable)
    {
        this.blocked = !editable;
        this.textArea.setEditable(editable);
        this.textArea.setFocusable(editable);
        if (!editable)
        {
            super.setBackground(this.backgroundColor);
        }
    }

    public Document getDocument()
    {
        return this.textArea.getDocument();
    }

}

package com.adamk33n3r.runelite.watchdog.ui;

import javax.swing.JTextArea;
import javax.swing.text.DefaultCaret;

public class WrappingLabel extends JTextArea {
    public WrappingLabel(String text) {
        super();

        this.setOpaque(false);
        this.setEditable(false);
        this.setFocusable(false);
        this.setLineWrap(true);
        this.setWrapStyleWord(true);

        // Need to update this before setting the text, or it will cause the scroll pane to scroll to this component
        ((DefaultCaret)this.getCaret()).setUpdatePolicy(DefaultCaret.NEVER_UPDATE);
        this.setText(text);
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import java.awt.*;
import java.util.function.Function;

/**
 * Modified DynamicGridLayout to not resize components vertically.
 */
public class StretchedStackedLayout extends GridLayout
{
    public StretchedStackedLayout(int vgap)
    {
        super(0, 1, 0, vgap);
    }

    @Override
    public Dimension preferredLayoutSize(Container parent)
    {
        synchronized (parent.getTreeLock())
        {
            return calculateSize(parent, Component::getPreferredSize);
        }
    }

    @Override
    public Dimension minimumLayoutSize(Container parent)
    {
        synchronized (parent.getTreeLock())
        {
            return calculateSize(parent, Component::getMinimumSize);
        }
    }

    @Override
    public void layoutContainer(Container parent)
    {
        synchronized (parent.getTreeLock())
        {
            final Insets insets = parent.getInsets();
            final int ncomponents = parent.getComponentCount();
            int nrows = getRows();
            int ncols = getColumns();

            if (ncomponents == 0)
            {
                return;
            }

            if (nrows > 0)
            {
                ncols = (ncomponents + nrows - 1) / nrows;
            }
            else
            {
                nrows = (ncomponents + ncols - 1) / ncols;
            }

            final int hgap = getHgap();
            final int vgap = getVgap();

            // scaling factors
            final Dimension pd = preferredLayoutSize(parent);
            final Insets parentInsets = parent.getInsets();
            int wborder = parentInsets.left + parentInsets.right;
//            int hborder = parentInsets.top + parentInsets.bottom;
            final double sw = (1.0 * parent.getWidth() - wborder) / (pd.width - wborder);
//            final double sh = (1.0 * parent.getHeight() - hborder) / (pd.height - hborder);

            final int[] w = new int[ncols];
            final int[] h = new int[nrows];

            // calculate dimensions for all components + apply scaling
            for (int i = 0; i < ncomponents; i++)
            {
                final int r = i / ncols;
                final int c = i % ncols;
                final Component comp = parent.getComponent(i);
                final Dimension d = comp.getPreferredSize();
                d.width = (int) (sw * d.width);
//                d.height = (int) (sh * d.height);

                if (w[c] < d.width)
                {
                    w[c] = d.width;
                }

                if (h[r] < d.height)
                {
                    h[r] = d.height;
                }
            }

            // Apply new bounds to all child components
            for (int c = 0, x = insets.left; c < ncols; c++)
            {
                for (int r = 0, y = insets.top; r < nrows; r++)
                {
                    int i = r * ncols + c;

                    if (i < ncomponents)
                    {
                        parent.getComponent(i).setBounds(x, y, w[c], h[r]);
                    }

                    y += h[r] + vgap;
                }

                x += w[c] + hgap;
            }
        }
    }

    /**
     * Calculate outer size of the layout based on it's children and sizer
     * @param parent parent component
     * @param sizer functioning returning dimension of the child component
     * @return outer size
     */
    private Dimension calculateSize(final Container parent, final Function<Component, Dimension> sizer)
    {
        final int ncomponents = parent.getComponentCount();
        int nrows = getRows();
        int ncols = getColumns();

        if (nrows > 0)
        {
            ncols = (ncomponents + nrows - 1) / nrows;
        }
        else
        {
            nrows = (ncomponents + ncols - 1) / ncols;
        }

        final int[] w = new int[ncols];
        final int[] h = new int[nrows];

        // Calculate dimensions for all components
        for (int i = 0; i < ncomponents; i++)
        {
            final int r = i / ncols;
            final int c = i % ncols;
            final Component comp = parent.getComponent(i);
            final Dimension d = sizer.apply(comp);

            if (w[c] < d.width)
            {
                w[c] = d.width;
            }

            if (h[r] < d.height)
            {
                h[r] = d.height;
            }
        }

        // Calculate total width and height of the layout
        int nw = 0;

        for (int j = 0; j < ncols; j++)
        {
            nw += w[j];
        }

        int nh = 0;

        for (int i = 0; i < nrows; i++)
        {
            nh += h[i];
        }

        final Insets insets = parent.getInsets();

        // Apply insets and horizontal and vertical gap to layout
        return new Dimension(
            insets.left + insets.right + nw + (ncols - 1) * getHgap(),
            insets.top + insets.bottom + nh + (nrows - 1) * getVgap());
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.LengthLimitFilter;
import com.adamk33n3r.runelite.watchdog.SimpleDocumentListener;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.elevenlabs.ElevenLabs;
import com.adamk33n3r.runelite.watchdog.elevenlabs.Voice;
import com.adamk33n3r.runelite.watchdog.notifications.TextToSpeech;
import com.adamk33n3r.runelite.watchdog.notifications.tts.TTSSource;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.notifications.VoiceChooser;
import com.adamk33n3r.runelite.watchdog.ui.notifications.VolumeSlider;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.Font;

@Slf4j
public class TextToSpeechNotificationPanel extends NotificationPanel {
    public TextToSpeechNotificationPanel(TextToSpeech notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);

        this.rebuild();
    }

    private void rebuild() {
        this.settings.removeAll();

        TextToSpeech notification = (TextToSpeech) this.notification;

        if (!WatchdogPlugin.getInstance().getConfig().ttsEnabled()) {
            JLabel ttsLabel = new JLabel("<html>Enable TTS in the config to use this Notification type</html>");
            ttsLabel.setFont(new Font(ttsLabel.getFont().getFontName(), Font.ITALIC | Font.BOLD, ttsLabel.getFont().getSize()));
            this.settings.add(ttsLabel);
            JButton settingsBtn = new JButton("Open Config");
            settingsBtn.addActionListener(ev -> WatchdogPlugin.getInstance().openConfiguration());
            this.settings.add(settingsBtn);
            return;
        }

        FlatTextArea messageTextArea = PanelUtils.createTextField(
            "Enter your message...",
            "The message to play",
            notification.getMessage(),
            val -> {
                notification.setMessage(val);
                onChangeListener.run();
            });
        this.settings.add(messageTextArea);

        JComboBox<TTSSource> sourceSelect = PanelUtils.createSelect(TTSSource.values(), notification.getSource(), (selected) -> {
            notification.setSource(selected);
            onChangeListener.run();
            this.rebuild();
            this.revalidate();
        });
        this.settings.add(sourceSelect);

        switch (notification.getSource()) {
            case ELEVEN_LABS:
                if (WatchdogPlugin.getInstance().getConfig().elevenLabsAPIKey().isEmpty()) {
                    JLabel ttsLabel = new JLabel("<html>Add your API key in the config to use Eleven Labs</html>");
                    ttsLabel.setFont(new Font(ttsLabel.getFont().getFontName(), Font.ITALIC | Font.BOLD, ttsLabel.getFont().getSize()));
                    this.settings.add(ttsLabel);
                    JButton settingsBtn = new JButton("Open Config");
                    settingsBtn.addActionListener(ev -> WatchdogPlugin.getInstance().openConfiguration());
                    this.settings.add(settingsBtn);
                    return;
                }
                JComboBox<Voice> voiceSelect = PanelUtils.createSelect(new Voice[]{}, null, Voice::getName, "Loading...", (voice) -> {
                    notification.setElevenLabsVoiceId(voice.getVoiceId());
                    //Not serialized
                    notification.setElevenLabsVoice(voice);
                });

                ElevenLabs.getVoices(WatchdogPlugin.getInstance().getHttpClient(), (voices) -> {
                    SwingUtilities.invokeLater(() -> {
                        // Store the voice id prior to adding to the list because adding the first item will select it
                        String elevenLabsVoiceId = notification.getElevenLabsVoiceId();
                        voices.getVoices().forEach((voice) -> {
                            voiceSelect.addItem(voice);
                            if (elevenLabsVoiceId == null) {
                                if (voice.getName().equals(WatchdogPlugin.getInstance().getConfig().defaultElevenLabsVoice())) {
                                    voiceSelect.setSelectedItem(voice);
                                }
                            } else {
                                if (voice.getVoiceId().equals(elevenLabsVoiceId)) {
                                    voiceSelect.setSelectedItem(voice);
                                }
                            }
                        });
                    });
                }, log::error);
                this.settings.add(voiceSelect);
                break;
            case LEGACY:
                JLabel deprecatedWarning = new JLabel("<html>The Legacy TTS API is deprecated and will likely be removed in the future.</html>");
                this.settings.add(deprecatedWarning);
                JSlider rateSlider = new JSlider(1, 5, notification.getRate());
                rateSlider.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
                rateSlider.addChangeListener(ev -> {
                    notification.setRate(rateSlider.getValue());
                    onChangeListener.run();
                });
                this.settings.add(PanelUtils.createIconComponent(Icons.SPEED, "The speed of the generated speech", rateSlider));

                VoiceChooser voiceChooser = new VoiceChooser(notification);
                voiceChooser.addActionListener(e -> onChangeListener.run());
                this.settings.add(PanelUtils.createIconComponent(Icons.SPEECH, "The voice to generate speech with", voiceChooser));
                break;
        }

        VolumeSlider volumeSlider = new VolumeSlider(notification);
        volumeSlider.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
        volumeSlider.addChangeListener(e -> onChangeListener.run());
        this.settings.add(PanelUtils.createIconComponent(Icons.VOLUME, "The volume to playback speech", volumeSlider));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.WatchdogProperties;
import com.adamk33n3r.runelite.watchdog.notifications.SoundEffect;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.notifications.VolumeSlider;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.plugins.info.JRichTextPane;
import net.runelite.client.ui.ColorScheme;

import javax.swing.JSpinner;

public class SoundEffectNotificationPanel extends NotificationPanel {

    public SoundEffectNotificationPanel(SoundEffect soundEffect, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(soundEffect, parentPanel, onChangeListener, onRemove);

        JRichTextPane richTextPane = new JRichTextPane();
        richTextPane.setContentType("text/html");
        richTextPane.setText("<html>Go to <a href='" + WatchdogProperties.getProperties().getProperty("watchdog.wikiPage.soundIDs") +
            "'>this wiki page</a> to get a list<br>of sound ids.</html>");
        this.settings.add(richTextPane);
        JSpinner soundID = PanelUtils.createSpinner(soundEffect.getSoundID(), 0, 99999, 1, (val) -> {
            soundEffect.setSoundID(val);
            onChangeListener.run();
        });
        this.settings.add(soundID);

        VolumeSlider volumeSlider = new VolumeSlider(soundEffect);
        volumeSlider.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
        volumeSlider.addChangeListener(e -> onChangeListener.run());
        this.settings.add(PanelUtils.createIconComponent(
            Icons.VOLUME,
            "The volume to playback sound effect",
            volumeSlider
        ));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.notifications.objectmarkers.ObjectMarker;
import com.adamk33n3r.runelite.watchdog.notifications.objectmarkers.ObjectMarkerManager;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

import javax.swing.*;
import java.awt.*;

public class ObjectMarkerNotificationPanel extends NotificationPanel {
    private JButton setMarkerButton;
    private JPanel displayTime;
    private JPanel stickyId;

    public ObjectMarkerNotificationPanel(ObjectMarker notification, NotificationsPanel parentPanel, ColorPickerManager colorPickerManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);

        this.setMarkerButton = PanelUtils.createButton("Set Marker", "Set Marker", (btn, modifiers) -> {
            ObjectMarkerManager objectMarkerManager = WatchdogPlugin.getInstance().getObjectMarkerManager();
            // Done
            if (objectMarkerManager.isInObjectMarkerMode()) {
                this.setMarkerButton.setText("Set Marker");
                this.setMarkerButton.setToolTipText("Set Marker");
                objectMarkerManager.turnOffObjectMarkerMode();
                onChangeListener.run();
            // Start
            } else {
                this.setMarkerButton.setText("Finish");
                this.setMarkerButton.setToolTipText("Finish");
                objectMarkerManager.turnOnObjectMarkerMode(notification);
            }
        });
        this.settings.add(this.setMarkerButton);

        this.settings.add(PanelUtils.createColorPicker(
            "Border Color",
            "The color of the border",
            "Border Color",
            this,
            notification.getBorderColor(),
            colorPickerManager,
            true,
            val -> {
                notification.setBorderColor(val);
                onChangeListener.run();
            }));

        this.settings.add(PanelUtils.createColorPicker(
            "Fill Color",
            "The color of the interior",
            "Fill Color",
            this,
            notification.getFillColor(),
            colorPickerManager,
            true,
            val -> {
                notification.setFillColor(val);
                onChangeListener.run();
            }));

        JPanel checkboxes = new JPanel(new GridLayout(2, 2, 5, 5));
        checkboxes.add(PanelUtils.createCheckbox("Hull", "Render Hull", notification.isHull(), val -> {
            notification.setHull(val);
            onChangeListener.run();
        }));
        checkboxes.add(PanelUtils.createCheckbox("Outline", "Render Outline", notification.isOutline(), val -> {
            notification.setOutline(val);
            onChangeListener.run();
        }));
        checkboxes.add(PanelUtils.createCheckbox("Clickbox", "Render Clickbox", notification.isClickbox(), val -> {
            notification.setClickbox(val);
            onChangeListener.run();
        }));
        checkboxes.add(PanelUtils.createCheckbox("Tile", "Render Tile", notification.isTile(), val -> {
            notification.setTile(val);
            onChangeListener.run();
        }));
        checkboxes.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        this.settings.add(checkboxes);

        JPanel feather = PanelUtils.createIconComponent(Icons.FEATHER, "Specify between 0-4 how much of the model outline should be faded.",
            PanelUtils.createSpinner(notification.getOutlineFeather(), 0, 4, 1, val -> {
                notification.setOutlineFeather(val);
                onChangeListener.run();
            }));
        this.settings.add(feather);

        JSpinner thickness = PanelUtils.createSpinnerDouble(
            notification.getBorderWidth(),
            0,
            200,
            0.1d,
            val -> {
                notification.setBorderWidth(val);
                onChangeListener.run();
            }
        );

        JPanel borderThickness = PanelUtils.createIconComponent(Icons.BORDER_OUTSIDE, "Width of the marked object border.", thickness);
        JPanel sub = new JPanel(new GridLayout(1, 2, 3, 3));
        sub.add(borderThickness);
        sub.add(feather);
        sub.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        this.settings.add(sub);

        JPanel stickySub = new JPanel(new GridLayout(1, 2, 3, 3));
        stickySub.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        this.settings.add(stickySub);

        JCheckBox sticky = PanelUtils.createCheckbox("Sticky", "Set the notification to not expire", notification.isSticky(), val -> {
            notification.setSticky(val);
            if (val) {
                stickySub.remove(this.displayTime);
                stickySub.add(this.stickyId);
            } else {
                stickySub.remove(this.stickyId);
                stickySub.add(this.displayTime);
            }
            stickySub.revalidate();
            stickySub.repaint();
            onChangeListener.run();
        });
        stickySub.add(sticky);

        JSpinner displayTime = PanelUtils.createSpinner(notification.getDisplayTime(), 0, 99, 1, val -> {
            notification.setDisplayTime(val);
            onChangeListener.run();
        });
        this.displayTime = PanelUtils.createIconComponent(Icons.CLOCK, "Time to display the marker in seconds.", displayTime);

        this.stickyId = PanelUtils.createTextArea(
            "ID to use with Dismiss Object Marker...",
            "",
            notification.getId(),
            val -> {
                notification.setId(val);
                onChangeListener.run();
            }
        );

        if (notification.isSticky()) {
            stickySub.add(this.stickyId);
        } else {
            stickySub.add(this.displayTime);
        }
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.RequestFocus;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import javax.swing.JCheckBox;

public class RequestFocusNotificationPanel extends NotificationPanel {
    public RequestFocusNotificationPanel(RequestFocus notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);

        JCheckBox force = PanelUtils.createCheckbox(
            "Force",
            "Force window focus (bring to foreground)",
            notification.isForceFocus(),
            (val) -> {
                notification.setForceFocus(val);
                onChangeListener.run();
            }
        );
        this.settings.add(force);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.DismissObjectMarker;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

public class DismissObjectMarkerNotificationPanel extends NotificationPanel {
    public DismissObjectMarkerNotificationPanel(DismissObjectMarker notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);

        FlatTextArea flatTextArea = PanelUtils.createTextField(
            "Enter the ID of the object marker...",
            "This is set in the Object Marker notification when set to Sticky.",
            notification.getDismissId(),
            val -> {
                notification.setDismissId(val);
                onChangeListener.run();
            }
        );
        this.settings.add(flatTextArea);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.Overhead;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.components.ColorJButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

import javax.swing.JSpinner;

public class OverheadNotificationPanel extends MessageNotificationPanel {
    public OverheadNotificationPanel(Overhead notification, NotificationsPanel parentPanel, ColorPickerManager colorPickerManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, true, parentPanel, onChangeListener, onRemove);

        ColorJButton colorPickerBtn = PanelUtils.createColorPicker(
            "Pick a color",
            "The color of the overhead text. Right click to reset.",
            "Text Color",
            this,
            notification.getTextColor(),
            colorPickerManager,
            false,
            val -> {
                notification.setTextColor(val);
                onChangeListener.run();
            });
        this.settings.add(colorPickerBtn);

        JSpinner displayTime = PanelUtils.createSpinner(notification.getDisplayTime(), 1, 99, 1, val -> {
            notification.setDisplayTime(val);
            onChangeListener.run();
        });
        this.settings.add(PanelUtils.createIconComponent(Icons.CLOCK, "Time to display overhead in seconds", displayTime));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.Overlay;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.ColorJButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

import javax.swing.JFileChooser;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import java.awt.*;

public class OverlayNotificationPanel extends MessageNotificationPanel {
    private JPanel displayTime;
    private JPanel stickyId;

    public OverlayNotificationPanel(Overlay notification, NotificationsPanel parentPanel, ColorPickerManager colorPickerManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, true, parentPanel, onChangeListener, onRemove);

        ColorJButton fgColorPicker = PanelUtils.createColorPicker(
            "Pick a color",
            "The text color of the notification",
            "Text Color",
            this,
            notification.getTextColor(),
            colorPickerManager,
            false,
            val -> {
                notification.setTextColor(val);
                onChangeListener.run();
            }
        );
        this.settings.add(fgColorPicker);

        ColorJButton colorPicker = PanelUtils.createColorPicker(
            "Pick a color",
            "The background color of the notification",
            "Background Color",
            this,
            notification.getColor(),
            colorPickerManager,
            true,
            val -> {
                notification.setColor(val);
                onChangeListener.run();
            }
        );
        this.settings.add(colorPicker);

        this.settings.add(PanelUtils.createFileChooser(null, "Path to the image file", ev -> {
            JFileChooser fileChooser = (JFileChooser) ev.getSource();
            notification.setImagePath(fileChooser.getSelectedFile().getAbsolutePath());
            onChangeListener.run();
        }, notification.getImagePath(), "Image Files", "png", "jpg"));

        JPanel checkboxes = new JPanel(new GridLayout(1, 2, 5, 5));
        checkboxes.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        var resizeImageCheckbox = PanelUtils.createCheckbox("Resize Image", "Resize the image to a standard size", notification.isResizeImage(), val -> {
            notification.setResizeImage(val);
            onChangeListener.run();
        });
        checkboxes.add(resizeImageCheckbox);

        var stickyCheckbox = PanelUtils.createCheckbox("Sticky", "Set the notification to not expire", notification.isSticky(), val -> {
            notification.setSticky(val);
            if (val) {
                this.settings.remove(this.displayTime);
                this.settings.add(this.stickyId);
            } else {
                this.settings.remove(this.stickyId);
                this.settings.add(this.displayTime);
            }
            this.revalidate();
            onChangeListener.run();
        });
        checkboxes.add(stickyCheckbox);
        this.settings.add(checkboxes);

        JSpinner displayTime = PanelUtils.createSpinner(notification.getTimeToLive(), 1, 999, 1, val -> {
            notification.setTimeToLive(val);
            onChangeListener.run();
        });
        this.displayTime = PanelUtils.createIconComponent(Icons.CLOCK, "Time to display in seconds", displayTime);

        this.stickyId = PanelUtils.createTextField(
            "ID to use with Dismiss Overlay...",
            "",
            notification.getId(),
            val -> {
                notification.setId(val);
                onChangeListener.run();
            }
        );

        if (notification.isSticky()) {
            this.settings.add(this.stickyId);
        } else {
            this.settings.add(this.displayTime);
        }
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.Sound;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.notifications.VolumeSlider;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.ColorScheme;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioSystem;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JSpinner;
import java.util.Arrays;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class SoundNotificationPanel extends NotificationPanel {

    public SoundNotificationPanel(Sound sound, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(sound, parentPanel, onChangeListener, onRemove);

        String[] supportedExtensions = Stream.concat(
            Arrays.stream(AudioSystem.getAudioFileTypes())
                .map(AudioFileFormat.Type::getExtension),
            Stream.of("mp3")
        ).toArray(String[]::new);
        this.settings.add(new JLabel("Choose sound (" + Arrays.stream(supportedExtensions).map(ext -> '.' + ext).collect(Collectors.joining(", ")) + ")"));
        this.settings.add(PanelUtils.createFileChooser(null, "Path to the sound file", ev -> {
            JFileChooser fileChooser = (JFileChooser) ev.getSource();
            sound.setPath(fileChooser.getSelectedFile().getAbsolutePath());
            onChangeListener.run();
        }, sound.getPath(), "Sound Files", supportedExtensions));

        VolumeSlider volumeSlider = new VolumeSlider(sound);
        volumeSlider.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
        volumeSlider.addChangeListener(e -> onChangeListener.run());
        this.settings.add(PanelUtils.createIconComponent(Icons.VOLUME, "The volume to playback sound", volumeSlider));

        JSpinner repeatDuration = PanelUtils.createSpinner(sound.getRepeatDuration(), -1, 120, 1, val -> {
            sound.setRepeatDuration(val);
            onChangeListener.run();
        });
        this.settings.add(PanelUtils.createIconComponent(Icons.CLOCK, "Duration to repeat sound, use -1 to repeat until cancelled", repeatDuration));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.DismissOverlay;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

public class DismissOverlayNotificationPanel extends NotificationPanel {
    public DismissOverlayNotificationPanel(DismissOverlay notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);

        FlatTextArea flatTextArea = PanelUtils.createTextField(
            "Enter the ID of the overlay...",
            "This is set in the Overlay notification when set to Sticky.",
            notification.getDismissId(),
            val -> {
                notification.setDismissId(val);
                onChangeListener.run();
            }
        );
        this.settings.add(flatTextArea);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.Popup;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;
import net.runelite.client.ui.components.ColorJButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

import java.awt.*;

public class PopupNotificationPanel extends MessageNotificationPanel {
    public PopupNotificationPanel(Popup notification, NotificationsPanel parentPanel, ColorPickerManager colorPickerManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, true, parentPanel, onChangeListener, onRemove);

        Component message = this.settings.getComponent(0);
        this.settings.remove(message);

        FlatTextArea title = PanelUtils.createTextArea(
            "Title. Empty uses the alert's name.",
            "The title of the popup. Leave empty to use the alert's name. Also supports formatting and capture groups.",
            notification.getTitle(),
            notification::setTitle
        );

        this.settings.add(title);
        this.settings.add(message);

        ColorJButton textColorPicker = PanelUtils.createColorPicker(
            "Pick a color",
            "The text color of the notification",
            "Text Color",
            this,
            notification.getTextColor(),
            colorPickerManager,
            false,
            val -> {
                notification.setTextColor(val);
                onChangeListener.run();
            }
        );
        this.settings.add(textColorPicker);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.PluginToggle;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.util.Comparator;

@Slf4j
public class PluginToggleNotificationPanel extends NotificationPanel {
    private final PluginManager pluginManager;
    public PluginToggleNotificationPanel(PluginToggle notification, NotificationsPanel parentPanel, PluginManager pluginManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);
        this.pluginManager = pluginManager;

        this.rebuild();
    }

    private void rebuild() {
        this.settings.removeAll();

        PluginToggle notification = (PluginToggle) this.notification;

        JComboBox<PluginToggle.ToggleMode> modeSelect = PanelUtils.createSelect(PluginToggle.ToggleMode.values(), notification.getMode(), (selected) -> {
            notification.setMode(selected);
            onChangeListener.run();
            this.rebuild();
        });
        JPanel mode = PanelUtils.createLabeledComponent("Mode", "The toggle mode plugin", modeSelect);
        mode.setBorder(null);
        mode.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        this.settings.add(mode);

        Plugin[] plugins = this.pluginManager.getPlugins()
            .stream().sorted(Comparator.comparing(Plugin::getName))
            .toArray(Plugin[]::new);
        Plugin selectedPlugin = notification.getPluginName() == null ? null : this.pluginManager.getPlugins().stream()
            .filter(p -> p.getName().equals(notification.getPluginName()))
            .findFirst()
            .orElse(null);
        JComboBox<Plugin> pluginSelect = PanelUtils.createSelect(plugins, selectedPlugin, Plugin::getName, "Select a plugin...", (selected) -> {
            log.debug("Setting plugin to toggle to {}", selected.getName());
            notification.setPluginName(selected.getName());
        });
        this.settings.add(pluginSelect);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.alerts.FlashMode;
import com.adamk33n3r.runelite.watchdog.notifications.ScreenFlash;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.components.ColorJButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

import javax.swing.DefaultListCellRenderer;
import javax.swing.JComboBox;
import javax.swing.JSpinner;

public class ScreenFlashNotificationPanel extends NotificationPanel {
    public ScreenFlashNotificationPanel(ScreenFlash screenFlash, NotificationsPanel parentPanel, ColorPickerManager colorPickerManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(screenFlash, parentPanel, onChangeListener, onRemove);

        ColorJButton colorPickerBtn = PanelUtils.createColorPicker(
            "Pick a color",
            "The color to flash the screen",
            "Flash Color",
            this,
            screenFlash.getColor(),
            colorPickerManager,
            true,
            val -> {
                screenFlash.setColor(val);
                onChangeListener.run();
            });
        this.settings.add(colorPickerBtn);

        JComboBox<FlashMode> flashModeSelect = new JComboBox<>(FlashMode.values());
        flashModeSelect.setToolTipText("The screen flash mode");
        // TODO: Would be nice to move this somewhere else on import or something
        if (screenFlash.getFlashMode() == null) {
            screenFlash.setFlashMode(FlashMode.FLASH);
            if (screenFlash.getFlashDuration() == 0) {
                screenFlash.setFlashDuration(2);
            }
        }
        flashModeSelect.setSelectedItem(screenFlash.getFlashMode());
        flashModeSelect.setRenderer((list, value, index, isSelected, cellHasFocus) -> {
            list.setToolTipText(value.getTooltip());
            return new DefaultListCellRenderer().getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
        });
        flashModeSelect.addActionListener(e -> {
            screenFlash.setFlashMode(flashModeSelect.getItemAt(flashModeSelect.getSelectedIndex()));
            onChangeListener.run();
        });
        this.settings.add(flashModeSelect);

        JSpinner flashDuration = PanelUtils.createSpinner(screenFlash.getFlashDuration(), 0, 120, 1, val -> {
            screenFlash.setFlashDuration(val);
            onChangeListener.run();
        });
        this.settings.add(PanelUtils.createIconComponent(Icons.CLOCK, "Duration of flash, use 0 to flash until cancelled", flashDuration));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.DismissScreenMarker;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

public class DismissScreenMarkerNotificationPanel extends NotificationPanel {
    public DismissScreenMarkerNotificationPanel(DismissScreenMarker notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);

        FlatTextArea flatTextArea = PanelUtils.createTextField(
            "Enter the ID of the screen marker...",
            "This is set in the Screen Marker notification when set to Sticky.",
            notification.getDismissId(),
            val -> {
                notification.setDismissId(val);
                onChangeListener.run();
            }
        );
        this.settings.add(flatTextArea);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.notifications.ScreenMarker;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker.ScreenMarkerOverlay;
import com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker.ScreenMarkerUtil;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

import javax.swing.*;
import java.awt.GridLayout;

public class ScreenMarkerNotificationPanel extends NotificationPanel {
    private ScreenMarkerOverlay screenMarkerOverlay;
    private JButton setMarkerButton;
    private JPanel displayTime;
    private JPanel stickyId;

    public ScreenMarkerNotificationPanel(ScreenMarker notification, NotificationsPanel parentPanel, ColorPickerManager colorPickerManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);
        // Rebind onRemove to hook into it so that we can delete the screen marker when this notification is deleted
        // Perhaps this should be refactored
        this.onRemove = (ele) -> {
            ScreenMarkerUtil screenMarkerUtil = WatchdogPlugin.getInstance().getScreenMarkerUtil();
            if (this.screenMarkerOverlay != null) {
                screenMarkerUtil.deleteMarker(this.screenMarkerOverlay);
            }
            screenMarkerUtil.finishCreation(true);
            onRemove.elementRemoved(ele);
        };

        net.runelite.client.plugins.screenmarkers.ScreenMarker screenMarker = notification.getScreenMarker();

        this.setMarkerButton = PanelUtils.createButton("Set Marker", "Set Marker", (btn, modifiers) -> {
            ScreenMarkerUtil screenMarkerUtil = WatchdogPlugin.getInstance().getScreenMarkerUtil();
            // Done
            if (screenMarkerUtil.isCreatingScreenMarker()) {
                this.screenMarkerOverlay = screenMarkerUtil.finishCreation(false);
                this.setMarkerButton.setText("Set Marker");
                this.setMarkerButton.setToolTipText("Set Marker");
                // Start
            } else {
                if (this.screenMarkerOverlay != null) {
                    screenMarkerUtil.deleteMarker(this.screenMarkerOverlay);
                }
                screenMarkerUtil.setMouseListenerEnabled(true);
                screenMarkerUtil.setCreatingScreenMarker(true);
                screenMarkerUtil.setCurrentMarker(notification);
                this.setMarkerButton.setText("Finish");
                this.setMarkerButton.setToolTipText("Finish");
            }
        });
        this.settings.add(this.setMarkerButton);

        FlatTextArea markerLabel = PanelUtils.createTextField(
            "Optional marker label...",
            "",
            screenMarker.getName(),
            val -> {
                screenMarker.setName(val);
                screenMarker.setLabelled(!val.isEmpty());
                onChangeListener.run();
            }
        );
        this.settings.add(markerLabel);

        this.settings.add(PanelUtils.createColorPicker(
            "Border Color",
            "The color of the border",
            "Border Color",
            this,
            notification.getScreenMarker().getColor(),
            colorPickerManager,
            true,
            val -> {
               screenMarker.setColor(val);
               onChangeListener.run();
            }));

        this.settings.add(PanelUtils.createColorPicker(
            "Fill Color",
            "The color of the interior",
            "Fill Color",
            this,
            notification.getScreenMarker().getFill(),
            colorPickerManager,
            true,
            val -> {
                screenMarker.setFill(val);
                onChangeListener.run();
            }));

        JSpinner thickness = PanelUtils.createSpinner(
            screenMarker.getBorderThickness(),
            0,
            Integer.MAX_VALUE,
            1,
            val -> {
                screenMarker.setBorderThickness(val);
                onChangeListener.run();
            }
        );

        JCheckBox sticky = PanelUtils.createCheckbox("Sticky", "Set the notification to not expire", notification.isSticky(), val -> {
            notification.setSticky(val);
            if (val) {
                this.settings.remove(this.displayTime);
                this.settings.add(this.stickyId);
            } else {
                this.settings.remove(this.stickyId);
                this.settings.add(this.displayTime);
            }
            this.revalidate();
            onChangeListener.run();
        });

        JSpinner displayTime = PanelUtils.createSpinner(notification.getDisplayTime(), 0, 99, 1, val -> {
            notification.setDisplayTime(val);
            onChangeListener.run();
        });
        JPanel borderThickness = PanelUtils.createIconComponent(Icons.BORDER_OUTSIDE, "Border thickness", thickness);
        this.displayTime = PanelUtils.createIconComponent(Icons.CLOCK, "Time to display the marker in seconds.", displayTime);
        JPanel sub = new JPanel(new GridLayout(1, 2, 3, 3));
        sub.add(borderThickness);
        sub.add(sticky);
        sub.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        this.settings.add(sub);

        this.stickyId = PanelUtils.createTextField(
            "ID to use with Dismiss Screen Marker...",
            "",
            notification.getId(),
            val -> {
                notification.setId(val);
                onChangeListener.run();
            }
        );

        if (notification.isSticky()) {
            this.settings.add(this.stickyId);
        } else {
            this.settings.add(this.displayTime);
        }
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.ShortestPath;
import com.adamk33n3r.runelite.watchdog.notifications.ShortestPathMode;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;
import java.util.function.Consumer;
import java.util.function.Supplier;

public class ShortestPathNotificationPanel extends NotificationPanel {
    private final ConfigManager configManager;
    public ShortestPathNotificationPanel(ShortestPath notification, NotificationsPanel parentPanel, ConfigManager configManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);
        this.configManager = configManager;

        this.rebuild();
    }

    private void rebuild() {
        this.settings.removeAll();

        ShortestPath notification = (ShortestPath) this.notification;

        String installedPlugins = configManager.getConfiguration("runelite", "externalPlugins");
        if (!installedPlugins.contains("shortest-path")) {
            JLabel installShortestPathLabel = new JLabel("<html>Install the Shortest Path plugin to use this Notification type</html>");
            installShortestPathLabel.setFont(new Font(installShortestPathLabel.getFont().getFontName(), Font.ITALIC | Font.BOLD, installShortestPathLabel.getFont().getSize()));
            this.settings.add(installShortestPathLabel);
            return;
        }

        JComboBox<ShortestPathMode> modeSelect = PanelUtils.createSelect(ShortestPathMode.values(), notification.getMode(), (selected) -> {
            notification.setMode(selected);
            onChangeListener.run();
            this.rebuild();
        });
        JPanel mode = PanelUtils.createLabeledComponent("Mode", "The mode for the Shortest Path plugin", modeSelect);
        mode.setBorder(null);
        mode.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        this.settings.add(mode);

        if (notification.isClearMode()) {
            JLabel clearModeLabel = new JLabel("<html>Clear Mode is enabled. This will clear the Shortest Path plugin's path when this notification is fired.</html>");
            this.settings.add(clearModeLabel);
            return;
        }

        JCheckBox useCurrentLocationForStart = PanelUtils.createCheckbox("Use current location", "Use the current location as the start point", notification.isUseCurrentLocationForStart(), (selected) -> {
            notification.setUseCurrentLocationForStart(selected);
            onChangeListener.run();
            this.rebuild();
        });
        JPanel startPoint = PanelUtils.createLabeledComponent("Start", "The start point for the Shortest Path plugin", useCurrentLocationForStart);
        startPoint.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        startPoint.setBorder(null);
        this.settings.add(startPoint);
        if (!notification.isUseCurrentLocationForStart()) {
            this.settings.add(this.createPointPanel(notification::getStart, notification::setStart));
        }
        JLabel endPoint = new JLabel("End");
        endPoint.setToolTipText("The end point for the Shortest Path plugin");
        JPanel endPointPanel = PanelUtils.createLabeledComponent("End", "The end point for the Shortest Path plugin", this.createPointPanel(notification::getTarget, notification::setTarget), true);
        endPointPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        this.settings.add(endPointPanel);
    }

    private JPanel createPointPanel(Supplier<WorldPoint> worldPointSupplier, Consumer<WorldPoint> worldPointConsumer) {
        JPanel pointPanel = new JPanel(new GridLayout(1, 3, 5, 5));
        pointPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        JPanel xPos = PanelUtils.createLabeledComponent(
            "X Pos",
            "The X position",
            PanelUtils.createSpinner(worldPointSupplier.get().getX(),
                Integer.MIN_VALUE,
                Integer.MAX_VALUE,
                1,
                (val) -> worldPointConsumer.accept(worldPointSupplier.get().dx(val - worldPointSupplier.get().getX())))
            , true);
        xPos.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        JPanel yPos = PanelUtils.createLabeledComponent(
            "Y Pos",
            "The Y position",
            PanelUtils.createSpinner(worldPointSupplier.get().getY(),
                Integer.MIN_VALUE,
                Integer.MAX_VALUE,
                1,
                (val) -> worldPointConsumer.accept(worldPointSupplier.get().dy(val - worldPointSupplier.get().getY())))
            , true);
        yPos.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        JPanel plane = PanelUtils.createLabeledComponent(
            "Plane",
            "The plane number",
            PanelUtils.createSpinner(worldPointSupplier.get().getPlane(),
                Integer.MIN_VALUE,
                Integer.MAX_VALUE,
                1,
                (val) -> worldPointConsumer.accept(worldPointSupplier.get().dz(val - worldPointSupplier.get().getPlane())))
            , true);
        plane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pointPanel.add(xPos);
        pointPanel.add(yPos);
        pointPanel.add(plane);

        return pointPanel;
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.MessageNotification;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

public class MessageNotificationPanel extends NotificationPanel {
    public MessageNotificationPanel(MessageNotification notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        this(notification, false, parentPanel, onChangeListener, onRemove);
    }

    public MessageNotificationPanel(MessageNotification notification, boolean supportsFormattingTags, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);

        FlatTextArea flatTextArea = PanelUtils.createTextField(
            supportsFormattingTags ? "Enter your formatted message..." : "Enter your message...",
            "",
            notification.getMessage(),
            val -> {
                notification.setMessage(val);
                onChangeListener.run();
            }
        );
        this.settings.add(flatTextArea);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.LengthLimitFilter;
import com.adamk33n3r.runelite.watchdog.notifications.Dink;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;
import net.runelite.client.config.ConfigManager;

import javax.swing.*;
import javax.swing.text.AbstractDocument;
import java.awt.*;

public class DinkNotificationPanel extends NotificationPanel {
    private final ConfigManager configManager;

    public DinkNotificationPanel(Dink notification, NotificationsPanel parentPanel, ConfigManager configManager, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);
        this.configManager = configManager;

        this.rebuild();
    }

    private void rebuild() {
        this.settings.removeAll();

        Dink notification = (Dink) this.notification;

        String installedPlugins = configManager.getConfiguration("runelite", "externalPlugins");
        if (!installedPlugins.contains("dink")) {
            JLabel installDinkLabel = new JLabel("<html>Install the Dink plugin to use this Notification type</html>");
            installDinkLabel.setFont(new Font(installDinkLabel.getFont().getFontName(), Font.ITALIC | Font.BOLD, installDinkLabel.getFont().getSize()));
            this.settings.add(installDinkLabel);
            return;
        }

        boolean externalEnabled = configManager.getConfiguration("dinkplugin", "notifyExternal").equals("true");
        if (!externalEnabled) {
            JLabel enableExternalLabel = new JLabel("<html>Enable External Plugin Notifications in Dink's config to use this Notification type</html>");
            enableExternalLabel.setFont(new Font(enableExternalLabel.getFont().getFontName(), Font.ITALIC | Font.BOLD, enableExternalLabel.getFont().getSize()));
            this.settings.add(enableExternalLabel);
            return;
        }

        FlatTextArea flatTextArea = PanelUtils.createTextField(
            "Enter your message...",
            "",
            notification.getMessage(),
            val -> {
                notification.setMessage(val);
                onChangeListener.run();
            }
        );
        ((AbstractDocument) flatTextArea.getDocument()).setDocumentFilter(new LengthLimitFilter(4096));
        this.settings.add(flatTextArea);

        JCheckBox includeScreenshot = PanelUtils.createCheckbox("Include Screenshot", "Whether or not to include a screenshot in the discord message", notification.isIncludeScreenshot(), (selected) -> {
            notification.setIncludeScreenshot(selected);
            onChangeListener.run();
        });
        this.settings.add(includeScreenshot);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.NotificationType;
import com.adamk33n3r.runelite.watchdog.notifications.Notification;
import com.adamk33n3r.runelite.watchdog.ui.Icons;
import com.adamk33n3r.runelite.watchdog.ui.StretchedStackedLayout;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.MouseDragEventForwarder;

import lombok.Getter;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

public abstract class NotificationPanel extends JPanel {
    // worldhopper - arrow down
    // screenmarker - border color icon - pencil
    // screenmarker/timetracking - delete icon - X
    // timetracking - notify - bell
    // timetracking - reset - circle arrow - used for in-focus?
    // timetracking - start - right chevron
    // loottracker - back arrow
    // loottracker - collapsed/expanded
    // info - import cloud
    // info - github
    // config - edit/back

    @Getter
    protected Notification notification;
    private final NotificationsPanel parentPanel;
    protected Runnable onChangeListener;
    protected PanelUtils.OnRemove onRemove;
    protected JPanel settings = new JPanel(new StretchedStackedLayout(3));

    private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
        BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
        BorderFactory.createMatteBorder(5, 10, 5, 0, ColorScheme.DARKER_GRAY_COLOR));

    public NotificationPanel(Notification notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        this.notification = notification;
        this.parentPanel = parentPanel;
        this.onChangeListener = onChangeListener;
        this.onRemove = onRemove;

        this.setLayout(new BorderLayout());
        this.setBorder(new EmptyBorder(3, 0, 0, 0));
        this.settings.setBorder(new EmptyBorder(5, 10, 5, 10));
        this.settings.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        this.rebuild();
    }
    private void rebuild() {
        this.removeAll();

        JPanel container = new JPanel(new StretchedStackedLayout(3));
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel nameWrapper = new JPanel(new BorderLayout(3, 3));
        container.add(nameWrapper);

        nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameWrapper.setBorder(NAME_BOTTOM_BORDER);
        NotificationType notificationType = notification.getType();
        JLabel nameLabel = new JLabel(notificationType.getName());
        nameLabel.setToolTipText(notificationType.getTooltip());
        nameWrapper.add(nameLabel, BorderLayout.CENTER);

        MouseDragEventForwarder mouseDragEventForwarder = new MouseDragEventForwarder(this.parentPanel.getNotificationContainer());
        nameWrapper.addMouseListener(mouseDragEventForwarder);
        nameWrapper.addMouseMotionListener(mouseDragEventForwarder);
        nameLabel.addMouseListener(mouseDragEventForwarder);
        nameLabel.addMouseMotionListener(mouseDragEventForwarder);

        // Right buttons
        JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 6, 0));
        rightActions.setBorder(new EmptyBorder(4, 0, 0, 0));
        rightActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameWrapper.add(rightActions, BorderLayout.EAST);

        JPanel afkTimerConfigRow = new JPanel(new GridLayout(1, 2));
        afkTimerConfigRow.setBorder(new EmptyBorder(0, 10, 0, 5));
        afkTimerConfigRow.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        JLabel afkTimerLabel = new JLabel("AFK Seconds:");
        afkTimerLabel.setToolTipText("Number of seconds for which the client doesn't get any mouse or keyboard inputs.");
        AtomicInteger previousAFKSeconds = new AtomicInteger(notification.getFireWhenAFKForSeconds());

        JSpinner afkTimerSpinner = PanelUtils.createSpinner(Math.max(notification.getFireWhenAFKForSeconds(), 1),
            1,
            25 * 60,
            1,
            (val) -> {
                notification.setFireWhenAFKForSeconds(val);
                previousAFKSeconds.set(val);
                onChangeListener.run();
            });

        afkTimerConfigRow.add(afkTimerLabel);
        afkTimerConfigRow.add(afkTimerSpinner);
        if (notification.isFireWhenAFK()) {
            container.add(afkTimerConfigRow);
        }

        JButton afkButton = PanelUtils.createToggleActionButton(
            Icons.AFK,
            Icons.AFK_HOVER,
            Icons.NON_AFK,
            Icons.NON_AFK_HOVER,
            "Enable notification even when you are active",
            "Switch to only fire notification when you have been AFK for a certain amount of time",
            notification.isFireWhenAFK(),
            (btn, modifiers) -> {
                notification.setFireWhenAFK(btn.isSelected());
                notification.setFireWhenAFKForSeconds(previousAFKSeconds.get());
                if (notification.isFireWhenAFK()) {
                    afkTimerSpinner.setValue(notification.getFireWhenAFKForSeconds());
                }
                this.rebuild();
                this.revalidate();
                onChangeListener.run();
            });
        rightActions.add(afkButton);

        JPanel delayConfigRow = new JPanel(new GridLayout(1, 2));
        delayConfigRow.setBorder(new EmptyBorder(0, 10, 0, 5));
        delayConfigRow.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        JLabel delayLabel = new JLabel("Delay Time (ms):");
        delayLabel.setToolTipText("Number of milliseconds to wait before firing this notification");
        AtomicInteger previousDelayMilliseconds = new AtomicInteger(notification.getDelayMilliseconds());

        JSpinner delaySpinner = PanelUtils.createSpinner(Math.max(notification.getDelayMilliseconds(), 100),
            100,
            5 * 60000,
            100,
            (val) -> {
                notification.setDelayMilliseconds(val);
                previousDelayMilliseconds.set(val);
                onChangeListener.run();
            });

        delayConfigRow.add(delayLabel);
        delayConfigRow.add(delaySpinner);
        if (notification.isDelayed()) {
            container.add(delayConfigRow);
        }

        AtomicBoolean showDelayMilliseconds = new AtomicBoolean(notification.isDelayed());

        JButton delayButton = PanelUtils.createToggleActionButton(
            Icons.TIMER_REMOVE,
            Icons.TIMER_REMOVE_HOVER,
            Icons.TIMER_PLUS,
            Icons.TIMER_PLUS_HOVER,
            "Turn off delay",
            "Delay notification",
            showDelayMilliseconds.get(),
            (btn, modifiers) -> {
                showDelayMilliseconds.set(!showDelayMilliseconds.get());
                if (showDelayMilliseconds.get()) {
                    notification.setDelayMilliseconds(Math.max(previousDelayMilliseconds.get(), 100));
                    delaySpinner.setValue(notification.getDelayMilliseconds());
                } else {
                    notification.setDelayMilliseconds(0);
                }
                this.rebuild();
                this.revalidate();
                onChangeListener.run();
            });
        rightActions.add(delayButton);

        JButton focusBtn = PanelUtils.createToggleActionButton(
            Icons.FOREGROUND,
            Icons.FOREGROUND_HOVER,
            Icons.BACKGROUND,
            Icons.BACKGROUND_HOVER,
            "Switch to only fire notification while the game is in the background",
            "Switch to fire notifications while the game is in the background and foreground",
            notification.isFireWhenFocused(),
            (btn, modifiers) -> {
                notification.setFireWhenFocused(btn.isSelected());
                onChangeListener.run();
            });
        rightActions.add(focusBtn);

        JButton testBtn = PanelUtils.createActionButton(
            Icons.TEST,
            Icons.TEST_HOVER,
            "Test the notification",
            (btn, modifiers) -> new Thread(() -> {
                this.notification.fireForced(new String[]{ "1", "2", "3", "4", "5" });
            }).start());
        rightActions.add(testBtn);

        JButton deleteBtn = PanelUtils.createActionButton(
            Icons.DELETE,
            Icons.DELETE_HOVER,
            "Remove this notification",
            (btn, modifiers) -> this.onRemove.elementRemoved(this));
        rightActions.add(deleteBtn);


        container.add(this.settings);

        this.add(container, BorderLayout.CENTER);
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.panels;

import com.adamk33n3r.runelite.watchdog.notifications.PluginMessage;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextArea;
import com.adamk33n3r.runelite.watchdog.ui.FlatTextAreaNamespace;
import com.adamk33n3r.runelite.watchdog.ui.panels.NotificationsPanel;
import com.adamk33n3r.runelite.watchdog.ui.panels.PanelUtils;
import net.runelite.client.ui.ColorScheme;


public class PluginMessageNotificationPanel extends NotificationPanel {
    public PluginMessageNotificationPanel(PluginMessage notification, NotificationsPanel parentPanel, Runnable onChangeListener, PanelUtils.OnRemove onRemove) {
        super(notification, parentPanel, onChangeListener, onRemove);

        this.rebuild();
    }

    private void rebuild() {
        this.settings.removeAll();

        PluginMessage notification = (PluginMessage) this.notification;

        FlatTextAreaNamespace fullText = PanelUtils.createTextFieldNamespace(
            "Namespace",
            "The namespace of the plugin message. Usually the name of the plugin.",
            notification.getNamespace(),
            ":",
            "Method",
            "The method or action of the plugin message.",
            notification.getName(),
            (val1, val2) -> {
                notification.setNamespace(val1);
                notification.setName(val2);
                onChangeListener.run();
            }
        );
        fullText.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        this.settings.add(fullText);

        FlatTextArea dataText = PanelUtils.createTextField(
            "Data (JSON)",
            "The data of the plugin message as a JSON object string. Leave empty if not needed.",
            notification.getData(),
            val -> {
                notification.setData(val);
                onChangeListener.run();
            }
        );
        this.settings.add(dataText);
    }
}

/*
 * Copyright (c) 2018, Jasper <Jasper0781@gmail.com>
 * Copyright (c) 2020, melky <https://github.com/melkypie>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker;

import net.runelite.api.Client;
import net.runelite.api.MenuEntry;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;

class ScreenMarkerWidgetHighlightOverlay extends Overlay
{
    private final ScreenMarkerUtil util;
    private final Client client;

    @Inject
    private ScreenMarkerWidgetHighlightOverlay(final ScreenMarkerUtil util, final Client client)
    {
        this.util = util;
        this.client = client;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(PRIORITY_HIGH);
        setMovable(true);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!util.isCreatingScreenMarker() || util.isDrawingScreenMarker())
        {
            return null;
        }

        final MenuEntry[] menuEntries = client.getMenuEntries();
        if (client.isMenuOpen() || menuEntries.length == 0)
        {
            util.setSelectedWidgetBounds(null);
            return null;
        }

        final MenuEntry menuEntry = menuEntries[menuEntries.length - 1];
        final int childIdx = menuEntry.getParam0();
        final int widgetId = menuEntry.getParam1();

        final Widget widget = client.getWidget(widgetId);
        if (widget == null)
        {
            util.setSelectedWidgetBounds(null);
            return null;
        }

        Rectangle bounds = null;
        if (childIdx > -1)
        {
            final Widget child = widget.getChild(childIdx);
            if (child != null)
            {
                bounds = child.getBounds();
            }
        }
        else
        {
            bounds = widget.getBounds();
        }

        if (bounds == null)
        {
            util.setSelectedWidgetBounds(null);
            return null;
        }

        drawHighlight(graphics, bounds);
        util.setSelectedWidgetBounds(bounds);

        return null;
    }

    private static void drawHighlight(Graphics2D graphics, Rectangle bounds)
    {
        graphics.setColor(Color.GREEN);
        graphics.draw(bounds);
    }
}

/*
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.notifications.ScreenMarker;

import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import lombok.Getter;
import lombok.NonNull;

import javax.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.time.Duration;
import java.time.Instant;

public class ScreenMarkerOverlay extends Overlay {
    @Getter
    private final ScreenMarker marker;
    private final ScreenMarkerRenderable screenMarkerRenderable;
    private final Instant timeStarted;

    @Inject
    private Client client;

    @Inject
    private ClientUI clientUI;

    @Inject
    private WatchdogConfig config;

    private long mouseLastPressedMillis;

    ScreenMarkerOverlay(@NonNull ScreenMarker marker)
    {
        this.marker = marker;
        this.screenMarkerRenderable = new ScreenMarkerRenderable();
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ALWAYS_ON_TOP);
        setPriority(PRIORITY_HIGH);
        setMovable(true);
        setResizable(true);
        setMinimumSize(16);
        setResettable(false);
        this.addMenuEntry(MenuAction.RUNELITE_OVERLAY, "Dismiss", "Watchdog screen marker", (me) -> WatchdogPlugin.getInstance().getScreenMarkerUtil().removeScreenMarker(marker));
        this.timeStarted = Instant.now();
    }

    public boolean isExpired() {
        return this.timeStarted.plus(Duration.ofSeconds(this.marker.getDisplayTime())).isBefore(Instant.now());
    }

    @Override
    public String getName()
    {
        return "watchdog.marker" + marker.getScreenMarker().getId();
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        net.runelite.client.plugins.screenmarkers.ScreenMarker marker = this.marker.getScreenMarker();

        if (!this.marker.isSticky() && this.isExpired()) {
            WatchdogPlugin.getInstance().getScreenMarkerUtil().removeScreenMarker(this.marker);
            return null;
        }

        if (!marker.isVisible())
        {
            return null;
        }

        Dimension preferredSize = getPreferredSize();
        if (preferredSize == null)
        {
            // overlay has no preferred size in the renderer configuration!
            return null;
        }

        screenMarkerRenderable.setBorderThickness(marker.getBorderThickness());
        screenMarkerRenderable.setColor(marker.getColor());
        screenMarkerRenderable.setFill(marker.getFill());
        screenMarkerRenderable.setStroke(new BasicStroke(marker.getBorderThickness()));
        screenMarkerRenderable.setSize(preferredSize);
        screenMarkerRenderable.setLabel(marker.isLabelled() ? marker.getName() : "");
        return screenMarkerRenderable.render(graphics);
    }
}

/*
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker;

import com.adamk33n3r.runelite.watchdog.notifications.ScreenMarker;

import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Stroke;

class ScreenMarkerCreationOverlay extends Overlay
{
    private final ScreenMarkerUtil plugin;

    @Inject
    private ScreenMarkerCreationOverlay(final ScreenMarkerUtil plugin)
    {
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(PRIORITY_HIGH);
        setMovable(true);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        ScreenMarker screenMarker = plugin.getCurrentMarker();

        if (screenMarker == null)
        {
            return null;
        }

        int thickness = screenMarker.getScreenMarker().getBorderThickness();
        int offset = thickness / 2;
        int width = getBounds().width - thickness;
        int height = getBounds().height - thickness;

        graphics.setStroke(createStripedStroke(thickness));
        graphics.setColor(screenMarker.getScreenMarker().getColor());
        graphics.drawRect(offset, offset, width, height);

        return getBounds().getSize();
    }

    private Stroke createStripedStroke(int thickness)
    {
        return new BasicStroke(thickness, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{9}, 0);
    }
}

/*
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker;

import net.runelite.client.input.MouseAdapter;

import javax.swing.SwingUtilities;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;

class ScreenMarkerMouseListener extends MouseAdapter
{
    private final ScreenMarkerUtil util;

    ScreenMarkerMouseListener(ScreenMarkerUtil util)
    {
        this.util = util;
    }

    @Override
    public MouseEvent mouseClicked(MouseEvent event)
    {
        if (SwingUtilities.isMiddleMouseButton(event))
        {
            return event;
        }

        event.consume();
        return event;
    }

    @Override
    public MouseEvent mousePressed(MouseEvent event)
    {
        if (SwingUtilities.isMiddleMouseButton(event))
        {
            return event;
        }

        if (SwingUtilities.isLeftMouseButton(event))
        {
            final Rectangle bounds = util.getSelectedWidgetBounds();

            if (bounds != null)
            {
                util.startCreation(bounds.getLocation(), bounds.getSize());
            }
            else
            {
                util.startCreation(event.getPoint());
            }
        }
        else if (util.isCreatingScreenMarker())
        {
            util.finishCreation(true);
        }

        event.consume();
        return event;
    }

    @Override
    public MouseEvent mouseReleased(MouseEvent event)
    {
        if (SwingUtilities.isMiddleMouseButton(event))
        {
            return event;
        }

        if (SwingUtilities.isLeftMouseButton(event) && util.isCreatingScreenMarker())
        {
            /* Set the creation panel as "ready" (because the marker area as been drawn) */
            // Was probably a widget misclick, reset drawing state
            if (util.getOverlay().getPreferredSize().height == 2 && util.getOverlay().getPreferredSize().width == 2) {
                util.setDrawingScreenMarker(false);
            } else {
                util.completeSelection();
            }
        }

        event.consume();
        return event;
    }

    @Override
    public MouseEvent mouseDragged(MouseEvent event)
    {
        if (!util.isCreatingScreenMarker())
        {
            return event;
        }

        if (SwingUtilities.isLeftMouseButton(event))
        {
            util.resizeMarker(event.getPoint());
        }

        return event;
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker;

import com.adamk33n3r.runelite.watchdog.notifications.ScreenMarker;

import net.runelite.client.config.ConfigManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.overlay.OverlayManager;

import com.google.gson.Gson;
import lombok.Getter;
import lombok.Setter;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@Singleton
public class ScreenMarkerUtil {
    private static final Dimension DEFAULT_SIZE = new Dimension(2, 2);

    @Getter
    private final List<ScreenMarkerOverlay> screenMarkers = new ArrayList<>();

    @Inject
    private ConfigManager configManager;

    @Inject
    private MouseManager mouseManager;

    @Inject
    private OverlayManager overlayManager;

    @Getter
    @Inject
    private ScreenMarkerCreationOverlay overlay;

    @Inject
    private Gson gson;

    @Getter
    @Inject
    private ColorPickerManager colorPickerManager;

    @Inject
    private ScreenMarkerWidgetHighlightOverlay widgetHighlight;

    private final ScreenMarkerMouseListener mouseListener;

    @Getter @Setter
    private ScreenMarker currentMarker;

    @Getter @Setter
    private boolean creatingScreenMarker = false;
    @Getter @Setter
    private boolean drawingScreenMarker = false;

    @Getter @Setter
    private Rectangle selectedWidgetBounds = null;
    private Point startLocation = null;

    public ScreenMarkerUtil() {
        this.mouseListener = new ScreenMarkerMouseListener(this);
    }

    public void startUp() {
        this.overlayManager.add(this.overlay);
        this.overlayManager.add(this.widgetHighlight);
    }

    public void setMouseListenerEnabled(boolean enabled) {
        if (enabled) {
            this.mouseManager.registerMouseListener(this.mouseListener);
        } else {
            this.mouseManager.unregisterMouseListener(this.mouseListener);
        }
    }

    public void startCreation(Point location)
    {
        startCreation(location, DEFAULT_SIZE);

        // Stop the highlighting so we don't get rectangles around widgets while trying to make normal screen markers
        if (selectedWidgetBounds == null)
        {
            drawingScreenMarker = true;
        }
    }

    public void startCreation(Point location, Dimension size)
    {
//        currentMarker = new ScreenMarker(
//            Instant.now().toEpochMilli(),
//            "Marker " + (screenMarkers.size() + 1),
//            3,
//            Color.GREEN,
//            new Color(0, 255, 0, 0),
////            pluginPanel.getSelectedBorderThickness(),
////            pluginPanel.getSelectedColor(),
////            pluginPanel.getSelectedFillColor(),
//            true,
//            false //marker.name.length > 1
//        );

        // Set overlay creator bounds to current position and default size
        startLocation = location;
        overlay.setPreferredLocation(location);
        overlay.setPreferredSize(size);
    }

    public ScreenMarkerOverlay finishCreation(boolean aborted)
    {
        ScreenMarker marker = currentMarker;
        ScreenMarkerOverlay screenMarkerOverlay = null;
        if (!aborted && marker != null)
        {
            screenMarkerOverlay = new ScreenMarkerOverlay(marker);
            screenMarkerOverlay.setPreferredLocation(overlay.getBounds().getLocation());
            screenMarkerOverlay.setPreferredSize(overlay.getBounds().getSize());

            screenMarkers.add(screenMarkerOverlay);
            overlayManager.saveOverlay(screenMarkerOverlay);
            overlayManager.add(screenMarkerOverlay);
//            pluginPanel.rebuild();
        }

        creatingScreenMarker = false;
        drawingScreenMarker = false;
        selectedWidgetBounds = null;
        startLocation = null;
        currentMarker = null;
        setMouseListenerEnabled(false);

//        pluginPanel.setCreation(false);
        return screenMarkerOverlay;
    }

    public void completeSelection()
    {
//        pluginPanel.getCreationPanel().unlockConfirm();
    }

    public void deleteMarker(final ScreenMarkerOverlay marker)
    {
        screenMarkers.remove(marker);
        overlayManager.remove(marker);
        overlayManager.resetOverlay(marker);
//        pluginPanel.rebuild();
    }

    void resizeMarker(Point point)
    {
        drawingScreenMarker = true;
        Rectangle bounds = new Rectangle(startLocation);
        bounds.add(point);
        overlay.setPreferredLocation(bounds.getLocation());
        overlay.setPreferredSize(bounds.getSize());
    }

    public void addScreenMarker(ScreenMarker screenMarker) {
        ScreenMarkerOverlay screenMarkerOverlay = new ScreenMarkerOverlay(screenMarker);
        this.screenMarkers.add(screenMarkerOverlay);
        this.overlayManager.add(screenMarkerOverlay);
    }

    public void removeScreenMarker(ScreenMarker screenMarker) {
        this.screenMarkers.removeIf(overlay -> overlay.getMarker() == screenMarker);
        this.overlayManager.removeIf(overlay -> overlay instanceof ScreenMarkerOverlay && ((ScreenMarkerOverlay) overlay).getMarker() == screenMarker);
    }

    public void removeScreenMarkerById(String id) {
        this.screenMarkers.removeIf(overlay -> Objects.equals(overlay.getMarker().getId(), id));
        this.overlayManager.removeIf(overlay -> overlay instanceof ScreenMarkerOverlay && Objects.equals(((ScreenMarkerOverlay) overlay).getMarker().getId(), id));
    }

    public void removeAllMarkers() {
        this.screenMarkers.clear();
        this.overlayManager.removeIf(ScreenMarkerOverlay.class::isInstance);
    }

    public void shutDown() {
        overlayManager.remove(overlay);
        overlayManager.remove(widgetHighlight);
        overlayManager.removeIf(ScreenMarkerOverlay.class::isInstance);
        screenMarkers.clear();
        this.setMouseListenerEnabled(false);
        this.creatingScreenMarker = false;
        this.drawingScreenMarker = false;

        currentMarker = null;
        selectedWidgetBounds = null;
    }
}

/*
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adamk33n3r.runelite.watchdog.ui.notifications.screenmarker;

import net.runelite.client.ui.overlay.RenderableEntity;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Stroke;

@Getter(AccessLevel.PACKAGE)
@Setter(AccessLevel.PACKAGE)
class ScreenMarkerRenderable implements RenderableEntity
{
    private Dimension size;
    private int borderThickness;
    private Color color;
    private Color fill;
    private Stroke stroke;
    private String label;

    @Override
    public Dimension render(Graphics2D graphics)
    {
        int thickness = borderThickness;
        int width = size.width;
        int height = size.height;

        //draw the fill
        graphics.setColor(fill);
        graphics.fillRect(thickness, thickness, width - thickness * 2, height - thickness * 2);

        //because the stroke is centered on the rectangle we draw, we need to translate where we draw the rectangle
        //this is to ensure that the rectangle we draw is our preferred size
        int offset = thickness / 2;
        graphics.setColor(color);
        graphics.setStroke(stroke);
        graphics.drawRect(offset, offset, width - thickness, height - thickness);

        if (!label.isEmpty())
        {
            graphics.drawString(label, 0, 0);
        }

        return size;
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications;

import com.adamk33n3r.runelite.watchdog.notifications.TextToSpeech;
import com.adamk33n3r.runelite.watchdog.notifications.tts.Voice;

import javax.swing.DefaultListCellRenderer;
import javax.swing.JComboBox;

public class VoiceChooser extends JComboBox<Voice> {
    public VoiceChooser(TextToSpeech notification) {
        super(Voice.values());
        this.setSelectedItem(notification.getLegacyVoice());
        this.setRenderer((list, value, index, isSelected, cellHasFocus) -> {
            list.setToolTipText(value.toString());
            return new DefaultListCellRenderer().getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
        });
        this.addActionListener(ev -> notification.setLegacyVoice(this.getItemAt(this.getSelectedIndex())));
    }
}

package com.adamk33n3r.runelite.watchdog.ui.notifications;

import com.adamk33n3r.runelite.watchdog.notifications.IAudioNotification;

import javax.swing.JSlider;

public class VolumeSlider extends JSlider {

    public VolumeSlider(IAudioNotification audioNotification) {
        super(0, 10, audioNotification.getGain());
        this.setSnapToTicks(true);
        this.addChangeListener(ev -> audioNotification.setGain(this.getValue()));
    }
}

package com.adamk33n3r.runelite.watchdog.ui;

import net.runelite.client.plugins.config.ConfigPlugin;
import net.runelite.client.plugins.info.InfoPanel;
import net.runelite.client.plugins.timetracking.TimeTrackingPlugin;
import net.runelite.client.util.ImageUtil;

import javax.swing.ImageIcon;

public abstract class Icons {
    public static final ImageIcon ADD = new ImageIcon(ImageUtil.loadImageResource(TimeTrackingPlugin.class, "add_icon.png"));

    public static final ImageIcon HELP = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "help_icon.png"), 80));
    public static final ImageIcon HELP_HOVER = new ImageIcon(ImageUtil.luminanceOffset(HELP.getImage(), -80));

    public static final ImageIcon HISTORY = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_history.png"));
    public static final ImageIcon HISTORY_HOVER = new ImageIcon(ImageUtil.luminanceOffset(HISTORY.getImage(), -80));
    public static final ImageIcon TOOLS = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_tools.png"));
    public static final ImageIcon TOOLS_HOVER = new ImageIcon(ImageUtil.luminanceOffset(TOOLS.getImage(), -80));

    public static final ImageIcon DISCORD = new ImageIcon(ImageUtil.loadImageResource(InfoPanel.class, "discord_icon.png"));
    public static final ImageIcon DISCORD_HOVER = new ImageIcon(ImageUtil.luminanceOffset(DISCORD.getImage(), -100));

    public static final ImageIcon KOFI = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "kofi_icon.png"));
    public static final ImageIcon KOFI_HOVER = new ImageIcon(ImageUtil.luminanceOffset(KOFI.getImage(), -100));

    public static final ImageIcon CONFIG = new ImageIcon(ImageUtil.resizeImage(ImageUtil.loadImageResource(Icons.class, "mdi_cog.png"), 14, 14));
    public static final ImageIcon CONFIG_HOVER = new ImageIcon(ImageUtil.luminanceOffset(CONFIG.getImage(), -100));

    public static final ImageIcon EXPORT = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_export-variant.png"));
    public static final ImageIcon EXPORT_HOVER = new ImageIcon(ImageUtil.alphaOffset(EXPORT.getImage(), -120));
    public static final ImageIcon IMPORT = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_import.png"));
    public static final ImageIcon IMPORT_HOVER = new ImageIcon(ImageUtil.alphaOffset(IMPORT.getImage(), -120));
    public static final ImageIcon DELETE = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_delete.png"));
    public static final ImageIcon DELETE_HOVER = new ImageIcon(ImageUtil.luminanceOffset(DELETE.getImage(), -80));
    public static final ImageIcon DOWNLOAD = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_download.png"));

    public static final ImageIcon CLONE = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_content-duplicate.png"));
    public static final ImageIcon CLONE_HOVER = new ImageIcon(ImageUtil.alphaOffset(CLONE.getImage(), -120));
    public static final ImageIcon EDIT = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_pencil.png"));
    public static final ImageIcon EDIT_HOVER = new ImageIcon(ImageUtil.alphaOffset(EDIT.getImage(), -120));
    public static final ImageIcon DRAG_VERT = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_drag-vertical.png"));

    public static final ImageIcon REFRESH = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_refresh.png"));
    public static final ImageIcon REFRESH_HOVER = new ImageIcon(ImageUtil.luminanceOffset(REFRESH.getImage(), -80));

    /*
     * Alerts
     */
    public static final ImageIcon BACK = new ImageIcon(ImageUtil.loadImageResource(ConfigPlugin.class, "config_back_icon.png"));
    public static final ImageIcon BACK_HOVER = new ImageIcon(ImageUtil.alphaOffset(BACK.getImage(), -120));
    public static final ImageIcon REGEX = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_regex.png"), -80));
    public static final ImageIcon REGEX_HOVER = new ImageIcon(ImageUtil.luminanceOffset(REGEX.getImage(), -40));
    public static final ImageIcon REGEX_SELECTED = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_regex-outline.png"));
    public static final ImageIcon REGEX_SELECTED_HOVER = new ImageIcon(ImageUtil.luminanceOffset(REGEX_SELECTED.getImage(), -80));
    public static final ImageIcon PICKER = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_eyedropper.png"));
    public static final ImageIcon PICKER_HOVER = new ImageIcon(ImageUtil.luminanceOffset(PICKER.getImage(), -120));

    /*
     * Notifications
     */
    public static final ImageIcon FOREGROUND = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_flip-to-front.png"));
    public static final ImageIcon FOREGROUND_HOVER = new ImageIcon(ImageUtil.luminanceOffset(FOREGROUND.getImage(), -80));
    public static final ImageIcon BACKGROUND = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_flip-to-back.png"));
    public static final ImageIcon BACKGROUND_HOVER = new ImageIcon(ImageUtil.luminanceOffset(BACKGROUND.getImage(), -80));
    public static final ImageIcon AFK = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "afk_icon.png"));
    public static final ImageIcon AFK_HOVER = new ImageIcon(ImageUtil.luminanceOffset(AFK.getImage(), -80));
    public static final ImageIcon NON_AFK = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "non_afk_icon.png"));
    public static final ImageIcon NON_AFK_HOVER = new ImageIcon(ImageUtil.luminanceOffset(NON_AFK.getImage(), -80));
    public static final ImageIcon TEST = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_flask.png"));
    public static final ImageIcon TEST_HOVER = new ImageIcon(ImageUtil.luminanceOffset(TEST.getImage(), -80));
    public static final ImageIcon VOLUME = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_volume-high.png"), -80));
    public static final ImageIcon CLOCK = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_clock-outline.png"), -80));
    public static final ImageIcon SPEECH = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_account-voice.png"), -80));
    public static final ImageIcon SPEED = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_speedometer.png"), -80));
    public static final ImageIcon TIMER_PLUS = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_timer-plus-outline.png"));
    public static final ImageIcon TIMER_PLUS_HOVER = new ImageIcon(ImageUtil.luminanceOffset(TIMER_PLUS.getImage(), -80));
    public static final ImageIcon TIMER_REMOVE = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_timer-remove-outline.png"));
    public static final ImageIcon TIMER_REMOVE_HOVER = new ImageIcon(ImageUtil.luminanceOffset(TIMER_REMOVE.getImage(), -80));
    public static final ImageIcon BORDER_OUTSIDE = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_border-outside.png"), -80));
    public static final ImageIcon FEATHER = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_feather.png"), -80));
    public static final ImageIcon DICE_MULTIPLE = new ImageIcon(ImageUtil.loadImageResource(Icons.class, "mdi_dice-multiple.png"));
    public static final ImageIcon DICE_MULTIPLE_HOVER = new ImageIcon(ImageUtil.luminanceOffset(DICE_MULTIPLE.getImage(), -80));
    public static final ImageIcon DICE_MULTIPLE_OFF = new ImageIcon(ImageUtil.luminanceOffset(ImageUtil.loadImageResource(Icons.class, "mdi_dice-multiple-outline.png"), -80));
    public static final ImageIcon DICE_MULTIPLE_OFF_HOVER = new ImageIcon(ImageUtil.luminanceOffset(DICE_MULTIPLE_OFF.getImage(), -40));
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.*;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum TriggerType {
    ALERT_GROUP("Alert Group", "Group alerts together", AlertGroup.class),
    GAME_MESSAGE("Game Message", "Game messages sent in chat", ChatAlert.class),
    PLAYER_CHAT_MESSAGE("Player Chat Message", "Player messages sent in chat", PlayerChatAlert.class),
    OVERHEAD_TEXT("Overhead Text", "Overhead text", OverheadTextAlert.class),
    STAT_CHANGED("Stat Changed", "Stat changes like boosts or drains", StatChangedAlert.class),
    XP_DROP("XP Drop", "Get an xp drop", XPDropAlert.class),
    SOUND_FIRED("Sound Fired", "When a sound effect plays", SoundFiredAlert.class),
    SPAWNED_OBJECT("Spawned Object", "When an object, player, or npc spawns or despawns", SpawnedAlert.class),
    INVENTORY("Inventory", "When your inventory is full, empty, or contains certain items", InventoryAlert.class),
    LOCATION("Location", "Triggers when you near a set location", LocationAlert.class),
    // Keep this last so that people maybe won't try to use it over the chat one
    NOTIFICATION_FIRED("Notification Fired", "When other plugins fire notifications", NotificationFiredAlert.class),
    ;

    private final String name;
    private final String tooltip;
    private final Class<? extends Alert> implClass;
}

package com.adamk33n3r.runelite.watchdog;

import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;

public class Interval extends Timeout {
    public Interval(ScheduledExecutorService executor, BiConsumer<Timeout, Boolean> task, long delay, TimeUnit unit) {
        super();
        this.task = task;
        this.future = executor.scheduleAtFixedRate(() -> task.accept(this, false), 0, delay, unit);
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.client.RuneLite;
import net.runelite.client.RuneLiteProperties;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.util.OSType;

import com.google.common.base.Strings;
import com.google.common.escape.Escaper;
import com.google.common.escape.Escapers;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import java.awt.TrayIcon;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * This file is as-much-as-possible a copy of {@link net.runelite.client.Notifier}
 * The copied functions can be run through a differ on Notifier's versions of the functions
 */
@Slf4j
@Singleton
public class TrayNotifier {
    // Copied from RuneLite's Notifier class
    private final RuneLiteConfig runeLiteConfig;
    private final ClientUI clientUI;
    private final ScheduledExecutorService executorService;
    private final String appName;
    private final Path notifyIconPath;
    private transient boolean terminalNotifierAvailable;
    private static final String DOUBLE_QUOTE = "\"";
    private static final Escaper SHELL_ESCAPE = Escapers.builder()
            .addEscape('"', "'")
            .build();

    @Inject
    public TrayNotifier(
        final ClientUI clientUI,
        final RuneLiteConfig runeliteConfig,
        final ScheduledExecutorService executorService,
        final ChatMessageManager chatMessageManager,
        final EventBus eventBus,
        @Named("runelite.title") final String appName
    ) {
        this.clientUI = clientUI;
        this.runeLiteConfig = runeliteConfig;
        this.executorService = executorService;
        this.appName = appName;
        this.notifyIconPath = RuneLite.RUNELITE_DIR.toPath().resolve("icon.png");

        // Check if we are running in the launcher because terminal-notifier notifications don't work
        // if the group/sender are unknown to it.
        if (!Strings.isNullOrEmpty(RuneLiteProperties.getLauncherVersion()) && OSType.getOSType() == OSType.MacOS)
        {
            executorService.execute(() -> {
                terminalNotifierAvailable = isTerminalNotifierAvailable();
            });
        }
    }

    public void notify(
            final String title,
            final String message,
            final TrayIcon.MessageType type)
    {
        this.sendNotification(title, message, type);
    }

    // Copy of RuneLite's Notifier::sendNotification
    private void sendNotification(
            final String title,
            final String message,
            final TrayIcon.MessageType type)
    {
        final String escapedTitle = SHELL_ESCAPE.escape(title);
        final String escapedMessage = SHELL_ESCAPE.escape(message);

        switch (OSType.getOSType())
        {
            case Linux:
                sendLinuxNotification(escapedTitle, escapedMessage, type);
                break;
            case MacOS:
                sendMacNotification(escapedTitle, escapedMessage);
                break;
            default:
                sendTrayNotification(title, message, type);
        }
    }

    // Copy of RuneLite's Notifier::sendTrayNotification
    private void sendTrayNotification(
            final String title,
            final String message,
            final TrayIcon.MessageType type)
    {
        if (clientUI.getTrayIcon() != null)
        {
            clientUI.getTrayIcon().displayMessage(title, message, type);
        }
    }

    // Copy of RuneLite's Notifier::sendLinuxNotification
    private void sendLinuxNotification(
            final String title,
            final String message,
            final TrayIcon.MessageType type)
    {
        final List<String> commands = new ArrayList<>();
        commands.add("notify-send");
        commands.add(title);
        commands.add(message);
        commands.add("-a");
        commands.add(SHELL_ESCAPE.escape(appName));
        commands.add("-i");
        commands.add(SHELL_ESCAPE.escape(notifyIconPath.toAbsolutePath().toString()));
        commands.add("-u");
        commands.add(toUrgency(type));
        if (runeLiteConfig.notificationTimeout() > 0)
        {
            commands.add("-t");
            commands.add(String.valueOf(runeLiteConfig.notificationTimeout()));
        }

        executorService.submit(() ->
        {
            try
            {
                Process notificationProcess = sendCommand(commands);

                boolean exited = notificationProcess.waitFor(500, TimeUnit.MILLISECONDS);
                if (exited && notificationProcess.exitValue() == 0)
                {
                    return;
                }
            }
            catch (IOException | InterruptedException ex)
            {
                log.debug("error sending notification", ex);
            }

            // fall back to tray notification
            sendTrayNotification(title, message, type);
        });
    }

    // Copy of RuneLite's Notifier::sendMacNotification
    private void sendMacNotification(final String title, final String message)
    {
        final List<String> commands = new ArrayList<>();

        if (terminalNotifierAvailable)
        {
            Collections.addAll(commands,
                    "sh", "-lc", "\"$@\"", "--",
                    "terminal-notifier",
                    "-title", title,
                    "-message", message,
                    "-group", "net.runelite.launcher",
                    "-sender", "net.runelite.launcher"
            );
        }
        else
        {
            commands.add("osascript");
            commands.add("-e");

            final String script = "display notification " + DOUBLE_QUOTE +
                    message +
                    DOUBLE_QUOTE +
                    " with title " +
                    DOUBLE_QUOTE +
                    title +
                    DOUBLE_QUOTE;

            commands.add(script);
        }

        try
        {
            sendCommand(commands);
        }
        catch (IOException ex)
        {
            log.warn("error sending notification", ex);
        }
    }

    // Copy of RuneLite's Notifier::sendCommand
    private static Process sendCommand(final List<String> commands) throws IOException
    {
        return new ProcessBuilder(commands)
                .redirectErrorStream(true)
                .start();
    }

    // Copy of RuneLite's Notifier::isTerminalNotifierAvailable
    private boolean isTerminalNotifierAvailable()
    {
        try
        {
            // The PATH seen by Cocoa apps does not resemble that seen by the shell, so we defer to the latter.
            final Process exec = Runtime.getRuntime().exec(new String[]{"sh", "-lc", "terminal-notifier -help"});
            if (!exec.waitFor(2, TimeUnit.SECONDS))
            {
                return false;
            }
            return exec.exitValue() == 0;
        }
        catch (IOException | InterruptedException e)
        {
            return false;
        }
    }

    // Copy of RuneLite's Notifier::toUrgency
    private static String toUrgency(TrayIcon.MessageType type)
    {
        switch (type)
        {
            case WARNING:
            case ERROR:
                return "critical";
            default:
                return "normal";
        }
    }

}

package com.adamk33n3r.runelite.watchdog;

import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

@FunctionalInterface
public interface SimpleDocumentListener extends DocumentListener {
    void update(DocumentEvent e);

    @Override
    default void insertUpdate(DocumentEvent e) {
        update(e);
    }
    @Override
    default void removeUpdate(DocumentEvent e) {
        update(e);
    }
    @Override
    default void changedUpdate(DocumentEvent e) {
        update(e);
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.notifications.Popup;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.WidgetNode;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetModalMode;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayDeque;
import java.util.Queue;

@Getter
@Singleton
public class PopupManager {
    private static final int SCRIPT_ID = 3343; // NOTIFICATION_DISPLAY_INIT

    private static final int RESIZABLE_CLASSIC_LAYOUT = WidgetUtil.packComponentId(161, 13);
    private static final int RESIZABLE_MODERN_LAYOUT = WidgetUtil.packComponentId(164, 13);
    private static final int FIXED_CLASSIC_LAYOUT = WidgetUtil.packComponentId(548, 42);

    private static final int INTERFACE_ID = 660;

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    private final Queue<Popup.PopupData> popupQueue = new ArrayDeque<>();

    public void processPopupQueue() {
        // Wait for there to not be any popups
        if (this.client.getWidget(INTERFACE_ID, 1) != null) {
            return;
        }

        if (!this.popupQueue.isEmpty()) {
            Popup.PopupData popupData = this.popupQueue.poll();

            WidgetNode widgetNode = this.client.openInterface(this.getComponentID(), INTERFACE_ID, WidgetModalMode.MODAL_CLICKTHROUGH);
            Widget widget = this.client.getWidget(INTERFACE_ID, 1);

            // Doing this instead of textColor.getRGB() so that it doesn't use the alpha channel and cause WHITE to be -1
            int color = popupData.color == null ? -1 : popupData.color.getRed() << 16 | popupData.color.getGreen() << 8 | popupData.color.getBlue();
            this.client.runScript(SCRIPT_ID, popupData.title, popupData.message, color);

            this.clientThread.invokeLater(() -> {
                assert widget != null;

                // Wait until the popup has closed
                if (widget.getWidth() > 0) {
                    return false;
                }

                this.client.closeInterface(widgetNode, true);
                return true;
            });
        }
    }

    private int getComponentID() {
        return this.client.isResized()
            ? (client.getVarbitValue(Varbits.SIDE_PANELS) == 1
            ? RESIZABLE_MODERN_LAYOUT
            : RESIZABLE_CLASSIC_LAYOUT)
            : FIXED_CLASSIC_LAYOUT;

    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.google.common.base.Strings;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;
import java.awt.Color;

import static com.adamk33n3r.runelite.watchdog.WatchdogConfig.DEFAULT_NOTIFICATION_TEXT_COLOR;

@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class Popup extends MessageNotification {
    private String title = "";
    private Color textColor = DEFAULT_NOTIFICATION_TEXT_COLOR;

    @Inject
    public Popup(WatchdogConfig config) {
        super(config);
        this.setDefaults();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        String titleString = Strings.isNullOrEmpty(this.title) ? this.getAlert().getName() : this.title;
        String title = Util.processTriggerValues(titleString, triggerValues);
        String message = Util.processTriggerValues(this.message, triggerValues);
        WatchdogPlugin.getInstance().getPopupManager().getPopupQueue().offer(new PopupData(
            title,
            message,
            this.getTextColor()
        ));
    }

    @Override
    public void setDefaults() {
        super.setDefaults();
        this.setTextColor(this.watchdogConfig.defaultPopupTextColor());
    }

    @AllArgsConstructor
    public static class PopupData {
        public String title;
        public String message;
        public Color color;
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Displayable;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.plugins.PluginManager;

import javax.inject.Inject;
import javax.swing.*;

@Slf4j
@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class PluginToggle extends Notification {
    private String pluginName;
    private ToggleMode mode = ToggleMode.TOGGLE;

    @Inject
    private transient PluginManager pluginManager;

    @Override
    protected void fireImpl(String[] triggerValues) {
        this.pluginManager.getPlugins().stream().filter(p -> p.getName().equals(this.pluginName)).findFirst().ifPresent(plugin -> {
            // Plugin start/stop must be done on the EDT
            SwingUtilities.invokeLater(() -> {
                if (this.mode == ToggleMode.ENABLE || (this.mode == ToggleMode.TOGGLE && !this.pluginManager.isPluginEnabled(plugin))) {
                    log.debug("Enabling and starting plugin {}", plugin.getName());
                    this.pluginManager.setPluginEnabled(plugin, true);
                    try {
                        this.pluginManager.startPlugin(plugin);
                    } catch (PluginInstantiationException e) {
                        log.error("Error starting plugin {}", plugin.getName(), e);
                    }
                } else if (this.mode == ToggleMode.DISABLE || (this.mode == ToggleMode.TOGGLE && this.pluginManager.isPluginEnabled(plugin))) {
                    log.debug("Disabling and stopping plugin {}", plugin.getName());
                    this.pluginManager.setPluginEnabled(plugin, false);
                    try {
                        this.pluginManager.stopPlugin(plugin);
                    } catch (PluginInstantiationException e) {
                        log.error("Error stopping plugin {}", plugin.getName(), e);
                    }
                }
            });
        });
    }

    @Getter
    @AllArgsConstructor
    public enum ToggleMode implements Displayable {
        ENABLE("Enable", "Enable the plugin"),
        DISABLE("Disable", "Disable the plugin"),
        TOGGLE("Toggle", "Toggle the plugin"),
        ;

        private final String name;
        private final String tooltip;
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;
import java.awt.Color;
import java.time.Instant;

@Getter
@Accessors(chain = true)
public class ScreenMarker extends Notification {
    private net.runelite.client.plugins.screenmarkers.ScreenMarker screenMarker;
    @Setter
    private int displayTime = 5;
    @Setter
    private boolean sticky = false;
    @Setter
    private String id;

    @Inject
    public ScreenMarker(WatchdogConfig config) {
        super(config);
        this.screenMarker = new net.runelite.client.plugins.screenmarkers.ScreenMarker(
            Instant.now().toEpochMilli(),
            "",
            3,
            Color.GREEN,
            new Color(0, 255, 0, 0),
            true,
            false
        );
        this.setDefaults();
    }

    public ScreenMarker setScreenMarkerProperties(String name, Color color, Color fill, int borderThickness) {
        this.screenMarker.setId(Instant.now().toEpochMilli());
        this.screenMarker.setName(name);
        this.screenMarker.setBorderThickness(borderThickness);
        this.screenMarker.setColor(color);
        this.screenMarker.setFill(fill);
        this.screenMarker.setLabelled(name != null && !name.isEmpty());
        return this;
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        WatchdogPlugin.getInstance().getScreenMarkerUtil().addScreenMarker(this);
    }

    @Override
    public void setDefaults() {
        super.setDefaults();

        this.screenMarker.setColor(this.watchdogConfig.defaultScreenMarkerBorderColor());
        this.screenMarker.setFill(this.watchdogConfig.defaultScreenMarkerFillColor());
        this.screenMarker.setBorderThickness(this.watchdogConfig.defaultScreenMarkerBorderThickness());
        this.displayTime = this.watchdogConfig.defaultScreenMarkerDisplayTime();
        this.sticky = this.watchdogConfig.defaultScreenMarkerSticky();
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;

import lombok.NoArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.SoundEffectVolume;
import net.runelite.client.callback.ClientThread;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;

@Getter
@Setter
@Accessors(chain = true)
@NoArgsConstructor
public class SoundEffect extends AudioNotification {
    private int soundID;

    @Inject
    private transient Client client;

    @Inject
    private transient ClientThread clientThread;

    @Inject
    public SoundEffect(WatchdogConfig config) {
        super(config);
        this.setDefaults();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        this.clientThread.invokeLater(() -> {
            var userVolume = this.client.getPreferences().getSoundEffectVolume();
            this.client.getPreferences().setSoundEffectVolume(Util.scale(this.gain, 0, 10, SoundEffectVolume.MUTED, SoundEffectVolume.HIGH));
            this.client.playSoundEffect(this.soundID, 0);
            this.client.getPreferences().setSoundEffectVolume(userVolume);
        });
    }

    @Override
    public void setDefaults() {
        super.setDefaults();
        this.setSoundID(this.watchdogConfig.defaultSoundEffectID());
        this.setGain(this.watchdogConfig.defaultSoundEffectVolume());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.google.common.base.Strings;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import com.google.gson.Gson;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;
import java.util.HashMap;

@Slf4j
@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class PluginMessage extends Notification {
    private String namespace;
    private String name;
    private String data;

    @Inject
    private transient EventBus eventBus;

    @Inject
    private transient ClientThread clientThread;

    @Inject
    private transient Gson gson;

    @Override
    protected void fireImpl(String[] triggerValues) {
        // Wrapping in client thread for safety
        this.clientThread.invoke(() -> {
            if (Strings.isNullOrEmpty(this.data)) {
                this.eventBus.post(new net.runelite.client.events.PluginMessage(this.namespace, this.name));
                return;
            }

            try {
                HashMap<String, Object> dataObj = gson.fromJson(
                    Util.processTriggerValues(this.data, triggerValues),
                    new TypeToken<HashMap<String, Object>>() {
                    }.getType()
                );
                this.eventBus.post(new net.runelite.client.events.PluginMessage(this.namespace, this.name, dataObj));
            } catch (JsonSyntaxException ex) {
                log.error("Invalid plugin message data. sending empty data", ex);
                this.eventBus.post(new net.runelite.client.events.PluginMessage(this.namespace, this.name));
            }
        });
    }
}

package com.adamk33n3r.runelite.watchdog.notifications.tts;

public enum Language {
    ENGLISH(),
    SPANISH(),
    FINNISH(),
    FRENCH(),
    JAPANESE(),
    SWEDISH(),
    DUTCH(),
    NORWEGIAN(),
}
package com.adamk33n3r.runelite.watchdog.notifications.tts;

import com.adamk33n3r.runelite.watchdog.Displayable;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum TTSSource implements Displayable {
    LEGACY("Legacy", "Legacy"),
    ELEVEN_LABS("Eleven Labs", "Eleven Labs (Supply your API Key in Config)"),
    ;
    private final String name;
    private final String tooltip;
}

package com.adamk33n3r.runelite.watchdog.notifications.tts;

import org.apache.commons.text.WordUtils;

public enum Voice {
    LUCAS(0, Language.ENGLISH, Gender.MALE),
    JAMES(1, Language.ENGLISH, Gender.MALE),
    LINDA(2, Language.ENGLISH, Gender.FEMALE),
    RICHARD(3, Language.ENGLISH, Gender.MALE),
    GEORGE(4, Language.ENGLISH, Gender.MALE),
    //SUSAN(5, Language.ENGLISH, Gender.FEMALE), Same as Hazel
    HEERA(6, Language.ENGLISH, Gender.FEMALE),
    RAVI(7, Language.ENGLISH, Gender.MALE),
    MARK(8, Language.ENGLISH, Gender.MALE),
    LAURA(9, Language.SPANISH, Gender.FEMALE),
    PABLO(10, Language.SPANISH, Gender.MALE),
    HEIDI(11, Language.FINNISH, Gender.FEMALE),
    JULIE(12, Language.FRENCH, Gender.FEMALE),
    PAUL(13, Language.FRENCH, Gender.MALE),
    AYUMI(14, Language.JAPANESE, Gender.FEMALE),
    ICHIRO(15, Language.JAPANESE, Gender.MALE),
    SAYAKA(16, Language.JAPANESE, Gender.FEMALE),
    JON(17, Language.NORWEGIAN, Gender.MALE),
    FRANK(18, Language.DUTCH, Gender.MALE),
    BENGT(19, Language.SWEDISH, Gender.MALE),
    HAZEL(20, Language.ENGLISH, Gender.FEMALE),
    EMMA(21, Language.ENGLISH, Gender.FEMALE),
    ZIRA(22, Language.ENGLISH, Gender.FEMALE),
    HELENA(23, Language.SPANISH, Gender.FEMALE),
    HORTENSE(24, Language.FRENCH, Gender.FEMALE),
    HARUKA(25, Language.JAPANESE, Gender.FEMALE);

    public final int id;
    public final Language language;
    public final Gender gender;
    Voice(int id, Language language, Gender gender) {
        this.id = id;
        this.language = language;
        this.gender = gender;
    }

    @Override
    public String toString() {
        return WordUtils.capitalizeFully(String.format("%s %s %s", this.name(), this.language.name(), this.gender.name()));
    }
}

package com.adamk33n3r.runelite.watchdog.notifications.tts;

public enum Gender {
    FEMALE(),
    MALE(),
    UNKNOWN();

    public boolean isFemale() {
        return this.equals(FEMALE);
    }

    public Gender reverse() {
        if (this == FEMALE) {
            return MALE;
        } else {
            return FEMALE;
        }
    }

    public static Gender get(boolean female) {
        if (female) {
            return FEMALE;
        } else {
            return MALE;
        }
    }
}
package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.elevenlabs.ElevenLabs;
import com.adamk33n3r.runelite.watchdog.notifications.tts.TTSSource;
import com.adamk33n3r.runelite.watchdog.notifications.tts.Voice;

import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.nio.file.Files;

import static net.runelite.client.RuneLite.CACHE_DIR;

@Slf4j
@Getter @Setter
@NoArgsConstructor
@Accessors(chain = true)
public class TextToSpeech extends MessageNotification implements IAudioNotification {
    private int gain = 5;
    private int rate = 1;
    @SerializedName("voice")
    private Voice legacyVoice = Voice.GEORGE;
    private TTSSource source = TTSSource.ELEVEN_LABS;
    private String elevenLabsVoiceId;
    private transient com.adamk33n3r.runelite.watchdog.elevenlabs.Voice elevenLabsVoice;

    @Inject
    public TextToSpeech(WatchdogConfig config) {
        super(config);
        this.setDefaults();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        if (!WatchdogPlugin.getInstance().getConfig().ttsEnabled()) {
            return;
        }

        String processedMessage = Util.processTriggerValues(this.message, triggerValues);

        try {
            String encodedMessage = URLEncoder.encode(processedMessage, "UTF-8");
            File watchdogPath = new File(CACHE_DIR, "watchdog");
            //noinspection ResultOfMethodCallIgnored
            watchdogPath.mkdirs();

            if (this.source == TTSSource.ELEVEN_LABS) {
                File soundFile = new File(watchdogPath, String.format("el-%s-%s.mp3", encodedMessage, this.elevenLabsVoiceId));
                if (soundFile.exists()) {
                    log.debug("Using cached file");
                    WatchdogPlugin.getInstance().getSoundPlayer().play(soundFile, this.gain);
                    return;
                }
                log.debug("generating tts");
                ElevenLabs.generateTTS(WatchdogPlugin.getInstance().getHttpClient(), this.elevenLabsVoice, processedMessage, (file) -> {
                    try {
                        Files.move(file.toPath(), soundFile.toPath());
                        WatchdogPlugin.getInstance().getSoundPlayer().play(soundFile, this.gain);
                    } catch (IOException e) {
                        log.error("Could not move tmp file to cache, playing from tmp", e);
                        WatchdogPlugin.getInstance().getSoundPlayer().play(file, this.gain);
                    }
                }, log::error);
                return;
            }

            File soundFile = new File(watchdogPath, String.format("%s-%d-%d.wav", encodedMessage, this.rate, this.legacyVoice.id));

            // If the cache file exists, load and play it. Else fetch it from the server and cache it.
            if (soundFile.exists()) {
                log.debug("Using cached file");
            } else {
                String request = String.format("https://ttsplugin.com?m=%s&r=%d&v=%d", encodedMessage, this.rate, this.legacyVoice.id);
                URLConnection conn = new URL(request).openConnection();
                if (conn.getContentLength() < 0) {
                    log.error("Issue with tts plugin service, content length invalid");
                    return;
                }
                byte[] bytes = new byte[conn.getContentLength()];
                try (InputStream stream = conn.getInputStream()) {
                    for (int i = 0; i < conn.getContentLength(); i++) {
                        bytes[i] = (byte) stream.read();
                    }
                }
                // Write bytes to file in cache
                try (FileOutputStream fileOutputStream = new FileOutputStream(soundFile)) {
                    fileOutputStream.write(bytes);
                }
            }
            WatchdogPlugin.getInstance().getSoundPlayer().play(soundFile, this.gain);
        } catch (Exception ex) {
            log.error("Exception occurred while playing text to speech", ex);
        }
    }

    @Override
    public void setDefaults() {
        super.setDefaults();
        this.setSource(this.watchdogConfig.defaultTTSSource());
        this.setLegacyVoice(this.watchdogConfig.defaultTTSVoice());
        // This will cause the tts panel to set the default
        this.setElevenLabsVoiceId(null);
        this.setGain(this.watchdogConfig.defaultTTSVolume());
        this.setRate(this.watchdogConfig.defaultTTSRate());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;
import java.awt.Color;

import static com.adamk33n3r.runelite.watchdog.WatchdogConfig.DEFAULT_NOTIFICATION_COLOR;
import static com.adamk33n3r.runelite.watchdog.WatchdogConfig.DEFAULT_NOTIFICATION_TEXT_COLOR;

@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class Overlay extends MessageNotification {
    private Color color = DEFAULT_NOTIFICATION_COLOR;
    private Color textColor = DEFAULT_NOTIFICATION_TEXT_COLOR;
    private boolean sticky = false;
    private int timeToLive = 5;
    private String imagePath;
    private String id;
    private boolean resizeImage = true;

    @Inject
    public Overlay(WatchdogConfig config) {
        super(config);
        this.setDefaults();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        WatchdogPlugin.getInstance().getNotificationOverlay()
            .add(this, Util.processTriggerValues(this.message, triggerValues));
    }

    @Override
    public void setDefaults() {
        super.setDefaults();
        this.setColor(this.watchdogConfig.defaultOverlayColor());
        this.setTextColor(this.watchdogConfig.defaultOverlayTextColor());
        this.setSticky(this.watchdogConfig.defaultOverlaySticky());
        this.setTimeToLive(this.watchdogConfig.defaultOverlayTTL());
        this.setImagePath(this.watchdogConfig.defaultOverlayImagePath());
        this.setResizeImage(this.watchdogConfig.defaultOverlayResizeImage());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

public interface IAudioNotification extends INotification {
    int getGain();
    IAudioNotification setGain(int gain);
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.events.PluginMessage;
import okhttp3.HttpUrl;
import org.apache.commons.lang3.StringUtils;

import javax.annotation.Nullable;
import javax.inject.Inject;
import java.util.HashMap;
import java.util.List;

@Slf4j
@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class Dink extends MessageNotification {
    private boolean includeScreenshot = false;

    @Inject
    private transient EventBus eventBus;

    @Inject
    private transient ClientThread clientThread;

    @Override
    protected void fireImpl(String[] triggerValues) {
        HashMap<String, Object> dinkData = new HashMap<>();
        String processedMessage = Util.processTriggerValues(this.message, triggerValues);
        dinkData.put("text", processedMessage);
        dinkData.put("sourcePlugin", WatchdogPlugin.getInstance().getName());
        dinkData.put("title", this.getAlert().getName());
        dinkData.put("imageRequested", this.includeScreenshot);

        log.debug("Sending dink notification with data: {}", dinkData);

        // Workaround for https://github.com/pajlads/DinkPlugin/pull/701
        // Tracked at https://github.com/pajlads/DinkPlugin/issues/758
        this.clientThread.invoke(() -> {
            this.eventBus.post(new PluginMessage("dink", "notify", dinkData));
        });
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.alerts.FlashMode;

import net.runelite.client.config.FlashNotification;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;
import java.awt.Color;

import static com.adamk33n3r.runelite.watchdog.WatchdogConfig.DEFAULT_NOTIFICATION_COLOR;

@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class ScreenFlash extends Notification {
    private Color color = DEFAULT_NOTIFICATION_COLOR;
    private FlashMode flashMode = FlashMode.FLASH;
    private int flashDuration = 2;

    @Deprecated
    private FlashNotification flashNotification;

    @Inject
    public ScreenFlash(WatchdogConfig config) {
        super(config);
        this.setDefaults();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        WatchdogPlugin.getInstance().getFlashOverlay().flash(this);
    }

    @Override
    public void setDefaults() {
        super.setDefaults();
        this.setFlashDuration(this.watchdogConfig.defaultScreenFlashDuration());
        this.setFlashMode(this.watchdogConfig.defaultScreenFlashMode());
        this.setColor(this.watchdogConfig.defaultScreenFlashColor());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter @Setter
@Accessors(chain = true)
public class DismissObjectMarker extends Notification {
    private String dismissId;

    @Override
    protected void fireImpl(String[] triggerValues) {
        WatchdogPlugin.getInstance().getObjectMarkerManager().hideObjectMarkerById(this.dismissId);
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;

@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public abstract class AudioNotification extends Notification implements IAudioNotification {
    protected int gain = 8;

    @Inject
    public AudioNotification(WatchdogConfig config) {
        super(config);
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter @Setter
@Accessors(chain = true)
public class DismissOverlay extends Notification {
    private String dismissId;

    @Override
    protected void fireImpl(String[] triggerValues) {
        WatchdogPlugin.getInstance().getNotificationOverlay().clearById(this.dismissId);
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.TrayNotifier;
import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;

import lombok.NoArgsConstructor;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.awt.TrayIcon;

@Slf4j
@NoArgsConstructor
@Accessors(chain = true)
public class TrayNotification extends MessageNotification {
    @Inject
    protected transient TrayNotifier trayNotifier;

    @Inject
    public TrayNotification(WatchdogConfig config) {
        super(config);
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        this.trayNotifier.notify(
                "Watchdog",
                Util.processTriggerValues(this.message, triggerValues),
                TrayIcon.MessageType.NONE);
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.alerts.Alert;

public interface INotification {
    Alert getAlert();
    void setAlert(Alert alert);
    void fire(String[] triggerValues);
    void setDefaults();
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter @Setter
@Accessors(chain = true)
public class DismissScreenMarker extends Notification {
    private String dismissId;

    @Override
    protected void fireImpl(String[] triggerValues) {
        WatchdogPlugin.getInstance().getScreenMarkerUtil().removeScreenMarkerById(this.dismissId);
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;
import java.io.File;

@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class Sound extends AudioNotification {
    private String path;
    private int repeatDuration = 0;

    @Inject
    public Sound(WatchdogConfig config) {
        super(config);
        this.setDefaults();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        String processedPath = Util.processTriggerValues(path, triggerValues);
        WatchdogPlugin.getInstance().getSoundPlayer().play(new File(processedPath), gain, repeatDuration);
    }

    @Override
    public void setDefaults() {
        super.setDefaults();
        this.setGain(this.watchdogConfig.defaultSoundVolume());
        this.setPath(this.watchdogConfig.defaultSoundPath());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.EventHandler;
import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;

import lombok.NoArgsConstructor;
import lombok.experimental.Accessors;

import javax.inject.Inject;

@NoArgsConstructor
@Accessors(chain = true)
public class NotificationEvent extends MessageNotification {
    @Inject
    private transient EventHandler eventHandler;

    @Inject
    public NotificationEvent(WatchdogConfig config) {
        super(config);
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        this.eventHandler.notify(Util.processTriggerValues(this.message, triggerValues));
    }
}

package com.adamk33n3r.runelite.watchdog.notifications.objectmarkers;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.notifications.Notification;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;
import net.runelite.api.ObjectComposition;
import net.runelite.api.TileObject;

import javax.inject.Inject;
import java.awt.*;

@Getter
@Setter
@Accessors(chain = true)
@NoArgsConstructor
public class ObjectMarker extends Notification {
    static final int HF_HULL = 0x1;
    static final int HF_OUTLINE = 0x2;
    static final int HF_CLICKBOX = 0x4;
    static final int HF_TILE = 0x8;

    private ObjectPoint objectPoint;
    private Color borderColor = Color.YELLOW;
    private Color fillColor;
    private int displayTime = 5;
    private boolean sticky = false;
    private String id;
    // highlight options
    private boolean hull = true;
    private boolean outline;
    private boolean clickbox;
    private boolean tile;
    private double borderWidth = 2.0d;
    private int outlineFeather;

    @Inject
    private transient ObjectMarkerManager objectMarkerManager;

    private transient TileObject tileObject;
    private transient ObjectComposition composition;

    @Inject
    public ObjectMarker(WatchdogConfig config) {
        super(config);
        this.setDefaults();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        if (this.objectPoint == null) {
            return;
        }
        this.objectMarkerManager.showObjectMarker(this);
    }

    @Override
    public void setDefaults() {
        super.setDefaults();

        this.borderColor = this.watchdogConfig.defaultObjectMarkerBorderColor();
        this.fillColor = this.watchdogConfig.defaultObjectMarkerFillColor();
        this.hull = this.watchdogConfig.defaultObjectMarkerHull();
        this.outline = this.watchdogConfig.defaultObjectMarkerOutline();
        this.clickbox = this.watchdogConfig.defaultObjectMarkerClickbox();
        this.tile = this.watchdogConfig.defaultObjectMarkerTile();
        this.borderWidth = this.watchdogConfig.defaultObjectMarkerBorderThickness();
        this.outlineFeather = this.watchdogConfig.defaultObjectMarkerFeather();
        this.displayTime = this.watchdogConfig.defaultObjectMarkerDisplayTime();
        this.sticky = this.watchdogConfig.defaultObjectMarkerSticky();
    }

    public byte getFlags() {
        return (byte)((this.hull ? HF_HULL : 0) |
            (this.outline ? HF_OUTLINE : 0) |
            (this.clickbox ? HF_CLICKBOX : 0) |
            (this.tile ? HF_TILE : 0));
    }

    public String toString() {
        return "ObjectMarker{" +
            "objectPoint=" + objectPoint +
            '}';
    }
}

package com.adamk33n3r.runelite.watchdog.notifications.objectmarkers;

import lombok.Value;

import java.time.Duration;
import java.time.Instant;
import java.util.Objects;

@Value
class ObjectMarkerData {
    ObjectMarker marker;
    Instant timeStarted;
    boolean sticky;

    public ObjectMarkerData(ObjectMarker marker) {
        this(marker, marker.isSticky());
    }

    public ObjectMarkerData(ObjectMarker marker, boolean stickyOverride) {
        this.marker = Objects.requireNonNull(marker);
        this.timeStarted = Instant.now();
        this.sticky = stickyOverride;
    }

    public boolean isExpired() {
        if (this.sticky) {
            return false;
        }
        return this.timeStarted.plus(Duration.ofSeconds(this.marker.getDisplayTime())).isBefore(Instant.now());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications.objectmarkers;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ObjectPoint
{
    private int id = -1;
    private String name;
    private int regionId;
    private int regionX;
    private int regionY;
    private int plane;
}

package com.adamk33n3r.runelite.watchdog.notifications.objectmarkers;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.google.common.base.Strings;
import com.google.gson.Gson;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.List;
import java.util.function.Predicate;

@Slf4j
@Singleton
public class ObjectMarkerManager {
    private static final String MARK = "Mark object";

    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private ColorPickerManager colorPickerManager;
    @Inject
    private WatchdogConfig config;
    @Inject
    private Gson gson;
    @Inject
    private ConfigManager configManager;

    @Getter
    private boolean isInObjectMarkerMode = false;
    @Getter
    private ObjectMarker editingObjectMarker;
    @Getter
    private final List<ObjectMarkerData> objects = new ArrayList<>();
    private final List<TileObject> tileObjectsLoaded = new ArrayList<>();

    public void turnOnObjectMarkerMode(ObjectMarker objectMarker) {
        this.isInObjectMarkerMode = true;
        this.editingObjectMarker = objectMarker;
        if (objectMarker.getObjectPoint() == null) {
            objectMarker.setObjectPoint(new ObjectPoint());
        }
    }

    public void turnOffObjectMarkerMode() {
        this.hideObjectMarker(this.editingObjectMarker);
        this.isInObjectMarkerMode = false;
        this.editingObjectMarker = null;
    }

    public void showObjectMarker(ObjectMarker objectMarker) {
        this.clientThread.invokeLater(() -> {
            log.debug("showObjectMarker: {}", objectMarker);
            ObjectPoint objectPoint = objectMarker.getObjectPoint();
            if (objectPoint == null) {
                log.debug("ObjectMarker {} has no ObjectPoint; ignoring show.", objectMarker);
                return;
            }
            TileObject tileObject = this.tileObjectsLoaded.stream().filter(obj -> {
                // Not sure why this was happening, might be fixed by the onWorldViewUnloaded event
                if (this.client.getWorldView(obj.getLocalLocation().getWorldView()) == null) {
                    return false;
                }
                WorldPoint worldPoint = WorldPoint.fromLocalInstance(this.client, obj.getLocalLocation(), obj.getPlane());
                return objectIdEquals(obj, objectPoint.getId()) &&
                    worldPoint.getRegionX() == objectPoint.getRegionX() &&
                    worldPoint.getRegionY() == objectPoint.getRegionY() &&
                    worldPoint.getPlane() == objectPoint.getPlane();
            }).findFirst().orElse(null);
            if (tileObject == null) {
                return;
            }
            objectMarker.setTileObject(tileObject);
            objectMarker.setComposition(this.client.getObjectDefinition(objectPoint.getId()));
            this.objects.add(new ObjectMarkerData(objectMarker));
        });
    }

    public void hideObjectMarker(ObjectMarker objectMarker) {
        this.clientThread.invokeLater(() -> this.objects.removeIf(objData -> objData.getMarker() == objectMarker));
    }

    public void hideObjectMarkerById(String id) {
        this.clientThread.invokeLater(() -> this.objects.removeIf(objData -> Objects.equals(objData.getMarker().getId(), id)));
    }

    public void removeAllMarkers() {
        this.clientThread.invokeLater(this.objects::clear);
    }
    
    @Subscribe
    private void onMenuEntryAdded(MenuEntryAdded event) {
        if (!this.isInObjectMarkerMode) {
            return;
        }
        if (event.getType() != MenuAction.EXAMINE_OBJECT.getId()) {
            return;
        }

        int worldId = event.getMenuEntry().getWorldViewId();
        WorldView wv = client.getWorldView(worldId);
        if (wv == null) {
            return;
        }

        final TileObject tileObject = findTileObject(wv, event.getActionParam0(), event.getActionParam1(), event.getIdentifier());
        if (tileObject == null)
        {
            return;
        }

        client.getMenu().createMenuEntry(-1)
            .setOption(MARK)
            .setTarget(event.getTarget())
            .setWorldViewId(worldId)
            .setParam0(event.getActionParam0())
            .setParam1(event.getActionParam1())
            .setIdentifier(event.getIdentifier())
            .setType(MenuAction.RUNELITE_HIGH_PRIORITY)
            .onClick(this::markObject);
    }

    @Subscribe
    private void onWorldViewUnloaded(WorldViewUnloaded event) {
        WorldView wv = event.getWorldView();
        this.tileObjectsLoaded.removeIf(o -> o.getWorldView() == wv);
    }

    @Subscribe
    private void onWallObjectSpawned(WallObjectSpawned event) {
        this.tileObjectsLoaded.add(event.getWallObject());
    }

    @Subscribe
    private void onWallObjectDespawned(WallObjectDespawned event) {
        this.tileObjectsLoaded.remove(event.getWallObject());
    }

    @Subscribe
    private void onGameObjectSpawned(GameObjectSpawned event) {
        this.tileObjectsLoaded.add(event.getGameObject());
    }

    @Subscribe
    private void onGameObjectDespawned(GameObjectDespawned event) {
        this.tileObjectsLoaded.remove(event.getGameObject());
    }

    @Subscribe
    private void onDecorativeObjectSpawned(DecorativeObjectSpawned event) {
        this.tileObjectsLoaded.add(event.getDecorativeObject());
    }

    @Subscribe
    private void onDecorativeObjectDespawned(DecorativeObjectDespawned event) {
        this.tileObjectsLoaded.remove(event.getDecorativeObject());
    }

    @Subscribe
    private void onGroundObjectSpawned(GroundObjectSpawned event) {
        this.tileObjectsLoaded.add(event.getGroundObject());
    }

    @Subscribe
    private void onGroundObjectDespawned(GroundObjectDespawned event) {
        this.tileObjectsLoaded.remove(event.getGroundObject());
    }

    private void markObject(MenuEntry entry)
    {
        WorldView wv = client.getWorldView(entry.getWorldViewId());
        if (wv == null) {
            return;
        }

        TileObject object = findTileObject(wv, entry.getParam0(), entry.getParam1(), entry.getIdentifier());
        if (object == null)
        {
            return;
        }
        log.debug("markObject: {} {} {} {} {}", object.getX(), object.getY(), object.getPlane(), object.getId(), object.getWorldView().getId());

        // object.getId() is always the base object id, getObjectComposition transforms it to
        // the correct object we see
        ObjectComposition objectDefinition = getObjectComposition(object.getId());
        String name = objectDefinition.getName();
        // Name is probably never "null" - however prevent adding it if it is, as it will
        // become ambiguous as objects with no name are assigned name "null"
        if (Strings.isNullOrEmpty(name) || name.equals("null"))
        {
            return;
        }

        markObject(objectDefinition, name, object);
    }

    private TileObject findTileObject(WorldView wv, int x, int y, int id)
    {
        int level = wv.getPlane();
        Scene scene = wv.getScene();
        Tile[][][] tiles = scene.getTiles();
        final Tile tile = tiles[level][x][y];
        if (tile == null) {
            return null;
        }

        final GameObject[] tileGameObjects = tile.getGameObjects();
        final DecorativeObject tileDecorativeObject = tile.getDecorativeObject();
        final WallObject tileWallObject = tile.getWallObject();
        final GroundObject groundObject = tile.getGroundObject();

        if (objectIdEquals(tileWallObject, id))
        {
            return tileWallObject;
        }

        if (objectIdEquals(tileDecorativeObject, id))
        {
            return tileDecorativeObject;
        }

        if (objectIdEquals(groundObject, id))
        {
            return groundObject;
        }

        for (GameObject object : tileGameObjects)
        {
            if (objectIdEquals(object, id))
            {
                return object;
            }
        }

        return null;
    }

    private boolean objectIdEquals(TileObject tileObject, int id)
    {
        if (tileObject == null)
        {
            return false;
        }

        if (tileObject.getId() == id)
        {
            return true;
        }

        // Menu action EXAMINE_OBJECT sends the transformed object id, not the base id, unlike
        // all of the GAME_OBJECT_OPTION actions, so check the id against the impostor ids
        final ObjectComposition comp = client.getObjectDefinition(tileObject.getId());

        if (comp.getImpostorIds() != null)
        {
            for (int impostorId : comp.getImpostorIds())
            {
                if (impostorId == id)
                {
                    return true;
                }
            }
        }

        return false;
    }

    /** mark or unmark an object
     *
     * @param objectComposition transformed composition of object based on vars
     * @param name name of objectComposition
     * @param tileObject tile object, for multilocs object.getId() is the base id
     */
    private void markObject(ObjectComposition objectComposition, String name, final TileObject tileObject)
    {
        final WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, tileObject.getLocalLocation());
        final int regionId = worldPoint.getRegionID();
        this.editingObjectMarker.setObjectPoint(new ObjectPoint(
            tileObject.getId(),
            name,
            regionId,
            worldPoint.getRegionX(),
            worldPoint.getRegionY(),
            worldPoint.getPlane()));

        objects.removeIf(o -> o.getMarker().getTileObject() == tileObject);
        this.editingObjectMarker.setTileObject(tileObject);
        this.editingObjectMarker.setComposition(objectComposition);
    }

    private static Predicate<ObjectMarker> findObjectPredicate(ObjectComposition objectComposition, TileObject object, WorldPoint worldPoint)
    {
        // Find the ObjectPoint for the given composition, object, and world point. There are two cases:
        // 1) object is a multiloc, the name may have changed since marking - match from base id
        // 2) not a multiloc, but an object has spawned with an identical name and a different
        //    id as what was originally marked
        return om -> {
            var op = om.getObjectPoint();
            return ((op.getId() == -1 || op.getId() == object.getId()) || op.getName().equals(objectComposition.getName()))
                && op.getRegionX() == worldPoint.getRegionX()
                && op.getRegionY() == worldPoint.getRegionY()
                && op.getPlane() == worldPoint.getPlane();
        };
    }

    @Nullable
    private ObjectComposition getObjectComposition(int id)
    {
        ObjectComposition objectComposition = client.getObjectDefinition(id);
        return objectComposition.getImpostorIds() == null ? objectComposition : objectComposition.getImpostor();
    }
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adamk33n3r.runelite.watchdog.notifications.objectmarkers;

import com.google.common.base.MoreObjects;
import com.google.common.base.Strings;
import net.runelite.api.*;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.*;

import static com.adamk33n3r.runelite.watchdog.notifications.objectmarkers.ObjectMarker.*;

public class ObjectMarkerOverlay extends Overlay
{
    private final ObjectMarkerManager objectMarkerManager;
    private final ModelOutlineRenderer modelOutlineRenderer;

    @Inject
    private ObjectMarkerOverlay(
        ObjectMarkerManager objectMarkerManager,
        ModelOutlineRenderer modelOutlineRenderer
    ) {
        this.objectMarkerManager = objectMarkerManager;
        this.modelOutlineRenderer = modelOutlineRenderer;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(PRIORITY_LOW);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (this.objectMarkerManager.isInObjectMarkerMode() && this.objectMarkerManager.getEditingObjectMarker() != null) {
            renderObject(graphics, this.objectMarkerManager.getEditingObjectMarker());
        }

        var objects = this.objectMarkerManager.getObjects();
        if (objects.isEmpty()) {
            return null;
        }

        for (ObjectMarkerData objData : objects) {
            if (!objData.getMarker().isSticky() && objData.isExpired()) {
                this.objectMarkerManager.hideObjectMarker(objData.getMarker());
                continue;
            }
            renderObject(graphics, objData.getMarker());
        }
        return null;
    }

    private void renderObject(Graphics2D graphics, ObjectMarker obj) {
        Stroke stroke = new BasicStroke((float) obj.getBorderWidth());
        TileObject object = obj.getTileObject();
        if (object == null) {
            return;
        }
        WorldView wv = object.getWorldView();
        if (wv == null || object.getPlane() != wv.getPlane())
        {
            return;
        }

        ObjectComposition composition = obj.getComposition();
        if (composition == null) {
            return;
        }
        if (composition.getImpostorIds() != null)
        {
            // This is a multiloc
            composition = composition.getImpostor();
            // Only mark the object if the name still matches
            if (composition == null
                || Strings.isNullOrEmpty(composition.getName())
                || "null".equals(composition.getName())
                || !composition.getName().equals(obj.getObjectPoint().getName()))
            {
                return;
            }
        }

        Color borderColor = obj.getBorderColor();

        final var flags = obj.getFlags();
        if ((flags & HF_HULL) != 0)
        {
            // default hull fill color is a=50 while the clickbox and tiles are a/12
            Color fillColor = MoreObjects.firstNonNull(obj.getFillColor(), new Color(0, 0, 0, 50));
            renderConvexHull(graphics, object, borderColor, fillColor, stroke);
        }

        if ((flags & HF_OUTLINE) != 0)
        {
            modelOutlineRenderer.drawOutline(object, (int)obj.getBorderWidth(), borderColor, obj.getOutlineFeather());
        }

        if ((flags & HF_CLICKBOX) != 0)
        {
            Shape clickbox = object.getClickbox();
            if (clickbox != null)
            {
                Color fillColor = MoreObjects.firstNonNull(obj.getFillColor(), ColorUtil.colorWithAlpha(borderColor, borderColor.getAlpha() / 12));
                OverlayUtil.renderPolygon(graphics, clickbox, borderColor, fillColor, stroke);
            }
        }

        if ((flags & HF_TILE) != 0)
        {
            Polygon tilePoly = object.getCanvasTilePoly();
            if (tilePoly != null)
            {
                Color fillColor = MoreObjects.firstNonNull(obj.getFillColor(), ColorUtil.colorWithAlpha(borderColor, borderColor.getAlpha() / 12));
                OverlayUtil.renderPolygon(graphics, tilePoly, borderColor, fillColor, stroke);
            }
        }
    }

    private void renderConvexHull(Graphics2D graphics, TileObject object, Color color, Color fillColor, Stroke stroke)
    {
        final Shape polygon;
        Shape polygon2 = null;

        if (object instanceof GameObject)
        {
            polygon = ((GameObject) object).getConvexHull();
        }
        else if (object instanceof WallObject)
        {
            polygon = ((WallObject) object).getConvexHull();
            polygon2 = ((WallObject) object).getConvexHull2();
        }
        else if (object instanceof DecorativeObject)
        {
            polygon = ((DecorativeObject) object).getConvexHull();
            polygon2 = ((DecorativeObject) object).getConvexHull2();
        }
        else if (object instanceof GroundObject)
        {
            polygon = ((GroundObject) object).getConvexHull();
        }
        else
        {
            polygon = object.getCanvasTilePoly();
        }

        if (polygon != null)
        {
            OverlayUtil.renderPolygon(graphics, polygon, color, fillColor, stroke);
        }

        if (polygon2 != null)
        {
            OverlayUtil.renderPolygon(graphics, polygon2, color, fillColor, stroke);
        }
    }
}
package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;

import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;

import lombok.NoArgsConstructor;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;

@Slf4j
@NoArgsConstructor
@Accessors(chain = true)
public class GameMessage extends MessageNotification {
    @Inject
    private transient ChatMessageManager chatMessageManager;

    @Inject
    public GameMessage(WatchdogConfig config) {
        super(config);
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        String formattedMessage = "<col" + ChatColorType.HIGHLIGHT.name() + ">" +
            Util.processTriggerValues(this.message, triggerValues);
        this.chatMessageManager.queue(QueuedMessage.builder()
            .type(ChatMessageType.CONSOLE)
            .name(WatchdogPlugin.getInstance().getName())
            .runeLiteFormattedMessage(formattedMessage)
            .build());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

public interface IMessageNotification extends INotification {
    String getMessage();
    IMessageNotification setMessage(String message);
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;

import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.Player;
import net.runelite.client.util.ColorUtil;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;
import java.awt.Color;
import java.util.concurrent.ScheduledExecutorService;

@NoArgsConstructor
@Accessors(chain = true)
public class Overhead extends MessageNotification {
    @Getter @Setter
    private int displayTime = 3;
    @Getter @Setter
    private Color textColor = null;

    @Inject
    private transient Client client;
    @Inject
    private transient ScheduledExecutorService executor;

    @Inject
    public Overhead(WatchdogConfig config) {
        super(config);
        this.setDefaults();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        String message = Util.processTriggerValues(this.message, triggerValues);
        Player localPlayer = this.client.getLocalPlayer();
        if (localPlayer == null) {
            return;
        }
        StringBuilder sb = new StringBuilder();
        if (this.textColor != null) {
            sb.append("<col=")
                .append(ColorUtil.colorToHexCode(this.textColor))
                .append(">")
                .append(message)
                .append("</col>");
        } else {
            sb.append(message);
        }
        localPlayer.setOverheadText(sb.toString());
        localPlayer.setOverheadCycle(this.displayTime * 1000 / Constants.CLIENT_TICK_LENGTH);
    }

    @Override
    public void setDefaults() {
        super.setDefaults();
        this.setDisplayTime(this.watchdogConfig.defaultOverHeadDisplayTime());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Displayable;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum ShortestPathMode implements Displayable {
    PATH("Set Path", "Set Path"),
    CLEAR("Clear Path", "Clear Path"),
    ;

    private final String name;
    private final String tooltip;
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.AlertManager;
import com.adamk33n3r.runelite.watchdog.NotificationType;
import com.adamk33n3r.runelite.watchdog.WatchdogConfig;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import com.adamk33n3r.runelite.watchdog.alerts.Alert;

import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.client.ui.ClientUI;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import javax.inject.Inject;
import java.util.Arrays;

@NoArgsConstructor
public abstract class Notification implements INotification {
    @Inject
    protected transient ClientUI clientUI;

    @Inject
    protected transient Client client;

    @Inject
    protected transient AlertManager alertManager;

    protected transient WatchdogConfig watchdogConfig;

    @Getter @Setter
    private boolean fireWhenFocused = true;

    @Getter @Setter
    private boolean fireWhenAFK = false;
    @Getter @Setter
    private int fireWhenAFKForSeconds = 5;

    @Getter @Setter
    private int delayMilliseconds = 0;

    public boolean isDelayed() {
        return this.delayMilliseconds > 0;
    }

    @Setter
    private transient Alert alert;
    public Alert getAlert() {
        if (this.alert == null) {
            this.alert = this.alertManager.getAllAlerts()
                .filter(a -> a.getNotifications().contains(this)).findFirst().orElse(null);
        }

        return this.alert;
    }

    @Inject
    public Notification(WatchdogConfig config) {
        this.watchdogConfig = config;
        this.fireWhenAFK = config.defaultAFKMode();
        this.fireWhenAFKForSeconds = config.defaultAFKSeconds();
    }

    public boolean shouldFire() {
        if (WatchdogPlugin.getInstance().isInBannedArea()) {
            return false;
        }

        int afkTime = (int)Math.floor(Math.min(client.getKeyboardIdleTicks(), client.getMouseIdleTicks()) * Constants.CLIENT_TICK_LENGTH / 1000f);
        if (this.fireWhenAFK && afkTime < this.fireWhenAFKForSeconds) {
            return false;
        }
        return !this.clientUI.isFocused() || this.fireWhenFocused;
    }

    @Override
    public void fire(String[] triggerValues) {
        if (this.shouldFire()) {
            this.fireImpl(triggerValues);
        }
    }

    public void fireForced(String[] triggerValues) {
        this.fireImpl(triggerValues);
    }

    protected abstract void fireImpl(String[] triggerValues);

    public NotificationType getType() {
        return Arrays.stream(NotificationType.values())
            .filter(nType -> nType.getImplClass() == this.getClass())
            .findFirst()
            .orElse(null);
    }

    public void setDefaults() {
        this.setFireWhenAFK(this.watchdogConfig.defaultAFKMode());
        this.setFireWhenAFKForSeconds(this.watchdogConfig.defaultAFKSeconds());
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;

@Setter
@Getter
@Accessors(chain = true)
@NoArgsConstructor
public abstract class MessageNotification extends Notification implements IMessageNotification {
    protected String message = "";

    @Inject
    public MessageNotification(WatchdogConfig config) {
        super(config);
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.Util;
import com.adamk33n3r.runelite.watchdog.WatchdogPlugin;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.events.PluginMessage;

import javax.inject.Inject;
import java.util.HashMap;

@Slf4j
@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class ShortestPath extends Notification {
    private ShortestPathMode mode = ShortestPathMode.PATH;
    private boolean useCurrentLocationForStart = true;
    private WorldPoint start = new WorldPoint(3223, 3219, 0);
    private WorldPoint target = new WorldPoint(2897, 3543, 0);

    @Inject
    private transient EventBus eventBus;

    @Inject
    private transient ClientThread clientThread;

    public boolean isPathMode() {
        return this.mode == ShortestPathMode.PATH;
    }

    public boolean isClearMode() {
        return this.mode == ShortestPathMode.CLEAR;
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        switch (this.mode) {
            case CLEAR:
                this.clientThread.invoke(() -> {
                    this.eventBus.post(new PluginMessage("shortestpath", "clear"));
                });
                break;
            case PATH:
                HashMap<String, Object> data = new HashMap<>();
                data.put("start", this.useCurrentLocationForStart ? -1 : this.start);
                data.put("target", this.target);

                log.debug("Setting shortest path with data: {}", data);

                this.clientThread.invoke(() -> {
                    this.eventBus.post(new PluginMessage("shortestpath", "path", data));
                });
                break;
        }
    }
}

package com.adamk33n3r.runelite.watchdog.notifications;

import com.adamk33n3r.runelite.watchdog.WatchdogConfig;

import net.runelite.client.ui.ClientUI;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.Accessors;

import javax.inject.Inject;

@Getter
@Setter
@NoArgsConstructor
@Accessors(chain = true)
public class RequestFocus extends Notification {
    private boolean forceFocus = false;

    @Inject
    private transient ClientUI clientUI;

    @Inject
    public RequestFocus(WatchdogConfig config) {
        super(config);
        this.forceFocus = config.defaultRequestFocusForce();
    }

    @Override
    protected void fireImpl(String[] triggerValues) {
        if (this.forceFocus) {
            this.clientUI.forceFocus();
        } else {
            this.clientUI.requestFocus();
        }
    }
}

package com.adamk33n3r.runelite.watchdog;

import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;

public class Timeout {
    BiConsumer<Timeout, Boolean> task;
    ScheduledFuture<?> future;
    public Timeout(ScheduledExecutorService executor, BiConsumer<Timeout, Boolean> task, long delay, TimeUnit unit) {
        this.task = task;
        this.future = executor.schedule(() -> this.task.accept(this, false), delay, unit);
    }
    protected Timeout() {}

    public void stop() {
        if (this.future.isDone()) {
            return;
        }
        this.future.cancel(true);
    }

    public void stopAndRunNow() {
        if (this.future.isDone()) {
            return;
        }
        this.future.cancel(true);
        this.task.accept(this, true);
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.api.ChatMessageType;

import lombok.Getter;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Getter
public enum GameMessageType implements Displayable {
    ANY("Any", "Any message", (ChatMessageType[]) null),
    BROADCAST("Broadcast", "Broadcast from the server", ChatMessageType.BROADCAST, ChatMessageType.WELCOME),
    DIALOG("Dialog", "Dialog messages", ChatMessageType.DIALOG, ChatMessageType.MESBOX),
    DUEL("Duel", "Duel messages", ChatMessageType.CHALREQ_TRADE, ChatMessageType.CHALREQ_FRIENDSCHAT, ChatMessageType.CHALREQ_CLANCHAT),
    EXAMINE("Examine", "Examine text", ChatMessageType.ITEM_EXAMINE, ChatMessageType.NPC_EXAMINE, ChatMessageType.OBJECT_EXAMINE),
    GAME_MESSAGE("Game Message", "Game messages", ChatMessageType.GAMEMESSAGE, ChatMessageType.CONSOLE, ChatMessageType.ENGINE),
    LOGIN_LOGOUT("Login/Logout", "Friend Login/Logout messages", ChatMessageType.LOGINLOGOUTNOTIFICATION),
    NPC_SAY("NPC Dialogue", "Overhead text from some NPCs", ChatMessageType.NPC_SAY),
    SPAM("Spam", "Filtered game messages", ChatMessageType.SPAM),
    TRADE("Trade", "Trade messages", ChatMessageType.TRADE, ChatMessageType.TRADE_SENT, ChatMessageType.TRADEREQ),
    ;

    private final String name;
    private final String tooltip;
    private final ChatMessageType[] chatMessageTypes;
    private static final List<ChatMessageType> ANY_TYPES;

    static {
        ANY_TYPES = Arrays.stream(values())
            .filter(gameMessageType -> gameMessageType != ANY)
            .flatMap((gameMessageType) -> Arrays.stream(gameMessageType.chatMessageTypes))
            .collect(Collectors.toList());
    }

    GameMessageType(String name, String tooltip, ChatMessageType... chatMessageTypes) {
        this.name = name;
        this.tooltip = tooltip;
        this.chatMessageTypes = chatMessageTypes;
    }

    public boolean isOfType(ChatMessageType chatMessageType) {
        return this.chatMessageTypes == null ? ANY_TYPES.contains(chatMessageType) : Arrays.asList(this.chatMessageTypes).contains(chatMessageType);
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.api.ChatMessageType;

import lombok.Getter;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Getter
public enum PlayerChatType implements Displayable {
    ANY("Any", "Any message", (ChatMessageType[]) null),
    PUBLIC("Public", "Public", ChatMessageType.PUBLICCHAT, ChatMessageType.MODCHAT),
    PRIVATE("Private", "Private message", ChatMessageType.PRIVATECHAT, ChatMessageType.PRIVATECHATOUT, ChatMessageType.MODPRIVATECHAT),
    FRIENDS("Friends", "Friends Chat", ChatMessageType.FRIENDSCHAT, ChatMessageType.FRIENDSCHATNOTIFICATION),
    CLAN("Clan", "Clan Chat", ChatMessageType.CLAN_CHAT, ChatMessageType.CLAN_MESSAGE),
    GUEST_CLAN("Guest Clan", "Guest Clan Chat", ChatMessageType.CLAN_GUEST_CHAT, ChatMessageType.CLAN_GUEST_MESSAGE),
    GIM("GIM", "Group Iron Man Chat", ChatMessageType.CLAN_GIM_CHAT, ChatMessageType.CLAN_GIM_MESSAGE, ChatMessageType.CLAN_GIM_FORM_GROUP, ChatMessageType.CLAN_GIM_GROUP_WITH),
    AUTOTYPER("Autochat", "Autochat messages", ChatMessageType.AUTOTYPER, ChatMessageType.MODAUTOTYPER),
    ;

    private final String name;
    private final String tooltip;
    private final ChatMessageType[] chatMessageTypes;
    private static final List<ChatMessageType> ANY_TYPES;

    static {
        ANY_TYPES = Arrays.stream(values())
            .filter(playerChatType -> playerChatType != ANY)
            .flatMap((playerChatType) -> Arrays.stream(playerChatType.chatMessageTypes))
            .collect(Collectors.toList());
    }

    PlayerChatType(String name, String tooltip, ChatMessageType... chatMessageTypes) {
        this.name = name;
        this.tooltip = tooltip;
        this.chatMessageTypes = chatMessageTypes;
    }

    public boolean isOfType(ChatMessageType chatMessageType) {
        return this.chatMessageTypes == null ? ANY_TYPES.contains(chatMessageType) : Arrays.asList(this.chatMessageTypes).contains(chatMessageType);
    }
}

package com.adamk33n3r.runelite.watchdog;

import lombok.Builder;
import lombok.Data;
import net.runelite.api.WorldView;
import org.apache.commons.text.WordUtils;

import java.util.Arrays;
import java.util.Set;

// Use https://explv.github.io to find region ids
public enum Region {
    ALCHEMICAL_HYDRA(RegionConfig
        .builder()
        .regionIDs(Set.of(5536))
        .onlyInInstance()
        .build()),
    VARDORVIS(RegionConfig
        .builder()
        .regionIDs(Set.of(4405))
        .build()),
    LEVIATHAN(RegionConfig
        .builder()
        .regionIDs(Set.of(8291))
        .build()),
    WHISPERER(RegionConfig
        .builder()
        .regionIDs(Set.of(10595))
        .build()),
    SUCELLUS(RegionConfig
        .builder()
        .regionIDs(Set.of(12132))
        .build()),
    VORKATH(RegionConfig
        .builder()
        .regionIDs(Set.of(9023))
        .build()),
    INFERNO(RegionConfig
        .builder()
        .regionIDs(Set.of(9043))
        .build()),
    FIGHT_CAVE(RegionConfig
        .builder()
        .regionIDs(Set.of(9551))
        .build()),
    COLOSSEUM(RegionConfig
        .builder()
        .regionIDs(Set.of(7216))
        .build()),
    KALPHITE_QUEEN(RegionConfig
        .builder()
        .regionIDs(Set.of(13972))
        .planes(Set.of(0))
        .build()),
    COX(RegionConfig
        .builder()
        .regionIDs(Set.of(
            13136, // End of floor
            13137, 13393, // Lobbies/Room transitions
            13138, 13394, // Vasa/Tekton/Vespula Lizardmen/Skeletal Mystics/Guardian
            13139, 13395, 13140, 13396, // Puzzle rooms/bosses
            13141, 13397, // Rest room
            13145, // New floor
            13401, // New floor?
            12889 // Olm
        ))
        .build()),
    TOB(RegionConfig
        .builder()
        .regionIDs(Set.of(
            // 12869, // Lobby
            12613, // Maiden
            13125, // Bloat
            13122, // Nylocas
            13123, 13379, // Sotetseg/maze
            12612, // Xarpus
            12611 // Verzik
            // 12867 // Loot room

//            // Outside
//            14386,
//            14642
        ))
        .build()),
    TOA(RegionConfig
        .builder()
        .regionIDs(Set.of(
            // 13454, // Lobby
            14160, // Nexus Lobby
            15698, // Crondis
            15700, // Zebak
            14162, // Scabaras
            14164, // Kephri
            15186, // Apmeken
            15188, // Ba-Ba
            14674, // Het
            14676, // Akkha
            15184, 15696 // Wardens
            // 14672 // Chest room
        ))
        .build()),
    YAMA(RegionConfig
        .builder()
        .regionIDs(Set.of(6045))
        .build()),
    DOOM_OF_MOKHAIOTL(RegionConfig
        .builder()
        .regionIDs(Set.of(5269, 13668, 14180))
        .build()),
//    LUMBRIDGE_CASTLE(RegionConfig
//        .builder()
//        .regionIDs(Set.of(12850))
//        .planes(Set.of(0, 2))
//        .build()),
    ;

    final RegionConfig config;

    Region(RegionConfig config) {
        this.config = config;
    }

    public static boolean isBannedRegion(int regionID, WorldView worldView) {
        return Arrays.stream(values())
            .filter(r -> worldView.isInstance() || !r.config.onlyInInstance)
            .filter(r -> r.config.planes.isEmpty() || r.config.planes.contains(worldView.getPlane()))
            .flatMap(r -> r.config.regionIDs.stream())
            .anyMatch(id -> id == regionID);
    }

    public String toString() {
        return WordUtils.capitalizeFully(this.name().replaceAll("_", " "));
    }

    @Data
    @Builder
    static class RegionConfig {
        @Builder.Default
        public final Set<Integer> regionIDs = Set.of();
        @Builder.Default
        public final Set<Integer> planes = Set.of();
        public final boolean onlyInInstance;

        public static class RegionConfigBuilder {
            public RegionConfigBuilder onlyInInstance() {
                this.onlyInInstance = true;
                return this;
            }
        }
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.notifications.Notification;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;
import java.util.function.Consumer;

public class AlertProcessor extends Thread {
    private final String[] triggerValues;
    private final boolean forceFire;
    private final Consumer<AlertProcessor> onFinish;
    private final Queue<Notification> notificationQueue = new LinkedList<>();

    public AlertProcessor(Alert alert, String[] triggerValues) {
        this(alert, triggerValues, false);
    }

    public AlertProcessor(Alert alert, String[] triggerValues, boolean forceFire) {
        this(alert, triggerValues, forceFire, (ap) -> {});
    }

    public AlertProcessor(Alert alert, String[] triggerValues, boolean forceFire, Consumer<AlertProcessor> onFinish) {
        this.triggerValues = triggerValues;
        this.forceFire = forceFire;
        this.onFinish = onFinish;
        if (alert.isRandomNotifications()) {
            this.notificationQueue.add(alert.getNotifications().get(new Random().nextInt(alert.getNotifications().size())));
        } else {
            this.notificationQueue.addAll(alert.getNotifications());
        }
    }

    @Override
    public void run() {
        while (!this.notificationQueue.isEmpty() && !this.isInterrupted()) {
            Notification nextNotification = this.notificationQueue.poll();
            // This is checked in .fire(), but we don't want to delay if it won't fire
            if (!nextNotification.shouldFire() && !this.forceFire) {
                continue;
            }
            int delayMilliseconds = nextNotification.getDelayMilliseconds();
            if (delayMilliseconds > 0) {
                try {
                    Thread.sleep(delayMilliseconds);
                } catch (InterruptedException e) {
                    break;
                }
            }

            if (this.forceFire) {
                nextNotification.fireForced(this.triggerValues);
            } else {
                nextNotification.fire(this.triggerValues);
            }
        }

        onFinish.accept(this);
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.api.WorldView;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;

import java.util.Arrays;
import java.util.stream.Collectors;

@RunWith(MockitoJUnitRunner.class)
public class RegionTest extends TestBase {
    @InjectMocks
    EventHandler eventHandler;

    @Test
    public void testCoxBanned() {
        var mockWorldView = Mockito.mock(WorldView.class);
        Mockito.when(mockWorldView.isInstance()).thenReturn(false);
        Mockito.when(mockWorldView.getPlane()).thenReturn(0);

//        var regions = Arrays.stream(Region.values())
//            .filter(r -> mockWorldView.isInstance() || !r.config.onlyInInstance)
//            .filter(r -> r.config.planes.isEmpty() || r.config.planes.contains(mockWorldView.getPlane()))
//            .flatMap(r -> r.config.regionIDs.stream())
//            .collect(Collectors.toList());
//        for (var region : regions) {
//            System.out.println(region);
//        }
        var res = Region.isBannedRegion(12889, mockWorldView);
        Assert.assertTrue(res);
    }
}

package com.adamk33n3r.runelite.watchdog;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class WatchdogPluginLauncher {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(WatchdogPlugin.class);
        RuneLite.main(args);
    }
}
package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.Alert;
import com.adamk33n3r.runelite.watchdog.notifications.Notification;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;

import java.util.List;

import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.*;

public class AlertProcessorTest {
    private Alert alert;
    private Notification notification;
    private Notification notification2;
    private AlertProcessor alertProcessor;

    @Before
    public void setup() {
        alert = mock(Alert.class);
        notification = mock(Notification.class);
        notification2 = mock(Notification.class);
        when(alert.getNotifications()).thenReturn(List.of(notification, notification2));
    }

    @Test
    public void shouldProcessNotificationsWhenForceFireIsFalseAndShouldFireIsTrue() throws InterruptedException {
        when(notification.shouldFire()).thenReturn(true);
        alertProcessor = new AlertProcessor(alert, new String[0], false);
        alertProcessor.start();
        alertProcessor.join();
        verify(notification, times(1)).fire(any());
    }

    @Test
    public void shouldNotProcessNotificationsWhenForceFireIsFalseAndShouldFireIsFalse() throws InterruptedException {
        when(notification.shouldFire()).thenReturn(false);
        alertProcessor = new AlertProcessor(alert, new String[0], false);
        alertProcessor.start();
        alertProcessor.join();
        verify(notification, times(0)).fire(any());
    }

    @Test
    public void shouldProcessNotificationsWhenForceFireIsTrueRegardlessOfShouldFire() throws InterruptedException {
        when(notification.shouldFire()).thenReturn(false);
        alertProcessor = new AlertProcessor(alert, new String[0], true);
        alertProcessor.start();
        alertProcessor.join();
        verify(notification, times(1)).fireForced(any());
    }

    @Test
    public void shouldProcessMultipleNotifications() throws InterruptedException {
        when(alert.isRandomNotifications()).thenReturn(false);
        when(notification.shouldFire()).thenReturn(true);
        when(notification2.shouldFire()).thenReturn(true);
        alertProcessor = new AlertProcessor(alert, new String[0], false);
        alertProcessor.start();
        alertProcessor.join();
        verify(notification, times(1)).fire(any());
        verify(notification2, times(1)).fire(any());
    }

    @Test
    public void shouldOnlyProcessOneNotification() throws InterruptedException {
        when(alert.isRandomNotifications()).thenReturn(true);
        when(notification.shouldFire()).thenReturn(true);
        when(notification2.shouldFire()).thenReturn(true);
        alertProcessor = new AlertProcessor(alert, new String[0], false);
        alertProcessor.start();
        alertProcessor.join();
        // verify that either notification or notification2 is fired, but not both
        ArgumentCaptor<String[]> argumentCaptor = ArgumentCaptor.forClass(String[].class);
        verify(notification, atLeast(0)).fire(argumentCaptor.capture());
        ArgumentCaptor<String[]> argumentCaptor2 = ArgumentCaptor.forClass(String[].class);
        verify(notification2, atLeast(0)).fire(argumentCaptor2.capture());

        assertTrue(!argumentCaptor.getAllValues().isEmpty() || !argumentCaptor2.getAllValues().isEmpty());
    }
}
package com.adamk33n3r.runelite.watchdog;

import net.runelite.api.SoundEffectVolume;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class NumberScaleTest {
    @Test
    public void test_scaling_decibels() {
        assertEquals(-25, Util.scale(0, 0, 10, -25, 5));
        assertEquals(5, Util.scale(10, 0, 10, -25, 5));

        assertEquals(0, Util.scale(-25, -25, 5, 0, 10));
        assertEquals(10, Util.scale(5, -25, 5, 0, 10));
    }

    @Test
    public void test_sound_effect_volume() {
        assertEquals(SoundEffectVolume.MUTED, Util.scale(0, 0, 10, SoundEffectVolume.MUTED, SoundEffectVolume.HIGH));
        assertEquals(SoundEffectVolume.HIGH, Util.scale(10, 0, 10, SoundEffectVolume.MUTED, SoundEffectVolume.HIGH));

        assertEquals(0, Util.scale(SoundEffectVolume.MUTED, SoundEffectVolume.MUTED, SoundEffectVolume.HIGH, 0, 10));
        assertEquals(10, Util.scale(SoundEffectVolume.HIGH, SoundEffectVolume.MUTED, SoundEffectVolume.HIGH, 0, 10));
        assertEquals(5, Util.scale(SoundEffectVolume.MEDIUM_LOW, SoundEffectVolume.MUTED, SoundEffectVolume.HIGH, 0, 10));
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.ui.panels.HistoryPanel;
import com.google.inject.testing.fieldbinder.Bind;
import net.runelite.client.eventbus.EventBus;
import org.junit.Before;
import org.mockito.Mock;
import org.mockito.Mockito;

import javax.inject.Provider;

public abstract class AlertTestBase extends TestBase {
    @Mock
    @Bind
    EventBus eventBus;

    @Mock
    HistoryPanel historyPanel;
    @Mock
    Provider<HistoryPanel> historyPanelProvider;


    @Before
    public void before() throws NoSuchFieldException {
        super.before();

        Mockito.when(historyPanelProvider.get()).thenReturn(this.historyPanel);
    }
}

package com.adamk33n3r.runelite.watchdog;

import org.junit.Assert;
import org.junit.Test;

import java.util.Arrays;
import java.util.List;

public class SearchTextTest {
    @Test
    public void test_simple_search() {
        List<String> keywords = Arrays.asList("me", "you", "adamk33n3r");
        Assert.assertTrue(Util.searchText("k33n3r", keywords));
        Assert.assertTrue(Util.searchText("Adam", keywords));
        Assert.assertFalse(Util.searchText("frank", keywords));
    }

    @Test
    public void test_accented_characters() {
        List<String> keywords = Arrays.asList("adamk33n3r", "om");
        Assert.assertTrue(Util.searchText("ome", keywords));
    }
}

package com.adamk33n3r.runelite.watchdog;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;


public class VersionTest {
    @Test
    public void compare_versions() throws Exception {
        Version a = new Version("1.1");
        Version b = new Version("1.1.1");
        assert(a.compareTo(b) < 0);
        assert(!a.equals(b));

        a = new Version("2.0");
        b = new Version("1.9.9");
        assert(a.compareTo(b) > 0);
        assert(!a.equals(b));

        a = new Version("1.0");
        b = new Version("1");
        assert(a.compareTo(b) == 0);
        assert(a.equals(b));

        a = new Version("1");
        b = new Version(null);
        assert(a.compareTo(b) > 0);
        assert(!a.equals(b));

        List<Version> versions = new ArrayList<Version>();
        versions.add(new Version("2"));
        versions.add(new Version("1.0.5"));
        versions.add(new Version("1.01.0"));
        versions.add(new Version("1.00.1"));
        assert(Collections.min(versions).equals(new Version("1.0.1")));
        assert(Collections.max(versions).equals(new Version("2.0.0")));
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.*;
import com.adamk33n3r.runelite.watchdog.notifications.Notification;
import com.adamk33n3r.runelite.watchdog.notifications.Overlay;

import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;

import javax.inject.Inject;
import java.util.List;

@RunWith(MockitoJUnitRunner.class)
public class AlertManagerTest extends TestBase {

    @Inject
    AlertManager alertManager;

    @Test
    public void test_import() {
        String json = "[{\"type\":\"ChatAlert\",\"message\":\"*is ready to harvest*\",\"regexEnabled\":false,\"enabled\":true,\"name\":\"Ready to Harvest\",\"debounceTime\":500,\"notifications\":[{\"type\":\"TrayNotification\",\"message\":\"Time to harvest your crops!\",\"fireWhenFocused\":true},{\"type\":\"Sound\",\"path\":\"C:\\\\Users\\\\adamg\\\\Music\\\\airplane_seatbelt.mp3\",\"gain\":10,\"fireWhenFocused\":true},{\"type\":\"TextToSpeech\",\"gain\":5,\"rate\":1,\"voice\":\"GEORGE\",\"source\":\"LEGACY\",\"message\":\"\",\"fireWhenFocused\":true},{\"type\":\"Overhead\",\"displayTime\":3,\"message\":\"\",\"fireWhenFocused\":true}]},{\"type\":\"NotificationFiredAlert\",\"message\":\"You are now out of combat!\",\"regexEnabled\":false,\"enabled\":true,\"name\":\"Out of Combat\",\"debounceTime\":0,\"notifications\":[{\"type\":\"ScreenFlash\",\"color\":\"#46FF0000\",\"flashMode\":\"FLASH\",\"flashDuration\":0,\"fireWhenFocused\":true}]},{\"type\":\"SpawnedAlert\",\"spawnedDespawned\":\"SPAWNED\",\"spawnedType\":\"ITEM\",\"spawnedName\":\"Bones\",\"regexEnabled\":false,\"enabled\":false,\"name\":\"Bones Spawned\",\"debounceTime\":0,\"notifications\":[{\"type\":\"SoundEffect\",\"soundID\":3925,\"gain\":10,\"fireWhenFocused\":true},{\"type\":\"ScreenFlash\",\"color\":\"#46FF0000\",\"flashMode\":\"FLASH\",\"flashDuration\":0,\"fireWhenFocused\":true}]},{\"type\":\"SpawnedAlert\",\"spawnedDespawned\":\"SPAWNED\",\"spawnedType\":\"NPC\",\"spawnedName\":\"Gee\",\"regexEnabled\":false,\"enabled\":false,\"name\":\"NPC Spawn\",\"debounceTime\":0,\"notifications\":[{\"type\":\"Overhead\",\"displayTime\":3,\"message\":\"The dude is here\",\"fireWhenFocused\":true},{\"type\":\"TextToSpeech\",\"gain\":10,\"rate\":1,\"voice\":\"GEORGE\",\"source\":\"LEGACY\",\"message\":\"\",\"fireWhenFocused\":true}]},{\"type\":\"SpawnedAlert\",\"spawnedDespawned\":\"SPAWNED\",\"spawnedType\":\"GAME_OBJECT\",\"spawnedName\":\"Tree\",\"regexEnabled\":false,\"enabled\":false,\"name\":\"New Spawned Alert\",\"debounceTime\":0,\"notifications\":[{\"type\":\"Overhead\",\"displayTime\":3,\"message\":\"CHOP THE TREE\",\"fireWhenFocused\":true},{\"type\":\"SoundEffect\",\"soundID\":3924,\"gain\":10,\"fireWhenFocused\":true}]},{\"type\":\"ChatAlert\",\"message\":\"\",\"regexEnabled\":false,\"enabled\":true,\"name\":\"test 11labs lag\",\"debounceTime\":0,\"notifications\":[{\"type\":\"TextToSpeech\",\"gain\":10,\"rate\":1,\"voice\":\"GEORGE\",\"source\":\"LEGACY\",\"message\":\"this is a test\",\"fireWhenFocused\":true}]}]";
        Mockito.when(this.configManager.getConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.ALERTS))
            .thenReturn(json);
        Mockito.when(this.configManager.getConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.PLUGIN_VERSION))
            .thenReturn(this.pluginVersion);
        Assert.assertEquals(0, alertManager.getAlerts().size());
        alertManager.loadAlerts();
        Assert.assertEquals(6, alertManager.getAlerts().size());
    }

    @Test
    public void test_upgrade() {
        String json = "[{\"type\":\"ChatAlert\",\"message\":\"\",\"regexEnabled\":false,\"enabled\":true,\"name\":\"Upgrade Test\",\"debounceTime\":0,\"notifications\":[{\"type\":\"Overlay\",\"color\":\"#46FF0000\",\"sticky\":false,\"timeToLive\":5,\"imagePath\":\"\",\"message\":\"Overlay notification\",\"fireWhenFocused\":true}]}]";
        Mockito.when(this.configManager.getConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.ALERTS))
            .thenReturn(json);
        Mockito.when(this.configManager.getConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.PLUGIN_VERSION))
            .thenReturn("2.12.0");
        alertManager.loadAlerts();
        Alert alert = alertManager.getAlerts().get(0);
        Assert.assertTrue(alert instanceof ChatAlert);
        Notification notification = alert.getNotifications().get(0);
        Assert.assertTrue(notification instanceof Overlay);
        Assert.assertNotNull(((Overlay) notification).getTextColor());
    }

    @Test
    public void test_upgrade_3_14_0() {
        String json = "[" +
            "{\"type\":\"ChatAlert\",\"message\":\"*the end.\",\"regexEnabled\":false,\"gameMessageType\":\"ANY\",\"enabled\":true,\"name\":\"v3.14.0 Upgrade Test\"}," +
            "{\"type\":\"ChatAlert\",\"message\":\"The beginning*\",\"regexEnabled\":false,\"gameMessageType\":\"ANY\",\"enabled\":true,\"name\":\"v3.14.0 Upgrade Test\"}," +
            "{\"type\":\"ChatAlert\",\"message\":\"The beginning and the end.\",\"regexEnabled\":false,\"gameMessageType\":\"ANY\",\"enabled\":true,\"name\":\"v3.14.0 Upgrade Test\"}," +
            "{\"type\":\"PlayerChatAlert\",\"message\":\"*and*\",\"regexEnabled\":false,\"gameMessageType\":\"ANY\",\"enabled\":true,\"name\":\"v3.14.0 Upgrade Test\"}," +

            "{\"type\":\"ChatAlert\",\"message\":\"The beginning and the end\\\\.\",\"regexEnabled\":true,\"gameMessageType\":\"ANY\",\"enabled\":true,\"name\":\"v3.14.0 Upgrade Test\"}," +
            "{\"type\":\"ChatAlert\",\"message\":\".*the end.\",\"regexEnabled\":true,\"gameMessageType\":\"ANY\",\"enabled\":true,\"name\":\"v3.14.0 Upgrade Test\"}," +
            "{\"type\":\"ChatAlert\",\"message\":\"^The beginning and the end\\\\.\",\"regexEnabled\":true,\"gameMessageType\":\"ANY\",\"enabled\":true,\"name\":\"v3.14.0 Upgrade Test\"}," +
            "{\"type\":\"ChatAlert\",\"message\":\"The beginning and the end\\\\.$\",\"regexEnabled\":true,\"gameMessageType\":\"ANY\",\"enabled\":true,\"name\":\"v3.14.0 Upgrade Test\"}," +
            "{\"type\":\"ChatAlert\",\"message\":\"^The beginning and the end\\\\.$\",\"regexEnabled\":true,\"gameMessageType\":\"ANY\",\"enabled\":true,\"name\":\"v3.14.0 Upgrade Test\"}," +

            "{\"type\":\"OverheadTextAlert\",\"regexEnabled\":false,\"message\":\"The beginning and the end.\",\"npcRegexEnabled\":false,\"npcName\":\"ali*\",\"enabled\":true,\"name\":\"v3.14.0 Upgrade Test\"}" +
        "]";
        Mockito.when(this.configManager.getConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.ALERTS))
            .thenReturn(json);
        Mockito.when(this.configManager.getConfiguration(WatchdogConfig.CONFIG_GROUP_NAME, WatchdogConfig.PLUGIN_VERSION))
            .thenReturn("3.13.0");
        alertManager.loadAlerts();
        alertManager.getAlerts().forEach(alert -> {
            Assert.assertTrue(alert instanceof RegexMatcher);
            String pattern = ((RegexMatcher) alert).getPattern();
            // Test the specific case where the glob is wrapped in * on both sides
            if (alert instanceof PlayerChatAlert) {
                Assert.assertEquals("and", ((PlayerChatAlert) alert).getPattern());
            } else {
                Assert.assertTrue(pattern.startsWith("^") && pattern.endsWith("$"));
            }
            if (alert instanceof OverheadTextAlert) {
                Assert.assertTrue(((OverheadTextAlert) alert).isNpcRegexEnabled());
                Assert.assertEquals("^ali.*$", ((OverheadTextAlert) alert).getNpcName());
            }
        });
    }
}

package com.adamk33n3r.runelite.watchdog;

import org.junit.Test;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class GlobTest {
    @Test
    public void star_becomes_dot_star() throws Exception {
        assertEquals("gl.*b", Util.createRegexFromGlob("gl*b"));
    }

    @Test
    public void escaped_star_is_unchanged() throws Exception {
        assertEquals("gl\\*b", Util.createRegexFromGlob("gl\\*b"));
    }

    @Test
    public void question_mark_becomes_dot() throws Exception {
        assertEquals("gl.b", Util.createRegexFromGlob("gl?b"));
    }

    @Test
    public void escaped_question_mark_is_unchanged() throws Exception {
        assertEquals("gl\\?b", Util.createRegexFromGlob("gl\\?b"));
    }

    @Test
    public void character_classes_dont_need_conversion() throws Exception {
        assertEquals("gl[-o]b", Util.createRegexFromGlob("gl[-o]b"));
    }

    @Test
    public void escaped_classes_are_unchanged() throws Exception {
        assertEquals("gl\\[-o\\]b", Util.createRegexFromGlob("gl\\[-o\\]b"));
    }

    @Test
    public void negation_in_character_classes() throws Exception {
        assertEquals("gl[^a-n!p-z]b", Util.createRegexFromGlob("gl[!a-n!p-z]b"));
    }

    @Test
    public void nested_negation_in_character_classes() throws Exception {
        assertEquals("gl[[^a-n]!p-z]b", Util.createRegexFromGlob("gl[[!a-n]!p-z]b"));
    }

    @Test
    public void escape_carat_if_it_is_the_first_char_in_a_character_class() throws Exception {
        assertEquals("gl[\\^o]b", Util.createRegexFromGlob("gl[^o]b"));
    }

    @Test
    public void metachars_are_escaped() throws Exception {
        assertEquals("gl..*\\.\\(\\)\\+\\|\\^\\$\\@\\%b", Util.createRegexFromGlob("gl?*.()+|^$@%b"));
    }

    @Test
    public void metachars_in_character_classes_dont_need_escaping() throws Exception {
        assertEquals("gl[?*.()+|^$@%]b", Util.createRegexFromGlob("gl[?*.()+|^$@%]b"));
    }

    @Test
    public void escaped_backslash_is_unchanged() throws Exception {
        assertEquals("gl\\\\b", Util.createRegexFromGlob("gl\\\\b"));
    }

    @Test
    public void slashQ_and_slashE_are_escaped() throws Exception {
        assertEquals("\\\\Qglob\\\\E", Util.createRegexFromGlob("\\Qglob\\E"));
    }

    @Test
    public void braces_are_turned_into_groups() throws Exception {
        assertEquals("(glob|regex)", Util.createRegexFromGlob("{glob,regex}"));
    }

    @Test
    public void escaped_braces_are_unchanged() throws Exception {
        assertEquals("\\{glob\\}", Util.createRegexFromGlob("\\{glob\\}"));
    }

    @Test
    public void commas_dont_need_escaping() throws Exception {
        assertEquals("(glob,regex),", Util.createRegexFromGlob("{glob\\,regex},"));
    }

    @Test
    public void test_real_example() throws Exception {
        String regex = Util.createRegexFromGlob("Your {*} {are,is} ready to harvest");
        assertEquals("Your (.*) (are|is) ready to harvest", regex);
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher("Your tomatoes are ready to harvest");
        assertTrue(matcher.matches());
        assertEquals(2, matcher.groupCount());
        assertEquals("tomatoes", matcher.group(1));
    }

    @Test
    public void test_character_classes() throws Exception {
        String regex = Util.createRegexFromGlob("Jan [4-9]th");
        assertEquals("Jan [4-9]th", regex);
        assertTrue("Jan 8th".matches(regex));
    }

    @Test
    public void test_valuable_drop() throws Exception {
        String regex = Util.createRegexFromGlob("*Valuable drop: *\\([5-9],??? coins\\)*");
        assertEquals(".*Valuable drop: .*\\([5-9],... coins\\).*", regex);
        assertTrue("Valuable drop: (5,001 coins)".matches(regex));
    }

    @Test
    public void test_valuable_drop_all() throws Exception {
        String regex = Util.createRegexFromGlob("*drop*");
        assertEquals(".*drop.*", regex);
        assertTrue("Valuable drop: (5,001 coins)".matches(regex));
    }

    @Test
    public void test_glob_groups() throws Exception {
        String regex = Util.createRegexFromGlob("{You're assigned to kill,Your new task is to kill} aberrant spectres");
        assertEquals("(You're assigned to kill|Your new task is to kill) aberrant spectres", regex);
        assertTrue("You're assigned to kill aberrant spectres".matches(regex));
        assertTrue("Your new task is to kill aberrant spectres".matches(regex));
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.ChatAlert;
import com.adamk33n3r.runelite.watchdog.notifications.Dink;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.events.PluginMessage;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;

import java.util.Map;
import java.util.function.BooleanSupplier;
import java.util.stream.Stream;

@RunWith(MockitoJUnitRunner.class)
public class DinkNotificationTest extends AlertTestBase {

    @InjectMocks
    EventHandler eventHandler;

    @Test
    public void testDinkNotification() {
        String alertName = "Test Alert";
        ChatAlert chatAlert = new ChatAlert(alertName);
        chatAlert.setGameMessageType(GameMessageType.GAME_MESSAGE);
        chatAlert.setPattern("*");
        Dink dink = new Dink();
        chatAlert.addNotification(dink);
        String dinkMessage = "Test Message";
        dink.setMessage(dinkMessage);
        dink.setIncludeScreenshot(true);

        watchdogPlugin.getInjector().injectMembers(chatAlert);
        watchdogPlugin.getInjector().injectMembers(dink);

        Mockito.when(alertManager.getAllAlerts()).thenAnswer(invocation -> Stream.of(chatAlert));
        Mockito.when(alertManager.getAllEnabledAlertsOfType(ChatAlert.class)).thenAnswer(invocation -> Stream.of(chatAlert));

        ChatMessage testMessage = Mockito.mock(ChatMessage.class);
        Mockito.when(testMessage.getName()).thenReturn("Test");
        Mockito.when(testMessage.getMessage()).thenReturn("Test Message");
        Mockito.when(testMessage.getType()).thenReturn(ChatMessageType.GAMEMESSAGE);
        Mockito.when(client.isClientThread()).thenReturn(true);
        Mockito.doCallRealMethod().when(clientThread).invoke(Mockito.any(Runnable.class));
        Mockito.doCallRealMethod().when(clientThread).invoke(Mockito.any(BooleanSupplier.class));
        eventHandler.onChatMessage(testMessage);
        Mockito.verify(eventBus, Mockito.timeout(100)).post(new PluginMessage("dink", "notify", Map.of(
            "text", dinkMessage,
            "title", alertName,
            "sourcePlugin", watchdogPlugin.getName(),
            "imageRequested", true
        )));
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.google.gson.Gson;
import com.google.inject.Guice;
import com.google.inject.Injector;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import net.runelite.api.Client;
import net.runelite.client.account.AccountClient;
import net.runelite.client.account.SessionManager;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ChatColorConfig;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.MultiplexingPluginPanel;
import net.runelite.http.api.RuneLiteAPI;
import org.junit.Before;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.internal.util.reflection.FieldSetter;

import javax.inject.Named;
import javax.inject.Provider;
import java.io.File;
import java.util.concurrent.ScheduledExecutorService;

public abstract class TestBase {
    @Bind
    @Named("watchdog.pluginVersion")
    final String pluginVersion = "3.14.0-TEST";
    @Bind
    @Named("watchdog.helpURL")
    private final String HELP_URL = "";
    @Bind
    @Named("watchdog.discordURL")
    private final String DISCORD_URL = "";
    @Bind
    @Named("watchdog.kofiURL")
    private final String KOFI_URL = "";
    @Bind
    @Named("watchdog.pluginVersionFull")
    private final String PLUGIN_VERSION_FULL = "";
    @Bind
    @Named("VERSION_PHASE")
    private final String PLUGIN_VERSION_PHASE = "";
    @Bind
    @Named("runelite.title")
    private final String RUNELITE_TITLE = "RuneLite";
    @Bind
    @Mock
    @Named("sessionfile")
    private final File SESSION_FILE = null;
    @Bind
    @Named("safeMode")
    private final Boolean SAFE_MODE = false;
    @Bind
    @Named("profile")
    private final String PROFILE = "";
    @Bind
    @Named("runelite.oauth.redirect")
    private final String OAUTH_REDIRECT = "";


    @Bind
    @Named("runelite.api.base")
    okhttp3.HttpUrl API_BASE = okhttp3.HttpUrl.get("https://api.runelite.net");
    @Bind
    @Named("runelite.static.base")
    okhttp3.HttpUrl STATIC_BASE = okhttp3.HttpUrl.get("https://static.runelite.net");

    @Bind
    @Spy
    WatchdogPlugin watchdogPlugin;
    @Bind
    @Mock
    WatchdogConfig watchdogConfig;
    @Bind
    @Spy
    AlertManager alertManager;
    @Mock
    @Bind
    WatchdogPanel watchdogPanel;
    @Bind
    Provider<WatchdogMuxer> muxerProvider = () -> this.watchdogPanel.getMuxer();
    @Bind
    Provider<MultiplexingPluginPanel> multiplexingPluginPanelProvider = () -> alertManager.getWatchdogPanel().getMuxer();

    @Bind
    @Mock
    ChatColorConfig chatColorConfig;
    @Bind
    Gson clientGson = RuneLiteAPI.GSON;
    @Mock
    @Bind
    ScheduledExecutorService executor;
    @Mock
    @Bind
    RuneLiteConfig runeliteConfig;
    @Mock
    @Bind
    SessionManager sessionManager;
    @Mock
    @Bind
    ConfigManager configManager;
    @Mock
    @Bind
    Client client;
    @Mock
    @Bind
    ClientThread clientThread;
    @Mock
    @Bind
    ClientUI clientUI;
    @Mock
    @Bind
    ItemManager itemManager;
    @Mock
    @Bind
    ChatMessageManager chatMessageManager;

    @Before
    public void before() throws NoSuchFieldException {
        BoundFieldModule module = BoundFieldModule.of(this);
        Injector injector = Guice.createInjector(module);
        injector.injectMembers(this);

        // can't mock the getInjector method because it's final
        FieldSetter.setField(watchdogPlugin, Plugin.class.getDeclaredField("injector"), injector);
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.elevenlabs.ElevenLabs;
import org.junit.Assert;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;

import java.io.IOException;
import java.util.Properties;
import java.util.concurrent.CountDownLatch;

@RunWith(MockitoJUnitRunner.class)
public class ElevenLabsTest extends TestBase {
    private static String apiKey;
    private static final String ENV_VAR_NAME = "ELEVEN_LABS_API_KEY";

    @BeforeClass
    public static void setup() {
        apiKey = System.getenv(ENV_VAR_NAME);
        if (apiKey == null) {
            System.err.println("API Key environment variable '" + ENV_VAR_NAME + "' is not set. Trying to load from test.properties");
            Properties properties = new Properties();
            try {
                properties.load(ElevenLabsTest.class.getResourceAsStream("/test.properties"));
                apiKey = properties.getProperty(ENV_VAR_NAME);
                if (apiKey == null) {
                    System.err.println("API Key property '" + ENV_VAR_NAME + "' is not set.");
                    throw new RuntimeException("API Key property '" + ENV_VAR_NAME + "' is not set.");
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }

    @Before
    public void before() throws NoSuchFieldException {
        super.before();
        Mockito.when(this.watchdogConfig.elevenLabsAPIKey()).thenReturn(apiKey);
    }

    @Test
    public void test_get_voices() throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        ElevenLabs.getVoices(WatchdogPlugin.getInstance().getHttpClient(), voices -> {
            Assert.assertFalse(voices.getVoices().isEmpty());
            countDownLatch.countDown();
        }, Assert::fail);
        countDownLatch.await();
    }

    @Test
    public void test_generate_tts() throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        ElevenLabs.getVoices(WatchdogPlugin.getInstance().getHttpClient(), voices -> {
            ElevenLabs.generateTTS(WatchdogPlugin.getInstance().getHttpClient(), voices.getVoices().get(0), "This is a test", file -> {
                Assert.assertTrue(file.exists());
                if (!file.delete()) {
                    System.err.println("Failed to delete temp file");
                }
                countDownLatch.countDown();
            }, Assert::fail);
        }, Assert::fail);
        countDownLatch.await();
    }
}

package com.adamk33n3r.runelite.watchdog;

import com.adamk33n3r.runelite.watchdog.alerts.*;
import com.adamk33n3r.runelite.watchdog.notifications.*;
import com.adamk33n3r.runelite.watchdog.notifications.tts.TTSSource;

import com.google.gson.Gson;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class GSONTest {
    @Test
    public void json_missing_property_with_initializer_test() throws Exception {
        final RuntimeTypeAdapterFactory<Alert> alertTypeFactory = RuntimeTypeAdapterFactory.of(Alert.class)
            .ignoreSubtype("IdleAlert")
            .ignoreSubtype("ResourceAlert")
            .recognizeSubtypes()
            .registerSubtype(ChatAlert.class)
            .registerSubtype(PlayerChatAlert.class)
            .registerSubtype(NotificationFiredAlert.class)
            .registerSubtype(StatDrainAlert.class)
            .registerSubtype(StatChangedAlert.class)
            .registerSubtype(XPDropAlert.class)
            .registerSubtype(SoundFiredAlert.class)
            .registerSubtype(SpawnedAlert.class)
            .registerSubtype(InventoryAlert.class)
            .registerSubtype(AlertGroup.class)
            .registerSubtype(LocationAlert.class);
        // Add new notification types here
        final RuntimeTypeAdapterFactory<Notification> notificationTypeFactory = RuntimeTypeAdapterFactory.of(Notification.class)
            .registerSubtype(TrayNotification.class)
            .registerSubtype(TextToSpeech.class)
            .registerSubtype(Sound.class)
            .registerSubtype(SoundEffect.class)
            .registerSubtype(ScreenFlash.class)
            .registerSubtype(GameMessage.class)
            .registerSubtype(Overhead.class)
            .registerSubtype(Overlay.class)
            .registerSubtype(RequestFocus.class)
            .registerSubtype(NotificationEvent.class)
            .registerSubtype(ScreenMarker.class)
            .registerSubtype(DismissOverlay.class);
        Gson gson = new Gson().newBuilder()
//            .serializeNulls()
            .registerTypeAdapterFactory(alertTypeFactory)
            .registerTypeAdapterFactory(notificationTypeFactory)
            .create();
        TextToSpeech tts = gson.fromJson("{\"type\":\"TextToSpeech\", \"message\":\"this is a test\"}", TextToSpeech.class);

        assertEquals(TTSSource.ELEVEN_LABS, tts.getSource());
        assertEquals(5, tts.getGain());
    }
}

