/*
 * Copyright (c) 2020, dekvall <https://github.com/dekvall>
 * Copyright (c) 2026, Zipon <https://github.com/zipon458>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.driftnetenhanced;

import java.util.Set;
import lombok.Data;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.GameObject;
import net.runelite.api.annotations.Varbit;
import net.runelite.api.coords.WorldPoint;

@Data
@RequiredArgsConstructor
class DriftNet
{
	private final int objectId;
	@Getter(onMethod_ = {@Varbit})
	private final int statusVarbit;
	@Getter(onMethod_ = {@Varbit})
	private final int countVarbit;
	private final Set<WorldPoint> adjacentTiles;

	private GameObject net;
	private DriftNetStatus status;
	private int count;
	@Setter
	private DriftNetStatus prevTickStatus;

	// Nets that are not accepting fish are those currently not accepting, or those which were not
	// accepting in the previous tick. (When a fish shoal is 2 tiles adjacent to a drift net and is
	// moving to a net that is just being setup it will be denied even though the net is currently
	// in the CATCHING status)
	boolean isNotAcceptingFish()
	{
		return (status != DriftNetStatus.CATCH && status != DriftNetStatus.SET) ||
			(prevTickStatus != DriftNetStatus.CATCH && prevTickStatus != DriftNetStatus.SET);
	}

	String getFormattedCountText()
	{
		return status != DriftNetStatus.UNSET ? count + "/10" : "";
	}
}

/*
 * Copyright (c) 2020, dekvall <https://github.com/dekvall>
 * Copyright (c) 2026, Zipon <https://github.com/zipon458>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.driftnetenhanced;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Notification;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(DriftNetPlugin.CONFIG_GROUP)
public interface DriftNetConfig extends Config
{
	@ConfigItem(
		position = 1,
		keyName = "showNetStatus",
		name = "Show net status",
		description = "Show net status and fish count."
	)
	default boolean showNetStatus()
	{
		return true;
	}

	@ConfigItem(
			position = 2,
			keyName = "netHighlightStyle",
			name = "Use clickbox for nets",
			description = "Use clickbox instead of hull to highlight drift nets."
	)
	default boolean useNetClickbox()
	{
		return false;
	}

	@Range(
			min = 0,
			max = 255
	)
	@ConfigItem(
			position = 3,
			keyName = "netFillOpacity",
			name = "Net fill opacity",
			description = "Opacity of drift net fill color (0 = transparent, 255 = solid)."
	)
	default int netFillOpacity()
	{
		return 0;
	}

	@ConfigItem(
		position = 4,
		keyName = "countColor",
		name = "Fish count color",
		description = "Color of the fish count text."
	)
	default Color countColor()
	{
		return Color.WHITE;
	}

	@ConfigItem(
		position = 5,
		keyName = "highlightUntaggedFish",
		name = "Highlight untagged fish",
		description = "Highlight the untagged fish."
	)
	default boolean highlightUntaggedFish()
	{
		return true;
	}

	@ConfigItem(
		position = 6,
		keyName = "highlightTaggedFish",
		name = "Highlight tagged fish",
		description = "Highlight the tagged fish."
	)
	default boolean highlightTaggedFish()
	{
		return false;
	}

	@ConfigItem(
		position = 7,
		keyName = "timeoutDelay",
		name = "Tagged timeout",
		description = "Time required for a tag to expire."
	)
	@Range(
		min = 1,
		max = 100
	)
	@Units(Units.TICKS)
	default int timeoutDelay()
	{
		return 40;
	}

	@Alpha
	@ConfigItem(
		keyName = "untaggedFishColor",
		name = "Untagged fish color",
		description = "Color of untagged fish.",
		position = 8
	)
	default Color untaggedFishColor()
	{
		return Color.CYAN;
	}

	@Alpha
	@ConfigItem(
			keyName = "untaggedFishFillColor",
			name = "Untagged fish fill color",
			description = "Fill color of untagged fish tile.",
			position = 9
	)
	default Color untaggedFishFillColor()
	{
		return new Color(0, 255, 255, 50);
	}

	@Alpha
	@ConfigItem(
		keyName = "taggedFishColor",
		name = "Tagged fish color",
		description = "Color of tagged fish.",
		position = 10
	)
	default Color taggedFishColor()
	{
		return Color.YELLOW;
	}

	@Alpha
	@ConfigItem(
		keyName = "taggedFishFillColor",
		name = "Tagged fish fill color",
		description = "Fill color of tagged fish tile.",
		position = 11
	)
	default Color taggedFishFillColor()
	{
		return new Color(255, 255, 0, 50);
	}

	@ConfigItem(
		keyName = "tagAnnette",
		name = "Tag Annette",
		description = "Tag Annette when no nets in inventory.",
		position = 12
	)
	default boolean tagAnnetteWhenNoNets()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightTacklebox",
		name = "Highlight tacklebox",
		description = "Highlight the tacklebox in your inventory when you have no drift nets.",
		position = 13
	)
	default boolean highlightTacklebox()
	{
		return false;
	}

	@Alpha
	@ConfigItem(
		keyName = "tackleboxColor",
		name = "Tacklebox highlight color",
		description = "Color for tacklebox inventory highlight.",
		position = 14
	)
	default Color tackleboxColor()
	{
		return Color.RED;
	}

	@Alpha
	@ConfigItem(
		keyName = "annetteTagColor",
		name = "Annette tag color",
		description = "Color of Annette tag.",
		position = 15
	)
	default Color annetteTagColor()
	{
		return Color.RED;
	}

	@Range(
			min = 0,
			max = 255
	)
	@ConfigItem(
			position = 16,
			keyName = "annetteFillOpacity",
			name = "Annette fill opacity",
			description = "Opacity of Annette fill color (0 = transparent, 255 = solid)."
	)
	default int annetteFillOpacity()
	{
		return 0;
	}

	@ConfigSection(
		name = "Timer",
		description = "Timer settings for tagged fish",
		position = 17,
		closedByDefault = true
	)
	String timerSection = "timer";

	@ConfigItem(
		keyName = "timerMode",
		name = "Timer display mode",
		description = "How to display the timer on tagged fish.",
		position = 18,
		section = timerSection
	)
	default TimerMode timerMode()
	{
		return TimerMode.OFF;
	}

	@ConfigSection(
		name = "Menu Options",
		description = "Menu entry hiding options",
		position = 19,
		closedByDefault = true
	)
	String menuSection = "menu";

	@ConfigItem(
		keyName = "hideTakeDown",
		name = "Hide 'Take down'",
		description = "Hide the 'Take down' option from empty drift nets.",
		position = 20,
		section = menuSection
	)
	default boolean hideTakeDown()
	{
		return false;
	}

	@ConfigItem(
		keyName = "swapUntaggedFish",
		name = "Swap untagged fish",
		description = "Prioritize untagged fish over tagged fish when they overlap, allowing left-click to tag both.",
		position = 21,
		section = menuSection
	)
	default boolean swapUntaggedFish()
	{
		return true;
	}

	@ConfigSection(
		name = "Statistics Overlay",
		description = "Fish caught statistics overlay",
		position = 22,
		closedByDefault = true
	)
	String statsSection = "stats";

	@ConfigItem(
		keyName = "showStatsOverlay",
		name = "Show stats overlay",
		description = "Show the statistics overlay in the drift net area.",
		position = 23,
		section = statsSection
	)
	default boolean showStatsOverlay()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showTotalFish",
		name = "Show total fish",
		description = "Show total fish caught since plugin installation.",
		position = 24,
		section = statsSection
	)
	default boolean showTotalFish()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showSessionFish",
		name = "Show session fish",
		description = "Show fish caught this session.",
		position = 25,
		section = statsSection
	)
	default boolean showSessionFish()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showFishPerHour",
		name = "Show fish/hour",
		description = "Show fish caught per hour this session.",
		position = 26,
		section = statsSection
	)
	default boolean showFishPerHour()
	{
		return true;
	}

	@ConfigSection(
		name = "Notifications",
		description = "Notification settings",
		position = 27,
		closedByDefault = false
	)
	String notificationSection = "notifications";

	@ConfigItem(
		keyName = "notifyOutOfNets",
		name = "Out of nets",
		description = "Send a notification when you run out of drift nets.",
		position = 28,
		section = notificationSection
	)
	default Notification notifyOutOfNets()
	{
		return Notification.OFF;
	}

	@ConfigItem(
		keyName = "notifyNetFull",
		name = "Net is full",
		description = "Send a notification when a drift net becomes full.",
		position = 29,
		section = notificationSection
	)
	default Notification notifyNetFull()
	{
		return Notification.OFF;
	}
}

/*
 * Copyright (c) 2020, dekvall <https://github.com/dekvall>
 * Copyright (c) 2026, Zipon <https://github.com/zipon458>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.driftnetenhanced;

import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.ui.overlay.components.TextComponent;

class DriftNetInventoryOverlay extends WidgetItemOverlay
{
	private static final int TACKLEBOX_ITEM_ID = 25580;
	private static final String TEXT_GET_MORE_NETS = "Get more nets";

	private final DriftNetConfig config;
	private final DriftNetPlugin plugin;
	private final ItemManager itemManager;

	private final TextComponent textComponent = new TextComponent();

	@Inject
	private DriftNetInventoryOverlay(DriftNetConfig config, DriftNetPlugin plugin, ItemManager itemManager)
	{
		this.config = config;
		this.plugin = plugin;
		this.itemManager = itemManager;
		showOnInventory();
	}

	@Override
	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem)
	{
		if (!config.highlightTacklebox() || !plugin.isInDriftNetArea())
		{
			return;
		}

		if (plugin.isDriftNetsInInventory())
		{
			return;
		}

		if (itemId != TACKLEBOX_ITEM_ID)
		{
			return;
		}

		Rectangle bounds = widgetItem.getCanvasBounds();

		final BufferedImage outline = itemManager.getItemOutline(itemId, widgetItem.getQuantity(), config.tackleboxColor());
		graphics.drawImage(outline, (int) bounds.getX(), (int) bounds.getY(), null);

		textComponent.setColor(config.tackleboxColor());
		textComponent.setText(TEXT_GET_MORE_NETS);

		FontMetrics fontMetrics = graphics.getFontMetrics();
		int textWidth = fontMetrics.stringWidth(TEXT_GET_MORE_NETS);
		int textHeight = fontMetrics.getHeight();

		textComponent.setPosition(new Point(
			bounds.x + bounds.width / 2 - textWidth / 2,
			bounds.y + bounds.height + textHeight / 2
		));

		textComponent.render(graphics);
	}
}

/*
 * Copyright (c) 2020, dekvall <https://github.com/dekvall>
 * Copyright (c) 2026, Zipon <https://github.com/zipon458>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.driftnetenhanced;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Shape;
import javax.inject.Inject;
import net.runelite.api.GameObject;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.components.ProgressPieComponent;

class DriftNetOverlay extends Overlay
{
	private final DriftNetConfig config;
	private final DriftNetPlugin plugin;

	// Performance: Reuse ProgressPieComponent instead of creating new one each frame
	private final ProgressPieComponent progressPie = new ProgressPieComponent();

	private Color cachedNetFillColor;
	private int cachedNetFillOpacity = -1;
	private Color cachedNetStatusColor;

	private Color cachedAnnetteFillColor;
	private int cachedAnnetteFillOpacity = -1;
	private Color cachedAnnetteColor;

	@Inject
	private DriftNetOverlay(DriftNetConfig config, DriftNetPlugin plugin)
	{
		this.config = config;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(PRIORITY_LOW);
		setLayer(OverlayLayer.ABOVE_SCENE);

		// Configure reusable pie component
		progressPie.setDiameter(20);
		progressPie.setBorderColor(Color.WHITE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!plugin.isInDriftNetArea())
		{
			return null;
		}

		if (config.highlightUntaggedFish() || config.highlightTaggedFish() || config.timerMode() != TimerMode.OFF)
		{
			renderFish(graphics);
		}
		if (config.showNetStatus())
		{
			renderNets(graphics);
		}
		if (config.tagAnnetteWhenNoNets())
		{
			renderAnnette(graphics);
		}

		return null;
	}

	private void renderFish(Graphics2D graphics)
	{
		for (NPC fish : plugin.getFish())
		{
			boolean isTagged = plugin.getTaggedFish().containsKey(fish);

			if (!isTagged && config.highlightUntaggedFish())
			{
				Polygon tilePoly = fish.getCanvasTilePoly();
				if (tilePoly != null)
				{
					graphics.setColor(config.untaggedFishFillColor());
					graphics.fill(tilePoly);
					graphics.setColor(config.untaggedFishColor());
					graphics.draw(tilePoly);
				}
			}
			else if (isTagged)
			{
				Polygon tilePoly = null;
				boolean needsTimer = config.timerMode() != TimerMode.OFF;

				// Render tagged fish highlight if enabled
				if (config.highlightTaggedFish())
				{
					tilePoly = fish.getCanvasTilePoly();
					if (tilePoly != null)
					{
						graphics.setColor(config.taggedFishFillColor());
						graphics.fill(tilePoly);
						graphics.setColor(config.taggedFishColor());
						graphics.draw(tilePoly);
					}
				}

				// Render timer on tagged fish if enabled
				if (needsTimer)
				{
					renderFishTimer(graphics, fish);
				}
			}
		}
	}

	private void renderFishTimer(Graphics2D graphics, NPC fish)
	{
		Integer taggedTick = plugin.getTaggedFish().get(fish);
		if (taggedTick == null)
		{
			return;
		}

		int currentTick = plugin.getClient().getTickCount();
		int ticksRemaining = (taggedTick + config.timeoutDelay()) - currentTick;

		if (ticksRemaining <= 0)
		{
			return;
		}

		Point location = fish.getCanvasTextLocation(graphics, "", 0);
		if (location == null)
		{
			return;
		}

		TimerMode mode = config.timerMode();
		switch (mode)
		{
			case TICKS:
				String tickText = String.valueOf(ticksRemaining);
				OverlayUtil.renderTextLocation(graphics, location, tickText, Color.WHITE);
				break;
			case SECONDS:
				int secondsRemaining = (int) Math.ceil(ticksRemaining * 0.6);
				String secondText = secondsRemaining + "s";
				OverlayUtil.renderTextLocation(graphics, location, secondText, Color.WHITE);
				break;
			case PIE:
				// Performance: Reuse progressPie component instead of creating new one
				double progress = (double) ticksRemaining / config.timeoutDelay();
				progressPie.setPosition(location);
				progressPie.setProgress(progress);
				progressPie.setFill(config.untaggedFishColor());
				progressPie.render(graphics);
				break;
		}
	}

	private void renderNets(Graphics2D graphics)
	{
		for (DriftNet net : plugin.getNETS())
		{
			if (net.getNet() == null)
			{
				continue;
			}

			final Shape polygon;
			if (config.useNetClickbox())
			{
				polygon = net.getNet().getClickbox();
			}
			else
			{
				polygon = net.getNet().getConvexHull();
			}

			if (polygon != null)
			{
				Color statusColor = net.getStatus().getColor();
				int opacity = config.netFillOpacity();

				if (opacity > 0)
				{
					if (cachedNetStatusColor != statusColor || cachedNetFillOpacity != opacity)
					{
						cachedNetStatusColor = statusColor;
						cachedNetFillOpacity = opacity;
						cachedNetFillColor = new Color(statusColor.getRed(), statusColor.getGreen(), statusColor.getBlue(), opacity);
					}
					graphics.setColor(cachedNetFillColor);
					graphics.fill(polygon);
				}
				graphics.setColor(statusColor);
				graphics.draw(polygon);
			}

			String text = net.getFormattedCountText();
			Point textLocation = net.getNet().getCanvasTextLocation(graphics, text, 0);
			if (textLocation != null)
			{
				OverlayUtil.renderTextLocation(graphics, textLocation, text, config.countColor());
			}
		}
	}

	private void renderAnnette(Graphics2D graphics)
	{
		GameObject annette = plugin.getAnnette();
		if (annette != null && !plugin.isDriftNetsInInventory())
		{
			Shape polygon = annette.getConvexHull();
			if (polygon != null)
			{
				Color annetteColor = config.annetteTagColor();
				int opacity = config.annetteFillOpacity();

				if (opacity > 0)
				{
					if (cachedAnnetteColor != annetteColor || cachedAnnetteFillOpacity != opacity)
					{
						cachedAnnetteColor = annetteColor;
						cachedAnnetteFillOpacity = opacity;
						cachedAnnetteFillColor = new Color(annetteColor.getRed(), annetteColor.getGreen(), annetteColor.getBlue(), opacity);
					}
					graphics.setColor(cachedAnnetteFillColor);
					graphics.fill(polygon);
				}
				graphics.setColor(annetteColor);
				graphics.draw(polygon);
			}
		}
	}
}

/*
 * Copyright (c) 2020, dekvall <https://github.com/dekvall>
 * Copyright (c) 2026, Zipon <https://github.com/zipon458>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.driftnetenhanced;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.inject.Provides;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.Getter;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.ObjectID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.Skill;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.Notifier;
import net.runelite.client.config.Notification;

@PluginDescriptor(
	name = "Drift Net Improved",
	description = "Drift net plugin with additional features",
	tags = {"hunter", "fishing", "drift", "net"}
)
public class DriftNetPlugin extends Plugin
{
	static final String CONFIG_GROUP = "driftnetenhanced";
	private static final int UNDERWATER_REGION = 15008;
	private static final String CHAT_PRODDING_FISH = "You prod at the shoal of fish to scare it.";

	@Inject
	@Getter
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private DriftNetConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private DriftNetOverlay overlay;

	@Inject
	private DriftNetStatsOverlay statsOverlay;

	@Inject
	private DriftNetInventoryOverlay inventoryOverlay;

	@Inject
	private Notifier notifier;

	@Inject
	private ConfigManager configManager;

	@Getter
	private final Set<NPC> fish = new HashSet<>();
	@Getter
	private final Map<NPC, Integer> taggedFish = new HashMap<>();
	@Getter
	private final List<DriftNet> NETS = ImmutableList.of(
		new DriftNet(ObjectID.FOSSIL_DRIFT_NET1_MULTI, VarbitID.FOSSIL_DRIFT_NET1, VarbitID.FOSSIL_DRIFT_NET1_CATCH, ImmutableSet.of(
			new WorldPoint(3746, 10297, 1),
			new WorldPoint(3747, 10297, 1),
			new WorldPoint(3748, 10297, 1),
			new WorldPoint(3749, 10297, 1)
		)),
		new DriftNet(ObjectID.FOSSIL_DRIFT_NET2_MULTI, VarbitID.FOSSIL_DRIFT_NET2, VarbitID.FOSSIL_DRIFT_NET2_CATCH, ImmutableSet.of(
			new WorldPoint(3742, 10288, 1),
			new WorldPoint(3742, 10289, 1),
			new WorldPoint(3742, 10290, 1),
			new WorldPoint(3742, 10291, 1),
			new WorldPoint(3742, 10292, 1)
		)));

	@Getter
	private boolean inDriftNetArea;
	private boolean armInteraction;

	@Getter
	private boolean driftNetsInInventory;

	@Getter
	private GameObject annette;

	// Statistics tracking
	@Getter
	private int totalFishCaught;
	@Getter
	private int sessionFishCaught;
	@Getter
	private long sessionStartTime;
	private int lastHunterXp;

	private static final double MIN_XP = 72.0;
	private static final double MAX_XP = 101.5;
	private static final int MIN_LEVEL = 50;
	private static final int MAX_LEVEL = 70;
	private static final double XP_PER_LEVEL = (MAX_XP - MIN_XP) / (MAX_LEVEL - MIN_LEVEL);

	@Provides
	DriftNetConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(DriftNetConfig.class);
	}

	@Override
	protected void startUp()
	{
		overlayManager.add(overlay);
		overlayManager.add(statsOverlay);
		overlayManager.add(inventoryOverlay);
		sessionStartTime = System.currentTimeMillis();

		Integer savedTotal = configManager.getConfiguration(CONFIG_GROUP, "totalFishCaught", Integer.class);
		totalFishCaught = (savedTotal != null) ? savedTotal : 0;

		if (client.getGameState() == GameState.LOGGED_IN)
		{
			clientThread.invokeLater(() ->
			{
				inDriftNetArea = checkArea();
				updateDriftNetVarbits();
				lastHunterXp = client.getSkillExperience(Skill.HUNTER);
			});
		}
	}

	@Override
	protected void shutDown()
	{
		// Save total fish count to config
		configManager.setConfiguration(CONFIG_GROUP, "totalFishCaught", totalFishCaught);

		overlayManager.remove(overlay);
		overlayManager.remove(statsOverlay);
		overlayManager.remove(inventoryOverlay);
		reset();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		switch (event.getGameState())
		{
			case LOGIN_SCREEN:
			case HOPPING:
			case LOADING:
				annette = null;
				reset();
				break;
			case LOGGED_IN:
				inDriftNetArea = checkArea();
				updateDriftNetVarbits();
				break;
		}
	}

	private void reset()
	{
		fish.clear();
		taggedFish.clear();
		armInteraction = false;
		inDriftNetArea = false;
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		updateDriftNetVarbits();
	}

	private void updateDriftNetVarbits()
	{
		if (!inDriftNetArea)
		{
			return;
		}

		for (DriftNet net : NETS)
		{
			DriftNetStatus oldStatus = net.getStatus();
			DriftNetStatus status = DriftNetStatus.of(client.getVarbitValue(net.getStatusVarbit()));
			int count = client.getVarbitValue(net.getCountVarbit());

			net.setStatus(status);
			net.setCount(count);

			if (config.notifyNetFull() != Notification.OFF && oldStatus != DriftNetStatus.FULL && status == DriftNetStatus.FULL)
			{
				notifier.notify(config.notifyNetFull(), "A drift net is full!");
			}
		}
	}

	@Subscribe
	public void onInteractingChanged(InteractingChanged event)
	{
		if (armInteraction
			&& event.getSource() == client.getLocalPlayer()
			&& event.getTarget() instanceof NPC
			&& ((NPC) event.getTarget()).getId() == NpcID.FOSSIL_FISH_SHOAL)
		{
			tagFish(event.getTarget());
			armInteraction = false;
		}
	}

	private boolean isFishNextToNet(NPC fish, Collection<DriftNet> nets)
	{
		if (nets.isEmpty())
		{
			return false;
		}
		final WorldPoint fishTile = WorldPoint.fromLocalInstance(client, fish.getLocalLocation());
		for (DriftNet net : nets)
		{
			if (net.getAdjacentTiles().contains(fishTile))
			{
				return true;
			}
		}
		return false;
	}

	private boolean isTagExpired(Integer tick)
	{
		return tick + config.timeoutDelay() <= client.getTickCount();
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		if (!inDriftNetArea)
		{
			return;
		}

		if (!taggedFish.isEmpty())
		{
			List<DriftNet> closedNets = null;
			for (DriftNet net : NETS)
			{
				if (net.isNotAcceptingFish())
				{
					if (closedNets == null)
					{
						closedNets = new java.util.ArrayList<>(2);
					}
					closedNets.add(net);
				}
			}

			if (closedNets != null)
			{
				final List<DriftNet> finalClosedNets = closedNets;
				taggedFish.entrySet().removeIf(entry ->
					isTagExpired(entry.getValue()) ||
					isFishNextToNet(entry.getKey(), finalClosedNets)
				);
			}
			else
			{
				taggedFish.entrySet().removeIf(entry -> isTagExpired(entry.getValue()));
			}
		}

		for (DriftNet net : NETS)
		{
			net.setPrevTickStatus(net.getStatus());
		}

		armInteraction = false;
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (!inDriftNetArea)
		{
			return;
		}

		if (event.getType() == ChatMessageType.SPAM && event.getMessage().equals(CHAT_PRODDING_FISH))
		{
			Actor target = client.getLocalPlayer().getInteracting();

			if (target instanceof NPC && ((NPC) target).getId() == NpcID.FOSSIL_FISH_SHOAL)
			{
				tagFish(target);
			}
			else
			{
				// If the fish is on an adjacent tile, the interaction change happens after
				// the chat message is sent, so we arm it
				armInteraction = true;
			}
		}
	}

	private void tagFish(Actor fish)
	{
		NPC fishTarget = (NPC) fish;
		taggedFish.put(fishTarget, client.getTickCount());
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
		final NPC npc = event.getNpc();
		if (npc.getId() == NpcID.FOSSIL_FISH_SHOAL)
		{
			fish.add(npc);
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
		final NPC npc = event.getNpc();
		fish.remove(npc);
		taggedFish.remove(npc);
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		GameObject object = event.getGameObject();
		int objectId = object.getId();

		if (objectId == ObjectID.FOSSIL_MERMAID_DRIFTNETS)
		{
			annette = object;
			return;
		}

		if (objectId != ObjectID.FOSSIL_DRIFT_NET1_MULTI && objectId != ObjectID.FOSSIL_DRIFT_NET2_MULTI)
		{
			return;
		}

		for (DriftNet net : NETS)
		{
			if (net.getObjectId() == objectId)
			{
				net.setNet(object);
				break;
			}
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned event)
	{
		GameObject object = event.getGameObject();
		if (object == annette)
		{
			annette = null;
			return;
		}

		int objectId = object.getId();

		if (objectId != ObjectID.FOSSIL_DRIFT_NET1_MULTI && objectId != ObjectID.FOSSIL_DRIFT_NET2_MULTI)
		{
			return;
		}

		for (DriftNet net : NETS)
		{
			if (net.getObjectId() == objectId)
			{
				net.setNet(null);
				break;
			}
		}
	}

	@Subscribe
	public void onItemContainerChanged(final ItemContainerChanged event)
	{
		final ItemContainer itemContainer = event.getItemContainer();
		if (itemContainer != client.getItemContainer(InventoryID.INV))
		{
			return;
		}

		boolean hadNets = driftNetsInInventory;
		driftNetsInInventory = itemContainer.contains(ItemID.FOSSIL_DRIFT_NET);

		if (config.notifyOutOfNets() != Notification.OFF && inDriftNetArea && hadNets && !driftNetsInInventory)
		{
			notifier.notify(config.notifyOutOfNets(), "You are out of drift nets!");
		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		if (!inDriftNetArea)
		{
			return;
		}

		// Hide "Take down" option from drift nets
		if (config.hideTakeDown() && event.getOption().equals("Take down") && event.getTarget().contains("Drift net"))
		{
			MenuEntry[] menuEntries = client.getMenuEntries();
			menuEntries = Arrays.copyOf(menuEntries, menuEntries.length - 1);
			client.setMenuEntries(menuEntries);
			return;
		}

		// Swap fish menu entries to prioritize untagged fish
		if (config.swapUntaggedFish() && event.getOption().equals("Chase") && event.getTarget().contains("Fish shoal"))
		{
			swapFishMenuEntries();
		}
	}

	private void swapFishMenuEntries()
	{
		MenuEntry[] menuEntries = client.getMenuEntries();
		if (menuEntries.length < 2)
		{
			return;
		}

		if (taggedFish.isEmpty())
		{
			return;
		}

		// Find "Chase" options for fish shoals - separate tagged from untagged
		int untaggedIndex = -1;
		int taggedIndex = -1;

		for (int i = menuEntries.length - 1; i >= 0; i--)
		{
			MenuEntry entry = menuEntries[i];
			if (entry.getOption().equals("Chase") && entry.getTarget().contains("Fish shoal"))
			{
				// Get the NPC from the menu entry
				NPC npc = entry.getNpc();
				if (npc != null)
				{
					// Check if this fish is in our tagged fish map
					boolean isTagged = taggedFish.containsKey(npc);

					if (!isTagged && untaggedIndex == -1)
					{
						// Found the first untagged fish
						untaggedIndex = i;
					}
					else if (isTagged && taggedIndex == -1)
					{
						// Found the first tagged fish
						taggedIndex = i;
					}

					// Early exit: if we found both, no need to continue
					if (untaggedIndex != -1 && taggedIndex != -1)
					{
						break;
					}
				}
			}
		}

		// If we found both tagged and untagged fish, and untagged is NOT already on top
		// Swap them so untagged becomes the left-click option
		if (untaggedIndex != -1 && taggedIndex != -1 && untaggedIndex < taggedIndex)
		{
			MenuEntry temp = menuEntries[untaggedIndex];
			menuEntries[untaggedIndex] = menuEntries[taggedIndex];
			menuEntries[taggedIndex] = temp;
			client.setMenuEntries(menuEntries);
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged event)
	{
		if (event.getSkill() != Skill.HUNTER)
		{
			return;
		}

		int currentXp = event.getXp();
		if (currentXp > lastHunterXp)
		{
			int xpGained = currentXp - lastHunterXp;

			// Calculate XP per fish based on Hunter level
			// Drift net XP scales from 72 XP at level 50 to 101.5 XP at level 70+
			int hunterLevel = event.getLevel();
			double xpPerFish = calculateDriftNetXp(hunterLevel);

			// Calculate fish caught (rounded to handle decimal XP values)
			int fishCaught = (int) Math.round(xpGained / xpPerFish);

			if (fishCaught > 0 && inDriftNetArea)
			{
				totalFishCaught += fishCaught;
				sessionFishCaught += fishCaught;

				// Save total fish count to config
				configManager.setConfiguration(CONFIG_GROUP, "totalFishCaught", totalFishCaught);
			}
		}
		lastHunterXp = currentXp;
	}

	private double calculateDriftNetXp(int hunterLevel)
	{
		// Drift net XP scales linearly from level 50 to 70
		// Level 50: 72 XP per fish
		// Level 70+: 101.5 XP per fish
		if (hunterLevel < MIN_LEVEL)
		{
			return MIN_XP;
		}
		else if (hunterLevel >= MAX_LEVEL)
		{
			return MAX_XP;
		}
		else
		{
			// Linear scaling between 50 and 70 using precomputed constant
			return MIN_XP + ((hunterLevel - MIN_LEVEL) * XP_PER_LEVEL);
		}
	}

	private boolean checkArea()
	{
		final Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null || !client.isInInstancedRegion())
		{
			return false;
		}

		final WorldPoint point = WorldPoint.fromLocalInstance(client, localPlayer.getLocalLocation());
		if (point == null)
		{
			return false;
		}

		return point.getRegionID() == UNDERWATER_REGION;
	}
}

/*
 * Copyright (c) 2020, dekvall <https://github.com/dekvall>
 * Copyright (c) 2026, Zipon <https://github.com/zipon458>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.driftnetenhanced;

import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

class DriftNetStatsOverlay extends Overlay
{
	private final DriftNetConfig config;
	private final DriftNetPlugin plugin;
	private final PanelComponent panelComponent = new PanelComponent();

	// Cache for fish per hour display (updates every 2 seconds)
	private int cachedFishPerHour = 0;
	private long lastFishPerHourUpdate = 0;
	private static final long FISH_PER_HOUR_UPDATE_INTERVAL = 2000;

	@Inject
	private DriftNetStatsOverlay(DriftNetConfig config, DriftNetPlugin plugin)
	{
		this.config = config;
		this.plugin = plugin;
		setPosition(OverlayPosition.TOP_LEFT);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.showStatsOverlay() || !plugin.isInDriftNetArea())
		{
			return null;
		}

		panelComponent.getChildren().clear();

		panelComponent.getChildren().add(TitleComponent.builder()
			.text("Drift Net Stats")
			.build());

		// Total fish caught
		if (config.showTotalFish())
		{
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Total:")
				.right(String.valueOf(plugin.getTotalFishCaught()))
				.build());
		}

		// Session fish caught
		if (config.showSessionFish())
		{
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Session:")
				.right(String.valueOf(plugin.getSessionFishCaught()))
				.build());
		}

		// Fish per hour
		if (config.showFishPerHour())
		{
			long currentTime = System.currentTimeMillis();

			// Only recalculate fish per hour every 2 seconds
			if (currentTime - lastFishPerHourUpdate >= FISH_PER_HOUR_UPDATE_INTERVAL)
			{
				long sessionTime = currentTime - plugin.getSessionStartTime();
				double hoursElapsed = sessionTime / (1000.0 * 60.0 * 60.0);
				cachedFishPerHour = hoursElapsed > 0 ? (int) (plugin.getSessionFishCaught() / hoursElapsed) : 0;
				lastFishPerHourUpdate = currentTime;
			}

			panelComponent.getChildren().add(LineComponent.builder()
				.left("Per hour:")
				.right(String.valueOf(cachedFishPerHour))
				.build());
		}

		return panelComponent.render(graphics);
	}
}

/*
 * Copyright (c) 2020, dekvall <https://github.com/dekvall>
 * Copyright (c) 2026, Zipon <https://github.com/zipon458>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.driftnetenhanced;

import java.awt.Color;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
enum DriftNetStatus
{
	UNSET(Color.YELLOW),
	SET(Color.GREEN),
	CATCH(Color.GREEN),
	FULL(Color.RED);

	private final Color color;

	static DriftNetStatus of(int varbitValue)
	{
		switch (varbitValue)
		{
			case 0:
				return UNSET;
			case 1:
				return SET;
			case 2:
				return CATCH;
			case 3:
				return FULL;
			default:
				return null;
		}
	}
}

/*
 * Copyright (c) 2020, dekvall <https://github.com/dekvall>
 * Copyright (c) 2026, Zipon <https://github.com/zipon458>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.driftnetenhanced;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum TimerMode
{
	OFF("Off"),
	TICKS("Ticks"),
	SECONDS("Seconds"),
	PIE("Pie timer");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

package com.driftnetenhanced;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class DriftNetPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DriftNetPlugin.class);
		RuneLite.main(args);
	}
}

