package com.bingosrs.api;

import com.bingosrs.BingOSRSConfig;
import com.bingosrs.BingOSRSPlugin;
import com.bingosrs.api.message.AuthResponse;
import com.bingosrs.api.model.Bingo;
import com.bingosrs.api.model.Team;
import com.bingosrs.api.message.AuthRequest;
import com.bingosrs.api.model.tile.CustomTile;
import com.bingosrs.api.model.tile.PointTile;
import com.bingosrs.api.model.tile.StandardTile;
import com.bingosrs.api.model.tile.Tile;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.GameTick;
import net.runelite.client.util.RuntimeTypeAdapterFactory;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.concurrent.CompletableFuture;

@Slf4j
@Singleton
public class BingOSRSService {
    private static final String SCHEME = "https";
    private static final String HOST = "api.bingosrs.com";
    private static final int PORT = 443;

    @Inject
    private OkHttpClient client;

    @Inject
    private Gson gson;

    @Inject
    private BingOSRSConfig config;

    @Inject
    private BingOSRSPlugin plugin;


    // Default to true so this pulls on first game tick
    private boolean shouldFetchAuth = true;
    private String accessToken;

    public void setAccessToken(String accessToken) {
        this.accessToken = accessToken;
        this.plugin.updatePanel();
    }

    public void startUp() {
        RuntimeTypeAdapterFactory<Tile> tileAdapter = RuntimeTypeAdapterFactory
                .of(Tile.class, "__t")
                .registerSubtype(StandardTile.class, "StandardTile")
                .registerSubtype(PointTile.class, "PointTile")
                .registerSubtype(CustomTile.class, "CustomTile");

        this.gson = this.gson.newBuilder()
                .registerTypeAdapterFactory(tileAdapter)
                .create();

        triggerAuth(false);
    }

    private String request(Request request) throws Exception {
        String json = null;
        Call call = client.newCall(request);
        Response response = null;

        try {
            response = call.execute();
            if (!response.isSuccessful()) {
                throw new IOException("Request failed with code: " + response.code() + " message: " + response.message());
            }
            ResponseBody body = response.body();
            if (body != null) {
                json = body.string();
            }
            return json;

        } catch (IOException e) {
            throw e;
        }
        finally {
            if(response != null) {
                response.close();
            }
        }
    }

    public void onGameTick(GameTick gameTick) {
        if (this.shouldFetchAuth) {
            this.shouldFetchAuth = false;
            this.fetchAuthTokenAsync();
        }
    }

    public void triggerAuth() {
        triggerAuth(true);
    }

    public void triggerAuth(boolean lazy) {
        if (lazy) {
            this.shouldFetchAuth = true;
        } else {
            this.fetchAuthTokenAsync();
        }
    }

    private CompletableFuture<Void> fetchAuthTokenAsync() {
        setAccessToken(null);
        CompletableFuture<Void> future = new CompletableFuture<>();
        if (config.bingoId().isBlank() || config.playerToken().isBlank()) {
            future.complete(null);
            return future;
        }

        HttpUrl url = new HttpUrl.Builder().scheme(SCHEME).host(HOST).port(PORT)
                .addPathSegment("auth").addPathSegment("login").addPathSegment("player").build();

        AuthRequest authRequest = new AuthRequest(config.bingoId(), config.playerToken());
        String json = gson.toJson(authRequest);

        RequestBody body = RequestBody.create(MediaType.get("application/json"), json);
        Request request = new Request.Builder().url(url).post(body).build();

        CompletableFuture.supplyAsync(() -> {
            try {
                String syncResponseJSON = request(request);
                AuthResponse authResponse = gson.fromJson(syncResponseJSON, AuthResponse.class);
                setAccessToken(authResponse.accessToken);
                log.debug("Successfully authenticated for bingo");
                future.complete(null);
            } catch (Exception e) {
                setAccessToken(null);
                log.debug("Authentication failed for bingo");
                future.completeExceptionally(e);
            }
            return null;
        });

        return future;
    }

    public CompletableFuture<Team[]> fetchTeamsAsync() {
        CompletableFuture<Team[]> future = new CompletableFuture<>();

        HttpUrl url = new HttpUrl.Builder().scheme(SCHEME).host(HOST).port(PORT)
                .addPathSegment("bingo").addPathSegment(config.bingoId()).addPathSegment("teams").build();

        Request request = new Request.Builder().url(url).build();

        CompletableFuture.supplyAsync(() -> {
            try {
                String syncResponseJSON = request(request);

                Type teamListType = new TypeToken<Team[]>(){}.getType();
                Team[] teams = gson.fromJson(syncResponseJSON, teamListType);

                future.complete(teams);
            } catch (Exception e) {
                log.debug("Error while fetching teams: {}", e.getMessage());
                future.completeExceptionally(e);
            }
            return null; // supplyAsync requires a return value, but it won't be used here
        });

        return future;
    }

    public CompletableFuture<Bingo> fetchBingoAsync() {
        CompletableFuture<Bingo> future = new CompletableFuture<>();

        HttpUrl url = new HttpUrl.Builder().scheme(SCHEME).host(HOST).port(PORT)
                .addPathSegment("bingo").addPathSegment(config.bingoId()).build();

        Request request = new Request.Builder().url(url).build();

        CompletableFuture.supplyAsync(() -> {
            try {
                String syncResponseJSON = request(request);

                Type bingoType = new TypeToken<Bingo>(){}.getType();
                Bingo bingo = gson.fromJson(syncResponseJSON, bingoType);

                future.complete(bingo);
            } catch (Exception e) {
                log.debug("Error while fetching bingo: {}", e.getMessage());
                future.completeExceptionally(e);
            }
            return null; // supplyAsync requires a return value, but it won't be used here
        });

        return future;
    }

    public CompletableFuture<String> submitDropAsync(String bingoId, byte[] screenshotBytes, String player, Integer itemId, Integer npcId) {
        return submitDropAttempt(bingoId, screenshotBytes, player, itemId, npcId, false); // initial attempt
    }

    private CompletableFuture<String> submitDropAttempt(String bingoId, byte[] screenshotBytes, String player, int itemId, int npcId, boolean isRetry) {
        CompletableFuture<String> future = new CompletableFuture<>();

        HttpUrl url = new HttpUrl.Builder().scheme(SCHEME).host(HOST).port(PORT)
                .addPathSegment("bingo").addPathSegment(bingoId).addPathSegment("drop").build();

        RequestBody requestBody = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("__t", "Standard")
                .addFormDataPart("player", player)
                .addFormDataPart("boss", Integer.toString(npcId))
                .addFormDataPart("item", Integer.toString(itemId))
                .addFormDataPart("screenshot", "screenshot.png",
                        RequestBody.create(MediaType.parse("image/png"), screenshotBytes))
                .build();

        Request request = new Request.Builder()
                .url(url)
                .post(requestBody)
                .header("Authorization", "Bearer " + accessToken)
                .build();

        CompletableFuture.supplyAsync(() -> {
            try {
                String responseString = request(request);
                future.complete(responseString);
            } catch (Exception e) {
                if (e.getMessage().contains("401") && !isRetry) {
                    log.debug("Auth error submitting drop to bingo: {}. Reauthenticating...", bingoId);
                    // If auth error, force re-auth and then retry once
                    fetchAuthTokenAsync()
                            .thenRun(() -> {
                                submitDropAttempt(bingoId, screenshotBytes, player, itemId, npcId, true)
                                        .whenComplete((result, throwable) -> {
                                            if (throwable != null) {
                                                future.completeExceptionally(throwable);
                                            } else {
                                                future.complete(result);
                                            }
                                        });
                            })
                            .exceptionally(throwable -> {
                                future.completeExceptionally(throwable);
                                return null;
                            });

                } else {
                    log.debug("Error submitting bingo drop: {}", e.getMessage());
                    future.completeExceptionally(e);
                }
            }
            return null;
        });

        return future;
    }

    public boolean isAuthenticated() {
        return this.accessToken != null;
    }
}

package com.bingosrs.api.message;

import com.google.gson.annotations.SerializedName;

public class AuthRequest {
    @SerializedName("bingoId")
    String bingoId;
    @SerializedName("token")
    String token;

    public AuthRequest(String bingoId, String token) {
        this.bingoId = bingoId;
        this.token = token;
    }
}

package com.bingosrs.api.message;

import com.google.gson.annotations.SerializedName;

public class AuthResponse {
    @SerializedName("access_token")
    public String accessToken;
}

package com.bingosrs.api.model;

import com.google.gson.annotations.SerializedName;

public class Bingo {
    @SerializedName("_id")
    public String id;

    @SerializedName("name")
    public String name;

    @SerializedName("board")
    public Board board;

    @SerializedName("state")
    public String state;

}

package com.bingosrs.api.model;

import com.bingosrs.api.model.tile.Tile;
import com.google.gson.annotations.SerializedName;

public class Board {
    @SerializedName("size")
    public Integer size;

    @SerializedName("tiles")
    public Tile[] tiles;
}

package com.bingosrs.api.model;

import com.google.gson.annotations.SerializedName;

public class Drop {
    @SerializedName("item")
    public Integer item;

    @SerializedName("player")
    public String player;
}

package com.bingosrs.api.model;

import com.google.gson.annotations.SerializedName;

public class RequiredDrop {
    @SerializedName("item")
    public Integer item;

    @SerializedName("bosses")
    public Integer[] bosses;
}

package com.bingosrs.api.model;
import com.google.gson.annotations.SerializedName;

public class Team {
    @SerializedName("name")
    public String name;

    @SerializedName("players")
    public String[] players;

    @SerializedName("remainingDrops")
    public RequiredDrop[][] remainingDrops;

    @SerializedName("drops")
    public Drop[][] drops;
}

package com.bingosrs.api.model.tile;

import com.bingosrs.api.model.RequiredDrop;

public class CustomTile extends Tile {
    public RequiredDrop[] getRequiredDrops() {
        return new RequiredDrop[0];
    }
}

package com.bingosrs.api.model.tile;

import com.bingosrs.api.model.RequiredDrop;
import com.google.gson.annotations.SerializedName;

public class PointTile extends Tile {
    @SerializedName("requiredDropValues")
    private RequiredDrop[] requiredDropValues;

    public RequiredDrop[] getRequiredDrops() {
        return this.requiredDropValues;
    }
}
package com.bingosrs.api.model.tile;

import com.bingosrs.api.model.RequiredDrop;
import com.google.gson.annotations.SerializedName;

public class StandardTile extends Tile {
    @SerializedName("requiredDrops")
    public RequiredDrop[] requiredDrops;

    public RequiredDrop[] getRequiredDrops() {
        return this.requiredDrops;
    }
}
package com.bingosrs.api.model.tile;

import com.bingosrs.api.model.RequiredDrop;
import com.google.gson.annotations.SerializedName;

public abstract class Tile {
    @SerializedName("__t")
    public String __t;

    @SerializedName("description")
    public String description;


    public abstract RequiredDrop[] getRequiredDrops();
}
package com.bingosrs;

import com.bingosrs.api.BingOSRSService;
import com.bingosrs.api.model.Bingo;
import com.bingosrs.api.model.RequiredDrop;
import com.bingosrs.api.model.Team;
import com.bingosrs.panel.BingOSRSPanel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.events.ConfigChanged;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;

@Slf4j
@Singleton
public class BingoInfoManager {
    public static final String CONFIG_GROUP = "bingosrs";

    @Inject
    private BingOSRSConfig config;

    @Inject
    private Client client;

    @Inject
    private BingOSRSService bingOSRSService;

    @Inject
    private BingOSRSPlugin plugin;

    // Default to true so this pulls on first game tick
    private boolean shouldUpdateData = true;

    @Getter
    private Bingo bingo;
    @Getter
    private Team[] teams;
    @Getter
    private Team team;

    public void setBingo(Bingo bingo) {
        this.bingo = bingo;
        this.plugin.updatePanel();
    }

    public void setTeam(Team team) {
        this.team = team;
        this.plugin.updatePanel();
    }

    public void setTeams(Team[] teams) {
        this.teams = teams;
        this.plugin.updatePanel();
    }

    public void startUp() {
        this.updateData();
    }

    public void onGameTick(GameTick gameTick) {
        if (this.shouldUpdateData) {
            this.shouldUpdateData = false;
            this.updateData();
        }
    }

    public void triggerUpdateData() {
        triggerUpdateData(true);
    }

    public void triggerUpdateData(boolean lazy) {
        if (lazy) {
            shouldUpdateData = true;
        } else {
            updateData();
        }
    }

    private void updateData() {
        setBingo(null);
        setTeam(null);
        setTeams(null);

        if (config.bingoId().isBlank()) {
            return;
        }
        bingOSRSService.fetchBingoAsync()
                .thenAccept(bingo -> {
                    setBingo(bingo);
                    if (!bingo.state.equals("Signup")) {
                        bingOSRSService.fetchTeamsAsync()
                                .thenAccept(teams -> {
                                    setTeams(teams);
                                    if (client.getLocalPlayer() != null) {
                                        boolean onTeam = false;
                                        for (Team team: teams) {
                                            if (Arrays.asList(team.players).contains(client.getLocalPlayer().getName())) {
                                                setTeam(team);
                                                onTeam = true;
                                                break;
                                            }
                                        }

                                        if (!onTeam) {
                                            setTeam(null);
                                            log.debug("No team found for player");
                                        } else {
                                            log.debug("Team data updated");
                                        }
                                    }
                                })
                                .exceptionally(throwable -> null);
                    }
                })
                .exceptionally(throwable -> null);
    }

    public boolean isRequiredDrop(Integer itemId, Integer npcId) {
        if (team == null) {
            return false;
        }

        for (RequiredDrop[] tileDrops: this.team.remainingDrops) {
            for (RequiredDrop requiredDrop: tileDrops) {
                if (Objects.equals(requiredDrop.item, itemId)) {
                    if (requiredDrop.bosses.length == 0 || Arrays.asList(requiredDrop.bosses).contains(npcId)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}

package com.bingosrs;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("bingosrs")
public interface BingOSRSConfig extends Config
{
	@ConfigItem(
		keyName = "bingoId",
		name = "Bingo ID",
		description = "ID of the bingo "
	)
	default String bingoId()
	{
		return "";
	}

	@ConfigItem(
			keyName = "playerToken",
			name = "Player Token",
			description = "Player token for the bingo. Required to submit drops.",
			secret = true
	)
	default String playerToken()
	{
		return "";
	}
}

package com.bingosrs;

import com.bingosrs.api.BingOSRSService;
import com.bingosrs.notifiers.LootNotifier;
import com.bingosrs.panel.BingOSRSPanel;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.*;
import net.runelite.api.gameval.NpcID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.*;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

import java.util.concurrent.atomic.AtomicReference;

@Slf4j
@PluginDescriptor(
	name = "BingOSRS"
)
public class BingOSRSPlugin extends Plugin
{
	@Inject
	private BingoInfoManager bingoInfoManager;

	@Inject
	private BingOSRSService bingOSRSService;

	@Inject
	private LootNotifier lootNotifier;

	@Inject
	private ClientToolbar clientToolbar;

	private BingOSRSPanel panel;
	private NavigationButton navButton;

	private final AtomicReference<GameState> gameState = new AtomicReference<>();

	@Override
	protected void startUp() {
		panel = injector.getInstance(BingOSRSPanel.class);

		navButton = NavigationButton.builder()
				.tooltip("BingOSRS")
				.icon(ImageUtil.loadImageResource(getClass(), "/panel_icon.png"))
				.priority(5)
				.panel(panel)
				.build();
		clientToolbar.addNavigation(navButton);

		this.bingOSRSService.startUp();
		this.bingoInfoManager.startUp();

		log.debug("Started up BingOSRS");
	}

	@Override
	protected void shutDown() {
		log.debug("Shutting down BingOSRS");
		gameState.lazySet(null);
	}

	@Provides
	BingOSRSConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(BingOSRSConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (!BingoInfoManager.CONFIG_GROUP.equals(event.getGroup())) {
			return;
		}

        bingOSRSService.triggerAuth(false);
		if (event.getKey().equals("bingoId")) {
			bingoInfoManager.triggerUpdateData(false);
		}
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		bingoInfoManager.onGameTick(event);
		bingOSRSService.onGameTick(event);
	}

	@Subscribe(priority = 1) // run before the base loot tracker plugin
	public void onServerNpcLoot(ServerNpcLoot event) {
		// temporarily only use new event when needed
		if (event.getComposition().getId() != NpcID.YAMA) {
			return;
		}
		lootNotifier.onServerNpcLoot(event);
	}

	@Subscribe(priority = 1) // run before the base loot tracker plugin
	public void onNpcLootReceived(NpcLootReceived npcLootReceived) {
		if (npcLootReceived.getNpc().getId() == NpcID.YAMA) {
			// handled by ServerNpcLoot, but return just in case
			return;
		}

		lootNotifier.onNpcLootReceived(npcLootReceived);
	}

	@Subscribe
	public void onLootReceived(LootReceived lootReceived) {
		lootNotifier.onLootReceived(lootReceived);
	}

	public void updatePanel() {
		this.panel.update();
	}
}

package com.bingosrs.notifiers;

import com.bingosrs.BingOSRSConfig;
import com.bingosrs.BingoInfoManager;
import com.bingosrs.api.BingOSRSService;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.gameval.NpcID;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.events.ServerNpcLoot;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.http.api.loottracker.LootRecordType;
import okhttp3.MediaType;
import okhttp3.RequestBody;
import org.apache.commons.lang3.StringUtils;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j
@Singleton
public class LootNotifier {

    public static final Set<Integer> SPECIAL_LOOT_NPC_IDS = Set.of(
            NpcID.WHISPERER, NpcID.WHISPERER_MELEE, NpcID.WHISPERER_QUEST, NpcID.WHISPERER_MELEE_QUEST,
            NpcID.ARAXXOR, NpcID.ARAXXOR_DEAD, NpcID.RT_FIRE_QUEEN_INACTIVE, NpcID.RT_ICE_KING_INACTIVE
    );
    public static final Set<String> SPECIAL_LOOT_NPC_NAMES = Set.of("The Whisperer", "Araxxor", "Branda the Fire Queen", "Eldric the Ice King");

    @Inject
    private BingOSRSConfig bingOSRSConfig;

    @Inject
    private BingoInfoManager bingoInfoManager;

    @Inject
    private BingOSRSService bingOSRSService;

    @Inject
    private Client client;

    @Inject
    private DrawManager drawManager;

    public void onServerNpcLoot(ServerNpcLoot event) {
        var comp = event.getComposition();
        this.handleNotify(event.getItems(), comp.getName(), LootRecordType.NPC, comp.getId());
    }

    public void onNpcLootReceived(NpcLootReceived event) {
        NPC npc = event.getNpc();
        int id = npc.getId();
        if (SPECIAL_LOOT_NPC_IDS.contains(id)) {
            // LootReceived is fired for certain NPCs rather than NpcLootReceived, but return here just in case upstream changes their implementation.
            return;
        }

        this.handleNotify(event.getItems(), npc.getName(), LootRecordType.NPC, id);
    }

    public void onLootReceived(LootReceived lootReceived) {
        // only consider non-NPC and non-PK loot
        if (lootReceived.getType() == LootRecordType.EVENT || lootReceived.getType() == LootRecordType.PICKPOCKET) {
            this.handleNotify(lootReceived.getItems(), lootReceived.getName(), lootReceived.getType(), null);
        } else if (lootReceived.getType() == LootRecordType.NPC && SPECIAL_LOOT_NPC_NAMES.contains(lootReceived.getName())) {
            // Special case: upstream fires LootReceived for certain NPCs, but not NpcLootReceived
            this.handleNotify(lootReceived.getItems(), lootReceived.getName(), lootReceived.getType(), null);
        }
    }

    private void handleNotify(Collection<ItemStack> items, String dropper, LootRecordType type, Integer npcId) {
        if (npcId == null && (type == LootRecordType.NPC || type == LootRecordType.PICKPOCKET)) {
            npcId = client.getTopLevelWorldView().npcs().stream()
                    .filter(npc -> dropper.equals(npc.getName()))
                    .findAny()
                    .map(NPC::getId)
                    .orElse(null);
        }

        for (ItemStack item : items) {
            Integer finalNpcId = npcId;

            if (bingoInfoManager.isRequiredDrop(item.getId(), npcId)) {
                log.debug("Submitting drop to bingo: " + item.getId());
                drawManager.requestNextFrameListener(image ->
                {
                    BufferedImage bufferedImage = (BufferedImage) image;
                    byte[] imageBytes;
                    try
                    {
                        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
                        ImageIO.write(bufferedImage, "png", byteArrayOutputStream);
                        imageBytes = byteArrayOutputStream.toByteArray();
                        bingOSRSService.submitDropAsync(bingOSRSConfig.bingoId(), imageBytes, client.getLocalPlayer().getName(), item.getId(), finalNpcId)
                                .whenComplete((result, throwable) -> bingoInfoManager.triggerUpdateData());
                    }
                    catch (IOException e)
                    {
                        log.debug("Error submitting drop", e);
                    }
                });
            }
        }
    }

}

package com.bingosrs.panel;

import com.bingosrs.BingoInfoManager;
import com.bingosrs.api.BingOSRSService;
import com.bingosrs.api.model.Bingo;
import com.bingosrs.api.model.Team;

import java.awt.*;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;

import com.bingosrs.api.model.tile.CustomTile;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.LinkBrowser;

@Slf4j
@Singleton
public class BingOSRSPanel extends PluginPanel {
    private final BingoInfoManager bingoInfoManager;
    private final BingOSRSService bingOSRSService;
    private final Client client;
    private final ClientThread clientThread;

    private final PluginErrorPanel noBingoDataPanel = new PluginErrorPanel();

    private final WarningPanel notInBingoPanel = new WarningPanel("Team not found. Check with your bingo admin that you're in the bingo and assigned to a team.");
    private final WarningPanel notAuthenticatedPanel = new WarningPanel("Error authenticating, drops will not be submitted. Double check that you entered the Player Token correctly in the config.");

    private final JButton linkButton = new JButton("Open Bingo");

    private final JComponent contentPanel = new JPanel();

    private boolean updateTriggered = false;

    @Inject
    BingOSRSPanel(final BingoInfoManager bingoInfoManager, final BingOSRSService bingOSRSService, final Client client, final ClientThread clientThread)
    {
        this.bingoInfoManager = bingoInfoManager;
        this.bingOSRSService = bingOSRSService;
        this.client = client;
        this.clientThread = clientThread;

        setBorder(new EmptyBorder(6, 6, 6, 6));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        final JPanel layoutPanel = new JPanel();
        layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));
        add(layoutPanel, BorderLayout.NORTH);

        final JPanel topPanel = new JPanel();
        topPanel.setLayout(new BorderLayout());
        topPanel.setBorder(new EmptyBorder(0, 0, 6, 0));

        JButton refreshButton = new JButton("Refresh");
        refreshButton.setFocusable(false);
        refreshButton.addActionListener(e -> bingoInfoManager.triggerUpdateData(false));
        topPanel.add(refreshButton, BorderLayout.EAST);

        this.linkButton.setFocusable(false);
        this.linkButton.addActionListener(e -> LinkBrowser.browse("https://bingosrs.com/bingo/" + bingoInfoManager.getBingo().id));
        topPanel.add(this.linkButton, BorderLayout.WEST);

        layoutPanel.add(topPanel);

        this.contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));

        layoutPanel.add(contentPanel);

        noBingoDataPanel.setContent("Bingo not found", "Double check that you entered the correct Bingo ID in the config.");

        update();
    }

    public synchronized void update()
    {
        if (updateTriggered) {
            return;
        }
        updateTriggered = true;

        this.contentPanel.removeAll();
        this.linkButton.setVisible(false);

        Bingo bingo = bingoInfoManager.getBingo();

        if (bingo == null) {
            contentPanel.add(noBingoDataPanel);
        } else {
            Team[] teams = bingoInfoManager.getTeams();
            Team team = bingoInfoManager.getTeam();

            this.linkButton.setVisible(true);
            contentPanel.add(new BingoSummary(bingo, teams));

            if (team == null && client.getLocalPlayer() != null) {
                contentPanel.add(notInBingoPanel);
            }
            if (!bingOSRSService.isAuthenticated()) {
                contentPanel.add(notAuthenticatedPanel);
            }

            JPanel headerPanel = new JPanel();
            headerPanel.setLayout(new BorderLayout());
            headerPanel.setBorder(new EmptyBorder(6, 0, 3, 0));
            String headerText = "Tiles" + (team != null ? (" (" + team.name + ")") : "") + ":";
            JLabel headerLabel = new JLabel("<html><body style = 'text-align:left'>" + headerText + "</body></html>");
            headerLabel.setFont(FontManager.getRunescapeBoldFont());
            headerPanel.add(headerLabel);
            contentPanel.add(headerPanel);

            for (int tileIdx = 0; tileIdx < bingo.board.tiles.length; tileIdx++) {
                boolean tileCompleted = false;
                if (team != null) {
                    if (bingo.board.tiles[tileIdx] instanceof CustomTile) {
                        tileCompleted = team.drops[tileIdx].length > 0;
                    } else {
                        tileCompleted = team.remainingDrops[tileIdx].length == 0;
                    }
                }
                contentPanel.add(new TileBox(bingo.board.tiles[tileIdx], tileCompleted, client, clientThread));
            }
        }

        revalidate();
        repaint();

        updateTriggered = false;
    }
}

package com.bingosrs.panel;

import com.bingosrs.api.model.Bingo;
import com.bingosrs.api.model.Drop;
import com.bingosrs.api.model.Team;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.JTableHeader;
import java.awt.*;

public class BingoSummary extends JPanel {

    public BingoSummary(Bingo bingo, Team[] teams) {
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBorder(new EmptyBorder(8, 8, 8, 8));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel infoPanel = new JPanel(new BorderLayout());
        infoPanel.setOpaque(false);
        infoPanel.setBorder(new EmptyBorder(0, 0, 10, 0));
        JTextArea name = new JTextArea(bingo.name);
        name.setBorder(new EmptyBorder(0, 0, 0, 0));
        name.setOpaque(false);
        name.setFont(FontManager.getRunescapeBoldFont());
        name.setEditable(false);
        name.setLineWrap(true);
        name.setWrapStyleWord(true);
        infoPanel.add(name, BorderLayout.CENTER);

        JLabel state = new JLabel(bingo.state);
        state.setFont(FontManager.getRunescapeSmallFont());
        state.setHorizontalAlignment(SwingConstants.RIGHT);
        state.setVerticalAlignment(SwingConstants.TOP);
        state.setOpaque(false);
        infoPanel.add(state, BorderLayout.EAST);

        add(infoPanel);

        if (teams != null) {
            JTable teamsTable = new JTable(new TeamTableModel(teams));
            teamsTable.setRowSelectionAllowed(false);
            teamsTable.setFocusable(false);
            teamsTable.setFont(FontManager.getRunescapeFont());
            teamsTable.setEnabled(false);

            teamsTable.setDefaultRenderer(Object.class, new DefaultTableCellRenderer() {
                final Border padding = BorderFactory.createEmptyBorder(5, 5, 5, 5);

                @Override
                public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
                    Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

                    if (c instanceof JComponent) {
                        ((JComponent) c).setBorder(padding);
                        c.setBackground(new Color(0, 0, 0, 0));
                        if (column > 0) {
                            ((JLabel)c).setHorizontalAlignment(SwingConstants.RIGHT);
                        } else {
                            ((JLabel)c).setHorizontalAlignment(SwingConstants.LEFT);
                        }
                    }

                    return c;
                }
            });

            JTableHeader tableHeader = teamsTable.getTableHeader();
            tableHeader.setFont(FontManager.getRunescapeBoldFont());
            tableHeader.setResizingAllowed(false);
            tableHeader.setReorderingAllowed(false);

            add(tableHeader);
            add(teamsTable);
        }
    }

    private static class TeamTableModel extends AbstractTableModel {

        private final Team[] teams;
        private final String[] columnNames = {"Team", "Drops", "Tiles"};

        public TeamTableModel(Team[] teams) {
            this.teams = teams;
        }

        @Override
        public int getRowCount() {
            return teams.length;
        }

        @Override
        public int getColumnCount() {
            return columnNames.length;
        }

        @Override
        public String getColumnName(int column) {
            return columnNames[column];
        }

        @Override
        public Object getValueAt(int rowIndex, int columnIndex) {
            Team team = teams[rowIndex];

            switch (columnIndex) {
                case 0: // Team Name
                    return team.name;
                case 1: // Drops
                    return calculateDrops(team);
                case 2: // Tiles
                    return calculateCompletedTiles(team);
                default:
                    return null;
            }
        }

        private int calculateDrops(Team team) {
            int dropCount = 0;
            if (team.drops != null) {
                for (Drop[] tileDrops : team.drops) {
                    if (tileDrops != null) {
                        dropCount += tileDrops.length;
                    }
                }
            }
            return dropCount;
        }

        private int calculateCompletedTiles(Team team) {
            int completedTiles = 0;
            if (team.remainingDrops != null && team.drops != null) {
                for (int i = 0; i < team.remainingDrops.length; i++) {
                    // A tile is completed if it has no remaining drops
                    // AND has at least one drop obtained.
                    if (team.remainingDrops[i] == null || team.remainingDrops[i].length == 0) {
                        if (team.drops[i] != null && team.drops[i].length > 0) {
                            completedTiles++;
                        }
                    }
                }
            }
            return completedTiles;
        }
    }
}
package com.bingosrs.panel;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;

import com.bingosrs.api.model.Drop;
import com.bingosrs.api.model.RequiredDrop;
import com.bingosrs.api.model.tile.Tile;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.NPCComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

@Slf4j
public class TileBox extends JPanel {
    private static final Color COMPLETED_COLOR = new Color(0, 50, 0);

    TileBox(Tile tile, boolean isCompleted, Client client, ClientThread clientThread)
    {
        setLayout(new BorderLayout());
        setBorder(new CompoundBorder(new EmptyBorder(3, 0, 3, 0), new LineBorder(ColorScheme.BORDER_COLOR, 1)));

        JPanel innerPanel = new JPanel();
        innerPanel.setLayout(new BorderLayout());
        innerPanel.setBorder(new EmptyBorder(4, 4, 4, 4));
        if (isCompleted) {
            innerPanel.setBackground(COMPLETED_COLOR);
        }
        add(innerPanel);

        JLabel headerLabel = new JLabel(tile.description);
        headerLabel.setFont(FontManager.getRunescapeBoldFont());
        innerPanel.add(headerLabel, BorderLayout.NORTH);

        JPanel content = new JPanel();
        content.setLayout(new BoxLayout(content, BoxLayout.Y_AXIS));
        content.setOpaque(false);
        innerPanel.add(content, BorderLayout.CENTER);

        RequiredDrop[] drops = tile.getRequiredDrops();

        for (RequiredDrop drop : drops) {
            clientThread.invoke(() -> {
                ItemComposition itemComposition = client.getItemDefinition(drop.item);

                SwingUtilities.invokeLater(() -> {
                    JLabel itemLabel = new JLabel(itemComposition.getMembersName());
                    itemLabel.setFont(FontManager.getRunescapeSmallFont());
                    itemLabel.setBorder(BorderFactory.createEmptyBorder(4, 0, 0, 0));
                    content.add(itemLabel);
                    revalidate();
                    repaint();
                });
            });
            if (drop.bosses != null && drop.bosses.length > 0) {
                clientThread.invoke(() -> {
                    StringBuilder labelText = new StringBuilder("Bosses: ");
                    for (int i = 0; i < drop.bosses.length; i++) {
                        NPCComposition npcComposition = client.getNpcDefinition(drop.bosses[i]);
                        labelText.append(npcComposition.getName());
                        if (i < drop.bosses.length - 1) {
                            labelText.append(", ");
                        }
                    }
                    SwingUtilities.invokeLater(() -> {
                        JLabel bossLabel = new JLabel(labelText.toString());
                        bossLabel.setFont(FontManager.getRunescapeSmallFont());
                        bossLabel.setBorder(new EmptyBorder(0, 8, 0, 0));
                        content.add(bossLabel);
                        revalidate();
                        repaint();
                    });
                });
            }
        }
    }
}

package com.bingosrs.panel;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;

public class WarningPanel extends JPanel {

    private static final Icon WARNING_ICON = scaleIcon(UIManager.getIcon("OptionPane.warningIcon"), 16, 16);

    WarningPanel(String text)
    {
        setLayout(new BorderLayout(8, 0));
        setBorder(new EmptyBorder(6, 0, 3, 0));

        JLabel label = new JLabel("<html><body style = 'text-align:left'>" + text + "</body></html>");
        label.setFont(FontManager.getRunescapeSmallFont());
        label.setIcon(WARNING_ICON);

        add(label);
    }

    public static Icon scaleIcon(Icon icon, int width, int height) {
        if (icon == null) {
            return null;
        }

        BufferedImage bi = new BufferedImage(icon.getIconWidth(), icon.getIconHeight(), BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = bi.createGraphics();
        icon.paintIcon(null, g, 0, 0);
        g.dispose();

        Image scaledImage = bi.getScaledInstance(width, height, Image.SCALE_SMOOTH);
        return new ImageIcon(scaledImage);
    }
}

package com.bingosrs;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BingOSRSPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BingOSRSPlugin.class);
		RuneLite.main(args);
	}
}
