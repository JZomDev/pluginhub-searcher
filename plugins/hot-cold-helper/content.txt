/*
 * Copyright (c) 2025, Lalochazia
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.hotcoldhelper;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup("hotcoldhelper")
public interface HotColdHelperConfig extends Config
{
	@Range(
			min = 1,
			max = 10
	)
	@ConfigItem(
			keyName = "maxTeleportEntries",
			name = "Max Teleport Entries",
			description = "Maximum number of teleport locations to display in the overlay (1-10)",
			position = 0
	)
	default int maxTeleportEntries()
	{
		return 5;
	}

	@ConfigSection(
			name = "Spellbooks",
			description = "Configure which spellbook teleports to include",
			position = 1
	)
	String spellbooksSection = "spellbooksSection";

	@ConfigItem(
			position = 0,
			keyName = "includeStandardTeleports",
			name = "Standard Spellbook",
			description = "Includes teleports from the Standard spellbook",
			section = "spellbooksSection"
	)
	default boolean includeStandardTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 1,
			keyName = "includeAncientTeleports",
			name = "Ancient Magicks",
			description = "Includes teleports from the Ancient Magicks spellbook",
			section = "spellbooksSection"
	)
	default boolean includeAncientTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 2,
			keyName = "includeLunarTeleports",
			name = "Lunar Spellbook",
			description = "Includes teleports from the Lunar spellbook",
			section = "spellbooksSection"
	)
	default boolean includeLunarTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 3,
			keyName = "includeArceuusTeleports",
			name = "Arceuus Spellbook",
			description = "Includes teleports from the Arceuus spellbook",
			section = "spellbooksSection"
	)
	default boolean includeArceuusTeleports()
	{
		return true;
	}

	@ConfigSection(
			name = "Capes of Accomplishment",
			description = "Configure which cape teleports to include",
			position = 2
	)
	String capesSection = "capesSection";

	@ConfigItem(
			position = 0,
			keyName = "includeDiaryCapeTeleports",
			name = "Achievement Diary Cape",
			description = "Include Achievement Diary Cape teleports",
			section = "capesSection"
	)
	default boolean includeDiaryCapeTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 1,
			keyName = "includeQPCapeTeleports",
			name = "Quest Point Cape",
			description = "Include Quest Point Cape teleports",
			section = "capesSection"
	)
	default boolean includeQPCapeTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 2,
			keyName = "includeMusicCapeTeleports",
			name = "Music Cape",
			description = "Include Music Cape teleports",
			section = "capesSection"
	)
	default boolean includeMusicCapeTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 3,
			keyName = "includeStrengthCapeTeleports",
			name = "Strength Cape",
			description = "Include Strength Cape teleports",
			section = "capesSection"
	)
	default boolean includeStrengthCapeTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 4,
			keyName = "includeHunterCapeTeleports",
			name = "Hunter Cape",
			description = "Include Hunter Cape teleports",
			section = "capesSection"
	)
	default boolean includeHunterCapeTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 5,
			keyName = "includeFarmingCapeTeleports",
			name = "Farming Cape",
			description = "Include Farming Cape teleports",
			section = "capesSection"
	)
	default boolean includeFarmingCapeTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 6,
			keyName = "includeFishingCapeTeleports",
			name = "Fishing Cape",
			description = "Include Fishing Cape teleports",
			section = "capesSection"
	)
	default boolean includeFishingCapeTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 7,
			keyName = "includeCraftingCapeTeleports",
			name = "Crafting Cape",
			description = "Include Crafting Cape teleports",
			section = "capesSection"
	)
	default boolean includeCraftingCapeTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 8,
			keyName = "includeConstructionCapeTeleports",
			name = "Construction Cape",
			description = "Include Construction Cape teleports",
			section = "capesSection"
	)
	default boolean includeConstructionCapeTeleports()
	{
		return true;
	}

	@ConfigSection(
			name = "Miscellaneous",
			description = "Configure other teleport options",
			position = 3
	)
	String miscSection = "miscSection";

	@ConfigItem(
		position = 0,
		keyName = "includeWildernessTeleports",
		name = "Wilderness Teleports",
		description = "Include teleports that lead into the Wilderness",
		section = "miscSection"
	)
	default boolean includeWildernessTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 1,
			keyName = "includePOHJewelryTeleports",
			name = "POH Jewelry Teleports",
			description = "Include teleports from jewelry items that can be stored in the POH",
			section = "miscSection"
	)
	default boolean includePOHJewelryTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 2,
			keyName = "includeNecklaceOfPassageTeleports",
			name = "Necklace of Passage",
			description = "Include teleports from Necklace of Passage",
			section = "miscSection"
	)
	default boolean includeNecklaceOfPassageTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 3,
			keyName = "includeCamuletTeleports",
			name = "Camulet",
			description = "Include teleports from Camulet",
			section = "miscSection"
	)
	default boolean includeCamuletTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 4,
			keyName = "includePendantOfAtesTeleports",
			name = "Pendant of Ates",
			description = "Include teleports from Pendant of Ates",
			section = "miscSection"
	)
	default boolean includePendantOfAtesTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 5,
			keyName = "includePharaohsSceptreTeleports",
			name = "Pharaoh's Sceptre",
			description = "Include teleports from Pharaoh's Sceptre",
			section = "miscSection"
	)
	default boolean includePharaohsSceptreTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 6,
			keyName = "includeRingOfTheElementsTeleports",
			name = "Ring of the Elements",
			description = "Include teleports from Ring of the Elements",
			section = "miscSection"
	)
	default boolean includeRingOfTheElementsTeleports()
	{
		return true;
	}

	@ConfigItem(
			position = 7,
			keyName = "includeRoyalSeedPodTeleports",
			name = "Royal Seed Pod",
			description = "Include teleports from Royal Seed Pod",
			section = "miscSection"
	)
	default boolean includeRoyalSeedPodTeleports()
	{
		return true;
	}
}
/*
 * Copyright (c) 2025, Lalochazia
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.hotcoldhelper;

import com.google.inject.Provides;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.cluescrolls.ClueScrollPlugin;
import net.runelite.client.plugins.cluescrolls.clues.HotColdClue;
import net.runelite.client.plugins.cluescrolls.clues.hotcold.HotColdLocation;
import net.runelite.client.plugins.cluescrolls.clues.hotcold.HotColdSolver;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j

@PluginDescriptor(
	name = "Hot Cold Helper",
	description = "Helps with the optimal solving of Hot/Clue Master Clue Steps",
	tags = {"hot", "cold", "clue", "helper"}
)
@PluginDependency(ClueScrollPlugin.class)

public class HotColdHelperPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private HotColdHelperConfig config;

	@Inject
	private ClientThread clientThread;

	@Inject
	private PluginManager pluginManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private HotColdHelperOverlay overlay;

	@Inject
	private ClueScrollPlugin clueScrollPlugin;

	private static final String HOT_COLD_DEVICE_MESSAGE = "The power of the strange device hurts you in the process.";
	private static final int CHECKED_LOCATION_RANGE = 25;

	@Getter
	private int possibleLocationsCount = -1;

	@Getter
	private final List<WorldPoint> possibleLocations = new ArrayList<>();

	@Getter
	private final List<WorldPoint> checkedLocations = new ArrayList<>();

	@Getter
	private final Map<HotColdTeleports, Double> entropyValues = new HashMap<>();

	@Getter
	private HotColdTeleports bestTeleport = null;

	@Getter
	private Map<String, Integer> cardinalInfoGain = new HashMap<>();

	@Getter
	private HotColdCardinalHelper.BestCardinalResult bestCardinalDirection =
		new HotColdCardinalHelper.BestCardinalResult("None", 0);

	private boolean needsUpdate = false;
	private Object hotColdClue = null;
	private net.runelite.api.coords.WorldPoint lastMessageLocation;

	@Provides
	HotColdHelperConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(HotColdHelperConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(overlay);
		clientThread.invokeLater(this::checkHotColdData);
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
		possibleLocations.clear();
		checkedLocations.clear();
		entropyValues.clear();
		possibleLocationsCount = -1;
		clueScrollPlugin = null;
		hotColdClue = null;
	}

	private void resetPluginState()
	{
		possibleLocationsCount = -1;
		checkedLocations.clear();
		lastMessageLocation = null;
		needsUpdate = false;
	}

	private void addCheckedLocation(WorldPoint location)
	{
		if (checkedLocations.stream().noneMatch(loc ->
			loc.distanceTo2D(location) <= CHECKED_LOCATION_RANGE))
		{
			checkedLocations.add(location);
		}
	}

	public boolean isHotColdClueActive()
	{
		if (clueScrollPlugin == null || hotColdClue == null)
		{
			return false;
		}
		try
		{
			Object currentClue = clueScrollPlugin.getClue();
			if (currentClue != null && hotColdClue.equals(currentClue))
			{
				return true;
			}
		}
		catch (Exception e)
		{
			log.debug("Error checking if hot-cold clue is active", e);
		}
		return false;
	}

	private boolean isLocationChecked(WorldPoint location)
	{
		return checkedLocations.stream()
			.anyMatch(checkedLoc -> checkedLoc.distanceTo2D(location) <= CHECKED_LOCATION_RANGE);
	}

	public boolean isNearLastMessageLocation()
	{
		if (lastMessageLocation == null || !isHotColdClueActive())
		{
			return false;
		}
		WorldPoint currentLocation = client.getLocalPlayer().getWorldLocation();
		int distance = currentLocation.distanceTo2D(lastMessageLocation);
		return distance <= 5;
	}

	private void checkHotColdData()
	{
		if (clueScrollPlugin == null)
		{
			log.debug("Could not find ClueScrollPlugin");
			return;
		}

		try
		{
			Object clue = clueScrollPlugin.getClue();
			if (clue != null)
			{
				if (clue.getClass().getSimpleName().equals("HotColdClue"))
				{
					hotColdClue = clue;
					updatePossibleLocations();
					updateCardinalInfoGain();
				}
				else
				{
					hotColdClue = null;
					possibleLocationsCount = 0;
					possibleLocations.clear();
					checkedLocations.clear();
					entropyValues.clear();
					bestTeleport = null;
				}
			}
			else
			{
				hotColdClue = null;
				possibleLocationsCount = 0;
				possibleLocations.clear();
				checkedLocations.clear();
				entropyValues.clear();
				bestTeleport = null;
			}
		}
		catch (Exception e)
		{
			log.error("Error getting clue", e);
		}
	}

	private void updatePossibleLocations() {
		if (hotColdClue == null) {
			return;
		}
		if (hotColdClue instanceof HotColdClue) {
			HotColdClue hotColdClueTyped = (HotColdClue) hotColdClue;

			HotColdSolver solver = hotColdClueTyped.getHotColdSolver();
			if (solver != null) {
				Set<HotColdLocation> locations = solver.getPossibleLocations();
				if (locations != null) {
					possibleLocationsCount = locations.size();
					possibleLocations.clear();
					for (HotColdLocation location : locations) {
						WorldPoint worldPoint = location.getWorldPoint();
						if (worldPoint != null) {
							possibleLocations.add(worldPoint);
						}
					}
					if (!possibleLocations.isEmpty()) {
						updateEntropyValues();
						updateCardinalInfoGain();
					}
				}
			}
		}
	}


	private void processLocations(Collection<?> points)
	{
		possibleLocationsCount = points.size();
		possibleLocations.clear();
		for (Object point : points)
		{
			if (point instanceof WorldPoint)
			{
				possibleLocations.add((WorldPoint) point);
			}
		}
		updateEntropyValues();
	}

	private void updateEntropyValues()
	{
		entropyValues.clear();
		bestTeleport = null;
		double bestEntropyValue = Double.MAX_VALUE;

		if (possibleLocations.isEmpty())
		{
			return;
		}

		for (HotColdTeleports teleport : HotColdTeleports.values())
		{
			WorldPoint teleportDestination = teleport.getLocation();
			if (teleportDestination == null)
			{
				continue;
			}
			if ("Diary Cape".equals(teleport.getTeleportType()) && !config.includeDiaryCapeTeleports())
			{
				continue;
			}
			if ("Standard".equals(teleport.getTeleportType()) && !config.includeStandardTeleports())
			{
				continue;
			}
			if ("Ancients".equals(teleport.getTeleportType()) && !config.includeAncientTeleports())
			{
				continue;
			}
			if ("Lunars".equals(teleport.getTeleportType()) && !config.includeLunarTeleports())
			{
				continue;
			}
			if ("Arceuus".equals(teleport.getTeleportType()) && !config.includeArceuusTeleports())
			{
				continue;
			}
			if (teleport.isWildernessTeleport() && !config.includeWildernessTeleports())
			{
				continue;
			}
			if (("Skills Necklace".equals(teleport.getTeleportType()) ||
				"Ring of Wealth".equals(teleport.getTeleportType()) ||
				"Ring of Dueling".equals(teleport.getTeleportType()) ||
				"Games Necklace".equals(teleport.getTeleportType()) ||
				"Digsite Pendant".equals(teleport.getTeleportType()) ||
				"Combat Bracelet".equals(teleport.getTeleportType()) ||
				"Amulet of Glory".equals(teleport.getTeleportType())) &&
				!config.includePOHJewelryTeleports())
			{
				continue;
			}
			if ("Music Cape".equals(teleport.getTeleportType()) && !config.includeMusicCapeTeleports())
			{
				continue;
			}
			if ("QP Cape".equals(teleport.getTeleportType()) && !config.includeQPCapeTeleports())
			{
				continue;
			}
			if ("Strength Cape".equals(teleport.getTeleportType()) && !config.includeStrengthCapeTeleports())
			{
				continue;
			}
			if ("Hunter Cape".equals(teleport.getTeleportType()) && !config.includeHunterCapeTeleports())
			{
				continue;
			}
			if ("Farming Cape".equals(teleport.getTeleportType()) && !config.includeFarmingCapeTeleports())
			{
				continue;
			}
			if ("Fishing Cape".equals(teleport.getTeleportType()) && !config.includeFishingCapeTeleports())
			{
				continue;
			}
			if ("Crafting Cape".equals(teleport.getTeleportType()) && !config.includeCraftingCapeTeleports())
			{
				continue;
			}
			if ("Construction Cape".equals(teleport.getTeleportType()) && !config.includeConstructionCapeTeleports())
			{
				continue;
			}
			if ("Necklace of Passage".equals(teleport.getTeleportType()) && !config.includeNecklaceOfPassageTeleports())
			{
				continue;
			}
			if ("Camulet".equals(teleport.getTeleportType()) && !config.includeCamuletTeleports())
			{
				continue;
			}
			if ("Pendant of Ates".equals(teleport.getTeleportType()) && !config.includePendantOfAtesTeleports())
			{
				continue;
			}
			if ("Pharaoh's Sceptre".equals(teleport.getTeleportType()) && !config.includePharaohsSceptreTeleports())
			{
				continue;
			}
			if ("Ring of the Elements".equals(teleport.getTeleportType()) && !config.includeRingOfTheElementsTeleports())
			{
				continue;
			}
			if ("Royal Seed Pod".equals(teleport.getTeleportType()) && !config.includeRoyalSeedPodTeleports())
			{
				continue;
			}
			if (isLocationChecked(teleportDestination))
			{
				continue;
			}

			double entropy = calculateEntropy(teleportDestination, possibleLocations);
			entropyValues.put(teleport, entropy);

			if (entropy < bestEntropyValue)
			{
				bestEntropyValue = entropy;
				bestTeleport = teleport;
			}
		}
	}

	private double calculateEntropy(WorldPoint teleportLocation, List<WorldPoint> possibleLocations)
	{
		if (possibleLocations.isEmpty())
		{
			return Double.MAX_VALUE;
		}
		double totalDistance = 0;
		for (WorldPoint location : possibleLocations)
		{
			double distance = teleportLocation.distanceTo2D(location);
			totalDistance += distance;
		}
		return totalDistance / possibleLocations.size();
	}

	private void updateCardinalInfoGain()
	{
		if (!isHotColdClueActive() || possibleLocations.isEmpty())
		{
			return;
		}

		WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
		cardinalInfoGain = HotColdCardinalHelper.calculateCardinalInfoGain(possibleLocations, playerLocation);
		bestCardinalDirection = HotColdCardinalHelper.findBestCardinalDirection(cardinalInfoGain);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() == GameState.LOGGED_IN && needsUpdate)
		{
			needsUpdate = false;
			clientThread.invokeLater(this::checkHotColdData);
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		if (possibleLocationsCount > 0)
		{
			boolean isStillActive = isHotColdClueActive();
			if (!isStillActive)
			{
				resetPluginState();
			}
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		if (chatMessage.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		if (chatMessage.getMessage().contains(HOT_COLD_DEVICE_MESSAGE))
		{
			if (client.getLocalPlayer() != null)
			{
				WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
				addCheckedLocation(playerLocation);
				lastMessageLocation = playerLocation;
			}

			needsUpdate = true;
			clientThread.invokeLater(this::checkHotColdData);
		}
	}
}
/*
 * Copyright (c) 2025, Lalochazia
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.hotcoldhelper;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
public enum HotColdTeleports {
    ARDOUGNE_DIARY_CAPE(new WorldPoint(2573, 3324, 0), "Ardougne", "Diary Cape",false),
    DESERT_DIARY_CAPE(new WorldPoint(3300, 3121, 0), "Desert", "Diary Cape",false),
    FALADOR_DIARY_CAPE(new WorldPoint(2977, 3346, 0), "Falador", "Diary Cape",false),
    FREMENNIK_DIARY_CAPE(new WorldPoint(2659, 3627, 0), "Fremennik", "Diary Cape",false),
    KANDARIN_DIARY_CAPE(new WorldPoint(2743, 3445, 0), "Kandarin", "Diary Cape",false),
    KARAMJA_JACKIE_DIARY_CAPE(new WorldPoint(2809, 3192, 0), "Karamja (Jackie)", "Diary Cape",false),
    KARAMJA_FORESTER_DIARY_CAPE(new WorldPoint(2796, 2944, 0), "Karamja (Forester)", "Diary Cape",false),
    KOUREND_DIARY_CAPE(new WorldPoint(1647, 3667, 0), "Kourend", "Diary Cape",false),
    LUMBRIDGE_DIARY_CAPE(new WorldPoint(3240, 3219, 0), "Lumbridge", "Diary Cape",false),
    MORYTANIA_DIARY_CAPE(new WorldPoint(3464, 3476, 0), "Morytania", "Diary Cape",false),
    VARROCK_DIARY_CAPE(new WorldPoint(3225, 3413, 0), "Varrock", "Diary Cape",false),
    WILDERNESS_DIARY_CAPE(new WorldPoint(3121, 3515, 0), "Wilderness", "Diary Cape",false),
    WESTERN_PROVINCES_DIARY_CAPE(new WorldPoint(2466, 3459, 0), "Western Provinces", "Diary Cape",false),
    TWIGGY_DIARY_CAPE(new WorldPoint(3097, 3226, 0), "Twiggy", "Diary Cape",false),
    LUMBRIDGE_STANDARD(new WorldPoint(3220, 3218, 0), "Lumbridge", "Standard",false),
    VARROCK_STANDARD(new WorldPoint(3211, 3427, 0), "Varrock", "Standard",false),
    FALADOR_STANDARD(new WorldPoint(2965, 3378, 0), "Falador", "Standard",false),
    CAMELOT_STANDARD(new WorldPoint(2757, 3478, 0), "Camelot", "Standard",false),
    SEERS_VILLAGE_STANDARD(new WorldPoint(2726, 3484, 0), "Seers' Village", "Standard",false),
    KOUREND_STANDARD(new WorldPoint(1641, 3673, 0), "Kourend", "Standard",false),
    ARDOUGNE_STANDARD(new WorldPoint(2660, 3301, 0), "Ardougne", "Standard",false),
    CIVITAS_ILLA_FORTIS_STANDARD(new WorldPoint(1680, 3134, 0), "Civitas illa Fortis", "Standard",false),
    YANILLE_STANDARD(new WorldPoint(2583, 3097, 0), "Yanille", "Standard",false),
    TROLLHEIM_STANDARD(new WorldPoint(2890, 3679, 0), "Trollheim", "Standard",false),
    APE_ATOLL_STANDARD(new WorldPoint(2799, 2792, 0), "Ape Atoll", "Standard",false),
    SENNTISTEN_ANCIENTS(new WorldPoint(3323, 3334, 0), "Senntisten", "Ancients",false),
    KHARYLL_ANCIENTS(new WorldPoint(3492, 3471, 0), "Kharyll", "Ancients",false),
    LASSAR_ANCIENTS(new WorldPoint(3004, 3470, 0), "Lassar", "Ancients",false),
    DAREEYAK_ANCIENTS(new WorldPoint(2969, 3697, 0), "Dareeyak", "Ancients",true),
    CARRALLANGER_ANCIENTS(new WorldPoint(3159, 3667, 0), "Carrallanger", "Ancients",true),
    ANNAKARL_ANCIENTS(new WorldPoint(3287, 3886, 0), "Annakarl", "Ancients",true),
    GHORROCK_ANCIENTS(new WorldPoint(2976, 3872, 0), "Ghorrock", "Ancients",true),
    MOONCLAN_LUNARS(new WorldPoint(2114, 3898, 0), "Moonclan", "Lunars",false),
    OURANIA_LUNARS(new WorldPoint(2466, 3246, 0), "Ourania", "Lunars",false),
    WATERBIRTH_LUNARS(new WorldPoint(2545, 3755, 0), "Waterbirth", "Lunars",false),
    BARBARIAN_LUNARS(new WorldPoint(2541, 3568, 0), "Barbarian", "Lunars",false),
    KHAZARD_LUNARS(new WorldPoint(2635, 3168, 0), "Khazard", "Lunars",false),
    FISHING_GUILD_LUNARS(new WorldPoint(2604, 3401, 0), "Fishing Guild", "Lunars",false),
    CATHERBY_LUNARS(new WorldPoint(2801, 3449, 0), "Catherby", "Lunars",false),
    ICE_PLATEAU_LUNARS(new WorldPoint(2972, 3916, 0), "Ice Plateau", "Lunars",true),
    ARCEUUS_LIBRARY_ARCEUUS(new WorldPoint(1631, 3833, 0), "Arceuus Library", "Arceuus",false),
    DRAYNOR_MANOR_ARCEUUS(new WorldPoint(3108, 3351, 0), "Draynor Manor", "Arceuus",false),
    BATTLEFRONT_ARCEUUS(new WorldPoint(1348, 3739, 0), "Battlefront", "Arceuus",false),
    MIND_ALTAR_ARCEUUS(new WorldPoint(2979, 3509, 0), "Mind Altar", "Arceuus",false),
    SALVE_GRAVEYARD_ARCEUUS(new WorldPoint(3432, 3460, 0), "Salve Graveyard", "Arceuus",false),
    FENKENSTRAINS_CASTLE_ARCEUUS(new WorldPoint(3546, 3528, 0), "Fenkenstrains Castle", "Arceuus",false),
    WEST_ARDOUGNE_ARCEUUS(new WorldPoint(2500, 3291, 0), "West Ardougne", "Arceuus",false),
    HARMONY_ISLAND_ARCEUUS(new WorldPoint(3796, 2867, 0), "Harmony Island", "Arceuus",false),
    CEMETERY_ARCEUUS(new WorldPoint(2980, 3763, 0), "Cemetery", "Arceuus",true),
    BARROWS_ARCEUUS(new WorldPoint(3565, 3311, 0), "Barrows", "Arceuus",false),
    APE_ATOLL_ARCEUUS(new WorldPoint(2764, 2704, 0), "Ape Atoll", "Arceuus",false),
    NARDAH_MASTER_SCROLL_BOX(new WorldPoint(3420, 2917, 0), "Nardah", "Master Scroll Book",false),
    DIGSITE_MASTER_SCROLL_BOX(new WorldPoint(3325, 3412, 0), "Digsite", "Master Scroll Book",false),
    FELDIP_HILLS_MASTER_SCROLL_BOX(new WorldPoint(2541, 2925, 0), "Feldip Hills", "Master Scroll Book",false),
    LUNAR_ISLE_MASTER_SCROLL_BOX(new WorldPoint(2094, 3913, 0), "Lunar Isle", "Master Scroll Book",false),
    MORTTON_MASTER_SCROLL_BOX(new WorldPoint(3489, 3287, 0), "Mort'ton", "Master Scroll Book",false),
    PEST_CONTROL_MASTER_SCROLL_BOX(new WorldPoint(2658, 2659, 0), "Pest Control", "Master Scroll Book",false),
    PISCATORIS_MASTER_SCROLL_BOX(new WorldPoint(2339, 3649, 0), "Piscatoris", "Master Scroll Book",false),
    TAI_BWO_WANNAI_MASTER_SCROLL_BOX(new WorldPoint(2789, 3066, 0), "Tai Bwo Wannai", "Master Scroll Book",false),
    IORWERTH_CAMP_MASTER_SCROLL_BOX(new WorldPoint(2194, 3258, 0), "Iorwerth Camp", "Master Scroll Book",false),
    MOS_LE_HARMLESS_MASTER_SCROLL_BOX(new WorldPoint(3701, 2996, 0), "Mos Le'Harmless", "Master Scroll Book",false),
    LUMBERYARD_MASTER_SCROLL_BOX(new WorldPoint(3302, 3487, 0), "Lumberyard", "Master Scroll Book",false),
    ZUL_ANDRA_MASTER_SCROLL_BOX(new WorldPoint(2196, 3056, 0), "Zul-Andra", "Master Scroll Book",false),
    REVENANT_CAVE_MASTER_SCROLL_BOX(new WorldPoint(3128, 3832, 0), "Revenant Cave", "Master Scroll Book",true),
    WATSON_MASTER_SCROLL_BOX(new WorldPoint(1645, 3579, 0), "Watson", "Master Scroll Book",false),
    CRAFTING_GUILD_CRAFTING_CAPE(new WorldPoint(2931, 3286, 0), "Crafting Guild", "Crafting Cape",false),
    FISHING_GUILD_FISHING_CAPE(new WorldPoint(2604, 3401, 0), "Fishing Guild", "Fishing Cape",false),
    OTTO_GROTTO_FISHING_CAPE(new WorldPoint(2504, 3484, 0), "Otto's Grotto", "Fishing Cape",false),
    FARMING_GUILD_FARMING_CAPE(new WorldPoint(1249, 3724, 0), "Farming Guild", "Farming Cape",false),
    RED_CHINCHOMPAS_HUNTER_CAPE(new WorldPoint(2556, 2918, 0), "Red Chinchompas", "Hunter Cape",false),
    BLACK_CHINCHOMPAS_HUNTER_CAPE(new WorldPoint(3144, 3772, 0), "Black Chinchompas", "Hunter Cape",true),
    HUNTER_GUILD_HUNTER_CAPE(new WorldPoint(1577, 3046, 0), "Hunter Guild", "Hunter Cape",false),
    WARRIOR_GUILD_STRENGTH_CAPE(new WorldPoint(2865, 3546, 0), "Warrior's Guild", "Strength Cape",false),
    LEGEND_GUILD_QP_CAPE(new WorldPoint(2729, 3348, 0), "Legend's Guild", "QP Cape",false),
    FALO_MUSIC_CAPE(new WorldPoint(2689, 3547, 0), "Falo", "Music Cape",false),
    BARBARIAN_ASSAULT_GAMES_NECKLACE(new WorldPoint(2519, 3571, 0), "Barbarian Assault", "Games Necklace",false),
    BURTHORPE_GAMES_NECKLACE(new WorldPoint(2898, 3553, 0), "Burthorpe", "Games Necklace",false),
    WINTERTODT_CAMP_GAMES_NECKLACE(new WorldPoint(1631, 3940, 0), "Wintertodt Camp", "Games Necklace",false),
    EMIR_ARENA_RING_OF_DUELING(new WorldPoint(3316, 3235, 0), "Emir's Arena", "Ring of Dueling",false),
    FEROX_ENCLAVE_RING_OF_DUELING(new WorldPoint(3150, 3634, 0), "Ferox Enclave", "Ring of Dueling",false),
    CASTLE_WARS_RING_OF_DUELING(new WorldPoint(2440, 3090, 0), "Castle Wars", "Ring of Dueling",false),
    FORTIS_COLOSSEUM_RING_OF_DUELING(new WorldPoint(1791, 3106, 0), "Fortis Colosseum", "Ring of Dueling",false),
    WARRIORS_GUILD_COMBAT_BRACELET(new WorldPoint(2881, 3546, 0), "Warriors' Guild", "Combat Bracelet",false),
    CHAMPIONS_GUILD_COMBAT_BRACELET(new WorldPoint(3191, 3336, 0), "Champions' Guild", "Combat Bracelet",false),
    EDGEVILLE_MONASTERY_COMBAT_BRACELET(new WorldPoint(3052, 3487, 0), "Edgeville Monastery", "Combat Bracelet",false),
    RANGING_GUILD_COMBAT_BRACELET(new WorldPoint(2655, 3442, 0), "Ranging Guild", "Combat Bracelet",false),
    FISHING_GUILD_SKILLS_NECKLACE(new WorldPoint(2611, 3390, 0), "Fishing Guild", "Skills Necklace",false),
    CRAFTING_GUILD_SKILLS_NECKLACE(new WorldPoint(2932, 3294, 0), "Crafting Guild", "Skills Necklace",false),
    COOKS_GUILD_SKILLS_NECKLACE(new WorldPoint(3143, 3442, 0), "Cooks' Guild", "Skills Necklace",false),
    WOODCUTTING_GUILD_SKILLS_NECKLACE(new WorldPoint(1660, 3504, 0), "Woodcutting Guild", "Skills Necklace",false),
    FARMING_GUILD_SKILLS_NECKLACE(new WorldPoint(1248, 3725, 0), "Farming Guild", "Skills Necklace",false),
    EDGEVILLE_AMULET_OF_GLORY(new WorldPoint(3087, 3496, 0), "Edgeville", "Amulet of Glory",false),
    KARAMJA_AMULET_OF_GLORY(new WorldPoint(2918, 3176, 0), "Karamja", "Amulet of Glory",false),
    DRAYNOR_VILLAGE_AMULET_OF_GLORY(new WorldPoint(3105, 3251, 0), "Draynor Village", "Amulet of Glory",false),
    AL_KHARID_AMULET_OF_GLORY(new WorldPoint(3293, 3163, 0), "Al Kharid", "Amulet of Glory",false),
    MISCELLANIA_RING_OF_WEALTH(new WorldPoint(2531, 3860, 0), "Miscellania", "Ring of Wealth",false),
    GRAND_EXCHANGE_RING_OF_WEALTH(new WorldPoint(3164, 3477, 0), "Grand Exchange", "Ring of Wealth",false),
    FALADOR_PARK_RING_OF_WEALTH(new WorldPoint(2996, 3373, 0), "Falador Park", "Ring of Wealth",false),
    SLAYER_TOWER_SLAYER_RING(new WorldPoint(3423, 3535, 0), "Slayer Tower", "Slayer Ring",false),
    FREMENNIK_SLAYER_DUNGEON_SLAYER_RING(new WorldPoint(2974, 3613, 0), "Fremennik Slayer Dungeon", "Slayer Ring",false),
    STRONGHOLD_SLAYER_CAVE_SLAYER_RING(new WorldPoint(2434, 3424, 0), "Stronghold Slayer Cave", "Slayer Ring",false),
    DIGSITE_PENDANT(new WorldPoint(3341, 3445, 0), "Digsite", "Digsite Pendant",false),
    CHAOS_TEMPLE_BURNING_AMULET(new WorldPoint(3234, 3638, 0), "Chaos Temple", "Burning Amulet",true),
    BANDIT_CAMP_BURNING_AMULET(new WorldPoint(3038, 3651, 0), "Bandit Camp", "Burning Amulet",true),
    LAVA_MAZE_BURNING_AMULET(new WorldPoint(3028, 3841, 0), "Lava Maze", "Burning Amulet",true),
    WIZARD_TOWER_NECKLACE_OF_PASSAGE(new WorldPoint(3113, 3178, 0), "Wizards' Tower", "Necklace of Passage",false),
    OUTPOST_NECKLACE_OF_PASSAGE(new WorldPoint(2431, 3349, 0), "Outpost", "Necklace of Passage",false),
    DESERT_EAGLE_STATION_NECKLACE_OF_PASSAGE(new WorldPoint(3404, 3156, 0), "Desert Eagle Station", "Necklace of Passage",false),
    LLETYA_TELEPORT_CRYSTAL(new WorldPoint(2330, 3170, 0), "Lletya", "Teleport Crystal",false),
    GRAND_TREE_ROYAL_SEED_POD(new WorldPoint(2465, 3495, 0), "Grand Tree", "Royal Seed Pod",false),
    RELLEKKA_ENCHANTED_LYRE(new WorldPoint(2662, 3644, 0), "Rellekka", "Enchanted Lyre",false),
    WATERBIRTH_ISLAND_ENCHANTED_LYRE(new WorldPoint(2548, 3759, 0), "Waterbirth Island", "Enchanted Lyre",false),
    NEITIZNOT_ENCHANTED_LYRE(new WorldPoint(2336, 3802, 0), "Neitiznot", "Enchanted Lyre",false),
    JATIZSO_ENCHANTED_LYRE(new WorldPoint(2411, 3810, 0), "Jatizso", "Enchanted Lyre",false),
    ENAKHRAS_TEMPLE_CAMULET(new WorldPoint(3191, 2923, 0), "Enakhra's Temple", "Camulet",false),
    ARCEUUS_BOOK_OF_THE_DEAD(new WorldPoint(1680, 3746, 0), "Arceuus", "Book of the Dead",false),
    HOSIDIUS_BOOK_OF_THE_DEAD(new WorldPoint(1713, 3611, 0), "Hosidius", "Book of the Dead",false),
    PORT_PISCARILLIUS_BOOK_OF_THE_DEAD(new WorldPoint(1803, 3748, 0), "Port Piscarillius", "Book of the Dead",false),
    LOVAKENGJ_BOOK_OF_THE_DEAD(new WorldPoint(1543, 3764, 0), "Lovakengj", "Book of the Dead",false),
    SHAYZIEN_BOOK_OF_THE_DEAD(new WorldPoint(1478, 3575, 0), "Shayzien", "Book of the Dead",false),
    WEISS_ICY_BASALT(new WorldPoint(2846, 3938, 0), "Weiss", "Icy Basalt",false),
    VER_SINHAZA_DRAKANS_MEDALLION(new WorldPoint(3653, 3217, 0), "Ver Sinhaza", "Drakan's Medallion",false),
    DARKMEYER_DRAKANS_MEDALLION(new WorldPoint(3595, 3340, 0), "Darkmeyer", "Drakan's Medallion",false),
    AGILITY_PYRAMID_PHARAOHS_SCEPTRE(new WorldPoint(3341, 2827, 0), "Agility Pyramid", "Pharaoh's Sceptre",false),
    ANCIENT_PYRAMID_PHARAOHS_SCEPTRE(new WorldPoint(3232, 2897, 0), "Ancient Pyramid", "Pharaoh's Sceptre",false),
    NECROPOLIS_PHARAOHS_SCEPTRE(new WorldPoint(3311, 2720, 0), "Necropolis", "Pharaoh's Sceptre",false),
    XERICS_LOOKOUT_XERICS_TALISMAN(new WorldPoint(1578, 3530, 0), "Xeric's Lookout", "Xeric's Talisman",false),
    XERICS_GLADE_XERICS_TALISMAN(new WorldPoint(1752, 3566, 0), "Xeric's Glade", "Xeric's Talisman",false),
    XERICS_INFERNO_XERICS_TALISMAN(new WorldPoint(1504, 3817, 0), "Xeric's Inferno", "Xeric's Talisman",false),
    XERICS_HEART_XERICS_TALISMAN(new WorldPoint(1646, 3743, 0), "Xeric's Heart", "Xeric's Talisman",false),
    XERICS_HONOUR_XERICS_TALISMAN(new WorldPoint(1254, 3562, 0), "Xeric's Honour", "Xeric's Talisman",false),
    FIRE_ALTAR_RING_OF_THE_ELEMENTS(new WorldPoint(3314, 3277, 0), "Fire Altar", "Ring of the Elements",false),
    WATER_ALTAR_RING_OF_THE_ELEMENTS(new WorldPoint(3170, 3155, 0), "Water Altar", "Ring of the Elements",false),
    AIR_ALTAR_RING_OF_THE_ELEMENTS(new WorldPoint(2982, 3276, 0), "Air Altar", "Ring of the Elements",false),
    EARTH_ALTAR_RING_OF_THE_ELEMENTS(new WorldPoint(3289, 3467, 0), "Earth Altar", "Ring of the Elements",false),
    DARKFROST_PENDANT_OF_ATES(new WorldPoint(1489, 3285, 0), "Darkfrost", "Pendant of Ates",false),
    TWILIGHT_TEMPLE_PENDANT_OF_ATES(new WorldPoint(1664, 3224, 0), "Twilight Temple", "Pendant of Ates",false),
    RALOS_RISE_PENDANT_OF_ATES(new WorldPoint(1459, 3137, 0), "Ralos' Rise", "Pendant of Ates",false),
    NORTH_ALDARIN_PENDANT_OF_ATES(new WorldPoint(1424, 2991, 0), "North Aldarin", "Pendant of Ates",true),
    OBELISK_13_WILDERNESS_OBELISK(new WorldPoint(3156, 3619, 0), "Obelisk 13", "Wilderness Obelisk",true),
    OBELISK_19_WILDERNESS_OBELISK(new WorldPoint(3228, 3667, 0), "Obelisk 19", "Wilderness Obelisk",true),
    OBELISK_27_WILDERNESS_OBELISK(new WorldPoint(3035, 3732, 0), "Obelisk 27", "Wilderness Obelisk",true),
    OBELISK_35_WILDERNESS_OBELISK(new WorldPoint(3106, 3794, 0), "Obelisk 35", "Wilderness Obelisk",true),
    OBELISK_44_WILDERNESS_OBELISK(new WorldPoint(2980, 3865, 0), "Obelisk 44", "Wilderness Obelisk",true),
    OBELISK_50_WILDERNESS_OBELISK(new WorldPoint(3307, 3915, 0), "Obelisk 50", "Wilderness Obelisk",true),
    RIMMINGTON_CONSTRUCTION_CAPE(new WorldPoint(2953, 3223, 0), "Rimmington", "Construction Cape",false),
    TAVERLEY_CONSTRUCTION_CAPE(new WorldPoint(2894, 3465, 0), "Taverley", "Construction Cape",false),
    POLLNIVNEACH_CONSTRUCTION_CAPE(new WorldPoint(3340, 3003, 0), "Pollnivneach", "Construction Cape",false),
    HOSIDIUS_CONSTRUCTION_CAPE(new WorldPoint(1743, 3517, 0), "Hosidius", "Construction Cape",false),
    RELLEKKA_CONSTRUCTION_CAPE(new WorldPoint(2670, 3631, 0), "Rellekka", "Construction Cape",false),
    ALDARIN_CONSTRUCTION_CAPE(new WorldPoint(1420, 2963, 0), "Aldarin", "Construction Cape",false),
    BRIMHAVEN_CONSTRUCTION_CAPE(new WorldPoint(2758, 3178, 0), "Brimhaven", "Construction Cape",false),
    YANILLE_CONSTRUCTION_CAPE(new WorldPoint(2544, 3095, 0), "Yanille", "Construction Cape",false);

    private final WorldPoint location;
    private final String name;
    private final String teleportType;
    private final boolean wildernessTeleport;

    HotColdTeleports(final WorldPoint location, final String name, final String teleportType, final boolean wildernessTeleport) {
        this.location = location;
        this.name = name;
        this.teleportType = teleportType;
        this.wildernessTeleport = wildernessTeleport;
    }

}
/*
 * Copyright (c) 2025, Lalochazia
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.hotcoldhelper;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import javax.inject.Inject;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

public class HotColdHelperOverlay extends OverlayPanel {
    private final HotColdHelperPlugin plugin;
    private final HotColdHelperConfig config;
    private static final int PANEL_WIDTH = 250;

    @Inject
    private HotColdHelperOverlay(HotColdHelperPlugin plugin, HotColdHelperConfig config) {
        super(plugin);
        setPosition(OverlayPosition.TOP_LEFT);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		this.plugin = plugin;
        this.config = config;
        panelComponent.setPreferredSize(new Dimension(PANEL_WIDTH, 0));
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.isHotColdClueActive()) {
            return null;
        }

        int possibleLocations = plugin.getPossibleLocationsCount();

        if (possibleLocations == 1) {
            return null;
        }

        if (possibleLocations >= 0) {
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("Hot/Cold Helper - " + possibleLocations + " Possible")
                    .color(Color.WHITE)
                    .build());

            if (possibleLocations > 1) {
                Map<String, Integer> cardinalInfo = plugin.getCardinalInfoGain();
                if (cardinalInfo != null && !cardinalInfo.isEmpty()) {
                    String bestDirection = "None";
                    int highestScore = 0;

                    for (Map.Entry<String, Integer> entry : cardinalInfo.entrySet()) {
                        if (entry.getValue() > highestScore) {
                            highestScore = entry.getValue();
                            bestDirection = entry.getKey();
                        }
                    }

                    if (!bestDirection.equals("None") && highestScore > 1000 && plugin.isNearLastMessageLocation() ) {
                        Color directionColor;
                        if (highestScore > 3000) {
                            directionColor = Color.GREEN;
                        } else if (highestScore >= 2000) {
                            directionColor = new Color(255, 191, 0);
                        } else {
                            directionColor = Color.RED;
                        }
                        panelComponent.getChildren().add(LineComponent.builder()
                                .left("Move " + bestDirection)
                                .leftColor(directionColor)
                                .build());
                    }
                }

                Map<HotColdTeleports, Double> entropyValues = plugin.getEntropyValues();

                List<Map.Entry<HotColdTeleports, Double>> sortedTeleports = entropyValues.entrySet()
                        .stream()
                        .sorted(Map.Entry.comparingByValue())
                        .limit(config.maxTeleportEntries())
                        .collect(Collectors.toList());

                for (int i = 0; i < sortedTeleports.size(); i++) {
                    Map.Entry<HotColdTeleports, Double> entry = sortedTeleports.get(i);
                    HotColdTeleports teleport = entry.getKey();
                    String name = teleport.getName();
                    String group = teleport.getTeleportType();
                    String teleportName = name + " (" + group + ")";
                    Color textColor = teleport.isWildernessTeleport() ? new Color(255, 102, 102) : Color.WHITE;
                    panelComponent.getChildren().add(LineComponent.builder()
                            .left((i+1) + ". " + teleportName)
                            .right("")
                            .leftColor(textColor)
                            .build());
                }
            }
        }
        return super.render(graphics);
    }
}
/*
 * Copyright (c) 2025, Lalochazia
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.hotcoldhelper;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;

@Slf4j
public class HotColdCardinalHelper {

    public static Map<String, Integer> calculateCardinalInfoGain(List<WorldPoint> possibleLocations, WorldPoint currentLocation) {
        if (possibleLocations == null || possibleLocations.isEmpty() || currentLocation == null) {
            return new HashMap<>();
        }

        Map<String, Integer> infoGain = new HashMap<>();
        int step = 2;
        Map<String, WorldPoint> cardinalPoints = new HashMap<>();
        cardinalPoints.put("North", new WorldPoint(currentLocation.getX(), currentLocation.getY() + step, currentLocation.getPlane()));
        cardinalPoints.put("East", new WorldPoint(currentLocation.getX() + step, currentLocation.getY(), currentLocation.getPlane()));
        cardinalPoints.put("South", new WorldPoint(currentLocation.getX(), currentLocation.getY() - step, currentLocation.getPlane()));
        cardinalPoints.put("West", new WorldPoint(currentLocation.getX() - step, currentLocation.getY(), currentLocation.getPlane()));

        for (Map.Entry<String, WorldPoint> entry : cardinalPoints.entrySet()) {
            String direction = entry.getKey();
            WorldPoint newPoint = entry.getValue();

            int signalQualityScore = calculateSignalQualityScore(possibleLocations, currentLocation, newPoint);
            infoGain.put(direction, signalQualityScore);
        }
        return infoGain;
    }

    private static int calculateSignalQualityScore(List<WorldPoint> possibleLocations,
                                                   WorldPoint currentLocation,
                                                   WorldPoint newPoint) {
        int totalLocations = possibleLocations.size();
        if (totalLocations <= 1) return 0;

        Map<String, Integer> signalCounts = new HashMap<>();
        signalCounts.put("warmer", 0);
        signalCounts.put("colder", 0);
        signalCounts.put("same", 0);

        for (WorldPoint location : possibleLocations) {
            int currentDistance = calculateDistance(currentLocation, location);
            int newDistance = calculateDistance(newPoint, location);

            if (newDistance < currentDistance) {
                signalCounts.put("warmer", signalCounts.get("warmer") + 1);
            } else if (newDistance > currentDistance) {
                signalCounts.put("colder", signalCounts.get("colder") + 1);
            } else {
                signalCounts.put("same", signalCounts.get("same") + 1);
            }
        }
        int uniqueSignalTypes = (int) signalCounts.values().stream().filter(count -> count > 0).count();
        int balanceScore = 0;
        for (int count : signalCounts.values()) {
            if (count > 0) {
                balanceScore += count * (totalLocations - count);
            }
        }
        return (uniqueSignalTypes * 1000) + (balanceScore / 100);
    }

    private static int calculateDistance(WorldPoint p1, WorldPoint p2) {
        return Math.max(Math.abs(p1.getX() - p2.getX()), Math.abs(p1.getY() - p2.getY()));
    }

    public static class BestCardinalResult {
        private final String direction;
        private final int score;

        public BestCardinalResult(String direction, int score) {
            this.direction = direction;
            this.score = score;
        }

        public String getDirection() {
            return direction;
        }

        public int getScore() {
            return score;
        }
    }

    public static BestCardinalResult findBestCardinalDirection(Map<String, Integer> cardinalInfoGain) {
        if (cardinalInfoGain == null || cardinalInfoGain.isEmpty()) {
            return new BestCardinalResult("None", 0);
        }
        String bestDirection = "None";
        int highestScore = 0;
        for (Map.Entry<String, Integer> entry : cardinalInfoGain.entrySet()) {
            if (entry.getValue() > highestScore) {
                highestScore = entry.getValue();
                bestDirection = entry.getKey();
            }
        }
        return new BestCardinalResult(bestDirection, highestScore);
    }
}
package com.hotcoldhelper;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class HotColdHelperTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(HotColdHelperPlugin.class);
		RuneLite.main(args);
	}
}
