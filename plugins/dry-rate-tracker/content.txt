package com.dryrate;

/**
 * Enum representing the different raid types we track
 */
public enum RaidType
{
    TOB("Theatre of Blood", "ToB"),
    TOA("Tombs of Amascut", "ToA"),
    COX("Chambers of Xeric", "CoX");

    private final String fullName;
    private final String shortName;

    RaidType(String fullName, String shortName)
    {
        this.fullName = fullName;
        this.shortName = shortName;
    }

    public String getFullName()
    {
        return fullName;
    }

    public String getShortName()
    {
        return shortName;
    }

    @Override
    public String toString()
    {
        return shortName;
    }
} 
package com.dryrate;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.text.DecimalFormat;
import java.util.Map;

/**
 * Panel that displays dry streak information for all raids
 */
@Slf4j
public class DryRatePanel extends PluginPanel
{
    private final DryRateManager dryRateManager;
    private final DecimalFormat decimalFormat;
    
    // UI Components
    private JPanel mainPanel;
    private Map<RaidType, JPanel> raidPanels;

    public DryRatePanel(DryRateManager dryRateManager)
    {
        this.dryRateManager = dryRateManager;
        this.decimalFormat = new DecimalFormat("#.#");
        
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());
        
        log.debug("Initializing panel");
        initializeComponents();
        updateDisplay();
        log.debug("Panel initialization complete");
    }

    private void initializeComponents()
    {
        // Main panel with vertical layout
        mainPanel = new JPanel();
        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
        mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        mainPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

        // Main title
        JLabel titleLabel = new JLabel("Dry Rate Tracker");
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setFont(new Font("SansSerif", Font.BOLD, 18));
        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        mainPanel.add(titleLabel);
        
        mainPanel.add(Box.createVerticalStrut(12));

        // Create panels for each raid type
        for (RaidType raidType : RaidType.values())
        {
            JPanel raidPanel = createRaidPanel(raidType);
            mainPanel.add(raidPanel);
            mainPanel.add(Box.createVerticalStrut(8));
        }

        // Scroll pane to handle overflow
        JScrollPane scrollPane = new JScrollPane(mainPanel);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setBorder(null);
        scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(8, 0));
        scrollPane.getVerticalScrollBar().setUnitIncrement(16); // Smoother scrolling
        
        // Let the main panel size itself naturally for proper scrolling
        mainPanel.setPreferredSize(null);
        
        add(scrollPane, BorderLayout.CENTER);
    }

    private JPanel createRaidPanel(RaidType raidType)
    {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(BorderFactory.createCompoundBorder(
            BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),
            new EmptyBorder(8, 8, 8, 8)
        ));

        // Raid title
        JLabel titleLabel = new JLabel(raidType.getShortName());
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 14f));
        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(titleLabel);

        panel.add(Box.createVerticalStrut(5));

        // Current dry streak
        JLabel dryStreakLabel = new JLabel();
        dryStreakLabel.setForeground(Color.WHITE);
        dryStreakLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(dryStreakLabel);

        // Statistics
        JLabel statsLabel = new JLabel();
        statsLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        statsLabel.setFont(statsLabel.getFont().deriveFont(11f));
        statsLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(statsLabel);

        // Reset button
        JButton resetButton = new JButton("Reset");
        resetButton.setPreferredSize(new Dimension(80, 25));
        resetButton.setMaximumSize(new Dimension(80, 25));
        resetButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        resetButton.addActionListener(new ActionListener()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                int result = JOptionPane.showConfirmDialog(
                    DryRatePanel.this,
                    "Reset dry streak for " + raidType.getShortName() + "?",
                    "Confirm Reset",
                    JOptionPane.YES_NO_OPTION
                );
                
                if (result == JOptionPane.YES_OPTION)
                {
                    dryRateManager.resetDryStreak(raidType);
                    updateDisplay();
                }
            }
        });
        
        panel.add(Box.createVerticalStrut(5));
        panel.add(resetButton);

        return panel;
    }

    public void updateDisplay()
    {
        SwingUtilities.invokeLater(() -> {
            // Remove all components and rebuild
            mainPanel.removeAll();
            
            // Main title
            JLabel titleLabel = new JLabel("Dry Rate Tracker");
            titleLabel.setForeground(Color.WHITE);
            titleLabel.setFont(new Font("SansSerif", Font.BOLD, 18));
            titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
            mainPanel.add(titleLabel);
            
            mainPanel.add(Box.createVerticalStrut(12));

            // Re-add raid panels with updated data
            for (RaidType raidType : RaidType.values())
            {
                JPanel raidPanel = createUpdatedRaidPanel(raidType);
                mainPanel.add(raidPanel);
                mainPanel.add(Box.createVerticalStrut(8));
            }

            mainPanel.revalidate();
            mainPanel.repaint();
        });
    }

    private JPanel createUpdatedRaidPanel(RaidType raidType)
    {
        DryRateData data = dryRateManager.getRaidData(raidType);
        
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        
        // Much simpler background colors
        Color bgColor = ColorScheme.DARKER_GRAY_COLOR;
        
        panel.setBackground(bgColor);
        panel.setBorder(BorderFactory.createCompoundBorder(
            BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
            new EmptyBorder(8, 10, 8, 10)
        ));

        // Raid title
        String titleText = raidType.getShortName();
        JLabel titleLabel = new JLabel(titleText);
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setFont(new Font("SansSerif", Font.BOLD, 16));
        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(titleLabel);

        panel.add(Box.createVerticalStrut(6));

        // Dry streak display
        String streakText = data.getCurrentDryStreak() == 0 ? "âœ… No dry streak!" : 
                           "Current dry: " + data.getCurrentDryStreak();
        JLabel dryStreakLabel = new JLabel(streakText);
        
        Color streakColor = data.getCurrentDryStreak() == 0 ? 
            new Color(100, 200, 100) : new Color(255, 200, 100);
        
        dryStreakLabel.setForeground(streakColor);
        dryStreakLabel.setFont(new Font("SansSerif", Font.BOLD, 14));
        dryStreakLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(dryStreakLabel);

        panel.add(Box.createVerticalStrut(6));

        // Statistics on two lines
        JLabel stats1Label = new JLabel("Completions: " + data.getTotalCompletions() + " | Uniques: " + data.getTotalUniques());
        stats1Label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        stats1Label.setFont(new Font("SansSerif", Font.PLAIN, 12));
        stats1Label.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(stats1Label);
        
        JLabel stats2Label = new JLabel("Longest dry: " + data.getLongestDryStreak());
        stats2Label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        stats2Label.setFont(new Font("SansSerif", Font.PLAIN, 12));
        stats2Label.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(stats2Label);

        panel.add(Box.createVerticalStrut(6));

        // Reset button
        JButton resetButton = new JButton("Manual Reset");
        resetButton.setPreferredSize(new Dimension(130, 26));
        resetButton.setMaximumSize(new Dimension(130, 26));
        resetButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        resetButton.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
        resetButton.setForeground(Color.WHITE);
        resetButton.setFocusPainted(false);
        resetButton.setFont(new Font("SansSerif", Font.PLAIN, 12));
        
        resetButton.addActionListener(new ActionListener()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                int result = JOptionPane.showConfirmDialog(
                    DryRatePanel.this,
                    "Manually reset dry streak for " + raidType.getShortName() + "?",
                    "Confirm Reset",
                    JOptionPane.YES_NO_OPTION
                );
                
                if (result == JOptionPane.YES_OPTION)
                {
                    dryRateManager.handleUniqueDropReceived(raidType);
                    updateDisplay();
                }
            }
        });
        
        panel.add(resetButton);

        return panel;
    }
} 
package com.dryrate;

import lombok.Data;
import java.util.ArrayList;
import java.util.List;

/**
 * Data class to store dry streak information for a specific raid type
 */
@Data
public class DryRateData
{
    private int currentDryStreak;
    private int totalCompletions;
    private int totalUniques;
    private List<Integer> previousDryStreaks;
    private long lastDropTime;

    public DryRateData()
    {
        this.currentDryStreak = 0;
        this.totalCompletions = 0;
        this.totalUniques = 0;
        this.previousDryStreaks = new ArrayList<>();
        this.lastDropTime = 0;
    }

    // Helper methods for dry streak tracking
    public void incrementDryStreak()
    {
        this.currentDryStreak++;
        this.totalCompletions++;
    }

    public void resetDryStreak()
    {
        // Add to history if we had a streak > 0
        if (currentDryStreak > 0)
        {
            previousDryStreaks.add(currentDryStreak);
        }
        
        // Reset streak to 0 and increment uniques
        this.currentDryStreak = 0;
        this.totalUniques++;
        this.lastDropTime = System.currentTimeMillis();
    }

    public int getLongestDryStreak()
    {
        int longest = currentDryStreak;
        for (int streak : previousDryStreaks)
        {
            if (streak > longest)
            {
                longest = streak;
            }
        }
        return longest;
    }

    public double getAverageDryStreak()
    {
        if (previousDryStreaks.isEmpty())
        {
            return 0.0;
        }
        
        int total = 0;
        for (int streak : previousDryStreaks)
        {
            total += streak;
        }
        return (double) total / previousDryStreaks.size();
    }
} 
package com.dryrate;


import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;

import net.runelite.api.Client;
import net.runelite.api.GameState;

import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WallObjectSpawned;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;

import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;


@Slf4j
@PluginDescriptor(
	name = "Dry Rate Tracker",
	description = "Automatically track dry streaks and unique drops for OSRS raids (ToB, ToA, CoX)",
	tags = {"raids", "tracking", "statistics", "purple", "unique"}
)
public class DryRatePlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private DryRateConfig config;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ConfigManager configManager;

	@Inject
	private DryRateManager dryRateManager;

	private DryRatePanel panel;
	private NavigationButton navButton;

	// Track previous region to detect raid completion
	private int previousRegionId = -1;
	private boolean inRaid = false;
	private RaidType currentRaidType = null;
	
	// Chest detection for raid completions and unique drops
	// Regular loot chests (no unique)
	private static final int TOB_LOOT_CHEST_REGULAR_TEAM = 32990;    // Teammate's regular chest
	private static final int TOB_LOOT_CHEST_REGULAR_PERSONAL = 32992; // Player's regular chest
	// ToA does NOT use these chest IDs - it uses sarcophagus + varbits instead
	// CoX does NOT use chest IDs - it uses light object + varbit instead
	
	// Purple loot chests (unique drops) - CORRECTED IDs
	private static final int TOB_LOOT_CHEST_PURPLE_TEAM = 32991;     // Teammate's purple chest
	private static final int TOB_LOOT_CHEST_PURPLE_PERSONAL = 32993; // Player's purple chest  
	// ToA does NOT use these chest IDs - it uses sarcophagus + varbits instead  
	// CoX does NOT use chest IDs - it uses light object + varbit instead
	
	// Chest tracking state
	private boolean chestsHandled = false;
	private List<Integer> loadedChests = new ArrayList<>();
	
	// ToA sarcophagus detection constants
	private static final int TOA_SARCOPHAGUS_ID = 46221; // Wall object ID for sarcophagus
	private static final int TOA_VARBIT_SARCOPHAGUS = 14373; // Varbit for purple detection
	private static final int[] TOA_VARBIT_CHEST_IDS = {14356, 14357, 14358, 14359, 14360, 14370, 14371, 14372};
	private static final int TOA_VARBIT_CHEST_KEY = 2;
	
	// CoX light detection constants (from CoX light colors plugin)
	private static final int COX_LIGHT_OBJECT_ID = 28848; // Light object spawned after raid completion
	private static final int COX_VARBIT_LIGHT_TYPE = 5456; // Varbit for loot type: 1=standard, 2=unique, 3=dust, 4=kit
	
	// Raid region IDs for detection  
	private static final int TOB_REGION = 12613; // Theatre of Blood - CORRECTED
	private static final int TOA_REGION = 14160; // Tombs of Amascut  
	private static final int COX_REGION = 12889; // Chambers of Xeric
	
	// Note: All chat message detection removed to prevent false positives.
	// Raid completions detected via chest spawning only.


	@Override
	protected void startUp() throws Exception
	{
		log.debug("Dry Rate Tracker started!");
		
		// Initialize the dry rate manager
		dryRateManager.loadData();
		
		// Create the panel
		panel = new DryRatePanel(dryRateManager);
		log.debug("Panel created successfully");
		
		// Create a towel icon (perfect for "dry" tracker!)
		BufferedImage icon = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
		java.awt.Graphics2D g2d = icon.createGraphics();
		g2d.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING, java.awt.RenderingHints.VALUE_ANTIALIAS_ON);
		
		// Draw towel main body (light blue/white towel)
		g2d.setColor(new java.awt.Color(200, 220, 255)); // Light blue towel
		g2d.fillRect(3, 2, 10, 12);
		
		// Add towel texture lines (horizontal stripes)
		g2d.setColor(new java.awt.Color(180, 200, 240)); // Slightly darker blue
		g2d.drawLine(4, 4, 11, 4);   // Top stripe
		g2d.drawLine(4, 6, 11, 6);   // Second stripe
		g2d.drawLine(4, 8, 11, 8);   // Third stripe
		g2d.drawLine(4, 10, 11, 10); // Fourth stripe
		g2d.drawLine(4, 12, 11, 12); // Bottom stripe
		
		// Add towel edges/border for definition
		g2d.setColor(new java.awt.Color(150, 170, 200)); // Darker border
		g2d.drawRect(3, 2, 10, 12);
		
		// Add a small "hanging" effect at the top
		g2d.setColor(new java.awt.Color(100, 100, 100)); // Dark gray hook/hanger
		g2d.fillRect(7, 0, 2, 3);
		
		g2d.dispose();
		
		navButton = NavigationButton.builder()
			.tooltip("Dry Rate Tracker")
			.icon(icon)
			.priority(5)
			.panel(panel)
			.build();
		
		clientToolbar.addNavigation(navButton);
		log.debug("Navigation button added to toolbar");
		
		// Initialize region tracking
		if (client.getLocalPlayer() != null)
		{
			previousRegionId = getCurrentRegionId();
			updateRaidState();
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.debug("Dry Rate Tracker stopped!");
		
		// Save data before shutting down
		dryRateManager.saveData();
		
		// Remove the panel
		clientToolbar.removeNavigation(navButton);
		
		// Reset tracking state
		inRaid = false;
		currentRaidType = null;
		previousRegionId = -1;
	}

	/**
	 * Primary detection method: Monitor for loot chest objects spawning
	 * Uses ToB QoL style logic to detect both completions and unique drops
	 */
	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		int objectId = event.getGameObject().getId();
		int regionId = getCurrentRegionId();
		
		// Debug: Log all object spawns while in raid regions for troubleshooting
		if (regionId == TOB_REGION)
		{
			log.debug("Object spawned in ToB region {}: objectId={}, position={}", 
				regionId, objectId, event.getGameObject().getWorldLocation());
		}
		else if (regionId == TOA_REGION)
		{
			log.debug("Object spawned in ToA region {}: objectId={}, position={}", 
				regionId, objectId, event.getGameObject().getWorldLocation());
		}
		else if (regionId == COX_REGION)
		{
			log.debug("Object spawned in CoX region {}: objectId={}, position={}", 
				regionId, objectId, event.getGameObject().getWorldLocation());
		}
		
		if (!inRaid || currentRaidType == null)
		{
			return;
		}
		
		// Check if this is a loot chest for the current raid type
		boolean isLootChest = false;
		switch (currentRaidType)
		{
			case TOB:
				isLootChest = objectId == TOB_LOOT_CHEST_REGULAR_TEAM || 
				              objectId == TOB_LOOT_CHEST_REGULAR_PERSONAL || 
				              objectId == TOB_LOOT_CHEST_PURPLE_TEAM || 
				              objectId == TOB_LOOT_CHEST_PURPLE_PERSONAL;
				break;
			case TOA:
				// ToA uses sarcophagus wall object + varbits, not chest objects
				// See onWallObjectSpawned for ToA detection
				isLootChest = false;
				break;
			case COX:
				// CoX uses light object + varbit, not chest objects
				isLootChest = false;
				break;
		}
		
		if (isLootChest)
		{
			log.debug("LOOT CHEST DETECTED for {}: objectId={}, position={}", 
				currentRaidType, objectId, event.getGameObject().getWorldLocation());
			handleChest(objectId);
		}
		
		// Special case: CoX light object detection
		if (currentRaidType == RaidType.COX && objectId == COX_LIGHT_OBJECT_ID)
		{
			log.info("*** COX LIGHT OBJECT SPAWNED *** objectId={}, position={}", 
				objectId, event.getGameObject().getWorldLocation());
			handleCoXLight();
		}
	}
	
	/**
	 * ToA detection: Monitor for sarcophagus wall objects (different from ToB/CoX chests)
	 */
	@Subscribe
	public void onWallObjectSpawned(WallObjectSpawned event)
	{
		if (!inRaid || currentRaidType != RaidType.TOA)
		{
			return;
		}
		
		int objectId = event.getWallObject().getId();
		
		// ToA sarcophagus detection
		if (objectId == TOA_SARCOPHAGUS_ID)
		{
			log.info("*** TOA SARCOPHAGUS SPAWNED *** objectId={}, position={}", 
				objectId, event.getWallObject().getWorldLocation());
			handleToASarcophagus();
		}
	}
	
	/**
	 * Handle ToA sarcophagus using varbit detection
	 */
	private void handleToASarcophagus()
	{
		if (chestsHandled)
		{
			log.debug("ToA sarcophagus already handled, ignoring");
			return;
		}
		
		// Check if sarcophagus is purple using varbit
		boolean isPurple = client.getVarbitValue(TOA_VARBIT_SARCOPHAGUS) % 2 != 0;
		
		// Check if it's personal (no team member has key)
		boolean isPersonal = true;
		for (int varbitId : TOA_VARBIT_CHEST_IDS)
		{
			if (client.getVarbitValue(varbitId) == TOA_VARBIT_CHEST_KEY)
			{
				isPersonal = false;
				break;
			}
		}
		
		log.info("*** TOA SARCOPHAGUS ANALYSIS *** isPurple={}, isPersonal={}", isPurple, isPersonal);
		
		// Always count as raid completion
		handleRaidCompletion(RaidType.TOA, "ToA sarcophagus detection");
		
		// Handle unique drops
		if (isPurple)
		{
			if (isPersonal)
			{
				log.info("*** TOA PERSONAL UNIQUE DROP *** detected");
				dryRateManager.handleUniqueDropReceived(RaidType.TOA);
			}
			else if (config.teamDropResets())
			{
				log.info("*** TOA TEAM UNIQUE DROP *** detected, team resets enabled: {}", 
					config.teamDropResets());
				dryRateManager.handleUniqueDropReceived(RaidType.TOA);
			}
			else
			{
				log.info("ToA team unique drop detected but team resets disabled");
			}
		}
		else
		{
			log.info("ToA regular sarcophagus (no unique) - dry streak will increment");
		}
		
		chestsHandled = true;
		
		// Update UI
		if (panel != null)
		{
			panel.updateDisplay();
		}
	}
	
	/**
	 * Handle CoX light object using varbit detection
	 */
	private void handleCoXLight()
	{
		if (chestsHandled)
		{
			log.debug("CoX light already handled, ignoring");
			return;
		}
		
		// Check light type using varbit
		int lightType = client.getVarbitValue(COX_VARBIT_LIGHT_TYPE);
		boolean isPurple = (lightType == 2); // 2 = unique drop
		
		log.info("*** COX LIGHT ANALYSIS *** lightType={}, isPurple={}", lightType, isPurple);
		
		// Always count as raid completion
		handleRaidCompletion(RaidType.COX, "CoX light detection");
		
		// Handle unique drops - CoX light doesn't distinguish personal vs team
		// We'll treat all unique drops as personal for now
		if (isPurple)
		{
			log.info("*** COX UNIQUE DROP *** detected");
			dryRateManager.handleUniqueDropReceived(RaidType.COX);
		}
		else
		{
			log.info("CoX regular light (no unique) - dry streak will increment");
		}
		
		chestsHandled = true;
		
		// Update UI
		if (panel != null)
		{
			panel.updateDisplay();
		}
	}
	
	/**
	 * Secondary detection method: Monitor region changes
	 */
	@Subscribe
	public void onGameTick(GameTick event)
	{
		int currentRegionId = getCurrentRegionId();
		
		if (currentRegionId != previousRegionId)
		{
			log.debug("Region changed from {} to {}", previousRegionId, currentRegionId);
			updateRaidState();
			previousRegionId = currentRegionId;
		}
	}
	
	/**
	 * Tertiary detection method: Game state detection via varbits (if available)
	 */
	@Subscribe  
	public void onVarbitChanged(VarbitChanged event)
	{
		// Monitor raid-specific varbits for completion
		// These varbit IDs would need to be researched for each raid
		// Example implementation:
		/*
		if (event.getVarbitId() == TOB_COMPLETION_VARBIT && event.getValue() > 0) 
		{
			handleRaidCompletion(RaidType.TOB, "Varbit completion detected");
		}
		*/
	}

	/**
	 * Handle chest spawning
	 */
	private void handleChest(int chestId)
	{
		log.debug("handleChest called: chestId={}, chestsHandled={}, currentRaidType={}", 
			chestId, chestsHandled, currentRaidType);
			
		if (chestsHandled)
		{
			log.debug("Chests already handled, ignoring chestId={}", chestId);
			return;
		}

		loadedChests.add(chestId);
		log.debug("Chest loaded: {}, total loaded: {}, loadedChests={}", 
			chestId, loadedChests.size(), loadedChests);

		// For now, process immediately when any chest is detected
		// TODO: Could enhance to wait for full party size
		processChests();
		chestsHandled = true;
		log.debug("Set chestsHandled=true after processing");
	}

	/**
	 * Process the loaded chests to determine completion and unique drops
	 */
	private void processChests()
	{
		log.debug("processChests called: currentRaidType={}, loadedChests={}", 
			currentRaidType, loadedChests);
			
		if (currentRaidType == null || loadedChests.isEmpty())
		{
			log.debug("Cannot process chests: currentRaidType={}, loadedChests.isEmpty()={}", 
				currentRaidType, loadedChests.isEmpty());
			return;
		}

		boolean isPurple = false;
		boolean isPersonal = false;

		// Check if any purple chests were loaded
		switch (currentRaidType)
		{
			case TOB:
				isPurple = loadedChests.contains(TOB_LOOT_CHEST_PURPLE_PERSONAL) || 
				           loadedChests.contains(TOB_LOOT_CHEST_PURPLE_TEAM);
				isPersonal = loadedChests.contains(TOB_LOOT_CHEST_PURPLE_PERSONAL);
				log.debug("ToB chest analysis: isPurple={}, isPersonal={}, personalId={}, teamId={}", 
					isPurple, isPersonal, TOB_LOOT_CHEST_PURPLE_PERSONAL, TOB_LOOT_CHEST_PURPLE_TEAM);
				break;
			case TOA:
				// ToA is handled separately via sarcophagus detection, not chest objects
				// This should not be reached since ToA doesn't add items to loadedChests
				log.warn("processChests called for ToA - this should not happen");
				return;
			case COX:
				// CoX is handled separately via light object detection, not chest objects
				// This should not be reached since CoX doesn't add items to loadedChests
				log.warn("processChests called for CoX - this should not happen");
				return;
		}

		log.debug("*** PROCESSING CHESTS *** {}: isPurple={}, isPersonal={}, teamResets={}", 
			currentRaidType, isPurple, isPersonal, config.teamDropResets());

		// Always count this as a raid completion
		handleRaidCompletion(currentRaidType, "Chest detection");

		// Handle unique drops
		if (isPurple)
		{
			if (isPersonal)
			{
				// Personal purple - always reset dry streak
				log.debug("*** PERSONAL UNIQUE DROP *** detected for {}", currentRaidType);
				dryRateManager.handleUniqueDropReceived(currentRaidType);
			}
			else if (config.teamDropResets())
			{
				// Team purple - only reset if config allows
				log.debug("*** TEAM UNIQUE DROP *** detected for {}, team resets enabled: {}", 
					currentRaidType, config.teamDropResets());
				dryRateManager.handleUniqueDropReceived(currentRaidType);
			}
			else
			{
				log.debug("Team unique drop detected for {} but team resets disabled", currentRaidType);
			}
		}
		else
		{
			log.debug("No purple chests detected - dry streak will increment");
		}
		
		// Update UI
		if (panel != null)
		{
			panel.updateDisplay();
		}
	}

	/**
	 * Reset chest tracking state (called when leaving raids)
	 */
	private void resetChestTracking()
	{
		chestsHandled = false;
		loadedChests.clear();
		log.debug("Reset chest tracking state");
	}

	/**
	 * Get current region ID
	 */
	private int getCurrentRegionId()
	{
		if (client.getLocalPlayer() == null)
		{
			return -1;
		}
		
		return client.getLocalPlayer().getWorldLocation().getRegionID();
	}
	
	/**
	 * Update raid state based on current region
	 */
	private void updateRaidState()
	{
		int regionId = getCurrentRegionId();
		
		// Log ALL region changes to help identify correct region IDs
		if (regionId != previousRegionId)
		{
			log.info("*** REGION CHANGE *** from {} to {} (TOB={}, TOA={}, COX={})", 
				previousRegionId, regionId, TOB_REGION, TOA_REGION, COX_REGION);
		}
		
		boolean wasInRaid = inRaid;
		RaidType previousRaidType = currentRaidType;
		
		// Determine if we're in a raid and which type
		if (regionId == TOB_REGION)
		{
			inRaid = true;
			currentRaidType = RaidType.TOB;
		}
		else if (regionId == TOA_REGION)
		{
			inRaid = true;
			currentRaidType = RaidType.TOA;
		}
		else if (regionId == COX_REGION)
		{
			inRaid = true;
			currentRaidType = RaidType.COX;
		}
		else
		{
			inRaid = false;
			currentRaidType = null;
		}
		
		// Enhanced logging for debugging
		log.debug("Region check: current={}, inRaid={}, raidType={}", 
			regionId, inRaid, currentRaidType);
		
		// Log raid state changes and reset chest tracking when leaving raids
		if (!wasInRaid && inRaid)
		{
			log.info("*** ENTERED {} RAID *** region={}, expected: TOB={}, TOA={}, COX={}", 
				currentRaidType, regionId, TOB_REGION, TOA_REGION, COX_REGION);
			resetChestTracking(); // Reset on entry to be safe
		}
		else if (wasInRaid && !inRaid)
		{
			log.info("*** LEFT {} RAID *** region={}", 
				previousRaidType, regionId);
			resetChestTracking(); // Reset when leaving raid
		}
		else if (inRaid && currentRaidType != previousRaidType)
		{
			log.info("*** CHANGED RAIDS *** from {} to {} region={}", 
				previousRaidType, currentRaidType, regionId);
			resetChestTracking(); // Reset when switching raid types
		}
		
		previousRegionId = regionId;
	}
	


	private void handleRaidCompletion(RaidType raidType, String message)
	{
		log.debug("Raid completion detected: {} - {}", raidType, message);
		
		// Track the completion
		dryRateManager.handleRaidCompletion(raidType);
		
		// Update the panel
		if (panel != null)
		{
			panel.updateDisplay();
		}
	}

	@Provides
	DryRateConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(DryRateConfig.class);
	}
} 
package com.dryrate;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.lang.reflect.Type;
import java.util.EnumMap;
import java.util.Map;

/**
 * Manager class that handles all dry rate tracking logic
 */
@Slf4j
@Singleton
public class DryRateManager
{
    private static final String CONFIG_GROUP = "dryrate";
    private static final String DATA_KEY = "data";

    private final DryRateConfig config;
    private final ConfigManager configManager;
    private final Map<RaidType, DryRateData> raidData;
    private final Gson gson;

    @Inject
    public DryRateManager(DryRateConfig config, ConfigManager configManager, Gson gson)
    {
        this.config = config;
        this.configManager = configManager;
        this.raidData = new EnumMap<>(RaidType.class);
        this.gson = gson; // Use injected Gson from RuneLite
        
        // Initialize data for each raid type
        for (RaidType raidType : RaidType.values())
        {
            raidData.put(raidType, new DryRateData());
        }
    }

    /**
     * Load data from configuration
     */
    public void loadData()
    {
        try
        {
            String dataJson = configManager.getConfiguration(CONFIG_GROUP, DATA_KEY);
            log.debug("*** LOADING DATA *** Raw JSON from config: {}", dataJson);
            
            if (dataJson != null && !dataJson.isEmpty())
            {
                // Use String keys to avoid enum serialization issues
                Type type = new TypeToken<Map<String, DryRateData>>(){}.getType();
                Map<String, DryRateData> loadedData = gson.fromJson(dataJson, type);
                
                if (loadedData != null)
                {
                    log.info("Dry rate data loaded successfully - {} raid types", loadedData.size());
                    
                    // Convert string keys back to enum keys
                    for (Map.Entry<String, DryRateData> entry : loadedData.entrySet())
                    {
                        try
                        {
                            RaidType raidType = RaidType.valueOf(entry.getKey());
                            DryRateData data = entry.getValue();
                            raidData.put(raidType, data);
                            
                            log.debug("*** {} DATA *** Streak: {}, Completions: {}, Uniques: {}", 
                                raidType, data.getCurrentDryStreak(), data.getTotalCompletions(), data.getTotalUniques());
                        }
                        catch (IllegalArgumentException e)
                        {
                            log.warn("*** LOAD WARNING *** Unknown raid type: {}", entry.getKey());
                        }
                    }
                }
                else
                {
                    log.warn("*** LOAD WARNING *** Parsed data was null");
                }
            }
            else
            {
                log.info("No existing dry rate data found, starting fresh");
            }
            log.debug("*** LOAD COMPLETE *** Current raid data state:");
            for (Map.Entry<RaidType, DryRateData> entry : raidData.entrySet())
            {
                DryRateData data = entry.getValue();
                log.debug("*** {} CURRENT *** Streak: {}, Completions: {}, Uniques: {}", 
                    entry.getKey(), data.getCurrentDryStreak(), data.getTotalCompletions(), data.getTotalUniques());
            }
        }
        catch (Exception e)
        {
            log.error("*** LOAD ERROR *** Error loading dry rate data", e);
        }
    }

    /**
     * Save data to configuration
     */
    public void saveData()
    {
        try
        {
            log.debug("*** SAVING DATA *** Current state before save:");
            for (Map.Entry<RaidType, DryRateData> entry : raidData.entrySet())
            {
                DryRateData data = entry.getValue();
                log.debug("*** {} SAVE *** Streak: {}, Completions: {}, Uniques: {}", 
                    entry.getKey(), data.getCurrentDryStreak(), data.getTotalCompletions(), data.getTotalUniques());
            }
            
            // Convert enum keys to strings to avoid serialization issues
            Map<String, DryRateData> stringKeyMap = new java.util.HashMap<>();
            for (Map.Entry<RaidType, DryRateData> entry : raidData.entrySet())
            {
                stringKeyMap.put(entry.getKey().name(), entry.getValue());
            }
            
            String dataJson = gson.toJson(stringKeyMap);
            log.debug("*** SAVING DATA *** JSON to save: {}", dataJson);
            
            configManager.setConfiguration(CONFIG_GROUP, DATA_KEY, dataJson);
            log.debug("*** SAVE COMPLETE *** Data saved successfully to config group: {}, key: {}", CONFIG_GROUP, DATA_KEY);
        }
        catch (Exception e)
        {
            log.error("*** SAVE ERROR *** Error saving dry rate data", e);
        }
    }

    /**
     * Handle a raid completion (increment dry streak and total count)
     */
    public void handleRaidCompletion(RaidType raidType)
    {
        if (!isRaidTrackingEnabled(raidType))
        {
            return;
        }

        DryRateData data = raidData.get(raidType);
        if (data != null)
        {
            // Increment dry streak directly on each completion
            data.incrementDryStreak();
            log.debug("Raid completion for {}: Dry streak now {}, total completions {}", 
                raidType, data.getCurrentDryStreak(), data.getTotalCompletions());
            saveData();
        }
    }

    /**
     * Handle receiving a unique drop (reset dry streak and increment unique count)
     * This is typically called manually when the user confirms they received a unique drop
     */
    public void handleUniqueDropReceived(RaidType raidType)
    {
        if (!isRaidTrackingEnabled(raidType))
        {
            return;
        }

        DryRateData data = raidData.get(raidType);
        if (data != null)
        {
            int previousStreak = data.getCurrentDryStreak();
            
            // Reset dry streak (this handles history and unique count)
            data.resetDryStreak();
            
            log.debug("Unique drop for {}: Reset streak from {}, total uniques now {}", 
                raidType, previousStreak, data.getTotalUniques());
            saveData();
        }
    }

    /**
     * Handle team member receiving unique drop (only reset if config enabled)
     */
    public void handleTeamUniqueDropReceived(RaidType raidType)
    {
        if (!isRaidTrackingEnabled(raidType))
        {
            return;
        }

        // Only reset dry streak if team drops are configured to reset personal streak
        if (config != null && config.teamDropResets())
        {
            DryRateData data = raidData.get(raidType);
            if (data != null)
            {
                int previousStreak = data.getCurrentDryStreak();
                
                // Reset dry streak but don't increment personal unique count
                if (previousStreak > 0)
                {
                    data.getPreviousDryStreaks().add(previousStreak);
                }
                data.setCurrentDryStreak(0);
                
                log.debug("Team unique drop for {}: Reset streak from {} (team drops reset enabled)", 
                    raidType, previousStreak);
                saveData();
            }
        }
        else
        {
            log.debug("Team unique drop for {} ignored (team drops reset disabled)", raidType);
        }
    }

    /**
     * Get dry rate data for a specific raid type
     */
    public DryRateData getRaidData(RaidType raidType)
    {
        return raidData.get(raidType);
    }

    /**
     * Get all raid data
     */
    public Map<RaidType, DryRateData> getAllRaidData()
    {
        return new EnumMap<>(raidData);
    }

    /**
     * Reset dry streak for a specific raid type
     */
    public void resetDryStreak(RaidType raidType)
    {
        DryRateData data = raidData.get(raidType);
        if (data != null)
        {
            data.setCurrentDryStreak(0);
            log.debug("Manually reset dry streak for {}", raidType);
            saveData();
        }
    }

    /**
     * Reset all data for a specific raid type
     */
    public void resetAllData(RaidType raidType)
    {
        raidData.put(raidType, new DryRateData());
        log.debug("Reset all data for {}", raidType);
        saveData();
    }

    /**
     * Test method to manually test save/load functionality
     */
    public void testSaveLoad()
    {
        log.info("*** TESTING SAVE/LOAD *** Starting test");
        
        // Set some test data
        DryRateData testData = raidData.get(RaidType.TOB);
        testData.incrementDryStreak();
        testData.incrementDryStreak();
        testData.incrementDryStreak();
        
        log.info("*** TEST *** Set ToB dry streak to: {}", testData.getCurrentDryStreak());
        
        // Save the data
        saveData();
        
        // Clear the data
        raidData.put(RaidType.TOB, new DryRateData());
        log.info("*** TEST *** Cleared ToB data, streak now: {}", raidData.get(RaidType.TOB).getCurrentDryStreak());
        
        // Load the data back
        loadData();
        
        log.info("*** TEST *** After reload, ToB streak is: {}", raidData.get(RaidType.TOB).getCurrentDryStreak());
        log.info("*** TESTING SAVE/LOAD *** Test complete");
    }

    /**
     * Check if tracking is enabled for a specific raid type
     */
    private boolean isRaidTrackingEnabled(RaidType raidType)
    {
        if (config == null)
        {
            return true; // Default to enabled if config is not available
        }

        switch (raidType)
        {
            case TOB:
                return config.trackToB();
            case TOA:
                return config.trackToA();
            case COX:
                return config.trackCoX();
            default:
                return true;
        }
    }
} 
package com.dryrate;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("dryrate")
public interface DryRateConfig extends Config
{
	@ConfigItem(
		keyName = "showNotifications",
		name = "Show notifications",
		description = "Show notifications when you go dry or get a unique"
	)
	default boolean showNotifications()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackToB",
		name = "Track Theatre of Blood",
		description = "Track dry streaks for Theatre of Blood"
	)
	default boolean trackToB()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackToA",
		name = "Track Tombs of Amascut",
		description = "Track dry streaks for Tombs of Amascut"
	)
	default boolean trackToA()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackCoX",
		name = "Track Chambers of Xeric",
		description = "Track dry streaks for Chambers of Xeric"
	)
	default boolean trackCoX()
	{
		return true;
	}

	@ConfigItem(
		keyName = "resetConfirmation",
		name = "Confirm resets",
		description = "Ask for confirmation before resetting dry streak counters"
	)
	default boolean resetConfirmation()
	{
		return true;
	}

	@ConfigItem(
		keyName = "teamDropResets",
		name = "Team drops reset streaks",
		description = "Reset your dry streak when anyone in your team gets a unique (not just you)",
		position = 4
	)
	default boolean teamDropResets()
	{
		return false;
	}
} 
package com.dryrate;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class DryRatePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DryRatePlugin.class);
		RuneLite.main(args);
	}
} 
