package com.dryrate.detectors;

import com.dryrate.DryRateManager;
import com.dryrate.RaidType;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Chambers of Xeric raid detector
 * Handles CoX-specific detection logic including light object detection
 */
@Slf4j
@Singleton
public class CoxRaidDetector implements RaidDetector
{
    // CoX region and constants
    private static final int COX_REGION = 12889; // Chambers of Xeric
    
    // CoX light detection constants
    private static final int COX_LIGHT_OBJECT_ID = 28848; // Light object spawned after raid completion
    private static final int COX_VARBIT_LIGHT_TYPE = 5456; // Varbit for loot type: 1=standard, 2=unique, 3=dust, 4=kit
    
    private final Client client;
    private final DryRateManager dryRateManager;
    
    // State tracking
    private boolean inRaid = false;
    private boolean chestsHandled = false;
    private boolean lightObjectDetected = false;
    
    // UI update callback
    private UIUpdateCallback uiUpdateCallback;
    
    @Inject
    public CoxRaidDetector(Client client, DryRateManager dryRateManager)
    {
        this.client = client;
        this.dryRateManager = dryRateManager;
    }
    
    @Override
    public RaidType getRaidType()
    {
        return RaidType.COX;
    }
    
    @Override
    public int getRaidRegion()
    {
        return COX_REGION;
    }
    
    @Override
    public boolean isInRaid()
    {
        return inRaid;
    }
    
    @Override
    public void reset()
    {
        inRaid = false;
        chestsHandled = false;
        lightObjectDetected = false;
        log.debug("CoX detector reset");
    }
    
    @Override
    public void setUIUpdateCallback(UIUpdateCallback callback)
    {
        this.uiUpdateCallback = callback;
    }
    
    @Override
    public void updateRaidState(int currentRegion)
    {
        boolean wasInRaid = inRaid;
        inRaid = (currentRegion == COX_REGION);
        
        if (!wasInRaid && inRaid)
        {
            log.debug("Entered CoX raid");
            chestsHandled = false;
            lightObjectDetected = false;
        }
        else if (wasInRaid && !inRaid)
        {
            log.debug("Left CoX raid");
            reset();
        }
    }
    
    @Override
    public boolean handleGameObjectSpawned(GameObjectSpawned event)
    {
        if (!inRaid)
        {
            return false;
        }
        
        int objectId = event.getGameObject().getId();
        
        // Special case: CoX light object detection
        if (objectId == COX_LIGHT_OBJECT_ID)
        {
            log.debug("CoX light object detected: {}", objectId);
            lightObjectDetected = true;
            handleLight();
            return true;
        }
        
        return false;
    }
    
    /**
     * Handle game tick events - check light state if we detected the light object
     */
    public void handleGameTick(GameTick event)
    {
        if (!inRaid || !lightObjectDetected || chestsHandled)
        {
            return;
        }
        
        // Check if the light has become active
        int lightType = client.getVarbitValue(COX_VARBIT_LIGHT_TYPE);
        if (lightType > 0)
        {
            log.debug("*** COX LIGHT BECAME ACTIVE *** lightType={}", lightType);
            handleLight();
        }
    }
    
    /**
     * Handle CoX light object using varbit detection
     */
    private void handleLight()
    {
        if (chestsHandled)
        {
            log.debug("CoX light already handled, ignoring");
            return;
        }
        
        // Check light type using varbit
        int lightType = client.getVarbitValue(COX_VARBIT_LIGHT_TYPE);
        
        log.debug("*** COX LIGHT DETECTED *** lightType={}", lightType);
        
        // Only process if the light indicates actual completion (non-zero lightType)
        // lightType 0 = inactive/no completion, 1+ = actual completion states
        if (lightType == 0)
        {
            log.debug("*** COX LIGHT *** Not active yet (lightType=0), waiting for completion");
            return;
        }
        
        boolean isPurple = (lightType == 2); // 2 = unique drop
        
        log.debug("*** PROCESSING COX COMPLETION *** lightType={}, isPurple={}", lightType, isPurple);
        
        // Always count as raid completion
        dryRateManager.handleRaidCompletion(RaidType.COX);
        
        // Handle unique drops - CoX light doesn't distinguish personal vs team
        // We'll treat all unique drops as personal for now
        if (isPurple)
        {
            log.debug("*** COX UNIQUE DROP *** detected");
            dryRateManager.handleUniqueDropReceived(RaidType.COX);
        }
        else
        {
            log.debug("No CoX purple detected - dry streak will increment");
        }
        
        chestsHandled = true;
        
        // Update UI
        if (uiUpdateCallback != null)
        {
            uiUpdateCallback.updateUI();
        }
    }
} 
package com.dryrate.detectors;

import com.dryrate.RaidType;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.WallObjectSpawned;
import net.runelite.api.events.VarbitChanged;

/**
 * Base interface for raid detection implementations
 * Each raid type should have its own detector that implements this interface
 */
public interface RaidDetector
{
    /**
     * Callback interface for UI updates
     */
    interface UIUpdateCallback
    {
        void updateUI();
    }

    /**
     * Get the raid type this detector handles
     */
    RaidType getRaidType();

    /**
     * Get the region ID for this raid
     */
    int getRaidRegion();

    /**
     * Check if the detector is currently in an active raid state
     */
    boolean isInRaid();

    /**
     * Reset the detector state (called when leaving raids)
     */
    void reset();

    /**
     * Set the UI update callback
     */
    void setUIUpdateCallback(UIUpdateCallback callback);

    /**
     * Handle game object spawned events
     * @return true if the event was handled, false otherwise
     */
    boolean handleGameObjectSpawned(GameObjectSpawned event);

    /**
     * Handle wall object spawned events
     * @return true if the event was handled, false otherwise
     */
    default boolean handleWallObjectSpawned(WallObjectSpawned event)
    {
        return false; // Most raids don't need wall object detection
    }

    /**
     * Handle game tick events for ongoing state management
     */
    default void handleGameTick(GameTick event)
    {
        // Most raids don't need tick handling
    }

    /**
     * Handle varbit changed events
     * @return true if the event was handled, false otherwise
     */
    default boolean handleVarbitChanged(VarbitChanged event)
    {
        return false; // Most raids don't need varbit handling
    }

    /**
     * Update the raid state based on current region
     */
    void updateRaidState(int currentRegion);
} 
package com.dryrate.detectors;

import com.dryrate.DryRateConfig;
import com.dryrate.DryRateManager;
import com.dryrate.RaidType;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameObjectSpawned;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Tombs of Amascut raid detector
 * Handles TOA loot room object detection and raid completion tracking
 */
@Slf4j
@Singleton
public class ToaRaidDetector implements RaidDetector
{
    // TOA loot room region ID
    private static final int TOA_REGION = 14672; // Tombs of Amascut loot room
    
    // TOA object IDs (confirmed from actual raids)
    private static final int TOA_SARCOPHAGUS_PURPLE = 44826;    // Purple sarcophagus (indicates unique) - TBD
    private static final int TOA_SARCOPHAGUS_NON_PURPLE = 46220; // Non-purple sarcophagus (no unique) - CONFIRMED
    private static final int TOA_PLAYER_CHEST = 29994;          // Player's unopened chest - CONFIRMED
    private static final int TOA_VAULT_CHEST_OPEN = 44787;      // Opened vault chest (toa_vault_chest_open) - CONFIRMED
    
    // Complete list of ALL object IDs that can spawn
    private static final List<Integer> TOA_ALL_OBJECT_IDS = Arrays.asList(
        TOA_SARCOPHAGUS_PURPLE,      // 44826 - Purple sarcophagus (TBD)
        TOA_SARCOPHAGUS_NON_PURPLE,  // 46220 - Non-purple sarcophagus (CONFIRMED)
        TOA_PLAYER_CHEST,            // 29994 - Player's unopened chest (CONFIRMED)
        TOA_VAULT_CHEST_OPEN,        // 44787 - Opened vault chest (CONFIRMED)
        44788                        // 44788 - Additional vault chest variant (observed)
    );
    
    // Purple detection IDs for analysis
    private static final List<Integer> TOA_PURPLE_SARCOPHAGUS_IDS = Arrays.asList(
        TOA_SARCOPHAGUS_PURPLE
    );

    @Inject
    private Client client;

    @Inject
    private DryRateManager dryRateManager;

    @Inject
    private DryRateConfig config;

    // State tracking
    private boolean inRaid = false;
    private boolean chestsHandled = false;
    private final List<Integer> loadedObjects = new ArrayList<>();
    private final Set<Integer> seenObjectIds = new HashSet<>();
    
    // UI update callback
    private UIUpdateCallback uiUpdateCallback;

    @Override
    public RaidType getRaidType()
    {
        return RaidType.TOA;
    }

    @Override
    public int getRaidRegion()
    {
        return TOA_REGION;
    }

    @Override
    public boolean isInRaid()
    {
        return inRaid;
    }

    @Override
    public void setUIUpdateCallback(UIUpdateCallback callback)
    {
        this.uiUpdateCallback = callback;
    }

    @Override
    public void updateRaidState(int currentRegion)
    {
        boolean wasInRaid = inRaid;
        inRaid = (currentRegion == TOA_REGION);
        
        // Only log when actually entering/leaving TOA
        if (!wasInRaid && inRaid)
        {
            		log.debug("*** TOA *** ENTERING loot room - region {}", currentRegion);
		chestsHandled = false;
		loadedObjects.clear();
            seenObjectIds.clear();
        }
        else if (wasInRaid && !inRaid)
        {
            		log.debug("*** TOA *** LEAVING loot room - region {}", currentRegion);
		reset();
        }
    }
    
    @Override
    public boolean handleGameObjectSpawned(GameObjectSpawned event)
    {
        if (!inRaid)
        {
            return false;
        }
        
        int objectId = event.getGameObject().getId();
        
        // Check if objectId is in expected object list
        if (TOA_ALL_OBJECT_IDS.contains(objectId))
        {
            log.debug("*** TOA *** Found object: {}", objectId);
            
            // Use the object ID directly for processing
            handleObject(objectId);
            return true;
        }
        
        // Log unknown objects once only (reduced spam)
        if (!seenObjectIds.contains(objectId))
        {
            log.debug("TOA: Unknown object {} (expected: {})", objectId, TOA_ALL_OBJECT_IDS);
            seenObjectIds.add(objectId);
        }
        
        return false;
    }
    
    /**
     * Handle object spawning
     */
    private void handleObject(int objectId)
    {
        log.debug("*** TOA *** Found: {}", objectId);
        
        // Add to loaded objects
        if (!loadedObjects.contains(objectId))
        {
            loadedObjects.add(objectId);
        }
        
        // Process objects when we have a player chest (indicating raid completion)
        boolean hasPlayerChest = loadedObjects.contains(TOA_PLAYER_CHEST);
        
        if (hasPlayerChest && !chestsHandled)
        {
            processObjects();
        }
    }
    
    /**
     * Process objects and handle raid completion
     */
    private void processObjects()
    {
        if (chestsHandled)
        {
            log.debug("*** TOA *** Objects already processed, skipping");
            return;
        }
        
        chestsHandled = true;
        
        log.debug("*** TOA *** PROCESSING OBJECTS: {}", loadedObjects);
        
        // TOA-specific logic: check for purple sarcophagus, player chest, and opened vault
        boolean hasPurpleSarcophagus = loadedObjects.contains(TOA_SARCOPHAGUS_PURPLE);
        boolean hasPlayerChest = loadedObjects.contains(TOA_PLAYER_CHEST);
        boolean hasOpenedVault = loadedObjects.contains(TOA_VAULT_CHEST_OPEN);
        
        log.debug("*** TOA ANALYSIS *** Purple sarcophagus: {}, Player chest: {}, Opened vault: {}", 
            hasPurpleSarcophagus, hasPlayerChest, hasOpenedVault);
        
        // Determine if this is a purple and if it's the player's
        boolean isPurpleDropForPlayer = false;
        boolean isPurpleDropForTeammate = false;
        
        if (hasPurpleSarcophagus)
        {
            if (hasPlayerChest)
            {
                // Purple sarcophagus + player chest present = teammate's purple
                isPurpleDropForTeammate = true;
                log.debug("*** TOA ANALYSIS *** TEAMMATE'S PURPLE detected (purple sarc + player chest)");
            }
            else
            {
                // Purple sarcophagus + no player chest = player's purple
                isPurpleDropForPlayer = true;
                log.debug("*** TOA ANALYSIS *** PLAYER'S PURPLE detected (purple sarc + no player chest)");
            }
        }
        else
        {
            log.debug("*** TOA ANALYSIS *** NO PURPLE detected (no purple sarcophagus)");
        }
        
        // Handle completion and unique drops
        log.debug("*** TOA *** Recording raid completion");
        dryRateManager.handleRaidCompletion(RaidType.TOA);
        
        if (isPurpleDropForPlayer)
        {
            log.debug("*** TOA *** Recording PLAYER'S unique drop");
            dryRateManager.handleUniqueDropReceived(RaidType.TOA);
        }
        else if (isPurpleDropForTeammate)
        {
            // Handle teammate drops based on config
            if (config.teamDropResets())
            {
                log.debug("*** TOA *** Recording teammate's unique drop (team drop reset enabled)");
                dryRateManager.handleUniqueDropReceived(RaidType.TOA);
            }
            else
            {
                log.debug("*** TOA *** Teammate's unique drop ignored (team drop reset disabled)");
            }
        }
        
        // Trigger UI update
        if (uiUpdateCallback != null)
        {
            log.debug("*** TOA *** Triggering UI update");
            uiUpdateCallback.updateUI();
        }
        else
        {
            log.warn("*** TOA *** No UI update callback set!");
        }
    }

    @Override
    public void reset()
    {
        log.debug("*** TOA *** Detector reset");
        inRaid = false;
        chestsHandled = false;
        loadedObjects.clear();
        seenObjectIds.clear();
    }
} 
package com.dryrate.detectors;

import com.dryrate.DryRateConfig;
import com.dryrate.DryRateManager;
import com.dryrate.RaidType;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameObjectSpawned;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Theatre of Blood raid detector
 * Handles TOB loot room chest detection and raid completion tracking
 */
@Slf4j
@Singleton
public class TobRaidDetector implements RaidDetector
{
    // TOB loot room region ID
    private static final int TOB_REGION = 12867; // Theatre of Blood loot room
    
    // TOB chest object IDs
    private static final int TOB_PLAYER_PURPLE = 32993;          // Player's purple chest
    private static final int TOB_PLAYER_CHEST_CLOSED = 32992;    // Player's closed chest  
    private static final int TOB_TEAMMATES_PURPLE = 32991;       // Teammates' purple chests
    private static final int TOB_TEAMMATES_CHEST_CLOSED = 32990; // Teammates' closed chests
    
    // Complete list of ALL chest IDs that can spawn
    private static final List<Integer> TOB_ALL_CHEST_IDS = Arrays.asList(
        // Regular chests that spawn in the room
        33086, 33087, 33088, 33089, 33090,
        // Purple and white chests
        TOB_PLAYER_CHEST_CLOSED,      // 32992 - Player's closed chest
        TOB_TEAMMATES_CHEST_CLOSED,   // 32990 - Teammates' closed chests
        TOB_PLAYER_PURPLE,            // 32993 - Player's purple
        TOB_TEAMMATES_PURPLE          // 32991 - Teammates' purple
    );
    
    // Purple chest IDs for detection
    private static final List<Integer> TOB_PURPLE_CHEST_IDS = Arrays.asList(
        TOB_PLAYER_PURPLE,            // 32993
        TOB_TEAMMATES_PURPLE          // 32991
    );
    
    private final Client client;
    private final DryRateManager dryRateManager;
    private final DryRateConfig config;
    
    // State tracking
    private boolean inRaid = false;
    private boolean chestsHandled = false;
    private List<Integer> loadedChests = new ArrayList<>();
    
    // Track seen object IDs to prevent log spam
    private Set<Integer> seenObjectIds = new HashSet<>();
    
    // UI update callback
    private UIUpdateCallback uiUpdateCallback;
    
    @Inject
    public TobRaidDetector(Client client, DryRateManager dryRateManager, DryRateConfig config)
    {
        this.client = client;
        this.dryRateManager = dryRateManager;
        this.config = config;
    }
    
    @Override
    public RaidType getRaidType()
    {
        return RaidType.TOB;
    }
    
    @Override
    public int getRaidRegion()
    {
        return TOB_REGION;
    }
    
    @Override
    public boolean isInRaid()
    {
        return inRaid;
    }
    
    @Override
    public void reset()
    {
        inRaid = false;
        chestsHandled = false;
        loadedChests.clear();
        seenObjectIds.clear();
        log.debug("TOB detector reset");
    }
    
    @Override
    public void setUIUpdateCallback(UIUpdateCallback callback)
    {
        this.uiUpdateCallback = callback;
    }
    
    @Override
    public void updateRaidState(int currentRegion)
    {
        boolean wasInRaid = inRaid;
        inRaid = (currentRegion == TOB_REGION);
        
        // Only log when actually entering/leaving TOB
        if (!wasInRaid && inRaid)
        {
            			log.debug("*** TOB *** ENTERING loot room - region {}", currentRegion);
            chestsHandled = false;
            loadedChests.clear();
            seenObjectIds.clear();
        }
        else if (wasInRaid && !inRaid)
        {
            			log.debug("*** TOB *** LEAVING loot room - region {}", currentRegion);
            reset();
        }
    }
    
    @Override
    public boolean handleGameObjectSpawned(GameObjectSpawned event)
    {
        if (!inRaid)
        {
            return false;
        }
        
        int objectId = event.getGameObject().getId();
        
        // Check if objectId is in expected chest list
        if (TOB_ALL_CHEST_IDS.contains(objectId))
        {
            		log.debug("*** TOB *** Found chest object: {}", objectId);
            
            // Use the object ID directly for processing
            handleChest(objectId);
            return true;
        }
        
        // Only log non-chest objects at debug level to reduce spam
        if (!seenObjectIds.contains(objectId))
        {
            log.debug("TOB: Object {} not a chest, ignoring", objectId);
            seenObjectIds.add(objectId);
        }
        
        return false;
    }
    
    /**
     * Handle chest spawning
     */
    private void handleChest(int chestId)
    {
        		log.debug("*** TOB *** Processing chest: {}", chestId);
        
        // Add to loaded chests
        if (!loadedChests.contains(chestId))
        {
            loadedChests.add(chestId);
            log.debug("TOB: Added chest {} to loadedChests: {}", chestId, loadedChests);
        }
        
        // Process chests when we have at least one
        if (!loadedChests.isEmpty() && !chestsHandled)
        {
            log.debug("TOB: Triggering chest processing");
            processChests();
        }
    }
    
    /**
     * Process chests and handle raid completion
     */
    private void processChests()
    {
        log.debug("TOB: Processing chests: {}", loadedChests);
        
        if (loadedChests.isEmpty())
        {
            log.warn("TOB: Cannot process chests - loadedChests is empty");
            return;
        }

        // Detect purple chests
        boolean isPurple = loadedChests.stream().anyMatch(TOB_PURPLE_CHEST_IDS::contains);
        
        // Detect if it's a personal purple (player's own purple)
        boolean isPersonal = loadedChests.contains(TOB_PLAYER_PURPLE);

        		log.debug("*** TOB *** Analysis - chests: {}, isPurple: {}, isPersonal: {}",
			loadedChests, isPurple, isPersonal);

        // Always count this as a raid completion
        		log.debug("*** TOB *** Recording raid completion");
        dryRateManager.handleRaidCompletion(RaidType.TOB);

        // Handle unique drops
        if (isPurple)
        {
            if (isPersonal)
            {
                // Personal purple - always reset dry streak
                			log.debug("*** TOB *** PERSONAL purple detected - resetting dry streak");
                dryRateManager.handleUniqueDropReceived(RaidType.TOB);
                processCompletion(true);
            }
            else
            {
                // Team purple - handle based on config
                				log.debug("*** TOB *** TEAM purple detected, teamDropResets: {}", config.teamDropResets());
                if (config.teamDropResets())
                {
                    					log.debug("*** TOB *** Team drops reset enabled - resetting dry streak");
                    dryRateManager.handleTeamUniqueDropReceived(RaidType.TOB);
                    processCompletion(true);
                }
                else
                {
                    					log.debug("*** TOB *** Team drops reset disabled - NOT resetting dry streak");
                    processCompletion(false);
                }
            }
        }
        else
        {
            			log.debug("*** TOB *** No purple detected - dry streak will increment");
            processCompletion(false);
        }
        
        // Always trigger UI update after processing
        processCompletion(isPurple);
    }
    
    /**
     * Process raid completion and trigger UI update
     */
    private void processCompletion(boolean hasUnique)
    {
        log.debug("TOB: Completion processing, hasUnique={}, uiCallback present: {}", 
            hasUnique, (uiUpdateCallback != null));
        
        // Set flag to prevent duplicate processing
        chestsHandled = true;
        
        // Trigger UI update callback
        if (uiUpdateCallback != null)
        {
            		log.debug("*** TOB *** Triggering UI update");
            uiUpdateCallback.updateUI();
        }
        else
        {
            log.warn("TOB: No UI update callback set!");
        }
    }
} 
package com.dryrate;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("dryrate")
public interface DryRateConfig extends Config
{
	@ConfigItem(
		keyName = "showNotifications",
		name = "Show notifications",
		description = "Show notifications when you go dry or get a unique"
	)
	default boolean showNotifications()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackToB",
		name = "Track Theatre of Blood",
		description = "Track dry streaks for Theatre of Blood"
	)
	default boolean trackToB()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackToA",
		name = "Track Tombs of Amascut",
		description = "Track dry streaks for Tombs of Amascut"
	)
	default boolean trackToA()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackCoX",
		name = "Track Chambers of Xeric",
		description = "Track dry streaks for Chambers of Xeric"
	)
	default boolean trackCoX()
	{
		return true;
	}

	@ConfigItem(
		keyName = "resetConfirmation",
		name = "Confirm resets",
		description = "Ask for confirmation before resetting dry streak counters"
	)
	default boolean resetConfirmation()
	{
		return true;
	}

	@ConfigItem(
		keyName = "teamDropResets",
		name = "Team drops reset streaks",
		description = "Reset your dry streak when anyone in your team gets a unique (not just you)",
		position = 4
	)
	default boolean teamDropResets()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showTestButtons",
		name = "Show test buttons",
		description = "Show test buttons for development/testing (Test Completion, Test Unique, etc.)",
		position = 5
	)
	default boolean showTestButtons()
	{
		return false;
	}


} 
package com.dryrate;

import lombok.Data;
import java.util.ArrayList;
import java.util.List;

/**
 * Data class to store dry streak information for a specific raid type
 */
@Data
public class DryRateData
{
    private int currentDryStreak;
    private int totalCompletions;
    private int totalUniques;
    private List<Integer> previousDryStreaks;
    private long lastDropTime;

    public DryRateData()
    {
        this.currentDryStreak = 0;
        this.totalCompletions = 0;
        this.totalUniques = 0;
        this.previousDryStreaks = new ArrayList<>();
        this.lastDropTime = 0;
    }

    // Helper methods for dry streak tracking
    public void incrementDryStreak()
    {
        this.currentDryStreak++;
        this.totalCompletions++;
    }

    public void resetDryStreak()
    {
        // Add to history if we had a streak > 0
        if (currentDryStreak > 0)
        {
            previousDryStreaks.add(currentDryStreak);
        }
        
        // Reset streak to 0 and increment uniques
        this.currentDryStreak = 0;
        this.totalUniques++;
        this.lastDropTime = System.currentTimeMillis();
    }

    public int getLongestDryStreak()
    {
        int longest = currentDryStreak;
        for (int streak : previousDryStreaks)
        {
            if (streak > longest)
            {
                longest = streak;
            }
        }
        return longest;
    }

    public double getAverageDryStreak()
    {
        if (previousDryStreaks.isEmpty())
        {
            return 0.0;
        }
        
        int total = 0;
        for (int streak : previousDryStreaks)
        {
            total += streak;
        }
        return (double) total / previousDryStreaks.size();
    }

    /**
     * Calculate overall average dry streak based on total completions / total uniques
     * This gives you the average number of raids per unique drop
     */
    public double getOverallAverageDryStreak()
    {
        if (totalUniques == 0)
        {
            return 0.0;
        }
        
        return (double) totalCompletions / totalUniques;
    }
} 
package com.dryrate;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.lang.reflect.Type;
import java.util.EnumMap;
import java.util.Map;

/**
 * Manager class that handles all dry rate tracking logic
 */
@Slf4j
@Singleton
public class DryRateManager
{
    private static final String CONFIG_GROUP = "dryrate";
    private static final String DATA_KEY = "data";

    private final DryRateConfig config;
    private final ConfigManager configManager;
    private final Map<RaidType, DryRateData> raidData;
    private final Gson gson;

    @Inject
    public DryRateManager(DryRateConfig config, ConfigManager configManager, Gson gson)
    {
        this.config = config;
        this.configManager = configManager;
        this.raidData = new EnumMap<>(RaidType.class);
        this.gson = gson; // Use injected Gson from RuneLite
        
        // Initialize data for each raid type
        for (RaidType raidType : RaidType.values())
        {
            raidData.put(raidType, new DryRateData());
        }
    }

    /**
     * Load data from configuration
     */
    public void loadData()
    {
        try
        {
            String dataJson = configManager.getConfiguration(CONFIG_GROUP, DATA_KEY);
            log.debug("*** LOADING DATA *** Raw JSON from config: {}", dataJson);
            
            if (dataJson != null && !dataJson.isEmpty())
            {
                // Use String keys to avoid enum serialization issues
                Type type = new TypeToken<Map<String, DryRateData>>(){}.getType();
                Map<String, DryRateData> loadedData = gson.fromJson(dataJson, type);
                
                if (loadedData != null)
                {
                    		log.debug("Dry rate data loaded successfully - {} raid types", loadedData.size());
                    
                    // Convert string keys back to enum keys
                    for (Map.Entry<String, DryRateData> entry : loadedData.entrySet())
                    {
                        try
                        {
                            RaidType raidType = RaidType.valueOf(entry.getKey());
                            DryRateData data = entry.getValue();
                            raidData.put(raidType, data);
                            
                            log.debug("*** {} DATA *** Streak: {}, Completions: {}, Uniques: {}", 
                                raidType, data.getCurrentDryStreak(), data.getTotalCompletions(), data.getTotalUniques());
                        }
                        catch (IllegalArgumentException e)
                        {
                            log.warn("*** LOAD WARNING *** Unknown raid type: {}", entry.getKey());
                        }
                    }
                }
                else
                {
                    log.warn("*** LOAD WARNING *** Parsed data was null");
                }
            }
            else
            {
                		log.debug("No existing dry rate data found, starting fresh");
            }
            log.debug("*** LOAD COMPLETE *** Current raid data state:");
            for (Map.Entry<RaidType, DryRateData> entry : raidData.entrySet())
            {
                DryRateData data = entry.getValue();
                log.debug("*** {} CURRENT *** Streak: {}, Completions: {}, Uniques: {}", 
                    entry.getKey(), data.getCurrentDryStreak(), data.getTotalCompletions(), data.getTotalUniques());
            }
        }
        catch (Exception e)
        {
            log.error("*** LOAD ERROR *** Error loading dry rate data", e);
        }
    }

    /**
     * Save data to configuration
     */
    public void saveData()
    {
        try
        {
            log.debug("*** SAVING DATA *** Current state before save:");
            for (Map.Entry<RaidType, DryRateData> entry : raidData.entrySet())
            {
                DryRateData data = entry.getValue();
                log.debug("*** {} SAVE *** Streak: {}, Completions: {}, Uniques: {}", 
                    entry.getKey(), data.getCurrentDryStreak(), data.getTotalCompletions(), data.getTotalUniques());
            }
            
            // Convert enum keys to strings to avoid serialization issues
            Map<String, DryRateData> stringKeyMap = new java.util.HashMap<>();
            for (Map.Entry<RaidType, DryRateData> entry : raidData.entrySet())
            {
                stringKeyMap.put(entry.getKey().name(), entry.getValue());
            }
            
            String dataJson = gson.toJson(stringKeyMap);
            log.debug("*** SAVING DATA *** JSON to save: {}", dataJson);
            
            configManager.setConfiguration(CONFIG_GROUP, DATA_KEY, dataJson);
            log.debug("*** SAVE COMPLETE *** Data saved successfully to config group: {}, key: {}", CONFIG_GROUP, DATA_KEY);
        }
        catch (Exception e)
        {
            log.error("*** SAVE ERROR *** Error saving dry rate data", e);
        }
    }

    /**
     * Handle a raid completion (increment dry streak and total count)
     */
    public void handleRaidCompletion(RaidType raidType)
    {
        if (!isRaidTrackingEnabled(raidType))
        {
            return;
        }

        DryRateData data = raidData.get(raidType);
        if (data != null)
        {
            // Increment dry streak directly on each completion
            data.incrementDryStreak();
            log.debug("Raid completion for {}: Dry streak now {}, total completions {}", 
                raidType, data.getCurrentDryStreak(), data.getTotalCompletions());
            saveData();
        }
    }

    /**
     * Handle receiving a unique drop (reset dry streak and increment unique count)
     * This is typically called manually when the user confirms they received a unique drop
     */
    public void handleUniqueDropReceived(RaidType raidType)
    {
        if (!isRaidTrackingEnabled(raidType))
        {
            return;
        }

        DryRateData data = raidData.get(raidType);
        if (data != null)
        {
            int previousStreak = data.getCurrentDryStreak();
            
            // Reset dry streak (this handles history and unique count)
            data.resetDryStreak();
            
            log.debug("Unique drop for {}: Reset streak from {}, total uniques now {}", 
                raidType, previousStreak, data.getTotalUniques());
            saveData();
        }
    }

    /**
     * Handle team member receiving unique drop (only reset if config enabled)
     */
    public void handleTeamUniqueDropReceived(RaidType raidType)
    {
        if (!isRaidTrackingEnabled(raidType))
        {
            return;
        }

        // Only reset dry streak if team drops are configured to reset personal streak
        if (config != null && config.teamDropResets())
        {
            DryRateData data = raidData.get(raidType);
            if (data != null)
            {
                int previousStreak = data.getCurrentDryStreak();
                
                // Reset dry streak but don't increment personal unique count
                if (previousStreak > 0)
                {
                    data.getPreviousDryStreaks().add(previousStreak);
                }
                data.setCurrentDryStreak(0);
                
                log.debug("Team unique drop for {}: Reset streak from {} (team drops reset enabled)", 
                    raidType, previousStreak);
                saveData();
            }
        }
        else
        {
            log.debug("Team unique drop for {} ignored (team drops reset disabled)", raidType);
        }
    }

    /**
     * Get dry rate data for a specific raid type
     */
    public DryRateData getRaidData(RaidType raidType)
    {
        return raidData.get(raidType);
    }

    /**
     * Get all raid data
     */
    public Map<RaidType, DryRateData> getAllRaidData()
    {
        return new EnumMap<>(raidData);
    }

    /**
     * Reset dry streak for a specific raid type
     */
    public void resetDryStreak(RaidType raidType)
    {
        DryRateData data = raidData.get(raidType);
        if (data != null)
        {
            data.setCurrentDryStreak(0);
            log.debug("Manually reset dry streak for {}", raidType);
            saveData();
        }
    }

    /**
     * Reset all data for a specific raid type
     */
    public void resetAllData(RaidType raidType)
    {
        raidData.put(raidType, new DryRateData());
        log.debug("Reset all data for {}", raidType);
        saveData();
    }

    /**
     * Test method to manually test save/load functionality
     */
    public void testSaveLoad()
    {
        log.debug("*** TESTING SAVE/LOAD *** Starting test");
        
        // Set some test data
        DryRateData testData = raidData.get(RaidType.TOB);
        testData.incrementDryStreak();
        testData.incrementDryStreak();
        testData.incrementDryStreak();
        
        log.debug("*** TEST *** Set ToB dry streak to: {}", testData.getCurrentDryStreak());
        
        // Save the data
        saveData();
        
        // Clear the data
        raidData.put(RaidType.TOB, new DryRateData());
        log.debug("*** TEST *** Cleared ToB data, streak now: {}", raidData.get(RaidType.TOB).getCurrentDryStreak());
        
        // Load the data back
        loadData();
        
        log.debug("*** TEST *** After reload, ToB streak is: {}", raidData.get(RaidType.TOB).getCurrentDryStreak());
        log.debug("*** TESTING SAVE/LOAD *** Test complete");
    }

    /**
     * Test method to simulate a raid completion without unique
     */
    public void testRaidCompletion(RaidType raidType)
    {
        log.debug("*** TEST COMPLETION *** Simulating {} completion", raidType);
        handleRaidCompletion(raidType);
        
        DryRateData data = raidData.get(raidType);
        log.debug("*** TEST RESULT *** {}: Streak={}, Completions={}, Uniques={}", 
            raidType, data.getCurrentDryStreak(), data.getTotalCompletions(), data.getTotalUniques());
    }

    /**
     * Test method to simulate receiving a unique drop
     * This simulates the complete process: raid completion + unique drop
     */
    public void testUniqueReceived(RaidType raidType)
    {
        log.debug("*** TEST UNIQUE *** Simulating {} completion with unique drop", raidType);
        
        // First handle the raid completion (increments dry streak and completions)
        handleRaidCompletion(raidType);
        
        // Then handle the unique drop (resets dry streak, increments uniques)
        handleUniqueDropReceived(raidType);
        
        DryRateData data = raidData.get(raidType);
        log.debug("*** TEST RESULT *** {}: Streak={}, Completions={}, Uniques={}", 
            raidType, data.getCurrentDryStreak(), data.getTotalCompletions(), data.getTotalUniques());
    }

    /**
     * Test method to simulate multiple completions for testing averages
     */
    public void testMultipleCompletions(RaidType raidType, int completions, int uniques)
    {
        log.debug("*** TEST BULK *** Simulating {} completions with {} uniques for {}", 
            completions, uniques, raidType);
        
        if (uniques > completions)
        {
            log.warn("Cannot have more uniques ({}) than completions ({}), adjusting uniques to {}", 
                uniques, completions, completions);
            uniques = completions;
        }
        
        // Add regular completions (without uniques)
        int regularCompletions = completions - uniques;
        for (int i = 0; i < regularCompletions; i++)
        {
            handleRaidCompletion(raidType);
        }
        
        // Add completions with uniques (each unique counts as both completion + unique)
        for (int i = 0; i < uniques; i++)
        {
            handleRaidCompletion(raidType); // Completion part
            handleUniqueDropReceived(raidType); // Unique part
        }
        
        DryRateData data = raidData.get(raidType);
        log.debug("*** TEST RESULT *** {}: Streak={}, Completions={}, Uniques={}, AvgDry={:.1f}", 
            raidType, data.getCurrentDryStreak(), data.getTotalCompletions(), 
            data.getTotalUniques(), data.getOverallAverageDryStreak());
    }

    /**
     * Check if tracking is enabled for a specific raid type
     */
    private boolean isRaidTrackingEnabled(RaidType raidType)
    {
        if (config == null)
        {
            return true; // Default to enabled if config is not available
        }

        switch (raidType)
        {
            case TOB:
                return config.trackToB();
            case TOA:
                return config.trackToA();
            case COX:
                return config.trackCoX();
            default:
                return true;
        }
    }
} 
package com.dryrate;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.text.DecimalFormat;
import java.util.Map;

/**
 * Panel that displays dry streak information for all raids
 */
@Slf4j
public class DryRatePanel extends PluginPanel
{
    private final DryRateManager dryRateManager;
    private final DryRateConfig config;
    private final DecimalFormat decimalFormat;
    
    // UI Components
    private JPanel mainPanel;
    private Map<RaidType, JPanel> raidPanels;

    public DryRatePanel(DryRateManager dryRateManager, DryRateConfig config)
    {
        this.dryRateManager = dryRateManager;
        this.config = config;
        this.decimalFormat = new DecimalFormat("#.#");
        
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());
        
        log.debug("Initializing panel");
        initializeComponents();
        updateDisplay();
        log.debug("Panel initialization complete");
    }

    private void initializeComponents()
    {
        // Main panel with vertical layout
        mainPanel = new JPanel();
        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
        mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        mainPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

        // Main title
        JLabel titleLabel = new JLabel("Dry Rate Tracker");
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setFont(new Font("SansSerif", Font.BOLD, 18));
        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        mainPanel.add(titleLabel);
        
        mainPanel.add(Box.createVerticalStrut(12));

        // Create panels for each raid type
        for (RaidType raidType : RaidType.values())
        {
            JPanel raidPanel = createRaidPanel(raidType);
            mainPanel.add(raidPanel);
            mainPanel.add(Box.createVerticalStrut(8));
        }

        // Scroll pane to handle overflow
        JScrollPane scrollPane = new JScrollPane(mainPanel);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setBorder(null);
        scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(8, 0));
        scrollPane.getVerticalScrollBar().setUnitIncrement(16); // Smoother scrolling
        
        // Let the main panel size itself naturally for proper scrolling
        mainPanel.setPreferredSize(null);
        
        add(scrollPane, BorderLayout.CENTER);
    }

    private JPanel createRaidPanel(RaidType raidType)
    {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(BorderFactory.createCompoundBorder(
            BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),
            new EmptyBorder(8, 8, 8, 8)
        ));

        // Raid title
        JLabel titleLabel = new JLabel(raidType.getShortName());
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 14f));
        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(titleLabel);

        panel.add(Box.createVerticalStrut(5));

        // Current dry streak
        JLabel dryStreakLabel = new JLabel();
        dryStreakLabel.setForeground(Color.WHITE);
        dryStreakLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(dryStreakLabel);

        // Statistics
        JLabel statsLabel = new JLabel();
        statsLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        statsLabel.setFont(statsLabel.getFont().deriveFont(11f));
        statsLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(statsLabel);

        // Reset button
        JButton resetButton = new JButton("Reset");
        resetButton.setPreferredSize(new Dimension(80, 25));
        resetButton.setMaximumSize(new Dimension(80, 25));
        resetButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        resetButton.addActionListener(new ActionListener()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                int result = JOptionPane.showConfirmDialog(
                    DryRatePanel.this,
                    "Reset dry streak for " + raidType.getShortName() + "?",
                    "Confirm Reset",
                    JOptionPane.YES_NO_OPTION
                );
                
                if (result == JOptionPane.YES_OPTION)
                {
                    dryRateManager.resetDryStreak(raidType);
                    updateDisplay();
                }
            }
        });
        
        panel.add(Box.createVerticalStrut(5));
        panel.add(resetButton);

        return panel;
    }

    public void updateDisplay()
    {
        SwingUtilities.invokeLater(() -> {
            // Remove all components and rebuild
            mainPanel.removeAll();
            
            // Main title
            JLabel titleLabel = new JLabel("Dry Rate Tracker");
            titleLabel.setForeground(Color.WHITE);
            titleLabel.setFont(new Font("SansSerif", Font.BOLD, 18));
            titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
            mainPanel.add(titleLabel);
            
            mainPanel.add(Box.createVerticalStrut(12));

            // Re-add raid panels with updated data
            for (RaidType raidType : RaidType.values())
            {
                JPanel raidPanel = createUpdatedRaidPanel(raidType);
                mainPanel.add(raidPanel);
                mainPanel.add(Box.createVerticalStrut(8));
            }

            mainPanel.revalidate();
            mainPanel.repaint();
        });
    }

    /**
     * Force refresh the display (useful for testing config changes)
     */
    public void forceRefresh()
    {
        log.debug("Force refreshing panel display");
        updateDisplay();
    }

    private JPanel createUpdatedRaidPanel(RaidType raidType)
    {
        DryRateData data = dryRateManager.getRaidData(raidType);
        
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        
        // Much simpler background colors
        Color bgColor = ColorScheme.DARKER_GRAY_COLOR;
        
        panel.setBackground(bgColor);
        panel.setBorder(BorderFactory.createCompoundBorder(
            BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
            new EmptyBorder(8, 10, 8, 10)
        ));

        // Raid title
        String titleText = raidType.getShortName();
        JLabel titleLabel = new JLabel(titleText);
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setFont(new Font("SansSerif", Font.BOLD, 16));
        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(titleLabel);

        panel.add(Box.createVerticalStrut(6));

        // Dry streak display
        String streakText = data.getCurrentDryStreak() == 0 ? "âœ… No dry streak!" : 
                           "Current dry: " + data.getCurrentDryStreak();
        JLabel dryStreakLabel = new JLabel(streakText);
        
        Color streakColor = data.getCurrentDryStreak() == 0 ? 
            new Color(100, 200, 100) : new Color(255, 200, 100);
        
        dryStreakLabel.setForeground(streakColor);
        dryStreakLabel.setFont(new Font("SansSerif", Font.BOLD, 14));
        dryStreakLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(dryStreakLabel);

        panel.add(Box.createVerticalStrut(6));

        // Statistics on three lines
        JLabel stats1Label = new JLabel("Completions: " + data.getTotalCompletions() + " | Uniques: " + data.getTotalUniques());
        stats1Label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        stats1Label.setFont(new Font("SansSerif", Font.PLAIN, 12));
        stats1Label.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(stats1Label);
        
        JLabel stats2Label = new JLabel("Longest dry: " + data.getLongestDryStreak());
        stats2Label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        stats2Label.setFont(new Font("SansSerif", Font.PLAIN, 12));
        stats2Label.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(stats2Label);
        
        // Average dry streak
        double avgDry = data.getOverallAverageDryStreak();
        String avgText = avgDry == 0.0 ? "Average dry: N/A" : 
                        String.format("Average dry: %.1f", avgDry);
        JLabel stats3Label = new JLabel(avgText);
        stats3Label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        stats3Label.setFont(new Font("SansSerif", Font.PLAIN, 12));
        stats3Label.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(stats3Label);

        panel.add(Box.createVerticalStrut(6));

        // Reset buttons panel
        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.Y_AXIS));
        buttonPanel.setBackground(bgColor);
        
        // Manual Reset button (resets dry streak only)
        JButton resetButton = new JButton("Manual Reset");
        resetButton.setPreferredSize(new Dimension(130, 24));
        resetButton.setMaximumSize(new Dimension(130, 24));
        resetButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        resetButton.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
        resetButton.setForeground(Color.WHITE);
        resetButton.setFocusPainted(false);
        resetButton.setFont(new Font("SansSerif", Font.PLAIN, 11));
        
        resetButton.addActionListener(new ActionListener()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                int result = JOptionPane.showConfirmDialog(
                    DryRatePanel.this,
                    "Manually reset dry streak for " + raidType.getShortName() + "?",
                    "Confirm Reset",
                    JOptionPane.YES_NO_OPTION
                );
                
                if (result == JOptionPane.YES_OPTION)
                {
                    dryRateManager.resetDryStreak(raidType);
                    updateDisplay();
                }
            }
        });
        
        // Full Reset button (resets everything)
        JButton fullResetButton = new JButton("Full Reset");
        fullResetButton.setPreferredSize(new Dimension(130, 24));
        fullResetButton.setMaximumSize(new Dimension(130, 24));
        fullResetButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        fullResetButton.setBackground(new Color(180, 50, 50)); // Red background for destructive action
        fullResetButton.setForeground(Color.WHITE);
        fullResetButton.setFocusPainted(false);
        fullResetButton.setFont(new Font("SansSerif", Font.BOLD, 11));
        
        fullResetButton.addActionListener(new ActionListener()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                int result = JOptionPane.showConfirmDialog(
                    DryRatePanel.this,
                    "Reset ALL data for " + raidType.getShortName() + "?\n" +
                    "This will reset:\n" +
                    "â€¢ Current dry streak\n" +
                    "â€¢ Total completions\n" +
                    "â€¢ Total uniques\n" +
                    "â€¢ Longest dry streak\n\n" +
                    "This action cannot be undone!",
                    "Confirm Full Reset",
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.WARNING_MESSAGE
                );
                
                if (result == JOptionPane.YES_OPTION)
                {
                    dryRateManager.resetAllData(raidType);
                    updateDisplay();
                }
            }
        });
        
        buttonPanel.add(resetButton);
        buttonPanel.add(Box.createVerticalStrut(3));
        buttonPanel.add(fullResetButton);
        
        panel.add(buttonPanel);
        
        // Test buttons panel (for development/testing) - only show if config enabled
        if (config != null && config.showTestButtons())
        {
            JPanel testPanel = new JPanel();
            testPanel.setLayout(new BoxLayout(testPanel, BoxLayout.Y_AXIS));
            testPanel.setBackground(bgColor);
        
        // Test completion button
        JButton testCompletionButton = new JButton("Test Completion");
        testCompletionButton.setPreferredSize(new Dimension(130, 20));
        testCompletionButton.setMaximumSize(new Dimension(130, 20));
        testCompletionButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        testCompletionButton.setBackground(new Color(50, 150, 50)); // Green
        testCompletionButton.setForeground(Color.WHITE);
        testCompletionButton.setFocusPainted(false);
        testCompletionButton.setFont(new Font("SansSerif", Font.PLAIN, 10));
        
        testCompletionButton.addActionListener(e -> {
            dryRateManager.testRaidCompletion(raidType);
            updateDisplay();
        });
        
        // Test unique button
        JButton testUniqueButton = new JButton("Test Unique");
        testUniqueButton.setPreferredSize(new Dimension(130, 20));
        testUniqueButton.setMaximumSize(new Dimension(130, 20));
        testUniqueButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        testUniqueButton.setBackground(new Color(150, 50, 150)); // Purple
        testUniqueButton.setForeground(Color.WHITE);
        testUniqueButton.setFocusPainted(false);
        testUniqueButton.setFont(new Font("SansSerif", Font.PLAIN, 10));
        
        testUniqueButton.addActionListener(e -> {
            dryRateManager.testUniqueReceived(raidType);
            updateDisplay();
        });
        
        // Test bulk button
        JButton testBulkButton = new JButton("Test 50+5");
        testBulkButton.setPreferredSize(new Dimension(130, 20));
        testBulkButton.setMaximumSize(new Dimension(130, 20));
        testBulkButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        testBulkButton.setBackground(new Color(50, 100, 150)); // Blue
        testBulkButton.setForeground(Color.WHITE);
        testBulkButton.setFocusPainted(false);
        testBulkButton.setFont(new Font("SansSerif", Font.PLAIN, 10));
        
        testBulkButton.addActionListener(e -> {
            dryRateManager.testMultipleCompletions(raidType, 50, 5);
            updateDisplay();
        });
        
            testPanel.add(Box.createVerticalStrut(3));
            testPanel.add(testCompletionButton);
            testPanel.add(Box.createVerticalStrut(2));
            testPanel.add(testUniqueButton);
            testPanel.add(Box.createVerticalStrut(2));
            testPanel.add(testBulkButton);
            
            panel.add(testPanel);
        }

        return panel;
    }
} 
package com.dryrate;

import com.dryrate.detectors.RaidDetector;
import com.dryrate.detectors.TobRaidDetector;
import com.dryrate.detectors.ToaRaidDetector;
import com.dryrate.detectors.CoxRaidDetector;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;

import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.coords.LocalPoint;

import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WallObjectSpawned;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;

import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@PluginDescriptor(
	name = "Dry Rate Tracker",
	description = "Automatically track dry streaks and unique drops for OSRS raids (ToB, ToA, CoX)",
	tags = {"raids", "tracking", "statistics", "purple", "unique"}
)
public class DryRatePlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private DryRateConfig config;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ConfigManager configManager;

	@Inject
	private DryRateManager dryRateManager;

	// Raid detectors
	@Inject
	private TobRaidDetector tobDetector;
	
	@Inject
	private ToaRaidDetector toaDetector;
	
	@Inject
	private CoxRaidDetector coxDetector;

	private DryRatePanel panel;
	private NavigationButton navButton;

	// Track current state
	private int previousRegionId = -1;
	private RaidDetector currentDetector = null;
	
	// Map regions to detectors for quick lookup
	private Map<Integer, RaidDetector> regionToDetector;

	@Override
	protected void startUp() throws Exception
	{
		log.debug("Dry Rate Tracker started!");
		
		// Initialize the dry rate manager
		dryRateManager.loadData();
		
		// Create the panel
		panel = new DryRatePanel(dryRateManager, config);
		log.debug("Panel created successfully");
		
		// Create a towel icon (perfect for "dry" tracker!)
		BufferedImage icon = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
		java.awt.Graphics2D g2d = icon.createGraphics();
		g2d.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING, java.awt.RenderingHints.VALUE_ANTIALIAS_ON);
		
		// Draw towel main body (light blue/white towel)
		g2d.setColor(new java.awt.Color(200, 220, 255)); // Light blue towel
		g2d.fillRect(3, 2, 10, 12);
		
		// Add towel texture lines (horizontal stripes)
		g2d.setColor(new java.awt.Color(180, 200, 240)); // Slightly darker blue
		g2d.drawLine(4, 4, 11, 4);   // Top stripe
		g2d.drawLine(4, 6, 11, 6);   // Second stripe
		g2d.drawLine(4, 8, 11, 8);   // Third stripe
		g2d.drawLine(4, 10, 11, 10); // Fourth stripe
		g2d.drawLine(4, 12, 11, 12); // Bottom stripe
		
		// Add towel edges/border for definition
		g2d.setColor(new java.awt.Color(150, 170, 200)); // Darker border
		g2d.drawRect(3, 2, 10, 12);
		
		// Add a small "hanging" effect at the top
		g2d.setColor(new java.awt.Color(100, 100, 100)); // Dark gray hook/hanger
		g2d.fillRect(7, 0, 2, 3);
		
		g2d.dispose();
		
		navButton = NavigationButton.builder()
			.tooltip("Dry Rate Tracker")
			.icon(icon)
			.priority(5)
			.panel(panel)
			.build();
		
		clientToolbar.addNavigation(navButton);
		log.debug("Navigation button added to toolbar");
		
		// Initialize region-to-detector mapping
		initializeDetectorMapping();
		
		// Set up UI update callbacks for all detectors
		setupUICallbacks();
		
		// Initialize region tracking
		if (client.getLocalPlayer() != null)
		{
			previousRegionId = getCurrentRegionId();
			updateRaidState();
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.debug("Dry Rate Tracker stopped!");
		
		// Save data before shutting down
		dryRateManager.saveData();
		
		// Remove the panel
		clientToolbar.removeNavigation(navButton);
		
		// Reset all detectors
		if (regionToDetector != null)
		{
			for (RaidDetector detector : regionToDetector.values())
			{
				detector.reset();
			}
		}
		
		// Reset tracking state
		currentDetector = null;
		previousRegionId = -1;
	}

	/**
	 * Initialize the mapping between regions and their corresponding detectors
	 */
	private void initializeDetectorMapping()
	{
		regionToDetector = new HashMap<>();
		regionToDetector.put(tobDetector.getRaidRegion(), tobDetector);
		regionToDetector.put(toaDetector.getRaidRegion(), toaDetector);
		regionToDetector.put(coxDetector.getRaidRegion(), coxDetector);
		
				log.debug("*** DETECTOR MAPPING *** Initialized: ToB={}, ToA={}, CoX={}",
			tobDetector.getRaidRegion(), toaDetector.getRaidRegion(), coxDetector.getRaidRegion());
	}

	/**
	 * Set up UI update callbacks for all detectors
	 */
	private void setupUICallbacks()
	{
		RaidDetector.UIUpdateCallback updateCallback = () -> {
			log.debug("*** UI CALLBACK *** Received UI update request, calling panel.updateDisplay()");
			if (panel != null)
			{
				panel.updateDisplay();
				log.debug("*** UI CALLBACK *** panel.updateDisplay() completed successfully");
			}
			else
			{
				log.error("*** UI CALLBACK *** Panel is NULL - cannot update display!");
			}
		};
		
		tobDetector.setUIUpdateCallback(updateCallback);
		toaDetector.setUIUpdateCallback(updateCallback);
		coxDetector.setUIUpdateCallback(updateCallback);
		
		log.debug("*** UI SETUP *** UI update callbacks configured for all detectors");
		log.debug("*** UI SETUP *** ToB detector: region={}, class={}", 
			tobDetector.getRaidRegion(), tobDetector.getClass().getSimpleName());
		log.debug("*** UI SETUP *** ToA detector: region={}, class={}", 
			toaDetector.getRaidRegion(), toaDetector.getClass().getSimpleName());
		log.debug("*** UI SETUP *** CoX detector: region={}, class={}", 
			coxDetector.getRaidRegion(), coxDetector.getClass().getSimpleName());
	}

	/**
	 * Route game object spawned events to the appropriate detector
	 */
	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		// Ensure raid state is up to date before processing objects
		updateRaidState();
		
		// Additional safety check: ensure detector is set for current region
		int currentRegion = getCurrentRegionId();
		if (currentDetector == null && regionToDetector.containsKey(currentRegion))
		{
			currentDetector = regionToDetector.get(currentRegion);
			log.debug("*** SAFETY FIX *** Set detector for region {} to {}", 
				currentRegion, currentDetector.getRaidType());
		}
		
		int objectId = event.getGameObject().getId();
		
		// Only log important objects in raid regions
		if ((currentRegion == 12867 || currentRegion == 14672) && currentDetector != null)
		{
			// Only log if it's a potential chest/important object (reduce spam)
			if (objectId >= 33086 && objectId <= 33090 || // TOB chests
				objectId >= 44786 && objectId <= 44787 || // TOA chests  
				objectId == 44825 || objectId == 44826)   // TOA sarcophagi
			{
				log.debug("*** {} CHEST *** Object: {}", currentDetector.getRaidType(), objectId);
			}
		}
		
		// Route to current detector if available
		if (currentDetector != null)
		{
			currentDetector.handleGameObjectSpawned(event);
		}
		else if (currentRegion == 12867 || currentRegion == 14672 || currentRegion == 12889)
		{
			// Only log once when entering raid region without detector
			log.warn("*** ERROR *** No detector for raid region: {}", currentRegion);
		}
	}

	/**
	 * Route wall object spawned events to the appropriate detector
	 */
	@Subscribe
	public void onWallObjectSpawned(WallObjectSpawned event)
	{
		if (currentDetector != null)
		{
			currentDetector.handleWallObjectSpawned(event);
		}
	}

	/**
	 * Route game tick events to the appropriate detector and update raid state
	 */
	@Subscribe(priority = 7)  // HIGH PRIORITY 
	public void onGameTick(GameTick event)
	{
		updateRaidState();
		
		if (currentDetector != null)
		{
			currentDetector.handleGameTick(event);
		}
	}

	/**
	 * Route varbit changed events to the appropriate detector
	 */
	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		if (currentDetector != null)
		{
			currentDetector.handleVarbitChanged(event);
		}
	}

	/**
	 * Handle config changes by refreshing the panel
	 */
	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals("dryrate"))
		{
			log.debug("Config changed: {} = {}", event.getKey(), event.getNewValue());
			// Refresh the panel to reflect config changes
			if (panel != null)
			{
				panel.forceRefresh();
			}
		}
	}

	/**
	 * Handle game state changes to reset when logging out
	 */
	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGIN_SCREEN)
		{
			log.debug("Player logged out, resetting state");
			if (currentDetector != null)
			{
				currentDetector.reset();
			}
			currentDetector = null;
			previousRegionId = -1;
		}
	}

	/**
	 * Get the current region ID from the player's location
	 */
	private int getCurrentRegionId()
	{
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null)
		{
			return -1;
		}

		LocalPoint localPoint = localPlayer.getLocalLocation();
		if (localPoint == null)
		{
			return -1;
		}

		WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, localPoint);
		if (worldPoint == null)
		{
			return -1;
		}

		int regionId = worldPoint.getRegionID();
		
		// Only log when entering raid regions (not every tick)
		if ((regionId == 12867 || regionId == 14672 || regionId == 12889) && 
			regionId != previousRegionId)
		{
			String raidName = (regionId == 12867) ? "TOB" : (regionId == 14672) ? "TOA" : "COX";
		log.debug("*** ENTERED {} REGION ***", raidName);
		}

		return regionId;
	}

	/**
	 * Update raid state based on current region and manage detector transitions
	 */
	private void updateRaidState()
	{
		int currentRegionId = getCurrentRegionId();
		
		if (currentRegionId == previousRegionId)
		{
			return; // No region change
		}
		
		// Check if we're entering a new raid region
		RaidDetector newDetector = regionToDetector.get(currentRegionId);
		
		// Handle detector transitions
		if (newDetector != currentDetector)
		{
			// Reset previous detector if we had one
			if (currentDetector != null)
			{
				log.debug("*** LEAVING {} ***", currentDetector.getRaidType());
				currentDetector.reset();
			}
			
			// Set new detector
			currentDetector = newDetector;
			
			if (currentDetector != null)
			{
				log.debug("*** ENTERING {} ***", currentDetector.getRaidType());
			}
		}
		
		// Update all detectors with current region
		for (RaidDetector detector : regionToDetector.values())
		{
			detector.updateRaidState(currentRegionId);
		}
		
		previousRegionId = currentRegionId;
	}

	@Provides
	DryRateConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(DryRateConfig.class);
	}
} 

package com.dryrate;

/**
 * Enum representing the different raid types we track
 */
public enum RaidType
{
    TOB("Theatre of Blood", "ToB"),
    TOA("Tombs of Amascut", "ToA"),
    COX("Chambers of Xeric", "CoX");

    private final String fullName;
    private final String shortName;

    RaidType(String fullName, String shortName)
    {
        this.fullName = fullName;
        this.shortName = shortName;
    }

    public String getFullName()
    {
        return fullName;
    }

    public String getShortName()
    {
        return shortName;
    }

    @Override
    public String toString()
    {
        return shortName;
    }
} 
package com.dryrate;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class DryRatePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DryRatePlugin.class);
		RuneLite.main(args);
	}
} 
