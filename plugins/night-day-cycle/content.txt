/*
 * Copyright (c) 2019 logarrhytmic <https://github.com/logarrhythmic>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.example;

import com.google.inject.Inject;
import com.google.inject.Provides;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.BeforeRender;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import java.awt.Color;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.ZonedDateTime;

@PluginDescriptor(
	name = "Day-Night Cycle",
	description = "Day/Night Cycle in OldSchool Runescape",
	enabledByDefault = true,
	tags = {"night", "skybox", "daynight", "overlay", "time", "sun", "sunrise", "sunset"},
	conflicts = {"Skybox"}
)
public class DayNightCyclePlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private DayNightCycleConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private DayNightCycleOverlay timeOverlay;

	private ZonedDateTime customHourStartTime = null;
	private long realMillisAtCustomStart = 0;

	@Provides
	DayNightCycleConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(DayNightCycleConfig.class);
	}

	@Provides
	DayNightCycleOverlay provideTimeOverlay()
	{
		return new DayNightCycleOverlay(this);
	}

	@Override
	protected void startUp()
	{
		overlayManager.remove(timeOverlay);
		if (config.showOverlay())
		{
			overlayManager.add(timeOverlay);
		}
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(timeOverlay);
		client.setSkyboxColor(0);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN)
		{
			client.setSkyboxColor(0);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals("dayNightCycle"))
		{
			return;
		}

		if (event.getKey().equals("showOverlay"))
		{
			overlayManager.remove(timeOverlay);
			if (config.showOverlay())
			{
				overlayManager.add(timeOverlay);
			}
		}

		if (event.getKey().equals("customHour") || event.getKey().equals("useCustomHour"))
		{
			if (config.useCustomHour())
			{
				setCustomHour(config.customHour());
			}
			else
			{
				customHourStartTime = null;
			}
		}
	}

	@Subscribe
	public void onBeforeRender(BeforeRender event)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		double latitude, longitude;
		ZoneId zone;

		if (config.useCustomCoordinates())
		{
			latitude = config.customLatitude();
			longitude = config.customLongitude();
			int offsetHours = (int) Math.round(longitude / 15.0);
			zone = ZoneId.ofOffset("UTC", java.time.ZoneOffset.ofHours(offsetHours));
		}
		else
		{
			DayNightCycleConfig.City city = config.getCity();
			latitude = city.getLatitude();
			longitude = city.getLongitude();
			zone = ZoneId.of(city.getTimezone());
		}

		LocalDate today = LocalDate.now(zone);

		ZonedDateTime sunrise = SunCalculator.calculateSunrise(today.getYear(), today.getMonthValue(), today.getDayOfMonth(),
			latitude, longitude, zone);
		ZonedDateTime sunset = SunCalculator.calculateSunset(today.getYear(), today.getMonthValue(), today.getDayOfMonth(),
			latitude, longitude, zone);

		ZonedDateTime sunriseStart = sunrise.minusMinutes(30);
		ZonedDateTime sunsetStart = sunset.minusMinutes(30);

		ZonedDateTime virtualTime = getVirtualTime();
		long nowSec = virtualTime.toEpochSecond();

		long sunriseStartSec = sunriseStart.toEpochSecond();
		long sunriseEndSec = sunrise.toEpochSecond();
		long sunsetStartSec = sunsetStart.toEpochSecond();
		long sunsetEndSec = sunset.toEpochSecond();

		Color skyColor;

		if (nowSec < sunriseStartSec)
		{
			skyColor = config.getNightColor();
		}
		else if (nowSec < sunriseEndSec)
		{
			float progress = (float) (nowSec - sunriseStartSec) / (sunriseEndSec - sunriseStartSec);

			if (progress < 0.7f)
			{
				float curveProgress = (float) Math.sin(progress / 0.7 * (Math.PI / 2));
				skyColor = interpolateColor(config.getNightColor(), config.getSunriseColor(), curveProgress);
			}
			else
			{

				float curveProgress = (float) Math.sin((progress - 0.7f) / 0.3 * (Math.PI / 2));
				skyColor = interpolateColor(config.getSunriseColor(), config.getDayColor(), curveProgress);
			}
		}
		else if (nowSec < sunsetStartSec)
		{
			skyColor = config.getDayColor();
		}
		else if (nowSec < sunsetEndSec)
		{
			float progress = (float) (nowSec - sunsetStartSec) / (sunsetEndSec - sunsetStartSec);

			if (progress < 0.7f)
			{
				float curveProgress = (float) Math.sin(progress / 0.7 * (Math.PI / 2));
				skyColor = interpolateColor(config.getDayColor(), config.getSunsetColor(), curveProgress);
			}
			else
			{
				float curveProgress = (float) Math.sin((progress - 0.7f) / 0.3 * (Math.PI / 2));
				skyColor = interpolateColor(config.getSunsetColor(), config.getNightColor(), curveProgress);
			}
		}
		else
		{
			skyColor = config.getNightColor();
		}

		client.setSkyboxColor(skyColor.getRGB());
	}


	private Color interpolateColor(Color start, Color end, float t)
	{
		int r = (int) (start.getRed() * (1 - t) + end.getRed() * t);
		int g = (int) (start.getGreen() * (1 - t) + end.getGreen() * t);
		int b = (int) (start.getBlue() * (1 - t) + end.getBlue() * t);
		return new Color(r, g, b);
	}

	// Custom Hour
	public void setCustomHour(String timeStr)
	{
		ZoneId zone;
		if (config.useCustomCoordinates())
		{
			int offsetHours = (int) Math.round(config.customLongitude() / 15.0);
			zone = ZoneId.ofOffset("UTC", java.time.ZoneOffset.ofHours(offsetHours));
		}
		else
		{
			zone = ZoneId.of(config.getCity().getTimezone());
		}

		String[] parts = timeStr.split(":");
		int h = parts.length > 0 ? Integer.parseInt(parts[0]) : 0;
		int m = parts.length > 1 ? Integer.parseInt(parts[1]) : 0;
		int s = parts.length > 2 ? Integer.parseInt(parts[2]) : 0;

		customHourStartTime = ZonedDateTime.now(zone)
			.withHour(h).withMinute(m).withSecond(s).withNano(0);

		realMillisAtCustomStart = System.currentTimeMillis();
	}

	public ZonedDateTime getVirtualTime()
	{
		ZoneId zone;
		if (config.useCustomCoordinates())
		{
			int offsetHours = (int) Math.round(config.customLongitude() / 15.0);
			zone = ZoneId.ofOffset("UTC", java.time.ZoneOffset.ofHours(offsetHours));
		}
		else
		{
			zone = ZoneId.of(config.getCity().getTimezone());
		}

		if (config.useCustomHour() && customHourStartTime != null)
		{

			long elapsedMillis = System.currentTimeMillis() - realMillisAtCustomStart;


			double cycleSeconds = config.cycleDuration();
			double factor = 24 * 60 * 60 / cycleSeconds;

			long virtualMillis = (long) (elapsedMillis * factor);
			return customHourStartTime.plusNanos(virtualMillis * 1_000_000L).withZoneSameInstant(zone);
		}

		if (config.useRealTimeCycle())
		{
			return ZonedDateTime.now(zone);
		}

		// rapid test
		long millis = System.currentTimeMillis();
		float t = (millis % (config.cycleDuration() * 1000L)) / (float) (config.cycleDuration() * 1000L);
		int totalSeconds = (int) (t * 24 * 60 * 60);
		int hour = totalSeconds / 3600;
		int minute = (totalSeconds % 3600) / 60;
		int second = totalSeconds % 60;

		return ZonedDateTime.now(zone).withHour(hour).withMinute(minute).withSecond(second).withNano(0);
	}

}

// https://web.archive.org/web/20161202180207/http://williams.best.vwh.net/sunrise_sunset_algorithm.htm
class SunCalculator
{
	private static final double ZENITH = 90.833; // Zenith oficial

	public static ZonedDateTime calculateSunrise(int year, int month, int day, double latitude, double longitude, ZoneId zone)
	{
		return calculateSolarEvent(year, month, day, latitude, longitude, zone, true);
	}

	public static ZonedDateTime calculateSunset(int year, int month, int day, double latitude, double longitude, ZoneId zone)
	{
		return calculateSolarEvent(year, month, day, latitude, longitude, zone, false);
	}

	private static ZonedDateTime calculateSolarEvent(int year, int month, int day, double latitude, double longitude, ZoneId zone, boolean sunrise)
	{
		// 1. day of the year
		int N1 = (int) Math.floor(275 * month / 9.0);
		int N2 = (int) Math.floor((month + 9) / 12.0);
		int N3 = 1 + (int) Math.floor((year - 4 * Math.floor(year / 4.0) + 2) / 3.0);
		int N = N1 - (N2 * N3) + day - 30;

		// 2. Longitude to hour
		double lngHour = longitude / 15.0;
		double t = sunrise ? N + ((6 - lngHour) / 24.0) : N + ((18 - lngHour) / 24.0);

		// 3. Sun Anomaly
		double M = (0.9856 * t) - 3.289;

		// 4. Sun real Longitude
		double L = M + (1.916 * Math.sin(Math.toRadians(M))) + (0.020 * Math.sin(Math.toRadians(2 * M))) + 282.634;
		L = normalizeAngle(L);

		// 5a. Straight Ascension
		double RA = Math.toDegrees(Math.atan(0.91764 * Math.tan(Math.toRadians(L))));
		RA = normalizeAngle(RA);

		// 5b. RA in L quadrant
		double Lquadrant = Math.floor(L / 90.0) * 90;
		double RAquadrant = Math.floor(RA / 90.0) * 90;
		RA = RA + (Lquadrant - RAquadrant);

		// 5c. RA in Hours
		RA = RA / 15.0;

		// 6. Sun Declination
		double sinDec = 0.39782 * Math.sin(Math.toRadians(L));
		double cosDec = Math.cos(Math.asin(sinDec));

		// 7a. hourly local angle
		double cosH = (Math.cos(Math.toRadians(ZENITH)) - (sinDec * Math.sin(Math.toRadians(latitude)))) /
			(cosDec * Math.cos(Math.toRadians(latitude)));

		if (cosH > 1)
		{
			return null;
		}
		if (cosH < -1)
		{
			return null;
		}

		// 7b. H in hours
		double H = sunrise ? 360 - Math.toDegrees(Math.acos(cosH)) : Math.toDegrees(Math.acos(cosH));
		H = H / 15.0;

		// 8. Medium time of event
		double T = H + RA - (0.06571 * t) - 6.622;

		// 9. UTC Adjustment
		double UT = T - lngHour;
		UT = normalizeTime(UT);

		// 10. adjustment to local timezone
		int offsetSeconds = zone.getRules().getOffset(java.time.Instant.now()).getTotalSeconds();
		double localT = UT + offsetSeconds / 3600.0;
		localT = normalizeTime(localT);

		int hour = (int) localT;
		int minute = (int) ((localT - hour) * 60);
		int second = (int) (((localT - hour) * 60 - minute) * 60);

		return ZonedDateTime.of(year, month, day, hour, minute, second, 0, zone);
	}

	private static double normalizeAngle(double angle)
	{
		angle = angle % 360;
		if (angle < 0)
		{
			angle += 360;
		}
		return angle;
	}

	private static double normalizeTime(double t)
	{
		t = t % 24;
		if (t < 0)
		{
			t += 24;
		}
		return t;
	}
}

/*
 * Copyright (c) 2019 logarrhytmic <https://github.com/logarrhythmic>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.example;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import java.awt.Color;
//import java.util.TimeZone;

@ConfigGroup("dayNightCycle")
public interface DayNightCycleConfig extends Config
{
	@ConfigItem(
		keyName = "SunriseColor",
		name = "Sunrise Color",
		description = "Early Morning Color",
		position = 0
	)
	default Color getSunriseColor()
	{
		return new Color(144, 173, 228);
	}

	@ConfigItem(
		keyName = "dayColor",
		name = "Day Color",
		description = "12PM color",
		position = 1
	)
	default Color getDayColor()
	{
		return new Color(122, 159, 231);
	}

	@ConfigItem(
		keyName = "sunsetColor",
		name = "Sunset Color",
		description = "Late afternoon color",
		position = 2
	)
	default Color getSunsetColor()
	{
		return new Color(18, 33, 58);
	}

	@ConfigItem(
		keyName = "nightColor",
		name = "Night Color",
		description = "12AM color",
		position = 3
	)
	default Color getNightColor()
	{
		return new Color(13, 17, 26);
	}

	@ConfigItem(
		keyName = "useRealTimeCycle",
		name = "Use Real-Time Cycle",
		description = "Toggle between fast test cycle or real-time day/night cycle",
		position = 5
	)
	default boolean useRealTimeCycle()
	{
		return true; // default value
	}

	@ConfigItem(
		keyName = "cycleDuration",
		name = "Cycle Duration",
		description = "(Seconds) Set the total duration of the day/night cycle when using fast mode",
		position = 6
	)
	default int cycleDuration()
	{
		return 20;
	}

	@ConfigItem(
		keyName = "showOverlay",
		name = "Show Virtual Time Overlay",
		description = "Toggle the virtual time overlay on/off",
		position = 7
	)
	default boolean showOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "city",
		name = "City",
		description = "Select city to calculate sunrise/sunset. This does smart astronomical calculations to estimate when the sun will rise and sunset in your city.",
		position = 8
	)
	default City getCity()
	{
		return City.SAO_PAULO;
	}

	enum City
	{
		TOKYO(35.6895, 139.6917, "Asia/Tokyo"),
		DELHI(28.7041, 77.1025, "Asia/Kolkata"),
		SHANGHAI(31.2304, 121.4737, "Asia/Shanghai"),
		BEIJING(39.9042, 116.4074, "Asia/Shanghai"),
		SINGAPORE(1.3521, 103.8198, "Asia/Singapore"),
		SEOUL(37.5665, 126.9780, "Asia/Seoul"),
		BANGKOK(13.7563, 100.5018, "Asia/Bangkok"),
		HONG_KONG(22.3193, 114.1694, "Asia/Hong_Kong"),
		KUALA_LUMPUR(3.1390, 101.6869, "Asia/Kuala_Lumpur"),
		MUMBAI(19.0760, 72.8777, "Asia/Kolkata"),
		LOS_ANGELES(34.0522, -118.2437, "America/Los_Angeles"),
		NEW_YORK(40.7128, -74.0060, "America/New_York"),
		CHICAGO(41.8781, -87.6298, "America/Chicago"),
		MIAMI(25.7617, -80.1918, "America/New_York"),
		TORONTO(43.6511, -79.3470, "America/Toronto"),
		MEXICO_CITY(19.4326, -99.1332, "America/Mexico_City"),
		SAO_PAULO(-23.5505, -46.6333, "America/Sao_Paulo"),
		JOAO_PESSOA(-7.1153, -34.8641, "America/Fortaleza"),
		RIO_DE_JANEIRO(-22.9068, -43.1729, "America/Sao_Paulo"),
		BUENOS_AIRES(-34.6037, -58.3816, "America/Argentina/Buenos_Aires"),
		LIMA(-12.0464, -77.0428, "America/Lima"),
		LONDON(51.5074, -0.1278, "Europe/London"),
		PARIS(48.8566, 2.3522, "Europe/Paris"),
		BERLIN(52.5200, 13.4050, "Europe/Berlin"),
		MADRID(40.4168, -3.7038, "Europe/Madrid"),
		ROME(41.9028, 12.4964, "Europe/Rome"),
		MOSCOW(55.7558, 37.6173, "Europe/Moscow"),
		ISTANBUL(41.0082, 28.9784, "Europe/Istanbul"),
		DUBAI(25.2048, 55.2708, "Asia/Dubai"),
		JEDDAH(21.4858, 39.1925, "Asia/Riyadh"),
		CAPE_TOWN(-33.9249, 18.4241, "Africa/Johannesburg"),
		JOHANNESBURG(-26.2041, 28.0473, "Africa/Johannesburg"),
		CAIRO(30.0444, 31.2357, "Africa/Cairo"),
		Nairobi(-1.2921, 36.8219, "Africa/Nairobi"),
		SYDNEY(-33.8688, 151.2093, "Australia/Sydney"),
		MELBOURNE(-37.8136, 144.9631, "Australia/Melbourne"),
		AUCKLAND(-36.8485, 174.7633, "Pacific/Auckland"),
		WELLINGTON(-41.2865, 174.7762, "Pacific/Auckland"),
		HANOI(21.0278, 105.8342, "Asia/Bangkok"),
		JAKARTA(-6.2088, 106.8456, "Asia/Jakarta"),
		KATHMANDU(27.7172, 85.3240, "Asia/Kathmandu"),
		DUBLIN(53.3498, -6.2603, "Europe/Dublin"),
		AMSTERDAM(52.3676, 4.9041, "Europe/Amsterdam"),
		BRUSSELS(50.8503, 4.3517, "Europe/Brussels"),
		OSLO(59.9139, 10.7522, "Europe/Oslo"),
		STOCKHOLM(59.3293, 18.0686, "Europe/Stockholm"),
		HELSINKI(60.1699, 24.9384, "Europe/Helsinki"),
		VIENNA(48.2082, 16.3738, "Europe/Vienna"),
		ZURICH(47.3769, 8.5417, "Europe/Zurich"),
		ATHENS(37.9838, 23.7275, "Europe/Athens");


		private final double latitude;
		private final double longitude;
		private final String timezone;

		City(double lat, double lon, String tz)
		{
			this.latitude = lat;
			this.longitude = lon;
			this.timezone = tz;
		}

		public double getLatitude()
		{
			return latitude;
		}

		public double getLongitude()
		{
			return longitude;
		}

		public String getTimezone()
		{
			return timezone;
		}
	}


	@ConfigItem(
		keyName = "useCustomCoordinates",
		name = "Use Custom Coordinates",
		description = "If enabled, uses the latitude/longitude below instead of a selected city",
		position = 9
	)
	default boolean useCustomCoordinates()
	{
		return false;
	}

	@ConfigItem(
		keyName = "customLatitude",
		name = "Custom Latitude N/S",
		description = "Enter the latitude for sunrise/sunset calculations. Example: Tokyo latitude is 35.6764",
		position = 10
	)
	default double customLatitude()
	{
		return 0.0;
	}

	@ConfigItem(
		keyName = "customLongitude",
		name = "Custom Longitude E/W",
		description = "Enter the longitude for sunrise/sunset calculations. Example: Tokyo longitude is 139.6503",
		position = 11
	)
	default double customLongitude()
	{
		return 0.0;
	}

	@ConfigItem(
		keyName = "useCustomHour",
		name = "Use Custom Time",
		description = "If enabled, the day/night cycle will use the hour below instead of real time. For now custom hour is using cycle duration 86400 seconds is real time.",
		position = 12
	)
	default boolean useCustomHour()
	{
		return false;
	}

	@ConfigItem(
		keyName = "customHour",
		name = "Custom Hour",
		description = "Set the hour of the day manually (0â€“23)",
		position = 13
	)
	default String customHour()
	{
		return "05:00:00"; // default noon
	}

}



package com.example;

import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayLayer;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.time.ZonedDateTime;

public class DayNightCycleOverlay extends Overlay
{
	private final DayNightCyclePlugin plugin;

	public DayNightCycleOverlay(DayNightCyclePlugin plugin)
	{
		this.plugin = plugin;
		setPosition(OverlayPosition.TOP_LEFT);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		ZonedDateTime virtualTime = plugin.getVirtualTime();
		String time = String.format("%02d:%02d:%02d",
			virtualTime.getHour(),
			virtualTime.getMinute(),
			virtualTime.getSecond());

		graphics.drawString("Virtual Time: " + time, 10, 20);
		return null;
	}
}

package com.example;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class Mainrunner
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DayNightCyclePlugin.class);
		RuneLite.main(args);
	}
}
package com.example;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DayNightCyclePlugin.class);
		RuneLite.main(args);
	}
}
