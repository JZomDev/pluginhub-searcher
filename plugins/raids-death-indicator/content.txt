package com.example.utils;

public interface TriFunction<S, T, U, V, R> {
    R apply(S s, T t, U u, V v);
}

package com.example.utils;

import com.example.Predictor;
import com.google.gson.annotations.SerializedName;
import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Computes the internal fraction of a skill
 *
 * <p>
 * It works in the following way:
 * 1. Receive xp drop
 * 2. Look at current possible values (initially 0-9)
 * 3. Branch into once or twice, some xp drops are only possible to receive with the "extra" xp
 * 4. Adjust the filters, for example if you have the filters 0-3 and you receive 22 xp,
 *    this means that it has to be a 21.8 drop because the next hit would be 23.0. This means we
 *    can adjust the filters by 8 and remove any value that didn't wrap, so our new filters would be 8-9
 *    (previously 0-1)
 * 5. goto 1.
 * </p>
 */
@Slf4j
public class PredictionTree {
    /**
     * For debugging purposes
     */
    @SerializedName("xp")
    public int xp;

    public int damage;
    @SerializedName("properties")
    public Predictor.Properties properties;

    public PredictionTree nobxp;

    public PredictionTree bxp;

    /**
     * Set of active filters for the node
     */
    public Set<Integer> available;

    /**
     * Marks whether this is a valid leaf anymore
     */
    public boolean dead = false;

    /**
     * Used to create root.
     */
    public PredictionTree() { }
    public static PredictionTree createRoot() {
        PredictionTree root = new PredictionTree();
        root.available = IntStream.rangeClosed(0, 9).boxed().collect(Collectors.toSet());
        return root;
    }

    @Override
    public String toString() {
        return available.toString();
    }

    public int getFrac() {
        List<PredictionTree> leaves = getLeaves(this);
        if (leaves.size() != 1) {
            // Should always be possible to determine
            return -1;
        }

        PredictionTree leaf = leaves.get(0);
        if (leaf.available.size() != 1) {
            return -1;
        }
        return getFrac(leaf);
    }

    public static int getFrac(PredictionTree leaf) {
        assert (leaf.available.size() == 1);
        return leaf.available.stream().findFirst().get();
    }

    private PredictionTree(int xp, Predictor.Properties properties) {
        this.xp = xp;
        this.properties = properties;
        this.damage = 0;
    }

    private PredictionTree createBxp(Set<Integer> avail, int preciseXp, int xp, Predictor.Properties properties) {
        final int frac = preciseXp % 10;
        Set<Integer> newAvail = avail.stream().filter(n -> n + frac >= 10).map(n -> (n + frac) % 10).collect(Collectors.toSet());
        if (newAvail.isEmpty()) {
            return null;
        }
        PredictionTree node = new PredictionTree(xp, properties);
        node.available = newAvail;
        return node;
    }

    private PredictionTree createNoBxp(Set<Integer> avail, int preciseXp, int xp, Predictor.Properties properties) {
        final int frac = preciseXp % 10;
        Set<Integer> newAvail = avail.stream().filter(n -> n + frac < 10).map(n -> (n + frac) % 10).collect(Collectors.toSet());
        if (newAvail.isEmpty()) {
            return null;
        }
        PredictionTree node = new PredictionTree(xp, properties);
        node.available = newAvail;
        return node;
    }

    public void insertInto(int xp, Predictor.Properties properties) {
        if (xp == 0) {
            return;
        }
        // TODO: should this just be passed into the function?
        Predictor.Hit hit = Predictor.findHit(xp, properties);

        List<PredictionTree> leaves = getLeaves(this);

        //log.info("XP(" + properties.skill.getName() + ", " + properties.scaling + "): " + xp + "xp hit: "+ hit.hit +
        //        " leaves: " + leaves.size() + " true xp(-1): " + Predictor.computePrecise(hit.hit-1, properties) / 10d +
        //        " true xp: " + Predictor.computePrecise(hit.hit, properties) / 10d +
        //        " true xp(+1): " + Predictor.computePrecise(hit.hit + 1, properties) / 10d +
        //        " target: " + (properties.npc != null ? properties.npc.getName() + "(idx: " + properties.npc.getIndex() + " ID: " + properties.npc.getId() + ")" : "") + "\n---");
        if (leaves.isEmpty()) {
            log.debug("Leaves are empty");
        }

        int precise;
        for(PredictionTree leaf : leaves) {
            Set<Integer> avail = leaf.available;
            //log.info("Current guesses: " + avail);
            assert (!avail.isEmpty()); // should never be empty, something is wrong
            int phigh = Predictor.computePrecise(hit.hit, properties);
            int plow = Predictor.computePrecise(hit.hit-1, properties);
            int high = phigh / 10;
            int low = plow / 10;

            if(avail.size() == 1) {
                // When we get to this situation, say we have a 9 here and then
                // we receive a 20 xp drop. This can be either a 19.2 or a 20.6.
                // But now we have what we believe is the fraction, so we check;
                // lets say that the fraction is 9.
                // 20.6 + 9 = 21, we go over the drop so it has to be 19.2
                precise = Predictor.computePrecise(hit.hit, properties);
                boolean correct = (getFrac(leaf) + precise) / 10 == xp;
                if (!correct) {
                    precise = Predictor.computePrecise(hit.hit-1, properties);
                }

                if ((precise + getFrac(leaf)) / 10 != xp) {
                    leaf.dead = true;
                    //log.info("dead leaf");
                    continue;
                }
                final int finalFrac = precise % 10;
                leaf.available = avail.stream()
                        .map(n -> (n + finalFrac) % 10)
                        .collect(Collectors.toSet());

                //log.info("Frac: " + leaf);

                continue;
            }


            // branch on the higher hit
            if (high == xp) {
                leaf.nobxp = createNoBxp(avail, phigh, xp, properties);
                //log.info("Creating nbxp high (" + phigh / 10d +") " + leaf.nobxp);
            } else if (high + 1 == xp) {
                leaf.bxp = createBxp(avail, phigh, xp, properties);
                //log.info("Creating bxp high (" + phigh / 10d +") " + leaf.bxp);
            }

            // branch on the lower hit
            if (low == xp) {
                leaf.nobxp = createNoBxp(avail, plow, xp, properties);
                //log.info("Creating nbxp low (" + plow / 10d + ") " + leaf.nobxp);
            } else if (low != 0 && low + 1 == xp) {
                leaf.bxp = createBxp(avail, plow, xp, properties);
                //log.info("Creating bxp low (" + plow / 10d + ") " + leaf.bxp);
            }
            leaf.dead = leaf.bxp == null && leaf.nobxp == null;
        }
    }


    /**
     * Finds all the leaves of a tree using depth first search
     * @param tree root of tree
     * @return List of leaves
     */
    public static List<PredictionTree> getLeaves(PredictionTree tree) {
        List<PredictionTree> nodes = new ArrayList<>();
        Deque<PredictionTree> stack = new ArrayDeque<>();
        stack.push(tree);

        while (!stack.isEmpty()) {
            PredictionTree node = stack.pop();

            if (isLeaf(node)) {
                nodes.add(node);
                continue;
            }
            if (node.bxp != null) {
                stack.add(node.bxp);
            }
            if (node.nobxp != null) {
                stack.add(node.nobxp);
            }
        }
        return nodes;
    }

    /**
     * DFS for the tree.
     * TODO: should this be removed, seems to only have been used for the automatic test generatio that was removed.
     * @param root root of tree
     * @return list of nodes with no leaves
     */
    private static List<PredictionTree> findDeepestPath(PredictionTree root) {
        List<PredictionTree> deepestPath = new ArrayList<>();
        findDeepestPathHelper(root, new ArrayList<>(), deepestPath);
        return deepestPath;
    }

    private static void findDeepestPathHelper(PredictionTree node, List<PredictionTree> currentPath, List<PredictionTree> deepestPath) {
        if (node == null) return;

        currentPath.add(node);

        if (isLeaf(node)) {
            // Leaf node, check if this path is deeper
            if (currentPath.size() > deepestPath.size()) {
                deepestPath.clear();
                deepestPath.addAll(currentPath);
            }
        } else {
            // Recur for both children
            findDeepestPathHelper(node.nobxp, currentPath, deepestPath);
            findDeepestPathHelper(node.bxp, currentPath, deepestPath);
        }

        currentPath.remove(currentPath.size() - 1); // Backtrack
    }

    public List<PredictionTree> getLeaves() {
        return PredictionTree.getLeaves(this);
    }

    public static boolean isLeaf(PredictionTree tree) {
        return tree.nobxp == null && tree.bxp == null && !tree.dead;
    }

    /**
     * Places damage dealt into the tree and marks paths that are impossible as dead, additionally fixes fractions.
     * @param damage
     */
    public void retroFit(int damage) {

    }
}

package com.example;

import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

import java.awt.*;

@ConfigGroup("raid-death-indicator")
public interface AkkhaPredictorConfig extends Config
{
    @Alpha
    @ConfigItem(
            keyName = "highlightColor",
            name = "Highlight color",
            description = ""
    )
    default Color highlightColor() {
        return new Color(98, 174, 253, 64);
    }

    // TODO: add hidden options to store the fraction
}

package com.example.enemydata.het;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class AkkhaShadow extends Enemy {
    public AkkhaShadow(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                70, 100, 140, 30,
                115, 30,
                60, 120, 120);
        if (scaled_health > 100)
        {
            final int roundTo = scaled_health > 300 ? 10 : 5;
            // Shadow does not work like akkha, it uses the rounded health in the xp modifier
            scaled_health = ((scaled_health + (roundTo / 2)) / roundTo) * roundTo;
            current_health = scaled_health;
        }
        hideOnDeath = false;
    }

    @Override
    public void fixupStats(int invo, int partySize, int pathLevel) {
        super.fixupStats(invo, partySize, pathLevel);
        if (scaled_health > 100)
        {
            final int roundTo = scaled_health > 300 ? 10 : 5;
            scaled_health = ((scaled_health + (roundTo / 2)) / roundTo) * roundTo;
            current_health = scaled_health;
        }
    }

    @Override
    public synchronized boolean queueDamage(int damage) {
        shouldDraw = super.queueDamage(damage);
        return shouldDraw;
    }
}

package com.example.enemydata.het;

import com.example.enemydata.Enemy;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;

@Slf4j
@Getter
@Setter
@Accessors(fluent = true)
public class Akkha  extends Enemy {
    private boolean canPhase;

    public Akkha(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                400, 100, 140, 80,
                115, 30,
                60, 120, 120);
        canPhase = false;
        // scale to nearest 10, leave scaled health as is, xp modifier is computed using the "real" hp
        current_health = (int) (Math.round(scaled_health / 10.0) * 10);
        hideOnDeath = false;
    }

    @Override
    public boolean queueDamage(int damage) {
        super.queueDamage(damage);
        int queuedDamage = getQueuedDamage();

        final int max_health = (int) (Math.round(scaled_health / 10.0) * 10);
        final int phase_health = max_health / 5;
        // compute what the threshold for the next phase is
        final int next_phase = (current_health / phase_health) * phase_health;
        // This causes her to be highlighted a few hits post shadow, can't fix due to veng being able to overkill too
        shouldDraw = current_health != next_phase && (current_health - queuedDamage) <= next_phase;
        //log.info("Akkha: current " + current_health + " queued " + queuedDamage + " next phase: " + next_phase + " draw: " + shouldDraw);
        return shouldDraw;
    }

    @Override
    public void fixupStats(int invo, int partySize, int pathLevel) {
        super.fixupStats(invo, partySize, pathLevel);
        current_health = (int) (Math.round(scaled_health / 10.0) * 10);
    }

    /**
     * Check if the npc id is Akkha. This is required due to the memory special making Akkha disappear and
     * "dies".
     * @param id NPC id
     * @return true if it's Akkha, false otherwise
     */
    public static boolean isAkkha(int id) {
        return id == NpcID.AKKHA_11790 || id == NpcID.AKKHA_11791 || id == NpcID.AKKHA_11792 || id == NpcID.AKKHA_11793;
    }
}

package com.example.enemydata.scabaras;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Kephri extends Enemy {
    // TODO: might need extra handling due to shield? Probably just to ignore the damage queueing
    public Kephri(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                150, 0, 0, 80,
                0, 0,
                60, 300, 100);
        scaled_health = (int) (Math.round(scaled_health / 10.0) * 10);
        current_health = scaled_health;
    }

    @Override
    public void fixupStats(int invo, int partySize, int pathLevel) {
        super.fixupStats(invo, partySize, pathLevel);
        scaled_health = (int) (Math.round(scaled_health / 10.0) * 10);
        current_health = scaled_health;
    }

    /**
     * Disable for kephri, no use for it either way. If requested, can try to fix.
     * @param damage damage dealt
     * @return false
     */
    @Override
    public boolean queueDamage(int damage) {
        return false;
    }
}

package com.example.enemydata.scabaras;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Kephri721 extends Enemy {
    public Kephri721(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                80, 0, 0, 80,
                0, 0,
                60, 300, 100);
        scaled_health = (int) (Math.round(scaled_health / 10.0) * 10);
        current_health = scaled_health;
    }

    @Override
    public void fixupStats(int invo, int partySize, int pathLevel) {
        super.fixupStats(invo, partySize, pathLevel);
        scaled_health = (int) (Math.round(scaled_health / 10.0) * 10);
        current_health = scaled_health;
    }
}

package com.example.enemydata.scabaras;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Arcane extends Enemy {
    public Arcane(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                40, 75, 80, 80,
                0, 55,
                15, 150, 30);
    }
}

package com.example.enemydata.scabaras;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Spitter extends Enemy {
    public Spitter(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                40, 1, 80, 80,
                0, 55,
                15, 250, 30);
    }

}

package com.example.enemydata.scabaras;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Scarab extends Enemy {
    public Scarab(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                12, 20, 32, 28,
                0, 0,
                0, 0, 0);
    }

}

package com.example.enemydata.scabaras;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Soldier extends Enemy {
    public Soldier(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                40, 75, 80, 80,
                0, 55,
                15, 250, 30);
    }
}

package com.example.enemydata.scabaras;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class AgileScarab extends Enemy {
    public AgileScarab(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                30, 60, 20, 5,
                0, 25,
                0, 0, 0);
    }
}

package com.example.enemydata.scabaras;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class EmptyEgg extends Enemy {
    public EmptyEgg(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                35, 0, 0, 80,
                0, 0,
                60, 300, 100);
    }
}

package com.example.enemydata.scabaras;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Swarm extends Enemy {
    public Swarm(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                10, 1, 1, 0,
                0, 0,
                -100, -100, -100);
    }
}

package com.example.enemydata;

import com.example.enemydata.ampken.*;
import com.example.enemydata.crondis.Crocodile;
import com.example.enemydata.crondis.Jug;
import com.example.enemydata.crondis.Zebak;
import com.example.enemydata.het.Akkha;
import com.example.enemydata.het.AkkhaShadow;
import com.example.enemydata.scabaras.*;
import com.example.enemydata.wardens.*;
import com.example.utils.TriFunction;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;

import java.util.HashMap;
import java.util.Map;

@Slf4j
public abstract class Enemy implements IEnemy {
    public static Map<Integer, TriFunction<NPC, Integer, Integer, Integer, Enemy>> enemies;
    public int queuedDamage;
    public boolean shouldDraw;
    protected boolean hideOnDeath;

    public int invocation;
    public int partySize;
    public int pathLevel;

    public final int base_health;
    // TODO: this may require some rework, akkha for example computes the xp modifier before rounding hp
    public int scaled_health;
    public int current_health;

    private final int attack;
    private final int str;
    private final int def;
    private final int offAtt;
    private final int offStr;
    private final int defStab;
    private final int defSlash;
    private final int defCrush;
    private final boolean isPuzzle;

    private static final Map<Integer, Double> teamScaling;
    private static final Map<Integer, Double> pathScaling;

    @Getter
    @Setter
    NPC npc;

    @Setter
    @Getter
    Client client;

    static {
        teamScaling = new HashMap<>();
        teamScaling.put(1, 1.0);
        teamScaling.put(2, 1.9);
        teamScaling.put(3, 2.8);
        teamScaling.put(4, 3.4);
        teamScaling.put(5, 4.0);
        teamScaling.put(6, 4.6);
        teamScaling.put(7, 5.2);
        teamScaling.put(8, 5.8);

        pathScaling = new HashMap<>();
        pathScaling.put(0, 1.0);
        pathScaling.put(1, 1.08);
        pathScaling.put(2, 1.13);
        pathScaling.put(3, 1.18);
        pathScaling.put(4, 1.23);
        pathScaling.put(5, 1.28);
        pathScaling.put(6, 1.33);

        enemies = new HashMap<>();
        enemies.put(NpcID.AKKHA, Akkha::new);
        enemies.put(NpcID.AKKHA_11790, Akkha::new);
        enemies.put(NpcID.AKKHA_11791, Akkha::new);
        enemies.put(NpcID.AKKHA_11792, Akkha::new);
        enemies.put(NpcID.AKKHA_11793, Akkha::new);
        enemies.put(NpcID.AKKHA_11794, Akkha::new);
        enemies.put(NpcID.AKKHA_11795, Akkha::new);
        enemies.put(NpcID.AKKHA_11796, Akkha::new);

        enemies.put(NpcID.AKKHAS_SHADOW, AkkhaShadow::new);

        enemies.put(NpcID.BABA, Baba::new);
        enemies.put(NpcID.BABA_11779, Baba::new);
        enemies.put(NpcID.BABA_11780, Baba::new);
        enemies.put(NpcID.BABOON, Baboon::new);
        enemies.put(NpcID.BOULDER_11782, Boulder::new);
        enemies.put(NpcID.BOULDER_11783, Boulder::new);

        enemies.put(NpcID.KEPHRI, Kephri::new);
        enemies.put(NpcID.KEPHRI_11721, Kephri721::new);
        enemies.put(NpcID.AGILE_SCARAB, AgileScarab::new);
        enemies.put(NpcID.ARCANE_SCARAB, Arcane::new);
        enemies.put(NpcID.SCARAB, Scarab::new);
        enemies.put(NpcID.SOLDIER_SCARAB, Soldier::new);
        enemies.put(NpcID.SPITTING_SCARAB, Spitter::new);
        enemies.put(NpcID.SCARAB_SWARM_11723, Swarm::new);

        enemies.put(NpcID.ZEBAK_11730, Zebak::new);
        enemies.put(NpcID.ZEBAK_11732, Zebak::new);
        enemies.put(NpcID.CROCODILE_11705, Crocodile::new);
        enemies.put(NpcID.JUG, Jug::new);
        enemies.put(NpcID.JUG_11736, Jug::new);

        enemies.put(NpcID.BABOON_BRAWLER, Brawler::new);
        enemies.put(NpcID.BABOON_BRAWLER_11712, Brawler::new);
        enemies.put(NpcID.BABOON_THROWER, Thrower::new);
        enemies.put(NpcID.BABOON_THROWER_11713, Thrower::new);
        enemies.put(NpcID.BABOON_MAGE, Mage::new);
        enemies.put(NpcID.BABOON_MAGE_11714, Mage::new);
        enemies.put(NpcID.BABOON_THRALL, Thrall::new);
        enemies.put(NpcID.BABOON_SHAMAN, Shaman::new);
        enemies.put(NpcID.CURSED_BABOON, Cursed::new);
        enemies.put(NpcID.VOLATILE_BABOON, Volatile::new);

        enemies.put(NpcID.OBELISK_11751, Obelisk::new);
        // different overheads -> different ID
        enemies.put(NpcID.ELIDINIS_WARDEN_11753, ElidinisWarden::new);
        enemies.put(NpcID.ELIDINIS_WARDEN_11754, ElidinisWarden::new);
        enemies.put(NpcID.ELIDINIS_WARDEN_11761, ElidinisWarden761::new);
        // different overheads -> different ID
        enemies.put(NpcID.TUMEKENS_WARDEN_11756, TumekensWarden::new);
        enemies.put(NpcID.TUMEKENS_WARDEN_11757, TumekensWarden::new);
        enemies.put(NpcID.TUMEKENS_WARDEN_11762, TumekensWarden762::new);
    }

    protected Enemy(NPC npc, int invocation, int partySize, int pathLevel,
          int baseHealth, int attack, int str, int def,
          int offAtt, int offStr,
          int defStab, int defSlash, int defCrush, boolean isPuzzle) {
        assert(partySize <= 8 && partySize >= 1);
        assert((invocation % 5) == 0);
        this.npc = npc;

        if (pathLevel >= 0) {
            this.invocation = invocation;
            this.partySize = partySize;
            this.pathLevel = pathLevel;
            this.scaled_health = getScaledHealth(invocation, partySize,
                    pathLevel, baseHealth, isPuzzle);
            this.current_health = this.scaled_health;
        }

        this.base_health = baseHealth;
        this.attack = attack;
        this.str = str;
        this.def = def;
        this.offAtt = offAtt;
        this.offStr = offStr;
        this.defStab = defStab;
        this.defSlash = defSlash;
        this.defCrush = defCrush;
        this.isPuzzle = isPuzzle;
        this.shouldDraw = false;
        this.hideOnDeath = true;
        this.queuedDamage = 0;
    }
    protected Enemy(NPC npc, int invocation, int partySize, int pathLevel,
          int baseHealth, int attack, int str, int def,
          int offAtt, int offStr,
          int defStab, int defSlash, int defCrush
    ) {
        this(npc, invocation, partySize, pathLevel,
                baseHealth, attack, str, def,
                offAtt, offStr,
                defStab, defSlash, defCrush, false);
    }

    public void setCurrentHealth(int hp) {
        if (hp >= 0) {
            current_health = hp;
        }
    }

    public synchronized int hit(int damage) {
        queuedDamage = Math.max(0, queuedDamage - damage);
        current_health -= damage;
        return current_health;
    }

    public synchronized int getQueuedDamage() {
        return queuedDamage;
    }

    public synchronized void setQueuedDamage(int queuedDamage) {
        this.queuedDamage = queuedDamage;
    }

    /**
     * Queues damage and counts if the enemy will die to it.
     * @param damage damage dealt.
     * @return true if the mob died, false if not.
     */
    public synchronized boolean queueDamage(int damage) {
        queuedDamage += damage;
        boolean died = queuedDamage >= current_health;

        npc.setDead(died && hideOnDeath);
        return died;
    }

    public boolean shouldHighlight() {
        return shouldDraw;
    }

    public void fixupStats(int invocation, int partySize, int pathLevel) {
        // Should only happen before any npcs actually have been damaged
        this.invocation = invocation;
        this.partySize = partySize;
        this.pathLevel = pathLevel;
        scaled_health = getScaledHealth(invocation, partySize, pathLevel, base_health, isPuzzle);
        current_health = scaled_health;
    }

    public double getModifier() {
        double avgs = Math.floor((getAvgLevel() * (getAvgDef() + offStr + offAtt)) / 5120d);
        avgs /= 40d;
        return Math.max(1.0d, 1 + avgs);
    }

    public int getScaledHealth() {
        return scaled_health;
    }

    private static int getScaledHealth(int invocation, int partySize, int pathLevel, int base_health, boolean isPuzzle) {
        double scale = (1 + 0.004 * invocation);
        double teamScale = teamScaling.get(partySize);
        double pathScale;
        if (isPuzzle) {
            pathScale = 1d;
            teamScale = 1d;
            scale = 1d;
        } else {
            pathScale = pathScaling.get(pathLevel);
        }

        return (int) (base_health * scale * teamScale * pathScale);
    }
    private int getAvgLevel() {
        return (attack + str + def + Math.min(getScaledHealth(), 2000)) / 4;
    }

    private int getAvgDef() {
        return (defStab + defSlash + defCrush) / 3;
    }

}

package com.example.enemydata.wardens;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class ElidinisWarden extends Enemy {
    public ElidinisWarden(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                140, 300, 150, 100,
                0, 10,
                70, 70, 70);
    }
}

package com.example.enemydata.wardens;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Obelisk extends Enemy {
    public Obelisk(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                260, 200, 150, 100,
                0, 0,
                70, 70, 70);
    }
}

package com.example.enemydata.wardens;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class TumekensWarden762 extends Enemy {

    public TumekensWarden762(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                880, 150, 150, 150,
                0, 40,
                40, 40, 20);
    }
}

package com.example.enemydata.wardens;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class TumekensWarden extends Enemy {
    public TumekensWarden(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                140, 300, 150, 100,
                0, 25,
                70, 70, 70);
    }
}

package com.example.enemydata.wardens;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class ElidinisWarden761 extends Enemy {
    public ElidinisWarden761(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                880, 150, 150, 150,
                0, 40,
                40, 40, 20);
    }
}

package com.example.enemydata;

public interface IEnemy {
    int hit(int damage);
}

package com.example.enemydata.ampken;

import com.example.enemydata.Enemy;
import net.runelite.api.*;

public class Thrower extends Enemy {
    public Thrower(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                npc.getId() == NpcID.BABOON_THROWER ? 30 : 35, npc.getId() == NpcID.BABOON_THROWER ? 40 : 60,
                npc.getId() == NpcID.BABOON_THROWER ? 40 : 60, npc.getId() == NpcID.BABOON_THROWER ? 12 : 20,
                npc.getId() == NpcID.BABOON_THROWER ? 20 : 25, 0,
                -50, -50, -50, true);
    }
}

package com.example.enemydata.ampken;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Baboon extends Enemy {
    // Baba baboon
    public Baboon(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                35, 0, 0, 50,
                0, 0,
                10, 50, 50);
    }
}

package com.example.enemydata.ampken;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Volatile extends Enemy {
    public Volatile(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                8, 60, 60, 20,
                25, 0,
                900, 900, 900, true);
    }
}

package com.example.enemydata.ampken;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;

public class Mage extends Enemy {
    public Mage(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                npc.getId() == NpcID.BABOON_MAGE ? 20 : 25, // health
                npc.getId() == NpcID.BABOON_MAGE ? 40 : 60, // attack
                npc.getId() == NpcID.BABOON_MAGE ? 40 : 60, // str
                npc.getId() == NpcID.BABOON_MAGE ? 12 : 20, // def
                npc.getId() == NpcID.BABOON_MAGE ? 20 : 25, // offatt
                0, 900, 900, 900, true);
    }
}

package com.example.enemydata.ampken;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Cursed extends Enemy {
    public Cursed(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                10, 60, 60, 20,
                25, 0,
                900, 900, 900, true);
    }
}

package com.example.enemydata.ampken;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

import java.util.HashMap;
import java.util.Map;

public class Boulder extends Enemy {
    // team size -> path level -> hp
    private static final int [][] hpMap = {
                    {25, 25, 27, 27, 31},
                    {36, 36, 39, 39, 45},
                    {47, 47, 51, 51, 58},
                    {55, 55, 60, 60, 68},
                    {62, 62, 68, 68, 77},
                    {70, 70, 77, 77, 87},
                    {77, 77, 84, 84, 96},
                    {85, 85, 93, 93, 106}
            };
    public Boulder(NPC npc, int invocation, int partySize, int pathLevel) {
        // TODO revisit this, seems that a new npc is spawned on phase?
        super(npc, invocation, partySize, pathLevel,
                hpMap[partySize-1][pathLevel], 0, 0, 0,
                0, 0,
                0, 0, 0);
    }
}

package com.example.enemydata.ampken;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Shaman extends Enemy {
    public Shaman(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                16, 60, 60, 20,
                25, 0,
                900, 900, 900, true);
    }
}

package com.example.enemydata.ampken;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Thrall extends Enemy {
    public Thrall(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                2, 40, 40, 12,
                20, 0,
                0, 0, 0, true);
    }
}

package com.example.enemydata.ampken;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Baba extends Enemy {
    public Baba(NPC npc, int invocation, int partySize, int pathLevel) {
        // TODO revisit this, seems that a new npc is spawned on phase?
        super(npc, invocation, partySize, pathLevel,
                380, 150, 160, 80,
                0, 26,
                80, 160, 240);
    }
}

package com.example.enemydata.ampken;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;

public class Brawler extends Enemy {
    public Brawler(NPC npc, int invocation, int partySize, int pathLevel) {
        // For solo 380, this should likely be have a scaling of 1.12?
        super(npc, invocation, partySize, pathLevel,
                npc.getId() == NpcID.BABOON_BRAWLER ? 25 : 30, // health
                npc.getId() == NpcID.BABOON_BRAWLER ? 40 : 60, // att
                npc.getId() == NpcID.BABOON_BRAWLER ? 40 : 60, // str
                npc.getId() == NpcID.BABOON_BRAWLER ? 12 : 20, // def
                npc.getId() == NpcID.BABOON_BRAWLER ? 20 : 25, // offatt
                0, 900, 900, 900, true);
    }
}

package com.example.enemydata.crondis;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Zebak extends Enemy {
    public Zebak(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                580, 250, 140, 70,
                160, 100,
                160, 160, 260);
    }
}

package com.example.enemydata.crondis;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Crocodile extends Enemy {
    public Crocodile(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                30, 150, 60, 100,
                0, 100,
                150, 350, 350);
    }
}

package com.example.enemydata.crondis;

import com.example.enemydata.Enemy;
import net.runelite.api.NPC;

public class Jug extends Enemy {

    public Jug(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                5, 0, 0, 0,
                0, 0,
                0, 0, 0);
    }
}

package com.example;

import com.example.utils.PredictionTree;
import lombok.AllArgsConstructor;
import lombok.NonNull;
import net.runelite.api.NPC;
import net.runelite.api.Skill;

import java.util.*;

/**
 * Class for computing the internal fraction in xp.
 */
public class Predictor {
    Map<Skill, PredictionTree> roots;

    @AllArgsConstructor
    public static class Properties {
        public Skill skill;
        public boolean isDefensive;
        public boolean isPoweredStaff;
        public NPC npc;
        public double scaling;


        public Properties(Skill skill, boolean isDefensive, boolean isPowered, double scaling) {
            this.skill = skill;
            this.isDefensive = isDefensive;
            this.isPoweredStaff = isPowered;
            this.scaling = scaling;
        }
        // TODO: add scaling here?
    }

    public Predictor() {
        roots = new HashMap<>();
    }

    @Deprecated
    public Predictor(double scaling) {
        this();
    }

    @AllArgsConstructor
    public static class Hit {
        public final int hit;
        /**
         * Could be bxp, a case where there both exists for example a 17 xp drop
         * and a 16 xp drop.
         */
        public final boolean possibleBxp;
        /**
         * It must be bxp, e.g. if you've received 18 xp, and it's
         * not possible to receive it without doing 17 + 1.
         */
        public boolean bxp;
    }

    /**
     * Resets all skill prediction trees.
     */
    public void reset() {
        if (!roots.isEmpty()) {
            roots = new HashMap<>();
        }
    }

    /**
     * Finds the hit that most closely represents the xp drop.
     * @param xp amount of xp received
     * @param properties
     * @return Upper bound for the hit.
     */
    public static Hit findHit(int xp, Properties properties) {
        boolean possibleBxp = false;
        boolean bxp = false;
        int hit;
        // 200 is a high number, will cover all the possible hits,
        // perhaps one day I'll make it compute the real max hit...
        // Today is not that day.
        for (hit = 0; hit <= 200; hit++) {
            int drop = computeDrop(hit, properties);
            if (drop > xp) {
                hit--;
                bxp = true;
                break;
            }

            if (drop == xp) {
                break;
            }

            int precise = computePrecise(hit, properties);
            // Check if xp + 1 is the real xp
            possibleBxp = (drop + 1) == xp && precise % 10 != 0;
        }

        return new Hit(hit, possibleBxp, bxp);
    }


    /**
     * Computes the precise xp drop as a fixed length integer
     * <a href="https://oldschool.runescape.wiki/w/Combat#Experience_gain">OSRS Wiki</a>
     * @param hit Damage dealt
     * @param props Skill that the xp was received in
     * @return A fixed length integer for how much xp was received.
     */
    public static int computePrecise(int hit, Properties props) {
        int scaling = (int) (props.scaling * 1000); // make it an integer that gets scaled down
        int precise = 0;
        switch (props.skill) {
            /* TODO: should this be removed in it's entirety?
            case DEFENCE:
                if (props.isPoweredStaff && props.isDefensive) {
                    precise = (int) (hit * 10 * scaling);
                } else {
                    // you receive 4xp per damage with melee
                    precise = (int) (hit * 10 * 4 * scaling);
                }
            case MAGIC:
                if (props.isPoweredStaff && !props.isDefensive) {
                    precise = (int) (hit * 2 * 10 * scaling);
                } else if (props.isPoweredStaff) {
                    precise = (int) (hit * 10 * 4 / 3.0d * scaling);
                }
                // TODO spells
                break;
            case ATTACK:
            case STRENGTH:
            case RANGED:
                precise = (int) (hit * 10 * 4 * scaling);
                break;
             */

            case HITPOINTS:
                precise = (int) (hit * 10 * 4 * scaling / 3);
                break;
        }
        return precise / 1000;
    }

    /**
     * Computes the xp amount received in the way that OSRS shows it to the user.
     *
     * @param hit Damage dealt
     * @param properties Properties of the xp drop
     * @return An integer that has been rounded down to represent the xp.
     */
    public static int computeDrop(int hit, Properties properties) {
        return computePrecise(hit, properties) / 10;
    }

    /**
     * Checks if the tree for a skill is accurate or not. The tree
     * is accurate if there's only one leaf that is not dead in the tree.
     * @param skill skill to check
     * @return true if accurate, false if not
     */
    public boolean isAccurate(Skill skill) {
        PredictionTree root = roots.getOrDefault(skill, null);
        if (root == null) {
            return false;
        }
        int frac = root.getFrac();
        return frac != -1;
    }

    /**
     * Inserts an xp node into the prediction tree.
     *
     * @param xp amount of xp received
     * @param scaling scaling of the monster attacked
     * @param props properties related to attack
     */
    public void insertInto(int xp, double scaling, @NonNull Properties props) {
        if (!roots.containsKey(props.skill)) {
            roots.put(props.skill, PredictionTree.createRoot());
        }
        PredictionTree root = roots.get(props.skill);
        root.insertInto(xp, props);
    }

    /**
     * Predicts a hit, if the tree isn't accurate it falls back to primitive methods.
     * @param xp xp received
     * @param props properties of the hit
     * @return expected hit
     */
    public int treePredict(int xp, @NonNull Properties props) {
        if (!roots.containsKey(props.skill)) {
            roots.put(props.skill, PredictionTree.createRoot());
        }
        PredictionTree root = roots.get(props.skill);
        int frac = root.getFrac();
        root.insertInto(xp, props);
        Hit hit = findHit(xp, props);

        int high = computePrecise(hit.hit, props);
        int low = computePrecise(hit.hit-1, props);

        if (frac != -1) {
            if ((high + frac) / 10 == xp) {
                return hit.hit;
            }
            if ((low + frac) / 10 == xp) {
                return hit.hit-1;
            }
        }
        // if the xp drops do not overlap, check which one matches the given drop, otherwise fall back
        // to where the low hit is returned.
        if (high / 10 != low / 10) {
            return high / 10 == xp ? hit.hit : hit.hit - 1;
        }

        // We have to always take hit-1 because low hits have overlapping xpdrops
        // it's worse if we say that the mob died and it didn't
        return Math.max(hit.hit-1, 1);
    }
}

package com.example;

import com.example.enemydata.Enemy;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Skill;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

import javax.inject.Inject;
import java.awt.*;

@Slf4j
public class AkkhaPredictorOverlay extends Overlay {
    private final AkkhaPredictor plugin;
    private final AkkhaPredictorConfig config;
    private final Client client;

    @Inject
    public AkkhaPredictorOverlay(AkkhaPredictor plugin, AkkhaPredictorConfig config, Client client, ModelOutlineRenderer renderer) {
        this.plugin = plugin;
        this.config = config;
        this.client = client;
        setPosition(OverlayPosition.DYNAMIC);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.isAtToa()) {
            return null;
        }
        var enemies = plugin.getActiveEnemies();

        for (Enemy enemy : enemies.values()) {
            if (enemy.shouldHighlight()) {
                NPC npc = enemy.getNpc();
                renderPoly(graphics, null, 0, config.highlightColor(), npc.getConvexHull());
            }
        }

        Skill []skills = new Skill[]{Skill.HITPOINTS};
        int start = 20;
        for (Skill skill : skills) {
            if (plugin.getPredictor().isAccurate(skill)) {
                graphics.setColor(Color.green);
                graphics.fillRect(10, start, 10, 10);
            } else {
                graphics.setColor(Color.red);
                graphics.fillRect(10, start, 10, 10);
            }
            start += 20;
        }
        return null;
    }

    private void renderPoly(Graphics2D graphics, Color borderColor, float borderWidth, Color fillColor, Shape polygon)
    {
        if (polygon != null)
        {
            graphics.setColor(borderColor);
            graphics.setStroke(new BasicStroke(borderWidth));
            graphics.draw(polygon);
            graphics.setColor(fillColor);
            graphics.fill(polygon);
        }
    }
}

package com.example.events;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

@Value
@EqualsAndHashCode(callSuper = true)
public class EntityDamaged extends PartyMemberMessage
{
    int npcIndex;
    int damage;
}


package com.example;

import com.example.enemydata.Enemy;
import com.example.enemydata.het.Akkha;
import com.example.events.EntityDamaged;
import com.example.utils.TriFunction;
import com.google.inject.Provides;
import javax.inject.Inject;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.kit.KitType;
import net.runelite.api.widgets.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.party.PartyMember;
import net.runelite.client.party.PartyService;
import net.runelite.client.party.WSClient;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import java.util.*;

@Slf4j
@PluginDescriptor(
	name = "Raid Death Indicator"
)
public class AkkhaPredictor extends Plugin
{
	@Inject
	private Client client;

	@Inject
	ClientThread clientThread;

	@Inject
	private AkkhaPredictorConfig config;

	@Inject
	private AkkhaPredictorOverlay overlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private PartyService party;

	@Inject
	private WSClient wsClient;

	private final Set<Skill> validSkills = Set.of(Skill.HITPOINTS);


	/**
	 * Map of current XP amounts in each skill
	 */
	private Map<Skill, Integer> previousXps;

	@Getter
	private final Map<Integer, Enemy> activeEnemies = new HashMap<>();

	@Getter
	private final Predictor predictor = new Predictor();

	private static final Set<Integer> POWERED_STAVES = new HashSet<>(Arrays.asList(
			ItemID.SANGUINESTI_STAFF,
			ItemID.TRIDENT_OF_THE_SEAS_FULL,
			ItemID.TRIDENT_OF_THE_SEAS,
			ItemID.TRIDENT_OF_THE_SWAMP,
			ItemID.TRIDENT_OF_THE_SWAMP_E,
			ItemID.HOLY_SANGUINESTI_STAFF,
			ItemID.TUMEKENS_SHADOW,
			ItemID.CORRUPTED_TUMEKENS_SHADOW,
			ItemID.VOIDWAKER
	));

	@Override
	protected void startUp() throws Exception
	{
		clientThread.invoke(this::initXpMap);
		overlayManager.add(overlay);
		wsClient.registerMessage(EntityDamaged.class);
	}

	private void initXpMap() {
		previousXps = new HashMap<>();
		Arrays.stream(Skill.values()).forEach(skill -> previousXps.put(skill, client.getSkillExperience(skill)));
	}

	/**
	 * @return TOA invocation level
	 */
	private int getInvocation() {
		return client.getVarbitValue(Varbits.TOA_RAID_LEVEL);
	}

	/**
	 * Fetches the path level from the TOA widget
	 * @return Path level
	 */
	private int getPathLevel() {
		Widget pathLevelWidget = client.getWidget(481, 45);
		if (pathLevelWidget == null) {
			return -1;
		}
		return Integer.parseInt(pathLevelWidget.getText());
	}

	/**
	 * Gets amount of people in the raid, amount makes the enemy health scale with 90%
	 * @return Amount of people in the raid
	 */
	private int getPartySize()
	{
		int partySize = 1;
		for (int i = 1; i < 8; i++) {
			if (client.getVarbitValue(Varbits.TOA_MEMBER_0_HEALTH + i) != 0) {
				partySize++;
			}
		}
		return partySize;
	}

	private boolean partyDead() {

		for (int i = Varbits.TOA_MEMBER_0_HEALTH; i <= Varbits.TOA_MEMBER_7_HEALTH; i++) {
			int value = client.getVarbitValue(i);
			 if (value != 30 && value != 0) {
				 return false;
			 }
		}

		return true;
	}

	@Subscribe
	public void onGameTick(GameTick tick) {
		if (partyDead()) {
			// TODO: does this need to be done each tick?
			activeEnemies.clear();
		}
	}

	@Subscribe
	protected void onGameStateChanged(GameStateChanged state) {
        if (Objects.requireNonNull(state.getGameState()) == GameState.LOGGED_IN) {
            initXpMap();
        }
	}

	@Subscribe
	protected void onNpcDespawned(NpcDespawned event) {
		NPC npc = event.getNpc();
		boolean isAkkha = Akkha.isAkkha(npc.getId());
		boolean isPartyDead = partyDead();
		if (isAkkha && !isPartyDead) {
			return;
		}
        activeEnemies.remove(npc.getIndex());
	}

	@Subscribe
	protected void onNpcSpawned(NpcSpawned event) {
		NPC npc = event.getNpc();
		if (activeEnemies.containsKey(npc.getIndex())) {
			Enemy enemy = activeEnemies.get(npc.getIndex());
			enemy.setNpc(npc);
			// Re-sync the health of the enemy (akkha) when it re-appears in case of hits during invuln
			// TODO should akkha be subscribed to the event bus?
			int newHealth = client.getVarbitValue(Varbits.BOSS_HEALTH_CURRENT);
			enemy.setCurrentHealth(newHealth);
			enemy.setQueuedDamage(0);

			return;
		}

		TriFunction<NPC, Integer, Integer, Integer, Enemy> constructor = Enemy.enemies.getOrDefault(npc.getId(), null);
		if (constructor == null) {
			return;
		}

		Enemy enemy = constructor.apply(npc, getInvocation(), getPartySize(), getPathLevel());
		enemy.setClient(client);

		activeEnemies.put(npc.getIndex(), enemy);
	}

	/**
	 * Create the new Akkha object when the TOA path widget has loaded, we aren't able to get the path level otherwise.
	 * @param event
	 */
	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		// 481 is the TOA path/time/etc. widget
		if (event.getGroupId() != InterfaceID.TOA_RAID) {
			return;
		}
		int invo = getInvocation();
		int pathLevel = getPathLevel();
		int partySize = getPartySize();
		if (pathLevel < 0 || invo < 0 || partySize <= 0) {
			return;
		}
		for (Enemy enemy : activeEnemies.values()) {
			enemy.fixupStats(invo, partySize, pathLevel);
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		previousXps = null;
		overlayManager.remove(overlay);
		wsClient.unregisterMessage(EntityDamaged.class);
	}

	public boolean isAtToa() {
		final int []TOA_REGIONS = {
				//13455, // Lobby
				//14160, // Nexus

				//15698, // Crondis
				//15700, // Zebak

				//14162, // Scabaras
				//14164, // Kephri

				15186, // Apmken
				//15188, // Baba

				//14674, // Het
				14676, // Akkha

				//15184, // Wardens
				//15696, // Wardens

				//14672, // Tomb
		};

		return Arrays.stream(client.getTopLevelWorldView().getMapRegions()).anyMatch(current -> Arrays.stream(TOA_REGIONS).anyMatch(reg -> reg == current));
	}

	/**
	 * Processes the xp drop and turns it into how much damage it did. Not entirely accurate due to fractional XP.
	 * Rounds down so that in case it does get fractional it should not give false positives.
	 *
	 * @param skill Skill that xp was received in.
	 * @param xp Amount of XP that was received.
	 */
	private void processXpDrop(Skill skill, int xp) {
		if (!validSkills.contains(skill)) {
			return;
		}

		Player player = Objects.requireNonNull(client.getLocalPlayer());
		Actor entity = player.getInteracting();
		if (!(entity instanceof NPC) || !isAtToa()) {
			return;
		}

		PlayerComposition playerComposition = player.getPlayerComposition();
		NPC npc = (NPC) entity;
		Enemy enemy;
		if (activeEnemies.containsKey(npc.getIndex())) {
			enemy = activeEnemies.get(npc.getIndex());
		} else {
			// Construct a new enemy
			enemy = Enemy.enemies.get(npc.getId()).apply(npc, getInvocation(), getPartySize(), getPathLevel());
			if (enemy == null) {
				return;
			}
			enemy.setClient(client);
			activeEnemies.put(npc.getIndex(), enemy);
		}

		int attackStyle = client.getVarpValue(VarPlayer.ATTACK_STYLE);
		int weapon = playerComposition.getEquipmentId(KitType.WEAPON);

		boolean isDefensiveCast = attackStyle == 3;
		boolean isPoweredStaff = POWERED_STAVES.contains(weapon);
		double scaling = enemy.getModifier();
		Predictor.Properties props = new Predictor.Properties(skill, isDefensiveCast, isPoweredStaff, npc, scaling);
		if ((skill == Skill.RANGED || skill == Skill.MAGIC) && isDefensiveCast) {
			// Ignore in order to not double hit, insert the drop into
			// the tree in order to track the fraction
			predictor.insertInto(xp, scaling, props);
			return;
		}
		int damage = predictor.treePredict(xp, props);
		assert (damage >= 0);

		sendDamage(player, damage);
	}

	private void sendDamage(Player player, int damage) {
		if (damage <= 0) {
			return;
		}

		NPC npc = (NPC) player.getInteracting();

		final int npcIndex = npc.getIndex();
		final EntityDamaged entityDamaged = new EntityDamaged(npcIndex, damage);

		if (party.isInParty()) {
			clientThread.invokeLater(() -> party.send(entityDamaged));
		}
		onEntityDamaged(entityDamaged);
	}

	/**
	 * Computes the difference between the updated xp drop and the previous one
	 * @param skill Skill XP was received in.
	 * @param xp Updated XP amount.
	 */
	private void preProcessXpDrop(Skill skill, int xp) {
		if (!isAtToa()) {
			predictor.reset();
			return;
		}

		int diff = xp - previousXps.getOrDefault(skill, 0);
		previousXps.put(skill, xp);
		processXpDrop(skill, diff);
	}

	/**
	 * Queues damage on an entity. If the entity is a shadow, it hides the shadow.
	 * If the entity is Akkha, it will highlight her.
	 * @param entityDamaged event
	 */
	@Subscribe
	public void onEntityDamaged(EntityDamaged entityDamaged) {
		if (!isAtToa()) {
			return;
		}

		PartyMember localPlayer = party.getLocalMember();

		if (localPlayer != null) {
			if (localPlayer.getMemberId() == entityDamaged.getMemberId()) {
				return; // Don't process your own events
			}
		}

		Integer npcIndex = entityDamaged.getNpcIndex();
		Enemy enemy = activeEnemies.getOrDefault(npcIndex, null);
		enemy.queueDamage(entityDamaged.getDamage());
	}

	@Subscribe(priority = -100f)
	public void onStatChanged(StatChanged xpDrop) {
		preProcessXpDrop(xpDrop.getSkill(), xpDrop.getXp());
	}

	@Subscribe
	public void onFakeXpDrop(FakeXpDrop xpDrop) {
		//TODO hopefully this works. I don't have 200m in magic to find out.
		processXpDrop(xpDrop.getSkill(), xpDrop.getXp());
	}

	/**
	 * Removes the hit from queued damage.
	 * @param hit hitsplat
	 */
	@Subscribe
	public void onHitsplatApplied(HitsplatApplied hit) {
		Hitsplat hitsplat = hit.getHitsplat();
		if (!isAtToa() || (hitsplat.getHitsplatType() == HitsplatID.HEAL && hitsplat.getAmount() > 0)) {
			return;
		}
		Actor actor = hit.getActor();
		if (actor instanceof NPC) {
			NPC npc = (NPC) actor;
			Enemy enemy = activeEnemies.getOrDefault(npc.getIndex(), null);
			if (enemy == null) {
				//log.info("Unknown target: " + npc.getId() + " index: " + npc.getIndex());
				return;
			}
			int amount = hitsplat.getAmount();
			int hp = enemy.hit(amount);
			//log.info("Damage: " + amount + " " + hit.getActor().getName() + " (" + hp +")");

			if (hp <= 0) {
				activeEnemies.remove(npc.getIndex());
			}
		}
	}


	@Provides
	AkkhaPredictorConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(AkkhaPredictorConfig.class);
	}
}

package com.example;

import com.example.utils.PredictionTree;
import static org.junit.Assert.*;

import net.runelite.api.Skill;
import org.junit.Test;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class TreeTests {
    @Test
    public void testLeafFinding() {
        PredictionTree root = new PredictionTree();
        root.available = new HashSet<>();
        root.available.add(8);
        root.bxp = new PredictionTree();
        root.bxp.available = new HashSet<>();
        root.bxp.available.add(9);

        root.bxp.bxp = new PredictionTree();
        root.bxp.bxp.available = new HashSet<>();
        root.bxp.bxp.available.add(1);

        root.bxp.nobxp = new PredictionTree();
        root.bxp.nobxp.available = new HashSet<>();
        root.bxp.nobxp.available.add(2);

        List<PredictionTree> leaves = PredictionTree.getLeaves(root);
        for (PredictionTree node : leaves) {
            assertTrue(PredictionTree.isLeaf(node));
            assertTrue(node.available.contains(1) || node.available.contains(2));
        }
    }

    @Test
    public void testInsertion() {
        PredictionTree root = PredictionTree.createRoot();
        Predictor.Properties properties = new Predictor.Properties(Skill.DEFENCE, true, true, 1.375d);
        root.insertInto(63, properties);
        List<PredictionTree> leaves = root.getLeaves();
        Integer[] expected = new Integer[]{2, 3, 4, 5, 6, 7, 8, 9};
        assertArrayEquals(expected, leaves.get(0).available.toArray());
    }

    @Test
    public void testHitFinder() {
        Predictor.Properties properties = new Predictor.Properties(Skill.DEFENCE, true, true, 1.375d);
        Predictor.Hit hit = Predictor.findHit(18, properties);
        assertEquals(13, hit.hit);
        assertTrue(hit.possibleBxp);
        assertTrue(hit.bxp);

        Predictor.Hit hit2 = Predictor.findHit(16, properties);
        assertEquals(12, hit2.hit);
        assertTrue(hit2.possibleBxp);
        assertFalse(hit2.bxp);

        Predictor.Hit hit3 = Predictor.findHit(103, properties);
        assertEquals(75, hit3.hit);
        assertFalse(hit3.possibleBxp);
        assertFalse(hit3.bxp);
    }

    @Test
    public void testPredictor() {
        double scaling = 1.21533203125d;
        // List of fixed precision integers

        final int iterations = 100;
        Predictor.Properties props = new Predictor.Properties(Skill.DEFENCE, true, true, scaling);
        runIterations(props, iterations);
    }

    private void runIterations(Predictor.Properties properties, int iterations) {
        int internalFrac = 9;
        List<Integer> possibleDrops = IntStream.rangeClosed(0, 100) // 100 is just a high number
                .map(n -> Predictor.computePrecise(n, properties))
                .boxed().collect(Collectors.toList());
        int[] n = new int[iterations];

        for (int i = 0; i < iterations; i++) {
            Predictor predictor = new Predictor();
            int count = 0;
            while (!predictor.isAccurate(Skill.DEFENCE)) {
                int idx = ThreadLocalRandom.current().nextInt(0, 84);
                //int idx = hits[i++];
                int xp = possibleDrops.get(idx);
                boolean wrapped = ((xp % 10) + internalFrac) >= 10;
                xp += wrapped ? 10 : 0;

                internalFrac = (internalFrac + xp) % 10;
                System.out.println("internal: " + internalFrac + " hit: " + idx + " xp: " + xp +" wrapped: " + wrapped);
                int predicted = predictor.treePredict(xp / 10, properties);
                count++;
            }
            n[i] = count;
            assertEquals(internalFrac, predictor.roots.get(Skill.DEFENCE).getFrac());
        }
        Arrays.sort(n);
        int sum = 0;
        for(int i = 0; i < iterations; i++) {
            sum += n[i];
        }
        System.out.println("avg: " + sum / iterations + " median: " + n[iterations / 2]);
    }

    @Test
    public void testPredictorSmall() {
        PredictionTree root = new PredictionTree();
        root.nobxp = new PredictionTree();
        root.nobxp.available = new HashSet<>();
        root.nobxp.available.add(7);

        root.bxp = new PredictionTree();
        root.bxp.available = new HashSet<>();
        root.bxp.available.add(5);
        root.bxp.available.add(6);
        root.bxp.available.add(7);
        root.insertInto(85, new Predictor.Properties(Skill.DEFENCE, true, true, 1.375d));
    }

    @Test
    public void testPredictorFraction1() {
        double scaling = 1.375;
        Predictor predictor = new Predictor();
        Predictor.Properties properties = new Predictor.Properties(Skill.DEFENCE, true, true, scaling);
        int[] drops = new int[]{108, 7, 18, 35, 71, 94, 15, 86};
        for (int drop : drops) {
            predictor.treePredict(drop, properties);
        }
        assertEquals(1, predictor.roots.get(Skill.DEFENCE).getFrac());
    }
}

package com.example;

import com.example.enemydata.Enemy;
import com.example.enemydata.ampken.*;
import com.example.enemydata.het.Akkha;
import com.example.enemydata.scabaras.Kephri;
import com.example.enemydata.scabaras.Kephri721;
import com.example.enemydata.scabaras.Spitter;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import org.junit.Test;

import javax.annotation.Nullable;
import java.awt.*;
import java.awt.image.BufferedImage;

import static org.junit.Assert.*;

class TestNPC implements NPC {
    int id;
    public TestNPC(int id) {
        this.id = id;
    }
    @Override
    public int getId() {
        return id;
    }

    @Override
    public String getName() {
        return null;
    }

    @Override
    public WorldView getWorldView() {
        return null;
    }
    @Override
    public boolean isInteracting() {
        return false;
    }

    @Override
    public Actor getInteracting() {
        return null;
    }

    @Override
    public int getHealthRatio() {
        return 0;
    }

    @Override
    public int getHealthScale() {
        return 0;
    }

    @Override
    public WorldPoint getWorldLocation() {
        return null;
    }

    @Override
    public LocalPoint getLocalLocation() {
        return null;
    }

    @Override
    public int getOrientation() {
        return 0;
    }

    @Override
    public int getCurrentOrientation() {
        return 0;
    }

    @Override
    public int getAnimation() {
        return 0;
    }

    @Override
    public int getPoseAnimation() {
        return 0;
    }

    @Override
    public void setPoseAnimation(int animation) {

    }

    @Override
    public int getPoseAnimationFrame() {
        return 0;
    }

    @Override
    public void setPoseAnimationFrame(int frame) {

    }

    @Override
    public int getIdlePoseAnimation() {
        return 0;
    }

    @Override
    public void setIdlePoseAnimation(int animation) {

    }

    @Override
    public int getIdleRotateLeft() {
        return 0;
    }

    @Override
    public void setIdleRotateLeft(int animationID) {

    }

    @Override
    public int getIdleRotateRight() {
        return 0;
    }

    @Override
    public void setIdleRotateRight(int animationID) {

    }

    @Override
    public int getWalkAnimation() {
        return 0;
    }

    @Override
    public void setWalkAnimation(int animationID) {

    }

    @Override
    public int getWalkRotateLeft() {
        return 0;
    }

    @Override
    public void setWalkRotateLeft(int animationID) {

    }

    @Override
    public int getWalkRotateRight() {
        return 0;
    }

    @Override
    public void setWalkRotateRight(int animationID) {

    }

    @Override
    public int getWalkRotate180() {
        return 0;
    }

    @Override
    public void setWalkRotate180(int animationID) {

    }

    @Override
    public int getRunAnimation() {
        return 0;
    }

    @Override
    public void setRunAnimation(int animationID) {

    }

    @Override
    public void setAnimation(int animation) {

    }

    @Override
    public int getAnimationFrame() {
        return 0;
    }

    @Override
    public void setActionFrame(int frame) {

    }

    @Override
    public void setAnimationFrame(int frame) {

    }

    @Override
    public IterableHashTable<ActorSpotAnim> getSpotAnims() {
        return null;
    }

    @Override
    public boolean hasSpotAnim(int spotAnimId) {
        return false;
    }

    @Override
    public void createSpotAnim(int id, int spotAnimId, int height, int delay) {

    }

    @Override
    public void removeSpotAnim(int id) {

    }

    @Override
    public void clearSpotAnims() {

    }

    @Override
    public int getGraphic() {
        return 0;
    }

    @Override
    public void setGraphic(int graphic) {

    }

    @Override
    public int getGraphicHeight() {
        return 0;
    }

    @Override
    public void setGraphicHeight(int height) {

    }

    @Override
    public int getSpotAnimFrame() {
        return 0;
    }

    @Override
    public void setSpotAnimFrame(int spotAnimFrame) {

    }

    @Override
    public Polygon getCanvasTilePoly() {
        return null;
    }

    @Nullable
    @Override
    public net.runelite.api.Point getCanvasTextLocation(Graphics2D graphics, String text, int zOffset) {
        return null;
    }

    @Override
    public net.runelite.api.Point getCanvasImageLocation(BufferedImage image, int zOffset) {
        return null;
    }

    @Override
    public net.runelite.api.Point getCanvasSpriteLocation(SpritePixels sprite, int zOffset) {
        return null;
    }

    @Override
    public Point getMinimapLocation() {
        return null;
    }

    @Override
    public int getLogicalHeight() {
        return 0;
    }

    @Override
    public Shape getConvexHull() {
        return null;
    }


    @Override
    public WorldArea getWorldArea() {
        return null;
    }

    @Override
    public String getOverheadText() {
        return null;
    }

    @Override
    public void setOverheadText(String overheadText) {

    }

    @Override
    public int getOverheadCycle() {
        return 0;
    }

    @Override
    public void setOverheadCycle(int cycles) {

    }

    @Override
    public boolean isDead() {
        return false;
    }

    @Override
    public void setDead(boolean dead) {

    }

    @Override
    public int getCombatLevel() {
        return 0;
    }

    @Override
    public int getIndex() {
        return 0;
    }

    @Override
    public NPCComposition getComposition() {
        return null;
    }

    @Nullable
    @Override
    public NPCComposition getTransformedComposition() {
        return null;
    }

    @Nullable
    @Override
    public NpcOverrides getModelOverrides() {
        return null;
    }

    @Nullable
    @Override
    public NpcOverrides getChatheadOverrides() {
        return null;
    }

    @Override
    public Model getModel() {
        return null;
    }

    @Override
    public int getModelHeight() {
        return 0;
    }

    @Override
    public void setModelHeight(int modelHeight) {

    }


    @Override
    public Node getNext() {
        return null;
    }

    @Override
    public Node getPrevious() {
        return null;
    }

    @Override
    public long getHash() {
        return 0;
    }
}
public class ScalingTests {
    private static final float delta = 0.00000001F;
    @Test
    public void testThrowerScaling() {
        TestNPC npc = new TestNPC(NpcID.BABOON_THROWER);
        Thrower thrower = new Thrower(npc, 515, 1, 2);
        assertEquals(1.0, thrower.getModifier(), delta);
        npc = new TestNPC(NpcID.BABOON_THROWER_11713);
        thrower = new Thrower(npc, 515, 1, 2);
        assertEquals(1.0, thrower.getModifier(), delta);
    }

    @Test
    public void testMageScaling() {
        TestNPC npc = new TestNPC(NpcID.BABOON_MAGE);
        Mage mage = new Mage(npc, 515, 1, 2);
        assertEquals(12, mage.getScaledHealth());
        assertEquals(1.1, mage.getModifier(), delta);
        npc = new TestNPC(NpcID.BABOON_MAGE_11714);
        mage = new Mage(npc, 515, 1, 2);
        assertEquals(1.175, mage.getModifier(), delta);
    }

    @Test
    public void testBrawlerScaling() {
        TestNPC npc = new TestNPC(NpcID.BABOON_BRAWLER);
        Brawler brawler = new Brawler(npc, 515, 1, 2);
        assertEquals(1.1, brawler.getModifier(), delta);
        npc = new TestNPC(NpcID.BABOON_BRAWLER_11712);
        brawler = new Brawler(npc, 515, 1, 2);
        assertEquals(1.175, brawler.getModifier(), delta);
    }

    @Test
    public void testMiscAmpkenScaling() {
        TestNPC shamanNpc = new TestNPC(NpcID.BABOON_SHAMAN);
        Shaman shaman = new Shaman(shamanNpc, 515, 1, 2);
        assertEquals(1.2, shaman.getModifier(), delta);

        TestNPC cursedNPC = new TestNPC(NpcID.CURSED_BABOON);
        Cursed cursed = new Cursed(cursedNPC, 515, 1, 2);
        assertEquals(1.175, cursed.getModifier(), delta);

        TestNPC thrallNPC = new TestNPC(NpcID.BABOON_THRALL);
        Thrall thrall = new Thrall(thrallNPC, 515, 1, 2);
        assertEquals(1.0, thrall.getModifier(), delta);

        TestNPC volatileNPC = new TestNPC(NpcID.VOLATILE_BABOON);
        Volatile vola = new Volatile(volatileNPC, 515, 1, 2);
        assertEquals(1.175, vola.getModifier(), delta);
    }

    @Test
    public void spitterScalingTest() {
        TestNPC spitterNpc = new TestNPC(NpcID.SPITTING_SCARAB);
        Spitter spitter = new Spitter(spitterNpc, 305, 1, 0);
        assertEquals(1.025, spitter.getModifier(), delta);

        TestNPC kephriNpc = new TestNPC(NpcID.KEPHRI);
        Kephri kephri = new Kephri(kephriNpc, 305, 1, 0);
        assertEquals(1.075, kephri.getModifier(), delta);
        assertEquals(330, kephri.getScaledHealth());

        TestNPC kephri721Npc = new TestNPC(NpcID.KEPHRI);
        Kephri721 kephri721 = new Kephri721(kephri721Npc, 305, 1, 0);
        assertEquals(180, kephri721.getScaledHealth());
        assertEquals(1.025, kephri721.getModifier(), delta);
    }

    @Test
    public void akkhaScalingTest() {
        TestNPC akkhaNpc = new TestNPC(NpcID.AKKHA_11790);
        Enemy akkha = new Akkha(akkhaNpc, 305, 2, 0);
        assertEquals(1.575, akkha.getModifier(), delta);
        akkha.fixupStats(305, 2, 0);
        assertEquals(1.575, akkha.getModifier(), delta);
    }
}

package com.example;

import net.runelite.api.Skill;
import org.junit.Test;

import java.util.List;
import java.util.Properties;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class PredictorTests {

    private int calibrate(Predictor predictor, List<Integer> possibleDrops, Predictor.Properties properties, int internalFrac) {
        while (!predictor.isAccurate(properties.skill)) {
            int hit = ThreadLocalRandom.current().nextInt(0, 84);
            //int hit = hits[i++];
            int xp = possibleDrops.get(hit);
            boolean wrapped = ((xp % 10) + internalFrac) >= 10;
            xp += wrapped ? 10 : 0;

            internalFrac = (internalFrac + xp) % 10;
            System.out.println("internal: " + internalFrac + " hit: " + hit + " xp: " + xp +" wrapped: " + wrapped);
            // We don't care about uncalibrated hits
            int predicted = predictor.treePredict(xp / 10, properties);
            // Make sure that when calibrating, we won't estimate higher
            assertTrue(predicted <= hit);
        }
        return internalFrac;
    }

    private void runIterations(Predictor predictor, int iterations, List<Integer> possibleDrops, Predictor.Properties properties, int internalFrac) {
        for (int i = 0; i < iterations; i++) {
            int hit = ThreadLocalRandom.current().nextInt(0, 84);
            int xp = possibleDrops.get(hit);
            boolean wrapped = ((xp % 10) + internalFrac) >= 10;
            xp += wrapped ? 10 : 0;

            internalFrac = (internalFrac + xp) % 10;
            int predicted = predictor.treePredict(xp / 10, properties);
            System.out.println("internal: " + internalFrac + " hit(" + properties.skill.getName() + "): " + hit + " predicted: " + predicted + " xp: " + xp +" wrapped: " + wrapped);
            System.out.println();
            assertEquals(hit, predicted);
        }
    }

    private void runTest(Predictor.Properties properties, int iterations, int internalFrac) {
        Predictor predictor = new Predictor();
        List<Integer> possibleDrops = IntStream.rangeClosed(0, 100)
                .map(n -> Predictor.computePrecise(n, properties))
                .boxed().collect(Collectors.toList());
        internalFrac = calibrate(predictor, possibleDrops, properties, internalFrac);

        runIterations(predictor, iterations, possibleDrops, properties, internalFrac);
    }
    @Test
    public void testPredictor() {
        double scaling = 1.21533203125d;
        int internalFrac = 9;
        int iterations = 1000;
        Predictor.Properties properties;
        properties = new Predictor.Properties(Skill.DEFENCE, true, true, scaling);
        runTest(properties, iterations, internalFrac);
        properties = new Predictor.Properties(Skill.STRENGTH, false, false, scaling);
        runTest(properties, iterations, internalFrac);
        properties = new Predictor.Properties(Skill.ATTACK, false, false, scaling);
        runTest(properties, iterations, internalFrac);
        properties = new Predictor.Properties(Skill.MAGIC, false, true, scaling);
        runTest(properties, iterations, internalFrac);
    }

    @Test
    public void testXpCalc() {
        double scaling = 1.375d;
        int hit = 10;
        Predictor.Properties properties = new Predictor.Properties(Skill.MAGIC, true, true, scaling);
        assertEquals(183, Predictor.computePrecise(hit, properties));
        properties.skill = Skill.DEFENCE;
        assertEquals(137, Predictor.computePrecise(hit, properties));
    }

    @Test
    public void testPredictorMultipleStyles() {
        double scaling = 1.21533203125d;
        int mfrac = 9;
        int dfrac = 3;
        int iterations = 1000;
        Predictor predictor = new Predictor();

        Predictor.Properties magicxp = new Predictor.Properties(Skill.MAGIC, true, true, scaling);
        Predictor.Properties defxp = new Predictor.Properties(Skill.DEFENCE, true, true, scaling);
        List<Integer> validMagic = IntStream.rangeClosed(0, 100)
                .map(hit -> Predictor.computePrecise(hit, magicxp))
                .boxed()
                .collect(Collectors.toList());
        List<Integer> validDef = IntStream.rangeClosed(0, 100)
                .map(hit -> Predictor.computePrecise(hit, defxp))
                .boxed()
                .collect(Collectors.toList());

        while (!predictor.isAccurate(Skill.MAGIC) || !predictor.isAccurate(Skill.DEFENCE)) {
            int hit = ThreadLocalRandom.current().nextInt(0, 84);
            //int hit = hits[i++];
            int mxp = validMagic.get(hit);
            int dxp = validDef.get(hit);
            boolean mwrapped = ((mxp % 10) + mfrac) >= 10;
            boolean dwrapped = ((dxp % 10) + dfrac) >= 10;
            mxp += mwrapped ? 10 : 0;
            dxp += dwrapped ? 10 : 0;
            mfrac = (mfrac + mxp) % 10;
            dfrac = (dfrac + dxp) % 10;
            int mpredict = predictor.treePredict(mxp / 10, magicxp);
            int dpredict = predictor.treePredict(dxp / 10, defxp);
            System.out.println("mfrac: " + mfrac + " dfrac: " + dfrac +
                    " hit: " + hit + " mpredict: " + mpredict + " dpredict: " + dpredict +
                    " mxp(" + mwrapped + "): " + mxp + " dxp(" + dwrapped + "): " + dxp);
            System.out.println();
            //assertEquals(mpredict, dpredict);
            assertTrue(hit >= mpredict);
        }
        System.out.println("*** CALIBRATED " + predictor.isAccurate(Skill.MAGIC) + " " + predictor.isAccurate(Skill.DEFENCE) +" ***");
        assertEquals(mfrac, predictor.roots.get(Skill.MAGIC).getFrac());
        assertEquals(dfrac, predictor.roots.get(Skill.DEFENCE).getFrac());

        for (int i = 0; i < iterations; i++) {
            int hit = ThreadLocalRandom.current().nextInt(0, 84);
            //int hit = hits[i++];
            int mxp = validMagic.get(hit);
            int dxp = validDef.get(hit);
            boolean mwrapped = ((mxp % 10) + mfrac) >= 10;
            boolean dwrapped = ((dxp % 10) + dfrac) >= 10;
            mxp += mwrapped ? 10 : 0;
            dxp += dwrapped ? 10 : 0;

            mfrac = (mfrac + mxp) % 10;
            dfrac = (dfrac + dxp) % 10;
            assertEquals(hit, predictor.treePredict(mxp / 10, magicxp));
            assertEquals(hit, predictor.treePredict(dxp / 10, defxp));
        }
    }

    @Test
    public void preciseCalcTests() {
        double scaling = 1.125d;
        Predictor.Properties properties = new Predictor.Properties(Skill.MAGIC, true, true, scaling);
        int precise = Predictor.computePrecise(23, properties);
        assertEquals(345, precise);
        precise = Predictor.computePrecise(10, properties);
        assertEquals(150, precise);
    }

    @Test
    public void preciseCursedBaboonTests() {
        double scaling = 1.15d;
        Predictor.Properties properties = new Predictor.Properties(Skill.MAGIC, false, true, scaling);
        int precise = Predictor.computePrecise(10, properties);
        assertEquals(230, precise);
    }

    @Test
    public void predictor1() {
        Predictor predictor = new Predictor();

    }
}

package com.example;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(AkkhaPredictor.class);
		RuneLite.main(args);
	}
}
