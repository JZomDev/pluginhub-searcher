package com.example.utils;

public interface QuadFunction<S, T, U, V, R> {
    R apply(S s, T t, U u, V v);
}

package com.example.utils;

import com.google.gson.annotations.SerializedName;
import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Computes the internal fraction of a skill
 *
 * <p>
 * It works in the following way:
 * 1. Receive xp drop
 * 2. Look at current possible values (initially 0-9)
 * 3. Branch into once or twice, some xp drops are only possible to receive with the "extra" xp
 * 4. Adjust the filters, for example if you have the filters 0-3 and you receive 22 xp,
 *    this means that it has to be a 21.8 drop because the next hit would be 23.0. This means we
 *    can adjust the filters by 8 and remove any value that didn't wrap, so our new filters would be 8-9
 *    (previously 0-1)
 * 5. goto 1.
 * </p>
 */
@Slf4j
public class PredictionTree {
    /**
     * For debugging purposes
     */
    @SerializedName("xp")
    public int xp;

    public int damage;
    @SerializedName("properties")
    public Predictor.Properties properties;

    public PredictionTree nobxp;

    public PredictionTree bxp;

    /**
     * Set of active filters for the node
     */
    public Set<Integer> available;

    /**
     * Marks whether this is a valid leaf anymore
     */
    public boolean dead = false;

    /**
     * Used to create root.
     */
    public PredictionTree() { }
    public static PredictionTree createRoot() {
        PredictionTree root = new PredictionTree();
        root.available = IntStream.rangeClosed(0, 9).boxed().collect(Collectors.toSet());
        return root;
    }

    @Override
    public String toString() {
        return available.toString();
    }

    public int getFrac() {
        List<PredictionTree> leaves = getLeaves(this);
        if (leaves.size() != 1) {
            // Should always be possible to determine
            return -2;
        }

        PredictionTree leaf = leaves.get(0);
        if (leaf.available.size() != 1) {
            return -1;
        }
        return getFrac(leaf);
    }

    public static int getFrac(PredictionTree leaf) {
        assert (leaf.available.size() == 1);
        return leaf.available.stream().findFirst().get();
    }

    private PredictionTree(int xp, Predictor.Properties properties) {
        this.xp = xp;
        this.properties = properties;
        this.damage = 0;
    }

    private PredictionTree createBxp(Set<Integer> avail, int preciseXp, int xp, Predictor.Properties properties) {
        final int frac = preciseXp % 10;
        Set<Integer> newAvail = avail.stream().filter(n -> n + frac >= 10).map(n -> (n + frac) % 10).collect(Collectors.toSet());
        if (newAvail.isEmpty()) {
            return null;
        }
        PredictionTree node = new PredictionTree(xp, properties);
        node.available = newAvail;
        return node;
    }

    private PredictionTree createNoBxp(Set<Integer> avail, int preciseXp, int xp, Predictor.Properties properties) {
        final int frac = preciseXp % 10;
        Set<Integer> newAvail = avail.stream().filter(n -> n + frac < 10).map(n -> (n + frac) % 10).collect(Collectors.toSet());
        if (newAvail.isEmpty()) {
            return null;
        }
        PredictionTree node = new PredictionTree(xp, properties);
        node.available = newAvail;
        return node;
    }

    public void insertInto(int xp, Predictor.Properties properties) {
        if (xp == 0) {
            return;
        }
        // TODO: should this just be passed into the function?
        Predictor.Hit hit = Predictor.findHit(xp, properties);

        List<PredictionTree> leaves = getLeaves(this);

        //log.info("XP(" + properties.skill.getName() + ", " + properties.scaling + "): " + xp + "xp hit: "+ hit.hit +
        //        " leaves: " + leaves.size() + " true xp(-1): " + Predictor.computePrecise(hit.hit-1, properties) / 10d +
        //        " true xp: " + Predictor.computePrecise(hit.hit, properties) / 10d +
        //        " true xp(+1): " + Predictor.computePrecise(hit.hit + 1, properties) / 10d +
        //        " target: " + (properties.npc != null ? properties.npc.getName() + "(idx: " + properties.npc.getIndex() + " ID: " + properties.npc.getId() + ")" : "") + "\n---");
        if (leaves.isEmpty()) {
            log.debug("Leaves are empty");
        }

        int precise;
        for(PredictionTree leaf : leaves) {
            Set<Integer> avail = leaf.available;
            //System.out.println("Current guesses: " + avail);
            assert (!avail.isEmpty()); // should never be empty, something is wrong
            int phigh = Predictor.computePrecise(hit.hit, properties);
            int plow = Predictor.computePrecise(hit.hit-1, properties);
            int high = phigh / 10;
            int low = plow / 10;

            if(avail.size() == 1) {
                // When we get to this situation, say we have a 9 here and then
                // we receive a 20 xp drop. This can be either a 19.2 or a 20.6.
                // But now we have what we believe is the fraction, so we check;
                // lets say that the fraction is 9.
                // 20.6 + 9 = 21, we go over the drop so it has to be 19.2
                precise = Predictor.computePrecise(hit.hit, properties);
                boolean correct = (getFrac(leaf) + precise) / 10 == xp;
                if (!correct) {
                    precise = Predictor.computePrecise(hit.hit-1, properties);
                }

                if ((precise + getFrac(leaf)) / 10 != xp) {
                    leaf.dead = true;
                    log.debug("dead leaf");
                    continue;
                }
                final int finalFrac = precise % 10;
                leaf.available = avail.stream()
                        .map(n -> (n + finalFrac) % 10)
                        .collect(Collectors.toSet());

                //log.info("Frac: " + leaf);

                continue;
            }


            // branch on the higher hit
            if (high == xp) {
                leaf.nobxp = createNoBxp(avail, phigh, xp, properties);
                //log.info("Creating nbxp high (" + phigh / 10d +") " + leaf.nobxp);
            } else if (high + 1 == xp) {
                leaf.bxp = createBxp(avail, phigh, xp, properties);
                //log.info("Creating bxp high (" + phigh / 10d +") " + leaf.bxp);
            }

            // branch on the lower hit
            if (low == xp) {
                leaf.nobxp = createNoBxp(avail, plow, xp, properties);
                //log.info("Creating nbxp low (" + plow / 10d + ") " + leaf.nobxp);
            } else if (low != 0 && low + 1 == xp) {
                leaf.bxp = createBxp(avail, plow, xp, properties);
                //log.info("Creating bxp low (" + plow / 10d + ") " + leaf.bxp);
            }
            leaf.dead = leaf.bxp == null && leaf.nobxp == null;
        }
    }


    /**
     * Finds all the leaves of a tree using depth first search
     * @param tree root of tree
     * @return List of leaves
     */
    public static List<PredictionTree> getLeaves(PredictionTree tree) {
        List<PredictionTree> nodes = new ArrayList<>();
        Deque<PredictionTree> stack = new ArrayDeque<>();
        stack.push(tree);

        while (!stack.isEmpty()) {
            PredictionTree node = stack.pop();

            if (isLeaf(node)) {
                nodes.add(node);
                continue;
            }
            if (node.bxp != null) {
                stack.add(node.bxp);
            }
            if (node.nobxp != null) {
                stack.add(node.nobxp);
            }
        }
        return nodes;
    }

    /**
     * DFS for the tree.
     * TODO: should this be removed, seems to only have been used for the automatic test generatio that was removed.
     * @param root root of tree
     * @return list of nodes with no leaves
     */
    private static List<PredictionTree> findDeepestPath(PredictionTree root) {
        List<PredictionTree> deepestPath = new ArrayList<>();
        findDeepestPathHelper(root, new ArrayList<>(), deepestPath);
        return deepestPath;
    }

    private static void findDeepestPathHelper(PredictionTree node, List<PredictionTree> currentPath, List<PredictionTree> deepestPath) {
        if (node == null) return;

        currentPath.add(node);

        if (isLeaf(node)) {
            // Leaf node, check if this path is deeper
            if (currentPath.size() > deepestPath.size()) {
                deepestPath.clear();
                deepestPath.addAll(currentPath);
            }
        } else {
            // Recur for both children
            findDeepestPathHelper(node.nobxp, currentPath, deepestPath);
            findDeepestPathHelper(node.bxp, currentPath, deepestPath);
        }

        currentPath.remove(currentPath.size() - 1); // Backtrack
    }

    public List<PredictionTree> getLeaves() {
        return PredictionTree.getLeaves(this);
    }

    public static boolean isLeaf(PredictionTree tree) {
        return tree.nobxp == null && tree.bxp == null && !tree.dead;
    }

    /**
     * Places damage dealt into the tree and marks paths that are impossible as dead, additionally fixes fractions.
     * @param damage
     */
    public void retroFit(int damage) {

    }
}

package com.example.utils;

public interface PentFunction<S, T, U, V, W, X> {
    X apply(S s, T t, U u, V v, W w);
}

package com.example.utils;

import com.example.AkkhaPredictorConfig;
import com.example.enemydata.Enemy;
import com.example.events.EntityDamaged;
import com.example.raids.Cox;
import com.example.raids.Toa;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.party.PartyMember;
import net.runelite.client.party.PartyService;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * Damage handler manages the damaging of enemies, the raid classes places and removes enemies from here.
 */
@Singleton
@Slf4j
public class DamageHandler {
    @Getter
    private final ConcurrentMap<Integer, Enemy> activeEnemies = new ConcurrentHashMap<>();

    @Getter
    private final Predictor predictor = new Predictor();

    @Inject
    private Client client;

    @Inject
    ClientThread clientThread;

    // We need to use the instanced one because getVarbitValue requires it to run on the clientThread
    @Inject
    Cox cox;

    @Inject
    private PartyService party;

    @Inject
    private AkkhaPredictorConfig config;
    /**
     * Map of current XP amounts in each skill
     */
    private Map<Skill, Integer> previousXps;

    private final Set<Skill> validSkills = Set.of(Skill.HITPOINTS);

    private static final Set<Integer> POWERED_STAVES = new HashSet<>(Arrays.asList(
            ItemID.SANGUINESTI_STAFF,
            ItemID.TRIDENT_OF_THE_SEAS_FULL,
            ItemID.TRIDENT_OF_THE_SEAS,
            ItemID.TRIDENT_OF_THE_SWAMP,
            ItemID.TRIDENT_OF_THE_SWAMP_E,
            ItemID.HOLY_SANGUINESTI_STAFF,
            ItemID.TUMEKENS_SHADOW,
            ItemID.CORRUPTED_TUMEKENS_SHADOW,
            ItemID.VOIDWAKER
    ));
    private static final Set<Integer> CHINCHOMPAS = Set.of(
            ItemID.CHINCHOMPA_10033,
            ItemID.BLACK_CHINCHOMPA,
            ItemID.RED_CHINCHOMPA);


    public void initXpMap() {
        previousXps = new HashMap<>();
        Arrays.stream(Skill.values()).forEach(skill -> previousXps.put(skill, client.getSkillExperience(skill)));
    }

    public boolean shouldProcess() {
        return Toa.isAtToa(client) || cox.getCachedInCox().get();
    }

    @Subscribe
    protected void onGameStateChanged(GameStateChanged gamestate) {
        if (gamestate == null) {
            return;
        }
        GameState state = Objects.requireNonNull(gamestate.getGameState());
        switch (state) {
            case LOGGED_IN:
                initXpMap();
                break;

            case CONNECTION_LOST:
                break; // no-op

            default:
                activeEnemies.clear();
                break;
        }
    }

    /**
     * Processes the xp drop and turns it into how much damage it did. Not entirely accurate due to fractional XP.
     * Rounds down so that in case it does get fractional it should not give false positives.
     *
     * @param skill Skill that xp was received in.
     * @param xp Amount of XP that was received.
     */
    private void processXpDrop(Skill skill, int xp) {
        if (!validSkills.contains(skill)) {
            return;
        }

        Player player = Objects.requireNonNull(client.getLocalPlayer());
        Actor entity = player.getInteracting();
        if (!(entity instanceof NPC) || !shouldProcess()) {
            return;
        }

        PlayerComposition playerComposition = player.getPlayerComposition();
        NPC npc = (NPC) entity;
        int id = npc.getId();

        if (Enemy.blacklist.contains(id)) {
            predictor.reset();
            // We actually always receive range xp, perhaps this can be used to
            // calculate the magic xp, as you seem to always receive .3 xp from swarms
            return;
        }

        Enemy enemy;
        if (activeEnemies.containsKey(npc.getIndex())) {
            enemy = activeEnemies.get(npc.getIndex());
        } else {
            //System.out.println("Unknown enemy \"" + npc.getName() + "\": " + npc.getId() + " (idx: " + npc.getIndex() + ")");
            return;
        }

        int bossHealth = client.getVarbitValue(Varbits.BOSS_HEALTH_CURRENT);
        if (bossHealth > 0 && Enemy.bosses.contains(npc.getId())) {
            enemy.current_health = bossHealth; // re-synchronize the health
        }

        int attackStyle = client.getVarpValue(VarPlayer.ATTACK_STYLE);
        int weapon = playerComposition.getEquipmentId(KitType.WEAPON);

        boolean isDefensiveCast = attackStyle == 3;
        boolean isPoweredStaff = POWERED_STAVES.contains(weapon);
        boolean isChinchompa = CHINCHOMPAS.contains(weapon);
        double scaling = enemy.getModifier();
        Predictor.Properties props = new Predictor.Properties(skill, isDefensiveCast, isPoweredStaff, npc, scaling);
        if ((skill == Skill.RANGED || skill == Skill.MAGIC) && isDefensiveCast) {
            // Ignore in order to not double hit, insert the drop into
            // the tree in order to track the fraction
            predictor.insertInto(xp, scaling, props);
            return;
        }

        int damage;
        if (config.experimentalHitPrediction()) {
            damage = predictor.treePredict2(xp, props);
        } else {
            damage = predictor.treePredict(xp, props);
        }

        if (!Toa.isAtToa(client)) {
            // TODO: figure out a better way to do this
            predictor.reset();
        }

        assert (damage >= 0);
        if (isChinchompa) {
            // TODO: barrage? prio: low, tldr: check for barrage animation
            handleAoe(props, damage);
        } else {
            sendDamage(player, damage);
        }
    }

    private void handleAoe(Predictor.Properties properties, int damage) {
        NPC npc = properties.npc;
        List<Enemy> nearby = activeEnemies.values().stream()
                .filter(enemy -> npc.getWorldLocation().distanceTo(enemy.getNpc().getWorldLocation()) <= 1)
                .collect(Collectors.toList());

        if (nearby.stream().anyMatch(e -> npc.getId() != e.getNpc().getId())) {
            predictor.reset(); // can't determine how much each npc was damaged, reset instead
        }

        final int clumpHp = nearby.stream().mapToInt(Enemy::getCurrent_health).sum();
        if (damage >= clumpHp) {
            sendClumpDamage(nearby);
        }
    }

    private void sendClumpDamage(List<Enemy> enemies) {
        for (Enemy enemy : enemies) {
            final int npcIndex = enemy.getNpc().getIndex();
            final EntityDamaged ev = new EntityDamaged(npcIndex, enemy.getCurrent_health());
            if (party.isInParty()) {
                clientThread.invokeLater(() -> party.send(ev));
            }
            onEntityDamaged(ev);
        }
    }

    private void sendDamage(Player player, int damage) {
        if (damage <= 0) {
            return;
        }

        NPC npc = (NPC) player.getInteracting();

        final int npcIndex = npc.getIndex();
        final EntityDamaged entityDamaged = new EntityDamaged(npcIndex, damage);

        if (party.isInParty()) {
            clientThread.invokeLater(() -> party.send(entityDamaged));
        }
        onEntityDamaged(entityDamaged);
    }

    /**
     * Computes the difference between the updated xp drop and the previous one
     * @param skill Skill XP was received in.
     * @param xp Updated XP amount.
     */
    private void preProcessXpDrop(Skill skill, int xp) {
        if (!shouldProcess()) {
            predictor.reset();
            return;
        }

        int diff = xp - previousXps.getOrDefault(skill, 0);
        previousXps.put(skill, xp);
        processXpDrop(skill, diff);
    }

    /**
     * Queues damage on an entity. If the entity is a shadow, it hides the shadow.
     * If the entity is Akkha, it will highlight her.
     * @param entityDamaged event
     */
    @Subscribe
    public void onEntityDamaged(EntityDamaged entityDamaged) {
        if (!shouldProcess()) {
            return;
        }

        PartyMember localPlayer = party.getLocalMember();

        if (localPlayer != null) {
            if (localPlayer.getMemberId() == entityDamaged.getMemberId()) {
                return; // Don't process your own events
            }
        }

        Integer npcIndex = entityDamaged.getNpcIndex();
        Enemy enemy = activeEnemies.getOrDefault(npcIndex, null);
        if (enemy != null) {
            enemy.queueDamage(entityDamaged.getDamage());
        }
    }

    @Subscribe
    public void onStatChanged(StatChanged xpDrop) {
        preProcessXpDrop(xpDrop.getSkill(), xpDrop.getXp());
    }

    @Subscribe
    public void onFakeXpDrop(FakeXpDrop xpDrop) {
        //TODO hopefully this works. I don't have 200m in magic to find out.
        processXpDrop(xpDrop.getSkill(), xpDrop.getXp());
    }

    /**
     * Removes the hit from queued damage.
     * @param hit hitsplat
     */
    @Subscribe
    public void onHitsplatApplied(HitsplatApplied hit) {
        Hitsplat hitsplat = hit.getHitsplat();
        if (!shouldProcess() || hitsplat.getHitsplatType() == HitsplatID.HEAL || hitsplat.getAmount() <= 0) {
            return;
        }
        Actor actor = hit.getActor();
        if (actor instanceof NPC) {
            NPC npc = (NPC) actor;
            Enemy enemy = activeEnemies.getOrDefault(npc.getIndex(), null);
            if (enemy == null) {
                //log.info("Unknown target: " + npc.getId() + " index: " + npc.getIndex());
                return;
            }

            int amount = hitsplat.getAmount();
            int hp = enemy.hit(amount);
            //log.info("Damage: " + amount + " " + hit.getActor().getName() + " (" + hp +")");
        }
    }
}

package com.example.utils;

import lombok.AllArgsConstructor;
import lombok.NonNull;
import net.runelite.api.NPC;
import net.runelite.api.Skill;

import java.util.*;

/**
 * Class for computing the internal fraction in xp.
 */
public class Predictor {
    Map<Skill, PredictionTree> roots;

    @AllArgsConstructor
    public static class Properties {
        public Skill skill;
        public boolean isDefensive;
        public boolean isPoweredStaff;
        public NPC npc;
        public double scaling;


        public Properties(Skill skill, boolean isDefensive, boolean isPowered, double scaling) {
            this.skill = skill;
            this.isDefensive = isDefensive;
            this.isPoweredStaff = isPowered;
            this.scaling = scaling;
        }
        // TODO: add scaling here?
    }

    public Predictor() {
        roots = new HashMap<>();
    }

    @Deprecated
    public Predictor(double scaling) {
        this();
    }

    @AllArgsConstructor
    public static class Hit {
        public final int hit;
        /**
         * Could be bxp, a case where there both exists for example a 17 xp drop
         * and a 16 xp drop.
         */
        public final boolean possibleBxp;
        /**
         * It must be bxp, e.g. if you've received 18 xp, and it's
         * not possible to receive it without doing 17 + 1.
         */
        public boolean bxp;
    }

    /**
     * Resets all skill prediction trees.
     */
    public void reset() {
        roots.clear();
    }

    /**
     * Finds the hit that most closely represents the xp drop.
     * @param xp amount of xp received
     * @param properties
     * @return Upper bound for the hit.
     */
    public static Hit findHit(int xp, Properties properties) {
        boolean possibleBxp = false;
        boolean bxp = false;
        int hit;
        // 200 is a high number, will cover all the possible hits,
        // perhaps one day I'll make it compute the real max hit...
        // Today is not that day.
        for (hit = 0; hit <= 200; hit++) {
            int drop = computeDrop(hit, properties);
            if (drop > xp) {
                hit--;
                bxp = true;
                break;
            }

            if (drop == xp) {
                break;
            }

            int precise = computePrecise(hit, properties);
            // Check if xp + 1 is the real xp
            possibleBxp = (drop + 1) == xp && precise % 10 != 0;
        }

        return new Hit(hit, possibleBxp, bxp);
    }


    /**
     * Computes the "Jagex" xp drop, i.e. removes the fraction
     * @param precise precise xp drop
     * @return xp drop without a fraction
     */
    public static int convertToJagexDrop(int precise) {
        return precise / 10;
    }

    /**
     * Computes the precise xp drop as a fixed length integer
     * <a href="https://oldschool.runescape.wiki/w/Combat#Experience_gain">OSRS Wiki</a>
     * @param hit Damage dealt
     * @param props Skill that the xp was received in
     * @return A fixed length integer for how much xp was received.
     */
    public static int computePrecise(int hit, Properties props) {
        int scaling = (int) (props.scaling * 1000); // make it an integer that gets scaled down
        int precise = 0;
        switch (props.skill) {
            // TODO: should this be removed in it's entirety?
            case DEFENCE:
                if (props.isPoweredStaff && props.isDefensive) {
                    precise = (int) (hit * 10 * scaling);
                } else {
                    // you receive 4xp per damage with melee
                    precise = (int) (hit * 10 * 4 * scaling);
                }
                break;
            case MAGIC:
                if (props.isPoweredStaff && !props.isDefensive) {
                    precise = (int) (hit * 2 * 10 * scaling);
                } else if (props.isPoweredStaff) {
                    precise = (int) (hit * 10 * 4 / 3.0d * scaling);
                }
                // TODO spells
                break;
            case ATTACK:
            case STRENGTH:
            case RANGED:
                precise = (int) (hit * 10 * 4 * scaling);
                break;

            case HITPOINTS:
                precise = (int) (hit * 10 * 4 * scaling / 3);
                break;
        }
        return precise / 1000;
    }

    /**
     * Computes the xp amount received in the way that OSRS shows it to the user.
     *
     * @param hit Damage dealt
     * @param properties Properties of the xp drop
     * @return An integer that has been rounded down to represent the xp.
     */
    public static int computeDrop(int hit, Properties properties) {
        return computePrecise(hit, properties) / 10;
    }

    /**
     * Checks if the tree for a skill is accurate or not. The tree
     * is accurate if there's only one leaf that is not dead in the tree.
     * @param skill skill to check
     * @return true if accurate, false if not
     */
    public boolean isAccurate(Skill skill) {
        PredictionTree root = roots.getOrDefault(skill, null);
        if (root == null) {
            return false;
        }
        int frac = root.getFrac();
        return frac >= 0;
    }

    public boolean isDead(Skill skill) {
        PredictionTree root = roots.getOrDefault(skill, null);
        if (root == null) {
            return false;
        }
        int frac = root.getFrac();
        return frac == -2;
    }

    /**
     * Inserts an xp node into the prediction tree.
     *
     * @param xp amount of xp received
     * @param scaling scaling of the monster attacked
     * @param props properties related to attack
     */
    public void insertInto(int xp, double scaling, @NonNull Properties props) {
        if (!roots.containsKey(props.skill)) {
            roots.put(props.skill, PredictionTree.createRoot());
        }
        PredictionTree root = roots.get(props.skill);
        root.insertInto(xp, props);
    }

    /**
     * Predicts a hit, if the tree isn't accurate it falls back to primitive methods.
     * @param xp xp received
     * @param props properties of the hit
     * @return expected hit
     */
    public int treePredict(int xp, @NonNull Properties props) {
        if (!roots.containsKey(props.skill)) {
            roots.put(props.skill, PredictionTree.createRoot());
        }
        PredictionTree root = roots.get(props.skill);
        int frac = root.getFrac();
        root.insertInto(xp, props);
        Hit hit = findHit(xp, props);

        int next = computePrecise(hit.hit + 1, props);
        int high = computePrecise(hit.hit, props);
        int low = computePrecise(hit.hit-1, props);

        if (frac != -1) {
            if ((high + frac) / 10 == xp) {
                return hit.hit;
            }
            if ((low + frac) / 10 == xp) {
                return hit.hit-1;
            }
        }
        // if the xp drops do not overlap, check which one matches the given drop, otherwise fall back
        // to where the low hit is returned.
        if (high / 10 != low / 10) {
            boolean overlapping = (high / 10 == xp && (high / 10 - 1) != low / 10);
            int rethit = overlapping ? hit.hit : hit.hit - 1;
            if (low / 10 > 0 && rethit < 1) {
                rethit++;
            }
            return Math.max(rethit, 0);
        }

        // If the next xp drop is further than 1 xp off, we can lazily check if it wrapped or not
        if ((high / 10 + 1) == xp && (next / 10) != xp) {
            return hit.hit;
        }

        // We have to always take hit-1 because low hits have overlapping xpdrops
        // it's worse if we say that the mob died and it didn't
        return Math.max(hit.hit-1, 1);
    }


    /**
     * Experimental tree prediction, hopefully more maintainable and better.
     * @param xp
     * @param props
     * @return
     */
    public int treePredict2(int xp, @NonNull Properties props) {
        if (!roots.containsKey(props.skill)) {
            roots.put(props.skill, PredictionTree.createRoot());
        }
        PredictionTree root = roots.get(props.skill);
        int frac = root.getFrac();
        root.insertInto(xp, props);
        Hit hit = findHit(xp, props);

        int high = computePrecise(hit.hit, props);
        int low = computePrecise(hit.hit-1, props);

        if (frac != -1) {
            high += frac;
            low += frac;
        }
        // if the xp drops do not overlap, check which one matches the given drop, otherwise fall back
        // to where the low hit is returned.
        if (convertToJagexDrop(high) != convertToJagexDrop(low)) {
            if (convertToJagexDrop(high) == xp) {
                return hit.hit;
            }
        }

        // We have to always take hit-1 because low hits have overlapping xpdrops
        // it's worse if we say that the mob died and it didn't
        return Math.max(hit.hit-1, 1);
    }
}

package com.example;

import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

import java.awt.*;

@ConfigGroup("raid-death-indicator")
public interface AkkhaPredictorConfig extends Config
{
    @Alpha
    @ConfigItem(
            keyName = "highlightColor",
            name = "Highlight color",
            description = ""
    )
    default Color highlightColor() {
        return new Color(98, 174, 253, 64);
    }

    @Alpha
    @ConfigItem(
            keyName = "textColor",
            name = "Text color",
            description = ""
    )
    default Color textColor() {
        return new Color(98, 174, 253, 64);
    }

    @ConfigItem(
            keyName = "maxHp",
            name = "Max HP",
            description = "Max HP in CoX, affects scales"
    )
    default int maxHp() {
        return 99;
    }

    @ConfigItem(
            keyName = "showStatus",
            name = "Show predictor status",
            description = "Show or hide the box in top left"
    )
    default boolean status() {
        return true;
    }

    @ConfigItem(
            keyName = "isCm",
            name = "Challenge mode",
            description = "To use challenge mode stats or not."
    )
    default boolean isCM() {
        return true;
    }

    @ConfigItem(
            keyName = "enableCox",
            name = "Enable cox (experimental)",
            description = ""
    )
    default boolean enableCox() {
        return true;
    }

    @ConfigItem(
            keyName = "enableExperimentalHitPrediction",
            name = "Hit prediction (experimental)",
            description = ""
    )
    default boolean experimentalHitPrediction() {
        return false;
    }

    @ConfigItem(
            keyName = "enableHpOverlay",
            name = "Enable HP overlay",
            description = "Draws the tracked health on the boss, please use this when reporting bugs"
    )
    default boolean enableHpOverlay() {
        return false;
    }


}

package com.example.enemydata.cox;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;

@Slf4j
public class SkeletalMystic extends CoxEnemy {
    public SkeletalMystic(NPC npc, boolean isCm, int partySize, int maxCombat, int maxHp) {
        super(npc, isCm, partySize, maxCombat, maxHp, 160, 140, 187, 85, 50, 155, 155, 115);
    }

    @Override
    public boolean queueDamage(int damage) {
        shouldDraw = super.queueDamage(damage);

        log.debug("current hp: {} queued damage: {} should draw: {}", current_health, queuedDamage, shouldDraw);
        return shouldDraw;
    }

}

package com.example.enemydata.cox;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;

@Slf4j
public class Portal extends CoxEnemy {
    public Portal(NPC npc, boolean isCm, int partySize, int maxCombat, int maxHp) {
        super(npc, isCm, partySize, maxCombat, maxHp, 250, 1, 176, 0, 0, 0, 0, 0);
    }

    @Override
    public boolean queueDamage(int damage) {
        shouldDraw = super.queueDamage(damage);
        log.debug("current hp: {} queued damage: {} should draw: {}", current_health, queuedDamage, shouldDraw);
        return shouldDraw;
    }

    @Override
    public double getModifier() {
        return 1.0d;
    }
}

package com.example.enemydata.cox;

import com.example.enemydata.Enemy;
import com.example.utils.PentFunction;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class CoxEnemy extends Enemy {
    public static final Map<Integer, PentFunction<NPC, Boolean, Integer, Integer, Integer, CoxEnemy>> enemies;
    public static final Set<Integer> bosses;

    boolean isCm;
    int partySize;
    int maxHp;

    static {
        enemies = new HashMap<>();
        bosses = new HashSet<>();

        enemies.put(NpcID.ABYSSAL_PORTAL, Portal::new);
        enemies.put(NpcID.SKELETAL_MYSTIC, SkeletalMystic::new);
        enemies.put(NpcID.SKELETAL_MYSTIC_7605, SkeletalMystic::new);
        enemies.put(NpcID.SKELETAL_MYSTIC_7606, SkeletalMystic::new);
        enemies.put(NpcID.LIZARDMAN_SHAMAN_7573, LizardmanShaman::new);
        enemies.put(NpcID.LIZARDMAN_SHAMAN_7574, LizardmanShaman::new);
        enemies.put(NpcID.ROCKS_7565, VasaNistirio::new);
        enemies.put(NpcID.GREAT_OLM_RIGHT_CLAW, OlmMageHand::new);
        enemies.put(NpcID.GREAT_OLM_RIGHT_CLAW_7553, OlmMageHand::new);
    }

    protected CoxEnemy(NPC npc, boolean isCm, int partySize, int maxCombat, int maxHp, int baseHealth, int melee, int def, int offAtt, int offStr, int defStab, int defSlash, int defCrush) {
        super(npc, baseHealth, melee, melee, def, offAtt, offStr, defStab, defSlash, defCrush);
        assert (attack == str);
        this.isCm = isCm;
        this.partySize = partySize;
        this.maxHp = maxHp;

        this.scaled_health = this.getScaledHealth(baseHealth, maxCombat, partySize);
        this.current_health = scaled_health;
        int scaledDef = getScaledDefence(def, partySize, maxHp);
        this.def = scaledDef;
        int scaledMelee = getScaledOffence(melee, partySize, maxHp);
        this.str = scaledMelee;
        this.attack = scaledMelee;
    }

    protected int getScaledDefence(int baseDef, int partySize, int maxHp) {
        return baseDef * (maxHp * 4 / 9 + 55) / 99 * ((int) Math.sqrt(partySize - 1) + (partySize - 1) * 7 / 10 + 100) / 100 * (isCm ? 3 : 2) / 2;
    }

    protected int getScaledOffence(int baseStat, int partySize, int maxHp) {
        return baseStat * (maxHp * 4 / 9 + 55) / 99 * ((int) Math.sqrt(partySize - 1) * 7 + (partySize - 1) + 100) / 100 * (isCm ? 3 : 2) / 2;
    }

    // TODO: override for olm
    protected int getScaledHealth(int baseHp, int maxCombat, int partySize) {
        int combatHpScale = (int) ((maxCombat / 126.0) * baseHp);
        int partyHpScale = (1 + (partySize / 2)) * combatHpScale;

        if (isCm) {
            partyHpScale = partyHpScale * 3 / 2;
        }
        return partyHpScale;
    }
}

package com.example.enemydata.cox;

import net.runelite.api.NPC;

public class OlmMageHand extends CoxEnemy {
    public OlmMageHand(NPC npc, boolean isCm, int partySize, int maxCombat, int maxHp) {
        super(npc, isCm, partySize, maxCombat, maxHp, 600, 250, 175, 0, 0, 200, 200, 200);
    }

    @Override
    protected int getScaledHealth(int baseHp, int maxCombat, int partySize) {
        return 300 * (partySize - partySize / 8 * 3 + 1);
    }

    @Override
    protected int getScaledDefence(int baseDef, int partySize, int maxHp) {
        return baseDef * ((int) Math.sqrt(partySize - 1) + (partySize - 1) * 7 / 10 + 100) / 100 * (isCm ? 3 : 2) / 2;
    }

    @Override
    protected int getScaledOffence(int baseStat, int partySize, int maxHp) {
        return baseStat * ((int) Math.sqrt(partySize - 1) * 7 + (partySize - 1) + 100) / 100 * (isCm ? 3 : 2) / 2;
    }

    @Override
    public boolean queueDamage(int damage) {
        shouldDraw = super.queueDamage(damage);
        //System.out.println("queued damage: " + queuedDamage + " hp: " + current_health);
        return shouldDraw;
    }

    @Override
    public double getModifier() {
        return 1.0d;
    }
}

package com.example.enemydata.cox;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;

@Slf4j
public class LizardmanShaman extends CoxEnemy {
    public LizardmanShaman(NPC npc, boolean isCm, int partySize, int maxCombat, int maxHp) {
        super(npc, isCm, partySize, maxCombat, maxHp, 190, 130, 210, 58, 52, 102, 160, 150);
    }

    @Override
    public boolean queueDamage(int damage) {
        shouldDraw = super.queueDamage(damage);
        log.debug("current hp: {} queued damage: {} should draw: {}", current_health, queuedDamage, shouldDraw);
        return shouldDraw;
    }

}

package com.example.enemydata.cox;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;

@Slf4j
public class VasaNistirio extends CoxEnemy {
    public VasaNistirio(NPC npc, boolean isCm, int partySize, int maxCombat, int maxHp) {
        super(npc, isCm, partySize, maxCombat, maxHp, 300, 1, 175, 0, 0, 170, 190, 50);
    }

    @Override
    public boolean queueDamage(int damage) {
        shouldDraw = super.queueDamage(damage);
        log.debug("current hp: {} queued damage: {} should draw: {}", current_health, queuedDamage, shouldDraw);
        return shouldDraw;
    }

}

package com.example.enemydata.toa.het;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class AkkhaShadow extends ToaEnemy {
    public AkkhaShadow(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                70, 100, 140, 30,
                115, 30,
                60, 120, 120);
        if (scaled_health > 100)
        {
            final int roundTo = scaled_health > 300 ? 10 : 5;
            // Shadow does not work like akkha, it uses the rounded health in the xp modifier
            scaled_health = ((scaled_health + (roundTo / 2)) / roundTo) * roundTo;
            current_health = scaled_health;
        }
        hideOnDeath = false;
    }

    @Override
    public void fixupStats(int invo, int partySize, int pathLevel) {
        super.fixupStats(invo, partySize, pathLevel);
        if (scaled_health > 100)
        {
            final int roundTo = scaled_health > 300 ? 10 : 5;
            scaled_health = ((scaled_health + (roundTo / 2)) / roundTo) * roundTo;
            current_health = scaled_health;
        }
    }

    @Override
    public synchronized boolean queueDamage(int damage) {
        shouldDraw = super.queueDamage(damage);
        return shouldDraw;
    }
}

package com.example.enemydata.toa.het;

import com.example.enemydata.toa.ToaEnemy;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;

@Slf4j
@Getter
@Setter
@Accessors(fluent = true)
public class Akkha extends ToaEnemy {
    private boolean canPhase;

    public Akkha(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                400, 100, 140, 80,
                115, 30,
                60, 120, 120);
        canPhase = false;
        // scale to nearest 10, leave scaled health as is, xp modifier is computed using the "real" hp
        current_health = (int) (Math.round(scaled_health / 10.0) * 10);
        hideOnDeath = false;
    }

    @Override
    public boolean queueDamage(int damage) {
        super.queueDamage(damage);
        int queuedDamage = getQueuedDamage();

        final int max_health = (int) (Math.round(scaled_health / 10.0) * 10);
        final int phase_health = max_health / 5;
        // compute what the threshold for the next phase is
        final int next_phase = (current_health / phase_health) * phase_health;
        // This causes her to be highlighted a few hits post shadow, can't fix due to veng being able to overkill too
        shouldDraw = current_health != next_phase && (current_health - queuedDamage) <= next_phase;
        //log.info("Akkha: current " + current_health + " queued " + queuedDamage + " next phase: " + next_phase + " draw: " + shouldDraw);
        return shouldDraw;
    }

    @Override
    public void fixupStats(int invo, int partySize, int pathLevel) {
        super.fixupStats(invo, partySize, pathLevel);
        current_health = (int) (Math.round(scaled_health / 10.0) * 10);
    }

    /**
     * Check if the npc id is Akkha. This is required due to the memory special making Akkha disappear and
     * "dies".
     * @param id NPC id
     * @return true if it's Akkha, false otherwise
     */
    public static boolean isAkkha(int id) {
        return id == NpcID.AKKHA_11790 || id == NpcID.AKKHA_11791 || id == NpcID.AKKHA_11792 || id == NpcID.AKKHA_11793;
    }
}

package com.example.enemydata.toa.scabaras;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Kephri extends ToaEnemy {
    // TODO: might need extra handling due to shield? Probably just to ignore the damage queueing
    public Kephri(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                150, 0, 0, 80,
                0, 0,
                60, 300, 100);
        scaled_health = (int) (Math.round(scaled_health / 10.0) * 10);
        current_health = scaled_health;
        hideOnDeath = false;
    }

    @Override
    public void fixupStats(int invo, int partySize, int pathLevel) {
        super.fixupStats(invo, partySize, pathLevel);
        scaled_health = (int) (Math.round(scaled_health / 10.0) * 10);
        current_health = scaled_health;
    }

    /**
     * Disable for kephri, no use for it either way. If requested, can try to fix.
     * @param damage damage dealt
     * @return false
     */
    @Override
    public boolean queueDamage(int damage) {
        return false;
    }
}

package com.example.enemydata.toa.scabaras;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Kephri721 extends ToaEnemy {
    public Kephri721(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                80, 0, 0, 80,
                0, 0,
                60, 300, 100);
        scaled_health = (int) (Math.round(scaled_health / 10.0) * 10);
        current_health = scaled_health;
    }

    @Override
    public void fixupStats(int invo, int partySize, int pathLevel) {
        super.fixupStats(invo, partySize, pathLevel);
        scaled_health = (int) (Math.round(scaled_health / 10.0) * 10);
        current_health = scaled_health;
    }
}

package com.example.enemydata.toa.scabaras;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Arcane extends ToaEnemy {
    public Arcane(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                40, 75, 80, 80,
                0, 55,
                15, 250, 30);
    }
}

package com.example.enemydata.toa.scabaras;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Spitter extends ToaEnemy {
    public Spitter(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                40, 1, 80, 80,
                0, 55,
                15, 250, 30);
    }

}

package com.example.enemydata.toa.scabaras;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Scarab extends ToaEnemy {
    public Scarab(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                12, 20, 32, 28,
                0, 0,
                0, 0, 0);
    }

}

package com.example.enemydata.toa.scabaras;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Soldier extends ToaEnemy {
    public Soldier(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                40, 75, 80, 80,
                100, 55,
                15, 250, 30);
    }
}

package com.example.enemydata.toa.scabaras;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class AgileScarab extends ToaEnemy {
    public AgileScarab(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                30, 60, 20, 5,
                0, 25,
                0, 0, 0, true);
    }
}

package com.example.enemydata.toa.scabaras;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class EmptyEgg extends ToaEnemy {
    public EmptyEgg(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                35, 0, 0, 80,
                0, 0,
                60, 300, 100);
    }
}

package com.example.enemydata.toa.scabaras;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Swarm extends ToaEnemy {
    public Swarm(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                10, 1, 1, 0,
                0, 0,
                -100, -100, -100);
    }
}

package com.example.enemydata.toa.wardens;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class ElidinisWarden extends ToaEnemy {
    public ElidinisWarden(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                140, 300, 150, 100,
                0, 10,
                70, 70, 70);
    }
}

package com.example.enemydata.toa.wardens;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Obelisk extends ToaEnemy {
    public Obelisk(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                260, 200, 150, 100,
                0, 0,
                70, 70, 70);
    }
}

package com.example.enemydata.toa.wardens;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class TumekensWarden762 extends ToaEnemy {

    public TumekensWarden762(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                880, 150, 150, 150,
                0, 40,
                40, 40, 20);
    }
}

package com.example.enemydata.toa.wardens;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class TumekensWarden extends ToaEnemy {
    public TumekensWarden(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                140, 300, 150, 100,
                0, 25,
                70, 70, 70);
    }
}

package com.example.enemydata.toa.wardens;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class ElidinisWarden761 extends ToaEnemy {
    public ElidinisWarden761(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                880, 150, 150, 150,
                0, 40,
                40, 40, 20);
    }
}

package com.example.enemydata.toa;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ampken.*;
import com.example.enemydata.toa.crondis.Crocodile;
import com.example.enemydata.toa.crondis.Zebak;
import com.example.enemydata.toa.het.Akkha;
import com.example.enemydata.toa.het.AkkhaShadow;
import com.example.enemydata.toa.scabaras.*;
import com.example.enemydata.toa.wardens.*;
import com.example.utils.QuadFunction;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;

import java.util.HashMap;
import java.util.Map;

public class ToaEnemy extends Enemy {
    public static final Map<Integer, QuadFunction<NPC, Integer, Integer, Integer, Enemy>> enemies;
    private static final Map<Integer, Double> teamScaling;
    private static final Map<Integer, Double> pathScaling;

    protected final boolean isPuzzle;
    public int invocation;
    public int partySize;
    public int pathLevel;

    static {
        teamScaling = new HashMap<>();
        teamScaling.put(1, 1.0);
        teamScaling.put(2, 1.9);
        teamScaling.put(3, 2.8);
        teamScaling.put(4, 3.4);
        teamScaling.put(5, 4.0);
        teamScaling.put(6, 4.6);
        teamScaling.put(7, 5.2);
        teamScaling.put(8, 5.8);

        pathScaling = new HashMap<>();
        pathScaling.put(0, 1.0);
        pathScaling.put(1, 1.08);
        pathScaling.put(2, 1.13);
        pathScaling.put(3, 1.18);
        pathScaling.put(4, 1.23);
        pathScaling.put(5, 1.28);
        pathScaling.put(6, 1.33);

        enemies = new HashMap<>();
        enemies.put(NpcID.AKKHA, Akkha::new);
        enemies.put(NpcID.AKKHA_11790, Akkha::new);
        enemies.put(NpcID.AKKHA_11791, Akkha::new);
        enemies.put(NpcID.AKKHA_11792, Akkha::new);
        enemies.put(NpcID.AKKHA_11793, Akkha::new);
        enemies.put(NpcID.AKKHA_11794, Akkha::new);
        enemies.put(NpcID.AKKHA_11795, Akkha::new);
        enemies.put(NpcID.AKKHA_11796, Akkha::new);

        enemies.put(NpcID.AKKHAS_SHADOW, AkkhaShadow::new);

        enemies.put(NpcID.BABA, Baba::new);
        enemies.put(NpcID.BABA_11779, Baba::new);
        enemies.put(NpcID.BABA_11780, Baba::new);
        enemies.put(NpcID.BABOON, Baboon::new);
        enemies.put(NpcID.BOULDER_11782, Boulder::new);
        enemies.put(NpcID.BOULDER_11783, Boulder::new);

        enemies.put(NpcID.KEPHRI, Kephri::new);
        enemies.put(NpcID.KEPHRI_11721, Kephri721::new);
        enemies.put(NpcID.AGILE_SCARAB, AgileScarab::new);
        enemies.put(NpcID.ARCANE_SCARAB, Arcane::new);
        enemies.put(NpcID.SCARAB, Scarab::new);
        enemies.put(NpcID.SOLDIER_SCARAB, Soldier::new);
        enemies.put(NpcID.SPITTING_SCARAB, Spitter::new);
        // enemies.put(NpcID.SCARAB_SWARM_11723, Swarm::new);

        enemies.put(NpcID.ZEBAK_11730, Zebak::new);
        enemies.put(NpcID.ZEBAK_11732, Zebak::new);
        enemies.put(NpcID.CROCODILE_11705, Crocodile::new);
        // enemies.put(NpcID.JUG, Jug::new);
        // enemies.put(NpcID.JUG_11736, Jug::new);

        enemies.put(NpcID.BABOON_BRAWLER, Brawler::new);
        enemies.put(NpcID.BABOON_BRAWLER_11712, Brawler::new);
        enemies.put(NpcID.BABOON_THROWER, Thrower::new);
        enemies.put(NpcID.BABOON_THROWER_11713, Thrower::new);
        enemies.put(NpcID.BABOON_MAGE, Mage::new);
        enemies.put(NpcID.BABOON_MAGE_11714, Mage::new);
        enemies.put(NpcID.BABOON_THRALL, Thrall::new);
        enemies.put(NpcID.BABOON_SHAMAN, Shaman::new);
        enemies.put(NpcID.CURSED_BABOON, Cursed::new);
        enemies.put(NpcID.VOLATILE_BABOON, Volatile::new);

        enemies.put(NpcID.OBELISK_11751, Obelisk::new);
        // different overheads -> different ID
        enemies.put(NpcID.ELIDINIS_WARDEN_11753, ElidinisWarden::new);
        enemies.put(NpcID.ELIDINIS_WARDEN_11754, ElidinisWarden::new);
        enemies.put(NpcID.ELIDINIS_WARDEN_11761, ElidinisWarden761::new);
        // different overheads -> different ID
        enemies.put(NpcID.TUMEKENS_WARDEN_11756, TumekensWarden::new);
        enemies.put(NpcID.TUMEKENS_WARDEN_11757, TumekensWarden::new);
        enemies.put(NpcID.TUMEKENS_WARDEN_11762, TumekensWarden762::new);
    }

    public ToaEnemy(NPC npc, int invocation, int partySize, int pathLevel,
                    int baseHealth, int attack, int str, int def,
                    int offAtt, int offStr,
                    int defStab, int defSlash, int defCrush, boolean isPuzzle) {
        super(npc, baseHealth, attack, str, def, offAtt, offStr, defStab, defSlash, defCrush);
        assert(partySize <= 8 && partySize >= 1);
        assert((invocation % 5) == 0);

        this.isPuzzle = isPuzzle;
        this.shouldDraw = false;
        this.hideOnDeath = true;
        this.queuedDamage = 0;

        if (pathLevel >= 0) {
            this.invocation = invocation;
            this.partySize = partySize;
            this.pathLevel = pathLevel;
            this.scaled_health = getScaledHealth(invocation, partySize,
                    pathLevel, baseHealth, isPuzzle);
            this.current_health = this.scaled_health;
        }

    }
    public ToaEnemy(NPC npc, int invocation, int partySize, int pathLevel,
                    int baseHealth, int attack, int str, int def,
                    int offAtt, int offStr,
                    int defStab, int defSlash, int defCrush
    ) {
        this(npc, invocation, partySize, pathLevel,
                baseHealth, attack, str, def,
                offAtt, offStr,
                defStab, defSlash, defCrush, false);
    }

    private static int getScaledHealth(int invocation, int partySize, int pathLevel, int base_health, boolean isPuzzle) {
        double scale = (1 + 0.004 * invocation);
        double teamScale = teamScaling.get(partySize);
        double pathScale;
        if (isPuzzle) {
            pathScale = 1d;
            teamScale = 1d;
            scale = 1d;
        } else {
            pathScale = pathScaling.get(pathLevel);
        }

        return (int) (base_health * scale * teamScale * pathScale);
    }

    public void fixupStats(int invocation, int partySize, int pathLevel) {
        // Should only happen before any npcs actually have been damaged
        this.invocation = invocation;
        this.partySize = partySize;
        this.pathLevel = pathLevel;
        scaled_health = getScaledHealth(invocation, partySize, pathLevel, base_health, isPuzzle);
        current_health = scaled_health;
    }
}

package com.example.enemydata.toa.ampken;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.*;

public class Thrower extends ToaEnemy {
    public Thrower(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                npc.getId() == NpcID.BABOON_THROWER ? 30 : 35, npc.getId() == NpcID.BABOON_THROWER ? 40 : 60,
                npc.getId() == NpcID.BABOON_THROWER ? 40 : 60, npc.getId() == NpcID.BABOON_THROWER ? 12 : 20,
                npc.getId() == NpcID.BABOON_THROWER ? 20 : 25, 0,
                -50, -50, -50, true);
    }
}

package com.example.enemydata.toa.ampken;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Baboon extends ToaEnemy {
    // Baba baboon
    public Baboon(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                35, 0, 0, 50,
                0, 0,
                10, 50, 50, true);
    }
}

package com.example.enemydata.toa.ampken;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Volatile extends ToaEnemy {
    public Volatile(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                8, 60, 60, 20,
                25, 0,
                900, 900, 900, true);
    }
}

package com.example.enemydata.toa.ampken;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;

public class Mage extends ToaEnemy {
    public Mage(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                npc.getId() == NpcID.BABOON_MAGE ? 20 : 25, // health
                npc.getId() == NpcID.BABOON_MAGE ? 40 : 60, // attack
                npc.getId() == NpcID.BABOON_MAGE ? 40 : 60, // str
                npc.getId() == NpcID.BABOON_MAGE ? 12 : 20, // def
                npc.getId() == NpcID.BABOON_MAGE ? 20 : 25, // offatt
                0, 900, 900, 900, true);
    }
}

package com.example.enemydata.toa.ampken;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Cursed extends ToaEnemy {
    public Cursed(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                30, 60, 60, 20,
                25, 0,
                900, 900, 900, true);
    }
}

package com.example.enemydata.toa.ampken;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

import java.util.HashMap;
import java.util.Map;

public class Boulder extends ToaEnemy {
    // team size -> path level -> hp
    private static final int [][] hpMap = {
                    {25, 25, 27, 27, 31},
                    {36, 36, 39, 39, 45},
                    {47, 47, 51, 51, 58},
                    {55, 55, 60, 60, 68},
                    {62, 62, 68, 68, 77},
                    {70, 70, 77, 77, 87},
                    {77, 77, 84, 84, 96},
                    {85, 85, 93, 93, 106}
            };
    public Boulder(NPC npc, int invocation, int partySize, int pathLevel) {
        // TODO revisit this, seems that a new npc is spawned on phase?
        super(npc, invocation, partySize, pathLevel,
                hpMap[partySize-1][pathLevel], 0, 0, 0,
                0, 0,
                0, 0, 0, true);
    }
}

package com.example.enemydata.toa.ampken;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Shaman extends ToaEnemy {
    public Shaman(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                50, 60, 60, 20,
                25, 0,
                900, 900, 900, true);
    }
}

package com.example.enemydata.toa.ampken;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Thrall extends ToaEnemy {
    public Thrall(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                2, 40, 40, 12,
                20, 0,
                0, 0, 0, false); // HP does indeed seem to scale by invocation?
    }
}

package com.example.enemydata.toa.ampken;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Baba extends ToaEnemy {
    public Baba(NPC npc, int invocation, int partySize, int pathLevel) {
        // TODO revisit this, seems that a new npc is spawned on phase?
        super(npc, invocation, partySize, pathLevel,
                380, 150, 160, 80,
                0, 26,
                80, 160, 240);
    }
}

package com.example.enemydata.toa.ampken;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;

public class Brawler extends ToaEnemy {
    public Brawler(NPC npc, int invocation, int partySize, int pathLevel) {
        // For solo 380, this should likely be have a scaling of 1.12?
        super(npc, invocation, partySize, pathLevel,
                npc.getId() == NpcID.BABOON_BRAWLER ? 25 : 30, // health
                npc.getId() == NpcID.BABOON_BRAWLER ? 40 : 60, // att
                npc.getId() == NpcID.BABOON_BRAWLER ? 40 : 60, // str
                npc.getId() == NpcID.BABOON_BRAWLER ? 12 : 20, // def
                npc.getId() == NpcID.BABOON_BRAWLER ? 20 : 25, // offatt
                0, 900, 900, 900, true);
    }
}

package com.example.enemydata.toa.crondis;

import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Zebak extends ToaEnemy {
    public Zebak(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                580, 250, 140, 70,
                160, 100,
                160, 160, 260);
        hideOnDeath = false;
    }
}

package com.example.enemydata.toa.crondis;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Crocodile extends ToaEnemy {
    public Crocodile(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                30, 150, 60, 100,
                0, 100,
                150, 350, 350, true);
    }
}

package com.example.enemydata.toa.crondis;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import net.runelite.api.NPC;

public class Jug extends ToaEnemy {
    public Jug(NPC npc, int invocation, int partySize, int pathLevel) {
        super(npc, invocation, partySize, pathLevel,
                5, 0, 0, 0,
                0, 0,
                0, 0, 0);
    }
}

package com.example.enemydata;

import lombok.Getter;
import lombok.Setter;
import lombok.Synchronized;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;

import java.util.HashSet;
import java.util.Set;

@Slf4j
public abstract class Enemy implements IEnemy {
    public static final Set<Integer> blacklist = Set.of(NpcID.SCARAB_SWARM_11723, NpcID.JUG, NpcID.JUG_11736);
    public static final Set<Integer> bosses;

    @Getter(onMethod_ = {@Synchronized})
    @Setter(onMethod_ = {@Synchronized})
    public int queuedDamage;
    public boolean shouldDraw;
    protected boolean hideOnDeath;

    public final int base_health;
    // TODO: this may require some rework, akkha for example computes the xp modifier before rounding hp
    public int scaled_health;
    @Getter(onMethod_ = {@Synchronized})
    public int current_health;

    protected int attack;
    protected int str;
    protected int def;
    protected int offAtt;
    protected int offStr;
    protected int defStab;
    protected int defSlash;
    protected int defCrush;

    @Getter
    @Setter
    NPC npc;

    @Setter
    @Getter
    Client client;

    static {
        bosses = new HashSet<>();
        // Add the NpcID values to the Set
        bosses.add(NpcID.AKKHA);
        bosses.add(NpcID.AKKHA_11790);
        bosses.add(NpcID.AKKHA_11791);
        bosses.add(NpcID.AKKHA_11792);
        bosses.add(NpcID.AKKHA_11793);
        bosses.add(NpcID.AKKHA_11794);
        bosses.add(NpcID.AKKHA_11795);
        bosses.add(NpcID.AKKHA_11796);

        bosses.add(NpcID.BABA);
        bosses.add(NpcID.BABA_11779);
        bosses.add(NpcID.BABA_11780);

        bosses.add(NpcID.KEPHRI);
        bosses.add(NpcID.KEPHRI_11721);

        bosses.add(NpcID.ZEBAK_11730);
        bosses.add(NpcID.ZEBAK_11732);


        bosses.add(NpcID.OBELISK_11751);
        bosses.add(NpcID.ELIDINIS_WARDEN_11753);
        bosses.add(NpcID.ELIDINIS_WARDEN_11754);
        bosses.add(NpcID.ELIDINIS_WARDEN_11761);
        bosses.add(NpcID.TUMEKENS_WARDEN_11756);
        bosses.add(NpcID.TUMEKENS_WARDEN_11757);
        bosses.add(NpcID.TUMEKENS_WARDEN_11762);

        bosses.add(NpcID.ABYSSAL_PORTAL);
        bosses.add(NpcID.VASA_NISTIRIO);
        bosses.add(NpcID.GREAT_OLM_RIGHT_CLAW);
        bosses.add(NpcID.GREAT_OLM_RIGHT_CLAW_7553);
        // TODO: add vangs? might be worth adding an event to send the HP to other players too
    }

    protected Enemy(NPC npc, int baseHealth, int attack, int str, int def,
          int offAtt, int offStr,
          int defStab, int defSlash, int defCrush) {
        this.npc = npc;

        this.base_health = baseHealth;
        this.current_health = base_health;
        this.attack = attack;
        this.str = str;
        this.def = def;
        this.offAtt = offAtt;
        this.offStr = offStr;
        this.defStab = defStab;
        this.defSlash = defSlash;
        this.defCrush = defCrush;
        this.shouldDraw = false;
        this.hideOnDeath = false;
        this.queuedDamage = 0;
    }

    public void setCurrentHealth(int hp) {
        if (hp >= 0) {
            current_health = hp;
        }
    }

    public synchronized int hit(int damage) {
        queuedDamage = Math.max(0, queuedDamage - damage);
        current_health -= damage;
        return current_health;
    }

    /**
     * Queues damage and counts if the enemy will die to it.
     * @param damage damage dealt.
     * @return true if the mob died, false if not.
     */
    public synchronized boolean queueDamage(int damage) {
        queuedDamage += damage;
        boolean died = queuedDamage >= current_health;

        npc.setDead(died && hideOnDeath);
        return died;
    }

    public boolean shouldHighlight() {
        return shouldDraw;
    }

    public double getModifier() {
        double avgs = Math.floor((getAvgLevel() * (getAvgDef() + offStr + offAtt)) / 5120d);
        avgs /= 40d;
        return Math.max(1.0d, 1 + avgs);
    }

    public int getScaledHealth() {
        return scaled_health;
    }

    private int getAvgLevel() {
        return (attack + str + def + Math.min(getScaledHealth(), 2000)) / 4;
    }

    private int getAvgDef() {
        return (defStab + defSlash + defCrush) / 3;
    }

}

package com.example.enemydata;

public interface IEnemy {
    int hit(int damage);
}

package com.example.raids;

import net.runelite.api.gameval.*;
import com.example.AkkhaPredictorConfig;
import com.example.enemydata.*;
import com.example.enemydata.cox.CoxEnemy;
import com.example.utils.DamageHandler;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.hiscore.HiscoreClient;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.atomic.AtomicBoolean;

@Singleton
public class Cox {
    static class InternalVarbits {
        public static final int COX_CM = 6385;
        public static final int GROUP_SIZE = 9540;
    }

    @Inject
    private DamageHandler damageHandler;

    @Inject
    private Client client;

    @Inject
    private HiscoreClient hiscoreClient;

    @Inject
    private AkkhaPredictorConfig config;

    @Getter
    AtomicBoolean cachedInCox;

    boolean isCm;

    int groupSize;

    int maxCombat;

    int maxHp;

    @Inject
    public void initialize() {
        cachedInCox = new AtomicBoolean();
        cachedInCox.set(false);
        isCm = false;
        groupSize = 0;
        maxCombat = 0;
        maxHp = 0;
    }

    public static boolean isInCox(Client client) {
        int state = client.getVarbitValue(VarbitID.RAIDS_CLIENT_PROGRESS);
        return state >= 1 && state < 5;
    }

    public boolean isInCox() {
        return isInCox(client) && config.enableCox(); // TODO: find a better way to check if in cox
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged ev) {
        if (ev.getVarbitId() == VarbitID.RAIDS_CLIENT_PROGRESS) {
            if (ev.getValue() == 1) {
                // TODO: Do the CM check only as the party leader
                isCm = config.isCM();
                groupSize = client.getVarbitValue(VarbitID.RAIDS_CLIENT_PARTYSIZE);
                maxHp = config.maxHp();
                maxCombat = client.getServerVarbitValue(VarbitID.RAIDS_CLIENT_HIGHESTCOMBAT);
            }
            cachedInCox.set(ev.getValue() >= 1 && ev.getValue() < 5);
        }
    }

    @Subscribe
    public void onNpcDespawned(NpcDespawned ev) {
        if (!isInCox()) {
            return;
        }
        NPC npc = ev.getNpc();
        var activeEnemies = damageHandler.getActiveEnemies();
        //System.out.println(MessageFormat.format("NPC despawned \"{0}\": {1} {2}", npc.getName(), npc.getId(), npc.getIndex()));

        activeEnemies.remove(npc.getIndex());
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned ev) {
        if (!isInCox()) {
            return;
        }

        NPC npc = ev.getNpc();
        var enemyConstructor = CoxEnemy.enemies.getOrDefault(npc.getId(), null);
        if (enemyConstructor == null) {
            return;
        }
        //System.out.println(MessageFormat.format("NPC spawned \"{0}\": {1} {2}", npc.getName(), npc.getId(), npc.getIndex()));
        Enemy enemy = enemyConstructor.apply(npc, isCm, groupSize, maxCombat, maxHp);
        damageHandler.getActiveEnemies().put(npc.getIndex(), enemy);
    }
}

package com.example.raids;

import com.example.enemydata.Enemy;
import com.example.enemydata.toa.ToaEnemy;
import com.example.enemydata.toa.het.Akkha;
import com.example.utils.DamageHandler;
import com.example.utils.QuadFunction;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.*;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Arrays;

@Singleton
@Slf4j
public class Toa {
    @Inject
    private Client client;

    @Inject
    private DamageHandler damageHandler;

    public static boolean isAtToa(Client client) {
        final int []TOA_REGIONS = {
                13455, // Lobby
                14160, // Nexus

                15698, // Crondis
                15700, // Zebak

                14162, // Scabaras
                14164, // Kephri

                15186, // Apmken
                15188, // Baba

                14674, // Het
                14676, // Akkha

                //15184, // Wardens
                //15696, // Wardens

                //14672, // Tomb
        };

        return Arrays.stream(client.getTopLevelWorldView().getMapRegions()).anyMatch(current -> Arrays.stream(TOA_REGIONS).anyMatch(reg -> reg == current));
    }

    public boolean isAtToa() {
        return isAtToa(client);
    }

    /**
     * @return TOA invocation level
     */
    private int getInvocation() {
        return client.getVarbitValue(VarbitID.TOA_CLIENT_RAID_LEVEL);
    }

    /**
     * Fetches the path level from the TOA widget
     * @return Path level
     */
    private int getPathLevel() {
        Widget pathLevelWidget = client.getWidget(481, 45);
        if (pathLevelWidget == null) {
            return -1;
        }
        return Integer.parseInt(pathLevelWidget.getText());
    }

    /**
     * Gets amount of people in the raid, amount makes the enemy health scale with 90%
     * @return Amount of people in the raid
     */
    private int getPartySize()
    {
        int partySize = 1;
        for (int i = 1; i < 8; i++) {
            if (client.getVarbitValue(VarbitID.TOA_CLIENT_P0 + i) != 0) {
                partySize++;
            }
        }
        return partySize;
    }

    private boolean partyDead() {

        for (int i = VarbitID.TOA_CLIENT_P0; i <= VarbitID.TOA_CLIENT_P7; i++) {
            int value = client.getVarbitValue(i);
            if (value != 30 && value != 0) {
                return false;
            }
        }

        return true;
    }

    /**
     * Create the new Akkha object when the TOA path widget has loaded, we aren't able to get the path level otherwise.
     * @param event
     */
    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event) {
        // 481 is the TOA path/time/etc. widget
        if (event.getGroupId() != InterfaceID.TOA_RAID) {
            return;
        }
        int invo = getInvocation();
        int pathLevel = getPathLevel();
        int partySize = getPartySize();
        if (pathLevel < 0 || invo < 0 || partySize <= 0) {
            return;
        }
        for (Enemy enemy : damageHandler.getActiveEnemies().values()) {
            if (enemy instanceof ToaEnemy) {
                ToaEnemy e = (ToaEnemy) enemy;
                e.fixupStats(invo, partySize, pathLevel);
            }
        }
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        if (isAtToa() && partyDead()) {
            // TODO: does this need to be done each tick?
            damageHandler.getActiveEnemies().clear();
        }
    }

    @Subscribe
    protected void onNpcDespawned(NpcDespawned event) {
        if (!isAtToa()) {
            return; // only handle toa enemies
        }
        NPC npc = event.getNpc();
        boolean isAkkha = Akkha.isAkkha(npc.getId());
        boolean isPartyDead = partyDead();
        if (isAkkha && !isPartyDead) {
            return;
        }
        damageHandler.getActiveEnemies().remove(npc.getIndex());
    }

    @Subscribe
    protected void onNpcSpawned(NpcSpawned event) {
        if (!isAtToa()) {
            return;
        }
        var activeEnemies = damageHandler.getActiveEnemies();
        NPC npc = event.getNpc();
        if (activeEnemies.containsKey(npc.getIndex())) {
            Enemy enemy = activeEnemies.get(npc.getIndex());
            enemy.setNpc(npc);
            // Re-sync the health of the enemy (akkha) when it re-appears in case of hits during invuln
            // TODO should akkha be subscribed to the event bus?
            int newHealth = client.getVarbitValue(VarbitID.HPBAR_HUD_HP);
            enemy.setCurrentHealth(newHealth);
            enemy.setQueuedDamage(0);

            return;
        }

        QuadFunction<NPC, Integer, Integer, Integer, Enemy> constructor = ToaEnemy.enemies.getOrDefault(npc.getId(), null);
        if (constructor == null) {
            return;
        }

        Enemy enemy = constructor.apply(npc, getInvocation(), getPartySize(), getPathLevel());
        enemy.setClient(client);

        activeEnemies.put(npc.getIndex(), enemy);
    }
}

package com.example;

import com.example.enemydata.Enemy;
import com.example.raids.Toa;
import com.example.utils.DamageHandler;
import com.example.utils.Predictor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Point;
import net.runelite.api.Skill;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;

@Slf4j
public class AkkhaPredictorOverlay extends Overlay {
    @Inject
    private AkkhaPredictorConfig config;

    @Inject
    private Client client;

    @Inject
    private DamageHandler damageHandler;

    @Inject
    public void initialize() {
        setPosition(OverlayPosition.DYNAMIC);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        var enemies = damageHandler.getActiveEnemies();

        for (Enemy enemy : enemies.values()) {
            if (enemy.shouldHighlight()) {
                NPC npc = enemy.getNpc();
                renderPoly(graphics, null, 0, config.highlightColor(), npc.getConvexHull());
            }

            if (config.enableHpOverlay()) {
                String str = enemy.getCurrent_health() + " (" + enemy.getQueuedDamage() + ")";
                renderText(graphics, enemy.getNpc(), str, config.textColor());
            }
        }

        if (!Toa.isAtToa(client) || !config.status()) {
            return null;
        }

        Skill []skills = new Skill[]{Skill.HITPOINTS};
        int start = 20;
        Predictor predictor = damageHandler.getPredictor();

        for (Skill skill : skills) {
            if (predictor.isAccurate(skill)) {
                graphics.setColor(Color.green);
                graphics.fillRect(10, start, 10, 10);
            } else if (predictor.isDead(skill)) {
                graphics.setColor(Color.pink);
                graphics.fillRect(10, start, 10, 10);
            } else {
                graphics.setColor(Color.red);
                graphics.fillRect(10, start, 10, 10);
            }
            start += 20;
        }
        return null;
    }

    private void renderText(Graphics2D graphics, NPC npc, String str, Color c) {
        if (npc == null) {
            return;
        }
        Point p = npc.getCanvasTextLocation(graphics, str, npc.getLogicalHeight());
        if (p == null) {
            return;
        }

        p = new Point(p.getX(), p.getY() + 20);
        graphics.setFont(FontManager.getDefaultBoldFont());
        OverlayUtil.renderTextLocation(graphics, p, str, c);
    }

    private void renderPoly(Graphics2D graphics, Color borderColor, float borderWidth, Color fillColor, Shape polygon)
    {
        if (polygon != null)
        {
            graphics.setColor(borderColor);
            graphics.setStroke(new BasicStroke(borderWidth));
            graphics.draw(polygon);
            graphics.setColor(fillColor);
            graphics.fill(polygon);
        }
    }
}

package com.example.events;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

@Value
@EqualsAndHashCode(callSuper = true)
public class EntityDamaged extends PartyMemberMessage
{
    int npcIndex;
    int damage;
}


package com.example;

import com.example.events.EntityDamaged;
import com.example.raids.Cox;
import com.example.raids.Toa;
import com.example.utils.DamageHandler;
import com.google.inject.Provides;
import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.party.WSClient;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
	name = "Raid Death Indicator"
)
public class AkkhaPredictor extends Plugin {
	@Inject
	private AkkhaPredictorOverlay overlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private WSClient wsClient;

	@Inject
	private DamageHandler damageHandler;

	@Inject
	private Toa toa;

	@Inject
	private Cox cox;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Override
	protected void startUp() throws Exception
	{
		eventBus.register(damageHandler);
		eventBus.register(toa);
		eventBus.register(cox);
		clientThread.invoke(damageHandler::initXpMap);
		overlayManager.add(overlay);
		wsClient.registerMessage(EntityDamaged.class);
	}
	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
		eventBus.unregister(damageHandler);
		eventBus.unregister(toa);
		eventBus.unregister(cox);
		wsClient.unregisterMessage(EntityDamaged.class);
		damageHandler.getPredictor().reset();
	}

	@Provides
	AkkhaPredictorConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(AkkhaPredictorConfig.class);
	}
}

package com.example;

import com.example.enemydata.cox.SkeletalMystic;
import net.runelite.api.NpcID;
import org.junit.Test;

import static org.junit.Assert.*;

public class CoxScalingTests {
    private static final float delta = 0.00000001F;

    @Test
    public void testMysticScaling() {
        TestNPC npc = new TestNPC(NpcID.SKELETAL_MYSTIC);
        SkeletalMystic mystic = new SkeletalMystic(npc, true, 3, 126, 99);
        assertEquals(480, mystic.scaled_health);
    }
}

package com.example;

import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.awt.*;
import java.awt.image.BufferedImage;

class TestNPC implements NPC {
    int id;

    public TestNPC(int id) {
        this.id = id;
    }

    @Override
    public int getId() {
        return id;
    }

    @Override
    public String getName() {
        return null;
    }

    @Override
    public WorldView getWorldView() {
        return null;
    }

    @Override
    public boolean isInteracting() {
        return false;
    }

    @Override
    public Actor getInteracting() {
        return null;
    }

    @Override
    public int getHealthRatio() {
        return 0;
    }

    @Override
    public int getHealthScale() {
        return 0;
    }

    @Override
    public WorldPoint getWorldLocation() {
        return null;
    }

    @Override
    public LocalPoint getLocalLocation() {
        return null;
    }

    @Override
    public int getOrientation() {
        return 0;
    }

    @Override
    public int getCurrentOrientation() {
        return 0;
    }

    @Override
    public int getAnimation() {
        return 0;
    }

    @Override
    public int getPoseAnimation() {
        return 0;
    }

    @Override
    public void setPoseAnimation(int animation) {

    }

    @Override
    public int getPoseAnimationFrame() {
        return 0;
    }

    @Override
    public void setPoseAnimationFrame(int frame) {

    }

    @Override
    public int getIdlePoseAnimation() {
        return 0;
    }

    @Override
    public void setIdlePoseAnimation(int animation) {

    }

    @Override
    public int getIdleRotateLeft() {
        return 0;
    }

    @Override
    public void setIdleRotateLeft(int animationID) {

    }

    @Override
    public int getIdleRotateRight() {
        return 0;
    }

    @Override
    public void setIdleRotateRight(int animationID) {

    }

    @Override
    public int getWalkAnimation() {
        return 0;
    }

    @Override
    public void setWalkAnimation(int animationID) {

    }

    @Override
    public int getWalkRotateLeft() {
        return 0;
    }

    @Override
    public void setWalkRotateLeft(int animationID) {

    }

    @Override
    public int getWalkRotateRight() {
        return 0;
    }

    @Override
    public void setWalkRotateRight(int animationID) {

    }

    @Override
    public int getWalkRotate180() {
        return 0;
    }

    @Override
    public void setWalkRotate180(int animationID) {

    }

    @Override
    public int getRunAnimation() {
        return 0;
    }

    @Override
    public void setRunAnimation(int animationID) {

    }

    @Override
    public void setAnimation(int animation) {

    }

    @Override
    public int getAnimationFrame() {
        return 0;
    }

    @Override
    public void setActionFrame(int frame) {

    }

    @Override
    public void setAnimationFrame(int frame) {

    }

    @Override
    public IterableHashTable<ActorSpotAnim> getSpotAnims() {
        return null;
    }

    @Override
    public boolean hasSpotAnim(int spotAnimId) {
        return false;
    }

    @Override
    public void createSpotAnim(int id, int spotAnimId, int height, int delay) {

    }

    @Override
    public void removeSpotAnim(int id) {

    }

    @Override
    public void clearSpotAnims() {

    }

    @Override
    public int getGraphic() {
        return 0;
    }

    @Override
    public void setGraphic(int graphic) {

    }

    @Override
    public int getGraphicHeight() {
        return 0;
    }

    @Override
    public void setGraphicHeight(int height) {

    }

    @Override
    public int getSpotAnimFrame() {
        return 0;
    }

    @Override
    public void setSpotAnimFrame(int spotAnimFrame) {

    }

    @Override
    public Polygon getCanvasTilePoly() {
        return null;
    }

    @Nullable
    @Override
    public Point getCanvasTextLocation(Graphics2D graphics, String text, int zOffset) {
        return null;
    }

    @Override
    public Point getCanvasImageLocation(BufferedImage image, int zOffset) {
        return null;
    }

    @Override
    public Point getCanvasSpriteLocation(SpritePixels sprite, int zOffset) {
        return null;
    }

    @Override
    public Point getMinimapLocation() {
        return null;
    }

    @Override
    public int getLogicalHeight() {
        return 0;
    }

    @Override
    public Shape getConvexHull() {
        return null;
    }


    @Override
    public WorldArea getWorldArea() {
        return null;
    }

    @Override
    public String getOverheadText() {
        return null;
    }

    @Override
    public void setOverheadText(String overheadText) {

    }

    @Override
    public int getOverheadCycle() {
        return 0;
    }

    @Override
    public void setOverheadCycle(int cycles) {

    }

    @Override
    public boolean isDead() {
        return false;
    }

    @Override
    public void setDead(boolean dead) {

    }

    @Override
    public int getAnimationHeightOffset() {
        return 0;
    }

    @Override
    public int getCombatLevel() {
        return 0;
    }

    @Override
    public int getIndex() {
        return 0;
    }

    @Override
    public NPCComposition getComposition() {
        return null;
    }

    @Nullable
    @Override
    public NPCComposition getTransformedComposition() {
        return null;
    }

    @Nullable
    @Override
    public NpcOverrides getModelOverrides() {
        return null;
    }

    @Nullable
    @Override
    public NpcOverrides getChatheadOverrides() {
        return null;
    }

    @Nullable
    @Override
    public int[] getOverheadArchiveIds() {
        return new int[0];
    }

    @Nullable
    @Override
    public short[] getOverheadSpriteIds() {
        return new short[0];
    }

    @Override
    public Model getModel() {
        return null;
    }

    @Override
    public int getModelHeight() {
        return 0;
    }

    @Override
    public void setModelHeight(int modelHeight) {

    }


    @Override
    public Node getNext() {
        return null;
    }

    @Override
    public Node getPrevious() {
        return null;
    }

    @Override
    public long getHash() {
        return 0;
    }
}

package com.example;

import com.example.utils.PredictionTree;
import static org.junit.Assert.*;

import com.example.utils.Predictor;
import net.runelite.api.Skill;
import org.junit.Test;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class TreeTests {
    @Test
    public void testLeafFinding() {
        PredictionTree root = new PredictionTree();
        root.available = new HashSet<>();
        root.available.add(8);
        root.bxp = new PredictionTree();
        root.bxp.available = new HashSet<>();
        root.bxp.available.add(9);

        root.bxp.bxp = new PredictionTree();
        root.bxp.bxp.available = new HashSet<>();
        root.bxp.bxp.available.add(1);

        root.bxp.nobxp = new PredictionTree();
        root.bxp.nobxp.available = new HashSet<>();
        root.bxp.nobxp.available.add(2);

        List<PredictionTree> leaves = PredictionTree.getLeaves(root);
        for (PredictionTree node : leaves) {
            assertTrue(PredictionTree.isLeaf(node));
            assertTrue(node.available.contains(1) || node.available.contains(2));
        }
    }

    @Test
    public void testInsertion() {
        PredictionTree root = PredictionTree.createRoot();
        Predictor.Properties properties = new Predictor.Properties(Skill.DEFENCE, true, true, 1.375d);
        root.insertInto(63, properties);
        List<PredictionTree> leaves = root.getLeaves();
        Integer[] expected = new Integer[]{2, 3, 4, 5, 6, 7, 8, 9};
        assertArrayEquals(expected, leaves.get(0).available.toArray());
    }

    @Test
    public void testHitFinder() {
        Predictor.Properties properties = new Predictor.Properties(Skill.DEFENCE, true, true, 1.375d);
        Predictor.Hit hit = Predictor.findHit(18, properties);
        assertEquals(13, hit.hit);
        assertTrue(hit.possibleBxp);
        assertTrue(hit.bxp);

        Predictor.Hit hit2 = Predictor.findHit(16, properties);
        assertEquals(12, hit2.hit);
        assertTrue(hit2.possibleBxp);
        assertFalse(hit2.bxp);

        Predictor.Hit hit3 = Predictor.findHit(103, properties);
        assertEquals(75, hit3.hit);
        assertFalse(hit3.possibleBxp);
        assertFalse(hit3.bxp);
    }

    @Test
    public void testPredictor() {
        double scaling = 1.21533203125d;
        // List of fixed precision integers

        final int iterations = 100;
        Predictor.Properties props = new Predictor.Properties(Skill.DEFENCE, true, true, scaling);
        runIterations(props, iterations);
    }

    private void runIterations(Predictor.Properties properties, int iterations) {
        int internalFrac = 9;
        List<Integer> possibleDrops = IntStream.rangeClosed(0, 100) // 100 is just a high number
                .map(n -> Predictor.computePrecise(n, properties))
                .boxed().collect(Collectors.toList());
        int[] n = new int[iterations];

        for (int i = 0; i < iterations; i++) {
            Predictor predictor = new Predictor();
            int count = 0;
            while (!predictor.isAccurate(Skill.DEFENCE)) {
                int idx = ThreadLocalRandom.current().nextInt(0, 84);
                //int idx = hits[i++];
                int xp = possibleDrops.get(idx);
                boolean wrapped = ((xp % 10) + internalFrac) >= 10;
                xp += wrapped ? 10 : 0;

                internalFrac = (internalFrac + xp) % 10;
                System.out.println("internal: " + internalFrac + " hit: " + idx + " xp: " + xp +" wrapped: " + wrapped);
                int predicted = predictor.treePredict(xp / 10, properties);
                count++;
            }
            n[i] = count;
        }
        Arrays.sort(n);
        int sum = 0;
        for(int i = 0; i < iterations; i++) {
            sum += n[i];
        }
        System.out.println("avg: " + sum / iterations + " median: " + n[iterations / 2]);
    }

    @Test
    public void testPredictorSmall() {
        PredictionTree root = new PredictionTree();
        root.nobxp = new PredictionTree();
        root.nobxp.available = new HashSet<>();
        root.nobxp.available.add(7);

        root.bxp = new PredictionTree();
        root.bxp.available = new HashSet<>();
        root.bxp.available.add(5);
        root.bxp.available.add(6);
        root.bxp.available.add(7);
        root.insertInto(85, new Predictor.Properties(Skill.DEFENCE, true, true, 1.375d));
    }

    @Test
    public void testPredictorFraction1() {
        double scaling = 1.375;
        Predictor predictor = new Predictor();
        Predictor.Properties properties = new Predictor.Properties(Skill.DEFENCE, true, true, scaling);
        int[] drops = new int[]{108, 7, 18, 35, 71, 94, 15, 86};
        for (int drop : drops) {
            predictor.treePredict(drop, properties);
        }
    }
}

package com.example;

import com.example.TestNPC;
import com.example.enemydata.toa.ToaEnemy;
import com.example.enemydata.toa.ampken.*;
import com.example.enemydata.toa.het.Akkha;
import com.example.enemydata.toa.scabaras.Kephri;
import com.example.enemydata.toa.scabaras.Kephri721;
import com.example.enemydata.toa.scabaras.Spitter;
import net.runelite.api.*;
import org.junit.Test;

import static org.junit.Assert.*;

public class ScalingTests {
    private static final float delta = 0.00000001F;
    @Test
    public void testThrowerScaling() {
        TestNPC npc = new TestNPC(NpcID.BABOON_THROWER);
        Thrower thrower = new Thrower(npc, 515, 1, 2);
        assertEquals(1.0, thrower.getModifier(), delta);
        npc = new TestNPC(NpcID.BABOON_THROWER_11713);
        thrower = new Thrower(npc, 515, 1, 2);
        assertEquals(1.0, thrower.getModifier(), delta);
    }

    @Test
    public void testMageScaling() {
        TestNPC npc = new TestNPC(NpcID.BABOON_MAGE);
        Mage mage = new Mage(npc, 515, 1, 2);
        assertEquals(12, mage.getScaledHealth());
        assertEquals(1.1, mage.getModifier(), delta);
        npc = new TestNPC(NpcID.BABOON_MAGE_11714);
        mage = new Mage(npc, 515, 1, 2);
        assertEquals(1.175, mage.getModifier(), delta);
    }

    @Test
    public void testBrawlerScaling() {
        TestNPC npc = new TestNPC(NpcID.BABOON_BRAWLER);
        Brawler brawler = new Brawler(npc, 515, 1, 2);
        assertEquals(1.1, brawler.getModifier(), delta);
        npc = new TestNPC(NpcID.BABOON_BRAWLER_11712);
        brawler = new Brawler(npc, 515, 1, 2);
        assertEquals(1.175, brawler.getModifier(), delta);
    }

    @Test
    public void testMiscAmpkenScaling() {
        TestNPC shamanNpc = new TestNPC(NpcID.BABOON_SHAMAN);
        Shaman shaman = new Shaman(shamanNpc, 515, 1, 2);
        assertEquals(1.2, shaman.getModifier(), delta);

        TestNPC cursedNPC = new TestNPC(NpcID.CURSED_BABOON);
        Cursed cursed = new Cursed(cursedNPC, 515, 1, 2);
        assertEquals(1.175, cursed.getModifier(), delta);

        TestNPC thrallNPC = new TestNPC(NpcID.BABOON_THRALL);
        Thrall thrall = new Thrall(thrallNPC, 515, 1, 2);
        assertEquals(1.0, thrall.getModifier(), delta);

        TestNPC volatileNPC = new TestNPC(NpcID.VOLATILE_BABOON);
        Volatile vola = new Volatile(volatileNPC, 515, 1, 2);
        assertEquals(1.175, vola.getModifier(), delta);
    }

    @Test
    public void spitterScalingTest() {
        TestNPC spitterNpc = new TestNPC(NpcID.SPITTING_SCARAB);
        Spitter spitter = new Spitter(spitterNpc, 305, 1, 0);
        assertEquals(1.025, spitter.getModifier(), delta);

        TestNPC kephriNpc = new TestNPC(NpcID.KEPHRI);
        Kephri kephri = new Kephri(kephriNpc, 305, 1, 0);
        assertEquals(1.075, kephri.getModifier(), delta);
        assertEquals(330, kephri.getScaledHealth());

        TestNPC kephri721Npc = new TestNPC(NpcID.KEPHRI);
        Kephri721 kephri721 = new Kephri721(kephri721Npc, 305, 1, 0);
        assertEquals(180, kephri721.getScaledHealth());
        assertEquals(1.025, kephri721.getModifier(), delta);
    }

    @Test
    public void akkhaScalingTest() {
        TestNPC akkhaNpc = new TestNPC(NpcID.AKKHA_11790);
        ToaEnemy akkha = new Akkha(akkhaNpc, 305, 2, 0);
        assertEquals(1.575, akkha.getModifier(), delta);
        akkha.fixupStats(305, 2, 0);
        assertEquals(1.575, akkha.getModifier(), delta);
    }
}

package com.example;

import com.example.utils.Predictor;
import net.runelite.api.Skill;
import org.junit.Test;

import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.junit.Assert.*;

public class PredictorTests {

    private int calibrate(Predictor predictor, List<Integer> possibleDrops, Predictor.Properties properties, int internalFrac) {
        while (!predictor.isAccurate(properties.skill)) {
            int hit = ThreadLocalRandom.current().nextInt(0, 84);
            //int hit = hits[i++];
            int xp = possibleDrops.get(hit);
            boolean wrapped = ((xp % 10) + internalFrac) >= 10;
            xp += wrapped ? 10 : 0;

            internalFrac = (internalFrac + xp) % 10;
            //System.out.println("internal: " + internalFrac + " hit: " + hit + " xp: " + xp +" wrapped: " + wrapped);
            // We don't care about uncalibrated hits
            int predicted = predictor.treePredict(xp / 10, properties);
            // Make sure that when calibrating, we won't estimate higher
            assertTrue(predicted + " <= " + hit, predicted <= hit);
        }
        return internalFrac;
    }

    private void runIterations(Predictor predictor, int iterations, List<Integer> possibleDrops, Predictor.Properties properties, int internalFrac) {
        for (int i = 0; i < iterations; i++) {
            int hit = ThreadLocalRandom.current().nextInt(0, 84);
            int xp = possibleDrops.get(hit);
            boolean wrapped = ((xp % 10) + internalFrac) >= 10;
            xp += wrapped ? 10 : 0;

            internalFrac = (internalFrac + xp) % 10;
            int predicted = predictor.treePredict(xp / 10, properties);
            //System.out.println("internal: " + internalFrac + " hit(" + properties.skill.getName() + "): " + hit + " predicted: " + predicted + " xp: " + xp +" wrapped: " + wrapped);
            //System.out.println();
            assertEquals(hit, predicted);
        }
    }

    private void runTest(Predictor.Properties properties, int iterations, int internalFrac) {
        Predictor predictor = new Predictor();
        List<Integer> possibleDrops = IntStream.rangeClosed(0, iterations)
                .map(n -> Predictor.computePrecise(n, properties))
                .boxed().collect(Collectors.toList());
        internalFrac = calibrate(predictor, possibleDrops, properties, internalFrac);

        runIterations(predictor, iterations, possibleDrops, properties, internalFrac);
    }
    @Test
    public void testPredictor() {
        double scaling = 1.375;
        int internalFrac = 9;
        int iterations = 1000;
        Predictor.Properties properties;
        properties = new Predictor.Properties(Skill.HITPOINTS, true, true, scaling);
        runTest(properties, iterations, internalFrac);
    }

    @Test
    public void testXpCalc() {
        double scaling = 1.375d;
        int hit = 10;
        Predictor.Properties properties = new Predictor.Properties(Skill.MAGIC, true, true, scaling);
        assertEquals(183, Predictor.computePrecise(hit, properties));
        properties = new Predictor.Properties(Skill.DEFENCE, true, true, scaling);
        assertEquals(137, Predictor.computePrecise(hit, properties));
    }

    @Test
    public void testPredictorMultipleStyles() {
        double scaling = 1.495;
        int mfrac = 9;
        int dfrac = 3;
        int iterations = 1000;
        Predictor predictor = new Predictor();

        Predictor.Properties magicxp = new Predictor.Properties(Skill.MAGIC, true, true, scaling);
        Predictor.Properties defxp = new Predictor.Properties(Skill.DEFENCE, true, true, scaling);
        List<Integer> validMagic = IntStream.rangeClosed(0, 100)
                .map(hit -> Predictor.computePrecise(hit, magicxp))
                .boxed()
                .collect(Collectors.toList());
        List<Integer> validDef = IntStream.rangeClosed(0, 100)
                .map(hit -> Predictor.computePrecise(hit, defxp))
                .boxed()
                .collect(Collectors.toList());

        while (!predictor.isAccurate(Skill.MAGIC) || !predictor.isAccurate(Skill.DEFENCE)) {
            int hit = ThreadLocalRandom.current().nextInt(0, 84);
            //int hit = hits[i++];
            int mxp = validMagic.get(hit);
            int dxp = validDef.get(hit);
            boolean mwrapped = ((mxp % 10) + mfrac) >= 10;
            boolean dwrapped = ((dxp % 10) + dfrac) >= 10;
            mxp += mwrapped ? 10 : 0;
            dxp += dwrapped ? 10 : 0;
            mfrac = (mfrac + mxp) % 10;
            dfrac = (dfrac + dxp) % 10;
            int mpredict = predictor.treePredict(mxp / 10, magicxp);
            int dpredict = predictor.treePredict(dxp / 10, defxp);
            //System.out.println("mfrac: " + mfrac + " dfrac: " + dfrac +
            //        " hit: " + hit + " mpredict: " + mpredict + " dpredict: " + dpredict +
            //        " mxp(" + mwrapped + "): " + mxp + " dxp(" + dwrapped + "): " + dxp);
            //System.out.println();
            //assertEquals(mpredict, dpredict);
            assertTrue(hit + " >= " + mpredict,hit >= mpredict);
        }
        //System.out.println("*** CALIBRATED " + predictor.isAccurate(Skill.MAGIC) + " " + predictor.isAccurate(Skill.DEFENCE) +" ***");


        for (int i = 0; i < iterations; i++) {
            int hit = ThreadLocalRandom.current().nextInt(0, 84);
            //int hit = hits[i++];
            int mxp = validMagic.get(hit);
            int dxp = validDef.get(hit);
            boolean mwrapped = ((mxp % 10) + mfrac) >= 10;
            boolean dwrapped = ((dxp % 10) + dfrac) >= 10;
            mxp += mwrapped ? 10 : 0;
            dxp += dwrapped ? 10 : 0;

            mfrac = (mfrac + mxp) % 10;
            dfrac = (dfrac + dxp) % 10;
            assertEquals(hit, predictor.treePredict(mxp / 10, magicxp));
            assertEquals(hit, predictor.treePredict(dxp / 10, defxp));
        }
    }

    @Test
    public void preciseCalcTests() {
        double scaling = 1.125d;
        Predictor.Properties properties = new Predictor.Properties(Skill.MAGIC, true, true, scaling);
        int precise = Predictor.computePrecise(23, properties);
        assertEquals(345, precise);
        precise = Predictor.computePrecise(10, properties);
        assertEquals(150, precise);
    }

    @Test
    public void preciseCursedBaboonTests() {
        double scaling = 1.15d;
        Predictor.Properties properties = new Predictor.Properties(Skill.MAGIC, false, true, scaling);
        int precise = Predictor.computePrecise(10, properties);
        assertEquals(230, precise);
    }

    @Test
    public void testPredictorDead() {
        double scaling = 1.375;
        int internalFrac = 9;
        int iterations = 1000;
        Predictor.Properties properties;
        properties = new Predictor.Properties(Skill.HITPOINTS, true, true, scaling);

        Predictor predictor = new Predictor();
        List<Integer> possibleDrops = IntStream.rangeClosed(0, iterations)
                .map(n -> Predictor.computePrecise(n, properties))
                .boxed().collect(Collectors.toList());
        internalFrac = calibrate(predictor, possibleDrops, properties, internalFrac);

        runIterations(predictor, iterations, possibleDrops, properties, internalFrac);
        predictor.reset();
        assertFalse(predictor.isDead(Skill.HITPOINTS));
        internalFrac = calibrate(predictor, possibleDrops, properties, internalFrac);
        runIterations(predictor, iterations, possibleDrops, properties, internalFrac);
        assertFalse(predictor.isDead(Skill.HITPOINTS));
    }

    @Test
    public void testMysticsHit() {
        double scaling = 1.3d;
        Predictor.Properties properties = new Predictor.Properties(Skill.HITPOINTS, true, true, scaling);
        Predictor predictor = new Predictor();
        assertEquals(11, predictor.treePredict(20, properties));
    }
}

package com.example;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(AkkhaPredictor.class);
		RuneLite.main(args);
	}
}
