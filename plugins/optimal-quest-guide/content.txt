/*
 * Copyright (c) 2020, Christopher Oswald <https://github.com/cesoun>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.optimalquestguide;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.awt.*;

@ConfigGroup("optimal-quest-guide")
public interface GuideConfig extends Config {

    @ConfigSection(
            name = "Quest Status Colors",
            description = "Colors of not started, in progress and completed Quest",
            position = 98
    )
    String questStatusSection = "status";

    @ConfigSection(
            name = "Quest Requirement Colors",
            description = "Colors of met, unmet and boostable Quest Requirements",
            position = 99
    )
    String questRequirementSection = "requirement";

    @ConfigItem(
            keyName = "showCompletedQuests",
            name = "Show completed quests",
            description = "Displays already completed quests"
    )
    default boolean showCompletedQuests() {
        return false;
    }

    @ConfigItem(
            keyName = "searchCompletedQuests",
            name = "Search completed quests",
            description = "Have the search include completed quests"
    )
    default boolean searchCompletedQuests() {
        return false;
    }

    @ConfigItem(
            keyName = "filterMetRequirements",
            name = "Filter by met Requirements",
            description = "Only display the quests that you have the met requirements to complete"
    )
    default boolean filterMetRequirements() { return false; }

    @ConfigItem(
            keyName = "inProgressColor",
            name = "Quest in progress color",
            description = "Color of Quests in progress",
            section = questStatusSection
    )
    default Color getInProgressColor() {
        return new Color(240, 207, 123);
    }

    @ConfigItem(
            keyName = "completedColor",
            name = "Quest completed color",
            description = "Color of Quests that have been completed",
            section = questStatusSection
    )
    default Color getCompletedColor() {
        return new Color(110, 225, 110);
    }

    @ConfigItem(
            keyName = "notStartedColor",
            name = "Quest not started color",
            description = "Color of Quests that have not been started",
            section = questStatusSection
    )
    default Color getNotStartedColor() {
        return new Color(198, 198, 198);
    }

    @ConfigItem(
            keyName = "requirementMetColor",
            name = "Requirement level met",
            description = "Color of Requirements that have been met or exceeded",
            section = questRequirementSection
    )
    default Color getRequirementMetColor() {
        return new Color(110, 225, 110);
    }

    @ConfigItem(
            keyName = "requirementUnmetColor",
            name = "Requirement level unmet",
            description = "Color of Requirements that have been unmet and unboostable",
            section = questRequirementSection
    )
    default Color getRequirementUnmetColor() {
        return new Color(230, 30, 30);
    }

    @ConfigItem(
            keyName = "requirementBoostableColor",
            name = "Requirement boostable",
            description = "Color of Requirements that have are unmet and boostable",
            section = questRequirementSection
    )
    default Color getRequirementBoostableColor() {
        return new Color(50, 160, 250);
    }
}

/*
 * Copyright (c) 2020, Christopher Oswald <https://github.com/cesoun>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.optimalquestguide;

import com.google.gson.Gson;
import com.google.inject.Provides;
import com.optimalquestguide.Panels.GuidePanel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Quest;
import net.runelite.api.events.GameTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.HashMap;

@Slf4j
@PluginDescriptor(
        name = "Optimal Quest Guide",
        description = "I wanted this so now you get this as well. OSRS Wiki Optimal Quest Guide.",
        tags = {"quest", "guide", "optimal"}
)
public class GuidePlugin extends Plugin {

    @Inject
    private Client c;

    @Inject
    private GuideConfig config;

    @Inject
    private ClientThread cThread;

    @Inject
    private ClientToolbar cToolbar;

    @Inject
    private Gson gson;

    private NavigationButton nBtn;
    private GuidePanel gPanel;
    private HashMap<String, QuestInfo> infoMap = new HashMap<>();

    @Override
    protected void startUp() throws Exception {
        // Parse the quests.json to be loaded into the panel.
        InputStream questDataFile = GuidePlugin.class.getResourceAsStream("/quests.json");
        QuestInfo[] infos = gson.fromJson(new InputStreamReader(questDataFile), QuestInfo[].class);

        // Populate HashMap for lookup
        for (int i = 0; i < infos.length; i++) {
            QuestInfo info = infos[i];

            info.setIndex(i);
            infoMap.put(info.getName(), info);
        }

        gPanel = new GuidePanel(c, config, infos);

        // Setup the icon.
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/panel_icon.png");

        // Build the navigation button that shows on the sidebar.
        nBtn = NavigationButton.builder()
                .tooltip("Optimal Quest Guide")
                .icon(icon)
                .priority(7)
                .panel(gPanel)
                .build();

        // Add the button to the sidebar.
        cToolbar.addNavigation(nBtn);
    }

    @Override
    protected void shutDown() throws Exception {
        cToolbar.removeNavigation(nBtn);
    }

    @Provides
    GuideConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(GuideConfig.class);
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged e) {
        // Check the group firing the event & if we are logged in.
        if (!e.getGroup().equalsIgnoreCase("optimal-quest-guide")) return;
        if (!c.getGameState().equals(GameState.LOGGED_IN)) return;

        cThread.invokeLater(this::updateQuestList);
    }

    @Subscribe
    public void onGameTick(GameTick e) {
        /*
            Replacing onWidgetLoaded with onGameTick should streamline the panel updates better.

            There were some occasions where the quest dialog gets 1 ticked and closed without updating the panel.

            If this turns out to be to heavy a task within the GameTick i'll like revert it back and look for another
                solution that is potentially more lightweight.
         */
        updateQuestList();
    }

    private void updateQuestList() {
        for (Quest quest : Quest.values()) {
           QuestInfo info = infoMap.get(quest.getName());
           if (info == null) {
               continue;
           }

           info.setWidget(quest);
           info.setQuestState(quest.getState(c));
        }

        gPanel.updateQuests(getInfoArray());
    }

    /**
     * Returns the local infoMap as a/an QuestInfo[]
     * @return QuestInfo[] array of QuestInfo
     */
    private QuestInfo[] getInfoArray() {
        QuestInfo[] infos = infoMap.values().toArray(new QuestInfo[0]);
        Arrays.sort(infos, (o1, o2) -> Integer.compare(o1.getIndex(), o2.getIndex()));

        return infos;
    }
}

/*
 * Copyright (c) 2020, Christopher Oswald <https://github.com/cesoun>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.optimalquestguide.Layouts;


import java.awt.*;
import java.util.function.Function;

/**
 * Grid Layout implementation with support for dynamic sizing based on cell visibility.
 * <p>
 * Functions the same as DynamicGridLayout but collapses the space between cells when they have
 * their visibility set to false. By default the space remains there and they would
 * need to be from the grid.
 */
public class CollapsingGridLayout extends GridLayout {

    public CollapsingGridLayout() {
        this(1, 0, 0, 0);
    }

    public CollapsingGridLayout(int rows, int cols) {
        this(rows, cols, 0, 0);
    }

    public CollapsingGridLayout(int rows, int cols, int hgap, int vgap) {
        super(rows, cols, hgap, vgap);
    }

    @Override
    public Dimension preferredLayoutSize(Container parent) {
        synchronized (parent.getTreeLock()) {
            return calculateSize(parent, Component::getPreferredSize);
        }
    }

    @Override
    public Dimension minimumLayoutSize(Container parent) {
        synchronized (parent.getTreeLock()) {
            return calculateSize(parent, Component::getMinimumSize);
        }
    }

    @Override
    public void layoutContainer(Container parent) {
        synchronized (parent.getTreeLock()) {
            final Insets insets = parent.getInsets();
            final int ncomponents = parent.getComponentCount();
            int nrows = getRows();
            int ncols = getColumns();

            if (ncomponents == 0) {
                return;
            }

            if (nrows > 0) {
                ncols = (ncomponents + nrows - 1) / nrows;
            } else {
                nrows = (ncomponents + ncols - 1) / ncols;
            }

            final int hgap = getHgap();
            final int vgap = getVgap();

            // scaling factors
            final Dimension pd = preferredLayoutSize(parent);
            final Insets parentInsets = parent.getInsets();
            int wborder = parentInsets.left + parentInsets.right;
            int hborder = parentInsets.top + parentInsets.bottom;
            final double sw = (1.0 * parent.getWidth() - wborder) / (pd.width - wborder);
            final double sh = (1.0 * parent.getHeight() - hborder) / (pd.height - hborder);

            final int[] w = new int[ncols];
            final int[] h = new int[nrows];

            // calculate dimensions for all visible components + apply scaling
            for (int i = 0; i < parent.getComponentCount(); i++) {
                final int r = i / ncols;
                final int c = i % ncols;
                final Component comp = parent.getComponent(i);

                if (!comp.isVisible()) continue;

                final Dimension d = comp.getPreferredSize();
                d.width = (int) (sw * d.width);
                d.height = (int) (sh * d.height);

                if (w[c] < d.width) {
                    w[c] = d.width;
                }

                if (h[r] < d.height) {
                    h[r] = d.height;
                }
            }

            // Apply new bounds to all child components
            for (int c = 0, x = insets.left; c < ncols; c++) {
                for (int r = 0, y = insets.top; r < nrows; r++) {
                    int i = r * ncols + c;

                    if (i < ncomponents) {
                        if (!parent.getComponent(i).isVisible()) continue;

                        parent.getComponent(i).setBounds(x, y, w[c], h[r]);
                    }

                    y += h[r] + vgap;
                }

                x += w[c] + hgap;
            }
        }
    }

    /**
     * Calculate outer size of the layout based on it's visible children and sizer
     *
     * @param parent parent component
     * @param sizer  functioning returning dimension of the child component
     * @return outer size
     */
    private Dimension calculateSize(final Container parent, final Function<Component, Dimension> sizer) {
        final int ncomponents = getVisibleComponents(parent);
        int nrows = getRows();
        int ncols = getColumns();

        if (nrows > 0) {
            ncols = (ncomponents + nrows - 1) / nrows;
        } else {
            nrows = (ncomponents + ncols - 1) / ncols;
        }

        final int[] w = new int[ncols];
        final int[] h = new int[nrows];

        // Calculate dimensions for all visible components
        for (int i = 0; i < parent.getComponentCount(); i++) {
            final int r = i / ncols;
            final int c = i % ncols;
            final Component comp = parent.getComponent(i);

            // Ignore not visible components.
            if (!comp.isVisible()) continue;

            final Dimension d = sizer.apply(comp);

            if (w[c] < d.width) {
                w[c] = d.width;
            }

            if (h[r] < d.height) {
                h[r] = d.height;
            }
        }

        // Calculate total width and height of the layout
        int nw = 0;

        for (int j = 0; j < ncols; j++) {
            nw += w[j];
        }

        int nh = 0;

        for (int i = 0; i < nrows; i++) {
            nh += h[i];
        }

        final Insets insets = parent.getInsets();

        // Apply insets and horizontal and vertical gap to layout
        // This uses a different nrow count because we only want to apply to the visible components.
        return new Dimension(
                insets.left + insets.right + nw + (ncols - 1) * getHgap(),
                insets.top + insets.bottom + nh + (getVisibleComponents(parent) - 1) * getVgap());
    }

    /**
     * Get the count of visible child components
     *
     * @param parent parent component
     * @return visible count
     */
    private int getVisibleComponents(Container parent) {
        int visible = 0;

        for (Component c : parent.getComponents())
            if (c.isVisible())
                visible++;

        return visible;
    }
}
/*
 * Copyright (c) 2020, Christopher Oswald <https://github.com/cesoun>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.optimalquestguide.Panels;

import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.shadowlabel.JShadowedLabel;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class ErrorPanel extends JPanel {

    private final JLabel title = new JShadowedLabel();
    private final JLabel description = new JShadowedLabel();

    public ErrorPanel() {
        setBorder(new EmptyBorder(5, 10, 10, 10));
        setLayout(new BorderLayout());

        title.setForeground(Color.WHITE);
        title.setHorizontalAlignment(SwingConstants.CENTER);

        description.setFont(FontManager.getRunescapeSmallFont());
        description.setForeground(Color.GRAY);
        description.setHorizontalAlignment(SwingConstants.CENTER);

        add(title, BorderLayout.NORTH);
        add(description, BorderLayout.CENTER);

        setVisible(false);
    }

    public void setContent(String title, String description) {
        this.title.setText(title);
        this.description.setText(description);
        setVisible(true);
    }
}

/*
 * Copyright (c) 2020, Christopher Oswald <https://github.com/cesoun>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.optimalquestguide.Panels;

import com.optimalquestguide.GuideConfig;
import com.optimalquestguide.Layouts.CollapsingGridLayout;
import com.optimalquestguide.Panels.Listeners.SearchListener;
import com.optimalquestguide.QuestInfo;
import com.optimalquestguide.QuestRequirement;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;
import net.runelite.api.VarPlayer;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;

import javax.inject.Inject;
import java.awt.*;
import java.util.HashMap;

@Slf4j
public class GuidePanel extends PluginPanel {

    private final Client c;
    private final GuideConfig config;

    private final ErrorPanel ePanel = new ErrorPanel();
    private final IconTextField searchBar = new IconTextField();
    private final HashMap<String, QuestPanel> qMap = new HashMap<>();
    private final HashMap<String, QuestPanel> searchMap = new HashMap<>();

    @Inject
    public GuidePanel(Client c, GuideConfig config, QuestInfo[] infos) {
        super();

        this.c = c;
        this.config = config;

        setLayout(new CollapsingGridLayout(infos.length + 2, 1, 0, 2));

        ePanel.setContent("Optimal Quest Guide", "Quests will adjust after login.");
        add(ePanel);

        // Search Bar for filtering quests.
        searchBar.setIcon(IconTextField.Icon.SEARCH);
        searchBar.setPreferredSize(new Dimension(PluginPanel.WIDTH - 10, 30));
        searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        searchBar.addClearListener(this::onSearch);

        // This is new and seems to be what was breaking the plugin. Not sure if this is 100% the right way to do this.
        // It will likely causes some bugs and need to be adjusted.
        SearchListener searchListener = new SearchListener(config, qMap, searchMap);
        searchBar.addKeyListener(searchListener);

        add(searchBar);

        // Save the object to a HashMap because we want need to build all panels.
        for (QuestInfo info : infos) {
            QuestPanel qPanel = new QuestPanel(c, config, info);
            qMap.put(info.getName(), qPanel);
            add(qPanel);
        }
    }

    /**
     * Used for filtering the search results of quests.
     */
    private void onSearch() {
        if (config.searchCompletedQuests() || searchMap.isEmpty()) {
            qMap.forEach((quest, panel) -> {
                panel.setVisible(quest.toLowerCase().contains(searchBar.getText().toLowerCase()));
                revalidate();
            });
        } else {
            searchMap.forEach((quest, panel) -> {
                panel.setVisible(quest.toLowerCase().contains(searchBar.getText().toLowerCase()));
                revalidate();
            });
        }
    }

    /**
     * Called when the panel is updated.
     *
     * @param infos The QuestInfo array.
     */
    public void updateQuests(QuestInfo[] infos) {
        // Prevent updates while the search bar contains text.
        if (!searchBar.getText().isEmpty()) return;

        // Update panels.
        for (QuestInfo info : infos) {
            QuestPanel qPanel = qMap.get(info.getName());
            if (qPanel == null) continue;

            qPanel.update(info);

            if (config.showCompletedQuests()) { // Display all.
                if (qPanel.isVisible()) continue;

                qPanel.setVisible(true);
            } else if (info.getQuestState() == QuestState.NOT_STARTED || info.getQuestState() == QuestState.IN_PROGRESS) { // Display only not completed.
                // Filter by met.
                if (config.filterMetRequirements()) {
                    filterByMet(qPanel, info);
                    continue;
                }

                if (qPanel.isVisible()) continue;

                qPanel.setVisible(true);
            } else { // Remove from the panel if it's not showing all and its finished.
                if (!qPanel.isVisible()) continue;

                qPanel.setVisible(false);
            }
        }

        // Clear the search map before updating.
        searchMap.clear();

        for (Component c : this.getComponents()) {
            if (!c.isVisible()) continue;

            if (c instanceof QuestPanel) {
                QuestPanel qPanel = (QuestPanel) c;
                searchMap.put(qPanel.getQuest().getName(), qPanel);
            }
        }

        ePanel.setContent("Optimal Quest Guide", "Happy questing.");

        revalidate();
    }

    /**
     * Check to see if the player meets a given requirement.
     * This function does not account for boostable skills.
     *
     * @param has  The players current level
     * @param need The needed level
     * @return true if met, false if unmet
     */
    private boolean meetsRequirement(int has, int need) {
        return has >= need;
    }

    /**
     * Displays only the quests that the player has the met requirements for.
     * This is used in both the show all completed, and only by incomplete / in-progress quests.
     *
     * @param qPanel The QuestPanel
     * @param info   The QuestInfo
     */
    private void filterByMet(QuestPanel qPanel, QuestInfo info) {
        // Filter by met requirements only.
        if (config.filterMetRequirements()) {
            // Only run if we have a player.
            if (this.c.getLocalPlayer() == null) return;

            // Loop over all the requirements
            for (QuestRequirement requirement : info.getReqs()) {
                String skill = requirement.getSkill();
                int level = requirement.getLevel();

                // Check for which skill type it is.
                if (skill.equalsIgnoreCase("quest points")) {
                    if (meetsRequirement(this.c.getVarpValue(VarPlayer.QUEST_POINTS), level)) continue;
                } else if (skill.equalsIgnoreCase("combat level")) {
                    if (meetsRequirement(this.c.getLocalPlayer().getCombatLevel(), level)) continue;
                } else {
                    if (meetsRequirement(this.c.getRealSkillLevel(Skill.valueOf(skill.toUpperCase())), level)) continue;
                }

                // If we don't meet a given requirement, the panel is hidden & break the loop.
                if (qPanel.isVisible()) {
                    qPanel.setVisible(false);
                }

                break;
            }
        }
    }
}

/*
 * Copyright (c) 2021, Christopher Oswald <https://github.com/cesoun>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.optimalquestguide.Panels.Listeners;

import com.optimalquestguide.GuideConfig;
import com.optimalquestguide.Panels.QuestPanel;
import net.runelite.client.input.KeyListener;

import javax.swing.*;
import java.awt.event.KeyEvent;
import java.util.HashMap;

public class SearchListener implements KeyListener {

    private final GuideConfig config;

    private final HashMap<String, QuestPanel> qMap;
    private final HashMap<String, QuestPanel> searchMap;

    public SearchListener(GuideConfig config, HashMap<String, QuestPanel> qMap, HashMap<String, QuestPanel> searchMap) {
        this.config = config;
        this.qMap = qMap;
        this.searchMap = searchMap;
    }

    @Override
    public void keyTyped(KeyEvent e) {
        JTextField searchBar = (JTextField) e.getSource();
        this.onSearch(searchBar);
    }

    @Override
    public void keyPressed(KeyEvent e) {

    }

    @Override
    public void keyReleased(KeyEvent e) {

    }

    /**
     * Used for filtering the search results of quests.
     */
    public void onSearch(JTextField searchBar) {
        String input = searchBar.getText().toLowerCase();

        if (config.searchCompletedQuests() || searchMap.isEmpty()) {
            qMap.forEach((quest, panel) -> {
                panel.setVisible(quest.toLowerCase().contains(input));
                searchBar.revalidate();
            });
        } else {
            searchMap.forEach((quest, panel) -> {
                panel.setVisible(quest.toLowerCase().contains(input));
                searchBar.revalidate();
            });
        }
    }
}


/*
 * Copyright (c) 2020, Christopher Oswald <https://github.com/cesoun>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.optimalquestguide.Panels;

import com.optimalquestguide.GuideConfig;
import com.optimalquestguide.QuestInfo;
import com.optimalquestguide.QuestRequirement;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;
import net.runelite.api.VarPlayer;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.HashMap;

@Slf4j
public class QuestPanel extends JPanel {

    private final Client c;
    private final GuideConfig config;

    private final JPanel qHeader = new JPanel();
    private final JPanel qRequirements = new JPanel();
    private final JLabel qLabel = new JLabel();

    @Getter
    private final QuestInfo quest;

    private final HashMap<String, JLabel> skillMap = new HashMap<>();

    public QuestPanel(Client c, GuideConfig config, QuestInfo quest) {
        this.c = c;
        this.config = config;
        this.quest = quest;

        setLayout(new GridBagLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridy = 0;
        gbc.gridx = 0;

        qHeader.setBorder(new EmptyBorder(5, 0, 5, 0));
        qHeader.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        qLabel.setText(quest.getName());
        qLabel.setFont(FontManager.getRunescapeBoldFont());
        qLabel.setHorizontalAlignment(SwingConstants.CENTER);
        qLabel.setVerticalAlignment(SwingConstants.CENTER);

        qHeader.add(qLabel, BorderLayout.NORTH);

        // Menu Item(s)
        JMenuItem openWiki = new JMenuItem("Open Wiki Guide");
        openWiki.addActionListener(e -> LinkBrowser.browse(quest.getUri()));

        // Popup Menu
        JPopupMenu popupMenu = new JPopupMenu();
        popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
        popupMenu.add(openWiki);

        add(qHeader, gbc);
        gbc.gridy++;

        if (quest.getReqs().length > 0) {
            addSkillReqs(quest.getReqs());
            add(qRequirements, gbc);
        }

        setComponentPopupMenu(popupMenu);
    }

    private void addSkillReqs(QuestRequirement[] requirements) {
        qRequirements.setLayout(new GridBagLayout());
        qRequirements.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridy = 0;
        gbc.gridx = 0;
        gbc.ipadx = 5;
        gbc.ipady = 5;

        for (QuestRequirement requirement : requirements) {
            JPanel reqGroup = new JPanel();
            reqGroup.setLayout(new GridBagLayout());
            reqGroup.setBackground(ColorScheme.DARKER_GRAY_COLOR);

            GridBagConstraints c = new GridBagConstraints();
            c.ipadx = 5;

            JLabel icon = new JLabel(new ImageIcon(requirement.getIcon()));
            icon.setHorizontalAlignment(SwingConstants.CENTER);
            icon.setVerticalAlignment(SwingConstants.CENTER);
            icon.setPreferredSize(new Dimension(25, 25));

            JLabel level = new JLabel();
            level.setFont(FontManager.getRunescapeSmallFont());
            level.setText(String.valueOf(requirement.getLevel()));
            level.setHorizontalAlignment(SwingConstants.CENTER);
            level.setVerticalAlignment(SwingConstants.CENTER);

            reqGroup.add(icon, c);
            reqGroup.add(level, c);

            // Add the level label to the hashmap to be updated later.
            skillMap.put(requirement.getSkill().toLowerCase(), level);

            qRequirements.add(reqGroup, gbc);
            gbc.gridx++;

            if (gbc.gridx > 4) {
                gbc.gridx = 0;
                gbc.gridy++;
            }
        }
    }

    public void update(QuestInfo quest) {
        SwingUtilities.invokeLater(() -> {
            if (quest == null) return;
            if (quest.getQuestState() == null) return;

            if (quest.getQuestState() == QuestState.IN_PROGRESS)
                qLabel.setForeground(config.getInProgressColor());
            else if (quest.getQuestState() == QuestState.FINISHED)
                qLabel.setForeground(config.getCompletedColor());
            else
                qLabel.setForeground(config.getNotStartedColor());

            for (QuestRequirement requirement : quest.getReqs()) {
                if (this.c.getLocalPlayer() == null) continue;

                String skill = requirement.getSkill();

                if (skill.equalsIgnoreCase("quest points")) {
                    updateRequirement(requirement, skill, this.c.getVarpValue(VarPlayer.QUEST_POINTS));
                } else if (skill.equalsIgnoreCase("combat level")) {
                    updateRequirement(requirement, skill, this.c.getLocalPlayer().getCombatLevel());
                } else {
                    updateRequirement(requirement, skill, this.c.getRealSkillLevel(Skill.valueOf(skill.toUpperCase())));
                }
            }
        });
    }

    private void updateRequirement(QuestRequirement requirement, String skill, int level) {
        // Get the label from the map.
        JLabel label = skillMap.get(skill.toLowerCase());
        if (label == null) return;

        // Update the label according to the value & boostable status.
        if (level >= requirement.getLevel()) {
            label.setForeground(config.getRequirementMetColor());
        } else if (requirement.isBoostable()) {
            label.setForeground(config.getRequirementBoostableColor());
        } else {
            label.setForeground(config.getRequirementUnmetColor());
        }
    }
}

/*
 * Copyright (c) 2020, Christopher Oswald <https://github.com/cesoun>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.optimalquestguide;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;

public class QuestInfo {
    @Getter
    @Setter
    private String name;

    @Getter
    @Setter
    private String uri;

    @Getter
    @Setter
    private int index;

    @Getter
    @Setter
    private QuestRequirement[] reqs;

    @Getter
    @Setter
    private QuestState questState;

    @Getter
    @Setter
    private Quest widget = null;
}


/*
 * Copyright (c) 2020, Christopher Oswald <https://github.com/cesoun>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.optimalquestguide;

import com.optimalquestguide.Panels.GuidePanel;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Skill;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;

public class QuestRequirement {

    @Getter
    @Setter
    private String skill;

    @Getter
    @Setter
    private int level;

    @Getter
    @Setter
    private boolean boostable;

    public BufferedImage getIcon() {
        if (this.skill.equalsIgnoreCase("quest points")) {
            return ImageUtil.loadImageResource(GuidePanel.class, "/quest_point.png");
        } else if (this.skill.equalsIgnoreCase("combat level")) {
            return ImageUtil.loadImageResource(GuidePanel.class, "/combat_level.png");
        }

        return new SkillIconManager().getSkillImage(Skill.valueOf(skill.toUpperCase()), true);
    }
}

package com.optimalquestguide;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class OptimalQuestGuidePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GuidePlugin.class);
		RuneLite.main(args);
	}
}
