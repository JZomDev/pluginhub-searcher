package tictac7x.motherlode.rockfalls;

import net.runelite.api.GameObject;
import tictac7x.motherlode.sectors.Sectors;
import tictac7x.motherlode.Character;
import tictac7x.motherlode.sectors.Sector;
import tictac7x.motherlode.TicTac7xMotherlodeConfig;

import java.awt.Color;
import java.util.Collections;
import java.util.List;

public class Rockfall {
    public final int x;
    public final int y;
    public final List<Sector> sectors;

    public Rockfall(final int x, final int y) {
        this.x = x;
        this.y = y;
        this.sectors = Sectors.getSectors(x, y, true);
    }

    public Color getTileColor(final TicTac7xMotherlodeConfig config) {
        return config.getRockfallsColor();
    }

    public boolean isRendering(final TicTac7xMotherlodeConfig config, final Character character) {
        if (config.upstairsOnly() && sectors.contains(Sector.DOWNSTAIRS)) {
            return false;
        }

        if (Collections.disjoint(character.getSectors(), sectors)) {
            return false;
        }

        return true;
    }

    public static boolean isRockfall(final GameObject gameObject) {
        switch (gameObject.getId()) {
            case 26679:
            case 26680:
                return true;
            default:
                return false;
        }
    }
}

package tictac7x.motherlode.rockfalls;

import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import tictac7x.motherlode.Character;
import tictac7x.motherlode.TicTac7xMotherlodeConfig;

import javax.annotation.Nullable;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import static tictac7x.motherlode.TicTac7xMotherlodePlugin.getWorldObjectKey;

public class Rockfalls extends Overlay {
    private final TicTac7xMotherlodeConfig config;
    private final Character character;

    private Map<String, Rockfall> rockfalls = new HashMap<>();
    private Set<GameObject> rockfallsGameObjects = new HashSet<>();

    public Rockfalls(final TicTac7xMotherlodeConfig config, final Character character) {
        this.config = config;
        this.character = character;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }


    public void onGameObjectSpawned(final GameObjectSpawned event) {
        if (!Rockfall.isRockfall(event.getGameObject())) return;

        updateRockfall(event.getGameObject());
        rockfallsGameObjects.add(event.getGameObject());
    }

    public void onGameObjectDespawned(final GameObjectDespawned event) {
        if (!Rockfall.isRockfall(event.getGameObject())) return;

        rockfallsGameObjects.remove(event.getGameObject());
    }

    public void onGameStateChanged(final GameStateChanged event) {
        if (event.getGameState() == GameState.LOADING) {
            rockfallsGameObjects.clear();
        }
    }

    private void updateRockfall(final GameObject gameObject) {
        final String key = getWorldObjectKey(gameObject);

        if (!rockfalls.containsKey(key)) {
            rockfalls.put(key, new Rockfall(gameObject.getWorldLocation().getX(), gameObject.getWorldLocation().getY()));
        }
    }

    @Nullable
    private Rockfall getRockfallFromGameObject(final GameObject gameObject) {
        for (final Rockfall rockfall : rockfalls.values()) {
            if (rockfall.x == gameObject.getWorldLocation().getX() && rockfall.y == gameObject.getWorldLocation().getY()) {
                return rockfall;
            }
        }

        return null;
    }

    @Override
    public Dimension render(final Graphics2D graphics2D) {
        if (config.getRockfallsColor().getAlpha() == 0) return null;

        for (final GameObject rockfallGameObject : rockfallsGameObjects) {
            final Rockfall rockfall = getRockfallFromGameObject(rockfallGameObject);
            if (rockfall == null || !rockfall.isRendering(config, character)) continue;

            renderTile(graphics2D, rockfallGameObject, rockfall.getTileColor(config));
        }

        return null;
    }

    private void renderTile(final Graphics2D graphics, final GameObject gameObject, final Color color) {
        try {
            // Area border.
            graphics.setColor(color);
            graphics.setStroke(new BasicStroke(1));
            graphics.draw(gameObject.getCanvasTilePoly());

            // Area fill.
            graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), Math.max(color.getAlpha() - 20, 0)));
            graphics.fill(gameObject.getCanvasTilePoly());
        } catch (final Exception ignored) {}
    }
}

package tictac7x.motherlode;

import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemID;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.client.config.ConfigManager;

public class Bank {
    private final ConfigManager configManager;
    private final TicTac7xMotherlodeConfig config;

    public Bank(final ConfigManager configManager, final TicTac7xMotherlodeConfig config) {
        this.configManager = configManager;
        this.config = config;
    }

    public int getGoldenNuggets() {
        return config.getBankGoldenNuggets();
    }

    public void onItemContainerChanged(final ItemContainerChanged event) {
        if (event.getContainerId() != InventoryID.BANK.getId()) return;

        for (final Item item : event.getItemContainer().getItems()) {
            if (item.getId() == ItemID.GOLDEN_NUGGET) {
                setGoldenNuggets(item.getQuantity());
                return;
            }
        }
    }

    public void depositGoldenNuggets(final int quantity) {
        setGoldenNuggets(config.getBankGoldenNuggets() + quantity);
    }

    private void setGoldenNuggets(final int quantity) {
        configManager.setConfiguration(TicTac7xMotherlodeConfig.group, TicTac7xMotherlodeConfig.bank_golden_nuggets, quantity);
    }
}

package tictac7x.motherlode;

import net.runelite.api.Item;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemID;
import net.runelite.api.events.ItemContainerChanged;

public class Inventory {
    private int paydirt = 0;
    private int otherItems = 0;

    public void onItemContainerChanged(final ItemContainerChanged event) {
        if (event.getContainerId() != InventoryID.INVENTORY.getId()) return;

        int paydirt = 0;
        int otherItems = 0;

        for (final Item item : event.getItemContainer().getItems()) {
            if (item.getId() >= 0) {
                otherItems += item.getId() == ItemID.PAYDIRT ? 0 : 1;
                paydirt += item.getId() == ItemID.PAYDIRT ? 1 : 0;
            }
        }

        this.paydirt = paydirt;
        this.otherItems = otherItems;
    }

    public int getPaydirt() {
        return paydirt;
    }

    public int getMaximumAvailablePayDirt() {
        return 28 - otherItems;
    }
}

package tictac7x.motherlode;

import net.runelite.api.Client;
import tictac7x.motherlode.sectors.Sector;
import tictac7x.motherlode.sectors.Sectors;

import java.util.Arrays;
import java.util.List;

import static tictac7x.motherlode.sectors.Sector.DOWNSTAIRS;

public class Character {
    private final Client client;

    public Character(final Client client) {
        this.client = client;
    }

    private final int[] MOTHERLODE_REGIONS = new int[]{ 14679, 14680, 14681, 14935, 14936, 14937, 15191, 15192, 15193 };

    private boolean inMotherlode = false;
    private List<Sector> sectors = Arrays.asList(DOWNSTAIRS);

    public boolean isInMotherlode() {
        return inMotherlode;
    }

    public List<Sector> getSectors() {
        return sectors;
    }

    public void onGameTick() {
        this.sectors = Sectors.getSectors(client.getLocalPlayer().getWorldLocation().getX(), client.getLocalPlayer().getWorldLocation().getY(), true);
    }

    public void checkIsInMotherlode() {
        for (final int playerRegion : client.getMapRegions()) {
            for (final int motherlodeRegion : MOTHERLODE_REGIONS) {
                if (motherlodeRegion == playerRegion) {
                    inMotherlode = true;
                    return;
                }
            }
        }

        inMotherlode = false;
    }
}

package tictac7x.motherlode;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.TileObject;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WallObjectDespawned;
import net.runelite.api.events.WallObjectSpawned;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import tictac7x.motherlode.oreveins.OreVeins;
import tictac7x.motherlode.rockfalls.Rockfalls;

import javax.inject.Inject;

@Slf4j
@PluginDescriptor(
	name = "Motherlode Mine Improved",
	description = "Better indicators for ore veins",
	tags = { "motherlode", "prospector", "golden", "nugget" },
	conflicts = {"Motherlode Mine", "MLM Mining Markers"}
)
public class TicTac7xMotherlodePlugin extends Plugin {
	private final String pluginVersion = "v0.4.3";
	private final String pluginMessage = "" +
		"<colHIGHLIGHT>Motherlode Mine Improved " + pluginVersion + ":<br>" +
		"<colHIGHLIGHT>* Needed paydirt improvements."
	;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ConfigManager configManager;

	@Inject
	private TicTac7xMotherlodeConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Notifier notifier;

	@Inject
	private ChatMessageManager chatMessageManager;

	private Character character;
	private Bank bank;
	private Inventory inventory;
	private Hopper hopper;
	private OreVeins oreVeins;
	private Rockfalls rockfalls;
	private Sack sack;
	private Motherlode motherlode;
	private Widget widget;

	@Provides
	TicTac7xMotherlodeConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(TicTac7xMotherlodeConfig.class);
	}

	@Override
	protected void startUp() {
		character = new Character(client);
		bank = new Bank(configManager, config);
		inventory = new Inventory();
		hopper = new Hopper(client, inventory);
		sack = new Sack(client);
		motherlode = new Motherlode(client, clientThread, notifier, config, bank, inventory, sack, hopper);
		widget = new Widget(client, config, motherlode, character);
		oreVeins = new OreVeins(config, character, motherlode);
		rockfalls = new Rockfalls(config, character);

		overlayManager.add(oreVeins);
		overlayManager.add(rockfalls);
		overlayManager.add(widget);
	}

	@Override
	protected void shutDown() {
		widget.shutDown();
		overlayManager.remove(oreVeins);
		overlayManager.remove(rockfalls);
		overlayManager.remove(widget);
	}

	@Subscribe
	public void onGameStateChanged(final GameStateChanged event) {
		oreVeins.onGameStateChanged(event);
		rockfalls.onGameStateChanged(event);
		sendMessageAboutPluginVersion(event);
	}

	@Subscribe
	public void onItemContainerChanged(final ItemContainerChanged event) {
		if (!character.isInMotherlode()) return;
		inventory.onItemContainerChanged(event);
		bank.onItemContainerChanged(event);
		motherlode.onItemContainerChanged(event);
	}

	@Subscribe
	public void onChatMessage(final ChatMessage event) {
		if (!character.isInMotherlode()) return;
		motherlode.onChatMessage(event);
	}

	@Subscribe
	public void onWallObjectSpawned(final WallObjectSpawned event) {
		if (!character.isInMotherlode()) return;
		oreVeins.onWallObjectSpawned(event);
	}

	@Subscribe
	public void onWallObjectDespawned(final WallObjectDespawned event) {
		if (!character.isInMotherlode()) return;
		oreVeins.onWallObjectDespawned(event);
	}

	@Subscribe
	public void onAnimationChanged(final AnimationChanged event) {
		if (!character.isInMotherlode()) return;
		oreVeins.onAnimationChanged(event);
		hopper.onAnimationChanged(event);
	}

	@Subscribe
	public void onGameObjectSpawned(final GameObjectSpawned event) {
		if (!character.isInMotherlode()) return;
		rockfalls.onGameObjectSpawned(event);
	}

	@Subscribe
	public void onGameObjectDespawned(final GameObjectDespawned event) {
		if (!character.isInMotherlode()) return;
		rockfalls.onGameObjectDespawned(event);
	}

	@Subscribe
	public void onGameTick(final GameTick event) {
		character.checkIsInMotherlode();
		if (!character.isInMotherlode()) return;

		character.onGameTick();
		oreVeins.onGameTick();
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged event) {
		if (!character.isInMotherlode()) return;
		widget.onConfigChanged(event);
	}

	@Subscribe
	public void onWidgetLoaded(final WidgetLoaded event) {
		if (!character.isInMotherlode()) return;
		widget.onWidgetLoaded(event);
	}

	@Subscribe
	public void onVarbitChanged(final VarbitChanged event) {
		if (!character.isInMotherlode()) return;
		hopper.onVarbitChanged(event);
		motherlode.onVarbitChanged(event);
	}

	private void sendMessageAboutPluginVersion(final GameStateChanged event) {
		if (event.getGameState() == GameState.LOGGED_IN && !config.getVersion().equals(pluginVersion)) {
			configManager.setConfiguration(TicTac7xMotherlodeConfig.group, TicTac7xMotherlodeConfig.version, pluginVersion);
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(pluginMessage)
				.build()
			);
		}
	}

	public static String getWorldObjectKey(final TileObject tileObject) {
		return tileObject.getWorldLocation().getX() + "_" + tileObject.getWorldLocation().getY();
	}
}

package tictac7x.motherlode;

import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.Varbits;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;

public class Motherlode {
    private final Client client;
    private final ClientThread clientThread;
    private final Notifier notifier;
    private final TicTac7xMotherlodeConfig config;
    private final Bank bank;
    private final Inventory inventory;
    private final Sack sack;
    private final Hopper hopper;
    private boolean notifiedToStopMining = false;
    private int goldenNuggetsBefore = 0;
    private int goldenNuggetsSession = 0;

    public Motherlode(final Client client, final ClientThread clientThread, final Notifier notifier, final TicTac7xMotherlodeConfig config, final Bank bank, final Inventory inventory, final Sack sack, final Hopper hopper) {
        this.client = client;
        this.clientThread = clientThread;
        this.notifier = notifier;
        this.config = config;
        this.bank = bank;
        this.inventory = inventory;
        this.sack = sack;
        this.hopper = hopper;
    }

    public int getDepositedPaydirt() {
        return sack.getPaydirt() + hopper.getPaydirt();
    }

    public int getSpaceLeftToDeposit() {
        return sack.getSize() - sack.getPaydirt() - hopper.getPaydirt();
    }

    public int getNeededPaydirt() {
        return Math.min(
            sack.getSize() - getDepositedPaydirt(),
            inventory.getMaximumAvailablePayDirt()
        ) - inventory.getPaydirt();
    }

    public boolean shouldStopMining() {
        return (
            getSpaceLeftToDeposit() == 0 ||
            getNeededPaydirt() < 0 ||
            getNeededPaydirt() == 0 && inventory.getPaydirt() < inventory.getMaximumAvailablePayDirt()
        );
    }

    public boolean shouldDepositPaydirt() {
        return getNeededPaydirt() == 0 && inventory.getPaydirt() > 0;
    }

    public int getGoldenNuggetsTotal() {
        return bank.getGoldenNuggets();
    }

    public int getDepositsLeft() {
        return inventory.getMaximumAvailablePayDirt() == 0 ? 0 : (int) Math.ceil((double) getSpaceLeftToDeposit() / inventory.getMaximumAvailablePayDirt());
    }

    public int getInventoryPaydirt() {
        return inventory.getPaydirt();
    }

    public int getSackSize() {
        return sack.getSize();
    }

    public boolean sackCanBeMoreThanFull() {
        return inventory.getMaximumAvailablePayDirt() > getSpaceLeftToDeposit();
    }

    public int getGoldenNuggetsSession() {
        return goldenNuggetsSession;
    }

    public void onItemContainerChanged(final ItemContainerChanged event) {
        if (!notifiedToStopMining && event.getContainerId() == InventoryID.INVENTORY.getId() && shouldStopMining() && config.notifyToStopMining()) {
            notifier.notify("Stop mining! Sack will be too full.");
            notifiedToStopMining = true;
        }
    }

    public void onVarbitChanged(final VarbitChanged event) {
        if (event.getVarbitId() == Varbits.SACK_NUMBER) {
            notifiedToStopMining = false;
        }
    }

    public void onChatMessage(final ChatMessage event) {
        if (event.getType() == ChatMessageType.MESBOX && event.getMessage().contains("You collect your ore from the sack.")) {
            depositFoundGoldenNuggetsToBank();
        }
    }

    private void depositFoundGoldenNuggetsToBank() {
        final ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory == null) return;

        for (final Item item : inventory.getItems()) {
            if (item.getId() == ItemID.GOLDEN_NUGGET) {
                goldenNuggetsBefore = item.getQuantity();
                break;
            }
        }

        clientThread.invokeLater(() -> {
            final ItemContainer inventoryNextTick = client.getItemContainer(InventoryID.INVENTORY);
            if (inventoryNextTick == null) return;

            for (final Item item : inventoryNextTick.getItems()) {
                if (item.getId() == ItemID.GOLDEN_NUGGET) {
                    final int quantity = item.getQuantity() - goldenNuggetsBefore;
                    bank.depositGoldenNuggets(quantity);
                    goldenNuggetsSession += quantity;
                    break;
                }
            }
        });
    }
}

package tictac7x.motherlode;

import net.runelite.api.Client;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;

public class Widget extends OverlayPanel {
    private final Client client;
    private final TicTac7xMotherlodeConfig config;
    private final Motherlode motherlode;
    private final Character character;

    private final int SACK_WIDGET_GROUP = 382;
    private final int SACK_WIDGET_CHILD = 0;

    public Widget(final Client client, final TicTac7xMotherlodeConfig config, final Motherlode motherlode, final Character character) {
        this.client = client;
        this.config = config;
        this.motherlode = motherlode;
        this.character = character;

        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        toggleOriginalWidget(config.showCustomSackWidget());
    }

    // On first widget load.
    public void onWidgetLoaded(final WidgetLoaded event) {
        if (event.getGroupId() == SACK_WIDGET_GROUP) {
            toggleOriginalWidget(config.showCustomSackWidget());
        }
    }

    // Widget needs to be toggled based on config changed.
    public void onConfigChanged(final ConfigChanged event) {
        if (event.getGroup().equals(TicTac7xMotherlodeConfig.group) && event.getKey().equals(TicTac7xMotherlodeConfig.sack_custom)) {
            toggleOriginalWidget(config.showCustomSackWidget());
        }
    }

    public void shutDown() {
        toggleOriginalWidget(false);
    }

    private void toggleOriginalWidget(final boolean hidden) {
        final net.runelite.api.widgets.Widget widget = client.getWidget(SACK_WIDGET_GROUP, SACK_WIDGET_CHILD);

        if (widget != null) {
            widget.setHidden(hidden);
        }
    }

    @Override
    public Dimension render(final Graphics2D graphics2D) {
        if (!character.isInMotherlode() || !config.showCustomSackWidget()) return null;

        panelComponent.getChildren().clear();

        setPreferredColor(
            motherlode.shouldStopMining() ? new Color(255,0,0, 70) :
            motherlode.sackCanBeMoreThanFull() ? new Color(255, 165, 0, 70) :
            motherlode.shouldDepositPaydirt() ? new Color(0, 255, 0, 70) :
            null
        );


        if (config.showGoldenNuggetsTotal() || config.showGoldenNuggetsSession()) {
            String nuggets = "";

            if (config.showGoldenNuggetsTotal()) {
                nuggets += motherlode.getGoldenNuggetsTotal();
            }

            if (config.showGoldenNuggetsSession()) {
                nuggets += config.showGoldenNuggetsTotal() ? " (+" + motherlode.getGoldenNuggetsSession() + ")" : motherlode.getGoldenNuggetsSession();
            }

            panelComponent.getChildren().add(LineComponent.builder()
                .left("Nuggets:")
                .right(nuggets).rightColor(Color.ORANGE)
                .build()
            );
        }

        if (config.showSackAndHopperPaydirt() || config.showSackSize()) {
            String paydirt = "";

            if (config.showSackAndHopperPaydirt()) {
                paydirt += motherlode.getDepositedPaydirt();

                if (config.showSackPaydirtFromInventory()) {
                    paydirt += " + " + motherlode.getInventoryPaydirt();
                }
            }

            if (config.showSackSize()) {
                if (config.showSackAndHopperPaydirt()) {
                    paydirt += " / ";
                }

                paydirt += motherlode.getSackSize();
            }

            panelComponent.getChildren().add(LineComponent.builder().left("Sack:").right(paydirt).build());
        }

        if (config.showSackDeposits()) {
            panelComponent.getChildren().add(LineComponent.builder()
                .left("Deposits:")
                .right(motherlode.getDepositsLeft() + "")
                .build()
            );
        }

        if (config.showSackNeeded()) {
            panelComponent.getChildren().add(LineComponent.builder()
                .left("Needed:")
                .right(motherlode.getNeededPaydirt() + "").rightColor(
                    (motherlode.getSpaceLeftToDeposit() == 0 || motherlode.getNeededPaydirt() == 0) ? Color.WHITE :
                    motherlode.getNeededPaydirt() < 0 ? Color.RED :
                    Color.GREEN )
                .build()
            );
        }

        return super.render(graphics2D);
    }
}

package tictac7x.motherlode.oreveins;

import net.runelite.api.Actor;
import net.runelite.api.AnimationID;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.WallObject;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.WallObjectDespawned;
import net.runelite.api.events.WallObjectSpawned;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ProgressPieComponent;
import tictac7x.motherlode.Motherlode;
import tictac7x.motherlode.Character;
import tictac7x.motherlode.TicTac7xMotherlodeConfig;

import javax.annotation.Nullable;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import static tictac7x.motherlode.TicTac7xMotherlodePlugin.getWorldObjectKey;

public class OreVeins extends Overlay {
    private final TicTac7xMotherlodeConfig config;
    private final Character character;
    private final Motherlode motherlode;

    public OreVeins(final TicTac7xMotherlodeConfig config, final Character character, final Motherlode motherlode) {
        this.config = config;
        this.character = character;
        this.motherlode = motherlode;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    public Map<String, OreVein> oreVeins = new HashMap<>();
    public Set<WallObject> oreVeinsWallObjects = new HashSet<>();

    public void onWallObjectSpawned(final WallObjectSpawned event) {
        final WallObject wallObject = event.getWallObject();
        final boolean isOreVein = OreVein.isOreVein(wallObject);
        final boolean isDepletedOreVein = OreVein.isDepletedOreVein(wallObject);
        if (!isOreVein && !isDepletedOreVein) return;

        updateOreVein(wallObject, isDepletedOreVein);
        oreVeinsWallObjects.add(event.getWallObject());
    }

    public void onWallObjectDespawned(final WallObjectDespawned event) {
        final WallObject wallObject = event.getWallObject();
        final boolean isOreVein = OreVein.isOreVein(wallObject);
        final boolean isDepletedOreVein = OreVein.isDepletedOreVein(wallObject);
        if (!isOreVein && !isDepletedOreVein) return;

        updateOreVein(wallObject, isDepletedOreVein);
        oreVeinsWallObjects.remove(event.getWallObject());
    }

    public void onGameStateChanged(final GameStateChanged event) {
        if (event.getGameState() == GameState.LOADING) {
            oreVeinsWallObjects.clear();
        }
    }

    public void onAnimationChanged(final AnimationChanged event) {
        setOreVeinMinedFromAnimation(event);
    }

    public void onGameTick() {
        for (final OreVein oreVein : oreVeins.values()) {
            oreVein.onGameTick();
        }
    }

    private void updateOreVein(final WallObject wallObject, final boolean isDepleted) {
        final String key = getWorldObjectKey(wallObject);

        if (oreVeins.containsKey(key)) {
            oreVeins.get(key).setDepleted(isDepleted);
        } else {
            oreVeins.put(key, new OreVein(
                wallObject.getWorldLocation().getX(),
                wallObject.getWorldLocation().getY(),
                isDepleted
            ));
        }
    }

    private void setOreVeinMinedFromAnimation(final AnimationChanged event) {
        final Actor player = event.getActor();
        if (!isMiningAnimation(event.getActor().getAnimation())) return;

        final int playerX = player.getWorldLocation().getX();
        final int playerY = player.getWorldLocation().getY();
        final int playerOrientation = player.getOrientation();

        // Find correct ore vein based on actor orientation when mining.
        for (final OreVein oreVein : oreVeins.values()) {
            if (
                // Facing south.
                playerOrientation == 0 && playerX == oreVein.x && playerY == oreVein.y + 1 ||
                // Facing west.
                playerOrientation == 512 && playerX == oreVein.x + 1 && playerY == oreVein.y ||
                // Facing north.
                playerOrientation == 1024 && playerX == oreVein.x && playerY == oreVein.y - 1 ||
                // Facing east.
                playerOrientation == 1536 && playerX == oreVein.x - 1 && playerY == oreVein.y
            ) {
                oreVein.startDepleting();
            }
        }
    }

    @Nullable
    private OreVein getOreVeinFromWallObject(final WallObject wallObject) {
        return oreVeins.getOrDefault(getWorldObjectKey(wallObject), null);
    }

    @Override
    public Dimension render(final Graphics2D graphics2D) {
        for (final WallObject wallObject : oreVeinsWallObjects) {
            final OreVein oreVein = getOreVeinFromWallObject(wallObject);
            if (oreVein == null || !oreVein.isRendering(config, character)) continue;

            renderPie(graphics2D, wallObject, oreVein.getPieColor(config, motherlode), oreVein.getPieProgress());
        }

        return null;
    }

    private void renderPie(final Graphics2D graphics, final WallObject object, final Color color, final float progress) {
        try {
            final ProgressPieComponent progressPieComponentBackground = new ProgressPieComponent();
            progressPieComponentBackground.setPosition(object.getCanvasLocation(160));
            progressPieComponentBackground.setProgress(1);
            progressPieComponentBackground.setFill(new Color(color.getRed(), color.getGreen(), color.getBlue(), Math.max(color.getAlpha() - 100, 0)));
            progressPieComponentBackground.render(graphics);

            final ProgressPieComponent progressPieComponentTimer = new ProgressPieComponent();
            progressPieComponentTimer.setPosition(object.getCanvasLocation(160));
            progressPieComponentTimer.setProgress(progress);
            progressPieComponentTimer.setBorderColor(color);
            progressPieComponentTimer.setFill(new Color(color.getRed(), color.getGreen(), color.getBlue(), Math.max(color.getAlpha() - 20, 0)));
            progressPieComponentTimer.render(graphics);
        } catch (final Exception ignored) {}
    }

    private boolean isMiningAnimation(final int animationId) {
        switch (animationId) {
            case AnimationID.MINING_MOTHERLODE_BRONZE:
            case AnimationID.MINING_MOTHERLODE_IRON:
            case AnimationID.MINING_MOTHERLODE_STEEL:
            case AnimationID.MINING_MOTHERLODE_BLACK:
            case AnimationID.MINING_MOTHERLODE_MITHRIL:
            case AnimationID.MINING_MOTHERLODE_ADAMANT:
            case AnimationID.MINING_MOTHERLODE_RUNE:
            case AnimationID.MINING_MOTHERLODE_DRAGON:
            case AnimationID.MINING_MOTHERLODE_DRAGON_OR:
            case AnimationID.MINING_MOTHERLODE_DRAGON_UPGRADED:
            case AnimationID.MINING_MOTHERLODE_DRAGON_OR_TRAILBLAZER:
            case AnimationID.MINING_MOTHERLODE_3A:
            case AnimationID.MINING_MOTHERLODE_CRYSTAL:
            case AnimationID.MINING_MOTHERLODE_INFERNAL:
            case AnimationID.MINING_MOTHERLODE_GILDED:
            case AnimationID.MINING_MOTHERLODE_TRAILBLAZER:
                return true;
            default:
                return false;
        }
    }
}
package tictac7x.motherlode.oreveins;

import net.runelite.api.WallObject;
import tictac7x.motherlode.Motherlode;
import tictac7x.motherlode.sectors.Sectors;
import tictac7x.motherlode.Character;
import tictac7x.motherlode.sectors.Sector;
import tictac7x.motherlode.TicTac7xMotherlodeConfig;

import java.awt.Color;

public class OreVein {
    public final int x;
    public final int y;
    private boolean isDepleted;
    private boolean isDepleting;
    private float health;
    public final Sector sector;

    private final int RESPAWN_TIME_GAMETICKS = 100;
    private final int DESPAWN_TIME_DOWNSTAIRS_GAMETICKS = 45;
    private final int DESPAWN_TIME_UPPERFLOOR_GAMETICKS = 67;
    private static final int[] ORE_VEINS_IDS = new int[]{ 26661, 26662, 26663, 26664};
    private static final int[] DEPLETED_ORE_VEINS_IDS = new int[]{ 26665, 26666, 26667, 26668 };

    public OreVein(final int x, final int y, final boolean isDepleted) {
        this.x = x;
        this.y = y;
        this.isDepleted = isDepleted;
        this.sector = Sectors.getSectors(x, y, false).get(0);
        this.health = getMaxHealth();
    }

    public void setDepleted(final boolean isDepleted) {
        if (this.isDepleted == isDepleted) return;

        this.isDepleted = isDepleted;
        this.health = isDepleted ? 0 : getMaxHealth();
        this.isDepleting = false;
    }

    public void startDepleting() {
        isDepleting = true;
    }

    public void onGameTick() {
        if (isDepleted) {
            health += (getMaxHealth()) / RESPAWN_TIME_GAMETICKS;
        } else if (isDepleting) {
            health = Math.max(health - 1, 0);
        }
    }

    public float getPieProgress() {
        return health / getMaxHealth() * (isDepleted ? -1 : 1);
    }

    public Color getPieColor(final TicTac7xMotherlodeConfig config, final Motherlode motherlode) {
        return
            motherlode.shouldStopMining() ? config.getOreVeinsStoppingColor() :
            isDepleted ? config.getOreVeinsDepletedColor() :
            config.getOreVeinsColor();
    }

    public boolean isRendering(final TicTac7xMotherlodeConfig config, final Character character) {
        if (config.upstairsOnly() && sector == Sector.DOWNSTAIRS) {
            return false;
        }

        if (!character.getSectors().contains(sector)) {
            return false;
        }

        return true;
    }

    private float getMaxHealth() {
        return sector == Sector.DOWNSTAIRS
            ? DESPAWN_TIME_DOWNSTAIRS_GAMETICKS
            : DESPAWN_TIME_UPPERFLOOR_GAMETICKS;
    }

    public static boolean isOreVein(final WallObject wallObject) {
        for (final int oreVeinId : ORE_VEINS_IDS) {
            if (wallObject.getId() == oreVeinId) return true;
        }

        return false;
    }

    public static boolean isDepletedOreVein(final WallObject wallObject) {
        for (final int depletedOreVeinId : DEPLETED_ORE_VEINS_IDS) {
            if (wallObject.getId() == depletedOreVeinId) return true;
        }

        return false;
    }
}

package tictac7x.motherlode.sectors;

public enum Sector {
    DOWNSTAIRS,
    UPSTAIRS_W,
    UPSTAIRS_NW,
    UPSTAIRS_SE,
    UPSTAIRS_S,
    UPSTAIRS_NE,
    UPSTAIRS_E
}

package tictac7x.motherlode.sectors;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Sectors {
    public static List<Sector> getSectors(final int x, final int y, final boolean multi) {
        final List<Sector> sectors = new ArrayList<>();
        final int[] location = new int[]{x, y};

        if (isInSector(UPSTAIRS_W, location)) {
            sectors.add(Sector.UPSTAIRS_W);
            if (!multi) return sectors;
        }
        if (isInSector(UPSTAIRS_NW, location)) {
            sectors.add(Sector.UPSTAIRS_NW);
            if (!multi) return sectors;
        }
        if (isInSector(UPSTAIRS_SE, location)) {
            sectors.add(Sector.UPSTAIRS_SE);
            if (!multi) return sectors;
        }
        if (isInSector(UPSTAIRS_S, location)) {
            sectors.add(Sector.UPSTAIRS_S);
            if (!multi) return sectors;
        }
        if (isInSector(UPSTAIRS_NE, location)) {
            sectors.add(Sector.UPSTAIRS_NE);
            if (!multi) return sectors;
        }
        if (isInSector(UPSTAIRS_E, location)) {
            sectors.add(Sector.UPSTAIRS_E);
            if (!multi) return sectors;
        }

        if (sectors.isEmpty()) {
            sectors.add(Sector.DOWNSTAIRS);
        }

        return sectors;
    }

    private static boolean isInSector(final int[][] sector, final int[] location) {
        for (int[] point : sector) {
            if (Arrays.equals(point, location)) {
                return true;
            }
        }

        return false;
    }

    private static final int[][] UPSTAIRS_W = {
            {3734, 5685},
            {3735, 5684}, {3735, 5685}, {3735, 5686},
            {3736, 5685},
            {3737, 5682}, {3737, 5683}, {3737, 5684}, {3737, 5685},
            {3738, 5682}, {3738, 5683}, {3738, 5684}, {3738, 5685},
            {3739, 5683}, {3739, 5684}, {3739, 5685},
            {3740, 5684}, {3740, 5685}, {3740, 5686},
            {3741, 5683}, {3741, 5684}, {3741, 5685}, {3741, 5686},
            {3742, 5683}, {3742, 5684}, {3742, 5685}, {3742, 5686},
            {3743, 5684}, {3743, 5686}, {3743, 5687},
            {3744, 5686}, {3744, 5687},
            {3745, 5684}, {3745, 5685}, {3745, 5686},
            {3746, 5684}, {3746, 5685}, {3746, 5686},
            {3747, 5685}, {3747, 5686},
            {3748, 5684}, {3748, 5685}
    };

    private static final int[][] UPSTAIRS_NW = {
            {3747, 5683},
            {3748, 5682}, {3748, 5683}, {3748, 5684},
            {3749, 5682}, {3749, 5683}, {3749, 5684},
            {3750, 5682}, {3750, 5683}, {3750, 5684}, {3750, 5685},
            {3751, 5678}, {3751, 5680}, {3751, 5681}, {3751, 5683}, {3751, 5684},
            {3752, 5676}, {3752, 5677}, {3752, 5678}, {3752, 5679}, {3752, 5680}, {3752, 5681}, {3752, 5682}, {3752, 5683}, {3752, 5684},
            {3753, 5676}, {3753, 5677}, {3753, 5678}, {3753, 5680}, {3753, 5682}, {3753, 5683}, {3753, 5684},
            {3754, 5675}, {3754, 5676}, {3754, 5677},{3754, 5678}, {3754, 5682}, {3754, 5683},
            {3755, 5675}, {3755, 5676}, {3755, 5677}
    };

    private static final int[][] UPSTAIRS_SE = {
            {3755, 5675}, {3755, 5676},
            {3756, 5674}, {3756, 5675}, {3756, 5676},
            {3757, 5673}, {3757, 5674}, {3757, 5675}, {3757, 5676},
            {3758, 5673}, {3758, 5675},
            {3759, 5672}, {3759, 5673}, {3759, 5674},
            {3760, 5671}, {3760, 5672}, {3760, 5673}, {3760, 5674},
            {3761, 5668}, {3761, 5669}, {3761, 5670}, {3761, 5671}, {3761, 5672}, {3761, 5673}, {3761, 5674},
            {3762, 5668}, {3762, 5670}, {3762, 5671}, {3762, 5672}, {3762, 5673}
    };

    private static final int[][] UPSTAIRS_S = {
            {3761, 5660}, {3761, 5661}, {3761, 5662}, {3761, 5663}, {3761, 5664},
            {3762, 5657}, {3762, 5658}, {3762, 5660}, {3762, 5661}, {3762, 5662}, {3762, 5663}, {3762, 5664}, {3762, 5665}, {3762, 5667}, {3762, 5668},
            {3763, 5656}, {3763, 5657}, {3763, 5658}, {3763, 5659}, {3763, 5660}, {3763, 5662}, {3763, 5663}, {3763, 5665}, {3763, 5666}, {3763, 5667}, {3763, 5668}, {3763, 5670},
            {3764, 5656}, {3764, 5657}, {3764, 5658}, {3764, 5659}, {3764, 5665}, {3764, 5667}, {3764, 5668}, {3764, 5669}, {3764, 5670},
            {3765, 5656}, {3765, 5657}, {3765, 5658},
            {3766, 5657}
    };

    private static final int[][] UPSTAIRS_NE = {
            {3755, 5675}, {3755, 5676}, {3755, 5681}, {3755, 5682}, {3755, 5683},
            {3756, 5676}, {3756, 5677}, {3756, 5678}, {3756, 5679}, {3756, 5681}, {3756, 5682}, {3756, 5683}, {3756, 5684},
            {3757, 5676}, {3757, 5677}, {3757, 5678}, {3757, 5679}, {3757, 5680}, {3757, 5681}, {3757, 5682}, {3757, 5683}, {3757, 5684},
            {3758, 5680}, {3758, 5681}, {3758, 5683}, {3758, 5685},
            {3759, 5682}, {3759, 5683}, {3759, 5684}, {3759, 5685},
            {3760, 5683}, {3760, 5684}, {3760, 5685},
            {3761, 5681}, {3761, 5682}, {3761, 5683}, {3761, 5684}, {3761, 5685},
            {3762, 5682}, {3762, 5683}
    };

    private static final int[][] UPSTAIRS_E = {
            {3755, 5675}, {3755, 5676},
            {3756, 5676}, {3756, 5677},
            {3757, 5676}, {3757, 5677},
            {3758, 5677}, {3758, 5678},
            {3759, 5676}, {3759, 5677}, {3759, 5678},
            {3760, 5677}, {3760, 5678}, {3760, 5679}, {3760, 5680},
            {3761, 5675}, {3761, 5676}, {3761, 5677}, {3761, 5678}, {3761, 5679}, {3761, 5680},
            {3762, 5675}, {3762, 5676}, {3762, 5677}, {3762, 5678}, {3762, 5679}, {3762, 5680},
            {3763, 5678}, {3763, 5679}, {3763, 5678}, {3763, 5681}, {3763, 5682}, {3763, 5683},
            {3764, 5677}, {3764, 5678}, {3764, 5679}, {3764, 5680}, {3764, 5681}, {3764, 5682}, {3764, 5683},
            {3765, 5677}, {3765, 5678}, {3765, 5679},
            {3766, 5678}
    };
}

package tictac7x.motherlode;

import net.runelite.api.AnimationID;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.VarbitChanged;

public class Hopper {
    private final Client client;
    private final Inventory inventory;
    private int paydirt = 0;

    public Hopper(final Client client, final Inventory inventory) {
        this.client = client;
        this.inventory = inventory;
    }

    public int getPaydirt() {
        return paydirt;
    }

    public void onAnimationChanged(final AnimationChanged event) {
        if (event.getActor() == client.getLocalPlayer() && event.getActor().getAnimation() == AnimationID.LOOKING_INTO) {
            paydirt = inventory.getPaydirt();
        }
    }

    public void onVarbitChanged(final VarbitChanged event) {
        if (event.getVarbitId() == Varbits.SACK_NUMBER) {
            paydirt = 0;
        }
    }
}

package tictac7x.motherlode;

import net.runelite.api.Client;
import net.runelite.api.Varbits;


public class Sack {
    private final Client client;

    private final int SACK_SIZE_SMALL = 108;
    private final int SACK_SIZE_UPGRADED = 189;

    public Sack(final Client client) {
        this.client = client;
    }

    public int getPaydirt() {
        return client.getVarbitValue(Varbits.SACK_NUMBER);
    }

    private boolean isSackUpgraded() {
        return client.getVarbitValue(Varbits.SACK_UPGRADED) == 1;
    }

    public int getSize() {
        return isSackUpgraded() ? SACK_SIZE_UPGRADED : SACK_SIZE_SMALL;
    }
}

package tictac7x.motherlode;

import net.runelite.client.config.*;
import java.awt.Color;

@ConfigGroup(TicTac7xMotherlodeConfig.group)
public interface TicTac7xMotherlodeConfig extends Config {
	String group = "tictac7x-motherlode";
	String sack_custom = "sack_custom";
	String bank_golden_nuggets = "bank_golden_nuggets";
	String version = "version";

	@ConfigItem(
		keyName = bank_golden_nuggets,
		name = bank_golden_nuggets,
		description = bank_golden_nuggets,
		hidden = true
	) default int getBankGoldenNuggets() { return 0; }

	@ConfigItem(
		keyName = version,
		name = version,
		description = version,
		hidden = true
	) default String getVersion() { return "0"; }

	@ConfigSection(
		name = "General",
		description = "General options to improve overall experience.",
		position = 1
	) String general = "general";

		@ConfigItem(
			keyName = "upstairs_only",
			name = "Only upstairs veins and rockfalls",
			description = "Highlight only upstairs ore veins and rockfalls.",
			position = 1,
			section = general
		) default boolean upstairsOnly() { return false; }

		@ConfigItem(
			keyName = "notify_to_stop_mining",
			name = "Notify to stop mining",
			description = "Notifies user to stop mining when sack would become full with already owned paydirt.",
			position = 2,
			section = general
		) default boolean notifyToStopMining() { return true; }

		@ConfigSection(
			name = "Ore veins and rockfalls",
			description = "Highlight ore veins and rockfalls based on their states.",
			position = 2
		) String ore_veins_and_rockfalls = "ore_veins_and_rockfalls";

		@Alpha
		@ConfigItem(
			keyName = "ore_veins",
			name = "Mineable Ore Veins",
			description = "Highlight ore veins that can be mined.",
			position = 1,
			section = ore_veins_and_rockfalls
		) default Color getOreVeinsColor() { return new Color(0, 255, 0, 140); }

		@Alpha
		@ConfigItem(
			keyName = "ore_veins_depleted",
			name = "Depleted Ore Veins",
			description = "Highlight ore veins that are depleted.",
			position = 2,
			section = ore_veins_and_rockfalls
		) default Color getOreVeinsDepletedColor() { return new Color(255, 180, 0, 140); }

		@Alpha
		@ConfigItem(
			keyName = "ore_veins_stop",
			name = "Stopping Ore Veins",
			description = "Highlight ore veins when they shouldn't be mined.",
			position = 3,
			section = ore_veins_and_rockfalls
		) default Color getOreVeinsStoppingColor() { return new Color(255, 0, 0, 140); }

		@Alpha
		@ConfigItem(
			keyName = "rockfalls",
			name = "Rockfalls",
			description = "Highlight rockfalls that need to be cleared.",
			position = 4,
			section = ore_veins_and_rockfalls
		) default Color getRockfallsColor() { return new Color(255, 0, 0, 80); }

	@ConfigSection(
		name = "Custom sack widget",
		description = "Show custom sack widget with helpful information.",
		position = 3
	) String custom_sack_widget = "custom_sack_widget";

		@ConfigItem(
			keyName = sack_custom,
			name = "Use custom sack widget",
			description = "Whether to show custom sack widget or not.",
			position = 1,
			section = custom_sack_widget
		) default boolean showCustomSackWidget() { return true; }

		@ConfigItem(
			keyName = "show_golden_nuggets_total",
			name = "Total golden nuggets",
			description = "Show the total number of golden nuggets that you have.",
			position = 2,
			section = custom_sack_widget
		) default boolean showGoldenNuggetsTotal() { return true; }

		@ConfigItem(
			keyName = "show_golden_nuggets_session",
			name = "Session golden nuggets",
			description = "Show the total number of golden nuggets you have found during this session.",
			position = 3,
			section = custom_sack_widget
		) default boolean showGoldenNuggetsSession() { return false; }

		@ConfigItem(
			keyName = "sack_paydirt",
			name = "Sack pay-dirt",
			description = "Show total number of pay-dirt in sack and hopper.",
			position = 4,
			section = custom_sack_widget
		) default boolean showSackAndHopperPaydirt() { return true; }

		@ConfigItem(
			keyName = "sack_paydirt_inventory",
			name = "Pay-dirt from inventory",
			description = "Show how many pay dirt will be added to the sack.",
			position = 5,
			section = custom_sack_widget
		) default boolean showSackPaydirtFromInventory() { return false; }

		@ConfigItem(
			keyName = "sack_size",
			name = "Sack total size",
			description = "Show total size of the sack.",
			position = 6,
			section = custom_sack_widget
		) default boolean showSackSize() { return true; }

		@ConfigItem(
			keyName = "sack_deposits",
			name = "Deposits left",
			description = "Show number of inventories you can store before sack gets full.",
			position = 7,
			section = custom_sack_widget
		) default boolean showSackDeposits() { return true; }

		@ConfigItem(
			keyName = "sack_needed",
			name = "Needed pay-dirt",
			description = "Show number of pay-dirt needed to mine before you should deposit the pay-dirt.",
			position = 8,
			section = custom_sack_widget
		) default boolean showSackNeeded() { return true; }


}

package tictac7x.motherlode;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class MotherlodePluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(TicTac7xMotherlodePlugin.class);
		RuneLite.main(args);
	}
}
