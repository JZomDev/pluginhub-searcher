package bbp.equipmentscreenshot;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class EquipmentScreenshotPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(EquipmentScreenshotPlugin.class);
		RuneLite.main(args);
	}
}

/*
 * Copyright (c) 2017, Tyler <http://github.com/tylerthardy>
 * Copyright (c) 2022, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package bbp.equipmentscreenshot;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.Point;
import net.runelite.api.Varbits;
import net.runelite.api.annotations.Varbit;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayUtil;

class EquipmentRunepouchOverlay
{
	private static final int NUM_SLOTS = 4;
	private static final int[] AMOUNT_VARBITS = {
			Varbits.RUNE_POUCH_AMOUNT1, Varbits.RUNE_POUCH_AMOUNT2, Varbits.RUNE_POUCH_AMOUNT3, Varbits.RUNE_POUCH_AMOUNT4
	};
	private static final int[] RUNE_VARBITS = {
			Varbits.RUNE_POUCH_RUNE1, Varbits.RUNE_POUCH_RUNE2, Varbits.RUNE_POUCH_RUNE3, Varbits.RUNE_POUCH_RUNE4
	};
	private static final Dimension IMAGE_SIZE = new Dimension(11, 11);
	private BufferedImage[] runeIcons = new BufferedImage[0];

	@Inject
	private Client client;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private EquipmentScreenshotConfig config;

	@Inject
	private EquipmentScreenshotUtil util;

	void renderRunepouchOverlay(Graphics2D graphics, Point location)
	{
		boolean showIcons = true;
		if (configManager.getConfiguration("runepouch", "runeicons", Boolean.class) != null)
			showIcons = configManager.getConfiguration("runepouch", "runeicons", Boolean.class);

		final int[] runeIds = new int[NUM_SLOTS];
		final int[] amounts = new int[NUM_SLOTS];
		final EnumComposition runepouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);
		int num = 0;

		for (int i = 0; i < NUM_SLOTS; i++)
		{
			@Varbit int amountVarbit = AMOUNT_VARBITS[i];
			int amount = client.getVarbitValue(amountVarbit);
			amounts[i] = amount;

			@Varbit int runeVarbit = RUNE_VARBITS[i];
			int runeId = client.getVarbitValue(runeVarbit);
			runeIds[i] = runeId;

			if (runeId != 0 && amount > 0)
			{
				++num;
			}
		}

		if (num == 0)
		{
			return;
		}

		if (num < 4)
		{
			renderList(graphics, location, runepouchEnum, runeIds, amounts);
		}
		else
		{
			renderGrid(graphics, location, runepouchEnum, runeIds, amounts);
		}
	}

	private void renderList(Graphics2D graphics, Point location, EnumComposition runepouchEnum, int[] runeIds, int[] amounts)
	{
		graphics.setFont(FontManager.getRunescapeSmallFont());

		int runeNum = -1;
		for (int i = 0; i < NUM_SLOTS; ++i)
		{
			final int runeId = runeIds[i];
			final int amount = amounts[i];

			if (runeId == 0 || amount <= 0)
			{
				continue;
			}

			++runeNum;

			final String text = formatNumber(amount);
			final int textX = location.getX() + 11;
			final int textY = location.getY() + 12 + (graphics.getFontMetrics().getHeight() - 1) * runeNum;

			graphics.setColor(Color.BLACK);
			graphics.drawString(text, textX + 1, textY + 1);

			graphics.setColor(config.fontColor());
			graphics.drawString(text, textX, textY);

			BufferedImage image = getRuneImage(runepouchEnum, runeId);
			if (image != null)
			{
				OverlayUtil.renderImageLocation(graphics,
						new Point(
								location.getX() - 1,
								location.getY() + graphics.getFontMetrics().getHeight() * runeNum - 1
						),
						image);
			}
		}
	}

	private void renderGrid(Graphics2D graphics, Point location, EnumComposition runepouchEnum, int[] runeIds, int[] amounts)
	{
		for (int i = 0; i < NUM_SLOTS; ++i)
		{
			final int runeId = runeIds[i];
			final int amount = amounts[i];

			if (runeId == -1 || amount <= 0)
			{
				continue;
			}

			final int iconX = location.getX() + 2 + (i == 1 || i == 3 ? IMAGE_SIZE.width + 2 /* pad */ + 2 /* bar offset */ : 0);
			final int iconY = location.getY() + 5 + (i >= 2 ? IMAGE_SIZE.height + 2 /* pad */ : 0);

			BufferedImage image = getRuneImage(runepouchEnum, runeId);
			if (image != null)
			{
				OverlayUtil.renderImageLocation(graphics,
						new Point(iconX, iconY),
						image);
			}

			final int height;
			final Color color;

			if (amount < 1000)
			{
				// with <1k runes, the bar is shown in red with 100 increments
				height = amount / 100;
				color = Color.RED;
			}
			else
			{
				// with >=1k runes, the bar is shown in 1000 increments capped at 10k
				height = Math.min(10, amount / 1000);
				color = Color.GREEN;
			}

			graphics.setColor(color);
			graphics.fillRect(iconX + IMAGE_SIZE.width, iconY + 1 + (10 - height), 2, height);
		}
	}

	private BufferedImage getRuneImage(EnumComposition runepouchEnum, int runeId)
	{
		if (runeId < runeIcons.length && runeIcons[runeId] != null)
		{
			return runeIcons[runeId];
		}

		BufferedImage runeImg = itemManager.getImage(runepouchEnum.getIntValue(runeId));
		if (runeImg == null)
		{
			return null;
		}

		BufferedImage resizedImg = new BufferedImage(IMAGE_SIZE.width, IMAGE_SIZE.height, BufferedImage.TYPE_INT_ARGB);
		Graphics2D g = resizedImg.createGraphics();
		g.drawImage(runeImg, 0, 0, IMAGE_SIZE.width, IMAGE_SIZE.height, null);
		g.dispose();

		if (runeId >= runeIcons.length)
		{
			runeIcons = Arrays.copyOf(runeIcons, runeId + 1);
		}
		runeIcons[runeId] = resizedImg;
		return resizedImg;
	}

	private static String formatNumber(int amount)
	{
		return amount < 1000 ? String.valueOf(amount) : amount / 1000 + "K";
	}
}


/*
 * Copyright (c) 2020, Truth Forger <http://github.com/Blackberry0Pie>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package bbp.equipmentscreenshot;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.inject.Provides;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import lombok.Getter;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.MenuAction;
import net.runelite.api.SpriteID;
import net.runelite.api.VarPlayer;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.menus.WidgetMenuOption;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageCapture;
import net.runelite.client.util.Text;
import net.runelite.http.api.item.ItemEquipmentStats;
import net.runelite.http.api.item.ItemStats;

@PluginDescriptor(
	name = "Equipment Screenshot",
	description = "Takes screenshots of inventory and equipt items",
	tags = {"items", "inventory", "equipment", "screenshot"},
	enabledByDefault = false
)
@Slf4j
public class EquipmentScreenshotPlugin extends Plugin
{
	private static final int INV_ROW_SIZE = 4;
	private static final int ITEM_H_SIZE = Constants.ITEM_SPRITE_WIDTH + 6 /*horizontal padding*/;
	private static final int ITEM_V_SIZE = Constants.ITEM_SPRITE_HEIGHT + 4 /*vertical padding*/;
	private static final int SPELLBOOK_VARBIT = 4070;
	private static final int COLUMN_WIDTH = 20; //actually 28 but we're cropping the side off
	private static final Map<EquipmentInventorySlot, Point> EQUIPMENT_ICON_LOCATIONS = new ImmutableMap.Builder<EquipmentInventorySlot, Point>().
			put(EquipmentInventorySlot.HEAD, new Point(77, 4)).
			put(EquipmentInventorySlot.CAPE, new Point(36, 43)).
			put(EquipmentInventorySlot.AMULET, new Point(77, 43)).
			put(EquipmentInventorySlot.WEAPON, new Point(21, 82)).
			put(EquipmentInventorySlot.BODY, new Point(77, 82)).
			put(EquipmentInventorySlot.SHIELD, new Point(133, 82)).
			put(EquipmentInventorySlot.LEGS, new Point(77, 122)).
			put(EquipmentInventorySlot.GLOVES, new Point(21, 162)).
			put(EquipmentInventorySlot.BOOTS, new Point(77, 162)).
			put(EquipmentInventorySlot.RING, new Point(133, 162)).
			put(EquipmentInventorySlot.AMMO, new Point(118, 43)).
			build();

	@Getter
	private int dartID;
	@Getter
	private int dartCount;
	@Getter
	private int scaleCount;
	private static final Pattern BLOWPIPE_REGEX = Pattern.compile("Darts: (.*)\\. Scales: ([0-9,]+) .*");
	private static final Pattern DARTS_REGEX = Pattern.compile("(.*) x ([0-9,]+)");
	private static final Map<String, Integer> DART_IDS = new ImmutableMap.Builder<String, Integer>().
			put("Bronze dart", ItemID.BRONZE_DART).
			put("Iron dart", ItemID.IRON_DART).
			put("Steel dart", ItemID.STEEL_DART).
			put("Black dart", ItemID.BLACK_DART).
			put("Mithril dart", ItemID.MITHRIL_DART).
			put("Adamant dart", ItemID.ADAMANT_DART).
			put("Rune dart", ItemID.RUNE_DART).
			put("Amethyst dart", ItemID.AMETHYST_DART).
			put("Dragon dart", ItemID.DRAGON_DART).
			build();

	private static final List<Integer> SNOWFLAKE_MAGIC_WEAPONS = new ImmutableList.Builder<Integer>().
			add(ItemID.GUTHIX_STAFF).
			add(ItemID.SARADOMIN_STAFF).
			add(ItemID.ZAMORAK_STAFF).
			add(ItemID.VOID_KNIGHT_MACE).
			add(ItemID.VOID_KNIGHT_MACE_L).
			build();

	private static final List<Integer> SNOWFLAKE_RANGED_WEAPONS = new ImmutableList.Builder<Integer>().
			add(ItemID.CRYSTAL_BOW).
			add(ItemID.BOW_OF_FAERDHINEN).
			add(ItemID.CRAWS_BOW).
			add(ItemID.CRAWS_BOW_U).
			add(ItemID.TOXIC_BLOWPIPE).
			add(ItemID.TOXIC_BLOWPIPE_EMPTY).
			build();

	private static final List<Integer> SALAMANDERS = new ImmutableList.Builder<Integer>().
			add(ItemID.SWAMP_LIZARD).
			add(ItemID.ORANGE_SALAMANDER).
			add(ItemID.RED_SALAMANDER).
			add(ItemID.BLACK_SALAMANDER).
			build();

	private static final List<Integer> THROWN_WEAPONS = new ImmutableList.Builder<Integer>().
			// Darts
			add(ItemID.BRONZE_DART).
			add(ItemID.IRON_DART).
			add(ItemID.STEEL_DART).
			add(ItemID.BLACK_DART).
			add(ItemID.MITHRIL_DART).
			add(ItemID.ADAMANT_DART).
			add(ItemID.RUNE_DART).
			add(ItemID.AMETHYST_DART).
			add(ItemID.DRAGON_DART).
			add(ItemID.BRONZE_DARTP).
			add(ItemID.IRON_DARTP).
			add(ItemID.STEEL_DARTP).
			add(ItemID.BLACK_DARTP).
			add(ItemID.MITHRIL_DARTP).
			add(ItemID.ADAMANT_DARTP).
			add(ItemID.RUNE_DARTP).
			add(ItemID.AMETHYST_DARTP).
			add(ItemID.DRAGON_DARTP).
			add(ItemID.BRONZE_DARTP_5628).
			add(ItemID.IRON_DARTP_5636).
			add(ItemID.STEEL_DARTP_5630).
			add(ItemID.BLACK_DARTP_5631).
			add(ItemID.MITHRIL_DARTP_5632).
			add(ItemID.ADAMANT_DARTP_5633).
			add(ItemID.RUNE_DARTP_5634).
			add(ItemID.AMETHYST_DARTP_25855).
			add(ItemID.DRAGON_DARTP_11233).
			add(ItemID.BRONZE_DARTP_5635).
			add(ItemID.IRON_DARTP_5636).
			add(ItemID.STEEL_DARTP_5637).
			add(ItemID.BLACK_DARTP_5638).
			add(ItemID.MITHRIL_DARTP_5639).
			add(ItemID.ADAMANT_DARTP_5640).
			add(ItemID.RUNE_DARTP_5641).
			add(ItemID.AMETHYST_DARTP_25857).
			add(ItemID.DRAGON_DARTP_11234).

			// Knives
			add(ItemID.BRONZE_KNIFE).
			add(ItemID.IRON_KNIFE).
			add(ItemID.STEEL_KNIFE).
			add(ItemID.BLACK_KNIFE).
			add(ItemID.MITHRIL_KNIFE).
			add(ItemID.ADAMANT_KNIFE).
			add(ItemID.RUNE_KNIFE).
			add(ItemID.DRAGON_KNIFE).
			add(ItemID.BRONZE_KNIFEP).
			add(ItemID.IRON_KNIFEP).
			add(ItemID.STEEL_KNIFEP).
			add(ItemID.BLACK_KNIFEP).
			add(ItemID.MITHRIL_KNIFEP).
			add(ItemID.ADAMANT_KNIFEP).
			add(ItemID.RUNE_KNIFEP).
			add(ItemID.DRAGON_KNIFEP).
			add(ItemID.BRONZE_KNIFEP_5654).
			add(ItemID.IRON_KNIFEP_5655).
			add(ItemID.STEEL_KNIFEP_5656).
			add(ItemID.BLACK_KNIFEP_5658).
			add(ItemID.MITHRIL_KNIFEP_5657).
			add(ItemID.ADAMANT_KNIFEP_5659).
			add(ItemID.RUNE_KNIFEP_5660).
			add(ItemID.DRAGON_KNIFEP_22808).
			add(ItemID.BRONZE_KNIFEP_5661).
			add(ItemID.IRON_KNIFEP_5662).
			add(ItemID.STEEL_KNIFEP_5663).
			add(ItemID.BLACK_KNIFEP_5665).
			add(ItemID.MITHRIL_KNIFEP_5664).
			add(ItemID.ADAMANT_KNIFEP_5666).
			add(ItemID.RUNE_KNIFEP_5667).
			add(ItemID.DRAGON_KNIFEP_22810).

			// Throwing Axes
			add(ItemID.BRONZE_THROWNAXE).
			add(ItemID.IRON_THROWNAXE).
			add(ItemID.STEEL_THROWNAXE).
			add(ItemID.MITHRIL_THROWNAXE).
			add(ItemID.ADAMANT_THROWNAXE).
			add(ItemID.RUNE_THROWNAXE).
			add(ItemID.DRAGON_THROWNAXE).
			add(ItemID.MORRIGANS_THROWING_AXE).

			// Snowflakes
			add(ItemID.CHINCHOMPA_10033).
			add(ItemID.RED_CHINCHOMPA_10034).
			add(ItemID.BLACK_CHINCHOMPA).
			add(ItemID.HOLY_WATER).
			add(ItemID.TOKTZXILUL).
			build();

	private static final Map<Integer, Double> WEIGHT_REDUCING_EQUIPMENT = new ImmutableMap.Builder<Integer, Double>().
			//item ids here are for the *worn* items, not inventory items
			put(ItemID.SPOTTED_CAPE_10073, 2.267).
			put(ItemID.SPOTTIER_CAPE_10074, 4.535).
			put(ItemID.BOOTS_OF_LIGHTNESS_89, 4.535).
			put(ItemID.PENANCE_GLOVES_10554, 4.535).
			//untested exact weights
			put(ItemID.AGILITY_CAPE_13340, 4d).
			put(ItemID.AGILITY_CAPET_13341, 4d).
			put(ItemID.MAX_CAPE_13342, 4d).
			//vanilla graceful
			put(ItemID.GRACEFUL_HOOD_11851, 3d).
			put(ItemID.GRACEFUL_CAPE_11853, 4d).
			put(ItemID.GRACEFUL_TOP_11855, 5d).
			put(ItemID.GRACEFUL_LEGS_11857, 6d).
			put(ItemID.GRACEFUL_GLOVES_11859, 3d).
			put(ItemID.GRACEFUL_BOOTS_11861, 4d).
			//Arceuus graceful
			put(ItemID.GRACEFUL_HOOD_13580, 3d).
			put(ItemID.GRACEFUL_CAPE_13582, 4d).
			put(ItemID.GRACEFUL_TOP_13584, 5d).
			put(ItemID.GRACEFUL_LEGS_13586, 6d).
			put(ItemID.GRACEFUL_GLOVES_13588, 3d).
			put(ItemID.GRACEFUL_BOOTS_13590, 4d).
			//Piscarilius graceful
			put(ItemID.GRACEFUL_HOOD_13592, 3d).
			put(ItemID.GRACEFUL_CAPE_13594, 4d).
			put(ItemID.GRACEFUL_TOP_13596, 5d).
			put(ItemID.GRACEFUL_LEGS_13598, 6d).
			put(ItemID.GRACEFUL_GLOVES_13600, 3d).
			put(ItemID.GRACEFUL_BOOTS_13602, 4d).
			//Lovakengj graceful
			put(ItemID.GRACEFUL_HOOD_13604, 3d).
			put(ItemID.GRACEFUL_CAPE_13606, 4d).
			put(ItemID.GRACEFUL_TOP_13608, 5d).
			put(ItemID.GRACEFUL_LEGS_13610, 6d).
			put(ItemID.GRACEFUL_GLOVES_13612, 3d).
			put(ItemID.GRACEFUL_BOOTS_13614, 4d).
			//Shayzien graceful
			put(ItemID.GRACEFUL_HOOD_13616, 3d).
			put(ItemID.GRACEFUL_CAPE_13618, 4d).
			put(ItemID.GRACEFUL_TOP_13620, 5d).
			put(ItemID.GRACEFUL_LEGS_13622, 6d).
			put(ItemID.GRACEFUL_GLOVES_13624, 3d).
			put(ItemID.GRACEFUL_BOOTS_13626, 4d).
			//Hosidius graceful
			put(ItemID.GRACEFUL_HOOD_13628, 3d).
			put(ItemID.GRACEFUL_CAPE_13630, 4d).
			put(ItemID.GRACEFUL_TOP_13632, 5d).
			put(ItemID.GRACEFUL_LEGS_13634, 6d).
			put(ItemID.GRACEFUL_GLOVES_13636, 3d).
			put(ItemID.GRACEFUL_BOOTS_13638, 4d).
			//Kourend graceful
			put(ItemID.GRACEFUL_HOOD_13668, 3d).
			put(ItemID.GRACEFUL_CAPE_13670, 4d).
			put(ItemID.GRACEFUL_TOP_13672, 5d).
			put(ItemID.GRACEFUL_LEGS_13674, 6d).
			put(ItemID.GRACEFUL_GLOVES_13676, 3d).
			put(ItemID.GRACEFUL_BOOTS_13678, 4d).
			//Brimhaven graceful
			put(ItemID.GRACEFUL_HOOD_21063, 3d).
			put(ItemID.GRACEFUL_CAPE_21066, 4d).
			put(ItemID.GRACEFUL_TOP_21069, 5d).
			put(ItemID.GRACEFUL_LEGS_21072, 6d).
			put(ItemID.GRACEFUL_GLOVES_21075, 3d).
			put(ItemID.GRACEFUL_BOOTS_21078, 4d).
			//Sepulchre graceful
			put(ItemID.GRACEFUL_HOOD_24745, 3d).
			put(ItemID.GRACEFUL_CAPE_24748, 4d).
			put(ItemID.GRACEFUL_TOP_24751, 5d).
			put(ItemID.GRACEFUL_LEGS_24754, 6d).
			put(ItemID.GRACEFUL_GLOVES_24757, 3d).
			put(ItemID.GRACEFUL_BOOTS_24760, 4d).
			//Trailblazer graceful
			put(ItemID.GRACEFUL_HOOD_25071, 3d).
			put(ItemID.GRACEFUL_CAPE_25074, 4d).
			put(ItemID.GRACEFUL_TOP_25077, 5d).
			put(ItemID.GRACEFUL_LEGS_25080, 6d).
			put(ItemID.GRACEFUL_GLOVES_25083, 3d).
			put(ItemID.GRACEFUL_BOOTS_25086, 4d).
			build();

	private static final String MENU_TARGET = "Equipment";
	private static final String TAKE_SCREENSHOT = "Screenshot";
	private static final WidgetMenuOption FIXED_EQUIPMENT_TAB_SCREENSHOT = new WidgetMenuOption(TAKE_SCREENSHOT,
			MENU_TARGET, WidgetInfo.FIXED_VIEWPORT_EQUIPMENT_TAB);
	private static final WidgetMenuOption RESIZABLE_EQUIPMENT_TAB_SCREENSHOT = new WidgetMenuOption(TAKE_SCREENSHOT,
			MENU_TARGET, WidgetInfo.RESIZABLE_VIEWPORT_EQUIPMENT_TAB);
	private static final WidgetMenuOption BOTTOM_LINE_INVENTORY_SCREENSHOT = new WidgetMenuOption(TAKE_SCREENSHOT,
			MENU_TARGET, WidgetInfo.RESIZABLE_VIEWPORT_BOTTOM_LINE_INVENTORY_TAB);

	private Widget button = null;
	private boolean useResourcePack = false;
	private double preciseWeight;
	private int weaponAmagic;
	private int weaponAranged;
	private int weaponSranged;
	private boolean isSalamander;
	private boolean isSnowflakeMagicWeapon;
	private int attackStyleVarbit = -1;

	@Inject
	private Client client;

	@Inject
	private ConfigManager configManager;

	@Inject
	private EquipmentScreenshotConfig config;

	@Inject
	private MenuManager menuManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	private SpriteManager spriteManager;

	@Inject
	private ImageCapture imageCapture;

	@Inject
	private ClientThread clientThread;

	@Inject
	private RuneLiteConfig runeLiteConfig;

	@Inject
	private EquipmentRunepouchOverlay equipmentRunepouchOverlay;

	@Inject
	private EquipmentBlowpipeOverlay equipmentBlowpipeOverlay;

	@Inject
	private EquipmentScreenshotUtil util;

	@Provides
	EquipmentScreenshotConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(EquipmentScreenshotConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		menuManager.addManagedCustomMenu(FIXED_EQUIPMENT_TAB_SCREENSHOT, null);
		menuManager.addManagedCustomMenu(RESIZABLE_EQUIPMENT_TAB_SCREENSHOT, null);
		menuManager.addManagedCustomMenu(BOTTOM_LINE_INVENTORY_SCREENSHOT, null);
		clientThread.invokeLater(this::createButton);
		useResourcePack = false;
		dartID = 0;
		dartCount = 0;
		scaleCount = 0;
		attackStyleVarbit = client.getVarpValue(VarPlayer.ATTACK_STYLE);
	}

	@Override
	protected void shutDown() throws Exception
	{
		menuManager.removeManagedCustomMenu(FIXED_EQUIPMENT_TAB_SCREENSHOT);
		menuManager.removeManagedCustomMenu(RESIZABLE_EQUIPMENT_TAB_SCREENSHOT);
		menuManager.removeManagedCustomMenu(BOTTOM_LINE_INVENTORY_SCREENSHOT);
		clientThread.invoke(this::hideButton);
	}

	@Subscribe
	public void onMenuOptionClicked(final MenuOptionClicked event)
	{
		if (event.getMenuAction() != MenuAction.RUNELITE)
			return;

		if (event.getMenuOption().equals(TAKE_SCREENSHOT))
			screenshotEquipment();
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)
			return;

		String message = event.getMessage();
		if (!message.startsWith("Darts: "))
			return;

		final Matcher m = BLOWPIPE_REGEX.matcher(Text.removeTags(message));
		if (m.find())
		{
			final Matcher n = DARTS_REGEX.matcher(m.group(1));
			if (n.find())
			{
				dartID = DART_IDS.get(n.group(1));
				dartCount = Integer.parseInt(n.group(2).replaceAll(",", ""));
			}
			else
			{
				dartID = 0;
				dartCount = 0;
			}

			scaleCount = Integer.parseInt(m.group(2).replaceAll(",", ""));
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		int currentAttackStyleVarbit = client.getVarpValue(VarPlayer.ATTACK_STYLE);
		if (attackStyleVarbit != currentAttackStyleVarbit)
			attackStyleVarbit = currentAttackStyleVarbit;
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals("equipmentscreenshot") && event.getKey().equals("button"))
		{
			if (config.button())
			{
				clientThread.invoke(this::createButton);
			}
			else
			{
				clientThread.invoke(this::hideButton);
			}
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (event.getGroupId() != WidgetID.EQUIPMENT_GROUP_ID)
		{
			return;
		}

		createButton();
	}

	private BufferedImage paintInventory(BufferedImage bi)
	{
		final ItemContainer itemContainer = client.getItemContainer(InventoryID.INVENTORY);
		if (itemContainer == null || util.isEmpty(itemContainer))
			return null;

		final Item[] items = itemContainer.getItems();

		Graphics2D g2d = bi.createGraphics();

		for (int i = 0; i < 28 /*inventory size*/; i++)
		{
			if (i < items.length)
			{
				final Item item = items[i];
				if (item.getQuantity() > 0)
				{
					final int itemId = item.getId();
					if (itemManager.getItemStats(itemId, false) != null &&
							!itemManager.getItemComposition(itemId).isStackable())
					{
						preciseWeight += itemManager.getItemStats(itemId, false).getWeight();
					}

					final BufferedImage image = util.getImage(item);
					if (image != null)
					{
						int x = 16 /*horizontal offset*/ + ITEM_H_SIZE * (i % INV_ROW_SIZE);
						int y = 8 /*vertical offset*/ + ITEM_V_SIZE * (i / INV_ROW_SIZE);
						g2d.drawImage(image, null, x, y);
						if (config.runepouchOverlay() && (itemId == ItemID.RUNE_POUCH || itemId == ItemID.RUNE_POUCH_L || itemId == ItemID.DIVINE_RUNE_POUCH))
						{
							equipmentRunepouchOverlay.renderRunepouchOverlay(g2d, new net.runelite.api.Point(x, y));
						}

						if (config.blowpipeOverlay() && itemId == ItemID.TOXIC_BLOWPIPE)
						{
							equipmentBlowpipeOverlay.renderBlowpipeOverlay(g2d, new net.runelite.api.Point(x, y));
						}
						g2d.setFont(FontManager.getRunescapeSmallFont());
					}
				}
			}
		}

		g2d.dispose();
		return bi;
	}

	private BufferedImage paintEquipment(BufferedImage bi)
	{
		final ItemContainer itemContainer = client.getItemContainer(InventoryID.EQUIPMENT);
		if (!config.showEmptyEquipment() && (itemContainer == null || util.isEmpty(itemContainer)))
			return null;

		final BufferedImage VERTICAL_RIVETS = util.getCroppedImageFromSpriteID(SpriteID.IRON_RIVETS_VERTICAL, useResourcePack);
		BufferedImage HORIZONTAL_RIVETS = util.getCroppedImageFromSpriteID(SpriteID.IRON_RIVETS_HORIZONTAL, useResourcePack);
		if (useResourcePack && HORIZONTAL_RIVETS.getHeight() > 6) // Crop the resouce pack image if it is doubled
			HORIZONTAL_RIVETS = HORIZONTAL_RIVETS.getSubimage(0, 0, HORIZONTAL_RIVETS.getWidth(), 6);
		final BufferedImage EQUIPMENT_SLOT = util.getCroppedImageFromSpriteID(SpriteID.EQUIPMENT_SLOT_TILE, useResourcePack);
		Graphics2D g2d = bi.createGraphics();

		util.tileImage(g2d, VERTICAL_RIVETS, new Point(92, 39), new Point(92, 163));
		util.tileImage(g2d, VERTICAL_RIVETS, new Point(36, 118), new Point(36, 163));
		util.tileImage(g2d, VERTICAL_RIVETS, new Point(148, 118), new Point(148, 163));

		util.tileImage(g2d, HORIZONTAL_RIVETS, new Point(56, 96), new Point(134, 96));
		util.tileImage(g2d, HORIZONTAL_RIVETS, new Point(71, 57), new Point(119, 57));

		final Map<EquipmentInventorySlot, BufferedImage> EQUIPMENT_ICONS = new ImmutableMap.Builder<EquipmentInventorySlot, BufferedImage>().
				put(EquipmentInventorySlot.HEAD, util.getImageFromSpriteID(SpriteID.EQUIPMENT_SLOT_HEAD, false, useResourcePack)).
				put(EquipmentInventorySlot.CAPE, util.getImageFromSpriteID(SpriteID.EQUIPMENT_SLOT_CAPE, false, useResourcePack)).
				put(EquipmentInventorySlot.AMULET, util.getImageFromSpriteID(SpriteID.EQUIPMENT_SLOT_NECK, false, useResourcePack)).
				put(EquipmentInventorySlot.WEAPON, util.getImageFromSpriteID(SpriteID.EQUIPMENT_SLOT_WEAPON, false, useResourcePack)).
				put(EquipmentInventorySlot.BODY, util.getImageFromSpriteID(SpriteID.EQUIPMENT_SLOT_TORSO, false, useResourcePack)).
				put(EquipmentInventorySlot.SHIELD, util.getImageFromSpriteID(SpriteID.EQUIPMENT_SLOT_SHIELD, false, useResourcePack)).
				put(EquipmentInventorySlot.LEGS, util.getImageFromSpriteID(SpriteID.EQUIPMENT_SLOT_LEGS, false, useResourcePack)).
				put(EquipmentInventorySlot.GLOVES, util.getImageFromSpriteID(SpriteID.EQUIPMENT_SLOT_HANDS, false, useResourcePack)).
				put(EquipmentInventorySlot.BOOTS, util.getImageFromSpriteID(SpriteID.EQUIPMENT_SLOT_FEET, false, useResourcePack)).
				put(EquipmentInventorySlot.RING, util.getImageFromSpriteID(SpriteID.EQUIPMENT_SLOT_RING, false, useResourcePack)).
				put(EquipmentInventorySlot.AMMO, util.getImageFromSpriteID(SpriteID.EQUIPMENT_SLOT_AMMUNITION, false, useResourcePack)).
				build();

		int prayer = 0;
		int str = 0;
		int rstr = 0;
		float mdmg = 0;

		int stabA = 0;
		int slashA = 0;
		int crushA = 0;
		int magicA = 0;
		int rangeA = 0;

		int stabD = 0;
		int slashD = 0;
		int crushD = 0;
		int magicD = 0;
		int rangeD = 0;

		Point p;
		for (EquipmentInventorySlot eis : EquipmentInventorySlot.values())
		{
			p = new Point(EQUIPMENT_ICON_LOCATIONS.get(eis).getLocation());
			g2d.drawImage(EQUIPMENT_SLOT, null, p.x, p.y);
			Item item = null;
			if (itemContainer != null)
				item = itemContainer.getItem(eis.getSlotIdx());
			if (item != null && item.getQuantity() > 0)
			{
				final int itemId = item.getId();
				if (config.showAllOptions() || config.showStats())
				{
					final ItemStats is = itemManager.getItemStats(itemId, false);
					if (is == null) {
						log.info("Error finding item stats for the {} slot with item {} using itemID: {}", eis.name().toLowerCase(), itemManager.getItemComposition(itemId).getName(), itemId);
						log.info("This probably means the itemID is new and not yet cached in the Runelite item stats database");
						continue;
					}
					final ItemEquipmentStats ies = is.getEquipment();
					prayer += ies.getPrayer();
					str += ies.getStr();
					if (!eis.equals(EquipmentInventorySlot.AMMO) ||
							itemContainer.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx()) == null ||
							(itemContainer.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx()) != null &&
							!THROWN_WEAPONS.contains(itemContainer.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx()).getId()) &&
							!SNOWFLAKE_RANGED_WEAPONS.contains(itemContainer.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx()).getId()) ))
					{
						rstr += ies.getRstr();
					}
					mdmg += ies.getMdmg();

					stabA += ies.getAstab();
					slashA += ies.getAslash();
					crushA += ies.getAcrush();
					magicA += ies.getAmagic();
					rangeA += ies.getArange();

					stabD += ies.getDstab();
					slashD += ies.getDslash();
					crushD += ies.getDcrush();
					magicD += ies.getDmagic();
					rangeD += ies.getDrange();

					if (eis.equals(EquipmentInventorySlot.WEAPON))
					{
						weaponAmagic = ies.getAmagic();
						weaponAranged = ies.getArange();
						weaponSranged = ies.getRstr();
						isSalamander = SALAMANDERS.contains(itemId);
						isSnowflakeMagicWeapon = SNOWFLAKE_MAGIC_WEAPONS.contains(itemId);
					}

					if (itemManager.getItemStats(itemId, false) != null &&
							!itemManager.getItemComposition(itemId).isStackable())
					{
						if (WEIGHT_REDUCING_EQUIPMENT.containsKey(itemId))
						{
							preciseWeight -= WEIGHT_REDUCING_EQUIPMENT.get(itemId);
						}
						else {
							preciseWeight += itemManager.getItemStats(itemId, false).getWeight();
						}
					}
				}

				final BufferedImage image = util.getImage(item);
				if (image != null)
				{
					g2d.drawImage(image, null, p.x + util.EQUIPMENT_PADDING, p.y + util.EQUIPMENT_PADDING);

					if (config.blowpipeOverlay() && itemId == ItemID.TOXIC_BLOWPIPE)
					{
						equipmentBlowpipeOverlay.renderBlowpipeOverlay(g2d, new net.runelite.api.Point(p.x, p.y));
					}
				}
			}
			else
			{
				util.drawEquipmentIcon(g2d, eis, p, EQUIPMENT_ICONS, useResourcePack);
			}
		}

		if (config.showAllOptions() || config.showStats())
		{
			// Add elite void mage set magic damage boost
			if (itemContainer != null)
			{
				Item head = itemContainer.getItem(EquipmentInventorySlot.HEAD.getSlotIdx());
				Item body = itemContainer.getItem(EquipmentInventorySlot.BODY.getSlotIdx());
				Item legs = itemContainer.getItem(EquipmentInventorySlot.LEGS.getSlotIdx());
				Item gloves = itemContainer.getItem(EquipmentInventorySlot.GLOVES.getSlotIdx());
				if (head != null && body != null && legs != null && gloves != null &&
						(head.getId() == ItemID.VOID_MAGE_HELM || head.getId() == ItemID.VOID_MAGE_HELM_L) &&
						(body.getId() == ItemID.ELITE_VOID_TOP || body.getId() == ItemID.ELITE_VOID_TOP_L) &&
						(legs.getId() == ItemID.ELITE_VOID_ROBE || legs.getId() == ItemID.ELITE_VOID_ROBE_L) &&
						(gloves.getId() == ItemID.VOID_KNIGHT_GLOVES || gloves.getId() == ItemID.VOID_KNIGHT_GLOVES_L))
				{
					mdmg += 2.5;
				}
			}

			// Add blowpipe ammo stats
			if (itemContainer != null)
			{
				Item weapon = itemContainer.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
				if (weapon != null && (weapon.getId() == ItemID.TOXIC_BLOWPIPE ||
						weapon.getId() == ItemID.TOXIC_BLOWPIPE_EMPTY) && dartID != 0)
				{
					final ItemStats is = itemManager.getItemStats(dartID, false);
					if(is != null)
					{
						final ItemEquipmentStats ies = is.getEquipment();
						rangeA += ies.getArange();
						rstr += ies.getRstr();
					}
				}
			}

			g2d.setFont(FontManager.getRunescapeSmallFont());
			g2d.setColor(config.fontColor());

			final BufferedImage MACIC_ICON = util.getCroppedImageFromSpriteID(SpriteID.SKILL_MAGIC, useResourcePack);
			final BufferedImage RANGED_ICON = util.getCroppedImageFromSpriteID(SpriteID.SKILL_RANGED, useResourcePack);
			final BufferedImage STR_ICON = util.getCroppedImageFromSpriteID(SpriteID.SKILL_STRENGTH, useResourcePack);
			BufferedImage MDMG_ICON = new BufferedImage(28, 29, STR_ICON.getType());
			Graphics2D g = MDMG_ICON.createGraphics();
			g.drawImage(STR_ICON, null, 12, 1);
			g.drawImage(MACIC_ICON, null, 0, 6);
			g.dispose();
			BufferedImage RSTR_ICON = new BufferedImage(23, 23, STR_ICON.getType());
			Graphics2D h = RSTR_ICON.createGraphics();
			h.drawImage(RANGED_ICON, null, 0, 0);
			h.drawImage(STR_ICON, null, 6, 1);
			h.dispose();

			if (config.showAllOptions() || config.showAllStr())
			{
				util.drawIconWithText(g2d, new Point(50, 22), MDMG_ICON, 1,
						mdmg + "%", true);
				util.drawIconWithText(g2d, new Point(170, 62), RSTR_ICON, 2,
						rstr, true);
				util.drawIconWithText(g2d, new Point(19, 62), STR_ICON, 2,
						str, true);
			}
			else
			{
				if (weaponAmagic >= 10 || isSnowflakeMagicWeapon || (isSalamander && attackStyleVarbit == 2))
				{
					util.drawIconWithText(g2d, new Point(50, 22), MDMG_ICON, 1,
							mdmg + "%", true);
				}
				else if ((!isSalamander && (weaponAranged > 0 || weaponSranged > 0)) || (isSalamander && attackStyleVarbit == 1))
				{
					util.drawIconWithText(g2d, new Point(50, 23), RSTR_ICON, 2,
							rstr, true);
				}
				else
				{
					util.drawIconWithText(g2d, new Point(50, 23), STR_ICON, 2,
							str, true);
				}
			}

			//Spellbook
			int spellBookID = SpriteID.TAB_MAGIC;
			String spellbook = "Modern";
			switch (client.getVarbitValue(SPELLBOOK_VARBIT))
			{
				case 1:
					spellBookID = SpriteID.TAB_MAGIC_SPELLBOOK_ANCIENT_MAGICKS;
					spellbook = "Ancient";
					break;
				case 2:
					spellBookID = SpriteID.TAB_MAGIC_SPELLBOOK_LUNAR;
					spellbook = "Lunar";
					break;
				case 3:
					spellBookID = SpriteID.TAB_MAGIC_SPELLBOOK_ARCEUUS;
					spellbook = "Arceuus";
					break;
			}
			if (!config.showAllOptions() && !config.writeSpellbook())
				spellbook = "";
			util.drawIconWithText(g2d, new Point(136, 23), spellBookID, useResourcePack, 2,
					spellbook, false);

			if (config.showAllOptions() || config.showPrayerAndWeight())
			{
				// Weight
				preciseWeight = new BigDecimal(preciseWeight).setScale(3, RoundingMode.HALF_UP).doubleValue();
				String weight = Double.toString(config.showAllOptions() || config.showPreciseWeight() ? preciseWeight : client.getWeight());
				util.drawIconWithText(g2d, new Point(59, 139), SpriteID.EQUIPMENT_WEIGHT, useResourcePack, 2,
						weight, false);

				// Prayer
				util.drawIconWithText(g2d, new Point(130, 139), SpriteID.SKILL_PRAYER, useResourcePack, 2,
						prayer, true);
			}

			// Equipment accuracy and defence
			final BufferedImage STAB_ICON = itemManager.getImage(ItemID.STEEL_DAGGER);
			final BufferedImage SLASH_ICON = itemManager.getImage(ItemID.STEEL_SCIMITAR);
			final BufferedImage CRUSH_ICON = itemManager.getImage(ItemID.STEEL_WARHAMMER);

			p = new Point(21, 228);
			util.drawStatIcon(g2d, p, STAB_ICON, stabA, stabD);
			util.drawStatIcon(g2d, util.nextIconPosition(p), SLASH_ICON, slashA, slashD);
			util.drawStatIcon(g2d, util.nextIconPosition(p), CRUSH_ICON, crushA, crushD);
			util.drawStatIcon(g2d, util.nextIconPosition(p), MACIC_ICON, magicA, magicD);
			util.drawStatIcon(g2d, util.nextIconPosition(p), RANGED_ICON, rangeA, rangeD);
		}

		g2d.dispose();
		return bi;
	}

	private void screenshotEquipment()
	{
		useResourcePack = config.useResourcePack() && isResourcePackActive();
		preciseWeight = 0;

		BufferedImage bi = util.getCroppedImageFromSpriteID(SpriteID.FIXED_MODE_SIDE_PANEL_BACKGROUND, useResourcePack);
		BufferedImage beq = util.copy(bi);
		BufferedImage binv = paintInventory(bi);
		BufferedImage beqpw = paintEquipment(beq);

		// Select image(s)
		BufferedImage frankensteinsMonster = null;
		if (binv != null)
		{
			if (beqpw != null)
			{
				int columnWidth = (config.columnBetween() ? COLUMN_WIDTH : 0);
				frankensteinsMonster = new BufferedImage(2 * binv.getWidth() + columnWidth,
						binv.getHeight(), 1);
				Graphics2D g2d = frankensteinsMonster.createGraphics();
				g2d.drawImage(binv, 0, 0, null);

				// Add column
				if (config.columnBetween())
				{
					final BufferedImage column = util.getCroppedImageFromSpriteID(SpriteID.OLD_SCHOOl_MODE_SIDE_PANEL_EDGE_RIGHT, useResourcePack).
							getSubimage(0, 0, COLUMN_WIDTH, binv.getHeight());
					g2d.drawImage(column, binv.getWidth(), 0, null);
				}

				g2d.drawImage(beqpw, binv.getWidth() + columnWidth, 0, null);
				g2d.dispose();
			}
			else
			{
				frankensteinsMonster = binv;
			}
		}
		else if (beqpw != null)
		{
			frankensteinsMonster = beqpw;
		}

		if (frankensteinsMonster != null)
			imageCapture.takeScreenshot(frankensteinsMonster, "Equipment-", config.notifyWhenTaken(), config.uploadScreenshot());
	}

	private boolean isResourcePackActive()
	{
		String str = configManager.getConfiguration("runelite", "resourcepacksplugin");
		if (str == null || str.equals("false") || str.isEmpty())
			return false;

		str = configManager.getConfiguration("resourcepacks", "resourcePack");
		if (str == null || str.isEmpty())
			return false;
		switch (str)
		{
			case "HUB":
				str = configManager.getConfiguration("resourcepacks", "selectedHubPack");
				if (str != null && !str.isEmpty())
					return true;
				break;
			case "FIRST":
				str = configManager.getConfiguration("resourcepacks", "resourcePackPath");
				if (str != null && !str.isEmpty())
					return true;
				break;
			case "SECOND":
				str = configManager.getConfiguration("resourcepacks", "resourcePack2Path");
				if (str != null && !str.isEmpty())
					return true;
				break;
			case "THIRD":
				str = configManager.getConfiguration("resourcepacks", "resourcePack3Path");
				if (str != null && !str.isEmpty())
					return true;
				break;
		}
		return false;
	}

	private void hideButton()
	{
		if (button == null)
		{
			return;
		}

		button.setHidden(true);
		button = null;
	}

	private void createButton()
	{
		if (!config.button())
		{
			return;
		}

		Widget parent = client.getWidget(WidgetInfo.EQUIPMENT);
		if (parent == null)
		{
			return;
		}

		hideButton();

		button = parent.createChild(-1, WidgetType.GRAPHIC);
		button.setOriginalHeight(20);
		button.setOriginalWidth(20);
		button.setOriginalX(48);
		button.setOriginalY(14);
		button.setSpriteId(573);
		button.setAction(0, "Screenshot");
		button.setOnOpListener((JavaScriptCallback) (e) -> clientThread.invokeLater(this::screenshotEquipment));
		button.setHasListener(true);
		button.revalidate();

		button.setOnMouseOverListener((JavaScriptCallback) (e) -> button.setSpriteId(570));
		button.setOnMouseLeaveListener((JavaScriptCallback) (e) -> button.setSpriteId(573));
	}
}

/*
 * Copyright (c) 2020, Truth Forger <http://github.com/Blackberry0Pie>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package bbp.equipmentscreenshot;

import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.util.Map;
import javax.inject.Inject;

import com.google.common.collect.ImmutableMap;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Point;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.util.ImageUtil;

class EquipmentBlowpipeOverlay
{
	private static final Map<Integer, Integer> DART_MATERIALS = new ImmutableMap.Builder<Integer, Integer>().
			put(ItemID.BRONZE_DART, ItemID.BRONZE_BAR).
			put(ItemID.IRON_DART, ItemID.IRON_BAR).
			put(ItemID.STEEL_DART, ItemID.STEEL_BAR).
			put(ItemID.BLACK_DART, -2).
			put(ItemID.MITHRIL_DART, ItemID.MITHRIL_BAR).
			put(ItemID.ADAMANT_DART, ItemID.ADAMANTITE_BAR).
			put(ItemID.RUNE_DART, ItemID.RUNITE_BAR).
			put(ItemID.AMETHYST_DART, ItemID.AMETHYST).
			put(ItemID.DRAGON_DART, -1).
			build();

	private final int MAX_CHARGES = 16383;

	@Inject
	private Client client;

	@Inject
	private EquipmentScreenshotPlugin plugin;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private EquipmentScreenshotConfig config;

	@Inject
	private EquipmentScreenshotUtil util;

	void renderBlowpipeOverlay(Graphics2D graphics, Point location)
	{
		BufferedImage dartImage = null;
		Integer dartMat = DART_MATERIALS.get(plugin.getDartID());
		if (dartMat != null)
		{
			if (dartMat == -1)
			{
				dartImage = ImageUtil.loadImageResource(EquipmentBlowpipeOverlay.class, "Dragon_bar.png");
			}
			else if (dartMat == -2)
			{
				dartImage = ImageUtil.loadImageResource(EquipmentBlowpipeOverlay.class, "Black_bar.png");
			}
			else if (itemManager.getImage(dartMat) != null)
			{
				dartImage = itemManager.getImage(dartMat);
			}
		}
		BufferedImage scaleImage = itemManager.getImage(ItemID.ZULRAHS_SCALES, 5, false);
		BufferedImage bi;
		for (int i = 2; i >= 0; i -= 2)
		{
			int amount;
			int imageSize;

			if (i == 0)
			{
				graphics.setFont(FontManager.getRunescapeFont());
				imageSize = 23;
				amount = plugin.getDartCount();
				bi = dartImage;
			}
			else
			{
				graphics.setFont(FontManager.getRunescapeSmallFont());
				imageSize = 17;
				amount = plugin.getScaleCount();
				bi = scaleImage;
			}
			if (bi != null && amount != 0)
			{
				BufferedImage resizedImg = new BufferedImage(imageSize, imageSize, BufferedImage.TYPE_INT_ARGB);
				Graphics2D g = resizedImg.createGraphics();
				g.drawImage(bi, 0, 0, imageSize, imageSize, null);
				g.dispose();
				OverlayUtil.renderImageLocation(graphics,
						new Point(location.getX() - 4, location.getY() + graphics.getFontMetrics().getHeight() * (i == 2 ? 1 : 0) - 7 + (i == 2 ? 11 : 0)),
						resizedImg);

				// Draw dart and scale amount
				int vOffset = 12 - (i == 2 ? 3 : 0) + (graphics.getFontMetrics().getHeight() - 1) * i;
				util.drawTextWithShadow(graphics, location, 13, vOffset, "" + formatNumber(amount));
			}
		}
	}

	private static String formatNumber(int amount)
	{
		return amount < 1000 ? String.valueOf(amount) : amount / 1000 + "K";
	}
}


/*
 * Copyright (c) 2020, Truth Forger <http://github.com/Blackberry0Pie>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package bbp.equipmentscreenshot;

import com.google.common.collect.ImmutableMap;
import java.awt.Color;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;
import java.util.Map;
import javax.inject.Inject;

import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.SpriteID;
import net.runelite.api.SpritePixels;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;

class EquipmentScreenshotUtil
{
	@Inject
	private Client client;

	@Inject
	private ItemManager itemManager;

	@Inject
	private SpriteManager spriteManager;

	@Inject
	private EquipmentScreenshotConfig config;

	static final int EQUIPMENT_PADDING = 2;
	private Map<Integer, SpritePixels> spriteOverrides = null;

	private static final Map<EquipmentInventorySlot, Point> EQUIPMENT_ICON_OFFSETS = new ImmutableMap.Builder<EquipmentInventorySlot, Point>().
			put(EquipmentInventorySlot.HEAD, new Point(6, 4)).
			put(EquipmentInventorySlot.CAPE, new Point(5, 1)).
			put(EquipmentInventorySlot.AMULET, new Point(8, 9)).
			put(EquipmentInventorySlot.WEAPON, new Point(4, 4)).
			put(EquipmentInventorySlot.BODY, new Point(2, 9)).
			put(EquipmentInventorySlot.SHIELD, new Point(3, 3)).
			put(EquipmentInventorySlot.LEGS, new Point(8, 2)).
			put(EquipmentInventorySlot.GLOVES, new Point(1, 2)).
			put(EquipmentInventorySlot.BOOTS, new Point(4, 6)).
			put(EquipmentInventorySlot.RING, new Point(8, 8)).
			put(EquipmentInventorySlot.AMMO, new Point(5, 6)).
			build();

	BufferedImage getImage(Item item)
	{
		ItemComposition itemComposition = itemManager.getItemComposition(item.getId());
		return itemManager.getImage(item.getId(), item.getQuantity(), itemComposition.isStackable());
	}

	BufferedImage copy(BufferedImage bi)
	{
		return new BufferedImage(
				bi.getColorModel(),
				bi.copyData(null),
				bi.getColorModel().isAlphaPremultiplied(),
				null);
	}

	BufferedImage getImageFromSpriteID(int spriteID, boolean crop, boolean useResourcePack)
	{
		BufferedImage bi = null;
		spriteOverrides = client.getSpriteOverrides();
		if (useResourcePack && spriteOverrides.containsKey(spriteID) && spriteOverrides.get(spriteID) != null)
		{
			bi = copy(spriteOverrides.get(spriteID).toBufferedImage());
		}
		else
		{
			final BufferedImage sprite = spriteManager.getSprite(spriteID, 0);
			if (sprite != null)
				bi = copy(sprite);
		}
		if (crop)
			bi = trimImage(bi);
		return bi;
	}

	BufferedImage getCroppedImageFromSpriteID(int spriteID, boolean useResourcePack)
	{
		return getImageFromSpriteID(spriteID, true, useResourcePack);
	}

	void drawEquipmentIcon(Graphics2D g2d, EquipmentInventorySlot eis, Point p, Map<EquipmentInventorySlot, BufferedImage> EQUIPMENT_ICONS, boolean useResourcePack)
	{
		Point iconOffset = new Point(0, 0);
		spriteOverrides = client.getSpriteOverrides();
		boolean resourcePackLoaded = spriteOverrides.containsKey(SpriteID.EQUIPMENT_SLOT_HEAD);
		if (!useResourcePack || !resourcePackLoaded)
			iconOffset = EQUIPMENT_ICON_OFFSETS.get(eis);
		BufferedImage bi = EQUIPMENT_ICONS.get(eis);
		g2d.drawImage(bi, null, p.x + EQUIPMENT_PADDING + iconOffset.x, p.y + EQUIPMENT_PADDING + iconOffset.y);
	}

	boolean isEmpty(ItemContainer ic)
	{
		boolean empty = true;
		for (Item i : ic.getItems())
		{
			if (i.getId() != -1)
			{
				empty = false;
				break;
			}
		}
		return empty;
	}

	private BufferedImage trimImage(BufferedImage image)
	{
		if (image == null)
			return null;
		WritableRaster raster = image.getAlphaRaster();
		if (raster == null)
			return image;
		int width = raster.getWidth();
		int height = raster.getHeight();
		int left = 0;
		int top = 0;
		int right = width - 1;
		int bottom = height - 1;
		int minRight = width - 1;
		int minBottom = height - 1;

		top:
		for (;top < bottom; top++)
		{
			for (int x = 0; x < width; x++)
			{
				if (raster.getSample(x, top, 0) != 0)
				{
					minRight = x;
					minBottom = top;
					break top;
				}
			}
		}

		left:
		for (;left < minRight; left++)
		{
			for (int y = height - 1; y > top; y--)
			{
				if (raster.getSample(left, y, 0) != 0)
				{
					minBottom = y;
					break left;
				}
			}
		}

		bottom:
		for (;bottom > minBottom; bottom--)
		{
			for (int x = width - 1; x >= left; x--)
			{
				if (raster.getSample(x, bottom, 0) != 0)
				{
					minRight = x;
					break bottom;
				}
			}
		}

		right:
		for (;right > minRight; right--)
		{
			for (int y = bottom; y >= top; y--)
			{
				if (raster.getSample(right, y, 0) != 0)
				{
					break right;
				}
			}
		}

		return image.getSubimage(left, top, right - left + 1, bottom - top + 1);
	}

	void tileImage(Graphics2D g2d, BufferedImage bi, Point start, Point finish)
	{
		int x = Math.abs(start.x - finish.x) / bi.getWidth();
		int y = Math.abs(start.y - finish.y) / bi.getHeight();
		boolean horizontal = x > y;
		int times = (horizontal ? x : y);
		for (; times >= 0 ; times--)
			g2d.drawImage(bi, null, start.x + (horizontal ? times * bi.getWidth() : 0),
					start.y + (!horizontal ? times * bi.getHeight() : 0));
	}

	void drawIconWithText(Graphics2D g2d, Point d, BufferedImage bi, int spacing, String str, boolean addPlusSign)
	{
		Point p = new Point(d.getLocation());
		if (str.endsWith(".0%") || str.endsWith(".0"))
			str = str.replace(".0", "");
		if (addPlusSign && str.charAt(0) != '-' && str.charAt(0) != '0')
			str = "+" + str;
		FontMetrics metrics = g2d.getFontMetrics(g2d.getFont());
		int textHOffset = metrics.stringWidth(str) / 2;
		int imageHOffset = bi.getWidth() / 2;
		int imageVOffset = (bi.getHeight() + (!str.equals("") ? metrics.getHeight() - metrics.getLeading() : 0) + spacing) / 2;
		g2d.drawImage(bi, null, p.x - imageHOffset, p.y - imageVOffset);
		p.translate(- textHOffset, - imageVOffset + bi.getHeight() + (!str.equals("") ? spacing + metrics.getHeight() : 0));
		drawTextWithShadow(g2d, p, str);
	}

	void drawIconWithText(Graphics2D g2d, Point p, int spriteID, boolean useResourcePack, int spacing, String str, boolean addPlusSign)
	{
		BufferedImage bi = getCroppedImageFromSpriteID(spriteID, useResourcePack);
		drawIconWithText(g2d, p, bi, spacing, str, addPlusSign);
	}

	void drawIconWithText(Graphics2D g2d, Point p, BufferedImage bi, int spacing, int i, boolean addPlusSign)
	{
		String str = Integer.toString(i);
		drawIconWithText(g2d, p, bi, spacing, str, addPlusSign);
	}

	void drawIconWithText(Graphics2D g2d, Point p, int spriteID, boolean useResourcePack, int spacing, int i, boolean addPlusSign)
	{
		BufferedImage bi = getCroppedImageFromSpriteID(spriteID, useResourcePack);
		drawIconWithText(g2d, p, bi, spacing, i, addPlusSign);
	}

	private void drawTextWithShadow(Graphics2D g2d, Point p, String str)
	{
		g2d.setColor(Color.black);
		g2d.drawString(str, p.x + 1, p.y + 1);

		g2d.setColor(config.fontColor());
		g2d.drawString(str, p.x, p.y);
	}

	private void drawTextWithShadow(Graphics2D g2d, Point d, int hOffset, int vOffset, String str)
	{
		Point p = new Point(d.getLocation());
		p.translate(hOffset, vOffset);
		drawTextWithShadow(g2d, p, str);
	}

	void drawTextWithShadow(Graphics2D g2d, net.runelite.api.Point d, int hOffset, int vOffset, String str)
	{
		Point p = new Point(d.getX(), d.getY());
		p.translate(hOffset, vOffset);
		drawTextWithShadow(g2d, p, str);
	}

	void drawStatIcon(Graphics2D g2d, Point p, BufferedImage bi, int a, int d)
	{
		boolean showStyleIcons = config.showAllOptions() || config.showStyleIcons();
		boolean overlapStatIcons = config.showAllOptions() || config.overlapStats();
		int spacing = (overlapStatIcons ? 0 : 10);
		FontMetrics metrics = g2d.getFontMetrics(g2d.getFont());
		int imageHOffset = bi.getWidth() / 2;
		int imageVOffset = bi.getHeight() / 2;
		int unleadTextHeight = metrics.getHeight() - metrics.getLeading();
		int textVOffset = unleadTextHeight / 2 + spacing;

		if (showStyleIcons)
			g2d.drawImage(bi, null, p.x - imageHOffset, p.y - imageVOffset);

		String acc = intToSignedString(a);
		int text1HOffset = metrics.stringWidth(acc) / 2;
		drawTextWithShadow(g2d, p, -text1HOffset, -textVOffset, acc);

		String def = intToSignedString(d);
		int text2HOffset = metrics.stringWidth(def) / 2;
		drawTextWithShadow(g2d, p, -text2HOffset, textVOffset + metrics.getHeight(), def);
	}

	private String intToSignedString(int i)
	{
		String str = Integer.toString(i);
		if (str.charAt(0) != '-' && str.charAt(0) != '0')
			str = "+" + str;
		return str;
	}

	Point nextIconPosition(Point p)
	{
		p.translate(37, 0);
		return p;
	}
}

/*
 * Copyright (c) 2020, Truth Forger <http://github.com/Blackberry0Pie>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package bbp.equipmentscreenshot;

import java.awt.Color;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.util.ImageUploadStyle;

@ConfigGroup("equipmentscreenshot")
public interface EquipmentScreenshotConfig extends Config
{
	@ConfigSection(
		name = "Equipment Stats",
		description = "Options for equipment stats",
		position = 99,
		closedByDefault = true
	)
	String equipmentStats = "equipmentStats";

	@ConfigItem(
		position = 0,
		keyName = "uploadScreenshot",
		name = "Upload equipment screenshot",
		description = "Uploads the equipment screenshot to Imgur or the clipboard"
	)
	default ImageUploadStyle uploadScreenshot()
	{
		return ImageUploadStyle.CLIPBOARD;
	}

	@ConfigItem(
		position = 1,
		keyName = "notifyWhenTaken",
		name = "Notify When Taken",
		description = "Configures whether or not you are notified when a screenshot has been taken"
	)
	default boolean notifyWhenTaken()
	{
		return true;
	}

	@ConfigItem(
		position = 3,
		keyName = "useResourcePack",
		name = "Use resource pack",
		description = "Uses the currently enabled resource pack instead of default sprites, if one is enabled"
	)
	default boolean useResourcePack()
{
	return false;
}

	@ConfigItem(
		position = 4,
		keyName = "columnBetween",
		name = "Column between",
		description = "Adds a column between the inventory and equipment"
	)
	default boolean columnBetween()
	{
		return false;
	}

	@ConfigItem(
		position = 89,
		keyName = "showStats",
		name = "Show equipment stats",
		description = "Shows equipment stats such as slash, prayer, strength, weight, ..."
	)
	default boolean showStats()
	{
		return true;
	}

	@ConfigItem(
		section = equipmentStats,
		position = 3,
		keyName = "showStyleIcons",
		name = "Show Atk/Def style icons",
		description = "Shows style icons for attack and defence such as slash"
	)
	default boolean showStyleIcons()
	{
		return true;
	}

	@ConfigItem(
		section = equipmentStats,
		position = 97,
		keyName = "writeSpellbook",
		name = "Write spellbook name",
		description = "Writes currently active spellbook name below the spellbook icon"
	)
	default boolean writeSpellbook()
	{
		return false;
	}

	@ConfigItem(
		section = equipmentStats,
		position = 99,
		keyName = "showPreciseWeight",
		name = "Show accurate weight",
		description = "Shows the precise player to 3 decimal places"
	)
	default boolean showPreciseWeight()
	{
		return false;
	}

	@ConfigItem(
		position = 2,
		keyName = "fontColor",
		name = "Text color",
		description = "The color of the text used"
	)
	default Color fontColor()
	{
		return Color.YELLOW;
	}

	@ConfigItem(
		position = 5,
		keyName = "runepouchOverlay",
		name = "Runepouch overlay",
		description = "Adds an overlay of the rune pouch contents"
)
	default boolean runepouchOverlay()
	{
		return true;
	}

	@ConfigItem(
		position = 6,
		keyName = "blowpipeOverlay",
		name = "Blowpipe overlay",
		description = "Adds an overlay of the blowpipe contents. Requires player to check blowpipe contents to work."
	)
	default boolean blowpipeOverlay()
	{
		return true;
	}

	@ConfigItem(
		position = 88,
		keyName = "showEmptyEquipment",
		name = "Show empty equipment",
		description = "Shows equipment even if nothing is worn"
)
	default boolean showEmptyEquipment()
	{
		return false;
	}

	@ConfigItem(
		section = equipmentStats,
		position = -2,
		keyName = "showAllOptions",
		name = "Use all equipment stat options",
		description = "Enable all of the following options in the equipment stats section"
	)
	default boolean showAllOptions()
	{
		return false;
	}

	@ConfigItem(
		section = equipmentStats,
		position = 98,
		keyName = "showPrayerAndWeight",
		name = "Show Prayer and Weight",
		description = "Shows prayer and weight"
	)
	default boolean showPrayerAndWeight()
	{
		return false;
	}

	@ConfigItem(
		section = equipmentStats,
		position = 96,
		keyName = "showAllStr",
		name = "Show all 3 strength stats",
		description = "Shows melee, ranged, and magic strength irrespective of gear"
	)
	default boolean showAllStr()
	{
		return false;
	}

	@ConfigItem(
		section = equipmentStats,
		position = 95,
		keyName = "overlapStats",
		name = "Overlap Atk/Def stats on icons",
		description = "Overlaps stats over the icons"
)
	default boolean overlapStats()
	{
		return true;
	}

	@ConfigItem(
		position = 87,
		keyName = "button",
		name = "Show button",
		description = "Shows a button in the equipment interface to take a screenshot"
	)
	default boolean button()
	{
		return true;
	}
}

