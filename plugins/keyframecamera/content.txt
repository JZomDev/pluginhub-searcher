package com.keyframecamera;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class KeyframeCameraPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(KeyframeCameraPlugin.class);
		RuneLite.main(args);
	}
}
package com.keyframecamera;

import com.google.inject.Provides;
import javax.inject.Inject;
import javax.swing.*;

import com.keyframecamera.panel.CameraControlPanel;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.BeforeRender;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.Calendar;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

@Slf4j
@PluginDescriptor(
	name = "Keyframe Camera",
	description = "Create and play camera sequences",
	tags = {"camera", "keyframe", "creator", "content"}
)
public class KeyframeCameraPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private KeyframeCameraConfig config;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Getter
	@Setter
	private CameraSequence sequence;

	private CameraControlPanel panel;
	private NavigationButton navButton;
	private static final BufferedImage ICON = ImageUtil.loadImageResource(KeyframeCameraPlugin.class, "icon.png");

	public static Path SEQUENCE_DIR = Paths.get(RUNELITE_DIR.toString(), "sequences");
	int prevCameraMode = -1;

	@Override
	protected void startUp()
	{
		configManager.setConfiguration(KeyframeCameraConfig.GROUP, "playing", false);
		configManager.setConfiguration(KeyframeCameraConfig.GROUP, "paused", false);

		if (!SEQUENCE_DIR.toFile().exists())
		{
			SEQUENCE_DIR.toFile().mkdir();
		}

		String timestamp = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(Calendar.getInstance().getTime());
		sequence = new CameraSequence(this, client, clientThread, config, configManager, timestamp);

		panel = new CameraControlPanel(this, client, config);
		navButton = NavigationButton.builder()
				.tooltip("Keyframe Camera")
				.icon(ICON)
				.panel(panel)
				.build();

		clientToolbar.addNavigation(navButton);
	}

	@Override
	protected void shutDown()
	{
		clientToolbar.removeNavigation(navButton);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		if (panel == null) return;
		if (event.getGameState() == GameState.LOGIN_SCREEN || event.getGameState() == GameState.LOGGED_IN) {
			redrawPanel();
		}
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (client.getGameState() != GameState.LOGGED_IN) return;
		if (prevCameraMode != client.getCameraMode())
		{
			prevCameraMode = client.getCameraMode();
			redrawPanel();
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (event.getGroup().equals(KeyframeCameraConfig.GROUP) && (event.getKey().equals("playing") || event.getKey().equals("paused"))) {
			redrawPanel();
		}
	}

	public void redrawPanel() {
		SwingUtilities.invokeLater(() -> {
			panel.updatePanel();
		});
	}

	public void loadSequence(String name) {
		sequence = CameraSequence.load(this, client, clientThread, config, configManager, name);
		redrawPanel();
	}

	public void sendChatMessage(String message) {

		if (client.getGameState() != GameState.LOGGED_IN) return;

		final String chatMessage = new ChatMessageBuilder()
				.append(ChatColorType.HIGHLIGHT)
				.append("[Keyframe Camera] ")
				.append(ChatColorType.NORMAL)
				.append(message)
				.build();

		chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(chatMessage)
				.build());
	}

	@Subscribe
	public void onBeforeRender(BeforeRender event)
	{
		if (client.getGameState() != GameState.LOGGED_IN) return;
		if (client.getCameraMode() != 1) return;
		if (sequence == null) return;
		sequence.tick();
	}

	@Provides
	KeyframeCameraConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(KeyframeCameraConfig.class);
	}
}

package com.keyframecamera;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("keyframecamera")
public interface KeyframeCameraConfig extends Config
{
	String GROUP = "keyframecamera";

	@ConfigItem(
		keyName = "defaultDuration",
		name = "Default Duration",
		description = "The default duration of keyframes (ms)",
		position = 1
	)
	default int defaultKeyframeDuration()
	{
		return 3000;
	}

	@ConfigItem(
			keyName = "defaultKeyframeEase",
			name = "Default Easing",
			description = "The default easing type for keyframes",
			position = 2
	)
	default EaseType defaultKeyframeEase()
	{
		return EaseType.SINE;
	}

	@ConfigItem(
			keyName = "loop",
			name = "Loop",
			description = "Should the camera sequence loop?",
			position = 3
	)
	default boolean loop()
	{
		return true;
	}

	@ConfigItem(
			keyName = "playing",
			name = "Playing",
			description = "Whether the camera sequence is currently playing",
			hidden = true
	)
	default boolean playing()
	{
		return false;
	}

	@ConfigItem(
			keyName = "paused",
			name = "Paused",
			description = "Whether the camera sequence is currently paused",
			hidden = true
	)
	default boolean paused()
	{
		return false;
	}
}

package com.keyframecamera;

import lombok.Data;

import java.util.UUID;

@Data
public class Keyframe
{
    private String id;
    private long duration;
    private double focalX;
    private double focalY;
    private double focalZ;
    private double pitch;
    private double yaw;
    private int scale;
    private EaseType ease;

    public Keyframe(long duration, double focalX, double focalY, double focalZ, double pitch, double yaw, int scale, EaseType ease)
    {
        this.id = UUID.randomUUID().toString();
        this.duration = duration;
        this.focalX = focalX;
        this.focalY = focalY;
        this.focalZ = focalZ;
        this.pitch = pitch;
        this.yaw = yaw;
        this.scale = scale;
        this.ease = ease;
    }

    public String toString()
    {
        return String.format(
                "%d,%f,%f,%f,%f,%f,%d,%s",
                duration,
                focalX,
                focalY,
                focalZ,
                pitch,
                yaw,
                scale,
                ease
        );
    }
}

package com.keyframecamera;

public class Ease {
    public static Keyframe interpolate(Keyframe currentKeyframe, Keyframe nextKeyframe, long keyframeElapsed) {
        double t = (double) keyframeElapsed / currentKeyframe.getDuration();

        if (nextKeyframe == null) {
            return currentKeyframe;
        }

        double interpolationFactor = calculateEasing(currentKeyframe.getEase(), t);

        double currentYaw = currentKeyframe.getYaw();
        double nextYaw = nextKeyframe.getYaw();

        double yawDiff = nextYaw - currentYaw;
        if (Math.abs(yawDiff) > 1024) {
            if (yawDiff > 0) {
                currentYaw += 2048;
            } else {
                nextYaw += 2048;
            }
        }

        return new Keyframe(
                0,
                lerp(currentKeyframe.getFocalX(), nextKeyframe.getFocalX(), interpolationFactor),
                lerp(currentKeyframe.getFocalY(), nextKeyframe.getFocalY(), interpolationFactor),
                lerp(currentKeyframe.getFocalZ(), nextKeyframe.getFocalZ(), interpolationFactor),
                lerp(currentKeyframe.getPitch(), nextKeyframe.getPitch(), interpolationFactor),
                lerp(currentYaw, nextYaw, interpolationFactor) % 2048,
                (int) lerp(currentKeyframe.getScale(), nextKeyframe.getScale(), interpolationFactor),
                currentKeyframe.getEase()
        );
    }

    public static double lerp(double start, double end, double t) {
        return start + (end - start) * t;
    }

    private static double calculateEasing(EaseType ease, double t) {
        switch (ease) {
            case LINEAR:
                return t;
            case SINE:
                return sinEaseInOut(t);
            case QUAD:
                return quadEaseInOut(t);
            case CUBIC:
                return cubicEaseInOut(t);
            case QUART:
                return quartEaseInOut(t);
            case QUINT:
                return quintEaseInOut(t);
            case EXPO:
                return expoEaseInOut(t);
            default:
                throw new IllegalArgumentException("Unknown easing type: " + ease);
        }
    }

    // Easing functions
    private static double sinEaseInOut(double t) { return (-(Math.cos(Math.PI * t) - 1) / 2); }

    private static double quadEaseInOut(double t) {
        return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }

    private static double cubicEaseInOut(double t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    private static double quartEaseInOut(double t) {
        return t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
    }

    private static double quintEaseInOut(double t) {
        return t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2;
    }

    private static double expoEaseInOut(double t) {
        return t == 0 ? 0 : t == 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2
                : (2 - Math.pow(2, -20 * t + 10)) / 2;
    }
}

package com.keyframecamera.panel;

import com.keyframecamera.CameraSequence;
import com.keyframecamera.EaseType;
import com.keyframecamera.Keyframe;
import com.keyframecamera.KeyframeCameraPlugin;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class KeyframeDisplay extends JPanel
{

    private static final ImageIcon VIEW_ICON;
    private static final ImageIcon OVERWRITE_ICON;
    private static final ImageIcon DUPLICATE_ICON;
    private static final ImageIcon UP_ICON;
    private static final ImageIcon DOWN_ICON;
    private static final ImageIcon DELETE_ICON;

    static {
        VIEW_ICON = new ImageIcon(ImageUtil.loadImageResource(KeyframeCameraPlugin.class, "view.png"));
        OVERWRITE_ICON = new ImageIcon(ImageUtil.loadImageResource(KeyframeCameraPlugin.class, "overwrite.png"));
        DUPLICATE_ICON = new ImageIcon(ImageUtil.loadImageResource(KeyframeCameraPlugin.class, "duplicate.png"));
        UP_ICON = new ImageIcon(ImageUtil.loadImageResource(KeyframeCameraPlugin.class, "up.png"));
        DOWN_ICON = new ImageIcon(ImageUtil.loadImageResource(KeyframeCameraPlugin.class, "down.png"));
        DELETE_ICON = new ImageIcon(ImageUtil.loadImageResource(KeyframeCameraPlugin.class, "delete.png"));

    }

    GridBagConstraints c = new GridBagConstraints();

    KeyframePanel parent;
    CameraSequence sequence;
    Keyframe keyframe;

    @Getter
    @Setter
    int index;

    public KeyframeDisplay(KeyframePanel parent, CameraSequence sequence, int index)
    {
        super();
        this.parent = parent;
        this.sequence = sequence;
        this.index = index;
        keyframe = sequence.getKeyframe(index);

        setLayout(new GridBagLayout());
        setOpaque(true);
        setBorder(BorderFactory.createMatteBorder(0, 0, 1, 0, bgColor().brighter()));

        drawPanel();
    }

    private void drawPanel()
    {
        setBackground(bgColor());

        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBorder(BorderFactory.createLineBorder(bgColor(), 3));
        panel.setOpaque(false);
        panel.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                parent.toggleShowControls(keyframe.getId());
                parent.redrawKeyframes();
            }
        });

        c.gridx = 0;
        c.gridy = 0;
        c.weightx = 1;
        c.fill = GridBagConstraints.HORIZONTAL;

        JPanel details = new JPanel(new GridBagLayout());
        details.setOpaque(false);
        panel.add(details, c);

        c.weightx = 0.2;

        JLabel indexLabel = new JLabel(String.valueOf(index + 1));
        indexLabel.setOpaque(true);
        indexLabel.setBackground(bgColor());
        indexLabel.setVerticalAlignment(SwingConstants.CENTER);
        indexLabel.setVerticalTextPosition(SwingConstants.CENTER);
        indexLabel.setPreferredSize(new Dimension(24, 24));
        indexLabel.setForeground(Color.WHITE);
        indexLabel.setFont(FontManager.getRunescapeSmallFont());

        details.add(indexLabel, c);

        c.gridx++;
        c.weightx = 0.4;
        c.fill = GridBagConstraints.NONE;

        JSpinner durationSpinner = new JSpinner();
        durationSpinner.setFont(FontManager.getRunescapeSmallFont());
        Component spinnerEditor = durationSpinner.getEditor();
        JFormattedTextField tf = ((JSpinner.DefaultEditor) spinnerEditor).getTextField();
        tf.setColumns(8);
        durationSpinner.setValue(keyframe.getDuration());

        durationSpinner.addChangeListener(e -> keyframe.setDuration(((Number) durationSpinner.getValue()).longValue()));
        details.add(durationSpinner, c);

        c.gridx++;
        c.weightx = 0.4;

        JComboBox<EaseType> easeTypeComboBox = new JComboBox<>(EaseType.values());
        easeTypeComboBox.setPrototypeDisplayValue(EaseType.LINEAR);
        easeTypeComboBox.setFont(FontManager.getRunescapeSmallFont());
        easeTypeComboBox.setSelectedItem(keyframe.getEase());
        easeTypeComboBox.addActionListener(e -> keyframe.setEase((EaseType) easeTypeComboBox.getSelectedItem()));
        details.add(easeTypeComboBox, c);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy++;

        if (parent.showingControls.contains(keyframe.getId()))
        {
            addControls(panel);
            add(panel, c);
        } else {
            add(panel, c);
        }
    }

    private Color bgColor()
    {
        return parent.showingControls.contains(keyframe.getId()) ? ColorScheme.MEDIUM_GRAY_COLOR : ColorScheme.DARK_GRAY_COLOR;
    }

    private void addControls(JPanel panel)
    {
        JPanel controls = new JPanel(new BorderLayout());
        controls.setOpaque(false);
        controls.setBorder(new EmptyBorder(2, 0, 2, 0));
        panel.add(controls, c);

        JPanel actionPanel = createActionPanel();

        controls.add(actionPanel, BorderLayout.CENTER);
        add(panel, c);
    }

    private JLabel createActionLabel(ImageIcon icon, String tooltip, MouseAdapter mouseAdapter) {
        JLabel label = new JLabel(icon);
        setOpaque(true);
        setBackground(bgColor());
        label.setPreferredSize(new Dimension(24, 24));
        label.setToolTipText(tooltip);
        label.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (!sequence.isPlaying()) mouseAdapter.mousePressed(e);
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                if (!sequence.isPlaying()) {
                    label.setCursor(new Cursor(Cursor.HAND_CURSOR));
                }
            }

            @Override
            public void mouseExited(MouseEvent e) {
                label.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            }
        });
        return label;
    }

    private JPanel createActionPanel()
    {
        JPanel actionPanel = new JPanel(new FlowLayout());
        actionPanel.setOpaque(false);
        actionPanel.setBorder(new EmptyBorder(5, 2, 5, 2));

        JPanel content = new JPanel(new GridBagLayout());
        content.setOpaque(false);
        GridBagConstraints cc = new GridBagConstraints();
        cc.fill = GridBagConstraints.HORIZONTAL;
        cc.gridx = 0;
        cc.gridy = 0;
        cc.weightx = 0.16666;
        actionPanel.add(content);

        JLabel view = createActionLabel(VIEW_ICON, "Move the camera to this keyframe", new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                sequence.setCameraToKeyframe(keyframe);
            }
        });

        JLabel overwrite = createActionLabel(OVERWRITE_ICON, "Overwrite with current camera state", new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                sequence.overwriteKeyframe(index);
            }
        });
        JLabel moveUp = createActionLabel(UP_ICON, "Move keyframe up", new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                parent.moveKeyframe(true, index);
                parent.redrawKeyframes();
            }
        });
        JLabel moveDown = createActionLabel(DOWN_ICON, "Move keyframe down", new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                parent.moveKeyframe(false, index);
                parent.redrawKeyframes();
            }
        });
        JLabel duplicate = createActionLabel(DUPLICATE_ICON, "Duplicate keyframe", new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                sequence.duplicateKeyframe(index);
                parent.redrawKeyframes();
            }
        });
        JLabel delete = createActionLabel(DELETE_ICON, "Delete keyframe", new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                sequence.deleteKeyframe(index);
                parent.redrawKeyframes();
            }
        });

        if (index == 0) {
            moveUp.setEnabled(false);
        }

        if (index == sequence.getKeyframes().size() - 1) {
            moveDown.setEnabled(false);
        }

        content.add(view, cc);
        cc.gridx++;
        content.add(overwrite, cc);
        cc.gridx++;
        content.add(duplicate, cc);
        cc.gridx++;
        content.add(moveUp, cc);
        cc.gridx++;
        content.add(moveDown, cc);
        cc.gridx++;
        content.add(delete, cc);
        cc.gridx++;

        return content;
    }

}

package com.keyframecamera.panel;

import com.formdev.flatlaf.icons.FlatFileViewDirectoryIcon;
import com.formdev.flatlaf.icons.FlatFileViewFileIcon;
import com.formdev.flatlaf.icons.FlatFileViewFloppyDriveIcon;
import com.keyframecamera.*;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.io.File;
import java.nio.file.Paths;

public class CameraControlPanel extends PluginPanel {

    private final KeyframeCameraPlugin plugin;
    private final Client client;
    private CameraSequence sequence;
    private final KeyframeCameraConfig config;

    private final GridBagConstraints c = new GridBagConstraints();

    private final JPanel contentPanel = new JPanel();

    private final JPanel controlsPanel = new JPanel();
    private final JButton playButton = new JButton();
    private final JButton pauseButton = new JButton();
    private final JButton stopButton = new JButton();
    private final JButton newButton = new JButton();
    private final JButton saveButton = new JButton();
    private final JButton loadButton = new JButton();
    private final JButton addKeyframeButton = new JButton();
    private final JButton cameraModeButton = new JButton();

    private final KeyframePanel keyframesPanel;
    private static final ImageIcon PLAY_ICON;
    private static final ImageIcon PAUSE_ICON;
    private static final ImageIcon STOP_ICON;

    static {
        PLAY_ICON = new ImageIcon(ImageUtil.loadImageResource(KeyframeCameraPlugin.class, "play.png"));
        PAUSE_ICON = new ImageIcon(ImageUtil.loadImageResource(KeyframeCameraPlugin.class, "pause.png"));
        STOP_ICON = new ImageIcon(ImageUtil.loadImageResource(KeyframeCameraPlugin.class, "stop.png"));
    }

    public CameraControlPanel(KeyframeCameraPlugin plugin, Client client, KeyframeCameraConfig config) {
        super();
        this.plugin = plugin;
        this.client = client;
        this.config = config;
        this.sequence = plugin.getSequence();

        setOpaque(true);
        setBorder(BorderFactory.createLineBorder(ColorScheme.DARK_GRAY_COLOR, 10));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 0;
        c.weightx = 1;
        c.weighty = 0;
        c.insets = new Insets(0, 0, 3, 0);

        contentPanel.setOpaque(true);
        contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        contentPanel.setLayout(new GridBagLayout());
        add(contentPanel, BorderLayout.CENTER);

        keyframesPanel = new KeyframePanel(sequence);

        addControls();
        contentPanel.add(keyframesPanel, c);
    }

    private void addControls()
    {
        controlsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        controlsPanel.setOpaque(false);
        controlsPanel.setLayout(new GridBagLayout());
        controlsPanel.setBorder(BorderFactory.createLineBorder(ColorScheme.DARK_GRAY_COLOR, 1));

        cameraModeButton.setText(client.getCameraMode() == 0 ? "Enable Free Cam" : "Disable Free Cam");
        cameraModeButton.addActionListener(e -> {
            client.setCameraMode(client.getCameraMode() == 0 ? 1 : 0);
            cameraModeButton.setText(client.getCameraMode() == 0 ? "Enable Free Cam" : "Disable Free Cam");
            cameraModeButton.revalidate();
            cameraModeButton.repaint();
        });

        controlsPanel.add(cameraModeButton, c);
        c.gridy++;

        JPanel playbackControls = new JPanel();
        playbackControls.setBackground(ColorScheme.DARK_GRAY_COLOR);
        playbackControls.setOpaque(false);
        playbackControls.setLayout(new FlowLayout());
        playbackControls.setBorder(new EmptyBorder(1, 1, 1, 1));

        addPlayButton(playbackControls);
        addPauseButton(playbackControls);
        addStopButton(playbackControls);
        addNewButton(playbackControls);
        addSaveButton(playbackControls);
        addLoadButton(playbackControls);

        controlsPanel.add(playbackControls, c);
        c.gridy++;

        addKeyframeButton.setText("Add Keyframe");
        addKeyframeButton.addActionListener(e -> {
            int newKeyframeIndex = sequence.addKeyframe();
            if (newKeyframeIndex == -1) return;
            keyframesPanel.addKeyframe(newKeyframeIndex);
            updatePanel();
        });
        addKeyframeButton.setEnabled(!config.playing());

        controlsPanel.add(addKeyframeButton, c);
        c.gridy++;

        contentPanel.add(controlsPanel, c);
        c.gridy++;
    }

    private void addPlayButton(JPanel panel) {
        playButton.setIcon(PLAY_ICON);
        playButton.addActionListener(e -> {
            if (config.paused())
            {
                sequence.togglePause();
            } else {
                sequence.play();
            }
        });
        playButton.setEnabled((!config.playing() || config.paused()) && sequence.getKeyframes().size() >= 2 && loggedIn());
        panel.add(playButton);
    }

    private void addPauseButton(JPanel panel) {
        pauseButton.setIcon(PAUSE_ICON);
        pauseButton.addActionListener(e -> sequence.togglePause());
        pauseButton.setEnabled(config.playing() && !config.paused() && loggedIn());
        panel.add(pauseButton);
    }

    private void addStopButton(JPanel panel) {
        stopButton.setIcon(STOP_ICON);
        stopButton.addActionListener(e -> sequence.stop());
        stopButton.setEnabled(config.playing() && loggedIn());
        panel.add(stopButton);
    }

    private void addNewButton(JPanel panel) {
        newButton.setIcon(new FlatFileViewFileIcon());
        newButton.addActionListener(e ->  {
            sequence.wipe();
            keyframesPanel.redrawKeyframes();
        });
        panel.add(newButton);
    }

    private void addSaveButton(JPanel panel) {
        saveButton.setIcon(new FlatFileViewFloppyDriveIcon());
        saveButton.addActionListener(e -> sequence.save());
        panel.add(saveButton);
    }

    private void addLoadButton(JPanel panel) {
        loadButton.setIcon(new FlatFileViewDirectoryIcon());
        loadButton.addActionListener(e -> {
            JFileChooser fileChooser = new JFileChooser(KeyframeCameraPlugin.SEQUENCE_DIR.toFile());
            fileChooser.setDialogTitle("Choose a keyframe sequence to load");

            int option = fileChooser.showOpenDialog(this);
            if (option == JFileChooser.APPROVE_OPTION)
            {
                File selectedFile = fileChooser.getSelectedFile();
                if (!selectedFile.exists())
                {
                    selectedFile = new File(selectedFile.getPath() + ".txt");
                    if (!selectedFile.exists())
                    {
                        return;
                    }
                }
                plugin.loadSequence(Paths.get(selectedFile.getPath()).getFileName().toString());
            }
        });

        panel.add(loadButton);
    }

    public void updatePanel()
    {
        this.sequence = plugin.getSequence();
        keyframesPanel.redrawKeyframes();
        updateControls();
        revalidate();
        repaint();
    }

    public void updateControls()
    {
        playButton.setEnabled((!config.playing() || config.paused()) && sequence.getKeyframes().size() >= 2 && loggedIn());
        pauseButton.setEnabled(config.playing() && !config.paused() && loggedIn());
        newButton.setEnabled(!config.playing());
        stopButton.setEnabled(config.playing() && loggedIn());
        saveButton.setEnabled(!config.playing() && sequence.getKeyframes().size() > 0);
        loadButton.setEnabled(!config.playing());
        addKeyframeButton.setEnabled(!config.playing() && loggedIn());
        cameraModeButton.setText(client.getCameraMode() == 0 && loggedIn() ? "Enable Free Cam" : "Disable Free Cam");
    }

    private boolean loggedIn() {
        return client.getGameState() == GameState.LOGGED_IN;
    }
}

package com.keyframecamera.panel;

import com.keyframecamera.CameraSequence;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import java.awt.*;
import java.util.HashSet;

@Slf4j
public class KeyframePanel extends JPanel {

    CameraSequence sequence;
    GridBagConstraints c = new GridBagConstraints();
    JPanel keyframes = new JPanel(new GridBagLayout());

    HashSet<String> showingControls = new HashSet<>();

    public KeyframePanel(CameraSequence sequence)
    {
        super();

        this.sequence = sequence;

        setLayout(new GridBagLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setOpaque(false);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 0;
        c.weightx = 1;
        c.insets = new Insets(0, 0, 3, 0);

        JPanel headerPanel = new JPanel(new GridBagLayout());
        headerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        headerPanel.setOpaque(false);

        c.weightx = 0.2;

        JLabel indexHeader = new JLabel("#");
        indexHeader.setForeground(Color.WHITE);
        indexHeader.setFont(FontManager.getRunescapeSmallFont());
        headerPanel.add(indexHeader, c);

        c.gridx++;
        c.weightx = 0.5;

        JLabel durationHeader = new JLabel("Duration (ms)");
        durationHeader.setForeground(Color.WHITE);
        durationHeader.setFont(FontManager.getRunescapeSmallFont());
        headerPanel.add(durationHeader, c);

        c.gridx++;
        c.weightx = 0.3;

        JLabel easingHeader = new JLabel("Easing");
        easingHeader.setForeground(Color.WHITE);
        easingHeader.setFont(FontManager.getRunescapeSmallFont());
        headerPanel.add(easingHeader, c);

        add(headerPanel, c);

        c.gridy++;
        c.weightx = 1;
        c.insets = new Insets(0, 0, 0, 0);

        keyframes.setBackground(ColorScheme.DARK_GRAY_COLOR);
        keyframes.setOpaque(false);

        for (int i = 0; i < sequence.getKeyframes().size(); i++)
        {
            KeyframeDisplay keyframeDisplay = new KeyframeDisplay(this, sequence, i);
            keyframes.add(keyframeDisplay, c);
            c.gridy++;
        }

        add(keyframes, c);
    }

    public void toggleShowControls(String id)
    {
        if (showingControls.contains(id))
        {
            showingControls.remove(id);
        }
        else
        {
            showingControls.add(id);
        }
    }

    public void addKeyframe(int index)
    {
        c.gridy = index + 2;
        KeyframeDisplay keyframeDisplay = new KeyframeDisplay(this, sequence, index);
        keyframes.add(keyframeDisplay, c);
    }

    public void redrawKeyframes()
    {
        this.sequence = sequence.getPlugin().getSequence();
        keyframes.removeAll();
        c.gridy = 1;

        for (int i = 0; i < sequence.getKeyframes().size(); i++)
        {
            addKeyframe(i);
        }
        revalidate();
        repaint();
    }

    void moveKeyframe(boolean up, int index)
    {
        sequence.moveKeyframe(up, index);
    }

}

package com.keyframecamera;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.ScriptID;
import net.runelite.api.VarClientInt;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;

import java.io.File;
import java.nio.file.Path;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

@Slf4j
public class CameraSequence
{
    @Getter
    @Setter
    private String name;

    @Getter
    private final KeyframeCameraPlugin plugin;
    private final Client client;
    private final ClientThread clientThread;
    private final KeyframeCameraConfig config;
    private final ConfigManager configManager;

    List<Keyframe> keyframes = new ArrayList<>();

    @Getter
    private int currentKeyframeIndex = 0;
    private long currentKeyframeStartTime = 0;

    private long startTime = 0;
    private long pauseStartTime = 0;
    private long totalPauseTime = 0;

    public CameraSequence(KeyframeCameraPlugin plugin, Client client, ClientThread clientThread, KeyframeCameraConfig config, ConfigManager configManager, String name)
    {
        this.plugin = plugin;
        this.client = client;
        this.clientThread = clientThread;
        this.config = config;
        this.configManager = configManager;
        this.name = name;
    }

    private int getScale()
    {
        return client.getVarcIntValue(VarClientInt.CAMERA_ZOOM_FIXED_VIEWPORT);
    }

    public List<Keyframe> getKeyframes()
    {
        return keyframes;
    }

    public Keyframe getKeyframe(int index)
    {
        return keyframes.get(index);
    }

    public long elapsed()
    {
        if (!config.playing())
        {
            return 0;
        }

        long currentTime = System.currentTimeMillis();
        long elapsedTime = currentTime - startTime - totalPauseTime;

        if (elapsedTime < 0)
        {
            return 0;
        }

        return elapsedTime;
    }

    public int addKeyframe()
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return -1;
        }

        keyframes.add(
            new Keyframe(
                config.defaultKeyframeDuration(),
                client.getCameraFocalPointX(),
                client.getCameraFocalPointY(),
                client.getCameraFocalPointZ(),
                client.getCameraPitch(),
                client.getCameraYaw(),
                getScale(),
                config.defaultKeyframeEase()
            )
        );

        return keyframes.size() - 1;
    }

    public void duplicateKeyframe(int index)
    {
        if (index < 0 || index >= keyframes.size())
        {
            return;
        }

        Keyframe keyframe = keyframes.get(index);
        keyframes.add(
            new Keyframe(
                keyframe.getDuration(),
                keyframe.getFocalX(),
                keyframe.getFocalY(),
                keyframe.getFocalZ(),
                keyframe.getPitch(),
                keyframe.getYaw(),
                keyframe.getScale(),
                keyframe.getEase()
            )
        );
    }

    public void overwriteKeyframe(int index)
    {
        Keyframe keyframe = keyframes.get(index);
        keyframe.setFocalX(client.getCameraFocalPointX());
        keyframe.setFocalY(client.getCameraFocalPointY());
        keyframe.setFocalZ(client.getCameraFocalPointZ());
        keyframe.setPitch(client.getCameraPitch());
        keyframe.setYaw(client.getCameraYaw());
        keyframe.setScale(getScale());
    }

    public void deleteKeyframe(int index)
    {
        if (index < 0 || index >= keyframes.size())
        {
            return;
        }

        keyframes.remove(index);
    }

    public void play()
    {
        if (client.getCameraMode() != 1)
        {
            clientThread.invoke(() -> client.setCameraMode(1));
        }
        configManager.setConfiguration(KeyframeCameraConfig.GROUP, "playing", true);
        startTime = System.currentTimeMillis();
        totalPauseTime = 0;
        currentKeyframeIndex = 0;
        currentKeyframeStartTime = 0;
    }

    public void stop()
    {
        startTime = 0;
        pauseStartTime = 0;
        totalPauseTime = 0;
        currentKeyframeIndex = 0;
        currentKeyframeStartTime = 0;
        configManager.setConfiguration(KeyframeCameraConfig.GROUP, "playing", false);
        configManager.setConfiguration(KeyframeCameraConfig.GROUP, "paused", false);
    }

    public void togglePause()
    {
        if (!config.playing())
        {
            return;
        }

        if (config.paused())
        {
            if (client.getCameraMode() != 1)
            {
                client.setCameraMode(1);
            }
            totalPauseTime += System.currentTimeMillis() - pauseStartTime;
            configManager.setConfiguration(KeyframeCameraConfig.GROUP, "paused", false);
        }
        else
        {
            pauseStartTime = System.currentTimeMillis();
            configManager.setConfiguration(KeyframeCameraConfig.GROUP, "paused", true);
        }
    }

    public void tick() {
        if (!config.playing() || config.paused()) {
            return;
        }

        if (client.getCameraMode() != 1) {
            stop();
            return;
        }

        Keyframe currentKeyframe = keyframes.get(currentKeyframeIndex);

        if (elapsed() >= currentKeyframeStartTime + currentKeyframe.getDuration()) {
            if (currentKeyframeIndex + 1 >= keyframes.size()) {
                if (config.loop()) {
                    startTime = System.currentTimeMillis();
                    totalPauseTime = 0;
                    currentKeyframeIndex = 0;
                    currentKeyframeStartTime = 0;
                    currentKeyframe = keyframes.get(0);
                } else {
                    stop();
                    return;
                }
            } else {
                currentKeyframeIndex++;
                currentKeyframe = keyframes.get(currentKeyframeIndex);
                currentKeyframeStartTime = elapsed();
            }
        }

        long keyframeElapsed = elapsed() - currentKeyframeStartTime;
        Keyframe nextKeyframe = currentKeyframeIndex + 1 < keyframes.size() ? keyframes.get(currentKeyframeIndex + 1) : null;
        Keyframe interpolatedFrame = Ease.interpolate(currentKeyframe, nextKeyframe, keyframeElapsed);

        if (client.getCameraMode() != 1)
        {
            client.setCameraMode(1);
        }

        setCameraToKeyframe(interpolatedFrame);
    }

    public boolean isPlaying()
    {
        return config.playing();
    }

    public boolean moveKeyframe(boolean up, int index)
    {
        if (index < 0 || index >= keyframes.size()) {
            return false;
        }

        if (up && index == 0) {
            return false;
        }

        if (!up && index == keyframes.size() - 1) {
            return false;
        }

        Keyframe keyframe = keyframes.remove(index);
        keyframes.add(up ? index - 1 : index + 1, keyframe);
        return true;
    }

    public void setCameraToKeyframe(Keyframe keyframe)
    {
        if (client.getCameraMode() != 1) {
            client.setCameraMode(1);
        }

        clientThread.invoke(() -> {
            client.setCameraFocalPointX(keyframe.getFocalX());
            client.setCameraFocalPointY(keyframe.getFocalY());
            client.setCameraFocalPointZ(keyframe.getFocalZ());
            client.setCameraPitchTarget((int) keyframe.getPitch());
            client.setCameraYawTarget((int) keyframe.getYaw());
            client.runScript(ScriptID.CAMERA_DO_ZOOM, keyframe.getScale(), keyframe.getScale());
        });
    }

    public void wipe()
    {
        configManager.setConfiguration(KeyframeCameraConfig.GROUP, "playing", false);
        configManager.setConfiguration(KeyframeCameraConfig.GROUP, "paused", false);

        keyframes.clear();

        startTime = 0;
        pauseStartTime = 0;
        totalPauseTime = 0;
        currentKeyframeIndex = 0;
        currentKeyframeStartTime = 0;
    }

    public void save()
    {
        Path sequencePath = KeyframeCameraPlugin.SEQUENCE_DIR.resolve(name + ".txt");
        try {
            StringBuilder kf = new StringBuilder();
            for (Keyframe keyframe : keyframes) {
                kf.append(keyframe.toString()).append("\n");
            }
            java.nio.file.Files.write(sequencePath, kf.toString().getBytes(), java.nio.file.StandardOpenOption.CREATE, java.nio.file.StandardOpenOption.TRUNCATE_EXISTING);
            plugin.sendChatMessage("Sequence saved as: " + name + ".txt");
        } catch (Exception e) {
            plugin.sendChatMessage("Failed to save sequence: " + name + ".txt");
        }
    }

    public static CameraSequence load(KeyframeCameraPlugin plugin, Client client, ClientThread clientThread, KeyframeCameraConfig config, ConfigManager configManager, String name)
    {
        CameraSequence sequence = new CameraSequence(plugin, client, clientThread, config, configManager, new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss").format(Calendar.getInstance().getTime()));
        Path sequencePath = KeyframeCameraPlugin.SEQUENCE_DIR.resolve(name);
        try {
            List<String> lines = java.nio.file.Files.readAllLines(sequencePath);
            for (String line : lines) {
                String[] parts = line.split(",");
                sequence.keyframes.add(new Keyframe(
                        Long.parseLong(parts[0]),
                        Double.parseDouble(parts[1]),
                        Double.parseDouble(parts[2]),
                        Double.parseDouble(parts[3]),
                        Double.parseDouble(parts[4]),
                        Double.parseDouble(parts[5]),
                        Integer.parseInt(parts[6]),
                        EaseType.valueOf(parts[7])
                ));
            }
        } catch (Exception e) {
            plugin.sendChatMessage("Failed to load sequence: " + name);
            return plugin.getSequence();
        }

        return sequence;
    }
}

package com.keyframecamera;

public enum EaseType {
    LINEAR,
    SINE,
    QUAD,
    CUBIC,
    QUART,
    QUINT,
    EXPO
}

