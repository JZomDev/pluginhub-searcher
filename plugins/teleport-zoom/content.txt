package com.teleportzoom;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;

import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;

import com.teleportzoom.GwenithHandler.HANDLE_TYPE;

@ConfigGroup(TeleportZoomConfig.GROUP)
public interface TeleportZoomConfig extends Config
{
	String GROUP = "teleportzoom";
	String PREFIX = "region_";
	String PREFIX_DIRECTION = "regionDirection_";

    @ConfigSection(name="Gwenith General", description="Gwenith general portal settings", position=4)
    String gwenithGeneralPanel = "gwenithGeneralPanel";

	@ConfigSection(name="White Portals", description="Gwenith white portal settings", position=5, closedByDefault = true)
	String gwenithWhitePanel = "gwenithWhitePanel";

	@ConfigSection(name="Blue Portals", description="Gwenith blue portal settings", position=6, closedByDefault = true)
	String gwenithBluePanel = "gwenithBluePanel";

	@ConfigSection(name="Black Portals", description="Gwenith black portal settings", position=7, closedByDefault = true)
	String gwenithBlackPanel = "gwenithBlackPanel";

	@ConfigSection(name="Purple Portals", description="Gwenith purple portal settings", position=8, closedByDefault = true)
	String gwenithPurplePanel = "gwenithPurplePanel";

	@ConfigSection(name="Green Portals", description="Gwenith green portal settings", position=9, closedByDefault = true)
	String gwenithGreenPanel = "gwenithGreenPanel";

	@ConfigSection(name="Yellow Portals", description="Gwenith yellow portal settings", position=10, closedByDefault = true)
	String gwenithYellowPanel = "gwenithYellowPanel";

	@ConfigSection(name="Cyan Portals", description="Gwenith cyan portal settings", position=11, closedByDefault = true)
	String gwenithCyanPanel = "gwenithCyanPanel";

	@ConfigSection(name="Red Portals", description="Gwenith red portal settings", position=12, closedByDefault = true)
	String gwenithRedPanel = "gwenithRedPanel";


	@ConfigItem(
			keyName = "saveZoomKey",
			name = "Save Zoom",
			description = "When you press this key you'll save your zoom to the current region",
			position = 0
	)
	default Keybind saveKey()
	{
		return new Keybind(KeyEvent.VK_INSERT, InputEvent.CTRL_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "deleteZoomKey",
			name = "Delete Zoom",
			description = "When you press this key you'll delete your zoom of the current region",
			position = 1
	)
	default Keybind deleteKey()
	{
		return new Keybind(KeyEvent.VK_DELETE, InputEvent.CTRL_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "directionPrompt",
			name = "Direction Prompt",
			description = "Additionally prompt for a compass direction on save (Cardinals only)",
			position = 3
	)
	default boolean directionPrompt()
	{
		return false;
	}

	@ConfigItem(
			keyName = "portalLabels",
			name = "Portal Labels",
			description = "Draws labels over portals, used to determine what portals you want to modify the zoom/direction of",
			position = 14,
			section = gwenithGeneralPanel
	)
	default boolean portalLabels()
	{
		return false;
	}


	@ConfigItem(
			keyName = "enableHandles",
			name = "Enable Handles",
			description = "Enables Direction/zoom modification on portal teleports with below settings.",
			position = 15,
			section = gwenithGeneralPanel
	)
	default boolean enableHandles()
	{
		return false;
	}

	/**White**/
	@ConfigItem(
			keyName = "whiteAHandle",
			name = "White A Handle",
			description = "What zoom actions are handled when entering white portal A",
			position = 16,
			section = gwenithWhitePanel
	)
	default HANDLE_TYPE whiteAZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "whiteADirection",
			name = "White A Direction",
			description = "Direction to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 17,
			section = gwenithWhitePanel
	)
	default Direction whiteADirection()
	{
		return Direction.EAST;
	}

	@ConfigItem(
			keyName = "whiteAZoom",
			name = "White A Zoom",
			description = "Zoom to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 18,
			section = gwenithWhitePanel
	)
	default int whiteAZoom()
	{
		return 0;
	}

	@ConfigItem(
			name = "——————————————————————————————",
			keyName = "whiteDividerA",
			description = "",
			position = 18,
			section = gwenithWhitePanel
	)
	void whiteDividerA();

	@ConfigItem(
			keyName = "whiteBHandle",
			name = "White B Handle",
			description = "What zoom actions are handled when entering the white portal B",
			position = 19,
			section = gwenithWhitePanel
	)
	default HANDLE_TYPE whiteBZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "whiteBDirection",
			name = "White B Direction",
			description = "Direction to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 20,
			section = gwenithWhitePanel
	)
	default Direction whiteBDirection()
	{
		return Direction.NORTH;
	}

	@ConfigItem(
			keyName = "whiteBZoom",
			name = "White B Zoom",
			description = "Zoom to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 21,
			section = gwenithWhitePanel
	)
	default int whiteBZoom()
	{
		return 0;
	}



	/**Blue**/
	@ConfigItem(
			keyName = "blueAHandle",
			name = "Blue A Handle",
			description = "What zoom actions are handled when entering the blue portal A",
			position = 22,
			section = gwenithBluePanel
	)
	default HANDLE_TYPE blueAZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "blueADirection",
			name = "Blue A Direction",
			description = "Direction to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 23,
			section = gwenithBluePanel
	)
	default Direction blueADirection()
	{
		return Direction.EAST;
	}

	@ConfigItem(
			keyName = "blueAZoom",
			name = "Blue A Zoom",
			description = "Zoom to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 24,
			section = gwenithBluePanel
	)
	default int blueAZoom()
	{
		return 0;
	}

	@ConfigItem(
			name = "——————————————————————————————",
			keyName = "blueDividerA",
			description = "",
			position = 24,
			section = gwenithBluePanel
	)
	void blueDividerA();

	@ConfigItem(
			keyName = "blueBHandle",
			name = "Blue B Handle",
			description = "What zoom actions are handled when entering the blue portal B",
			position = 25,
			section = gwenithBluePanel
	)
	default HANDLE_TYPE blueBZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "blueBDirection",
			name = "Blue B Direction",
			description = "Direction to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 26,
			section = gwenithBluePanel
	)
	default Direction blueBDirection()
	{
		return Direction.SOUTH;
	}

	@ConfigItem(
			keyName = "blueBZoom",
			name = "Blue B Zoom",
			description = "Zoom to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 27,
			section = gwenithBluePanel
	)
	default int blueBZoom()
	{
		return 0;
	}


	/**Black**/
	@ConfigItem(
			keyName = "blackAHandle",
			name = "Black A Handle",
			description = "What zoom actions are handled when entering the black portal A",
			position = 28,
			section = gwenithBlackPanel
	)
	default HANDLE_TYPE blackAZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "blackADirection",
			name = "Black A Direction",
			description = "Direction to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 29,
			section = gwenithBlackPanel
	)
	default Direction blackADirection()
	{
		return Direction.WEST;
	}

	@ConfigItem(
			keyName = "blackAZoom",
			name = "Black A Zoom",
			description = "Zoom to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 30,
			section = gwenithBlackPanel
	)
	default int blackAZoom()
	{
		return 0;
	}

	@ConfigItem(
			name = "——————————————————————————————",
			keyName = "blackDividerA",
			description = "",
			position = 30,
			section = gwenithBlackPanel
	)
	void blackDividerA();

	@ConfigItem(
			keyName = "blackBHandle",
			name = "Black B Handle",
			description = "What zoom actions are handled when entering the black portal B",
			position = 31,
			section = gwenithBlackPanel
	)
	default HANDLE_TYPE blackBZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "blackBDirection",
			name = "Black B Direction",
			description = "Direction to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 32,
			section = gwenithBlackPanel
	)
	default Direction blackBDirection()
	{
		return Direction.WEST;
	}

	@ConfigItem(
			keyName = "blackBZoom",
			name = "Black B Zoom",
			description = "Zoom to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 33,
			section = gwenithBlackPanel
	)
	default int blackBZoom()
	{
		return 0;
	}

	/**Purple**/
	@ConfigItem(
			keyName = "purpleAHandle",
			name = "Purple A Handle",
			description = "What zoom actions are handled when entering the purple portal A",
			position = 34,
			section = gwenithPurplePanel
	)
	default HANDLE_TYPE purpleAZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "purpleADirection",
			name = "Purple A Direction",
			description = "Direction to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 35,
			section = gwenithPurplePanel
	)
	default Direction purpleADirection()
	{
		return Direction.WEST;
	}

	@ConfigItem(
			keyName = "purpleAZoom",
			name = "Purple A Zoom",
			description = "Zoom to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 36,
			section = gwenithPurplePanel
	)
	default int purpleAZoom()
	{
		return 0;
	}

	@ConfigItem(
			name = "——————————————————————————————",
			keyName = "purpleDividerA",
			description = "",
			position = 36,
			section = gwenithPurplePanel
	)
	void purpleDividerA();

	@ConfigItem(
			keyName = "purpleBHandle",
			name = "Purple B Handle",
			description = "What zoom actions are handled when entering the purple portal B",
			position = 37,
			section = gwenithPurplePanel
	)
	default HANDLE_TYPE purpleBZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "purpleBDirection",
			name = "Purple B Direction",
			description = "Direction to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 38,
			section = gwenithPurplePanel
	)
	default Direction purpleBDirection()
	{
		return Direction.NORTH;
	}

	@ConfigItem(
			keyName = "purpleBZoom",
			name = "Purple B Zoom",
			description = "Zoom to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 39,
			section = gwenithPurplePanel
	)
	default int purpleBZoom()
	{
		return 0;
	}

	/**Green**/
	@ConfigItem(
			keyName = "greenAHandle",
			name = "Green A Handle",
			description = "What zoom actions are handled when entering the green portal A",
			position = 40,
			section = gwenithGreenPanel
	)
	default HANDLE_TYPE greenAZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "greenADirection",
			name = "Green A Direction",
			description = "Direction to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 41,
			section = gwenithGreenPanel
	)
	default Direction greenADirection()
	{
		return Direction.NORTH;
	}

	@ConfigItem(
			keyName = "greenAZoom",
			name = "Green A Zoom",
			description = "Zoom to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 42,
			section = gwenithGreenPanel
	)
	default int greenAZoom()
	{
		return 0;
	}

	@ConfigItem(
			name = "——————————————————————————————",
			keyName = "greenDividerA",
			description = "",
			position = 42,
			section = gwenithGreenPanel
	)
	void greenDividerA();

	@ConfigItem(
			keyName = "greenBHandle",
			name = "Green B Handle",
			description = "What zoom actions are handled when entering the green portal B",
			position = 43,
			section = gwenithGreenPanel
	)
	default HANDLE_TYPE greenBZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "greenBDirection",
			name = "Green B Direction",
			description = "Direction to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 44,
			section = gwenithGreenPanel
	)
	default Direction greenBDirection()
	{
		return Direction.SOUTH;
	}

	@ConfigItem(
			keyName = "greenBZoom",
			name = "Green B Zoom",
			description = "Zoom to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 45,
			section = gwenithGreenPanel
	)
	default int greenBZoom()
	{
		return 0;
	}

	@ConfigItem(
			name = "——————————————————————————————",
			keyName = "greenDividerB",
			description = "",
			position = 45,
			section = gwenithGreenPanel
	)
	void greenDividerB();

	@ConfigItem(
			keyName = "greenCHandle",
			name = "Green C Handle",
			description = "What zoom actions are handled when entering the green portal C",
			position = 46,
			section = gwenithGreenPanel
	)
	default HANDLE_TYPE greenCZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "greenCDirection",
			name = "Green C Direction",
			description = "Direction to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 47,
			section = gwenithGreenPanel
	)
	default Direction greenCDirection()
	{
		return Direction.NORTH;
	}

	@ConfigItem(
			keyName = "greenCZoom",
			name = "Green C Zoom",
			description = "Zoom to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 48,
			section = gwenithGreenPanel
	)
	default int greenCZoom()
	{
		return 0;
	}

	/**Yellow**/
	@ConfigItem(
			keyName = "yellowAHandle",
			name = "Yellow A Handle",
			description = "What zoom actions are handled when entering the yellow portal A",
			position = 49,
			section = gwenithYellowPanel
	)
	default HANDLE_TYPE yellowAZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "yellowADirection",
			name = "Yellow A Direction",
			description = "Direction to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 50,
			section = gwenithYellowPanel
	)
	default Direction yellowADirection()
	{
		return Direction.WEST;
	}

	@ConfigItem(
			keyName = "yellowAZoom",
			name = "Yellow A Zoom",
			description = "Zoom to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 51,
			section = gwenithYellowPanel
	)
	default int yellowAZoom()
	{
		return 0;
	}

	@ConfigItem(
			name = "——————————————————————————————",
			keyName = "yellowDividerA",
			description = "",
			position = 51,
			section = gwenithYellowPanel
	)
	void yellowDividerA();

	@ConfigItem(
			keyName = "yellowBHandle",
			name = "Yellow B Handle",
			description = "What zoom actions are handled when entering the yellow portal B",
			position = 52,
			section = gwenithYellowPanel
	)
	default HANDLE_TYPE yellowBZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "yellowBDirection",
			name = "Yellow B Direction",
			description = "Direction to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 53,
			section = gwenithYellowPanel
	)
	default Direction yellowBDirection()
	{
		return Direction.NORTH;
	}

	@ConfigItem(
			keyName = "yellowBZoom",
			name = "Yellow B Zoom",
			description = "Zoom to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 54,
			section = gwenithYellowPanel
	)
	default int yellowBZoom()
	{
		return 0;
	}

	/**Cyan**/
	@ConfigItem(
			keyName = "cyanAHandle",
			name = "Cyan A Handle",
			description = "What zoom actions are handled when entering the cyan portal A",
			position = 55,
			section = gwenithCyanPanel
	)
	default HANDLE_TYPE cyanAZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "cyanADirection",
			name = "Cyan A Direction",
			description = "Direction to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 56,
			section = gwenithCyanPanel
	)
	default Direction cyanADirection()
	{
		return Direction.NORTH;
	}

	@ConfigItem(
			keyName = "cyanAZoom",
			name = "Cyan A Zoom",
			description = "Zoom to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 57,
			section = gwenithCyanPanel
	)
	default int cyanAZoom()
	{
		return 0;
	}

	@ConfigItem(
			name = "——————————————————————————————",
			keyName = "cyanDividerA",
			description = "",
			position = 57,
			section = gwenithCyanPanel
	)
	void cyanDividerA();

	@ConfigItem(
			keyName = "cyanBHandle",
			name = "Cyan B Handle",
			description = "What zoom actions are handled when entering the cyan portal B",
			position = 58,
			section = gwenithCyanPanel
	)
	default HANDLE_TYPE cyanBZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "cyanBDirection",
			name = "Cyan B Direction",
			description = "Direction to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 59,
			section = gwenithCyanPanel
	)
	default Direction cyanBDirection()
	{
		return Direction.SOUTH;
	}

	@ConfigItem(
			keyName = "cyanBZoom",
			name = "Cyan B Zoom",
			description = "Zoom to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 60,
			section = gwenithCyanPanel
	)
	default int cyanBZoom()
	{
		return 0;
	}

	/**Red**/
	@ConfigItem(
			keyName = "redAHandle",
			name = "Red A Handle",
			description = "What zoom actions are handled when entering the red portal A",
			position = 61,
			section = gwenithRedPanel
	)
	default HANDLE_TYPE redAZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "redADirection",
			name = "Red A Direction",
			description = "Direction to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 62,
			section = gwenithRedPanel
	)
	default Direction redADirection()
	{
		return Direction.SOUTH;
	}

	@ConfigItem(
			keyName = "redAZoom",
			name = "Red A Zoom",
			description = "Zoom to set when entering portal specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 63,
			section = gwenithRedPanel
	)
	default int redAZoom()
	{
		return 0;
	}

	@ConfigItem(
			name = "——————————————————————————————",
			keyName = "redDividerA",
			description = "",
			position = 63,
			section = gwenithRedPanel
	)
	void redDividerA();

	@ConfigItem(
			keyName = "redBHandle",
			name = "Red B Handle",
			description = "What zoom actions are handled when entering the red portal B",
			position = 64,
			section = gwenithRedPanel
	)
	default HANDLE_TYPE redBZoomType()
	{
		return HANDLE_TYPE.DIRECTION;
	}

	@ConfigItem(
			keyName = "redBDirection",
			name = "Red B Direction",
			description = "Direction to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 65,
			section = gwenithRedPanel
	)
	default Direction redBDirection()
	{
		return Direction.EAST;
	}

	@ConfigItem(
			keyName = "redBZoom",
			name = "Red B Zoom",
			description = "Zoom to set when entering specified portal (Refer to -Portal Labels- to know which portal is associated with what label)",
			position = 66,
			section = gwenithRedPanel
	)
	default int redBZoom()
	{
		return 0;
	}
}

/*
 * Copyright (c) 2025, 1Defence
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.teleportzoom;

import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ScriptID;
import net.runelite.api.WorldEntity;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.events.WorldEntitySpawned;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;


/**
 * Specific to Gwenith glide, you want the transition to occur as the teleport is occurring rather than after it's processed to not be jarring
 * It also wouldn't be super viable to go around every portal's edge and set a direction/zoom without getting sent through it not to mention the excessive number of them
 */
@Slf4j
@Singleton
public class GwenithHandler
{

    private final TeleportZoomPlugin plugin;
    private final TeleportZoomConfig config;
    private final ConfigManager configManager;
    private final Client client;
    private WorldEntity boatEntity = null;

    public boolean configPortalLabels, configEnableHandles;

    /**
     * Pairing of WorldPoint(Portal center) to PortalData
     * PortalData is set to the default static values, effectively just the name,config name and color
     * PortalData's Handles are set later during config caching
     */
    public Map<WorldPoint, PortalData> portalMap = new HashMap<>(Map.ofEntries(
            Map.entry(new WorldPoint(2260, 3497, 0), new PortalData("White A","whiteA", Color.WHITE)),
            Map.entry(new WorldPoint(2158, 3293, 0), new PortalData("White B","whiteB", Color.WHITE)),
            Map.entry(new WorldPoint(2241, 3574, 0), new PortalData("Blue A", "blueA",Color.BLUE)),
            Map.entry(new WorldPoint(2155, 3247, 0), new PortalData("Blue B", "blueB",Color.BLUE)),
            Map.entry(new WorldPoint(2207, 3584, 0), new PortalData("Black A", "blackA",Color.BLACK)),
            Map.entry(new WorldPoint(2107, 3543, 0), new PortalData("Purple A", "purpleA",Color.PINK)),
            Map.entry(new WorldPoint(2197, 3512, 0), new PortalData("Green A", "greenA",Color.GREEN)),
            Map.entry(new WorldPoint(2127, 3171, 0), new PortalData("Green B", "greenB",Color.GREEN)),
            Map.entry(new WorldPoint(2157, 3464, 0), new PortalData("Yellow A", "yellowA",Color.YELLOW)),
            Map.entry(new WorldPoint(2105, 3423, 0), new PortalData("Black B", "blackB",Color.BLACK)),
            Map.entry(new WorldPoint(2142, 3582, 0), new PortalData("Cyan A", "cyanA",Color.CYAN)),
            Map.entry(new WorldPoint(2126, 3356, 0), new PortalData("Cyan B", "cyanB",Color.CYAN)),
            Map.entry(new WorldPoint(2172, 3523, 0), new PortalData("Purple B", "purpleB",Color.PINK)),
            Map.entry(new WorldPoint(2118, 3439, 0), new PortalData("Yellow B", "yellowB",Color.YELLOW)),
            Map.entry(new WorldPoint(2162, 3508, 0), new PortalData("Red A", "redA",Color.RED)),
            Map.entry(new WorldPoint(2106, 3574, 0), new PortalData("Red B", "redB",Color.RED)),
            Map.entry(new WorldPoint(2190, 3508, 0), new PortalData("Green C","greenC",Color.GREEN))
    ));

    /**Used for config updates without needing to reparse the entire collection*/
    public Map<String, PortalData> configPortalMapping = new HashMap<>();
    String HANDLE_POSTFIX = "Handle";
    String DIRECTION_POSTFIX = "Direction";
    String ZOOM_POSTFIX = "Zoom";

    /**What to handle when teleporting through a portal*/
    public enum HANDLE_TYPE {
        DIRECTION(1),
        ZOOM(2),
        BOTH(3),
        DISABLED(0);

        private final int value;

        HANDLE_TYPE(int value) {
            this.value = value;
        }

        public int getValue() {
            return value;
        }
    }

    @Inject
    public GwenithHandler(TeleportZoomPlugin plugin,TeleportZoomConfig config, ConfigManager configManager,Client client){
        this.plugin = plugin;
        this.config = config;
        this.configManager = configManager;
        this.client = client;
        cachePortalSettings();
    }

    /**Register boat on startup when no spawn events occur*/
    public void registerBoat(){
        WorldView wv = client.getTopLevelWorldView();
        if(wv == null)
            return;

        for (WorldEntity worldEntity : wv.worldEntities())
        {
            if (worldEntity.getOwnerType() == WorldEntity.OWNER_TYPE_SELF_PLAYER)
            {
                boatEntity = worldEntity;
                break;
            }
        }
    }

    /**
     * Set Portal handles (zoom/direction values & whether or not they're enabled) based on config values
     * Store in a separate mapping, the portal in question against it's 3 possible config values for fast modification on config edit.
     */
    public void cachePortalSettings(){
        configPortalLabels = config.portalLabels();
        configEnableHandles = config.enableHandles();
        configPortalMapping = new HashMap<>();
        for (Map.Entry<WorldPoint, PortalData> entry : portalMap.entrySet()) {
            PortalData portal = entry.getValue();

            String configPrefix = portal.portalConfigPrefix;
            configPortalMapping.put(configPrefix+HANDLE_POSTFIX,portal);
            configPortalMapping.put(configPrefix+DIRECTION_POSTFIX,portal);
            configPortalMapping.put(configPrefix+ZOOM_POSTFIX,portal);

            String handlesStr = configManager.getConfiguration(TeleportZoomConfig.GROUP,configPrefix+HANDLE_POSTFIX);
            if(!Strings.isNullOrEmpty(handlesStr))
            {
                try
                {
                    HANDLE_TYPE handles = HANDLE_TYPE.valueOf(handlesStr);
                    portal.SetHandles(handles);
                } catch (IllegalArgumentException ignored){}
            }

            String directionStr = configManager.getConfiguration(TeleportZoomConfig.GROUP,configPrefix+DIRECTION_POSTFIX);
            if(!Strings.isNullOrEmpty(directionStr))
            {
                try
                {
                    Direction direction = Direction.valueOf(directionStr);
                    portal.SetDirection(direction);
                } catch (IllegalArgumentException ignored){}
            }

            String zoomStr = configManager.getConfiguration(TeleportZoomConfig.GROUP,configPrefix+ZOOM_POSTFIX);
            if(!Strings.isNullOrEmpty(zoomStr))
            {
                try
                {
                    int zoom = Integer.parseInt(zoomStr);
                    portal.SetZoom(zoom);
                } catch (NumberFormatException ignored) {}
            }

        }
    }

    /**
     * There is a substantial collection of config values, modify the specific portal of the given config updated rather than refreshing the entire map
     */
    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged){

        if(!configChanged.getGroup().equals(TeleportZoomConfig.GROUP))
        {
            return;
        }

        String configKey = configChanged.getKey();
        String configVal = configChanged.getNewValue();

        if(configKey.equals("portalLabels"))
        {
            configPortalLabels = config.portalLabels();
            return;
        }else if(configKey.equals("enableHandles"))
        {
            configEnableHandles = config.enableHandles();
            return;
        }

        PortalData portal = configPortalMapping.get(configKey);

        if(portal == null)
        {
            return;
        }

        if(configVal == null)
        {
            return;
        }

        if(configKey.endsWith(HANDLE_POSTFIX)){
            try
            {
                HANDLE_TYPE handles = HANDLE_TYPE.valueOf(configVal);
                portal.SetHandles(handles);
            } catch (IllegalArgumentException ignored) {}

        }else if(configKey.endsWith(DIRECTION_POSTFIX)){
            try
            {
                Direction direction = Direction.valueOf(configVal);
                portal.SetDirection(direction);
            } catch (IllegalArgumentException ignored){}

        }else if(configKey.endsWith(ZOOM_POSTFIX)){
            try
            {
                int zoom = Integer.parseInt(configVal);
                portal.SetZoom(zoom);
            } catch (NumberFormatException ignored) {}

        }

    }

    /**
     * Register the local players boat.
     */
    @Subscribe
    public void onWorldEntitySpawned(WorldEntitySpawned e)
    {
        WorldEntity worldEntity = e.getWorldEntity();
        if (worldEntity.getOwnerType() == WorldEntity.OWNER_TYPE_SELF_PLAYER)
        {
            boatEntity = worldEntity;
        }
    }

    /**
     * Convert Local location of the boat into a worldPoint, additionally shifting it down 1 plane to render on the correct view
     */
    WorldPoint GetBoatWorldLocation(){
        if(boatEntity == null)
            return null;
        LocalPoint lp = boatEntity.getTargetLocation();
        //setting plane to 0 shifts the tile underneath the boats' worldview. possibly grab current player plane and dz -1 instead
        return WorldPoint.fromScene(client.getTopLevelWorldView().getScene(),lp.getSceneX(),lp.getSceneY(),0);
    }

    /**
     * Compare distance of player boat against portal WPs to determine the correct portal the player is going through, as both use centers this shouldn't have mismatches.
     */
    WorldPoint GetClosestPortal()
    {
        if(boatEntity == null)
            return null;
        WorldPoint boat = GetBoatWorldLocation();
        WorldPoint closestPoint = null;
        int lowestDist = Integer.MAX_VALUE;
        for (WorldPoint portalPoint : portalMap.keySet())
        {
            int compareDist = boat.distanceTo2D(portalPoint);
            if(compareDist < lowestDist)
            {
                lowestDist = compareDist;
                closestPoint = portalPoint;
            }
        }

        return closestPoint;
    }

    /**
     * 948 is the script that requests a fade, setting the initial values of starting and ending opacity
     * 'pre-fade' event [Starting opacity : 255, Ending opacity : 0]
     * 'post-fade' event [Starting opacity : 0, Ending opacity : 255]
     * For the purposes of teleport handling only the 'pre-fade' event has relevance.
     */
    @Subscribe
    public void onScriptPreFired(ScriptPreFired e)
    {
        if(e.getScriptId() == 948){
            //'pre-fade' : 948,0,255,0,0,15
            //'post-fade' : 948,0,0,0,255,15
            Object[] args = e.getScriptEvent().getArguments();
            int opacityStart = (int) args[2];
            int opacityEnd = (int) args[4];

            boolean startedTeleport = opacityStart == 255 && opacityEnd == 0;
            if(startedTeleport)
            {
                //the final fade of lap completion isn't triggered via a portal, the only differentiator we have to invalidate the teleport is the busy value not being 0. no other varbit is set during this tick.
                if(client.getVarbitValue(VarbitID.SAILING_BT_GWENITH_GLIDE_MASTER_STATE) == 2 && client.getVarbitValue(VarbitID.BUSY) == 0)
                {
                    HandleTeleport();
                }
            }
        }
    }

    /**
     * Called when a teleport is about to occur
     * Handles either Direction change, Zoom change, both or none depending on the selected handles for the given portal.
     */
    void HandleTeleport(){

        if(!configEnableHandles)
        {
            return;
        }

        WorldPoint closestPortal = GetClosestPortal();
        if(closestPortal == null)
        {
            return;
        }

        PortalData portal = portalMap.get(closestPortal);
        if(portal.handlesDirection && portal.direction != null){
            plugin.SetDirection(portal.direction);
        }

        if(portal.handlesZoom){
            client.runScript(ScriptID.CAMERA_DO_ZOOM, portal.zoomValue, portal.zoomValue);
        }

    }

    /**
     * Stored data for every given relevant portal (portals the average player will never go through or do nothing are currently omitted)
     * Additionally when set, stores the zoom/direction data of the given portal from configs.
     */
    public static class PortalData{
        public String portalDisplayName;
        public String portalConfigPrefix;

        Color drawColor;
        PortalData(String portalDisplayName, String portalConfigPrefix, Color drawColor){
            this.portalDisplayName = portalDisplayName;
            this.portalConfigPrefix = portalConfigPrefix;
            this.drawColor = drawColor;
            this.direction = Direction.UNSET;
            this.zoomValue = 0;
            this.handlesZoom = false;
            this.handlesDirection = false;
        }

        void SetHandles(HANDLE_TYPE handles){
            int handleFlags = handles.getValue();
            handlesDirection = (handleFlags & HANDLE_TYPE.DIRECTION.getValue()) != 0;
            handlesZoom = (handleFlags & HANDLE_TYPE.ZOOM.getValue()) != 0;
        }

        void SetDirection(Direction direction){
            this.direction = direction;
        }

        void SetZoom(int zoomValue){
            this.zoomValue = zoomValue;
        }

        Direction direction;
        int zoomValue;
        boolean handlesZoom;
        boolean handlesDirection;
    }

}

/*
 * Copyright (c) 2025, 1Defence
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.teleportzoom;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.chatbox.ChatboxPanelManager;

import javax.inject.Inject;

@Slf4j
public class SelectionHandler
{
    TeleportZoomPlugin plugin;
    ChatboxPanelManager chatboxPanelManager;
    ConfigManager configManager;

    @Inject
    public SelectionHandler(TeleportZoomPlugin plugin, ChatboxPanelManager chatboxPanelManager, ConfigManager configManager){
        this.plugin = plugin;
        this.chatboxPanelManager = chatboxPanelManager;
        this.configManager = configManager;
    }

    public void promptForDirection(int promptedRegion){
        chatboxPanelManager.openTextMenuInput("[Teleport Zoom] Save a direction?")
                .option("North", () -> SaveDirection(Direction.NORTH,promptedRegion))
                .option("East", () -> SaveDirection(Direction.EAST,promptedRegion))
                .option("South", () -> SaveDirection(Direction.SOUTH,promptedRegion))
                .option("West", () -> SaveDirection(Direction.WEST,promptedRegion))
                .option("None, Zoom only", () -> SaveDirection(Direction.UNSET,promptedRegion))
                .build();
    }

    void SaveDirection(Direction direction, int promptedRegion){
        if (direction == Direction.UNSET)
        {
            //while yes, the user may not have a value set in this selection.. unsetconfig already null checks so this option is both a clear or a no if not already present.
            configManager.unsetConfiguration(TeleportZoomConfig.GROUP, TeleportZoomConfig.PREFIX_DIRECTION + promptedRegion);
        }else{
            configManager.setConfiguration(TeleportZoomConfig.GROUP, TeleportZoomConfig.PREFIX_DIRECTION + promptedRegion, direction);
        }
    }

}
/*
 * Copyright (c) 2025, 1Defence
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.teleportzoom;

import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.api.Point;

import javax.inject.Inject;
import java.awt.*;
import java.util.Map;

import com.teleportzoom.GwenithHandler.PortalData;


public class GwenithTeleportsOverlay extends Overlay
{

    private final Client client;
    private final GwenithHandler handler;

    @Inject
    public GwenithTeleportsOverlay(Client client, GwenithHandler handler)
    {
        this.client = client;
        this.handler = handler;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);
        setPriority(OverlayPriority.MED);

    }

    /**Render label over portals, used to indicate to the user what portal is what in the configuration.*/
    @Override
    public Dimension render(Graphics2D graphics)
    {

        if(!handler.configPortalLabels)
        {
            return null;
        }

        for (Map.Entry<WorldPoint, PortalData> entry : handler.portalMap.entrySet()) {
            WorldPoint centerTile = entry.getKey();
            PortalData portal = entry.getValue();

            renderTile(graphics,centerTile,portal.drawColor);
            LocalPoint portalLP = LocalPoint.fromWorld(client,centerTile);
            if(portalLP != null)
            {
                FontMetrics fm2 = graphics.getFontMetrics();
                int halfWidth = fm2.stringWidth(portal.portalDisplayName)/2;

                final int height = client.getLocalPlayer().getLogicalHeight();
                Point textPointA = Perspective.localToCanvas(client, portalLP, 0, height);
                if(textPointA != null)
                {
                    Point textPointB = new Point(textPointA.getX() - halfWidth, textPointA.getY());
                    graphics.setFont(new Font(FontManager.getRunescapeFont().getName(), Font.BOLD, 20));
                    OverlayUtil.renderTextLocation(graphics, textPointB, portal.portalDisplayName, portal.drawColor);
                }
            }
        }


        return null;
    }

    /**Renders a singular tile on the scene*/
    private void renderTile(Graphics2D graphics, WorldPoint tile, Color tileBorderColor)
    {
        LocalPoint lp;
        if((lp = LocalPoint.fromWorld(client, tile)) == null){
            return;
        }

        Polygon poly = Perspective.getCanvasTilePoly(client, lp);
        if (poly != null)
        {
            OverlayUtil.renderPolygon(graphics, poly, tileBorderColor,new Color(tileBorderColor.getRed(),tileBorderColor.getGreen(),tileBorderColor.getBlue(),20), new BasicStroke(2f));
        }
    }

}


package com.teleportzoom;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.HotkeyListener;

@Slf4j
@PluginDescriptor(
	name = "Teleport Zoom",
		description = "Set custom zoom value when arriving at a teleport"
)
public class TeleportZoomPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private TeleportZoomConfig config;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private GwenithHandler gwenithHandler;

	@Inject
	private GwenithTeleportsOverlay gwenithTeleportsOverlay;

	@Inject
	private EventBus eventBus;

	@Inject SelectionHandler selectionHandler;

	GameState lastState = GameState.LOGGED_IN;

	WorldPoint lastWorldPoint = null;

	private final HotkeyListener saveKeyListener = new HotkeyListener(() -> config.saveKey())
	{
		@Override
		public void hotkeyPressed()
		{
			clientThread.invoke(() -> SaveZoom());
		}
	};

	private final HotkeyListener deleteKeyListener = new HotkeyListener(() -> config.deleteKey())
	{
		@Override
		public void hotkeyPressed()
		{
			clientThread.invoke(() -> DeleteZoom());
		}
	};

	@Provides
	TeleportZoomConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TeleportZoomConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		keyManager.registerKeyListener(saveKeyListener);
		keyManager.registerKeyListener(deleteKeyListener);
		overlayManager.add(gwenithTeleportsOverlay);
		eventBus.register(gwenithHandler);
		gwenithHandler.registerBoat();
	}

	@Override
	protected void shutDown() throws Exception
	{
		keyManager.unregisterKeyListener(saveKeyListener);
		keyManager.unregisterKeyListener(deleteKeyListener);
		overlayManager.remove(gwenithTeleportsOverlay);
		eventBus.unregister(gwenithHandler);
	}

	/**
	 * Save last known location to verify a teleport has occcured rather than running accross a load line.
	 */
	@Subscribe
	public void onGameTick(GameTick tick)
	{
		lastWorldPoint = GetCurrentWorldPoint();
	}

	/**
	 * Detect when a teleport load has occured and set the zoom accordingly if there is one saved for the given region.
	 */
	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (lastState == GameState.LOADING && gameStateChanged.getGameState() == GameState.LOGGED_IN)
		{
			String savedZoomRaw = configManager.getConfiguration(TeleportZoomConfig.GROUP, TeleportZoomConfig.PREFIX + GetCurrentRegion());
			if(savedZoomRaw != null)
			{
				//ensures the zoom only triggers if the player traverses more than the max natural tiles possible in one tick(1=walk,2=run,3=run+light log)
				boolean distanceValid = lastWorldPoint == null || GetCurrentWorldPoint().distanceTo(lastWorldPoint) > 3;
				if(distanceValid)
				{
					try
					{
						int savedZoom = Integer.parseInt(savedZoomRaw);
						client.runScript(ScriptID.CAMERA_DO_ZOOM, savedZoom, savedZoom);
					} catch (NumberFormatException ignored)
					{
					}
				}
			}

			String savedDirectionRaw = configManager.getConfiguration(TeleportZoomConfig.GROUP, TeleportZoomConfig.PREFIX_DIRECTION + GetCurrentRegion());
			if (savedDirectionRaw != null)
			{
				//ensures the direction change only triggers if the player traverses more than the max natural tiles possible in one tick(1=walk,2=run,3=run+light log)
				boolean distanceValid = lastWorldPoint == null || GetCurrentWorldPoint().distanceTo(lastWorldPoint) > 3;
				if (distanceValid)
				{
					try
					{
						Direction savedDirection = Direction.valueOf(savedDirectionRaw);
						SetDirection(savedDirection);
					} catch (IllegalArgumentException ignored)
					{
					}
				}
			}

		}
		lastState = gameStateChanged.getGameState();
	}

	/**
	 * Call the script the compass uses to set a pre-defined angle of N-E-S-W
	 */
	void SetDirection(Direction direction){
		if(direction == Direction.UNSET)
			return;
		final int compassScriptID = 1050;
		client.runScript(compassScriptID, direction.getScriptValue());
	}

	/**
	 * Convenience function to send a game message.
	 */
	void SendGameMessage(String contents){
			String message = new ChatMessageBuilder()
					.append(ChatColorType.HIGHLIGHT)
					.append(contents)
					.build();
			chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage(message)
					.build());
	}


	/**
	 * If valid gets the current world point of the local player.
	 */
	WorldPoint GetCurrentWorldPoint(){
		Player localPlayer;
		if((localPlayer = client.getLocalPlayer()) == null)
			return null;

		WorldPoint worldPoint;
		if((worldPoint = localPlayer.getWorldLocation()) == null)
			return null;

		return worldPoint;
	}

	/**
	 * Determine and return the current region accounting for instances such as the POH
	 */
	int GetCurrentRegion(){
		WorldPoint worldPoint = GetCurrentWorldPoint();
		if(worldPoint == null)
			return -1;

		LocalPoint localPoint = LocalPoint.fromWorld(client, worldPoint);

		if(localPoint == null)
			return -1;

		return WorldPoint.fromLocalInstance(client, localPoint).getRegionID();
	}

	/**
	 * Return the current zoom
	 */
	int GetCurrentZoom(){
		return client.getVarcIntValue(VarClientInt.CAMERA_ZOOM_FIXED_VIEWPORT);
	}

	/**
	 * Save the current zoom to the active loaded region
	 */
	void SaveZoom(){
		int currentRegionId = GetCurrentRegion();
		if(currentRegionId != -1)
		{
			int currentZoom = GetCurrentZoom();
			configManager.setConfiguration(TeleportZoomConfig.GROUP, TeleportZoomConfig.PREFIX + currentRegionId, currentZoom);
			SendGameMessage("Saved zoom...(" + currentZoom + ")");
			if (config.directionPrompt())
			{
				selectionHandler.promptForDirection(currentRegionId);
			}
		}
	}

	/**
	 * Delete the current zoom from the active loaded region
	 */
	void DeleteZoom(){
		int currentRegionId = GetCurrentRegion();
		if(currentRegionId != -1)
		{
			int currentZoom = GetCurrentZoom();
			configManager.unsetConfiguration(TeleportZoomConfig.GROUP, TeleportZoomConfig.PREFIX + currentRegionId);
			configManager.unsetConfiguration(TeleportZoomConfig.GROUP, TeleportZoomConfig.PREFIX_DIRECTION + currentRegionId);
			SendGameMessage("Deleted zoom...("+currentZoom+")");
		}
	}

}

package com.teleportzoom;

public enum Direction {
    UNSET(0),
    NORTH(1),
    EAST(2),
    SOUTH(3),
    WEST(4);

    private final int scriptValue;
    Direction(int scriptValue){
        this.scriptValue = scriptValue;
    }

    public int getScriptValue(){
        return scriptValue;
    }

}

package com.teleportzoom;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TeleportZoomPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TeleportZoomPlugin.class);
		RuneLite.main(args);
	}
}
