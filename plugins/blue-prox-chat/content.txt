package com.thatgamerblue.osrs.proxchat.server.config;

/**
 * Possible results of a config file read
 */
public enum ConfigState
{
	/**
	 * Config read was successful, continue loading
	 */
	SUCCESS,
	/**
	 * Config file was actually a directory, abort loading
	 */
	IS_DIRECTORY,
	/**
	 * Config read failed for an unknown reason, abort loading
	 */
	FAILURE,
	/**
	 * Created a new config file, abort loading and alert user to change the password
	 */
	CREATED_NEW;
}

package com.thatgamerblue.osrs.proxchat.server.config;

import com.google.common.collect.ImmutableList;
import com.google.gson.annotations.SerializedName;
import java.util.List;
import lombok.Getter;

/**
 * Data class for holding the server's configuration
 */
@Getter
public class ServerConfig
{
	/**
	 * Holds the original comment so we can put it back if the user changes it
	 */
	public static final List<String> STATIC_COMMENT = ImmutableList.of(
		"You must change the password before use!",
		"An empty password will allow any user to connect with any password.",
		"Any modifications to this comment field will be overwritten."
	);

	/**
	 * Let people know some rules about the config
	 */
	@SerializedName("__comment__readme")
	public List<String> comment = STATIC_COMMENT;

	/**
	 * Password that clients have to supply to connect successfully
	 */
	public String password = "CHANGEME!!!";

	/**
	 * Address for the server to bind to
	 */
	public String bindAddress = "0.0.0.0";

	/**
	 * Port for the server to bind to
	 */
	public int port = 30666;
}

package com.thatgamerblue.osrs.proxchat.server.net;

import java.util.Objects;
import java.util.UUID;
import lombok.Value;

/**
 * Data class to hold the state of a client
 */
@Value
public class ClientState
{
	/**
	 * Server-assigned UUID
	 */
	UUID uuid;

	/**
	 * Player world x position
	 */
	int x;

	/**
	 * Player world y position
	 */
	int y;

	/**
	 * Player world plane
	 */
	int plane;

	/**
	 * Player world
	 */
	int world;

	/**
	 * Player game state
	 */
	int gameState;

	/**
	 * Player chatroom
	 */
	String room;

	/**
	 * Gets the distance to another player. Basically just {@link net.runelite.api.coords.WorldPoint#distanceTo(net.runelite.api.coords.WorldPoint)} with a fancy wrapper
	 *
	 * @param other state of the other client
	 * @return distance to that client
	 */
	public int distanceTo(ClientState other)
	{
		if (other == null)
		{
			return Integer.MAX_VALUE;
		}

		if (this.gameState < 25 || this.gameState > 30)
		{
			return Integer.MAX_VALUE;
		}

		if (other.gameState < 25 || other.gameState > 30)
		{
			return Integer.MAX_VALUE;
		}

		if (this.world != other.world)
		{
			return Integer.MAX_VALUE;
		}

		if (this.x == -1 || other.x == -1)
		{
			return Integer.MAX_VALUE;
		}

		if (!Objects.equals(other.room, this.room))
		{
			return Integer.MAX_VALUE;
		}

		return Math.max(Math.abs(getX() - other.getX()), Math.abs(getY() - other.getY()));
	}
}

package com.thatgamerblue.osrs.proxchat.server.net;

import com.esotericsoftware.kryonet.Connection;
import com.esotericsoftware.kryonet.FrameworkMessage;
import com.google.common.base.Strings;
import com.google.common.hash.Hashing;
import com.thatgamerblue.osrs.proxchat.common.audio.AudioConstants;
import com.thatgamerblue.osrs.proxchat.common.net.NetworkHandler;
import com.thatgamerblue.osrs.proxchat.common.net.messages.c2s.C2SAuth;
import com.thatgamerblue.osrs.proxchat.common.net.messages.c2s.C2SMicPacket;
import com.thatgamerblue.osrs.proxchat.common.net.messages.c2s.C2SUpdatePacket;
import com.thatgamerblue.osrs.proxchat.common.net.messages.s2c.S2CAuthReq;
import com.thatgamerblue.osrs.proxchat.common.net.messages.s2c.S2CKillDecoder;
import com.thatgamerblue.osrs.proxchat.common.net.messages.s2c.S2CMicPacket;
import com.thatgamerblue.osrs.proxchat.common.net.messages.s2c.S2CUpdateReq;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.charset.StandardCharsets;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Map;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;

/**
 * Network handler for the server side.
 * Entrypoint for all packets received from the client
 */
public class ServerNetworkHandler extends NetworkHandler
{
	/**
	 * A secure random instance used for generating nonces
	 */
	private static Random random;

	/**
	 * Holds clients that are waiting for authentication
	 */
	private static final ConcurrentHashMap<Integer, Integer> nonceMap = new ConcurrentHashMap<>();

	/**
	 * Holds clients that are authenticated
	 */
	private static final CopyOnWriteArrayList<Integer> authenticatedClients = new CopyOnWriteArrayList<>();

	/**
	 * Holds game states of clients
	 */
	private static final ConcurrentHashMap<Integer, ClientState> clientStates = new ConcurrentHashMap<>();

	/**
	 * Holds an executor used for doing time-based cleanup e.g. of the nonce map
	 */
	private static final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();

	static
	{
		try
		{
			random = SecureRandom.getInstance("SHA1PRNG");
		}
		catch (NoSuchAlgorithmException e)
		{
			e.printStackTrace();
			System.out.println("Failed to initialize secure random instance, security may be diminished.");
			random = new Random();
		}
	}

	/**
	 * Holds the bind address for the server
	 */
	private final Supplier<String> bindAddress;

	/**
	 * Holds the port for the server to bind to
	 */
	private final Supplier<Integer> port;

	/**
	 * Holds the pre-shared key of the server
	 */
	private final Supplier<String> password;

	/**
	 * Are we shutting down?
	 */
	private final AtomicBoolean shuttingDown = new AtomicBoolean(false);

	/**
	 * Initializes an {@link NetworkHandler} in server operating mode
	 * Handles all connections to clients.
	 * Mainly just acts as a relay for audio.
	 *
	 * @param bindAddress address supplier, see {@link #bindAddress}
	 * @param port        port to bind to
	 * @param password    password to require clients to provide
	 */
	public ServerNetworkHandler(
		Supplier<String> bindAddress,
		Supplier<Integer> port,
		Supplier<String> password
	)
	{
		super(Mode.SERVER);
		this.bindAddress = bindAddress;
		this.port = port;
		this.password = password;
	}

	/**
	 * Sends an object to a specific client over the network
	 *
	 * @param connection where to send the object to
	 * @param object     object to send
	 */
	public void sendTCP(int connection, Object object)
	{
		netServer.sendToTCP(connection, object);
	}

	/**
	 * Sends an object to everyone except one client over the network
	 *
	 * @param connection where to not send the object to
	 * @param object     object to send
	 */
	public void sendTCPToAllExcept(int connection, Object object)
	{
		netServer.sendToAllExceptTCP(connection, object);
	}

	/**
	 * Opens the listen server on the address supplied by {@link #bindAddress}
	 *
	 * @throws java.io.IOException if the initialization fails, for example due to port being in use
	 */
	@Override
	public void connect() throws IOException
	{
		shuttingDown.set(false);
		netServer.start();
		netServer.bind(new InetSocketAddress(bindAddress.get(), port.get()), null);
	}

	/**
	 * Called when a client connects to the server
	 *
	 * @param connection connection object from kryonet
	 */
	@Override
	protected void onConnected(Connection connection)
	{
		int nonce = random.nextInt();
		nonceMap.put(connection.getID(), nonce);
		System.out.println("Received connection w/ id " + connection.getID() + ", sending back nonce " + nonce);
		executor.schedule(() ->
		{
			nonceMap.remove(connection.getID());

			if (connection.isConnected() && !authenticatedClients.contains(connection.getID()))
			{
				connection.close();
			}

		}, 30, TimeUnit.SECONDS);
		sendTCP(connection.getID(), new S2CAuthReq(nonce));
	}

	/**
	 * Called when a client sends a message to the server
	 *
	 * @param connection connection object from kryonet
	 * @param message    message object deserialized by kryonet
	 */
	@Override
	protected void onMessageReceived(Connection connection, Object message)
	{
		if (message instanceof FrameworkMessage)
		{
			// dont care about these messages
			return;
		}

		if (message instanceof C2SAuth)
		{
			Integer nonce;
			if ((nonce = nonceMap.get(connection.getID())) == null)
			{
				System.out.println("Closing connection with " + connection.getID() + " due to lack of nonce");
				connection.close();
				return;
			}

			nonceMap.remove(connection.getID());

			// if password is not empty, do authorization
			if (!Strings.isNullOrEmpty(password.get()))
			{
				byte[] provided = ((C2SAuth) message).password;
				if (provided == null)
				{
					connection.close();
					return;
				}
				byte[] serverPw = password.get().getBytes(StandardCharsets.UTF_8);

				Random rand = new Random(nonce);
				for (int i = 0; i < serverPw.length; i++)
				{
					serverPw[i] = (byte) (serverPw[i] ^ rand.nextInt());
				}

				byte[] expected = Hashing.sha256().hashBytes(serverPw).asBytes();

				if (provided.length != expected.length)
				{
					connection.close();
					return;
				}

				int result = 0;
				for (int i = 0; i < expected.length; i++)
				{
					result |= provided[i] ^ expected[i];
				}

				if (result != 0)
				{
					System.out.println("Closing connection with " + connection.getID() + " due to an invalid password");
					connection.close();
					return;
				}
			}

			authenticatedClients.add(connection.getID());

			sendTCP(connection.getID(), new S2CUpdateReq());

			System.out.println("Client " + connection.getID() + " successfully authorized.");

			// because of this return we can now hoist out the auth check
			return;
		}

		// authentication check
		if (!authenticatedClients.contains(connection.getID()))
		{
			connection.close();
			return;
		}

		if (message instanceof C2SUpdatePacket)
		{
			C2SUpdatePacket update = (C2SUpdatePacket) message;
			ClientState oldState;
			UUID uuid;
			if ((oldState = clientStates.get(connection.getID())) != null)
			{
				uuid = oldState.getUuid();
			}
			else
			{
				uuid = UUID.randomUUID();
			}

			clientStates.put(connection.getID(), new ClientState(uuid, update.x, update.y, update.plane, update.world, update.gameState, update.room));
		}
		else if (message instanceof C2SMicPacket)
		{
			C2SMicPacket micPacket = (C2SMicPacket) message;

			if (micPacket.data == null)
			{
				return;
			}

			int sender = connection.getID();
			ClientState senderState = clientStates.get(sender);

			if (senderState == null)
			{
				sendTCP(sender, new S2CUpdateReq());
				return;
			}

			for (Map.Entry<Integer, ClientState> e : clientStates.entrySet())
			{
				int k = e.getKey();
				ClientState v = e.getValue();
				if (k == sender)
				{
					continue;
				}

				int dist;
				if ((dist = senderState.distanceTo(v)) > AudioConstants.MAX_DISTANCE)
				{
					continue;
				}

				sendTCP(k, new S2CMicPacket(senderState.getUuid(), micPacket.data, dist));
			}
		}
	}

	/**
	 * Called when a client disconnects from the server
	 *
	 * @param connection connection object from kryonet
	 */
	@Override
	protected void onDisconnected(Connection connection)
	{
		System.out.println("Client " + connection.getID() + " disconnected.");
		nonceMap.remove(connection.getID());
		authenticatedClients.remove((Object) connection.getID());
		ClientState state = clientStates.remove(connection.getID());
		if (!shuttingDown.get())
		{
			if (state != null)
			{
				sendTCPToAllExcept(connection.getID(), new S2CKillDecoder(state.getUuid()));
			}
		}
	}

	/**
	 * Disconnects all open client connections and closes the server for connections.
	 * Reusable after calling {@link ServerNetworkHandler#connect()}
	 */
	@Override
	public void disconnect()
	{
		netServer.stop();
	}

	/**
	 * Destroys any long-lasting instances this class holds. Will not be reusable after this is called.
	 * Also calls {@link #disconnect()}
	 */
	public void shutdown()
	{
		System.out.println("Shutting down network...");
		shuttingDown.set(true);
		disconnect();
		System.out.println("Shutting down executor...");
		executor.shutdown();
	}
}

package com.thatgamerblue.osrs.proxchat.server;

import com.esotericsoftware.minlog.Log;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.thatgamerblue.osrs.proxchat.server.config.ConfigState;
import com.thatgamerblue.osrs.proxchat.server.config.ServerConfig;
import com.thatgamerblue.osrs.proxchat.server.net.ServerNetworkHandler;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.Base64;
import lombok.SneakyThrows;

/**
 * Entrypoint for the Proximity Chat server component
 */
public class ProxChatServer
{
	/**
	 * Global GSON instance for json /(de)?serialization/
	 */
	public static final Gson GSON = createGson();
	/**
	 * Location of the configuration file
	 */
	private static final File CONFIG_FILE = new File("config.json");

	/**
	 * Network handler for the server side
	 */
	private ServerNetworkHandler networkHandler;

	/**
	 * The configuration for the server side
	 */
	private ServerConfig config;

	/**
	 * Main function for the server
	 *
	 * @param args any arguments passed on the command line
	 * @throws java.io.IOException if network or file errors occur
	 */
	public static void main(String[] args) throws IOException
	{
		Log.set(Log.LEVEL_INFO);
		ProxChatServer server = new ProxChatServer();
		switch (server.loadConfig())
		{
			case SUCCESS:
				System.out.println("Successfully loaded config.");
				break;
			case FAILURE:
				System.out.println("Failed to load config, exiting.");
				System.exit(-1);
				break;
			case IS_DIRECTORY:
				System.out.println("config.json is a directory, please remove it.");
				System.exit(-1);
				break;
			case CREATED_NEW:
				System.out.println("Created new config file, please change the password.");
				System.exit(0);
				break;
		}
		server.writeConfig();
		Runtime.getRuntime().addShutdownHook(new Thread(server::shutdown));
		server.start();
	}

	/**
	 * Creates the GSON instance to bypass the check for a new GSON in the gh actions because this is server side code,
	 * so I don't care if it's rubbish, it only runs once and not on the client
	 *
	 * @return a new Gson instance, created with reflection
	 */
	private static Gson createGson() {
		//GsonBuilder builder = (GsonBuilder) Class.forName("com.google.gson.GsonBuilder").getDeclaredConstructor().newInstance();
		//return builder.setPrettyPrinting().disableHtmlEscaping().create();
		return new GsonBuilder().disableHtmlEscaping().setPrettyPrinting().create();
	}

	/**
	 * Loads the config. Will set {@link com.thatgamerblue.osrs.proxchat.server.ProxChatServer#config}
	 * If doesn't return SUCCESS, no guarantees are made about the validity of the config instance.
	 *
	 * @return the appropriate {@link com.thatgamerblue.osrs.proxchat.server.config.ConfigState} based off what happened
	 */
	public ConfigState loadConfig()
	{
		if (CONFIG_FILE.isDirectory())
		{
			return ConfigState.IS_DIRECTORY;
		}
		else if (!CONFIG_FILE.exists())
		{
			ServerConfig defaultConfig = new ServerConfig();
			String configStr = GSON.toJson(defaultConfig);
			try
			{
				Files.write(CONFIG_FILE.toPath(), configStr.getBytes(StandardCharsets.UTF_8));
			}
			catch (IOException ex)
			{
				ex.printStackTrace();
				return ConfigState.FAILURE;
			}

			return ConfigState.CREATED_NEW;
		}

		try (FileReader fr = new FileReader(CONFIG_FILE))
		{
			config = GSON.fromJson(fr, ServerConfig.class);
		}
		catch (IOException ex)
		{
			ex.printStackTrace();
			return ConfigState.FAILURE;
		}

		return ConfigState.SUCCESS;
	}

	/**
	 * Writes the current {@link #config} to disk, overwriting config.json if it exists.
	 *
	 * @return true on success, false on failure
	 */
	public boolean writeConfig()
	{
		// we've already verified that config.json isn't a directory, so we can safely clobber it.
		// if someone replaced it with a directory while the server is running they have subzero iq

		System.out.println("Writing config file...");

		config.comment = ServerConfig.STATIC_COMMENT;

		String configStr = GSON.toJson(config);
		try
		{
			Files.write(CONFIG_FILE.toPath(), configStr.getBytes(StandardCharsets.UTF_8));
		}
		catch (IOException ex)
		{
			ex.printStackTrace();
			System.out.println(Base64.getEncoder().encodeToString(configStr.getBytes(StandardCharsets.UTF_8)));
			System.out.println("Failed to write config file, data may be lost!");
			return false;
		}

		System.out.println("Successfully written config file");
		return true;
	}

	/**
	 * Creates the networkHandler instqnce and starts listening
	 *
	 * @throws IOException if anything goes wrong starting the server
	 */
	public void start() throws IOException
	{
		networkHandler = new ServerNetworkHandler(config::getBindAddress, config::getPort, config::getPassword);
		networkHandler.initKryonet();
		networkHandler.connect();
	}

	/**
	 * Shuts down the server entirely
	 */
	public void shutdown()
	{
		System.out.println("Shutting down...");
		writeConfig();
		networkHandler.shutdown();
	}
}

package com.thatgamerblue.osrs.proxchat.server.test;

import com.thatgamerblue.osrs.proxchat.server.ProxChatServer;
import java.io.IOException;

/**
 * Runs the server.
 */
public class RunServer {

	/**
	 * Main entrypoint for the server to run in IDE
	 *
	 * @param args any command line arguments
	 * @throws java.io.IOException sometimes
	 */
	public static void main(String[] args) throws IOException {
		ProxChatServer.main(args);
	}
}

package com.thatgamerblue.osrs.proxchat.server.test;

import com.esotericsoftware.kryonet.Connection;
import com.esotericsoftware.kryonet.Listener;
import com.esotericsoftware.kryonet.Server;
import com.thatgamerblue.osrs.proxchat.common.net.messages.test.C2STestPacket;
import com.thatgamerblue.osrs.proxchat.common.net.messages.test.S2CTestPacket;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Simple test server, created so I can get familiar with how kryonet works
 */
public class TestServer
{
	/**
	 * Main entrypoint of the test server
	 *
	 * @param args any commandline arguments
	 * @throws IOException if an error occurs. It's a test server nobody cares about exceptions.
	 */
	public static void main(String[] args) throws IOException
	{
		TestServerNetworkHandler handler = new TestServerNetworkHandler();
		handler.connect();
	}

	/**
	 * Class for handing connections for the test server
	 */
	static class TestServerNetworkHandler
	{
		/**
		 * Kryonet server instance
		 */
		Server server = new Server(16384, 16384);
		/**
		 * Executor for sending packets on a delay
		 */
		ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();

		/**
		 * Initialize kryonet and start listening
		 *
		 * @throws IOException if starting the listener fails
		 */
		public void connect() throws IOException
		{
			initKryonet();
			doConnect();
		}

		/**
		 * Registers all the packets, serializers and listeners used
		 */
		private void initKryonet()
		{
			server.getKryo().register(S2CTestPacket.class, new S2CTestPacket.Serializer());
			server.getKryo().register(C2STestPacket.class, new C2STestPacket.Serializer());

			server.addListener(new Listener()
			{
				/**
				 * {@inheritDoc}
				 */
				@Override
				public void received(Connection connection, Object object)
				{
					if (object instanceof C2STestPacket)
					{
						System.out.println("recv: " + ((C2STestPacket) object).s);
						executor.schedule(() -> connection.sendTCP(new S2CTestPacket("Server to client")), 10, TimeUnit.SECONDS);
					}
				}

				/**
				 * {@inheritDoc}
				 */
				@Override
				public void connected(Connection connection)
				{
					System.out.println("New connection id: " + connection.getID());
					connection.sendTCP(new S2CTestPacket("Server to client"));
				}
			});
		}

		/**
		 * Binds to port 30666/tcp on all interfaces and starts listening
		 *
		 * @throws IOException if binding fails
		 */
		private void doConnect() throws IOException
		{
			server.start();
			server.bind(new InetSocketAddress("0.0.0.0", 30666), null);
		}
	}
}


package com.esotericsoftware.kryo;

import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;

/** Handles class registration, writing class identifiers to bytes, and reading class identifiers from bytes.
 * @author Nathan Sweet <misc@n4te.com> */
public interface ClassResolver {
	/** Sets the Kryo instance that this ClassResolver will be used for. This is called automatically by Kryo. */
	public void setKryo (Kryo kryo);

	/** Stores the specified registration.
	 * @see Kryo#register(Registration) */
	public Registration register (Registration registration);

	/** Returns the registration for the specified class, or null if the class is not registered. */
	public Registration getRegistration (Class type);

	/** Returns the registration for the specified ID, or null if no class is registered with that ID. */
	public Registration getRegistration (int classID);

	/** Writes a class and returns its registration.
	 * @param type May be null.
	 * @return Will be null if type is null. */
	public Registration writeClass (Output output, Class type);

	/** Reads a class and returns its registration.
	 * @return May be null. */
	public Registration readClass (Input input);

	/** Called by {@link Kryo#reset()}. */
	public void reset ();
}

package com.esotericsoftware.kryo.factories;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.Serializer;

public class NullSerializerFactory implements SerializerFactory {
	@Override
	public Serializer makeSerializer (Kryo kryo, Class<?> type) {
		return makeSerializer();
	}

	public static Serializer makeSerializer() {
		return null;
	}
}

package com.esotericsoftware.kryo.factories;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.Serializer;

/**
 * A serializer factory that allows the creation of serializers. This factory will be called when a {@link Kryo}
 * serializer discovers a new type for which no serializer is yet known. For example, when a factory is registered
 * via {@link Kryo#setDefaultSerializer(SerializerFactory)} a different serializer can be created dependent on the
 * type of a class.
 *
 * @author Rafael Winterhalter <rafael.wth@web.de>
 */
public interface SerializerFactory {

    /**
     * Creates a new serializer
     * @param kryo The serializer instance requesting the new serializer.
     * @param type The type of the object that is to be serialized.
     * @return An implementation of a serializer that is able to serialize an object of type {@code type}.
     */
	Serializer makeSerializer (Kryo kryo, Class<?> type);
}


package com.esotericsoftware.kryo.io;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;

/** An InputStream whose source is a {@link ByteBuffer}.
 * @author Nathan Sweet <misc@n4te.com> */
public class ByteBufferInputStream extends InputStream {
	private ByteBuffer byteBuffer;

	public ByteBufferInputStream () {
	}

	/** Creates a stream with a new non-direct buffer of the specified size. The position and limit of the buffer is zero. */
	public ByteBufferInputStream (int bufferSize) {
		this(ByteBuffer.allocate(bufferSize));
		byteBuffer.flip();
	}

	/** Creates an uninitialized stream that cannot be used until {@link #setByteBuffer(ByteBuffer)} is called. */
	public ByteBufferInputStream (ByteBuffer byteBuffer) {
		this.byteBuffer = byteBuffer;
	}

	public ByteBuffer getByteBuffer () {
		return byteBuffer;
	}

	public void setByteBuffer (ByteBuffer byteBuffer) {
		this.byteBuffer = byteBuffer;
	}

	public int read () throws IOException {
		if (!byteBuffer.hasRemaining()) return -1;
		return byteBuffer.get();
	}

	public int read (byte[] bytes, int offset, int length) throws IOException {
		if (length == 0) return 0;
		int count = Math.min(byteBuffer.remaining(), length);
		if (count == 0) return -1;
		byteBuffer.get(bytes, offset, count);
		return count;
	}

	public int available () throws IOException {
		return byteBuffer.remaining();
	}
}


package com.esotericsoftware.kryo.io;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;

/** An OutputStream whose target is a {@link ByteBuffer}. If bytes would be written that would overflow the buffer,
 * {@link #flush()} is called. Subclasses can override flush to empty the buffer.
 * @author Nathan Sweet <misc@n4te.com> */
public class ByteBufferOutputStream extends OutputStream {
	private ByteBuffer byteBuffer;

	/** Creates an uninitialized stream that cannot be used until {@link #setByteBuffer(ByteBuffer)} is called. */
	public ByteBufferOutputStream () {
	}

	/** Creates a stream with a new non-direct buffer of the specified size. */
	public ByteBufferOutputStream (int bufferSize) {
		this(ByteBuffer.allocate(bufferSize));
	}

	public ByteBufferOutputStream (ByteBuffer byteBuffer) {
		this.byteBuffer = byteBuffer;
	}

	public ByteBuffer getByteBuffer () {
		return byteBuffer;
	}

	public void setByteBuffer (ByteBuffer byteBuffer) {
		this.byteBuffer = byteBuffer;
	}

	public void write (int b) throws IOException {
		if (!byteBuffer.hasRemaining()) flush();
		byteBuffer.put((byte)b);
	}

	public void write (byte[] bytes, int offset, int length) throws IOException {
		if (byteBuffer.remaining() < length) flush();
		byteBuffer.put(bytes, offset, length);
	}
}


package com.esotericsoftware.kryo.io;

import com.esotericsoftware.kryo.KryoException;

import java.io.IOException;
import java.io.InputStream;

/** An InputStream that reads data from a byte array and optionally fills the byte array from another InputStream as needed.
 * Utility methods are provided for efficiently reading primitive types and strings.
 * <p>
 * The byte[] buffer may be modified and then returned to its original state during some read operations, so the same byte[]
 * should not be used concurrently in separate threads.
 * @author Nathan Sweet <misc@n4te.com> */
public class Input extends InputStream {
	protected byte[] buffer;
	protected int position;
	protected int capacity;
	protected int limit;
	protected long total;
	protected char[] chars = new char[32];
	protected InputStream inputStream;

	/** Creates an uninitialized Input. {@link #setBuffer(byte[])} must be called before the Input is used. */
	public Input () {
	}

	/** Creates a new Input for reading from a byte array.
	 * @param bufferSize The size of the buffer. An exception is thrown if more bytes than this are read. */
	public Input (int bufferSize) {
		this.capacity = bufferSize;
		buffer = new byte[bufferSize];
	}

	/** Creates a new Input for reading from a byte array.
	 * @param buffer An exception is thrown if more bytes than this are read. */
	public Input (byte[] buffer) {
		setBuffer(buffer, 0, buffer.length);
	}

	/** Creates a new Input for reading from a byte array.
	 * @param buffer An exception is thrown if more bytes than this are read. */
	public Input (byte[] buffer, int offset, int count) {
		setBuffer(buffer, offset, count);
	}

	/** Creates a new Input for reading from an InputStream with a buffer size of 4096. */
	public Input (InputStream inputStream) {
		this(4096);
		if (inputStream == null) throw new IllegalArgumentException("inputStream cannot be null.");
		this.inputStream = inputStream;
	}

	/** Creates a new Input for reading from an InputStream. */
	public Input (InputStream inputStream, int bufferSize) {
		this(bufferSize);
		if (inputStream == null) throw new IllegalArgumentException("inputStream cannot be null.");
		this.inputStream = inputStream;
	}

	/** Sets a new buffer. The position and total are reset, discarding any buffered bytes. */
	public void setBuffer (byte[] bytes) {
		setBuffer(bytes, 0, bytes.length);
	}

	/** Sets a new buffer. The position and total are reset, discarding any buffered bytes. */
	public void setBuffer (byte[] bytes, int offset, int count) {
		if (bytes == null) throw new IllegalArgumentException("bytes cannot be null.");
		buffer = bytes;
		position = offset;
		limit = offset + count;
		capacity = bytes.length;
		total = 0;
		inputStream = null;
	}

	public byte[] getBuffer () {
		return buffer;
	}

	public InputStream getInputStream () {
		return inputStream;
	}

	/** Sets a new InputStream. The position and total are reset, discarding any buffered bytes.
	 * @param inputStream May be null. */
	public void setInputStream (InputStream inputStream) {
		this.inputStream = inputStream;
		limit = 0;
		rewind();
	}

	/** Returns the number of bytes read. */
	public long total () {
		return total + position;
	}

	/** Sets the number of bytes read. */
	public void setTotal (int total) {
		this.total = total;
	}

	/** Returns the current position in the buffer. */
	final public int position () {
		return position;
	}

	/** Sets the current position in the buffer. */
	public void setPosition (int position) {
		this.position = position;
	}

	/** Returns the limit for the buffer. */
	final public int limit () {
		return limit;
	}

	/** Sets the limit in the buffer. */
	public void setLimit (int limit) {
		this.limit = limit;
	}

	/** Sets the position and total to zero. */
	public void rewind () {
		position = 0;
		total = 0;
	}

	/** Discards the specified number of bytes. */
	public void skip (int count) throws KryoException {
		int skipCount = Math.min(limit - position, count);
		while (true) {
			position += skipCount;
			count -= skipCount;
			if (count == 0) break;
			skipCount = Math.min(count, capacity);
			require(skipCount);
		}
	}

	/** Fills the buffer with more bytes. Can be overridden to fill the bytes from a source other than the InputStream.
	 * @return -1 if there are no more bytes. */
	protected int fill (byte[] buffer, int offset, int count) throws KryoException {
		if (inputStream == null) return -1;
		try {
			return inputStream.read(buffer, offset, count);
		} catch (IOException ex) {
			throw new KryoException(ex);
		}
	}

	/** @param required Must be > 0. The buffer is filled until it has at least this many bytes.
	 * @return the number of bytes remaining.
	 * @throws KryoException if EOS is reached before required bytes are read (buffer underflow). */
	protected int require (int required) throws KryoException {
		int remaining = limit - position;
		if (remaining >= required) return remaining;
		if (required > capacity) throw new KryoException("Buffer too small: capacity: " + capacity + ", required: " + required);

		int count;
		// Try to fill the buffer.
		if (remaining > 0) {
			count = fill(buffer, limit, capacity - limit);
			if (count == -1) throw new KryoException("Buffer underflow.");
			remaining += count;
			if (remaining >= required) {
				limit += count;
				return remaining;
			}
		}

		// Was not enough, compact and try again.
		System.arraycopy(buffer, position, buffer, 0, remaining);
		total += position;
		position = 0;

		while (true) {
			count = fill(buffer, remaining, capacity - remaining);
			if (count == -1) {
				if (remaining >= required) break;
				throw new KryoException("Buffer underflow.");
			}
			remaining += count;
			if (remaining >= required) break; // Enough has been read.
		}

		limit = remaining;
		return remaining;
	}

	/** @param optional Try to fill the buffer with this many bytes.
	 * @return the number of bytes remaining, but not more than optional, or -1 if the EOS was reached and the buffer is empty. */
	private int optional (int optional) throws KryoException {
		int remaining = limit - position;
		if (remaining >= optional) return optional;
		optional = Math.min(optional, capacity);

		int count;

		// Try to fill the buffer.
		count = fill(buffer, limit, capacity - limit);
		if (count == -1) return remaining == 0 ? -1 : Math.min(remaining, optional);
		remaining += count;
		if (remaining >= optional) {
			limit += count;
			return optional;
		}

		// Was not enough, compact and try again.
		System.arraycopy(buffer, position, buffer, 0, remaining);
		total += position;
		position = 0;

		while (true) {
			count = fill(buffer, remaining, capacity - remaining);
			if (count == -1) break;
			remaining += count;
			if (remaining >= optional) break; // Enough has been read.
		}

		limit = remaining;
		return remaining == 0 ? -1 : Math.min(remaining, optional);
	}

	public boolean eof () {
		return optional(1) <= 0;
	}

	// InputStream

	public int available () throws IOException {
		return limit - position + ((null != inputStream) ? inputStream.available() : 0);
	}

	/** Reads a single byte as an int from 0 to 255, or -1 if there are no more bytes are available. */
	public int read () throws KryoException {
		if (optional(1) <= 0) return -1;
		return buffer[position++] & 0xFF;
	}

	/** Reads bytes.length bytes or less and writes them to the specified byte[], starting at 0, and returns the number of bytes
	 * read. */
	public int read (byte[] bytes) throws KryoException {
		return read(bytes, 0, bytes.length);
	}

	/** Reads count bytes or less and writes them to the specified byte[], starting at offset, and returns the number of bytes read
	 * or -1 if no more bytes are available. */
	public int read (byte[] bytes, int offset, int count) throws KryoException {
		if (bytes == null) throw new IllegalArgumentException("bytes cannot be null.");
		int startingCount = count;
		int copyCount = Math.min(limit - position, count);
		while (true) {
			System.arraycopy(buffer, position, bytes, offset, copyCount);
			position += copyCount;
			count -= copyCount;
			if (count == 0) break;
			offset += copyCount;
			copyCount = optional(count);
			if (copyCount == -1) {
				// End of data.
				if (startingCount == count) return -1;
				break;
			}
			if (position == limit) break;
		}
		return startingCount - count;
	}

	/** Discards the specified number of bytes. */
	public long skip (long count) throws KryoException {
		long remaining = count;
		while (remaining > 0) {
			int skip = (int)Math.min(Integer.MAX_VALUE, remaining);
			skip(skip);
			remaining -= skip;
		}
		return count;
	}

	/** Closes the underlying InputStream, if any. */
	public void close () throws KryoException {
		if (inputStream != null) {
			try {
				inputStream.close();
			} catch (IOException ignored) {
			}
		}
	}

	// byte

	/** Reads a single byte. */
	public byte readByte () throws KryoException {
		require(1);
		return buffer[position++];
	}

	/** Reads a byte as an int from 0 to 255. */
	public int readByteUnsigned () throws KryoException {
		require(1);
		return buffer[position++] & 0xFF;
	}

	/** Reads the specified number of bytes into a new byte[]. */
	public byte[] readBytes (int length) throws KryoException {
		byte[] bytes = new byte[length];
		readBytes(bytes, 0, length);
		return bytes;
	}

	/** Reads bytes.length bytes and writes them to the specified byte[], starting at index 0. */
	public void readBytes (byte[] bytes) throws KryoException {
		readBytes(bytes, 0, bytes.length);
	}

	/** Reads count bytes and writes them to the specified byte[], starting at offset. */
	public void readBytes (byte[] bytes, int offset, int count) throws KryoException {
		if (bytes == null) throw new IllegalArgumentException("bytes cannot be null.");
		int copyCount = Math.min(limit - position, count);
		while (true) {
			System.arraycopy(buffer, position, bytes, offset, copyCount);
			position += copyCount;
			count -= copyCount;
			if (count == 0) break;
			offset += copyCount;
			copyCount = Math.min(count, capacity);
			require(copyCount);
		}
	}

	// int

	/** Reads a 4 byte int. */
	public int readInt () throws KryoException {
		require(4);
		byte[] buffer = this.buffer;
		int position = this.position;
		this.position = position + 4;
		return (buffer[position] & 0xFF) << 24 //
			| (buffer[position + 1] & 0xFF) << 16 //
			| (buffer[position + 2] & 0xFF) << 8 //
			| buffer[position + 3] & 0xFF;
	}

	/** Reads a 1-5 byte int. This stream may consider such a variable length encoding request as a hint. It is not guaranteed that
	 * a variable length encoding will be really used. The stream may decide to use native-sized integer representation for
	 * efficiency reasons. **/
	public int readInt (boolean optimizePositive) throws KryoException {
		return readVarInt(optimizePositive);
	}

	/** Reads a 1-5 byte int. It is guaranteed that a varible length encoding will be used. */
	public int readVarInt (boolean optimizePositive) throws KryoException {
		if (require(1) < 5) return readInt_slow(optimizePositive);
		int b = buffer[position++];
		int result = b & 0x7F;
		if ((b & 0x80) != 0) {
			byte[] buffer = this.buffer;
			b = buffer[position++];
			result |= (b & 0x7F) << 7;
			if ((b & 0x80) != 0) {
				b = buffer[position++];
				result |= (b & 0x7F) << 14;
				if ((b & 0x80) != 0) {
					b = buffer[position++];
					result |= (b & 0x7F) << 21;
					if ((b & 0x80) != 0) {
						b = buffer[position++];
						result |= (b & 0x7F) << 28;
					}
				}
			}
		}
		return optimizePositive ? result : ((result >>> 1) ^ -(result & 1));
	}

	private int readInt_slow (boolean optimizePositive) {
		// The buffer is guaranteed to have at least 1 byte.
		int b = buffer[position++];
		int result = b & 0x7F;
		if ((b & 0x80) != 0) {
			require(1);
			byte[] buffer = this.buffer;
			b = buffer[position++];
			result |= (b & 0x7F) << 7;
			if ((b & 0x80) != 0) {
				require(1);
				b = buffer[position++];
				result |= (b & 0x7F) << 14;
				if ((b & 0x80) != 0) {
					require(1);
					b = buffer[position++];
					result |= (b & 0x7F) << 21;
					if ((b & 0x80) != 0) {
						require(1);
						b = buffer[position++];
						result |= (b & 0x7F) << 28;
					}
				}
			}
		}
		return optimizePositive ? result : ((result >>> 1) ^ -(result & 1));
	}

	/** Returns true if enough bytes are available to read an int with {@link #readInt(boolean)}. */
	public boolean canReadInt () throws KryoException {
		if (limit - position >= 5) return true;
		if (optional(5) <= 0) return false;
		int p = position;
		if ((buffer[p++] & 0x80) == 0) return true;
		if (p == limit) return false;
		if ((buffer[p++] & 0x80) == 0) return true;
		if (p == limit) return false;
		if ((buffer[p++] & 0x80) == 0) return true;
		if (p == limit) return false;
		if ((buffer[p++] & 0x80) == 0) return true;
		if (p == limit) return false;
		return true;
	}

	/** Returns true if enough bytes are available to read a long with {@link #readLong(boolean)}. */
	public boolean canReadLong () throws KryoException {
		if (limit - position >= 9) return true;
		if (optional(5) <= 0) return false;
		int p = position;
		if ((buffer[p++] & 0x80) == 0) return true;
		if (p == limit) return false;
		if ((buffer[p++] & 0x80) == 0) return true;
		if (p == limit) return false;
		if ((buffer[p++] & 0x80) == 0) return true;
		if (p == limit) return false;
		if ((buffer[p++] & 0x80) == 0) return true;
		if (p == limit) return false;
		if ((buffer[p++] & 0x80) == 0) return true;
		if (p == limit) return false;
		if ((buffer[p++] & 0x80) == 0) return true;
		if (p == limit) return false;
		if ((buffer[p++] & 0x80) == 0) return true;
		if (p == limit) return false;
		if ((buffer[p++] & 0x80) == 0) return true;
		if (p == limit) return false;
		return true;
	}

	// string

	/** Reads the length and string of UTF8 characters, or null. This can read strings written by {@link Output#writeString(String)}
	 * , {@link Output#writeString(CharSequence)}, and {@link Output#writeAscii(String)}.
	 * @return May be null. */
	public String readString () {
		int available = require(1);
		int b = buffer[position++];
		if ((b & 0x80) == 0) return readAscii(); // ASCII.
		// Null, empty, or UTF8.
		int charCount = available >= 5 ? readUtf8Length(b) : readUtf8Length_slow(b);
		switch (charCount) {
		case 0:
			return null;
		case 1:
			return "";
		}
		charCount--;
		if (chars.length < charCount) chars = new char[charCount];
		readUtf8(charCount);
		return new String(chars, 0, charCount);
	}

	private int readUtf8Length (int b) {
		int result = b & 0x3F; // Mask all but first 6 bits.
		if ((b & 0x40) != 0) { // Bit 7 means another byte, bit 8 means UTF8.
			byte[] buffer = this.buffer;
			b = buffer[position++];
			result |= (b & 0x7F) << 6;
			if ((b & 0x80) != 0) {
				b = buffer[position++];
				result |= (b & 0x7F) << 13;
				if ((b & 0x80) != 0) {
					b = buffer[position++];
					result |= (b & 0x7F) << 20;
					if ((b & 0x80) != 0) {
						b = buffer[position++];
						result |= (b & 0x7F) << 27;
					}
				}
			}
		}
		return result;
	}

	private int readUtf8Length_slow (int b) {
		int result = b & 0x3F; // Mask all but first 6 bits.
		if ((b & 0x40) != 0) { // Bit 7 means another byte, bit 8 means UTF8.
			require(1);
			byte[] buffer = this.buffer;
			b = buffer[position++];
			result |= (b & 0x7F) << 6;
			if ((b & 0x80) != 0) {
				require(1);
				b = buffer[position++];
				result |= (b & 0x7F) << 13;
				if ((b & 0x80) != 0) {
					require(1);
					b = buffer[position++];
					result |= (b & 0x7F) << 20;
					if ((b & 0x80) != 0) {
						require(1);
						b = buffer[position++];
						result |= (b & 0x7F) << 27;
					}
				}
			}
		}
		return result;
	}

	private void readUtf8 (int charCount) {
		byte[] buffer = this.buffer;
		char[] chars = this.chars;
		// Try to read 7 bit ASCII chars.
		int charIndex = 0;
		int count = Math.min(require(1), charCount);
		int position = this.position;
		int b;
		while (charIndex < count) {
			b = buffer[position++];
			if (b < 0) {
				position--;
				break;
			}
			chars[charIndex++] = (char)b;
		}
		this.position = position;
		// If buffer didn't hold all chars or any were not ASCII, use slow path for remainder.
		if (charIndex < charCount) readUtf8_slow(charCount, charIndex);
	}

	private void readUtf8_slow (int charCount, int charIndex) {
		char[] chars = this.chars;
		byte[] buffer = this.buffer;
		while (charIndex < charCount) {
			if (position == limit) require(1);
			int b = buffer[position++] & 0xFF;
			switch (b >> 4) {
			case 0:
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
			case 6:
			case 7:
				chars[charIndex] = (char)b;
				break;
			case 12:
			case 13:
				if (position == limit) require(1);
				chars[charIndex] = (char)((b & 0x1F) << 6 | buffer[position++] & 0x3F);
				break;
			case 14:
				require(2);
				chars[charIndex] = (char)((b & 0x0F) << 12 | (buffer[position++] & 0x3F) << 6 | buffer[position++] & 0x3F);
				break;
			}
			charIndex++;
		}
	}

	private String readAscii () {
		byte[] buffer = this.buffer;
		int end = position;
		int start = end - 1;
		int limit = this.limit;
		int b;
		do {
			if (end == limit) return readAscii_slow();
			b = buffer[end++];
		} while ((b & 0x80) == 0);
		buffer[end - 1] &= 0x7F; // Mask end of ascii bit.
		String value = new String(buffer, 0, start, end - start);
		buffer[end - 1] |= 0x80;
		position = end;
		return value;
	}

	private String readAscii_slow () {
		position--; // Re-read the first byte.
		// Copy chars currently in buffer.
		int charCount = limit - position;
		if (charCount > chars.length) chars = new char[charCount * 2];
		char[] chars = this.chars;
		byte[] buffer = this.buffer;
		for (int i = position, ii = 0, n = limit; i < n; i++, ii++)
			chars[ii] = (char)buffer[i];
		position = limit;
		// Copy additional chars one by one.
		while (true) {
			require(1);
			int b = buffer[position++];
			if (charCount == chars.length) {
				char[] newChars = new char[charCount * 2];
				System.arraycopy(chars, 0, newChars, 0, charCount);
				chars = newChars;
				this.chars = newChars;
			}
			if ((b & 0x80) == 0x80) {
				chars[charCount++] = (char)(b & 0x7F);
				break;
			}
			chars[charCount++] = (char)b;
		}
		return new String(chars, 0, charCount);
	}

	/** Reads the length and string of UTF8 characters, or null. This can read strings written by {@link Output#writeString(String)}
	 * , {@link Output#writeString(CharSequence)}, and {@link Output#writeAscii(String)}.
	 * @return May be null. */
	public StringBuilder readStringBuilder () {
		int available = require(1);
		int b = buffer[position++];
		if ((b & 0x80) == 0) return new StringBuilder(readAscii()); // ASCII.
		// Null, empty, or UTF8.
		int charCount = available >= 5 ? readUtf8Length(b) : readUtf8Length_slow(b);
		switch (charCount) {
		case 0:
			return null;
		case 1:
			return new StringBuilder("");
		}
		charCount--;
		if (chars.length < charCount) chars = new char[charCount];
		readUtf8(charCount);
		StringBuilder builder = new StringBuilder(charCount);
		builder.append(chars, 0, charCount);
		return builder;
	}

	// float

	/** Reads a 4 byte float. */
	public float readFloat () throws KryoException {
		return Float.intBitsToFloat(readInt());
	}

	/** Reads a 1-5 byte float with reduced precision. */
	public float readFloat (float precision, boolean optimizePositive) throws KryoException {
		return readInt(optimizePositive) / (float)precision;
	}

	// short

	/** Reads a 2 byte short. */
	public short readShort () throws KryoException {
		require(2);
		return (short)(((buffer[position++] & 0xFF) << 8) | (buffer[position++] & 0xFF));
	}

	/** Reads a 2 byte short as an int from 0 to 65535. */
	public int readShortUnsigned () throws KryoException {
		require(2);
		return ((buffer[position++] & 0xFF) << 8) | (buffer[position++] & 0xFF);
	}

	// long

	/** Reads an 8 byte long. */
	public long readLong () throws KryoException {
		require(8);
		byte[] buffer = this.buffer;
		return (long)buffer[position++] << 56 //
			| (long)(buffer[position++] & 0xFF) << 48 //
			| (long)(buffer[position++] & 0xFF) << 40 //
			| (long)(buffer[position++] & 0xFF) << 32 //
			| (long)(buffer[position++] & 0xFF) << 24 //
			| (buffer[position++] & 0xFF) << 16 //
			| (buffer[position++] & 0xFF) << 8 //
			| buffer[position++] & 0xFF;

	}

	/** Reads a 1-9 byte long. This stream may consider such a variable length encoding request as a hint. It is not guaranteed that
	 * a variable length encoding will be really used. The stream may decide to use native-sized integer representation for
	 * efficiency reasons. */
	public long readLong (boolean optimizePositive) throws KryoException {
		return readVarLong(optimizePositive);
	}

	/** Reads a 1-9 byte long. It is guaranteed that a varible length encoding will be used. */
	public long readVarLong (boolean optimizePositive) throws KryoException {
		if (require(1) < 9) return readLong_slow(optimizePositive);
		int b = buffer[position++];
		long result = b & 0x7F;
		if ((b & 0x80) != 0) {
			byte[] buffer = this.buffer;
			b = buffer[position++];
			result |= (b & 0x7F) << 7;
			if ((b & 0x80) != 0) {
				b = buffer[position++];
				result |= (b & 0x7F) << 14;
				if ((b & 0x80) != 0) {
					b = buffer[position++];
					result |= (b & 0x7F) << 21;
					if ((b & 0x80) != 0) {
						b = buffer[position++];
						result |= (long)(b & 0x7F) << 28;
						if ((b & 0x80) != 0) {
							b = buffer[position++];
							result |= (long)(b & 0x7F) << 35;
							if ((b & 0x80) != 0) {
								b = buffer[position++];
								result |= (long)(b & 0x7F) << 42;
								if ((b & 0x80) != 0) {
									b = buffer[position++];
									result |= (long)(b & 0x7F) << 49;
									if ((b & 0x80) != 0) {
										b = buffer[position++];
										result |= (long)b << 56;
									}
								}
							}
						}
					}
				}
			}
		}
		if (!optimizePositive) result = (result >>> 1) ^ -(result & 1);
		return result;
	}

	private long readLong_slow (boolean optimizePositive) {
		// The buffer is guaranteed to have at least 1 byte.
		int b = buffer[position++];
		long result = b & 0x7F;
		if ((b & 0x80) != 0) {
			require(1);
			byte[] buffer = this.buffer;
			b = buffer[position++];
			result |= (b & 0x7F) << 7;
			if ((b & 0x80) != 0) {
				require(1);
				b = buffer[position++];
				result |= (b & 0x7F) << 14;
				if ((b & 0x80) != 0) {
					require(1);
					b = buffer[position++];
					result |= (b & 0x7F) << 21;
					if ((b & 0x80) != 0) {
						require(1);
						b = buffer[position++];
						result |= (long)(b & 0x7F) << 28;
						if ((b & 0x80) != 0) {
							require(1);
							b = buffer[position++];
							result |= (long)(b & 0x7F) << 35;
							if ((b & 0x80) != 0) {
								require(1);
								b = buffer[position++];
								result |= (long)(b & 0x7F) << 42;
								if ((b & 0x80) != 0) {
									require(1);
									b = buffer[position++];
									result |= (long)(b & 0x7F) << 49;
									if ((b & 0x80) != 0) {
										require(1);
										b = buffer[position++];
										result |= (long)b << 56;
									}
								}
							}
						}
					}
				}
			}
		}
		if (!optimizePositive) result = (result >>> 1) ^ -(result & 1);
		return result;
	}

	// boolean

	/** Reads a 1 byte boolean. */
	public boolean readBoolean () throws KryoException {
		require(1);
		return buffer[position++] == 1;
	}

	// char

	/** Reads a 2 byte char. */
	public char readChar () throws KryoException {
		require(2);
		return (char)(((buffer[position++] & 0xFF) << 8) | (buffer[position++] & 0xFF));
	}

	// double

	/** Reads an 8 bytes double. */
	public double readDouble () throws KryoException {
		return Double.longBitsToDouble(readLong());
	}

	/** Reads a 1-9 byte double with reduced precision. */
	public double readDouble (double precision, boolean optimizePositive) throws KryoException {
		return readLong(optimizePositive) / (double)precision;
	}

	// Methods implementing bulk operations on arrays of primitive types

	/** Bulk input of an int array. */
	public int[] readInts (int length, boolean optimizePositive) throws KryoException {
		int[] array = new int[length];
		for (int i = 0; i < length; i++)
			array[i] = readInt(optimizePositive);
		return array;
	}

	/** Bulk input of a long array. */
	public long[] readLongs (int length, boolean optimizePositive) throws KryoException {
		long[] array = new long[length];
		for (int i = 0; i < length; i++)
			array[i] = readLong(optimizePositive);
		return array;
	}

	/** Bulk input of an int array. */
	public int[] readInts (int length) throws KryoException {
		int[] array = new int[length];
		for (int i = 0; i < length; i++)
			array[i] = readInt();
		return array;
	}

	/** Bulk input of a long array. */
	public long[] readLongs (int length) throws KryoException {
		long[] array = new long[length];
		for (int i = 0; i < length; i++)
			array[i] = readLong();
		return array;
	}

	/** Bulk input of a float array. */
	public float[] readFloats (int length) throws KryoException {
		float[] array = new float[length];
		for (int i = 0; i < length; i++)
			array[i] = readFloat();
		return array;
	}

	/** Bulk input of a short array. */
	public short[] readShorts (int length) throws KryoException {
		short[] array = new short[length];
		for (int i = 0; i < length; i++)
			array[i] = readShort();
		return array;
	}

	/** Bulk input of a char array. */
	public char[] readChars (int length) throws KryoException {
		char[] array = new char[length];
		for (int i = 0; i < length; i++)
			array[i] = readChar();
		return array;
	}

	/** Bulk input of a double array. */
	public double[] readDoubles (int length) throws KryoException {
		double[] array = new double[length];
		for (int i = 0; i < length; i++)
			array[i] = readDouble();
		return array;
	}
}


package com.esotericsoftware.kryo.io;

import com.esotericsoftware.kryo.KryoException;

import java.io.IOException;
import java.io.OutputStream;

/** An OutputStream that buffers data in a byte array and optionally flushes to another OutputStream. Utility methods are provided
 * for efficiently writing primitive types and strings.
 * 
 * Encoding of integers: BIG_ENDIAN is used for storing fixed native size integer values LITTLE_ENDIAN is used for a variable
 * length encoding of integer values
 * 
 * @author Nathan Sweet <misc@n4te.com> */
public class Output extends OutputStream {
	protected int maxCapacity;
	protected long total;
	protected int position;
	protected int capacity;
	protected byte[] buffer;
	protected OutputStream outputStream;

	/** Creates an uninitialized Output. {@link #setBuffer(byte[], int)} must be called before the Output is used. */
	public Output () {
	}

	/** Creates a new Output for writing to a byte array.
	 * @param bufferSize The initial and maximum size of the buffer. An exception is thrown if this size is exceeded. */
	public Output (int bufferSize) {
		this(bufferSize, bufferSize);
	}

	/** Creates a new Output for writing to a byte array.
	 * @param bufferSize The initial size of the buffer.
	 * @param maxBufferSize The buffer is doubled as needed until it exceeds maxBufferSize and an exception is thrown. Can be -1
	 *           for no maximum. */
	public Output (int bufferSize, int maxBufferSize) {
		if (maxBufferSize < -1) throw new IllegalArgumentException("maxBufferSize cannot be < -1: " + maxBufferSize);
		this.capacity = bufferSize;
		this.maxCapacity = maxBufferSize == -1 ? Integer.MAX_VALUE : maxBufferSize;
		buffer = new byte[bufferSize];
	}

	/** Creates a new Output for writing to a byte array.
	 * @see #setBuffer(byte[]) */
	public Output (byte[] buffer) {
		this(buffer, buffer.length);
	}

	/** Creates a new Output for writing to a byte array.
	 * @see #setBuffer(byte[], int) */
	public Output (byte[] buffer, int maxBufferSize) {
		if (buffer == null) throw new IllegalArgumentException("buffer cannot be null.");
		setBuffer(buffer, maxBufferSize);
	}

	/** Creates a new Output for writing to an OutputStream. A buffer size of 4096 is used. */
	public Output (OutputStream outputStream) {
		this(4096, 4096);
		if (outputStream == null) throw new IllegalArgumentException("outputStream cannot be null.");
		this.outputStream = outputStream;
	}

	/** Creates a new Output for writing to an OutputStream. */
	public Output (OutputStream outputStream, int bufferSize) {
		this(bufferSize, bufferSize);
		if (outputStream == null) throw new IllegalArgumentException("outputStream cannot be null.");
		this.outputStream = outputStream;
	}

	public OutputStream getOutputStream () {
		return outputStream;
	}

	/** Sets a new OutputStream. The position and total are reset, discarding any buffered bytes.
	 * @param outputStream May be null. */
	public void setOutputStream (OutputStream outputStream) {
		this.outputStream = outputStream;
		position = 0;
		total = 0;
	}

	/** Sets the buffer that will be written to. {@link #setBuffer(byte[], int)} is called with the specified buffer's length as the
	 * maxBufferSize. */
	public void setBuffer (byte[] buffer) {
		setBuffer(buffer, buffer.length);
	}

	/** Sets the buffer that will be written to. The position and total are reset, discarding any buffered bytes. The
	 * {@link #setOutputStream(OutputStream) OutputStream} is set to null.
	 * @param maxBufferSize The buffer is doubled as needed until it exceeds maxBufferSize and an exception is thrown. */
	public void setBuffer (byte[] buffer, int maxBufferSize) {
		if (buffer == null) throw new IllegalArgumentException("buffer cannot be null.");
		if (maxBufferSize < -1) throw new IllegalArgumentException("maxBufferSize cannot be < -1: " + maxBufferSize);
		this.buffer = buffer;
		this.maxCapacity = maxBufferSize == -1 ? Integer.MAX_VALUE : maxBufferSize;
		capacity = buffer.length;
		position = 0;
		total = 0;
		outputStream = null;
	}

	/** Returns the buffer. The bytes between zero and {@link #position()} are the data that has been written. */
	public byte[] getBuffer () {
		return buffer;
	}

	/** Returns a new byte array containing the bytes currently in the buffer between zero and {@link #position()}. */
	public byte[] toBytes () {
		byte[] newBuffer = new byte[position];
		System.arraycopy(buffer, 0, newBuffer, 0, position);
		return newBuffer;
	}

	/** Returns the current position in the buffer. This is the number of bytes that have not been flushed. */
	final public int position () {
		return position;
	}

	/** Sets the current position in the buffer. */
	public void setPosition (int position) {
		this.position = position;
	}

	/** Returns the total number of bytes written. This may include bytes that have not been flushed. */
	final public long total () {
		return total + position;
	}

	/** Sets the position and total to zero. */
	public void clear () {
		position = 0;
		total = 0;
	}

	/** @return true if the buffer has been resized. */
	protected boolean require (int required) throws KryoException {
		if (capacity - position >= required) return false;
		if (required > maxCapacity)
			throw new KryoException("Buffer overflow. Max capacity: " + maxCapacity + ", required: " + required);
		flush();
		while (capacity - position < required) {
			if (capacity == maxCapacity)
				throw new KryoException("Buffer overflow. Available: " + (capacity - position) + ", required: " + required);
			// Grow buffer.
			if (capacity == 0) capacity = 1;
			capacity = Math.min(capacity * 2, maxCapacity);
			if (capacity < 0) capacity = maxCapacity;
			byte[] newBuffer = new byte[capacity];
			System.arraycopy(buffer, 0, newBuffer, 0, position);
			buffer = newBuffer;
		}
		return true;
	}

	// OutputStream

	/** Writes the buffered bytes to the underlying OutputStream, if any. */
	public void flush () throws KryoException {
		if (outputStream == null) return;
		try {
			outputStream.write(buffer, 0, position);
		} catch (IOException ex) {
			throw new KryoException(ex);
		}
		total += position;
		position = 0;
	}

	/** Flushes any buffered bytes and closes the underlying OutputStream, if any. */
	public void close () throws KryoException {
		flush();
		if (outputStream != null) {
			try {
				outputStream.close();
			} catch (IOException ignored) {
			}
		}
	}

	/** Writes a byte. */
	public void write (int value) throws KryoException {
		if (position == capacity) require(1);
		buffer[position++] = (byte)value;
	}

	/** Writes the bytes. Note the byte[] length is not written. */
	public void write (byte[] bytes) throws KryoException {
		if (bytes == null) throw new IllegalArgumentException("bytes cannot be null.");
		writeBytes(bytes, 0, bytes.length);
	}

	/** Writes the bytes. Note the byte[] length is not written. */
	public void write (byte[] bytes, int offset, int length) throws KryoException {
		writeBytes(bytes, offset, length);
	}

	// byte

	public void writeByte (byte value) throws KryoException {
		if (position == capacity) require(1);
		buffer[position++] = value;
	}

	public void writeByte (int value) throws KryoException {
		if (position == capacity) require(1);
		buffer[position++] = (byte)value;
	}

	/** Writes the bytes. Note the byte[] length is not written. */
	public void writeBytes (byte[] bytes) throws KryoException {
		if (bytes == null) throw new IllegalArgumentException("bytes cannot be null.");
		writeBytes(bytes, 0, bytes.length);
	}

	/** Writes the bytes. Note the byte[] length is not written. */
	public void writeBytes (byte[] bytes, int offset, int count) throws KryoException {
		if (bytes == null) throw new IllegalArgumentException("bytes cannot be null.");
		int copyCount = Math.min(capacity - position, count);
		while (true) {
			System.arraycopy(bytes, offset, buffer, position, copyCount);
			position += copyCount;
			count -= copyCount;
			if (count == 0) return;
			offset += copyCount;
			copyCount = Math.min(capacity, count);
			require(copyCount);
		}
	}

	// int

	/** Writes a 4 byte int. Uses BIG_ENDIAN byte order. */
	public void writeInt (int value) throws KryoException {
		require(4);
		byte[] buffer = this.buffer;
		buffer[position++] = (byte)(value >> 24);
		buffer[position++] = (byte)(value >> 16);
		buffer[position++] = (byte)(value >> 8);
		buffer[position++] = (byte)value;
	}

	/** Writes a 1-5 byte int. This stream may consider such a variable length encoding request as a hint. It is not guaranteed that
	 * a variable length encoding will be really used. The stream may decide to use native-sized integer representation for
	 * efficiency reasons.
	 * 
	 * @param optimizePositive If true, small positive numbers will be more efficient (1 byte) and small negative numbers will be
	 *           inefficient (5 bytes). */
	public int writeInt (int value, boolean optimizePositive) throws KryoException {
		return writeVarInt(value, optimizePositive);
	}

	/** Writes a 1-5 byte int. It is guaranteed that a varible length encoding will be used.
	 * 
	 * @param optimizePositive If true, small positive numbers will be more efficient (1 byte) and small negative numbers will be
	 *           inefficient (5 bytes). */
	public int writeVarInt (int value, boolean optimizePositive) throws KryoException {
		if (!optimizePositive) value = (value << 1) ^ (value >> 31);
		if (value >>> 7 == 0) {
			require(1);
			buffer[position++] = (byte)value;
			return 1;
		}
		if (value >>> 14 == 0) {
			require(2);
			buffer[position++] = (byte)((value & 0x7F) | 0x80);
			buffer[position++] = (byte)(value >>> 7);
			return 2;
		}
		if (value >>> 21 == 0) {
			require(3);
			buffer[position++] = (byte)((value & 0x7F) | 0x80);
			buffer[position++] = (byte)(value >>> 7 | 0x80);
			buffer[position++] = (byte)(value >>> 14);
			return 3;
		}
		if (value >>> 28 == 0) {
			require(4);
			buffer[position++] = (byte)((value & 0x7F) | 0x80);
			buffer[position++] = (byte)(value >>> 7 | 0x80);
			buffer[position++] = (byte)(value >>> 14 | 0x80);
			buffer[position++] = (byte)(value >>> 21);
			return 4;
		}
		require(5);
		buffer[position++] = (byte)((value & 0x7F) | 0x80);
		buffer[position++] = (byte)(value >>> 7 | 0x80);
		buffer[position++] = (byte)(value >>> 14 | 0x80);
		buffer[position++] = (byte)(value >>> 21 | 0x80);
		buffer[position++] = (byte)(value >>> 28);
		return 5;
	}

	// string

	/** Writes the length and string, or null. Short strings are checked and if ASCII they are written more efficiently, else they
	 * are written as UTF8. If a string is known to be ASCII, {@link #writeAscii(String)} may be used. The string can be read using
	 * {@link Input#readString()} or {@link Input#readStringBuilder()}.
	 * @param value May be null. */
	public void writeString (String value) throws KryoException {
		if (value == null) {
			writeByte(0x80); // 0 means null, bit 8 means UTF8.
			return;
		}
		int charCount = value.length();
		if (charCount == 0) {
			writeByte(1 | 0x80); // 1 means empty string, bit 8 means UTF8.
			return;
		}
		// Detect ASCII.
		boolean ascii = false;
		if (charCount > 1 && charCount < 64) {
			ascii = true;
			for (int i = 0; i < charCount; i++) {
				int c = value.charAt(i);
				if (c > 127) {
					ascii = false;
					break;
				}
			}
		}
		if (ascii) {
			if (capacity - position < charCount)
				writeAscii_slow(value, charCount);
			else {
				value.getBytes(0, charCount, buffer, position);
				position += charCount;
			}
			buffer[position - 1] |= 0x80;
		} else {
			writeUtf8Length(charCount + 1);
			int charIndex = 0;
			if (capacity - position >= charCount) {
				// Try to write 8 bit chars.
				byte[] buffer = this.buffer;
				int position = this.position;
				for (; charIndex < charCount; charIndex++) {
					int c = value.charAt(charIndex);
					if (c > 127) break;
					buffer[position++] = (byte)c;
				}
				this.position = position;
			}
			if (charIndex < charCount) writeString_slow(value, charCount, charIndex);
		}
	}

	/** Writes the length and CharSequence as UTF8, or null. The string can be read using {@link Input#readString()} or
	 * {@link Input#readStringBuilder()}.
	 * @param value May be null. */
	public void writeString (CharSequence value) throws KryoException {
		if (value == null) {
			writeByte(0x80); // 0 means null, bit 8 means UTF8.
			return;
		}
		int charCount = value.length();
		if (charCount == 0) {
			writeByte(1 | 0x80); // 1 means empty string, bit 8 means UTF8.
			return;
		}
		writeUtf8Length(charCount + 1);
		int charIndex = 0;
		if (capacity - position >= charCount) {
			// Try to write 8 bit chars.
			byte[] buffer = this.buffer;
			int position = this.position;
			for (; charIndex < charCount; charIndex++) {
				int c = value.charAt(charIndex);
				if (c > 127) break;
				buffer[position++] = (byte)c;
			}
			this.position = position;
		}
		if (charIndex < charCount) writeString_slow(value, charCount, charIndex);
	}

	/** Writes a string that is known to contain only ASCII characters. Non-ASCII strings passed to this method will be corrupted.
	 * Each byte is a 7 bit character with the remaining byte denoting if another character is available. This is slightly more
	 * efficient than {@link #writeString(String)}. The string can be read using {@link Input#readString()} or
	 * {@link Input#readStringBuilder()}.
	 * @param value May be null. */
	public void writeAscii (String value) throws KryoException {
		if (value == null) {
			writeByte(0x80); // 0 means null, bit 8 means UTF8.
			return;
		}
		int charCount = value.length();
		switch (charCount) {
		case 0:
			writeByte(1 | 0x80); // 1 is string length + 1, bit 8 means UTF8.
			return;
		case 1:
			writeByte(2 | 0x80); // 2 is string length + 1, bit 8 means UTF8.
			writeByte(value.charAt(0));
			return;
		}
		if (capacity - position < charCount)
			writeAscii_slow(value, charCount);
		else {
			value.getBytes(0, charCount, buffer, position);
			position += charCount;
		}
		buffer[position - 1] |= 0x80; // Bit 8 means end of ASCII.
	}

	/** Writes the length of a string, which is a variable length encoded int except the first byte uses bit 8 to denote UTF8 and
	 * bit 7 to denote if another byte is present. */
	private void writeUtf8Length (int value) {
		if (value >>> 6 == 0) {
			require(1);
			buffer[position++] = (byte)(value | 0x80); // Set bit 8.
		} else if (value >>> 13 == 0) {
			require(2);
			byte[] buffer = this.buffer;
			buffer[position++] = (byte)(value | 0x40 | 0x80); // Set bit 7 and 8.
			buffer[position++] = (byte)(value >>> 6);
		} else if (value >>> 20 == 0) {
			require(3);
			byte[] buffer = this.buffer;
			buffer[position++] = (byte)(value | 0x40 | 0x80); // Set bit 7 and 8.
			buffer[position++] = (byte)((value >>> 6) | 0x80); // Set bit 8.
			buffer[position++] = (byte)(value >>> 13);
		} else if (value >>> 27 == 0) {
			require(4);
			byte[] buffer = this.buffer;
			buffer[position++] = (byte)(value | 0x40 | 0x80); // Set bit 7 and 8.
			buffer[position++] = (byte)((value >>> 6) | 0x80); // Set bit 8.
			buffer[position++] = (byte)((value >>> 13) | 0x80); // Set bit 8.
			buffer[position++] = (byte)(value >>> 20);
		} else {
			require(5);
			byte[] buffer = this.buffer;
			buffer[position++] = (byte)(value | 0x40 | 0x80); // Set bit 7 and 8.
			buffer[position++] = (byte)((value >>> 6) | 0x80); // Set bit 8.
			buffer[position++] = (byte)((value >>> 13) | 0x80); // Set bit 8.
			buffer[position++] = (byte)((value >>> 20) | 0x80); // Set bit 8.
			buffer[position++] = (byte)(value >>> 27);
		}
	}

	private void writeString_slow (CharSequence value, int charCount, int charIndex) {
		for (; charIndex < charCount; charIndex++) {
			if (position == capacity) require(Math.min(capacity, charCount - charIndex));
			int c = value.charAt(charIndex);
			if (c <= 0x007F) {
				buffer[position++] = (byte)c;
			} else if (c > 0x07FF) {
				buffer[position++] = (byte)(0xE0 | c >> 12 & 0x0F);
				require(2);
				buffer[position++] = (byte)(0x80 | c >> 6 & 0x3F);
				buffer[position++] = (byte)(0x80 | c & 0x3F);
			} else {
				buffer[position++] = (byte)(0xC0 | c >> 6 & 0x1F);
				require(1);
				buffer[position++] = (byte)(0x80 | c & 0x3F);
			}
		}
	}

	private void writeAscii_slow (String value, int charCount) throws KryoException {
		byte[] buffer = this.buffer;
		int charIndex = 0;
		int charsToWrite = Math.min(charCount, capacity - position);
		while (charIndex < charCount) {
			value.getBytes(charIndex, charIndex + charsToWrite, buffer, position);
			charIndex += charsToWrite;
			position += charsToWrite;
			charsToWrite = Math.min(charCount - charIndex, capacity);
			if (require(charsToWrite)) buffer = this.buffer;
		}
	}

	// float

	/** Writes a 4 byte float. */
	public void writeFloat (float value) throws KryoException {
		writeInt(Float.floatToIntBits(value));
	}

	/** Writes a 1-5 byte float with reduced precision.
	 * @param optimizePositive If true, small positive numbers will be more efficient (1 byte) and small negative numbers will be
	 *           inefficient (5 bytes). */
	public int writeFloat (float value, float precision, boolean optimizePositive) throws KryoException {
		return writeInt((int)(value * precision), optimizePositive);
	}

	// short

	/** Writes a 2 byte short. Uses BIG_ENDIAN byte order. */
	public void writeShort (int value) throws KryoException {
		require(2);
		buffer[position++] = (byte)(value >>> 8);
		buffer[position++] = (byte)value;
	}

	// long

	/** Writes an 8 byte long. Uses BIG_ENDIAN byte order. */
	public void writeLong (long value) throws KryoException {
		require(8);
		byte[] buffer = this.buffer;
		buffer[position++] = (byte)(value >>> 56);
		buffer[position++] = (byte)(value >>> 48);
		buffer[position++] = (byte)(value >>> 40);
		buffer[position++] = (byte)(value >>> 32);
		buffer[position++] = (byte)(value >>> 24);
		buffer[position++] = (byte)(value >>> 16);
		buffer[position++] = (byte)(value >>> 8);
		buffer[position++] = (byte)value;
	}

	/** Writes a 1-9 byte long. This stream may consider such a variable length encoding request as a hint. It is not guaranteed
	 * that a variable length encoding will be really used. The stream may decide to use native-sized integer representation for
	 * efficiency reasons.
	 * 
	 * @param optimizePositive If true, small positive numbers will be more efficient (1 byte) and small negative numbers will be
	 *           inefficient (9 bytes). */
	public int writeLong (long value, boolean optimizePositive) throws KryoException {
		return writeVarLong(value, optimizePositive);
	}

	/** Writes a 1-9 byte long. It is guaranteed that a varible length encoding will be used.
	 * @param optimizePositive If true, small positive numbers will be more efficient (1 byte) and small negative numbers will be
	 *           inefficient (9 bytes). */
	public int writeVarLong (long value, boolean optimizePositive) throws KryoException {
		if (!optimizePositive) value = (value << 1) ^ (value >> 63);
		if (value >>> 7 == 0) {
			require(1);
			buffer[position++] = (byte)value;
			return 1;
		}
		if (value >>> 14 == 0) {
			require(2);
			buffer[position++] = (byte)((value & 0x7F) | 0x80);
			buffer[position++] = (byte)(value >>> 7);
			return 2;
		}
		if (value >>> 21 == 0) {
			require(3);
			buffer[position++] = (byte)((value & 0x7F) | 0x80);
			buffer[position++] = (byte)(value >>> 7 | 0x80);
			buffer[position++] = (byte)(value >>> 14);
			return 3;
		}
		if (value >>> 28 == 0) {
			require(4);
			buffer[position++] = (byte)((value & 0x7F) | 0x80);
			buffer[position++] = (byte)(value >>> 7 | 0x80);
			buffer[position++] = (byte)(value >>> 14 | 0x80);
			buffer[position++] = (byte)(value >>> 21);
			return 4;
		}
		if (value >>> 35 == 0) {
			require(5);
			buffer[position++] = (byte)((value & 0x7F) | 0x80);
			buffer[position++] = (byte)(value >>> 7 | 0x80);
			buffer[position++] = (byte)(value >>> 14 | 0x80);
			buffer[position++] = (byte)(value >>> 21 | 0x80);
			buffer[position++] = (byte)(value >>> 28);
			return 5;
		}
		if (value >>> 42 == 0) {
			require(6);
			buffer[position++] = (byte)((value & 0x7F) | 0x80);
			buffer[position++] = (byte)(value >>> 7 | 0x80);
			buffer[position++] = (byte)(value >>> 14 | 0x80);
			buffer[position++] = (byte)(value >>> 21 | 0x80);
			buffer[position++] = (byte)(value >>> 28 | 0x80);
			buffer[position++] = (byte)(value >>> 35);
			return 6;
		}
		if (value >>> 49 == 0) {
			require(7);
			buffer[position++] = (byte)((value & 0x7F) | 0x80);
			buffer[position++] = (byte)(value >>> 7 | 0x80);
			buffer[position++] = (byte)(value >>> 14 | 0x80);
			buffer[position++] = (byte)(value >>> 21 | 0x80);
			buffer[position++] = (byte)(value >>> 28 | 0x80);
			buffer[position++] = (byte)(value >>> 35 | 0x80);
			buffer[position++] = (byte)(value >>> 42);
			return 7;
		}
		if (value >>> 56 == 0) {
			require(8);
			buffer[position++] = (byte)((value & 0x7F) | 0x80);
			buffer[position++] = (byte)(value >>> 7 | 0x80);
			buffer[position++] = (byte)(value >>> 14 | 0x80);
			buffer[position++] = (byte)(value >>> 21 | 0x80);
			buffer[position++] = (byte)(value >>> 28 | 0x80);
			buffer[position++] = (byte)(value >>> 35 | 0x80);
			buffer[position++] = (byte)(value >>> 42 | 0x80);
			buffer[position++] = (byte)(value >>> 49);
			return 8;
		}
		require(9);
		buffer[position++] = (byte)((value & 0x7F) | 0x80);
		buffer[position++] = (byte)(value >>> 7 | 0x80);
		buffer[position++] = (byte)(value >>> 14 | 0x80);
		buffer[position++] = (byte)(value >>> 21 | 0x80);
		buffer[position++] = (byte)(value >>> 28 | 0x80);
		buffer[position++] = (byte)(value >>> 35 | 0x80);
		buffer[position++] = (byte)(value >>> 42 | 0x80);
		buffer[position++] = (byte)(value >>> 49 | 0x80);
		buffer[position++] = (byte)(value >>> 56);
		return 9;
	}

	// boolean

	/** Writes a 1 byte boolean. */
	public void writeBoolean (boolean value) throws KryoException {
		if (position == capacity) require(1);
		buffer[position++] = (byte)(value ? 1 : 0);
	}

	// char

	/** Writes a 2 byte char. Uses BIG_ENDIAN byte order. */
	public void writeChar (char value) throws KryoException {
		require(2);
		buffer[position++] = (byte)(value >>> 8);
		buffer[position++] = (byte)value;
	}

	// double

	/** Writes an 8 byte double. */
	public void writeDouble (double value) throws KryoException {
		writeLong(Double.doubleToLongBits(value));
	}

	/** Writes a 1-9 byte double with reduced precision.
	 * @param optimizePositive If true, small positive numbers will be more efficient (1 byte) and small negative numbers will be
	 *           inefficient (9 bytes). */
	public int writeDouble (double value, double precision, boolean optimizePositive) throws KryoException {
		return writeLong((long)(value * precision), optimizePositive);
	}

	/** Returns the number of bytes that would be written with {@link #writeInt(int, boolean)}. */
	static public int intLength (int value, boolean optimizePositive) {
		if (!optimizePositive) value = (value << 1) ^ (value >> 31);
		if (value >>> 7 == 0) return 1;
		if (value >>> 14 == 0) return 2;
		if (value >>> 21 == 0) return 3;
		if (value >>> 28 == 0) return 4;
		return 5;
	}

	/** Returns the number of bytes that would be written with {@link #writeLong(long, boolean)}. */
	static public int longLength (long value, boolean optimizePositive) {
		if (!optimizePositive) value = (value << 1) ^ (value >> 63);
		if (value >>> 7 == 0) return 1;
		if (value >>> 14 == 0) return 2;
		if (value >>> 21 == 0) return 3;
		if (value >>> 28 == 0) return 4;
		if (value >>> 35 == 0) return 5;
		if (value >>> 42 == 0) return 6;
		if (value >>> 49 == 0) return 7;
		if (value >>> 56 == 0) return 8;
		return 9;
	}

	// Methods implementing bulk operations on arrays of primitive types

	/** Bulk output of an int array. */
	public void writeInts (int[] object, boolean optimizePositive) throws KryoException {
		for (int i = 0, n = object.length; i < n; i++)
			writeInt(object[i], optimizePositive);
	}

	/** Bulk output of an long array. */
	public void writeLongs (long[] object, boolean optimizePositive) throws KryoException {
		for (int i = 0, n = object.length; i < n; i++)
			writeLong(object[i], optimizePositive);
	}

	/** Bulk output of an int array. */
	public void writeInts (int[] object) throws KryoException {
		for (int i = 0, n = object.length; i < n; i++)
			writeInt(object[i]);
	}

	/** Bulk output of an long array. */
	public void writeLongs (long[] object) throws KryoException {
		for (int i = 0, n = object.length; i < n; i++)
			writeLong(object[i]);
	}

	/** Bulk output of a float array. */
	public void writeFloats (float[] object) throws KryoException {
		for (int i = 0, n = object.length; i < n; i++)
			writeFloat(object[i]);
	}

	/** Bulk output of a short array. */
	public void writeShorts (short[] object) throws KryoException {
		for (int i = 0, n = object.length; i < n; i++)
			writeShort(object[i]);
	}

	/** Bulk output of a char array. */
	public void writeChars (char[] object) throws KryoException {
		for (int i = 0, n = object.length; i < n; i++)
			writeChar(object[i]);
	}

	/** Bulk output of a double array. */
	public void writeDoubles (double[] object) throws KryoException {
		for (int i = 0, n = object.length; i < n; i++)
			writeDouble(object[i]);
	}
}


package com.esotericsoftware.kryo;

import static com.esotericsoftware.kryo.util.Util.*;
import static com.esotericsoftware.minlog.Log.*;

import com.esotericsoftware.kryo.factories.NullSerializerFactory;
import com.esotericsoftware.kryo.factories.SerializerFactory;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import com.esotericsoftware.kryo.serializers.DefaultSerializers.BooleanSerializer;
import com.esotericsoftware.kryo.serializers.DefaultSerializers.ByteSerializer;
import com.esotericsoftware.kryo.serializers.DefaultSerializers.CharSerializer;
import com.esotericsoftware.kryo.serializers.DefaultSerializers.DoubleSerializer;
import com.esotericsoftware.kryo.serializers.DefaultSerializers.FloatSerializer;
import com.esotericsoftware.kryo.serializers.DefaultSerializers.IntSerializer;
import com.esotericsoftware.kryo.serializers.DefaultSerializers.LongSerializer;
import com.esotericsoftware.kryo.serializers.DefaultSerializers.ShortSerializer;
import com.esotericsoftware.kryo.serializers.DefaultSerializers.StringSerializer;
import com.esotericsoftware.kryo.serializers.DefaultSerializers.VoidSerializer;
import com.esotericsoftware.kryo.util.DefaultClassResolver;
import com.esotericsoftware.kryo.util.IdentityMap;

import java.util.ArrayList;
import java.util.ConcurrentModificationException;
import java.util.EnumSet;

/** Maps classes to serializers so object graphs can be serialized automatically.
 * @author Nathan Sweet <misc@n4te.com> */
public class Kryo {
	static public final byte NULL = 0;

	private SerializerFactory defaultSerializer = new NullSerializerFactory();
	private final ArrayList<DefaultSerializerEntry> defaultSerializers = new ArrayList(32);
	private final int lowPriorityDefaultSerializerCount;

	private final ClassResolver classResolver;
	private int nextRegisterID;
	private boolean registrationRequired = true;

	private int depth, maxDepth = Integer.MAX_VALUE;
	private boolean autoReset = true;
	private volatile Thread thread;
	private boolean copyReferences = true;

	private int copyDepth;
	private IdentityMap originalToCopy;
	private Object needsCopyReference;

	/** Creates a new Kryo with a {@link DefaultClassResolver} */
	public Kryo () {
		this(new DefaultClassResolver());
	}

	public Kryo(ClassResolver classResolver) {
		if (classResolver == null) throw new IllegalArgumentException("classResolver cannot be null.");

		this.classResolver = classResolver;
		classResolver.setKryo(this);

		lowPriorityDefaultSerializerCount = defaultSerializers.size();

		// Primitives and string. Primitive wrappers automatically use the same registration as primitives.
		register(int.class, new IntSerializer());
		register(String.class, new StringSerializer());
		register(float.class, new FloatSerializer());
		register(boolean.class, new BooleanSerializer());
		register(byte.class, new ByteSerializer());
		register(char.class, new CharSerializer());
		register(short.class, new ShortSerializer());
		register(long.class, new LongSerializer());
		register(double.class, new DoubleSerializer());
		register(void.class, new VoidSerializer());
	}

	// --- Default serializers ---
	/** Sets the serializer factory to use when no {@link #addDefaultSerializer(Class, Class) default serializers} match an object's
	 * type. Default is {@link com.esotericsoftware.kryo.factories.NullSerializerFactory}.
	 * @see #newDefaultSerializer(Class) */
	public void setDefaultSerializer (SerializerFactory serializer) {
		if (serializer == null) throw new IllegalArgumentException("serializer cannot be null.");
		defaultSerializer = serializer;
	}

	/** Sets the serializer to use when no {@link #addDefaultSerializer(Class, Class) default serializers} match an object's type.
	 * @see #newDefaultSerializer(Class) */
	public void setDefaultSerializer (Class<? extends Serializer> serializer) {
		if (serializer == null) throw new IllegalArgumentException("serializer cannot be null.");
		defaultSerializer = new NullSerializerFactory();
	}

	public void addDefaultSerializer (Class type, SerializerFactory serializerFactory) {
		if (type == null) throw new IllegalArgumentException("type cannot be null.");
		if (serializerFactory == null) throw new IllegalArgumentException("serializerFactory cannot be null.");
		DefaultSerializerEntry entry = new DefaultSerializerEntry(type, serializerFactory);
		defaultSerializers.add(defaultSerializers.size() - lowPriorityDefaultSerializerCount, entry);
	}

	public void addDefaultSerializer (Class type, Class<? extends Serializer> serializerClass) {
		if (type == null) throw new IllegalArgumentException("type cannot be null.");
		if (serializerClass == null) throw new IllegalArgumentException("serializerClass cannot be null.");
		DefaultSerializerEntry entry = new DefaultSerializerEntry(type, new NullSerializerFactory());
		defaultSerializers.add(defaultSerializers.size() - lowPriorityDefaultSerializerCount, entry);
	}

	/** Returns the best matching serializer for a class. This method can be overridden to implement custom logic to choose a
	 * serializer. */
	public Serializer getDefaultSerializer (Class type) {
		if (type == null) throw new IllegalArgumentException("type cannot be null.");

		for (int i = 0, n = defaultSerializers.size(); i < n; i++) {
			DefaultSerializerEntry entry = defaultSerializers.get(i);
			if (entry.type.isAssignableFrom(type)) {
				Serializer defaultSerializer = entry.serializerFactory.makeSerializer(this, type);
				return defaultSerializer;
			}
		}

		return newDefaultSerializer(type);
	}

	/** Called by {@link #getDefaultSerializer(Class)} when no default serializers matched the type. Subclasses can override this
	 * method to customize behavior. The default implementation calls {@link SerializerFactory#makeSerializer(Kryo, Class)} using
	 * the {@link #setDefaultSerializer(Class) default serializer}. */
	protected Serializer newDefaultSerializer (Class type) {
		return defaultSerializer.makeSerializer(this, type);
	}

	// --- Registration ---

	/** Registers the class using the lowest, next available integer ID and the {@link Kryo#getDefaultSerializer(Class) default
	 * serializer}. If the class is already registered, the existing entry is updated with the new serializer. Registering a
	 * primitive also affects the corresponding primitive wrapper.
	 * <p>
	 * Because the ID assigned is affected by the IDs registered before it, the order classes are registered is important when
	 * using this method. The order must be the same at deserialization as it was for serialization. */
	public Registration register (Class type) {
		Registration registration = classResolver.getRegistration(type);
		if (registration != null) return registration;
		return register(type, getDefaultSerializer(type));
	}

	/** Registers the class using the specified ID and the {@link Kryo#getDefaultSerializer(Class) default serializer}. If the ID is
	 * already in use by the same type, the old entry is overwritten. If the ID is already in use by a different type, a
	 * {@link KryoException} is thrown. Registering a primitive also affects the corresponding primitive wrapper.
	 * <p>
	 * IDs must be the same at deserialization as they were for serialization.
	 * @param id Must be >= 0. Smaller IDs are serialized more efficiently. IDs 0-8 are used by default for primitive types and
	 *           String, but these IDs can be repurposed. */
	public Registration register (Class type, int id) {
		Registration registration = classResolver.getRegistration(type);
		if (registration != null) return registration;
		return register(type, getDefaultSerializer(type), id);
	}

	/** Registers the class using the lowest, next available integer ID and the specified serializer. If the class is already
	 * registered, the existing entry is updated with the new serializer. Registering a primitive also affects the corresponding
	 * primitive wrapper.
	 * <p>
	 * Because the ID assigned is affected by the IDs registered before it, the order classes are registered is important when
	 * using this method. The order must be the same at deserialization as it was for serialization. */
	public Registration register (Class type, Serializer serializer) {
		Registration registration = classResolver.getRegistration(type);
		if (registration != null) {
			registration.setSerializer(serializer);
			return registration;
		}
		return classResolver.register(new Registration(type, serializer, getNextRegistrationId()));
	}

	/** Registers the class using the specified ID and serializer. If the ID is already in use by the same type, the old entry is
	 * overwritten. If the ID is already in use by a different type, a {@link KryoException} is thrown. Registering a primitive
	 * also affects the corresponding primitive wrapper.
	 * <p>
	 * IDs must be the same at deserialization as they were for serialization.
	 * @param id Must be >= 0. Smaller IDs are serialized more efficiently. IDs 0-8 are used by default for primitive types and
	 *           String, but these IDs can be repurposed. */
	public Registration register (Class type, Serializer serializer, int id) {
		if (id < 0) throw new IllegalArgumentException("id must be >= 0: " + id);
		return register(new Registration(type, serializer, id));
	}

	/** Stores the specified registration. If the ID is already in use by the same type, the old entry is overwritten. If the ID is
	 * already in use by a different type, a {@link KryoException} is thrown. Registering a primitive also affects the
	 * corresponding primitive wrapper.
	 * <p>
	 * IDs must be the same at deserialization as they were for serialization.
	 * <p>
	 * Registration can be suclassed to efficiently store per type information, accessible in serializers via
	 * {@link Kryo#getRegistration(Class)}. */
	public Registration register (Registration registration) {
		int id = registration.getId();
		if (id < 0) throw new IllegalArgumentException("id must be > 0: " + id);

		Registration existing = getRegistration(registration.getId());
		if (DEBUG && existing != null && existing.getType() != registration.getType()) {
			debug("An existing registration with a different type already uses ID: " + registration.getId()
				+ "\nExisting registration: " + existing + "\nUnable to set registration: " + registration);
		}

		return classResolver.register(registration);
	}

	/** @return the lowest, next available integer ID. */
	public int getNextRegistrationId () {
		while (nextRegisterID != -2) {
			if (classResolver.getRegistration(nextRegisterID) == null) return nextRegisterID;
			nextRegisterID++;
		}
		throw new KryoException("No registration IDs are available.");
	}

	/**
	 * @throws IllegalArgumentException if the class is not registered.
	 * @see ClassResolver#getRegistration(Class)
	 */
	public Registration getRegistration (Class type) {
		if (type == null) throw new IllegalArgumentException("type cannot be null.");

		Registration registration = classResolver.getRegistration(type);
		if (registration == null) {
			if (!type.isEnum() && Enum.class.isAssignableFrom(type)) {
				// This handles an enum value that is an inner class. Eg: enum A {b{}};
				registration = getRegistration(type.getEnclosingClass());
			} else if (EnumSet.class.isAssignableFrom(type)) {
				registration = classResolver.getRegistration(EnumSet.class);
			}
			if (registration == null) {
				throw new IllegalArgumentException("Class is not registered: " + className(type)
					+ "\nNote: To register this class use: kryo.register(" + className(type) + ".class);");
			}
		}
		return registration;
	}

	/** @see ClassResolver#getRegistration(int) */
	public Registration getRegistration (int classID) {
		return classResolver.getRegistration(classID);
	}

	/** Returns the serializer for the registration for the specified class.
	 * @see #getRegistration(Class)
	 * @see Registration#getSerializer() */
	public Serializer getSerializer (Class type) {
		return getRegistration(type).getSerializer();
	}

	// --- Serialization ---

	/** Writes a class and returns its registration.
	 * @param type May be null.
	 * @return Will be null if type is null.
	 * @see ClassResolver#writeClass(Output, Class) */
	public Registration writeClass (Output output, Class type) {
		if (output == null) throw new IllegalArgumentException("output cannot be null.");
		try {
			return classResolver.writeClass(output, type);
		} finally {
			if (depth == 0 && autoReset) reset();
		}
	}

	/** Writes the class and object or null using the registered serializer.
	 * @param object May be null. */
	public void writeClassAndObject (Output output, Object object) {
		if (output == null) throw new IllegalArgumentException("output cannot be null.");
		beginObject();
		try {
			if (object == null) {
				writeClass(output, null);
				return;
			}
			Registration registration = writeClass(output, object.getClass());
			if (TRACE || (DEBUG && depth == 1)) log("Write", object);
			registration.getSerializer().write(this, output, object);
		} finally {
			if (--depth == 0 && autoReset) reset();
		}
	}

	/** Reads a class and returns its registration.
	 * @return May be null.
	 * @see ClassResolver#readClass(Input) */
	public Registration readClass (Input input) {
		if (input == null) throw new IllegalArgumentException("input cannot be null.");
		try {
			return classResolver.readClass(input);
		} finally {
			if (depth == 0 && autoReset) reset();
		}
	}

	/** Reads an object using the registered serializer. */
	public <T> T readObject (Input input, Class<T> type) {
		if (input == null) throw new IllegalArgumentException("input cannot be null.");
		if (type == null) throw new IllegalArgumentException("type cannot be null.");
		beginObject();
		try {
			T object = (T)getRegistration(type).getSerializer().read(this, input, type);
			if (TRACE || (DEBUG && depth == 1)) log("Read", object);
			return object;
		} finally {
			if (--depth == 0 && autoReset) reset();
		}
	}

	/** Reads an object using the specified serializer. The registered serializer is ignored. */
	public <T> T readObject (Input input, Class<T> type, Serializer serializer) {
		if (input == null) throw new IllegalArgumentException("input cannot be null.");
		if (type == null) throw new IllegalArgumentException("type cannot be null.");
		if (serializer == null) throw new IllegalArgumentException("serializer cannot be null.");
		beginObject();
		try {
			T object = (T)serializer.read(this, input, type);
			if (TRACE || (DEBUG && depth == 1)) log("Read", object);
			return object;
		} finally {
			if (--depth == 0 && autoReset) reset();
		}
	}

	/** Reads the class and object or null using the registered serializer.
	 * @return May be null. */
	public Object readClassAndObject (Input input) {
		if (input == null) throw new IllegalArgumentException("input cannot be null.");
		beginObject();
		try {
			Registration registration = readClass(input);
			if (registration == null) return null;
			Class type = registration.getType();

			Object object = registration.getSerializer().read(this, input, type);
			if (TRACE || (DEBUG && depth == 1)) log("Read", object);
			return object;
		} finally {
			if (--depth == 0 && autoReset) reset();
		}
	}

	/** Called by {@link Serializer#read(Kryo, Input, Class)} and {@link Serializer#copy(Kryo, Object)} before Kryo can be used to
	 * deserialize or copy child objects. Calling this method is unnecessary if Kryo is not used to deserialize or copy child
	 * objects.
	 * @param object May be null, unless calling this method from {@link Serializer#copy(Kryo, Object)}. */
	public void reference (Object object) {
		if (copyDepth > 0) {
			if (needsCopyReference != null) {
				if (object == null) throw new IllegalArgumentException("object cannot be null.");
				originalToCopy.put(needsCopyReference, object);
				needsCopyReference = null;
			}
		}
	}

	public void reset () {
		depth = 0;
		classResolver.reset();

		copyDepth = 0;
		if (originalToCopy != null) originalToCopy.clear(2048);

		if (TRACE) trace("kryo", "Object graph complete.");
	}

	/** Returns a deep copy of the object. Serializers for the classes involved must support {@link Serializer#copy(Kryo, Object)}.
	 * @param object May be null. */
	public <T> T copy (T object) {
		if (object == null) return null;
		copyDepth++;
		try {
			if (originalToCopy == null) originalToCopy = new IdentityMap();
			Object existingCopy = originalToCopy.get(object);
			if (existingCopy != null) return (T)existingCopy;

			if (copyReferences) needsCopyReference = object;
			Object copy = getSerializer(object.getClass()).copy(this, object);
			if (needsCopyReference != null) reference(copy);
			if (TRACE || (DEBUG && copyDepth == 1)) log("Copy", copy);
			return (T)copy;
		} finally {
			if (--copyDepth == 0) reset();
		}
	}

	// --- Utility ---

	private void beginObject () {
		if (DEBUG) {
			if (depth == 0)
				thread = Thread.currentThread();
			else if (thread != Thread.currentThread())
				throw new ConcurrentModificationException("Kryo must not be accessed concurrently by multiple threads.");
		}
		if (depth == maxDepth) throw new KryoException("Max depth exceeded: " + depth);
		depth++;
	}

	public boolean isRegistrationRequired () {
		return registrationRequired;
	}

	/** Returns the number of child objects away from the object graph root. */
	public int getDepth () {
		return depth;
	}

	static final class DefaultSerializerEntry {
		final Class type;
		final SerializerFactory serializerFactory;

		DefaultSerializerEntry (Class type, SerializerFactory serializerFactory) {
			this.type = type;
			this.serializerFactory = serializerFactory;
		}
	}
}


package com.esotericsoftware.kryo;

/** General Kryo RuntimeException.
 * @author Nathan Sweet <misc@n4te.com> */
public class KryoException extends RuntimeException {
	private StringBuffer trace;

	public KryoException (String message, Throwable cause) {
		super(message, cause);
	}

	public KryoException (String message) {
		super(message);
	}

	public KryoException (Throwable cause) {
		super(cause);
	}

	public String getMessage () {
		if (trace == null) return super.getMessage();
		StringBuffer buffer = new StringBuffer(512);
		buffer.append(super.getMessage());
		if (buffer.length() > 0) buffer.append('\n');
		buffer.append("Serialization trace:");
		buffer.append(trace);
		return buffer.toString();
	}

	/** Adds information to the exception message about where in the the object graph serialization failure occurred.
	 * {@link Serializer Serializers} can catch {@link KryoException}, add trace information, and rethrow the exception. */
	public void addTrace (String info) {
		if (info == null) throw new IllegalArgumentException("info cannot be null.");
		if (trace == null) trace = new StringBuffer(512);
		trace.append('\n');
		trace.append(info);
	}
}


package com.esotericsoftware.kryo;

import static com.esotericsoftware.kryo.util.Util.*;
import static com.esotericsoftware.minlog.Log.*;

/** Describes the {@link Serializer} and class ID to use for a class.
 * @author Nathan Sweet <misc@n4te.com> */
public class Registration {
	private final Class type;
	private final int id;
	private Serializer serializer;

	public Registration (Class type, Serializer serializer, int id) {
		if (type == null) throw new IllegalArgumentException("type cannot be null.");
		if (serializer == null) throw new IllegalArgumentException("serializer cannot be null.");
		this.type = type;
		this.serializer = serializer;
		this.id = id;
	}

	public Class getType () {
		return type;
	}

	/** Returns the registered class ID.
	 * @see Kryo#register(Class) */
	public int getId () {
		return id;
	}

	public Serializer getSerializer () {
		return serializer;
	}

	public void setSerializer (Serializer serializer) {
		if (serializer == null) throw new IllegalArgumentException("serializer cannot be null.");
		this.serializer = serializer;
		if (TRACE) trace("kryo", "Update registered serializer: " + type.getName() + " (" + serializer.getClass().getName() + ")");
	}

	public String toString () {
		return "[" + id + ", " + className(type) + "]";
	}
}


package com.esotericsoftware.kryo;

import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;

/** Reads and writes objects to and from bytes.
 * @author Nathan Sweet <misc@n4te.com> */
public abstract class Serializer<T> {
	private boolean immutable;

	public Serializer () {
	}

	/** Writes the bytes for the object to the output.
	 * <p>
	 * This method should not be called directly, instead this serializer can be passed to {@link Kryo} write methods that accept a
	 * serialier.
	 * @param object not null */
	abstract public void write (Kryo kryo, Output output, T object);

	/** Reads bytes and returns a new object of the specified concrete type.
	 * <p>
	 * Before Kryo can be used to read child objects, {@link Kryo#reference(Object)} must be called with the parent object to
	 * ensure it can be referenced by the child objects. Any serializer that uses {@link Kryo} to read a child object may need to
	 * be reentrant.
	 * <p>
	 * This method should not be called directly, instead this serializer can be passed to {@link Kryo} read methods that accept a
	 * serialier.
	 * @return not null */
	abstract public T read (Kryo kryo, Input input, Class<T> type);

	/** If true, this serializer will handle writing and reading null values. If false, the Kryo framework handles null values and
	 * the serializer will never receive null.
	 * <p>
	 * This can be set to true on a serializer that does not accept nulls if it is known that the serializer will never encounter
	 * null. Doing this will prevent the framework from writing a byte to denote null. */
	public void setAcceptsNull (boolean acceptsNull) {
	}

	public boolean isImmutable () {
		return immutable;
	}

	/** If true, the type this serializer will be used for is considered immutable. This causes {@link #copy(Kryo, Object)} to
	 * return the original object. */
	public void setImmutable (boolean immutable) {
		this.immutable = immutable;
	}
	
	/** Sets the generic types of the field or method this serializer will be used for on the next call to read or write. Subsequent
	 * calls to read and write must not use this generic type information. The default implementation does nothing. Subclasses may
	 * use the information provided to this method for more efficient serialization, eg to use the same type for all items in a
	 * list.
	 * @param generics Some (but never all) elements may be null if there is no generic type information at that index. */
	public void setGenerics (Kryo kryo, Class[] generics) {
	}

	/** Returns a copy of the specified object. The default implementation returns the original if {@link #isImmutable()} is true,
	 * else throws {@link KryoException}. Subclasses should override this method if needed to support {@link Kryo#copy(Object)}.
	 * <p>
	 * Before Kryo can be used to copy child objects, {@link Kryo#reference(Object)} must be called with the copy to ensure it can
	 * be referenced by the child objects. Any serializer that uses {@link Kryo} to copy a child object may need to be reentrant.
	 * <p>
	 * This method should not be called directly, instead this serializer can be passed to {@link Kryo} copy methods that accept a
	 * serialier. */
	public T copy (Kryo kryo, T original) {
		if (immutable) return original;
		throw new KryoException("Serializer does not support copy: " + getClass().getName());
	}
}

package com.esotericsoftware.kryo.serializers;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.Serializer;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;

/** Contains many serializer classes that are provided by {@link Kryo#addDefaultSerializer(Class, Class) default}.
 * @author Nathan Sweet <misc@n4te.com> */
public class DefaultSerializers {
	static public class VoidSerializer extends Serializer {
		{
			setImmutable(true);
		}

		public void write (Kryo kryo, Output output, Object object) {
			
		}

		public Object read (Kryo kryo, Input input, Class type) {
			return null;
		}
	}
	static public class BooleanSerializer extends Serializer<Boolean> {
		{
			setImmutable(true);
		}

		public void write (Kryo kryo, Output output, Boolean object) {
			output.writeBoolean(object);
		}

		public Boolean read (Kryo kryo, Input input, Class<Boolean> type) {
			return input.readBoolean();
		}
	}

	static public class ByteSerializer extends Serializer<Byte> {
		{
			setImmutable(true);
		}

		public void write (Kryo kryo, Output output, Byte object) {
			output.writeByte(object);
		}

		public Byte read (Kryo kryo, Input input, Class<Byte> type) {
			return input.readByte();
		}
	}

	static public class CharSerializer extends Serializer<Character> {
		{
			setImmutable(true);
		}

		public void write (Kryo kryo, Output output, Character object) {
			output.writeChar(object);
		}

		public Character read (Kryo kryo, Input input, Class<Character> type) {
			return input.readChar();
		}
	}

	static public class ShortSerializer extends Serializer<Short> {
		{
			setImmutable(true);
		}

		public void write (Kryo kryo, Output output, Short object) {
			output.writeShort(object);
		}

		public Short read (Kryo kryo, Input input, Class<Short> type) {
			return input.readShort();
		}
	}

	static public class IntSerializer extends Serializer<Integer> {
		{
			setImmutable(true);
		}

		public void write (Kryo kryo, Output output, Integer object) {
			output.writeInt(object, false);
		}

		public Integer read (Kryo kryo, Input input, Class<Integer> type) {
			return input.readInt(false);
		}
	}

	static public class LongSerializer extends Serializer<Long> {
		{
			setImmutable(true);
		}

		public void write (Kryo kryo, Output output, Long object) {
			output.writeLong(object, false);
		}

		public Long read (Kryo kryo, Input input, Class<Long> type) {
			return input.readLong(false);
		}
	}

	static public class FloatSerializer extends Serializer<Float> {
		{
			setImmutable(true);
		}

		public void write (Kryo kryo, Output output, Float object) {
			output.writeFloat(object);
		}

		public Float read (Kryo kryo, Input input, Class<Float> type) {
			return input.readFloat();
		}
	}

	static public class DoubleSerializer extends Serializer<Double> {
		{
			setImmutable(true);
		}

		public void write (Kryo kryo, Output output, Double object) {
			output.writeDouble(object);
		}

		public Double read (Kryo kryo, Input input, Class<Double> type) {
			return input.readDouble();
		}
	}

	/** @see Output#writeString(String) */
	static public class StringSerializer extends Serializer<String> {
		{
			setImmutable(true);
		}

		public void write (Kryo kryo, Output output, String object) {
			output.writeString(object);
		}

		public String read (Kryo kryo, Input input, Class<String> type) {
			return input.readString();
		}
	}
}


package com.esotericsoftware.kryo.util;

import static com.esotericsoftware.kryo.util.Util.*;
import static com.esotericsoftware.minlog.Log.*;

import com.esotericsoftware.kryo.ClassResolver;
import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.KryoException;
import com.esotericsoftware.kryo.Registration;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;

/** Resolves classes by ID or by fully qualified class name.
 * @author Nathan Sweet <misc@n4te.com> */
public class DefaultClassResolver implements ClassResolver {

	protected Kryo kryo;

	protected final IntMap<Registration> idToRegistration = new IntMap();
	protected final ObjectMap<Class, Registration> classToRegistration = new ObjectMap();

	protected IdentityObjectIntMap<Class> classToNameId;
	protected IntMap<Class> nameIdToClass;
	protected int nextNameId;

	private int memoizedClassId = -1;
	private Registration memoizedClassIdValue;
	private Class memoizedClass;
	private Registration memoizedClassValue;

	public void setKryo (Kryo kryo) {
		this.kryo = kryo;
	}

	public Registration register (Registration registration) {
		if (registration == null) throw new IllegalArgumentException("registration cannot be null.");
		if (TRACE) {
			trace("kryo", "Register class ID " + registration.getId() + ": " + className(registration.getType()) + " ("
				+ registration.getSerializer().getClass().getName() + ")");
		}
		idToRegistration.put(registration.getId(), registration);
		classToRegistration.put(registration.getType(), registration);
		if (registration.getType().isPrimitive()) classToRegistration.put(getWrapperClass(registration.getType()), registration);
		return registration;
	}

	public Registration getRegistration (Class type) {
		if (type == memoizedClass) return memoizedClassValue;
		Registration registration = classToRegistration.get(type);
		if (registration != null) {
			memoizedClass = type;
			memoizedClassValue = registration;
		}
		return registration;
	}

	public Registration getRegistration (int classID) {
		return idToRegistration.get(classID);
	}

	public Registration writeClass (Output output, Class type) {
		if (type == null) {
			if (TRACE || (DEBUG && kryo.getDepth() == 1)) log("Write", null);
			output.writeVarInt(Kryo.NULL, true);
			return null;
		}
		Registration registration = kryo.getRegistration(type);
		if (TRACE) trace("kryo", "Write class " + registration.getId() + ": " + className(type));
		output.writeVarInt(registration.getId() + 2, true);
		return registration;
	}

	public Registration readClass (Input input) {
		int classID = input.readVarInt(true);
		if (classID == Kryo.NULL)
		{
			if (TRACE || (DEBUG && kryo.getDepth() == 1)) log("Read", null);
			return null;
		}
		if (classID == memoizedClassId) return memoizedClassIdValue;
		Registration registration = idToRegistration.get(classID - 2);
		if (registration == null) throw new KryoException("Encountered unregistered class ID: " + (classID - 2));
		if (TRACE) trace("kryo", "Read class " + (classID - 2) + ": " + className(registration.getType()));
		memoizedClassId = classID;
		memoizedClassIdValue = registration;
		return registration;
	}

	public void reset () {
		if (!kryo.isRegistrationRequired()) {
			if (classToNameId != null) classToNameId.clear();
			if (nameIdToClass != null) nameIdToClass.clear();
			nextNameId = 0;
		}
	}
}

/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.esotericsoftware.kryo.util;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;

/** An unordered map that uses identity comparison for keys. This implementation is a cuckoo hash map using 3 hashes, random
 * walking, and a small stash for problematic keys. Null keys are not allowed. Null values are allowed. No allocation is done
 * except when growing the table size. <br>
 * <br>
 * This map performs very fast get, containsKey, and remove (typically O(1), worst case O(log(n))). Put may be a bit slower,
 * depending on hash collisions. Load factors greater than 0.91 greatly increase the chances the map will have to rehash to the
 * next higher POT size.
 * @author Nathan Sweet */
public class IdentityMap<K, V> {
	private static final int PRIME1 = 0xbe1f14b1;
	private static final int PRIME2 = 0xb4b82e39;
	private static final int PRIME3 = 0xced1c241;

	public int size;

	K[] keyTable;
	V[] valueTable;
	int capacity, stashSize;

	private float loadFactor;
	private int hashShift, mask, threshold;
	private int stashCapacity;
	private int pushIterations;

	private Entries entries;
	private Values values;
	private Keys keys;

	/** Creates a new map with an initial capacity of 32 and a load factor of 0.8. This map will hold 25 items before growing the
	 * backing table. */
	public IdentityMap () {
		this(32, 0.8f);
	}

	/** Creates a new map with a load factor of 0.8. This map will hold initialCapacity * 0.8 items before growing the backing
	 * table. */
	public IdentityMap (int initialCapacity) {
		this(initialCapacity, 0.8f);
	}

	/** Creates a new map with the specified initial capacity and load factor. This map will hold initialCapacity * loadFactor items
	 * before growing the backing table. */
	public IdentityMap (int initialCapacity, float loadFactor) {
		if (initialCapacity < 0) throw new IllegalArgumentException("initialCapacity must be >= 0: " + initialCapacity);
		if (capacity > 1 << 30) throw new IllegalArgumentException("initialCapacity is too large: " + initialCapacity);
		capacity = ObjectMap.nextPowerOfTwo(initialCapacity);

		if (loadFactor <= 0) throw new IllegalArgumentException("loadFactor must be > 0: " + loadFactor);
		this.loadFactor = loadFactor;

		threshold = (int)(capacity * loadFactor);
		mask = capacity - 1;
		hashShift = 31 - Integer.numberOfTrailingZeros(capacity);
		stashCapacity = Math.max(3, (int)Math.ceil(Math.log(capacity)) * 2);
		pushIterations = Math.max(Math.min(capacity, 8), (int)Math.sqrt(capacity) / 8);

		keyTable = (K[])new Object[capacity + stashCapacity];
		valueTable = (V[])new Object[keyTable.length];
	}

	public V put (K key, V value) {
		if (key == null) throw new IllegalArgumentException("key cannot be null.");
		K[] keyTable = this.keyTable;

		// Check for existing keys.
		int hashCode = System.identityHashCode(key);
		int index1 = hashCode & mask;
		K key1 = keyTable[index1];
		if (key1 == key) {
			V oldValue = valueTable[index1];
			valueTable[index1] = value;
			return oldValue;
		}

		int index2 = hash2(hashCode);
		K key2 = keyTable[index2];
		if (key2 == key) {
			V oldValue = valueTable[index2];
			valueTable[index2] = value;
			return oldValue;
		}

		int index3 = hash3(hashCode);
		K key3 = keyTable[index3];
		if (key3 == key) {
			V oldValue = valueTable[index3];
			valueTable[index3] = value;
			return oldValue;
		}

		// Update key in the stash.
		for (int i = capacity, n = i + stashSize; i < n; i++) {
			if (keyTable[i] == key) {
				V oldValue = valueTable[i];
				valueTable[i] = value;
				return oldValue;
			}
		}

		// Check for empty buckets.
		if (key1 == null) {
			keyTable[index1] = key;
			valueTable[index1] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return null;
		}

		if (key2 == null) {
			keyTable[index2] = key;
			valueTable[index2] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return null;
		}

		if (key3 == null) {
			keyTable[index3] = key;
			valueTable[index3] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return null;
		}

		push(key, value, index1, key1, index2, key2, index3, key3);
		return null;
	}

	/** Skips checks for existing keys. */
	private void putResize (K key, V value) {
		// Check for empty buckets.
		int hashCode = System.identityHashCode(key);
		int index1 = hashCode & mask;
		K key1 = keyTable[index1];
		if (key1 == null) {
			keyTable[index1] = key;
			valueTable[index1] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		int index2 = hash2(hashCode);
		K key2 = keyTable[index2];
		if (key2 == null) {
			keyTable[index2] = key;
			valueTable[index2] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		int index3 = hash3(hashCode);
		K key3 = keyTable[index3];
		if (key3 == null) {
			keyTable[index3] = key;
			valueTable[index3] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		push(key, value, index1, key1, index2, key2, index3, key3);
	}

	private void push (K insertKey, V insertValue, int index1, K key1, int index2, K key2, int index3, K key3) {
		K[] keyTable = this.keyTable;
		V[] valueTable = this.valueTable;
		int mask = this.mask;

		// Push keys until an empty bucket is found.
		K evictedKey;
		V evictedValue;
		int i = 0, pushIterations = this.pushIterations;
		do {
			// Replace the key and value for one of the hashes.
			switch (ObjectMap.random.nextInt(3)) {
			case 0:
				evictedKey = key1;
				evictedValue = valueTable[index1];
				keyTable[index1] = insertKey;
				valueTable[index1] = insertValue;
				break;
			case 1:
				evictedKey = key2;
				evictedValue = valueTable[index2];
				keyTable[index2] = insertKey;
				valueTable[index2] = insertValue;
				break;
			default:
				evictedKey = key3;
				evictedValue = valueTable[index3];
				keyTable[index3] = insertKey;
				valueTable[index3] = insertValue;
				break;
			}

			// If the evicted key hashes to an empty bucket, put it there and stop.
			int hashCode = System.identityHashCode(evictedKey);
			index1 = hashCode & mask;
			key1 = keyTable[index1];
			if (key1 == null) {
				keyTable[index1] = evictedKey;
				valueTable[index1] = evictedValue;
				if (size++ >= threshold) resize(capacity << 1);
				return;
			}

			index2 = hash2(hashCode);
			key2 = keyTable[index2];
			if (key2 == null) {
				keyTable[index2] = evictedKey;
				valueTable[index2] = evictedValue;
				if (size++ >= threshold) resize(capacity << 1);
				return;
			}

			index3 = hash3(hashCode);
			key3 = keyTable[index3];
			if (key3 == null) {
				keyTable[index3] = evictedKey;
				valueTable[index3] = evictedValue;
				if (size++ >= threshold) resize(capacity << 1);
				return;
			}

			if (++i == pushIterations) break;

			insertKey = evictedKey;
			insertValue = evictedValue;
		} while (true);

		putStash(evictedKey, evictedValue);
	}

	private void putStash (K key, V value) {
		if (stashSize == stashCapacity) {
			// Too many pushes occurred and the stash is full, increase the table size.
			resize(capacity << 1);
			put(key, value);
			return;
		}
		// Store key in the stash.
		int index = capacity + stashSize;
		keyTable[index] = key;
		valueTable[index] = value;
		stashSize++;
		size++;
	}

	public V get (K key) {
		int hashCode = System.identityHashCode(key);
		int index = hashCode & mask;
		if (key != keyTable[index]) {
			index = hash2(hashCode);
			if (key != keyTable[index]) {
				index = hash3(hashCode);
				if (key != keyTable[index]) return getStash(key, null);
			}
		}
		return valueTable[index];
	}

	public V get (K key, V defaultValue) {
		int hashCode = System.identityHashCode(key);
		int index = hashCode & mask;
		if (key != keyTable[index]) {
			index = hash2(hashCode);
			if (key != keyTable[index]) {
				index = hash3(hashCode);
				if (key != keyTable[index]) return getStash(key, defaultValue);
			}
		}
		return valueTable[index];
	}

	private V getStash (K key, V defaultValue) {
		K[] keyTable = this.keyTable;
		for (int i = capacity, n = i + stashSize; i < n; i++)
			if (keyTable[i] == key) return valueTable[i];
		return defaultValue;
	}

	public V remove (K key) {
		int hashCode = System.identityHashCode(key);
		int index = hashCode & mask;
		if (keyTable[index] == key) {
			keyTable[index] = null;
			V oldValue = valueTable[index];
			valueTable[index] = null;
			size--;
			return oldValue;
		}

		index = hash2(hashCode);
		if (keyTable[index] == key) {
			keyTable[index] = null;
			V oldValue = valueTable[index];
			valueTable[index] = null;
			size--;
			return oldValue;
		}

		index = hash3(hashCode);
		if (keyTable[index] == key) {
			keyTable[index] = null;
			V oldValue = valueTable[index];
			valueTable[index] = null;
			size--;
			return oldValue;
		}

		return removeStash(key);
	}

	V removeStash (K key) {
		K[] keyTable = this.keyTable;
		for (int i = capacity, n = i + stashSize; i < n; i++) {
			if (keyTable[i] == key) {
				V oldValue = valueTable[i];
				removeStashIndex(i);
				size--;
				return oldValue;
			}
		}
		return null;
	}

	void removeStashIndex (int index) {
		// If the removed location was not last, move the last tuple to the removed location.
		stashSize--;
		int lastIndex = capacity + stashSize;
		if (index < lastIndex) {
			keyTable[index] = keyTable[lastIndex];
			valueTable[index] = valueTable[lastIndex];
			valueTable[lastIndex] = null;
		} else
			valueTable[index] = null;
	}

	/** Reduces the size of the backing arrays to be the specified capacity or less. If the capacity is already less, nothing is
	 * done. If the map contains more items than the specified capacity, nothing is done. */
	public void shrink (int maximumCapacity) {
		if (maximumCapacity < 0) throw new IllegalArgumentException("maximumCapacity must be >= 0: " + maximumCapacity);
		if (size > maximumCapacity) maximumCapacity = size;
		if (capacity <= maximumCapacity) return;
		maximumCapacity = ObjectMap.nextPowerOfTwo(maximumCapacity);
		resize(maximumCapacity);
	}

	/** Clears the map and reduces the size of the backing arrays to be the specified capacity if they are larger. */
	public void clear (int maximumCapacity) {
		if (capacity <= maximumCapacity) {
			clear();
			return;
		}
		size = 0;
		resize(maximumCapacity);
	}

	public void clear () {
		K[] keyTable = this.keyTable;
		V[] valueTable = this.valueTable;
		for (int i = capacity + stashSize; i-- > 0;) {
			keyTable[i] = null;
			valueTable[i] = null;
		}
		size = 0;
		stashSize = 0;
	}

	/** Returns true if the specified value is in the map. Note this traverses the entire map and compares every value, which may be
	 * an expensive operation.
	 * @param identity If true, uses == to compare the specified value with values in the map. If false, uses
	 *           {@link #equals(Object)}. */
	public boolean containsValue (Object value, boolean identity) {
		V[] valueTable = this.valueTable;
		if (value == null) {
			K[] keyTable = this.keyTable;
			for (int i = capacity + stashSize; i-- > 0;)
				if (keyTable[i] != null && valueTable[i] == null) return true;
		} else if (identity) {
			for (int i = capacity + stashSize; i-- > 0;)
				if (valueTable[i] == value) return true;
		} else {
			for (int i = capacity + stashSize; i-- > 0;)
				if (value.equals(valueTable[i])) return true;
		}
		return false;
	}

	public boolean containsKey (K key) {
		int hashCode = System.identityHashCode(key);
		int index = hashCode & mask;
		if (key != keyTable[index]) {
			index = hash2(hashCode);
			if (key != keyTable[index]) {
				index = hash3(hashCode);
				if (key != keyTable[index]) return containsKeyStash(key);
			}
		}
		return true;
	}

	private boolean containsKeyStash (K key) {
		K[] keyTable = this.keyTable;
		for (int i = capacity, n = i + stashSize; i < n; i++)
			if (keyTable[i] == key) return true;
		return false;
	}

	/** Returns the key for the specified value, or null if it is not in the map. Note this traverses the entire map and compares
	 * every value, which may be an expensive operation.
	 * @param identity If true, uses == to compare the specified value with values in the map. If false, uses
	 *           {@link #equals(Object)}. */
	public K findKey (Object value, boolean identity) {
		V[] valueTable = this.valueTable;
		if (value == null) {
			K[] keyTable = this.keyTable;
			for (int i = capacity + stashSize; i-- > 0;)
				if (keyTable[i] != null && valueTable[i] == null) return keyTable[i];
		} else if (identity) {
			for (int i = capacity + stashSize; i-- > 0;)
				if (valueTable[i] == value) return keyTable[i];
		} else {
			for (int i = capacity + stashSize; i-- > 0;)
				if (value.equals(valueTable[i])) return keyTable[i];
		}
		return null;
	}

	/** Increases the size of the backing array to acommodate the specified number of additional items. Useful before adding many
	 * items to avoid multiple backing array resizes. */
	public void ensureCapacity (int additionalCapacity) {
		int sizeNeeded = size + additionalCapacity;
		if (sizeNeeded >= threshold) resize(ObjectMap.nextPowerOfTwo((int)(sizeNeeded / loadFactor)));
	}

	private void resize (int newSize) {
		int oldEndIndex = capacity + stashSize;

		capacity = newSize;
		threshold = (int)(newSize * loadFactor);
		mask = newSize - 1;
		hashShift = 31 - Integer.numberOfTrailingZeros(newSize);
		stashCapacity = Math.max(3, (int)Math.ceil(Math.log(newSize)) * 2);
		pushIterations = Math.max(Math.min(newSize, 8), (int)Math.sqrt(newSize) / 8);

		K[] oldKeyTable = keyTable;
		V[] oldValueTable = valueTable;

		keyTable = (K[])new Object[newSize + stashCapacity];
		valueTable = (V[])new Object[newSize + stashCapacity];

		int oldSize = size;
		size = 0;
		stashSize = 0;
		if (oldSize > 0) {
			for (int i = 0; i < oldEndIndex; i++) {
				K key = oldKeyTable[i];
				if (key != null) putResize(key, oldValueTable[i]);
			}
		}
	}

	private int hash2 (int h) {
		h *= PRIME2;
		return (h ^ h >>> hashShift) & mask;
	}

	private int hash3 (int h) {
		h *= PRIME3;
		return (h ^ h >>> hashShift) & mask;
	}

	public String toString () {
		if (size == 0) return "[]";
		StringBuilder buffer = new StringBuilder(32);
		buffer.append('[');
		K[] keyTable = this.keyTable;
		V[] valueTable = this.valueTable;
		int i = keyTable.length;
		while (i-- > 0) {
			K key = keyTable[i];
			if (key == null) continue;
			buffer.append(key);
			buffer.append('=');
			buffer.append(valueTable[i]);
			break;
		}
		while (i-- > 0) {
			K key = keyTable[i];
			if (key == null) continue;
			buffer.append(", ");
			buffer.append(key);
			buffer.append('=');
			buffer.append(valueTable[i]);
		}
		buffer.append(']');
		return buffer.toString();
	}

	/** Returns an iterator for the entries in the map. Remove is supported. Note that the same iterator instance is returned each
	 * time this method is called. Use the {@link Entries} constructor for nested or multithreaded iteration. */
	public Entries<K, V> entries () {
		if (entries == null)
			entries = new Entries(this);
		else
			entries.reset();
		return entries;
	}

	/** Returns an iterator for the values in the map. Remove is supported. Note that the same iterator instance is returned each
	 * time this method is called. Use the {@link Entries} constructor for nested or multithreaded iteration. */
	public Values<V> values () {
		if (values == null)
			values = new Values(this);
		else
			values.reset();
		return values;
	}

	/** Returns an iterator for the keys in the map. Remove is supported. Note that the same iterator instance is returned each time
	 * this method is called. Use the {@link Entries} constructor for nested or multithreaded iteration. */
	public Keys<K> keys () {
		if (keys == null)
			keys = new Keys(this);
		else
			keys.reset();
		return keys;
	}

	static public class Entry<K, V> {
		public K key;
		public V value;

		public String toString () {
			return key + "=" + value;
		}
	}

	static private class MapIterator<K, V> {
		public boolean hasNext;

		final IdentityMap<K, V> map;
		int nextIndex, currentIndex;

		public MapIterator (IdentityMap<K, V> map) {
			this.map = map;
			reset();
		}

		public void reset () {
			currentIndex = -1;
			nextIndex = -1;
			findNextIndex();
		}

		void findNextIndex () {
			hasNext = false;
			K[] keyTable = map.keyTable;
			for (int n = map.capacity + map.stashSize; ++nextIndex < n;) {
				if (keyTable[nextIndex] != null) {
					hasNext = true;
					break;
				}
			}
		}

		public void remove () {
			if (currentIndex < 0) throw new IllegalStateException("next must be called before remove.");
			if (currentIndex >= map.capacity) {
				map.removeStashIndex(currentIndex);
				nextIndex = currentIndex - 1;
				findNextIndex();
			} else {
				map.keyTable[currentIndex] = null;
				map.valueTable[currentIndex] = null;
			}
			currentIndex = -1;
			map.size--;
		}
	}

	static public class Entries<K, V> extends MapIterator<K, V> implements Iterable<Entry<K, V>>, Iterator<Entry<K, V>> {
		private Entry<K, V> entry = new Entry();

		public Entries (IdentityMap<K, V> map) {
			super(map);
		}

		/** Note the same entry instance is returned each time this method is called. */
		public Entry<K, V> next () {
			if (!hasNext) throw new NoSuchElementException();
			K[] keyTable = map.keyTable;
			entry.key = keyTable[nextIndex];
			entry.value = map.valueTable[nextIndex];
			currentIndex = nextIndex;
			findNextIndex();
			return entry;
		}

		public boolean hasNext () {
			return hasNext;
		}

		public Iterator<Entry<K, V>> iterator () {
			return this;
		}
	}

	static public class Values<V> extends MapIterator<Object, V> implements Iterable<V>, Iterator<V> {
		public Values (IdentityMap<?, V> map) {
			super((IdentityMap<Object, V>)map);
		}

		public boolean hasNext () {
			return hasNext;
		}

		public V next () {
			V value = map.valueTable[nextIndex];
			currentIndex = nextIndex;
			findNextIndex();
			return value;
		}

		public Iterator<V> iterator () {
			return this;
		}

		/** Returns a new array containing the remaining values. */
		public ArrayList<V> toArray () {
			ArrayList array = new ArrayList(map.size);
			while (hasNext)
				array.add(next());
			return array;
		}

		/** Returns a new array containing the remaining values. */
		public void toArray (ArrayList<V> array) {
			while (hasNext)
				array.add(next());
		}
	}

	static public class Keys<K> extends MapIterator<K, Object> implements Iterable<K>, Iterator<K> {
		public Keys (IdentityMap<K, ?> map) {
			super((IdentityMap<K, Object>)map);
		}

		public boolean hasNext () {
			return hasNext;
		}

		public K next () {
			K key = map.keyTable[nextIndex];
			currentIndex = nextIndex;
			findNextIndex();
			return key;
		}

		public Iterator<K> iterator () {
			return this;
		}

		/** Returns a new array containing the remaining keys. */
		public ArrayList<K> toArray () {
			ArrayList array = new ArrayList(map.size);
			while (hasNext)
				array.add(next());
			return array;
		}
	}
}


package com.esotericsoftware.kryo.util;

/** An unordered map where identity comparison is used for keys and the values are ints. This implementation is a cuckoo hash map
 * using 3 hashes, random walking, and a small stash for problematic keys. Null keys are not allowed. No allocation is done except
 * when growing the table size. <br>
 * <br>
 * This map performs very fast get, containsKey, and remove (typically O(1), worst case O(log(n))). Put may be a bit slower,
 * depending on hash collisions. Load factors greater than 0.91 greatly increase the chances the map will have to rehash to the
 * next higher POT size.
 * @author Nathan Sweet */
public class IdentityObjectIntMap<K> {
	private static final int PRIME1 = 0xbe1f14b1;
	private static final int PRIME2 = 0xb4b82e39;
	private static final int PRIME3 = 0xced1c241;

	public int size;

	K[] keyTable;
	int[] valueTable;
	int capacity, stashSize;

	private float loadFactor;
	private int hashShift, mask, threshold;
	private int stashCapacity;
	private int pushIterations;

	/** Creates a new map with an initial capacity of 32 and a load factor of 0.8. This map will hold 25 items before growing the
	 * backing table. */
	public IdentityObjectIntMap () {
		this(32, 0.8f);
	}

	/** Creates a new map with a load factor of 0.8. This map will hold initialCapacity * 0.8 items before growing the backing
	 * table. */
	public IdentityObjectIntMap (int initialCapacity) {
		this(initialCapacity, 0.8f);
	}

	/** Creates a new map with the specified initial capacity and load factor. This map will hold initialCapacity * loadFactor items
	 * before growing the backing table. */
	public IdentityObjectIntMap (int initialCapacity, float loadFactor) {
		if (initialCapacity < 0) throw new IllegalArgumentException("initialCapacity must be >= 0: " + initialCapacity);
		if (capacity > 1 << 30) throw new IllegalArgumentException("initialCapacity is too large: " + initialCapacity);
		capacity = ObjectMap.nextPowerOfTwo(initialCapacity);

		if (loadFactor <= 0) throw new IllegalArgumentException("loadFactor must be > 0: " + loadFactor);
		this.loadFactor = loadFactor;

		threshold = (int)(capacity * loadFactor);
		mask = capacity - 1;
		hashShift = 31 - Integer.numberOfTrailingZeros(capacity);
		stashCapacity = Math.max(3, (int)Math.ceil(Math.log(capacity)) * 2);
		pushIterations = Math.max(Math.min(capacity, 8), (int)Math.sqrt(capacity) / 8);

		keyTable = (K[])new Object[capacity + stashCapacity];
		valueTable = new int[keyTable.length];
	}

	public void put (K key, int value) {
		if (key == null) throw new IllegalArgumentException("key cannot be null.");
		K[] keyTable = this.keyTable;

		// Check for existing keys.
		int hashCode = System.identityHashCode(key);
		int index1 = hashCode & mask;
		K key1 = keyTable[index1];
		if (key == key1) {
			valueTable[index1] = value;
			return;
		}

		int index2 = hash2(hashCode);
		K key2 = keyTable[index2];
		if (key == key2) {
			valueTable[index2] = value;
			return;
		}

		int index3 = hash3(hashCode);
		K key3 = keyTable[index3];
		if (key == key3) {
			valueTable[index3] = value;
			return;
		}

		// Update key in the stash.
		for (int i = capacity, n = i + stashSize; i < n; i++) {
			if (keyTable[i] == key) {
				valueTable[i] = value;
				return;
			}
		}

		// Check for empty buckets.
		if (key1 == null) {
			keyTable[index1] = key;
			valueTable[index1] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		if (key2 == null) {
			keyTable[index2] = key;
			valueTable[index2] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		if (key3 == null) {
			keyTable[index3] = key;
			valueTable[index3] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		push(key, value, index1, key1, index2, key2, index3, key3);
	}

	/** Skips checks for existing keys. */
	private void putResize (K key, int value) {
		// Check for empty buckets.
		int hashCode = System.identityHashCode(key);
		int index1 = hashCode & mask;
		K key1 = keyTable[index1];
		if (key1 == null) {
			keyTable[index1] = key;
			valueTable[index1] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		int index2 = hash2(hashCode);
		K key2 = keyTable[index2];
		if (key2 == null) {
			keyTable[index2] = key;
			valueTable[index2] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		int index3 = hash3(hashCode);
		K key3 = keyTable[index3];
		if (key3 == null) {
			keyTable[index3] = key;
			valueTable[index3] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		push(key, value, index1, key1, index2, key2, index3, key3);
	}

	private void push (K insertKey, int insertValue, int index1, K key1, int index2, K key2, int index3, K key3) {
		K[] keyTable = this.keyTable;
		int[] valueTable = this.valueTable;
		int mask = this.mask;

		// Push keys until an empty bucket is found.
		K evictedKey;
		int evictedValue;
		int i = 0, pushIterations = this.pushIterations;
		do {
			// Replace the key and value for one of the hashes.
			switch (ObjectMap.random.nextInt(3)) {
			case 0:
				evictedKey = key1;
				evictedValue = valueTable[index1];
				keyTable[index1] = insertKey;
				valueTable[index1] = insertValue;
				break;
			case 1:
				evictedKey = key2;
				evictedValue = valueTable[index2];
				keyTable[index2] = insertKey;
				valueTable[index2] = insertValue;
				break;
			default:
				evictedKey = key3;
				evictedValue = valueTable[index3];
				keyTable[index3] = insertKey;
				valueTable[index3] = insertValue;
				break;
			}

			// If the evicted key hashes to an empty bucket, put it there and stop.
			int hashCode = System.identityHashCode(evictedKey);
			index1 = hashCode & mask;
			key1 = keyTable[index1];
			if (key1 == null) {
				keyTable[index1] = evictedKey;
				valueTable[index1] = evictedValue;
				if (size++ >= threshold) resize(capacity << 1);
				return;
			}

			index2 = hash2(hashCode);
			key2 = keyTable[index2];
			if (key2 == null) {
				keyTable[index2] = evictedKey;
				valueTable[index2] = evictedValue;
				if (size++ >= threshold) resize(capacity << 1);
				return;
			}

			index3 = hash3(hashCode);
			key3 = keyTable[index3];
			if (key3 == null) {
				keyTable[index3] = evictedKey;
				valueTable[index3] = evictedValue;
				if (size++ >= threshold) resize(capacity << 1);
				return;
			}

			if (++i == pushIterations) break;

			insertKey = evictedKey;
			insertValue = evictedValue;
		} while (true);

		putStash(evictedKey, evictedValue);
	}

	private void putStash (K key, int value) {
		if (stashSize == stashCapacity) {
			// Too many pushes occurred and the stash is full, increase the table size.
			resize(capacity << 1);
			put(key, value);
			return;
		}
		// Store key in the stash.
		int index = capacity + stashSize;
		keyTable[index] = key;
		valueTable[index] = value;
		stashSize++;
		size++;
	}

	/** @param defaultValue Returned if the key was not associated with a value. */
	public int get (K key, int defaultValue) {
		int hashCode = System.identityHashCode(key);
		int index = hashCode & mask;
		if (key != keyTable[index]) {
			index = hash2(hashCode);
			if (key != keyTable[index]) {
				index = hash3(hashCode);
				if (key != keyTable[index]) return getStash(key, defaultValue);
			}
		}
		return valueTable[index];
	}

	private int getStash (K key, int defaultValue) {
		K[] keyTable = this.keyTable;
		for (int i = capacity, n = i + stashSize; i < n; i++)
			if (key == keyTable[i]) return valueTable[i];
		return defaultValue;
	}

	/** Returns the key's current value and increments the stored value. If the key is not in the map, defaultValue + increment is
	 * put into the map. */
	public int getAndIncrement (K key, int defaultValue, int increment) {
		int hashCode = System.identityHashCode(key);
		int index = hashCode & mask;
		if (key != keyTable[index]) {
			index = hash2(hashCode);
			if (key != keyTable[index]) {
				index = hash3(hashCode);
				if (key != keyTable[index]) return getAndIncrementStash(key, defaultValue, increment);
			}
		}
		int value = valueTable[index];
		valueTable[index] = value + increment;
		return value;
	}

	private int getAndIncrementStash (K key, int defaultValue, int increment) {
		K[] keyTable = this.keyTable;
		for (int i = capacity, n = i + stashSize; i < n; i++)
			if (key == keyTable[i]) {
				int value = valueTable[i];
				valueTable[i] = value + increment;
				return value;
			}
		put(key, defaultValue + increment);
		return defaultValue;
	}

	public int remove (K key, int defaultValue) {
		int hashCode = System.identityHashCode(key);
		int index = hashCode & mask;
		if (key == keyTable[index]) {
			keyTable[index] = null;
			int oldValue = valueTable[index];
			size--;
			return oldValue;
		}

		index = hash2(hashCode);
		if (key == keyTable[index]) {
			keyTable[index] = null;
			int oldValue = valueTable[index];
			size--;
			return oldValue;
		}

		index = hash3(hashCode);
		if (key == keyTable[index]) {
			keyTable[index] = null;
			int oldValue = valueTable[index];
			size--;
			return oldValue;
		}

		return removeStash(key, defaultValue);
	}

	int removeStash (K key, int defaultValue) {
		K[] keyTable = this.keyTable;
		for (int i = capacity, n = i + stashSize; i < n; i++) {
			if (key == keyTable[i]) {
				int oldValue = valueTable[i];
				removeStashIndex(i);
				size--;
				return oldValue;
			}
		}
		return defaultValue;
	}

	void removeStashIndex (int index) {
		// If the removed location was not last, move the last tuple to the removed location.
		stashSize--;
		int lastIndex = capacity + stashSize;
		if (index < lastIndex) {
			keyTable[index] = keyTable[lastIndex];
			valueTable[index] = valueTable[lastIndex];
		}
	}

	/** Reduces the size of the backing arrays to be the specified capacity or less. If the capacity is already less, nothing is
	 * done. If the map contains more items than the specified capacity, nothing is done. */
	public void shrink (int maximumCapacity) {
		if (maximumCapacity < 0) throw new IllegalArgumentException("maximumCapacity must be >= 0: " + maximumCapacity);
		if (size > maximumCapacity) maximumCapacity = size;
		if (capacity <= maximumCapacity) return;
		maximumCapacity = ObjectMap.nextPowerOfTwo(maximumCapacity);
		resize(maximumCapacity);
	}

	/** Clears the map and reduces the size of the backing arrays to be the specified capacity if they are larger. */
	public void clear (int maximumCapacity) {
		if (capacity <= maximumCapacity) {
			clear();
			return;
		}
		size = 0;
		resize(maximumCapacity);
	}

	public void clear () {
		K[] keyTable = this.keyTable;
		for (int i = capacity + stashSize; i-- > 0;)
			keyTable[i] = null;
		size = 0;
		stashSize = 0;
	}

	/** Returns true if the specified value is in the map. Note this traverses the entire map and compares every value, which may be
	 * an expensive operation. */
	public boolean containsValue (int value) {
		int[] valueTable = this.valueTable;
		for (int i = capacity + stashSize; i-- > 0;)
			if (valueTable[i] == value) return true;
		return false;
	}

	public boolean containsKey (K key) {
		int hashCode = System.identityHashCode(key);
		int index = hashCode & mask;
		if (key != keyTable[index]) {
			index = hash2(hashCode);
			if (key != keyTable[index]) {
				index = hash3(hashCode);
				if (key != keyTable[index]) return containsKeyStash(key);
			}
		}
		return true;
	}

	private boolean containsKeyStash (K key) {
		K[] keyTable = this.keyTable;
		for (int i = capacity, n = i + stashSize; i < n; i++)
			if (key == keyTable[i]) return true;
		return false;
	}

	/** Returns the key for the specified value, or null if it is not in the map. Note this traverses the entire map and compares
	 * every value, which may be an expensive operation. */
	public K findKey (int value) {
		int[] valueTable = this.valueTable;
		for (int i = capacity + stashSize; i-- > 0;)
			if (valueTable[i] == value) return keyTable[i];
		return null;
	}

	/** Increases the size of the backing array to acommodate the specified number of additional items. Useful before adding many
	 * items to avoid multiple backing array resizes. */
	public void ensureCapacity (int additionalCapacity) {
		int sizeNeeded = size + additionalCapacity;
		if (sizeNeeded >= threshold) resize(ObjectMap.nextPowerOfTwo((int)(sizeNeeded / loadFactor)));
	}

	private void resize (int newSize) {
		int oldEndIndex = capacity + stashSize;

		capacity = newSize;
		threshold = (int)(newSize * loadFactor);
		mask = newSize - 1;
		hashShift = 31 - Integer.numberOfTrailingZeros(newSize);
		stashCapacity = Math.max(3, (int)Math.ceil(Math.log(newSize)) * 2);
		pushIterations = Math.max(Math.min(newSize, 8), (int)Math.sqrt(newSize) / 8);

		K[] oldKeyTable = keyTable;
		int[] oldValueTable = valueTable;

		keyTable = (K[])new Object[newSize + stashCapacity];
		valueTable = new int[newSize + stashCapacity];

		int oldSize = size;
		size = 0;
		stashSize = 0;
		if (oldSize > 0) {
			for (int i = 0; i < oldEndIndex; i++) {
				K key = oldKeyTable[i];
				if (key != null) putResize(key, oldValueTable[i]);
			}
		}
	}

	private int hash2 (int h) {
		h *= PRIME2;
		return (h ^ h >>> hashShift) & mask;
	}

	private int hash3 (int h) {
		h *= PRIME3;
		return (h ^ h >>> hashShift) & mask;
	}

	public String toString () {
		if (size == 0) return "{}";
		StringBuilder buffer = new StringBuilder(32);
		buffer.append('{');
		K[] keyTable = this.keyTable;
		int[] valueTable = this.valueTable;
		int i = keyTable.length;
		while (i-- > 0) {
			K key = keyTable[i];
			if (key == null) continue;
			buffer.append(key);
			buffer.append('=');
			buffer.append(valueTable[i]);
			break;
		}
		while (i-- > 0) {
			K key = keyTable[i];
			if (key == null) continue;
			buffer.append(", ");
			buffer.append(key);
			buffer.append('=');
			buffer.append(valueTable[i]);
		}
		buffer.append('}');
		return buffer.toString();
	}
}


package com.esotericsoftware.kryo.util;

import java.util.Arrays;

/** A resizable, ordered or unordered int array. Avoids the boxing that occurs with ArrayList<Integer>. If unordered, this class
 * avoids a memory copy when removing elements (the last element is moved to the removed element's position).
 * @author Nathan Sweet */
public class IntArray {
	public int[] items;
	public int size;
	public boolean ordered;

	/** Creates an ordered array with a capacity of 16. */
	public IntArray () {
		this(true, 16);
	}

	/** Creates an ordered array with the specified capacity. */
	public IntArray (int capacity) {
		this(true, capacity);
	}

	/** @param ordered If false, methods that remove elements may change the order of other elements in the array, which avoids a
	 *           memory copy.
	 * @param capacity Any elements added beyond this will cause the backing array to be grown. */
	public IntArray (boolean ordered, int capacity) {
		this.ordered = ordered;
		items = new int[capacity];
	}

	/** Creates a new array containing the elements in the specific array. The new array will be ordered if the specific array is
	 * ordered. The capacity is set to the number of elements, so any subsequent elements added will cause the backing array to be
	 * grown. */
	public IntArray (IntArray array) {
		this.ordered = array.ordered;
		size = array.size;
		items = new int[size];
		System.arraycopy(array.items, 0, items, 0, size);
	}

	/** Creates a new ordered array containing the elements in the specified array. The capacity is set to the number of elements,
	 * so any subsequent elements added will cause the backing array to be grown. */
	public IntArray (int[] array) {
		this(true, array);
	}

	/** Creates a new array containing the elements in the specified array. The capacity is set to the number of elements, so any
	 * subsequent elements added will cause the backing array to be grown.
	 * @param ordered If false, methods that remove elements may change the order of other elements in the array, which avoids a
	 *           memory copy. */
	public IntArray (boolean ordered, int[] array) {
		this(ordered, array.length);
		size = array.length;
		System.arraycopy(array, 0, items, 0, size);
	}

	public void add (int value) {
		int[] items = this.items;
		if (size == items.length) items = resize(Math.max(8, (int)(size * 1.75f)));
		items[size++] = value;
	}

	public void addAll (IntArray array) {
		addAll(array, 0, array.size);
	}

	public void addAll (IntArray array, int offset, int length) {
		if (offset + length > array.size)
			throw new IllegalArgumentException("offset + length must be <= size: " + offset + " + " + length + " <= " + array.size);
		addAll(array.items, offset, length);
	}

	public void addAll (int[] array) {
		addAll(array, 0, array.length);
	}

	public void addAll (int[] array, int offset, int length) {
		int[] items = this.items;
		int sizeNeeded = size + length - offset;
		if (sizeNeeded >= items.length) items = resize(Math.max(8, (int)(sizeNeeded * 1.75f)));
		System.arraycopy(array, offset, items, size, length);
		size += length;
	}

	public int get (int index) {
		if (index >= size) throw new IndexOutOfBoundsException(String.valueOf(index));
		return items[index];
	}

	public void set (int index, int value) {
		if (index >= size) throw new IndexOutOfBoundsException(String.valueOf(index));
		items[index] = value;
	}

	public void insert (int index, int value) {
		int[] items = this.items;
		if (size == items.length) items = resize(Math.max(8, (int)(size * 1.75f)));
		if (ordered)
			System.arraycopy(items, index, items, index + 1, size - index);
		else
			items[size] = items[index];
		size++;
		items[index] = value;
	}

	public void swap (int first, int second) {
		if (first >= size) throw new IndexOutOfBoundsException(String.valueOf(first));
		if (second >= size) throw new IndexOutOfBoundsException(String.valueOf(second));
		int[] items = this.items;
		int firstValue = items[first];
		items[first] = items[second];
		items[second] = firstValue;
	}

	public boolean contains (int value) {
		int i = size - 1;
		int[] items = this.items;
		while (i >= 0)
			if (items[i--] == value) return true;
		return false;
	}

	public int indexOf (int value) {
		int[] items = this.items;
		for (int i = 0, n = size; i < n; i++)
			if (items[i] == value) return i;
		return -1;
	}

	public boolean removeValue (int value) {
		int[] items = this.items;
		for (int i = 0, n = size; i < n; i++) {
			if (items[i] == value) {
				removeIndex(i);
				return true;
			}
		}
		return false;
	}

	/** Removes and returns the item at the specified index. */
	public int removeIndex (int index) {
		if (index >= size) throw new IndexOutOfBoundsException(String.valueOf(index));
		int[] items = this.items;
		int value = items[index];
		size--;
		if (ordered)
			System.arraycopy(items, index + 1, items, index, size - index);
		else
			items[index] = items[size];
		return value;
	}

	/** Removes and returns the last item. */
	public int pop () {
		return items[--size];
	}

	/** Returns the last item. */
	public int peek () {
		return items[size - 1];
	}

	public void clear () {
		size = 0;
	}

	/** Reduces the size of the backing array to the size of the actual items. This is useful to release memory when many items have
	 * been removed, or if it is known that more items will not be added. */
	public void shrink () {
		resize(size);
	}

	/** Increases the size of the backing array to acommodate the specified number of additional items. Useful before adding many
	 * items to avoid multiple backing array resizes.
	 * @return {@link #items} */
	public int[] ensureCapacity (int additionalCapacity) {
		int sizeNeeded = size + additionalCapacity;
		if (sizeNeeded >= items.length) resize(Math.max(8, sizeNeeded));
		return items;
	}

	protected int[] resize (int newSize) {
		int[] newItems = new int[newSize];
		int[] items = this.items;
		System.arraycopy(items, 0, newItems, 0, Math.min(items.length, newItems.length));
		this.items = newItems;
		return newItems;
	}

	public void sort () {
		Arrays.sort(items, 0, size);
	}

	public void reverse () {
		for (int i = 0, lastIndex = size - 1, n = size / 2; i < n; i++) {
			int ii = lastIndex - i;
			int temp = items[i];
			items[i] = items[ii];
			items[ii] = temp;
		}
	}

	/** Reduces the size of the array to the specified size. If the array is already smaller than the specified size, no action is
	 * taken. */
	public void truncate (int newSize) {
		if (size > newSize) size = newSize;
	}

	public int[] toArray () {
		int[] array = new int[size];
		System.arraycopy(items, 0, array, 0, size);
		return array;
	}

	public String toString () {
		if (size == 0) return "[]";
		int[] items = this.items;
		StringBuilder buffer = new StringBuilder(32);
		buffer.append('[');
		buffer.append(items[0]);
		for (int i = 1; i < size; i++) {
			buffer.append(", ");
			buffer.append(items[i]);
		}
		buffer.append(']');
		return buffer.toString();
	}

	public String toString (String separator) {
		if (size == 0) return "";
		int[] items = this.items;
		StringBuilder buffer = new StringBuilder(32);
		buffer.append(items[0]);
		for (int i = 1; i < size; i++) {
			buffer.append(separator);
			buffer.append(items[i]);
		}
		return buffer.toString();
	}
}

/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.esotericsoftware.kryo.util;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;

/** An unordered map that uses int keys. This implementation is a cuckoo hash map using 3 hashes, random walking, and a small stash
 * for problematic keys. Null values are allowed. No allocation is done except when growing the table size. <br>
 * <br>
 * This map performs very fast get, containsKey, and remove (typically O(1), worst case O(log(n))). Put may be a bit slower,
 * depending on hash collisions. Load factors greater than 0.91 greatly increase the chances the map will have to rehash to the
 * next higher POT size.
 * @author Nathan Sweet */
public class IntMap<V> {
	private static final int PRIME1 = 0xbe1f14b1;
	private static final int PRIME2 = 0xb4b82e39;
	private static final int PRIME3 = 0xced1c241;
	private static final int EMPTY = 0;

	public int size;

	int[] keyTable;
	V[] valueTable;
	int capacity, stashSize;
	V zeroValue;
	boolean hasZeroValue;

	private float loadFactor;
	private int hashShift, mask, threshold;
	private int stashCapacity;
	private int pushIterations;

	/** Creates a new map with an initial capacity of 32 and a load factor of 0.8. This map will hold 25 items before growing the
	 * backing table. */
	public IntMap () {
		this(32, 0.8f);
	}

	/** Creates a new map with a load factor of 0.8. This map will hold initialCapacity * 0.8 items before growing the backing
	 * table. */
	public IntMap (int initialCapacity) {
		this(initialCapacity, 0.8f);
	}

	/** Creates a new map with the specified initial capacity and load factor. This map will hold initialCapacity * loadFactor items
	 * before growing the backing table. */
	public IntMap (int initialCapacity, float loadFactor) {
		if (initialCapacity < 0) throw new IllegalArgumentException("initialCapacity must be >= 0: " + initialCapacity);
		if (initialCapacity > 1 << 30) throw new IllegalArgumentException("initialCapacity is too large: " + initialCapacity);
		capacity = ObjectMap.nextPowerOfTwo(initialCapacity);

		if (loadFactor <= 0) throw new IllegalArgumentException("loadFactor must be > 0: " + loadFactor);
		this.loadFactor = loadFactor;

		threshold = (int)(capacity * loadFactor);
		mask = capacity - 1;
		hashShift = 31 - Integer.numberOfTrailingZeros(capacity);
		stashCapacity = Math.max(3, (int)Math.ceil(Math.log(capacity)) * 2);
		pushIterations = Math.max(Math.min(capacity, 8), (int)Math.sqrt(capacity) / 8);

		keyTable = new int[capacity + stashCapacity];
		valueTable = (V[])new Object[keyTable.length];
	}

	/** Creates a new map identical to the specified map. */
	public IntMap (IntMap<? extends V> map) {
		this(map.capacity, map.loadFactor);
		stashSize = map.stashSize;
		System.arraycopy(map.keyTable, 0, keyTable, 0, map.keyTable.length);
		System.arraycopy(map.valueTable, 0, valueTable, 0, map.valueTable.length);
		size = map.size;
		zeroValue = map.zeroValue;
		hasZeroValue = map.hasZeroValue;
	}

	public V put (int key, V value) {
		if (key == 0) {
			V oldValue = zeroValue;
			zeroValue = value;
			if (!hasZeroValue) {
				hasZeroValue = true;
				size++;
			}
			return oldValue;
		}

		int[] keyTable = this.keyTable;

		// Check for existing keys.
		int index1 = key & mask;
		int key1 = keyTable[index1];
		if (key1 == key) {
			V oldValue = valueTable[index1];
			valueTable[index1] = value;
			return oldValue;
		}

		int index2 = hash2(key);
		int key2 = keyTable[index2];
		if (key2 == key) {
			V oldValue = valueTable[index2];
			valueTable[index2] = value;
			return oldValue;
		}

		int index3 = hash3(key);
		int key3 = keyTable[index3];
		if (key3 == key) {
			V oldValue = valueTable[index3];
			valueTable[index3] = value;
			return oldValue;
		}

		// Update key in the stash.
		for (int i = capacity, n = i + stashSize; i < n; i++) {
			if (keyTable[i] == key) {
				V oldValue = valueTable[i];
				valueTable[i] = value;
				return oldValue;
			}
		}

		// Check for empty buckets.
		if (key1 == EMPTY) {
			keyTable[index1] = key;
			valueTable[index1] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return null;
		}

		if (key2 == EMPTY) {
			keyTable[index2] = key;
			valueTable[index2] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return null;
		}

		if (key3 == EMPTY) {
			keyTable[index3] = key;
			valueTable[index3] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return null;
		}

		push(key, value, index1, key1, index2, key2, index3, key3);
		return null;
	}

	public void putAll (IntMap<V> map) {
		for (Entry<V> entry : map.entries())
			put(entry.key, entry.value);
	}

	/** Skips checks for existing keys. */
	private void putResize (int key, V value) {
		if (key == 0) {
			zeroValue = value;
			hasZeroValue = true;
			return;
		}

		// Check for empty buckets.
		int index1 = key & mask;
		int key1 = keyTable[index1];
		if (key1 == EMPTY) {
			keyTable[index1] = key;
			valueTable[index1] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		int index2 = hash2(key);
		int key2 = keyTable[index2];
		if (key2 == EMPTY) {
			keyTable[index2] = key;
			valueTable[index2] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		int index3 = hash3(key);
		int key3 = keyTable[index3];
		if (key3 == EMPTY) {
			keyTable[index3] = key;
			valueTable[index3] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		push(key, value, index1, key1, index2, key2, index3, key3);
	}

	private void push (int insertKey, V insertValue, int index1, int key1, int index2, int key2, int index3, int key3) {
		int[] keyTable = this.keyTable;

		V[] valueTable = this.valueTable;
		int mask = this.mask;

		// Push keys until an empty bucket is found.
		int evictedKey;
		V evictedValue;
		int i = 0, pushIterations = this.pushIterations;
		do {
			// Replace the key and value for one of the hashes.
			switch (ObjectMap.random.nextInt(3)) {
			case 0:
				evictedKey = key1;
				evictedValue = valueTable[index1];
				keyTable[index1] = insertKey;
				valueTable[index1] = insertValue;
				break;
			case 1:
				evictedKey = key2;
				evictedValue = valueTable[index2];
				keyTable[index2] = insertKey;
				valueTable[index2] = insertValue;
				break;
			default:
				evictedKey = key3;
				evictedValue = valueTable[index3];
				keyTable[index3] = insertKey;
				valueTable[index3] = insertValue;
				break;
			}

			// If the evicted key hashes to an empty bucket, put it there and stop.
			index1 = evictedKey & mask;
			key1 = keyTable[index1];
			if (key1 == EMPTY) {
				keyTable[index1] = evictedKey;
				valueTable[index1] = evictedValue;
				if (size++ >= threshold) resize(capacity << 1);
				return;
			}

			index2 = hash2(evictedKey);
			key2 = keyTable[index2];
			if (key2 == EMPTY) {
				keyTable[index2] = evictedKey;
				valueTable[index2] = evictedValue;
				if (size++ >= threshold) resize(capacity << 1);
				return;
			}

			index3 = hash3(evictedKey);
			key3 = keyTable[index3];
			if (key3 == EMPTY) {
				keyTable[index3] = evictedKey;
				valueTable[index3] = evictedValue;
				if (size++ >= threshold) resize(capacity << 1);
				return;
			}

			if (++i == pushIterations) break;

			insertKey = evictedKey;
			insertValue = evictedValue;
		} while (true);

		putStash(evictedKey, evictedValue);
	}

	private void putStash (int key, V value) {
		if (stashSize == stashCapacity) {
			// Too many pushes occurred and the stash is full, increase the table size.
			resize(capacity << 1);
			put(key, value);
			return;
		}
		// Store key in the stash.
		int index = capacity + stashSize;
		keyTable[index] = key;
		valueTable[index] = value;
		stashSize++;
		size++;
	}

	public V get (int key) {
		if (key == 0) {
			if (!hasZeroValue) return null;
			return zeroValue;
		}
		int index = key & mask;
		if (keyTable[index] != key) {
			index = hash2(key);
			if (keyTable[index] != key) {
				index = hash3(key);
				if (keyTable[index] != key) return getStash(key, null);
			}
		}
		return valueTable[index];
	}

	public V get (int key, V defaultValue) {
		if (key == 0) {
			if (!hasZeroValue) return defaultValue;
			return zeroValue;
		}
		int index = key & mask;
		if (keyTable[index] != key) {
			index = hash2(key);
			if (keyTable[index] != key) {
				index = hash3(key);
				if (keyTable[index] != key) return getStash(key, defaultValue);
			}
		}
		return valueTable[index];
	}

	private V getStash (int key, V defaultValue) {
		int[] keyTable = this.keyTable;
		for (int i = capacity, n = i + stashSize; i < n; i++)
			if (keyTable[i] == key) return valueTable[i];
		return defaultValue;
	}

	public V remove (int key) {
		if (key == 0) {
			if (!hasZeroValue) return null;
			V oldValue = zeroValue;
			zeroValue = null;
			hasZeroValue = false;
			size--;
			return oldValue;
		}

		int index = key & mask;
		if (keyTable[index] == key) {
			keyTable[index] = EMPTY;
			V oldValue = valueTable[index];
			valueTable[index] = null;
			size--;
			return oldValue;
		}

		index = hash2(key);
		if (keyTable[index] == key) {
			keyTable[index] = EMPTY;
			V oldValue = valueTable[index];
			valueTable[index] = null;
			size--;
			return oldValue;
		}

		index = hash3(key);
		if (keyTable[index] == key) {
			keyTable[index] = EMPTY;
			V oldValue = valueTable[index];
			valueTable[index] = null;
			size--;
			return oldValue;
		}

		return removeStash(key);
	}

	V removeStash (int key) {
		int[] keyTable = this.keyTable;
		for (int i = capacity, n = i + stashSize; i < n; i++) {
			if (keyTable[i] == key) {
				V oldValue = valueTable[i];
				removeStashIndex(i);
				size--;
				return oldValue;
			}
		}
		return null;
	}

	void removeStashIndex (int index) {
		// If the removed location was not last, move the last tuple to the removed location.
		stashSize--;
		int lastIndex = capacity + stashSize;
		if (index < lastIndex) {
			keyTable[index] = keyTable[lastIndex];
			valueTable[index] = valueTable[lastIndex];
			valueTable[lastIndex] = null;
		} else
			valueTable[index] = null;
	}

	/** Reduces the size of the backing arrays to be the specified capacity or less. If the capacity is already less, nothing is
	 * done. If the map contains more items than the specified capacity, the next highest power of two capacity is used instead. */
	public void shrink (int maximumCapacity) {
		if (maximumCapacity < 0) throw new IllegalArgumentException("maximumCapacity must be >= 0: " + maximumCapacity);
		if (size > maximumCapacity) maximumCapacity = size;
		if (capacity <= maximumCapacity) return;
		maximumCapacity = ObjectMap.nextPowerOfTwo(maximumCapacity);
		resize(maximumCapacity);
	}

	/** Clears the map and reduces the size of the backing arrays to be the specified capacity if they are larger. */
	public void clear (int maximumCapacity) {
		if (capacity <= maximumCapacity) {
			clear();
			return;
		}
		zeroValue = null;
		hasZeroValue = false;
		size = 0;
		resize(maximumCapacity);
	}

	public void clear () {
		int[] keyTable = this.keyTable;
		V[] valueTable = this.valueTable;
		for (int i = capacity + stashSize; i-- > 0;) {
			keyTable[i] = EMPTY;
			valueTable[i] = null;
		}
		size = 0;
		stashSize = 0;
		zeroValue = null;
		hasZeroValue = false;
	}

	/** Returns true if the specified value is in the map. Note this traverses the entire map and compares every value, which may be
	 * an expensive operation.
	 * @param identity If true, uses == to compare the specified value with values in the map. If false, uses
	 *           {@link #equals(Object)}. */
	public boolean containsValue (Object value, boolean identity) {
		V[] valueTable = this.valueTable;
		if (value == null) {
			if (hasZeroValue && zeroValue == null) return true;
			int[] keyTable = this.keyTable;
			for (int i = capacity + stashSize; i-- > 0;)
				if (keyTable[i] != EMPTY && valueTable[i] == null) return true;
		} else if (identity) {
			if (value == zeroValue) return true;
			for (int i = capacity + stashSize; i-- > 0;)
				if (valueTable[i] == value) return true;
		} else {
			if (hasZeroValue && value.equals(zeroValue)) return true;
			for (int i = capacity + stashSize; i-- > 0;)
				if (value.equals(valueTable[i])) return true;
		}
		return false;
	}

	public boolean containsKey (int key) {
		if (key == 0) return hasZeroValue;
		int index = key & mask;
		if (keyTable[index] != key) {
			index = hash2(key);
			if (keyTable[index] != key) {
				index = hash3(key);
				if (keyTable[index] != key) return containsKeyStash(key);
			}
		}
		return true;
	}

	private boolean containsKeyStash (int key) {
		int[] keyTable = this.keyTable;
		for (int i = capacity, n = i + stashSize; i < n; i++)
			if (keyTable[i] == key) return true;
		return false;
	}

	/** Returns the key for the specified value, or <tt>notFound</tt> if it is not in the map. Note this traverses the entire map
	 * and compares every value, which may be an expensive operation.
	 * @param identity If true, uses == to compare the specified value with values in the map. If false, uses
	 *           {@link #equals(Object)}. */
	public int findKey (Object value, boolean identity, int notFound) {
		V[] valueTable = this.valueTable;
		if (value == null) {
			if (hasZeroValue && zeroValue == null) return 0;
			int[] keyTable = this.keyTable;
			for (int i = capacity + stashSize; i-- > 0;)
				if (keyTable[i] != EMPTY && valueTable[i] == null) return keyTable[i];
		} else if (identity) {
			if (value == zeroValue) return 0;
			for (int i = capacity + stashSize; i-- > 0;)
				if (valueTable[i] == value) return keyTable[i];
		} else {
			if (hasZeroValue && value.equals(zeroValue)) return 0;
			for (int i = capacity + stashSize; i-- > 0;)
				if (value.equals(valueTable[i])) return keyTable[i];
		}
		return notFound;
	}

	/** Increases the size of the backing array to acommodate the specified number of additional items. Useful before adding many
	 * items to avoid multiple backing array resizes. */
	public void ensureCapacity (int additionalCapacity) {
		int sizeNeeded = size + additionalCapacity;
		if (sizeNeeded >= threshold) resize(ObjectMap.nextPowerOfTwo((int)(sizeNeeded / loadFactor)));
	}

	private void resize (int newSize) {
		int oldEndIndex = capacity + stashSize;

		capacity = newSize;
		threshold = (int)(newSize * loadFactor);
		mask = newSize - 1;
		hashShift = 31 - Integer.numberOfTrailingZeros(newSize);
		stashCapacity = Math.max(3, (int)Math.ceil(Math.log(newSize)) * 2);
		pushIterations = Math.max(Math.min(newSize, 8), (int)Math.sqrt(newSize) / 8);

		int[] oldKeyTable = keyTable;
		V[] oldValueTable = valueTable;

		keyTable = new int[newSize + stashCapacity];
		valueTable = (V[])new Object[newSize + stashCapacity];

		int oldSize = size;
		size = hasZeroValue ? 1 : 0;
		stashSize = 0;
		if (oldSize > 0) {
			for (int i = 0; i < oldEndIndex; i++) {
				int key = oldKeyTable[i];
				if (key != EMPTY) putResize(key, oldValueTable[i]);
			}
		}
	}

	private int hash2 (int h) {
		h *= PRIME2;
		return (h ^ h >>> hashShift) & mask;
	}

	private int hash3 (int h) {
		h *= PRIME3;
		return (h ^ h >>> hashShift) & mask;
	}

	public String toString () {
		if (size == 0) return "[]";
		StringBuilder buffer = new StringBuilder(32);
		buffer.append('[');
		int[] keyTable = this.keyTable;
		V[] valueTable = this.valueTable;
		int i = keyTable.length;
		if (hasZeroValue) {
			buffer.append("0=");
			buffer.append(zeroValue);
		} else {
			while (i-- > 0) {
				int key = keyTable[i];
				if (key == EMPTY) continue;
				buffer.append(key);
				buffer.append('=');
				buffer.append(valueTable[i]);
				break;
			}
		}
		while (i-- > 0) {
			int key = keyTable[i];
			if (key == EMPTY) continue;
			buffer.append(", ");
			buffer.append(key);
			buffer.append('=');
			buffer.append(valueTable[i]);
		}
		buffer.append(']');
		return buffer.toString();
	}

	/** Returns an iterator for the entries in the map. Remove is supported. Note that the same iterator instance is returned each
	 * time this method is called. Use the {@link Entries} constructor for nested or multithreaded iteration. */
	public Entries<V> entries () {
		return new Entries(this);
	}

	/** Returns an iterator for the values in the map. Remove is supported. Note that the same iterator instance is returned each
	 * time this method is called. Use the {@link Entries} constructor for nested or multithreaded iteration. */
	public Values<V> values () {
		return new Values(this);
	}

	/** Returns an iterator for the keys in the map. Remove is supported. Note that the same iterator instance is returned each time
	 * this method is called. Use the {@link Entries} constructor for nested or multithreaded iteration. */
	public Keys keys () {
		return new Keys(this);
	}

	static public class Entry<V> {
		public int key;
		public V value;

		public String toString () {
			return key + "=" + value;
		}
	}

	static private class MapIterator<V> {
		static final int INDEX_ILLEGAL = -2;
		static final int INDEX_ZERO = -1;

		public boolean hasNext;

		final IntMap<V> map;
		int nextIndex, currentIndex;

		public MapIterator (IntMap<V> map) {
			this.map = map;
			reset();
		}

		public void reset () {
			currentIndex = INDEX_ILLEGAL;
			nextIndex = INDEX_ZERO;
			if (map.hasZeroValue)
				hasNext = true;
			else
				findNextIndex();
		}

		void findNextIndex () {
			hasNext = false;
			int[] keyTable = map.keyTable;
			for (int n = map.capacity + map.stashSize; ++nextIndex < n;) {
				if (keyTable[nextIndex] != EMPTY) {
					hasNext = true;
					break;
				}
			}
		}

		public void remove () {
			if (currentIndex == INDEX_ZERO && map.hasZeroValue) {
				map.zeroValue = null;
				map.hasZeroValue = false;
			} else if (currentIndex < 0) {
				throw new IllegalStateException("next must be called before remove.");
			} else if (currentIndex >= map.capacity) {
				map.removeStashIndex(currentIndex);
				nextIndex = currentIndex - 1;
				findNextIndex();
			} else {
				map.keyTable[currentIndex] = EMPTY;
				map.valueTable[currentIndex] = null;
			}
			currentIndex = INDEX_ILLEGAL;
			map.size--;
		}
	}

	static public class Entries<V> extends MapIterator<V> implements Iterable<Entry<V>>, Iterator<Entry<V>> {
		private Entry<V> entry = new Entry();

		public Entries (IntMap map) {
			super(map);
		}

		/** Note the same entry instance is returned each time this method is called. */
		public Entry<V> next () {
			if (!hasNext) throw new NoSuchElementException();
			int[] keyTable = map.keyTable;
			if (nextIndex == INDEX_ZERO) {
				entry.key = 0;
				entry.value = map.zeroValue;
			} else {
				entry.key = keyTable[nextIndex];
				entry.value = map.valueTable[nextIndex];
			}
			currentIndex = nextIndex;
			findNextIndex();
			return entry;
		}

		public boolean hasNext () {
			return hasNext;
		}

		public Iterator<Entry<V>> iterator () {
			return this;
		}
	}

	static public class Values<V> extends MapIterator<V> implements Iterable<V>, Iterator<V> {
		public Values (IntMap<V> map) {
			super(map);
		}

		public boolean hasNext () {
			return hasNext;
		}

		public V next () {
			if (!hasNext) throw new NoSuchElementException();
			V value;
			if (nextIndex == INDEX_ZERO)
				value = map.zeroValue;
			else
				value = map.valueTable[nextIndex];
			currentIndex = nextIndex;
			findNextIndex();
			return value;
		}

		public Iterator<V> iterator () {
			return this;
		}

		/** Returns a new array containing the remaining values. */
		public ArrayList<V> toArray () {
			ArrayList array = new ArrayList(map.size);
			while (hasNext)
				array.add(next());
			return array;
		}
	}

	static public class Keys extends MapIterator {
		public Keys (IntMap map) {
			super(map);
		}

		public int next () {
			if (!hasNext) throw new NoSuchElementException();
			int key = nextIndex == INDEX_ZERO ? 0 : map.keyTable[nextIndex];
			currentIndex = nextIndex;
			findNextIndex();
			return key;
		}

		/** Returns a new array containing the remaining keys. */
		public IntArray toArray () {
			IntArray array = new IntArray(true, map.size);
			while (hasNext)
				array.add(next());
			return array;
		}
	}
}


package com.esotericsoftware.kryo.util;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Random;

/** An unordered map. This implementation is a cuckoo hash map using 3 hashes, random walking, and a small stash for problematic
 * keys. Null keys are not allowed. Null values are allowed. No allocation is done except when growing the table size. <br>
 * <br>
 * This map performs very fast get, containsKey, and remove (typically O(1), worst case O(log(n))). Put may be a bit slower,
 * depending on hash collisions. Load factors greater than 0.91 greatly increase the chances the map will have to rehash to the
 * next higher POT size.
 * @author Nathan Sweet */
public class ObjectMap<K, V> {
	private static final int PRIME1 = 0xbe1f14b1;
	private static final int PRIME2 = 0xb4b82e39;
	private static final int PRIME3 = 0xced1c241;

	static Random random = new Random();

	public int size;

	K[] keyTable;
	V[] valueTable;
	int capacity, stashSize;

	private float loadFactor;
	private int hashShift, mask, threshold;
	private int stashCapacity;
	private int pushIterations;

	/** Creates a new map with an initial capacity of 32 and a load factor of 0.8. This map will hold 25 items before growing the
	 * backing table. */
	public ObjectMap () {
		this(32, 0.8f);
	}

	/** Creates a new map with a load factor of 0.8. This map will hold initialCapacity * 0.8 items before growing the backing
	 * table. */
	public ObjectMap (int initialCapacity) {
		this(initialCapacity, 0.8f);
	}

	/** Creates a new map with the specified initial capacity and load factor. This map will hold initialCapacity * loadFactor items
	 * before growing the backing table. */
	public ObjectMap (int initialCapacity, float loadFactor) {
		if (initialCapacity < 0) throw new IllegalArgumentException("initialCapacity must be >= 0: " + initialCapacity);
		if (initialCapacity > 1 << 30) throw new IllegalArgumentException("initialCapacity is too large: " + initialCapacity);
		capacity = nextPowerOfTwo(initialCapacity);

		if (loadFactor <= 0) throw new IllegalArgumentException("loadFactor must be > 0: " + loadFactor);
		this.loadFactor = loadFactor;

		threshold = (int)(capacity * loadFactor);
		mask = capacity - 1;
		hashShift = 31 - Integer.numberOfTrailingZeros(capacity);
		stashCapacity = Math.max(3, (int)Math.ceil(Math.log(capacity)) * 2);
		pushIterations = Math.max(Math.min(capacity, 8), (int)Math.sqrt(capacity) / 8);

		keyTable = (K[])new Object[capacity + stashCapacity];
		valueTable = (V[])new Object[keyTable.length];
	}

	/** Creates a new map identical to the specified map. */
	public ObjectMap (ObjectMap<? extends K, ? extends V> map) {
		this(map.capacity, map.loadFactor);
		stashSize = map.stashSize;
		System.arraycopy(map.keyTable, 0, keyTable, 0, map.keyTable.length);
		System.arraycopy(map.valueTable, 0, valueTable, 0, map.valueTable.length);
		size = map.size;
	}

	/** Returns the old value associated with the specified key, or null. */
	public V put (K key, V value) {
		if (key == null) throw new IllegalArgumentException("key cannot be null.");
		return put_internal(key, value);
	}

	private V put_internal (K key, V value) {
		K[] keyTable = this.keyTable;

		// Check for existing keys.
		int hashCode = key.hashCode();
		int index1 = hashCode & mask;
		K key1 = keyTable[index1];
		if (key.equals(key1)) {
			V oldValue = valueTable[index1];
			valueTable[index1] = value;
			return oldValue;
		}

		int index2 = hash2(hashCode);
		K key2 = keyTable[index2];
		if (key.equals(key2)) {
			V oldValue = valueTable[index2];
			valueTable[index2] = value;
			return oldValue;
		}

		int index3 = hash3(hashCode);
		K key3 = keyTable[index3];
		if (key.equals(key3)) {
			V oldValue = valueTable[index3];
			valueTable[index3] = value;
			return oldValue;
		}

		// Update key in the stash.
		for (int i = capacity, n = i + stashSize; i < n; i++) {
			if (key.equals(keyTable[i])) {
				V oldValue = valueTable[i];
				valueTable[i] = value;
				return oldValue;
			}
		}

		// Check for empty buckets.
		if (key1 == null) {
			keyTable[index1] = key;
			valueTable[index1] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return null;
		}

		if (key2 == null) {
			keyTable[index2] = key;
			valueTable[index2] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return null;
		}

		if (key3 == null) {
			keyTable[index3] = key;
			valueTable[index3] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return null;
		}

		push(key, value, index1, key1, index2, key2, index3, key3);
		return null;
	}

	public void putAll (ObjectMap<K, V> map) {
		ensureCapacity(map.size);
		for (Entry<K, V> entry : map.entries())
			put(entry.key, entry.value);
	}

	/** Skips checks for existing keys. */
	private void putResize (K key, V value) {
		// Check for empty buckets.
		int hashCode = key.hashCode();
		int index1 = hashCode & mask;
		K key1 = keyTable[index1];
		if (key1 == null) {
			keyTable[index1] = key;
			valueTable[index1] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		int index2 = hash2(hashCode);
		K key2 = keyTable[index2];
		if (key2 == null) {
			keyTable[index2] = key;
			valueTable[index2] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		int index3 = hash3(hashCode);
		K key3 = keyTable[index3];
		if (key3 == null) {
			keyTable[index3] = key;
			valueTable[index3] = value;
			if (size++ >= threshold) resize(capacity << 1);
			return;
		}

		push(key, value, index1, key1, index2, key2, index3, key3);
	}

	private void push (K insertKey, V insertValue, int index1, K key1, int index2, K key2, int index3, K key3) {
		K[] keyTable = this.keyTable;
		V[] valueTable = this.valueTable;
		int mask = this.mask;

		// Push keys until an empty bucket is found.
		K evictedKey;
		V evictedValue;
		int i = 0, pushIterations = this.pushIterations;
		do {
			// Replace the key and value for one of the hashes.
			switch (random.nextInt(3)) {
			case 0:
				evictedKey = key1;
				evictedValue = valueTable[index1];
				keyTable[index1] = insertKey;
				valueTable[index1] = insertValue;
				break;
			case 1:
				evictedKey = key2;
				evictedValue = valueTable[index2];
				keyTable[index2] = insertKey;
				valueTable[index2] = insertValue;
				break;
			default:
				evictedKey = key3;
				evictedValue = valueTable[index3];
				keyTable[index3] = insertKey;
				valueTable[index3] = insertValue;
				break;
			}

			// If the evicted key hashes to an empty bucket, put it there and stop.
			int hashCode = evictedKey.hashCode();
			index1 = hashCode & mask;
			key1 = keyTable[index1];
			if (key1 == null) {
				keyTable[index1] = evictedKey;
				valueTable[index1] = evictedValue;
				if (size++ >= threshold) resize(capacity << 1);
				return;
			}

			index2 = hash2(hashCode);
			key2 = keyTable[index2];
			if (key2 == null) {
				keyTable[index2] = evictedKey;
				valueTable[index2] = evictedValue;
				if (size++ >= threshold) resize(capacity << 1);
				return;
			}

			index3 = hash3(hashCode);
			key3 = keyTable[index3];
			if (key3 == null) {
				keyTable[index3] = evictedKey;
				valueTable[index3] = evictedValue;
				if (size++ >= threshold) resize(capacity << 1);
				return;
			}

			if (++i == pushIterations) break;

			insertKey = evictedKey;
			insertValue = evictedValue;
		} while (true);

		putStash(evictedKey, evictedValue);
	}

	private void putStash (K key, V value) {
		if (stashSize == stashCapacity) {
			// Too many pushes occurred and the stash is full, increase the table size.
			resize(capacity << 1);
			put_internal(key, value);
			return;
		}
		// Store key in the stash.
		int index = capacity + stashSize;
		keyTable[index] = key;
		valueTable[index] = value;
		stashSize++;
		size++;
	}

	public V get (K key) {
		int hashCode = key.hashCode();
		int index = hashCode & mask;
		if (!key.equals(keyTable[index])) {
			index = hash2(hashCode);
			if (!key.equals(keyTable[index])) {
				index = hash3(hashCode);
				if (!key.equals(keyTable[index])) return getStash(key);
			}
		}
		return valueTable[index];
	}

	private V getStash (K key) {
		K[] keyTable = this.keyTable;
		for (int i = capacity, n = i + stashSize; i < n; i++)
			if (key.equals(keyTable[i])) return valueTable[i];
		return null;
	}

	/** Returns the value for the specified key, or the default value if the key is not in the map. */
	public V get (K key, V defaultValue) {
		int hashCode = key.hashCode();
		int index = hashCode & mask;
		if (!key.equals(keyTable[index])) {
			index = hash2(hashCode);
			if (!key.equals(keyTable[index])) {
				index = hash3(hashCode);
				if (!key.equals(keyTable[index])) return getStash(key, defaultValue);
			}
		}
		return valueTable[index];
	}

	private V getStash (K key, V defaultValue) {
		K[] keyTable = this.keyTable;
		for (int i = capacity, n = i + stashSize; i < n; i++)
			if (key.equals(keyTable[i])) return valueTable[i];
		return defaultValue;
	}

	public V remove (K key) {
		int hashCode = key.hashCode();
		int index = hashCode & mask;
		if (key.equals(keyTable[index])) {
			keyTable[index] = null;
			V oldValue = valueTable[index];
			valueTable[index] = null;
			size--;
			return oldValue;
		}

		index = hash2(hashCode);
		if (key.equals(keyTable[index])) {
			keyTable[index] = null;
			V oldValue = valueTable[index];
			valueTable[index] = null;
			size--;
			return oldValue;
		}

		index = hash3(hashCode);
		if (key.equals(keyTable[index])) {
			keyTable[index] = null;
			V oldValue = valueTable[index];
			valueTable[index] = null;
			size--;
			return oldValue;
		}

		return removeStash(key);
	}

	V removeStash (K key) {
		K[] keyTable = this.keyTable;
		for (int i = capacity, n = i + stashSize; i < n; i++) {
			if (key.equals(keyTable[i])) {
				V oldValue = valueTable[i];
				removeStashIndex(i);
				size--;
				return oldValue;
			}
		}
		return null;
	}

	void removeStashIndex (int index) {
		// If the removed location was not last, move the last tuple to the removed location.
		stashSize--;
		int lastIndex = capacity + stashSize;
		if (index < lastIndex) {
			keyTable[index] = keyTable[lastIndex];
			valueTable[index] = valueTable[lastIndex];
			valueTable[lastIndex] = null;
		} else
			valueTable[index] = null;
	}

	/** Reduces the size of the backing arrays to be the specified capacity or less. If the capacity is already less, nothing is
	 * done. If the map contains more items than the specified capacity, the next highest power of two capacity is used instead. */
	public void shrink (int maximumCapacity) {
		if (maximumCapacity < 0) throw new IllegalArgumentException("maximumCapacity must be >= 0: " + maximumCapacity);
		if (size > maximumCapacity) maximumCapacity = size;
		if (capacity <= maximumCapacity) return;
		maximumCapacity = nextPowerOfTwo(maximumCapacity);
		resize(maximumCapacity);
	}

	/** Clears the map and reduces the size of the backing arrays to be the specified capacity if they are larger. */
	public void clear (int maximumCapacity) {
		if (capacity <= maximumCapacity) {
			clear();
			return;
		}
		size = 0;
		resize(maximumCapacity);
	}

	public void clear () {
		K[] keyTable = this.keyTable;
		V[] valueTable = this.valueTable;
		for (int i = capacity + stashSize; i-- > 0;) {
			keyTable[i] = null;
			valueTable[i] = null;
		}
		size = 0;
		stashSize = 0;
	}

	/** Returns true if the specified value is in the map. Note this traverses the entire map and compares every value, which may be
	 * an expensive operation.
	 * @param identity If true, uses == to compare the specified value with values in the map. If false, uses
	 *           {@link #equals(Object)}. */
	public boolean containsValue (Object value, boolean identity) {
		V[] valueTable = this.valueTable;
		if (value == null) {
			K[] keyTable = this.keyTable;
			for (int i = capacity + stashSize; i-- > 0;)
				if (keyTable[i] != null && valueTable[i] == null) return true;
		} else if (identity) {
			for (int i = capacity + stashSize; i-- > 0;)
				if (valueTable[i] == value) return true;
		} else {
			for (int i = capacity + stashSize; i-- > 0;)
				if (value.equals(valueTable[i])) return true;
		}
		return false;
	}

	public boolean containsKey (K key) {
		int hashCode = key.hashCode();
		int index = hashCode & mask;
		if (!key.equals(keyTable[index])) {
			index = hash2(hashCode);
			if (!key.equals(keyTable[index])) {
				index = hash3(hashCode);
				if (!key.equals(keyTable[index])) return containsKeyStash(key);
			}
		}
		return true;
	}

	private boolean containsKeyStash (K key) {
		K[] keyTable = this.keyTable;
		for (int i = capacity, n = i + stashSize; i < n; i++)
			if (key.equals(keyTable[i])) return true;
		return false;
	}

	/** Returns the key for the specified value, or null if it is not in the map. Note this traverses the entire map and compares
	 * every value, which may be an expensive operation.
	 * @param identity If true, uses == to compare the specified value with values in the map. If false, uses
	 *           {@link #equals(Object)}. */
	public K findKey (Object value, boolean identity) {
		V[] valueTable = this.valueTable;
		if (value == null) {
			K[] keyTable = this.keyTable;
			for (int i = capacity + stashSize; i-- > 0;)
				if (keyTable[i] != null && valueTable[i] == null) return keyTable[i];
		} else if (identity) {
			for (int i = capacity + stashSize; i-- > 0;)
				if (valueTable[i] == value) return keyTable[i];
		} else {
			for (int i = capacity + stashSize; i-- > 0;)
				if (value.equals(valueTable[i])) return keyTable[i];
		}
		return null;
	}

	/** Increases the size of the backing array to acommodate the specified number of additional items. Useful before adding many
	 * items to avoid multiple backing array resizes. */
	public void ensureCapacity (int additionalCapacity) {
		int sizeNeeded = size + additionalCapacity;
		if (sizeNeeded >= threshold) resize(nextPowerOfTwo((int)(sizeNeeded / loadFactor)));
	}

	private void resize (int newSize) {
		int oldEndIndex = capacity + stashSize;

		capacity = newSize;
		threshold = (int)(newSize * loadFactor);
		mask = newSize - 1;
		hashShift = 31 - Integer.numberOfTrailingZeros(newSize);
		stashCapacity = Math.max(3, (int)Math.ceil(Math.log(newSize)) * 2);
		pushIterations = Math.max(Math.min(newSize, 8), (int)Math.sqrt(newSize) / 8);

		K[] oldKeyTable = keyTable;
		V[] oldValueTable = valueTable;

		keyTable = (K[])new Object[newSize + stashCapacity];
		valueTable = (V[])new Object[newSize + stashCapacity];

		int oldSize = size;
		size = 0;
		stashSize = 0;
		if (oldSize > 0) {
			for (int i = 0; i < oldEndIndex; i++) {
				K key = oldKeyTable[i];
				if (key != null) putResize(key, oldValueTable[i]);
			}
		}
	}

	private int hash2 (int h) {
		h *= PRIME2;
		return (h ^ h >>> hashShift) & mask;
	}

	private int hash3 (int h) {
		h *= PRIME3;
		return (h ^ h >>> hashShift) & mask;
	}

	public String toString () {
		if (size == 0) return "{}";
		StringBuilder buffer = new StringBuilder(32);
		buffer.append('{');
		K[] keyTable = this.keyTable;
		V[] valueTable = this.valueTable;
		int i = keyTable.length;
		while (i-- > 0) {
			K key = keyTable[i];
			if (key == null) continue;
			buffer.append(key);
			buffer.append('=');
			buffer.append(valueTable[i]);
			break;
		}
		while (i-- > 0) {
			K key = keyTable[i];
			if (key == null) continue;
			buffer.append(", ");
			buffer.append(key);
			buffer.append('=');
			buffer.append(valueTable[i]);
		}
		buffer.append('}');
		return buffer.toString();
	}

	/** Returns an iterator for the entries in the map. Remove is supported. */
	public Entries<K, V> entries () {
		return new Entries(this);
	}

	/** Returns an iterator for the values in the map. Remove is supported. */
	public Values<V> values () {
		return new Values(this);
	}

	/** Returns an iterator for the keys in the map. Remove is supported. */
	public Keys<K> keys () {
		return new Keys(this);
	}

	static public class Entry<K, V> {
		public K key;
		public V value;

		public String toString () {
			return key + "=" + value;
		}
	}

	static private class MapIterator<K, V> {
		public boolean hasNext;

		final ObjectMap<K, V> map;
		int nextIndex, currentIndex;

		public MapIterator (ObjectMap<K, V> map) {
			this.map = map;
			reset();
		}

		public void reset () {
			currentIndex = -1;
			nextIndex = -1;
			advance();
		}

		void advance () {
			hasNext = false;
			K[] keyTable = map.keyTable;
			for (int n = map.capacity + map.stashSize; ++nextIndex < n;) {
				if (keyTable[nextIndex] != null) {
					hasNext = true;
					break;
				}
			}
		}

		public void remove () {
			if (currentIndex < 0) throw new IllegalStateException("next must be called before remove.");
			if (currentIndex >= map.capacity) {
				map.removeStashIndex(currentIndex);
				nextIndex = currentIndex - 1;
				advance();
			} else {
				map.keyTable[currentIndex] = null;
				map.valueTable[currentIndex] = null;
			}
			currentIndex = -1;
			map.size--;
		}
	}

	static public class Entries<K, V> extends MapIterator<K, V> implements Iterable<Entry<K, V>>, Iterator<Entry<K, V>> {
		Entry<K, V> entry = new Entry();

		public Entries (ObjectMap<K, V> map) {
			super(map);
		}

		/** Note the same entry instance is returned each time this method is called. */
		public Entry<K, V> next () {
			if (!hasNext) throw new NoSuchElementException();
			K[] keyTable = map.keyTable;
			entry.key = keyTable[nextIndex];
			entry.value = map.valueTable[nextIndex];
			currentIndex = nextIndex;
			advance();
			return entry;
		}

		public boolean hasNext () {
			return hasNext;
		}

		public Iterator<Entry<K, V>> iterator () {
			return this;
		}
	}

	static public class Values<V> extends MapIterator<Object, V> implements Iterable<V>, Iterator<V> {
		public Values (ObjectMap<?, V> map) {
			super((ObjectMap<Object, V>)map);
		}

		public boolean hasNext () {
			return hasNext;
		}

		public V next () {
			if (!hasNext) throw new NoSuchElementException();
			V value = map.valueTable[nextIndex];
			currentIndex = nextIndex;
			advance();
			return value;
		}

		public Iterator<V> iterator () {
			return this;
		}

		/** Returns a new array containing the remaining values. */
		public ArrayList<V> toArray () {
			ArrayList array = new ArrayList(map.size);
			while (hasNext)
				array.add(next());
			return array;
		}

		/** Adds the remaining values to the specified array. */
		public void toArray (ArrayList<V> array) {
			while (hasNext)
				array.add(next());
		}
	}

	static public class Keys<K> extends MapIterator<K, Object> implements Iterable<K>, Iterator<K> {
		public Keys (ObjectMap<K, ?> map) {
			super((ObjectMap<K, Object>)map);
		}

		public boolean hasNext () {
			return hasNext;
		}

		public K next () {
			if (!hasNext) throw new NoSuchElementException();
			K key = map.keyTable[nextIndex];
			currentIndex = nextIndex;
			advance();
			return key;
		}

		public Iterator<K> iterator () {
			return this;
		}

		/** Returns a new array containing the remaining keys. */
		public ArrayList<K> toArray () {
			ArrayList array = new ArrayList(map.size);
			while (hasNext)
				array.add(next());
			return array;
		}
	}

	static public int nextPowerOfTwo (int value) {
		if (value == 0) return 1;
		value--;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		return value + 1;
	}
}


package com.esotericsoftware.kryo.util;

import static com.esotericsoftware.minlog.Log.*;

/** A few utility methods, mostly for private use.
 * @author Nathan Sweet <misc@n4te.com> */
public class Util {
	/** Returns the primitive wrapper class for a primitive class.
	 * @param type Must be a primitive class. */
	static public Class getWrapperClass (Class type) {
		if (type == int.class)
			return Integer.class;
		else if (type == float.class)
			return Float.class;
		else if (type == boolean.class)
			return Boolean.class;
		else if (type == long.class)
			return Long.class;
		else if (type == byte.class)
			return Byte.class;
		else if (type == char.class)
			return Character.class;
		else if (type == short.class) //
			return Short.class;
		else if (type == double.class)
			return Double.class;
		return Void.class;
	}

	/** Logs a message about an object. The log level and the string format of the object depend on the object type. */
	static public void log (String message, Object object) {
		if (object == null) {
			if (TRACE) trace("kryo", message + ": null");
			return;
		}
		Class type = object.getClass();
		if (type.isPrimitive() || type == Boolean.class || type == Byte.class || type == Character.class || type == Short.class
			|| type == Integer.class || type == Long.class || type == Float.class || type == Double.class || type == String.class) {
		}
	}

	/** Returns the class formatted as a string. The format varies depending on the type. */
	static public String className (Class type) {
		if (type.isArray()) {
			Class elementClass = getElementClass(type);
			StringBuilder buffer = new StringBuilder(16);
			for (int i = 0, n = getDimensionCount(type); i < n; i++)
				buffer.append("[]");
			return className(elementClass) + buffer;
		}
		if (type.isPrimitive() || type == Object.class || type == Boolean.class || type == Byte.class || type == Character.class
			|| type == Short.class || type == Integer.class || type == Long.class || type == Float.class || type == Double.class
			|| type == String.class) {
			return type.getSimpleName();
		}
		return type.getName();
	}

	/** Returns the number of dimensions of an array. */
	static public int getDimensionCount (Class arrayClass) {
		int depth = 0;
		Class nextClass = arrayClass.getComponentType();
		while (nextClass != null) {
			depth++;
			nextClass = nextClass.getComponentType();
		}
		return depth;
	}

	/** Returns the base element type of an n-dimensional array class. */
	static public Class getElementClass (Class arrayClass) {
		Class elementClass = arrayClass;
		while (elementClass.getComponentType() != null)
			elementClass = elementClass.getComponentType();
		return elementClass;
	}
}


package com.esotericsoftware.kryonet;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.NetworkInterface;
import java.net.SocketTimeoutException;
import java.nio.ByteBuffer;
import java.nio.channels.CancelledKeyException;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryonet.FrameworkMessage.DiscoverHost;
import com.esotericsoftware.kryonet.FrameworkMessage.RegisterTCP;
import com.esotericsoftware.kryonet.FrameworkMessage.RegisterUDP;

import static com.esotericsoftware.minlog.Log.*;

/** Represents a TCP and optionally a UDP connection to a {@link Server}.
 * @author Nathan Sweet <misc@n4te.com> */
public class Client extends Connection implements EndPoint {
	private final Serialization serialization;
	private Selector selector;
	private int emptySelects;
	private volatile boolean tcpRegistered, udpRegistered;
	private Object tcpRegistrationLock = new Object();
	private Object udpRegistrationLock = new Object();
	private volatile boolean shutdown;
	private final Object updateLock = new Object();
	private Thread updateThread;
	private int connectTimeout;
	private InetAddress connectHost;
	private int connectTcpPort;
	private int connectUdpPort;
	private boolean isClosed;

	/** Creates a Client with a write buffer size of 8192 and an object buffer size of 2048. */
	public Client () {
		this(8192, 2048);
	}

	/** @param writeBufferSize One buffer of this size is allocated. Objects are serialized to the write buffer where the bytes are
	 *           queued until they can be written to the TCP socket.
	 *           <p>
	 *           Normally the socket is writable and the bytes are written immediately. If the socket cannot be written to and
	 *           enough serialized objects are queued to overflow the buffer, then the connection will be closed.
	 *           <p>
	 *           The write buffer should be sized at least as large as the largest object that will be sent, plus some head room to
	 *           allow for some serialized objects to be queued in case the buffer is temporarily not writable. The amount of head
	 *           room needed is dependent upon the size of objects being sent and how often they are sent.
	 * @param objectBufferSize One (using only TCP) or three (using both TCP and UDP) buffers of this size are allocated. These
	 *           buffers are used to hold the bytes for a single object graph until it can be sent over the network or
	 *           deserialized.
	 *           <p>
	 *           The object buffers should be sized at least as large as the largest object that will be sent or received. */
	public Client (int writeBufferSize, int objectBufferSize) {
		this(writeBufferSize, objectBufferSize, new KryoSerialization());
	}

	public Client (int writeBufferSize, int objectBufferSize, Serialization serialization) {
		super();
		endPoint = this;

		this.serialization = serialization;

		initialize(serialization, writeBufferSize, objectBufferSize);

		try {
			selector = Selector.open();
		} catch (IOException ex) {
			throw new RuntimeException("Error opening selector.", ex);
		}
	}

	public Serialization getSerialization () {
		return serialization;
	}

	public Kryo getKryo () {
		return ((KryoSerialization)serialization).getKryo();
	}

	/** Opens a TCP only client.
	 * @see #connect(int, InetAddress, int, int) */
	public void connect (int timeout, String host, int tcpPort) throws IOException {
		connect(timeout, InetAddress.getByName(host), tcpPort, -1);
	}

	/** Opens a TCP and UDP client.
	 * @see #connect(int, InetAddress, int, int) */
	public void connect (int timeout, String host, int tcpPort, int udpPort) throws IOException {
		connect(timeout, InetAddress.getByName(host), tcpPort, udpPort);
	}

	/** Opens a TCP only client.
	 * @see #connect(int, InetAddress, int, int) */
	public void connect (int timeout, InetAddress host, int tcpPort) throws IOException {
		connect(timeout, host, tcpPort, -1);
	}

	/** Opens a TCP and UDP client. Blocks until the connection is complete or the timeout is reached.
	 * <p>
	 * Because the framework must perform some minimal communication before the connection is considered successful,
	 * {@link #update(int)} must be called on a separate thread during the connection process.
	 * @throws IllegalStateException if called from the connection's update thread.
	 * @throws IOException if the client could not be opened or connecting times out. */
	public void connect (int timeout, InetAddress host, int tcpPort, int udpPort) throws IOException {
		if (host == null) throw new IllegalArgumentException("host cannot be null.");
		if (Thread.currentThread() == getUpdateThread())
			throw new IllegalStateException("Cannot connect on the connection's update thread.");
		this.connectTimeout = timeout;
		this.connectHost = host;
		this.connectTcpPort = tcpPort;
		this.connectUdpPort = udpPort;
		close();
		if (INFO) {
			if (udpPort != -1)
				info("Connecting: " + host + ":" + tcpPort + "/" + udpPort);
			else
				info("Connecting: " + host + ":" + tcpPort);
		}
		id = -1;
		try {
			if (udpPort != -1) udp = new UdpConnection(serialization, tcp.readBuffer.capacity());

			long endTime;
			synchronized (updateLock) {
				tcpRegistered = false;
				selector.wakeup();
				endTime = System.currentTimeMillis() + timeout;
				tcp.connect(selector, new InetSocketAddress(host, tcpPort), 5000);
			}

			// Wait for RegisterTCP.
			synchronized (tcpRegistrationLock) {
				while (!tcpRegistered && System.currentTimeMillis() < endTime) {
					try {
						tcpRegistrationLock.wait(100);
					} catch (InterruptedException ignored) {
					}
				}
				if (!tcpRegistered) {
					throw new SocketTimeoutException("Connected, but timed out during TCP registration.\n"
						+ "Note: Client#update must be called in a separate thread during connect.");
				}
			}

			if (udpPort != -1) {
				InetSocketAddress udpAddress = new InetSocketAddress(host, udpPort);
				synchronized (updateLock) {
					udpRegistered = false;
					selector.wakeup();
					udp.connect(selector, udpAddress);
				}

				// Wait for RegisterUDP reply.
				synchronized (udpRegistrationLock) {
					while (!udpRegistered && System.currentTimeMillis() < endTime) {
						RegisterUDP registerUDP = new RegisterUDP();
						registerUDP.connectionID = id;
						udp.send(this, registerUDP, udpAddress);
						try {
							udpRegistrationLock.wait(100);
						} catch (InterruptedException ignored) {
						}
					}
					if (!udpRegistered)
						throw new SocketTimeoutException("Connected, but timed out during UDP registration: " + host + ":" + udpPort);
				}
			}
		} catch (IOException ex) {
			close();
			throw ex;
		}
	}

	/** Calls {@link #connect(int, InetAddress, int) connect} with the values last passed to connect.
	 * @throws IllegalStateException if connect has never been called. */
	public void reconnect () throws IOException {
		reconnect(connectTimeout);
	}

	/** Calls {@link #connect(int, InetAddress, int) connect} with the specified timeout and the other values last passed to
	 * connect.
	 * @throws IllegalStateException if connect has never been called. */
	public void reconnect (int timeout) throws IOException {
		if (connectHost == null) throw new IllegalStateException("This client has never been connected.");
		connect(connectTimeout, connectHost, connectTcpPort, connectUdpPort);
	}

	/** Reads or writes any pending data for this client. Multiple threads should not call this method at the same time.
	 * @param timeout Wait for up to the specified milliseconds for data to be ready to process. May be zero to return immediately
	 *           if there is no data to process. */
	public void update (int timeout) throws IOException {
		updateThread = Thread.currentThread();
		synchronized (updateLock) { // Blocks to avoid a select while the selector is used to bind the server connection.
		}
		long startTime = System.currentTimeMillis();
		int select = 0;
		if (timeout > 0) {
			select = selector.select(timeout);
		} else {
			select = selector.selectNow();
		}
		if (select == 0) {
			emptySelects++;
			if (emptySelects == 100) {
				emptySelects = 0;
				// NIO freaks and returns immediately with 0 sometimes, so try to keep from hogging the CPU.
				long elapsedTime = System.currentTimeMillis() - startTime;
				try {
					if (elapsedTime < 25) Thread.sleep(25 - elapsedTime);
				} catch (InterruptedException ex) {
				}
			}
		} else {
			emptySelects = 0;
			isClosed = false;
			Set<SelectionKey> keys = selector.selectedKeys();
			synchronized (keys) {
				for (Iterator<SelectionKey> iter = keys.iterator(); iter.hasNext();) {
					SelectionKey selectionKey = iter.next();
					iter.remove();
					try {
						int ops = selectionKey.readyOps();
						if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {
							if (selectionKey.attachment() == tcp) {
								while (true) {
									Object object = tcp.readObject(this);
									if (object == null) break;
									if (!tcpRegistered) {
										if (object instanceof RegisterTCP) {
											id = ((RegisterTCP)object).connectionID;
											synchronized (tcpRegistrationLock) {
												tcpRegistered = true;
												tcpRegistrationLock.notifyAll();
												if (TRACE) trace("kryonet", this + " received TCP: RegisterTCP");
												if (udp == null) setConnected(true);
											}
											if (udp == null) notifyConnected();
										}
										continue;
									}
									if (udp != null && !udpRegistered) {
										if (object instanceof RegisterUDP) {
											synchronized (udpRegistrationLock) {
												udpRegistered = true;
												udpRegistrationLock.notifyAll();
												if (TRACE) trace("kryonet", this + " received UDP: RegisterUDP");
												if (DEBUG) {
													debug("kryonet", "Port " + udp.datagramChannel.socket().getLocalPort()
														+ "/UDP connected to: " + udp.connectedAddress);
												}
												setConnected(true);
											}
											notifyConnected();
										}
										continue;
									}
									if (!isConnected) continue;
									keepAlive();
									if (DEBUG) {
										String objectString = object == null ? "null" : object.getClass().getSimpleName();
										if (!(object instanceof FrameworkMessage)) {
											debug("kryonet", this + " received TCP: " + objectString);
										} else if (TRACE) {
											trace("kryonet", this + " received TCP: " + objectString);
										}
									}
									notifyReceived(object);
								}
							} else {
								if (udp.readFromAddress() == null) continue;
								Object object = udp.readObject(this);
								if (object == null) continue;
								keepAlive();
								if (DEBUG) {
									String objectString = object == null ? "null" : object.getClass().getSimpleName();
									debug("kryonet", this + " received UDP: " + objectString);
								}
								notifyReceived(object);
							}
						}
						if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) tcp.writeOperation();
					} catch (CancelledKeyException ignored) {
						// Connection is closed.
					}
				}
			}
		}
		if (isConnected) {
			long time = System.currentTimeMillis();
			if (tcp.isTimedOut(time)) {
				if (DEBUG) debug("kryonet", this + " timed out.");
				close();
			} else {
				keepAlive();
			}
			if (isIdle()) notifyIdle();
		}
	}

	void keepAlive () {
		if (!isConnected) return;
		long time = System.currentTimeMillis();
		if (tcp.needsKeepAlive(time)) sendTCP(FrameworkMessage.keepAlive);
		if (udp != null && udpRegistered && udp.needsKeepAlive(time)) sendUDP(FrameworkMessage.keepAlive);
	}

	public void run () {
		if (TRACE) trace("kryonet", "Client thread started.");
		shutdown = false;
		while (!shutdown) {
			try {
				update(250);
			} catch (IOException ex) {
				if (TRACE) {
					if (isConnected)
						trace("kryonet", "Unable to update connection: " + this, ex);
					else
						trace("kryonet", "Unable to update connection.", ex);
				} else if (DEBUG) {
					if (isConnected)
						debug("kryonet", this + " update: " + ex.getMessage());
					else
						debug("kryonet", "Unable to update connection: " + ex.getMessage());
				}
				close();
			} catch (KryoNetException ex) {
				if (ERROR) {
					if (isConnected)
						error("kryonet", "Error updating connection: " + this, ex);
					else
						error("kryonet", "Error updating connection.", ex);
				}
				close();
				throw ex;
			}
		}
		if (TRACE) trace("kryonet", "Client thread stopped.");
	}

	public void start () {
		// Try to let any previous update thread stop.
		if (updateThread != null) {
			shutdown = true;
			try {
				updateThread.join(5000);
			} catch (InterruptedException ignored) {
			}
		}
		updateThread = new Thread(this, "Client");
		updateThread.setDaemon(true);
		updateThread.start();
	}

	public void stop () {
		if (shutdown) return;
		close();
		if (TRACE) trace("kryonet", "Client thread stopping.");
		shutdown = true;
		selector.wakeup();
	}

	public void close () {
		super.close();
		// Select one last time to complete closing the socket.
		synchronized (updateLock) {
			if (!isClosed) {
				isClosed = true;
				selector.wakeup();
				try {
					selector.selectNow();
				} catch (IOException ignored) {
				}
			}
		}
	}

	public void addListener (Listener listener) {
		super.addListener(listener);
		if (TRACE) trace("kryonet", "Client listener added.");
	}

	public void removeListener (Listener listener) {
		super.removeListener(listener);
		if (TRACE) trace("kryonet", "Client listener removed.");
	}

	/** An empty object will be sent if the UDP connection is inactive more than the specified milliseconds. Network hardware may
	 * keep a translation table of inside to outside IP addresses and a UDP keep alive keeps this table entry from expiring. Set to
	 * zero to disable. Defaults to 19000. */
	public void setKeepAliveUDP (int keepAliveMillis) {
		if (udp == null) throw new IllegalStateException("Not connected via UDP.");
		udp.keepAliveMillis = keepAliveMillis;
	}

	public Thread getUpdateThread () {
		return updateThread;
	}

	private void broadcast (int udpPort, DatagramSocket socket) throws IOException {
		ByteBuffer dataBuffer = ByteBuffer.allocate(64);
		serialization.write(null, dataBuffer, new DiscoverHost());
		dataBuffer.flip();
		byte[] data = new byte[dataBuffer.limit()];
		dataBuffer.get(data);
		for (NetworkInterface iface : Collections.list(NetworkInterface.getNetworkInterfaces())) {
			for (InetAddress address : Collections.list(iface.getInetAddresses())) {
				// Java 1.5 doesn't support getting the subnet mask, so try the two most common.
				byte[] ip = address.getAddress();
				ip[3] = -1; // 255.255.255.0
				try {
					socket.send(new DatagramPacket(data, data.length, InetAddress.getByAddress(ip), udpPort));
				} catch (Exception ignored) {
				}
				ip[2] = -1; // 255.255.0.0
				try {
					socket.send(new DatagramPacket(data, data.length, InetAddress.getByAddress(ip), udpPort));
				} catch (Exception ignored) {
				}
			}
		}
		if (DEBUG) debug("kryonet", "Broadcasted host discovery on port: " + udpPort);
	}

	/** Broadcasts a UDP message on the LAN to discover any running servers. The address of the first server to respond is returned.
	 * @param udpPort The UDP port of the server.
	 * @param timeoutMillis The number of milliseconds to wait for a response.
	 * @return the first server found, or null if no server responded. */
	public InetAddress discoverHost (int udpPort, int timeoutMillis) {
		DatagramSocket socket = null;
		try {
			socket = new DatagramSocket();
			broadcast(udpPort, socket);
			socket.setSoTimeout(timeoutMillis);
			DatagramPacket packet = new DatagramPacket(new byte[0], 0);
			try {
				socket.receive(packet);
			} catch (SocketTimeoutException ex) {
				if (INFO) info("kryonet", "Host discovery timed out.");
				return null;
			}
			if (INFO) info("kryonet", "Discovered server: " + packet.getAddress());
			return packet.getAddress();
		} catch (IOException ex) {
			if (ERROR) error("kryonet", "Host discovery failed.", ex);
			return null;
		} finally {
			if (socket != null) socket.close();
		}
	}

	/** Broadcasts a UDP message on the LAN to discover any running servers.
	 * @param udpPort The UDP port of the server.
	 * @param timeoutMillis The number of milliseconds to wait for a response. */
	public List<InetAddress> discoverHosts (int udpPort, int timeoutMillis) {
		List<InetAddress> hosts = new ArrayList<InetAddress>();
		DatagramSocket socket = null;
		try {
			socket = new DatagramSocket();
			broadcast(udpPort, socket);
			socket.setSoTimeout(timeoutMillis);
			while (true) {
				DatagramPacket packet = new DatagramPacket(new byte[0], 0);
				try {
					socket.receive(packet);
				} catch (SocketTimeoutException ex) {
					if (INFO) info("kryonet", "Host discovery timed out.");
					return hosts;
				}
				if (INFO) info("kryonet", "Discovered server: " + packet.getAddress());
				hosts.add(packet.getAddress());
			}
		} catch (IOException ex) {
			if (ERROR) error("kryonet", "Host discovery failed.", ex);
			return hosts;
		} finally {
			if (socket != null) socket.close();
		}
	}
}


package com.esotericsoftware.kryonet;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.channels.SocketChannel;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryonet.FrameworkMessage.Ping;

import static com.esotericsoftware.minlog.Log.*;

// BOZO - Layer to handle handshake state.

/** Represents a TCP and optionally a UDP connection between a {@link Client} and a {@link Server}. If either underlying connection
 * is closed or errors, both connections are closed.
 * @author Nathan Sweet <misc@n4te.com> */
public class Connection {
	int id = -1;
	private String name;
	EndPoint endPoint;
	TcpConnection tcp;
	UdpConnection udp;
	InetSocketAddress udpRemoteAddress;
	private Listener[] listeners = {};
	private Object listenerLock = new Object();
	private int lastPingID;
	private long lastPingSendTime;
	private int returnTripTime;
	volatile boolean isConnected;

	protected Connection () {
	}

	void initialize (Serialization serialization, int writeBufferSize, int objectBufferSize) {
		tcp = new TcpConnection(serialization, writeBufferSize, objectBufferSize);
	}

	/** Returns the server assigned ID. Will return -1 if this connection has never been connected or the last assigned ID if this
	 * connection has been disconnected. */
	public int getID () {
		return id;
	}

	/** Returns true if this connection is connected to the remote end. Note that a connection can become disconnected at any time. */
	public boolean isConnected () {
		return isConnected;
	}

	/** Sends the object over the network using TCP.
	 * @return The number of bytes sent.
	 * @see Kryo#register(Class, com.esotericsoftware.kryo.Serializer) */
	public int sendTCP (Object object) {
		if (object == null) throw new IllegalArgumentException("object cannot be null.");
		try {
			int length = tcp.send(this, object);
			if (length == 0) {
				if (TRACE) trace("kryonet", this + " TCP had nothing to send.");
			} else if (DEBUG) {
				String objectString = object == null ? "null" : object.getClass().getSimpleName();
				if (!(object instanceof FrameworkMessage)) {
					debug("kryonet", this + " sent TCP: " + objectString + " (" + length + ")");
				} else if (TRACE) {
					trace("kryonet", this + " sent TCP: " + objectString + " (" + length + ")");
				}
			}
			return length;
		} catch (IOException ex) {
			if (DEBUG) debug("kryonet", "Unable to send TCP with connection: " + this, ex);
			close();
			return 0;
		} catch (KryoNetException ex) {
			if (ERROR) error("kryonet", "Unable to send TCP with connection: " + this, ex);
			close();
			return 0;
		}
	}

	/** Sends the object over the network using UDP.
	 * @return The number of bytes sent.
	 * @see Kryo#register(Class, com.esotericsoftware.kryo.Serializer)
	 * @throws IllegalStateException if this connection was not opened with both TCP and UDP. */
	public int sendUDP (Object object) {
		if (object == null) throw new IllegalArgumentException("object cannot be null.");
		SocketAddress address = udpRemoteAddress;
		if (address == null && udp != null) address = udp.connectedAddress;
		if (address == null && isConnected) throw new IllegalStateException("Connection is not connected via UDP.");

		try {
			if (address == null) throw new SocketException("Connection is closed.");

			int length = udp.send(this, object, address);
			if (length == 0) {
				if (TRACE) trace("kryonet", this + " UDP had nothing to send.");
			} else if (DEBUG) {
				if (length != -1) {
					String objectString = object == null ? "null" : object.getClass().getSimpleName();
					if (!(object instanceof FrameworkMessage)) {
						debug("kryonet", this + " sent UDP: " + objectString + " (" + length + ")");
					} else if (TRACE) {
						trace("kryonet", this + " sent UDP: " + objectString + " (" + length + ")");
					}
				} else
					debug("kryonet", this + " was unable to send, UDP socket buffer full.");
			}
			return length;
		} catch (IOException ex) {
			if (DEBUG) debug("kryonet", "Unable to send UDP with connection: " + this, ex);
			close();
			return 0;
		} catch (KryoNetException ex) {
			if (ERROR) error("kryonet", "Unable to send UDP with connection: " + this, ex);
			close();
			return 0;
		}
	}

	public void close () {
		boolean wasConnected = isConnected;
		isConnected = false;
		tcp.close();
		if (udp != null && udp.connectedAddress != null) udp.close();
		if (wasConnected) {
			notifyDisconnected();
			if (INFO) info("kryonet", this + " disconnected.");
		}
		setConnected(false);
	}

	/** Requests the connection to communicate with the remote computer to determine a new value for the
	 * {@link #getReturnTripTime() return trip time}. When the connection receives a {@link FrameworkMessage.Ping} object with
	 * {@link Ping#isReply isReply} set to true, the new return trip time is available. */
	public void updateReturnTripTime () {
		Ping ping = new Ping();
		ping.id = lastPingID++;
		lastPingSendTime = System.currentTimeMillis();
		sendTCP(ping);
	}

	/** Returns the last calculated TCP return trip time, or -1 if {@link #updateReturnTripTime()} has never been called or the
	 * {@link FrameworkMessage.Ping} response has not yet been received. */
	public int getReturnTripTime () {
		return returnTripTime;
	}

	/** An empty object will be sent if the TCP connection has not sent an object within the specified milliseconds. Periodically
	 * sending a keep alive ensures that an abnormal close is detected in a reasonable amount of time (see {@link #setTimeout(int)}
	 * ). Also, some network hardware will close a TCP connection that ceases to transmit for a period of time (typically 1+
	 * minutes). Set to zero to disable. Defaults to 8000. */
	public void setKeepAliveTCP (int keepAliveMillis) {
		tcp.keepAliveMillis = keepAliveMillis;
	}

	/** If the specified amount of time passes without receiving an object over TCP, the connection is considered closed. When a TCP
	 * socket is closed normally, the remote end is notified immediately and this timeout is not needed. However, if a socket is
	 * closed abnormally (eg, power loss), KryoNet uses this timeout to detect the problem. The timeout should be set higher than
	 * the {@link #setKeepAliveTCP(int) TCP keep alive} for the remote end of the connection. The keep alive ensures that the remote
	 * end of the connection will be constantly sending objects, and setting the timeout higher than the keep alive allows for
	 * network latency. Set to zero to disable. Defaults to 12000. */
	public void setTimeout (int timeoutMillis) {
		tcp.timeoutMillis = timeoutMillis;
	}

	/** If the listener already exists, it is not added again. */
	public void addListener (Listener listener) {
		if (listener == null) throw new IllegalArgumentException("listener cannot be null.");
		synchronized (listenerLock) {
			Listener[] listeners = this.listeners;
			int n = listeners.length;
			for (int i = 0; i < n; i++)
				if (listener == listeners[i]) return;
			Listener[] newListeners = new Listener[n + 1];
			newListeners[0] = listener;
			System.arraycopy(listeners, 0, newListeners, 1, n);
			this.listeners = newListeners;
		}
		if (TRACE) trace("kryonet", "Connection listener added: " + listener.getClass().getName());
	}

	public void removeListener (Listener listener) {
		if (listener == null) throw new IllegalArgumentException("listener cannot be null.");
		synchronized (listenerLock) {
			Listener[] listeners = this.listeners;
			int n = listeners.length;
			if (n == 0) return;
			Listener[] newListeners = new Listener[n - 1];
			for (int i = 0, ii = 0; i < n; i++) {
				Listener copyListener = listeners[i];
				if (listener == copyListener) continue;
				if (ii == n - 1) return;
				newListeners[ii++] = copyListener;
			}
			this.listeners = newListeners;
		}
		if (TRACE) trace("kryonet", "Connection listener removed: " + listener.getClass().getName());
	}

	void notifyConnected () {
		if (INFO) {
			SocketChannel socketChannel = tcp.socketChannel;
			if (socketChannel != null) {
				Socket socket = tcp.socketChannel.socket();
				if (socket != null) {
					InetSocketAddress remoteSocketAddress = (InetSocketAddress)socket.getRemoteSocketAddress();
					if (remoteSocketAddress != null) info("kryonet", this + " connected: " + remoteSocketAddress.getAddress());
				}
			}
		}
		Listener[] listeners = this.listeners;
		for (int i = 0, n = listeners.length; i < n; i++)
			listeners[i].connected(this);
	}

	void notifyDisconnected () {
		Listener[] listeners = this.listeners;
		for (int i = 0, n = listeners.length; i < n; i++)
			listeners[i].disconnected(this);
	}

	void notifyIdle () {
		Listener[] listeners = this.listeners;
		for (int i = 0, n = listeners.length; i < n; i++) {
			listeners[i].idle(this);
			if (!isIdle()) break;
		}
	}

	void notifyReceived (Object object) {
		if (object instanceof Ping) {
			Ping ping = (Ping)object;
			if (ping.isReply) {
				if (ping.id == lastPingID - 1) {
					returnTripTime = (int)(System.currentTimeMillis() - lastPingSendTime);
					if (TRACE) trace("kryonet", this + " return trip time: " + returnTripTime);
				}
			} else {
				ping.isReply = true;
				sendTCP(ping);
			}
		}
		Listener[] listeners = this.listeners;
		for (int i = 0, n = listeners.length; i < n; i++)
			listeners[i].received(this, object);
	}

	/** Returns the local {@link Client} or {@link Server} to which this connection belongs. */
	public EndPoint getEndPoint () {
		return endPoint;
	}

	/** Returns the IP address and port of the remote end of the TCP connection, or null if this connection is not connected. */
	public InetSocketAddress getRemoteAddressTCP () {
		SocketChannel socketChannel = tcp.socketChannel;
		if (socketChannel != null) {
			Socket socket = tcp.socketChannel.socket();
			if (socket != null) {
				return (InetSocketAddress)socket.getRemoteSocketAddress();
			}
		}
		return null;
	}

	/** Returns the IP address and port of the remote end of the UDP connection, or null if this connection is not connected. */
	public InetSocketAddress getRemoteAddressUDP () {
		InetSocketAddress connectedAddress = udp.connectedAddress;
		if (connectedAddress != null) return connectedAddress;
		return udpRemoteAddress;
	}

	/** Workaround for broken NIO networking on Android 1.6. If true, the underlying NIO buffer is always copied to the beginning of
	 * the buffer before being given to the SocketChannel for sending. The Harmony SocketChannel implementation in Android 1.6
	 * ignores the buffer position, always copying from the beginning of the buffer. This is fixed in Android 2.0+. */
	public void setBufferPositionFix (boolean bufferPositionFix) {
		tcp.bufferPositionFix = bufferPositionFix;
	}

	/** Sets the friendly name of this connection. This is returned by {@link #toString()} and is useful for providing application
	 * specific identifying information in the logging. May be null for the default name of "Connection X", where X is the
	 * connection ID. */
	public void setName (String name) {
		this.name = name;
	}

	/** Returns the number of bytes that are waiting to be written to the TCP socket, if any. */
	public int getTcpWriteBufferSize () {
		return tcp.writeBuffer.position();
	}

	/** @see #setIdleThreshold(float) */
	public boolean isIdle () {
		return tcp.writeBuffer.position() / (float)tcp.writeBuffer.capacity() < tcp.idleThreshold;
	}

	/** If the percent of the TCP write buffer that is filled is less than the specified threshold,
	 * {@link Listener#idle(Connection)} will be called for each network thread update. Default is 0.1. */
	public void setIdleThreshold (float idleThreshold) {
		tcp.idleThreshold = idleThreshold;
	}

	public String toString () {
		if (name != null) return name;
		return "Connection " + id;
	}

	void setConnected (boolean isConnected) {
		this.isConnected = isConnected;
		if (isConnected && name == null) name = "Connection " + id;
	}
}


package com.esotericsoftware.kryonet;

import java.io.IOException;

import com.esotericsoftware.kryo.Kryo;

/** Represents the local end point of a connection.
 * @author Nathan Sweet <misc@n4te.com> */
public interface EndPoint extends Runnable {
	/** Gets the serialization instance that will be used to serialize and deserialize objects. */
	public Serialization getSerialization ();

	/** If the listener already exists, it is not added again. */
	public void addListener (Listener listener);

	public void removeListener (Listener listener);

	/** Continually updates this end point until {@link #stop()} is called. */
	public void run ();

	/** Starts a new thread that calls {@link #run()}. */
	public void start ();

	/** Closes this end point and causes {@link #run()} to return. */
	public void stop ();

	/** @see Client
	 * @see Server */
	public void close ();

	/** @see Client#update(int)
	 * @see Server#update(int) */
	public void update (int timeout) throws IOException;

	/** Returns the last thread that called {@link #update(int)} for this end point. This can be useful to detect when long running
	 * code will be run on the update thread. */
	public Thread getUpdateThread ();

	/** Gets the Kryo instance that will be used to serialize and deserialize objects. This is only valid if
	 * {@link KryoSerialization} is being used, which is the default. */
	public Kryo getKryo ();
}


package com.esotericsoftware.kryonet;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import com.esotericsoftware.minlog.Log;

/** Marker interface to denote that a message is used by the Ninja framework and is generally invisible to the developer. Eg, these
 * messages are only logged at the {@link Log#LEVEL_TRACE} level.
 * @author Nathan Sweet <misc@n4te.com> */
public interface FrameworkMessage {
	static final FrameworkMessage.KeepAlive keepAlive = new KeepAlive();

	/** Internal message to give the client the server assigned connection ID. */
	static public class RegisterTCP implements FrameworkMessage {
		public int connectionID;

		public static class Serializer extends com.esotericsoftware.kryo.Serializer<RegisterTCP>
		{
			@Override
			public void write(Kryo kryo, Output output, RegisterTCP packet)
			{
				output.writeInt(packet.connectionID);
			}

			@Override
			public RegisterTCP read(Kryo kryo, Input input, Class<RegisterTCP> aClass)
			{
				RegisterTCP packet = new RegisterTCP();
				packet.connectionID = input.readInt();
				return packet;
			}
		}
	}

	/** Internal message to give the server the client's UDP port. */
	static public class RegisterUDP implements FrameworkMessage {
		public int connectionID;

		public static class Serializer extends com.esotericsoftware.kryo.Serializer<RegisterUDP>
		{
			@Override
			public void write(Kryo kryo, Output output, RegisterUDP packet)
			{
				output.writeInt(packet.connectionID);
			}

			@Override
			public RegisterUDP read(Kryo kryo, Input input, Class<RegisterUDP> aClass)
			{
				RegisterUDP packet = new RegisterUDP();
				packet.connectionID = input.readInt();
				return packet;
			}
		}
	}

	/** Internal message to keep connections alive. */
	static public class KeepAlive implements FrameworkMessage {
		public static class Serializer extends com.esotericsoftware.kryo.Serializer<KeepAlive>
		{
			@Override
			public void write(Kryo kryo, Output output, KeepAlive s2CUpdateReq)
			{

			}

			@Override
			public KeepAlive read(Kryo kryo, Input input, Class<KeepAlive> aClass)
			{
				return new KeepAlive();
			}
		}
	}

	/** Internal message to discover running servers. */
	static public class DiscoverHost implements FrameworkMessage {
		public static class Serializer extends com.esotericsoftware.kryo.Serializer<DiscoverHost>
		{
			@Override
			public void write(Kryo kryo, Output output, DiscoverHost s2CUpdateReq)
			{

			}

			@Override
			public DiscoverHost read(Kryo kryo, Input input, Class<DiscoverHost> aClass)
			{
				return new DiscoverHost();
			}
		}
	}

	/** Internal message to determine round trip time. */
	static public class Ping implements FrameworkMessage {
		public int id;
		public boolean isReply;

		public static class Serializer extends com.esotericsoftware.kryo.Serializer<Ping>
		{
			@Override
			public void write(Kryo kryo, Output output, Ping packet)
			{
				output.writeInt(packet.id);
				output.writeBoolean(packet.isReply);
			}

			@Override
			public Ping read(Kryo kryo, Input input, Class<Ping> aClass)
			{
				Ping packet = new Ping();
				packet.id = input.readInt();
				packet.isReply = input.readBoolean();
				return packet;
			}
		}
	}
}


package com.esotericsoftware.kryonet;

public class KryoNetException extends RuntimeException {
	public KryoNetException () {
		super();
	}

	public KryoNetException (String message, Throwable cause) {
		super(message, cause);
	}

	public KryoNetException (String message) {
		super(message);
	}

	public KryoNetException (Throwable cause) {
		super(cause);
	}
}


package com.esotericsoftware.kryonet;

import java.io.IOException;
import java.nio.ByteBuffer;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.ByteBufferInputStream;
import com.esotericsoftware.kryo.io.ByteBufferOutputStream;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import com.esotericsoftware.kryonet.FrameworkMessage.DiscoverHost;
import com.esotericsoftware.kryonet.FrameworkMessage.KeepAlive;
import com.esotericsoftware.kryonet.FrameworkMessage.Ping;
import com.esotericsoftware.kryonet.FrameworkMessage.RegisterTCP;
import com.esotericsoftware.kryonet.FrameworkMessage.RegisterUDP;

public class KryoSerialization implements Serialization {
	private final Kryo kryo;
	private final Input input;
	private final Output output;
	private final ByteBufferInputStream byteBufferInputStream = new ByteBufferInputStream();
	private final ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream();

	public KryoSerialization () {
		this(new Kryo());
	}

	public KryoSerialization (Kryo kryo) {
		this.kryo = kryo;

		kryo.register(RegisterTCP.class, new RegisterTCP.Serializer());
		kryo.register(RegisterUDP.class, new RegisterUDP.Serializer());
		kryo.register(KeepAlive.class, new KeepAlive.Serializer());
		kryo.register(DiscoverHost.class, new DiscoverHost.Serializer());
		kryo.register(Ping.class, new Ping.Serializer());

		input = new Input(byteBufferInputStream, 512);
		output = new Output(byteBufferOutputStream, 512);
	}

	public Kryo getKryo () {
		return kryo;
	}

	public synchronized void write (Connection connection, ByteBuffer buffer, Object object) throws IOException
	{
		byteBufferOutputStream.setByteBuffer(buffer);
		kryo.writeClassAndObject(output, object);
		output.flush();
	}

	public synchronized Object read (Connection connection, ByteBuffer buffer) {
		byteBufferInputStream.setByteBuffer(buffer);
		input.setInputStream(byteBufferInputStream);
		return kryo.readClassAndObject(input);
	}

	public void writeLength (ByteBuffer buffer, int length) {
		buffer.putInt(length);
	}

	public int readLength (ByteBuffer buffer) {
		return buffer.getInt();
	}

	public int getLengthLength () {
		return 4;
	}
}


package com.esotericsoftware.kryonet;

import java.util.LinkedList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/** Used to be notified about connection events. */
public class Listener {
	/** Called when the remote end has been connected. This will be invoked before any objects are received by
	 * {@link #received(Connection, Object)}. This will be invoked on the same thread as {@link Client#update(int)} and
	 * {@link Server#update(int)}. This method should not block for long periods as other network activity will not be processed
	 * until it returns. */
	public void connected (Connection connection) {
	}

	/** Called when the remote end is no longer connected. There is no guarantee as to what thread will invoke this method. */
	public void disconnected (Connection connection) {
	}

	/** Called when an object has been received from the remote end of the connection. This will be invoked on the same thread as
	 * {@link Client#update(int)} and {@link Server#update(int)}. This method should not block for long periods as other network
	 * activity will not be processed until it returns. */
	public void received (Connection connection, Object object) {
	}

	/** Called when the connection is below the {@link Connection#setIdleThreshold(float) idle threshold}. */
	public void idle (Connection connection) {
	}

	/** Wraps a listener and queues notifications as {@link Runnable runnables}. This allows the runnables to be processed on a
	 * different thread, preventing the connection's update thread from being blocked. */
	static public abstract class QueuedListener extends Listener {
		final Listener listener;

		public QueuedListener (Listener listener) {
			if (listener == null) throw new IllegalArgumentException("listener cannot be null.");
			this.listener = listener;
		}

		public void connected (final Connection connection) {
			queue(new Runnable() {
				public void run () {
					listener.connected(connection);
				}
			});
		}

		public void disconnected (final Connection connection) {
			queue(new Runnable() {
				public void run () {
					listener.disconnected(connection);
				}
			});
		}

		public void received (final Connection connection, final Object object) {
			queue(new Runnable() {
				public void run () {
					listener.received(connection, object);
				}
			});
		}

		public void idle (final Connection connection) {
			queue(new Runnable() {
				public void run () {
					listener.idle(connection);
				}
			});
		}

		abstract protected void queue (Runnable runnable);
	}

	/** Wraps a listener and processes notification events on a separate thread. */
	static public class ThreadedListener extends QueuedListener {
		protected final ExecutorService threadPool;

		/** Creates a single thread to process notification events. */
		public ThreadedListener (Listener listener) {
			this(listener, Executors.newFixedThreadPool(1));
		}

		/** Uses the specified threadPool to process notification events. */
		public ThreadedListener (Listener listener, ExecutorService threadPool) {
			super(listener);
			if (threadPool == null) throw new IllegalArgumentException("threadPool cannot be null.");
			this.threadPool = threadPool;
		}

		public void queue (Runnable runnable) {
			threadPool.execute(runnable);
		}
	}

	/** Delays the notification of the wrapped listener to simulate lag on incoming objects. Notification events are processed on a
	 * separate thread after a delay. Note that only incoming objects are delayed. To delay outgoing objects, use a LagListener at
	 * the other end of the connection. */
	static public class LagListener extends QueuedListener {
		private final ScheduledExecutorService threadPool;
		private final int lagMillisMin, lagMillisMax;
		final LinkedList<Runnable> runnables = new LinkedList();

		public LagListener (int lagMillisMin, int lagMillisMax, Listener listener) {
			super(listener);
			this.lagMillisMin = lagMillisMin;
			this.lagMillisMax = lagMillisMax;
			threadPool = Executors.newScheduledThreadPool(1);
		}

		public void queue (Runnable runnable) {
			synchronized (runnables) {
				runnables.addFirst(runnable);
			}
			int lag = lagMillisMin + (int)(Math.random() * (lagMillisMax - lagMillisMin));
			threadPool.schedule(new Runnable() {
				public void run () {
					Runnable runnable;
					synchronized (runnables) {
						runnable = runnables.removeLast();
					}
					runnable.run();
				}
			}, lag, TimeUnit.MILLISECONDS);
		}
	}
}


package com.esotericsoftware.kryonet;

import java.io.IOException;
import java.nio.ByteBuffer;

/** Controls how objects are transmitted over the network. */
public interface Serialization {
	/** @param connection May be null. */
	public void write (Connection connection, ByteBuffer buffer, Object object) throws IOException;

	public Object read (Connection connection, ByteBuffer buffer);

	/** The fixed number of bytes that will be written by {@link #writeLength(ByteBuffer, int)} and read by
	 * {@link #readLength(ByteBuffer)}. */
	public int getLengthLength ();

	public void writeLength (ByteBuffer buffer, int length);

	public int readLength (ByteBuffer buffer);
}


package com.esotericsoftware.kryonet;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.CancelledKeyException;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Set;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.util.IntMap;
import com.esotericsoftware.kryonet.FrameworkMessage.DiscoverHost;
import com.esotericsoftware.kryonet.FrameworkMessage.RegisterTCP;
import com.esotericsoftware.kryonet.FrameworkMessage.RegisterUDP;

import static com.esotericsoftware.minlog.Log.*;

/** Manages TCP and optionally UDP connections from many {@link Client Clients}.
 * @author Nathan Sweet <misc@n4te.com> */
public class Server implements EndPoint {
	private final Serialization serialization;
	private final int writeBufferSize, objectBufferSize;
	private final Selector selector;
	private int emptySelects;
	private ServerSocketChannel serverChannel;
	private UdpConnection udp;
	private Connection[] connections = {};
	private IntMap<Connection> pendingConnections = new IntMap();
	Listener[] listeners = {};
	private Object listenerLock = new Object();
	private int nextConnectionID = 1;
	private volatile boolean shutdown;
	private Object updateLock = new Object();
	private Thread updateThread;
	private ByteBuffer emptyBuffer = ByteBuffer.allocate(0);

	private Listener dispatchListener = new Listener() {
		public void connected (Connection connection) {
			Listener[] listeners = Server.this.listeners;
			for (int i = 0, n = listeners.length; i < n; i++)
				listeners[i].connected(connection);
		}

		public void disconnected (Connection connection) {
			removeConnection(connection);
			Listener[] listeners = Server.this.listeners;
			for (int i = 0, n = listeners.length; i < n; i++)
				listeners[i].disconnected(connection);
		}

		public void received (Connection connection, Object object) {
			Listener[] listeners = Server.this.listeners;
			for (int i = 0, n = listeners.length; i < n; i++)
				listeners[i].received(connection, object);
		}

		public void idle (Connection connection) {
			Listener[] listeners = Server.this.listeners;
			for (int i = 0, n = listeners.length; i < n; i++)
				listeners[i].idle(connection);
		}
	};

	/** Creates a Server with a write buffer size of 16384 and an object buffer size of 2048. */
	public Server () {
		this(16384, 2048);
	}

	/** @param writeBufferSize One buffer of this size is allocated for each connected client. Objects are serialized to the write
	 *           buffer where the bytes are queued until they can be written to the TCP socket.
	 *           <p>
	 *           Normally the socket is writable and the bytes are written immediately. If the socket cannot be written to and
	 *           enough serialized objects are queued to overflow the buffer, then the connection will be closed.
	 *           <p>
	 *           The write buffer should be sized at least as large as the largest object that will be sent, plus some head room to
	 *           allow for some serialized objects to be queued in case the buffer is temporarily not writable. The amount of head
	 *           room needed is dependent upon the size of objects being sent and how often they are sent.
	 * @param objectBufferSize One (using only TCP) or three (using both TCP and UDP) buffers of this size are allocated. These
	 *           buffers are used to hold the bytes for a single object graph until it can be sent over the network or
	 *           deserialized.
	 *           <p>
	 *           The object buffers should be sized at least as large as the largest object that will be sent or received. */
	public Server (int writeBufferSize, int objectBufferSize) {
		this(writeBufferSize, objectBufferSize, new KryoSerialization());
	}

	public Server (int writeBufferSize, int objectBufferSize, Serialization serialization) {
		this.writeBufferSize = writeBufferSize;
		this.objectBufferSize = objectBufferSize;

		this.serialization = serialization;

		try {
			selector = Selector.open();
		} catch (IOException ex) {
			throw new RuntimeException("Error opening selector.", ex);
		}
	}

	public Serialization getSerialization () {
		return serialization;
	}

	public Kryo getKryo () {
		return ((KryoSerialization)serialization).getKryo();
	}

	/** Opens a TCP only server.
	 * @throws IOException if the server could not be opened. */
	public void bind (int tcpPort) throws IOException {
		bind(new InetSocketAddress(tcpPort), null);
	}

	/** Opens a TCP and UDP server.
	 * @throws IOException if the server could not be opened. */
	public void bind (int tcpPort, int udpPort) throws IOException {
		bind(new InetSocketAddress(tcpPort), new InetSocketAddress(udpPort));
	}

	/** @param udpPort May be null. */
	public void bind (InetSocketAddress tcpPort, InetSocketAddress udpPort) throws IOException {
		close();
		synchronized (updateLock) {
			selector.wakeup();
			try {
				serverChannel = selector.provider().openServerSocketChannel();
				serverChannel.socket().bind(tcpPort);
				serverChannel.configureBlocking(false);
				serverChannel.register(selector, SelectionKey.OP_ACCEPT);
				if (DEBUG) debug("kryonet", "Accepting connections on port: " + tcpPort + "/TCP");

				if (udpPort != null) {
					udp = new UdpConnection(serialization, objectBufferSize);
					udp.bind(selector, udpPort);
					if (DEBUG) debug("kryonet", "Accepting connections on port: " + udpPort + "/UDP");
				}
			} catch (IOException ex) {
				close();
				throw ex;
			}
		}
		if (INFO) info("kryonet", "Server opened.");
	}

	/** Accepts any new connections and reads or writes any pending data for the current connections.
	 * @param timeout Wait for up to the specified milliseconds for a connection to be ready to process. May be zero to return
	 *           immediately if there are no connections to process. */
	public void update (int timeout) throws IOException {
		updateThread = Thread.currentThread();
		synchronized (updateLock) { // Blocks to avoid a select while the selector is used to bind the server connection.
		}
		long startTime = System.currentTimeMillis();
		int select = 0;
		if (timeout > 0) {
			select = selector.select(timeout);
		} else {
			select = selector.selectNow();
		}
		if (select == 0) {
			emptySelects++;
			if (emptySelects == 100) {
				emptySelects = 0;
				// NIO freaks and returns immediately with 0 sometimes, so try to keep from hogging the CPU.
				long elapsedTime = System.currentTimeMillis() - startTime;
				try {
					if (elapsedTime < 25) Thread.sleep(25 - elapsedTime);
				} catch (InterruptedException ex) {
				}
			}
		} else {
			emptySelects = 0;
			Set<SelectionKey> keys = selector.selectedKeys();
			synchronized (keys) {
				UdpConnection udp = this.udp;
				outer:
				for (Iterator<SelectionKey> iter = keys.iterator(); iter.hasNext();) {
					SelectionKey selectionKey = iter.next();
					iter.remove();
					Connection fromConnection = (Connection)selectionKey.attachment();
					try {
						int ops = selectionKey.readyOps();

						if (fromConnection != null) { // Must be a TCP read or write operation.
							if (udp != null && fromConnection.udpRemoteAddress == null) {
								fromConnection.close();
								continue;
							}
							if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {
								try {
									while (true) {
										Object object = fromConnection.tcp.readObject(fromConnection);
										if (object == null) break;
										if (DEBUG) {
											String objectString = object == null ? "null" : object.getClass().getSimpleName();
											if (!(object instanceof FrameworkMessage)) {
												debug("kryonet", fromConnection + " received TCP: " + objectString);
											} else if (TRACE) {
												trace("kryonet", fromConnection + " received TCP: " + objectString);
											}
										}
										fromConnection.notifyReceived(object);
									}
								} catch (IOException ex) {
									if (TRACE) {
										trace("kryonet", "Unable to read TCP from: " + fromConnection, ex);
									} else if (DEBUG) {
										debug("kryonet", fromConnection + " update: " + ex.getMessage());
									}
									fromConnection.close();
								} catch (KryoNetException ex) {
									if (ERROR) error("kryonet", "Error reading TCP from connection: " + fromConnection, ex);
									fromConnection.close();
								}
							}
							if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {
								try {
									fromConnection.tcp.writeOperation();
								} catch (IOException ex) {
									if (TRACE) {
										trace("kryonet", "Unable to write TCP to connection: " + fromConnection, ex);
									} else if (DEBUG) {
										debug("kryonet", fromConnection + " update: " + ex.getMessage());
									}
									fromConnection.close();
								}
							}
							continue;
						}

						if ((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {
							ServerSocketChannel serverChannel = this.serverChannel;
							if (serverChannel == null) continue;
							try {
								SocketChannel socketChannel = serverChannel.accept();
								if (socketChannel != null) acceptOperation(socketChannel);
							} catch (IOException ex) {
								if (DEBUG) debug("kryonet", "Unable to accept new connection.", ex);
							}
							continue;
						}

						// Must be a UDP read operation.
						if (udp == null) {
							selectionKey.channel().close();
							continue;
						}
						InetSocketAddress fromAddress;
						try {
							fromAddress = udp.readFromAddress();
						} catch (IOException ex) {
							if (WARN) warn("kryonet", "Error reading UDP data.", ex);
							continue;
						}
						if (fromAddress == null) continue;

						Connection[] connections = this.connections;
						for (int i = 0, n = connections.length; i < n; i++) {
							Connection connection = connections[i];
							if (fromAddress.equals(connection.udpRemoteAddress)) {
								fromConnection = connection;
								break;
							}
						}

						Object object;
						try {
							object = udp.readObject(fromConnection);
						} catch (KryoNetException ex) {
							if (WARN) {
								if (fromConnection != null) {
									if (ERROR) error("kryonet", "Error reading UDP from connection: " + fromConnection, ex);
								} else
									warn("kryonet", "Error reading UDP from unregistered address: " + fromAddress, ex);
							}
							continue;
						}

						if (object instanceof FrameworkMessage) {
							if (object instanceof RegisterUDP) {
								// Store the fromAddress on the connection and reply over TCP with a RegisterUDP to indicate success.
								int fromConnectionID = ((RegisterUDP)object).connectionID;
								Connection connection = pendingConnections.remove(fromConnectionID);
								if (connection != null) {
									if (connection.udpRemoteAddress != null) continue outer;
									connection.udpRemoteAddress = fromAddress;
									addConnection(connection);
									connection.sendTCP(new RegisterUDP());
									if (DEBUG)
										debug("kryonet", "Port " + udp.datagramChannel.socket().getLocalPort() + "/UDP connected to: "
											+ fromAddress);
									connection.notifyConnected();
									continue;
								}
								if (DEBUG)
									debug("kryonet", "Ignoring incoming RegisterUDP with invalid connection ID: " + fromConnectionID);
								continue;
							}
							if (object instanceof DiscoverHost) {
								try {
									udp.datagramChannel.send(emptyBuffer, fromAddress);
									if (DEBUG) debug("kryonet", "Responded to host discovery from: " + fromAddress);
								} catch (IOException ex) {
									if (WARN) warn("kryonet", "Error replying to host discovery from: " + fromAddress, ex);
								}
								continue;
							}
						}

						if (fromConnection != null) {
							if (DEBUG) {
								String objectString = object == null ? "null" : object.getClass().getSimpleName();
								if (object instanceof FrameworkMessage) {
									if (TRACE) trace("kryonet", fromConnection + " received UDP: " + objectString);
								} else
									debug("kryonet", fromConnection + " received UDP: " + objectString);
							}
							fromConnection.notifyReceived(object);
							continue;
						}
						if (DEBUG) debug("kryonet", "Ignoring UDP from unregistered address: " + fromAddress);
					} catch (CancelledKeyException ex) {
						if (fromConnection != null)
							fromConnection.close();
						else
							selectionKey.channel().close();
					}
				}
			}
		}
		long time = System.currentTimeMillis();
		Connection[] connections = this.connections;
		for (int i = 0, n = connections.length; i < n; i++) {
			Connection connection = connections[i];
			if (connection.tcp.isTimedOut(time)) {
				if (DEBUG) debug("kryonet", connection + " timed out.");
				connection.close();
			} else {
				if (connection.tcp.needsKeepAlive(time)) connection.sendTCP(FrameworkMessage.keepAlive);
			}
			if (connection.isIdle()) connection.notifyIdle();
		}
	}

	public void run () {
		if (TRACE) trace("kryonet", "Server thread started.");
		shutdown = false;
		while (!shutdown) {
			try {
				update(250);
			} catch (IOException ex) {
				if (ERROR) error("kryonet", "Error updating server connections.", ex);
				close();
			}
		}
		if (TRACE) trace("kryonet", "Server thread stopped.");
	}

	public void start () {
		new Thread(this, "Server").start();
	}

	public void stop () {
		if (shutdown) return;
		close();
		if (TRACE) trace("kryonet", "Server thread stopping.");
		shutdown = true;
	}

	private void acceptOperation (SocketChannel socketChannel) {
		Connection connection = newConnection();
		connection.initialize(serialization, writeBufferSize, objectBufferSize);
		connection.endPoint = this;
		UdpConnection udp = this.udp;
		if (udp != null) connection.udp = udp;
		try {
			SelectionKey selectionKey = connection.tcp.accept(selector, socketChannel);
			selectionKey.attach(connection);

			int id = nextConnectionID++;
			if (nextConnectionID == -1) nextConnectionID = 1;
			connection.id = id;
			connection.setConnected(true);
			connection.addListener(dispatchListener);

			if (udp == null)
				addConnection(connection);
			else
				pendingConnections.put(id, connection);

			RegisterTCP registerConnection = new RegisterTCP();
			registerConnection.connectionID = id;
			connection.sendTCP(registerConnection);

			if (udp == null) connection.notifyConnected();
		} catch (IOException ex) {
			connection.close();
			if (DEBUG) debug("kryonet", "Unable to accept TCP connection.", ex);
		}
	}

	/** Allows the connections used by the server to be subclassed. This can be useful for storage per connection without an
	 * additional lookup. */
	protected Connection newConnection () {
		return new Connection();
	}

	private void addConnection (Connection connection) {
		Connection[] newConnections = new Connection[connections.length + 1];
		newConnections[0] = connection;
		System.arraycopy(connections, 0, newConnections, 1, connections.length);
		connections = newConnections;
	}

	void removeConnection (Connection connection) {
		ArrayList<Connection> temp = new ArrayList(Arrays.asList(connections));
		temp.remove(connection);
		connections = temp.toArray(new Connection[temp.size()]);

		pendingConnections.remove(connection.id);
	}

	// BOZO - Provide mechanism for sending to multiple clients without serializing multiple times.

	public void sendToAllTCP (Object object) {
		Connection[] connections = this.connections;
		for (int i = 0, n = connections.length; i < n; i++) {
			Connection connection = connections[i];
			connection.sendTCP(object);
		}
	}

	public void sendToAllExceptTCP (int connectionID, Object object) {
		Connection[] connections = this.connections;
		for (int i = 0, n = connections.length; i < n; i++) {
			Connection connection = connections[i];
			if (connection.id != connectionID) connection.sendTCP(object);
		}
	}

	public void sendToTCP (int connectionID, Object object) {
		Connection[] connections = this.connections;
		for (int i = 0, n = connections.length; i < n; i++) {
			Connection connection = connections[i];
			if (connection.id == connectionID) {
				connection.sendTCP(object);
				break;
			}
		}
	}

	public void addListener (Listener listener) {
		if (listener == null) throw new IllegalArgumentException("listener cannot be null.");
		synchronized (listenerLock) {
			Listener[] listeners = this.listeners;
			int n = listeners.length;
			for (int i = 0; i < n; i++)
				if (listener == listeners[i]) return;
			Listener[] newListeners = new Listener[n + 1];
			newListeners[0] = listener;
			System.arraycopy(listeners, 0, newListeners, 1, n);
			this.listeners = newListeners;
		}
		if (TRACE) trace("kryonet", "Server listener added: " + listener.getClass().getName());
	}

	public void removeListener (Listener listener) {
		if (listener == null) throw new IllegalArgumentException("listener cannot be null.");
		synchronized (listenerLock) {
			Listener[] listeners = this.listeners;
			int n = listeners.length;
			Listener[] newListeners = new Listener[n - 1];
			for (int i = 0, ii = 0; i < n; i++) {
				Listener copyListener = listeners[i];
				if (listener == copyListener) continue;
				if (ii == n - 1) return;
				newListeners[ii++] = copyListener;
			}
			this.listeners = newListeners;
		}
		if (TRACE) trace("kryonet", "Server listener removed: " + listener.getClass().getName());
	}

	/** Closes all open connections and the server port(s). */
	public void close () {
		Connection[] connections = this.connections;
		if (INFO && connections.length > 0) info("kryonet", "Closing server connections...");
		for (int i = 0, n = connections.length; i < n; i++)
			connections[i].close();
		connections = new Connection[0];

		ServerSocketChannel serverChannel = this.serverChannel;
		if (serverChannel != null) {
			try {
				serverChannel.close();
				if (INFO) info("kryonet", "Server closed.");
			} catch (IOException ex) {
				if (DEBUG) debug("kryonet", "Unable to close server.", ex);
			}
			this.serverChannel = null;
		}

		UdpConnection udp = this.udp;
		if (udp != null) {
			udp.close();
			this.udp = null;
		}

		// Select one last time to complete closing the socket.
		synchronized (updateLock) {
			selector.wakeup();
			try {
				selector.selectNow();
			} catch (IOException ignored) {
			}
		}
	}

	public Thread getUpdateThread () {
		return updateThread;
	}

	/** Returns the current connections. The array returned should not be modified. */
	public Connection[] getConnections () {
		return connections;
	}
}


package com.esotericsoftware.kryonet;

import java.io.IOException;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;

import static com.esotericsoftware.minlog.Log.*;

/** @author Nathan Sweet <misc@n4te.com> */
class TcpConnection {
	static private final int IPTOS_LOWDELAY = 0x10;

	SocketChannel socketChannel;
	int keepAliveMillis = 8000;
	final ByteBuffer readBuffer, writeBuffer;
	boolean bufferPositionFix;
	int timeoutMillis = 12000;
	float idleThreshold = 0.1f;

	final Serialization serialization;
	private SelectionKey selectionKey;
	private volatile long lastWriteTime, lastReadTime;
	private int currentObjectLength;
	private final Object writeLock = new Object();

	public TcpConnection (Serialization serialization, int writeBufferSize, int objectBufferSize) {
		this.serialization = serialization;
		writeBuffer = ByteBuffer.allocate(writeBufferSize);
		readBuffer = ByteBuffer.allocate(objectBufferSize);
		readBuffer.flip();
	}

	public SelectionKey accept (Selector selector, SocketChannel socketChannel) throws IOException {
		writeBuffer.clear();
		readBuffer.clear();
		readBuffer.flip();
		currentObjectLength = 0;
		try {
			this.socketChannel = socketChannel;
			socketChannel.configureBlocking(false);
			Socket socket = socketChannel.socket();
			socket.setTcpNoDelay(true);

			selectionKey = socketChannel.register(selector, SelectionKey.OP_READ);

			if (DEBUG) {
				debug("kryonet", "Port " + socketChannel.socket().getLocalPort() + "/TCP connected to: "
					+ socketChannel.socket().getRemoteSocketAddress());
			}

			lastReadTime = lastWriteTime = System.currentTimeMillis();

			return selectionKey;
		} catch (IOException ex) {
			close();
			throw ex;
		}
	}

	public void connect (Selector selector, SocketAddress remoteAddress, int timeout) throws IOException {
		close();
		writeBuffer.clear();
		readBuffer.clear();
		readBuffer.flip();
		currentObjectLength = 0;
		try {
			SocketChannel socketChannel = selector.provider().openSocketChannel();
			Socket socket = socketChannel.socket();
			socket.setTcpNoDelay(true);
			// socket.setTrafficClass(IPTOS_LOWDELAY);
			socket.connect(remoteAddress, timeout); // Connect using blocking mode for simplicity.
			socketChannel.configureBlocking(false);
			this.socketChannel = socketChannel;

			selectionKey = socketChannel.register(selector, SelectionKey.OP_READ);
			selectionKey.attach(this);

			if (DEBUG) {
				debug("kryonet", "Port " + socketChannel.socket().getLocalPort() + "/TCP connected to: "
					+ socketChannel.socket().getRemoteSocketAddress());
			}

			lastReadTime = lastWriteTime = System.currentTimeMillis();
		} catch (IOException ex) {
			close();
			IOException ioEx = new IOException("Unable to connect to: " + remoteAddress);
			ioEx.initCause(ex);
			throw ioEx;
		}
	}

	public Object readObject (Connection connection) throws IOException {
		SocketChannel socketChannel = this.socketChannel;
		if (socketChannel == null) throw new SocketException("Connection is closed.");

		if (currentObjectLength == 0) {
			// Read the length of the next object from the socket.
			int lengthLength = serialization.getLengthLength();
			if (readBuffer.remaining() < lengthLength) {
				readBuffer.compact();
				int bytesRead = socketChannel.read(readBuffer);
				readBuffer.flip();
				if (bytesRead == -1) throw new SocketException("Connection is closed.");
				lastReadTime = System.currentTimeMillis();

				if (readBuffer.remaining() < lengthLength) return null;
			}
			currentObjectLength = serialization.readLength(readBuffer);

			if (currentObjectLength <= 0) throw new KryoNetException("Invalid object length: " + currentObjectLength);
			if (currentObjectLength > readBuffer.capacity())
				throw new KryoNetException("Unable to read object larger than read buffer: " + currentObjectLength);
		}

		int length = currentObjectLength;
		if (readBuffer.remaining() < length) {
			// Fill the tcpInputStream.
			readBuffer.compact();
			int bytesRead = socketChannel.read(readBuffer);
			readBuffer.flip();
			if (bytesRead == -1) throw new SocketException("Connection is closed.");
			lastReadTime = System.currentTimeMillis();

			if (readBuffer.remaining() < length) return null;
		}
		currentObjectLength = 0;

		int startPosition = readBuffer.position();
		int oldLimit = readBuffer.limit();
		readBuffer.limit(startPosition + length);
		Object object;
		try {
			object = serialization.read(connection, readBuffer);
		} catch (Exception ex) {
			throw new KryoNetException("Error during deserialization.", ex);
		}

		readBuffer.limit(oldLimit);
		if (readBuffer.position() - startPosition != length)
			throw new KryoNetException("Incorrect number of bytes (" + (startPosition + length - readBuffer.position())
				+ " remaining) used to deserialize object: " + object);

		return object;
	}

	public void writeOperation () throws IOException {
		synchronized (writeLock) {
			if (writeToSocket()) {
				// Write successful, clear OP_WRITE.
				selectionKey.interestOps(SelectionKey.OP_READ);
			}
			lastWriteTime = System.currentTimeMillis();
		}
	}

	private boolean writeToSocket () throws IOException {
		SocketChannel socketChannel = this.socketChannel;
		if (socketChannel == null) throw new SocketException("Connection is closed.");

		ByteBuffer buffer = writeBuffer;
		buffer.flip();
		while (buffer.hasRemaining()) {
			if (bufferPositionFix) {
				buffer.compact();
				buffer.flip();
			}
			if (socketChannel.write(buffer) == 0) break;
		}
		buffer.compact();

		return buffer.position() == 0;
	}

	/** This method is thread safe. */
	public int send (Connection connection, Object object) throws IOException {
		SocketChannel socketChannel = this.socketChannel;
		if (socketChannel == null) throw new SocketException("Connection is closed.");
		synchronized (writeLock) {
			// Leave room for length.
			int start = writeBuffer.position();
			int lengthLength = serialization.getLengthLength();
			writeBuffer.position(writeBuffer.position() + lengthLength);

			// Write data.
			try {
				serialization.write(connection, writeBuffer, object);
			} catch (KryoNetException ex) {
				throw new KryoNetException("Error serializing object of type: " + object.getClass().getName(), ex);
			}
			int end = writeBuffer.position();

			// Write data length.
			writeBuffer.position(start);
			serialization.writeLength(writeBuffer, end - lengthLength - start);
			writeBuffer.position(end);

			// Write to socket if no data was queued.
			if (start == 0 && !writeToSocket()) {
				// A partial write, set OP_WRITE to be notified when more writing can occur.
				selectionKey.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
			} else {
				// Full write, wake up selector so idle event will be fired.
				selectionKey.selector().wakeup();
			}

			if (DEBUG || TRACE) {
				float percentage = writeBuffer.position() / (float)writeBuffer.capacity();
				if (DEBUG && percentage > 0.75f)
					debug("kryonet", connection + " TCP write buffer is approaching capacity: " + percentage + "%");
				else if (TRACE && percentage > 0.25f)
					trace("kryonet", connection + " TCP write buffer utilization: " + percentage + "%");
			}

			lastWriteTime = System.currentTimeMillis();
			return end - start;
		}
	}

	public void close () {
		try {
			if (socketChannel != null) {
				socketChannel.close();
				socketChannel = null;
				if (selectionKey != null) selectionKey.selector().wakeup();
			}
		} catch (IOException ex) {
			if (DEBUG) debug("kryonet", "Unable to close TCP connection.", ex);
		}
	}

	public boolean needsKeepAlive (long time) {
		return socketChannel != null && keepAliveMillis > 0 && time - lastWriteTime > keepAliveMillis;
	}

	public boolean isTimedOut (long time) {
		return socketChannel != null && timeoutMillis > 0 && time - lastReadTime > timeoutMillis;
	}
}


package com.esotericsoftware.kryonet;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;

import static com.esotericsoftware.minlog.Log.*;

/** @author Nathan Sweet <misc@n4te.com> */
class UdpConnection {
	InetSocketAddress connectedAddress;
	DatagramChannel datagramChannel;
	int keepAliveMillis = 19000;
	final ByteBuffer readBuffer, writeBuffer;
	private final Serialization serialization;
	private SelectionKey selectionKey;
	private final Object writeLock = new Object();
	private long lastCommunicationTime;

	public UdpConnection (Serialization serialization, int bufferSize) {
		this.serialization = serialization;
		readBuffer = ByteBuffer.allocate(bufferSize);
		writeBuffer = ByteBuffer.allocateDirect(bufferSize);
	}

	public void bind (Selector selector, InetSocketAddress localPort) throws IOException {
		close();
		readBuffer.clear();
		writeBuffer.clear();
		try {
			datagramChannel = selector.provider().openDatagramChannel();
			datagramChannel.socket().bind(localPort);
			datagramChannel.configureBlocking(false);
			selectionKey = datagramChannel.register(selector, SelectionKey.OP_READ);

			lastCommunicationTime = System.currentTimeMillis();
		} catch (IOException ex) {
			close();
			throw ex;
		}
	}

	public void connect (Selector selector, InetSocketAddress remoteAddress) throws IOException {
		close();
		readBuffer.clear();
		writeBuffer.clear();
		try {
			datagramChannel = selector.provider().openDatagramChannel();
			datagramChannel.socket().bind(null);
			datagramChannel.socket().connect(remoteAddress);
			datagramChannel.configureBlocking(false);

			selectionKey = datagramChannel.register(selector, SelectionKey.OP_READ);

			lastCommunicationTime = System.currentTimeMillis();

			connectedAddress = remoteAddress;
		} catch (IOException ex) {
			close();
			IOException ioEx = new IOException("Unable to connect to: " + remoteAddress);
			ioEx.initCause(ex);
			throw ioEx;
		}
	}

	public InetSocketAddress readFromAddress () throws IOException {
		DatagramChannel datagramChannel = this.datagramChannel;
		if (datagramChannel == null) throw new SocketException("Connection is closed.");
		lastCommunicationTime = System.currentTimeMillis();
		return (InetSocketAddress)datagramChannel.receive(readBuffer);
	}

	public Object readObject (Connection connection) {
		readBuffer.flip();
		try {
			try {
				Object object = serialization.read(connection, readBuffer);
				if (readBuffer.hasRemaining())
					throw new KryoNetException("Incorrect number of bytes (" + readBuffer.remaining()
						+ " remaining) used to deserialize object: " + object);
				return object;
			} catch (Exception ex) {
				throw new KryoNetException("Error during deserialization.", ex);
			}
		} finally {
			readBuffer.clear();
		}
	}

	/** This method is thread safe. */
	public int send (Connection connection, Object object, SocketAddress address) throws IOException {
		DatagramChannel datagramChannel = this.datagramChannel;
		if (datagramChannel == null) throw new SocketException("Connection is closed.");
		synchronized (writeLock) {
			try {
				try {
					serialization.write(connection, writeBuffer, object);
				} catch (Exception ex) {
					throw new KryoNetException("Error serializing object of type: " + object.getClass().getName(), ex);
				}
				writeBuffer.flip();
				int length = writeBuffer.limit();
				datagramChannel.send(writeBuffer, address);

				lastCommunicationTime = System.currentTimeMillis();

				boolean wasFullWrite = !writeBuffer.hasRemaining();
				return wasFullWrite ? length : -1;
			} finally {
				writeBuffer.clear();
			}
		}
	}

	public void close () {
		connectedAddress = null;
		try {
			if (datagramChannel != null) {
				datagramChannel.close();
				datagramChannel = null;
				if (selectionKey != null) selectionKey.selector().wakeup();
			}
		} catch (IOException ex) {
			if (DEBUG) debug("kryonet", "Unable to close UDP connection.", ex);
		}
	}

	public boolean needsKeepAlive (long time) {
		return connectedAddress != null && keepAliveMillis > 0 && time - lastCommunicationTime > keepAliveMillis;
	}
}

package com.thatgamerblue.osrs.proxchat.client.audio;

import lombok.RequiredArgsConstructor;

/**
 * Audio detection modes for microphone input
 */
@RequiredArgsConstructor
public enum AudioMode
{
	/**
	 * Activates microphone when sound is detected
	 */
	VOICE_ACTIVITY("Voice Activity"),
	/**
	 * Activates microphone when a button is pushed
	 */
	PUSH_TO_TALK("PTT");

	/**
	 * Human-friendly name of this {@link AudioMode}
	 */
	private final String name;

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toString()
	{
		return name;
	}
}

package com.thatgamerblue.osrs.proxchat.client.audio;

/**
 * Various utilities for audio processing
 */
public class AudioUtil
{
	/**
	 * Converts two bytes into a short
	 *
	 * @param b1 low byte
	 * @param b2 high byte
	 * @return {@code ((b2 & 0xff) << 8 | b1 & 0xff)}
	 */
	public static short bytesToShort(byte b1, byte b2)
	{
		return (short) ((b2 & 0xff) << 8 | b1 & 0xff);
	}

	/**
	 * Converts a short array to a byte array
	 *
	 * @param sIn short array
	 * @return byte array containing the shorts split up
	 */
	public static byte[] shortsToBytes(short[] sIn)
	{
		byte[] bAry = new byte[sIn.length * 2];

		shortsToBytes(sIn, bAry);

		return bAry;
	}

	/**
	 * Converts a short array to a byte array
	 *
	 * @param sIn  short array
	 * @param bOut output byte array
	 */
	public static void shortsToBytes(short[] sIn, byte[] bOut)
	{
		for (int i = 0; i < sIn.length; i++)
		{
			byte[] bytes = AudioUtil.shortToBytes(sIn[i]);
			bOut[i * 2] = bytes[0];
			bOut[i * 2 + 1] = bytes[1];
		}
	}

	/**
	 * Converts a byte array to a short array
	 *
	 * @param bIn byte array
	 * @return short array containing the bytes merged
	 */
	public static short[] bytesToShorts(byte[] bIn)
	{
		short[] sOut = new short[bIn.length / 2];

		bytesToShorts(bIn, sOut);

		return sOut;
	}

	/**
	 * Converts a byte array to a short array
	 *
	 * @param bIn  byte array
	 * @param sOut output short array
	 */
	public static void bytesToShorts(byte[] bIn, short[] sOut)
	{
		int j = 0;
		for (int i = 0; i < bIn.length; i += 2)
		{
			short s = AudioUtil.bytesToShort(bIn[i], bIn[i + 1]);
			sOut[j++] = s;
		}
	}

	/**
	 * Converts a short into two bytes
	 *
	 * @param s short value
	 * @return short in a byte array in little endian format
	 */
	public static byte[] shortToBytes(short s)
	{
		return new byte[]{(byte) (s & 0xff), (byte) ((s >> 8) & 0xff)};
	}

	/**
	 * Amplifies the volume of 16-bit audio.
	 * Modifies the input array
	 *
	 * @param buf   input 16-bit pcm
	 * @param scale multiplication factor
	 */
	public static void amplify(byte[] buf, float scale)
	{
		for (int i = 0; i < buf.length; i += 2)
		{
			// we want to do the multiplication in the float domain so we dont lose precision in `scale`
			float fSample = bytesToShort(buf[i], buf[i + 1]);
			fSample *= scale;
			short sSample = (short) fSample;
			buf[i] = (byte) sSample;
			buf[i + 1] = (byte) (sSample >> 8);
		}
	}

	/**
	 * Converts mono pcm data to stereo pcm data, with equal volume on each channel
	 *
	 * @param mono mono pcm audio data
	 * @return stereo pcm audio data
	 */
	public static byte[] convertToStereo(byte[] mono)
	{
		byte[] stereo = new byte[mono.length * 2];
		for (int i = 0; i < mono.length; i += 2)
		{
			// left channel
			stereo[i * 2] = mono[i];
			stereo[i * 2 + 1] = mono[i + 1];

			// right channel
			stereo[i * 2 + 2] = mono[i];
			stereo[i * 2 + 3] = mono[i + 1];
		}

		return stereo;
	}

	/**
	 * Calculates the audio level of a signal with specific samples.
	 *
	 * @param samples the samples of the signal to calculate the audio level of
	 * @return the audio level of the specified signal in db
	 */
	public static double calculateAudioLevel(byte[] samples)
	{
		double rms = 0D; // root mean square (RMS) amplitude

		for (int i = 0; i < samples.length; i += 2)
		{
			double sample = (double) bytesToShort(samples[i], samples[i + 1]) / Short.MAX_VALUE;
			rms += sample * sample;
		}

		int sampleCount = samples.length / 2;

		rms = (sampleCount == 0) ? 0 : Math.sqrt(rms / sampleCount);

		double db;

		if (rms > 0D)
		{
			db = Math.min(Math.max(20D * Math.log10(rms), -127D), 0D);
		}
		else
		{
			db = -127D;
		}

		return db;
	}
}

package com.thatgamerblue.osrs.proxchat.client.audio;

import com.thatgamerblue.osrs.proxchat.client.net.ClientNetworkHandler;
import com.thatgamerblue.osrs.proxchat.common.audio.AudioConstants;
import com.thatgamerblue.osrs.proxchat.common.net.messages.c2s.C2SMicPacket;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.TargetDataLine;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;

/**
 * Reads microphone data and sends packets over the network
 */
@Slf4j
public class MicThread extends Thread
{
	/**
	 * How long to hold the mic open for after releasing push to talk/voice activity stops
	 * Helps prevent rapid enabling and disabling of the microphone causing an unpleasant experience
	 */
	private static final int MIC_HOLDON_TIME_DELAY = 120;

	/**
	 * Atomic used to tell when the thread should stop
	 */
	private final AtomicBoolean running = new AtomicBoolean(true);
	/**
	 * Atomic used to tell when the PTT key is pressed
	 */
	private final AtomicBoolean pttDown = new AtomicBoolean(false);
	/**
	 * Atomic used to tell when toggle mute is enabled
	 */
	private final AtomicBoolean toggleMute = new AtomicBoolean(false);
	/**
	 * Client network handler for sending mic data out
	 */
	private final ClientNetworkHandler networkHandler;
	/**
	 * How much to amplify microphone volume by
	 */
	private final Supplier<Integer> amplificationSupplier;
	/**
	 * Minimum audio level for mic to activate on voice activation mode.
	 */
	private final Supplier<Integer> thresholdSupplier;
	/**
	 * Push-to-talk or voice activity
	 */
	private final Supplier<AudioMode> audioModeSupplier;
	/**
	 * Game state supplier, we don't want to blast the server with sound nobody can hear
	 */
	private final Supplier<GameState> gameStateSupplier;
	/**
	 * Microphone input device
	 */
	private final TargetDataLine mic;
	/**
	 * Hold-on time before deactivating mic output
	 */
	private long micHoldOnTime = -1;

	/**
	 * Constructs a new thread to read microphone pcm data
	 *
	 * @param network               connection to the server
	 * @param amplificationSupplier supplier of mic volume amplification
	 * @param thresholdSupplier     supplier of mic activation threshold
	 * @param audioModeSupplier     supplier of audio mode
	 * @param gameStateSupplier     supplier of current game state
	 */
	public MicThread(
		ClientNetworkHandler network,
		Supplier<Integer> amplificationSupplier,
		Supplier<Integer> thresholdSupplier,
		Supplier<AudioMode> audioModeSupplier,
		Supplier<GameState> gameStateSupplier
	)
	{
		this.networkHandler = network;
		this.amplificationSupplier = amplificationSupplier;
		this.thresholdSupplier = thresholdSupplier;
		this.audioModeSupplier = audioModeSupplier;
		this.gameStateSupplier = gameStateSupplier;
		TargetDataLine __mic;
		try
		{
			DataLine.Info info = new DataLine.Info(TargetDataLine.class, null);
			__mic = (TargetDataLine) AudioSystem.getLine(info);
			__mic.open(AudioConstants.MONO_FORMAT);
		}
		catch (LineUnavailableException e)
		{
			log.error("Failed to initialize microphone", e);
			__mic = null;
		}
		mic = __mic;

		setDaemon(true);
		setName("Prox-MicThread");
	}

	/**
	 * Blasts voice data across the network. Good luck everybody else!
	 */
	@Override
	public void run()
	{
		if (mic == null)
		{
			throw new RuntimeException("Microphone uninitialized.");
		}

		byte[] inBuf = new byte[AudioConstants.FRAME_SIZE];

		while (running.get())
		{
			if (toggleMute.get())
			{
				sleep(1);
				continue;
			}

			if (!networkHandler.isConnected())
			{
				sleep(1);
				continue;
			}

			GameState currentState = gameStateSupplier.get();
			if (currentState != GameState.LOADING && currentState != GameState.LOGGED_IN)
			{
				sleep(1);
				continue;
			}

			mic.start();
			int avail = mic.available();
			if (avail < AudioConstants.FRAME_SIZE)
			{
				sleep(1);
				continue;
			}

			Arrays.fill(inBuf, (byte) 0);
			mic.read(inBuf, 0, inBuf.length);
			AudioUtil.amplify(inBuf, amplificationSupplier.get() / 25.f);

			switch (audioModeSupplier.get())
			{
				case PUSH_TO_TALK:
					if (pttDown.get())
					{
						micHoldOnTime = System.currentTimeMillis() + MIC_HOLDON_TIME_DELAY;
						networkHandler.sendTCP(new C2SMicPacket(inBuf));
						continue;
					}
					break;
				case VOICE_ACTIVITY:
					double highestLvl = AudioUtil.calculateAudioLevel(inBuf);
					if (highestLvl > thresholdSupplier.get())
					{
						micHoldOnTime = System.currentTimeMillis() + MIC_HOLDON_TIME_DELAY;
						networkHandler.sendTCP(new C2SMicPacket(inBuf));
						continue;
					}
					break;
			}

			if (micHoldOnTime > System.currentTimeMillis())
			{
				// if the mic is being held on, send data anyway
				networkHandler.sendTCP(new C2SMicPacket(inBuf));
				continue;
			}

			// if we reached here we haven't transmitted anything
			// the sendTCP calls above will set the boolean to true when we send a mic packet
			networkHandler.getMicTransmitting().set(false);
		}

		log.info("MicThread stopping...");

		mic.stop();
		mic.close();
	}

	/**
	 * Stops this thread from running and cleans up
	 */
	public void end()
	{
		running.set(false);
	}

	/**
	 * Atomically sets {@link #pttDown}
	 *
	 * @param ptt whether or not the PTT key is pressed
	 */
	public void setPttDown(boolean ptt)
	{
		pttDown.set(ptt);
	}

	/**
	 * Atomically sets {@link #toggleMute} to the opposite of its current value
	 * <p>
	 * Source: https://stackoverflow.com/a/1255633
	 */
	public void toggleMute()
	{
		boolean v;
		do
		{
			v = toggleMute.get();
		}
		while (!toggleMute.compareAndSet(v, !v));
	}

	/**
	 * Is the mic currently deactivated
	 *
	 * @return if the mic is muted by the user
	 */
	public boolean isToggleMute()
	{
		return toggleMute.get();
	}

	/**
	 * Sleeps for {@code ms} milliseconds
	 *
	 * @param ms ms to sleep for
	 */
	private void sleep(int ms)
	{
		try
		{
			Thread.sleep(ms);
		}
		catch (InterruptedException ignored)
		{
		}
	}
}

package com.thatgamerblue.osrs.proxchat.client.audio;

import com.thatgamerblue.osrs.proxchat.common.audio.AudioConstants;
import com.thatgamerblue.osrs.proxchat.common.net.messages.s2c.S2CMicPacket;
import java.util.UUID;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.FloatControl;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.SourceDataLine;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;

/**
 * Plays speaker data fed to it via the queue
 */
@Slf4j
public class SpeakerThread extends Thread
{
	/**
	 * Holds audio data in FIFO queue, initial capacity is one second of audio
	 */
	private final ArrayBlockingQueue<S2CMicPacket> soundQueue = new ArrayBlockingQueue<>(1000 / AudioConstants.MS_PER_PACKET);

	/**
	 * Microphone input device
	 */
	private final SourceDataLine speaker;

	/**
	 * Atomic used to tell when the thread should stop
	 */
	private final AtomicBoolean running = new AtomicBoolean(true);

	/**
	 * Output volume scale
	 */
	private final Supplier<Integer> volume;

	/**
	 * Current game state
	 */
	private final Supplier<GameState> gameState;

	/**
	 * Constructs a thread to play mic data
	 *
	 * @param uuid      server-assigned uuid of this thread
	 * @param volume    volume of the speaker
	 * @param gameState current client game state
	 */
	public SpeakerThread(
		UUID uuid,
		Supplier<Integer> volume,
		Supplier<GameState> gameState
	)
	{
		this.volume = volume;
		this.gameState = gameState;

		SourceDataLine __speaker;
		try
		{
			DataLine.Info info = new DataLine.Info(SourceDataLine.class, null);
			__speaker = (SourceDataLine) AudioSystem.getLine(info);
		}
		catch (LineUnavailableException e)
		{
			log.error("Failed to initialize speaker", e);
			__speaker = null;
		}
		speaker = __speaker;

		setDaemon(true);
		setName("Prox-SpeakerThread-" + uuid.toString());
	}

	/**
	 * Tries to play mic data as fast as possible. Probably will lag behind lmao
	 */
	@Override
	public void run()
	{
		try
		{
			speaker.open(AudioConstants.STEREO_FORMAT);
		}
		catch (LineUnavailableException e)
		{
			log.error("Failed to initialize speaker", e);
			speaker.close();
			return;
		}

		FloatControl gainControl = (FloatControl) speaker.getControl(FloatControl.Type.MASTER_GAIN);

		while (running.get())
		{
			// prevent the last sample from being repeated infinitely
			if (speaker.getBufferSize() - speaker.available() <= 0 && speaker.isActive())
			{
				speaker.stop();
			}

			S2CMicPacket packet;

			try
			{
				packet = soundQueue.poll(5, TimeUnit.MILLISECONDS);
			}
			catch (InterruptedException e)
			{
				continue;
			}

			if (packet == null)
			{
				continue;
			}

			GameState gs = gameState.get();
			if (gs.getState() > GameState.LOGGED_IN.getState() || gs.getState() < GameState.LOADING.getState())
			{
				continue;
			}

			if (speaker.getBufferSize() - speaker.available() <= 0)
			{
				// nothing in the buffer, buffer some silence
				byte[] data = new byte[Math.min(AudioConstants.FRAME_SIZE * 4, speaker.getBufferSize() - AudioConstants.FRAME_SIZE)];
				speaker.write(data, 0, data.length);
			}

			float volumeScale = scaleAudio(packet.distance);
			float volumeDb = (float) (10d * Math.log(volumeScale)) * ((float) volume.get() / 50.0f);
			gainControl.setValue(Math.min(Math.max(volumeDb, gainControl.getMinimum()), gainControl.getMaximum()));

			byte[] decoded = packet.data;

			byte[] stereo = AudioUtil.convertToStereo(decoded);

			speaker.write(stereo, 0, stereo.length);
			speaker.start();
		}

		speaker.stop();
		speaker.close();
		soundQueue.clear();
	}

	/**
	 * Scales audio levels based off distance
	 * Algorithm from https://stackoverflow.com/a/929107 because I'm too stupid to write it myself
	 *
	 * @param distance distance away from player in tiles * 128
	 * @return audio multiplier
	 */
	private float scaleAudio(int distance)
	{
		float minDist = (float) AudioConstants.MIN_DISTANCE;
		float maxDist = (float) AudioConstants.MAX_DISTANCE;
		float diff = maxDist - minDist;
		float val = 1.0f - ((((distance - minDist) * 0.99f) / diff) + 0.01f);
		return Math.max(0.0f, Math.min(val, 1.0f));
	}

	/**
	 * Stops this thread from running, leaves cleanup to the {@link SpeakerThread#run()} method
	 */
	public void destroy()
	{
		running.set(false);
	}

	/**
	 * Adds a mic packet to the buffer, to be played as soon as possible
	 *
	 * @param micPacket microphone packet to buffer
	 */
	public void push(S2CMicPacket micPacket)
	{
		try
		{
			soundQueue.offer(micPacket, 25, TimeUnit.MILLISECONDS);
		}
		catch (InterruptedException ignored)
		{
		}
	}
}

package com.thatgamerblue.osrs.proxchat.client.net;

import com.esotericsoftware.kryonet.Connection;
import com.esotericsoftware.kryonet.FrameworkMessage;
import com.google.common.hash.Hashing;
import com.thatgamerblue.osrs.proxchat.client.ProxChatClientPlugin;
import com.thatgamerblue.osrs.proxchat.client.audio.SpeakerThread;
import com.thatgamerblue.osrs.proxchat.common.audio.AudioConstants;
import com.thatgamerblue.osrs.proxchat.common.net.NetworkHandler;
import com.thatgamerblue.osrs.proxchat.common.net.messages.c2s.C2SAuth;
import com.thatgamerblue.osrs.proxchat.common.net.messages.c2s.C2SMicPacket;
import com.thatgamerblue.osrs.proxchat.common.net.messages.c2s.C2SUpdatePacket;
import com.thatgamerblue.osrs.proxchat.common.net.messages.s2c.S2CAuthReq;
import com.thatgamerblue.osrs.proxchat.common.net.messages.s2c.S2CKillDecoder;
import com.thatgamerblue.osrs.proxchat.common.net.messages.s2c.S2CMicPacket;
import com.thatgamerblue.osrs.proxchat.common.net.messages.s2c.S2CUpdateReq;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;

/**
 * Network handler for the client side.
 * Entrypoint for all packets received from the server
 */
@Slf4j
public class ClientNetworkHandler extends NetworkHandler
{
	/**
	 * Instance of the plugin controlling this instance
	 */
	private final ProxChatClientPlugin plugin;

	/**
	 * Instance of the RS client
	 */
	private final Client client;

	/**
	 * Holds the server's address for connection
	 */
	private final Supplier<String> connectionAddress;

	/**
	 * Holds the port open on the server
	 */
	private final Supplier<Integer> port;

	/**
	 * Holds the pre-shared key of the server
	 */
	private final Supplier<String> password;

	/**
	 * Holds if we should actually try to connect
	 */
	private final Supplier<Boolean> enabled;

	/**
	 * Holds the current room the player is speaking in
	 */
	private final Supplier<String> room;

	/**
	 * Holds all the SpeakerThread instances this handler controls
	 */
	private final ConcurrentHashMap<UUID, SpeakerThread> speakers = new ConcurrentHashMap<>();

	/**
	 * Holds the speaker's muted state. Held here so we can drop packets early to not bother the speaker threads
	 */
	@Getter
	private final AtomicBoolean speakerMuted = new AtomicBoolean(false);

	/**
	 * Holds the mic's transmitting state. Held here because the speakerMuted value is too
	 */
	@Getter
	private final AtomicBoolean micTransmitting = new AtomicBoolean(false);

	/**
	 * Whether or not we should attempt a reconnect after we get disconnected
	 */
	private final AtomicBoolean reconnect = new AtomicBoolean(false);

	/**
	 * Whether or not we are currently attempting to connect to the server
	 */
	private final AtomicBoolean connecting = new AtomicBoolean(false);

	/**
	 * Holds the last state we sent to the server
	 */
	private C2SUpdatePacket lastState = null;

	/**
	 * Maximum value for the backoff timer in seconds
	 * <p>
	 * 4 minutes
	 */
	private static final int BACKOFF_TIMER_MAX = 240;

	/**
	 * Minimum value for the backoff timer in seconds
	 * <p>
	 * 30 seconds
	 */
	private static final int BACKOFF_TIMER_MIN = 30;

	/**
	 * Exponential backoff timer in seconds
	 */
	private int backoffTimer = BACKOFF_TIMER_MIN;

	/**
	 * Future holding the task execution of the connection
	 */
	private ScheduledFuture<?> connectionFuture;

	/**
	 * Initializes an {@link NetworkHandler} in client operating mode
	 * Handles all connections to the server.
	 * Handles memory management of audio handlers.
	 *
	 * @param plugin            instance of the plugin that controls this
	 * @param client            instance of the RS client
	 * @param connectionAddress address supplier, see {@link #connectionAddress}
	 * @param port              port of the voice server
	 * @param password          password of the voice server
	 */
	public ClientNetworkHandler(
		ProxChatClientPlugin plugin,
		Client client,
		Supplier<String> connectionAddress,
		Supplier<Integer> port,
		Supplier<String> password,
		Supplier<Boolean> enabled,
		Supplier<String> room
	)
	{
		super(Mode.CLIENT);
		this.plugin = plugin;
		this.client = client;
		this.connectionAddress = connectionAddress;
		this.port = port;
		this.password = password;
		this.enabled = enabled;
		this.room = room;
	}

	/**
	 * Initializes networking, should be called AFTER {@link NetworkHandler#initKryonet()}
	 * Connects to the server
	 */
	@Override
	public void connect()
	{
		if (connecting.get())
		{
			return;
		}

		backoffTimer = BACKOFF_TIMER_MIN;
		connecting.set(true);

		doConnect();
	}

	private void doConnect()
	{
		if (connectionAddress.get().equals("<disabled>") || !enabled.get())
		{
			connecting.set(false);
			return;
		}

		try
		{
			netClient.start();
			netClient.connect(5000, connectionAddress.get(), port.get());

			connecting.set(false);
			log.info("Connected to voice server");
		}
		catch (IOException ex)
		{
			log.error("Failed to connect to the server, retrying in " + backoffTimer + " seconds.", ex);
			connectionFuture = plugin.getExecutor().schedule(this::doConnect, backoffTimer, TimeUnit.SECONDS);
			backoffTimer *= 2;
			if (backoffTimer > BACKOFF_TIMER_MAX)
			{
				backoffTimer = BACKOFF_TIMER_MAX;
			}
		}
	}

	/**
	 * Called when a successful connection is established
	 *
	 * @param connection connection object from kryonet
	 */
	@Override
	protected void onConnected(Connection connection)
	{

	}

	/**
	 * Called when a message is received over the network
	 *
	 * @param connection connection object from kryonet
	 * @param message    message object deserialized by kryonet
	 */
	@Override
	protected void onMessageReceived(Connection connection, Object message)
	{
		if (!(message instanceof FrameworkMessage) && !(message instanceof S2CMicPacket))
		{
			log.info("Recv message: {}", message);
		}

		if (message instanceof S2CAuthReq)
		{
			Random rand = new Random(((S2CAuthReq) message).replay);
			byte[] pw = password.get().getBytes(StandardCharsets.UTF_8);
			for (int i = 0; i < pw.length; i++)
			{
				pw[i] = (byte) (pw[i] ^ rand.nextInt());
			}

			byte[] fin = Hashing.sha256().hashBytes(pw).asBytes();

			sendTCP(new C2SAuth(fin));
		}
		else if (message instanceof S2CUpdateReq)
		{
			sendUpdate(client.getGameState().getState());
		}
		else if (message instanceof S2CKillDecoder)
		{
			UUID uuid = ((S2CKillDecoder) message).uuid;
			SpeakerThread speaker = speakers.get(uuid);
			if (speaker != null)
			{
				speaker.destroy();
				speakers.remove(uuid);
			}
		}
		else if (message instanceof S2CMicPacket)
		{
			S2CMicPacket micPacket = (S2CMicPacket) message;

			if (micPacket.distance < 0 || micPacket.distance > AudioConstants.MAX_DISTANCE)
			{
				// drop the packet, something's gone wrong
				return;
			}

			if (speakerMuted.get())
			{
				// speaker is muted, don't bother the decoders
				return;
			}

			UUID decoderId = micPacket.decoder;
			SpeakerThread speaker = speakers.get(decoderId);
			if (speaker == null)
			{
				speaker = new SpeakerThread(decoderId, () -> plugin.getConfig().speakerVolume(), client::getGameState);
				speakers.put(decoderId, speaker);
				speaker.start();
			}

			speaker.push(micPacket);
		}
	}

	/**
	 * Is this instance connected to a server
	 *
	 * @return true if this instance is connected to a server
	 */
	public boolean isConnected()
	{
		return netClient.isConnected();
	}

	/**
	 * Sends an object over the network, synchronized on {@code this}
	 *
	 * @param object object to send
	 */
	public void sendTCP(Object object)
	{
		if (object instanceof C2SMicPacket)
		{
			micTransmitting.set(true);
		}

		netClient.sendTCP(object);
	}

	/**
	 * Called when a connection is disconnected
	 *
	 * @param connection connection object from kryonet
	 */
	@Override
	protected void onDisconnected(Connection connection)
	{
		if (!reconnect.get())
		{
			return;
		}

		this.connect();
	}

	/**
	 * Sends an update about the client's current state to the server
	 *
	 * @param gameState current game state
	 */
	public void sendUpdate(int gameState)
	{
		int x, y, plane, world;
		if (client.getLocalPlayer() != null)
		{
			LocalPoint lp = client.getLocalPlayer().getLocalLocation();
			int lX = lp.getX();
			int lY = lp.getY();

			x = lX + (client.getBaseX() * Perspective.LOCAL_TILE_SIZE);
			y = lY + (client.getBaseY() * Perspective.LOCAL_TILE_SIZE);
			plane = client.getPlane();
			world = client.getWorld();
		}
		else
		{
			x = y = plane = world = -1;
		}

		if (!netClient.isConnected())
		{
			return;
		}

		C2SUpdatePacket packet = new C2SUpdatePacket(x, y, plane, world, gameState, room.get());
		if (packet.equals(lastState))
		{
			return;
		}

		lastState = packet;

		sendTCP(packet);
	}

	/**
	 * Disconnects the open server connection and destroys all audio players.
	 * Reusable after calling {@link ClientNetworkHandler#connect()}
	 */
	@Override
	public void disconnect()
	{
		reconnect.set(false);
		netClient.stop();
		speakers.forEach((u, s) -> s.destroy());
		speakers.clear();
	}

	/**
	 * Cancels any waiting connection attempts
	 */
	public void cancelConnecting()
	{
		if (connectionFuture != null)
		{
			connectionFuture.cancel(false);
		}
		connecting.set(false);
	}

	/**
	 * Atomically sets {@link #speakerMuted} to the opposite of its current value
	 * <p>
	 * Source: https://stackoverflow.com/a/1255633
	 */
	public void toggleSpeakerMute()
	{
		boolean v;
		do
		{
			v = speakerMuted.get();
		}
		while (!speakerMuted.compareAndSet(v, !v));
	}

	/**
	 * Are we currently attempting to connect to the server
	 *
	 * @return true if connecting, false otherwise
	 */
	public boolean isConnecting()
	{
		return connecting.get();
	}
}

package com.thatgamerblue.osrs.proxchat.client;

import com.thatgamerblue.osrs.proxchat.client.audio.AudioMode;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Range;

/**
 * Cool config class fully handled by RuneLite
 */
@ConfigGroup("blueproxchat")
public interface ProxChatClientConfig extends Config
{
	/**
	 * Config for if the plugin should connect to the server
	 * We want this because even if the user turns on the plugin, we want them to look at the settings pane
	 * to change servers if they don't want to connect to the default public server
	 *
	 * @return is the plugin enabled?
	 */
	@ConfigItem(
		keyName = "enabled",
		name = "Enabled",
		description = "Enable the plugin",
		position = 0
	)
	default boolean enabled() {
		return false;
	}

	/**
	 * Config for the address of the voice server
	 *
	 * @return network address of the voice server
	 */
	@ConfigItem(
		keyName = "address",
		name = "Server Address",
		description = "The voice server to use. Default: proxchat.thatgamerblue.com",
		position = 1
	)
	default String address()
	{
		return "proxchat.thatgamerblue.com";
	}

	/**
	 * Config for the port of the voice server
	 *
	 * @return port of the server
	 */
	@Range(min = 1024, max = 65535)
	@ConfigItem(
		keyName = "port",
		name = "Server Port",
		description = "Port of the voice server",
		position = 2
	)
	default int port()
	{
		return 30666;
	}

	/**
	 * Config for the password of the voice server
	 *
	 * @return password of the server
	 */
	@ConfigItem(
		keyName = "password",
		name = "Server Password",
		description = "Password of the voice server",
		position = 3,
		secret = true
	)
	default String password()
	{
		return "";
	}

	/**
	 * Config for the room the player is in
	 *
	 * @return shared room name
	 */
	@ConfigItem(
		keyName = "room",
		name = "Room Name",
		description = "Shared room name for private calls - if this gets leaked anyone can join",
		position = 4
	)
	default String room() {
		return "";
	}

	/**
	 * Config for the audio mode to use, push to talk or voice activity
	 *
	 * @return push-to-talk or voice activity depending on selection
	 */
	@ConfigItem(
		keyName = "audioMode",
		name = "Mic Mode",
		description = "Voice detection type to use.",
		position = 5
	)
	default AudioMode audioMode()
	{
		return AudioMode.VOICE_ACTIVITY;
	}

	/**
	 * Config for the threshold of voice activation
	 *
	 * @return -127 to 0, depending on selection
	 */
	@Range(min = -127, max = 0)
	@ConfigItem(
		keyName = "activationThreshold",
		name = "Activation Threshold",
		description = "Threshold for voice activation in dB. Range: -127 - 0",
		position = 6
	)
	default int activationThreshold()
	{
		return -50;
	}

	/**
	 * Config for the push to talk key
	 *
	 * @return user-set keybind for push to talk
	 */
	@ConfigItem(
		keyName = "pushToTalk",
		name = "PTT Key",
		description = "Push To Talk Key",
		position = 7
	)
	default Keybind pushToTalk()
	{
		return Keybind.NOT_SET;
	}

	/**
	 * Config for the mute mic key
	 *
	 * @return user-set keybind for mute mic
	 */
	@ConfigItem(
		keyName = "toggleMute",
		name = "Mute Mic",
		description = "Push to mute mic",
		position = 8
	)
	default Keybind toggleMute()
	{
		return Keybind.NOT_SET;
	}

	/**
	 * Config for mic amplification
	 *
	 * @return value to amplify microphone audio by
	 */
	@Range(max = 100)
	@ConfigItem(
		keyName = "micVolume",
		name = "Mic Volume",
		description = "Range 0 - 100",
		position = 9
	)
	default int micVolume()
	{
		return 25;
	}

	/**
	 * Config for the mute speakers key
	 *
	 * @return user-set keybind for mute speaker
	 */
	@ConfigItem(
		keyName = "toggleMuteSpeaker",
		name = "Mute Speaker",
		description = "Push to mute speakers",
		position = 10
	)
	default Keybind toggleMuteSpeaker()
	{
		return Keybind.NOT_SET;
	}

	/**
	 * Config for speaker amplification
	 *
	 * @return value to amplify speaker audio by
	 */
	@Range(max = 100)
	@ConfigItem(
		keyName = "speakerVolume",
		name = "Speaker Volume",
		description = "Range 0 - 100",
		position = 11
	)
	default int speakerVolume()
	{
		return 50;
	}

	/**
	 * Toggle to display license information for icons used
	 *
	 * @return unused, boolean to make it a checkbox in the config panel
	 */
	@ConfigItem(
		keyName = "showLicenseInfo",
		name = "Display Icon License",
		description = "Acts as a button. Click to show icon license info",
		position = 99
	)
	default boolean showLicenseInfo()
	{
		return false;
	}
}

package com.thatgamerblue.osrs.proxchat.client;

import com.google.inject.Inject;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ImageUtil;

/**
 * Overlay for displaying current microphone, speaker and connection states to the user
 */
public class ProxChatClientOverlay extends Overlay
{
	/**
	 * Plugin instance for getting the states
	 */
	private final ProxChatClientPlugin plugin;
	/**
	 * Image to display if the network is disconnected
	 */
	private final BufferedImage disconnectedImg;
	/**
	 * Image to display if the microphone is muted
	 */
	private final BufferedImage micMutedImg;
	/**
	 * Image to display if the mic is transmitting
	 */
	private final BufferedImage micActiveImg;
	/**
	 * Image to display if the output is muted
	 */
	private final BufferedImage outputMutedImg;

	/**
	 * Constructs a new instance of this overlay. Uses guice for that fancy dependency injection
	 *
	 * @param plugin plugin instance provided by guice
	 */
	@Inject
	public ProxChatClientOverlay(ProxChatClientPlugin plugin)
	{
		this.plugin = plugin;

		disconnectedImg = ImageUtil.loadImageResource(ProxChatClientPlugin.class, "disconnected.png");
		micMutedImg = ImageUtil.loadImageResource(ProxChatClientPlugin.class, "mic-muted.png");
		micActiveImg = ImageUtil.loadImageResource(ProxChatClientPlugin.class, "mic-active.png");
		outputMutedImg = ImageUtil.loadImageResource(ProxChatClientPlugin.class, "output-muted.png");

		setLayer(OverlayLayer.UNDER_WIDGETS);
		setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
	}

	/**
	 * Renders this overlay to the provided graphics instance
	 *
	 * @param graphics graphics instance to draw to
	 * @return dimensions of the drawn overlay, or 32x32 in the case of no drawing
	 */
	@Override
	public Dimension render(Graphics2D graphics)
	{
		BufferedImage image1 = null;
		BufferedImage image2 = null;
		if (!plugin.getNetwork().isConnected())
		{
			image1 = disconnectedImg;
		}
		else if (plugin.getMicThread().isToggleMute())
		{
			image1 = micMutedImg;
		}
		else if (plugin.getNetwork().getMicTransmitting().get())
		{
			image1 = micActiveImg;
		}

		if (plugin.getNetwork().getSpeakerMuted().get())
		{
			if (image1 == null)
			{
				image1 = outputMutedImg;
			}
			else
			{
				image2 = outputMutedImg;
			}
		}

		if (image1 == null)
		{
			// return a 32x32 square so the user can still move the overlay around
			return new Dimension(32, 32);
		}

		graphics.drawImage(image1, 0, 0, null);
		if (image2 != null)
		{
			graphics.drawImage(image2, 0, 34, null);
		}

		return new Dimension(32, image2 == null ? 32 : 66);
	}
}

package com.thatgamerblue.osrs.proxchat.client;

import com.esotericsoftware.minlog.Log;
import com.google.common.collect.ImmutableSet;
import com.google.inject.Inject;
import com.google.inject.Provides;
import com.thatgamerblue.osrs.proxchat.client.audio.MicThread;
import com.thatgamerblue.osrs.proxchat.client.net.ClientNetworkHandler;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

/**
 * Entrypoint for the Proximity Chat client
 * <p>
 * This is a RuneLite plugin
 */
@Slf4j
@PluginDescriptor(
	name = "Proximity Chat"
)
public class ProxChatClientPlugin extends Plugin
{
	/**
	 * License string for icons
	 */
	private static final String ICON_LICENSE =
		"Icons from iconfinder.com (Benjamin STAWARZ)\r\n" +
			"All licensed under CC Abbrib. 3.0 Unported:\r\n" +
			"https://creativecommons.org/licenses/by/3.0/\r\n" +
			"Disconnected: iconfinder.com/icons/6137632\r\n" +
			"Output Muted: iconfinder.com/icons/6138050\r\n" +
			"Mic Muted: iconfinder.com/icons/6138089\r\n" +
			"Mic Active: iconfinder.com/icons/6138088\r\n" +
			"Modified by ThatGamerBlue, filled in icons";

	/**
	 * Set of config keys that require disconnecting and reconnecting to the server
	 */
	private static final Set<String> RECONNECT_CONFIGS = ImmutableSet.of("address", "port", "password", "enabled");

	/**
	 * Instance of the RuneScape game client
	 */
	@Inject
	private Client client;

	/**
	 * Holds the configuration for the client side
	 */
	@Getter
	@Inject
	private ProxChatClientConfig config;

	/**
	 * Used to connect to the server on so we don't block the UI or Client threads
	 */
	@Getter
	private ScheduledExecutorService executor;

	/**
	 * RuneLite's key manager. Used to detect if PTT or toggle mute is in effect
	 */
	@Inject
	private KeyManager keyManager;

	/**
	 * Listener for PTT and toggle mute keys
	 */
	@Inject
	private ProxKeyHandler keyHandler;

	/**
	 * RuneLite's overlay manager, for registering overlays to be drawn
	 */
	@Inject
	private OverlayManager overlayManager;

	/**
	 * Instance of our overlay for displaying state to the user
	 */
	@Inject
	private ProxChatClientOverlay overlay;

	/**
	 * The networking handler for the client side
	 */
	@Getter
	private ClientNetworkHandler network;

	/**
	 * The thread responsible for reading and sending out microphone data
	 */
	@Getter
	private MicThread micThread;

	/**
	 * Does some magic with guice to make the config work
	 *
	 * @param configManager RuneLite's {@link net.runelite.client.config.ConfigManager} instance
	 * @return the {@link com.thatgamerblue.osrs.proxchat.client.ProxChatClientConfig} instance
	 */
	@Provides
	ProxChatClientConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ProxChatClientConfig.class);
	}

	/**
	 * Main entrypoint for the plugin
	 */
	@Override
	protected void startUp()
	{
		Log.set(Log.LEVEL_INFO);
		executor = Executors.newSingleThreadScheduledExecutor();
		network = new ClientNetworkHandler(this, client, config::address, config::port, config::password, config::enabled, config::room);
		network.initKryonet();

		micThread = new MicThread(network, config::micVolume, config::activationThreshold, config::audioMode, client::getGameState);
		micThread.start();

		executor.submit(() -> network.connect());

		keyManager.registerKeyListener(keyHandler);

		overlayManager.add(overlay);
	}

	/**
	 * Called when the plugin shuts down
	 */
	@Override
	protected void shutDown()
	{
		overlayManager.remove(overlay);
		
		keyManager.unregisterKeyListener(keyHandler);
		network.cancelConnecting();
		executor.submit(() -> network.disconnect());
		if (micThread != null)
		{
			micThread.end();
		}

		executor.submit(System::gc);
		executor.shutdown();
	}

	/**
	 * Fired whenever a config key changes. Used to detect when to disconnect from and reconnect to the server
	 * Also used to show icon license information
	 *
	 * @param event ConfigChanged event object fired by runelite
	 */
	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!"blueproxchat".equals(event.getGroup()))
		{
			return;
		}

		if (RECONNECT_CONFIGS.contains(event.getKey()))
		{
			executor.submit(() ->
			{
				if (!event.getKey().equals("enabled") && !network.isConnected() && !network.isConnecting())
				{
					return;
				}
				network.cancelConnecting();
				network.disconnect();
				network.connect();
			});
		}
		else if ("showLicenseInfo".equals(event.getKey()))
		{
			SwingUtilities.invokeLater(() -> JOptionPane.showMessageDialog(null, ICON_LICENSE, "Blue's Prox Chat", JOptionPane.INFORMATION_MESSAGE));
		}
	}

	/**
	 * Event fired roughly every 20ms by the RuneScape client
	 *
	 * @param event ignored
	 */
	@Subscribe
	public void onClientTick(ClientTick event)
	{
		network.sendUpdate(client.getGameState().getState());
	}

	/**
	 * Event fired every time the {@link net.runelite.api.GameState} of the client changes
	 *
	 * @param event event object containing the new state
	 */
	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState().getState() < GameState.LOGIN_SCREEN.getState())
		{
			return;
		}

		network.sendUpdate(event.getGameState().getState());
	}
}

package com.thatgamerblue.osrs.proxchat.client;

import java.awt.event.KeyEvent;
import javax.inject.Inject;
import net.runelite.client.input.KeyListener;

/**
 * Handles keypresses for push-to-talk and toggle mute
 */
public class ProxKeyHandler implements KeyListener
{
	/**
	 * Plugin instance to get the keybinds and access the mic thread
	 */
	@Inject
	private ProxChatClientPlugin plugin;

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void keyTyped(KeyEvent e)
	{
		if (plugin.getConfig().pushToTalk().matches(e))
		{
			plugin.getMicThread().setPttDown(true);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void keyPressed(KeyEvent e)
	{
		if (plugin.getConfig().pushToTalk().matches(e))
		{
			plugin.getMicThread().setPttDown(true);
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void keyReleased(KeyEvent e)
	{
		if (plugin.getConfig().pushToTalk().matches(e))
		{
			plugin.getMicThread().setPttDown(false);
		}

		if (plugin.getConfig().toggleMute().matches(e))
		{
			plugin.getMicThread().toggleMute();
		}

		if (plugin.getConfig().toggleMuteSpeaker().matches(e))
		{
			plugin.getNetwork().toggleSpeakerMute();
		}
	}
}

package com.thatgamerblue.osrs.proxchat.common.audio;

import java.time.temporal.Temporal;
import java.util.concurrent.TimeUnit;
import javax.sound.sampled.AudioFormat;
import net.runelite.api.Perspective;

/**
 * Small class to hold constants related to audio encoding and decoding
 */
public class AudioConstants
{
	/**
	 * Minimum distance before applying volume scaling based off distance
	 */
	public static final int MIN_DISTANCE = 5 * Perspective.LOCAL_TILE_SIZE;

	/**
	 * Max distance for an audio packet before dropping
	 */
	public static final int MAX_DISTANCE = 15 * Perspective.LOCAL_TILE_SIZE;

	/**
	 * Audio sample rate used for encoding and decoding.
	 */
	public static final int SAMPLE_RATE = 24000;

	/**
	 * Milliseconds of audio per packet
	 */
	public static final int MS_PER_PACKET = 20;

	/**
	 * Size for each packet.
	 * <p>
	 * Packet size (in bytes) is equal to
	 * <ul>
	 * <li>(SAMPLE_RATE / 1000) * 2 * 20;</li>
	 * <li>SAMPLES_PER_MS * BYTES_PER_SHORT * MS_PER_PACKET;</li>
	 * </ul>
	 */
	public static final int FRAME_SIZE = (SAMPLE_RATE / 1000) * Short.BYTES * MS_PER_PACKET;

	/**
	 * AudioFormat for reading from the mic
	 */
	public static final AudioFormat MONO_FORMAT = new AudioFormat(SAMPLE_RATE, 16, 1, true, false);

	/**
	 * AudioFormat for playing to the speaker
	 */
	public static final AudioFormat STEREO_FORMAT = new AudioFormat(SAMPLE_RATE, 16, 2, true, false);
}

package com.thatgamerblue.osrs.proxchat.common.net.messages.c2s;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.ToString;

/**
 * A packet sent from client to server to authenticate. Uses the number in the S2CHello to help prevent replay attacks
 * <p>
 * I know this isn't secure by any stretch of the imagination, but I don't care enough to fix it.
 * Use a strong random password and just don't get sniffed 4Head
 */
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class C2SAuth
{
	/**
	 * The password to authenticate with the server
	 */
	public byte[] password;

	/**
	 * Serializes a C2SAuth packet to binary
	 */
	public static class Serializer extends com.esotericsoftware.kryo.Serializer<C2SAuth>
	{
		/**
		 * Serialize to binary
		 *
		 * @param kryo   gets serializers for other types
		 * @param output output stream
		 * @param packet packet to write
		 */
		@Override
		public void write(Kryo kryo, Output output, C2SAuth packet)
		{
			kryo.getSerializer(byte[].class).write(kryo, output, packet.password);
		}

		/**
		 * Deserialize from binary
		 *
		 * @param kryo   unused
		 * @param input  input stream
		 * @param aClass unused
		 * @return deserialized packet
		 */
		@Override
		public C2SAuth read(Kryo kryo, Input input, Class<C2SAuth> aClass)
		{
			return new C2SAuth((byte[]) kryo.getSerializer(byte[].class).read(kryo, input, byte[].class));
		}
	}
}

package com.thatgamerblue.osrs.proxchat.common.net.messages.c2s;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.ToString;

/**
 * A packet sent from client to server containing microphone data
 */
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class C2SMicPacket
{
	/**
	 * Microphone data
	 */
	public byte[] data;

	/**
	 * Serializes a C2SMicPacket packet to binary
	 */
	public static class Serializer extends com.esotericsoftware.kryo.Serializer<C2SMicPacket>
	{
		/**
		 * Serialize to binary
		 *
		 * @param kryo   gets serializers for other types
		 * @param output output stream
		 * @param packet packet to write
		 */
		@Override
		public void write(Kryo kryo, Output output, C2SMicPacket packet)
		{
			kryo.getSerializer(byte[].class).write(kryo, output, packet.data);
		}

		/**
		 * Deserialize from binary
		 *
		 * @param kryo   unused
		 * @param input  input stream
		 * @param aClass unused
		 * @return deserialized packet
		 */
		@Override
		public C2SMicPacket read(Kryo kryo, Input input, Class<C2SMicPacket> aClass)
		{
			return new C2SMicPacket((byte[]) kryo.getSerializer(byte[].class).read(kryo, input, byte[].class));
		}
	}
}

package com.thatgamerblue.osrs.proxchat.common.net.messages.c2s;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.ToString;

/**
 * A packet sent from client to server containing player position and game state
 */
@ToString
@EqualsAndHashCode
@NoArgsConstructor
@AllArgsConstructor
public class C2SUpdatePacket
{
	/**
	 * Player x position
	 */
	public int x;
	/**
	 * Player y position
	 */
	public int y;
	/**
	 * Player plane
	 */
	public int plane;
	/**
	 * Player world
	 */
	public int world;
	/**
	 * Client game state
	 */
	public int gameState;
	/**
	 * Shared room name
	 */
	public String room;

	/**
	 * Serializes a C2SUpdatePacket to binary
	 */
	public static class Serializer extends com.esotericsoftware.kryo.Serializer<C2SUpdatePacket>
	{
		/**
		 * Serialize to binary
		 *
		 * @param kryo   unused
		 * @param output output stream
		 * @param packet packet to write
		 */
		@Override
		public void write(Kryo kryo, Output output, C2SUpdatePacket packet)
		{
			output.writeInt(packet.x);
			output.writeInt(packet.y);
			output.writeInt(packet.plane);
			output.writeInt(packet.world);
			output.writeInt(packet.gameState);
			output.writeString(packet.room);
		}

		/**
		 * Deserialize from binary
		 *
		 * @param kryo   unused
		 * @param input  input stream
		 * @param aClass unused
		 * @return deserialized packet
		 */
		@Override
		public C2SUpdatePacket read(Kryo kryo, Input input, Class<C2SUpdatePacket> aClass)
		{
			return new C2SUpdatePacket(input.readInt(), input.readInt(), input.readInt(), input.readInt(), input.readInt(), input.readString());
		}
	}
}

package com.thatgamerblue.osrs.proxchat.common.net.messages.s2c;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.ToString;

/**
 * A packet sent from server to client acknowledging its existence and providing a number to help prevent replay attacks
 */
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class S2CAuthReq
{
	/**
	 * An int used to help prevent replay attacks
	 */
	public int replay;

	/**
	 * Serializes a S2CAuthReq packet to binary
	 */
	public static class Serializer extends com.esotericsoftware.kryo.Serializer<S2CAuthReq>
	{
		/**
		 * Serialize to binary
		 *
		 * @param kryo   unused
		 * @param output output stream
		 * @param packet packet to write
		 */
		@Override
		public void write(Kryo kryo, Output output, S2CAuthReq packet)
		{
			output.writeInt(packet.replay);
		}

		/**
		 * Deserialize from binary
		 *
		 * @param kryo   unused
		 * @param input  input stream
		 * @param aClass unused
		 * @return deserialized packet
		 */
		@Override
		public S2CAuthReq read(Kryo kryo, Input input, Class<S2CAuthReq> aClass)
		{
			return new S2CAuthReq(input.readInt());
		}
	}
}

package com.thatgamerblue.osrs.proxchat.common.net.messages.s2c;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.ToString;

/**
 * A packet sent from server to client signalling the end of a decoder
 */
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class S2CKillDecoder
{
	/**
	 * The UUID of the decoder to kill
	 */
	public UUID uuid;

	/**
	 * Serializes a S2CKillDecoder packet to binary
	 */
	public static class Serializer extends com.esotericsoftware.kryo.Serializer<S2CKillDecoder>
	{
		/**
		 * Serialize to binary
		 *
		 * @param kryo   gets serializers for other types
		 * @param output output stream
		 * @param packet packet to write
		 */
		@Override
		public void write(Kryo kryo, Output output, S2CKillDecoder packet)
		{
			kryo.getSerializer(UUID.class).write(kryo, output, packet.uuid);
		}

		/**
		 * Deserialize from binary
		 *
		 * @param kryo   unused
		 * @param input  input stream
		 * @param aClass unused
		 * @return deserialized packet
		 */
		@Override
		public S2CKillDecoder read(Kryo kryo, Input input, Class<S2CKillDecoder> aClass)
		{
			return new S2CKillDecoder((UUID) kryo.getSerializer(UUID.class).read(kryo, input, UUID.class));
		}
	}
}

package com.thatgamerblue.osrs.proxchat.common.net.messages.s2c;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.ToString;

/**
 * A packet sent from server to client containing audio data to play
 */
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class S2CMicPacket
{
	/**
	 * UUID of the decoder to use
	 */
	public UUID decoder;
	/**
	 * Audio data to decode
	 */
	public byte[] data;
	/**
	 * Distance away of the transmitting player
	 */
	public int distance;

	/**
	 * Serializes a S2CMicPacket to binary
	 */
	public static class Serializer extends com.esotericsoftware.kryo.Serializer<S2CMicPacket>
	{
		/**
		 * Serialize to binary
		 *
		 * @param kryo   gets serializers for other types
		 * @param output output stream
		 * @param packet packet to write
		 */
		@Override
		public void write(Kryo kryo, Output output, S2CMicPacket packet)
		{
			kryo.getSerializer(UUID.class).write(kryo, output, packet.decoder);
			kryo.getSerializer(byte[].class).write(kryo, output, packet.data);
			output.writeInt(packet.distance);
		}

		/**
		 * Deserialize from binary
		 *
		 * @param kryo   gets serializers for other types
		 * @param input  input stream
		 * @param aClass unused
		 * @return deserialized packet
		 */
		@Override
		public S2CMicPacket read(Kryo kryo, Input input, Class<S2CMicPacket> aClass)
		{
			UUID uuid = (UUID) kryo.getSerializer(UUID.class).read(kryo, input, UUID.class);
			byte[] data = (byte[]) kryo.getSerializer(byte[].class).read(kryo, input, byte[].class);
			return new S2CMicPacket(uuid, data, input.readInt());
		}
	}
}

package com.thatgamerblue.osrs.proxchat.common.net.messages.s2c;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import lombok.NoArgsConstructor;
import lombok.ToString;

/**
 * A packet sent from server to client requesting a state update
 */
@ToString
@NoArgsConstructor
public class S2CUpdateReq
{
	/**
	 * Serializes a S2CUpdateReq packet to binary
	 */
	public static class Serializer extends com.esotericsoftware.kryo.Serializer<S2CUpdateReq>
	{
		@Override
		public void write(Kryo kryo, Output output, S2CUpdateReq s2CUpdateReq)
		{

		}

		@Override
		public S2CUpdateReq read(Kryo kryo, Input input, Class<S2CUpdateReq> aClass)
		{
			return new S2CUpdateReq();
		}
	}
}

package com.thatgamerblue.osrs.proxchat.common.net.messages.test;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.ToString;

/**
 * Packet sent from test client to test server containing a string
 */
@ToString
@AllArgsConstructor
@NoArgsConstructor
public class C2STestPacket
{
	/**
	 * Will be printed out on the other side
	 */
	public String s;

	/**
	 * Serializes a C2STestPacket packet to binary
	 */
	public static class Serializer extends com.esotericsoftware.kryo.Serializer<C2STestPacket>
	{
		@Override
		public void write(Kryo kryo, Output output, C2STestPacket packet)
		{
			output.writeString(packet.s);
		}

		@Override
		public C2STestPacket read(Kryo kryo, Input input, Class<C2STestPacket> aClass)
		{
			return new C2STestPacket(input.readString());
		}
	}
}

package com.thatgamerblue.osrs.proxchat.common.net.messages.test;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.ToString;

/**
 * Packet sent from test server to test client containing a string
 */
@ToString
@AllArgsConstructor
@NoArgsConstructor
public class S2CTestPacket
{
	/**
	 * Will be printed out on the other side
	 */
	public String s;

	/**
	 * Serializes a S2CTestPacket packet to binary
	 */
	public static class Serializer extends com.esotericsoftware.kryo.Serializer<S2CTestPacket>
	{
		@Override
		public void write(Kryo kryo, Output output, S2CTestPacket packet)
		{
			output.writeString(packet.s);
		}

		@Override
		public S2CTestPacket read(Kryo kryo, Input input, Class<S2CTestPacket> aClass)
		{
			return new S2CTestPacket(input.readString());
		}
	}
}

package com.thatgamerblue.osrs.proxchat.common.net;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryonet.Client;
import com.esotericsoftware.kryonet.Connection;
import com.esotericsoftware.kryonet.EndPoint;
import com.esotericsoftware.kryonet.Listener;
import com.esotericsoftware.kryonet.Server;
import com.thatgamerblue.osrs.proxchat.common.net.messages.c2s.C2SAuth;
import com.thatgamerblue.osrs.proxchat.common.net.messages.c2s.C2SMicPacket;
import com.thatgamerblue.osrs.proxchat.common.net.messages.c2s.C2SUpdatePacket;
import com.thatgamerblue.osrs.proxchat.common.net.messages.s2c.S2CAuthReq;
import com.thatgamerblue.osrs.proxchat.common.net.messages.s2c.S2CKillDecoder;
import com.thatgamerblue.osrs.proxchat.common.net.messages.s2c.S2CMicPacket;
import com.thatgamerblue.osrs.proxchat.common.net.messages.s2c.S2CUpdateReq;
import com.thatgamerblue.osrs.proxchat.common.serializers.ByteArySerializer;
import com.thatgamerblue.osrs.proxchat.common.serializers.UUIDSerializer;
import java.io.IOException;
import java.util.UUID;

/**
 * Superclass for both client and server networking classes.
 * Contains common code such as message receiving and initialization of kryo.
 */
public abstract class NetworkHandler
{
	/**
	 * Holds the {@link com.esotericsoftware.kryonet.Client} instance of this NetworkHandler
	 * Null on the server side.
	 */
	protected Client netClient;
	/**
	 * Holds the {@link com.esotericsoftware.kryonet.Server} instance of this NetworkHandler
	 * Null on the client side.
	 */
	protected Server netServer;

	/**
	 * Determines if we're acting as the server or as a client
	 */
	protected final Mode networkMode;

	/**
	 * Should not be initialized directly, rather as a subclass, usually
	 * {@link com.thatgamerblue.osrs.proxchat.client.net.ClientNetworkHandler} or
	 * {@link com.thatgamerblue.osrs.proxchat.server.net.ServerNetworkHandler}
	 *
	 * @param mode operating mode to enter
	 */
	protected NetworkHandler(Mode mode)
	{
		this.networkMode = mode;
	}

	/**
	 * Initializes everything to do with Kryonet.
	 * In shared code because kryonet is finicky about initialization order
	 */
	public void initKryonet()
	{
		// grab the correct instance of kryo based off the operating mode
		Kryo kryo;
		switch (networkMode)
		{
			case CLIENT:
				netClient = new Client(16384, 16384);
				kryo = netClient.getKryo();
				break;
			case SERVER:
				netServer = new Server(16384, 16384);
				kryo = netServer.getKryo();
				break;
			default:
				throw new IllegalStateException("Unexpected value: " + networkMode);
		}

		// register used types
		kryo.register(byte[].class, new ByteArySerializer());
		kryo.register(UUID.class, new UUIDSerializer());

		// register C2S packets
		kryo.register(C2SAuth.class, new C2SAuth.Serializer());
		kryo.register(C2SMicPacket.class, new C2SMicPacket.Serializer());
		kryo.register(C2SUpdatePacket.class, new C2SUpdatePacket.Serializer());

		// register S2C packets
		kryo.register(S2CAuthReq.class, new S2CAuthReq.Serializer());
		kryo.register(S2CKillDecoder.class, new S2CKillDecoder.Serializer());
		kryo.register(S2CMicPacket.class, new S2CMicPacket.Serializer());
		kryo.register(S2CUpdateReq.class, new S2CUpdateReq.Serializer());

		EndPoint endPoint;

		switch (networkMode)
		{
			case CLIENT:
				endPoint = netClient;
				break;
			case SERVER:
				endPoint = netServer;
				break;
			default:
				throw new IllegalStateException("Unexpected value: " + networkMode);
		}

		endPoint.addListener(new Listener()
		{
			@Override
			public void connected(Connection connection)
			{
				onConnected(connection);
			}

			@Override
			public void disconnected(Connection connection)
			{
				onDisconnected(connection);
			}

			@Override
			public void received(Connection connection, Object o)
			{
				onMessageReceived(connection, o);
			}
		});
	}

	/**
	 * Initializes networking, should be called AFTER {@link NetworkHandler#initKryonet()}
	 * Creates listener on the server, connects to the server on the client
	 *
	 * @throws java.io.IOException when any networking errors occur
	 */
	public abstract void connect() throws IOException;

	/**
	 * Called when a successful connection is established
	 *
	 * @param connection connection object from kryonet
	 */
	protected abstract void onConnected(Connection connection);

	/**
	 * Called when a message is received over the network
	 *
	 * @param connection connection object from kryonet
	 * @param message    message object deserialized by kryonet
	 */
	protected abstract void onMessageReceived(Connection connection, Object message);

	/**
	 * Called when a connection is disconnected
	 *
	 * @param connection connection object from kryonet
	 */
	protected abstract void onDisconnected(Connection connection);

	/**
	 * Disconnects all open connections and releases all memory used by natives
	 * Makes no guarantees about the re-usability of this instance.
	 *
	 * @throws java.io.IOException when any networking errors occur
	 */
	public abstract void disconnect() throws IOException;

	/**
	 * Enum for holding possible operating modes.
	 */
	public enum Mode
	{
		/**
		 * Operating mode for acting as a CLIENT
		 */
		CLIENT,
		/**
		 * Operating mode for active as a SERVER
		 */
		SERVER;
	}
}

package com.thatgamerblue.osrs.proxchat.common.serializers;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.Serializer;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;

/**
 * Kryo {@link com.esotericsoftware.kryo.Serializer} for byte arrays
 */
public class ByteArySerializer extends Serializer<byte[]>
{
	/**
	 * Serializes a byte array into the output
	 * <p>
	 * Writes:
	 * <ul>
	 * <li>int: length of byte array</li>
	 * <li>byte[]: contents of byte array</li>
	 * </ul>
	 *
	 * @param kryo   unused
	 * @param output output stream to write into
	 * @param bytes  byte array to write
	 */
	@Override
	public void write(Kryo kryo, Output output, byte[] bytes)
	{
		output.writeInt(bytes.length);
		output.write(bytes);
	}

	/**
	 * Deserializes a byte array from the input
	 * <p>
	 * Reads:
	 * <ul>
	 * <li>int: length of byte array</li>
	 * <li>byte[]: contents of byte array</li>
	 * </ul>
	 *
	 * @param kryo   unused
	 * @param input  input stream to read from
	 * @param aClass unused
	 * @return a byte array read from input
	 */
	@Override
	public byte[] read(Kryo kryo, Input input, Class<byte[]> aClass)
	{
		int len = input.readInt();
		byte[] ary = new byte[len];
		input.read(ary);
		return ary;
	}
}

package com.thatgamerblue.osrs.proxchat.common.serializers;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.Serializer;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;
import java.util.UUID;

/**
 * Kryo {@link com.esotericsoftware.kryo.Serializer} for UUIDs
 */
public class UUIDSerializer extends Serializer<UUID>
{
	/**
	 * Serializes a UUID into the output
	 * <p>
	 * Writes:
	 * <ul>
	 * <li>long: uuid MSB</li>
	 * <li>long: uuid LSB</li>
	 * </ul>
	 *
	 * @param kryo   unused
	 * @param output output stream to write into
	 * @param uuid   uuid to write
	 */
	@Override
	public void write(Kryo kryo, Output output, UUID uuid)
	{
		output.writeLong(uuid.getMostSignificantBits());
		output.writeLong(uuid.getLeastSignificantBits());
	}

	/**
	 * Deserializes a UUID from the input
	 * <p>
	 * Reads:
	 * <ul>
	 * <li>long: uuid MSB</li>
	 * <li>long: uuid LSB</li>
	 * </ul>
	 *
	 * @param kryo   unused
	 * @param input  input stream to read from
	 * @param aClass unused
	 */
	@Override
	public UUID read(Kryo kryo, Input input, Class<UUID> aClass)
	{
		return new UUID(input.readLong(), input.readLong());
	}
}

package com.thatgamerblue.osrs.proxchat.client.test;

import com.thatgamerblue.osrs.proxchat.client.ProxChatClientPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import org.apache.commons.lang3.ArrayUtils;

/**
 * Runs the plugin.
 */
public class RunPlugin
{
	/**
	 * Main entrypoint for RuneLite w/ the plugin enabled
	 *
	 * @param args any command line arguments
	 * @throws Exception if runelite throws an exception
	 */
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ProxChatClientPlugin.class);
		RuneLite.main(ArrayUtils.add(args, "--developer-mode"));
	}
}

package com.thatgamerblue.osrs.proxchat.client.test;

import com.esotericsoftware.kryonet.Client;
import com.esotericsoftware.kryonet.Connection;
import com.esotericsoftware.kryonet.Listener;
import com.esotericsoftware.minlog.Log;
import com.thatgamerblue.osrs.proxchat.common.net.messages.test.C2STestPacket;
import com.thatgamerblue.osrs.proxchat.common.net.messages.test.S2CTestPacket;
import java.io.IOException;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;

/**
 * Simple test client, created so I can get familiar with how kryonet works
 */
public class TestClient
{
	/**
	 * Main entrypoint for the test client
	 *
	 * @param args any command line arguments
	 * @throws IOException if an error occurs. It's a test client nobody cares about exceptions.
	 */
	public static void main(String[] args) throws IOException
	{
		Log.set(Log.LEVEL_TRACE);
		TestClientNetworkHandler netHandler = new TestClientNetworkHandler(
			() -> "mainland.server",
			() -> 30666
		);
		netHandler.connect();
		// block forever because the client thread is a daemon
		while (true)
		{
			;
		}
	}

	/**
	 * Class for handling connections to the test client
	 */
	static class TestClientNetworkHandler
	{
		/**
		 * Kryonet client instance
		 */
		Client client = new Client();
		/**
		 * Executor for sending packets on a delay
		 */
		ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
		/**
		 * Hostname/IP address of the server
		 */
		Supplier<String> host;
		/**
		 * Port of the server
		 */
		Supplier<Integer> port;

		/**
		 * Constructs a new TestClientNetworkHandler with the hostname and port supplied
		 *
		 * @param host hostname/ip address of the server
		 * @param port port of the server
		 */
		public TestClientNetworkHandler(
			Supplier<String> host,
			Supplier<Integer> port
		)
		{
			this.host = host;
			this.port = port;
		}

		/**
		 * Initialize kryonet and connect to the server
		 *
		 * @throws IOException if connecting to the server fails
		 */
		public void connect() throws IOException
		{
			initKryonet();
			doConnect();
		}

		/**
		 * Registers all the packets, serializers and listeners used
		 */
		private void initKryonet()
		{
			client.getKryo().register(S2CTestPacket.class, new S2CTestPacket.Serializer());
			client.getKryo().register(C2STestPacket.class, new C2STestPacket.Serializer());

			client.addListener(new Listener()
			{
				@Override
				public void received(Connection connection, Object object)
				{
					if (object instanceof S2CTestPacket)
					{
						System.out.println("recv: " + ((S2CTestPacket) object).s);
						executor.schedule(() -> connection.sendTCP(new C2STestPacket("Client to server")), 10, TimeUnit.SECONDS);
					}
				}
			});
		}

		/**
		 * Connects to the server on the provided port/tcp
		 *
		 * @throws IOException if connecting to the server fails
		 */
		private void doConnect() throws IOException
		{
			client.start();
			client.connect(5000, host.get(), port.get());
		}
	}
}

