package com.attacktimer;

/*
 * Copyright (c) 2022, Nick Graves <https://github.com/ngraves95>
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import lombok.Getter;
import net.runelite.api.Skill;

public enum AttackStyle
{
    ACCURATE("Accurate", Skill.ATTACK),
    AGGRESSIVE("Aggressive", Skill.STRENGTH),
    DEFENSIVE("Defensive", Skill.DEFENCE),
    CONTROLLED("Controlled", Skill.ATTACK, Skill.STRENGTH, Skill.DEFENCE),
    RANGING("Ranging", Skill.RANGED),
    LONGRANGE("Longrange", Skill.RANGED, Skill.DEFENCE),
    CASTING("Casting", Skill.MAGIC),
    DEFENSIVE_CASTING("Defensive Casting", Skill.MAGIC, Skill.DEFENCE),
    OTHER("Other");

    @Getter
    private final String name;
    @Getter
    private final Skill[] skills;

    AttackStyle(String name, Skill... skills)
    {
        this.name = name;
        this.skills = skills;
    }
}
package com.attacktimer;


/*
 * Copyright (c) 2022, Nick Graves <https://github.com/ngraves95>
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * Copyright (c) 2024, Richardant <https://github.com/Richardant>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.attacktimer.VariableSpeed.VariableSpeed;
import com.google.common.collect.ImmutableMap;
import com.google.inject.Provides;
import java.awt.Color;
import java.awt.Dimension;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import javax.inject.Inject;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.Varbits;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.SoundEffectPlayed;
import net.runelite.api.events.VarClientIntChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStats;
import net.runelite.client.game.NPCManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@PluginDescriptor(
        name = "Attack Timer Metronome",
        description = "Shows a visual cue on an overlay every game tick to help timing based activities",
        tags = {"timers", "overlays", "tick", "skilling"}
)
public class AttackTimerMetronomePlugin extends Plugin
{
    public enum AttackState {
        NOT_ATTACKING,
        DELAYED_FIRST_TICK,
        DELAYED,
    }

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private ConfigManager configManager;

    @Inject
    private AttackTimerMetronomeTileOverlay overlay;

    @Inject
    private AttackTimerBarOverlay barOverlay;

    @Inject
    private AttackTimerMetronomeConfig config;

    @Inject
    private ItemManager itemManager;

    @Inject
    private Client client;

    @Inject
    private NPCManager npcManager;

    public int tickPeriod = 0;

    final int ATTACK_DELAY_NONE = 0;

    private int uiUnshowDebounceTickCount = 0;
    private int uiUnshowDebounceTicksMax = 1;

    public int attackDelayHoldoffTicks = ATTACK_DELAY_NONE;

    public AttackState attackState = AttackState.NOT_ATTACKING;
    // The state of the renderer, will lag a few cycles behind the plugin's state. "cycles" in this comment
    // refers to the client.getGameCycle() method, a cycle occurs every 20ms, meaning 30 of them occur per
    // game tick.
    public AttackState renderedState = AttackState.NOT_ATTACKING;

    public Color CurrentColor = Color.WHITE;

    public int DEFAULT_SIZE_UNIT_PX = 25;

    public static final int SALAMANDER_SET_ANIM_ID = 952; // Used by all 4 types of salamander https://oldschool.runescape.wiki/w/Salamander

    private static final int TWINFLAME_STAFF_WEAPON_ID = 30634;
    private static final int ECHO_VENATOR_BOW_WEAPON_ID = 30434;
    private static final int VENATOR_BOW_WEAPON_ID = 27610;

    private static final Map<Integer, Integer> NON_STANDARD_MAGIC_WEAPON_SPEEDS =
            new ImmutableMap.Builder<Integer, Integer>()
                    .put(TWINFLAME_STAFF_WEAPON_ID, 6)
                    .build();

    // Map of problematic itemIds to equivalent working ones.
    // The Echo Venator Bow's ItemStats are returning null, so use the regular bow instead.
    private static final Map<Integer, Integer> WEAPON_ID_MAPPING_WORKAROUNDS =
            new ImmutableMap.Builder<Integer, Integer>()
                    .put(ECHO_VENATOR_BOW_WEAPON_ID, VENATOR_BOW_WEAPON_ID)
                    .build();

    private final int DEFAULT_FOOD_ATTACK_DELAY_TICKS = 3;
    private final int KARAMBWAN_ATTACK_DELAY_TICKS = 2;
    public static final int EQUIPPING_MONOTONIC = 384; // From empirical testing this clientint seems to always increase whenever the player equips an item
    private Spellbook currentSpellBook = Spellbook.STANDARD;
    private int lastEquippingMonotonicValue = -1;
    private int soundEffectTick = -1;
    private int soundEffectId = -1;
    public Dimension DEFAULT_SIZE = new Dimension(DEFAULT_SIZE_UNIT_PX, DEFAULT_SIZE_UNIT_PX);

    private int pendingEatDelayTicks = 0;

    // region subscribers

    @Subscribe
    public void onVarbitChanged(VarbitChanged varbitChanged)
    {
        if (varbitChanged.getVarbitId() == Varbits.SPELLBOOK)
        {
            currentSpellBook = Spellbook.fromVarbit(varbitChanged.getValue());
        }
    }

    // onVarbitChanged happens when the user causes some interaction therefore we can't rely on some fixed
    // timing relative to a tick. A player can swap many items in the duration of the a tick.
    @Subscribe
    public void onVarClientIntChanged(VarClientIntChanged varClientIntChanged)
    {
        final int currentMagicVarBit = client.getVarcIntValue(EQUIPPING_MONOTONIC);
        if (currentMagicVarBit <= lastEquippingMonotonicValue)
        {
            return;
        }
        lastEquippingMonotonicValue = currentMagicVarBit;

        // This windowing safe guards of from late swaps inside a tick, if we have already rendered the tick
        // then we shouldn't perform another attack.
        boolean preAttackWindow = attackState == AttackState.DELAYED_FIRST_TICK && renderedState != attackState;
        if (preAttackWindow)
        {
            // "Perform an attack" this is overwrites the last attack since we now know the user swapped
            // "Something" this tick, the equipped weapon detection will pick up specific weapon swaps. Even
            // swapping more than 1 weapon inside a single tick.
            performAttack();
        }
    }

    // onSoundEffectPlayed used to track spell casts, for when the player casts a spell on first tick coming
    // off cooldown, in some cases (e.g. ice barrage) the player will have no animation. Also they don't have
    // a projectile to detect instead :/
    @Subscribe
    public void onSoundEffectPlayed(SoundEffectPlayed event)
    {
        // event.getSource() will be null if the player cast a spell, it's only for area sounds.
        soundEffectTick = client.getTickCount();
        soundEffectId = event.getSoundId();
    }

    // endregion

    @Provides
    AttackTimerMetronomeConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(AttackTimerMetronomeConfig.class);
    }

    private int getItemIdFromContainer(ItemContainer container, int slotID)
    {
        if (container == null) {
            return -1;
        }
        final Item item = container.getItem(slotID);
        return (item != null) ? item.getId() : -1;
    }

    private int getWeaponId() {
        int weaponId = getItemIdFromContainer(
                client.getItemContainer(InventoryID.EQUIPMENT),
                EquipmentInventorySlot.WEAPON.getSlotIdx()
        );

        return WEAPON_ID_MAPPING_WORKAROUNDS.getOrDefault(weaponId, weaponId);
    }

    private ItemStats getWeaponStats(int weaponId)
    {
        return itemManager.getItemStats(weaponId);
    }

    private boolean getSalamanderAttack()
    {
        return client.getLocalPlayer().hasSpotAnim(SALAMANDER_SET_ANIM_ID);
    }

    private void setAttackDelay()
    {
        int weaponId = getWeaponId();
        AnimationData curAnimation = AnimationData.fromId(client.getLocalPlayer().getAnimation());
        PoweredStaves stave = PoweredStaves.getPoweredStaves(weaponId, curAnimation);
        boolean matchesSpellbook = matchesSpellbook(curAnimation);
        attackDelayHoldoffTicks = getWeaponSpeed(weaponId, stave, curAnimation, matchesSpellbook);
    }

    // matchesSpellbook tries two methods, matching the animation the spell book based on the enum of
    // pre-coded matches, and then the second set of matches against the known sound id of the spell (which
    // unfortunately doesn't work if the player has them disabled).
    private boolean matchesSpellbook(AnimationData curAnimation)
    {
        if (curAnimation != null && curAnimation.matchesSpellbook(currentSpellBook))
        {
            return true;
        }
        if (client.getTickCount() == soundEffectTick)
        {
            return CastingSoundData.getSpellBookFromId(soundEffectId) == currentSpellBook;
        }
        return false;
    }

    private int getMagicBaseSpeed(int weaponId)
    {
        return NON_STANDARD_MAGIC_WEAPON_SPEEDS.getOrDefault(weaponId, 5);
    }

    private int getWeaponSpeed(int weaponId, PoweredStaves stave, AnimationData curAnimation, boolean matchesSpellbook)
    {
        if (stave != null && stave.getAnimations().contains(curAnimation))
        {
            // We are currently dealing with a staves in which case we can make decisions based on the
            // spellbook flag. We can only improve this by using a deprecated API to check the projectile
            // matches the stave rather than a manual spell, but this is good enough for now.
            return VariableSpeed.computeSpeed(client, curAnimation, AttackProcedure.POWERED_STAVE, 4);
        }

        if (matchesSpellbook && isManualCasting(curAnimation))
        {
            // You can cast with anything equipped in which case we shouldn't look to invent for speed.
            return VariableSpeed.computeSpeed(client, curAnimation, AttackProcedure.MANUAL_AUTO_CAST, getMagicBaseSpeed(weaponId));
        }

        ItemStats weaponStats = getWeaponStats(weaponId);
        if (weaponStats == null) {
            return VariableSpeed.computeSpeed(client, curAnimation, AttackProcedure.MELEE_OR_RANGE, 4); // Assume barehanded == 4t
        }
        // Deadline for next available attack.
        return VariableSpeed.computeSpeed(client, curAnimation, AttackProcedure.MELEE_OR_RANGE, weaponStats.getEquipment().getAspeed());
    }

    private static final List<Integer> SPECIAL_NPCS = Arrays.asList(10507, 9435, 9438, 9441, 9444); // Combat Dummy + Nightmare Pillars

    private boolean isPlayerAttacking()
    {
        int animationId = client.getLocalPlayer().getAnimation();
        if (AnimationData.isBlockListAnimation(animationId))
        {
            return false;
        }

        // Not walking is either any player animation or the edge cases which don't trigger an animation, e.g Salamander.
        boolean notWalking = animationId != -1 || getSalamanderAttack();

        // Testing if we are attacking by checking the target is more future
        // proof to new weapons which don't need custom code and the weapon
        // stats are enough.
        Actor target = client.getLocalPlayer().getInteracting();
        if (target != null && (target instanceof NPC))
        {
            final NPC npc = (NPC) target;
            boolean containsAttackOption = Arrays.stream(npc.getComposition().getActions()).anyMatch("Attack"::equals);
            Integer health = npcManager.getHealth(npc.getId());
            boolean hasHealthAndLevel = health != null && health > 0 && target.getCombatLevel() > 0;
            boolean attackingNPC = hasHealthAndLevel || SPECIAL_NPCS.contains(npc.getId()) || containsAttackOption;
            // just having a target is not enough the player may be out of range, we must wait for any
            // animation which isn't running/walking/etc
            return attackingNPC && notWalking;
        }
        if (target != null && (target instanceof Player))
        {
            return notWalking;
        }

        AnimationData fromId = AnimationData.fromId(animationId);
        if (fromId == AnimationData.RANGED_BLOWPIPE || fromId == AnimationData.RANGED_BLAZING_BLOWPIPE)
        {
            // These two animations are the only ones which exceed the duration of their attack cooldown (when
            // on rapid), so in this case DO NOT fall back the animation as it is un-reliable.
            return false;
        }
        // fall back to animations.
        return fromId != null;
    }

    private boolean isManualCasting(AnimationData curId)
    {
        // If you use a weapon like a blow pipe which has an animation longer than it's cool down then cast an
        // ancient attack it wont have an animation at all. We can therefore need to detect this with a list
        // of sounds instead. This obviously doesn't work if the player is muted. ATM I can't think of a way
        // to detect this type of attack as a cast, only sound is an indication that the player is on
        // cooldown, melee attacks, etc will trigger an animation overwriting the last frame of the blowpipe's
        // idle animation.
        boolean castingFromSound = client.getTickCount() == soundEffectTick ? CastingSoundData.isCastingSound(soundEffectId) : false;
        boolean castingFromAnimation = AnimationData.isManualCasting(curId);
        return castingFromSound || castingFromAnimation;
    }

    private void performAttack()
    {
        attackState = AttackState.DELAYED_FIRST_TICK;
        setAttackDelay();
        tickPeriod = attackDelayHoldoffTicks;
        uiUnshowDebounceTickCount = uiUnshowDebounceTicksMax;
    }

    public int getTicksUntilNextAttack()
    {
        return 1 + attackDelayHoldoffTicks;
    }

    public int getWeaponPeriod()
    {
        return tickPeriod;
    }

    public boolean isAttackCooldownPending()
    {
        return attackState == AttackState.DELAYED
            || attackState == AttackState.DELAYED_FIRST_TICK
            || uiUnshowDebounceTickCount > 0;
    }

    @Subscribe
    public void onChatMessage(ChatMessage event)
    {
        final String message = event.getMessage();

        if (message.startsWith("You eat") ||
                message.startsWith("You drink the wine")) {
            int attackDelay = (message.toLowerCase().contains("karambwan")) ?
                    KARAMBWAN_ATTACK_DELAY_TICKS :
                    DEFAULT_FOOD_ATTACK_DELAY_TICKS;

            if (isAttackCooldownPending()) {
                pendingEatDelayTicks += attackDelay;
            }
        }
    }

    // onInteractingChanged is the driver for detecting if the player attacked out side the usual tick window
    // of the onGameTick events.
    @Subscribe
    public void onInteractingChanged(InteractingChanged interactingChanged)
    {
        Actor source = interactingChanged.getSource();
        Actor target = interactingChanged.getTarget();

        Player p = client.getLocalPlayer();

        if (source.equals(p) && (target instanceof NPC)) {
            switch (attackState) {
                case NOT_ATTACKING:
                    // If not previously attacking, this action can result in a queued attack or
                    // an instant attack. If its queued, don't trigger the cooldown yet.
                    if (isPlayerAttacking()) {
                        performAttack();
                    }
                    break;
                case DELAYED_FIRST_TICK:
                    // fallthrough
                case DELAYED:
                    // Don't reset tick counter or tick period.
                    break;
            }
        }

        applyAndClearEats();
    }

    private void applyAndClearEats() {
        int pendingEats = pendingEatDelayTicks;
        attackDelayHoldoffTicks += pendingEats;
        pendingEatDelayTicks -= pendingEats;
    }

    @Subscribe
    public void onGameTick(GameTick tick)
    {
        VariableSpeed.onGameTick(client, tick);
        boolean isAttacking = isPlayerAttacking();
        switch (attackState) {
            case NOT_ATTACKING:
                if (isAttacking) {
                    performAttack(); // Sets state to DELAYED_FIRST_TICK.
                } else {
                    uiUnshowDebounceTickCount--;
                }
                break;
            case DELAYED_FIRST_TICK:
                // we stay in this state for one tick to allow for 0-ticking
                attackState = AttackState.DELAYED;
                // fallthrough
            case DELAYED:
                if (attackDelayHoldoffTicks <= 0) { // Eligible for a new attack
                    if (isAttacking) {
                        performAttack();
                    } else {
                        attackState = AttackState.NOT_ATTACKING;
                    }
                }
        }

        applyAndClearEats();

        attackDelayHoldoffTicks--;
    }


    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (event.getGroup().equals("attacktimermetronome"))
        {
            attackDelayHoldoffTicks = 0;
        }
    }

    @Override
    protected void startUp() throws Exception
    {
        overlayManager.add(overlay);
        overlay.setPreferredSize(DEFAULT_SIZE);
        overlayManager.add(barOverlay);
    }

    @Override
    protected void shutDown() throws Exception
    {
        overlayManager.remove(overlay);
        overlayManager.remove(barOverlay);
        attackDelayHoldoffTicks = 0;
    }
}

package com.attacktimer;

/*
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import lombok.Getter;

// https://oldschool.runescape.wiki/w/Powered_staff
//
// They are typically charged with runes or coins to automatically fire magic projectiles. Unlike other Magic
// weapons, they cannot be used to auto-cast spells. In addition, they have an attack speed of 4, faster than
// other magic weapons, which have an attack speed of 5. The Tumeken's shadow, however, has an attack speed of
// 5. This Enum is only to contain the staves which allow magic at 4 ticks.
enum PoweredStaves
{
    WEAPON_ACCURSED( Set.of(AnimationData.MAGIC_STANDARD_WAVE_STAFF, AnimationData.MAGIC_ACCURSED_SCEPTRE_SPEC), Projectiles(2337, 2339), 27665, 27666), // https://oldschool.runescape.wiki/w/Accursed_sceptre
    WEAPON_BLUE_C_STAFF_A(AnimationData.MAGIC_STANDARD_WAVE_STAFF, Projectiles(1720), 23899), // https://oldschool.runescape.wiki/w/Crystal_staff_(attuned)
    WEAPON_BLUE_C_STAFF_B(AnimationData.MAGIC_STANDARD_WAVE_STAFF, Projectiles(1720), 23898), // https://oldschool.runescape.wiki/w/Crystal_staff_(basic)
    WEAPON_BLUE_C_STAFF_P(AnimationData.MAGIC_STANDARD_WAVE_STAFF, Projectiles(1720),23900), // https://oldschool.runescape.wiki/w/Crystal_staff_(perfected)
    WEAPON_BONE_STAFF(AnimationData.MELEE_GENERIC_SLASH, Projectiles(2647),  28796, 28797), //https://oldschool.runescape.wiki/w/Bone_staff
    WEAPON_DAWNBRINGER(AnimationData.MAGIC_STANDARD_WAVE_STAFF,  Projectiles(1544, 1547),22516), // https://oldschool.runescape.wiki/w/Dawnbringer
    WEAPON_HARM(Set.of(AnimationData.MAGIC_STANDARD_WAVE_STAFF, AnimationData.MAGIC_STANDARD_STRIKE_BOLT_BLAST_STAFF, AnimationData.MAGIC_STANDARD_SURGE_STAFF),
        Projectiles(/*in level order then air -> fire*/
            91, 94, 97, 100, /* strikes */
            118, 121, 124, 127, /* bolts */
            133, 136, 139, 130, /* blasts */
            159, 162, 165, 156, /* waves */
            1456, 1459, 1462, 1465 /* surges */),
        24508), // https://oldschool.runescape.wiki/w/Harmonised_nightmare_staff
    WEAPON_RED_C_STAFF_A(AnimationData.MAGIC_STANDARD_WAVE_STAFF, Projectiles(1723), 23853), // https://oldschool.runescape.wiki/w/Corrupted_staff_(attuned)
    WEAPON_RED_C_STAFF_B(AnimationData.MAGIC_STANDARD_WAVE_STAFF, Projectiles(1723), 23852), // https://oldschool.runescape.wiki/w/Corrupted_staff_(basic)
    WEAPON_RED_C_STAFF_P(AnimationData.MAGIC_STANDARD_WAVE_STAFF, Projectiles(1723), 23854), // https://oldschool.runescape.wiki/w/Corrupted_staff_(perfected)
    WEAPON_SANG(AnimationData.MAGIC_STANDARD_WAVE_STAFF, Projectiles(1539), 22323), // https://oldschool.runescape.wiki/w/Sanguinesti_staff#Charged
    WEAPON_SANG_KIT(AnimationData.MAGIC_STANDARD_WAVE_STAFF, 25731), // https://oldschool.runescape.wiki/w/Holy_sanguinesti_staff#Charged
    WEAPON_STARTER_STAFF(22335, 22336, 28557, 28558), // https://oldschool.runescape.wiki/w/Starter_staff TODO get the animation when DMM goes live
    WEAPON_SWAMP(AnimationData.MAGIC_STANDARD_WAVE_STAFF, Projectiles(1040),12899), // https://oldschool.runescape.wiki/w/Trident_of_the_swamp#Charged
    WEAPON_SWAMP_E(AnimationData.MAGIC_STANDARD_WAVE_STAFF, Projectiles(1252),22292), // https://oldschool.runescape.wiki/w/Trident_of_the_swamp_(e)#Charged
    WEAPON_THAMMARON(AnimationData.MAGIC_STANDARD_WAVE_STAFF, Projectiles(2340),22555, 22556), //https://oldschool.runescape.wiki/w/Thammaron%27s_sceptre
    WEAPON_TRIDENT(AnimationData.MAGIC_STANDARD_WAVE_STAFF, Projectiles(1252), 11907), // https://oldschool.runescape.wiki/w/Trident_of_the_seas#Partially_charged
    WEAPON_TRIDENT_E(AnimationData.MAGIC_STANDARD_WAVE_STAFF, Projectiles(1252),22288), // https://oldschool.runescape.wiki/w/Trident_of_the_seas_(e)#Charged
    WEAPON_WARPED_SCEPTRE(AnimationData.MAGIC_WARPED_SCEPTRE, 28585, 28586); // https://oldschool.runescape.wiki/w/Warped_sceptre

    @Getter
    private final Set<Integer> ids;
    @Getter
    private final Set<Integer> projectiles;
    @Getter
    private final Set<AnimationData> animations;

    private static Set<Integer> Projectiles(int... id)
    {
        ImmutableSet.Builder<Integer> builder = new ImmutableSet.Builder<>();
        if (id.length == 0)
        {
            return builder.build();
        }
        for (int i : id)
        {
            builder.add(i);
        }
        return builder.build();
    }

    // Unknown projectile and animation
    PoweredStaves(int... id)
    {
        this.ids = Projectiles(id);
        this.projectiles = null;
        this.animations = null;
    }

    // Unknown projectile
    PoweredStaves(AnimationData spell, int... id)
    {
        this.ids = Projectiles(id);
        this.projectiles = new HashSet<Integer>();
        this.animations = Set.of(spell);
    }

    // Single animation 4t powered staff
    PoweredStaves(AnimationData spell, Set<Integer> projectiles, int... id)
    {
        this.ids = Projectiles(id);
        this.projectiles = projectiles;
        this.animations = Set.of(spell);
    }
    // Multiple animations 4t powered staff
    PoweredStaves(Set<AnimationData> spell, Set<Integer> projectiles, int... id)
    {
        this.ids = Projectiles(id);
        this.projectiles = projectiles;
        this.animations = spell;
    }

    protected static final boolean LOCAL_DEBUGGING = false;
    protected static final int UNKNOWN_SPELL = 0xDEADBEEF;
    protected static final ImmutableMap<Integer, ImmutableMap<Integer, PoweredStaves>> poweredStaves;

    static
    {
        ImmutableMap.Builder<Integer, ImmutableMap<Integer, PoweredStaves>> builder = new ImmutableMap.Builder<>();

        for (PoweredStaves p : values())
        {
            for (int id : p.ids)
            {
                ImmutableMap.Builder<Integer, PoweredStaves> spellMap = new ImmutableMap.Builder<>();
                if (p.animations == null)
                {
                    spellMap.put(UNKNOWN_SPELL, p);
                }
                else
                {
                    for (AnimationData spell : p.animations)
                    {
                        spellMap.put(spell.animationId, p);
                    }
                }
                builder.put(id, spellMap.build());
            }
        }
        if (LOCAL_DEBUGGING)
        {
            // Fake the kodai to be a harm for testing, because I don't own a harm.
            ImmutableMap.Builder<Integer, PoweredStaves> spellMap = new ImmutableMap.Builder<>();
            for (AnimationData harmAnim : WEAPON_HARM.animations)
            {
                spellMap.put(harmAnim.animationId, WEAPON_HARM);
            }
            builder.put(21006, spellMap.build());
        }

        poweredStaves = builder.build();
    }

    public static PoweredStaves getPoweredStaves(int weaponId, AnimationData animation)
    {
        ImmutableMap<Integer, PoweredStaves> weaponMap = poweredStaves.get(weaponId);
        if (weaponMap == null || animation == null)
        {
            return null;
        }
        // If the data in the enum doesn't have a spell then we can simply return the stave based on the
        // weapon ID only.
        if (weaponMap.containsKey(UNKNOWN_SPELL))
        {
            return weaponMap.get(UNKNOWN_SPELL);
        }
        return weaponMap.get(animation.animationId);
    }

    @Override
    public String toString()
    {
        String[] words = super.toString().toLowerCase().split("_");
        Arrays.stream(words)
                .map(StringUtils::capitalize).collect(Collectors.toList()).toArray(words);

        return String.join(" ", words);
    }

    public boolean MatchesProjectile(int projectile)
    {
        if (this.projectiles == null)
        {
            return false;
        }
        return this.projectiles.contains(projectile);
    }
}

package com.attacktimer;

/*
 * Copyright (c) 2022, Nick Graves <https://github.com/ngraves95>
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * Copyright (c) 2024, Richardant <https://github.com/Richardant>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Range;
import net.runelite.client.config.ConfigSection;
import java.awt.Color;

@ConfigGroup("attacktimermetronome")
public interface AttackTimerMetronomeConfig extends Config
{
	@ConfigItem(
			position = 0,
			keyName = "enableMetronome",
			name = "Attack Timer Metronome",
			description = "Enable visual metronome"
	)
	default boolean enableMetronome()
	{
		return true;
	}

	@ConfigSection(
			name = "Attack Cooldown Tick Settings",
			description = "Change attack tick cooldown settings",
			position = 1
	)
	String TickNumberSettings = "Attack Cooldown Tick Settings";

	@ConfigItem(
			position = 1,
			keyName = "showTick",
			name = "Show Attack Cooldown Ticks",
			description = "Shows number of ticks until next attack",
			section = TickNumberSettings
	)
	default boolean showTick()
	{
		return true;
	}


	@ConfigItem(
			position = 2,
			keyName = "disableFontScaling",
			name = "Disable Font Size Scaling (Metronome Tick Only)",
			description = "Disables font size scaling for metronome tick number",
			section = TickNumberSettings
	)
	default boolean disableFontScaling()
	{
		return false;
	}

	@ConfigItem(
			position = 3,
			keyName = "fontSize",
			name = "Font Size (Overhead Tick Only)",
			description = "Change the font size of the overhead attack cooldown ticks",
			section = TickNumberSettings
	)
	@Range(min = 8, max = 50)
	default int fontSize()
	{
		return 15;
	}

	@ConfigItem(
			position = 4,
			keyName = "countColor",
			name = "Tick Number Color",
			description = "Configures the color of tick number",
			section = TickNumberSettings
	)
	default Color NumberColor()
	{
		return Color.CYAN;
	}

	@ConfigItem(
			position = 5,
			keyName = "lastColor",
			name = "Last Tick Color",
			description = "Configures the color of tick number when it says 1",
			section = TickNumberSettings
	)
	default Color LastColor()
	{
		return Color.CYAN;
	}

	@ConfigItem(
			position = 6,
			keyName = "fontType",
			name = "Font Type",
			description = "Change the font of the tick number",
			section = TickNumberSettings
	)
	default FontTypes fontType()
	{
		return FontTypes.REGULAR; 
	}

	@ConfigItem(
			position = 7,
			keyName = "ticksPosition",
			name = "Ticks Position",
			description = "Position of the tick number respective to the player",
			section = TickNumberSettings
	)
	default TicksPosition ticksPosition()
	{
		return TicksPosition.DEFAULT;
	}

	@ConfigItem(
			position = 8,
			keyName = "tickHeightOffset",
			name = "Height Offset",
			description = "Height offset for minor adjustments of the tick number",
			section = TickNumberSettings
	)
	@Range(min = -50, max = 50)
	default int heightTickOffset()
	{
		return 0;
	}

	@ConfigSection(
			name = "Attack Bar",
			description = "Change the colors and number of colors to cycle through",
			position = 2
	)
	String AttackBarSettings = "Attack Cooldown Bar Settings";

	@ConfigItem(
			position = 1,
			keyName = "attackBar",
			name = "Show Attack Bar",
			description = "Show the attack bar",
			section = AttackBarSettings
	)
	default boolean showBar()
	{
		return false;
	}

	@ConfigItem(
			position = 2,
			keyName = "attackBarHeightOffset",
			name = "Height Offset",
			description = "Height offset for the bar from top of player model",
			section = AttackBarSettings
	)
	@Range(min = -100, max = 100)
	default int heightOffset()
	{
		return 0;
	}

	@ConfigItem(
			position = 3,
			keyName = "attackBarEmpties",
			name = "Empties Before Attack",
			description = "Controls whether the attack bar will fully empty before a new attack can occur",
			section = AttackBarSettings
	)
	default boolean barEmpties()
	{
		return true;
	}

	@ConfigItem(
			position = 4,
			keyName = "attackBarFills",
			name = "Fills Before Attack",
			description = "Controls whether the attack bar will fill completely after an attack",
			section = AttackBarSettings
	)
	default boolean barFills()
	{
		return true;
	}

	@ConfigItem(
			position = 5,
			keyName = "attackBarDirection",
			name = "Attack Bar Fills or Drains",
			description = "Controls whether the attack bar will fill or drain as a cooldown",
			section = AttackBarSettings
	)
	default boolean barDirection()
	{
		return true;
	}

	@Getter
	@AllArgsConstructor
	enum TicksPosition
	{
		DEFAULT("Default"),
		TOP("Top"),
		CENTERED("Centered"),
		BOTTOM("Bottom");

		private final String name;

		@Override
		public String toString()
		{
			return name;
		}
	}
}

package com.attacktimer.VariableSpeed;

/*
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.attacktimer.AnimationData;
import com.attacktimer.AttackProcedure;
import com.attacktimer.AttackType;
import com.attacktimer.ClientUtils.Utils;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;

/**
 * There is no cooldown when attacking the skulls with melee.
 */
public class TombsOfAmascut implements IVariableSpeed
{
    // The skulls during p3 wardens.
    // https://oldschool.runescape.wiki/w/Energy_Siphon
    private static final int ENERGY_SIPHON_ID = 11772;

    public int apply(final Client client, final AnimationData curAnimation, final AttackProcedure atkProcedure, final int baseSpeed, final int curSpeed)
    {
        final int targetId = Utils.getTargetId(client);
        final AttackType attkType = Utils.getAttackType(client);
        if (targetId == ENERGY_SIPHON_ID && attkType.IsMelee())
        {
            return 1;
        }
        return curSpeed;
    }
    public void onGameTick(Client client, GameTick tick) {}
}

package com.attacktimer.VariableSpeed;

/*
 * Copyright (c) 2024-2025, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.attacktimer.AttackProcedure;
import com.attacktimer.AnimationData;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;

public class VariableSpeed {

    /**
     * computeSpeed will forward the client, animation data and current weapon speed to all the known classes
     * which can affect the base speed of a weapon. See implementations of IVariableSpeed.
     * @param client
     * @param curAnimation
     * @param atkType
     * @param baseSpeed
     * @return
     */
    public static int computeSpeed(final Client client, final AnimationData curAnimation, final AttackProcedure atkProcedure, final int baseSpeed)
    {
        int newSpeed = baseSpeed;
        for (IVariableSpeed i : toApply)
        {
            newSpeed = i.apply(client, curAnimation, atkProcedure, baseSpeed, newSpeed);
        }
        return newSpeed;
    }

    public static void onGameTick(Client client, GameTick tick)
    {
        for (IVariableSpeed i : toApply)
        {
            i.onGameTick(client, tick);
        }
    }

    private static final IVariableSpeed[] toApply = {
        // Order matters, apply leagues first, then any incremental modifications like rapid, or set effects.
        // Then overriding speeds last, which set a speed.
        new Leagues(),

        // Incremental:
        new BloodMoonSet(),
        new RapidAttackStyle(),
        new RedKerisSpec(),
        new EyeOfAyak(),
        new TormentedDemons(),

        // Overriding modifiers:
        new Scurrius(),
        new TombsOfAmascut(),
    };

}

package com.attacktimer.VariableSpeed;

/*
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.attacktimer.AnimationData;
import com.attacktimer.AttackProcedure;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;

public interface IVariableSpeed
{
    /**
     * apply is the general method the attack timer plugin will call with all the data about an attack
     * currently being triggered. apply is only called when the plugin is sure the player just started
     * attacking and hence a new cooldown.
     *
     * to ensure a new IVariableSpeed implementation is used ensure to add a new instance of that class in
     * {@see VariableSpeed.toApply}.
     * @param client the RuneScape client.
     * @param curAnimation the animation currently being used to attack.
     * @param atkType the overarching "attack type" for this attack, this is based on all the inference made
     * about manual casts, etc. For more details about the attack {@see com.attacktimer.ClientUtils.Utils}.
     * @param baseSpeed the speed at which the attack speed started before any other variable speeds have
     * changed it.
     * @param curSpeed the current speed at which the attack is now after variable speeds have been applied,
     * e.g. rapid with range style.
     * @return the new attack speed if the pre-conditions for this variable attack speed where met.
     */
    public int apply(Client client, AnimationData curAnimation, AttackProcedure atkType, int baseSpeed, int curSpeed);
    /**
     * onGameTick is pseudo subscription method, a variable speed implementation can implement this if the
     * condition for the variable speed requires some larger state tracking and cannot be implemented in apply
     * alone.
     * @param client the RuneScape client.
     * @param tick the current tick.
     */
    public void onGameTick(Client client, GameTick tick);
}
package com.attacktimer.VariableSpeed;

/*
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.attacktimer.AnimationData;
import com.attacktimer.AttackProcedure;
import com.attacktimer.ClientUtils.Utils;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;

/**
 * Scurrius: https://oldschool.runescape.wiki/w/Scurrius/Strategies#Strategies
 *
 * When attacking the giant rats summoned by Scurrius and attacking them with a bone weapon the player has no
 * attack delay.
 */
public class Scurrius implements IVariableSpeed
{
    private static final int BONE_STAFF_ID = 28796;
    private static final int BONE_MACE_ID = 28792;
    private static final int BONE_BOW_ID = 28794;
    private static final int GIANT_RAT = 7223;

    private static final int SCURRIUS_REGION_ID = 13210;

    private static final int SCURRIUS_MIN_X = 3290;
    private static final int SCURRIUS_MAX_X = 3307;

    private static final int SCURRIUS_MIN_Y = 9859;
    private static final int SCURRIUS_MAX_Y = 9876;

    private static boolean attackingGiantRatWithBoneWeapon(final int equipped, final int regionId, final int x, final int y, final int target)
    {
        final boolean correctWeapon = equipped == BONE_STAFF_ID || equipped == BONE_MACE_ID || equipped == BONE_BOW_ID;
        final boolean correctCoords = x >= SCURRIUS_MIN_X && x <= SCURRIUS_MAX_X && y >= SCURRIUS_MIN_Y && y <= SCURRIUS_MAX_Y;
        final boolean correctRegion = regionId == SCURRIUS_REGION_ID;
        final boolean correctEnemy = target == GIANT_RAT;
        return correctWeapon && correctCoords && correctRegion && correctEnemy;
    }

    public int apply(final Client client, final AnimationData curAnimation, final AttackProcedure atkProcedure, final int baseSpeed, final int curSpeed)
    {
        final WorldPoint location = Utils.getLocation(client);
        final int weaponId = Utils.getWeaponId(client);
        final int targetId = Utils.getTargetId(client);
        if (attackingGiantRatWithBoneWeapon(weaponId, location.getRegionID(), location.getX(), location.getY(), targetId))
        {
            return 1;
        }
        return curSpeed;
    }
    public void onGameTick(final Client client, final GameTick tick) {}
}

package com.attacktimer.VariableSpeed;

/*
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.attacktimer.AnimationData;
import com.attacktimer.AttackProcedure;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;

public class BloodMoonSet implements IVariableSpeed
{
    private static final int BloodMoonSetAnimId = 2792;
    public int apply(final Client client, final AnimationData curAnimation, final AttackProcedure atkProcedure, final int baseSpeed, final int curSpeed)
    {
        if (client.getLocalPlayer().hasSpotAnim(BloodMoonSetAnimId))
        {
            return curSpeed-1;
        }
        return curSpeed;
    }
    public void onGameTick(Client client, GameTick tick) {}
}

package com.attacktimer.VariableSpeed;

/*
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.attacktimer.AnimationData;
import com.attacktimer.AttackProcedure;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;

public class RedKerisSpec implements IVariableSpeed
{
    public int apply(final Client client, final AnimationData curAnimation, final AttackProcedure atkProcedure, final int baseSpeed, final int curSpeed)
    {
        if (curAnimation == AnimationData.MELEE_RED_KERIS_SPEC)
        {
            // TODO add miss/hit tracking code, if we missed this delay is not applied
            return curSpeed+4;
        }
        return curSpeed;
    }
    public void onGameTick(Client client, GameTick tick) {}
}

package com.attacktimer.VariableSpeed;

/*
 * Copyright (c) 2022, Nick Graves <https://github.com/ngraves95>
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.attacktimer.AnimationData;
import com.attacktimer.AttackProcedure;
import com.attacktimer.AttackStyle;
import com.attacktimer.ClientUtils.Utils;

import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.WorldType;
import net.runelite.api.events.GameTick;

public class Leagues implements IVariableSpeed
{
    public int apply(final Client client, final AnimationData curAnimation, final AttackProcedure atkProcedure, final int baseSpeed, final int curSpeed)
    {
        if (!client.getWorldType().contains(WorldType.SEASONAL))
        {
            return curSpeed;
        }

        AttackStyle attackStyle = Utils.getAttackStyle(client);
        if (attackStyle == AttackStyle.RANGING || attackStyle == AttackStyle.LONGRANGE)
        {
            return applyLeagueFormulaSpeed(baseSpeed, client.getVarbitValue(Varbits.LEAGUES_RANGED_COMBAT_MASTERY_LEVEL));
        }
        if (attackStyle == AttackStyle.ACCURATE ||
            attackStyle == AttackStyle.AGGRESSIVE ||
            attackStyle == AttackStyle.CONTROLLED ||
            attackStyle == AttackStyle.DEFENSIVE)
        {
            return applyLeagueFormulaSpeed(baseSpeed, client.getVarbitValue(Varbits.LEAGUES_MELEE_COMBAT_MASTERY_LEVEL));
        }
        if (attackStyle == AttackStyle.CASTING || attackStyle == AttackStyle.DEFENSIVE_CASTING)
        {
            return applyLeagueFormulaSpeed(baseSpeed, client.getVarbitValue(Varbits.LEAGUES_MAGIC_COMBAT_MASTERY_LEVEL));
        }

        return curSpeed;
    }

    private int applyLeagueFormulaSpeed(int baseSpeed, int masteryLevel)
    {
        // Older league's had no masteries and were all: "attack rate set to 50%, rounded down for 5t and above, rounded up below 4t. "
        if (masteryLevel >= 5 || masteryLevel <= 0)
        {
            if (baseSpeed >= 4)
            {
                return baseSpeed / 2;
            }
            else
            {
                return (baseSpeed + 1) / 2;
            }
        }
        else if (masteryLevel >= 3)
        {
            // "attack rate set to 80%, rounding down." e.g. https://oldschool.runescape.wiki/w/Melee_III
            return (int) Math.floor(((double) baseSpeed) * 0.8);
        }
        return baseSpeed;
    }

    public void onGameTick(Client client, GameTick tick) {}
}

package com.attacktimer.VariableSpeed;

/*
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import com.attacktimer.AnimationData;
import com.attacktimer.AttackProcedure;
import com.attacktimer.AttackType;
import com.attacktimer.WeaponType;
import com.attacktimer.ClientUtils.Utils;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;

/**
 * TormentedDemons is the variable speed implementation for the "punish" attack a player can do against a
 * demon.
 *
 * https://oldschool.runescape.wiki/w/Tormented_Demon/Strategies#Fire_bombs_and_shield
 * > Within this moment of vulnerability, attacking the demon using crush weapons, heavy ranged weapons
 * > (crossbows and ballistae), or casting a spell (not from a powered staff) increases all damage dealt by
 * > X216, where X is the weapon's attack speed. The attack speed for this one attack is set to 4 ticks
 * > (2.4s); if multiple demons are attacking, the attack speed decreases by one tick per additional demon
 * > that is fighting the player.
 *
 * This class works by keeping a map which tracks every demon that the client is provided, then if any demon
 * triggers a spot animation matching the vulnerability animation then we store this in the map. Every attack
 * the parent {@see VariableSpeed} will call apply, in which if we are attacking a vulnerable demon we can do
 * extra checks and compute the new attack speed and show the correct tick countdown.
 */
public class TormentedDemons implements IVariableSpeed
{
    public int apply(final Client client, final AnimationData curAnimation, final AttackProcedure atkProcedure, final int baseSpeed, final int curSpeed)
    {
        WorldPoint location = Utils.getLocation(client);
        int weaponId = Utils.getWeaponId(client);
        int targetId = Utils.getTargetId(client);
        if (!attackingTormentedDemon(weaponId, location.getRegionID(), location.getX(), location.getY(), targetId))
        {
            return curSpeed;
        }
        final NPC target = Utils.getTargetNPC(client);
        if (!tormentedDemons.containsKey(target))
        {
            // This doesn't feel very likely but this is more graceful than throwing.
            return curSpeed;
        }
        final DemonData targetDemon = tormentedDemons.get(target);
        if (!targetDemon.isVulnerable(tickCount))
        {
            return curSpeed;
        }
        // The demon is vulnerable! However if it's already been attacked in a previous tick then the
        // vulnerability is moot.
        if (targetDemon.vulnConsumed(tickCount))
        {
            return curSpeed;
        }
        // Finally the last checks, only certain attack styles and weapons can trigger the effect.
        switch (atkProcedure)
        {
            case POWERED_STAVE:
                // Powered staves cannot trigger the effect
                // TODO edge case with harm?
                return curSpeed;
            case MANUAL_AUTO_CAST:
                break;
            case MELEE_OR_RANGE:
                final WeaponType wep = Utils.getWeaponType(client);
                final AttackType attkType = Utils.getAttackType(client);
                if (wep != WeaponType.HEAVY_RANGED && attkType != AttackType.CRUSH)
                {
                    // This weapon is not a heavy ranged weapon or a melee weapon set to crush
                    // so it wont trigger the shorter cooldown.
                    return curSpeed;
                }
                break;
        }
        // All checks passed this is consuming the vulnerability, change our speed.
        //
        // TODO implement more than 1 demon cases
        if (curSpeed > 4)
        {
            return 4;
        }
        else
        {
            return curSpeed;
        }
    }

    private static final int TORMENTED_DEMON_VULN_SPOT_ANIM = 2852;
    private static final int TORMENTED_DEMON_ID = 13600;

    private static final int TORMENTED_DEMON_2_ID = 13599;
    private static final int TORMENTED_DEMON_REGION_ID = 16197;

    private static final int TORMENTED_DEMON_REGION_2_ID = 16452;
    private static final int TORMENTED_DEMON_MIN_X = 4010;

    private static final int TORMENTED_DEMON_MAX_X = 4180;
    private static final int TORMENTED_DEMON_MIN_Y = 4320;

    private static final int TORMENTED_DEMON_MAX_Y = 4490;

    private static boolean attackingTormentedDemon(int equipped, int regionId, int x, int y, int target)
    {
        boolean correctCoords = x >= TORMENTED_DEMON_MIN_X && x <= TORMENTED_DEMON_MAX_X && y >= TORMENTED_DEMON_MIN_Y && y <= TORMENTED_DEMON_MAX_Y;
        boolean correctRegion = regionId == TORMENTED_DEMON_REGION_ID || regionId == TORMENTED_DEMON_REGION_2_ID;
        return correctCoords && correctRegion && isTormentedDemon(target);
    }

    private static boolean isTormentedDemon(int targetId)
    {
        return targetId == TORMENTED_DEMON_ID || targetId == TORMENTED_DEMON_2_ID;
    }

    private Map<NPC, DemonData> tormentedDemons = new HashMap<NPC,DemonData>();;
    private int tickCount;

    public void onGameTick(Client client, GameTick tick)
    {
        tickCount++;
        for (NPC npc : client.getTopLevelWorldView().npcs())
        {
            if (!isTormentedDemon(npc.getId())) { continue; }
            boolean isVulnerable = npc.hasSpotAnim(TORMENTED_DEMON_VULN_SPOT_ANIM);
            if (tormentedDemons.containsKey(npc))
            {
                DemonData d = tormentedDemons.get(npc);
                d.update(tickCount, isVulnerable);
            }
            else
            {
                tormentedDemons.put(npc, new DemonData(tickCount, isVulnerable));
            }
        }
        // Only check for staleness every so often
        if (tickCount % 100 == 0)
        {
            var toDelete = new ArrayList<NPC>();
            for (Entry<NPC, DemonData> td : tormentedDemons.entrySet())
            {
                if (td.getValue().isStale(tickCount))
                {
                    toDelete.add(td.getKey());
                }
            }
            for (NPC td : toDelete)
            {
                tormentedDemons.remove(td);
            }
        }
    }

    /**
     * DemonData is an internal helper class containing the last ticks in which a demon was noticed by the
     * client, the tick it was vulnerable (if ever) and the tick in which it was attacked while vulnerable.
     */
    class DemonData
    {
        // VulTicksAfterEnd is just a guess the wiki isn't clear how long this period is, from testing 10
        // ticks feels about right.
        private static final int VulTicksAfterEnd = 10;
        private int lastSpotted;
        private Integer vulnerableStart;
        private Integer vulnerableFinish;
        private int attacked;
        DemonData(int tick, boolean vuln)
        {
            lastSpotted = tick;
            this.update(tick, vuln);
            this.attacked = -1;
        }

        void update(int tick, boolean vuln)
        {
            // NOTE: we can't use the chat message "The demon's spell binds you" because this doesn't trigger
            // at the start of any kill.
            lastSpotted = tick;
            if (vuln && this.vulnerableStart == null)
            {
                this.vulnerableStart = Integer.valueOf(tick);
                this.vulnerableFinish = Integer.valueOf(tick);
            }
            else if (vuln && this.vulnerableStart != null)
            {
                this.vulnerableFinish = Integer.valueOf(tick);
            }

            if (!vuln)
            {
                this.vulnerableStart = null;
            }
            if (this.attacked != -1 && this.attacked + 1 >= tick)
            {
                this.attacked = -1;
            }
        }

        boolean isVulnerable(int tick)
        {
            if (this.vulnerableFinish == null)
            {
                return false;
            }
            return (this.vulnerableFinish + VulTicksAfterEnd) > tick;
        }

        // isStale returns true if the last time this demon was spotted by the client was too long ago.
        boolean isStale(int tick)
        {
            if (this.lastSpotted + 50 < tick)
            {
                // Last update was over 50 ticks ago, this is stale
                return true;
            }
            return false;
        }

        boolean vulnConsumed(int tick)
        {
            if (this.attacked == tick || this.attacked == -1)
            {
                this.attacked = tick;
                return false;
            }
            else if (this.attacked > tick + VulTicksAfterEnd)
            {
                // already attacked within the window
                return true;
            }
            else
            {
                this.attacked = tick;
                return false;
            }
        }

        @Override
        public String toString()
        {
            return "created: " + String.valueOf(this.lastSpotted) + " vulnerableStart: " + String.valueOf(this.vulnerableStart) + " vulnerableFinish: " + String.valueOf(this.vulnerableFinish);
        }
    }

}

package com.attacktimer.VariableSpeed;

/*
 * Copyright (c) 2025, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.attacktimer.AnimationData;
import com.attacktimer.AttackProcedure;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;

public class EyeOfAyak implements IVariableSpeed
{
    public int apply(final Client client, final AnimationData curAnimation, final AttackProcedure atkProcedure, final int baseSpeed, final int curSpeed)
    {
        // https://oldschool.runescape.wiki/w/Eye_of_ayak#Charged
        // https://oldschool.runescape.wiki/w/Eye_of_ayak#Special_attack
        if (curAnimation == AnimationData.MAGIC_EYE_OF_AYAK_SPEC)
        {
            // This is unclear if the Ayak spec "sets" the speed to 5 or adds two ticks. We can't know until
            // leagues. If it does set it too 5 this code is correct and it's order in
            // `src\main\java\com\attacktimer\VariableSpeed\VariableSpeed.java` is correct. However if it's
            // actually a +2 this code is wrong and it *might* need to come before the leagues modifier.
            return 5;
        }
        return curSpeed;
    }
    public void onGameTick(Client client, GameTick tick) {}
}

package com.attacktimer.VariableSpeed;

/*
 * Copyright (c) 2022, Nick Graves <https://github.com/ngraves95>
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.attacktimer.AnimationData;
import com.attacktimer.AttackStyle;
import com.attacktimer.AttackProcedure;
import com.attacktimer.ClientUtils.Utils;
import net.runelite.api.Client;
import net.runelite.api.VarPlayer;
import net.runelite.api.events.GameTick;

public class RapidAttackStyle implements IVariableSpeed
{
    public int apply(final Client client, final AnimationData curAnimation, final AttackProcedure atkProcedure, final int baseSpeed, final int curSpeed)
    {
        // index 1 == rapid
        final boolean isRapid = client.getVarpValue(VarPlayer.ATTACK_STYLE) == 1;
        if (atkProcedure == AttackProcedure.MELEE_OR_RANGE && Utils.getAttackStyle(client) == AttackStyle.RANGING && isRapid)
        {
            // Also works for salamanders which attack 1 tick faster when using the ranged style
            return curSpeed-1;
        }
        return curSpeed;
    }
    public void onGameTick(Client client, GameTick tick) {}
}

package com.attacktimer;

/*
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.google.common.collect.ImmutableMap;

enum Spellbook
{
    STANDARD(0),
    ANCIENT(1),
    LUNAR(2),
    ARCEUUS(3);

    private final int id;

    Spellbook(int id)
    {
        this.id = id;
    }

    private static final ImmutableMap<Integer, Spellbook> books;

    static
    {
        ImmutableMap.Builder<Integer, Spellbook> builder = new ImmutableMap.Builder<>();

        for (Spellbook data : values())
        {
            builder.put(data.id, data);
        }

        books = builder.build();
    }

    public static Spellbook fromVarbit(int varbit)
    {
        return books.get(varbit);
    }
}

package com.attacktimer;

/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.google.common.collect.ImmutableMap;
import java.util.Map;
import lombok.Getter;
import static com.attacktimer.AttackStyle.ACCURATE;
import static com.attacktimer.AttackStyle.AGGRESSIVE;
import static com.attacktimer.AttackStyle.CASTING;
import static com.attacktimer.AttackStyle.DEFENSIVE;
import static com.attacktimer.AttackStyle.DEFENSIVE_CASTING;
import static com.attacktimer.AttackStyle.OTHER;
import static com.attacktimer.AttackType.CRUSH;
import static com.attacktimer.AttackType.SLASH;
import static com.attacktimer.AttackType.STAB;
import static com.attacktimer.AttackType.RANGED;
import static com.attacktimer.AttackType.MAGIC;
import static com.attacktimer.AttackType.NONE;

import net.runelite.api.Client;
import net.runelite.api.ParamID;
import net.runelite.api.EnumID;
import net.runelite.api.StructComposition;

public enum WeaponType
{
    // https://oldschool.runescape.wiki/w/Weapons/Types
    // * Note this ordering the ordering in which the enum is defined by the client you should not re-order
    //   this list
    // * Note the ordering of attack types is arbitrary and also defined by the client and should not be
    //   re-ordered. Where nulls are empty spots. Arrays are either 4 or 6 items long.
    //
    // Taken from
    // https://github.com/Joshua-F/cs2-scripts/blob/562819dbac880d2890daa40adcb209eb7413d2dd/scripts/%5Bclientscript%2Ccombat_interface_setup%5D.cs2
    // Not sure why the latest update to that repo has this script deleted but the gathered data from the
    // older commit still seem fine.
    UNARMED(CRUSH, CRUSH, null, CRUSH),
    AXE(SLASH, SLASH, CRUSH, SLASH),
    BLUNT(CRUSH, CRUSH, null, CRUSH),
    BOW(RANGED, RANGED, null, RANGED),
    CLAW(SLASH, SLASH, STAB, SLASH),
    HEAVY_RANGED(RANGED, RANGED, null, RANGED),
    SALAMANDER(SLASH, RANGED, MAGIC, null),
    CHINCHOMPA(RANGED, RANGED, null, RANGED),
    GUN(NONE, CRUSH, null, null),
    SLASH_SWORD(SLASH, SLASH, STAB, SLASH),
    TWO_HANDED_SWORD(SLASH, SLASH, CRUSH, SLASH),
    PICKAXE(STAB, STAB, CRUSH, STAB),
    POLEARM(STAB, SLASH, null, STAB),
    POLESTAFF(CRUSH, CRUSH, null, CRUSH),
    SCYTHE(SLASH, SLASH, CRUSH, SLASH),
    SPEAR(STAB, SLASH, CRUSH, STAB),
    SPIKED(CRUSH, CRUSH, STAB, CRUSH),
    STAB_SWORD(STAB, STAB, SLASH, STAB),
    STAFF(CRUSH, CRUSH, null, CRUSH, MAGIC, MAGIC),
    THROWN(RANGED, RANGED, null, RANGED),
    WHIP(SLASH, SLASH, null, SLASH),
    BLADED_STAFF(STAB, SLASH, null, CRUSH, MAGIC, MAGIC),
    TWO_HANDED_SWORD_GODSWORD(STAB, SLASH, null, CRUSH, MAGIC, MAGIC),
    POWERED_STAFF(SLASH, SLASH, CRUSH, SLASH),
    BANNER(MAGIC, MAGIC, null, MAGIC),
    POLEARM_CRYSTAL_HALBERD(STAB, SLASH, CRUSH, STAB),
    BLUDGEON(STAB, SLASH, null, STAB),
    BULWARK(CRUSH, CRUSH, null, CRUSH),
    POWERED_WAND(CRUSH, null, null, NONE),
    PARTISAN(MAGIC, MAGIC, null, MAGIC),
    PARTISAN_2(STAB, STAB, CRUSH, STAB);

    private static final Map<Integer, WeaponType> weaponTypes;

    @Getter
    private final AttackType[] attackTypes;

    static
    {
        ImmutableMap.Builder<Integer, WeaponType> builder = new ImmutableMap.Builder<>();

        for (WeaponType weaponType : values())
        {
            builder.put(weaponType.ordinal(), weaponType);
        }

        weaponTypes = builder.build();
    }

    WeaponType(AttackType... attackTypes)
    {
        this.attackTypes = attackTypes;
    }

    // Copied from https://github.com/runelite/runelite/commit/ffe16454ba894d673db91e2d1fd8d3c4c265b2c7
    // runelite-client\src\main\java\net\runelite\client\plugins\attackstyles\AttackStylesPlugin.java IMO This
    // code should remain fairly in-sync with the upstream unless there is good reason to fork. License was
    // in-sync at time of copying. Credit: [Adam-](https://github.com/Adam-)
    // [honeyhoney](https://github.com/honeyhoney)
    //
    // It seems that at some point the code to generate an attack style started to come from the client rather
    // than being hardcoded. However this only generates the Style of attack not the attack type which is
    // still hardcoded.
    public AttackStyle[] getAttackStyles(Client client)
    {
        // from script4525
        int weaponType = this.ordinal();
        int weaponStyleEnum = client.getEnum(EnumID.WEAPON_STYLES).getIntValue(weaponType);
        if (weaponStyleEnum == -1)
        {
            // Blue moon spear
            if (weaponType == 22)
            {
                return new AttackStyle[]{
                    ACCURATE, AGGRESSIVE, null, DEFENSIVE, CASTING, DEFENSIVE_CASTING
                };
            }

            if (weaponType == 30)
            {
                // Partisan
                return new AttackStyle[]{
                    ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE
                };
            }
            return new AttackStyle[0];
        }
        int[] weaponStyleStructs = client.getEnum(weaponStyleEnum).getIntVals();

        AttackStyle[] styles = new AttackStyle[weaponStyleStructs.length];
        int i = 0;
        for (int style : weaponStyleStructs)
        {
            StructComposition attackStyleStruct = client.getStructComposition(style);
            String attackStyleName = attackStyleStruct.getStringValue(ParamID.ATTACK_STYLE_NAME);
            AttackStyle attackStyle = AttackStyle.valueOf(attackStyleName.toUpperCase());
            if (attackStyle == OTHER)
            {
                // "Other" is used for no style
                ++i;
                continue;
            }

            // "Defensive" is used for Defensive and also Defensive casting
            if (i == 5 && attackStyle == DEFENSIVE)
            {
                attackStyle = DEFENSIVE_CASTING;
            }

            styles[i++] = attackStyle;
        }
        return styles;
    }

    public static WeaponType getWeaponType(int id)
    {
        return weaponTypes.get(id);
    }
}
package com.attacktimer;

/*
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

public enum AttackType
{
    CRUSH,
    SLASH,
    STAB,
    RANGED,
    MAGIC,
    NONE;

    public boolean IsMelee()
    {
        return this.equals(CRUSH) || this.equals(SLASH) || this.equals(STAB);
    }
}
package com.attacktimer;

/*
 * Copyright (c) 2022, Nick Graves <https://github.com/ngraves95>
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * Copyright (c) 2024, Richardant <https://github.com/Richardant>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import javax.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Font;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPriority;


public class AttackTimerMetronomeTileOverlay extends Overlay
{

    private final Client client;
    private final AttackTimerMetronomeConfig config;
    private final AttackTimerMetronomePlugin plugin;

    private Player player;

    @Inject
    public AttackTimerMetronomeTileOverlay(Client client, AttackTimerMetronomeConfig config, AttackTimerMetronomePlugin plugin)
    {
        super(plugin);
        this.client = client;
        this.config = config;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);
        setPriority(OverlayPriority.MED);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        player = client.getLocalPlayer();
        plugin.renderedState = plugin.attackState;
        if (plugin.attackState == AttackTimerMetronomePlugin.AttackState.NOT_ATTACKING) {
            return null;
        }

        if (config.showTick())
        {
            if (config.fontType() == FontTypes.REGULAR)
            {
                graphics.setFont(new Font(FontManager.getRunescapeFont().getName(), Font.PLAIN, config.fontSize()));
            }
            else if (config.fontType() == FontTypes.BOLD)
            {
                graphics.setFont(new Font(config.fontType().toString(), Font.BOLD, config.fontSize()));
            }
            else
            {
                graphics.setFont(new Font(config.fontType().toString(), Font.PLAIN, config.fontSize()));
            }

            // Countdown ticks instead of up.
            // plugin.tickCounter => ticksRemaining
            int ticksRemaining = plugin.getTicksUntilNextAttack();

            final LocalPoint localLocation = client.getLocalPlayer().getLocalLocation();
            Point playerPoint = null;

            switch (config.ticksPosition()) {
                case TOP:
                    playerPoint = Perspective.localToCanvas(client, localLocation, client.getTopLevelWorldView().getPlane(), 214 + config.heightTickOffset());
                    break;

                case CENTERED:
                    playerPoint = Perspective.localToCanvas(client, localLocation, client.getTopLevelWorldView().getPlane(), 100 + config.heightTickOffset());
                    break;

                case BOTTOM:
                    playerPoint = player.getCanvasTextLocation(graphics, String.valueOf(ticksRemaining), 10 + config.heightTickOffset());
                    break;

                case DEFAULT:
                    int height = client.getLocalPlayer().getLogicalHeight() + 20 + config.heightTickOffset();
                    playerPoint = Perspective.localToCanvas(client, localLocation, client.getTopLevelWorldView().getPlane(), height);
                    break;
            }
            if (playerPoint != null) {
                OverlayUtil.renderTextLocation(graphics, playerPoint, String.valueOf(ticksRemaining), ticksRemaining == 1 ? config.LastColor() : config.NumberColor());
            }
        }
        return null;
    }

    private void renderTile(final Graphics2D graphics, final LocalPoint dest, final Color color, final Color fillColor, final double borderWidth)
    {
        if (dest == null)
        {
            return;
        }

        final Polygon poly = Perspective.getCanvasTilePoly(client, dest);

        if (poly == null)
        {
            return;
        }

        OverlayUtil.renderPolygon(graphics, poly, color, fillColor, new BasicStroke((float) borderWidth));
    }
}

package com.attacktimer;

/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * Copyright (c) 2020, Mazhar <https://twitter.com/maz_rs>
 * Copyright (c) 2024-2025, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.google.common.collect.ImmutableMap;
import java.security.InvalidParameterException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;

public enum AnimationData
{
    // MELEE
    MELEE_VIGGORAS_CHAINMACE(245, AttackStyle.MELEE),
    MELEE_DAGGER_SLASH(376, AttackStyle.MELEE), // tested w/ dds
    MELEE_SPEAR_STAB(381, AttackStyle.MELEE), // tested w/ zammy hasta
    MELEE_SWORD_STAB(386, AttackStyle.MELEE), // tested w/ dragon sword, obby sword, d long
    MELEE_SCIM_SLASH(390, AttackStyle.MELEE), // tested w/ rune & dragon scim, d sword, VLS, obby sword

    MELEE_LANCE_STAB(8288, AttackStyle.MELEE),
    MELEE_LANCE_CRUSH(8290, AttackStyle.MELEE),
    MELEE_LANCE_SLASH(8289, AttackStyle.MELEE),

    MELEE_FANG_STAB(9471, AttackStyle.MELEE), // tested w/ fang
    MELEE_FANG_SPEC(6118, AttackStyle.MELEE, true), // tested w/ fang spec

    MELEE_GENERIC_SLASH(393, AttackStyle.MELEE), // tested w/ zuriel's staff, d long slash, dclaws regular slash
    MELEE_STAFF_CRUSH(0, AttackStyle.MELEE), // 393 previously, save name to support old fights but no longer track

    MELEE_BATTLEAXE_SLASH(395, AttackStyle.MELEE), // tested w/ rune baxe
    MELEE_MACE_STAB(400, AttackStyle.MELEE), // tested w/ d mace
    MELEE_BATTLEAXE_CRUSH(401, AttackStyle.MELEE), // tested w/ rune baxe, dwh & statius warhammer animation, d mace
    MELEE_2H_CRUSH(406, AttackStyle.MELEE), // tested w/ rune & dragon 2h
    MELEE_2H_SLASH(407, AttackStyle.MELEE), // tested w/ rune & dragon 2h
    MELEE_STAFF_CRUSH_2(414, AttackStyle.MELEE), // tested w/ ancient staff, 3rd age wand
    MELEE_STAFF_CRUSH_3(419, AttackStyle.MELEE), // Common staff crush. Air/fire/etc staves, smoke battlestaff, SOTD/SOL crush, zammy hasta crush
    MELEE_PUNCH(422, AttackStyle.MELEE),
    MELEE_KICK(423, AttackStyle.MELEE),
    MELEE_STAFF_STAB(428, AttackStyle.MELEE), // tested w/ SOTD/SOL jab, vesta's spear stab, c hally
    MELEE_SPEAR_CRUSH(429, AttackStyle.MELEE), // tested w/ vesta's spear
    MELEE_STAFF_SLASH(440, AttackStyle.MELEE), // tested w/ SOTD/SOL slash, zammy hasta slash, vesta's spear slash, c hally
    MELEE_DLONG_SPEC(1058, AttackStyle.MELEE, true), // tested w/ d long spec, also thammaron's sceptre crush (????)...
    MELEE_DRAGON_MACE_SPEC(1060, AttackStyle.MELEE, true),
    MELEE_DRAGON_DAGGER_SPEC(1062, AttackStyle.MELEE, true),
    MELEE_DRAGON_WARHAMMER_SPEC(1378, AttackStyle.MELEE, true), // tested w/ dwh, statius warhammer spec
    MELEE_ABYSSAL_WHIP(1658, AttackStyle.MELEE), // tested w/ whip, tent whip
    MELEE_GRANITE_MAUL(1665, AttackStyle.MELEE), // tested w/ normal gmaul, ornate maul
    MELEE_GRANITE_MAUL_SPEC(1667, AttackStyle.MELEE, true), // tested w/ normal gmaul, ornate maul
    MELEE_DHAROKS_GREATAXE_CRUSH(2066, AttackStyle.MELEE),
    MELEE_DHAROKS_GREATAXE_SLASH(2067, AttackStyle.MELEE),
    MELEE_AHRIMS_STAFF_CRUSH(2078, AttackStyle.MELEE),
    MELEE_OBBY_MAUL_CRUSH(2661, AttackStyle.MELEE),
    MELEE_ABYSSAL_DAGGER_STAB(3297, AttackStyle.MELEE), // spec un-tested
    MELEE_ABYSSAL_BLUDGEON_CRUSH(3298, AttackStyle.MELEE),
    MELEE_ABYSSAL_BLUDGEON_SPEC(3299, AttackStyle.MELEE, true),
    MELEE_LEAF_BLADED_BATTLEAXE_CRUSH(3852, AttackStyle.MELEE),
    MELEE_INQUISITORS_MACE(4503, AttackStyle.MELEE),
    MELEE_BARRELCHEST_ANCHOR_CRUSH(5865, AttackStyle.MELEE),
    MELEE_BARRELCHEST_ANCHOR_CRUSH_SPEC(5870, AttackStyle.MELEE, true),
    MELEE_LEAF_BLADED_BATTLEAXE_SLASH(7004, AttackStyle.MELEE),
    MELEE_GODSWORD_SLASH(7045, AttackStyle.MELEE), // tested w/ AGS, BGS, ZGS, SGS, AGS(or) sara sword
    MELEE_GODSWORD_CRUSH(7054, AttackStyle.MELEE), // tested w/ AGS, BGS, ZGS, SGS, sara sword
    MELEE_GODSWORD_DEFENSIVE(7055, AttackStyle.MELEE), // tested w/ BGS
    MELEE_RUNE_CLAWS_SPEC(923, AttackStyle.MELEE, true),
    MELEE_DRAGON_CLAWS_SPEC(7514, AttackStyle.MELEE, true),
    MELEE_VLS_SPEC(7515, AttackStyle.MELEE, true), // both VLS and dragon sword spec
    MELEE_ELDER_MAUL(7516, AttackStyle.MELEE),
    MELEE_ZAMORAK_GODSWORD_SPEC(7638, AttackStyle.MELEE, true), // tested zgs spec
    MELEE_ELDER_MAUL_SPEC(11124, AttackStyle.MELEE),
    MELEE_ZAMORAK_GODSWORD_OR_SPEC(7639, AttackStyle.MELEE, true), // verified 22/06/2024, assumed due to ags(or)
    MELEE_SARADOMIN_GODSWORD_SPEC(7640, AttackStyle.MELEE, true), // tested sgs spec
    MELEE_SARADOMIN_GODSWORD_OR_SPEC(7641, AttackStyle.MELEE, true), // verified 22/06/2024, assumed due to ags(or)
    MELEE_BANDOS_GODSWORD_SPEC(7642, AttackStyle.MELEE, true), // tested bgs spec
    MELEE_BANDOS_GODSWORD_OR_SPEC(7643, AttackStyle.MELEE, true), // verified 22/06/2024, assumed due to ags(or)
    MELEE_ARMADYL_GODSWORD_SPEC(7644, AttackStyle.MELEE, true), // tested ags spec
    MELEE_ARMADYL_GODSWORD_OR_SPEC(7645, AttackStyle.MELEE, true), // tested ags(or) spec
    MELEE_SCYTHE(8056, AttackStyle.MELEE), // tested w/ all scythe styles (so could be crush, but unlikely)
    MELEE_GHAZI_RAPIER_STAB(8145, AttackStyle.MELEE), // rapier slash is 390, basic slash animation. Also VLS stab.
    MELEE_ANCIENT_GODSWORD_SPEC(9171, AttackStyle.MELEE, true),
    MELEE_CRYSTAL_HALBERD_SPEC(1203, AttackStyle.MELEE, true),
    MELEE_SOULREAPER_AXE(10172, AttackStyle.MELEE, true),
    MELEE_SOULREAPER_AXE_SPEC(10173, AttackStyle.MELEE, true),
    MELEE_GUTHANS_LUNGE(2080, AttackStyle.MELEE),
    MELEE_GUTHANS_SWIPE(2081, AttackStyle.MELEE),
    MELEE_GUTHANS_POUNDMA(2082, AttackStyle.MELEE),
    MELEE_TORAG_HAMMERS(2068, AttackStyle.MELEE),
    MELEE_VERACS_FLAIL(2062, AttackStyle.MELEE),
    MELEE_BLISTERWOOD_FLAIL_CRUSH(8010, AttackStyle.MELEE), // blisterwood flail
    MELEE_BONE_DAGGER_SPEC(4198, AttackStyle.MELEE, true), // tested with all poison variants (p, p+, p++, none)
    MELEE_DUAL_MACUAHUITL(10989, AttackStyle.MELEE), // https://oldschool.runescape.wiki/w/Dual_macuahuitl set effect needs custom code
    MELEE_BLUE_MOON_SPEAR_SPEC(1710, AttackStyle.MELEE, true), // https://oldschool.runescape.wiki/w/Blue_moon_spear
    MELEE_BLUE_MOON_SPEAR(1711, AttackStyle.MELEE),
    MELEE_DHINS(7511, AttackStyle.MELEE), // https://oldschool.runescape.wiki/w/Dinh%27s_bulwark
    MELEE_URSINE_CHAINMACE_SPEC(9963, AttackStyle.MELEE, true), // https://oldschool.runescape.wiki/w/Ursine_chainmace#Charged
    MELEE_ANCIENT_MACE_SPEC(6147, AttackStyle.MELEE, true), // https://oldschool.runescape.wiki/w/Ancient_mace
    MELEE_DSCIM_SPEC(1872, AttackStyle.MELEE, true), // https://oldschool.runescape.wiki/w/Dragon_scimitar
    MELEE_D2H_SPEC(3157, AttackStyle.MELEE, true), // https://oldschool.runescape.wiki/w/Dragon_2h_sword
    MELEE_ARCLIGHT_SPEC(2890, AttackStyle.MELEE, true), // https://oldschool.runescape.wiki/w/Arclight
    MELEE_SARA_SWORD_SPEC(1132, AttackStyle.MELEE, true), // https://oldschool.runescape.wiki/w/Saradomin_sword assumed to be the same for the blessed version
    MELEE_RED_KERIS_SPEC(9544, AttackStyle.MELEE, true), // https://oldschool.runescape.wiki/w/Keris_partisan_of_corruption
    MELEE_SALAMANDER(5247, AttackStyle.MELEE), // https://oldschool.runescape.wiki/w/Salamander

    // RANGED
    RANGED_CHINCHOMPA(7618, AttackStyle.RANGED),
    RANGED_SHORTBOW(426, AttackStyle.RANGED), // Confirmed same w/ 3 types of arrows, w/ maple, magic, & hunter's shortbow, craw's bow, dbow, dbow spec
    RANGED_RUNE_KNIFE_PVP(929, AttackStyle.RANGED), // 1 tick animation, has 1 tick delay between attacks. likely same for all knives. Same for morrigan's javelins, both spec & normal attack.
    RANGED_MAGIC_SHORTBOW_SPEC(1074, AttackStyle.RANGED, true),
    RANGED_CROSSBOW_PVP(4230, AttackStyle.RANGED), // Tested RCB & ACB w/ dragonstone bolts (e) & diamond bolts (e)
    RANGED_BLOWPIPE(5061, AttackStyle.RANGED), // tested in PvP with all styles. Has 1 tick delay between animations in pvp.
    RANGED_DARTS(7554, AttackStyle.RANGED), // tested w/ addy darts. Seems to be constant animation but sometimes stalls and doesn't animate
    RANGED_BALLISTA(7218, AttackStyle.RANGED), // Tested w/ dragon javelins.
    RANGED_BALLISTA_SPEC(7556, AttackStyle.RANGED, true),
    RANGED_RUNE_THROWNAXE_SPEC(1068, AttackStyle.RANGED, true), // https://oldschool.runescape.wiki/w/Rune_thrownaxe
    RANGED_DRAGON_THROWNAXE_SPEC(7521, AttackStyle.RANGED, true),
    RANGED_RUNE_CROSSBOW(7552, AttackStyle.RANGED),
    RANGED_RUNE_CROSSBOW_OR(9206, AttackStyle.RANGED),
    RANGED_BALLISTA_2(7555, AttackStyle.RANGED), // tested w/ light & heavy ballista, dragon & iron javelins.
    RANGED_RUNE_KNIFE(7617, AttackStyle.RANGED), // 1 tick animation, has 1 tick delay between attacks. Also d thrownaxe
    RANGED_DRAGON_KNIFE(8194, AttackStyle.RANGED),
    RANGED_DRAGON_KNIFE_SPEC(8291, AttackStyle.RANGED, true),
    RANGED_DRAGON_KNIFE_POISONED(8195, AttackStyle.RANGED), // tested w/ d knife p++
    RANGED_DRAGON_KNIFE_POISONED_SPEC(8292, AttackStyle.RANGED, true),
    RANGED_ZARYTE_CROSSBOW(9168, AttackStyle.RANGED),
    RANGED_ZARYTE_CROSSBOW_PVP(9166, AttackStyle.RANGED),
    RANGED_BLAZING_BLOWPIPE(10656, AttackStyle.RANGED),
    RANGED_VENATOR_BOW(9858, AttackStyle.RANGED),
    RANGED_KARIL_CROSSBOW(2075, AttackStyle.RANGED),
    RANGED_ATLATL(11057, AttackStyle.RANGED), // https://oldschool.runescape.wiki/w/Eclipse_atlatl
    RANGED_ATLATL_SPEC(11060, AttackStyle.RANGED, true),
    RANGED_TONALZTICS(10923, AttackStyle.RANGED), // https://oldschool.runescape.wiki/w/Tonalztics_of_ralos#Charged
    RANGED_TONALZTICS_SPEC(10914, AttackStyle.RANGED, true),
    RANGED_WEBWEAVER_SPEC(9964, AttackStyle.RANGED, true), // https://oldschool.runescape.wiki/w/Webweaver_bow#Charged
    RANGED_BONE_CROSSBOW_SPEC(7557, AttackStyle.RANGED, true), // https://oldschool.runescape.wiki/w/Dorgeshuun_crossbow

    // MAGIC - Keep in spellbook order (staves last) then alphabetical order and oneline
    MAGIC_GOD_SPELL(811, AttackStyle.MAGIC, Spellbook.STANDARD), // https://oldschool.runescape.wiki/w/God_spells
    MAGIC_IBAN_BLAST(708, AttackStyle.MAGIC, Spellbook.STANDARD),
    MAGIC_SLAYER_DART(1576, AttackStyle.MAGIC, Spellbook.STANDARD), // https://oldschool.runescape.wiki/w/Magic_Dart
    MAGIC_STANDARD_BIND(710, AttackStyle.MAGIC, Spellbook.STANDARD), // tested w/ bind, snare, entangle
    MAGIC_STANDARD_BIND_STAFF(1161, AttackStyle.MAGIC, Spellbook.STANDARD), // tested w/ bind, snare, entangle, various staves
    MAGIC_STANDARD_CONFUSE(1163, AttackStyle.MAGIC, Spellbook.STANDARD),
    MAGIC_STANDARD_CRUMBLE_UNDEAD(724, AttackStyle.MAGIC, Spellbook.STANDARD),
    MAGIC_STANDARD_CRUMBLE_UNDEAD_HOLDING_STAFF(1166, AttackStyle.MAGIC, Spellbook.STANDARD),
    MAGIC_STANDARD_ENFEEBLE(1168, AttackStyle.MAGIC, Spellbook.STANDARD),
    MAGIC_STANDARD_STRIKE_BOLT_BLAST(9144, AttackStyle.MAGIC, Spellbook.STANDARD), // tested w/ bolt
    MAGIC_STANDARD_STRIKE_BOLT_BLAST_STAFF(11423, AttackStyle.MAGIC, Spellbook.STANDARD), // strike, bolt and blast (tested all spells, different weapons)
    MAGIC_STANDARD_STUN(1169, AttackStyle.MAGIC, Spellbook.STANDARD),
    MAGIC_STANDARD_SURGE_STAFF(9145, AttackStyle.MAGIC, Spellbook.STANDARD), // tested many staves
    MAGIC_STANDARD_VULNERABILITY_CURSE(1165, AttackStyle.MAGIC, Spellbook.STANDARD),
    MAGIC_STANDARD_WAVE(11429, AttackStyle.MAGIC, Spellbook.STANDARD), // tested w/ wave spells
    MAGIC_STANDARD_WAVE_STAFF(11430, AttackStyle.MAGIC, Spellbook.STANDARD), // tested many staves
    MAGIC_STANDARD_WEAKEN(1164, AttackStyle.MAGIC, Spellbook.STANDARD),

    MAGIC_ANCIENT_MULTI_TARGET(10092, AttackStyle.MAGIC, Spellbook.ANCIENT), // Burst & Barrage animations (tested all 8, different weapons)
    MAGIC_ANCIENT_SINGLE_TARGET(10091, AttackStyle.MAGIC, Spellbook.ANCIENT), // Rush & Blitz animations (tested all 8, different weapons)

    MAGIC_ARCEUUS_DEMONBANE(8977, AttackStyle.MAGIC, Spellbook.ARCEUUS), // Also greater corruption, so that may accidentally trigger a manual-cast, but that's probably fine only affects Muspah
    MAGIC_ARCEUUS_GRASP(8972, AttackStyle.MAGIC, Spellbook.ARCEUUS),

    MAGIC_ACCURSED_SCEPTRE_SPEC(9961, AttackStyle.MAGIC, true),
    MAGIC_TUMEKENS_SHADOW(9493, AttackStyle.MAGIC, false),
    MAGIC_WARPED_SCEPTRE(10501, AttackStyle.MAGIC, false), // https://oldschool.runescape.wiki/w/Warped_sceptre
    MAGIC_VOLATILE_NIGHTMARE_STAFF_SPEC(8532, AttackStyle.MAGIC, true), // assume 99 mage's base damage (does not rise when boosted).

    MAGIC_EYE_OF_AYAK_SPEC(12394, AttackStyle.MAGIC, true), // https://github.com/ngraves95/attacktimer/issues/91

    // Misc
    MAGIC_IMBUE(722, AttackStyle.NON_ATTACK),
    SPELLBOOK_SWAP(6299, AttackStyle.NON_ATTACK),
    LUNAR_GROUP(4409, AttackStyle.NON_ATTACK), // heal group, cure group, etc
    LUNAR_OTHER(4411, AttackStyle.NON_ATTACK), // Venge other, heal other, spec transfer, cure other, cure me, etc
    NPC_CONTACT(4413, AttackStyle.NON_ATTACK), // Also bake pie and pot share
    VENGEANCE(8316, AttackStyle.NON_ATTACK),
    REANIMATION(7198, AttackStyle.NON_ATTACK),
    DEMONIC_OFFERING(8975, AttackStyle.NON_ATTACK), // Also sinister offering
    SHADOW_VEIL(8979, AttackStyle.NON_ATTACK),
    MARK_OF_DARKNESS(8970, AttackStyle.NON_ATTACK), // Also death charge and ward of arceuss
    PICK_POCKETING(881, AttackStyle.NON_ATTACK),
    SUMMON_THRALL(8973, AttackStyle.NON_ATTACK),
    LUNAR_TELEPORT(1816, AttackStyle.NON_ATTACK),
    MONSTER_EXAMINE(6293, AttackStyle.NON_ATTACK), // Also stat spy
    HUMIDIFY(6294, AttackStyle.NON_ATTACK),
    GEOMANCY(7118, AttackStyle.NON_ATTACK),
    DREAM(7672, AttackStyle.NON_ATTACK),

    DESERT_AMMY(3872, AttackStyle.NON_ATTACK),

    EAT_FOOD_OR_POTION(829, AttackStyle.NON_ATTACK),
    OVERLOAD_HIT(3170, AttackStyle.NON_ATTACK), // https://oldschool.runescape.wiki/w/Overload_(Chambers_of_Xeric)#4_dose

    TAKING_HIT_1HANDED_UNARMED(397, AttackStyle.NON_ATTACK),
    TAKING_HIT_2H_SWORD(410, AttackStyle.NON_ATTACK),
    TAKING_HIT_ANCHOR(5866, AttackStyle.NON_ATTACK),
    TAKING_HIT_BLISTERWOOD_FLAIL(8017, AttackStyle.NON_ATTACK),
    TAKING_HIT_BLOWPIPE(430, AttackStyle.NON_ATTACK),
    TAKING_HIT_BULWARK(7512, AttackStyle.NON_ATTACK),
    TAKING_HIT_CHAINMACE(7200, AttackStyle.NON_ATTACK),
    TAKING_HIT_CHIN_CHOMPA(3176, AttackStyle.NON_ATTACK),
    TAKING_HIT_DAGGER(378, AttackStyle.NON_ATTACK),
    TAKING_HIT_DEFENDER(4177, AttackStyle.NON_ATTACK),
    TAKING_HIT_FANG(388, AttackStyle.NON_ATTACK),
    TAKING_HIT_GODSWORD(7056, AttackStyle.NON_ATTACK),
    TAKING_HIT_KERIS(383, AttackStyle.NON_ATTACK),
    TAKING_HIT_LARGE_STAFF(420, AttackStyle.NON_ATTACK),
    TAKING_HIT_MACE(403, AttackStyle.NON_ATTACK),
    TAKING_HIT_OBBY_MAUL(1666, AttackStyle.NON_ATTACK),
    TAKING_HIT_SCYTHE(435, AttackStyle.NON_ATTACK),
    TAKING_HIT_SHIELD(1156, AttackStyle.NON_ATTACK),
    TAKING_HIT_SPEAR(1709, AttackStyle.NON_ATTACK),
    TAKING_HIT_STAFF(415, AttackStyle.NON_ATTACK),
    TAKING_HIT_UNARMED(424, AttackStyle.NON_ATTACK),
    TAKING_HIT_VERACS_FLAIL(2063, AttackStyle.NON_ATTACK),
    TAKING_HIT_WHIP(1659, AttackStyle.NON_ATTACK),

    LOW_ALCH(712, AttackStyle.NON_ATTACK),
    HIGH_ALCH(713, AttackStyle.NON_ATTACK);

    private static final Map<Integer, AnimationData> DATA;
    private static final Map<Spellbook, Set<AnimationData>> spellBookAnimations;
    private static final Map<Integer, AnimationData> notAttacks;

    public final int animationId;
    public final boolean isSpecial;
    public final AttackStyle attackStyle;
    private final Spellbook spellbook;

    // Simple animation data constructor for all melee and range attacks
    AnimationData(int animationId, AttackStyle attackStyle)
    {
        if (attackStyle == null)
        {
            throw new InvalidParameterException("Attack Style must be valid for AnimationData");
        }
        this.animationId = animationId;
        this.attackStyle = attackStyle;
        this.isSpecial = false;
        this.spellbook = null;
    }

    // Simple animation data constructor for all melee and range attacks w/ special
    AnimationData(int animationId, AttackStyle attackStyle, boolean isSpecial)
    {
        if (attackStyle == null)
        {
            throw new InvalidParameterException("Attack Style must be valid for AnimationData");
        }
        this.animationId = animationId;
        this.attackStyle = attackStyle;
        this.isSpecial = isSpecial;
        this.spellbook = null;
    }

    // Simple animation data constructor for all magic attacks
    AnimationData(int animationId, AttackStyle attackStyle, Spellbook book)
    {
        if (attackStyle == null)
        {
            throw new InvalidParameterException("Attack Style must be valid for AnimationData");
        }
        this.animationId = animationId;
        this.attackStyle = attackStyle;
        this.isSpecial = false;
        this.spellbook = book;
    }

    static
    {
        ImmutableMap.Builder<Integer, AnimationData> builder = new ImmutableMap.Builder<>();
        ImmutableMap.Builder<Integer, AnimationData> notAttacksBuilder = new ImmutableMap.Builder<>();
        Map<Spellbook, Set<AnimationData>> spellBookBuilder = new HashMap<>();

        for (Spellbook s : Spellbook.values())
        {
            spellBookBuilder.put(s, new HashSet<AnimationData>());
        }

        for (AnimationData data : values())
        {
            builder.put(data.animationId, data);

            if (data.spellbook != null)
            {
                if (data.attackStyle != AttackStyle.MAGIC)
                {
                    throw new InvalidParameterException("Spell book should only be magic animations");
                }
                spellBookBuilder.get(data.spellbook).add(data);
            }
            if (data.attackStyle == AttackStyle.NON_ATTACK)
            {
                notAttacksBuilder.put(data.animationId, data);
            }
        }

        DATA = builder.build();
        notAttacks = notAttacksBuilder.build();
        spellBookAnimations = spellBookBuilder;
    }

    public static AnimationData fromId(int animationId)
    {
        return DATA.get(animationId);
    }

    public static Set<AnimationData> getAnimationsForSpellbook(Spellbook s)
    {
        return spellBookAnimations.get(s);
    }

    public static boolean isManualCasting(AnimationData animationData)
    {
        // This check ensures we don't treat staff animations which are magic attacks as a "manual cast".
        if (animationData.spellbook != null && animationData != null)
        {
            // We tell a manual cast by the animation data:
            return animationData.attackStyle == AttackStyle.MAGIC &&
                spellBookAnimations.get(animationData.spellbook).contains(animationData);
        }
        return false;
    }

    public static boolean isBlockListAnimation(int animationId)
    {
        return notAttacks.containsKey(animationId);
    }

    @Override
    public String toString()
    {
        String[] words = super.toString().toLowerCase().split("_");
        Arrays.stream(words)
                .map(StringUtils::capitalize).collect(Collectors.toList()).toArray(words);

        return String.join(" ", words);
    }

    public boolean matchesSpellbook(Spellbook s)
    {
        if (this.spellbook != null)
        {
            return this.spellbook == s;
        }
        return false;
    }


    // An enum of combat styles (including stab, slash, crush).
    public enum AttackStyle
    {
        MELEE,
        RANGED,
        MAGIC,
        NON_ATTACK;

        @Override
        public String toString()
        {
            return StringUtils.capitalize(super.toString().toLowerCase());
        }
    }
}

package com.attacktimer.ClientUtils;

/*
 * Copyright (c) 2022, Nick Graves <https://github.com/ngraves95>
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.attacktimer.AttackStyle;
import com.attacktimer.AttackType;
import com.attacktimer.WeaponType;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.NPC;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

public class Utils
{
    public static int getItemIdFromContainer(ItemContainer container, int slotID)
    {
        if (container == null)
        {
            return -1;
        }
        final Item item = container.getItem(slotID);
        return (item != null) ? item.getId() : -1;
    }

    public static int getWeaponId(Client client)
    {
        return getItemIdFromContainer(client.getItemContainer(InventoryID.EQUIPMENT),
                EquipmentInventorySlot.WEAPON.getSlotIdx());
    }

    // getLocation will return the current world point of the player accounting for instances.
    public static WorldPoint getLocation(Client client)
    {
        WorldPoint location = client.getLocalPlayer().getWorldLocation();
        final LocalPoint localPoint = client.getLocalPlayer().getLocalLocation();
        location = WorldPoint.fromLocalInstance(client, localPoint);
        return location;
    }

    // returns ACCURATE for unknown weapons/styles
    public static AttackStyle getAttackStyle(Client client)
    {
        final AttackStyle[] attackStyles = getWeaponType(client).getAttackStyles(client);
        final int currentAttackStyleVarbit = client.getVarpValue(VarPlayer.ATTACK_STYLE);
        if (currentAttackStyleVarbit < attackStyles.length)
        {
            return attackStyles[currentAttackStyleVarbit];
        }

        return AttackStyle.ACCURATE;
    }

    // returns null for unknown weapons
    public static WeaponType getWeaponType(Client client)
    {
        final int currentEquippedWeaponTypeVarbit = client.getVarbitValue(Varbits.EQUIPPED_WEAPON_TYPE);
        return WeaponType.getWeaponType(currentEquippedWeaponTypeVarbit);
    }

    // returns null for unknown weapons
    public static AttackType getAttackType(Client client)
    {
        final WeaponType weaponType = getWeaponType(client);
        final int currentAttackStyleVarbit = client.getVarpValue(VarPlayer.ATTACK_STYLE);
        if (currentAttackStyleVarbit < weaponType.getAttackTypes().length)
        {
            return weaponType.getAttackTypes()[currentAttackStyleVarbit];
        }
        return null;
    }

    // returns zero for no target
    public static int getTargetId(Client client)
    {
        final NPC target = getTargetNPC(client);
        int targetId = 0;
        if (target != null)
        {
            targetId = target.getId();
        }
        return targetId;
    }

    // returns null for no target
    public static NPC getTargetNPC(Client client)
    {
        final Actor target = client.getLocalPlayer().getInteracting();
        if (target != null && (target instanceof NPC))
        {
            final NPC npc = (NPC) target;
            return npc;
        }
        return null;
    }

}

package com.attacktimer;
/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * Copyright (c) 2018, Chdata
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	this list of conditions and the following disclaimer in the documentation
 *	and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.SpriteID;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.util.ImageUtil;


@Singleton
class AttackTimerBarOverlay extends Overlay
{
    private static final Color BAR_FILL_COLOR = new Color(201, 161, 28);
    private static final Color BAR_BG_COLOR = Color.black;
    private static final Dimension ATTACK_BAR_SIZE = new Dimension(30, 5);
    private static final BufferedImage HD_FRONT_BAR = ImageUtil.loadImageResource(AttackTimerMetronomePlugin.class, "/front.png");
    private static final BufferedImage HD_BACK_BAR = ImageUtil.loadImageResource(AttackTimerMetronomePlugin.class, "/back.png");
    private final Client client;
    private final AttackTimerMetronomeConfig config;
    private final AttackTimerMetronomePlugin plugin;

    private boolean shouldShowBar = false;

    @Inject
    private AttackTimerBarOverlay(final Client client, final AttackTimerMetronomeConfig config, final AttackTimerMetronomePlugin plugin)
    {
        this.client = client;
        this.config = config;
        this.plugin = plugin;

        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.HIGH);
        setLayer(OverlayLayer.UNDER_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        onTick();

        if (!shouldShowBar)
        {
            return null;
        }

        final int height = client.getLocalPlayer().getLogicalHeight() + config.heightOffset() + 5;
        final LocalPoint localLocation = client.getLocalPlayer().getLocalLocation();
        final Point canvasPoint = Perspective.localToCanvas(client, localLocation, client.getTopLevelWorldView().getPlane(), height);

        int denomMod = (config.barEmpties()) ? 1 : 0;
        int numerMod = (config.barFills()) ? 1 : 0;
        float ratio = (float) (plugin.getTicksUntilNextAttack() - numerMod) / (float) (plugin.getWeaponPeriod() - denomMod);
        if (!config.barDirection()) {
            ratio = (float)Math.max(1.0f - ratio, 0f);
        }

        if (client.getSpriteOverrides().containsKey(SpriteID.HEALTHBAR_DEFAULT_FRONT_30PX)) {
            final int barWidth = HD_FRONT_BAR.getWidth();
            final int barHeight = HD_FRONT_BAR.getHeight();
            final int barX = canvasPoint.getX() - barWidth / 2;
            final int barY = canvasPoint.getY() + 7;

            final int progressFill = (int) Math.ceil(Math.min((barWidth * ratio), barWidth));

            graphics.drawImage(HD_BACK_BAR, barX, barY, barWidth, barHeight, null);
            // Use a sub-image to create the same effect the HD Health Bar has
            graphics.drawImage(HD_FRONT_BAR.getSubimage(0, 0, progressFill, barHeight), barX, barY, progressFill, barHeight, null);
            return null;
        }
        // Draw bar
        final int barX = canvasPoint.getX() - 15;
        final int barY = canvasPoint.getY() + 7;
        final int barWidth = ATTACK_BAR_SIZE.width;
        final int barHeight = ATTACK_BAR_SIZE.height;

        // Restricted by the width to prevent the bar from being too long while you are boosted above your real prayer level.
        final int progressFill = (int) Math.ceil(Math.min((barWidth * ratio), barWidth));

        graphics.setColor(BAR_BG_COLOR);
        graphics.fillRect(barX, barY, barWidth, barHeight);
        graphics.setColor(BAR_FILL_COLOR);
        graphics.fillRect(barX, barY, progressFill, barHeight);

        return null;
    }
    private void onTick()
    {
        shouldShowBar = true;

        if (!config.enableMetronome()) {
            shouldShowBar = false;
        }

        if (!config.showBar()) {
            shouldShowBar = false;
        }

        if (!plugin.isAttackCooldownPending()) {
            shouldShowBar = false;
        }
    }
}
package com.attacktimer;

/*
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

public enum AttackProcedure {
    POWERED_STAVE,
    MANUAL_AUTO_CAST,
    MELEE_OR_RANGE
}

package com.attacktimer;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum FontTypes
{
    REGULAR("RS Regular"),
    ARIAL("Arial"),
    BOLD("Bold"),
    CAMBRIA("Cambria"),
    ROCKWELL("Rockwell"),
    SEGOE_UI("Segoe Ui"),
    TIMES_NEW_ROMAN("Times New Roman"),
    VERDANA("Verdana");

    private final String name;

    @Override
    public String toString() {
        return name;
    }
}

package com.attacktimer;

/*
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.google.common.collect.ImmutableMap;

enum CastingSoundData
{
    // Keep in spellbook order then alphabetical order and oneline

    // God spells are silent
    STANDARD_BIND(101, Spellbook.STANDARD),
    STANDARD_CONFUSE(119, Spellbook.STANDARD),
    STANDARD_CRUMBLE_UNDEAD(122, Spellbook.STANDARD),
    STANDARD_CURSE(127, Spellbook.STANDARD),
    STANDARD_EARTH_BLAST(128, Spellbook.STANDARD),
    STANDARD_EARTH_BOLT(130, Spellbook.STANDARD),
    STANDARD_EARTH_STRIKE(132, Spellbook.STANDARD),
    STANDARD_EARTH_SURGE(4025, Spellbook.STANDARD),
    STANDARD_EARTH_WAVE(134, Spellbook.STANDARD),
    STANDARD_ENFEEBLE(148, Spellbook.STANDARD),
    STANDARD_ENTANGLE(151, Spellbook.STANDARD),
    STANDARD_FIRE_BLAST(155, Spellbook.STANDARD),
    STANDARD_FIRE_BOLT(157, Spellbook.STANDARD),
    STANDARD_FIRE_STRIKE(160, Spellbook.STANDARD),
    STANDARD_FIRE_SURGE(4032, Spellbook.STANDARD),
    STANDARD_IBANS_BLAST_FIRE_WAVE(162, Spellbook.STANDARD),
    STANDARD_SLAYER_DART(1718, Spellbook.STANDARD),
    STANDARD_SNARE(3003, Spellbook.STANDARD),
    STANDARD_STUN(3004, Spellbook.STANDARD),
    STANDARD_VULNERABILITY(3009, Spellbook.STANDARD),
    STANDARD_WATER_BLAST(207, Spellbook.STANDARD),
    STANDARD_WATER_BOLT(209, Spellbook.STANDARD),
    STANDARD_WATER_STRIKE(221, Spellbook.STANDARD),
    STANDARD_WATER_SURGE(4030, Spellbook.STANDARD),
    STANDARD_WATER_WAVE(213, Spellbook.STANDARD),
    STANDARD_WEAKEN(3011, Spellbook.STANDARD),
    STANDARD_WIND_BLAST(216, Spellbook.STANDARD),
    STANDARD_WIND_BOLT(218, Spellbook.STANDARD),
    STANDARD_WIND_STRIKE(220, Spellbook.STANDARD),
    STANDARD_WIND_SURGE(4028, Spellbook.STANDARD),
    STANDARD_WIND_WAVE(222, Spellbook.STANDARD),

    ANCIENT_BLOOD_SPELL(106, Spellbook.ANCIENT),
    ANCIENT_ICE_SPELL(171, Spellbook.ANCIENT),
    ANCIENT_SHADOW_SPELL(178, Spellbook.ANCIENT),
    ANCIENT_SMOKE_SPELL(183, Spellbook.ANCIENT),

    ARCEUUS_DARK_DEMONBANE(5053, Spellbook.ARCEUUS),
    ARCEUUS_GHOSTLY_GRASP(5042, Spellbook.ARCEUUS),
    ARCEUUS_INFERIOR_DEMONBANE(5038, Spellbook.ARCEUUS),
    ARCEUUS_SKELETAL_GRASP(5026, Spellbook.ARCEUUS),
    ARCEUUS_SUPERIOR_DEMONBANE(5027, Spellbook.ARCEUUS),
    ARCEUUS_UNDEAD_GRASP(5030, Spellbook.ARCEUUS);

    private final int id;
    private final Spellbook spellbook;

    CastingSoundData(int id, Spellbook b)
    {
        this.id = id;
        this.spellbook = b;
    }


    private static final ImmutableMap<Integer, CastingSoundData> sounds;

    static
    {
        ImmutableMap.Builder<Integer, CastingSoundData> builder = new ImmutableMap.Builder<>();

        for (CastingSoundData data : values())
        {
            builder.put(data.id, data);
        }

        sounds = builder.build();
    }

    public static boolean isCastingSound(int id)
    {
        return sounds.containsKey(id);
    }

    public static Spellbook getSpellBookFromId(int id)
    {
        if (!sounds.containsKey(id))
        {
            return null;
        }
        return sounds.get(id).spellbook;
    }
}

package com.attacktimer;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class AttackTimerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(AttackTimerMetronomePlugin.class);
		RuneLite.main(args);
	}
}
package com.attacktimer;

/*
 * Copyright (c) 2024, Lexer747 <https://github.com/Lexer747>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.fail;
import org.junit.Ignore;
import org.junit.Test;
import org.slf4j.helpers.MessageFormatter;

public class EnumTests
{
    @Test
    public void runtimeCheck()
    {
        // Ensures every enum has no duplicate values
        for (AnimationData a : AnimationData.values())
        {
            System.out.println(a.toString());
        }
        for (PoweredStaves a : PoweredStaves.values())
        {
            System.out.println(a.toString());
        }
        for (CastingSoundData a : CastingSoundData.values())
        {
            System.out.println(a.toString());
        }
        for (WeaponType a : WeaponType.values())
        {
            System.out.println(a.toString());
        }
        assertFalse(PoweredStaves.LOCAL_DEBUGGING);
    }

    @Ignore("Only for reporting purposes")
    @Test
    public void missingIdReport()
    {
        boolean failed = false;
        String fails = new String();
        for (PoweredStaves staff : PoweredStaves.values())
        {
            for (int id : staff.getIds()) {
                boolean containsKey = PoweredStaves.poweredStaves.get(id).containsKey(PoweredStaves.UNKNOWN_SPELL);
                if (containsKey)
                {
                    failed = true;
                    fails += MessageFormatter.format("Staff | {} IDs:{} doesn't have a spell associated\n", staff, staff.getIds()).getMessage();
                }
                break;
            }
            if (staff.getProjectiles() == null)
            {
                fails += MessageFormatter.format("Staff | {} doesn't have a projectile associated\n", staff).getMessage();
            }
        }

        if (failed) {
            fail(fails);
        }
    }
}
