package com.splitmanager.controllers;

/**
 * Actions that the PanelView can invoke on its controller.
 */
public interface PanelActions
{
	/**
	 * Start a new session if none is active.
	 */
	void startSession();

	/**
	 * Stop the currently active session, if any.
	 */
	void stopSession();

	/**
	 * Add a player to the active session.
	 *
	 * @param player player display name
	 */
	void addPlayerToSession(String player);

	/**
	 * Add a name to the known-players list.
	 *
	 * @param name player name
	 */
	void addKnownPlayer(String name);

	/**
	 * Remove a name from the known-players list.
	 *
	 * @param name player name
	 */
	void removeKnownPlayer(String name);

	/**
	 * Record a kill amount for a player.
	 *
	 * @param player player name
	 * @param amount amount (may be negative if allowed by config)
	 */
	void addKill(String player, long amount);

	/**
	 * Read current inputs from the view and record a kill.
	 */
	void addKillFromInputs();

	/**
	 * Link an alt to a main account.
	 *
	 * @param main main player
	 * @param alt  alt account to link
	 */
	void addAltToMain(String main, String alt);

	/**
	 * Remove an alt link from the selected main.
	 *
	 * @param main          selected main
	 * @param selectedEntry UI entry string to parse
	 */
	void removeSelectedAlt(String main, String selectedEntry);

	/**
	 * Apply the selected pending value to a specific player.
	 *
	 * @param tableRowIndex index in the pending table
	 */
	void applySelectedPendingValue(int tableRowIndex);

	/**
	 * Delete the selected pending value entry.
	 *
	 * @param tableRowIndex index in the pending table
	 */
	void deleteSelectedPendingValue(int tableRowIndex);

	/**
	 * Handle selection change in known-players list.
	 *
	 * @param selected currently selected name
	 */
	void onKnownPlayerSelectionChanged(String selected);

	/**
	 * Refresh all sections of the view; idempotent and safe after mutations.
	 */
	void refreshAllView(); // idempotent, safe to call after model mutations

	/**
	 * Recompute and apply metrics for current session.
	 */
	void recomputeMetrics();

	void recomputeMetricsForSession(String sessionId);

	void altPlayerManageAddPlayer(String player);

	void altPlayerManageRemovePlayer(String player);

	/**
	 * Copy metrics to clipboard in JSON.
	 */
	void copyMetricsJson();

	/**
	 * Copy metrics to clipboard in Markdown.
	 */
	void copyMetricsMarkdown();

	// Tutorial controls to keep MVC separation
	void tourStart();

	void tourPrev();

	void tourNext();

	void tourEnd();
}

package com.splitmanager.controllers;

import com.splitmanager.ManagerKnownPlayers;
import com.splitmanager.ManagerPanel;
import com.splitmanager.ManagerSession;
import com.splitmanager.PluginConfig;
import com.splitmanager.models.Metrics;
import com.splitmanager.models.PendingValue;
import com.splitmanager.models.Session;
import com.splitmanager.models.WaitlistTable;
import com.splitmanager.utils.Formats;
import com.splitmanager.utils.MarkdownFormatter;
import static com.splitmanager.utils.Utils.toast;
import com.splitmanager.views.PanelView;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.util.List;
import javax.swing.DefaultCellEditor;
import javax.swing.DefaultComboBoxModel;
import javax.swing.DefaultListModel;
import javax.swing.JComboBox;
import javax.swing.JOptionPane;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

//Testing push again

/**
 * MVC Controller: non-UI logic + event handling. The View calls into this via PanelActions.
 * Keeps string/markdown/transfer computations here and pushes UI refreshes through the View.
 */
@Slf4j
public class PanelController implements PanelActions
{
	private final ManagerSession sessionManager;
	private final PluginConfig config;
	private final ManagerKnownPlayers playerManager;
	private final ManagerPanel managerPanel;
	@Setter
	private PanelView view;
	private Formats.OsrsAmountFormatter formats;

	public PanelController(ManagerSession sessionManager, PluginConfig config, ManagerKnownPlayers playerManager, ManagerPanel managerPanel)
	{
		this.sessionManager = sessionManager;
		this.playerManager = playerManager;
		this.config = config;
		this.managerPanel = managerPanel;
		this.formats = new Formats.OsrsAmountFormatter();
	}

	@Override
	public void startSession()
	{
		if (sessionManager.isHistoryLoaded())
		{
			toast(view, "Unload history first.");
			return;
		}
		if (sessionManager.hasActiveSession())
		{
			toast(view, "Active session exists.");
			return;
		}
		sessionManager.startSession().ifPresent(s -> toast(view, "Session started."));
		managerPanel.refreshAllView();
		refreshAllView();
	}

	@Override
	public void stopSession()
	{
		if (sessionManager.isHistoryLoaded())
		{
			toast(view, "Cannot stop while history loaded.");
			return;
		}
		if (sessionManager.stopSession(view))
		{
			managerPanel.refreshAllView();
		}
		else
		{
			toast(view, "Failed to stop session.");
		}
		refreshAllView();
	}

	@Override
	public void addPlayerToSession(String player)
	{
		if (player == null)
		{
			toast(view, "Select a player in dropdown.");
			return;
		}
		if (sessionManager.addPlayerToActive(player))
		{
			managerPanel.refreshAllView();
		}
		else
		{
			toast(view, "Failed to add player, player might already be in session.");
		}
		refreshAllView();
	}

	@Override
	public void addKnownPlayer(String name)
	{
		String clean = name == null ? "" : name.trim();
		if (clean.isEmpty())
		{
			toast(view, "Enter a name.");
			return;
		}
		if (!playerManager.addKnownPlayer(clean))
		{
			toast(view, "Player already in list exists.");
			return;
		}
		playerManager.saveToConfig();
		managerPanel.refreshAllView();
		view.getKnownPlayersDropdown().setSelectedItem(clean);
		view.getNewPlayerField().setText("");
		view.getNewPlayerField().requestFocusInWindow();
		refreshAllView();
	}

	@Override
	public void removeKnownPlayer(String name)
	{
		if (name == null)
		{
			toast(view, "Select a Player to remove.");
			return;
		}
		int res = JOptionPane.showConfirmDialog(view,
			"Remove '" + name + "'? This will also unlink any alt relationships.",
			"Confirm removal",
			JOptionPane.YES_NO_OPTION,
			JOptionPane.WARNING_MESSAGE);
		if (res != JOptionPane.YES_OPTION)
		{
			return;
		}

		if (!playerManager.removeKnownPlayer(name))
		{
			toast(view, "Not found.");
			return;
		}
		playerManager.saveToConfig();
		managerPanel.refreshAllView();
		refreshAllView();
	}

	@Override
	public void addKill(String player, long amount)
	{
		if (player == null)
		{
			toast(view, "Select a player.");
			return;
		}
		if (sessionManager.addKill(player, amount))
		{
			view.getKillAmountField().setText("");
			managerPanel.refreshAllView();
		}
		else
		{
			toast(view, "Failed to add kill (is player in session?).");
		}
		refreshAllView();
	}

	@Override
	public void addKillFromInputs()
	{
		String player = (String) view.getCurrentSessionPlayerDropdown().getSelectedItem();

		Object rawValue = view.getKillAmountField().getValue();
		if (rawValue == null) {
			toast(view, "Please enter a valid amount.");
			return;
		}

		String val = rawValue.toString();
		long amt;
		try
		{
			log.debug("Adding kill for1  {} with amount {}", player, val);
			//amt = Formats.OsrsAmountFormatter.stringAmountToLongAmount(val,config);
			//log.debug("Adding kill for2  {} with amount {}", player, amt);
			amt = Long.parseLong(val);
			log.debug("Adding kill for3  {} with amount {}", player, amt);
			// amt = Long.parseLong(val); TODO?????
			addKill(player, amt);
		}
		catch (Exception ex)
		{
			toast(view, "Invalid amount.");
		}
	}

	@Override
	public void addAltToMain(String main, String alt)
	{
		if (sessionManager.hasActiveSession())
		{
			toast(view, "Cannot add/remove alts while session is active. Stop session first.");
			return;
		}
		if (main == null || alt == null)
		{
			toast(view, "Select a player and an alt to add.");
			return;
		}
		if (!playerManager.canLinkAltToMain(alt, main))
		{
			toast(view, "Cannot link: either main is an alt, alt already linked, or alt is a main.");
			return;
		}
		if (playerManager.trySetAltMain(alt, main))
		{
			toast(view, String.format("Linked %s â†’ %s", alt, main));
			managerPanel.refreshAllView();
			refreshAllView();
		}
		else
		{
			toast(view, "Failed to link alt.");
		}
	}

	@Override
	public void removeSelectedAlt(String selectedMain, String selectedEntry)
	{
		if (sessionManager.hasActiveSession())
		{
			toast(view, "Cannot add/remove alts while session is active. Stop session first.");
			return;
		}
		if (selectedMain == null || selectedMain.isBlank())
		{
			toast(view, "Select a player in Known list.");
			return;
		}
		if (selectedEntry == null || selectedEntry.isBlank())
		{
			toast(view, "Select an alt in the list to remove.");
			return;
		}

		String alt = playerManager.parseAltFromEntry(selectedEntry);
		String main = playerManager.getMainName(alt);

		if (!playerManager.isAlt(alt))
		{
			toast(view, alt + " is not linked as an alt.");
			return;
		}

		if (main == null || !main.equalsIgnoreCase(selectedMain))
		{
			toast(view, String.format("%s is linked to %s, not %s.", alt, main, selectedMain));
			return;
		}

		int res = JOptionPane.showConfirmDialog(view,
			"Unlink '" + alt + "' from '" + main + "'?",
			"Confirm unlink",
			JOptionPane.YES_NO_OPTION,
			JOptionPane.WARNING_MESSAGE);

		if (res != JOptionPane.YES_OPTION)
		{
			return;
		}

		if (playerManager.unlinkAlt(alt))
		{
			toast(view, "Unlinked alt.");
			managerPanel.refreshAllView();
			playerManager.saveToConfig();
			refreshAllView();
		}
		else
		{
			toast(view, "Failed to unlink alt.");
		}
	}

	@Override
	public void applySelectedPendingValue(int idx)
	{
		if (idx < 0)
		{
			toast(view, "Select a detected value first.");
			return;
		}
		if (!sessionManager.hasActiveSession())
		{
			toast(view, "Start a session first.");
			return;
		}
		WaitlistTable m = view.getWaitlistTableModel();
		PendingValue pv = m.getRow(idx);
		if (pv == null)
		{
			return;
		}
		String target = pv.getSuggestedPlayer();
		if (target == null || target.isBlank())
		{
			toast(view, "Choose a Suggested Player in the table first.");
			return;
		}
		if (sessionManager.applyPendingValueToPlayer(pv.getId(), target))
		{
			managerPanel.refreshAllView();
		}
		else
		{
			toast(view, "Failed to add value. Is the player in the session?");
		}
		refreshAllView();
	}

	@Override
	public void deleteSelectedPendingValue(int idx)
	{
		if (idx < 0)
		{
			toast(view, "Select a detected value first.");
			return;
		}
		WaitlistTable m = view.getWaitlistTableModel();
		PendingValue pv = m.getRow(idx);
		if (pv == null)
		{
			return;
		}
		if (sessionManager.removePendingValueById(pv.getId()))
		{
			managerPanel.refreshAllView();
		}
		refreshAllView();
	}

	@Override
	public void onKnownPlayerSelectionChanged(String selected)
	{
		refreshAlts();
	}

	@Override
	public void refreshAllView()
	{
		refreshKnownPlayers();
		recomputeMetrics();
		refreshSessionData();
		refreshWaitlist();
		refreshButtonStates();
	}

	@Override
	public void recomputeMetrics()
	{
		Session current = sessionManager.getCurrentSession().orElse(null);
		if (current != null)
		{
			((Metrics) view.getMetricsTable().getModel()).setData(sessionManager.computeMetricsFor(current, true));
			view.getRecentSplitsModel().setFromKills(sessionManager.getAllKills());
		}
		else
		{
			view.getRecentSplitsModel().clear();
		}
	}

	@Override
	public void recomputeMetricsForSession(String sessionId)
	{
		if (sessionId == null)
		{
			recomputeMetrics();
			return;
		}
		// Find that session (either current or one from history)
		Session target = sessionManager.getAllSessionsNewestFirst().stream()
			.filter(s -> sessionId.equals(s.getId()))
			.findFirst().orElse(null);
		if (target != null)
		{
			((Metrics) view.getMetricsTable().getModel()).setData(
				sessionManager.computeMetricsFor(target, true)
			);
		}
		// Keep the recent splits list up-to-date (it shows all kills)
		view.getRecentSplitsModel().setFromKills(sessionManager.getAllKills());
	}

	@Override
	public void altPlayerManageAddPlayer(String player)
	{
		//TODO remove
	}

	@Override
	public void altPlayerManageRemovePlayer(String player)
	{
		//TODO remove
	}

	@Override
	public void copyMetricsJson()
	{
		String payload = MarkdownFormatter.buildMetricsJson(sessionManager);
		StringSelection selection = new StringSelection(payload);
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(selection, selection);
	}

	@Override
	public void copyMetricsMarkdown()
	{
		String payload = MarkdownFormatter.buildMetricsMarkdown(
			sessionManager.computeMetricsFor(
				sessionManager.getCurrentSession().orElse(null), true), config);
		StringSelection selection = new StringSelection(payload);
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(selection, selection);
	}

	// Tutorial control implementations to keep view passive
	@Override
	public void tourStart()
	{
		view.startTour();
	}

	@Override
	public void tourPrev()
	{
		view.prevTourStep();
	}

	@Override
	public void tourNext()
	{
		view.nextTourStep();
	}

	@Override
	public void tourEnd()
	{
		try
		{
			config.enableTour(false);
		}
		catch (Throwable ignored)
		{
		}
		view.endTour();
	}

	/**
	 * Refreshes the list of known players and updates corresponding UI components.
	 * <p>
	 * This method retrieves the list of known players from the session manager and updates
	 * the dropdown menu for known players in the user interface, as well as the label showing
	 * the count of known players. It ensures synchronization between the backend data and
	 * the visual presentation of known players.
	 */
	private void refreshKnownPlayers()
	{
		String[] players = sessionManager.getKnownPlayers().toArray(new String[0]);
		view.getKnownPlayersDropdown().setModel(new DefaultComboBoxModel<>(players));
		view.getKnownListLabel().setText("Known (" + players.length + "):");

		refreshAlts();
	}

	/**
	 * Refreshes and updates user interface components related to the current session data.
	 */
	private void refreshSessionData()
	{
		Session currentSession = sessionManager.getCurrentSession().orElse(null);

		if (currentSession != null && currentSession.isActive())
		{
			String[] sessionPlayers = currentSession.getPlayers().toArray(new String[0]);
			String[] notPlayers = sessionManager.getNonActivePlayers().toArray(new String[0]);

			view.getCurrentSessionPlayerDropdown().setEnabled(true);
			view.getCurrentSessionPlayerDropdown().setModel(new DefaultComboBoxModel<>(sessionPlayers));
			view.getNotInCurrentSessionPlayerDropdown().setModel(new DefaultComboBoxModel<>(notPlayers));
		}
		else
		{
			view.getCurrentSessionPlayerDropdown().setModel(new DefaultComboBoxModel<>(new String[0]));
			view.getCurrentSessionPlayerDropdown().setEnabled(false);
		}

		view.getHistoryLabel().setText("History: " + (sessionManager.isHistoryLoaded() ? "ON" : "OFF"));

		Session current = sessionManager.getCurrentSession().orElse(null);
		if (current != null)
		{
			((Metrics) view.getMetricsTable().getModel())
				.setData(sessionManager.computeMetricsFor(current, true));
			view.getRecentSplitsModel().setFromKills(sessionManager.getAllKills());
		}
		else
		{
			view.getRecentSplitsModel().clear();
		}
	}

	/**
	 * Refreshes the data and UI components related to the waitlist table.
	 * <p>
	 * This method fetches the latest pending values from the session manager and updates
	 * the waitlist table model with this data. It also configures the cell editor for the
	 * third column of the waitlist table, populating it with a dropdown of known main players
	 * retrieved from the session manager.
	 * <p>
	 * Ensures that the waitlist table reflects the most up-to-date state of the application.
	 */
	private void refreshWaitlist()
	{
		view.getWaitlistTableModel().setData(sessionManager.getPendingValues());
		view.getWaitlistTable()
			.getColumnModel()
			.getColumn(2)
			.setCellEditor(new DefaultCellEditor(new JComboBox<>(
				playerManager.getKnownMains().toArray(new String[0]
				)
			)));
	}

	/**
	 * Updates the enabled or disabled state of various buttons and fields in the user interface.
	 * The button states are set based on the current session status, player selections, and
	 * whether the session is in a read-only mode.
	 */
	private void refreshButtonStates()
	{
		boolean readOnly = sessionManager.isHistoryLoaded();
		boolean hasActiveSession = sessionManager.hasActiveSession();

		view.getBtnStart().setEnabled(!readOnly && !hasActiveSession);
		view.getBtnStop().setEnabled(!readOnly && hasActiveSession);
		view.getBtnAddToSession().setEnabled(!readOnly && hasActiveSession);
		view.getNotInCurrentSessionPlayerDropdown().setEnabled(!readOnly && hasActiveSession);
		view.getBtnRemoveFromSession().setEnabled(!readOnly && hasActiveSession);

		boolean canAddKill = !readOnly && hasActiveSession;
		boolean hasSessionPlayers = view.getCurrentSessionPlayerDropdown().getItemCount() > 0;

		view.getBtnAddKill().setEnabled(canAddKill && hasSessionPlayers);
		view.getKillAmountField().setEnabled(canAddKill && hasSessionPlayers);

		int waitlistRows = view.getWaitlistTableModel().getRowCount();

		view.getBtnWaitlistAdd().setEnabled(!readOnly && hasActiveSession && waitlistRows > 0);
		view.getBtnWaitlistDelete().setEnabled(waitlistRows > 0);
	}

	/**
	 * Refreshes the dropdown lists and UI components related to alternate accounts.
	 * This method ensures that the UI reflects the currently selected main player
	 * and dynamically updates the list of eligible alternate accounts that can be linked to the selected player.
	 */
	private void refreshAlts()
	{
		String[] players = sessionManager.getKnownPlayers().toArray(new String[0]);

		String selectedMain = (String) view.getKnownPlayersDropdown().getSelectedItem();
		if (selectedMain == null && players.length > 0)
		{
			selectedMain = players[0];
			view.getKnownPlayersDropdown().setSelectedIndex(0);
		}

		refreshAltList(selectedMain);

		List<String> eligiblePlayers = new java.util.ArrayList<>();

		if (selectedMain != null)
		{
			for (String p : sessionManager.getKnownPlayers())
			{
				if (playerManager.canLinkAltToMain(p, selectedMain))
				{
					eligiblePlayers.add(p);
				}
			}
		}

		view.getAddAltDropdown().setModel(new DefaultComboBoxModel<>(eligiblePlayers.toArray(new String[0])));
	}

	/**
	 * Refreshes the list of alternate accounts associated with the given main player.
	 * Updates the alt label and list in the view with relevant information about the player's alt accounts.
	 * If the player is identified as an alt, displays the corresponding main account name.
	 *
	 * @param mainPlayer the name of the main player whose alternate accounts are to be refreshed;
	 *                   if null, the method exits without performing any action.
	 */
	public void refreshAltList(String mainPlayer)
	{
		if (mainPlayer == null)
		{
			return;
		}

		String altsText = !mainPlayer.isBlank()
			? (mainPlayer + " known alts:")
			: "Known alts:";
		view.getAltsLabel().setText(altsText);

		DefaultListModel<String> altsModel = (DefaultListModel<String>) view.getAltsList().getModel();
		altsModel.clear();

		if (playerManager.isAlt(mainPlayer))
		{
			String mainName = playerManager.getMainName(mainPlayer);
			if (mainName != null && !mainName.equalsIgnoreCase(mainPlayer))
			{
				altsModel.addElement(mainPlayer + " is an alt of " + mainName);
			}
		}

		for (String alt : playerManager.getAltsOf(mainPlayer))
		{
			altsModel.addElement(alt);
		}
	}
}
package com.splitmanager;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.splitmanager.utils.InstantTypeAdapter;
import java.lang.reflect.Type;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;

/**
 * This class provides functionality to manage relationships between "main" players
 * and their alternate (alt) players within a gaming or user system. It interacts
 * with backend session management to perform operations like linking, unlinking,
 * and retrieving alt players while also updating the user interface to reflect
 * these changes.
 */
@Singleton
public class ManagerKnownPlayers
{
	private final Gson gson;
	private final PluginConfig config;
	@Getter
	private Set<String> knownPlayers = new LinkedHashSet<>();
	@Getter
	private Map<String, String> altMainMapping = new LinkedHashMap<>();

	@Inject
	public ManagerKnownPlayers(PluginConfig config, Gson gson)
	{
		this.config = config;
		// Use the client's injected Gson and customize via newBuilder per PluginHub guidelines
		this.gson = gson.newBuilder()
			.registerTypeAdapter(Instant.class, new InstantTypeAdapter())
			.create();
	}

	public void loadFromConfig()
	{
		knownPlayers.clear();
		String csv = config.knownPlayersCsv();
		if (csv != null && !csv.isEmpty())
		{
			for (String p : csv.split(","))
			{
				String t = p.trim();
				if (!t.isEmpty())
				{
					knownPlayers.add(t);
				}
			}
		}

		altMainMapping.clear();
		String altsJson = config.altsJson();
		if (altsJson != null && !altsJson.isEmpty())
		{
			try
			{
				Type mapType = new TypeToken<Map<String, String>>()
				{
				}.getType();
				Map<String, String> m = gson.fromJson(altsJson, mapType);
				if (m != null)
				{
					altMainMapping.putAll(m);
				}
			}
			catch (Exception ignored)
			{
			}
		}
	}

	public void saveToConfig()
	{
		config.knownPlayersCsv(String.join(",", knownPlayers));
		try
		{
			config.altsJson(gson.toJson(altMainMapping));
		}
		catch (Exception e)
		{
			// ignore
		}
	}

	/**
	 * Parse the alt name from a selected entry.
	 */
	public String parseAltFromEntry(String selectedEntry)
	{
		if (selectedEntry.contains(" is an alt of "))
		{
			String[] parts = selectedEntry.split(" is an alt of ", 2);
			if (parts.length == 2)
			{
				return parts[0].trim();
			}
		}
		return selectedEntry.trim();
	}

	/**
	 * @return unmodifiable set of known players that are mains (exclude names mapped as alts).
	 */
	public Set<String> getKnownMains()
	{
		LinkedHashSet<String> mains = knownPlayers.stream()
			.filter(p -> !isAlt(p))
			.collect(Collectors.toCollection(LinkedHashSet::new));
		return Collections.unmodifiableSet(mains);
	}

	/**
	 * Validate whether an alt may be linked to a main.
	 * Rules:
	 * - alt and main must be non-empty and not equal (case-insensitive)
	 * - the chosen main cannot itself be an alt
	 * - the alt cannot already point to a different main
	 * - the alt cannot be someone else's main (prevents cycles)
	 *
	 * @return true if the link is allowed
	 */
	public boolean canLinkAltToMain(String alt, String main)
	{
		if (alt == null || main == null)
		{
			return false;
		}
		String a = alt.trim();
		String m = main.trim();
		if (a.isEmpty() || m.isEmpty())
		{
			return false;
		}
		if (a.equalsIgnoreCase(m))
		{
			return false;
		}
		if (altMainMapping.containsKey(m))
		{
			return false;
		}
		if (altMainMapping.containsKey(a) && !altMainMapping.get(a).equalsIgnoreCase(m))
		{
			return false;
		}
		for (Map.Entry<String, String> e : altMainMapping.entrySet())
		{
			if (e.getValue() != null && e.getValue().equalsIgnoreCase(a))
			{
				return false;
			}
		}
		return true;
	}

	/**
	 * Attempt to persist an alt->main link, enforcing the validation from canLinkAltToMain().
	 * Adds both names to the known list on success.
	 *
	 * @return true if the mapping either already existed (same) or was created
	 */
	public boolean trySetAltMain(String alt, String main)
	{
		if (!canLinkAltToMain(alt, main))
		{
			return false;
		}
		String a = alt.trim();
		String m = main.trim();
		if (altMainMapping.containsKey(a) && altMainMapping.get(a).equalsIgnoreCase(m))
		{
			return true;
		}
		altMainMapping.put(a, m);
		knownPlayers.add(a);
		knownPlayers.add(m);
		saveToConfig();
		return true;
	}

	/**
	 * Unlink the given alt from its main.
	 *
	 * @param alt the alt name to unlink
	 * @return true if an existing mapping was removed
	 */
	public boolean unlinkAlt(String alt)
	{
		if (alt == null || alt.trim().isEmpty())
		{
			return false;
		}
		String a = alt.trim();
		if (!altMainMapping.containsKey(a))
		{
			return false;
		}
		altMainMapping.remove(a);
		saveToConfig();
		return true;
	}

	/**
	 * Resolve a display name to its main account by following the alt->main mapping.
	 * If the name is not an alt, returns the original trimmed name. Protects against cycles.
	 *
	 * @param name main or alt name
	 * @return resolved main name (or the input trimmed if not an alt)
	 */
	public String getMainName(@Nonnull String name)
	{
		String n = name.trim();
		String visited = null;
		// resolve chain up to a few steps to avoid cycles
		for (int i = 0; i < 5; i++)
		{
			String m = altMainMapping.get(n);
			if (m == null || m.equalsIgnoreCase(n))
			{
				return n;
			}
			if (visited != null && visited.equalsIgnoreCase(m))
			{
				break;
			}
			visited = n;
			n = m;
		}
		return n;
	}

	/**
	 * @param name player name
	 * @return true if the given name is present as a key in the alt->main mapping
	 */
	public boolean isAlt(String name)
	{
		if (name == null)
		{
			return false;
		}
		return altMainMapping.containsKey(name.trim());
	}

	/**
	 * List all alts currently linked to the given main.
	 *
	 * @param main main account name
	 * @return sorted list of alt names linked to this main (case-insensitive compare)
	 */
	public List<String> getAltsOf(String main)
	{
		if (main == null || main.isBlank())
		{
			return List.of();
		}
		String m = main.trim();
		List<String> out = new ArrayList<>();
		for (Map.Entry<String, String> e : altMainMapping.entrySet())
		{
			if (e.getValue() != null && e.getValue().equalsIgnoreCase(m))
			{
				out.add(e.getKey());
			}
		}
		out.sort(String::compareToIgnoreCase);
		return out;
	}


	/**
	 * Add a player name to the known-players list.
	 *
	 * @param name display name
	 * @return true if added
	 */
	public boolean addKnownPlayer(String name)
	{
		boolean added = knownPlayers.add(name.trim());
		if (added)
		{
			saveToConfig();
		}
		return added;
	}

	public boolean isKnownPlayer(@Nonnull String name)
	{
		return isKnownPlayer(name, false);
	}

	public boolean isKnownPlayer(@Nonnull String name, @Nonnull Boolean save)
	{
		if (name.trim().isEmpty())
		{
			return false;
		}

		boolean known = knownPlayers.contains(name.trim());

		if (save && !known)
		{
			addKnownPlayer(name.trim());
			return true;
		}

		return known;
	}

	public boolean removeKnownPlayer(String name)
	{
		String n = name == null ? null : name.trim();
		if (n == null || n.isEmpty())
		{
			return false;
		}
		boolean rem = knownPlayers.remove(n);

		altMainMapping.remove(n);
		altMainMapping.entrySet().removeIf(e -> e.getValue().equalsIgnoreCase(n));

		saveToConfig();
		return rem;
	}

	public void init()
	{
		loadFromConfig();
	}
}
package com.splitmanager;

import com.splitmanager.controllers.PanelController;
import com.splitmanager.views.PanelView;
import com.splitmanager.views.PopoutView;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.FlowLayout;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.WindowConstants;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;


/**
 * Composition root: builds Model, View, Controller and wires them together.
 * No UI logic or event handling lives here anymore.
 */
@Slf4j
@Singleton
public class ManagerPanel
{

	private final ManagerSession manager;
	private final PluginConfig config;
	private final ManagerKnownPlayers playerManager;
	private JFrame popoutFrame;
	private JButton popOutBtn;
	private PanelController controller;
	@Getter
	@Setter
	private PanelView view;

	/**
	 * Construct a new plugin panel and bootstrap its MVC components.
	 *
	 * @param sessionManager session/state sessionManager for split tracking
	 * @param config         plugin configuration
	 */
	@Inject
	public ManagerPanel(ManagerSession sessionManager, PluginConfig config, ManagerKnownPlayers playerManager)
	{
		this.manager = sessionManager;
		this.config = config;
		this.playerManager = playerManager;
	}

	/**
	 * Refresh all view sections via the controller.
	 */
	public void refreshAllView()
	{
		controller.refreshAllView();
	}

	/**
	 * Initialize and wire the view and controller, and perform an initial sync.
	 */
	private void startPanel()
	{
		controller = new PanelController(manager, config, playerManager, this);
		view = new PanelView(manager, config, playerManager, controller);
		controller.setView(view);

		if (config.enablePopout())
		{
			popOutBtn = new JButton("Pop Out");
			popOutBtn.addActionListener(e -> togglePopOutWindow());
			JPanel topBar = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 5));
			topBar.add(popOutBtn);
			view.add(topBar, BorderLayout.NORTH, 0);
		}

		controller.refreshAllView();
	}


	private void togglePopOutWindow()
	{
		if (popoutFrame != null && popoutFrame.isDisplayable())
		{
			return;
		}
		if (popOutBtn != null)//hide button if window open
		{
			popOutBtn.setVisible(false);
			view.revalidate();
			view.repaint();
		}

		PanelController ctrl = new PanelController(manager, config, playerManager, this);
		PopoutView popoutView = new PopoutView(manager, config, playerManager, ctrl);
		ctrl.setView(popoutView);

		ctrl.refreshAllView();

		popoutFrame = new JFrame("Auto Split Manager");
		popoutFrame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
		JScrollPane scrollPane = new JScrollPane(popoutView);
		scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		popoutFrame.getContentPane().add(scrollPane, BorderLayout.CENTER);
		popoutFrame.pack();
		popoutFrame.setMinimumSize(new Dimension(800, 600));
		popoutFrame.setLocationRelativeTo(null);
		popoutFrame.setVisible(true);

		//show button if window closes
		popoutFrame.addWindowListener(new java.awt.event.WindowAdapter()
		{
			@Override
			public void windowClosed(java.awt.event.WindowEvent e)
			{
				popoutFrame = null;
				if (popOutBtn != null)
				{
					popOutBtn.setVisible(true);
					popoutView.revalidate();
					popoutView.repaint();
				}
			}
		});
	}


	/**
	 * Recreate the panel components from scratch.
	 */
	public void restart()
	{
		view.removeAll();
		startPanel();
	}

	public void init()
	{
		startPanel();
	}
}

package com.splitmanager;

import com.google.inject.Provides;
import com.splitmanager.models.PendingValue;
import com.splitmanager.models.Session;
import com.splitmanager.utils.ChatStatusOverlay;
import com.splitmanager.utils.Formats;
import com.splitmanager.views.PanelView;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.text.ParseException;
import java.util.Arrays;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.Player;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanChannelMember;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ClanChannelChanged;
import net.runelite.api.events.FriendsChatChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.WorldChanged;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;

@Slf4j
@PluginDescriptor(
	name = "Auto Split Manager",
	description = "Automatically track and manage splits for group PvM/PvP. Features include: chat detection of drops, player roster management with alt support, split calculations, session tracking, settlement metrics, and configurable UI. JSON export available for sharing and backup.",
	tags = {"splits", "loot", "pvm", "pvp", "tracker", "clan", "group"}
)
/**
 * Main RuneLite plugin entry point for Auto Split Manager.
 * Wires up UI, session management, configuration, and chat/menu event handlers.
 */
public class ManagerPlugin extends Plugin
{
	@Getter
	private static ManagerPanel panel;
	@Inject
	private Client client;
	@Inject
	private ClientToolbar clientToolbar;
	@Getter
	@Inject
	private PluginConfig config;
	@Inject
	private OverlayManager overlayManager;
	private ChatStatusOverlay chatOverlay;
	private NavigationButton navButton;

	@Inject
	private ManagerPanel panelManager;
	@Inject
	private ManagerSession sessionManager;
	@Inject
	private ManagerKnownPlayers playerManager;
	private PanelView view;


	@Override
	/**
	 * Initialize plugin state and register the sidebar panel/navigation.
	 */
	protected void startUp()
	{
		Formats.setConfig(config);
		playerManager.init();
		sessionManager.init();
		panelManager.init();

		// TODO create an icon

		chatOverlay = new ChatStatusOverlay();
		overlayManager.add(chatOverlay);
		view = panelManager.getView();
		navButton = NavigationButton.builder()
			.tooltip("Auto Split Manager")
			.icon(createIcon())
			.priority(5)
			.panel(view)
			.build();
		clientToolbar.addNavigation(navButton);
	}


	private BufferedImage createIcon(){
		BufferedImage scalesIcon = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
		java.awt.Graphics2D g = scalesIcon.createGraphics();
		g.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING, java.awt.RenderingHints.VALUE_ANTIALIAS_ON);

		// Define colors
		java.awt.Color darkBrown = new java.awt.Color(58, 40, 28);
		java.awt.Color orange = new java.awt.Color(246, 135, 79);
		java.awt.Color cream = new java.awt.Color(255, 224, 159);
		java.awt.Color black = new java.awt.Color(0, 0, 0);

		// First draw black outlines/shadows (slightly offset)
		g.setColor(black);
		g.setStroke(new java.awt.BasicStroke(2.0f));

		// Shadow for the center vertical line - made taller
		g.drawLine(8, 1, 8, 12);

		// Shadow for the horizontal balance bar - moved up slightly
		g.drawLine(2, 3, 14, 3);

		// Shadow for triangular connections - adjusted for taller appearance
		g.drawLine(4, 3, 1, 8); // Left triangle
		g.drawLine(12, 3, 15, 8); // Right triangle

		// Shadow for the left scale bowl - moved down slightly
		g.drawArc(0, 8, 6, 4, 0, 180);

		// Shadow for the right scale bowl - moved down slightly
		g.drawArc(10, 8, 6, 4, 0, 180);

		// Shadow for the base - moved down
		g.drawArc(5, 12, 6, 4, 0, 180);

		// Now draw the actual elements

		// Draw the center vertical line (pole) - made taller
		g.setColor(darkBrown);
		g.setStroke(new java.awt.BasicStroke(1.5f));
		g.drawLine(8, 1, 8, 12);

		// Draw the horizontal balance bar - moved up slightly
		g.drawLine(2, 3, 14, 3);

		// Draw the triangular connections - adjusted for taller appearance
		g.drawLine(4, 3, 1, 8); // Left triangle
		g.drawLine(12, 3, 15, 8); // Right triangle

		// Draw the left scale bowl outline - moved down slightly
		g.drawArc(0, 8, 6, 4, 0, 180);

		// Draw the right scale bowl outline - moved down slightly
		g.drawArc(10, 8, 6, 4, 0, 180);

		// Fill the bowls with orange
		g.setColor(orange);
		g.fillArc(1, 9, 4, 2, 0, 180);
		g.fillArc(11, 9, 4, 2, 0, 180);

		// Draw the base outline - moved down
		g.setColor(darkBrown);
		g.drawArc(5, 12, 6, 4, 0, 180);

		// Fill the base with cream color
		g.setColor(cream);
		g.fillArc(6, 13, 4, 2, 0, 180);

		g.dispose();

		return scalesIcon;
	}

	@Override
	/**
	 * Persist state and remove UI elements when the plugin shuts down.
	 */
	protected void shutDown()
	{
		if (navButton != null)
		{
			clientToolbar.removeNavigation(navButton);
			navButton = null;
		}
		if (sessionManager != null)
		{
			sessionManager.saveToConfig();
		}

		if (chatOverlay != null)
		{
			overlayManager.remove(chatOverlay);
			chatOverlay = null;
		}
	}

	/**
	 * Provide injectable configuration instance.
	 *
	 * @param configManager RuneLite config manager
	 * @return plugin config
	 */
	@Provides
	PluginConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(PluginConfig.class);
	}

	@Subscribe
	public void onClanChannelChanged(ClanChannelChanged e)
	{
		updateChatWarningStatus();
	}

	@Subscribe
	public void onFriendsChatChanged(FriendsChatChanged e)
	{
		updateChatWarningStatus();
	}

	@Subscribe
	public void onWorldChanged(WorldChanged e)
	{
		updateChatWarningStatus();
	}

	/**
	 * React to plugin configuration changes that require a panel refresh/restart.
	 *
	 * @param e config change event
	 */
	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		if (!"Split Manager".equals(e.getGroup()))
		{
			return;
		}

		switch (e.getKey())
		{
			case "directPayments":
				log.info("Direct payments changed, refreshing panel");
				restartViewFix();
				break;
			case "WarnNotInFC":
				updateChatWarningStatus();
				break;
			case "enablePopout":
			case "enableTour":
				restartViewFix();
				break;
		}
	}

	private void restartViewFix()
	{
		panelManager.restart();
		view = panelManager.getView();
		if (navButton != null)
		{
			clientToolbar.removeNavigation(navButton);
			navButton = NavigationButton.builder()
				.tooltip("Auto Split Manager")
				.icon(navButton.getIcon())
				.priority(5)
				.panel(view)
				.build();
			clientToolbar.addNavigation(navButton);
		}
	}

	/**
	 * Parse chat messages to detect values and enqueue PendingValue suggestions.
	 *
	 * @param event chat message event
	 * @throws ParseException when number parsing fails
	 */
	@Subscribe
	public void onChatMessage(ChatMessage event) throws ParseException
	{

		// Disabled for now, this should be covered by other checks
		if (CheckChatJoinLeave(event))
		{
			return;
		}

		if (!config.enableChatDetection())
		{
			return;
		}

		Formats.OsrsAmountFormatter f = new Formats.OsrsAmountFormatter();
		ChatMessageType type = event.getType();
		String tname = type.name();

		boolean isClan = tname.contains("CLAN");
		boolean isFriends = tname.contains("FRIEND");

		if (isClan && !config.detectInClanChat())
		{
			return;
		}
		if (isFriends && !config.detectInFriendsChat())
		{
			return;
		}
		if (!isClan && !isFriends)
		{
			return;
		}

		String msg = event.getMessage();

		// Try parse PvM drop
		if (config.detectPvmValues())
		{
			java.util.regex.Matcher m = java.util.regex.Pattern.compile("^(.+?) has received a drop: .*?\\((\\d[\\d,]*) coins\\)").matcher(msg);
			if (m.find())
			{
				String player = m.group(1);
				Long value = (Long) f.stringToValue(m.group(2) + " coins");
				queuePending(PendingValue.Type.PVM, isClan ? "Clan" : "Friends", msg, value, player);
				return;
			}
		}

		// Try parse PvP loot
		if (config.detectPvpValues())
		{
			java.util.regex.Matcher m = java.util.regex.Pattern.compile("^(.+?) has defeated (.+?) and received \\((\\d[\\d,]*) coins\\) worth of loot!").matcher(msg);
			if (m.find())
			{
				String player = m.group(1);
				Long value = (Long) f.stringToValue(m.group(3) + " coins");
				queuePending(PendingValue.Type.PVP, isClan ? "Clan" : "Friends", msg, value, player);
				return;
			}
		}

		// Try parse player !add value
		//TODO fix negative numbers
		if (config.detectPlayerValues())
		{
			// Pattern to match a single value with k, m, or b unit only
			String valuePattern = "([0-9][0-9,]*(?:\\.[0-9]+)?)\\s*([kmb])?";

			// Pattern to match one or more values separated by spaces or commas
			java.util.regex.Pattern multiValuePattern = java.util.regex.Pattern
				.compile("(?i)!add\\s+(" + valuePattern + "(\\s*,?\\s*" + valuePattern + ")*)");

			java.util.regex.Matcher multiMatcher = multiValuePattern.matcher(msg);

			if (multiMatcher.find())
			{
				String sender = event.getName();
				String who = sender.replaceAll("<[^>]*>", "");
				String valuesText = multiMatcher.group(1);
				String[] valueStrings = valuesText.split("\\s*,\\s*|\\s+");

				for (String valueString : valueStrings)
				{
					java.util.regex.Matcher singleValueMatcher = java.util.regex.Pattern
						.compile("(?i)(" + valuePattern + ")")
						.matcher(valueString);

					if (singleValueMatcher.find())
					{
						String numberTxt = singleValueMatcher.group(2);
						String unitTxt = singleValueMatcher.group(3);
						if (unitTxt == null)
						{
							unitTxt = config.defaultValueMultiplier().getValue();
						}

						// Combine the number and unit for parsing
						String fullValueText = numberTxt + (unitTxt != null ? unitTxt : "");

						try
						{
							Long value = (Long) f.stringToValue(fullValueText);
							queuePending(PendingValue.Type.ADD, isClan ? "Clan" : "Friends",
								"!add " + fullValueText, value, who);
						}
						catch (ParseException e)
						{
							// Skip invalid values
							log.debug("Failed to parse value: " + fullValueText, e);
						}
					}
				}
			}
		}
	}


	/**
	 * Enqueue a pending value suggestion for user approval.
	 *
	 * @param type            source type (PvM, PvP, player add)
	 * @param source          chat source label
	 * @param msg             original chat message
	 * @param value           numeric value (coins or K)
	 * @param suggestedPlayer prefilled player name when available
	 */
	private void queuePending(PendingValue.Type type, String source, String msg, Long value, String suggestedPlayer)
	{
		if (sessionManager == null)
		{
			return;
		}
		PendingValue pv = PendingValue.of(type, source, msg, value, suggestedPlayer);
		sessionManager.addPendingValue(pv);

		panelManager.refreshAllView();
	}

	private boolean CheckChatJoinLeave(ChatMessage event)
	{

		String plain = Text.removeTags(event.getMessage()).trim();
		String lower = plain.toLowerCase();

		ChatMessageType t = event.getType();
		boolean isSystemish = t == ChatMessageType.GAMEMESSAGE
			|| t == ChatMessageType.CLAN_MESSAGE
			|| t == ChatMessageType.CLAN_CHAT
			|| t == ChatMessageType.CLAN_GUEST_CHAT
			|| t.name().contains("CLAN");

		if (!isSystemish)
		{
			return false;
		}

		//LEAVE/KICK Chat
		if (java.util.regex.Pattern
			.compile("(?i)^\\s*(?:you\\s+(?:have\\s+)?left\\s+(?:the\\s+)?(?:chat-)?channel\\.?|you\\s+(?:are|aren't|are\\s+not)\\s+currently\\s+in\\s+(?:a|the|your)\\s+(?:chat-)?channel\\.?|you\\s+have\\s+been\\s+kicked\\s+from\\s+the\\s+channel\\.?)\\s*$")
			.matcher(plain)
			.find())
		{
			updateChatWarningStatus();
			return true;
		}


		//JOIN Chat
		if (java.util.regex.Pattern
			.compile("(?i)^\\s*now\\s+talking\\s+in\\s+(?:the\\s+)?(?:chat-)?channel\\.?\\s*$")
			.matcher(plain)
			.find())
		{
			updateChatWarningStatus();
			return false;
		}
		return false;
	}


	/**
	 * Recompute overlay purely from member lists (no timers, no message heuristics).
	 */
	public void updateChatWarningStatus()
	{
		if (chatOverlay == null)
		{
			return;
		}

		if (sessionManager.getCurrentSession().isEmpty() || !config.warnNotFC())
		{
			chatOverlay.setVisible(false);
			return;
		}

		log.info("Updating chat overlay status");
		log.info("{}", isFriendsChatOn());

		if (isFriendsChatOn())
		{
			chatOverlay.setVisible(false);
			chatOverlay.setChatchanOn(true);
			return;
		}

		chatOverlay.setVisible(true);
		chatOverlay.setChatchanOn(false);
	}


	/**
	 * Track context (in game) menu openings to add an option to add/remove players from session.
	 * This Triggers when you right click a player in the friends/clan chat.
	 *
	 * @param event menu entry added event
	 */
	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		int componentId = event.getActionParam1();
		int groupId = WidgetUtil.componentToInterface(componentId);

		Session currentSession = null;
		if (sessionManager == null)
		{
			return;
		}
		else
		{
			currentSession = sessionManager.getCurrentSession().orElse(null);
		}
		if (!(groupId == InterfaceID.FRIENDS || groupId == InterfaceID.CHATCHANNEL_CURRENT
			|| componentId == InterfaceID.ClansSidepanel.PLAYERLIST || componentId == InterfaceID.ClansGuestSidepanel.PLAYERLIST))
		{
			return;
		}
		String playername = Text.removeTags(event.getTarget());

		if (currentSession == null)
		{
			String removeFromSession = "Add to known players";

			if (playerManager.isKnownPlayer(playername))
			{
				return;
			}
			// TODO Fix bug: For some reason this event/function triggers twice, so i have to check that the entry doesn't already exist' and i feel like i should not have to check this.
			// This might be a janky mess but idc
			if (Arrays.stream(client.getMenu().getMenuEntries()).anyMatch(e -> e.getOption().equals(removeFromSession)))
			{
				return;
			}

			client.getMenu().createMenuEntry(-1)
				.setOption(removeFromSession)
				.setTarget(event.getTarget())
				.setType(MenuAction.RUNELITE)
				.onClick(e ->
				{
					playerManager.addKnownPlayer(playername);
					panelManager.refreshAllView();
				});
			return;
		}


		if (sessionManager.currentSessionHasPlayer(playername))
		{
			String removeFromSession = "Remove from session";

			// TODO Fix bug: For some reason this event/function triggers twice, so i have to check that the entry doesn't already exist' and i feel like i should not have to check this.
			// This might be a janky mess but idc
			if (Arrays.stream(client.getMenu().getMenuEntries()).anyMatch(e -> e.getOption().equals(removeFromSession)))
			{
				return;
			}

			client.getMenu().createMenuEntry(-1)
				.setOption(removeFromSession)
				.setTarget(event.getTarget())
				.setType(MenuAction.RUNELITE)
				.onClick(e ->
				{
					sessionManager.removePlayerFromSession(playername);
					panelManager.refreshAllView();
				});
			return;
		}

		String removeFromSession = "Add to session";

		// TODO Fix bug: For some reason this event/function triggers twice, so i have to check that the entry doesn't already exist' and i feel like i should not have to check this.
		// This might be a janky mess but idc
		if (Arrays.stream(client.getMenu().getMenuEntries()).anyMatch(e -> e.getOption().equals(removeFromSession)))
		{
			return;
		}

		client.getMenu().createMenuEntry(-1)
			.setOption(removeFromSession)
			.setTarget(event.getTarget())
			.setType(MenuAction.RUNELITE)
			.onClick(e ->
			{
				if (playerManager.isKnownPlayer(playername, true))
				{
					sessionManager.addPlayerToActive(playername);
				}
				panelManager.refreshAllView();
			});
	}


	/**
	 * Local player's cleaned display name ("" if not ready).
	 */
	private String myCleanName()
	{
		Player me = client.getLocalPlayer();
		if (me == null)
		{
			return "";
		}
		return net.runelite.client.util.Text.toJagexName(
			net.runelite.client.util.Text.removeTags(me.getName()));
	}

	/**
	 * True iff the given clan channel currently contains *you*.
	 */
	private boolean channelHasSelf(ClanChannel ch)
	{
		if (ch == null || ch.getMembers() == null)
		{
			return false;
		}
		String me = myCleanName();
		if (me.isEmpty())
		{
			return false;
		}

		for (ClanChannelMember m : ch.getMembers())
		{
			if (m == null)
			{
				continue;
			}
			String n = m.getName();
			if (n == null)
			{
				continue;
			}
			n = net.runelite.client.util.Text.toJagexName(
				net.runelite.client.util.Text.removeTags(n));
			if (me.equalsIgnoreCase(n))
			{
				return true;
			}
		}
		return false;
	}

	/**
	 * Joined to main / guest chat-channel (based solely on your presence).
	 */
	private boolean isMainClanChatOn()
	{
		return channelHasSelf(client.getClanChannel());
	}

	private boolean isGuestClanChatOn()
	{
		return channelHasSelf(client.getGuestClanChannel());
	}

	/**
	 * Joined to Friends Chat ("Chat Channel")?
	 */
	private boolean isFriendsChatOn()
	{
		return client.getFriendsChatManager() != null;
	}
}

package com.splitmanager;

import com.google.gson.Gson;
import com.splitmanager.models.Kill;
import com.splitmanager.models.PendingValue;
import com.splitmanager.models.PlayerMetrics;
import com.splitmanager.models.Session;
import com.splitmanager.utils.InstantTypeAdapter;
import com.splitmanager.views.PanelView;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.JOptionPane;
import lombok.Getter;

/**
 * Manages sessions, persistence, and all the logic for roster changes,
 * child sessions, and live split calculations.
 */
@Singleton
public class ManagerSession
{
	private final Gson gson;
	private final Map<String, Session> sessions = new LinkedHashMap<>();
	private final List<PendingValue> pendingValues = new ArrayList<>();
	private final ManagerKnownPlayers playerManager;
	private final PluginConfig config;
	// Cache of all kills grouped by mother session id to avoid recomputing on every UI refresh
	private final Map<String, List<Kill>> motherKillsCache = new LinkedHashMap<>();
	private String currentSessionId;
	private ManagerPlugin pluginManager;
	// TODO implement in newer versions
	@Getter
	private boolean historyLoaded;

	/**
	 * Construct a new ManagerSession bound to the given PluginConfig.
	 * This instance owns all in-memory session state and persists it via the config.
	 *
	 * @param config backing configuration/store used to load and save state
	 */
	@Inject
	public ManagerSession(PluginConfig config, ManagerKnownPlayers playerManager, ManagerPlugin pluginManager, Gson gson)
	{
		this.config = config;
		this.playerManager = playerManager;
		// Use injected client's Gson, customize via newBuilder per guidelines
		this.gson = gson.newBuilder()
			.registerTypeAdapter(Instant.class, new InstantTypeAdapter())
			.create();
		this.pluginManager = pluginManager;
	}

	/**
	 * Utility: convert null to empty string for config storage.
	 */
	private static String nullToEmpty(String s)
	{
		return s == null ? "" : s;
	}

	/**
	 * Utility: convert empty string to null when reading config values.
	 */
	private static String emptyToNull(String s)
	{
		return s == null || s.isEmpty() ? null : s;
	}

	// TODO add export all/ or specific session to json

	/**
	 * Loads configuration data into the application's runtime structures.
	 * <p>
	 * This method performs the following operations:
	 * <p>
	 * 1. Clears the list of known players and repopulates it from a CSV string
	 * retrieved from the configuration. Each player is trimmed of extraneous
	 * whitespace before being added to the collection.
	 * <p>
	 * 2. Clears the mapping of alternate accounts to main accounts and repopulates
	 * it from a JSON structure retrieved from the configuration. The JSON is
	 * parsed into a Map using GSON. If the parsing fails or the structure is
	 * invalid, the operation is gracefully ignored.
	 * <p>
	 * 3. Clears the session map and populates it with sessions retrieved from a
	 * JSON array in the configuration. Each session is parsed and added to
	 * the map by its ID.
	 * <p>
	 * 4. Updates the current session ID and sets whether the history has been
	 * loaded from the configuration.
	 */
	public void loadFromConfig()
	{
		sessions.clear();
		String json = config.sessionsJson();
		if (json != null && !json.isEmpty())
		{
			Session[] arr = gson.fromJson(json, Session[].class);
			if (arr != null)
			{
				for (Session s : arr)
				{
					sessions.put(s.getId(), s);
				}
			}
		}

		// Invalidate any cached mother->kills when loading fresh data
		motherKillsCache.clear();

		currentSessionId = emptyToNull(config.currentSessionId());
	}

	/**
	 * Persist sessions, current state, known players, and alt mappings to PluginConfig.
	 */
	public void saveToConfig()
	{
		Session[] arr = sessions.values().toArray(new Session[0]);
		config.sessionsJson(gson.toJson(arr));
		config.currentSessionId(nullToEmpty(currentSessionId));
	}

	/**
	 * Placeholder for exporting all sessions as JSON (for sharing/backups).
	 * Returns a JSON string. Implementation can reuse the existing gson and sessions map.
	 */
	public String exportAllSessionsJson()
	{
		// TODO Implement: return gson.toJson(sessions.values());
		return "";
	}

	/**
	 * Placeholder for exporting a single session by id as JSON.
	 * Returns a JSON string for the specified session or empty string if not found.
	 */
	public String exportSessionJson(String sessionId)
	{
		// TODO Implement: Session s = sessions.get(sessionId); return s != null ? gson.toJson(s) : "";
		return "";
	}

	/**
	 * @return unmodifiable set of all known player names (mains and alts).
	 */
	public Set<String> getKnownPlayers()
	{
		return Collections.unmodifiableSet(playerManager.getKnownMains());
	}

	/**
	 * Compute known main players not currently active in the session roster.
	 *
	 * @return set of eligible names to add to the current session
	 */
	public Set<String> getNonActivePlayers()
	{
		Session curr = getCurrentSession().orElse(null);
		java.util.Set<String> mains = playerManager.getKnownMains();

		if (curr == null || !curr.isActive())
		{
			return java.util.Collections.unmodifiableSet(mains);
		}

		return mains.stream()
			.filter(p -> !curr.getPlayers().contains(p))
			.collect(Collectors.toCollection(LinkedHashSet::new));
	}

	/**
	 * @return Optional of the currently active child session, if any. Empty if no session is active.
	 */
	public Optional<Session> getCurrentSession()
	{
		return Optional.ofNullable(currentSessionId).map(sessions::get);
	}

	/**
	 * @return all sessions (mother and children) sorted by start time descending (newest first).
	 */
	public List<Session> getAllSessionsNewestFirst()
	{
		return sessions.values().stream()
			.sorted(Comparator.comparing(Session::getStart).reversed())
			.collect(Collectors.toList());
	}

	/**
	 * Exit read-only history mode and return to live mode.
	 * Persists the flag immediately.
	 */
	public void unloadHistory()
	{
		historyLoaded = false;
		saveToConfig();
	}

	/**
	 * Enter read-only history mode by selecting a session to view.
	 * Requires that no active session is running. Persists the flag immediately.
	 *
	 * @param sessionId id of the session (mother or child) to load
	 * @return the loaded session if found and preconditions met; empty otherwise
	 */
	public Optional<Session> loadHistory(String sessionId)
	{
		if (hasActiveSession())
		{
			return Optional.empty(); // must stop active first
		}
		Session s = sessions.get(sessionId);
		if (s == null)
		{
			return Optional.empty();
		}
		historyLoaded = true;
		saveToConfig();
		return Optional.of(s);
	}

	/**
	 * @return true if there is a current child session and its end time is null (active).
	 */
	public boolean hasActiveSession()
	{
		return getCurrentSession().map(Session::isActive).orElse(false);
	}

	/**
	 * Start a new session thread consisting of a mother session and an initial active child.
	 * Fails if history mode is on or another session is currently active.
	 *
	 * @return the newly created active child session, if started
	 */
	public Optional<Session> startSession()
	{
		if (historyLoaded)
		{
			return Optional.empty();
		}
		if (hasActiveSession())
		{
			return Optional.empty();
		}

		// Create mother and an initial child immediately (to mirror sheet)
		Session mother = new Session(newId(), Instant.now(), null);
		sessions.put(mother.getId(), mother);
		// initialize empty cache list for this mother thread
		motherKillsCache.put(mother.getId(), new ArrayList<>());

		Session child = new Session(newId(), Instant.now(), mother.getId());
		sessions.put(child.getId(), child);

		currentSessionId = child.getId();
		saveToConfig();
		pluginManager.updateChatWarningStatus();
		return Optional.of(child);
	}

	/**
	 * Stop the currently active child session. If its mother session is still active,
	 * it will be ended as well. No-op in history mode.
	 *
	 * @return true if an active session was stopped
	 */
	public boolean stopSession(PanelView view)
	{
		if (historyLoaded)
		{
			return false;
		}

		Session curr = getCurrentSession().orElse(null);
		if (curr == null || !curr.isActive())
		{
			return false;
		}

		if (
			JOptionPane.showConfirmDialog(view,
				"Are you sure you want to stop the session")
				!= 0
		)
		{
			return false;
		}

		curr.setEnd(Instant.now());

		// If child has a mother which is active, end mother too.
		if (curr.getMotherId() != null)
		{
			Session mother = sessions.get(curr.getMotherId());
			if (mother != null && mother.isActive())
			{
				mother.setEnd(Instant.now());
			}
		}

		currentSessionId = null;
		saveToConfig();
		pluginManager.updateChatWarningStatus();
		return true;
	}

	/**
	 * Add a player to the currently active child session. If the child already has kills recorded,
	 * a new child session is forked (same mother), roster is copied, the player is added, and the
	 * previous child is ended to preserve historical rosters per split segment.
	 * Alt names are resolved to main before checks. No-op in history mode.
	 *
	 * @param player display name (main or alt)
	 * @return true if the roster changed (player added)
	 */
	public boolean addPlayerToActive(String player)
	{
		if (historyLoaded)
		{
			return false; // TODO support his
		}
		Session curr = getCurrentSession().orElse(null);
		if (curr == null || !curr.isActive())
		{
			return false;
		}

		String mainPlayer = playerManager.getMainName(player == null ? null : player.trim());
		if (mainPlayer == null || mainPlayer.isBlank())
		{
			return false;
		}
		final String fMain = mainPlayer;
		if (curr.getPlayers().stream().anyMatch(p -> p.equalsIgnoreCase(fMain)))
		{
			// Player (main) already in session
			return false;
		}

		if (curr.hasKills())
		{
			// Create a new child session, copy players, add this player, end current child
			String motherId = curr.getMotherId() == null ? curr.getId() : curr.getMotherId();
			Session newChild = new Session(newId(), Instant.now(), motherId);
			// copy players
			newChild.getPlayers().addAll(curr.getPlayers());
			// add the new player (main)
			newChild.getPlayers().add(player);

			// End current child (but keep kills)
			curr.setEnd(Instant.now());

			// Activate new child
			sessions.put(newChild.getId(), newChild);
			currentSessionId = newChild.getId();
		}
		else
		{
			curr.getPlayers().add(player);
		}
		saveToConfig();
		return true;
	}

	/**
	 * Remove a player from the active child session. If the current child already has kills,
	 * a new child is created (same mother) without this player, and the current child is ended
	 * to keep per-segment rosters intact. No-op in history mode.
	 *
	 * @param player display name (main or alt)
	 * @return true if the roster changed (player removed)
	 */
	public boolean removePlayerFromSession(String player)
	{
		if (historyLoaded)
		{
			return false;
		}
		Session curr = getCurrentSession().orElse(null);
		if (curr == null || !curr.isActive())
		{
			return false;
		}

		player = player.trim();
		if (!curr.getPlayers().contains(player))
		{
			return false;
		}

		if (curr.hasKills())
		{
			// Create a new child without this player, end current child
			String motherId = curr.getMotherId() == null ? curr.getId() : curr.getMotherId();
			Session newChild = new Session(newId(), Instant.now(), motherId);
			String finalPlayer = player;
			newChild.getPlayers().addAll(
				curr.getPlayers().stream().filter(p -> !p.equalsIgnoreCase(finalPlayer)).collect(Collectors.toList())
			);

			curr.setEnd(Instant.now());
			sessions.put(newChild.getId(), newChild);
			currentSessionId = newChild.getId();
		}
		else
		{
			curr.getPlayers().remove(player);
		}
		saveToConfig();
		return true;
	}

	/**
	 * Record a kill value for a player in the active session. The player is resolved to its main
	 * and must be on the active roster. No-op in history mode.
	 *
	 * @param player display name (main or alt)
	 * @param amount value in coins (may be negative if allowed by config)
	 * @return true if recorded
	 */
	public boolean addKill(@Nonnull String player, @Nonnull Long amount)
	{
		if (historyLoaded)
		{
			return false; //TODO support altering history
		}

		Session currentSession = getCurrentSession().orElse(null);
		if (currentSession == null || !currentSession.isActive())
		{
			return false;
		}

		String mainPlayer = playerManager.getMainName(player.trim());
		if (mainPlayer == null || mainPlayer.isBlank())
		{
			return false;
		}
		if (currentSession.getPlayers().stream().noneMatch(p -> p.equalsIgnoreCase(mainPlayer)))
		{
			return false;
		}

		Kill newKill = new Kill(currentSession.getId(), mainPlayer, amount, Instant.now());
		currentSession.getKills().add(newKill);

		// Update mother cache incrementally
		String motherId = currentSession.getMotherId() == null ? currentSession.getId() : currentSession.getMotherId();
		motherKillsCache.computeIfAbsent(motherId, k -> new ArrayList<>()).add(newKill);

		saveToConfig();
		return true;
	}

	/**
	 * Read-only view of the queued pending values detected from chat.
	 */
	public List<PendingValue> getPendingValues()
	{
		return Collections.unmodifiableList(pendingValues);
	}

	/**
	 * Queue a new pending value. The suggested player is normalized to its main. If configured,
	 * the value may be auto-applied (when the player is currently in session), in which case this
	 * method records a kill and does not queue. A small cap prevents unbounded growth.
	 *
	 * @param pendingValue pending value payload; null is ignored
	 */
	public void addPendingValue(@Nonnull PendingValue pendingValue)
	{
		// Normalize suggestedPlayer player to main for all downstream uses
		String suggestedPlayer = pendingValue.getSuggestedPlayer();
		String resolvedPlayer = playerManager.getMainName(suggestedPlayer);

		pendingValue.setSuggestedPlayer(resolvedPlayer);

		if (!playerManager.getKnownPlayers().contains(resolvedPlayer))
		{
			playerManager.getKnownPlayers().add(resolvedPlayer);
			saveToConfig();
		}

		// Auto-apply if configured and player already in session
		if (config.autoApplyWhenInSession() && hasActiveSession())
		{
			Session currentSession = getCurrentSession().orElse(null);
			if (currentSession != null && currentSession.getPlayers().stream().anyMatch(p -> p.equalsIgnoreCase(resolvedPlayer)))
			{
				addKill(resolvedPlayer, pendingValue.getValue());
				return; // do not queue
			}
		}

		// Limit size to avoid unbounded growth
		if (pendingValues.size() > 100)
		{
			pendingValues.remove(0);
		}
		pendingValues.add(pendingValue);
	}

	/**
	 * Remove a pending value by its id.
	 *
	 * @param id unique pending id
	 * @return true if removed
	 */
	public boolean removePendingValueById(String id)
	{
		return pendingValues.removeIf(p -> p.getId().equals(id));
	}

	/**
	 * Apply a pending value to a specific player and remove it from the queue.
	 * The player is resolved to its main; the underlying addKill() enforces roster rules.
	 *
	 * @param id     pending id
	 * @param player target player (main or alt)
	 * @return true if applied
	 */
	public boolean applyPendingValueToPlayer(String id, String player)
	{
		PendingValue pv = pendingValues.stream().filter(p -> p.getId().equals(id)).findFirst().orElse(null);
		if (pv == null)
		{
			return false;
		}
		String target = playerManager.getMainName(player);
		boolean ok = addKill(target, pv.getValue());
		if (ok)
		{
			pendingValues.remove(pv);
		}
		return ok;
	}

	/**
	 * Returns true if the given player (main or alt) is present in the roster of the current session.
	 * Alts are resolved to their main before the check.
	 */
	public boolean currentSessionHasPlayer(@Nonnull String player)
	{
		return sessionHasPlayer(player, getCurrentSession().orElse(null));
	}

	/**
	 * Returns true if the given player (main or alt) is present in the roster of the provided session.
	 * Alts are resolved to their main before the check.
	 */
	public boolean sessionHasPlayer(@Nonnull String player, Session session)
	{
		if (playerManager.isAlt(player))
		{
			player = playerManager.getMainName(player);
		}

		String finalPlayer = player;

		return session.getPlayers().stream().anyMatch(e ->
			e.equals(Objects.requireNonNull(finalPlayer)));
	}

	public void init()
	{
		loadFromConfig();
	}

	//TODO make this not recalc everything if it does

	/**
	 * Compute metrics for the given session's thread (mother + children) including only currently active players.
	 *
	 * @param s a session within the thread to compute against
	 * @return list of PlayerMetrics rows (non-zero totals only)
	 */
	public List<PlayerMetrics> computeMetricsFor(Session s)
	{
		return computeMetricsFor(s, false);
	}

	/**
	 * Compute metrics for the given session's thread (mother + children).
	 * When includeNonActivePlayers is true, any player appearing in the thread or known list may be included.
	 * Otherwise, only players on the provided session's current roster are considered for output.
	 * Players with zero total and zero split are omitted.
	 *
	 * @param s                       a session within the thread to compute against
	 * @param includeNonActivePlayers whether to include players outside the current roster
	 * @return list of PlayerMetrics rows
	 */
	public List<PlayerMetrics> computeMetricsFor(Session s, boolean includeNonActivePlayers)
	{
		if (s == null)
		{
			return List.of();
		}

		// Determine the mother (root) id for the session thread
		String rootId = (s.getMotherId() == null) ? s.getId() : s.getMotherId();

		// Collect all sessions in the thread: mother + all children
		List<Session> thread = new ArrayList<>();
		Session mother = sessions.get(rootId);
		if (mother != null)
		{
			thread.add(mother);
		}
		for (Session candidate : sessions.values())
		{
			if (rootId.equals(candidate.getMotherId()))
			{
				thread.add(candidate);
			}
		}

		// Build included players:
		// - includeNonActivePlayers: union of knownPlayers and everyone who appeared in the thread
		// - otherwise: only the current session's active roster
		LinkedHashSet<String> includedPlayers = new LinkedHashSet<>();
		if (includeNonActivePlayers)
		{
			includedPlayers.addAll(playerManager.getKnownPlayers());
			for (Session part : thread)
			{
				includedPlayers.addAll(part.getPlayers());
			}
		}
		else
		{
			includedPlayers.addAll(s.getPlayers());
		}

		// Initialize aggregate totals and splits
		Map<String, Long> totals = new LinkedHashMap<>();
		Map<String, Long> splits = new LinkedHashMap<>();
		for (String p : includedPlayers)
		{
			totals.put(p, 0L);
			splits.put(p, 0L);
		}

		// For each session in the thread:
		// - compute that session's per-player totals for its own roster
		// - compute that session's average across its roster (including zeroes)
		// - for players active in that session, accumulate (playerTotal - sessionAvg) into splits
		for (Session part : thread)
		{
			// Roster for this part (the only players eligible for this part's split)
			List<String> roster = new ArrayList<>(part.getPlayers());
			if (roster.isEmpty())
			{
				continue;
			}

			// Per-session totals for players in this roster
			Map<String, Long> perSessionTotals = new LinkedHashMap<>();
			for (String p : roster)
			{
				perSessionTotals.put(p, 0L);
			}
			for (Kill k : part.getKills())
			{
				perSessionTotals.computeIfPresent(k.getPlayer(), (k1, v) -> v + k.getAmount());
			}

			// Session average across the entire roster
			Long sessionAvg = 0L;
			if (!perSessionTotals.isEmpty())
			{
				Long sum = 0L;
				for (Long v : perSessionTotals.values())
				{
					sum += v;
				}
				sessionAvg = sum / perSessionTotals.size();
			}

			// Accumulate totals and splits into the aggregate maps
			for (Map.Entry<String, Long> e : perSessionTotals.entrySet())
			{
				String player = e.getKey();
				Long playerTotalThisSession = e.getValue();

				// Aggregate total (only if we're showing this player)
				if (totals.containsKey(player))
				{
					totals.compute(player, (k, v) -> (v) + playerTotalThisSession);
				}

				// Aggregate split only for players active in THIS session
				if (splits.containsKey(player))
				{
					Long delta = playerTotalThisSession - sessionAvg;
					splits.compute(player, (k, v) -> (v) + delta);
				}
			}
		}

		// Build output rows, marking active based on the provided session's current roster
		List<PlayerMetrics> out = new ArrayList<>();
		for (String p : includedPlayers)
		{
			boolean isActiveNow = s.getPlayers().contains(p);
			Long total = totals.getOrDefault(p, 0L);
			Long split = splits.getOrDefault(p, 0L);

			// Skip players with total = 0
			if (total == 0.0 && split == 0.0)
			{
				continue;
			}

			out.add(new PlayerMetrics(p, total, split, isActiveNow));
		}
		return out;
	}


	/**
	 * Get all kills from all sessions that share the same mother session as the current session.
	 * Uses a cached list per mother to avoid recomputing on every UI update.
	 *
	 * @return a list containing all kill records from sessions with the same mother
	 */
	public List<Kill> getAllKills()
	{
		Session curr = getCurrentSession().orElse(null);
		if (curr == null)
		{
			return new ArrayList<>();
		}
		// Determine the mother id for this thread
		String motherId = (curr.getMotherId() == null) ? curr.getId() : curr.getMotherId();
		// If cached, return it
		List<Kill> cached = motherKillsCache.get(motherId);
		if (cached != null)
		{
			return Collections.unmodifiableList(cached);
		}
		// Build once, sort by time ascending (oldest first), and cache
		List<Kill> built = new ArrayList<>();
		for (Session session : sessions.values())
		{
			if (motherId.equals(session.getId()) || motherId.equals(session.getMotherId()))
			{
				built.addAll(session.getKills());
			}
		}
		built.sort(Comparator.comparing(Kill::getAt, Comparator.nullsLast(Comparator.naturalOrder())));
		motherKillsCache.put(motherId, built);
		return built;
	}


	/**
	 * Generate a random unique id for sessions.
	 */
	private String newId()
	{
		return UUID.randomUUID().toString();
	}


}

package com.splitmanager.models;

import java.io.Serializable;
import java.time.Instant;
import lombok.Getter;
import lombok.Setter;

/**
 * A single kill record attributed to a player for a given session.
 */
@Getter
@Setter
public class Kill implements Serializable
{
	private final String sessionId;
	private final Instant at;
	private String player;
	private Long amount;

	public Kill(String sessionId, String player, Long amount, Instant at)
	{
		this.sessionId = sessionId;
		this.player = player;
		this.amount = amount;
		this.at = at;
	}
}

package com.splitmanager.models;

import com.splitmanager.utils.Formats;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;
import javax.swing.table.AbstractTableModel;

public final class Metrics extends AbstractTableModel
{
	private List<PlayerMetrics> rows = List.of();
	private boolean hideTotalColumn = false;

	public void setHideTotalColumn(boolean hide)
	{
		if (this.hideTotalColumn != hide)
		{
			this.hideTotalColumn = hide;
			fireTableStructureChanged();
		}
	}

	public boolean isHidingTotalColumn()
	{
		return hideTotalColumn;
	}

	public void setData(List<PlayerMetrics> rows)
	{
		// Sort: active first, inactive at bottom; stable within groups
		this.rows = rows.stream()
			.sorted(Comparator.comparingInt(pm -> pm.activePlayer ? 0 : 1)) // active=true â†’ 0, inactive=false â†’ 1
			.collect(Collectors.toList());
		fireTableDataChanged();
	}

	// Helper for renderers/editors to know if a row is active
	public boolean isRowActive(int rowIndex)
	{
		if (rowIndex < 0 || rowIndex >= rows.size())
		{
			return false;
		}
		return rows.get(rowIndex).activePlayer;
	}

	@Override
	public int getRowCount()
	{
		return rows.size();
	}

	@Override
	public int getColumnCount()
	{
		return hideTotalColumn ? 3 : 4;
	}

	@Override
	public Object getValueAt(int rowIndex, int columnIndex)
	{
		var r = rows.get(rowIndex);
		if (!hideTotalColumn)
		{
			switch (columnIndex)
			{
				case 0:
					return r.player;
				case 1:
					return Formats.OsrsAmountFormatter.toSuffixString(r.total, 'k');
				case 2:
					return Formats.OsrsAmountFormatter.toSuffixString(r.split, 'k');
				case 3:
					// Show X for active players, sleeping emoji for non-active
					return r.activePlayer ? "X" : "ðŸ’¤";
				default:
					return "";
			}
		}
		else
		{
			switch (columnIndex)
			{
				case 0:
					return r.player;
				case 1:
					return Formats.OsrsAmountFormatter.toSuffixString(r.split, 'k');
				case 2:
					return r.activePlayer ? "X" : "ðŸ’¤";
				default:
					return "";
			}
		}
	}

	@Override
	public String getColumnName(int column)
	{
		if (!hideTotalColumn)
		{
			switch (column)
			{
				case 0:
					return "Player";
				case 1:
					return "Total";
				case 2:
					return "Split";
				case 3:
					return "X";
				default:
					return "";
			}
		}
		else
		{
			switch (column)
			{
				case 0:
					return "Player";
				case 1:
					return "Split";
				case 2:
					return "X";
				default:
					return "";
			}
		}
	}

	@Override
	public Class<?> getColumnClass(int columnIndex)
	{
		// Use Object so we can render either a JButton (active) or a JLabel (inactive) in action col
		return Object.class;
	}

	@Override
	public boolean isCellEditable(int rowIndex, int columnIndex)
	{
		// Only the action column is potentially editable, and only for active players
		int actionCol = hideTotalColumn ? 2 : 3;
		return columnIndex == actionCol && isRowActive(rowIndex);
	}

	// Accessor for renderers: raw split value for row
	public long getRawSplitAt(int rowIndex)
	{
		if (rowIndex < 0 || rowIndex >= rows.size())
		{
			return 0L;
		}
		return rows.get(rowIndex).split;
	}
}
package com.splitmanager.models;

import java.time.Instant;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PendingValue
{
	private String id;
	private Type type;
	private String source; // e.g., Clan, Friends
	private String message; // original or summary
	private Long value;
	private String suggestedPlayer; // may be null
	private Instant detectedAt;

	public static PendingValue of(Type type, String source, String message, Long value, String suggestedPlayer)
	{
		return new PendingValue(UUID.randomUUID().toString(), type, source, message, value, suggestedPlayer, Instant.now());
	}

	public enum Type
	{PVM, PVP, ADD}
}

package com.splitmanager.models;

/**
 * Aggregate row to display per-player totals and split deltas for a session thread.
 * total = sum of that player's kills across all sessions in the thread.
 * split = sum over each session in the thread of (playerTotalInThatSession - avgOfThatSessionRoster).
 * activePlayer indicates whether the player is on the provided session's current roster.
 */
public class PlayerMetrics
{
	public final String player;
	public final Long total;
	public final Long split;
	public final boolean activePlayer;

	public PlayerMetrics(String player, Long total, Long split, boolean activePlayer)
	{
		this.player = player;
		this.total = total;
		this.split = split;
		this.activePlayer = activePlayer;
	}
}

package com.splitmanager.models;


import com.splitmanager.PluginConfig;
import com.splitmanager.utils.Formats;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public final class RecentSplitsTable extends javax.swing.table.AbstractTableModel
{
	private static final String[] COLS = {"Time", "Player", "Amount"};
	private static final java.time.format.DateTimeFormatter TIME_FMT =
		java.time.format.DateTimeFormatter
			.ofLocalizedTime(java.time.format.FormatStyle.SHORT)
			.withLocale(java.util.Locale.getDefault());
	private static final java.time.ZoneId SYS_TZ = java.time.ZoneId.systemDefault();
	private final java.util.List<Row> rows = new java.util.ArrayList<>(10);
	private final PluginConfig config;
	@Setter
	private Listener listener;

	public RecentSplitsTable(PluginConfig config)
	{
		this.config = config;
	}

	@Override
	public int getRowCount()
	{
		return rows.size();
	}

	@Override
	public int getColumnCount()
	{
		return 3;
	}

	@Override
	public Object getValueAt(int rowIndex, int columnIndex)
	{
		Row e = rows.get(rowIndex);
		switch (columnIndex)
		{
			case 0:
				return e.time;
			case 1:
				return e.kill.getPlayer();
			case 2:
				return Formats.OsrsAmountFormatter.toSuffixString(e.kill.getAmount(), 'k');
			default:
				return "";
		}
	}

	@Override
	public String getColumnName(int column)
	{
		return COLS[column];
	}

	@Override
	public Class<?> getColumnClass(int columnIndex)
	{
		return String.class;
	}

	@Override
	public boolean isCellEditable(int rowIndex, int columnIndex)
	{
		return columnIndex == 1 || columnIndex == 2; // player, amount
	}

	@Override
	public void setValueAt(Object aValue, int rowIndex, int columnIndex)
	{
		if (rowIndex < 0 || rowIndex >= rows.size())
		{
			return;
		}
		Row e = rows.get(rowIndex);
		if (columnIndex == 1) // player
		{
			String v = aValue == null ? null : aValue.toString();
			if (v != null && !v.isBlank())
			{
				e.kill.setPlayer(v.trim());
			}
		}
		else if (columnIndex == 2) // amount (K)
		{
			try
			{
				Long k = Formats.OsrsAmountFormatter.stringAmountToLongAmount((String) aValue, config);
				e.kill.setAmount(k);
			}
			catch (Exception ignored)
			{
				log.warn("Invalid amount: {}", aValue);
			}
		}
		fireTableRowsUpdated(rowIndex, rowIndex);
		if (listener != null)
		{
			listener.onEdited(e.kill); // pass the edited kill so we know its sessionId
		}
	}

	// Optionally expose a getter to let editors query the kill of a row:
	public Kill getKillAt(int rowIndex)
	{
		return (rowIndex >= 0 && rowIndex < rows.size()) ? rows.get(rowIndex).kill : null;
	}

	private void addEntry(Kill k)
	{
		String timeStr = "";
		if (k.getAt() != null)
		{
			timeStr = TIME_FMT.format(java.time.ZonedDateTime.ofInstant(k.getAt(), SYS_TZ));
		}
		// newest on top (insert at index 0)
		rows.add(0, new Row(k, timeStr));
		fireTableDataChanged();
	}

	public void setFromKills(java.util.List<Kill> kills)
	{
		clear();
		if (kills == null || kills.isEmpty())
		{
			fireTableDataChanged();
			return;
		}
		int n = kills.size();
		// Iterate from oldest to newest
		for (int i = 0; i < n; i++)
		{
			Kill k = kills.get(i);
			addEntry(k);
		}
		fireTableDataChanged();
	}

	public void clear()
	{
		rows.clear();
		fireTableDataChanged();
	}

	public interface Listener
	{
		void onEdited(Kill editedKill);
	}

	private static final class Row
	{
		final Kill kill; // keep reference for editing
		final String time;

		Row(Kill kill, String time)
		{
			this.kill = kill;
			this.time = time;
		}
	}
}

package com.splitmanager.models;

import java.io.Serializable;
import java.time.Instant;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import lombok.Getter;
import lombok.Setter;

/**
 * Immutable-ish data model representing a single segment of a session thread.
 * <p>
 * How sessions are tracked overall
 * - The plugin tracks "threads" of activity consisting of a root (mother) session and
 * zero or more child sessions. A new child is created whenever the roster changes AFTER
 * at least one kill has been recorded, preserving historical rosters for split math.
 * - The root (mother) session has motherId = null and represents the thread start. The first
 * active child is created immediately when a thread starts so that kills and roster are
 * always associated with a child segment. All subsequent children reference the same motherId.
 * - ManagerSession owns a Map<String, Session> of all sessions and switches the current active
 * child by storing its id. ManagerSession also forks new children on roster changes and
 * appends kills to the active child.
 * <p>
 * What each Session holds
 * - id: unique identifier (UUID string) used as the key in ManagerSession's map and persisted.
 * - start/end: timestamps for this segment; end == null indicates the segment is currently active.
 * - motherId: null for the mother/root; otherwise the id of the mother that all children share.
 * - players: the roster for this segment (names are stored as mains; alts resolved earlier).
 * - kills: ordered list of Kill records attributed during this segment.
 * <p>
 * Lifecycle notes
 * - A thread starts by creating a mother + an initial child (active). Kills are written to the
 * active child only. If a roster mutation happens and the current child already has kills,
 * ManagerSession ends the current child and creates a new child with a copied roster and the
 * mutation applied. If there are no kills yet, the roster is edited in-place on the current child.
 * - Stopping a thread ends the active child, and if the mother is still open, it is ended too.
 * <p>
 * Persistence/serialization
 * - This model is Gson-serializable; ManagerSession persists an array of Session objects in the
 * PluginConfig as JSON. Instant fields are serialized via a custom adapter.
 */
@Getter
public class Session implements Serializable
{
	/**
	 * Unique identifier for this segment (UUID string). Used as the key in persistence and lookup.
	 */
	private final String id;

	/**
	 * Wall-clock time when this segment became active (creation time for children; thread start for mother).
	 */
	private final Instant start;
	/**
	 * Id of the mother (root) session. Null means this instance is the mother/root of the thread.
	 */
	private final String motherId; // null for mother; otherwise id of mother
	/**
	 * Roster (set) of players for this segment. Order is insertion order as displayed in UI.
	 * Names are expected to be mains; alt->main resolution happens before mutation.
	 */
	private final Set<String> players = new LinkedHashSet<>();
	/**
	 * Kills recorded during this segment, in insertion order.
	 */
	private final List<Kill> kills = new ArrayList<>();
	/**
	 * When non-null, marks the time this segment was closed. Null implies the segment is active.
	 */
	@Setter
	private Instant end; // null when active

	/**
	 * Create a new Session segment.
	 *
	 * @param id       unique identifier (UUID string)
	 * @param start    segment start time
	 * @param motherId null for mother/root; otherwise id of the mother this child belongs to
	 */
	public Session(String id, Instant start, String motherId)
	{
		this.id = id;
		this.start = start;
		this.motherId = motherId;
	}

	/**
	 * @return true when this segment is currently active (end == null).
	 */
	public boolean isActive()
	{
		return end == null;
	}

	/**
	 * @return true if at least one kill has been recorded in this segment.
	 */
	public boolean hasKills()
	{
		return !kills.isEmpty();
	}
}

package com.splitmanager.models;

import lombok.Getter;
import lombok.Setter;

/**
 * Simple immutable container describing a suggested transfer between two players.
 */
@Getter
@Setter
public final class Transfer
{
	/**
	 * Player paying or sending value.
	 */
	final String from;
	/**
	 * Player receiving value.
	 */
	final String to;
	/**
	 * Amount in coins (or the configured split unit).
	 */
	final long amount;

	/**
	 * Create a new suggested transfer record.
	 *
	 * @param from   player paying/sending
	 * @param to     player receiving
	 * @param amount amount in coins
	 */
	public Transfer(String from, String to, long amount)
	{
		this.from = from;
		this.to = to;
		this.amount = amount;
	}
}

package com.splitmanager.models;

import static com.splitmanager.utils.Formats.OsrsAmountFormatter.toSuffixString;
import java.util.ArrayList;
import java.util.List;
import javax.swing.table.AbstractTableModel;

public class WaitlistTable extends AbstractTableModel
{
	private final String[] cols = {"Type", "Value", "Player"};
	private final List<PendingValue> rows = new ArrayList<>();

	public void setData(List<PendingValue> pending)
	{
		rows.clear();
		if (pending != null)
		{
			rows.addAll(pending);
		}
		fireTableDataChanged();
	}

	public PendingValue getRow(int idx)
	{
		if (idx < 0 || idx >= rows.size())
		{
			return null;
		}
		return rows.get(idx);
	}

	@Override
	public int getRowCount()
	{
		return rows.size();
	}

	@Override
	public int getColumnCount()
	{
		return cols.length;
	}

	@Override
	public Object getValueAt(int rowIndex, int columnIndex)
	{
		PendingValue pv = rows.get(rowIndex);
		switch (columnIndex)
		{
			case 0:
				return pv.getType().name();
			case 1:
				long value = pv.getValue();
				//TODO get this from config
				return toSuffixString(value, "k");
			case 2:
				return pv.getSuggestedPlayer() == null ? "" : pv.getSuggestedPlayer();
		}
		return null;
	}

	@Override
	public String getColumnName(int column)
	{
		return cols[column];
	}

	@Override
	public Class<?> getColumnClass(int columnIndex)
	{
		switch (columnIndex)
		{
			case 0:
			case 2:
				return String.class;
			case 1:
				return String.class; // formatted K string
		}
		return Object.class;
	}

	@Override
	public boolean isCellEditable(int rowIndex, int columnIndex)
	{
		return columnIndex == 2;
	}

	@Override
	public void setValueAt(Object aValue, int rowIndex, int columnIndex)
	{
		if (columnIndex != 2)
		{
			return;
		}
		PendingValue pv = rows.get(rowIndex);
		pv.setSuggestedPlayer(aValue == null ? null : aValue.toString());
	}
}

package com.splitmanager;

import lombok.Getter;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;


/**
 * The PluginConfig interface defines a configuration for the Split Manager plugin.
 * It provides persistent storage of various user and system-defined settings. Additionally, this interface
 * manages settings related to settlement, chat detection, and session handling.
 */
@ConfigGroup(PluginConfig.GROUP)
public interface PluginConfig extends Config
{
	String GROUP = "Split Manager";

	String KEY_SESSIONS_JSON = "sessionsJson";
	String KEY_CURRENT_SESSION_ID = "currentSessionId";
	String KEY_HISTORY_LOADED = "historyLoaded";
	String KEY_PEOPLE_CSV = "PlayersCsv";
	//TODO Create a new configitem that allows the user to submit any forms on enter, e.g. 1) user fills in split amount 2) presses enter 3) The same function as button press is called
	@ConfigSection(
		name = "Settlement",
		description = "Settlement config",
		position = 2
	)
	String settlementSection = "Settlement";
	// Chat detection settings
	@ConfigSection(
		name = "Chat detection",
		description = "Detect and queue values from chat",
		position = 1
	)
	String chatDetectionSection = "Chat detection";
	// Alt/main mapping persistence (hidden JSON)
	String KEY_ALTS_JSON = "altsJson";

	@ConfigItem(
		keyName = "enablePopout",
		name = "Enable popout",
		description = "Show a popout button that enables the user to pop the plugin out into its own window."
	)
	default boolean enablePopout()
	{
		return false;
	}

	@ConfigItem(
		keyName = "defaultValueMultiplier",
		name = "Default value multiplier",
		description = "The default multiplier that is used upon adding split values"
	)
	default ValueMultiplier defaultValueMultiplier()
	{
		return ValueMultiplier.THOUSAND;
	}

	@ConfigItem(
		keyName = "enableTour",
		name = "Enable tour",
		description = "Show a guided step-by-step tutorial panel at the top of the plugin UI"
	)
	default boolean enableTour()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableTour",
		name = "Enable tour",
		description = "Show a guided step-by-step tutorial panel at the top of the plugin UI",
		hidden = true
	)
	void enableTour(boolean value);

	@ConfigItem(
		keyName = "WarnNotInFC",
		name = "Warning not in FC",
		description = "Give a warning on OSRS canvas that you are not in a FC, usefull if you have !add on",
		section = chatDetectionSection
	)
	default boolean warnNotFC()
	{
		return false;
	}

	/**
	 * Retrieves the JSON string representation of serialized sessions.
	 *
	 * @return a JSON string representing the serialized sessions, or an empty string if no sessions are serialized
	 */
	@ConfigItem(
		keyName = KEY_SESSIONS_JSON,
		name = "Sessions JSON",
		description = "Serialized sessions",
		hidden = true
	)
	default String sessionsJson()
	{
		return "";
	}

	/**
	 * Sets the JSON string representation of serialized sessions.
	 *
	 * @param value a JSON string representing the serialized sessions
	 */
	@ConfigItem(
		keyName = KEY_SESSIONS_JSON,
		name = "Sessions JSON",
		description = "Serialized sessions",
		hidden = true
	)
	void sessionsJson(String value);

	/**
	 * Retrieves the identifier of the current active session.
	 *
	 * @return the current session ID as a string, or an empty string if no session is active
	 */
	@ConfigItem(
		keyName = KEY_CURRENT_SESSION_ID,
		name = "Current Session Id",
		description = "Active session id",
		hidden = true
	)
	default String currentSessionId()
	{
		return "";
	}

	/**
	 * Sets the identifier of the current active session.
	 *
	 * @param value the current session ID to set as a string
	 */
	@ConfigItem(
		keyName = KEY_CURRENT_SESSION_ID,
		name = "Current Session Id",
		description = "Active session id",
		hidden = true
	)
	void currentSessionId(String value);

	/**
	 * Retrieves a comma-separated string of known players.
	 *
	 * @return a string containing the known players separated by commas,
	 * or an empty string if no players are defined
	 */
	@ConfigItem(
		keyName = KEY_PEOPLE_CSV,
		name = "Players",
		description = "Comma-separated known players",
		hidden = true
	)
	default String knownPlayersCsv()
	{
		return "";
	}

	/**
	 * Sets a comma-separated string of known players.
	 *
	 * @param value a string containing the known players separated by commas
	 */
	@ConfigItem(
		keyName = KEY_PEOPLE_CSV,
		name = "Players",
		description = "Comma-separated known players",
		hidden = true
	)
	void knownPlayersCsv(String value);

	/**
	 * Determines whether the Markdown table should be wrapped in triple backticks (` ``` `)
	 * and columns padded for monospaced display when copying the table for Discord.
	 *
	 * @return true if the table should be formatted for Discord with Markdown wrapping
	 * and monospaced column padding; false otherwise.
	 */
	// Markdown / copy settings
	@ConfigItem(
		keyName = "copyForDiscord",
		name = "Copy for Discord",
		description = "Wrap copied Markdown table in ``` and pad columns for monospaced display",
		section = settlementSection
	)
	default boolean copyForDiscord()
	{
		return true;
	}

	/**
	 * Determines whether direct payments between players are enabled, bypassing a middleman or bank.
	 * If enabled, the settlement guidance assumes players directly settle payments with one another.
	 * If disabled, a middleman or bank is used for settling payments.
	 *
	 * @return true if direct payments are enabled, false if middleman mode is used.
	 */
	@ConfigItem(
		keyName = "directPayments",
		name = "Direct payments (no middleman)",
		description = "If enabled, settlement guidance assumes players pay each other directly instead of settling via a bank/middleman. Off = middleman mode.",
		section = settlementSection
	)
	default boolean directPayments()
	{
		return false;
	}

	/**
	 * Determines whether chat detection is enabled.
	 * This method checks if values from clan or friends chat should be detected
	 * and queued in a waitlist as specified by the configuration.
	 *
	 * @return true if chat detection is enabled; false otherwise
	 */
	@ConfigItem(
		keyName = "enableChatDetection",
		name = "Enable chat detection",
		description = "Detect values from clan/friends chat and queue them in a waitlist",
		section = chatDetectionSection
	)
	default boolean enableChatDetection()
	{
		return false;
	}

	/**
	 * Determines whether the detection of values should be enabled in the clan chat.
	 *
	 * @return true if detection in the clan chat is enabled, otherwise false.
	 */
	@ConfigItem(
		keyName = "detectInClanChat",
		name = "Detect in Clan Chat",
		description = "Listen for values in clan chat",
		section = chatDetectionSection
	)
	default boolean detectInClanChat()
	{
		return true;
	}

	/**
	 * Determines whether the system should listen for values in the friends chat.
	 *
	 * @return true if listening for values in friends chat is enabled; false otherwise.
	 */
	@ConfigItem(
		keyName = "detectInFriendsChat",
		name = "Detect in Friends Chat",
		description = "Listen for values in friends chat",
		section = chatDetectionSection
	)
	default boolean detectInFriendsChat()
	{
		return true;
	}

	/**
	 * Determines whether the detection of PvM (Player vs Monster) values
	 * from drop messages is enabled. When enabled, values related to
	 * PvM drops are queued for further processing.
	 *
	 * @return true if PvM value detection is enabled, false otherwise
	 */
	@ConfigItem(
		keyName = "detectPvmValues",
		name = "Detect PvM values",
		description = "Queue values detected from PvM drop messages",
		section = chatDetectionSection
	)
	default boolean detectPvmValues()
	{
		return true;
	}

	/**
	 * Determines if the detection of PvP values from loot messages should
	 * be enabled. When enabled, it queues the values detected from PvP
	 * loot messages for further processing.
	 *
	 * @return true if PvP value detection is enabled, false otherwise
	 */
	@ConfigItem(
		keyName = "detectPvpValues",
		name = "Detect PvP values",
		description = "Queue values detected from PvP loot messages",
		section = chatDetectionSection
	)
	default boolean detectPvpValues()
	{
		return true;
	}

	/**
	 * Enables or disables the detection of player values when they send a command
	 * using the format !add {value}.
	 *
	 * @return true if the detection of player values is enabled, false otherwise
	 */
	@ConfigItem(
		keyName = "detectPlayerValues",
		name = "Detect player !add",
		description = "Allow players to queue values by sending !add {value}",
		section = chatDetectionSection
	)
	default boolean detectPlayerValues()
	{
		return true;
	}

	/**
	 * Determines if the system should automatically apply when the suggested player
	 * (or their main account) is already in the active session, bypassing the waitlist.
	 *
	 * @return true if auto-apply is enabled when the player is in session; false otherwise
	 */
	@ConfigItem(
		keyName = "autoApplyWhenInSession",
		name = "Auto-apply when in session",
		description = "Skip waitlist if suggested player (or its main) is already in the active session",
		section = chatDetectionSection
	)
	default boolean autoApplyWhenInSession()
	{
		return false;
	}

	/**
	 * Indicates whether to flip the sign of settlement values for display purposes.
	 * When disabled, a positive value indicates that the bank pays the player.
	 * When enabled, a positive value indicates that the player pays the bank. This setting
	 * applies only in middleman mode and does not affect the actual transaction values.
	 *
	 * @return true if settlement sign flipping is enabled, false otherwise.
	 */
	@ConfigItem(
		keyName = "flipSettlementSign",
		name = "Flip settlement sign (perspective)",
		description = "Display-only: flips the sign of Split values. Off = + means bank pays the player; On = + means player pays the bank (middleman mode only).",
		section = settlementSection
	)
	default boolean flipSettlementSign()
	{
		return false;
	}

	/**
	 * Retrieves a JSON-formatted string that represents the mapping of alternate accounts (alts) to their main account names.
	 * This configuration item is hidden and intended for internal use.
	 *
	 * @return a JSON string containing the alt-to-main name mapping. Defaults to an empty string if not configured.
	 */
	@ConfigItem(
		keyName = KEY_ALTS_JSON,
		name = "Alts JSON",
		description = "alt->main name mapping",
		hidden = true
	)
	default String altsJson()
	{
		return "";
	}

	/**
	 * Sets the JSON string representing an alt-to-main name mapping.
	 *
	 * @param value a JSON string defining the mapping from alternate accounts to main accounts
	 */
	@ConfigItem(
		keyName = KEY_ALTS_JSON,
		name = "Alts JSON",
		description = "alt->main name mapping",
		hidden = true
	)
	void altsJson(String value);

	// Define an enum for your dropdown options
	@Getter
	enum ValueMultiplier
	{
		COINS("None, 1 = 1gp", " coins"),
		THOUSAND("k, aka a thousand", "k"),
		MILLION("m, aka a million", "m"),
		BILLION("b, aka a billion", "b");

		private final String description;
		private final String value;

		ValueMultiplier(String description, String value)
		{
			this.description = description;
			this.value = value;
		}

		@Override
		public String toString()
		{
			return description;
		}
	}
}

package com.splitmanager.utils;

import java.awt.Color;
import java.awt.Dimension;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Getter
@Setter
public class ChatStatusOverlay extends OverlayPanel
{

	private boolean visible = false;
	private boolean chatchanOn = false;
	private boolean clanOn = false;
	private boolean guestOn = false;

	public ChatStatusOverlay()
	{
		setPosition(OverlayPosition.TOP_LEFT);
		setPosition(OverlayPosition.TOP_LEFT);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(java.awt.Graphics2D g)
	{
		if (!visible)
		{
			return null;
		}
		panelComponent.getChildren().clear();
		panelComponent.setPreferredSize(new Dimension(120, 0));

		final String title = "Cant track splits:";
		final Color titleColor = new Color(255, 80, 80);

		panelComponent.getChildren().add(TitleComponent.builder()
			.text(title)
			.color(titleColor)
			.build());

		if (!chatchanOn)
		{
			addStatusLine("Chat Channel", chatchanOn);
		}
/*		if (!clanOn)
			addStatusLine("Clan Chat", clanOn);
		if (!guestOn)
			addStatusLine("Guest Chat", guestOn);
		if (!countedOn)
			addStatusLine("Counted Chat", countedOn);*/

		return super.render(g);
	}

	public void addStatusLine(String label, boolean on)
	{
		final String statusText = on ? "ON" : "OFF";
		final Color statusCol = on ? new Color(120, 255, 120) : new Color(255, 120, 120);

		panelComponent.getChildren().add(LineComponent.builder()
			.left(label)
			.right(statusText)
			.leftColor(Color.WHITE)
			.rightColor(statusCol)
			.build());
	}


}
package com.splitmanager.utils;

import com.splitmanager.PluginConfig;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.regex.Pattern;
import javax.annotation.Nonnull;
import javax.swing.JFormattedTextField;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class Formats
{
	private static final DateTimeFormatter TS = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")
		.withZone(ZoneId.systemDefault());
	private static final DecimalFormat DF = new DecimalFormat("#,##0");
	private static final DecimalFormat DF_3DP = new DecimalFormat("#,##0.###");
	@Setter
	private static PluginConfig config;

	public static DateTimeFormatter getDateTime()
	{
		return TS;
	}

	public static DecimalFormat getDecimalFormat()
	{
		return DF;
	}

	public static final class OsrsAmountFormatter extends JFormattedTextField.AbstractFormatter
	{
		private static final Pattern P =
			Pattern.compile("(?i)^\\s*([0-9]+(?:\\.[0-9]+)?)\\s*([kmb]| coins)?\\s*$");

		private static BigDecimal getBigDecimal(BigDecimal number, char suffix) throws ParseException
		{
			log.debug("Converting {} to BigDecimal, with {}", number, suffix);
			if (number.signum() < 0)
			{
				throw new ParseException("Negative not allowed", 0);
			}

			long multiplierK;
			switch (suffix)
			{
				case 'k':
					multiplierK = 1_000L;
					break;
				case 'm':
					multiplierK = 1_000_000L;
					break;
				case 'b':
					multiplierK = 1_000_000_000L;
					break;
				default:
					multiplierK = 1L;
					break;
			}

			return number.multiply(BigDecimal.valueOf(multiplierK));
		}

		/**
		 * Convert a K-based long amount to a human string with a target suffix.
		 * Examples:
		 * amountK=1500, 'm' -> "1.5M"
		 * amountK=250,  'k' -> "250K"
		 * amountK=3,    'b' -> "0.003B"
		 *
		 * @param amountK value expressed in K-units (thousands)
		 * @param suffix  desired suffix: 'k', 'm', or 'b' (case-insensitive)
		 * @return formatted string with suffix
		 */
		public static String toSuffixString(long amountK, char suffix)
		{
			DecimalFormat localDF = DF;
			String s = String.valueOf(Character.toLowerCase(suffix));
			long divK; // how many K per target unit
			switch (s)
			{
				case "k":
					divK = 1_000L;
					break;              // 1 K per K
				case "m":
					divK = 1_000_000L;
					break;          // 1,000 K per M
				case "b":
					divK = 1_000_000_000L;
					localDF = DF_3DP;
					break;      // 1,000,000 K per B
				default:
					divK = 1L;
					s = "gp";
					break;
			}

			// Use BigDecimal to avoid precision issues for large numbers
			BigDecimal val = BigDecimal.valueOf(amountK)
				.divide(BigDecimal.valueOf(divK));

			// Format with up to 3 decimals, trimming trailing zeros
			String num = localDF.format(val);

			// Uppercase the suffix in output
			return num + s.toUpperCase();
		}

		/**
		 * Overload that accepts a String suffix ("k", "m", "b").
		 */
		public static String toSuffixString(long amountK, String suffix)
		{
			if (suffix == null || suffix.isEmpty())
			{
				return toSuffixString(amountK, 'k');
			}
			return toSuffixString(amountK, suffix.charAt(0));
		}

		public static long stringAmountToLongAmount(String amount, PluginConfig config) throws ParseException
		{
			String valueStr = amount;

			log.debug("Parsing amount: {}", valueStr);
			// Check if the value has no unit (k, m, b) and append the default
			java.util.regex.Pattern unitPattern = java.util.regex.Pattern.compile("(?i)^\\s*([0-9][0-9,]*(?:\\.[0-9]+)?)\\s*([kmb])?\\s*$");
			java.util.regex.Matcher matcher = unitPattern.matcher(valueStr);

			if (matcher.matches())
			{
				String numberTxt = matcher.group(1);
				String unitTxt = matcher.group(2);
				log.debug("Number: {}, Unit: {}", numberTxt, unitTxt);

				if (unitTxt == null && config != null)
				{
					// No unit specified, append the default multiplier
					valueStr = numberTxt + config.defaultValueMultiplier().getValue();
				}
				log.debug("Final value: {}", valueStr);
			}

			log.debug("Parsed amount: {}", valueStr);
			Object k = new Formats.OsrsAmountFormatter().stringToValue(valueStr);
			if (k == null)
			{
				throw new ParseException("Invalid amount", 0);
			}
			return (Long) k;
		}

		@Override
		public Object stringToValue(@Nonnull String text) throws ParseException
		{
			log.debug("Parsing bujiamount: {}", text);
			String s = text.replace(",", "").trim(); // ignore commas
			if (s.isEmpty())
			{
				return null;
			}

			java.util.regex.Matcher m = P.matcher(s);
			if (!m.matches())
			{
				throw new ParseException("Invalid amount", 0);
			}

			BigDecimal number = new BigDecimal(m.group(1));
			Character suffixCh = (m.group(2) == null) ? null : Character.toLowerCase(m.group(2).charAt(0));
			// If no suffix provided by user, fall back to config default if available
			char suffix;
			if (config == null)
			{
				log.debug("No config available, falling back to global config");
			}
			if (suffixCh == null)
			{
				log.debug("No suffix provided, falling back to config default");
				String def = config.defaultValueMultiplier().getValue();
				suffix = def != null && !def.isEmpty() ? Character.toLowerCase(def.charAt(0)) : ' ';
			}
			else
			{
				log.debug("Suffix provided: {}", suffixCh);
				suffix = (suffixCh == null) ? ' ' : suffixCh;
			}

			log.debug("Parsed amo00unt: {}{}", number, suffix);

			// Convert to raw coins
			BigDecimal coinsValue = getBigDecimal(number, suffix);
			// Return the exact long value (no normalization to K units)
			return coinsValue.setScale(0, RoundingMode.FLOOR).longValueExact();
		}

		@Override
		public String valueToString(Object value)
		{
			if (value == null)
			{
				return "";
			}
			Long k = ((Number) value).longValue();
			return k + "K";
		}

	}

}


package com.splitmanager.utils;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import java.lang.reflect.Type;
import java.time.Instant;

/**
 * Gson adapter for java.time.Instant (ISO-8601 text), avoiding reflective access issues
 * on older JVMs/contexts. Stored as Instant.toString(), parsed with Instant.parse().
 */
public class InstantTypeAdapter implements JsonSerializer<Instant>, JsonDeserializer<Instant>
{
	@Override
	public JsonElement serialize(Instant src, Type typeOfSrc, JsonSerializationContext context)
	{
		return new JsonPrimitive(src.toString());
	}

	@Override
	public Instant deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
	{
		return Instant.parse(json.getAsString());
	}
}

package com.splitmanager.utils;

import com.splitmanager.ManagerSession;
import com.splitmanager.PluginConfig;
import com.splitmanager.models.PlayerMetrics;
import com.splitmanager.models.Session;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.List;

/**
 * Handles formatting player metrics into markdown tables and other text formats.
 */
public class MarkdownFormatter
{

	/**
	 * Build metrics table as markdown.
	 */
	public static String buildMetricsMarkdown(List<PlayerMetrics> data, PluginConfig config)
	{
		DecimalFormat df = Formats.getDecimalFormat();
		StringBuilder sb = new StringBuilder();

		if (config.directPayments())
		{
			List<String> transfers = PaymentProcessor.computeDirectPayments(data);
			if (!transfers.isEmpty())
			{
				sb.append('\n').append("Suggested direct payments:\n");
				for (String line : transfers)
				{
					sb.append("- ").append(line).append('\n');
				}
			}
		}

		if (config.copyForDiscord())
		{
			sb.append("```\n");
		}

		if (!config.directPayments())
		{
			appendFullTable(data, df, sb, config);
		}
		else
		{
			appendSimpleTable(data, df, sb);
		}

		if (config.copyForDiscord())
		{
			sb.append("```\n");
		}

		return sb.toString();
	}

	private static void appendFullTable(List<PlayerMetrics> data,
										DecimalFormat df,
										StringBuilder sb,
										PluginConfig config)
	{
		List<String[]> rows = new ArrayList<>();
		int maxPlayer = "Player".length();
		int maxTotal = "Total".length();
		int maxSplit = "Split".length();

		for (PlayerMetrics pm : data)
		{
			String player = pm.player == null ? "" : pm.player.replace("|", "\\|");
			String total = df.format(pm.total);
			long dispSplit = pm.split;

			if (config.flipSettlementSign())
			{
				dispSplit = -dispSplit;
			}

			String split = df.format(dispSplit);
			rows.add(new String[]{player, total, split});

			if (player.length() > maxPlayer)
			{
				maxPlayer = player.length();
			}
			if (total.length() > maxTotal)
			{
				maxTotal = total.length();
			}
			if (split.length() > maxSplit)
			{
				maxSplit = split.length();
			}
		}

		sb.append("| ")
			.append(padRight("Player", maxPlayer)).append(" | ")
			.append(padLeft("Total", maxTotal)).append(" | ")
			.append(padLeft("Split", maxSplit)).append(" |\n");

		sb.append("| ")
			.append(repeat(maxPlayer)).append(" | ")
			.append(repeat(maxTotal - 1)).append(":").append(" | ")
			.append(repeat(maxSplit - 1)).append(":").append(" |\n");

		for (String[] r : rows)
		{
			sb.append("| ")
				.append(padRight(r[0], maxPlayer)).append(" | ")
				.append(padLeft(r[1], maxTotal)).append(" | ")
				.append(padLeft(r[2], maxSplit)).append(" |\n");
		}
	}

	private static void appendSimpleTable(List<PlayerMetrics> data,
										  DecimalFormat df,
										  StringBuilder sb)
	{
		List<String[]> rows = new ArrayList<>();
		int maxPlayer = "Player".length();
		int maxSplit = "Split".length();

		for (var pm : data)
		{
			String player = pm.player == null ? "" : pm.player.replace("|", "\\|");
			long dispSplit = pm.split;
			String split = df.format(dispSplit);

			rows.add(new String[]{player, split});

			if (player.length() > maxPlayer)
			{
				maxPlayer = player.length();
			}
			if (split.length() > maxSplit)
			{
				maxSplit = split.length();
			}
		}

		sb.append("| ")
			.append(padRight("Player", maxPlayer)).append(" | ")
			.append(padLeft("Split", maxSplit)).append(" |\n");

		sb.append("| ")
			.append(repeat(maxPlayer)).append(" | ")
			.append(repeat(maxSplit - 1)).append(":").append(" |\n");
		for (String[] r : rows)
		{
			sb.append("| ").append(padRight(r[0], maxPlayer)).append(" | ")
				.append(padLeft(r[1], maxSplit)).append(" |\n");
		}
	}

	private static String padRight(String s, int width)
	{
		if (s == null)
		{
			s = "";
		}
		if (s.length() >= width)
		{
			return s;
		}
		return s + " ".repeat(width - s.length());
	}

	private static String padLeft(String s, int width)
	{
		if (s == null)
		{
			s = "";
		}
		return " ".repeat(Math.max(0, width - s.length())) + s;
	}

	private static String repeat(int count)
	{
		if (count <= 0)
		{
			return "";
		}
		return "-".repeat(count);
	}

	/**
	 * Builds a JSON representation of the player metrics for the current session.
	 * The method retrieves the current session and computes metrics for each player in that session.
	 * The metrics are then formatted as a JSON array, where each entry contains the player's name,
	 * total count, split count, and active player status.
	 *
	 * @return A JSON string representing the computed player metrics for the current session.
	 * Returns an empty JSON array "[]" if no session is active or there are no metrics.
	 */
	public static String buildMetricsJson(ManagerSession sessionManager)
	{
		Session currentSession = sessionManager.getCurrentSession().orElse(null);
		List<PlayerMetrics> data = sessionManager.computeMetricsFor(currentSession, true);
		StringBuilder sb = new StringBuilder();

		sb.append("[");
		for (int i = 0; i < data.size(); i++)
		{
			PlayerMetrics pm = data.get(i);
			sb.append("{\"player\":\"").append(pm.player).append("\",")
				.append("\"total\":").append(pm.total).append(",")
				.append("\"split\":").append(pm.split).append(",")
				.append("\"active\":").append(pm.activePlayer).append("}");
			if (i < data.size() - 1)
			{
				sb.append(",");
			}
		}
		sb.append("]");

		return sb.toString();
	}
}
package com.splitmanager.utils;

import com.splitmanager.models.PlayerMetrics;
import com.splitmanager.models.Transfer;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.List;

/**
 * Handles payment calculations and formatting for settlements between players.
 */
public class PaymentProcessor
{

	/**
	 * Compute direct payments as text instructions.
	 */
	public static List<String> computeDirectPayments(List<PlayerMetrics> data)
	{
		List<PlayerMetrics> receivers = new ArrayList<>();
		List<PlayerMetrics> payers = new ArrayList<>();

		for (PlayerMetrics pm : data)
		{
			if (pm.split > 0)
			{
				receivers.add(pm);
			}
			else if (pm.split < 0)
			{
				payers.add(pm);
			}
		}

		receivers.sort((a, b) -> Long.compare(b.split, a.split));
		payers.sort((a, b) -> Long.compare(Math.abs(b.split), Math.abs(a.split)));

		List<String> lines = new ArrayList<>();
		DecimalFormat df = Formats.getDecimalFormat();

		int i = 0, j = 0;
		long recvLeft = receivers.isEmpty() ? 0 : receivers.get(0).split;
		long payLeft = payers.isEmpty() ? 0 : -payers.get(0).split;
		while (i < receivers.size() && j < payers.size())
		{
			long amt = Math.min(recvLeft, payLeft);
			if (amt > 0)
			{
				String from = payers.get(j).player;
				String to = receivers.get(i).player;
				lines.add(from + " -> " + to + ": " + df.format(amt));
				recvLeft -= amt;
				payLeft -= amt;
			}
			if (recvLeft == 0)
			{
				i++;
				if (i < receivers.size())
				{
					recvLeft = receivers.get(i).split;
				}
			}
			if (payLeft == 0)
			{
				j++;
				if (j < payers.size())
				{
					payLeft = -payers.get(j).split;
				}
			}
		}

		return lines;
	}

	/**
	 * Compute direct payments as structured Transfer objects.
	 */
	public static List<Transfer> computeDirectPaymentsStructured(List<PlayerMetrics> data)
	{
		List<PlayerMetrics> receivers = new ArrayList<>();
		List<PlayerMetrics> payers = new ArrayList<>();
		for (PlayerMetrics pm : data)
		{
			if (pm.split > 0)
			{
				receivers.add(pm);
			}
			else if (pm.split < 0)
			{
				payers.add(pm);
			}
		}
		receivers.sort((a, b) -> Long.compare(b.split, a.split));
		payers.sort((a, b) -> Long.compare(Math.abs(b.split), Math.abs(a.split)));

		List<Transfer> out = new ArrayList<>();
		int i = 0, j = 0;
		long recvLeft = receivers.isEmpty() ? 0 : receivers.get(0).split;
		long payLeft = payers.isEmpty() ? 0 : -payers.get(0).split;

		while (i < receivers.size() && j < payers.size())
		{
			long amt = Math.min(recvLeft, payLeft);
			if (amt > 0)
			{
				String from = payers.get(j).player;
				String to = receivers.get(i).player;
				out.add(new Transfer(from, to, amt));
				recvLeft -= amt;
				payLeft -= amt;
			}
			if (recvLeft == 0)
			{
				i++;
				if (i < receivers.size())
				{
					recvLeft = receivers.get(i).split;
				}
			}
			if (payLeft == 0)
			{
				j++;
				if (j < payers.size())
				{
					payLeft = -payers.get(j).split;
				}
			}
		}
		return out;
	}

}
package com.splitmanager.utils;

import java.awt.Component;
import javax.swing.JOptionPane;

public class Utils
{
	public static void toast(Component parent, String msg)
	{
		JOptionPane.showMessageDialog(parent, msg);
	}
}

package com.splitmanager.views.components;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.BORDER_OFFSET;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

/**
 * Drop-in replacement for the old DropdownRip used across RuneLite plugins.
 * Constructor signature matches the legacy usage: new DropdownRip(title, content).
 * The header is clickable and toggles the visibility of the content area.
 */
public class DropdownRip extends JPanel
{
	private final Header header;
	private final JPanel contentHolder;
	private boolean expanded;

	public DropdownRip(String title, JComponent content)
	{
		this(title, content, true);
	}

	public DropdownRip(String title, JComponent content, boolean expanded)
	{
		super(new BorderLayout());
		this.expanded = expanded;

		String description = "";
		header = new Header(title, description);
		header.setBorder(new EmptyBorder(3, 0, 0, 0));
		contentHolder = new JPanel(new BorderLayout());
		contentHolder.setOpaque(false);
		contentHolder.setBorder(new EmptyBorder(3, 0, 3, 0));
		contentHolder.add(content);

		add(header, BorderLayout.NORTH);
		add(contentHolder, BorderLayout.CENTER);

		updateExpanded();
	}

	public void setExpanded(boolean expanded)
	{
		if (this.expanded != expanded)
		{
			this.expanded = expanded;
			updateExpanded();
		}
	}


	public void toggle()
	{
		setExpanded(!expanded);
	}


	private void updateExpanded()
	{
		contentHolder.setVisible(expanded);
		header.setExpanded(expanded);
		revalidate();
		repaint();
	}

	private final class Header extends JPanel
	{
		private final ImageIcon SECTION_EXPAND_ICON;
		private final ImageIcon SECTION_RETRACT_ICON;

		private final JButton sectionToggle;

		private Header(String title, String description)
		{
			super(new BorderLayout());

			BufferedImage sectionRetractIcon = ImageUtil.loadImageResource(Header.class, "/util/arrow_right.png");
			sectionRetractIcon = ImageUtil.luminanceOffset(sectionRetractIcon, -121);
			SECTION_EXPAND_ICON = new ImageIcon(sectionRetractIcon);
			final BufferedImage sectionExpandIcon = ImageUtil.rotateImage(sectionRetractIcon, Math.PI / 2);
			SECTION_RETRACT_ICON = new ImageIcon(sectionExpandIcon);

			final JPanel section = new JPanel();
			section.setLayout(new BoxLayout(section, BoxLayout.Y_AXIS));
			section.setMinimumSize(new Dimension(PANEL_WIDTH, 0));

			final JPanel sectionHeader = new JPanel();
			sectionHeader.setLayout(new BorderLayout());
			sectionHeader.setMinimumSize(new Dimension(PANEL_WIDTH, 0));
			// For whatever reason, the header extends out by a single pixel when closed. Adding a single pixel of
			// border on the right only affects the width when closed, fixing the issue.
			if (!expanded)
			{
				sectionHeader.setBorder(new CompoundBorder(
					new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
					new EmptyBorder(0, 0, 3, 1)));
			}
			section.add(sectionHeader, BorderLayout.NORTH);

			sectionToggle = new JButton(expanded ? SECTION_RETRACT_ICON : SECTION_EXPAND_ICON);
			//sectionToggle = new JButton();
			sectionToggle.setPreferredSize(new Dimension(18, 0));
			sectionToggle.setBorder(new EmptyBorder(0, 0, 0, 0));
			sectionToggle.setToolTipText(expanded ? "Retract" : "Expand");
			SwingUtil.removeButtonDecorations(sectionToggle);
			sectionHeader.add(sectionToggle, BorderLayout.WEST);

			JLabel sectionName = new JLabel(title);
			sectionName.setForeground(ColorScheme.BRAND_ORANGE);
			sectionName.setFont(FontManager.getRunescapeBoldFont());
			sectionName.setToolTipText("<html>" + title + ":<br>" + description + "</html>");
			sectionHeader.add(sectionName, BorderLayout.CENTER);

			final JPanel sectionContents = new JPanel();
			sectionContents.setLayout(new DynamicGridLayout(0, 1, 0, 5));
			sectionContents.setMinimumSize(new Dimension(PANEL_WIDTH, 0));
			if (expanded)
			{
				sectionContents.setBorder(new CompoundBorder(
					new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
					new EmptyBorder(BORDER_OFFSET, 0, BORDER_OFFSET, 0)));
			}
			sectionContents.setVisible(expanded);
			section.add(sectionContents);

			setOpaque(true);
			setBackground(ColorScheme.DARK_GRAY_COLOR);
			setBorder(BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.BORDER_COLOR));
			setPreferredSize(new Dimension(10, 28));

			add(section);

			MouseAdapter click = new MouseAdapter()
			{
				@Override
				public void mouseClicked(MouseEvent e)
				{
					toggle();
				}

				@Override
				public void mouseEntered(MouseEvent e)
				{
					sectionName.setForeground(ColorScheme.BRAND_ORANGE_TRANSPARENT);
				}

				@Override
				public void mouseExited(MouseEvent e)
				{
					sectionName.setForeground(ColorScheme.BRAND_ORANGE);
				}
			};

			addMouseListener(click);
			sectionName.addMouseListener(click);
			sectionHeader.addMouseListener(click);
			sectionToggle.addActionListener(a -> toggle());
		}


		private void setExpanded(boolean ex)
		{
			sectionToggle.setIcon(ex ? SECTION_RETRACT_ICON : SECTION_EXPAND_ICON);
			sectionToggle.setToolTipText(ex ? "Retract" : "Expand");
			sectionToggle.repaint();
		}
	}
}

package com.splitmanager.views.components.table;

import com.splitmanager.ManagerPanel;
import com.splitmanager.ManagerSession;
import com.splitmanager.controllers.PanelActions;
import static com.splitmanager.utils.Utils.toast;
import java.awt.Component;
import javax.inject.Inject;
import javax.swing.DefaultCellEditor;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JTable;

/**
 * Table cell editor rendering a small X button to remove a player from the active session.
 */
public class RemoveButtonEditor extends DefaultCellEditor
{
	private final JButton button = new JButton("X");
	private int row = -1;

	@Inject
	private ManagerPanel managerPanel;

	/**
	 * Create the editor and wire the remove behavior.
	 *
	 * @param parent       parent component for toasts
	 * @param manager      session manager
	 * @param metricsTable table with player rows
	 * @param actions
	 */
	public RemoveButtonEditor(Component parent, ManagerSession manager, JTable metricsTable, PanelActions actions)
	{
		super(new JCheckBox());

		button.setOpaque(true);
		button.addActionListener(e -> {
			if (row >= 0 && !manager.isHistoryLoaded())
			{
				String player = (String) metricsTable.getModel().getValueAt(row, 0);
				if (manager.removePlayerFromSession(player))
				{
					actions.refreshAllView();
				}
				else
				{
					toast(parent, "Failed to remove player.");
				}
			}
			fireEditingStopped();
		});

	}

	@Override
	public Object getCellEditorValue()
	{
		return "X";
	}

	@Override
	public boolean stopCellEditing()
	{
		this.row = -1;
		return super.stopCellEditing();
	}

	@Override
	public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column)
	{
		this.row = row;
		return button;
	}

}

package com.splitmanager.views.components.table;

import javax.swing.JButton;
import javax.swing.JTable;
import javax.swing.table.TableCellRenderer;

public class RemoveButtonRenderer extends JButton implements TableCellRenderer
{
	RemoveButtonRenderer()
	{
		setOpaque(true);
	}

	@Override
	public java.awt.Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column)
	{
		setText("X");
		return this;
	}
}


package com.splitmanager.views;

import com.splitmanager.ManagerKnownPlayers;
import com.splitmanager.ManagerSession;
import com.splitmanager.PluginConfig;
import com.splitmanager.controllers.PanelActions;
import com.splitmanager.controllers.PanelController;
import com.splitmanager.models.Kill;
import com.splitmanager.models.Metrics;
import com.splitmanager.models.PlayerMetrics;
import com.splitmanager.models.RecentSplitsTable;
import com.splitmanager.models.Session;
import com.splitmanager.models.Transfer;
import com.splitmanager.models.WaitlistTable;
import com.splitmanager.utils.Formats;
import static com.splitmanager.utils.Formats.OsrsAmountFormatter.toSuffixString;
import com.splitmanager.utils.MarkdownFormatter;
import com.splitmanager.utils.PaymentProcessor;
import com.splitmanager.views.components.DropdownRip;
import com.splitmanager.views.components.table.RemoveButtonEditor;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.datatransfer.StringSelection;
import java.util.ArrayList;
import java.util.List;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.DefaultCellEditor;
import javax.swing.DefaultComboBoxModel;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JFormattedTextField;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.SwingConstants;
import javax.swing.Timer;
import javax.swing.border.Border;
import javax.swing.text.DefaultFormatterFactory;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.PluginPanel;

@Slf4j
@Getter
/**
 * Swing-based view for the Auto Split Manager panel. Renders sections and forwards
 * user interactions to PanelActions.
 */
public class PanelView extends PluginPanel
{
	private final JPanel activePlayersButtonsPanel = new JPanel(new GridLayout(0, 1, 0, 2));
	private final ManagerSession sessionManager;
	private final PluginConfig config;
	private final ManagerKnownPlayers playerManager;
	private final JComboBox<String> knownPlayersDropdown = new JComboBox<>();
	private final JTextField newPlayerField = new JTextField();
	private final JLabel historyLabel = new JLabel("History: OFF");
	private final JFormattedTextField killAmountField = makeOsrsField();
	private final JFormattedTextField activeKillAmountField = makeOsrsField(); // TODO Remove this?
	private final JTable metricsTable = new JTable(new Metrics());
	private final RecentSplitsTable recentSplitsModel;
	private final WaitlistTable waitlistTableModel = new WaitlistTable();
	private final JTable waitlistTable = new JTable(waitlistTableModel);
	private final JButton btnWaitlistAdd = new JButton("Add");
	private final JButton btnWaitlistDelete = new JButton("Del");
	private final JButton btnAddPlayer = new JButton("Add Player");
	private final JLabel knownListLabel = new JLabel("Known:");
	private final JLabel altsLabel = new JLabel("Known alts:");
	private final JLabel altOfLabel = new JLabel("");
	private final JList<String> altsList = new JList<>(new DefaultListModel<>());
	private final JComboBox<String> addAltDropdown = new JComboBox<>();
	private final JButton btnAddAlt = new JButton("Add alt");
	private final JButton btnRemoveAlt = new JButton("Remove alt");
	private final JButton btnRemovePlayer = new JButton("Remove");
	private final JButton btnAddKill = new JButton("Add");
	private final JButton btnStart = new JButton("Start");
	private final JButton btnStop = new JButton("Stop");
	private final JButton btnAddToSession = new JButton("Add");
	private final JButton btnRemoveFromSession = new JButton("Remove");
	private final JComboBox<String> currentSessionPlayerDropdown = new JComboBox<>();
	private final JComboBox<String> notInCurrentSessionPlayerDropdown = new JComboBox<>();
	private final DefaultListModel<Session> historyModel = new DefaultListModel<>();
	private final JList<Session> historyList = new JList<>(historyModel);
	private final Dimension dl = new Dimension(48, 24);
	private final Dimension dm = new Dimension(64, 24);
	private final Dimension bm = new Dimension(59, 24);
	private final Dimension dv = new Dimension(96, 24);
	private final Dimension d = new Dimension(128, 24);
	private final Insets inset = new Insets(3, 3, 3, 3);
	private final Dimension lm = new Dimension(0, 140);
	private final Dimension ll = new Dimension(0, 280);
	private final JTable recentSplitsTable;
	private PanelActions actions;
	// Tutorial UI
	private JPanel tutorialPanel;
	private JTextArea tutorialText;
	private JButton btnTourStart;
	private JButton btnTourPrev;
	private JButton btnTourNext;
	private JButton btnTourEnd;
	private boolean tourRunning = false;
	private int tourStep = 0;
	private Timer rainbowTimer;
	private JComponent highlighted;
	private Border originalBorder;

	// References to copy buttons so we can highlight them in the tour
	private JButton btnCopyJson;
	private JButton btnCopyMd;
	private DropdownRip detectedValuesDropdown;

	public PanelView(ManagerSession sessionManager, PluginConfig config, ManagerKnownPlayers playerManager, PanelController controller)
	{
		this.sessionManager = sessionManager;
		this.config = config;
		this.playerManager = playerManager;
		bindActions(controller);

		recentSplitsModel = new RecentSplitsTable(config);
		recentSplitsModel.setListener(editedKill -> {
			if (actions != null)
			{
				actions.recomputeMetricsForSession(editedKill != null ? editedKill.getSessionId() : null);
			}
			else
			{
				// Fallback: recompute current if no controller available
				refreshMetrics();
			}
		});
		recentSplitsTable = makeRecentSplitsTable(recentSplitsModel);

		JPanel top = new JPanel();
		top.setLayout(new BoxLayout(top, BoxLayout.Y_AXIS));

		top.add(generateTutorialPanel());

		top.add(generateSessionPanel());
		top.add(Box.createVerticalStrut(3));
		top.add(generateSessionPlayerManagement());
		top.add(Box.createVerticalStrut(3));
		top.add(generateAddSplit());
		top.add(Box.createVerticalStrut(3));
		top.add(generateRecentSplitsPanel());
		top.add(Box.createVerticalStrut(3));
		top.add(generateWaitlistPanelCollapsible());
		top.add(Box.createVerticalStrut(3));
		top.add(generateMetrics());
		top.add(Box.createVerticalStrut(3));
		top.add(generateKnownPlayersManagement());
		top.add(Box.createVerticalStrut(3));

		add(top, BorderLayout.NORTH);
	}

	private static String shortenName(String name, int maxLen)
	{
		if (name == null)
		{
			return "";
		}
		String n = name.trim();
		return n.length() <= maxLen ? n : n.substring(0, maxLen);
	}

	public void bindActions(PanelActions actions)
	{
		this.actions = actions;

		btnStart.addActionListener(e -> actions.startSession());
		btnStop.addActionListener(e -> actions.stopSession());

		btnAddToSession.addActionListener(e ->
			actions.addPlayerToSession((String) notInCurrentSessionPlayerDropdown.getSelectedItem()));

		btnAddPlayer.addActionListener(e ->
			actions.addKnownPlayer(newPlayerField.getText()));
		btnRemovePlayer.addActionListener(e ->
			actions.removeKnownPlayer((String) knownPlayersDropdown.getSelectedItem()));
		knownPlayersDropdown.addItemListener(e -> {
			if (e.getStateChange() == java.awt.event.ItemEvent.SELECTED)
			{
				actions.onKnownPlayerSelectionChanged((String) e.getItem());
			}
		});

		btnAddAlt.addActionListener(e ->
			actions.addAltToMain((String) knownPlayersDropdown.getSelectedItem(),
				(String) addAltDropdown.getSelectedItem()));
		btnRemoveAlt.addActionListener(e ->
			actions.removeSelectedAlt((String) knownPlayersDropdown.getSelectedItem(),
				altsList.getSelectedValue()));

		btnAddKill.addActionListener(e -> {
			actions.addKillFromInputs();
		});

		btnWaitlistAdd.addActionListener(e -> actions.applySelectedPendingValue(waitlistTable.getSelectedRow()));
		btnWaitlistDelete.addActionListener(e -> actions.deleteSelectedPendingValue(waitlistTable.getSelectedRow()));
	}

	private JFormattedTextField makeOsrsField()
	{
		JFormattedTextField f = new JFormattedTextField(
			new DefaultFormatterFactory(new Formats.OsrsAmountFormatter()));
		f.setColumns(14);
		f.setFocusLostBehavior(JFormattedTextField.COMMIT_OR_REVERT);
		f.setToolTipText("Enter amount like 10k, 1.1m, or 1b (K = thousands)");
		return f;
	}

	private JPanel generateTutorialPanel()
	{
		if (tutorialPanel != null)
		{
			return tutorialPanel;
		}

		tutorialPanel = new JPanel(new BorderLayout());
		tutorialPanel.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(Color.GRAY),
			BorderFactory.createEmptyBorder(6, 6, 6, 6)));

		JPanel left = new JPanel();
		left.setLayout(new BoxLayout(left, BoxLayout.Y_AXIS));
		tutorialText = new JTextArea("Welcome! Click Start tour to begin a quick walkthrough.");
		tutorialText.setLineWrap(true);
		tutorialText.setWrapStyleWord(true);
		tutorialText.setEditable(false);
		tutorialText.setFont(tutorialText.getFont().deriveFont(Font.BOLD));
		tutorialText.setAlignmentX(Component.LEFT_ALIGNMENT);
		JLabel hint = new JLabel("   Tip: You can disable this tour in settings");
		hint.setFont(hint.getFont().deriveFont(Font.PLAIN, 11f));
		hint.setAlignmentX(Component.LEFT_ALIGNMENT);
		left.add(tutorialText);
		left.add(Box.createVerticalStrut(3));
		left.add(hint);

		JPanel right = new JPanel();
		right.setLayout(new BoxLayout(right, BoxLayout.Y_AXIS));
		btnTourStart = new JButton("Start tour");
		btnTourPrev = new JButton("Previous");
		btnTourNext = new JButton("Next");
		btnTourEnd = new JButton("End");

		Dimension small = new Dimension(90, 22);
		btnTourStart.setPreferredSize(small);
		btnTourPrev.setPreferredSize(small);
		btnTourNext.setPreferredSize(small);
		btnTourEnd.setPreferredSize(small);

		// Create button rows with proper alignment
		JPanel buttonRow1 = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 5));
		buttonRow1.add(btnTourStart);

		JPanel buttonRow2 = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 0));
		buttonRow2.add(btnTourPrev);
		buttonRow2.add(btnTourNext);

		right.add(buttonRow1);
		right.add(buttonRow2);

		// Route through controller for MVC
		btnTourStart.addActionListener(e -> {
			if (actions != null)
			{
				actions.tourStart();
			}
			else
			{
				startTour();
			}
		});
		btnTourPrev.addActionListener(e -> {
			if (actions != null)
			{
				actions.tourPrev();
			}
			else
			{
				prevTourStep();
			}
		});
		btnTourNext.addActionListener(e -> {
			if (actions != null)
			{
				actions.tourNext();
			}
			else
			{
				nextTourStep();
			}
		});
		btnTourEnd.addActionListener(e -> {
			if (actions != null)
			{
				actions.tourEnd();
			}
			else
			{
				endTourAndDisable();
			}
		});

		tutorialPanel.add(left, BorderLayout.CENTER);
		tutorialPanel.add(right, BorderLayout.SOUTH);

		updateTutorialUI();
		return tutorialPanel;
	}

	public void startTour()
	{
		tourRunning = true;
		tourStep = 0;
		updateTutorialUI();
		highlightTargetForStep();
	}

	public void endTour()
	{
		// do not auto-disable config here; controller decides
		tourRunning = false;
		gotoStep(0);
		clearHighlight();
		updateTutorialUI();
	}

	public void endTourAndDisable()
	{
		// Delegate disabling to controller for MVC; fallback to local end
		if (actions != null)
		{
			actions.tourEnd();
			return;
		}
		// Fallback when no controller bound
		tourRunning = false;
		gotoStep(0);
		clearHighlight();
		try
		{
			config.enableTour(false);
		}
		catch (Throwable ignored)
		{
		}
		updateTutorialUI();
	}

	public void nextTourStep()
	{
		gotoStep(tourStep + 1);
	}

	public void prevTourStep()
	{
		gotoStep(tourStep - 1);
	}

	public void gotoStep(int step)
	{
		int max = getTourSteps().size() - 1;
		if (step < 0)
		{
			step = 0;
		}
		if (step > max)
		{
			endTourAndDisable();
			return;
		}
		tourStep = step;
		updateTutorialUI();
		highlightTargetForStep();
	}

	private void updateTutorialUI()
	{
		boolean enabled = config.enableTour();
		boolean show = enabled || tourRunning;
		if (tutorialPanel != null)
		{
			tutorialPanel.setVisible(show);
		}
		if (tutorialText != null)
		{
			List<String> steps = getTourSteps();
			int max = steps.size();
			String msg = tourRunning ? ("Step " + (tourStep + 1) + "/" + max + ": " + steps.get(tourStep))
				: "Welcome! Click Start tour to begin a quick walkthrough.";
			tutorialText.setText(msg);
		}
		boolean inTour = tourRunning;
		if (btnTourStart != null)
		{
			btnTourStart.setVisible(!inTour);
		}
		if (btnTourPrev != null)
		{
			btnTourPrev.setVisible(inTour);
		}
		if (btnTourNext != null)
		{
			btnTourNext.setVisible(inTour);
		}
		if (btnTourEnd != null)
		{
			btnTourEnd.setVisible(inTour);
		}
	}

	private List<String> getTourSteps()
	{
		List<String> steps = new ArrayList<>();
		steps.add("Scroll down and add a new player: type a name in the text field and click Add Player.");
		steps.add("Optional: The 'Known alts' dropdown lets you link an alt account to a selected known player.");
		steps.add("Start a session using the Start button.");
		steps.add("Add players to the session: use the 'Not in session' dropdown, click Add. Tip: add 2 players to see splits.");
		steps.add("Record a split: use the 'Player' dropdown, enter an amount, then click Add.");
		steps.add("You can remove a player from settlement by clicking the 'x' button in the Settlement table.");
		steps.add("Share results: use the Copy MD button (great for Discord) or Copy JSON if you need raw data.");
		steps.add("Detected values: expand the 'Detected values' section. '!add' in clan chat will queue amounts here. See Settings > Chat detection to configure.");
		steps.add("Review the Recent Splits table.");
		steps.add("Stop the session when you are done.");
		return steps;
	}

	private void highlightTargetForStep()
	{
		clearHighlight();
		if (!tourRunning)
		{
			return;
		}
		switch (tourStep)
		{
			case 0:
				// Start session
				highlight(newPlayerField);
				break;
			case 1:
				// Add new player via text field
				highlight(addAltDropdown);
				break;
			case 2:
				// Known alts dropdown to link alts
				highlight(btnStart);
				break;
			case 3:
				// Add players to session using 'Not in session' dropdown
				highlight(notInCurrentSessionPlayerDropdown);
				break;
			case 4:
				// Record split: Player dropdown (and amount field exists near)
				highlight(currentSessionPlayerDropdown);
				break;
			case 5:
				// Show settlement table where 'x' removes a player
				highlight(metricsTable);
				break;
			case 6:
				// Copy buttons for sharing results
				highlight(btnCopyMd != null ? btnCopyMd : metricsTable);
				break;
			case 7:
				// Detected values dropdown / table
				highlight(detectedValuesDropdown);
				break;
			case 8:
				// Recent splits table review
				highlight(recentSplitsTable);
				break;
			case 9:
				// Stop session
				highlight(btnStop);
				break;
			default:
				clearHighlight();
		}
	}

	private void highlight(JComponent c)
	{
		if (c == null)
		{
			return;
		}
		clearHighlight();
		highlighted = c;
		originalBorder = c.getBorder();
		final float[] hue = {0f};
		if (rainbowTimer != null)
		{
			rainbowTimer.stop();
		}
		rainbowTimer = new Timer(80, e -> {
			hue[0] += 0.02f;
			if (hue[0] > 1f)
			{
				hue[0] = 0f;
			}
			Color color = Color.getHSBColor(hue[0], 1f, 1f);
			Border rb = BorderFactory.createLineBorder(color, 3);
			Border pad = BorderFactory.createEmptyBorder(2, 2, 2, 2);
			c.setBorder(BorderFactory.createCompoundBorder(rb, pad));
			c.repaint();
		});
		rainbowTimer.start();
	}

	private void clearHighlight()
	{
		if (rainbowTimer != null)
		{
			rainbowTimer.stop();
			rainbowTimer = null;
		}
		if (highlighted != null)
		{
			highlighted.setBorder(originalBorder);
			highlighted.repaint();
			highlighted = null;
			originalBorder = null;
		}
	}

	private JTable makeRecentSplitsTable(RecentSplitsTable model)
	{
		JTable t = new JTable(model);
		// ... existing table setup ...

		// Right align Amount renderer
		javax.swing.table.DefaultTableCellRenderer right = new javax.swing.table.DefaultTableCellRenderer();
		right.setHorizontalAlignment(SwingConstants.RIGHT);
		t.getColumnModel().getColumn(2).setCellRenderer(right);

		// Row-aware player editor
		javax.swing.DefaultCellEditor playerEditor = new javax.swing.DefaultCellEditor(new JComboBox<String>())
		{
			@Override
			public java.awt.Component getTableCellEditorComponent(
				JTable table, Object value, boolean isSelected, int row, int column)
			{
				JComboBox<String> combo = (JComboBox<String>) getComponent();

				// Determine players for this row's session
				String[] choices;
				Kill k = ((RecentSplitsTable) table.getModel()).getKillAt(row);
				java.util.Set<String> playersForRow = new java.util.LinkedHashSet<>();
				if (k != null && k.getSessionId() != null)
				{
					Session s = sessionManager.getAllSessionsNewestFirst().stream()
						.filter(ss -> k.getSessionId().equals(ss.getId()))
						.findFirst().orElse(null);
					if (s != null && s.getPlayers() != null && !s.getPlayers().isEmpty())
					{
						playersForRow.addAll(s.getPlayers());
					}
				}
				if (playersForRow.isEmpty())
				{
					playersForRow.addAll(playerManager.getKnownMains());
				}
				choices = playersForRow.toArray(new String[0]);

				combo.setModel(new DefaultComboBoxModel<>(choices));
				combo.setSelectedItem(value);
				return combo;
			}
		};
		t.getColumnModel().getColumn(1).setCellEditor(playerEditor);

		// Amount editor (existing)
		JFormattedTextField amtField = new JFormattedTextField(new DefaultFormatterFactory(new Formats.OsrsAmountFormatter()));
		amtField.setBorder(null);
		DefaultCellEditor amtEditor = new DefaultCellEditor(amtField);
		t.getColumnModel().getColumn(2).setCellEditor(amtEditor);

		return t;
	}

	private JPanel generateAddSplit()
	{
		JPanel killPanel = new JPanel();
		killPanel.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createTitledBorder("Add split to session:"),
			BorderFactory.createEmptyBorder(3, 3, 3, 3)));
		killPanel.setLayout(new GridBagLayout());

		GridBagLayout gbl1 = (GridBagLayout) killPanel.getLayout();
		gbl1.columnWidths = new int[]{dm.width, 0};     // col0 fixed, col1 auto
		gbl1.columnWeights = new double[]{0.0, 1.0};    // col0 no grow, col1 grows

		GridBagConstraints gbc = new GridBagConstraints();
		gbc.insets = inset;

		gbc.gridx = 0;
		gbc.gridy = 0;
		gbc.weightx = 0;
		gbc.anchor = GridBagConstraints.EAST;

		JLabel apLabel = new JLabel("Player:");
		apLabel.setHorizontalAlignment(SwingConstants.RIGHT);
		killPanel.add(apLabel, gbc);

		gbc.gridx = 1;
		gbc.gridy = 0;
		gbc.weightx = 1.0;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		killPanel.add(currentSessionPlayerDropdown, gbc);

		gbc.gridx = 0;
		gbc.gridy = 1;
		gbc.weightx = 0;

		JLabel amountLabel = new JLabel("Amount:");
		amountLabel.setHorizontalAlignment(SwingConstants.RIGHT);
		killPanel.add(amountLabel, gbc);

		gbc.gridx = 1;
		gbc.gridy = 1;
		gbc.weightx = 1.0;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		killPanel.add(killAmountField, gbc);

		gbc.gridx = 1;
		gbc.gridy = 2;
		gbc.weightx = 1.0;
		gbc.anchor = GridBagConstraints.EAST;
		gbc.fill = GridBagConstraints.NONE;
		btnAddKill.setPreferredSize(dv);
		btnAddKill.setMinimumSize(dv);
		killPanel.add(btnAddKill, gbc);

		return killPanel;
	}

	private JPanel generateSessionPlayerManagement()
	{
		JPanel rosterPanel = new JPanel();
		rosterPanel.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createTitledBorder("Add players to session:"),
			BorderFactory.createEmptyBorder(3, 3, 3, 3)));
		rosterPanel.setLayout(new GridBagLayout());

		GridBagLayout gbl1 = (GridBagLayout) rosterPanel.getLayout();
		gbl1.columnWidths = new int[]{dm.width, 0};     // col0 fixed, col1 auto
		gbl1.columnWeights = new double[]{0.0, 1.0};

		GridBagConstraints gbc = new GridBagConstraints();
		gbc.insets = inset;

		gbc.gridx = 1;
		gbc.gridy = 0;
		gbc.weightx = 1.0;
		gbc.fill = GridBagConstraints.HORIZONTAL;

		String[] Players = sessionManager.getNonActivePlayers().toArray(new String[0]);
		notInCurrentSessionPlayerDropdown.setModel(new DefaultComboBoxModel<>(Players));
		rosterPanel.add(notInCurrentSessionPlayerDropdown, gbc);

		gbc.gridx = 0;
		gbc.gridy = 0;
		gbc.weightx = 0;


		JLabel apLabel = new JLabel("Player:");
		apLabel.setHorizontalAlignment(SwingConstants.RIGHT);
		rosterPanel.add(apLabel, gbc);

/*        gbc.gridx = 0;
        gbc.gridy = 1;
        gbc.gridwidth = 2;
        gbc.weightx = 1.0;
        gbc.anchor = GridBagConstraints.CENTER;

        JLabel help = new JLabel("Remove via the 'X' in the table.");
        help.setHorizontalAlignment(SwingConstants.CENTER);
        rosterPanel.add(help, gbc);*/


		gbc.gridx = 1;
		gbc.gridy = 1;
		gbc.weightx = 1.0;
		gbc.anchor = GridBagConstraints.EAST;
		gbc.fill = GridBagConstraints.NONE;
		btnAddToSession.setPreferredSize(dv);
		rosterPanel.add(btnAddToSession, gbc);

		return rosterPanel;
	}

	private JPanel generateKnownPlayersManagement()
	{
		JPanel PlayersPanel = new JPanel();
		PlayersPanel.setLayout(new GridBagLayout());
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.insets = inset;
		gbc.anchor = GridBagConstraints.WEST;
		gbc.fill = GridBagConstraints.HORIZONTAL;

		JLabel title = new JLabel("Edit the known players list:");
		title.setFont(title.getFont().deriveFont(Font.BOLD));

		newPlayerField.setColumns(14);
		newPlayerField.setPreferredSize(dv);
		knownPlayersDropdown.setPreferredSize(dv);
		addAltDropdown.setPreferredSize(dv);

		int row = 0;

		gbc.gridx = 0;
		gbc.gridy = row;
		gbc.gridwidth = 2;
		gbc.weightx = 1.0;
		PlayersPanel.add(title, gbc);
		row++;

		JLabel nameLabel = new JLabel("Name:");
		nameLabel.setPreferredSize(dl);
		nameLabel.setHorizontalAlignment(SwingConstants.RIGHT);

		gbc.gridwidth = 1;
		gbc.gridx = 0;
		gbc.gridy = row;
		gbc.weightx = 0;
		gbc.fill = GridBagConstraints.NONE;
		gbc.anchor = GridBagConstraints.EAST;
		PlayersPanel.add(nameLabel, gbc);

		gbc.gridx = 1;
		gbc.gridy = row;
		gbc.weightx = 1.0;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.anchor = GridBagConstraints.WEST;
		PlayersPanel.add(newPlayerField, gbc);
		row++;

		gbc.gridx = 0;
		gbc.gridy = row;
		gbc.gridwidth = 2;
		gbc.weightx = 1.0;
		gbc.anchor = GridBagConstraints.EAST;
		gbc.fill = GridBagConstraints.NONE;
		btnAddPlayer.setPreferredSize(dv);
		btnAddPlayer.setMinimumSize(dv);
		PlayersPanel.add(btnAddPlayer, gbc);
		row++;

		gbc.gridx = 0;
		gbc.gridy = row;
		gbc.gridwidth = 2;
		gbc.weightx = 1.0;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.anchor = GridBagConstraints.CENTER;
		PlayersPanel.add(new JSeparator(SwingConstants.HORIZONTAL), gbc);
		row++;

		JLabel alterLbl = new JLabel("Alter player info:");
		alterLbl.setHorizontalAlignment(SwingConstants.LEFT);
		gbc.gridx = 0;
		gbc.gridy = row;
		gbc.gridwidth = 2;
		gbc.weightx = 1.0;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.anchor = GridBagConstraints.WEST;
		PlayersPanel.add(alterLbl, gbc);
		row++;

		gbc.gridx = 0;
		gbc.gridy = row;
		gbc.gridwidth = 2;
		gbc.weightx = 1.0;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.anchor = GridBagConstraints.WEST;
		PlayersPanel.add(knownPlayersDropdown, gbc);
		row++;

		gbc.gridx = 0;
		gbc.gridy = row;
		gbc.gridwidth = 2;
		gbc.weightx = 1.0;
		gbc.anchor = GridBagConstraints.EAST;
		gbc.fill = GridBagConstraints.NONE;
		btnRemovePlayer.setPreferredSize(dv);
		btnRemovePlayer.setMinimumSize(dv);
		PlayersPanel.add(btnRemovePlayer, gbc);
		row++;

		gbc.gridx = 0;
		gbc.gridy = row;
		gbc.gridwidth = 2;
		gbc.weightx = 1.0;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.anchor = GridBagConstraints.CENTER;
		PlayersPanel.add(new JSeparator(SwingConstants.HORIZONTAL), gbc);
		row++;

		altsLabel.setHorizontalAlignment(SwingConstants.LEFT);
		gbc.gridx = 0;
		gbc.gridy = row;
		gbc.gridwidth = 2;
		gbc.weightx = 1.0;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.anchor = GridBagConstraints.WEST;
		PlayersPanel.add(altsLabel, gbc);
		row++;

		JScrollPane altsScroll = new JScrollPane(altsList);
		altsScroll.setPreferredSize(lm);
		gbc.gridx = 0;
		gbc.gridy = row;
		gbc.gridwidth = 2;
		gbc.weightx = 1.0;
		gbc.weighty = 1.0;
		gbc.fill = GridBagConstraints.BOTH;
		gbc.anchor = GridBagConstraints.CENTER;
		PlayersPanel.add(altsScroll, gbc);
		row++;

		JLabel addAltLbl = new JLabel("Add alt:");
		addAltLbl.setPreferredSize(dl);
		addAltLbl.setHorizontalAlignment(SwingConstants.RIGHT);

		gbc.gridwidth = 1;
		gbc.weighty = 0;
		gbc.gridx = 0;
		gbc.gridy = row;
		gbc.weightx = 0;
		gbc.fill = GridBagConstraints.NONE;
		gbc.anchor = GridBagConstraints.EAST;
		PlayersPanel.add(addAltLbl, gbc);

		gbc.gridx = 1;
		gbc.gridy = row;
		gbc.weightx = 1.0;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.anchor = GridBagConstraints.WEST;
		PlayersPanel.add(addAltDropdown, gbc);
		row++;

		JPanel altButtonsRow = new JPanel(new GridLayout(1, 2, 6, 0));
		altButtonsRow.add(btnAddAlt);
		altButtonsRow.add(btnRemoveAlt);

		gbc.gridx = 0;
		gbc.gridy = row;
		gbc.gridwidth = 2;
		gbc.weightx = 1.0;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.anchor = GridBagConstraints.CENTER;
		PlayersPanel.add(altButtonsRow, gbc);

		return new DropdownRip("Known player info", PlayersPanel, config.enableTour());
	}

	private JPanel generateSessionPanel()
	{
		JPanel sessionPanel = new JPanel();
		sessionPanel.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createTitledBorder("Session"),
			BorderFactory.createEmptyBorder(3, 3, 3, 3)));
		sessionPanel.setLayout(new GridBagLayout());
		GridBagConstraints g2 = new GridBagConstraints();
		g2.gridx = 0;
		g2.insets = new Insets(3, 3, 3, 3);
		g2.weightx = 1.0;
		g2.fill = GridBagConstraints.HORIZONTAL;
		g2.anchor = GridBagConstraints.CENTER;

		JPanel buttonsHalfHalf = new JPanel(new GridLayout(1, 2, 6, 0));
		buttonsHalfHalf.add(btnStart);
		buttonsHalfHalf.add(btnStop);

		g2.gridy = 0;
		sessionPanel.add(buttonsHalfHalf, g2);

		historyLabel.setHorizontalAlignment(SwingConstants.CENTER);
		g2.gridy = 1;
		sessionPanel.add(historyLabel, g2);

		return sessionPanel;
	}

	private JPanel generateWaitlistPanel()
	{
		JPanel p = new JPanel();
		p.setLayout(new GridBagLayout());
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridx = 0;
		gbc.gridy = 0;
		gbc.gridwidth = 1;
		gbc.weightx = 1.0;
		gbc.fill = GridBagConstraints.BOTH;
		waitlistTable.setFillsViewportHeight(true);
		waitlistTable.setRowHeight(22);
		waitlistTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		JScrollPane sc = new JScrollPane(waitlistTable);
		sc.setPreferredSize(lm);
		p.add(sc, gbc);

		JPanel btns = new JPanel(new GridLayout(1, 2, 6, 0));
		btns.add(btnWaitlistAdd);
		btns.add(btnWaitlistDelete);
		gbc.gridx = 0;
		gbc.gridy = 1;
		gbc.gridwidth = 2;
		gbc.weightx = 1.0;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.insets = new Insets(3, 0, 0, 0);
		p.add(btns, gbc);

		waitlistTableModel.addTableModelListener(e -> {
			if (waitlistTable.getRowCount() > 0)
			{
				waitlistTable.getSelectionModel().setSelectionInterval(0, 0);
			}
			else
			{
				waitlistTable.clearSelection();
			}
		});
		if (waitlistTable.getRowCount() > 0)
		{
			waitlistTable.getSelectionModel().setSelectionInterval(0, 0);
		}
		return p;
	}

	private JComponent generateWaitlistPanelCollapsible()
	{
		JPanel content = new JPanel(new BorderLayout());
		content.add(generateWaitlistPanel(), BorderLayout.CENTER);
		detectedValuesDropdown = new DropdownRip("Detected values", content, config.enableTour());
		return detectedValuesDropdown;
	}

	private JComponent generateRecentSplitsPanel()
	{
		JScrollPane scroller = new JScrollPane(recentSplitsTable);
		scroller.setPreferredSize(new Dimension(0, 140));
		return new DropdownRip("Recent splits", scroller, config.enableTour());
	}

	private JComponent generateMetrics()
	{
		JPanel wrapper = new JPanel(new BorderLayout(0, 6));
		JLabel title = new JLabel("Settlement");
		title.setFont(title.getFont().deriveFont(Font.BOLD));

		boolean direct = config.directPayments();
		String explanation = direct
			? "Direct payments mode: negatives pay positives directly. We'll suggest who pays whom below."
			: (config.flipSettlementSign()
			? "Middleman mode (flipped): positive Split means you pay the bank; negative means the bank pays you."
			: "Middleman mode: negative Split means you pay the bank; positive means the bank pays you.");
		JTextArea desc = new JTextArea(explanation);
		desc.setEditable(false);
		desc.setLineWrap(true);
		desc.setWrapStyleWord(true);

		JPanel header = new JPanel(new BorderLayout());
		header.add(title, BorderLayout.NORTH);
		header.add(desc, BorderLayout.CENTER);

		btnCopyJson = new JButton("Copy JSON");
		btnCopyJson.addActionListener(e -> {
			if (actions != null)
			{
				actions.copyMetricsJson();
			}
			else
			{
				copyMetricsJsonToClipboard();
			}
		});
		btnCopyMd = new JButton("Copy MD");
		btnCopyMd.addActionListener(e -> {
			if (actions != null)
			{
				actions.copyMetricsMarkdown();
			}
			else
			{
				copyMetricsMarkdownToClipboard();
			}
		});

		wrapper.add(header, BorderLayout.NORTH);

		metricsTable.setFillsViewportHeight(true);
		metricsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);

		((Metrics) metricsTable.getModel()).setHideTotalColumn(true);
		refreshMetrics();

		int colCount = metricsTable.getColumnModel().getColumnCount();
		if (colCount > 0)
		{
			int actionColViewIndex = colCount - 1;
			int nonActionCols = Math.max(1, colCount - 1);
			int tableWidth = Math.max(metricsTable.getWidth(), 1);
			int equalWidth = (int) (tableWidth * (1.0 / nonActionCols));
			for (int i = 0; i < colCount; i++)
			{
				if (i == actionColViewIndex)
				{
					continue;
				}
				metricsTable.getColumnModel().getColumn(i).setPreferredWidth(equalWidth);
			}
			metricsTable.getColumnModel().getColumn(actionColViewIndex).setMaxWidth(40);
			metricsTable.getColumnModel().getColumn(actionColViewIndex).setMinWidth(40);
			metricsTable.getColumnModel().getColumn(actionColViewIndex).setPreferredWidth(40);
		}

		javax.swing.table.DefaultTableCellRenderer greyingRenderer = new javax.swing.table.DefaultTableCellRenderer()
		{
			@Override
			public java.awt.Component getTableCellRendererComponent(JTable table, Object value,
																	boolean isSelected, boolean hasFocus,
																	int row, int column)
			{
				java.awt.Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
				Metrics model = (Metrics) table.getModel();
				boolean active = model.isRowActive(row);
				if (!isSelected)
				{
					c.setForeground(active ? table.getForeground() : java.awt.Color.GRAY);
				}
				return c;
			}
		};
		try
		{
			int playerIdx = metricsTable.getColumnModel().getColumnIndex("Player");
			metricsTable.getColumnModel().getColumn(playerIdx).setCellRenderer(greyingRenderer);
		}
		catch (IllegalArgumentException ignored)
		{
		}
		try
		{
			int totalIdx = metricsTable.getColumnModel().getColumnIndex("Total");
			metricsTable.getColumnModel().getColumn(totalIdx).setCellRenderer(greyingRenderer);
		}
		catch (IllegalArgumentException ignored)
		{
		}

		javax.swing.table.DefaultTableCellRenderer splitRenderer = new javax.swing.table.DefaultTableCellRenderer()
		{
			@Override
			public java.awt.Component getTableCellRendererComponent(JTable table, Object value,
																	boolean isSelected, boolean hasFocus,
																	int row, int column)
			{
				Metrics model = (Metrics) table.getModel();
				boolean active = model.isRowActive(row);
				long raw = model.getRawSplitAt(row);
				long disp = raw;
				if (!config.directPayments() && config.flipSettlementSign())
				{
					disp = -raw;
				}
				java.awt.Component c = super.getTableCellRendererComponent(table,
					Formats.OsrsAmountFormatter.toSuffixString(disp, 'k'), isSelected, hasFocus, row, column);
				if (!isSelected)
				{
					c.setForeground(active ? table.getForeground() : java.awt.Color.GRAY);
				}
				setHorizontalAlignment(SwingConstants.RIGHT);
				return c;
			}
		};
		try
		{
			int splitIdx = metricsTable.getColumnModel().getColumnIndex("Split");
			metricsTable.getColumnModel().getColumn(splitIdx).setCellRenderer(splitRenderer);
		}
		catch (IllegalArgumentException ignored)
		{
		}

		try
		{
			int actionIdx = metricsTable.getColumnModel().getColumnIndex("X");
			metricsTable.getColumnModel().getColumn(actionIdx)
				.setCellEditor(new RemoveButtonEditor(this, sessionManager, metricsTable, actions));
		}
		catch (IllegalArgumentException ignored)
		{
		}

		JComponent centerContent;
		if (direct)
		{
			Session currentSession = sessionManager.getCurrentSession().orElse(null);
			List<PlayerMetrics> data = sessionManager.computeMetricsFor(currentSession, true);
			List<Transfer> transfers = PaymentProcessor.computeDirectPaymentsStructured(data);

			if (transfers != null && !transfers.isEmpty())
			{
				javax.swing.table.DefaultTableModel txModel =
					new javax.swing.table.DefaultTableModel(new Object[]{"Suggested direct payments"}, 0)
					{
						@Override
						public boolean isCellEditable(int r, int c)
						{
							return false;
						}
					};

				for (Transfer t : transfers)
				{
					String payerShort = shortenName(t.getFrom(), 7);
					String payeeShort = shortenName(t.getTo(), 7);
					String amountStr = toSuffixString(Math.abs(t.getAmount()), config.defaultValueMultiplier().getValue());
					String display = payerShort + " -> " + payeeShort + ": " + amountStr;
					txModel.addRow(new Object[]{display});
				}

				JTable txTable = new JTable(txModel);
				txTable.setFillsViewportHeight(true);
				txTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
				txTable.setRowSelectionAllowed(false);
				txTable.setShowGrid(false);

				JScrollPane txScroll = new JScrollPane(txTable);
				txScroll.setPreferredSize(ll);
				centerContent = txScroll;
			}
			else
			{
				JScrollPane tableScroll = new JScrollPane(metricsTable);
				tableScroll.setPreferredSize(ll);
				centerContent = tableScroll;
			}
		}
		else
		{
			JScrollPane tableScroll = new JScrollPane(metricsTable);
			tableScroll.setPreferredSize(ll);
			centerContent = tableScroll;
		}

		wrapper.add(centerContent, BorderLayout.CENTER);

		JPanel btns = new JPanel(new GridLayout(1, 2, 6, 0));
		btns.add(btnCopyJson);
		btns.add(btnCopyMd);
		wrapper.add(btns, BorderLayout.SOUTH);

		return new DropdownRip("Settlement information", wrapper);
	}

	private void refreshMetrics()
	{
		Session currentSession = sessionManager.getCurrentSession().orElse(null);
		((Metrics) metricsTable.getModel()).setData(sessionManager.computeMetricsFor(currentSession, true));
	}

	private void copyMetricsJsonToClipboard()
	{
		String payload = MarkdownFormatter.buildMetricsJson(sessionManager);
		StringSelection selection = new StringSelection(payload);
		java.awt.Toolkit.getDefaultToolkit().getSystemClipboard().setContents(selection, selection);
	}

	private void copyMetricsMarkdownToClipboard()
	{
		String payload = MarkdownFormatter.buildMetricsMarkdown(
			sessionManager.computeMetricsFor(
				sessionManager.getCurrentSession().orElse(null), true), config);
		StringSelection selection = new StringSelection(payload);
		java.awt.Toolkit.getDefaultToolkit().getSystemClipboard().setContents(selection, selection);
	}
}

package com.splitmanager.views;

import com.splitmanager.ManagerKnownPlayers;
import com.splitmanager.ManagerSession;
import com.splitmanager.PluginConfig;
import com.splitmanager.controllers.PanelController;

public class PopoutView extends PanelView
{
	public PopoutView(ManagerSession sessionManager, PluginConfig config, ManagerKnownPlayers playerManager, PanelController controller)
	{
		super(sessionManager, config, playerManager, controller);
	}
}

package com.example;

import com.splitmanager.ManagerPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ManagerPlugin.class);
		RuneLite.main(args);
	}
}
