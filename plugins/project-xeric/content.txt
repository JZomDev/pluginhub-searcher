package io.septem150.xeric.util;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class ImageCoord {
  public final int archive;
  public final int file;
}

package io.septem150.xeric.util;

import com.google.common.collect.Sets;
import java.util.Set;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.WorldType;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public class WorldUtil {
  private static final Set<WorldType> invalidWorldTypes =
      Set.of(
          WorldType.NOSAVE_MODE,
          WorldType.BETA_WORLD,
          WorldType.FRESH_START_WORLD,
          WorldType.DEADMAN,
          WorldType.PVP_ARENA,
          WorldType.QUEST_SPEEDRUNNING,
          WorldType.SEASONAL,
          WorldType.TOURNAMENT_WORLD);

  public static boolean isValidWorldType(Client client) {
    if (!client.isClientThread()) {
      return false;
    }
    return Sets.intersection(invalidWorldTypes, client.getWorldType()).isEmpty();
  }
}

/*
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.septem150.xeric.util;

import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Adapts values whose runtime type may differ from their declaration type. This is necessary when a
 * field's type is not the same type that GSON should create when deserializing that field. For
 * example, consider these types:
 *
 * <pre>{@code
 * abstract class Shape {
 *   int x;
 *   int y;
 * }
 * class Circle extends Shape {
 *   int radius;
 * }
 * class Rectangle extends Shape {
 *   int width;
 *   int height;
 * }
 * class Diamond extends Shape {
 *   int width;
 *   int height;
 * }
 * class Drawing {
 *   Shape bottomShape;
 *   Shape topShape;
 * }
 * }</pre>
 *
 * <p>Without additional type information, the serialized JSON is ambiguous. Is the bottom shape in
 * this drawing a rectangle or a diamond?
 *
 * <pre>{@code
 * {
 *   "bottomShape": {
 *     "width": 10,
 *     "height": 5,
 *     "x": 0,
 *     "y": 0
 *   },
 *   "topShape": {
 *     "radius": 2,
 *     "x": 4,
 *     "y": 1
 *   }
 * }
 * }</pre>
 *
 * This class addresses this problem by adding type information to the serialized JSON and honoring
 * that type information when the JSON is deserialized:
 *
 * <pre>{@code
 * {
 *   "bottomShape": {
 *     "type": "Diamond",
 *     "width": 10,
 *     "height": 5,
 *     "x": 0,
 *     "y": 0
 *   },
 *   "topShape": {
 *     "type": "Circle",
 *     "radius": 2,
 *     "x": 4,
 *     "y": 1
 *   }
 * }
 * }</pre>
 *
 * Both the type field name ({@code "type"}) and the type labels ({@code "Rectangle"}) are
 * configurable.
 *
 * <h2>Registering Types</h2>
 *
 * Create a {@code RuntimeTypeAdapterFactory} by passing the base type and type field name to the
 * {@link #of} factory method. If you don't supply an explicit type field name, {@code "type"} will
 * be used.
 *
 * <pre>{@code
 * RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory
 *     = RuntimeTypeAdapterFactory.of(Shape.class, "type");
 * }</pre>
 *
 * Next register all of your subtypes. Every subtype must be explicitly registered. This protects
 * your application from injection attacks. If you don't supply an explicit type label, the type's
 * simple name will be used.
 *
 * <pre>{@code
 * shapeAdapterFactory.registerSubtype(Rectangle.class, "Rectangle");
 * shapeAdapterFactory.registerSubtype(Circle.class, "Circle");
 * shapeAdapterFactory.registerSubtype(Diamond.class, "Diamond");
 * }</pre>
 *
 * Finally, register the type adapter factory in your application's GSON builder:
 *
 * <pre>{@code
 * Gson gson = new GsonBuilder()
 *     .registerTypeAdapterFactory(shapeAdapterFactory)
 *     .create();
 * }</pre>
 *
 * Like {@code GsonBuilder}, this API supports chaining:
 *
 * <pre>{@code
 * RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory = RuntimeTypeAdapterFactory.of(Shape.class)
 *     .registerSubtype(Rectangle.class)
 *     .registerSubtype(Circle.class)
 *     .registerSubtype(Diamond.class);
 * }</pre>
 *
 * <h2>Serialization and deserialization</h2>
 *
 * In order to serialize and deserialize a polymorphic object, you must specify the base type
 * explicitly.
 *
 * <pre>{@code
 * Diamond diamond = new Diamond();
 * String json = gson.toJson(diamond, Shape.class);
 * }</pre>
 *
 * And then:
 *
 * <pre>{@code
 * Shape shape = gson.fromJson(json, Shape.class);
 * }</pre>
 */
public final class RuntimeTypeAdapterFactory<T> implements TypeAdapterFactory {
  private final Class<?> baseType;
  private final String typeFieldName;
  private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<>();
  private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<>();
  private final boolean maintainType;
  private boolean recognizeSubtypes;

  private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName, boolean maintainType) {
    if (typeFieldName == null || baseType == null) {
      throw new NullPointerException();
    }
    this.baseType = baseType;
    this.typeFieldName = typeFieldName;
    this.maintainType = maintainType;
  }

  /**
   * Creates a new runtime type adapter for {@code baseType} using {@code typeFieldName} as the type
   * field name. Type field names are case sensitive.
   *
   * @param maintainType true if the type field should be included in deserialized objects
   */
  public static <T> RuntimeTypeAdapterFactory<T> of(
      Class<T> baseType, String typeFieldName, boolean maintainType) {
    return new RuntimeTypeAdapterFactory<>(baseType, typeFieldName, maintainType);
  }

  /**
   * Creates a new runtime type adapter for {@code baseType} using {@code typeFieldName} as the type
   * field name. Type field names are case sensitive.
   */
  public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName) {
    return new RuntimeTypeAdapterFactory<>(baseType, typeFieldName, false);
  }

  /**
   * Creates a new runtime type adapter for {@code baseType} using {@code "type"} as the type field
   * name.
   */
  public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType) {
    return new RuntimeTypeAdapterFactory<>(baseType, "type", false);
  }

  /**
   * Ensures that this factory will handle not just the given {@code baseType}, but any subtype of
   * that type.
   */
  @CanIgnoreReturnValue
  public RuntimeTypeAdapterFactory<T> recognizeSubtypes() {
    this.recognizeSubtypes = true;
    return this;
  }

  /**
   * Registers {@code type} identified by {@code label}. Labels are case sensitive.
   *
   * @throws IllegalArgumentException if either {@code type} or {@code label} have already been
   *     registered on this type adapter.
   */
  @CanIgnoreReturnValue
  public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type, String label) {
    if (type == null || label == null) {
      throw new NullPointerException();
    }
    if (subtypeToLabel.containsKey(type) || labelToSubtype.containsKey(label)) {
      throw new IllegalArgumentException("types and labels must be unique");
    }
    labelToSubtype.put(label, type);
    subtypeToLabel.put(type, label);
    return this;
  }

  /**
   * Registers {@code type} identified by its {@link Class#getSimpleName simple name}. Labels are
   * case sensitive.
   *
   * @throws IllegalArgumentException if either {@code type} or its simple name have already been
   *     registered on this type adapter.
   */
  @CanIgnoreReturnValue
  public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type) {
    return registerSubtype(type, type.getSimpleName());
  }

  @Override
  public <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {
    if (type == null) {
      return null;
    }
    Class<?> rawType = type.getRawType();
    boolean handle =
        recognizeSubtypes ? baseType.isAssignableFrom(rawType) : baseType.equals(rawType);
    if (!handle) {
      return null;
    }

    TypeAdapter<JsonElement> jsonElementAdapter = gson.getAdapter(JsonElement.class);
    Map<String, TypeAdapter<?>> labelToDelegate = new LinkedHashMap<>();
    Map<Class<?>, TypeAdapter<?>> subtypeToDelegate = new LinkedHashMap<>();
    for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {
      TypeAdapter<?> delegate = gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));
      labelToDelegate.put(entry.getKey(), delegate);
      subtypeToDelegate.put(entry.getValue(), delegate);
    }

    return new TypeAdapter<R>() {
      @Override
      public R read(JsonReader in) throws IOException {
        JsonElement jsonElement = jsonElementAdapter.read(in);
        JsonElement labelJsonElement;
        if (maintainType) {
          labelJsonElement = jsonElement.getAsJsonObject().get(typeFieldName);
        } else {
          labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);
        }

        if (labelJsonElement == null) {
          throw new JsonParseException(
              "cannot deserialize "
                  + baseType
                  + " because it does not define a field named "
                  + typeFieldName);
        }
        String label = labelJsonElement.getAsString();
        @SuppressWarnings("unchecked") // registration requires that subtype extends T
        TypeAdapter<R> delegate = (TypeAdapter<R>) labelToDelegate.get(label);
        if (delegate == null) {
          throw new JsonParseException(
              "cannot deserialize "
                  + baseType
                  + " subtype named "
                  + label
                  + "; did you forget to register a subtype?");
        }
        return delegate.fromJsonTree(jsonElement);
      }

      @Override
      public void write(JsonWriter out, R value) throws IOException {
        Class<?> srcType = value.getClass();
        String label = subtypeToLabel.get(srcType);
        @SuppressWarnings("unchecked") // registration requires that subtype extends T
        TypeAdapter<R> delegate = (TypeAdapter<R>) subtypeToDelegate.get(srcType);
        if (delegate == null) {
          throw new JsonParseException(
              "cannot serialize " + srcType.getName() + "; did you forget to register a subtype?");
        }
        JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();

        if (maintainType) {
          jsonElementAdapter.write(out, jsonObject);
          return;
        }

        JsonObject clone = new JsonObject();

        if (jsonObject.has(typeFieldName)) {
          throw new JsonParseException(
              "cannot serialize "
                  + srcType.getName()
                  + " because it already defines a field named "
                  + typeFieldName);
        }
        clone.add(typeFieldName, new JsonPrimitive(label));

        for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {
          clone.add(e.getKey(), e.getValue());
        }
        jsonElementAdapter.write(out, clone);
      }
    }.nullSafe();
  }
}

package io.septem150.xeric.util;

import io.septem150.xeric.ProjectXericPlugin;
import java.awt.image.BufferedImage;
import lombok.NonNull;
import net.runelite.client.util.ImageUtil;

public class ResourceUtil {
  private ResourceUtil() {}

  public static BufferedImage getImage(@NonNull String name) {
    String imagePath = name;
    if (!name.startsWith("/")) {
      imagePath = String.format("images/%s", imagePath);
    }
    return ImageUtil.loadImageResource(ProjectXericPlugin.class, imagePath);
  }

  public static BufferedImage getImage(@NonNull String name, int width, int height) {
    return getImage(name, width, height, false);
  }

  public static BufferedImage getImage(
      @NonNull String name, int width, int height, boolean preserveAspectRatio) {
    BufferedImage image = getImage(name);
    return ImageUtil.resizeImage(image, width, height, preserveAspectRatio);
  }
}

package io.septem150.xeric.util;

import java.util.regex.Pattern;
import lombok.AccessLevel;
import lombok.NoArgsConstructor;

@NoArgsConstructor(access = AccessLevel.PRIVATE)
public class RegexUtil {
  public static final String ID_GROUP = "id";
  public static final String NAME_GROUP = "name";
  public static final String COUNT_GROUP = "count";
  public static final Pattern CLOG_REGEX =
      Pattern.compile("New item added to your collection log: (?<" + NAME_GROUP + ">.*)");
  public static final Pattern COMBAT_TASK_REGEX =
      Pattern.compile(
          "CA_ID:(?<"
              + ID_GROUP
              + ">[0-9,]+)\\|Congratulations, you've completed an? \\w+ combat task:"
              + " .+? \\([0-9,]+ points?\\)\\.");
  public static final Pattern DIARY_REGEX =
      Pattern.compile(
          "Well done! You have completed an? \\w+ task in the .* area\\. Your Achievement"
              + " Diary has been updated\\.");
  public static final Pattern KC_REGEX =
      Pattern.compile(
          "Your (?:subdued |completed )?(?<"
              + NAME_GROUP
              + ">.+?) (?:kill |success )?count is:"
              + " (?<"
              + COUNT_GROUP
              + ">[0-9,]+)\\.");
  public static final Pattern DELVE_KC_REGEX =
      Pattern.compile("Deep delves completed: (?<" + COUNT_GROUP + ">[0-9,]+)");
  public static final Pattern CLUE_REGEX =
      Pattern.compile(
          "You have completed (?<"
              + COUNT_GROUP
              + ">[0-9,]+) (?<"
              + NAME_GROUP
              + ">.*) Treasure Trails?\\.");
  public static final Pattern QUEST_REGEX =
      Pattern.compile("Congratulations, you've completed a quest:.*");
}

/*
 * Copyright (c) 2019, Alexsuperfly <https://github.com/Alexsuperfly>
 * Copyright (c) 2019, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.septem150.xeric.util;

import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.image.BufferedImage;
import lombok.AllArgsConstructor;
import lombok.NonNull;

/**
 * Taken from: <a
 * href="https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/util/TransferableBufferedImage.java">TransferableBufferedImage</a>
 *
 * <p>Changes: - made class public, since it was package protected. - added @NonNull annotation to
 * {@link #getTransferData(DataFlavor)}
 */
@AllArgsConstructor
public class TransferableBufferedImage implements Transferable {
  @NonNull private final BufferedImage image;

  @Override
  public @NonNull Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException {
    if (flavor.equals(DataFlavor.imageFlavor)) {
      return image;
    } else {
      throw new UnsupportedFlavorException(flavor);
    }
  }

  @Override
  public DataFlavor[] getTransferDataFlavors() {
    return new DataFlavor[] {DataFlavor.imageFlavor};
  }

  @Override
  public boolean isDataFlavorSupported(DataFlavor flavor) {
    return flavor.equals(DataFlavor.imageFlavor);
  }
}

package io.septem150.xeric.data.diary;

import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum KourendDiary {
  @SerializedName("Easy")
  KOUREND_EASY(7933, 7925),
  @SerializedName("Medium")
  KOUREND_MEDIUM(7934, 7926),
  @SerializedName("Hard")
  KOUREND_HARD(7935, 7927),
  @SerializedName("Elite")
  KOUREND_ELITE(7936, 7928);

  private final int countVarb;
  private final int completedVarb;
}

package io.septem150.xeric.data.diary;

import java.util.List;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.ToString;

@AllArgsConstructor
@Getter
@Setter
@EqualsAndHashCode
@ToString
public class DiaryProgress {
  @NonNull private final KourendDiary diary;
  @EqualsAndHashCode.Exclude private int count;
  @EqualsAndHashCode.Exclude private boolean completed;

  public static final List<KourendDiary> TRACKED_DIARIES =
      List.of(
          KourendDiary.KOUREND_EASY,
          KourendDiary.KOUREND_MEDIUM,
          KourendDiary.KOUREND_HARD,
          KourendDiary.KOUREND_ELITE);
}

package io.septem150.xeric.data.clog;

import com.google.common.collect.ImmutableSet;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.gson.Gson;
import com.google.gson.JsonParseException;
import io.septem150.xeric.ProjectXericConfig;
import java.io.Serializable;
import java.time.Instant;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;

@Slf4j
public class CollectionLog {
  // Clog Constants
  public static final int COLLECTION_LOG_SETUP_SCRIPT_ID = 7797;
  public static final int COLLECTION_LOG_TRANSMIT_SCRIPT_ID = 4100;

  public static final int CLOG_TOP_TABS_ENUM_ID = 2102;
  public static final int CLOG_SUB_TABS_PARAM_ID = 683;
  public static final int CLOG_SUB_TAB_ITEMS_PARAM_ID = 690;
  public static final int ITEM_REPLACEMENT_MAPPING_ENUM_ID = 3721;
  public static final List<Integer> UNUSED_PROSPECTOR_ITEM_IDS =
      List.of(29472, 29474, 29476, 29478);

  @NonNull private final Client client;
  @NonNull private final ConfigManager configManager;
  @NonNull private final Gson gson;

  @Getter @Setter private boolean interfaceOpened = false;
  @Getter @NonNull private Instant lastUpdated = Instant.EPOCH;
  private final Set<ClogItem> items = new HashSet<>();

  public CollectionLog(Client client, ConfigManager configManager, Gson gson) {
    this.client = client;
    this.configManager = configManager;
    this.gson = gson;
  }

  @CanIgnoreReturnValue
  public boolean add(@Nullable ClogItem item) {
    if (item == null) return false;
    final boolean added = items.add(item);
    if (added) lastUpdated = Instant.now();
    return added;
  }

  public void reset() {
    items.clear();
    lastUpdated = Instant.EPOCH;
  }

  public @NonNull ImmutableSet<ClogItem> getItems() {
    return ImmutableSet.copyOf(items);
  }

  public void saveToRSProfile() {
    configManager.setRSProfileConfiguration(
        ProjectXericConfig.GROUP,
        ProjectXericConfig.CLOG_DATA_KEY,
        gson.toJson(
            new RSProfileClog(
                lastUpdated, items.stream().map(ClogItem::getId).collect(Collectors.toSet()))));
  }

  public void loadFromRSProfile() {
    try {
      boolean updatedFromProfile =
          fromRSProfileJson(
              configManager.getRSProfileConfiguration(
                  ProjectXericConfig.GROUP, ProjectXericConfig.CLOG_DATA_KEY));

      if (!updatedFromProfile) {
        saveToRSProfile();
      }
    } catch (JsonParseException err) {
      log.error("malformed clog data in profile");
      configManager.unsetRSProfileConfiguration(
          ProjectXericConfig.GROUP, ProjectXericConfig.CLOG_DATA_KEY);
    }
  }

  @CanIgnoreReturnValue
  private boolean fromRSProfileJson(@Nullable String json) throws JsonParseException {
    if (json == null) return false;
    RSProfileClog profileClog = gson.fromJson(json, RSProfileClog.class);
    if (lastUpdated.isBefore(profileClog.lastUpdated)) {
      lastUpdated = profileClog.lastUpdated;
      items.clear();
      for (int itemId : profileClog.itemIds) {
        ClogItem clogItem = new ClogItem(itemId, client.getItemDefinition(itemId).getMembersName());
        items.add(clogItem);
      }
      return true;
    }
    return false;
  }

  @RequiredArgsConstructor
  private static class RSProfileClog implements Serializable {
    private final Instant lastUpdated;
    private final Set<Integer> itemIds;
  }
}

package io.septem150.xeric.data.clog;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.ToString;

@RequiredArgsConstructor
@Getter
@EqualsAndHashCode
@ToString
public class ClogItem {
  private final int id;
  @NonNull private final String name;
}

package io.septem150.xeric.data;

import static io.septem150.xeric.data.clog.CollectionLog.CLOG_SUB_TABS_PARAM_ID;
import static io.septem150.xeric.data.clog.CollectionLog.CLOG_SUB_TAB_ITEMS_PARAM_ID;
import static io.septem150.xeric.data.clog.CollectionLog.CLOG_TOP_TABS_ENUM_ID;
import static io.septem150.xeric.data.clog.CollectionLog.COLLECTION_LOG_SETUP_SCRIPT_ID;
import static io.septem150.xeric.data.clog.CollectionLog.COLLECTION_LOG_TRANSMIT_SCRIPT_ID;
import static io.septem150.xeric.data.clog.CollectionLog.ITEM_REPLACEMENT_MAPPING_ENUM_ID;
import static io.septem150.xeric.data.clog.CollectionLog.UNUSED_PROSPECTOR_ITEM_IDS;
import static io.septem150.xeric.data.player.CombatAchievement.CA_STRUCT_ID_PARAM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.CA_STRUCT_NAME_PARAM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.CA_STRUCT_TIER_PARAM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.EASY_TIER_ENUM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.ELITE_TIER_ENUM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.GM_TIER_ENUM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.HARD_TIER_ENUM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.MASTER_TIER_ENUM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.MEDIUM_TIER_ENUM_ID;
import static io.septem150.xeric.util.RegexUtil.CLOG_REGEX;
import static io.septem150.xeric.util.RegexUtil.CLUE_REGEX;
import static io.septem150.xeric.util.RegexUtil.COMBAT_TASK_REGEX;
import static io.septem150.xeric.util.RegexUtil.COUNT_GROUP;
import static io.septem150.xeric.util.RegexUtil.DELVE_KC_REGEX;
import static io.septem150.xeric.util.RegexUtil.DIARY_REGEX;
import static io.septem150.xeric.util.RegexUtil.ID_GROUP;
import static io.septem150.xeric.util.RegexUtil.KC_REGEX;
import static io.septem150.xeric.util.RegexUtil.NAME_GROUP;
import static io.septem150.xeric.util.RegexUtil.QUEST_REGEX;

import com.google.common.collect.Sets;
import com.google.common.net.HttpHeaders;
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.reflect.TypeToken;
import io.septem150.xeric.ProjectXericConfig;
import io.septem150.xeric.data.clog.ClogItem;
import io.septem150.xeric.data.diary.DiaryProgress;
import io.septem150.xeric.data.diary.KourendDiary;
import io.septem150.xeric.data.player.AccountType;
import io.septem150.xeric.data.player.CombatAchievement;
import io.septem150.xeric.data.player.KillCount;
import io.septem150.xeric.data.player.Level;
import io.septem150.xeric.data.player.PlayerInfo;
import io.septem150.xeric.data.player.QuestProgress;
import io.septem150.xeric.data.task.KCTask;
import io.septem150.xeric.data.task.Task;
import io.septem150.xeric.data.task.TaskType;
import io.septem150.xeric.panel.ProjectXericPanel;
import io.septem150.xeric.util.WorldUtil;
import java.awt.Color;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.GameState;
import net.runelite.api.ItemComposition;
import net.runelite.api.MenuAction;
import net.runelite.api.Quest;
import net.runelite.api.Skill;
import net.runelite.api.StructComposition;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.hiscore.HiscoreManager;
import net.runelite.client.hiscore.HiscoreResult;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;

@Slf4j
@Singleton
public class ProjectXericManager {
  public static final Color DARK_GREEN = Color.decode("#006600");

  private final Client client;
  private final ClientThread clientThread;
  private final ProjectXericConfig config;
  private final ConfigManager configManager;
  private final ScheduledExecutorService executor;
  private final OkHttpClient httpClient;
  private final HiscoreManager hiscoreManager;
  private final Gson gson;
  private final PlayerInfo playerInfo;

  private ProjectXericPanel panel;

  private Map<Integer, CombatAchievement> allCombatAchievements;
  private Map<Integer, ClogItem> allItemsById;
  private Map<String, ClogItem> allItemsByName;
  private Set<TaskType> pendingUpdates;
  private int ticksTilUpdate;
  private int ticksTilClientReady;

  @Inject
  public ProjectXericManager(
      Client client,
      ClientThread clientThread,
      ProjectXericConfig config,
      ConfigManager configManager,
      ScheduledExecutorService executor,
      OkHttpClient httpClient,
      HiscoreManager hiscoreManager,
      @Named("xericGson") Gson gson,
      PlayerInfo playerInfo) {
    this.client = client;
    this.clientThread = clientThread;
    this.config = config;
    this.configManager = configManager;
    this.executor = executor;
    this.httpClient = httpClient;
    this.hiscoreManager = hiscoreManager;
    this.gson = gson;
    this.playerInfo = playerInfo;
  }

  public void startUp(ProjectXericPanel panel) {
    this.panel = panel;
    ticksTilClientReady = 2;
    ticksTilUpdate = 0;
    pendingUpdates = new HashSet<>();
    panel.startUp();
    SwingUtilities.invokeLater(panel::refresh);
    // handle login as soon as possible from client in case
    // the player is logged in when installing or starting the plugin
    clientThread.invokeLater(
        () -> {
          if (client.getGameState() == GameState.LOGGED_IN && WorldUtil.isValidWorldType(client))
            handleLogin();
        });
    log.info("{} started!", ProjectXericConfig.NAME);
  }

  public void shutDown() {
    playerInfo.reset();
    ticksTilClientReady = 2;
    ticksTilUpdate = 0;
    pendingUpdates = null;
    allItemsById = null;
    allItemsByName = null;
    allCombatAchievements = null;
    panel.shutDown();
    log.info("{} stopped!", ProjectXericConfig.NAME);
  }

  private void handleLogin() {
    // synchronous operations that can be handled directly on client thread
    updateAccountInfo();
    updateClientCache();
    checkClogChatMessageEnabled();
    playerInfo.loadClogFromRSProfile();
    updateCombatAchievements();
    loadSkillLevels();
    updateQuests();
    updateDiaries();
    // asynchronous operations
    updatePlayerHiscores()
        .thenCompose(unused -> updateTaskCacheAsync())
        .thenRun(
            () ->
                clientThread.invoke(
                    () -> {
                      // compare new task list to the last task list used and notify user
                      // if there's been updates to the tasks or if new ones have been added
                      if (playerInfo.checkForUpdatedTasks()) {
                        playerInfo.clearCompletedTasks();
                        pendingUpdates.addAll(Set.of(TaskType.values()));
                        updateXericTasks(false);
                      } else {
                        playerInfo.loadTasksFromRSProfile();
                        scheduleUpdate(0, Set.of(TaskType.values()));
                      }
                      panel.startUpChildren();
                      SwingUtilities.invokeLater(panel::refresh);
                    }));
  }

  private void handleLogout() {
    playerInfo.logout();
    ticksTilClientReady = 2;
  }

  private void scheduleUpdate(int tickDelay, Set<TaskType> taskTypes) {
    ticksTilUpdate = ticksTilUpdate > 0 ? ticksTilUpdate : Math.max(0, tickDelay);
    pendingUpdates.addAll(taskTypes);
  }

  @Subscribe
  void onGameStateChanged(GameStateChanged event) {
    if (!playerInfo.isLoggedIn() && event.getGameState() == GameState.LOGGED_IN) {
      clientThread.invokeLater(
          () -> {
            if (ticksTilClientReady > 0) return false;
            if (client.getGameState() == GameState.LOGGED_IN && WorldUtil.isValidWorldType(client))
              handleLogin();
            return true;
          });
    } else if (playerInfo.isLoggedIn() && event.getGameState() == GameState.LOGIN_SCREEN) {
      handleLogout();
    } else if (event.getGameState() == GameState.HOPPING) {
      // wait 2 ticks after hopping before checking varbits and statchanges
      ticksTilClientReady = 2;
    }
  }

  @Subscribe
  void onGameTick(GameTick event) {
    if (ticksTilClientReady > 0) {
      ticksTilClientReady--;
      return;
    }
    if (ticksTilUpdate > 0) {
      ticksTilUpdate--;
      return;
    }
    if (pendingUpdates.isEmpty()) return;
    boolean updated = updateXericTasks();
    if (updated) {
      SwingUtilities.invokeLater(panel::refresh);
    }
  }

  @Subscribe
  void onChatMessage(ChatMessage event) {
    if (event.getType() != ChatMessageType.GAMEMESSAGE) return;
    String message = Text.removeTags(event.getMessage());
    Matcher caTaskMatcher = COMBAT_TASK_REGEX.matcher(message);
    if (caTaskMatcher.matches()) {
      int id = Integer.parseInt(caTaskMatcher.group(ID_GROUP).replace(",", ""));
      playerInfo.addCombatAchievement(id, allCombatAchievements.get(id));
      scheduleUpdate(0, Set.of(TaskType.CA));
      return;
    }
    Matcher diaryMatcher = DIARY_REGEX.matcher(message);
    if (diaryMatcher.matches()) {
      updateDiaries();
      scheduleUpdate(0, Set.of(TaskType.DIARY));
      return;
    }
    Matcher questMatcher = QUEST_REGEX.matcher(message);
    if (questMatcher.matches()) {
      updateQuests();
      scheduleUpdate(0, Set.of(TaskType.QUEST));
    }
    Matcher kcMatcher = KC_REGEX.matcher(message);
    if (kcMatcher.matches()) {
      String name = KCTask.fixBossName(kcMatcher.group(NAME_GROUP));
      int count = Integer.parseInt(kcMatcher.group(COUNT_GROUP).replace(",", ""));
      playerInfo.addHiscore(name, new KillCount(name, count));
      scheduleUpdate(0, Set.of(TaskType.HISCORE));
      return;
    }
    Matcher clueMatcher = CLUE_REGEX.matcher(message);
    if (clueMatcher.matches()) {
      String name = KCTask.fixBossName(clueMatcher.group(NAME_GROUP));
      int count = Integer.parseInt(clueMatcher.group(COUNT_GROUP).replace(",", ""));
      playerInfo.addHiscore(name, new KillCount(name, count));
      scheduleUpdate(0, Set.of(TaskType.HISCORE));
      return;
    }
    Matcher delveMatcher = DELVE_KC_REGEX.matcher(message);
    if (delveMatcher.matches()) {
      String name = HiscoreSkill.DOOM_OF_MOKHAIOTL.getName();
      int count = Integer.parseInt(delveMatcher.group(COUNT_GROUP).replace(",", ""));
      playerInfo.addHiscore(name, new KillCount(name, count));
      scheduleUpdate(0, Set.of(TaskType.HISCORE));
      return;
    }
    Matcher clogMatcher = CLOG_REGEX.matcher(message);
    if (clogMatcher.matches()) {
      String itemName = clogMatcher.group(NAME_GROUP);
      ClogItem clogItem = allItemsByName.get(itemName);
      playerInfo.addClogItem(clogItem);
      scheduleUpdate(0, Set.of(TaskType.CLOG));
    }
  }

  @Subscribe
  public void onStatChanged(StatChanged event) {
    if (ticksTilClientReady > 0) return;
    Level skillLevel =
        playerInfo.getLevels().computeIfAbsent(event.getSkill(), key -> new Level(key, 0, 1));
    if (skillLevel.getXp() < event.getXp()) {
      skillLevel.setXp(event.getXp());
      skillLevel.setLevel(event.getLevel());
      // only refresh level stats every 6 ticks
      scheduleUpdate(6, Set.of(TaskType.LEVEL));
    }
  }

  @Subscribe
  void onVarbitChanged(VarbitChanged event) {
    if (ticksTilClientReady > 0) return;
    int varbId = event.getVarbitId();
    int varpId = event.getVarpId();
    if (varbId != -1) {
      if (varbId != VarbitID.OPTION_COLLECTION_NEW_ITEM) return;
      checkClogChatMessageEnabled();
    } else if (varpId != -1) {
      if (varpId != VarPlayerID.COLOSSEUM_CURRENT_GLORY) return;
      int count = event.getValue();
      String gloryName = HiscoreSkill.COLOSSEUM_GLORY.getName();
      KillCount gloryHiscore =
          playerInfo.getHiscores().computeIfAbsent(gloryName, key -> new KillCount(key, 0));
      if (gloryHiscore.getCount() < count) {
        gloryHiscore.setCount(count);
        scheduleUpdate(0, Set.of(TaskType.HISCORE));
      }
    }
  }

  @Subscribe
  void onScriptPreFired(ScriptPreFired event) {
    if (event.getScriptId() != COLLECTION_LOG_TRANSMIT_SCRIPT_ID) return;
    int itemId = (int) event.getScriptEvent().getArguments()[1];
    ClogItem clogItem = allItemsById.get(itemId);
    playerInfo.addClogItem(clogItem);
    // schedule an update in 2 ticks to let all items load
    // this method is called for each new item, but delay starts after first call
    scheduleUpdate(2, Set.of(TaskType.CLOG));
  }

  @Subscribe
  void onScriptPostFired(ScriptPostFired event) {
    if (playerInfo.isClogInterfaceOpened() || event.getScriptId() != COLLECTION_LOG_SETUP_SCRIPT_ID)
      return;
    // taken from WikiSync, not really sure what script is being run,
    // but it appears that simulating a click on the Search button
    // loads the script that checks for obtained clog items (not quantities though)
    client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
    client.runScript(2240);
    playerInfo.setClogInterfaceOpened(true);
  }

  @Subscribe
  void onConfigChanged(ConfigChanged event) {
    if (!event.getGroup().equals(ProjectXericConfig.GROUP)) return;
    if (event.getKey().equals(ProjectXericConfig.SLAYER_CONFIG_KEY)) {
      playerInfo.setSlayerException(Boolean.parseBoolean(event.getNewValue()));
      SwingUtilities.invokeLater(panel::refresh);
    }
  }

  private boolean updateXericTasks(boolean showMessage) {
    log.debug(
        "Called updateTaskCompletions with: {}",
        pendingUpdates.stream().map(TaskType::getName).collect(Collectors.toSet()));
    Set<Task> remainingTasksToCheck =
        playerInfo.getRemainingTasks().stream()
            .filter(task -> pendingUpdates.contains(task.getType()))
            .collect(Collectors.toSet());
    boolean updated = false;
    for (Task task : remainingTasksToCheck) {
      if (task.checkCompletion(playerInfo)) {
        updated = true;
        playerInfo.addCompletedTask(task);
        if (showMessage) {
          client.addChatMessage(
              ChatMessageType.GAMEMESSAGE,
              "",
              String.format(
                  "Xeric task completed for %d point%s: %s.",
                  task.getTier(),
                  task.getTier() > 1 ? "s" : "",
                  ColorUtil.wrapWithColorTag(task.getName(), DARK_GREEN)),
              null);
        }
      }
    }
    pendingUpdates.clear();
    return updated;
  }

  private boolean updateXericTasks() {
    return updateXericTasks(config.chatMessages());
  }

  private void updateAccountInfo() {
    playerInfo.login(
        client.getLocalPlayer().getName(),
        AccountType.fromVarbValue(client.getVarbitValue(VarbitID.IRONMAN)));
    playerInfo.setSlayerException(config.slayer());
  }

  private void updateQuests() {
    // load player quests
    for (Quest quest : QuestProgress.TRACKED_QUESTS) {
      playerInfo.addQuest(quest, new QuestProgress(quest, quest.getState(client)));
    }
  }

  private void updateDiaries() {
    // load player diaries
    for (KourendDiary diary : DiaryProgress.TRACKED_DIARIES) {
      playerInfo
          .getDiaries()
          .put(
              diary,
              new DiaryProgress(
                  diary,
                  client.getVarbitValue(diary.getCountVarb()),
                  client.getVarbitValue(diary.getCompletedVarb()) == 1));
    }
  }

  private void updateCombatAchievements() {
    // load player combat achievements
    Set<CombatAchievement> remainingCombatAchievements =
        Sets.difference(
            new HashSet<>(allCombatAchievements.values()),
            new HashSet<>(playerInfo.getCombatAchievements().values()));
    for (CombatAchievement combatAchievement : remainingCombatAchievements) {
      client.runScript(4834, combatAchievement.getId());
      boolean unlocked = client.getIntStack()[client.getIntStackSize() - 1] != 0;
      if (unlocked) {
        playerInfo.addCombatAchievement(combatAchievement.getId(), combatAchievement);
      }
    }
  }

  private void loadSkillLevels() {
    // load player levels
    for (Skill skill : Skill.values()) {
      Level skillLevel = playerInfo.getLevels().computeIfAbsent(skill, key -> new Level(key, 0, 1));
      int skillXp = client.getSkillExperience(skill);
      if (skillLevel.getXp() < skillXp) {
        skillLevel.setXp(skillXp);
        skillLevel.setLevel(client.getRealSkillLevel(skill));
      }
    }
  }

  private void checkClogChatMessageEnabled() {
    // warn if player doesn't have collection log chat drops enabled
    if (client.getVarbitValue(VarbitID.OPTION_COLLECTION_NEW_ITEM) % 2 != 1) {
      client.addChatMessage(
          ChatMessageType.GAMEMESSAGE,
          "",
          String.format(
              "[%s] Warning: %s",
              ColorUtil.wrapWithColorTag(ProjectXericConfig.NAME, DARK_GREEN),
              ColorUtil.wrapWithColorTag(
                  "Tasks will not update properly unless you enable the game setting:"
                      + " Collection log - New addition notification",
                  Color.RED)),
          null);
    }
  }

  private void updateClientCache() {
    // check if clog items need to be cached
    if (allItemsById == null || allItemsByName == null) {
      allItemsById = new HashMap<>();
      allItemsByName = new HashMap<>();
      for (int itemId : requestAllClogItems()) {
        ItemComposition itemComposition = client.getItemDefinition(itemId);
        ClogItem clogItem = new ClogItem(itemId, itemComposition.getMembersName());
        allItemsById.put(itemId, clogItem);
        allItemsByName.put(clogItem.getName(), clogItem);
      }
    }
    // check if combat achievements need to be cached
    if (allCombatAchievements == null) {
      allCombatAchievements = new HashMap<>();
      for (int caStructId : requestAllCaTaskStructIds()) {
        StructComposition struct = client.getStructComposition(caStructId);
        int caId = struct.getIntValue(CA_STRUCT_ID_PARAM_ID);
        String caName = struct.getStringValue(CA_STRUCT_NAME_PARAM_ID);
        int caPoints = struct.getIntValue(CA_STRUCT_TIER_PARAM_ID);
        CombatAchievement combatAchievement = new CombatAchievement(caId, caName, caPoints);
        allCombatAchievements.put(caId, combatAchievement);
      }
    }
  }

  private CompletableFuture<Void> updateTaskCacheAsync() {
    CompletableFuture<Void> future = new CompletableFuture<>();
    HttpUrl url =
        new HttpUrl.Builder()
            .scheme("https")
            .host("api.projectxeric.com")
            .addPathSegment("v1")
            .addPathSegment("tasks")
            .build();
    Request request =
        new Request.Builder()
            .get()
            .url(url)
            .addHeader(HttpHeaders.CONTENT_TYPE, "application/json; charset=utf-8")
            .build();
    httpClient
        .newCall(request)
        .enqueue(
            new Callback() {
              @Override
              public void onFailure(@NonNull Call call, @NonNull IOException err) {
                log.warn("api call to tasks failed: {}", err.getMessage());
                future.completeExceptionally(err);
              }

              @Override
              public void onResponse(@NonNull Call call, @NonNull Response response) {
                try (Response res = response) {
                  ResponseBody body = res.body();
                  if (body == null) {
                    throw new IOException("response body empty");
                  }
                  String bodyString = body.string();
                  if (!res.isSuccessful()) {
                    JsonObject json = gson.fromJson(bodyString, JsonObject.class);
                    throw new IOException(json.get("error").getAsString());
                  }
                  Type type = new TypeToken<Set<Task>>() {}.getType();
                  playerInfo.setAllTasks(gson.fromJson(bodyString, type));
                  future.complete(null);
                } catch (IOException | JsonParseException err) {
                  onFailure(call, new IOException(err));
                }
              }
            });
    return future;
  }

  private CompletableFuture<Void> updatePlayerHiscores() {
    // load player hiscores from jagex
    final String username = client.getLocalPlayer().getName();
    final AccountType accountType =
        AccountType.fromVarbValue(client.getVarbitValue(VarbitID.IRONMAN));
    CompletableFuture<Void> future = new CompletableFuture<>();
    executor.execute(
        () -> {
          try {
            HiscoreResult hiscoreResult =
                hiscoreManager.lookup(username, accountType.getHiscoreEndpoint());
            for (HiscoreSkill hiscoreSkill : KillCount.HISCORE_SKILLS) {
              String name = hiscoreSkill.getName();
              int count = Math.max(0, hiscoreResult.getSkill(hiscoreSkill).getLevel());
              if (count == 0) {
                // fallback to checking killcount config if player not ranked on hiscore
                Integer configCount =
                    configManager.getRSProfileConfiguration(
                        "killcount", name.toLowerCase(), Integer.class);
                if (configCount != null) count = configCount;
              }
              playerInfo.addHiscore(name, new KillCount(name, count));
            }
            future.complete(null);
          } catch (IOException err) {
            future.completeExceptionally(err);
          }
        });
    return future;
  }

  private Set<Integer> requestAllCaTaskStructIds() {
    Set<Integer> allCaTaskStructIds = new HashSet<>();
    for (int caTiersEnumId :
        new int[] {
          EASY_TIER_ENUM_ID,
          MEDIUM_TIER_ENUM_ID,
          HARD_TIER_ENUM_ID,
          ELITE_TIER_ENUM_ID,
          MASTER_TIER_ENUM_ID,
          GM_TIER_ENUM_ID
        }) {
      EnumComposition caTiersEnum = client.getEnum(caTiersEnumId);
      for (int caTierStructId : caTiersEnum.getIntVals()) {
        allCaTaskStructIds.add(caTierStructId);
      }
    }
    return allCaTaskStructIds;
  }

  /**
   * Parse the enums and structs in the cache to figure out which item ids exist in the collection
   *
   * <p>log.
   *
   * @return a {@link Set} containing the IDs of all collection log items.
   * @see <a
   *     href="https://github.com/weirdgloop/WikiSync/blob/master/src/main/java/com/andmcadams/wikisync/WikiSyncPlugin.java">WikiSyncPlugin</a>
   */
  private Set<Integer> requestAllClogItems() {
    Set<Integer> clogItems = new HashSet<>();
    // Some items with data saved on them have replacements to fix a duping issue (satchels,
    // flamtaer bag)
    // Enum 3721 contains a mapping of the item ids to replace -> ids to replace them with
    EnumComposition itemReplacementMapping = client.getEnum(ITEM_REPLACEMENT_MAPPING_ENUM_ID);

    // 2102 - Struct that contains the highest level tabs in the collection log (Bosses, Raids, etc)
    // https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2102
    int[] clogTopTabsEnum = client.getEnum(CLOG_TOP_TABS_ENUM_ID).getIntVals();
    for (int clogTopLevelTabStructId : clogTopTabsEnum) {
      // The collection log top level tab structs contain a param that points to the enum
      // that contains the pointers to sub tabs.
      // ex: https://chisel.weirdgloop.org/structs/index.html?type=structs&id=471
      StructComposition clogTopLevelTabStruct =
          client.getStructComposition(clogTopLevelTabStructId);
      // Param 683 contains the pointer to the enum that contains the subtabs ids
      // ex: https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2103
      int[] clogSubTabStructIds =
          client.getEnum(clogTopLevelTabStruct.getIntValue(CLOG_SUB_TABS_PARAM_ID)).getIntVals();
      for (int clogSubTabStructId : clogSubTabStructIds) {
        // The subtab structs are for subtabs in the collection log (Commander Zilyana, Chambers of
        // Xeric, etc.)
        // and contain a pointer to the enum that contains all the item ids for that tab.
        // ex subtab struct: https://chisel.weirdgloop.org/structs/index.html?type=structs&id=476
        // ex subtab enum: https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2109
        StructComposition clogSubTabStruct = client.getStructComposition(clogSubTabStructId);
        int[] clogSubTabItemIds =
            client.getEnum(clogSubTabStruct.getIntValue(CLOG_SUB_TAB_ITEMS_PARAM_ID)).getIntVals();
        for (int clogSubTabItemId : clogSubTabItemIds) clogItems.add(clogSubTabItemId);
      }
    }
    for (int badItemId : itemReplacementMapping.getKeys()) clogItems.remove(badItemId);
    for (int goodItemId : itemReplacementMapping.getIntVals()) clogItems.add(goodItemId);
    // remove duplicate Prospector outfit
    for (int prospectorItemId : UNUSED_PROSPECTOR_ITEM_IDS) clogItems.remove(prospectorItemId);
    return clogItems;
  }
}

package io.septem150.xeric.data.player;

import java.util.List;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.ToString;
import net.runelite.client.hiscore.HiscoreSkill;

@AllArgsConstructor
@Getter
@Setter
@EqualsAndHashCode
@ToString
public class KillCount {
  @NonNull private final String name;
  @EqualsAndHashCode.Exclude private int count;

  public static final List<HiscoreSkill> HISCORE_SKILLS =
      List.of(
          HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE,
          HiscoreSkill.CHAMBERS_OF_XERIC,
          HiscoreSkill.ALCHEMICAL_HYDRA,
          HiscoreSkill.AMOXLIATL,
          HiscoreSkill.THE_HUEYCOATL,
          HiscoreSkill.SARACHNIS,
          HiscoreSkill.HESPORI,
          HiscoreSkill.SKOTIZO,
          HiscoreSkill.LUNAR_CHESTS,
          HiscoreSkill.SOL_HEREDIT,
          HiscoreSkill.WINTERTODT,
          HiscoreSkill.MIMIC,
          HiscoreSkill.YAMA,
          HiscoreSkill.DOOM_OF_MOKHAIOTL,
          HiscoreSkill.CLUE_SCROLL_ALL,
          HiscoreSkill.CLUE_SCROLL_EASY,
          HiscoreSkill.CLUE_SCROLL_MEDIUM,
          HiscoreSkill.CLUE_SCROLL_HARD,
          HiscoreSkill.CLUE_SCROLL_ELITE,
          HiscoreSkill.CLUE_SCROLL_MASTER,
          HiscoreSkill.COLOSSEUM_GLORY);
}

package io.septem150.xeric.data.player;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.ToString;
import net.runelite.api.Skill;

@AllArgsConstructor
@Setter
@Getter
@EqualsAndHashCode
@ToString
public class Level {
  @NonNull private final Skill skill;
  private int xp;
  private int level;
}

package io.septem150.xeric.data.player;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.ToString;

@RequiredArgsConstructor
@Getter
@EqualsAndHashCode
@ToString
public class CombatAchievement {
  public static final int EASY_TIER_ENUM_ID = 3981;
  public static final int MEDIUM_TIER_ENUM_ID = 3982;
  public static final int HARD_TIER_ENUM_ID = 3983;
  public static final int ELITE_TIER_ENUM_ID = 3984;
  public static final int MASTER_TIER_ENUM_ID = 3985;
  public static final int GM_TIER_ENUM_ID = 3986;
  public static final int CA_STRUCT_ID_PARAM_ID = 1306;
  public static final int CA_STRUCT_NAME_PARAM_ID = 1308;
  public static final int CA_STRUCT_TIER_PARAM_ID = 1310;

  private final int id;
  private final String name;
  private final int points;
}

package io.septem150.xeric.data.player;

import java.util.List;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.ToString;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;

@AllArgsConstructor
@Getter
@Setter
@EqualsAndHashCode
@ToString
public class QuestProgress {
  @NonNull private final Quest quest;
  @EqualsAndHashCode.Exclude @NonNull private QuestState state;

  public static final List<Quest> TRACKED_QUESTS =
      List.of(
          Quest.DRUIDIC_RITUAL,
          Quest.EAGLES_PEAK,
          Quest.RUNE_MYSTERIES,
          Quest.A_KINGDOM_DIVIDED,
          Quest.GETTING_AHEAD,
          Quest.THE_GARDEN_OF_DEATH,
          Quest.CHILDREN_OF_THE_SUN,
          Quest.TWILIGHTS_PROMISE,
          Quest.THE_HEART_OF_DARKNESS,
          Quest.X_MARKS_THE_SPOT,
          Quest.CLIENT_OF_KOUREND,
          Quest.THE_QUEEN_OF_THIEVES,
          Quest.THE_DEPTHS_OF_DESPAIR,
          Quest.THE_ASCENT_OF_ARCEUUS,
          Quest.THE_FORSAKEN_TOWER,
          Quest.TALE_OF_THE_RIGHTEOUS,
          Quest.PERILOUS_MOONS,
          Quest.THE_RIBBITING_TALE_OF_A_LILY_PAD_LABOUR_DISPUTE,
          Quest.AT_FIRST_LIGHT,
          Quest.DEATH_ON_THE_ISLE,
          Quest.MEAT_AND_GREET,
          Quest.ETHICALLY_ACQUIRED_ANTIQUITIES,
          Quest.THE_FINAL_DAWN,
          Quest.SHADOWS_OF_CUSTODIA,
          Quest.SCRAMBLED);
}

package io.septem150.xeric.data.player;

import java.awt.image.BufferedImage;
import java.util.function.Consumer;
import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.ToString;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreEndpoint;
import net.runelite.client.util.ImageUtil;

@Slf4j
@RequiredArgsConstructor
@Getter
@ToString
public enum AccountType {
  DEFAULT(0, HiscoreEndpoint.NORMAL, 32),
  IRONMAN(1, HiscoreEndpoint.IRONMAN, 2),
  ULTIMATE(2, HiscoreEndpoint.ULTIMATE_IRONMAN, 3),
  HARDCORE(3, HiscoreEndpoint.HARDCORE_IRONMAN, 10),
  RANKED_GIM(4, HiscoreEndpoint.NORMAL, 41),
  HARDCORE_GIM(5, HiscoreEndpoint.NORMAL, 42),
  UNRANKED_GIM(6, HiscoreEndpoint.NORMAL, 43);

  private static final int MODICONS_ARCHIVE_ID = 423;
  private static final int ICON_SIZE = 14;

  private final int varbValue;
  private final HiscoreEndpoint hiscoreEndpoint;
  private final int spriteId;

  public static AccountType fromVarbValue(int varbValue) {
    for (AccountType accountType : AccountType.values()) {
      if (accountType.varbValue == varbValue) {
        return accountType;
      }
    }
    log.warn("no account type with varbValue of {}", varbValue);
    return DEFAULT;
  }

  public void getImageAsync(@NonNull SpriteManager spriteManager, Consumer<BufferedImage> user) {
    spriteManager.getSpriteAsync(
        MODICONS_ARCHIVE_ID,
        this.getSpriteId(),
        image -> user.accept(ImageUtil.resizeImage(image, ICON_SIZE, ICON_SIZE, true)));
  }
}

package io.septem150.xeric.data.player;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import com.google.gson.Gson;
import com.google.gson.JsonParseException;
import com.google.gson.reflect.TypeToken;
import io.septem150.xeric.ProjectXericConfig;
import io.septem150.xeric.data.ProjectXericManager;
import io.septem150.xeric.data.clog.ClogItem;
import io.septem150.xeric.data.clog.CollectionLog;
import io.septem150.xeric.data.diary.DiaryProgress;
import io.septem150.xeric.data.diary.KourendDiary;
import io.septem150.xeric.data.task.Task;
import java.awt.Color;
import java.lang.reflect.Type;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.Instant;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Quest;
import net.runelite.api.Skill;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfile;
import net.runelite.client.util.ColorUtil;

@Slf4j
@Singleton
@Getter
public class PlayerInfo {
  @Getter(AccessLevel.NONE)
  @NonNull private final Client client;

  @Getter(AccessLevel.NONE)
  @NonNull private final ConfigManager configManager;

  @Getter(AccessLevel.NONE)
  @NonNull private final Gson gson;

  private boolean loggedIn;
  @Nullable private String username;
  @Nullable private AccountType accountType;

  @Setter private boolean slayerException;
  private final Map<Quest, QuestProgress> quests = new EnumMap<>(Quest.class);
  private final Map<KourendDiary, DiaryProgress> diaries = new EnumMap<>(KourendDiary.class);
  private final Map<Skill, Level> levels = new EnumMap<>(Skill.class);
  private final Map<String, KillCount> hiscores = new HashMap<>();
  private final Map<Integer, CombatAchievement> combatAchievements = new HashMap<>();
  private final CollectionLog collectionLog;
  private final Set<Task> allTasks = new HashSet<>();
  private final Set<Task> completedTasks = new HashSet<>();
  private final Set<Task> remainingTasks = new HashSet<>();
  private String tasksHash;

  @Inject
  public PlayerInfo(Client client, ConfigManager configManager, @Named("xericGson") Gson gson) {
    this.client = client;
    this.configManager = configManager;
    this.gson = gson;
    collectionLog = new CollectionLog(client, configManager, gson);
  }

  public void login(String username, AccountType accountType) {
    loggedIn = true;
    this.username = username;
    this.accountType = accountType;
  }

  public void logout() {
    loggedIn = false;
    // reset whether the clog interface has been opened on logout in case
    // the player leaves this client open and then obtains an item on another
    // client before logging in again to this one
    collectionLog.setInterfaceOpened(false);
    collectionLog.saveToRSProfile();
    configManager.setRSProfileConfiguration(
        ProjectXericConfig.GROUP,
        ProjectXericConfig.TASKS_DATA_KEY,
        gson.toJson(completedTasks.stream().map(Task::getId).collect(Collectors.toSet())));
    configManager.setRSProfileConfiguration(
        ProjectXericConfig.GROUP, ProjectXericConfig.TASKS_HASH_DATA_KEY, tasksHash);
  }

  public void reset() {
    loggedIn = false;
    username = null;
    accountType = null;
    slayerException = false;
    quests.clear();
    diaries.clear();
    levels.clear();
    hiscores.clear();
    combatAchievements.clear();
    collectionLog.reset();
    allTasks.clear();
    completedTasks.clear();
    remainingTasks.clear();
    tasksHash = null;
  }

  public void addClogItem(ClogItem item) {
    collectionLog.add(item);
  }

  public void addHiscore(String name, KillCount hiscore) {
    hiscores.put(name, hiscore);
  }

  public void addCombatAchievement(int id, CombatAchievement combatAchievement) {
    combatAchievements.put(id, combatAchievement);
  }

  public void addQuest(Quest quest, QuestProgress progress) {
    quests.put(quest, progress);
  }

  public boolean isClogInterfaceOpened() {
    return collectionLog.isInterfaceOpened();
  }

  public void setClogInterfaceOpened(boolean interfaceOpened) {
    collectionLog.setInterfaceOpened(interfaceOpened);
  }

  public Instant getClogLastUpdated() {
    return collectionLog.getLastUpdated();
  }

  public ImmutableSet<ClogItem> getClogItems() {
    return collectionLog.getItems();
  }

  public void loadClogFromRSProfile() {
    collectionLog.loadFromRSProfile();
  }

  public void loadTasksFromRSProfile() {
    completedTasks.clear();
    remainingTasks.clear();
    try {
      Type type = new TypeToken<Set<Integer>>() {}.getType();
      Set<Integer> taskIds =
          gson.fromJson(
              configManager.getRSProfileConfiguration(
                  ProjectXericConfig.GROUP, ProjectXericConfig.TASKS_DATA_KEY),
              type);
      if (taskIds != null) {
        completedTasks.addAll(
            allTasks.stream()
                .filter(task -> taskIds.contains(task.getId()))
                .collect(Collectors.toSet()));
        remainingTasks.addAll(Sets.difference(allTasks, completedTasks));
      }
    } catch (JsonParseException err) {
      log.error("malformed task data in profile");
      configManager.unsetRSProfileConfiguration(
          ProjectXericConfig.GROUP, ProjectXericConfig.TASKS_DATA_KEY);
    }
  }

  private boolean isTaskListUpdated() {
    String prevTasksHash =
        configManager.getRSProfileConfiguration(
            ProjectXericConfig.GROUP, ProjectXericConfig.TASKS_HASH_DATA_KEY);
    if (prevTasksHash == null || !prevTasksHash.equals(tasksHash)) {
      for (RuneScapeProfile rsProfile : configManager.getRSProfiles()) {
        String profileKey = rsProfile.getKey();
        configManager.unsetConfiguration(
            ProjectXericConfig.GROUP, profileKey, ProjectXericConfig.TASKS_DATA_KEY);
      }
      configManager.setRSProfileConfiguration(
          ProjectXericConfig.GROUP, ProjectXericConfig.TASKS_HASH_DATA_KEY, tasksHash);

      return true;
    }
    return false;
  }

  public boolean checkForUpdatedTasks() {
    if (isTaskListUpdated()) {
      client.addChatMessage(
          ChatMessageType.GAMEMESSAGE,
          "",
          String.format(
              "[%s] Info: %s",
              ColorUtil.wrapWithColorTag(ProjectXericConfig.NAME, ProjectXericManager.DARK_GREEN),
              ColorUtil.wrapWithColorTag(
                  "Tasks have been updated! Check your tasks in the side panel.", Color.RED)),
          null);
      return true;
    }
    return false;
  }

  public void clearCompletedTasks() {
    completedTasks.clear();
    remainingTasks.clear();
    remainingTasks.addAll(Sets.difference(allTasks, completedTasks));
  }

  public void setAllTasks(Set<Task> tasks) {
    allTasks.clear();
    allTasks.addAll(tasks);
    try {
      tasksHash =
          String.format(
              "%032x",
              new BigInteger(
                  1,
                  MessageDigest.getInstance("MD5")
                      .digest(gson.toJson(allTasks).getBytes(StandardCharsets.UTF_8))));
    } catch (NoSuchAlgorithmException e) {
      throw new RuntimeException(e);
    }
  }

  public void addCompletedTask(Task task) {
    completedTasks.add(task);
    remainingTasks.remove(task);
  }

  public int getPoints() {
    return completedTasks.stream().mapToInt(Task::getTier).sum();
  }

  public ClanRank getRank() {
    return ClanRank.fromPoints(getPoints());
  }
}

package io.septem150.xeric.data.player;

import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.text.WordUtils;

@RequiredArgsConstructor
@Getter
public enum ClanRank {
  CARRY(0, 3235, 0),
  BRONZE(25, 3153, 0),
  IRON(50, 3154, 0),
  STEEL(100, 3155, 0),
  OPAL(150, 3127, 0),
  JADE(200, 3128, 0),
  RED_TOPAZ(250, 3129, 0),
  SAPPHIRE(300, 3130, 0),
  EMERALD(400, 3131, 0),
  RUBY(500, 3132, 0),
  DIAMOND(600, 3133, 0),
  DRAGONSTONE(700, 3134, 0),
  ONYX(850, 3135, 0),
  ZENYTE(1000, 3136, 0),
  SPELLCASTER(1150, 3256, 0),
  SNIPER(1300, 3254, 0),
  XERICIAN(1450, 3229, 0),
  MAXED(1650, 3247, 0);

  /** All ranks sorted by points needed to obtain. */
  public static final List<ClanRank> ALL_RANKS =
      Arrays.stream(ClanRank.values())
          .sorted(Comparator.comparingInt(r -> r.pointsNeeded))
          .collect(Collectors.toList());

  private final int pointsNeeded;
  private final int archive;
  private final int file;

  public static ClanRank fromPoints(int points) {
    ClanRank obtainedRank = ClanRank.CARRY;
    for (ClanRank rank : ALL_RANKS) {
      if (points < rank.pointsNeeded) break;
      obtainedRank = rank;
    }
    return obtainedRank;
  }

  public ClanRank getNextRank() {
    return ALL_RANKS.get(Math.min(ALL_RANKS.indexOf(this) + 1, ALL_RANKS.size() - 1));
  }

  @Override
  public String toString() {
    return WordUtils.capitalizeFully(String.format("%s Rank", this.name()));
  }

  public void getImageAsync(@NonNull SpriteManager spriteManager, Consumer<BufferedImage> user) {
    spriteManager.getSpriteAsync(
        archive, file, image -> user.accept(ImageUtil.resizeImage(image, 32, 32, true)));
  }
}

package io.septem150.xeric.data.task;

import io.septem150.xeric.data.clog.ClogItem;
import io.septem150.xeric.data.player.PlayerInfo;
import io.septem150.xeric.util.ResourceUtil;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;

@Slf4j
@Setter
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
public class CollectTask extends Task {
  private Set<Integer> itemIds;
  private int amount;

  @Override
  public boolean checkCompletion(@NonNull PlayerInfo playerInfo) {
    if (itemIds == null) {
      log.warn("clog task with id {} has null itemIds!", getId());
      return false;
    }
    if (itemIds.isEmpty()) {
      return !playerInfo.getClogLastUpdated().equals(Instant.EPOCH)
          && playerInfo.getClogItems().size() >= amount;
    }
    Set<Integer> playerItemIds =
        playerInfo.getClogItems().stream().map(ClogItem::getId).collect(Collectors.toSet());
    int amountRemaining = amount;
    for (int itemId : playerItemIds) {
      if (itemIds.contains(itemId)) {
        amountRemaining--;
      }
      if (amountRemaining == 0) return true;
    }
    return false;
  }

  @Override
  public BufferedImage getIcon(SpriteManager spriteManager) {
    if (this.getIcon() != null) {
      return ResourceUtil.getImage(this.getIcon(), ICON_SIZE, ICON_SIZE, true);
    }
    return ImageUtil.resizeImage(
        Objects.requireNonNull(spriteManager.getSprite(3390, 0)), ICON_SIZE, ICON_SIZE, true);
  }
}

package io.septem150.xeric.data.task;

import io.septem150.xeric.data.player.PlayerInfo;
import java.awt.image.BufferedImage;
import java.io.Serializable;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.Setter;
import lombok.ToString;
import net.runelite.client.game.SpriteManager;

@NoArgsConstructor
@Setter
@Getter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@ToString
public abstract class Task implements Serializable {
  protected static final int ICON_SIZE = 20;

  @EqualsAndHashCode.Include private int id;
  private String icon;
  private String name;
  private TaskType type;
  private int tier;

  public abstract boolean checkCompletion(@NonNull PlayerInfo playerInfo);

  public abstract BufferedImage getIcon(SpriteManager spriteManager);
}

package io.septem150.xeric.data.task;

import io.septem150.xeric.data.player.Level;
import io.septem150.xeric.data.player.PlayerInfo;
import io.septem150.xeric.util.ResourceUtil;
import java.awt.image.BufferedImage;
import java.util.Objects;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Skill;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;

@Slf4j
@Setter
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
public class LevelTask extends Task {
  private String level;
  private int goal;

  @Override
  public boolean checkCompletion(@NonNull PlayerInfo playerInfo) {
    if (level == null) {
      log.warn("level task with id {} has null level!", getId());
      return false;
    }
    switch (level.toUpperCase()) {
      case "TOTAL":
        int total = playerInfo.getLevels().values().stream().mapToInt(Level::getLevel).sum();
        return total >= goal;
      case "ANY":
        for (Level skillLevel : playerInfo.getLevels().values()) {
          if (skillLevel.getXp() >= goal) return true;
        }
        return false;
      case "MAXED":
        int maxed = 0;
        for (Level skillLevel : playerInfo.getLevels().values()) {
          if (skillLevel.getLevel() >= 99) maxed++;
        }
        return maxed >= goal;
      default:
        try {
          Level skillLevel = playerInfo.getLevels().get(Skill.valueOf(level.toUpperCase()));
          if (skillLevel == null) return false;
          return skillLevel.getLevel() >= goal;
        } catch (IllegalArgumentException err) {
          log.warn("unknown skill name parsed: {}", level.toUpperCase());
          return false;
        }
    }
  }

  @Override
  public BufferedImage getIcon(SpriteManager spriteManager) {
    if (this.getIcon() != null) {
      return ResourceUtil.getImage(this.getIcon(), ICON_SIZE, ICON_SIZE, true);
    }
    return ImageUtil.resizeImage(
        Objects.requireNonNull(spriteManager.getSprite(3387, 0)), ICON_SIZE, ICON_SIZE, true);
  }
}

package io.septem150.xeric.data.task;

import io.septem150.xeric.data.diary.DiaryProgress;
import io.septem150.xeric.data.diary.KourendDiary;
import io.septem150.xeric.data.player.PlayerInfo;
import java.awt.image.BufferedImage;
import java.util.Objects;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;

@Slf4j
@Setter
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
public class DiaryTask extends Task {
  private KourendDiary diary;

  @Override
  public boolean checkCompletion(@NonNull PlayerInfo playerInfo) {
    if (diary == null) {
      log.warn("diary task with id {} has null diary!", getId());
      return false;
    }
    DiaryProgress diaryProgress = playerInfo.getDiaries().get(diary);
    if (diaryProgress == null) return false;
    return diaryProgress.isCompleted();
  }

  @Override
  public BufferedImage getIcon(SpriteManager spriteManager) {
    return ImageUtil.resizeImage(
        Objects.requireNonNull(spriteManager.getSprite(1299, 0)), ICON_SIZE, ICON_SIZE, true);
  }
}

package io.septem150.xeric.data.task;

import io.septem150.xeric.data.player.PlayerInfo;
import io.septem150.xeric.data.player.QuestProgress;
import java.awt.image.BufferedImage;
import java.util.Objects;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;

@Slf4j
@Setter
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
public class QuestTask extends Task {
  private String quest;

  @Override
  public boolean checkCompletion(@NonNull PlayerInfo playerInfo) {
    if (quest == null) {
      log.warn("quest task with id {} has null quest!", getId());
      return false;
    }
    Quest questObj =
        QuestProgress.TRACKED_QUESTS.stream()
            .filter(q -> q.getName().equals(quest))
            .findFirst()
            .orElse(null);
    if (questObj == null) {
      log.warn("unknown quest: {}", quest);
      return false;
    }
    QuestProgress questProgress = playerInfo.getQuests().get(questObj);
    if (questProgress == null) return false;
    return questProgress.getState() == QuestState.FINISHED;
  }

  @Override
  public BufferedImage getIcon(SpriteManager spriteManager) {
    return ImageUtil.resizeImage(
        Objects.requireNonNull(spriteManager.getSprite(899, 0)), ICON_SIZE, ICON_SIZE, true);
  }
}

package io.septem150.xeric.data.task;

import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum TaskType {
  @SerializedName("collect")
  CLOG("collect"),
  @SerializedName("level")
  LEVEL("level"),
  @SerializedName("kc")
  HISCORE("kc"),
  @SerializedName("ca")
  CA("ca"),
  @SerializedName("quest")
  QUEST("quest"),
  @SerializedName("diary")
  DIARY("diary");

  private final String name;
}

package io.septem150.xeric.data.task;

import io.septem150.xeric.data.player.PlayerInfo;
import java.awt.image.BufferedImage;
import java.util.Objects;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.Setter;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;

@Setter
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
public class CATask extends Task {
  private int total;

  @Override
  public boolean checkCompletion(@NonNull PlayerInfo playerInfo) {
    return playerInfo.getCombatAchievements().size() >= total;
  }

  @Override
  public BufferedImage getIcon(SpriteManager spriteManager) {
    return ImageUtil.resizeImage(
        Objects.requireNonNull(spriteManager.getSprite(3389, 0)), ICON_SIZE, ICON_SIZE, true);
  }
}

package io.septem150.xeric.data.task;

import io.septem150.xeric.data.player.KillCount;
import io.septem150.xeric.data.player.PlayerInfo;
import io.septem150.xeric.util.ImageCoord;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.util.ImageUtil;

@Slf4j
@Setter
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
public class KCTask extends Task {
  private static final Map<String, ImageCoord> ICON_MAP = new HashMap<>();

  private String boss;
  private int total;
  private transient String fixedBoss;

  static {
    ICON_MAP.put(HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE.getName(), new ImageCoord(4296, 0));
    ICON_MAP.put(HiscoreSkill.CHAMBERS_OF_XERIC.getName(), new ImageCoord(4288, 0));
    ICON_MAP.put(HiscoreSkill.ALCHEMICAL_HYDRA.getName(), new ImageCoord(4289, 0));
    ICON_MAP.put(HiscoreSkill.AMOXLIATL.getName(), new ImageCoord(5639, 0));
    ICON_MAP.put(HiscoreSkill.THE_HUEYCOATL.getName(), new ImageCoord(5640, 0));
    ICON_MAP.put(HiscoreSkill.SARACHNIS.getName(), new ImageCoord(4269, 0));
    ICON_MAP.put(HiscoreSkill.HESPORI.getName(), new ImageCoord(4271, 0));
    ICON_MAP.put(HiscoreSkill.SKOTIZO.getName(), new ImageCoord(4272, 0));
    ICON_MAP.put(HiscoreSkill.LUNAR_CHESTS.getName(), new ImageCoord(5637, 0));
    ICON_MAP.put(HiscoreSkill.SOL_HEREDIT.getName(), new ImageCoord(5636, 0));
    ICON_MAP.put(HiscoreSkill.COLOSSEUM_GLORY.getName(), new ImageCoord(5862, 0));
    ICON_MAP.put(HiscoreSkill.WINTERTODT.getName(), new ImageCoord(4266, 0));
    ICON_MAP.put(HiscoreSkill.MIMIC.getName(), new ImageCoord(4260, 0));
    ICON_MAP.put(HiscoreSkill.YAMA.getName(), new ImageCoord(6346, 0));
    ICON_MAP.put(HiscoreSkill.DOOM_OF_MOKHAIOTL.getName(), new ImageCoord(6347, 0));
    ICON_MAP.put("Clues", new ImageCoord(5853, 0));
  }

  public static String fixBossName(String bossName) {
    // handle special cases where hiscore name doesn't match in-game message name for boss
    switch (bossName) {
      case "Hueycoatl":
        return HiscoreSkill.THE_HUEYCOATL.getName();
      case "Lunar Chest":
        return HiscoreSkill.LUNAR_CHESTS.getName();
      case "Chambers of Xeric Challenge Mode":
        return HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE.getName();
      case "easy":
        return HiscoreSkill.CLUE_SCROLL_EASY.getName();
      case "medium":
        return HiscoreSkill.CLUE_SCROLL_MEDIUM.getName();
      case "hard":
        return HiscoreSkill.CLUE_SCROLL_HARD.getName();
      case "elite":
        return HiscoreSkill.CLUE_SCROLL_ELITE.getName();
      case "master":
        return HiscoreSkill.CLUE_SCROLL_MASTER.getName();
      default:
        return bossName;
    }
  }

  @Override
  public boolean checkCompletion(@NonNull PlayerInfo playerInfo) {
    if (boss == null) {
      log.warn("hiscore task with id {} has null boss!", getId());
      return false;
    }
    if (fixedBoss == null) {
      fixedBoss = KCTask.fixBossName(boss);
    }
    KillCount hiscore = playerInfo.getHiscores().get(fixedBoss);
    if (hiscore == null) return false;
    return hiscore.getCount() >= total;
  }

  @Override
  public BufferedImage getIcon(SpriteManager spriteManager) {
    if (fixedBoss == null) {
      fixedBoss = KCTask.fixBossName(boss);
    }
    ImageCoord coord = ICON_MAP.get(fixedBoss.contains("Clue") ? "Clues" : fixedBoss);
    return ImageUtil.resizeImage(
        Objects.requireNonNull(spriteManager.getSprite(coord.archive, coord.file)),
        ICON_SIZE,
        ICON_SIZE,
        true);
  }
}

package io.septem150.xeric;

import com.google.gson.Gson;
import com.google.inject.Provides;
import io.septem150.xeric.data.ProjectXericManager;
import io.septem150.xeric.data.task.CATask;
import io.septem150.xeric.data.task.CollectTask;
import io.septem150.xeric.data.task.DiaryTask;
import io.septem150.xeric.data.task.KCTask;
import io.septem150.xeric.data.task.LevelTask;
import io.septem150.xeric.data.task.QuestTask;
import io.septem150.xeric.data.task.Task;
import io.septem150.xeric.data.task.TaskType;
import io.septem150.xeric.panel.ProjectXericPanel;
import io.septem150.xeric.util.RuntimeTypeAdapterFactory;
import javax.inject.Inject;
import javax.inject.Named;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfile;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

/**
 * Project Xeric plugin.
 *
 * @author <a href="mailto:carson.mullins@proton.me">Septem 150</a>
 */
@Slf4j
@PluginDescriptor(name = ProjectXericConfig.NAME)
public final class ProjectXericPlugin extends Plugin {
  @Inject private ConfigManager configManager;
  @Inject private ProjectXericManager manager;
  @Inject private EventBus eventBus;

  private ProjectXericPanel panel;

  @Override
  protected void startUp() throws Exception {
    panel = injector.getInstance(ProjectXericPanel.class);
    eventBus.register(manager);
    manager.startUp(panel);
  }

  @Override
  protected void shutDown() throws Exception {
    manager.shutDown();
    eventBus.unregister(manager);
  }

  @Subscribe
  void onCommandExecuted(CommandExecuted event) {
    // ::xeric - resets the plugin's saved data for all RS profiles then reloads
    if (event.getCommand().equals("xeric")) {
      for (RuneScapeProfile rsProfile : configManager.getRSProfiles()) {
        String profileKey = rsProfile.getKey();
        configManager.unsetConfiguration(
            ProjectXericConfig.GROUP, profileKey, ProjectXericConfig.TASKS_DATA_KEY);
        configManager.unsetConfiguration(
            ProjectXericConfig.GROUP, profileKey, ProjectXericConfig.CLOG_DATA_KEY);
        configManager.unsetConfiguration(
            ProjectXericConfig.GROUP, profileKey, ProjectXericConfig.TASKS_HASH_DATA_KEY);
      }
      try {
        shutDown();
        startUp();
      } catch (Exception err) {
        throw new RuntimeException(err);
      }
    }
  }

  @Provides
  ProjectXericConfig provideConfig(ConfigManager configManager) {
    return configManager.getConfig(ProjectXericConfig.class);
  }

  @Provides
  @Named("xericGson")
  Gson provideGson(Gson gson) {
    RuntimeTypeAdapterFactory<Task> taskTypeAdapterFactory =
        RuntimeTypeAdapterFactory.of(Task.class, "type", true)
            .registerSubtype(CATask.class, TaskType.CA.getName())
            .registerSubtype(CollectTask.class, TaskType.CLOG.getName())
            .registerSubtype(DiaryTask.class, TaskType.DIARY.getName())
            .registerSubtype(KCTask.class, TaskType.HISCORE.getName())
            .registerSubtype(LevelTask.class, TaskType.LEVEL.getName())
            .registerSubtype(QuestTask.class, TaskType.QUEST.getName());

    return gson.newBuilder()
        .disableHtmlEscaping()
        .registerTypeAdapterFactory(taskTypeAdapterFactory)
        .create();
  }
}

package io.septem150.xeric;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

/**
 * Project Xeric plugin configuration.
 *
 * @author <a href="mailto:carson.mullins@proton.me">Septem 150</a>
 */
@ConfigGroup(ProjectXericConfig.GROUP)
public interface ProjectXericConfig extends Config {
  String NAME = "Project Xeric";
  String GROUP = "projectxeric";
  String CLOG_DATA_KEY = "clog";
  String TASKS_DATA_KEY = "tasks";
  String TASKS_HASH_DATA_KEY = "tasks_hash";
  String SLAYER_CONFIG_KEY = "slayer";
  String CHAT_MESSAGES_CONFIG_KEY = "chat_messages";

  @ConfigItem(
      keyName = SLAYER_CONFIG_KEY,
      name = "Slayer Exception",
      description = "Toggle on if you train Slayer off-island.")
  default boolean slayer() {
    return false;
  }

  @ConfigItem(
      keyName = CHAT_MESSAGES_CONFIG_KEY,
      name = "Task Completion Chat Messages",
      description = "Toggle on to receive chat messages upon completing tasks.")
  default boolean chatMessages() {
    return true;
  }
}

package io.septem150.xeric.panel.summary;

import io.septem150.xeric.data.player.PlayerInfo;
import io.septem150.xeric.data.task.Task;
import io.septem150.xeric.data.task.TaskType;
import java.awt.Component;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.SpriteManager;

@Slf4j
public class TaskTierPanel extends JPanel {
  @Getter private final int tier;
  private List<TaskPanel> taskPanels = new ArrayList<>();

  private final transient PlayerInfo playerInfo;
  private final transient SpriteManager spriteManager;

  private final JLabel tierAndCountLabel = new JLabel();
  private final JPanel tasksContainerPanel = new JPanel();

  private boolean loaded;

  public TaskTierPanel(
      int tier, @NonNull PlayerInfo playerInfo, @NonNull SpriteManager spriteManager) {
    this.tier = tier;
    this.playerInfo = playerInfo;
    this.spriteManager = spriteManager;
  }

  private void initComponents() {
    // set up tier label and get count
    tierAndCountLabel.setText(
        String.format(
            "Tier %d Tasks (%d/%d)",
            tier,
            (int) taskPanels.stream().filter(TaskPanel::isCompleted).count(),
            taskPanels.size()));
    tierAndCountLabel.setHorizontalAlignment(SwingConstants.LEFT);
    tierAndCountLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
    tierAndCountLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));

    // set up tasks container
    tasksContainerPanel.setOpaque(false);
    tasksContainerPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 5));
    tasksContainerPanel.setLayout(new BoxLayout(tasksContainerPanel, BoxLayout.Y_AXIS));
    tasksContainerPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

    // setup parent panel and add components to layout
    setOpaque(false);
    setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
    add(tierAndCountLabel);
    add(Box.createRigidArea(new Dimension(0, 5)));
    add(tasksContainerPanel);
  }

  public void startUp() {
    taskPanels =
        playerInfo.getAllTasks().stream()
            .filter(task -> task.getTier() == tier)
            .sorted(Comparator.comparing(Task::getType).thenComparing(Task::getName))
            .map(task -> new TaskPanel(task, playerInfo, spriteManager))
            .collect(Collectors.toList());
    if (!loaded) {
      removeAll();
      initComponents();
      loaded = true;
    }
    for (TaskPanel taskPanel : taskPanels) {
      taskPanel.startUp();
    }
    refresh();
  }

  private void refresh() {
    tierAndCountLabel.setText(
        String.format(
            "Tier %d Tasks (%d/%d)",
            tier,
            (int) taskPanels.stream().filter(TaskPanel::isCompleted).count(),
            taskPanels.size()));
    tasksContainerPanel.removeAll();
    for (int i = 0; i < taskPanels.size(); i++) {
      TaskPanel taskPanel = taskPanels.get(i);
      taskPanel.refresh();
      if (taskPanel.isVisible()) {
        tasksContainerPanel.add(taskPanel);
        if (i < taskPanels.size() - 1) {
          tasksContainerPanel.add(Box.createRigidArea(new Dimension(0, 5)));
        }
      }
    }
    revalidate();
  }

  public void applyFilter(String search, boolean showCompleted) {
    invalidate();
    int countShown = 0;
    for (TaskPanel taskPanel : taskPanels) {
      taskPanel.refresh();
      if ((taskPanel.getTaskType().getName().equalsIgnoreCase(search)
              || (Arrays.stream(TaskType.values())
                      .noneMatch(taskType -> taskType.getName().equalsIgnoreCase(search)))
                  && taskPanel.getTaskName().toLowerCase().contains(search.toLowerCase()))
          && (showCompleted || !taskPanel.isCompleted())) {
        taskPanel.setVisible(true);
        countShown++;
        continue;
      }
      taskPanel.setVisible(false);
    }
    setVisible(countShown != 0);
    refresh();
  }
}

package io.septem150.xeric.panel.summary;

import io.septem150.xeric.data.player.PlayerInfo;
import java.awt.BorderLayout;
import java.awt.CardLayout;
import java.time.Instant;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

@Slf4j
@Singleton
public class SummaryPanel extends JPanel {
  public static final String TOOLTIP = "Player Summary";
  public static final String TAB_ICON = "summary_tab_icon.png";

  private final PlayerInfo playerInfo;
  private final TaskListPanel taskListPanel;
  private final IdCard idCardPanel;

  @Inject
  private SummaryPanel(PlayerInfo playerInfo, TaskListPanel taskListPanel, IdCard idCardPanel) {
    this.playerInfo = playerInfo;
    this.taskListPanel = taskListPanel;
    this.idCardPanel = idCardPanel;
  }

  private static final String LOGGED_OUT_CONSTRAINT = "LOGGED_OUT";
  private static final String LOGGED_IN_CONSTRAINT = "LOGGED_IN";
  private final CardLayout layout = new CardLayout();
  private final JLabel loginLabel = new JLabel();
  private final JLabel clogLabel = new JLabel();
  private final JPanel loggedOutPanel = new JPanel();
  private final JPanel loggedInPanel = new JPanel();
  private final JPanel taskListContainerPanel = new JPanel();

  private boolean loaded;

  private void initComponent() {
    loginLabel.setText(
        "<html><body style='text-align: center'>Log in to start tracking Xeric"
            + " Tasks.</body></html>");
    loginLabel.setFont(FontManager.getRunescapeSmallFont());
    loginLabel.setForeground(ColorScheme.BRAND_ORANGE);
    loginLabel.setBorder(new EmptyBorder(20, 0, 0, 0));
    loginLabel.setHorizontalAlignment(SwingConstants.CENTER);

    clogLabel.setText(
        "<html><body style='text-align: center'>Open the Collection Log to start tracking Xeric"
            + " Tasks.</body></html>");
    clogLabel.setFont(FontManager.getRunescapeSmallFont());
    clogLabel.setForeground(ColorScheme.BRAND_ORANGE);
    clogLabel.setBorder(new EmptyBorder(0, 0, 5, 0));
    clogLabel.setHorizontalAlignment(SwingConstants.CENTER);

    loggedOutPanel.setLayout(new BorderLayout());
    loggedOutPanel.add(loginLabel, BorderLayout.NORTH);

    loggedInPanel.setLayout(new BorderLayout());
    loggedInPanel.add(idCardPanel, BorderLayout.NORTH);
    loggedInPanel.add(taskListContainerPanel, BorderLayout.CENTER);

    taskListContainerPanel.setLayout(new BorderLayout());
    taskListContainerPanel.add(clogLabel, BorderLayout.NORTH);
    taskListContainerPanel.add(taskListPanel, BorderLayout.CENTER);

    setLayout(layout);
    setBackground(ColorScheme.DARK_GRAY_COLOR);
    add(loggedOutPanel, LOGGED_OUT_CONSTRAINT);
    add(loggedInPanel, LOGGED_IN_CONSTRAINT);
  }

  public void startUp() {
    if (!loaded) {
      removeAll();
      initComponent();
      loaded = true;
    }
    refresh();
  }

  public void startupChildren() {
    taskListPanel.startUp();
  }

  public void refresh() {
    if (!playerInfo.isLoggedIn()) {
      layout.show(this, LOGGED_OUT_CONSTRAINT);
    } else {
      layout.show(this, LOGGED_IN_CONSTRAINT);
      clogLabel.setVisible(playerInfo.getClogLastUpdated().equals(Instant.EPOCH));
      idCardPanel.reload();
      taskListPanel.reload();
    }
    revalidate();
  }
}

package io.septem150.xeric.panel.summary;

import io.septem150.xeric.data.player.PlayerInfo;
import io.septem150.xeric.data.task.Task;
import io.septem150.xeric.data.task.TaskType;
import io.septem150.xeric.util.ResourceUtil;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JToggleButton;
import javax.swing.ScrollPaneConstants;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.IconTextField;

@Singleton
public class TaskListPanel extends JPanel {
  private final PlayerInfo playerInfo;
  private final SpriteManager spriteManager;

  private List<TaskTierPanel> tierPanels = new ArrayList<>();

  private final IconTextField searchBar = new IconTextField();
  private final JToggleButton showCompletedButton = new JToggleButton();
  private final JPanel controlsContainerPanel = new JPanel();
  private final JPanel taskTiersContainerPanel = new JPanel();
  private final JScrollPane scrollContainerPanel = new JScrollPane();

  private boolean loaded;

  @Inject
  public TaskListPanel(PlayerInfo playerInfo, SpriteManager spriteManager) {
    this.playerInfo = playerInfo;
    this.spriteManager = spriteManager;
  }

  private void initComponents() {
    // set up search bar, toggle button, and tasks panel
    searchBar.setIcon(IconTextField.Icon.SEARCH);
    searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
    searchBar
        .getDocument()
        .addDocumentListener(
            new DocumentListener() {
              @Override
              public void insertUpdate(DocumentEvent documentEvent) {
                reload();
              }

              @Override
              public void removeUpdate(DocumentEvent documentEvent) {
                reload();
              }

              @Override
              public void changedUpdate(DocumentEvent documentEvent) {
                // do nothing, event not used
              }
            });
    for (TaskType taskType : TaskType.values()) {
      searchBar.getSuggestionListModel().addElement(taskType.getName().toUpperCase());
    }

    showCompletedButton.setIcon(
        new ImageIcon(ResourceUtil.getImage("show_completed_disabled.png")));
    showCompletedButton.setSelectedIcon(
        new ImageIcon(ResourceUtil.getImage("show_completed_enabled.png")));
    showCompletedButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    showCompletedButton.addActionListener(unused -> reload());

    // setup parent panel and add components to layout
    controlsContainerPanel.setOpaque(false);
    controlsContainerPanel.setLayout(new BorderLayout(5, 0));
    controlsContainerPanel.add(searchBar, BorderLayout.CENTER);
    controlsContainerPanel.add(showCompletedButton, BorderLayout.EAST);

    taskTiersContainerPanel.setOpaque(false);
    taskTiersContainerPanel.setLayout(new BoxLayout(taskTiersContainerPanel, BoxLayout.Y_AXIS));

    scrollContainerPanel.setOpaque(false);
    scrollContainerPanel.setViewportView(taskTiersContainerPanel);
    scrollContainerPanel.setWheelScrollingEnabled(true);
    scrollContainerPanel.setHorizontalScrollBarPolicy(
        ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
    scrollContainerPanel.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

    setOpaque(false);
    setLayout(new BorderLayout(0, 5));
    add(controlsContainerPanel, BorderLayout.NORTH);
    add(scrollContainerPanel, BorderLayout.CENTER);
  }

  public void startUp() {
    tierPanels =
        playerInfo.getAllTasks().stream()
            .map(Task::getTier)
            .distinct()
            .sorted()
            .map(tier -> new TaskTierPanel(tier, playerInfo, spriteManager))
            .collect(Collectors.toList());
    if (!loaded) {
      removeAll();
      initComponents();
      loaded = true;
    }
    for (TaskTierPanel taskTierPanel : tierPanels) {
      taskTierPanel.startUp();
    }
    reload();
  }

  public void reload() {
    invalidate();
    scrollContainerPanel.setBorder(BorderFactory.createEmptyBorder());
    setBorder(BorderFactory.createEmptyBorder());
    String search = searchBar.getText();
    taskTiersContainerPanel.removeAll();
    for (int i = 0; i < tierPanels.size(); i++) {
      TaskTierPanel taskTierPanel = tierPanels.get(i);
      taskTierPanel.applyFilter(search, showCompletedButton.isSelected());
      if (taskTierPanel.isVisible()) {
        taskTiersContainerPanel.add(taskTierPanel);
        if (i < tierPanels.size() - 1) {
          taskTiersContainerPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        }
      }
    }
    revalidate();
  }
}

package io.septem150.xeric.panel.summary;

import io.septem150.xeric.data.player.PlayerInfo;
import io.septem150.xeric.data.task.Task;
import io.septem150.xeric.data.task.TaskType;
import java.awt.BorderLayout;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import lombok.NonNull;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;

public class TaskPanel extends JPanel {
  private final Task task;

  private final transient PlayerInfo playerInfo;
  private final transient SpriteManager spriteManager;

  private final JLabel nameAndIconLabel = new JLabel();
  private final JCheckBox completedCheckbox = new JCheckBox();

  private boolean loaded;

  public TaskPanel(
      @NonNull Task task, @NonNull PlayerInfo playerInfo, @NonNull SpriteManager spriteManager) {
    this.task = task;
    this.playerInfo = playerInfo;
    this.spriteManager = spriteManager;
  }

  private void initComponents() {
    // set up name and icon label
    nameAndIconLabel.setText(task.getName());
    nameAndIconLabel.setIconTextGap(5);
    nameAndIconLabel.setIcon(new ImageIcon(task.getIcon(spriteManager)));
    nameAndIconLabel.setHorizontalAlignment(SwingConstants.LEFT);
    nameAndIconLabel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 0));

    // set up completed checkbox
    completedCheckbox.setEnabled(false);
    completedCheckbox.setSelected(playerInfo.getCompletedTasks().contains(task));
    completedCheckbox.setBorder(BorderFactory.createEmptyBorder(5, 0, 5, 5));

    // setup parent panel and add components to layout
    setBackground(ColorScheme.DARKER_GRAY_COLOR);
    setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
    add(nameAndIconLabel);
    add(Box.createHorizontalGlue());
    add(completedCheckbox, BorderLayout.EAST);
  }

  public void startUp() {
    if (!loaded) {
      removeAll();
      initComponents();
      loaded = true;
    }
    refresh();
  }

  public void refresh() {
    completedCheckbox.setSelected(playerInfo.getCompletedTasks().contains(task));
    revalidate();
  }

  public boolean isCompleted() {
    return completedCheckbox.isSelected();
  }

  public String getTaskName() {
    return task.getName();
  }

  public TaskType getTaskType() {
    return task.getType();
  }
}

package io.septem150.xeric.panel.summary;

import com.google.common.collect.Iterables;
import io.septem150.xeric.data.player.ClanRank;
import io.septem150.xeric.data.player.PlayerInfo;
import io.septem150.xeric.data.task.Task;
import io.septem150.xeric.panel.JLabeledValue;
import io.septem150.xeric.util.ResourceUtil;
import io.septem150.xeric.util.TransferableBufferedImage;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;
import org.apache.commons.text.WordUtils;

@Singleton
public class IdCard extends JPanel {
  private final PlayerInfo playerInfo;
  private final SpriteManager spriteManager;

  @Inject
  private IdCard(PlayerInfo playerInfo, SpriteManager spriteManager) {
    this.playerInfo = playerInfo;
    this.spriteManager = spriteManager;

    setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));
    add(wrappedPanel, BorderLayout.NORTH);

    SwingUtil.removeButtonDecorations(screenshotButton);
    screenshotButton.setToolTipText("Copy ID Card to your clipboard");
    screenshotButton.setUI(new BasicButtonUI());
    screenshotButton.setBorder(new EmptyBorder(0, 0, 0, 0));
    screenshotButton.setFocusable(false);
    screenshotButton.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
    screenshotButton.addActionListener(
        actionEvent -> {
          BufferedImage image =
              new BufferedImage(
                  wrappedPanel.getWidth(), wrappedPanel.getHeight(), BufferedImage.TYPE_INT_RGB);
          screenshotButton.setVisible(false);
          wrappedPanel.paint(image.getGraphics());
          screenshotButton.setVisible(true);
          Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
          TransferableBufferedImage transferableImage = new TransferableBufferedImage(image);
          clipboard.setContents(transferableImage, null);
        });
    screenshotButton.addMouseListener(
        new MouseAdapter() {
          @Override
          public void mouseEntered(MouseEvent e) {
            screenshotButton.setBorder(new EmptyBorder(0, 0, 0, 0));
          }

          @Override
          public void mouseExited(MouseEvent e) {
            screenshotButton.setBorder(new EmptyBorder(0, 0, 0, 0));
          }
        });
  }

  private final JPanel wrappedPanel = new JPanel(new GridBagLayout());
  private final JLabel rank = new JLabel();
  private final JLabel username = new JLabel();
  private final JLabeledValue points = new JLabeledValue();
  private final JLabel herbException = new JLabel();
  private final JLabel chinException = new JLabel();
  private final JLabel slayException = new JLabel();
  private final JLabeledValue tasksCompleted = new JLabeledValue();
  private final JLabeledValue pointsToNextRank = new JLabeledValue();
  private final JLabeledValue highestTierCompleted = new JLabeledValue();
  private final JButton screenshotButton = new JButton();

  private void makeLayout() {
    removeAll();
    wrappedPanel.removeAll();
    wrappedPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    wrappedPanel.setBorder(new LineBorder(ColorScheme.BORDER_COLOR, 1));
    setLayout(new BorderLayout());
    rank.setPreferredSize(new Dimension(32, 32));
    wrappedPanel.add(rank, gbc(0, 0, 1, 2, 0, GridBagConstraints.CENTER, new Insets(5, 10, 5, 5)));

    username.setFont(FontManager.getDefaultFont().deriveFont(Font.BOLD, 14));
    wrappedPanel.add(username, gbc(1, 0, 2, 1, 1, GridBagConstraints.WEST, new Insets(5, 0, 1, 0)));

    final JPanel exceptions = new JPanel();
    exceptions.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    exceptions.setLayout(new BoxLayout(exceptions, BoxLayout.X_AXIS));
    herbException.setAlignmentY(Component.BOTTOM_ALIGNMENT);
    chinException.setAlignmentY(Component.BOTTOM_ALIGNMENT);
    slayException.setAlignmentY(Component.BOTTOM_ALIGNMENT);
    exceptions.add(herbException);
    exceptions.add(chinException);
    exceptions.add(slayException);
    wrappedPanel.add(
        exceptions, gbc(1, 1, 2, 1, 1, GridBagConstraints.WEST, new Insets(1, 0, 5, 0)));

    wrappedPanel.add(
        points, gbc(3, 0, 1, 2, 0, GridBagConstraints.CENTER, new Insets(5, 5, 5, 10)));

    wrappedPanel.add(
        tasksCompleted, gbc(0, 2, 2, 1, 0, GridBagConstraints.WEST, new Insets(5, 10, 5, 5)));

    wrappedPanel.add(
        pointsToNextRank, gbc(2, 2, 2, 1, 0, GridBagConstraints.EAST, new Insets(5, 5, 5, 10)));

    wrappedPanel.add(
        highestTierCompleted,
        gbc(0, 3, 3, 1, 0, GridBagConstraints.CENTER, new Insets(5, 10, 5, 5)));

    wrappedPanel.add(
        screenshotButton, gbc(3, 3, 1, 1, 0, GridBagConstraints.CENTER, new Insets(5, 5, 5, 10)));
    add(wrappedPanel, BorderLayout.NORTH);
  }

  private GridBagConstraints gbc(
      int x, int y, int width, int height, double weightX, int anchor, Insets insets) {
    GridBagConstraints gbc = new GridBagConstraints();
    gbc.gridx = x;
    gbc.gridy = y;
    gbc.gridwidth = width;
    gbc.gridheight = height;
    gbc.fill = GridBagConstraints.NONE;
    gbc.weightx = weightX;
    gbc.anchor = anchor;
    gbc.insets = insets;
    return gbc;
  }

  private void makeStaticData() {
    points.setLabel("Points");
    tasksCompleted.setLabel("Tasks completed");
    pointsToNextRank.setLabel("Points to next rank");
    highestTierCompleted.setLabel("Highest tier completed");
    screenshotButton.setIcon(
        new ImageIcon(
            ResourceUtil.getImage("/net/runelite/client/plugins/screenshot/screenshot.png")));
  }

  private void makeDynamicData() {
    int playerPoints = playerInfo.getPoints();
    ClanRank playerRank = playerInfo.getRank();
    playerRank.getImageAsync(spriteManager, image -> rank.setIcon(new ImageIcon(image)));
    rank.setToolTipText(WordUtils.capitalizeFully(playerRank.name()));
    Objects.requireNonNull(playerInfo.getAccountType())
        .getImageAsync(spriteManager, image -> username.setIcon(new ImageIcon(image)));
    username.setText(playerInfo.getUsername());
    points.setValue(playerPoints);
    if (herbException.getIcon() == null) {
      spriteManager.getSpriteAsync(
          205,
          0,
          image ->
              herbException.setIcon(new ImageIcon(ImageUtil.resizeImage(image, 20, 20, true))));
    }
    herbException.setEnabled(
        playerInfo.getQuests().get(Quest.DRUIDIC_RITUAL).getState() == QuestState.FINISHED);
    if (chinException.getIcon() == null) {
      chinException.setIcon(
          new ImageIcon(ResourceUtil.getImage("box_trap_icon.png", 20, 20, true)));
    }
    chinException.setEnabled(
        playerInfo.getQuests().get(Quest.EAGLES_PEAK).getState() != QuestState.NOT_STARTED);
    if (slayException.getIcon() == null) {
      spriteManager.getSpriteAsync(
          216,
          0,
          image ->
              slayException.setIcon(new ImageIcon(ImageUtil.resizeImage(image, 20, 20, true))));
    }
    slayException.setEnabled(playerInfo.isSlayerException());
    tasksCompleted.setValue(playerInfo.getCompletedTasks().size());
    pointsToNextRank.setValue(playerRank.getNextRank().getPointsNeeded() - playerPoints);
    highestTierCompleted.setValue(getHighestTierCompleted());
  }

  public void reload() {
    makeLayout();
    makeStaticData();
    makeDynamicData();
  }

  private String getHighestTierCompleted() {
    List<Integer> tiers =
        playerInfo.getAllTasks().stream()
            .map(Task::getTier)
            .distinct()
            .sorted()
            .collect(Collectors.toList());
    int highestTier = 0;
    int maxTiers = Optional.ofNullable(Iterables.getLast(tiers, 0)).orElse(0);
    for (int tier = 1; tier <= maxTiers; tier++) {
      if (playerInfo.getCompletedTasks().isEmpty()) break;
      boolean completed = true;
      for (Task task : playerInfo.getAllTasks()) {
        if (task.getTier() != tier) continue;
        if (!playerInfo.getCompletedTasks().contains(task)) {
          completed = false;
          break;
        }
      }
      if (completed) {
        highestTier = tier;
      } else break;
    }
    return highestTier > 0 ? String.format("Tier %d", highestTier) : "None";
  }
}

package io.septem150.xeric.panel;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.Optional;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

public class JLabeledValue extends JPanel {
  private final JLabel value;
  private final JLabel label;

  public JLabeledValue(String value, String label) {
    setLayout(new BorderLayout());

    final JPanel labeledValue = new JPanel();
    labeledValue.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    labeledValue.setLayout(new BoxLayout(labeledValue, BoxLayout.Y_AXIS));
    labeledValue.setAlignmentY(Component.CENTER_ALIGNMENT);

    this.value = new JLabel(Optional.ofNullable(value).orElse(""));
    this.value.setForeground(Color.WHITE);
    this.value.setAlignmentX(Component.CENTER_ALIGNMENT);
    this.value.setFont(FontManager.getDefaultFont().deriveFont(Font.BOLD, 12));
    labeledValue.add(this.value);

    this.label = new JLabel(Optional.ofNullable(label).orElse(""));
    this.label.setForeground(ColorScheme.TEXT_COLOR);
    this.label.setAlignmentX(Component.CENTER_ALIGNMENT);
    this.label.setFont(FontManager.getDefaultFont().deriveFont(Font.PLAIN, 10));
    labeledValue.add(this.label);

    add(labeledValue, BorderLayout.CENTER);
  }

  public JLabeledValue() {
    this(null, null);
  }

  public void setValue(int value) {
    setValue(String.valueOf(value));
  }

  public void setValue(String value) {
    this.value.setText(value);
  }

  public void setLabel(String label) {
    this.label.setText(label);
  }
}

package io.septem150.xeric.panel.leaderboard;

import io.septem150.xeric.util.ResourceUtil;
import java.awt.Component;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.LinkBrowser;

@Slf4j
@Singleton
public class LeaderboardPanel extends JPanel {
  public static final String TOOLTIP = "Leaderboard";
  public static final String TAB_ICON = "/skill_icons/overall.png";

  private final BoxLayout layout = new BoxLayout(this, BoxLayout.Y_AXIS);
  private final JLabel wipLabel = new JLabel();
  private final JButton womButton = new JButton();

  @Inject
  private LeaderboardPanel() {
    makeLayout();
    makeStaticData();
  }

  private void makeLayout() {
    removeAll();
    setLayout(layout);
    wipLabel.setBorder(new EmptyBorder(20, 0, 20, 0));
    wipLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
    add(wipLabel);
    womButton.setAlignmentX(Component.CENTER_ALIGNMENT);
    add(womButton);
  }

  private void makeStaticData() {
    setBackground(ColorScheme.DARK_GRAY_COLOR);
    wipLabel.setText(
        "<html><body style='text-align: center'>Leaderboard coming soon!<br>Check out the Wise Old"
            + " Man group in the meantime.</body></html>");
    wipLabel.setFont(FontManager.getRunescapeSmallFont());
    wipLabel.setForeground(ColorScheme.BRAND_ORANGE);
    womButton.setIcon(new ImageIcon(ResourceUtil.getImage("wiseoldman_icon.png")));
    womButton.addActionListener(
        event -> LinkBrowser.browse("https://wiseoldman.net/groups/1200/hiscores"));
    womButton.setToolTipText("View the Leaderboard on Wise Old Man");
  }

  public void refresh() {
    revalidate();
  }
}

package io.septem150.xeric.panel;

import io.septem150.xeric.ProjectXericConfig;
import io.septem150.xeric.panel.leaderboard.LeaderboardPanel;
import io.septem150.xeric.panel.summary.SummaryPanel;
import io.septem150.xeric.util.ResourceUtil;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;

@Slf4j
@Singleton
public class ProjectXericPanel extends PluginPanel {
  private static final String SIDEPANEL_ICON = "sidepanel_icon.png";
  private static final int SIDEPANEL_PRIORITY = 3;

  private final ClientToolbar clientToolbar;
  private final NavigationButton navigationButton;
  private final SummaryPanel summaryPanel;
  private final LeaderboardPanel leaderboardPanel;

  @Inject
  private ProjectXericPanel(
      ClientToolbar clientToolbar, SummaryPanel summaryPanel, LeaderboardPanel leaderboardPanel) {
    super(false);
    this.clientToolbar = clientToolbar;
    navigationButton =
        NavigationButton.builder()
            .tooltip(ProjectXericConfig.NAME)
            .icon(ResourceUtil.getImage(SIDEPANEL_ICON))
            .priority(SIDEPANEL_PRIORITY)
            .panel(this)
            .build();

    this.summaryPanel = summaryPanel;
    this.leaderboardPanel = leaderboardPanel;
    setLayout(new BorderLayout());
    setBackground(ColorScheme.DARK_GRAY_COLOR);
    setBorder(new EmptyBorder(10, 10, 10, 10));

    JPanel layoutPanel = new JPanel();
    layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));

    JPanel titlePanel = createTitlePanel();
    layoutPanel.add(titlePanel);

    JPanel display = new JPanel();
    display.setBorder(new EmptyBorder(10, 0, 0, 0));
    MaterialTabGroup tabGroup = new MaterialTabGroup(display);
    tabGroup.setLayout(new GridLayout(1, 0, 7, 7));

    MaterialTab summaryTab =
        createTab(SummaryPanel.TOOLTIP, SummaryPanel.TAB_ICON, summaryPanel, tabGroup);

    createTab(LeaderboardPanel.TOOLTIP, LeaderboardPanel.TAB_ICON, leaderboardPanel, tabGroup);

    layoutPanel.add(tabGroup);

    add(layoutPanel, BorderLayout.NORTH);
    add(display, BorderLayout.CENTER);

    tabGroup.select(summaryTab);
  }

  /** Adds this Side Panel to the RuneLite client toolbar */
  public void startUp() {
    clientToolbar.addNavigation(navigationButton);
    summaryPanel.startUp();
  }

  public void startUpChildren() {
    summaryPanel.startupChildren();
  }

  /** Removes this Side Panel from the RuneLite client toolbar */
  public void shutDown() {
    clientToolbar.removeNavigation(navigationButton);
  }

  public void refresh() {
    summaryPanel.refresh();
    leaderboardPanel.refresh();
    revalidate();
  }

  /**
   * Creates a new {@link MaterialTab} with a given image and tooltip text. The {@code imageName} is
   * used as the tab's icon via {@link ResourceUtil#getImage(String imageName)}.
   *
   * @param tooltip the tooltip to display on hover.
   * @param imageName the name of an image, including extension.
   * @param content a {@link JPanel} to display when the tab is selected.
   * @param tabGroup the {@link MaterialTabGroup} to assign the newly created tab to.
   * @return a new {@link MaterialTab} with the desired properties.
   */
  private MaterialTab createTab(
      String tooltip, String imageName, JPanel content, MaterialTabGroup tabGroup) {
    MaterialTab tab =
        new MaterialTab(new ImageIcon(ResourceUtil.getImage(imageName)), tabGroup, content);
    tab.setToolTipText(tooltip);
    tabGroup.addTab(tab);
    return tab;
  }

  /**
   * Creates a {@link JPanel} that contains the plugin's title and social media buttons.
   *
   * @return a new {@link JPanel}.
   */
  private JPanel createTitlePanel() {
    JPanel titlePanel = new JPanel(new BorderLayout());
    titlePanel.setBorder(new EmptyBorder(0, 0, 10, 0));

    JLabel title = new JLabel(ProjectXericConfig.NAME);
    title.setForeground(Color.WHITE);
    titlePanel.add(title, BorderLayout.WEST);

    JPanel infoButtons = new JPanel(new GridLayout(1, 2, 10, 0));

    JButton discordButton =
        createTitleButton(
            "Join the Zeah Ironman Discord Server",
            "discord_icon.png",
            "https://discord.gg/q73k9Dn");
    infoButtons.add(discordButton);

    JButton githubButton =
        createTitleButton(
            "View the plugin's Source Code on GitHub",
            "github_icon.png",
            "https://github.com/Septem151/project-xeric");
    infoButtons.add(githubButton);

    titlePanel.add(infoButtons, BorderLayout.EAST);

    return titlePanel;
  }

  /**
   * Creates a {@link JButton} with a given image, tooltip text, and URL. The {@code imageName} is
   * used as the tab's icon via {@link ResourceUtil#getImage(String imageName)}. Attempts to open a
   * new browser tab to the provided URL on click.
   *
   * @param tooltip the tooltip to display on hover.
   * @param imageName the name of an image, including extension.
   * @param url the URL to open when the button is clicked.
   * @return a new {@link JButton} with the desired properties.
   */
  private JButton createTitleButton(String tooltip, String imageName, String url) {
    JButton button = new JButton(new ImageIcon(ResourceUtil.getImage(imageName, 16, 16)));
    SwingUtil.removeButtonDecorations(button);
    button.setToolTipText(tooltip);
    button.setBackground(ColorScheme.DARK_GRAY_COLOR);
    button.setUI(new BasicButtonUI());
    button.setFocusable(false);
    button.addActionListener(event -> LinkBrowser.browse(url));
    button.addMouseListener(
        new MouseAdapter() {
          @Override
          public void mouseEntered(MouseEvent e) {
            button.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
          }

          @Override
          public void mouseExited(MouseEvent e) {
            button.setBackground(ColorScheme.DARK_GRAY_COLOR);
          }
        });
    return button;
  }
}

package io.septem150.xeric;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

/**
 * Project Xeric plugin tests.
 *
 * @author <a href="mailto:carson.mullins@proton.me">Septem 150</a>
 */
public class ProjectXericPluginTest {
  /**
   * Main entrypoint for running a test client with the plugin added.
   *
   * @param args String[] program args
   * @throws Exception if a failure occurs
   */
  @SuppressWarnings("unchecked")
  public static void main(String[] args) throws Exception {
    ExternalPluginManager.loadBuiltin(ProjectXericPlugin.class);
    RuneLite.main(args);
  }
}

