package io.septem150.xeric.util;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class ImageCoord {
  public final int archive;
  public final int file;
}

package io.septem150.xeric.util;

import com.google.common.collect.Sets;
import java.util.Set;
import net.runelite.api.Client;
import net.runelite.api.WorldType;

public class WorldUtil {
  private WorldUtil() {}

  private static final Set<WorldType> invalidWorldTypes =
      Set.of(
          WorldType.NOSAVE_MODE,
          WorldType.BETA_WORLD,
          WorldType.FRESH_START_WORLD,
          WorldType.DEADMAN,
          WorldType.PVP_ARENA,
          WorldType.QUEST_SPEEDRUNNING,
          WorldType.SEASONAL,
          WorldType.TOURNAMENT_WORLD);

  public static boolean isValidWorldType(Client client) {
    if (!client.isClientThread()) {
      return false;
    }
    return Sets.intersection(invalidWorldTypes, client.getWorldType()).isEmpty();
  }
}

/*
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.septem150.xeric.util;

import com.google.errorprone.annotations.CanIgnoreReturnValue;
import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Adapts values whose runtime type may differ from their declaration type. This is necessary when a
 * field's type is not the same type that GSON should create when deserializing that field. For
 * example, consider these types:
 *
 * <pre>{@code
 * abstract class Shape {
 *   int x;
 *   int y;
 * }
 * class Circle extends Shape {
 *   int radius;
 * }
 * class Rectangle extends Shape {
 *   int width;
 *   int height;
 * }
 * class Diamond extends Shape {
 *   int width;
 *   int height;
 * }
 * class Drawing {
 *   Shape bottomShape;
 *   Shape topShape;
 * }
 * }</pre>
 *
 * <p>Without additional type information, the serialized JSON is ambiguous. Is the bottom shape in
 * this drawing a rectangle or a diamond?
 *
 * <pre>{@code
 * {
 *   "bottomShape": {
 *     "width": 10,
 *     "height": 5,
 *     "x": 0,
 *     "y": 0
 *   },
 *   "topShape": {
 *     "radius": 2,
 *     "x": 4,
 *     "y": 1
 *   }
 * }
 * }</pre>
 *
 * This class addresses this problem by adding type information to the serialized JSON and honoring
 * that type information when the JSON is deserialized:
 *
 * <pre>{@code
 * {
 *   "bottomShape": {
 *     "type": "Diamond",
 *     "width": 10,
 *     "height": 5,
 *     "x": 0,
 *     "y": 0
 *   },
 *   "topShape": {
 *     "type": "Circle",
 *     "radius": 2,
 *     "x": 4,
 *     "y": 1
 *   }
 * }
 * }</pre>
 *
 * Both the type field name ({@code "type"}) and the type labels ({@code "Rectangle"}) are
 * configurable.
 *
 * <h2>Registering Types</h2>
 *
 * Create a {@code RuntimeTypeAdapterFactory} by passing the base type and type field name to the
 * {@link #of} factory method. If you don't supply an explicit type field name, {@code "type"} will
 * be used.
 *
 * <pre>{@code
 * RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory
 *     = RuntimeTypeAdapterFactory.of(Shape.class, "type");
 * }</pre>
 *
 * Next register all of your subtypes. Every subtype must be explicitly registered. This protects
 * your application from injection attacks. If you don't supply an explicit type label, the type's
 * simple name will be used.
 *
 * <pre>{@code
 * shapeAdapterFactory.registerSubtype(Rectangle.class, "Rectangle");
 * shapeAdapterFactory.registerSubtype(Circle.class, "Circle");
 * shapeAdapterFactory.registerSubtype(Diamond.class, "Diamond");
 * }</pre>
 *
 * Finally, register the type adapter factory in your application's GSON builder:
 *
 * <pre>{@code
 * Gson gson = new GsonBuilder()
 *     .registerTypeAdapterFactory(shapeAdapterFactory)
 *     .create();
 * }</pre>
 *
 * Like {@code GsonBuilder}, this API supports chaining:
 *
 * <pre>{@code
 * RuntimeTypeAdapterFactory<Shape> shapeAdapterFactory = RuntimeTypeAdapterFactory.of(Shape.class)
 *     .registerSubtype(Rectangle.class)
 *     .registerSubtype(Circle.class)
 *     .registerSubtype(Diamond.class);
 * }</pre>
 *
 * <h2>Serialization and deserialization</h2>
 *
 * In order to serialize and deserialize a polymorphic object, you must specify the base type
 * explicitly.
 *
 * <pre>{@code
 * Diamond diamond = new Diamond();
 * String json = gson.toJson(diamond, Shape.class);
 * }</pre>
 *
 * And then:
 *
 * <pre>{@code
 * Shape shape = gson.fromJson(json, Shape.class);
 * }</pre>
 */
public final class RuntimeTypeAdapterFactory<T> implements TypeAdapterFactory {
  private final Class<?> baseType;
  private final String typeFieldName;
  private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<>();
  private final Map<Class<?>, String> subtypeToLabel = new LinkedHashMap<>();
  private final boolean maintainType;
  private boolean recognizeSubtypes;

  private RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName, boolean maintainType) {
    if (typeFieldName == null || baseType == null) {
      throw new NullPointerException();
    }
    this.baseType = baseType;
    this.typeFieldName = typeFieldName;
    this.maintainType = maintainType;
  }

  /**
   * Creates a new runtime type adapter for {@code baseType} using {@code typeFieldName} as the type
   * field name. Type field names are case sensitive.
   *
   * @param maintainType true if the type field should be included in deserialized objects
   */
  public static <T> RuntimeTypeAdapterFactory<T> of(
      Class<T> baseType, String typeFieldName, boolean maintainType) {
    return new RuntimeTypeAdapterFactory<>(baseType, typeFieldName, maintainType);
  }

  /**
   * Creates a new runtime type adapter for {@code baseType} using {@code typeFieldName} as the type
   * field name. Type field names are case sensitive.
   */
  public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName) {
    return new RuntimeTypeAdapterFactory<>(baseType, typeFieldName, false);
  }

  /**
   * Creates a new runtime type adapter for {@code baseType} using {@code "type"} as the type field
   * name.
   */
  public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType) {
    return new RuntimeTypeAdapterFactory<>(baseType, "type", false);
  }

  /**
   * Ensures that this factory will handle not just the given {@code baseType}, but any subtype of
   * that type.
   */
  @CanIgnoreReturnValue
  public RuntimeTypeAdapterFactory<T> recognizeSubtypes() {
    this.recognizeSubtypes = true;
    return this;
  }

  /**
   * Registers {@code type} identified by {@code label}. Labels are case sensitive.
   *
   * @throws IllegalArgumentException if either {@code type} or {@code label} have already been
   *     registered on this type adapter.
   */
  @CanIgnoreReturnValue
  public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type, String label) {
    if (type == null || label == null) {
      throw new NullPointerException();
    }
    if (subtypeToLabel.containsKey(type) || labelToSubtype.containsKey(label)) {
      throw new IllegalArgumentException("types and labels must be unique");
    }
    labelToSubtype.put(label, type);
    subtypeToLabel.put(type, label);
    return this;
  }

  /**
   * Registers {@code type} identified by its {@link Class#getSimpleName simple name}. Labels are
   * case sensitive.
   *
   * @throws IllegalArgumentException if either {@code type} or its simple name have already been
   *     registered on this type adapter.
   */
  @CanIgnoreReturnValue
  public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type) {
    return registerSubtype(type, type.getSimpleName());
  }

  @Override
  public <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {
    if (type == null) {
      return null;
    }
    Class<?> rawType = type.getRawType();
    boolean handle =
        recognizeSubtypes ? baseType.isAssignableFrom(rawType) : baseType.equals(rawType);
    if (!handle) {
      return null;
    }

    TypeAdapter<JsonElement> jsonElementAdapter = gson.getAdapter(JsonElement.class);
    Map<String, TypeAdapter<?>> labelToDelegate = new LinkedHashMap<>();
    Map<Class<?>, TypeAdapter<?>> subtypeToDelegate = new LinkedHashMap<>();
    for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {
      TypeAdapter<?> delegate = gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));
      labelToDelegate.put(entry.getKey(), delegate);
      subtypeToDelegate.put(entry.getValue(), delegate);
    }

    return new TypeAdapter<R>() {
      @Override
      public R read(JsonReader in) throws IOException {
        JsonElement jsonElement = jsonElementAdapter.read(in);
        JsonElement labelJsonElement;
        if (maintainType) {
          labelJsonElement = jsonElement.getAsJsonObject().get(typeFieldName);
        } else {
          labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);
        }

        if (labelJsonElement == null) {
          throw new JsonParseException(
              "cannot deserialize "
                  + baseType
                  + " because it does not define a field named "
                  + typeFieldName);
        }
        String label = labelJsonElement.getAsString();
        @SuppressWarnings("unchecked") // registration requires that subtype extends T
        TypeAdapter<R> delegate = (TypeAdapter<R>) labelToDelegate.get(label);
        if (delegate == null) {
          throw new JsonParseException(
              "cannot deserialize "
                  + baseType
                  + " subtype named "
                  + label
                  + "; did you forget to register a subtype?");
        }
        return delegate.fromJsonTree(jsonElement);
      }

      @Override
      public void write(JsonWriter out, R value) throws IOException {
        Class<?> srcType = value.getClass();
        String label = subtypeToLabel.get(srcType);
        @SuppressWarnings("unchecked") // registration requires that subtype extends T
        TypeAdapter<R> delegate = (TypeAdapter<R>) subtypeToDelegate.get(srcType);
        if (delegate == null) {
          throw new JsonParseException(
              "cannot serialize " + srcType.getName() + "; did you forget to register a subtype?");
        }
        JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();

        if (maintainType) {
          jsonElementAdapter.write(out, jsonObject);
          return;
        }

        JsonObject clone = new JsonObject();

        if (jsonObject.has(typeFieldName)) {
          throw new JsonParseException(
              "cannot serialize "
                  + srcType.getName()
                  + " because it already defines a field named "
                  + typeFieldName);
        }
        clone.add(typeFieldName, new JsonPrimitive(label));

        for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {
          clone.add(e.getKey(), e.getValue());
        }
        jsonElementAdapter.write(out, clone);
      }
    }.nullSafe();
  }
}

package io.septem150.xeric.util;

import io.septem150.xeric.ProjectXericPlugin;
import java.awt.image.BufferedImage;
import lombok.NonNull;
import net.runelite.client.util.ImageUtil;

public class ResourceUtil {
  private ResourceUtil() {}

  public static BufferedImage getImage(@NonNull String name) {
    String imagePath = name;
    if (!name.startsWith("/")) {
      imagePath = String.format("images/%s", imagePath);
    }
    return ImageUtil.loadImageResource(ProjectXericPlugin.class, imagePath);
  }

  public static BufferedImage getImage(@NonNull String name, int width, int height) {
    return getImage(name, width, height, false);
  }

  public static BufferedImage getImage(
      @NonNull String name, int width, int height, boolean preserveAspectRatio) {
    BufferedImage image = getImage(name);
    return ImageUtil.resizeImage(image, width, height, preserveAspectRatio);
  }
}

/*
 * Copyright (c) 2019, Alexsuperfly <https://github.com/Alexsuperfly>
 * Copyright (c) 2019, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.septem150.xeric.util;

import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.image.BufferedImage;
import lombok.AllArgsConstructor;
import lombok.NonNull;

/**
 * Taken from: <a
 * href="https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/util/TransferableBufferedImage.java">TransferableBufferedImage</a>
 *
 * <p>Changes: - made class public, since it was package protected. - added @NonNull annotation to
 * {@link #getTransferData(DataFlavor)}
 */
@AllArgsConstructor
public class TransferableBufferedImage implements Transferable {
  @NonNull private final BufferedImage image;

  @Override
  public @NonNull Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException {
    if (flavor.equals(DataFlavor.imageFlavor)) {
      return image;
    } else {
      throw new UnsupportedFlavorException(flavor);
    }
  }

  @Override
  public DataFlavor[] getTransferDataFlavors() {
    return new DataFlavor[] {DataFlavor.imageFlavor};
  }

  @Override
  public boolean isDataFlavorSupported(DataFlavor flavor) {
    return flavor.equals(DataFlavor.imageFlavor);
  }
}

package io.septem150.xeric.data.diary;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;

@RequiredArgsConstructor
@Getter
public enum KourendDiary {
  EASY("Easy", 7933, 7925),
  MEDIUM("Medium", 7934, 7926),
  HARD("Hard", 7935, 7927),
  ELITE("Elite", 7936, 7928);

  private final String name;
  private final int countVarb;
  private final int completedVarb;

  @Override
  public String toString() {
    return name;
  }

  public int getTaskCount(Client client) {
    if (client == null || !client.isClientThread()) {
      throw new RuntimeException("must be on client thread");
    }
    return client.getVarbitValue(this.countVarb);
  }

  public boolean getCompleted(Client client) {
    if (client == null || !client.isClientThread()) {
      throw new RuntimeException("must be on client thread");
    }
    return client.getVarbitValue(this.completedVarb) == 1;
  }
}

package io.septem150.xeric.data.diary;

import java.util.List;
import lombok.Data;
import net.runelite.api.Client;

@Data
public class DiaryProgress {
  private KourendDiary diary;
  private int count;
  private boolean completed;

  public static final List<KourendDiary> trackedDiaries =
      List.of(KourendDiary.EASY, KourendDiary.MEDIUM, KourendDiary.HARD, KourendDiary.ELITE);

  public static DiaryProgress from(Client client, KourendDiary diary) {
    if (client == null || !client.isClientThread()) {
      throw new RuntimeException("must be on client thread");
    }
    DiaryProgress progress = new DiaryProgress();
    progress.diary = diary;
    progress.count = diary.getTaskCount(client);
    progress.completed = diary.getCompleted(client);
    return progress;
  }
}

package io.septem150.xeric.data.clog;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import lombok.Data;

@Data
public class CollectionLog {
  private Instant lastOpened;
  private List<ClogItem> items = new ArrayList<>();

  public void add(ClogItem clogItem) {
    items.add(clogItem);
  }

  public int size() {
    return items.size();
  }

  public Set<Integer> getItemIds() {
    return items.stream().map(ClogItem::getId).collect(Collectors.toSet());
  }

  public static final int COLLECTION_LOG_SETUP_SCRIPT_ID = 7797;
  public static final int COLLECTION_LOG_TRANSMIT_SCRIPT_ID = 4100;

  public static final int CLOG_TOP_TABS_ENUM_ID = 2102;
  public static final int CLOG_SUB_TABS_PARAM_ID = 683;
  public static final int CLOG_SUB_TAB_ITEMS_PARAM_ID = 690;
  public static final int ITEM_REPLACEMENT_MAPPING_ENUM_ID = 3721;
  public static final List<Integer> UNUSED_PROSPECTOR_ITEM_IDS =
      List.of(29472, 29474, 29476, 29478);
}

package io.septem150.xeric.data.clog;

import lombok.Data;
import net.runelite.api.Client;

@Data
public class ClogItem {
  private int id;
  private String name;

  public static ClogItem from(Client client, int id) {
    if (client == null || !client.isClientThread()) {
      throw new RuntimeException("must be on client thread");
    }
    ClogItem item = new ClogItem();
    item.id = id;
    item.name = client.getItemDefinition(id).getMembersName();
    return item;
  }
}

package io.septem150.xeric.data;

import static io.septem150.xeric.data.clog.CollectionLog.CLOG_SUB_TABS_PARAM_ID;
import static io.septem150.xeric.data.clog.CollectionLog.CLOG_SUB_TAB_ITEMS_PARAM_ID;
import static io.septem150.xeric.data.clog.CollectionLog.CLOG_TOP_TABS_ENUM_ID;
import static io.septem150.xeric.data.clog.CollectionLog.COLLECTION_LOG_SETUP_SCRIPT_ID;
import static io.septem150.xeric.data.clog.CollectionLog.COLLECTION_LOG_TRANSMIT_SCRIPT_ID;
import static io.septem150.xeric.data.clog.CollectionLog.ITEM_REPLACEMENT_MAPPING_ENUM_ID;
import static io.septem150.xeric.data.clog.CollectionLog.UNUSED_PROSPECTOR_ITEM_IDS;
import static io.septem150.xeric.data.player.CombatAchievement.CA_STRUCT_ID_PARAM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.CA_STRUCT_NAME_PARAM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.CA_STRUCT_TIER_PARAM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.EASY_TIER_ENUM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.ELITE_TIER_ENUM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.GM_TIER_ENUM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.HARD_TIER_ENUM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.MASTER_TIER_ENUM_ID;
import static io.septem150.xeric.data.player.CombatAchievement.MEDIUM_TIER_ENUM_ID;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;
import com.google.common.collect.Multisets;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import io.septem150.xeric.ProjectXericConfig;
import io.septem150.xeric.data.clog.ClogItem;
import io.septem150.xeric.data.clog.CollectionLog;
import io.septem150.xeric.data.diary.DiaryProgress;
import io.septem150.xeric.data.player.AccountType;
import io.septem150.xeric.data.player.CombatAchievement;
import io.septem150.xeric.data.player.KillCount;
import io.septem150.xeric.data.player.Level;
import io.septem150.xeric.data.player.PlayerInfo;
import io.septem150.xeric.data.player.QuestProgress;
import io.septem150.xeric.data.task.LevelTask;
import io.septem150.xeric.data.task.Task;
import io.septem150.xeric.data.task.TaskStore;
import io.septem150.xeric.panel.ProjectXericPanel;
import io.septem150.xeric.util.WorldUtil;
import java.awt.Color;
import java.io.IOException;
import java.lang.reflect.Type;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.GameState;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuAction;
import net.runelite.api.Skill;
import net.runelite.api.StructComposition;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.events.StatChanged;
import net.runelite.api.gameval.InterfaceID.TrailRewardscreen;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.hiscore.HiscoreEndpoint;
import net.runelite.client.hiscore.HiscoreManager;
import net.runelite.client.hiscore.HiscoreResult;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;

@Slf4j
@Singleton
public class ProjectXericManager {
  private static final Pattern COMBAT_TASK_REGEX =
      Pattern.compile("Congratulations, you've completed an? \\w+ combat task:.*");
  private static final Pattern CLOG_REGEX =
      Pattern.compile("New item added to your collection log: (?<item>.*)");
  private static final Pattern DIARY_REGEX =
      Pattern.compile(
          "Well done! You have completed an? \\w+ task in the .* area\\. Your Achievement"
              + " Diary has been updated");
  private static final Pattern KC_REGEX =
      Pattern.compile(
          "Your (?:subdued |completed )?(?<name>.*) (?:kill )?count is: (?<count>\\d+)\\.");
  private static final Pattern DELVE_KC_REGEX =
      Pattern.compile("Deep delves completed: (?<count>\\d+)");
  private static final Pattern DELVE_REGEX =
      Pattern.compile(
          "Delve level: (?<wave>\\d+|8\\+ \\((?<deepWave>\\d+)\\)) duration:"
              + " (?<duration>(?:\\d+:)?\\d+:\\d+)(?:\\.\\d+)?(?: \\(new personal best\\)|\\."
              + " Personal best: (?<pb>(?:\\d+:)?\\d+:\\d+)(?:\\.\\d+)?)");
  private static final Pattern CLUE_REGEX =
      Pattern.compile("You have completed (?<count>\\d+) (?<tier>.*) Treasure Trails?\\.");
  private static final Pattern QUEST_REGEX =
      Pattern.compile("Congratulations, you've completed a quest:.*");

  private final Client client;
  private final ClientThread clientThread;
  private final ProjectXericConfig config;
  private final ConfigManager configManager;
  private final ItemManager itemManager;
  private final ScheduledExecutorService executor;
  private final HiscoreManager hiscoreManager;
  private final TaskStore taskStore;
  private final Gson gson;

  private ProjectXericPanel panel;
  private long lastAccountId;
  private Set<Integer> remainingCaStructIds;
  private Set<Integer> completedTaskIds;
  private Set<Integer> clogItemIds;
  private Set<Task> remainingTasks;
  private Set<Task> levelTasks;
  private boolean clogOpened;
  private Multiset<Integer> inventoryItems;
  private String obtainedItemName;
  private int updateGeneral;
  private int updateTasks;
  private int updateLevels;
  @Getter private PlayerInfo playerInfo;

  @Inject
  public ProjectXericManager(
      Client client,
      ClientThread clientThread,
      ProjectXericConfig config,
      ConfigManager configManager,
      ItemManager itemManager,
      ScheduledExecutorService executor,
      HiscoreManager hiscoreManager,
      TaskStore taskStore,
      @Named("xericGson") Gson gson) {
    this.client = client;
    this.clientThread = clientThread;
    this.config = config;
    this.configManager = configManager;
    this.itemManager = itemManager;
    this.executor = executor;
    this.hiscoreManager = hiscoreManager;
    this.taskStore = taskStore;
    this.gson = gson;
  }

  public void startUp(ProjectXericPanel panel) {
    this.panel = panel;
    lastAccountId = -1L;
    playerInfo = new PlayerInfo();
    clientThread.invokeLater(
        () -> {
          if (client.getGameState() == GameState.LOGGED_IN && WorldUtil.isValidWorldType(client)) {
            updateGeneral = 1;
          }
        });
    taskStore
        .getAllAsync(false)
        .exceptionally(
            err -> {
              throw new RuntimeException(err);
            });
  }

  public void shutDown() {
    configManager.setRSProfileConfiguration(
        ProjectXericConfig.GROUP,
        ProjectXericConfig.CLOG_DATA_KEY,
        gson.toJson(playerInfo.getCollectionLog().getItemIds()));
    configManager.setRSProfileConfiguration(
        ProjectXericConfig.GROUP,
        ProjectXericConfig.TASKS_DATA_KEY,
        gson.toJson(playerInfo.getTasks().stream().map(Task::getId).collect(Collectors.toSet())));
    playerInfo = null;
    lastAccountId = -1L;
    clogOpened = false;
    remainingCaStructIds = null;
    clogItemIds = null;
    completedTaskIds = null;
    levelTasks = null;
    inventoryItems = null;
    obtainedItemName = null;
    updateGeneral = 0;
    updateTasks = 0;
    updateLevels = 0;
    taskStore.reset();
  }

  public void reset(long accountId) {
    if (lastAccountId == accountId) return;
    lastAccountId = accountId;
    playerInfo = new PlayerInfo();
    updateAccountInfo();
    updateQuests();
    updateDiaries();
    updateCombatAchievements();
    updateCollectionLog();

    // Attempt to load collection log data from RuneLite Profile data first
    try {
      Type type = new TypeToken<Set<Integer>>() {}.getType();
      completedTaskIds =
          gson.fromJson(
              configManager.getRSProfileConfiguration(
                  ProjectXericConfig.GROUP, ProjectXericConfig.TASKS_DATA_KEY),
              type);
    } catch (JsonSyntaxException exc) {
      log.warn("malformed stored tasks data found, will ignore and overwrite.");
      configManager.unsetRSProfileConfiguration(
          ProjectXericConfig.GROUP, ProjectXericConfig.TASKS_DATA_KEY);
    }
    // Save empty clog to RuneLite Profile if malformed clog data or null key
    if (completedTaskIds == null) {
      completedTaskIds = new HashSet<>();
      configManager.setRSProfileConfiguration(
          ProjectXericConfig.GROUP,
          ProjectXericConfig.TASKS_DATA_KEY,
          gson.toJson(completedTaskIds));
    }

    // Update player tasks and levels in the background, as these are both asynchronous processes
    // that require network calls, and we don't want the panel or task-checking logic running until
    // those calls are complete
    CompletableFuture.allOf(updatePlayerTasks(), updatePlayerLevels())
        .thenRun(
            () -> {
              updateLevels = 2;
              updateTasks = 2;
              clientThread.invoke(
                  () -> {
                    panel.startUpChildren();
                    SwingUtilities.invokeLater(panel::refresh);
                  });
            });
  }

  @Subscribe
  public void onGameStateChanged(GameStateChanged event) {
    if (client.getGameState() == GameState.LOGGED_IN && WorldUtil.isValidWorldType(client)) {
      updateGeneral = 1;
    } else if (client.getGameState() == GameState.LOGIN_SCREEN) {
      configManager.setRSProfileConfiguration(
          ProjectXericConfig.GROUP,
          ProjectXericConfig.CLOG_DATA_KEY,
          gson.toJson(playerInfo.getCollectionLog().getItemIds()));
      configManager.setRSProfileConfiguration(
          ProjectXericConfig.GROUP,
          ProjectXericConfig.TASKS_DATA_KEY,
          gson.toJson(playerInfo.getTasks().stream().map(Task::getId).collect(Collectors.toSet())));
      clogOpened = false;
      updateLevels = 2;
    }
  }

  @Subscribe
  public void onGameTick(GameTick event) {
    if (updateGeneral > 0 && --updateGeneral == 0) {
      reset(client.getAccountHash());
      return;
    }
    if (updateLevels > 0 && --updateLevels == 0) {
      if (playerInfo.getLevels().isEmpty()) {
        playerInfo.setLevels(
            Arrays.stream(Skill.values())
                .map(skill -> Level.from(client, skill))
                .collect(Collectors.toMap(Level::getName, level -> level)));
      }
      updateXericTasks(true);
    }
    if (updateTasks > 0 && --updateTasks == 0) {
      updateXericTasks(false);
    }
  }

  @Subscribe
  public void onChatMessage(ChatMessage event) {
    if (event.getType() != ChatMessageType.GAMEMESSAGE) return;
    String message = Text.removeTags(event.getMessage());
    Matcher caTaskMatcher = COMBAT_TASK_REGEX.matcher(message);
    if (caTaskMatcher.matches()) {
      if (updateCombatAchievements() && updateTasks <= 0) updateTasks = 1;
      return;
    }
    Matcher diaryMatcher = DIARY_REGEX.matcher(message);
    if (diaryMatcher.matches()) {
      updateDiaries();
      if (updateTasks <= 0) updateTasks = 1;
      return;
    }
    Matcher questMatcher = QUEST_REGEX.matcher(message);
    if (questMatcher.matches()) {
      updateQuests();
      if (updateTasks <= 0) updateTasks = 1;
      return;
    }
    Matcher kcMatcher = KC_REGEX.matcher(message);
    if (kcMatcher.matches()) {
      String name = kcMatcher.group("name");
      if ("Lunar Chest".equals(name)) {
        name += "s";
      } else if ("Hueycoatl".equals(name)) {
        name = "The " + name;
      }
      int count = Integer.parseInt(kcMatcher.group("count"));
      KillCount kc = playerInfo.getKillCounts().getOrDefault(name, null);
      if (kc != null) {
        kc.setCount(count);
        if (updateTasks <= 0) updateTasks = 1;
      }
      return;
    }
    Matcher clueMatcher = CLUE_REGEX.matcher(message);
    if (clueMatcher.matches()) {
      int count = Integer.parseInt(clueMatcher.group("count"));
      String tier = clueMatcher.group("tier");
      KillCount kc =
          playerInfo.getKillCounts().getOrDefault(String.format("Clue Scrolls (%s)", tier), null);
      if (kc != null) {
        kc.setCount(count);
        if (updateTasks <= 0) updateTasks = 1;
      }
      return;
    }
    Matcher clogMatcher = CLOG_REGEX.matcher(message);
    if (clogMatcher.matches()) {
      obtainedItemName = Text.removeTags(clogMatcher.group("item"));

      ItemContainer inventory = client.getItemContainer(InventoryID.INV);
      if (inventory == null) {
        obtainedItemName = null;
        inventoryItems = null;
        return;
      }

      // Get inventory prior to onItemContainerChanged event
      Arrays.stream(inventory.getItems())
          .forEach(item -> inventoryItems.add(item.getId(), item.getQuantity()));

      // Defer to onItemContainerChanged or onLootReceived
    }
  }

  @Subscribe
  public void onStatChanged(StatChanged event) {
    if (playerInfo.getLevels().isEmpty()) return;
    Level level = playerInfo.getLevels().getOrDefault(event.getSkill().getName(), null);
    if (level == null) {
      level = new Level();
      level.setName(event.getSkill().getName());
    }
    if (level.getExp() == event.getXp()) return;
    level.setAmount(event.getLevel());
    level.setExp(event.getXp());
    if (updateLevels <= 0 && level.isAccurate()) updateLevels = 5;
  }

  @Subscribe
  public void onScriptPreFired(ScriptPreFired event) {
    if (event.getScriptId() != COLLECTION_LOG_TRANSMIT_SCRIPT_ID) return;
    int itemId = (int) event.getScriptEvent().getArguments()[1];
    if (playerInfo.getCollectionLog().getItems().stream()
        .noneMatch(item -> item.getId() == itemId)) {
      ClogItem clogItem = ClogItem.from(client, itemId);
      playerInfo.getCollectionLog().getItems().add(clogItem);
    }
  }

  @Subscribe
  public void onScriptPostFired(ScriptPostFired event) {
    if (event.getScriptId() != COLLECTION_LOG_SETUP_SCRIPT_ID) {
      return;
    }
    if (!clogOpened) {
      playerInfo.getCollectionLog().setLastOpened(Instant.now());
      // taken from WikiSync, not really sure what script is being run,
      // but it appears that simulating a click on the Search button
      // loads the script that checks for obtained clog items (not quantities though)
      client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
      client.runScript(2240);
      clogOpened = true;
      updateTasks = 3;
    }
  }

  @Subscribe
  public void onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
    if (itemContainerChanged.getContainerId() != InventoryID.INV) {
      return;
    }

    if (obtainedItemName == null) {
      inventoryItems = HashMultiset.create();
      return;
    }

    if (inventoryItems == null) {
      inventoryItems = HashMultiset.create();
    }

    // Need to build a diff of inventory items prior to item appearing in inventory and current
    // inventory items
    // Necessary to find item that may have non-unique name (Ancient page, decorative armor) that
    // may already be in inventory
    ItemContainer inventory = itemContainerChanged.getItemContainer();
    Multiset<Integer> currentInventoryItems = HashMultiset.create();
    Arrays.stream(inventory.getItems())
        .forEach(item -> currentInventoryItems.add(item.getId(), item.getQuantity()));
    Multiset<Integer> invDiff = Multisets.difference(currentInventoryItems, inventoryItems);

    ItemStack obtainedItemStack = null;
    for (Multiset.Entry<Integer> item : invDiff.entrySet()) {
      ItemComposition itemComp = itemManager.getItemComposition(item.getElement());
      if (itemComp.getName().equals(obtainedItemName)) {
        obtainedItemStack = new ItemStack(item.getElement(), item.getCount());

        break;
      }
    }

    if (obtainedItemStack == null) {
      // Opening clue casket triggers onItemContainerChanged event before clue items
      // appear in inventory. Fall through to onLootReceived to find obtained item(s)
      if (client.getWidget(TrailRewardscreen.ITEMS) != null) {
        return;
      }

      obtainedItemName = null;
      inventoryItems = HashMultiset.create();
      return;
    }

    updateObtainedItem(obtainedItemStack);
  }

  @Subscribe
  public void onLootReceived(LootReceived lootReceived) {
    if (obtainedItemName == null) {
      inventoryItems = null;
      return;
    }

    ItemStack obtainedItem = null;
    Collection<ItemStack> items = lootReceived.getItems();
    for (ItemStack item : items) {
      ItemComposition itemComp = itemManager.getItemComposition(item.getId());
      if (itemComp.getName().equals(obtainedItemName)) {
        obtainedItem = item;
      }
    }

    if (obtainedItem == null) {
      obtainedItemName = null;
      inventoryItems = null;
      return;
    }

    updateObtainedItem(obtainedItem);
  }

  @Subscribe
  public void onConfigChanged(ConfigChanged event) {
    if (!event.getGroup().equals(ProjectXericConfig.GROUP)) return;
    if (event.getKey().equals(ProjectXericConfig.SLAYER_CONFIG_KEY)) {
      playerInfo.setSlayerException(Boolean.parseBoolean(event.getNewValue()));
      SwingUtilities.invokeLater(panel::refresh);
    }
  }

  private void updateObtainedItem(ItemStack itemStack) {
    if (clogItemIds.contains(itemStack.getId())) {
      ClogItem clogItem = ClogItem.from(client, itemStack.getId());
      playerInfo.getCollectionLog().add(clogItem);
      if (updateTasks <= 0) updateTasks = 1;
    }
    obtainedItemName = null;
    inventoryItems = HashMultiset.create();
  }

  private void updateXericTasks(boolean onlyLevels) {
    executor.execute(
        () -> {
          log.debug("Called UPDATE TASKS, Only Levels: {}", onlyLevels);
          boolean refresh = false;
          Set<Task> completedTasks = new HashSet<>(playerInfo.getTasks());
          Iterator<Task> iterator = onlyLevels ? levelTasks.iterator() : remainingTasks.iterator();
          log.debug(
              "Iterating over {} tasks", onlyLevels ? levelTasks.size() : remainingTasks.size());
          while (iterator.hasNext()) {
            Task task = iterator.next();
            if (task.checkCompletion(playerInfo)) {
              log.debug("New completed task!\n{}", gson.toJson(task));
              completedTasks.add(task);
              iterator.remove();
              if (onlyLevels) remainingTasks.remove(task);
              else levelTasks.remove(task);
              refresh = true;
              if (config.chatMessages()) {
                clientThread.invokeLater(
                    () -> {
                      int points = config.slayer() ? task.getSlayerPoints() : task.getTier();
                      client.addChatMessage(
                          ChatMessageType.GAMEMESSAGE,
                          ProjectXericConfig.NAME,
                          String.format(
                              "Xeric task completed for %d point%s: %s.",
                              points,
                              points > 1 ? "s" : "",
                              ColorUtil.wrapWithColorTag(task.getName(), Color.decode("#006600"))),
                          "");
                    });
              }
            }
          }
          if (refresh) {
            playerInfo.setTasks(new ArrayList<>(completedTasks));
            SwingUtilities.invokeLater(panel::refresh);
          }
        });
  }

  private void updateAccountInfo() {
    playerInfo.setUsername(client.getLocalPlayer().getName());
    playerInfo.setAccountType(AccountType.fromVarbValue(client.getVarbitValue(VarbitID.IRONMAN)));
    playerInfo.setSlayerException(config.slayer());
  }

  private void updateQuests() {
    playerInfo.setQuests(
        QuestProgress.trackedQuests.stream()
            .map(quest -> QuestProgress.from(client, quest))
            .collect(Collectors.toList()));
  }

  private void updateDiaries() {
    playerInfo.setDiaries(
        DiaryProgress.trackedDiaries.stream()
            .map(diary -> DiaryProgress.from(client, diary))
            .collect(Collectors.toList()));
  }

  private boolean updateCombatAchievements() {
    if (remainingCaStructIds == null) {
      remainingCaStructIds = requestAllCaTaskStructIds();
    }
    Set<CombatAchievement> cas = new HashSet<>(playerInfo.getCombatAchievements());
    boolean refresh = false;
    Iterator<Integer> iterator = remainingCaStructIds.iterator();
    while (iterator.hasNext()) {
      int caStructId = iterator.next();
      StructComposition struct = client.getStructComposition(caStructId);
      int caTaskId = struct.getIntValue(CA_STRUCT_ID_PARAM_ID);
      client.runScript(4834, caTaskId);
      boolean unlocked = client.getIntStack()[client.getIntStackSize() - 1] != 0;
      if (unlocked) {
        CombatAchievement combatAchievement = new CombatAchievement();
        combatAchievement.setId(caTaskId);
        combatAchievement.setName(struct.getStringValue(CA_STRUCT_NAME_PARAM_ID));
        combatAchievement.setPoints(struct.getIntValue(CA_STRUCT_TIER_PARAM_ID));
        cas.add(combatAchievement);
        iterator.remove();
        refresh = true;
      }
    }
    if (refresh) {
      playerInfo.setCombatAchievements(new ArrayList<>(cas));
    }
    return refresh;
  }

  private void updateCollectionLog() {
    clogItemIds = requestAllClogItems();
    Set<Integer> obtainedClogItemIds = null;
    Instant clogUpdated = null;

    // Attempt to load collection log data from RuneLite Profile data first
    try {
      Type type = new TypeToken<Set<Integer>>() {}.getType();
      obtainedClogItemIds =
          gson.fromJson(
              configManager.getRSProfileConfiguration(
                  ProjectXericConfig.GROUP, ProjectXericConfig.CLOG_DATA_KEY),
              type);
    } catch (JsonSyntaxException exc) {
      log.warn("malformed stored clog data found, will ignore and overwrite.");
      configManager.unsetRSProfileConfiguration(
          ProjectXericConfig.GROUP, ProjectXericConfig.CLOG_DATA_KEY);
    }
    // Save empty clog to RuneLite Profile if malformed clog data or null key
    if (obtainedClogItemIds == null) {
      obtainedClogItemIds = new HashSet<>();
      configManager.setRSProfileConfiguration(
          ProjectXericConfig.GROUP,
          ProjectXericConfig.CLOG_DATA_KEY,
          gson.toJson(obtainedClogItemIds));
    } else {
      clogUpdated = Instant.now();
    }

    CollectionLog clog = new CollectionLog();
    clog.setLastOpened(clogUpdated);
    clog.setItems(
        obtainedClogItemIds.stream()
            .map(itemId -> ClogItem.from(client, itemId))
            .collect(Collectors.toList()));
    playerInfo.setCollectionLog(clog);
  }

  private CompletableFuture<Void> updatePlayerTasks() {
    return taskStore
        .getAllAsync()
        .exceptionally(
            err -> {
              throw new RuntimeException(err);
            })
        .thenAccept(
            tasks -> {
              remainingTasks = new HashSet<>(tasks);
              List<Task> completedTasks = new ArrayList<>();
              Iterator<Task> iterator = remainingTasks.iterator();
              while (iterator.hasNext()) {
                Task task = iterator.next();
                if (completedTaskIds.contains(task.getId())) {
                  iterator.remove();
                  completedTasks.add(task);
                }
              }
              playerInfo.setTasks(completedTasks);
              levelTasks =
                  remainingTasks.stream()
                      .filter(LevelTask.class::isInstance)
                      .collect(Collectors.toSet());
            });
  }

  private CompletableFuture<Void> updatePlayerLevels() {
    return CompletableFuture.runAsync(
        () -> {
          HiscoreEndpoint hiscoreEndpoint = playerInfo.getAccountType().getHiscoreEndpoint();
          Map<String, KillCount> kcs = new HashMap<>();
          try {
            HiscoreResult result =
                hiscoreManager.lookup(client.getLocalPlayer().getName(), hiscoreEndpoint);
            KillCount.hiscoreSkills.forEach(
                hiscoreSkill -> {
                  KillCount killCount = new KillCount();
                  killCount.setCount(Math.max(0, result.getSkill(hiscoreSkill).getLevel()));
                  killCount.setName(hiscoreSkill.getName());
                  kcs.put(killCount.getName(), killCount);
                });
            playerInfo.setKillCounts(kcs);
          } catch (IOException exc) {
            log.warn(
                "IOException while looking up hiscores for player '{}'",
                client.getLocalPlayer().getName());
          }
        },
        executor);
  }

  private Set<Integer> requestAllCaTaskStructIds() {
    Set<Integer> allCaTaskStructIds = new HashSet<>();
    for (int caTiersEnumId :
        new int[] {
          EASY_TIER_ENUM_ID,
          MEDIUM_TIER_ENUM_ID,
          HARD_TIER_ENUM_ID,
          ELITE_TIER_ENUM_ID,
          MASTER_TIER_ENUM_ID,
          GM_TIER_ENUM_ID
        }) {
      EnumComposition caTiersEnum = client.getEnum(caTiersEnumId);
      // so we can iterate the enum to find a bunch of structs
      for (int caTierStructId : caTiersEnum.getIntVals()) {
        StructComposition caTierStruct = client.getStructComposition(caTierStructId);
        // and with the struct we can get info about the ca
        // like its id, which we can use to get if its completed or not
        allCaTaskStructIds.add(caTierStructId);
        // we can use the cs2 vm to invoke script 4834 to do the lookup for us
        // client.runScript(4834, id);
        // boolean unlocked = client.getIntStack()[client.getIntStackSize() - 1] != 0;

        // or we can reimplement it ourselves
        // from script 4834
      }
    }
    return allCaTaskStructIds;
  }

  /**
   * Parse the enums and structs in the cache to figure out which item ids exist in the collection
   *
   * <p>log.
   *
   * @return a {@link Set} containing the IDs of all collection log items.
   * @see <a
   *     href="https://github.com/weirdgloop/WikiSync/blob/master/src/main/java/com/andmcadams/wikisync/WikiSyncPlugin.java">WikiSyncPlugin</a>
   */
  private Set<Integer> requestAllClogItems() {
    Set<Integer> clogItems = new HashSet<>();
    // 2102 - Struct that contains the highest level tabs in the collection log (Bosses, Raids, etc)
    // https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2102
    int[] clogTopTabsEnum = client.getEnum(CLOG_TOP_TABS_ENUM_ID).getIntVals();
    for (int clogTopLevelTabStructId : clogTopTabsEnum) {
      // The collection log top level tab structs contain a param that points to the enum
      // that contains the pointers to sub tabs.
      // ex: https://chisel.weirdgloop.org/structs/index.html?type=structs&id=471
      StructComposition clogTopLevelTabStruct =
          client.getStructComposition(clogTopLevelTabStructId);
      // Param 683 contains the pointer to the enum that contains the subtabs ids
      // ex: https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2103
      int[] clogSubTabStructIds =
          client.getEnum(clogTopLevelTabStruct.getIntValue(CLOG_SUB_TABS_PARAM_ID)).getIntVals();
      for (int clogSubTabStructId : clogSubTabStructIds) {
        // The subtab structs are for subtabs in the collection log (Commander Zilyana, Chambers of
        // Xeric, etc.)
        // and contain a pointer to the enum that contains all the item ids for that tab.
        // ex subtab struct: https://chisel.weirdgloop.org/structs/index.html?type=structs&id=476
        // ex subtab enum: https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2109
        StructComposition clogSubTabStruct = client.getStructComposition(clogSubTabStructId);
        int[] clogSubTabItemIds =
            client.getEnum(clogSubTabStruct.getIntValue(CLOG_SUB_TAB_ITEMS_PARAM_ID)).getIntVals();
        String subTabName = clogSubTabStruct.getStringValue(689);
        for (int clogSubTabItemId : clogSubTabItemIds) clogItems.add(clogSubTabItemId);
      }
    }
    // Some items with data saved on them have replacements to fix a duping issue (satchels,
    // flamtaer bag)
    // Enum 3721 contains a mapping of the item ids to replace -> ids to replace them with
    EnumComposition itemReplacementMapping = client.getEnum(ITEM_REPLACEMENT_MAPPING_ENUM_ID);
    for (int badItemId : itemReplacementMapping.getKeys()) clogItems.remove(badItemId);
    for (int goodItemId : itemReplacementMapping.getIntVals()) clogItems.add(goodItemId);
    // remove duplicate Prospector outfit
    for (int prospectorItemId : UNUSED_PROSPECTOR_ITEM_IDS) clogItems.remove(prospectorItemId);
    return clogItems;
  }
}

package io.septem150.xeric.data.player;

import java.util.List;
import lombok.Data;
import net.runelite.client.hiscore.HiscoreSkill;

@Data
public class KillCount {
  private String name;
  private int count;

  public static final List<HiscoreSkill> hiscoreSkills =
      List.of(
          HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE,
          HiscoreSkill.CHAMBERS_OF_XERIC,
          HiscoreSkill.ALCHEMICAL_HYDRA,
          HiscoreSkill.AMOXLIATL,
          HiscoreSkill.THE_HUEYCOATL,
          HiscoreSkill.SARACHNIS,
          HiscoreSkill.HESPORI,
          HiscoreSkill.SKOTIZO,
          HiscoreSkill.LUNAR_CHESTS,
          HiscoreSkill.SOL_HEREDIT,
          HiscoreSkill.WINTERTODT,
          HiscoreSkill.MIMIC,
          HiscoreSkill.YAMA,
          HiscoreSkill.DOOM_OF_MOKHAIOTL,
          HiscoreSkill.CLUE_SCROLL_ALL,
          HiscoreSkill.CLUE_SCROLL_EASY,
          HiscoreSkill.CLUE_SCROLL_MEDIUM,
          HiscoreSkill.CLUE_SCROLL_HARD,
          HiscoreSkill.CLUE_SCROLL_ELITE,
          HiscoreSkill.CLUE_SCROLL_MASTER,
          HiscoreSkill.COLOSSEUM_GLORY);
}

package io.septem150.xeric.data.player;

import lombok.Data;
import net.runelite.api.Client;
import net.runelite.api.Skill;

@Data
public class Level {
  private String name;
  private int amount;
  private int exp;

  public static Level from(Client client, Skill skill) {
    if (client == null || !client.isClientThread()) {
      throw new RuntimeException("must be on client thread");
    }
    Level level = new Level();
    level.name = skill.getName();
    level.amount = client.getRealSkillLevel(skill);
    level.exp = client.getSkillExperience(skill);
    return level;
  }

  public boolean isAccurate() {
    return amount != 0;
  }
}

package io.septem150.xeric.data.player;

import lombok.Data;

@Data
public class CombatAchievement {
  public static final int EASY_TIER_ENUM_ID = 3981;
  public static final int MEDIUM_TIER_ENUM_ID = 3982;
  public static final int HARD_TIER_ENUM_ID = 3983;
  public static final int ELITE_TIER_ENUM_ID = 3984;
  public static final int MASTER_TIER_ENUM_ID = 3985;
  public static final int GM_TIER_ENUM_ID = 3986;
  public static final int CA_STRUCT_ID_PARAM_ID = 1306;
  public static final int CA_STRUCT_NAME_PARAM_ID = 1308;
  public static final int CA_STRUCT_TIER_PARAM_ID = 1310;

  private int id;
  private String name;
  private int points;
}

package io.septem150.xeric.data.player;

import java.util.List;
import lombok.Data;
import net.runelite.api.Client;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;

@Data
public class QuestProgress {
  private Quest quest;
  private QuestState state;

  public static final List<Quest> trackedQuests =
      List.of(
          Quest.DRUIDIC_RITUAL,
          Quest.EAGLES_PEAK,
          Quest.RUNE_MYSTERIES,
          Quest.A_KINGDOM_DIVIDED,
          Quest.GETTING_AHEAD,
          Quest.THE_GARDEN_OF_DEATH,
          Quest.CHILDREN_OF_THE_SUN,
          Quest.TWILIGHTS_PROMISE,
          Quest.THE_HEART_OF_DARKNESS,
          Quest.X_MARKS_THE_SPOT,
          Quest.CLIENT_OF_KOUREND,
          Quest.THE_QUEEN_OF_THIEVES,
          Quest.THE_DEPTHS_OF_DESPAIR,
          Quest.THE_ASCENT_OF_ARCEUUS,
          Quest.THE_FORSAKEN_TOWER,
          Quest.TALE_OF_THE_RIGHTEOUS,
          Quest.PERILOUS_MOONS,
          Quest.THE_RIBBITING_TALE_OF_A_LILY_PAD_LABOUR_DISPUTE,
          Quest.AT_FIRST_LIGHT,
          Quest.DEATH_ON_THE_ISLE,
          Quest.MEAT_AND_GREET,
          Quest.ETHICALLY_ACQUIRED_ANTIQUITIES,
          Quest.THE_FINAL_DAWN,
          Quest.SHADOWS_OF_CUSTODIA,
          Quest.SCRAMBLED);

  public static QuestProgress from(Client client, Quest quest) {
    if (client == null || !client.isClientThread()) {
      throw new RuntimeException("must be on client thread");
    }
    QuestProgress progress = new QuestProgress();
    progress.quest = quest;
    progress.state = quest.getState(client);
    return progress;
  }
}

package io.septem150.xeric.data.player;

import java.awt.image.BufferedImage;
import java.util.Objects;
import java.util.function.Consumer;
import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreEndpoint;
import net.runelite.client.util.ImageUtil;

@RequiredArgsConstructor
@Getter
public enum AccountType {
  INVALID("Invalid", -1, -1, HiscoreEndpoint.NORMAL),
  DEFAULT("Default", 0, 32, HiscoreEndpoint.NORMAL),
  IRONMAN("Ironman", 1, 2, HiscoreEndpoint.IRONMAN),
  ULTIMATE("Ultimate Ironman", 2, 3, HiscoreEndpoint.ULTIMATE_IRONMAN),
  HARDCORE("Hardcore Ironman", 3, 10, HiscoreEndpoint.HARDCORE_IRONMAN),
  RANKED_GIM("Ranked Group Ironman", 4, 41, HiscoreEndpoint.NORMAL),
  HARDCORE_GIM("Hardcore Group Ironman", 5, 42, HiscoreEndpoint.NORMAL),
  UNRANKED_GIM("Unranked Group Ironman", 6, 43, HiscoreEndpoint.NORMAL);

  private static final int MODICONS_ARCHIVE_ID = 423;

  private final String refName;
  private final int varbValue;
  private final int spriteId;
  private final HiscoreEndpoint hiscoreEndpoint;

  public static AccountType fromVarbValue(int varbValue) {
    for (AccountType accountType : AccountType.values()) {
      if (accountType.varbValue == varbValue) {
        return accountType;
      }
    }
    return AccountType.INVALID;
  }

  public static AccountType fromName(String name) {
    for (AccountType accountType : AccountType.values()) {
      if (accountType.refName.equals(name)) {
        return accountType;
      }
    }
    return AccountType.INVALID;
  }

  public BufferedImage getImage(@NonNull SpriteManager spriteManager) {
    if (this == AccountType.INVALID) {
      return DEFAULT.getImage(spriteManager);
    }
    final BufferedImage sprite = spriteManager.getSprite(MODICONS_ARCHIVE_ID, this.getSpriteId());
    return ImageUtil.resizeImage(Objects.requireNonNull(sprite), 14, 14, true);
  }

  public void getImageAsync(@NonNull SpriteManager spriteManager, Consumer<BufferedImage> user) {
    spriteManager.getSpriteAsync(
        MODICONS_ARCHIVE_ID,
        this.getSpriteId(),
        image -> user.accept(ImageUtil.resizeImage(image, 14, 14, true)));
  }
}

package io.septem150.xeric.data.player;

import io.septem150.xeric.data.clog.CollectionLog;
import io.septem150.xeric.data.diary.DiaryProgress;
import io.septem150.xeric.data.task.Task;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.Data;
import lombok.NonNull;

@Data
public class PlayerInfo {
  private String username;
  private AccountType accountType;
  private boolean slayerException;
  private @NonNull List<QuestProgress> quests = new ArrayList<>();
  private @NonNull List<DiaryProgress> diaries = new ArrayList<>();
  private @NonNull Map<String, Level> levels = new HashMap<>();
  private @NonNull Map<String, KillCount> killCounts = new HashMap<>();
  private @NonNull List<CombatAchievement> combatAchievements = new ArrayList<>();
  private @NonNull CollectionLog collectionLog = new CollectionLog();
  private @NonNull List<Task> tasks = new ArrayList<>();

  public PlayerInfo() {
    clear();
  }

  public void clear() {
    username = null;
    accountType = null;
    slayerException = false;
    quests = new ArrayList<>();
    diaries = new ArrayList<>();
    levels = new HashMap<>();
    killCounts = new HashMap<>();
    combatAchievements = new ArrayList<>();
    collectionLog = new CollectionLog();
    tasks = new ArrayList<>();
  }

  public int getPoints() {
    return tasks.stream()
        .mapToInt(
            task -> {
              if (isSlayerException()) {
                return task.getSlayerPoints();
              }
              return task.getTier();
            })
        .sum();
  }

  public ClanRank getRank() {
    return ClanRank.fromPoints(getPoints());
  }
}

package io.septem150.xeric.data.player;

import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.text.WordUtils;

@RequiredArgsConstructor
@Getter
public enum ClanRank {
  CARRY(0, 3235, 0),
  BRONZE(25, 3153, 0),
  IRON(50, 3154, 0),
  STEEL(100, 3155, 0),
  OPAL(150, 3127, 0),
  JADE(200, 3128, 0),
  RED_TOPAZ(250, 3129, 0),
  SAPPHIRE(300, 3130, 0),
  EMERALD(400, 3131, 0),
  RUBY(500, 3132, 0),
  DIAMOND(600, 3133, 0),
  DRAGONSTONE(700, 3134, 0),
  ONYX(850, 3135, 0),
  ZENYTE(1000, 3136, 0),
  SPELLCASTER(1150, 3256, 0),
  SNIPER(1300, 3254, 0),
  XERICIAN(1450, 3229, 0),
  MAXED(1650, 3247, 0);

  /** All ranks sorted by points needed to obtain. */
  public static final List<ClanRank> ALL_RANKS =
      Arrays.stream(ClanRank.values())
          .sorted(Comparator.comparingInt(r -> r.pointsNeeded))
          .collect(Collectors.toList());

  private final int pointsNeeded;
  private final int archive;
  private final int file;

  public static ClanRank fromPoints(int points) {
    ClanRank obtainedRank = ClanRank.CARRY;
    for (ClanRank rank : ALL_RANKS) {
      if (points < rank.pointsNeeded) break;
      obtainedRank = rank;
    }
    return obtainedRank;
  }

  public ClanRank getNextRank() {
    return ALL_RANKS.get(Math.min(ALL_RANKS.indexOf(this) + 1, ALL_RANKS.size() - 1));
  }

  @Override
  public String toString() {
    return WordUtils.capitalizeFully(String.format("%s Rank", this.name()));
  }

  public BufferedImage getImage(@NonNull SpriteManager spriteManager) {
    return ImageUtil.resizeImage(
        Objects.requireNonNull(spriteManager.getSprite(archive, file)), 32, 32, true);
  }

  public void getImageAsync(@NonNull SpriteManager spriteManager, Consumer<BufferedImage> user) {
    spriteManager.getSpriteAsync(
        archive, file, image -> user.accept(ImageUtil.resizeImage(image, 32, 32, true)));
  }
}

package io.septem150.xeric.data.task;

import io.septem150.xeric.data.player.PlayerInfo;
import io.septem150.xeric.util.ResourceUtil;
import java.awt.image.BufferedImage;
import java.util.Objects;
import java.util.Set;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.Setter;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;

@Setter
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
public class CollectTask extends Task {
  private Set<Integer> itemIds;
  private int amount;

  @Override
  public boolean checkCompletion(@NonNull PlayerInfo playerInfo) {
    if (itemIds.isEmpty()) {
      return playerInfo.getCollectionLog().size() >= amount;
    }
    Set<Integer> playerItemIds = playerInfo.getCollectionLog().getItemIds();
    int amountRemaining = amount;
    for (int itemId : playerItemIds) {
      if (itemIds.contains(itemId)) {
        amountRemaining--;
      }
      if (amountRemaining == 0) break;
    }
    return amountRemaining <= 0;
  }

  @Override
  public BufferedImage getIcon(SpriteManager spriteManager) {
    if (this.getIcon() != null) {
      return ResourceUtil.getImage(this.getIcon(), ICON_SIZE, ICON_SIZE, true);
    }
    return ImageUtil.resizeImage(
        Objects.requireNonNull(spriteManager.getSprite(3390, 0)), 20, 20, true);
  }
}

package io.septem150.xeric.data.task;

import io.septem150.xeric.data.player.PlayerInfo;
import java.awt.image.BufferedImage;
import java.io.Serializable;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.Setter;
import lombok.ToString;
import net.runelite.client.game.SpriteManager;

@NoArgsConstructor
@Setter
@Getter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@ToString
public abstract class Task implements Serializable {
  protected static final int ICON_SIZE = 20;

  @EqualsAndHashCode.Include private int id;
  private String icon;
  private String name;
  private TaskType type;
  private int tier;
  int slayerPoints;

  public abstract boolean checkCompletion(@NonNull PlayerInfo playerInfo);

  public abstract BufferedImage getIcon(SpriteManager spriteManager);
}

package io.septem150.xeric.data.task;

import io.septem150.xeric.data.player.Level;
import io.septem150.xeric.data.player.PlayerInfo;
import io.septem150.xeric.util.ResourceUtil;
import java.awt.image.BufferedImage;
import java.util.Objects;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.Setter;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.text.WordUtils;

@Setter
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
public class LevelTask extends Task {
  private String level;
  private int goal;

  @Override
  public boolean checkCompletion(@NonNull PlayerInfo playerInfo) {
    switch (level.toLowerCase()) {
      case "total":
        int total = playerInfo.getLevels().values().stream().mapToInt(Level::getAmount).sum();
        return total >= goal;
      case "any":
        for (Level playerLevel : playerInfo.getLevels().values()) {
          int currentExp = playerLevel.getExp();
          if (currentExp >= goal) {
            return true;
          }
        }
        return false;
      case "maxed":
        int maxed = 0;
        for (Level playerLevel : playerInfo.getLevels().values()) {
          if (playerLevel.getAmount() >= 99) {
            maxed++;
          }
        }
        return maxed >= goal;
      default:
        Level playerLevel = playerInfo.getLevels().getOrDefault(WordUtils.capitalize(level), null);
        if (playerLevel == null) return false;
        return playerLevel.getAmount() >= goal;
    }
  }

  @Override
  public BufferedImage getIcon(SpriteManager spriteManager) {
    if (this.getIcon() != null) {
      return ResourceUtil.getImage(this.getIcon(), ICON_SIZE, ICON_SIZE, true);
    }
    return ImageUtil.resizeImage(
        Objects.requireNonNull(spriteManager.getSprite(3387, 0)), 20, 20, true);
  }
}

package io.septem150.xeric.data.task;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import io.septem150.xeric.ProjectXericPlugin;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Singleton
public final class LocalTaskStore implements TaskStore {
  private static final String TASKS_RES_PATH = "data/rank_tasks.json";

  private final Gson gson;

  private @Nullable List<Task> tasksList;
  private @Nullable CompletableFuture<List<Task>> future;

  @Inject
  public LocalTaskStore(@Named("xericGson") Gson gson) {
    this.gson = gson;
  }

  @Override
  public @NonNull List<Task> getAll() {
    if (tasksList != null) return tasksList;
    try {
      return getAllAsync().get();
    } catch (InterruptedException | ExecutionException err) {
      throw new RuntimeException(err);
    }
  }

  @Override
  public @NonNull CompletableFuture<List<Task>> getAllAsync() {
    return getAllAsync(true);
  }

  @Override
  public @NonNull CompletableFuture<List<Task>> getAllAsync(boolean cached) {
    if (!cached || tasksList == null) {
      if (future == null || future.isDone()) {
        try (InputStream in = ProjectXericPlugin.class.getResourceAsStream(TASKS_RES_PATH)) {
          if (in == null) {
            throw new FileNotFoundException(
                String.format("Unable to access resource '%s'", TASKS_RES_PATH));
          }
          Type type = new TypeToken<List<Task>>() {}.getType();
          tasksList = gson.fromJson(new InputStreamReader(in, StandardCharsets.UTF_8), type);
          future = CompletableFuture.completedFuture(tasksList);
        } catch (Exception err) {
          future = CompletableFuture.failedFuture(err);
        }
      }
    } else {
      future = CompletableFuture.completedFuture(tasksList);
    }
    return future;
  }

  @Override
  public void reset() {
    tasksList = null;
  }
}

package io.septem150.xeric.data.task;

import io.septem150.xeric.data.player.PlayerInfo;
import java.awt.image.BufferedImage;
import java.util.Objects;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.Setter;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;

@Setter
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
public class DiaryTask extends Task {
  private String diary;

  @Override
  public boolean checkCompletion(@NonNull PlayerInfo playerInfo) {
    return playerInfo.getDiaries().stream()
        .anyMatch(
            diaryProgress ->
                diaryProgress.getDiary().getName().equals(diary) && diaryProgress.isCompleted());
  }

  @Override
  public BufferedImage getIcon(SpriteManager spriteManager) {
    return ImageUtil.resizeImage(
        Objects.requireNonNull(spriteManager.getSprite(1299, 0)), 20, 20, true);
  }
}

package io.septem150.xeric.data.task;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import lombok.NonNull;

public interface TaskStore {
  @NonNull List<Task> getAll();

  @NonNull CompletableFuture<List<Task>> getAllAsync();

  @NonNull CompletableFuture<List<Task>> getAllAsync(boolean cached);

  void reset();
}

package io.septem150.xeric.data.task;

import io.septem150.xeric.data.player.PlayerInfo;
import java.awt.image.BufferedImage;
import java.util.Objects;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.Setter;
import net.runelite.api.QuestState;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;

@Setter
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
public class QuestTask extends Task {
  private String quest;

  @Override
  public boolean checkCompletion(@NonNull PlayerInfo playerInfo) {
    return playerInfo.getQuests().stream()
        .anyMatch(
            questProgress ->
                questProgress.getQuest().getName().equals(quest)
                    && questProgress.getState() == QuestState.FINISHED);
  }

  @Override
  public BufferedImage getIcon(SpriteManager spriteManager) {
    return ImageUtil.resizeImage(
        Objects.requireNonNull(spriteManager.getSprite(899, 0)), 20, 20, true);
  }
}

package io.septem150.xeric.data.task;

import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum TaskType {
  @SerializedName("collect")
  CLOG("collect"),
  @SerializedName("level")
  LEVEL("level"),
  @SerializedName("kc")
  HISCORE("kc"),
  @SerializedName("ca")
  CA("ca"),
  @SerializedName("quest")
  QUEST("quest"),
  @SerializedName("diary")
  DIARY("diary");

  private final String name;
}

package io.septem150.xeric.data.task;

import io.septem150.xeric.data.player.PlayerInfo;
import java.awt.image.BufferedImage;
import java.util.Objects;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.Setter;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.ImageUtil;

@Setter
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
public class CATask extends Task {
  private int total;

  @Override
  public boolean checkCompletion(@NonNull PlayerInfo playerInfo) {
    return playerInfo.getCombatAchievements().size() >= total;
  }

  @Override
  public BufferedImage getIcon(SpriteManager spriteManager) {
    return ImageUtil.resizeImage(
        Objects.requireNonNull(spriteManager.getSprite(3389, 0)), ICON_SIZE, ICON_SIZE, true);
  }
}

package io.septem150.xeric.data.task;

import io.septem150.xeric.data.player.KillCount;
import io.septem150.xeric.data.player.PlayerInfo;
import io.septem150.xeric.util.ImageCoord;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.Setter;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.util.ImageUtil;

@Setter
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
public class KCTask extends Task {
  private static final Map<String, ImageCoord> iconMap = new HashMap<>();

  private String boss;
  private int total;

  static {
    iconMap.put(HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE.getName(), new ImageCoord(4296, 0));
    iconMap.put(HiscoreSkill.CHAMBERS_OF_XERIC.getName(), new ImageCoord(4288, 0));
    iconMap.put(HiscoreSkill.ALCHEMICAL_HYDRA.getName(), new ImageCoord(4289, 0));
    iconMap.put(HiscoreSkill.AMOXLIATL.getName(), new ImageCoord(5639, 0));
    iconMap.put(HiscoreSkill.THE_HUEYCOATL.getName(), new ImageCoord(5640, 0));
    iconMap.put(HiscoreSkill.SARACHNIS.getName(), new ImageCoord(4269, 0));
    iconMap.put(HiscoreSkill.HESPORI.getName(), new ImageCoord(4271, 0));
    iconMap.put(HiscoreSkill.SKOTIZO.getName(), new ImageCoord(4272, 0));
    iconMap.put(HiscoreSkill.LUNAR_CHESTS.getName(), new ImageCoord(5637, 0));
    iconMap.put(HiscoreSkill.SOL_HEREDIT.getName(), new ImageCoord(5636, 0));
    iconMap.put(HiscoreSkill.COLOSSEUM_GLORY.getName(), new ImageCoord(5862, 0));
    iconMap.put(HiscoreSkill.WINTERTODT.getName(), new ImageCoord(4266, 0));
    iconMap.put(HiscoreSkill.MIMIC.getName(), new ImageCoord(4260, 0));
    iconMap.put(HiscoreSkill.YAMA.getName(), new ImageCoord(6346, 0));
    iconMap.put(HiscoreSkill.DOOM_OF_MOKHAIOTL.getName(), new ImageCoord(6347, 0));
    iconMap.put("Clues", new ImageCoord(5853, 0));
  }

  @Override
  public boolean checkCompletion(@NonNull PlayerInfo playerInfo) {
    String name = boss;
    if ("Lunar Chest".equals(name)) {
      name += "s";
    } else if ("Hueycoatl".equals(name)) {
      name = "The " + name;
    }
    KillCount kc = playerInfo.getKillCounts().getOrDefault(name, null);
    if (kc == null) return false;
    return kc.getCount() >= total;
  }

  @Override
  public BufferedImage getIcon(SpriteManager spriteManager) {
    String name = boss;
    if ("Lunar Chest".equals(name)) {
      name += "s";
    } else if ("Hueycoatl".equals(name)) {
      name = "The " + name;
    } else if (boss.contains("Clue")) {
      name = "Clues";
    }
    ImageCoord coord = iconMap.get(name);
    return ImageUtil.resizeImage(
        Objects.requireNonNull(spriteManager.getSprite(coord.archive, coord.file)), 20, 20, true);
  }
}

package io.septem150.xeric;

import com.google.gson.Gson;
import com.google.inject.Binder;
import com.google.inject.Provides;
import io.septem150.xeric.data.ProjectXericManager;
import io.septem150.xeric.data.task.CATask;
import io.septem150.xeric.data.task.CollectTask;
import io.septem150.xeric.data.task.DiaryTask;
import io.septem150.xeric.data.task.KCTask;
import io.septem150.xeric.data.task.LevelTask;
import io.septem150.xeric.data.task.LocalTaskStore;
import io.septem150.xeric.data.task.QuestTask;
import io.septem150.xeric.data.task.Task;
import io.septem150.xeric.data.task.TaskStore;
import io.septem150.xeric.data.task.TaskType;
import io.septem150.xeric.panel.ProjectXericPanel;
import io.septem150.xeric.util.RuntimeTypeAdapterFactory;
import javax.inject.Inject;
import javax.inject.Named;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

/**
 * Project Xeric plugin.
 *
 * @author <a href="mailto:carson.mullins@proton.me">Septem 150</a>
 */
@Slf4j
@PluginDescriptor(name = ProjectXericConfig.NAME)
public final class ProjectXericPlugin extends Plugin {
  @Inject
  private @Named("xericGson") Gson gson;

  @Inject private ConfigManager configManager;
  @Inject private ProjectXericManager manager;
  @Inject private EventBus eventBus;

  private ProjectXericPanel panel;
  private int updatePanel;

  @Override
  protected void startUp() throws Exception {
    log.info("Project Xeric started!");
    panel = injector.getInstance(ProjectXericPanel.class);
    eventBus.register(manager);
    manager.startUp(panel);
    panel.startUp();
    SwingUtilities.invokeLater(panel::refresh);
  }

  @Override
  protected void shutDown() throws Exception {
    log.info("Project Xeric stopped!");
    eventBus.unregister(manager);
    panel.shutDown();
    manager.shutDown();
  }

  @Subscribe
  public void onCommandExecuted(CommandExecuted event) {
    if (event.getCommand().equals("xeric")) {
      // ::xeric - resets your saved collection log data and refreshes the side panel
      configManager.unsetRSProfileConfiguration(
          ProjectXericConfig.GROUP, ProjectXericConfig.CLOG_DATA_KEY);
      configManager.unsetRSProfileConfiguration(
          ProjectXericConfig.GROUP, ProjectXericConfig.TASKS_DATA_KEY);
      panel.shutDown();
      manager.getPlayerInfo().clear();
      manager.shutDown();
      manager.startUp(panel);
      panel.startUp();
      SwingUtilities.invokeLater(panel::refresh);
    }
  }

  @Override
  public void configure(Binder binder) {
    super.configure(binder);
    binder.bind(TaskStore.class).to(LocalTaskStore.class);
  }

  @Provides
  ProjectXericConfig provideConfig(ConfigManager configManager) {
    return configManager.getConfig(ProjectXericConfig.class);
  }

  @Provides
  @Named("xericGson")
  public Gson provideGson(Gson gson) {
    RuntimeTypeAdapterFactory<Task> taskTypeAdapterFactory =
        RuntimeTypeAdapterFactory.of(Task.class, "type", true)
            .registerSubtype(CATask.class, TaskType.CA.getName())
            .registerSubtype(CollectTask.class, TaskType.CLOG.getName())
            .registerSubtype(DiaryTask.class, TaskType.DIARY.getName())
            .registerSubtype(KCTask.class, TaskType.HISCORE.getName())
            .registerSubtype(LevelTask.class, TaskType.LEVEL.getName())
            .registerSubtype(QuestTask.class, TaskType.QUEST.getName());

    return gson.newBuilder()
        .disableHtmlEscaping()
        .registerTypeAdapterFactory(taskTypeAdapterFactory)
        .create();
  }
}

package io.septem150.xeric;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

/**
 * Project Xeric plugin configuration.
 *
 * @author <a href="mailto:carson.mullins@proton.me">Septem 150</a>
 */
@ConfigGroup(ProjectXericConfig.GROUP)
public interface ProjectXericConfig extends Config {
  String NAME = "Project Xeric";
  String GROUP = "projectxeric";
  String CLOG_DATA_KEY = "clog";
  String TASKS_DATA_KEY = "tasks";
  String SLAYER_CONFIG_KEY = "slayer";
  String CHAT_MESSAGES_CONFIG_KEY = "chat_messages";

  @ConfigItem(
      keyName = SLAYER_CONFIG_KEY,
      name = "Slayer Exception",
      description = "Toggle on if you train Slayer off-island.")
  default boolean slayer() {
    return false;
  }

  @ConfigItem(
      keyName = CHAT_MESSAGES_CONFIG_KEY,
      name = "Task Completion Chat Messages",
      description = "Toggle on to receive chat messages upon completing tasks.")
  default boolean chatMessages() {
    return true;
  }
}

package io.septem150.xeric.panel.summary;

import io.septem150.xeric.data.ProjectXericManager;
import io.septem150.xeric.data.task.Task;
import io.septem150.xeric.data.task.TaskStore;
import io.septem150.xeric.data.task.TaskType;
import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;
import javax.swing.*;
import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.SpriteManager;

@Slf4j
public class TaskTierPanel extends JPanel {
  @Getter private final int tier;
  private List<TaskPanel> taskPanels = new ArrayList<>();

  private final transient TaskStore taskStore;
  private final transient ProjectXericManager manager;
  private final transient SpriteManager spriteManager;

  private final JLabel tierAndCountLabel = new JLabel();
  private final JPanel tasksContainerPanel = new JPanel();

  private boolean loaded;

  public TaskTierPanel(
      int tier,
      @NonNull TaskStore taskStore,
      @NonNull ProjectXericManager manager,
      @NonNull SpriteManager spriteManager) {
    this.tier = tier;
    this.taskStore = taskStore;
    this.manager = manager;
    this.spriteManager = spriteManager;
  }

  private void initComponents() {
    // set up tier label and get count
    tierAndCountLabel.setText(
        String.format(
            "Tier %d Tasks (%d/%d)",
            tier,
            (int) taskPanels.stream().filter(TaskPanel::isCompleted).count(),
            taskPanels.size()));
    tierAndCountLabel.setHorizontalAlignment(SwingConstants.LEFT);
    tierAndCountLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
    tierAndCountLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));

    // set up tasks container
    tasksContainerPanel.setOpaque(false);
    tasksContainerPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 5));
    tasksContainerPanel.setLayout(new BoxLayout(tasksContainerPanel, BoxLayout.Y_AXIS));
    tasksContainerPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

    // setup parent panel and add components to layout
    setOpaque(false);
    setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
    add(tierAndCountLabel);
    add(Box.createRigidArea(new Dimension(0, 5)));
    add(tasksContainerPanel);
  }

  public void startUp() {
    taskPanels =
        taskStore.getAll().stream()
            .filter(task -> task.getTier() == tier)
            .sorted(Comparator.comparing(Task::getType).thenComparing(Task::getName))
            .map(task -> new TaskPanel(task, manager, spriteManager))
            .collect(Collectors.toList());
    if (!loaded) {
      removeAll();
      initComponents();
      loaded = true;
    }
    for (TaskPanel taskPanel : taskPanels) {
      taskPanel.startUp();
    }
    refresh();
  }

  private void refresh() {
    tierAndCountLabel.setText(
        String.format(
            "Tier %d Tasks (%d/%d)",
            tier,
            (int) taskPanels.stream().filter(TaskPanel::isCompleted).count(),
            taskPanels.size()));
    tasksContainerPanel.removeAll();
    for (int i = 0; i < taskPanels.size(); i++) {
      TaskPanel taskPanel = taskPanels.get(i);
      taskPanel.refresh();
      if (taskPanel.isVisible()) {
        tasksContainerPanel.add(taskPanel);
        if (i < taskPanels.size() - 1) {
          tasksContainerPanel.add(Box.createRigidArea(new Dimension(0, 5)));
        }
      }
    }
    revalidate();
  }

  public void applyFilter(String search, boolean showCompleted) {
    invalidate();
    int countShown = 0;
    for (TaskPanel taskPanel : taskPanels) {
      taskPanel.refresh();
      if ((taskPanel.getTaskType().equalsIgnoreCase(search)
              || (Arrays.stream(TaskType.values())
                      .noneMatch(taskType -> taskType.getName().equalsIgnoreCase(search)))
                  && taskPanel.getTaskName().toLowerCase().contains(search.toLowerCase()))
          && (showCompleted || !taskPanel.isCompleted())) {
        taskPanel.setVisible(true);
        countShown++;
        continue;
      }
      taskPanel.setVisible(false);
    }
    setVisible(countShown != 0);
    refresh();
  }
}

package io.septem150.xeric.panel.summary;

import io.septem150.xeric.data.ProjectXericManager;
import java.awt.BorderLayout;
import java.awt.CardLayout;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

@Slf4j
@Singleton
public class SummaryPanel extends JPanel {
  public static final String TOOLTIP = "Player Summary";
  public static final String TAB_ICON = "summary_tab_icon.png";

  private final ProjectXericManager manager;
  private final TaskListPanel taskListPanel;
  private final IdCard idCardPanel;

  @Inject
  private SummaryPanel(
      ProjectXericManager manager, TaskListPanel taskListPanel, IdCard idCardPanel) {
    this.manager = manager;
    this.taskListPanel = taskListPanel;
    this.idCardPanel = idCardPanel;
  }

  private static final String LOGGED_OUT_CONSTRAINT = "LOGGED_OUT";
  private static final String LOGGED_IN_CONSTRAINT = "LOGGED_IN";
  private final CardLayout layout = new CardLayout();
  private final JLabel loginLabel = new JLabel();
  private final JLabel clogLabel = new JLabel();
  private final JPanel loggedOutPanel = new JPanel();
  private final JPanel loggedInPanel = new JPanel();
  private final JPanel taskListContainerPanel = new JPanel();

  private boolean loaded;

  private void initComponent() {
    loginLabel.setText(
        "<html><body style='text-align: center'>Log in to start tracking Xeric"
            + " Tasks.</body></html>");
    loginLabel.setFont(FontManager.getRunescapeSmallFont());
    loginLabel.setForeground(ColorScheme.BRAND_ORANGE);
    loginLabel.setBorder(new EmptyBorder(20, 0, 0, 0));
    loginLabel.setHorizontalAlignment(SwingConstants.CENTER);

    clogLabel.setText(
        "<html><body style='text-align: center'>Open the Collection Log to start tracking Xeric"
            + " Tasks.</body></html>");
    clogLabel.setFont(FontManager.getRunescapeSmallFont());
    clogLabel.setForeground(ColorScheme.BRAND_ORANGE);
    clogLabel.setBorder(new EmptyBorder(0, 0, 5, 0));
    clogLabel.setHorizontalAlignment(SwingConstants.CENTER);

    loggedOutPanel.setLayout(new BorderLayout());
    loggedOutPanel.add(loginLabel, BorderLayout.NORTH);

    loggedInPanel.setLayout(new BorderLayout());
    loggedInPanel.add(idCardPanel, BorderLayout.NORTH);
    loggedInPanel.add(taskListContainerPanel, BorderLayout.CENTER);

    taskListContainerPanel.setLayout(new BorderLayout());
    taskListContainerPanel.add(clogLabel, BorderLayout.NORTH);
    taskListContainerPanel.add(taskListPanel, BorderLayout.CENTER);

    setLayout(layout);
    setBackground(ColorScheme.DARK_GRAY_COLOR);
    add(loggedOutPanel, LOGGED_OUT_CONSTRAINT);
    add(loggedInPanel, LOGGED_IN_CONSTRAINT);
  }

  public void startUp() {
    if (!loaded) {
      removeAll();
      initComponent();
      loaded = true;
    }
    refresh();
  }

  public void startupChildren() {
    taskListPanel.startUp();
  }

  public void refresh() {
    if (manager.getPlayerInfo().getUsername() == null) {
      layout.show(this, LOGGED_OUT_CONSTRAINT);
    } else {
      layout.show(this, LOGGED_IN_CONSTRAINT);
      clogLabel.setVisible(manager.getPlayerInfo().getCollectionLog().getLastOpened() == null);
      idCardPanel.reload();
      taskListPanel.reload();
    }
    revalidate();
  }
}

package io.septem150.xeric.panel.summary;

import io.septem150.xeric.data.ProjectXericManager;
import io.septem150.xeric.data.task.Task;
import io.septem150.xeric.data.task.TaskStore;
import io.septem150.xeric.data.task.TaskType;
import io.septem150.xeric.util.ResourceUtil;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.IconTextField;

@Singleton
public class TaskListPanel extends JPanel {
  private final TaskStore taskStore;
  private final ProjectXericManager manager;
  private final SpriteManager spriteManager;

  private List<TaskTierPanel> tierPanels = new ArrayList<>();

  private final IconTextField searchBar = new IconTextField();
  private final JToggleButton showCompletedButton = new JToggleButton();
  private final JPanel controlsContainerPanel = new JPanel();
  private final JPanel taskTiersContainerPanel = new JPanel();
  private final JScrollPane scrollContainerPanel = new JScrollPane();

  private boolean loaded;

  @Inject
  public TaskListPanel(
      TaskStore taskStore, ProjectXericManager manager, SpriteManager spriteManager) {
    this.taskStore = taskStore;
    this.manager = manager;
    this.spriteManager = spriteManager;
  }

  private void initComponents() {
    // set up search bar, toggle button, and tasks panel
    searchBar.setIcon(IconTextField.Icon.SEARCH);
    searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
    searchBar
        .getDocument()
        .addDocumentListener(
            new DocumentListener() {
              @Override
              public void insertUpdate(DocumentEvent documentEvent) {
                reload();
              }

              @Override
              public void removeUpdate(DocumentEvent documentEvent) {
                reload();
              }

              @Override
              public void changedUpdate(DocumentEvent documentEvent) {
                // do nothing, event not used
              }
            });
    for (TaskType taskType : TaskType.values()) {
      searchBar.getSuggestionListModel().addElement(taskType.getName().toUpperCase());
    }

    showCompletedButton.setIcon(
        new ImageIcon(ResourceUtil.getImage("show_completed_disabled.png")));
    showCompletedButton.setSelectedIcon(
        new ImageIcon(ResourceUtil.getImage("show_completed_enabled.png")));
    showCompletedButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    showCompletedButton.addActionListener(unused -> reload());

    // setup parent panel and add components to layout
    controlsContainerPanel.setOpaque(false);
    controlsContainerPanel.setLayout(new BorderLayout(5, 0));
    controlsContainerPanel.add(searchBar, BorderLayout.CENTER);
    controlsContainerPanel.add(showCompletedButton, BorderLayout.EAST);

    taskTiersContainerPanel.setOpaque(false);
    taskTiersContainerPanel.setLayout(new BoxLayout(taskTiersContainerPanel, BoxLayout.Y_AXIS));

    scrollContainerPanel.setOpaque(false);
    scrollContainerPanel.setViewportView(taskTiersContainerPanel);
    scrollContainerPanel.setWheelScrollingEnabled(true);
    scrollContainerPanel.setHorizontalScrollBarPolicy(
        ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
    scrollContainerPanel.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

    setOpaque(false);
    setLayout(new BorderLayout(0, 5));
    add(controlsContainerPanel, BorderLayout.NORTH);
    add(scrollContainerPanel, BorderLayout.CENTER);
  }

  public void startUp() {
    tierPanels =
        taskStore.getAll().stream()
            .map(Task::getTier)
            .distinct()
            .sorted()
            .map(tier -> new TaskTierPanel(tier, taskStore, manager, spriteManager))
            .collect(Collectors.toList());
    if (!loaded) {
      removeAll();
      initComponents();
      loaded = true;
    }
    for (TaskTierPanel taskTierPanel : tierPanels) {
      taskTierPanel.startUp();
    }
    reload();
  }

  public void reload() {
    invalidate();
    scrollContainerPanel.setBorder(BorderFactory.createEmptyBorder());
    setBorder(BorderFactory.createEmptyBorder());
    String search = searchBar.getText();
    taskTiersContainerPanel.removeAll();
    for (int i = 0; i < tierPanels.size(); i++) {
      TaskTierPanel taskTierPanel = tierPanels.get(i);
      taskTierPanel.applyFilter(search, showCompletedButton.isSelected());
      if (taskTierPanel.isVisible()) {
        taskTiersContainerPanel.add(taskTierPanel);
        if (i < tierPanels.size() - 1) {
          taskTiersContainerPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        }
      }
    }
    revalidate();
  }
}

package io.septem150.xeric.panel.summary;

import io.septem150.xeric.data.ProjectXericManager;
import io.septem150.xeric.data.task.Task;
import java.awt.*;
import javax.swing.*;
import lombok.NonNull;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;

public class TaskPanel extends JPanel {
  private final Task task;

  private final transient ProjectXericManager manager;
  private final transient SpriteManager spriteManager;

  private final JLabel nameAndIconLabel = new JLabel();
  private final JCheckBox completedCheckbox = new JCheckBox();

  private boolean loaded;

  public TaskPanel(
      @NonNull Task task,
      @NonNull ProjectXericManager manager,
      @NonNull SpriteManager spriteManager) {
    this.task = task;
    this.manager = manager;
    this.spriteManager = spriteManager;
  }

  private void initComponents() {
    // set up name and icon label
    nameAndIconLabel.setText(task.getName());
    nameAndIconLabel.setIconTextGap(5);
    nameAndIconLabel.setIcon(new ImageIcon(task.getIcon(spriteManager)));
    nameAndIconLabel.setHorizontalAlignment(SwingConstants.LEFT);
    nameAndIconLabel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 0));

    // set up completed checkbox
    completedCheckbox.setEnabled(false);
    completedCheckbox.setSelected(manager.getPlayerInfo().getTasks().contains(task));
    completedCheckbox.setBorder(BorderFactory.createEmptyBorder(5, 0, 5, 5));

    // setup parent panel and add components to layout
    setBackground(ColorScheme.DARKER_GRAY_COLOR);
    setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
    add(nameAndIconLabel);
    add(Box.createHorizontalGlue());
    add(completedCheckbox, BorderLayout.EAST);
  }

  public void startUp() {
    if (!loaded) {
      removeAll();
      initComponents();
      loaded = true;
    }
    refresh();
  }

  public void refresh() {
    completedCheckbox.setSelected(manager.getPlayerInfo().getTasks().contains(task));
    revalidate();
  }

  public boolean isCompleted() {
    return completedCheckbox.isSelected();
  }

  public String getTaskName() {
    return task.getName();
  }

  public String getTaskType() {
    return task.getType().getName();
  }
}

package io.septem150.xeric.panel.summary;

import com.google.common.collect.Iterables;
import io.septem150.xeric.data.ProjectXericManager;
import io.septem150.xeric.data.player.ClanRank;
import io.septem150.xeric.data.player.PlayerInfo;
import io.septem150.xeric.data.task.Task;
import io.septem150.xeric.data.task.TaskStore;
import io.septem150.xeric.panel.JLabeledValue;
import io.septem150.xeric.util.ResourceUtil;
import io.septem150.xeric.util.TransferableBufferedImage;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;
import org.apache.commons.text.WordUtils;

@Singleton
public class IdCard extends JPanel {
  private final ProjectXericManager manager;
  private final TaskStore taskStore;
  private final SpriteManager spriteManager;

  @Inject
  private IdCard(ProjectXericManager manager, TaskStore taskStore, SpriteManager spriteManager) {
    this.manager = manager;
    this.taskStore = taskStore;
    this.spriteManager = spriteManager;

    setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));
    add(wrappedPanel, BorderLayout.NORTH);

    SwingUtil.removeButtonDecorations(screenshotButton);
    screenshotButton.setToolTipText("Copy ID Card to your clipboard");
    screenshotButton.setUI(new BasicButtonUI());
    screenshotButton.setBorder(new EmptyBorder(0, 0, 0, 0));
    screenshotButton.setFocusable(false);
    screenshotButton.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
    screenshotButton.addActionListener(
        actionEvent -> {
          BufferedImage image =
              new BufferedImage(
                  wrappedPanel.getWidth(), wrappedPanel.getHeight(), BufferedImage.TYPE_INT_RGB);
          screenshotButton.setVisible(false);
          wrappedPanel.paint(image.getGraphics());
          screenshotButton.setVisible(true);
          Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
          TransferableBufferedImage transferableImage = new TransferableBufferedImage(image);
          clipboard.setContents(transferableImage, null);
        });
    screenshotButton.addMouseListener(
        new MouseAdapter() {
          @Override
          public void mouseEntered(MouseEvent e) {
            screenshotButton.setBorder(new EmptyBorder(0, 0, 0, 0));
          }

          @Override
          public void mouseExited(MouseEvent e) {
            screenshotButton.setBorder(new EmptyBorder(0, 0, 0, 0));
          }
        });
  }

  private final JPanel wrappedPanel = new JPanel(new GridBagLayout());
  private final JLabel rank = new JLabel();
  private final JLabel username = new JLabel();
  private final JLabeledValue points = new JLabeledValue();
  private final JLabel herbException = new JLabel();
  private final JLabel chinException = new JLabel();
  private final JLabel slayException = new JLabel();
  private final JLabeledValue tasksCompleted = new JLabeledValue();
  private final JLabeledValue pointsToNextRank = new JLabeledValue();
  private final JLabeledValue highestTierCompleted = new JLabeledValue();
  private final JButton screenshotButton = new JButton();

  private void makeLayout() {
    removeAll();
    wrappedPanel.removeAll();
    wrappedPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    wrappedPanel.setBorder(new LineBorder(ColorScheme.BORDER_COLOR, 1));
    setLayout(new BorderLayout());
    rank.setPreferredSize(new Dimension(32, 32));
    wrappedPanel.add(rank, gbc(0, 0, 1, 2, 0, GridBagConstraints.CENTER, new Insets(5, 10, 5, 5)));

    username.setFont(FontManager.getDefaultFont().deriveFont(Font.BOLD, 14));
    wrappedPanel.add(username, gbc(1, 0, 2, 1, 1, GridBagConstraints.WEST, new Insets(5, 0, 1, 0)));

    final JPanel exceptions = new JPanel();
    exceptions.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    exceptions.setLayout(new BoxLayout(exceptions, BoxLayout.X_AXIS));
    herbException.setAlignmentY(Component.BOTTOM_ALIGNMENT);
    chinException.setAlignmentY(Component.BOTTOM_ALIGNMENT);
    slayException.setAlignmentY(Component.BOTTOM_ALIGNMENT);
    exceptions.add(herbException);
    exceptions.add(chinException);
    exceptions.add(slayException);
    wrappedPanel.add(
        exceptions, gbc(1, 1, 2, 1, 1, GridBagConstraints.WEST, new Insets(1, 0, 5, 0)));

    wrappedPanel.add(
        points, gbc(3, 0, 1, 2, 0, GridBagConstraints.CENTER, new Insets(5, 5, 5, 10)));

    wrappedPanel.add(
        tasksCompleted, gbc(0, 2, 2, 1, 0, GridBagConstraints.WEST, new Insets(5, 10, 5, 5)));

    wrappedPanel.add(
        pointsToNextRank, gbc(2, 2, 2, 1, 0, GridBagConstraints.EAST, new Insets(5, 5, 5, 10)));

    wrappedPanel.add(
        highestTierCompleted,
        gbc(0, 3, 3, 1, 0, GridBagConstraints.CENTER, new Insets(5, 10, 5, 5)));

    wrappedPanel.add(
        screenshotButton, gbc(3, 3, 1, 1, 0, GridBagConstraints.CENTER, new Insets(5, 5, 5, 10)));
    add(wrappedPanel, BorderLayout.NORTH);
  }

  private GridBagConstraints gbc(
      int x, int y, int width, int height, double weightX, int anchor, Insets insets) {
    GridBagConstraints gbc = new GridBagConstraints();
    gbc.gridx = x;
    gbc.gridy = y;
    gbc.gridwidth = width;
    gbc.gridheight = height;
    gbc.fill = GridBagConstraints.NONE;
    gbc.weightx = weightX;
    gbc.anchor = anchor;
    gbc.insets = insets;
    return gbc;
  }

  private void makeStaticData() {
    points.setLabel("Points");
    tasksCompleted.setLabel("Tasks completed");
    pointsToNextRank.setLabel("Points to next rank");
    highestTierCompleted.setLabel("Highest tier completed");
    screenshotButton.setIcon(
        new ImageIcon(
            ResourceUtil.getImage("/net/runelite/client/plugins/screenshot/screenshot.png")));
  }

  private void makeDynamicData() {
    PlayerInfo playerInfo = manager.getPlayerInfo();
    int playerPoints = playerInfo.getPoints();
    ClanRank playerRank = playerInfo.getRank();
    playerRank.getImageAsync(spriteManager, image -> rank.setIcon(new ImageIcon(image)));
    rank.setToolTipText(WordUtils.capitalizeFully(playerRank.name()));
    playerInfo
        .getAccountType()
        .getImageAsync(spriteManager, image -> username.setIcon(new ImageIcon(image)));
    username.setText(playerInfo.getUsername());
    points.setValue(playerPoints);
    if (herbException.getIcon() == null) {
      spriteManager.getSpriteAsync(
          205,
          0,
          image ->
              herbException.setIcon(new ImageIcon(ImageUtil.resizeImage(image, 20, 20, true))));
    }
    herbException.setEnabled(
        playerInfo.getQuests().stream()
            .anyMatch(
                qp ->
                    qp.getQuest() == Quest.DRUIDIC_RITUAL && qp.getState() == QuestState.FINISHED));
    if (chinException.getIcon() == null) {
      chinException.setIcon(
          new ImageIcon(ResourceUtil.getImage("box_trap_icon.png", 20, 20, true)));
    }
    chinException.setEnabled(
        playerInfo.getQuests().stream()
            .anyMatch(
                qp ->
                    qp.getQuest() == Quest.EAGLES_PEAK && qp.getState() != QuestState.NOT_STARTED));
    if (slayException.getIcon() == null) {
      spriteManager.getSpriteAsync(
          216,
          0,
          image ->
              slayException.setIcon(new ImageIcon(ImageUtil.resizeImage(image, 20, 20, true))));
    }
    slayException.setEnabled(playerInfo.isSlayerException());
    tasksCompleted.setValue(playerInfo.getTasks().size());
    pointsToNextRank.setValue(playerRank.getNextRank().getPointsNeeded() - playerPoints);
    highestTierCompleted.setValue(getHighestTierCompleted());
  }

  public void reload() {
    makeLayout();
    makeStaticData();
    makeDynamicData();
  }

  private String getHighestTierCompleted() {
    List<Task> tasks = taskStore.getAll();
    List<Integer> tiers =
        tasks.stream().map(Task::getTier).distinct().sorted().collect(Collectors.toList());
    int highestTier = 0;
    int maxTiers = Optional.ofNullable(Iterables.getLast(tiers, 0)).orElse(0);
    for (int tier = 1; tier <= maxTiers; tier++) {
      if (manager.getPlayerInfo().getTasks().isEmpty()) break;
      boolean completed = true;
      for (Task task : tasks) {
        if (task.getTier() != tier) continue;
        if (!manager.getPlayerInfo().getTasks().contains(task)) {
          completed = false;
          break;
        }
      }
      if (completed) {
        highestTier = tier;
      } else break;
    }
    return highestTier > 0 ? String.format("Tier %d", highestTier) : "None";
  }
}

package io.septem150.xeric.panel;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.Optional;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

public class JLabeledValue extends JPanel {
  private final JLabel value;
  private final JLabel label;

  public JLabeledValue(String value, String label) {
    setLayout(new BorderLayout());

    final JPanel labeledValue = new JPanel();
    labeledValue.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    labeledValue.setLayout(new BoxLayout(labeledValue, BoxLayout.Y_AXIS));
    labeledValue.setAlignmentY(Component.CENTER_ALIGNMENT);

    this.value = new JLabel(Optional.ofNullable(value).orElse(""));
    this.value.setForeground(Color.WHITE);
    this.value.setAlignmentX(Component.CENTER_ALIGNMENT);
    this.value.setFont(FontManager.getDefaultFont().deriveFont(Font.BOLD, 12));
    labeledValue.add(this.value);

    this.label = new JLabel(Optional.ofNullable(label).orElse(""));
    this.label.setForeground(ColorScheme.TEXT_COLOR);
    this.label.setAlignmentX(Component.CENTER_ALIGNMENT);
    this.label.setFont(FontManager.getDefaultFont().deriveFont(Font.PLAIN, 10));
    labeledValue.add(this.label);

    add(labeledValue, BorderLayout.CENTER);
  }

  public JLabeledValue() {
    this(null, null);
  }

  public void setValue(int value) {
    setValue(String.valueOf(value));
  }

  public void setValue(String value) {
    this.value.setText(value);
  }

  public void setLabel(String label) {
    this.label.setText(label);
  }
}

package io.septem150.xeric.panel.leaderboard;

import io.septem150.xeric.util.ResourceUtil;
import java.awt.Component;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.LinkBrowser;

@Slf4j
@Singleton
public class LeaderboardPanel extends JPanel {
  public static final String TOOLTIP = "Leaderboard";
  public static final String TAB_ICON = "/skill_icons/overall.png";

  private final BoxLayout layout = new BoxLayout(this, BoxLayout.Y_AXIS);
  private final JLabel wipLabel = new JLabel();
  private final JButton womButton = new JButton();

  @Inject
  private LeaderboardPanel() {
    makeLayout();
    makeStaticData();
  }

  private void makeLayout() {
    removeAll();
    setLayout(layout);
    wipLabel.setBorder(new EmptyBorder(20, 0, 20, 0));
    wipLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
    add(wipLabel);
    womButton.setAlignmentX(Component.CENTER_ALIGNMENT);
    add(womButton);
  }

  private void makeStaticData() {
    setBackground(ColorScheme.DARK_GRAY_COLOR);
    wipLabel.setText(
        "<html><body style='text-align: center'>Leaderboard coming soon!<br>Check out the Wise Old"
            + " Man group in the meantime.</body></html>");
    wipLabel.setFont(FontManager.getRunescapeSmallFont());
    wipLabel.setForeground(ColorScheme.BRAND_ORANGE);
    womButton.setIcon(new ImageIcon(ResourceUtil.getImage("wiseoldman_icon.png")));
    womButton.addActionListener(
        event -> LinkBrowser.browse("https://wiseoldman.net/groups/1200/hiscores"));
    womButton.setToolTipText("View the Leaderboard on Wise Old Man");
  }

  public void startUp() {}

  public void refresh() {
    revalidate();
  }
}

package io.septem150.xeric.panel;

import lombok.Data;

@Data
public class PanelUpdate {}

package io.septem150.xeric.panel;

import io.septem150.xeric.ProjectXericConfig;
import io.septem150.xeric.panel.leaderboard.LeaderboardPanel;
import io.septem150.xeric.panel.summary.SummaryPanel;
import io.septem150.xeric.util.ResourceUtil;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;

@Slf4j
@Singleton
public class ProjectXericPanel extends PluginPanel {
  private static final String SIDEPANEL_ICON = "sidepanel_icon.png";
  private static final int SIDEPANEL_PRIORITY = 3;

  private final ClientToolbar clientToolbar;
  private final NavigationButton navigationButton;
  private final SummaryPanel summaryPanel;
  private final LeaderboardPanel leaderboardPanel;

  @Inject
  private ProjectXericPanel(
      ClientToolbar clientToolbar, SummaryPanel summaryPanel, LeaderboardPanel leaderboardPanel) {
    super(false);
    this.clientToolbar = clientToolbar;
    navigationButton =
        NavigationButton.builder()
            .tooltip(ProjectXericConfig.NAME)
            .icon(ResourceUtil.getImage(SIDEPANEL_ICON))
            .priority(SIDEPANEL_PRIORITY)
            .panel(this)
            .build();

    this.summaryPanel = summaryPanel;
    this.leaderboardPanel = leaderboardPanel;
    setLayout(new BorderLayout());
    setBackground(ColorScheme.DARK_GRAY_COLOR);
    setBorder(new EmptyBorder(10, 10, 10, 10));

    JPanel layoutPanel = new JPanel();
    layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));

    JPanel titlePanel = createTitlePanel();
    layoutPanel.add(titlePanel);

    JPanel display = new JPanel();
    display.setBorder(new EmptyBorder(10, 0, 0, 0));
    MaterialTabGroup tabGroup = new MaterialTabGroup(display);
    tabGroup.setLayout(new GridLayout(1, 0, 7, 7));

    MaterialTab summaryTab =
        createTab(SummaryPanel.TOOLTIP, SummaryPanel.TAB_ICON, summaryPanel, tabGroup);

    createTab(LeaderboardPanel.TOOLTIP, LeaderboardPanel.TAB_ICON, leaderboardPanel, tabGroup);

    layoutPanel.add(tabGroup);

    add(layoutPanel, BorderLayout.NORTH);
    add(display, BorderLayout.CENTER);

    tabGroup.select(summaryTab);
  }

  /** Adds this Side Panel to the RuneLite client toolbar */
  public void startUp() {
    clientToolbar.addNavigation(navigationButton);
    summaryPanel.startUp();
    leaderboardPanel.startUp();
  }

  public void startUpChildren() {
    summaryPanel.startupChildren();
  }

  /** Removes this Side Panel from the RuneLite client toolbar */
  public void shutDown() {
    clientToolbar.removeNavigation(navigationButton);
  }

  public void refresh() {
    summaryPanel.refresh();
    leaderboardPanel.refresh();
    revalidate();
  }

  /**
   * Creates a new {@link MaterialTab} with a given image and tooltip text. The {@code imageName} is
   * used as the tab's icon via {@link ResourceUtil#getImage(String imageName)}.
   *
   * @param tooltip the tooltip to display on hover.
   * @param imageName the name of an image, including extension.
   * @param content a {@link JPanel} to display when the tab is selected.
   * @param tabGroup the {@link MaterialTabGroup} to assign the newly created tab to.
   * @return a new {@link MaterialTab} with the desired properties.
   */
  private MaterialTab createTab(
      String tooltip, String imageName, JPanel content, MaterialTabGroup tabGroup) {
    MaterialTab tab =
        new MaterialTab(new ImageIcon(ResourceUtil.getImage(imageName)), tabGroup, content);
    tab.setToolTipText(tooltip);
    tabGroup.addTab(tab);
    return tab;
  }

  /**
   * Creates a {@link JPanel} that contains the plugin's title and social media buttons.
   *
   * @return a new {@link JPanel}.
   */
  private JPanel createTitlePanel() {
    JPanel titlePanel = new JPanel(new BorderLayout());
    titlePanel.setBorder(new EmptyBorder(0, 0, 10, 0));

    JLabel title = new JLabel(ProjectXericConfig.NAME);
    title.setForeground(Color.WHITE);
    titlePanel.add(title, BorderLayout.WEST);

    JPanel infoButtons = new JPanel(new GridLayout(1, 2, 10, 0));

    JButton discordButton =
        createTitleButton(
            "Join the Zeah Ironman Discord Server",
            "discord_icon.png",
            "https://discord.gg/q73k9Dn");
    infoButtons.add(discordButton);

    JButton githubButton =
        createTitleButton(
            "View the plugin's Source Code on GitHub",
            "github_icon.png",
            "https://github.com/Septem151/project-xeric");
    infoButtons.add(githubButton);

    titlePanel.add(infoButtons, BorderLayout.EAST);

    return titlePanel;
  }

  /**
   * Creates a {@link JButton} with a given image, tooltip text, and URL. The {@code imageName} is
   * used as the tab's icon via {@link ResourceUtil#getImage(String imageName)}. Attempts to open a
   * new browser tab to the provided URL on click.
   *
   * @param tooltip the tooltip to display on hover.
   * @param imageName the name of an image, including extension.
   * @param url the URL to open when the button is clicked.
   * @return a new {@link JButton} with the desired properties.
   */
  private JButton createTitleButton(String tooltip, String imageName, String url) {
    JButton button = new JButton(new ImageIcon(ResourceUtil.getImage(imageName, 16, 16)));
    SwingUtil.removeButtonDecorations(button);
    button.setToolTipText(tooltip);
    button.setBackground(ColorScheme.DARK_GRAY_COLOR);
    button.setUI(new BasicButtonUI());
    button.setFocusable(false);
    button.addActionListener(event -> LinkBrowser.browse(url));
    button.addMouseListener(
        new MouseAdapter() {
          @Override
          public void mouseEntered(MouseEvent e) {
            button.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
          }

          @Override
          public void mouseExited(MouseEvent e) {
            button.setBackground(ColorScheme.DARK_GRAY_COLOR);
          }
        });
    return button;
  }
}

package io.septem150.xeric;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

/**
 * Project Xeric plugin tests.
 *
 * @author <a href="mailto:carson.mullins@proton.me">Septem 150</a>
 */
public class ProjectXericPluginTest {
  /**
   * Main entrypoint for running a test client with the plugin added.
   *
   * @param args String[] program args
   * @throws Exception if a failure occurs
   */
  public static void main(String[] args) throws Exception {
    ExternalPluginManager.loadBuiltin(ProjectXericPlugin.class);
    RuneLite.main(args);
  }
}

