package dev.thource.runelite.dudewheresmystuff;

import com.google.api.client.auth.oauth2.TokenResponseException;
import dev.thource.runelite.dudewheresmystuff.carryable.CarryableStorageManager;
import dev.thource.runelite.dudewheresmystuff.coins.CoinsStorageManager;
import dev.thource.runelite.dudewheresmystuff.coins.CoinsStorageType;
import dev.thource.runelite.dudewheresmystuff.death.DeathItems;
import dev.thource.runelite.dudewheresmystuff.death.DeathStorageManager;
import dev.thource.runelite.dudewheresmystuff.death.Deathbank;
import dev.thource.runelite.dudewheresmystuff.death.Deathpile;
import dev.thource.runelite.dudewheresmystuff.export.DataDestination;
import dev.thource.runelite.dudewheresmystuff.export.DataExportWriter;
import dev.thource.runelite.dudewheresmystuff.export.DataExporter;
import dev.thource.runelite.dudewheresmystuff.export.exporters.StorageManagerExporter;
import dev.thource.runelite.dudewheresmystuff.export.utils.GoogleSheetConnectionUtils;
import dev.thource.runelite.dudewheresmystuff.export.writers.CsvWriter;
import dev.thource.runelite.dudewheresmystuff.export.writers.GoogleSheetsWriter;
import dev.thource.runelite.dudewheresmystuff.minigames.MinigamesStorageManager;
import dev.thource.runelite.dudewheresmystuff.playerownedhouse.PlayerOwnedHouseStorageManager;
import dev.thource.runelite.dudewheresmystuff.stash.StashStorageManager;
import dev.thource.runelite.dudewheresmystuff.world.WorldStorageManager;
import java.awt.TrayIcon.MessageType;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.config.ConfigManager;

/** The manager of storage managers. */
@Slf4j
@Getter
public class StorageManagerManager {

  private final CarryableStorageManager carryableStorageManager;
  private final CoinsStorageManager coinsStorageManager;
  private final DeathStorageManager deathStorageManager;
  private final MinigamesStorageManager minigamesStorageManager;
  private final StashStorageManager stashStorageManager;
  private final PlayerOwnedHouseStorageManager playerOwnedHouseStorageManager;
  private final WorldStorageManager worldStorageManager;
  @Getter private final List<StorageManager<?, ?>> storageManagers;
  private final DudeWheresMyStuffPlugin plugin;
  private final ConfigManager configManager;
  @Setter private String displayName;

  @SuppressWarnings("java:S107")
  StorageManagerManager(
      DudeWheresMyStuffPlugin plugin,
      CarryableStorageManager carryableStorageManager,
      CoinsStorageManager coinsStorageManager,
      DeathStorageManager deathStorageManager,
      MinigamesStorageManager minigamesStorageManager,
      StashStorageManager stashStorageManager,
      PlayerOwnedHouseStorageManager playerOwnedHouseStorageManager,
      WorldStorageManager worldStorageManager) {
    this.plugin = plugin;
    this.configManager = carryableStorageManager.getConfigManager();
    this.carryableStorageManager = carryableStorageManager;
    this.coinsStorageManager = coinsStorageManager;
    this.deathStorageManager = deathStorageManager;
    this.minigamesStorageManager = minigamesStorageManager;
    this.stashStorageManager = stashStorageManager;
    this.playerOwnedHouseStorageManager = playerOwnedHouseStorageManager;
    this.worldStorageManager = worldStorageManager;
    this.displayName = "";

    storageManagers =
        Arrays.asList(
            carryableStorageManager,
            coinsStorageManager,
            deathStorageManager,
            minigamesStorageManager,
            stashStorageManager,
            playerOwnedHouseStorageManager,
            worldStorageManager);
  }

  void reset() {
    storageManagers.forEach(StorageManager::reset);
  }

  public void onActorDeath(ActorDeath actorDeath) {
    storageManagers.forEach(storageManager -> storageManager.onActorDeath(actorDeath));
  }

  public void onGameStateChanged(GameStateChanged gameStateChanged) {
    storageManagers.forEach(storageManager -> storageManager.onGameStateChanged(gameStateChanged));
  }

  /**
   * Loads the data for every storage.
   *
   * @param profileKey the profile key to load the data from
   */
  public void load(String profileKey) {
    for (StorageManager<?, ?> storageManager : storageManagers) {
      storageManager.load(profileKey);

      // Bounce into swing and back into the client thread to give StoragePanels a chance to be created
      SwingUtilities.invokeLater(
          () ->
              plugin.getClientThread().invoke(() -> {
                storageManager.getStorages().forEach(storage -> {
                  if (storage.getStoragePanel() != null) {
                    storage.getStoragePanel().refreshItems();
                  }
                });

                SwingUtilities.invokeLater(
                    () -> {
                      storageManager.getStorages().forEach(storage -> {
                        if (storage.getStoragePanel() != null) {
                          storage.getStoragePanel().update();
                        }
                      });
                      storageManager.getStorageTabPanel().reorderStoragePanels();
                    });
              }));
    }
  }

  /**
   * Saves the data for every storage.
   *
   * @param profileKey the profile key to save the data under
   */
  public void save(String profileKey) {
    for (StorageManager<?, ?> storageManager : storageManagers) {
      storageManager.save(profileKey);
    }
  }

  public void onGameTick() {
    storageManagers.forEach(StorageManager::onGameTick);
  }

  public void onGameObjectSpawned(GameObjectSpawned gameObjectSpawned) {
    storageManagers.forEach(m -> m.onGameObjectSpawned(gameObjectSpawned));
  }

  public void onWidgetLoaded(WidgetLoaded widgetLoaded) {
    storageManagers.forEach(manager -> manager.onWidgetLoaded(widgetLoaded));
  }

  public void onWidgetClosed(WidgetClosed widgetClosed) {
    storageManagers.forEach(manager -> manager.onWidgetClosed(widgetClosed));
  }

  public void onVarbitChanged(VarbitChanged varbitChanged) {
    storageManagers.forEach(storageManager -> storageManager.onVarbitChanged(varbitChanged));
  }

  public void onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
    storageManagers.forEach(manager -> manager.onItemContainerChanged(itemContainerChanged));
  }

  public void onItemDespawned(ItemDespawned itemDespawned) {
    storageManagers.forEach(manager -> manager.onItemDespawned(itemDespawned));
  }

  public void onChatMessage(ChatMessage chatMessage) {
    storageManagers.forEach(manager -> manager.onChatMessage(chatMessage));
  }

  /**
   * Gets all the storages from each storage manager.
   *
   * @return a flat map of every storage from every storage manager (except for expired deathpiles,
   *     lost deathbanks and the inventory/looting bag coin storages.)
   */
  @SuppressWarnings("java:S1452")
  public Stream<? extends Storage<? extends Enum<? extends Enum<?>>>> getStorages() {
    return Stream.of(
            getDeathStorageManager().getStorages().stream()
                .filter(s -> !(s instanceof DeathItems))
                .filter(
                    s ->
                        (s instanceof Deathpile && !((Deathpile) s).hasExpired())
                            || (s instanceof Deathbank && ((Deathbank) s).isActive())),
            getCoinsStorageManager().getStorages().stream()
                .filter(
                    storage ->
                        storage.getType() != CoinsStorageType.INVENTORY
                            && storage.getType() != CoinsStorageType.LOOTING_BAG
                            && storage.getType() != CoinsStorageType.BANK),
            getCarryableStorageManager().getStorages().stream(),
            getStashStorageManager().getStorages().stream(),
            getPlayerOwnedHouseStorageManager().getStorages().stream(),
            getWorldStorageManager().getStorages().stream())
        .flatMap(i -> i);
  }

  /**
   * Gets all the storages which are included in the item count tooltip from each storage manager.
   *
   * @return a flat map of every storage from every storage manager (except for expired deathpiles,
   *     lost deathbanks and the inventory/looting bag coin storages.)
   */
  @SuppressWarnings("java:S1452")
  public Stream<? extends Storage<? extends Enum<? extends Enum<?>>>> getStoredItemCountStorages() {
    return Stream.of(
            getDeathStorageManager().getStorages().stream()
                .filter(s -> !(s instanceof DeathItems))
                .filter(
                    s ->
                        (s instanceof Deathpile && !((Deathpile) s).hasExpired())
                            || (s instanceof Deathbank && ((Deathbank) s).isActive()))
                .filter(s -> s.includeInStoredItemCount(getDeathStorageManager().getConfigKey())),
            getCoinsStorageManager().getStorages().stream()
                .filter(
                    storage ->
                        storage.getType() != CoinsStorageType.INVENTORY
                            && storage.getType() != CoinsStorageType.LOOTING_BAG
                            && storage.getType() != CoinsStorageType.BANK)
                .filter(s -> s.includeInStoredItemCount(getCoinsStorageManager().getConfigKey())),
            getCarryableStorageManager().getStorages().stream()
                .filter(s -> s.includeInStoredItemCount(getCarryableStorageManager().getConfigKey())),
            getStashStorageManager().getStorages().stream()
                .filter(s -> s.includeInStoredItemCount(getStashStorageManager().getConfigKey())),
            getPlayerOwnedHouseStorageManager().getStorages().stream()
                .filter(s -> s.includeInStoredItemCount(getPlayerOwnedHouseStorageManager().getConfigKey())),
            getWorldStorageManager().getStorages().stream()
                .filter(s -> s.includeInStoredItemCount(getWorldStorageManager().getConfigKey())))
        .flatMap(s -> s).filter(Storage::isWithdrawable);
  }


  public List<ItemStack> getItems() {
    return getStorages().filter(Storage::isEnabled).map(Storage::getItems).flatMap(List::stream)
        .collect(Collectors.toList());
  }

  public void onMenuOptionClicked(MenuOptionClicked menuOption) {
    storageManagers.forEach(manager -> manager.onMenuOptionClicked(menuOption));
  }

  /** Creates a CSV file containing all the items in any exportable storage. */
  public void exportItems(DataDestination destination) {
    StorageManagerManager s = this;
    Thread t =
        new Thread(
            () -> {
              DataExportWriter writer;

              if ((destination == DataDestination.CSV)) {
                writer = new CsvWriter(displayName);
              } else if ((destination == DataDestination.GOOGLE_SHEETS)) {
                writer = new GoogleSheetsWriter(plugin, displayName);
              } else {
                throw new RuntimeException(
                    "Could not find a writer that likes the destination selected");
              }

              DataExporter exporter = new StorageManagerExporter(writer, s);
              try {
                export(exporter, writer);
              } catch (IOException | IllegalArgumentException e) {
                log.error("Unable to export: " + e.getMessage());
                plugin.getNotifier().notify("Item export failed.", MessageType.ERROR);
              } catch (Exception ex) {
                if (ex instanceof TokenResponseException) {
                  GoogleSheetConnectionUtils.invalidateCredentials();
                  try {
                    export(exporter, writer);
                  } catch (IOException e) {
                    throw new RuntimeException(e);
                  }
                }
              }
            });
    t.start();
  }

  private void export(DataExporter exporter, DataExportWriter writer)
      throws IOException, IllegalArgumentException {
    String filePath = exporter.export(plugin.getConfig().exportCombineItems());
    writer.close();
    plugin.getNotifier().notify("Items successfully exported to: " + filePath, MessageType.INFO);
  }
}

package dev.thource.runelite.dudewheresmystuff;

import java.awt.Graphics2D;
import java.util.Comparator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.config.Keybind;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

public class ItemCountOverlay extends WidgetItemOverlay {

  private final Client client;
  private final DudeWheresMyStuffPlugin plugin;
  private final DudeWheresMyStuffConfig dudeWheresMyStuffConfig;
  private final TooltipManager tooltipManager;
  @Setter private boolean keybindPressed;

  @Inject
  ItemCountOverlay(Client client, DudeWheresMyStuffPlugin dudeWheresMyStuffPlugin,
      DudeWheresMyStuffConfig dudeWheresMyStuffConfig, TooltipManager tooltipManager) {
    this.client = client;
    this.plugin = dudeWheresMyStuffPlugin;
    this.dudeWheresMyStuffConfig = dudeWheresMyStuffConfig;
    this.tooltipManager = tooltipManager;
    showOnInventory();
    showOnBank();
  }

  @Override
  public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem) {
    if (dudeWheresMyStuffConfig.storedItemCountTooltip() == StoredItemCountTooltipMode.OFF) {
      return;
    }

    if (dudeWheresMyStuffConfig.storedItemCountTooltipKeybind().getKeyCode()
        != Keybind.NOT_SET.getKeyCode()
        || dudeWheresMyStuffConfig.storedItemCountTooltipKeybind().getModifiers()
        != Keybind.NOT_SET.getModifiers()
        && !keybindPressed) {
      return;
    }

    final Point mousePos = client.getMouseCanvasPosition();
    if (!widgetItem.getCanvasBounds().contains(mousePos.getX(), mousePos.getY())) {
      return;
    }

    if (dudeWheresMyStuffConfig.storedItemCountTooltip() == StoredItemCountTooltipMode.SIMPLE) {
      long count = plugin.getWithdrawableItemCount(widgetItem.getId());
      tooltipManager.add(new Tooltip("Stored: " + String.format("%,d", count)));
      return;
    }

    Map<Storage<?>, Long> detailedItemCountMap = plugin.getDetailedWithdrawableItemCount(
        widgetItem.getId());
    long total = detailedItemCountMap.values().stream().mapToLong(count -> count).sum();

    String detailedText = detailedItemCountMap.entrySet()
        .stream().sorted(Comparator.comparingLong(Entry<Storage<?>, Long>::getValue).reversed())
        .map(entry -> entry.getKey().getName() + ": " + String.format("%,d", entry.getValue()))
        .collect(Collectors.joining("</br>"));

    if (detailedItemCountMap.values().size() > 1) {
      detailedText += "</br></br>Total: " + String.format("%,d", total);
    }

    tooltipManager.add(new Tooltip(detailedText));
  }
}

/*
 * Copyright (c) 2022, Thource <https://github.com/Thource>
 * Copyright (c) 2018, Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package dev.thource.runelite.dudewheresmystuff;

import com.google.common.collect.ImmutableMap;
import dev.thource.runelite.dudewheresmystuff.carryable.CarryableStorageManager;
import dev.thource.runelite.dudewheresmystuff.coins.CoinsStorageManager;
import dev.thource.runelite.dudewheresmystuff.death.DeathStorageManager;
import dev.thource.runelite.dudewheresmystuff.minigames.MinigamesStorageManager;
import dev.thource.runelite.dudewheresmystuff.playerownedhouse.PlayerOwnedHouseStorageManager;
import dev.thource.runelite.dudewheresmystuff.stash.StashStorageManager;
import dev.thource.runelite.dudewheresmystuff.world.WorldStorageManager;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.ItemID;

/** Tab is used to define tabs that the user can click to swap panels. */
@RequiredArgsConstructor
@Getter
public enum Tab {
  OVERVIEW("Overview", ItemID.HW16_CLUE_LIBRARY),
  COINS("Coins", ItemID.COINS, 0xBADCA7),
  CARRYABLE_STORAGE("Carry-able Storage", ItemID.LOOTING_BAG),
  WORLD("World Storage", ItemID.ROGUESDEN_CRATE),
  MINIGAMES("Minigames", ItemID.MAGICTRAINING_PROGHAT_DULL),
  DEATH("Death Storage", ItemID.SKULL),
  POH_STORAGE("POH Storage", ItemID.POH_COS_ROOM_ARMOUR_CASE_MAHOGANY),
  STASH_UNITS("STASH Units", ItemID.POH_WALLCHART_4),
  SEARCH("Search", -1),
  DEBUG("Debug", ItemID.BLUECOG);

  public static final ImmutableMap<Class<? extends StorageManager<?, ?>>, Tab> MANAGER_TAB_MAP =
      ImmutableMap.<Class<? extends StorageManager<?, ?>>, Tab>builder()
          .put(DeathStorageManager.class, DEATH)
          .put(CoinsStorageManager.class, COINS)
          .put(CarryableStorageManager.class, CARRYABLE_STORAGE)
          .put(WorldStorageManager.class, WORLD)
          .put(StashStorageManager.class, STASH_UNITS)
          .put(PlayerOwnedHouseStorageManager.class, POH_STORAGE)
          .put(MinigamesStorageManager.class, MINIGAMES)
          .build();
  public static final List<Tab> TABS =
      Collections.unmodifiableList(
          Arrays.asList(
              OVERVIEW,
              DEATH,
              COINS,
              CARRYABLE_STORAGE,
              STASH_UNITS,
              POH_STORAGE,
              WORLD,
              MINIGAMES,
              SEARCH));

  private final String name;
  private final int itemId;
  private final int itemQuantity;

  Tab(String name, int itemId) {
    this.name = name;
    this.itemId = itemId;
    this.itemQuantity = 1;
  }
}

package dev.thource.runelite.dudewheresmystuff;

import dev.thource.runelite.dudewheresmystuff.playerownedhouse.PlayerOwnedHouseStorageType;
import dev.thource.runelite.dudewheresmystuff.stash.StashUnit;
import java.util.stream.Collectors;
import net.runelite.client.config.ConfigManager;

class FakeDataService {

  public static final String PROFILE = "rsprofile.ZZZ";

  private FakeDataService() {
  }

  static void createData(ConfigManager configManager) {
    // Wipe the fake profile data
    for (String configKey : configManager.getRSProfileConfigurationKeys(
        DudeWheresMyStuffConfig.CONFIG_GROUP, PROFILE, "")) {
      configManager.unsetConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP, PROFILE, configKey);
    }

    // Create a fake profile, real profiles have 8 character keys, so this has no chance of being
    // a duplicate
    configManager.setConfiguration("rsprofile", PROFILE, "displayName", "Thource");
    configManager.setConfiguration("rsprofile", PROFILE, "type", "STANDARD");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP, PROFILE, "saveMigrated", true);
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP, PROFILE, "minutesPlayed", 600);
    configManager.setConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP, PROFILE, "isMember", true);
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "accountType",
        2); // uim

    createDeathData(configManager);
    createCoinsData(configManager);
    createCarryableData(configManager);
    createWorldData(configManager);
    createMinigamesData(configManager);
    createStashData(configManager);
    createPlayerOwnedHouseData(configManager);
  }

  private static void createPlayerOwnedHouseData(ConfigManager configManager) {
    for (PlayerOwnedHouseStorageType type : PlayerOwnedHouseStorageType.values()) {
      if (type.getStorableItemIds() == null) {
        if (type == PlayerOwnedHouseStorageType.MENAGERIE) {
          configManager.setConfiguration(
              DudeWheresMyStuffConfig.CONFIG_GROUP,
              PROFILE,
              "poh." + type.getConfigKey(),
              (System.currentTimeMillis() - (1000 * 60 * 4)) + ";6555x1;482534;2343");
        }
      } else {
        configManager.setConfiguration(
            DudeWheresMyStuffConfig.CONFIG_GROUP,
            PROFILE,
            "poh." + type.getConfigKey(),
            (System.currentTimeMillis() - (1000 * 60 * 4))
                + ";"
                + type.getStorableItemIds().stream()
                .map(id -> id + "x" + 1)
                .collect(Collectors.joining(",")));
      }
    }
  }

  private static void createStashData(ConfigManager configManager) {
    for (StashUnit stashUnit : StashUnit.values()) {
      StringBuilder itemsBuilder = new StringBuilder();
      for (int itemId : stashUnit.getDefaultItemIds()) {
        itemsBuilder.append(itemId).append("x1,");
      }

      configManager.setConfiguration(
          DudeWheresMyStuffConfig.CONFIG_GROUP,
          PROFILE,
          "stash." + stashUnit.getStashUnitData().getObjectId(),
          (System.currentTimeMillis() - (1000 * 60 * 9)) + ";" + itemsBuilder);
    }
  }

  private static void createDeathData(ConfigManager configManager) {
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "death.deathpile.5d7f983f-3501-4010-8522-a45c3173ffb3",
        "995x26000000,5295x185,22875x3,5296x278,5343x19,952x15,7409x1,13353x1;"
            + "5d7f983f-3501-4010-8522-a45c3173ffb3;3203,3824,0;true;0;"
            + (System.currentTimeMillis() - (1000 * 60 * 25))
    );
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "death.deathpile.5a5d74b6-d279-4fa9-95e7-ee0c14f957d2",
        "562x7756,556x12148,560x5336,554x10885,3031x3789,168x642,2459x936,2999x272;"
            + "5a5d74b6-d279-4fa9-95e7-ee0c14f957d2;2205,3212,0;false;500"
    );
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "death.deathpile.cebe31f5-0047-40c2-bddf-9f2f37a3664b",
        "1523,150x4838,142x1697,3031x3789,7937x144000,2362x1030,1618x155;"
            + "cebe31f5-0047-40c2-bddf-9f2f37a3664b;3222,3218,0;true;619"
    );
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "death.deathbank.9267fafd-517d-45db-8d88-ede39393f176",
        "1678391322175;4214x1,11802x1,;9267fafd-517d-45db-8d88-ede39393f176;true;-1;HESPORI"
    );
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "death.deathbank.b6dcb979-ad92-4641-8540-6efee365c629",
        "1675972962178;4214x1,19675x1,2434x1,19564x1,148x6582,160x3548,24482x1,5295x79,"
            + "5297x121,5296x588,5302x212,5298x92,5301x20,561x1135,560x4804,11865x1,6570x1,"
            + "6585x1,12508x1,12954x1,10388x1,7462x1,11773x1,12851x1;"
            + "b6dcb979-ad92-4641-8540-6efee365c629;false;"
            + (System.currentTimeMillis() - (1000 * 60 * 60 * 24 * 9)) + ";HESPORI"
    );
  }

  private static void createCoinsData(ConfigManager configManager) {
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP, PROFILE, "coins.nightmarezone", "73000000");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP, PROFILE, "coins.lastmanstanding", "188979000");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "coins.servantsmoneybag",
        System.currentTimeMillis() - (1000 * 60 * 60 * 4) + ";737300");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP, PROFILE, "coins.blastfurnace", "173");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP, PROFILE, "coins.inventory", "26000000");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "coins.lootingbag",
        System.currentTimeMillis() - (1000 * 60 * 60 * 18) + ";666000");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "coins.grandexchange",
        System.currentTimeMillis() - (1000 * 60 * 60 * 50) + ";69420");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "coins.shilofurnace",
        System.currentTimeMillis() - (1000 * 60 * 30) + ";2020");
  }

  private static void createCarryableData(ConfigManager configManager) {
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "carryable.inventory",
        "2434x1,2434x1,-1x1,892x10593,143x1,-1x1,-1x1,9433x1,7937x144000,2362x1030,"
            + "1618x155,1392x470,1514x12499,441x8800,1620x300,568x2700,566x60,563x3439,565x1075,"
            + "555x6450,562x7756,556x12148,560x5336,554x10885,995x26000000,24482x1,12791x1,"
            + "11941x1");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "carryable.equipment",
        "-1x1,3749x1,-1x1,-1x1,6570x1,1708x1,892x255,-1x1,13576x1,4940x1,-1x1,-1x1,-1x1,"
            + "12502x1,-1x1,-1x1,7462x1,22951x1,6737x1");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "carryable.lootingbag",
        System.currentTimeMillis()
            - (1000 * 60 * 60 * 18)
            + ";12632x2091,162x1523,150x4838,142x1697,3031x3789,168x642,2459x936,2999x272,262x448,"
            + "445x2632,2354x1080,13391x294,4736x1,4728x1,4722x1,4716x1,810x19069,6914x1,11905x1,"
            + "20736x1,995x666000");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "carryable.seedbox",
        System.currentTimeMillis()
            - (1000 * 60 * 60 * 14)
            + ";5295x185,22875x3,5296x278,5300x35,5304x11");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "carryable.runepouch",
        "563x580,4696x853,554x429");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "carryable.bottomlessbucket",
        System.currentTimeMillis() - (1000 * 60 * 60 * 2) + ";0,0,1423");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "carryable.planksack",
        System.currentTimeMillis() - (1000 * 60 * 43) + ";0,0,0,21");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "carryable.boltpouch",
        "4740x301,21950x10000,8882x8080,9245x99");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "carryable.gnomishfirelighter",
        System.currentTimeMillis() - (1000 * 60 * 60 * 3) + ";0,0,730,0,0");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "carryable.masterscrollbook",
        "1,12,32,40,2,32,43,5,9,8,4,24,57,100,28");
  }

  private static void createWorldData(ConfigManager configManager) {
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "world.leprechaun",
        "10,19,15,1,1,5,8,1,10,65,17,647;1;10");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "world.blastfurnace",
        "0,0,0,4,0,0,0,0,0,0,0,0,0,0,22,0,0");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "world.logstorage",
        System.currentTimeMillis() - (1000 * 60 * 60 * 2) + ";10,12,8,5,24");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "world.fossilstorage",
        "10,4,5,6,4,3,2,34,23,12,5,4,6,45,3,43,23,21,12,4,6,4,11,16,1,2,7,9,4,8");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "world.vyrewell",
        "10000,3000000");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "world.annette",
        "82");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "world.elnock",
        "0,1,1,948");
  }

  private static void createMinigamesData(ConfigManager configManager) {
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "minigames.magetrainingarena",
        System.currentTimeMillis() - (1000 * 60 * 60 * 2) + ";84,30,1020,489");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP, PROFILE, "minigames.tithefarm", "843");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "minigames.lastmanstanding",
        System.currentTimeMillis() - (1000 * 60 * 60 * 5) + ";43");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP, PROFILE, "minigames.nightmarezone",
        "435645,12,8,120,30");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "minigames.barbarianassault",
        "194,294,40,64");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "minigames.guardiansoftherift",
        System.currentTimeMillis() - (1000 * 60 * 60) + ";1200,1200");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "minigames.mahoganyhomes",
        System.currentTimeMillis() - (1000 * 60 * 23) + ";782");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "minigames.slayer",
        "1043");
    configManager.setConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        PROFILE,
        "minigames.pestcontrol",
        System.currentTimeMillis() - (1000 * 60 * 4) + ";1050");
  }
}

package dev.thource.runelite.dudewheresmystuff;

import com.google.common.collect.ImmutableMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.InventoryID;

/** ItemContainerWatcher makes it easy to detect changes to ItemContainers. */
public class ItemContainerWatcher {

  @Getter static final ItemContainerWatcher inventoryWatcher =
      new ItemContainerWatcher(InventoryID.INV, true);
  @Getter static final ItemContainerWatcher wornWatcher =
      new ItemContainerWatcher(InventoryID.WORN, true);
  @Getter static final ItemContainerWatcher lootingBagWatcher = new ItemContainerWatcher(
      InventoryID.LOOTING_BAG);
  @Getter static final ItemContainerWatcher bankWatcher = new ItemContainerWatcher(
      InventoryID.BANK);
  @Getter static final ItemContainerWatcher seedBoxWatcher = new ItemContainerWatcher(
      InventoryID.SEED_BOX);
  @Getter static final ItemContainerWatcher deathsOfficeWatcher = new ItemContainerWatcher(
      InventoryID.DEATH_PERMANENT);
  private static final Map<Integer, ItemContainerWatcher> watcherMap;
  private static final ItemContainerWatcher[] all =
      new ItemContainerWatcher[]{inventoryWatcher, wornWatcher, lootingBagWatcher, bankWatcher,
          seedBoxWatcher, deathsOfficeWatcher};
  private static Client client;

  static {
    ImmutableMap.Builder<Integer, ItemContainerWatcher> mapBuilder = new ImmutableMap.Builder<>();
    for (ItemContainerWatcher itemContainerWatcher : all) {
      mapBuilder.put(itemContainerWatcher.itemContainerId, itemContainerWatcher);
    }
    watcherMap = mapBuilder.build();
  }

  private final int itemContainerId;
  private final List<ItemStack> itemsLastTick = new ArrayList<>();
  @Getter private final List<ItemStack> items = new ArrayList<>();
  private boolean justUpdated = false;
  private final boolean requiresInitialUpdate;
  private boolean initialUpdateOccurred = false;

  ItemContainerWatcher(int itemContainerId) {
    this.itemContainerId = itemContainerId;
    this.requiresInitialUpdate = false;
  }

  ItemContainerWatcher(int itemContainerId, boolean requiresInitialUpdate) {
    this.itemContainerId = itemContainerId;
    this.requiresInitialUpdate = requiresInitialUpdate;
  }

  static void init(Client client) {
    ItemContainerWatcher.client = client;
  }

  static void reset() {
    for (ItemContainerWatcher itemContainerWatcher : all) {
      itemContainerWatcher.itemsLastTick.clear();
      itemContainerWatcher.items.clear();
      itemContainerWatcher.justUpdated = false;
      if (itemContainerWatcher.requiresInitialUpdate) {
        itemContainerWatcher.initialUpdateOccurred = false;
      }
    }
  }

  static void onGameTick(DudeWheresMyStuffPlugin plugin) {
    for (ItemContainerWatcher itemContainerWatcher : all) {
      itemContainerWatcher.gameTick(plugin);
    }
  }

  public static ItemContainerWatcher getWatcher(int itemContainerId) {
    return watcherMap.get(itemContainerId);
  }

  public boolean wasJustUpdated() {
    return justUpdated;
  }

  private void gameTick(DudeWheresMyStuffPlugin plugin) {
    justUpdated = false;
    itemsLastTick.clear();
    itemsLastTick.addAll(items);

    ItemContainer itemContainer = client.getItemContainer(itemContainerId);
    if (itemContainer == null) {
      return;
    }

    justUpdated = true;
    items.clear();
    items.addAll(
        Arrays.stream(itemContainer.getItems())
            .map(
                item -> {
                  if (item.getId() == -1) {
                    return new ItemStack(-1, "empty", 1, 0, 0, false);
                  }

                  Optional<ItemStack> oldItem =
                      itemsLastTick.stream().filter(o -> o.getId() == item.getId()).findFirst();
                  if (oldItem.isPresent()) {
                    ItemStack newItem = new ItemStack(oldItem.get());
                    newItem.setQuantity(item.getQuantity());

                    return newItem;
                  }

                  return new ItemStack(item.getId(), item.getQuantity(), plugin);
                })
            .collect(Collectors.toList()));

    if (requiresInitialUpdate && !initialUpdateOccurred) {
      initialUpdateOccurred = true;

      itemsLastTick.clear();
      itemsLastTick.addAll(items);
    }
  }

  /**
   * returns a List of just added ItemStacks.
   *
   * @return ItemStack List
   */
  public List<ItemStack> getItemsAddedLastTick() {
    if (!justUpdated || (requiresInitialUpdate && !initialUpdateOccurred)) {
      return List.of();
    }

    List<ItemStack> itemsAddedLastTick =
        items.stream()
            .filter(i -> i.getId() != -1)
            .map(ItemStack::new)
            .collect(Collectors.toList());

    ItemStackUtils.removeItems(itemsAddedLastTick, itemsLastTick);

    return itemsAddedLastTick;
  }

  /**
   * returns a List of just removed ItemStacks.
   *
   * @return ItemStack List
   */
  public List<ItemStack> getItemsRemovedLastTick() {
    if (!justUpdated || (requiresInitialUpdate && !initialUpdateOccurred)) {
      return List.of();
    }

    List<ItemStack> itemsRemovedLastTick =
        itemsLastTick.stream()
            .filter(i -> i.getId() != -1)
            .map(ItemStack::new)
            .collect(Collectors.toList());

    ItemStackUtils.removeItems(itemsRemovedLastTick, items);

    return itemsRemovedLastTick;
  }
}

/*
 * Copyright (c) 2022, Thource <https://github.com/Thource>
 * Copyright (c) 2018, Daniel Teo <https://github.com/takuyakanbr>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package dev.thource.runelite.dudewheresmystuff;

import javax.swing.JPanel;
import lombok.extern.slf4j.Slf4j;

@Slf4j
abstract class TabContentPanel extends JPanel {

  public abstract void softUpdate();
}

package dev.thource.runelite.dudewheresmystuff;

enum ClientState {
  LOGGED_OUT,
  LOGGING_IN,
  LOGGED_IN
}

package dev.thource.runelite.dudewheresmystuff;

import dev.thource.runelite.dudewheresmystuff.death.DeathbankType;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

/** SaveFieldFormatter converts various data types into strings so that they can be saved. */
public class SaveFieldFormatter {

  private SaveFieldFormatter() {}

  /**
   * Converts an ItemStack list into a string.
   *
   * @param list the item stack list
   * @param quantitiesOnly whether the result should be composed of only quantities
   * @return a string representation of the item stack list
   */
  public static String format(List<ItemStack> list, boolean quantitiesOnly) {
    return list.stream().map(item -> format(item, quantitiesOnly)).collect(Collectors.joining(","));
  }

  /**
   * Converts an ItemStack into a string.
   *
   * @param itemStack the item stack
   * @param quantityOnly whether the result should be composed of only quantity
   * @return a string representation of the item stack
   */
  public static String format(ItemStack itemStack, boolean quantityOnly) {
    if (quantityOnly) {
      return String.valueOf(itemStack.getQuantity());
    }

    return itemStack.getId() + "x" + itemStack.getQuantity();
  }

  public static String format(WorldPoint worldPoint) {
    return worldPoint.getX() + "," + worldPoint.getY() + "," + worldPoint.getPlane();
  }

  public static String format(DeathbankType val) {
    return String.valueOf(val);
  }

  public static String format(boolean val) {
    return String.valueOf(val);
  }

  public static String format(int val) {
    return String.valueOf(val);
  }

  public static String format(long val) {
    return String.valueOf(val);
  }

  public static String format(UUID val) {
    return val.toString();
  }

  public static String format(WorldArea worldArea) {
    return worldArea.getX()
        + ","
        + worldArea.getY()
        + ","
        + worldArea.getWidth()
        + ","
        + worldArea.getHeight()
        + ","
        + worldArea.getPlane();
  }
}

package dev.thource.runelite.dudewheresmystuff.coins;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/**
 * ShiloFurnace is responsible for tracking how many coins the player has stored in the shilo
 * village furnace coffer.
 */
public class ShiloFurnace extends CoinsStorage {

  ShiloFurnace(DudeWheresMyStuffPlugin plugin) {
    super(CoinsStorageType.SHILO_FURNACE, plugin);
  }

  @Override
  public boolean onGameTick() {
    Widget widget = plugin.getClient().getWidget(219, 1);
    if (widget == null) {
      return false;
    }

    Widget textWidget = widget.getChild(0);
    if (textWidget == null) {
      return false;
    }
    if (!textWidget.getText().startsWith("Furnace coffer: ")) {
      return false;
    }

    int parsedCoins = NumberUtils.toInt(textWidget.getText().replaceAll("\\D+", ""), 0);
    this.getCoinStack().setQuantity(parsedCoins);
    updateLastUpdated();
    return true;
  }
}

package dev.thource.runelite.dudewheresmystuff.coins;

import com.google.inject.Inject;
import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import lombok.extern.slf4j.Slf4j;

/** CoinsStorageManager is responsible for managing all CoinsStorages. */
@Slf4j
public class CoinsStorageManager extends StorageManager<CoinsStorageType, CoinsStorage> {

  @Inject
  CoinsStorageManager(DudeWheresMyStuffPlugin plugin) {
    super(plugin);

    for (CoinsStorageType type : CoinsStorageType.values()) {
      if (type == CoinsStorageType.SERVANT_MONEYBAG
          || type == CoinsStorageType.SHILO_FURNACE
          || type == CoinsStorageType.GRAND_EXCHANGE
          || type == CoinsStorageType.LOOTING_BAG
          || type == CoinsStorageType.BOUNTY_HUNTER) {
        continue;
      }

      storages.add(new CoinsStorage(type, plugin));
    }

    storages.add(new ServantsMoneybag(plugin));
    storages.add(new ShiloFurnace(plugin));
    storages.add(new GrandExchange(plugin));
    storages.add(new LootingBag(plugin));
    storages.add(new BountyHunterCoffer(plugin));
    storages.add(new ScarEssenceMine(plugin));
  }

  @Override
  public String getConfigKey() {
    return "coins";
  }

}

package dev.thource.runelite.dudewheresmystuff.coins;

import dev.thource.runelite.dudewheresmystuff.StorageType;
import java.util.List;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.VarbitID;

/** CoinsStorageType is used to identify CoinsStorages. */
@RequiredArgsConstructor
@Getter
public enum CoinsStorageType implements StorageType {
  BANK("Bank", -1, InventoryID.BANK, false, "bank", false),
  NMZ("Nightmare Zone", VarbitID.NZONE_CASH, -1, true, "nightmarezone", true, 1000),
  LMS("Last Man Standing", VarbitID.BR_COFFER, -1, true, "lastmanstanding", false, 1000),
  SERVANT_MONEYBAG("Servant's Moneybag", -1, -1, false, "servantsmoneybag", true),
  BF("Blast Furnace", VarbitID.BLAST_FURNACE_COFFER, -1, true, "blastfurnace", true),
  INVENTORY("Inventory", -1, InventoryID.INV, true, "inventory", false),
  LOOTING_BAG("Looting Bag", -1, InventoryID.LOOTING_BAG, false, "lootingbag", true),
  GRAND_EXCHANGE("Grand Exchange", -1, -1, false, "grandexchange", false),
  SHILO_FURNACE("Shilo Furnace", -1, -1, false, "shilofurnace", true),
  BOUNTY_HUNTER("Bounty Hunter", -1, -1, false, "bountyhunter", true),
  MANAGING_MISCELLANIA("Managing Miscellania", VarbitID.MISC_COFFERS, -1, true, "managingMiscellania", true),
  SCAR_ESSENCE_MINE("Scar Essence Mine", -1, -1, true, "scarEssenceMine", true);

  private final String name;
  private final int varbitId;
  private final int itemContainerId;
  // Whether the storage can be updated with no action required by the player
  private final boolean automatic;
  private final String configKey;
  private final boolean membersOnly;
  private final int multiplier;
  private final List<Integer> accountTypeBlacklist = null;

  CoinsStorageType(
      String name,
      int varbitId,
      int itemContainerId,
      boolean automatic,
      String configKey,
      boolean membersOnly) {
    this.name = name;
    this.varbitId = varbitId;
    this.itemContainerId = itemContainerId;
    this.automatic = automatic;
    this.configKey = configKey;
    this.membersOnly = membersOnly;
    this.multiplier = 1;
  }
}

package dev.thource.runelite.dudewheresmystuff.coins;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.ItemStorage;
import dev.thource.runelite.dudewheresmystuff.Var;
import java.util.Optional;
import lombok.Getter;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.VarbitChanged;

/**
 * CoinsStorage is responsible for tracking storages that hold the players coins (coffers,
 * inventory, etc).
 */
@Getter
public class CoinsStorage extends ItemStorage<CoinsStorageType> {

  protected final ItemStack coinStack = new ItemStack(995, "Coins", 0, 1, 0, true);

  protected CoinsStorage(CoinsStorageType type, DudeWheresMyStuffPlugin plugin) {
    super(type, plugin);

    hasStaticItems = true;

    items.add(coinStack);
  }

  @Override
  public boolean onGameTick() {
    if (itemContainerWatcher != null && itemContainerWatcher.wasJustUpdated()) {
      Optional<ItemStack> coinsItem =
          itemContainerWatcher.getItems().stream().filter(i -> i.getId() == 995).findFirst();
      coinStack.setQuantity(coinsItem.map(ItemStack::getQuantity).orElse(0L));

      updateLastUpdated();

      return true;
    }

    return false;
  }

  @Override
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    if (type.getVarbitId() == -1) {
      return false;
    }

    var coinsVar = Var.bit(varbitChanged, type.getVarbitId());
    if (!coinsVar.wasChanged()) {
      return false;
    }

    var coins = coinsVar.getValue(plugin.getClient()) * type.getMultiplier();
    if (coinStack.getQuantity() == coins) {
      return false;
    }

    coinStack.setQuantity(coins);
    return true;
  }

  @Override
  public boolean onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
    if (itemContainerWatcher != null
        || type.getItemContainerId() != itemContainerChanged.getContainerId()) {
      return false;
    }

    ItemContainer itemContainer = itemContainerChanged.getItemContainer();
    if (itemContainer == null) {
      return false;
    }

    updateLastUpdated();
    int coins = itemContainer.count(995);
    if (coinStack.getQuantity() == coins) {
      return !this.getType().isAutomatic();
    }

    coinStack.setQuantity(coins);
    return true;
  }
}

package dev.thource.runelite.dudewheresmystuff.coins;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import java.util.Objects;
import java.util.stream.IntStream;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/**
 * GrandExchange is responsible for tracking how many coins the player has stored in the Grand
 * Exchange.
 */
public class GrandExchange extends CoinsStorage {

  GrandExchange(DudeWheresMyStuffPlugin plugin) {
    super(CoinsStorageType.GRAND_EXCHANGE, plugin);
  }

  @Override
  public boolean onGameTick() {
    return updateFromGrandExchangeWindow() || updateFromCollectWindow();
  }

  private boolean updateFromCollectWindow() {
    if (plugin.getClient().getWidget(402, 1) == null) {
      return false;
    }

    long oldValue = coinStack.getQuantity();
    coinStack.setQuantity(IntStream.range(0, 8).mapToLong(this::getCoinsInCollectSlot).sum());
    updateLastUpdated();

    return oldValue != coinStack.getQuantity();
  }

  private int getCoinsInCollectSlot(int slot) {
    Widget slotWidget = plugin.getClient().getWidget(402, 5 + slot);
    if (slotWidget == null) {
      return 0;
    }

    Widget itemWidget = slotWidget.getChild(3);
    if (itemWidget == null || itemWidget.getItemId() != 995 || itemWidget.isHidden()) {
      return 0;
    }

    return itemWidget.getItemQuantity();
  }

  private boolean updateFromGrandExchangeWindow() {
    if (plugin.getClient().getWidget(465, 1) == null) {
      return false;
    }

    long oldValue = coinStack.getQuantity();
    coinStack.setQuantity(IntStream.range(0, 8).mapToLong(this::getCoinsInGrandExchangeSlot).sum());
    updateLastUpdated();

    return oldValue != coinStack.getQuantity();
  }

  private int getCoinsInGrandExchangeSlot(int slot) {
    Widget slotWidget = plugin.getClient().getWidget(465, 7 + slot);
    if (slotWidget == null) {
      return 0;
    }

    Widget offerType = slotWidget.getChild(16);
    if (offerType == null || !Objects.equals(offerType.getText(), "Buy")) {
      return 0;
    }

    Widget offerBar = slotWidget.getChild(22);
    if (offerBar == null || !Objects.equals(offerBar.getTextColor(), 0x8f0000)) {
      return 0;
    }

    Widget offerCoins = slotWidget.getChild(25);
    if (offerCoins == null) {
      return 0;
    }

    return NumberUtils.toInt(offerCoins.getText().replaceAll("\\D+", ""), 0);
  }
}

package dev.thource.runelite.dudewheresmystuff.coins;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/**
 * ServantsMoneybag is responsible for tracking how many coins the player has stored in their
 * servant's moneybag.
 */
public class ServantsMoneybag extends CoinsStorage {

  ServantsMoneybag(DudeWheresMyStuffPlugin plugin) {
    super(CoinsStorageType.SERVANT_MONEYBAG, plugin);
  }

  @Override
  public boolean onGameTick() {
    Widget widget = plugin.getClient().getWidget(193, 2);
    if (widget == null) {
      return false;
    }
    if (!widget.getText().startsWith("The money bag ")) {
      return false;
    }

    int parsedCoins = NumberUtils.toInt(widget.getText().replaceAll("\\D+", ""), 0);
    this.getCoinStack().setQuantity(parsedCoins);
    updateLastUpdated();
    return true;
  }
}

package dev.thource.runelite.dudewheresmystuff.coins;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.StorageTabPanel;

/** CoinsStorageTabPanel is responsible for displaying coins storage data to the player. */
public class CoinsStorageTabPanel
    extends StorageTabPanel<CoinsStorageType, CoinsStorage, CoinsStorageManager> {

  public CoinsStorageTabPanel(DudeWheresMyStuffPlugin plugin, CoinsStorageManager storageManager) {
    super(plugin, storageManager);
  }
}

package dev.thource.runelite.dudewheresmystuff.coins;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/**
 * BountyHunterCoffer is responsible for tracking how many coins the player has stored in the bounty
 * hunter coffer.
 */
public class BountyHunterCoffer extends CoinsStorage {

  private static final Pattern depositWithdrawPattern =

      Pattern.compile(
          "You (?:withdrew|added) \\d+ coins (?:from|to) your coffer. There are now (\\d+) coins in it. You need to "
              + "have at least \\d+ coins in your coffer to participate.");

  BountyHunterCoffer(DudeWheresMyStuffPlugin plugin) {
    super(CoinsStorageType.BOUNTY_HUNTER, plugin);
  }

  public boolean updateFromMain() {
    Widget widget = plugin.getClient().getWidget(219, 1);
    if (widget == null) {
      return false;
    }

    Widget textWidget = widget.getChild(0);
    if (textWidget == null) {
      return false;
    }
    if (!textWidget.getText().startsWith("Current coffer: ")) {
      return false;
    }

    int parsedCoins = NumberUtils.toInt(textWidget.getText().replaceAll("\\D+", ""), 0);
    this.getCoinStack().setQuantity(parsedCoins);
    updateLastUpdated();
    return true;
  }

  public boolean updateFromDepositWithdraw() {
    Widget widget = plugin.getClient().getWidget(193, 2);
    if (widget == null) {
      return false;
    }

    String text = widget.getText().replace(",", "").replace("<br>", " ");
    Matcher matcher = depositWithdrawPattern.matcher(text);
    if (!matcher.matches()) {
      return false;
    }

    int parsedCoins = NumberUtils.toInt(matcher.group(1), 0);
    this.getCoinStack().setQuantity(parsedCoins);
    updateLastUpdated();
    return true;
  }

  @Override
  public boolean onGameTick() {
    return updateFromMain() || updateFromDepositWithdraw();
  }
}

package dev.thource.runelite.dudewheresmystuff.coins;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.Var;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarPlayerID;

/**
 * ScarEssenceMine is responsible for tracking how many coins the player has stored in the Scar
 * essence mine coffer.
 */
public class ScarEssenceMine extends CoinsStorage {

  ScarEssenceMine(DudeWheresMyStuffPlugin plugin) {
    super(CoinsStorageType.SCAR_ESSENCE_MINE, plugin);
  }

  @Override
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    var client = plugin.getClient();

    var coinsVar = Var.player(varbitChanged, VarPlayerID.SCAR_ESSENCEMINE_COFFER);
    if (coinsVar.wasChanged()) {
      var newQuantity = coinsVar.getValue(client);
      if (newQuantity != coinStack.getQuantity()) {
        coinStack.setQuantity(newQuantity);
        return true;
      }
    }

    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.coins;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import java.util.Objects;
import lombok.Getter;
import net.runelite.api.widgets.Widget;

/** LootingBag is responsible for tracking the player's coins in their looting bag. */
@Getter
public class LootingBag extends CoinsStorage {

  LootingBag(DudeWheresMyStuffPlugin plugin) {
    super(CoinsStorageType.LOOTING_BAG, plugin);
  }

  @Override
  public boolean onGameTick() {
    Widget lootingBagWidget = plugin.getClient().getWidget(81, 5);
    if (lootingBagWidget == null) {
      return false;
    }

    Widget emptyText = lootingBagWidget.getChild(28);
    if (emptyText == null || !Objects.equals(emptyText.getText(), "The bag is empty.")) {
      return false;
    }

    coinStack.setQuantity(0);
    updateLastUpdated();
    return true;
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

/** Slayer is responsible for tracking the player's Slayer points. */
@Getter
public class Slayer extends MinigamesStorage {

  private final ItemStack points = new ItemStack(ItemID.SKULL, "Points", 0, 0, 0, true);

  Slayer(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.SLAYER, plugin);

    varbits = new int[]{VarbitID.SLAYER_POINTS};

    items.add(points);
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Var;
import lombok.Getter;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

/** BarbarianAssault is responsible for tracking the player's Barbarian Assault points. */
@Getter
public class BarbarianAssault extends MinigamesStorage {

  private final ItemStack attackerPoints =
      new ItemStack(ItemID.BARBASSAULT_PLAYERICON_ATTACKER, "Attacker Points", 0, 0, 0, true);
  private final ItemStack collectorPoints =
      new ItemStack(ItemID.BARBASSAULT_PLAYERICON_COLLECTOR, "Collector Points", 0, 0, 0, true);
  private final ItemStack defenderPoints =
      new ItemStack(ItemID.BARBASSAULT_PLAYERICON_DEFENDER, "Defender Points", 0, 0, 0, true);
  private final ItemStack healerPoints =
      new ItemStack(ItemID.BARBASSAULT_PLAYERICON_HEALER, "Healer Points", 0, 0, 0, true);

  BarbarianAssault(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.BARBARIAN_ASSAULT, plugin);

    varbits =
        new int[] {
          VarbitID.BARBASSAULT_POINTS_ATTACKER_BASE,
          VarbitID.BARBASSAULT_POINTS_COLLECTOR_BASE,
          VarbitID.BARBASSAULT_POINTS_DEFENDER_BASE,
          VarbitID.BARBASSAULT_POINTS_HEALER_BASE
        };

    items.add(attackerPoints);
    items.add(collectorPoints);
    items.add(defenderPoints);
    items.add(healerPoints);
  }

  @Override
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    if (varbits == null) {
      return false;
    }

    for (int i = 0; i < varbits.length; i++) {
      var var = Var.bit(varbitChanged, varbits[i]);
      if (!var.wasChanged()) {
        continue;
      }

      var itemStack = items.get(i);
      var client = plugin.getClient();
      var newPoints = var.getValue(client) + (client.getVarbitValue(varbits[i] + 4) * 512);
      if (newPoints == itemStack.getQuantity()) {
        continue;
      }

      itemStack.setQuantity(newPoints);
      return true;
    }

    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.util.Text;

/** VolcanicMine is responsible for tracking the player's Volcanic Mine points. */
@Getter
public class VolcanicMine extends MinigamesStorage {

  private static final Pattern SHOP_PATTERN = Pattern.compile("Points: (\\d+)");

  private final ItemStack points = new ItemStack(ItemID.FOSSIL_VOLCANIC_ASH, "Points", 0, 0, 0, true);

  VolcanicMine(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.VOLCANIC_MINE, plugin);

    items.add(points);
  }

  @Override
  public boolean onGameTick() {
    return updateFromWidgets();
  }

  boolean updateFromWidgets() {
    Widget widget = plugin.getClient().getWidget(612, 5);
    if (widget == null) {
      return false;
    }

    String widgetText = Text.removeTags(widget.getText()).replace(",", "");
    Matcher matcher = SHOP_PATTERN.matcher(widgetText);
    if (!matcher.find()) {
      return false;
    }

    updateLastUpdated();
    int newPoints = Integer.parseInt(matcher.group(1));
    if (newPoints != points.getQuantity()) {
      points.setQuantity(newPoints);
    }
    return true;
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.util.Text;

/** LastManStanding is responsible for tracking the player's Last Man Standing points. */
@Getter
public class LastManStanding extends MinigamesStorage {

  private static final Pattern SHOP_PATTERN = Pattern.compile("Points: (\\d+)");

  private final ItemStack points = new ItemStack(ItemID.SKULL, "Points", 0, 0, 0, true);

  LastManStanding(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.LAST_MAN_STANDING, plugin);

    items.add(points);
  }

  @Override
  public boolean onGameTick() {
    return updateFromWidgets();
  }

  boolean updateFromWidgets() {
    Widget widget = plugin.getClient().getWidget(645, 8);
    if (widget == null) {
      return false;
    }

    String widgetText = Text.removeTags(widget.getText()).replace(",", "");
    Matcher matcher = SHOP_PATTERN.matcher(widgetText);
    if (!matcher.find()) {
      return false;
    }

    updateLastUpdated();
    int newPoints = Integer.parseInt(matcher.group(1));
    if (newPoints != points.getQuantity()) {
      points.setQuantity(newPoints);
    }
    return true;
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStorage;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import dev.thource.runelite.dudewheresmystuff.StoragePanel;
import lombok.Getter;

@Getter
abstract class MinigamesStorage extends ItemStorage<MinigamesStorageType> {

  protected MinigamesStorage(MinigamesStorageType type, DudeWheresMyStuffPlugin plugin) {
    super(type, plugin);

    hasStaticItems = true;
  }

  @Override
  protected void createStoragePanel(StorageManager<?, ?> storageManager) {
    storagePanel = new StoragePanel(plugin, this, false, true, true);

    createComponentPopupMenu(storageManager);
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.StorageTabPanel;
import java.util.Comparator;

/** MinigamesStorageTabPanel is responsible for displaying minigame data to the player. */
public class MinigamesStorageTabPanel
    extends StorageTabPanel<MinigamesStorageType, MinigamesStorage, MinigamesStorageManager> {

  /** A constructor. */
  public MinigamesStorageTabPanel(
      DudeWheresMyStuffPlugin plugin, MinigamesStorageManager storageManager) {
    super(plugin, storageManager);

    remove(sortItemsDropdown);
  }

  @Override
  protected Comparator<MinigamesStorage> getStorageSorter() {
    return Comparator.comparing(s -> s.getType().getName());
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Getter;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/** PestControl is responsible for tracking the player's Pest Control points. */
@Getter
public class PestControl extends MinigamesStorage {

  private static final Pattern afterGamePattern1 = Pattern.compile(
      "awarded you (\\d+) Void Knight");
  private static final Pattern afterGamePattern2 = Pattern.compile(
      "now have <col=800000>(\\d+)<col=000080> Void Knight");
  private static final Pattern afterPurchasePattern = Pattern.compile(
      "Remaining Void Knight Commendation Points: (\\d+)");

  private final ItemStack points =
      new ItemStack(ItemID.PEST_SEAL_1, "Points", 0, 0, 0, true);

  private Widget shopWidget = null;

  PestControl(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.PEST_CONTROL, plugin);

    items.add(points);
  }

  @Override
  public boolean onGameTick() {
    // This can't go in onWidgetLoaded because for some reason the text isn't populated at that
    // point
    Widget widget = plugin.getClient().getWidget(229, 1);
    if (widget != null) {
      String widgetText = widget.getText().replace("<br>", " ").replace(",", "");
      Matcher matcher = afterGamePattern2.matcher(widgetText);
      if (matcher.find()) {
        points.setQuantity(NumberUtils.toInt(matcher.group(1)));
        updateLastUpdated();
        return true;
      }

      matcher = afterPurchasePattern.matcher(widgetText);
      if (matcher.find()) {
        points.setQuantity(NumberUtils.toInt(matcher.group(1)));
        updateLastUpdated();
        return true;
      }
    }

    return updateFromWidget();
  }

  @Override
  public boolean onWidgetLoaded(WidgetLoaded widgetLoaded) {
    if (widgetLoaded.getGroupId() == 243) {
      shopWidget = plugin.getClient().getWidget(243, 0);
      return updateFromWidget();
    } else if (widgetLoaded.getGroupId() == 231) {
      Widget widget = plugin.getClient().getWidget(231, 6);
      if (widget != null) {
        Matcher matcher = afterGamePattern1.matcher(widget.getText().replace("<br>", " "));
        if (matcher.find()) {
          points.setQuantity(points.getQuantity() + NumberUtils.toInt(matcher.group(1)));
          updateLastUpdated();
          return true;
        }
      }
    }

    return false;
  }

  @Override
  public void onWidgetClosed(WidgetClosed widgetClosed) {
    if (widgetClosed.getGroupId() == 243) {
      shopWidget = null;
    }
  }

  boolean updateFromWidget() {
    if (shopWidget == null) {
      return false;
    }

    updateLastUpdated();
    points.setQuantity(plugin.getClient().getVarpValue(VarPlayerID.IF1));
    return true;
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Var;
import lombok.Getter;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;

/** NightmareZone is responsible for tracking the player's Nightmare Zone points. */
@Getter
public class NightmareZone extends MinigamesStorage {

  private final ItemStack points = new ItemStack(ItemID.DREAM_VIAL_FULL, "Points", 0, 0, 0, true);

  NightmareZone(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.NIGHTMARE_ZONE, plugin);

    varbits =
        new int[] {
          VarbitID.NZONE_POTION_1,
          VarbitID.NZONE_POTION_2,
          VarbitID.NZONE_POTION_3,
          VarbitID.NZONE_POTION_4
        };
    varbitItemOffset = 1;

    items.add(points);
    items.add(new ItemStack(ItemID.NZONE1DOSE2RANGERSPOTION, 0, plugin));
    items.add(new ItemStack(ItemID.NZONE1DOSE2MAGICPOTION, 0, plugin));
    items.add(new ItemStack(ItemID.NZONE1DOSEOVERLOADPOTION, 0, plugin));
    items.add(new ItemStack(ItemID.NZONE1DOSEABSORPTIONPOTION, 0, plugin));
    plugin
        .getClientThread()
        .invokeLater(() -> items.forEach(itemStack -> itemStack.setStackable(true)));
  }

  @Override
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    var updated = super.onVarbitChanged(varbitChanged);

    var currentPointsVar = Var.bit(varbitChanged, VarbitID.NZONE_CURRENTPOINTS);
    var rewardPointsVar = Var.player(varbitChanged, VarPlayerID.NZONE_REWARDPOINTS);
    if (!currentPointsVar.wasChanged() && !rewardPointsVar.wasChanged()) {
      return updated;
    }

    var client = plugin.getClient();
    int newPoints = currentPointsVar.getValue(client) + rewardPointsVar.getValue(client);
    if (newPoints != points.getQuantity()) {
      points.setQuantity(newPoints);
      updated = true;
    }

    return updated;
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.math.NumberUtils;

/** MasteringMixology tracks paste/points at the Mastering Mixology minigame. */
public class MasteringMixology extends MinigamesStorage {

  private final ItemStack moxPaste;
  private final ItemStack agaPaste;
  private final ItemStack lyePaste;
  private final ItemStack moxResin;
  private final ItemStack agaResin;
  private final ItemStack lyeResin;

  private static final Pattern rewardPointsPattern =
      Pattern.compile("You are rewarded \\d+/\\d+/\\d+. You now have (\\d+)/(\\d+)/(\\d+).");

  protected MasteringMixology(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.MASTERING_MIXOLOGY, plugin);

    hasStaticItems = true;

    varbits =
        new int[] {VarbitID.MM_AVAILABLE_MOX, VarbitID.MM_AVAILABLE_AGA, VarbitID.MM_AVAILABLE_LYE};

    moxPaste = new ItemStack(ItemID.MM_MOX_PASTE, plugin);
    items.add(moxPaste);
    agaPaste = new ItemStack(ItemID.MM_AGA_PASTE, plugin);
    items.add(agaPaste);
    lyePaste = new ItemStack(ItemID.MM_LYE_PASTE, plugin);
    items.add(lyePaste);

    moxResin = new ItemStack(-2, "Mox resin", 0, 0, 0, true); // sprite 5666
    moxResin.setSpriteId(5666);
    agaResin = new ItemStack(-2, "Aga resin", 0, 0, 0, true); // sprite 5667
    agaResin.setSpriteId(5667);
    lyeResin = new ItemStack(-2, "Lye resin", 0, 0, 0, true); // sprite 5668
    lyeResin.setSpriteId(5668);

    items.add(moxResin);
    items.add(agaResin);
    items.add(lyeResin);
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if ((chatMessage.getType() != ChatMessageType.SPAM
            && chatMessage.getType() != ChatMessageType.GAMEMESSAGE)
        || !chatMessage.getMessage().startsWith("You are rewarded ")) {
      return false;
    }

    Matcher matcher =
        rewardPointsPattern.matcher(Text.removeTags(chatMessage.getMessage().replace(",", "")));
    if (!matcher.find()) {
      return false;
    }

    boolean updated = false;
    int newMoxResin = NumberUtils.toInt(matcher.group(1), 0);
    if (newMoxResin != moxResin.getQuantity()) {
      moxResin.setQuantity(newMoxResin);
      updated = true;
    }

    int newAgaResin = NumberUtils.toInt(matcher.group(2), 0);
    if (newAgaResin != agaResin.getQuantity()) {
      agaResin.setQuantity(newAgaResin);
      updated = true;
    }

    int newLyeResin = NumberUtils.toInt(matcher.group(3), 0);
    if (newLyeResin != lyeResin.getQuantity()) {
      lyeResin.setQuantity(newLyeResin);
      updated = true;
    }

    if (updated) {
      updateLastUpdated();
    }

    return updated;
  }

  @Override
  public boolean onGameTick() {
    return updateFromWidgets();
  }

  private boolean updateFromOverlay() {
    Widget widget = plugin.getClient().getWidget(InterfaceID.MmOverlay.CONTENT);
    if (widget == null) {
      return false;
    }

    Widget[] widgetChildren = widget.getChildren();
    if (widgetChildren == null || widgetChildren.length < 16) {
      return false;
    }

    updateLastUpdated();

    int newMoxPaste = Integer.parseInt(widgetChildren[8].getText());
    if (newMoxPaste != moxPaste.getQuantity()) {
      moxPaste.setQuantity(newMoxPaste);
    }

    int newAgaPaste = Integer.parseInt(widgetChildren[11].getText());
    if (newAgaPaste != agaPaste.getQuantity()) {
      agaPaste.setQuantity(newAgaPaste);
    }

    int newLyePaste = Integer.parseInt(widgetChildren[14].getText());
    if (newLyePaste != lyePaste.getQuantity()) {
      lyePaste.setQuantity(newLyePaste);
    }

    return true;
  }

  private boolean updateFromShop() {
    Widget widget = plugin.getClient().getWidget(InterfaceID.OmnishopMain.POINTS_LAYER);
    if (widget == null) {
      return false;
    }

    Widget[] widgetChildren = widget.getChildren();
    if (widgetChildren == null || widgetChildren.length < 9) {
      return false;
    }

    updateLastUpdated();

    int newMoxResin = Integer.parseInt(widgetChildren[2].getText()
        .replace(",", "").replace("k", ""));
    if (widgetChildren[2].getText().endsWith("k")) {
      newMoxResin *= 1000;
    }
    if (newMoxResin != moxResin.getQuantity()) {
      moxResin.setQuantity(newMoxResin);
    }

    int newAgaResin = Integer.parseInt(widgetChildren[5].getText()
        .replace(",", "").replace("k", ""));
    if (widgetChildren[5].getText().endsWith("k")) {
      newAgaResin *= 1000;
    }
    if (newAgaResin != agaResin.getQuantity()) {
      agaResin.setQuantity(newAgaResin);
    }

    int newLyeResin = Integer.parseInt(widgetChildren[8].getText()
        .replace(",", "").replace("k", ""));
    if (widgetChildren[8].getText().endsWith("k")) {
      newLyeResin *= 1000;
    }
    if (newLyeResin != lyeResin.getQuantity()) {
      lyeResin.setQuantity(newLyeResin);
    }

    return true;
  }

  private boolean updateFromWidgets() {
    return updateFromOverlay() | updateFromShop();
  }

  @Override
  public boolean isWithdrawable() {
    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import lombok.Getter;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/** MageTrainingArena is responsible for tracking the player's Mage Training Arena points. */
@Getter
public class MageTrainingArena extends MinigamesStorage {

  private final ItemStack telekineticPoints =
      new ItemStack(ItemID.LAWRUNE, "Telekinetic Points", 0, 0, 0, true);
  private final ItemStack graveyardPoints =
      new ItemStack(ItemID.PEACH, "Graveyard Points", 0, 0, 0, true);
  private final ItemStack enchantmentPoints =
      new ItemStack(ItemID.MAGICTRAINING_ENCHAN_CYLINDER, "Enchantment Points", 0, 0, 0, true);
  private final ItemStack alchemistPoints =
      new ItemStack(ItemID.FAKE_COINS, "Alchemist Points", 0, 0, 0, true);

  private final Map<ItemStack, MageTrainingArenaPoint> pointData = new HashMap<>();

  private Widget shopWidget = null;
  private boolean lobbyWidgetOpen;

  MageTrainingArena(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.MAGE_TRAINING_ARENA, plugin);

    items.add(telekineticPoints);
    items.add(graveyardPoints);
    items.add(enchantmentPoints);
    items.add(alchemistPoints);

    pointData.put(telekineticPoints, new MageTrainingArenaPoint(198, 261, 10));
    pointData.put(alchemistPoints, new MageTrainingArenaPoint(194, 262, 11));
    pointData.put(enchantmentPoints, new MageTrainingArenaPoint(195, 263, 12));
    pointData.put(graveyardPoints, new MageTrainingArenaPoint(196, 264, 13));
  }

  @Override
  public boolean onGameTick() {
    return updateFromWidgets();
  }

  @Override
  public boolean onWidgetLoaded(WidgetLoaded widgetLoaded) {
    if (widgetLoaded.getGroupId() == 197) {
      shopWidget = plugin.getClient().getWidget(197, 0);
    } else if (widgetLoaded.getGroupId() == 553) {
      lobbyWidgetOpen = true;
    } else {
      pointData.forEach(
          (itemStack, pointDatum) -> {
            if (widgetLoaded.getGroupId() != pointDatum.getWidgetId()) {
              return;
            }

            pointDatum.widget = plugin.getClient().getWidget(pointDatum.getWidgetId(), 6);
          });
    }

    return updateFromWidgets();
  }

  @Override
  public void onWidgetClosed(WidgetClosed widgetClosed) {
    if (widgetClosed.getGroupId() == 197) {
      shopWidget = null;
    } else if (widgetClosed.getGroupId() == 553) {
      lobbyWidgetOpen = false;
    } else {
      pointData.forEach(
          (itemStack, pointDatum) -> {
            if (widgetClosed.getGroupId() != pointDatum.getWidgetId()) {
              return;
            }

            pointDatum.widget = null;
          });
    }
  }

  boolean updateFromWidgets() {
    if (shopWidget != null) {
      updateLastUpdated();
      pointData.forEach(
          (itemStack, pointDatum) -> {
            int newPoints = plugin.getClient().getVarpValue(pointDatum.getVarpId());
            itemStack.setQuantity(newPoints);
          });

      return true;
    }

    if (lobbyWidgetOpen) {
      lastUpdated = System.currentTimeMillis();
      pointData.forEach(
          (itemStack, pointDatum) -> {
            Widget widget = plugin.getClient().getWidget(553, pointDatum.getLobbyWidgetId());
            if (widget == null) {
              return;
            }

            int newPoints = NumberUtils.toInt(widget.getText().replace(",", ""), 0);
            itemStack.setQuantity(newPoints);
          });

      return true;
    }

    for (Entry<ItemStack, MageTrainingArenaPoint> entry : pointData.entrySet()) {
      ItemStack itemStack = entry.getKey();
      MageTrainingArenaPoint pointDatum = entry.getValue();
      if (pointDatum.getWidget() == null) {
        continue;
      }

      int newPoints = NumberUtils.toInt(pointDatum.getWidget().getText().replace(",", ""), 0);
      itemStack.setQuantity(newPoints);
      updateLastUpdated();
      return true;
    }

    return false;
  }

  @Override
  public void reset() {
    super.reset();

    pointData.forEach((itemStack, mageTrainingArenaPoint) -> mageTrainingArenaPoint.reset());
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.widgets.Widget;

@RequiredArgsConstructor
@Getter
class MageTrainingArenaPoint {

  final int widgetId;
  final int varpId;
  final int lobbyWidgetId;
  Widget widget = null;

  void reset() {
    widget = null;
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

/** Tempoross is responsible for tracking the player's Tempoross reward permits. */
@Getter
public class Tempoross extends MinigamesStorage {

  private final ItemStack points = new ItemStack(ItemID.TOME_OF_WATER, "Reward permits", 0, 0, 0, true);

  Tempoross(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.TEMPOROSS, plugin);

    varbits = new int[]{VarbitID.TEMPOROSS_REWARDPERMITS};

    items.add(points);
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Region;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/**
 * GuardiansOfTheRift is responsible for tracking the player's Guardians of the Rift reward points.
 */
@Getter
public class GuardiansOfTheRift extends MinigamesStorage {

  private final ItemStack elementalEnergy =
      new ItemStack(ItemID.AIRRUNE, "Elemental Energy", 0, 0, 0, true);
  private final ItemStack catalyticEnergy =
      new ItemStack(ItemID.COSMICRUNE, "Catalytic Energy", 0, 0, 0, true);

  private final Pattern chatPointsPattern =
      Pattern.compile(
          "Total elemental energy: <col=ef1020>(\\d+)</col>\\. "
              + "Total catalytic energy: {2}<col=ef1020>(\\d+)</col>\\.");

  private final Pattern widgetPattern =
      Pattern.compile("You have (\\d+) catalytic energy and (\\d+) elemental energy\\.");

  GuardiansOfTheRift(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.GUARDIANS_OF_THE_RIFT, plugin);

    items.add(elementalEnergy);
    items.add(catalyticEnergy);
  }

  @Override
  public boolean onGameTick() {
    Widget widget = plugin.getClient().getWidget(229, 1);
    if (widget == null) {
      return false;
    }

    Matcher matcher = widgetPattern.matcher(widget.getText().replace(",", ""));
    if (!matcher.find()) {
      return false;
    }

    final long lastElementalEnergy = elementalEnergy.getQuantity();
    final long lastCatalyticEnergy = catalyticEnergy.getQuantity();
    elementalEnergy.setQuantity(NumberUtils.toInt(matcher.group(2), 0));
    catalyticEnergy.setQuantity(NumberUtils.toInt(matcher.group(1), 0));
    updateLastUpdated();

    return lastElementalEnergy != elementalEnergy.getQuantity()
        || lastCatalyticEnergy != catalyticEnergy.getQuantity();
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (chatMessage.getType() != ChatMessageType.SPAM
        && chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
      return false;
    }

    if (chatMessage.getMessage().startsWith("You found some loot:")) {
      if (Region.get(
          WorldPoint.fromLocalInstance(
                  plugin.getClient(),
                  Objects.requireNonNull(plugin.getClient().getLocalPlayer())
                      .getLocalLocation())
              .getRegionID())
          != Region.MG_GUARDIANS_OF_THE_RIFT) {
        return false;
      }

      elementalEnergy.setQuantity(elementalEnergy.getQuantity() - 1);
      catalyticEnergy.setQuantity(catalyticEnergy.getQuantity() - 1);
      updateLastUpdated();

      return true;
    }

    Matcher matcher = chatPointsPattern.matcher(chatMessage.getMessage().replace(",", ""));
    if (!matcher.matches()) {
      return false;
    }

    final long lastElementalEnergy = elementalEnergy.getQuantity();
    final long lastCatalyticEnergy = catalyticEnergy.getQuantity();
    elementalEnergy.setQuantity(NumberUtils.toInt(matcher.group(1), 0));
    catalyticEnergy.setQuantity(NumberUtils.toInt(matcher.group(2), 0));
    updateLastUpdated();

    return lastElementalEnergy != elementalEnergy.getQuantity()
        || lastCatalyticEnergy != catalyticEnergy.getQuantity();
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/** GiantsFoundry is responsible for tracking the player's Giants' Foundry points. */
@Getter
public class GiantsFoundry extends MinigamesStorage {

  private static final Pattern HAND_IN_PATTERN = Pattern.compile("at quality: (\\d+)");

  private final ItemStack points =
      new ItemStack(ItemID.GIANTS_FOUNDRY_COLOSSAL_BLADE, "Points", 0, 0, 0, true);
  private boolean didJustHandIn = false;

  GiantsFoundry(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.GIANTS_FOUNDRY, plugin);

    items.add(points);
  }

  @Override
  public boolean onGameTick() {
    Widget shopWidget = plugin.getClient().getWidget(753, 13);
    if (shopWidget != null) {
      points.setQuantity(Integer.parseInt(shopWidget.getText()));
      updateLastUpdated();
      return true;
    }

    Widget chatWidget = plugin.getClient().getWidget(229, 1);
    if (chatWidget != null) {
      if (!didJustHandIn) {
        Matcher matcher = HAND_IN_PATTERN.matcher(chatWidget.getText());
        if (matcher.find()) {
          points.setQuantity(points.getQuantity() + NumberUtils.toInt(matcher.group(1)));
          updateLastUpdated();
          didJustHandIn = true;
          return true;
        }
      }
    } else {
      didJustHandIn = false;
    }

    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.math.NumberUtils;

/** MahoganyHomes is responsible for tracking the player's Mahogany Homes points. */
@Getter
public class MahoganyHomes extends MinigamesStorage {

  private final Pattern chatMessagePattern =
      Pattern.compile(
          "You have completed <col=ef1020>\\d+</col> contracts with a total of "
              + "<col=ef1020>(\\d+)</col> points\\.");

  private final ItemStack points = new ItemStack(ItemID.POH_SAW, "Points", 0, 0, 0, true);

  MahoganyHomes(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.MAHOGANY_HOMES, plugin);

    items.add(points);
  }

  @Override
  public boolean onGameTick() {
    Widget widget = plugin.getClient().getWidget(673, 8);
    if (widget == null) {
      return false;
    }

    points.setQuantity(
        NumberUtils.toInt(Text.removeTags(widget.getText()).replaceAll("\\D+", ""), 0));
    updateLastUpdated();
    return true;
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (chatMessage.getType() != ChatMessageType.SPAM
        && chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
      return false;
    }

    Matcher matcher = chatMessagePattern.matcher(chatMessage.getMessage().replace(",", ""));
    if (!matcher.matches()) {
      return false;
    }

    points.setQuantity(NumberUtils.toInt(matcher.group(1), 0));
    updateLastUpdated();

    return true;
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

/** TitheFarm is responsible for tracking the player's Tithe Farm points. */
@Getter
public class TitheFarm extends MinigamesStorage {

  private final ItemStack points = new ItemStack(ItemID.ZEAH_WATERINGCAN, "Points", 0, 0, 0, true);

  TitheFarm(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.TITHE_FARM, plugin);

    varbits = new int[]{VarbitID.HOSIDIUS_TITHE_REWARDPOINTS};

    items.add(points);
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.StorageType;
import java.util.List;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

/** MinigamesStorageType is used to identify MinigameStorages. */
@RequiredArgsConstructor
@Getter
public enum MinigamesStorageType implements StorageType {
  MAGE_TRAINING_ARENA("Mage Training Arena", false, "magetrainingarena"),
  TITHE_FARM("Tithe Farm", true, "tithefarm"),
  LAST_MAN_STANDING("Last Man Standing", false, "lastmanstanding"),
  NIGHTMARE_ZONE("Nightmare Zone", true, "nightmarezone"),
  PEST_CONTROL("Pest Control", false, "pestcontrol"),
  BARBARIAN_ASSAULT("Barbarian Assault", true, "barbarianassault"),
  GUARDIANS_OF_THE_RIFT("Guardians of the Rift", false, "guardiansoftherift"),
  TEMPOROSS("Tempoross", true, "tempoross"),
  SLAYER("Slayer", true, "slayer"),
  SOUL_WARS("Soul Wars", true, "soulwars"),
  MAHOGANY_HOMES("Mahogany Homes", false, "mahoganyhomes"),
  GIANTS_FOUNDRY("Giants' Foundry", false, "giantsfoundry"),
  VOLCANIC_MINE("Volcanic Mine", false, "volcanicmine"),
  TROUBLE_BREWING("Trouble Brewing", true, "troubleBrewing"),
  MASTERING_MIXOLOGY("Mastering Mixology", false, "masteringMixology"),
  WINTERTODT("Wintertodt", true, "wintertodt");

  private final String name;
  private final int itemContainerId = -1;
  // Whether the storage can be updated with no action required by the player
  private final boolean automatic;
  private final String configKey;
  private final boolean membersOnly = true;
  private final List<Integer> accountTypeBlacklist = null;
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Var;
import lombok.Getter;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarPlayerID;

/** TroubleBrewing is responsible for tracking the player's Trouble Brewing pieces of eight. */
@Getter
public class TroubleBrewing extends MinigamesStorage {

  private final ItemStack points = new ItemStack(ItemID.BREW_PIECE_OF_EIGHT, "Pieces of eight", 0, 0, 0, true);

  TroubleBrewing(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.TROUBLE_BREWING, plugin);

    items.add(points);
  }

  @Override
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    var piecesVar = Var.player(varbitChanged, VarPlayerID.BREW_PIECES);
    if (!piecesVar.wasChanged()) {
      return false;
    }

    var newPoints = piecesVar.getValue(plugin.getClient());
    if (newPoints != points.getQuantity()) {
      points.setQuantity(newPoints);
      return true;
    }

    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.minigames;

import com.google.inject.Inject;
import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import lombok.extern.slf4j.Slf4j;

/** MinigamesStorageManager is responsible for managing all MinigamesStorages. */
@Slf4j
public class MinigamesStorageManager
    extends StorageManager<MinigamesStorageType, MinigamesStorage> {

  @Inject
  private MinigamesStorageManager(DudeWheresMyStuffPlugin plugin) {
    super(plugin);

    storages.add(new BarbarianAssault(plugin));
    storages.add(new GiantsFoundry(plugin));
    storages.add(new GuardiansOfTheRift(plugin));
    storages.add(new LastManStanding(plugin));
    storages.add(new MageTrainingArena(plugin));
    storages.add(new MahoganyHomes(plugin));
    storages.add(new NightmareZone(plugin));
    storages.add(new PestControl(plugin));
    storages.add(new Slayer(plugin));
    storages.add(new TitheFarm(plugin));
    storages.add(new TroubleBrewing(plugin));
    storages.add(new VolcanicMine(plugin));
    storages.add(new MasteringMixology(plugin));
    storages.add(new Tempoross(plugin));
    storages.add(new Wintertodt(plugin));
  }

  @Override
  public String getConfigKey() {
    return "minigames";
  }

}

package dev.thource.runelite.dudewheresmystuff.minigames;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

/** Wintertodt is responsible for tracking the player's Wintertodt reward permits. */
@Getter
public class Wintertodt extends MinigamesStorage {

  private final ItemStack points =
      new ItemStack(ItemID.TOME_OF_FIRE, "Reward permits", 0, 0, 0, true);

  Wintertodt(DudeWheresMyStuffPlugin plugin) {
    super(MinigamesStorageType.WINTERTODT, plugin);

    varbits = new int[] {VarbitID.WINT_REWARD_POOL};

    items.add(points);
  }
}

package dev.thource.runelite.dudewheresmystuff;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.annotation.Nullable;
import lombok.Getter;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.VarbitChanged;

/** ItemStorage builds upon Storage by adding items and some other functionality. */
public class ItemStorage<T extends StorageType> extends Storage<T> {

  @Nullable protected int[] varbits = null;
  // used when there are items before the varbit items
  protected int varbitItemOffset = 0;
  @Nullable protected final ItemContainerWatcher itemContainerWatcher;
  @Getter protected List<ItemStack> items = new ArrayList<>();
  protected boolean hasStaticItems = false;

  protected ItemStorage(T type, DudeWheresMyStuffPlugin plugin) {
    super(type, plugin);

    itemContainerWatcher = ItemContainerWatcher.getWatcher(type.getItemContainerId());
  }

  @Override
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    if (varbits == null) {
      return false;
    }

    var updated = false;

    var client = plugin.getClient();
    for (int i = 0; i < varbits.length; i++) {
      var var = Var.bit(varbitChanged, varbits[i]);
      if (!var.wasChanged()) {
        continue;
      }

      var itemStack = items.get(i + varbitItemOffset);
      var newQuantity = var.getValue(client);
      if (newQuantity == itemStack.getQuantity()) {
        continue;
      }

      itemStack.setQuantity(newQuantity);
      updated = true;
      if (!type.isAutomatic()) {
        updateLastUpdated();
      }
    }

    return updated;
  }

  @Override
  public boolean onGameTick() {
    if (itemContainerWatcher != null && itemContainerWatcher.wasJustUpdated()) {
      items.clear();
      itemContainerWatcher.getItems().forEach(item -> {
        ItemComposition itemComposition = plugin.getItemManager().getItemComposition(item.getId());
        if (itemComposition.getPlaceholderTemplateId() == -1) {
          items.add(new ItemStack(item.getId(), item.getQuantity(), plugin));
        }
      });
      updateLastUpdated();

      return true;
    }

    return false;
  }

  @Override
  public boolean onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
    if (itemContainerWatcher != null
        || type.getItemContainerId() != itemContainerChanged.getContainerId()) {
      return false;
    }

    ItemContainer itemContainer = itemContainerChanged.getItemContainer();
    if (itemContainer == null) {
      return false;
    }

    resetItems();
    for (Item item : itemContainer.getItems()) {
      if (hasStaticItems) {
        items.stream()
            .filter(i -> item.getId() == i.getId())
            .findFirst()
            .ifPresent(i -> i.setQuantity(item.getQuantity()));
        continue;
      }

      if (item.getId() == -1) {
        items.add(new ItemStack(item.getId(), "empty slot", 1, 0, 0, false));
        continue;
      }

      ItemComposition itemComposition = plugin.getItemManager().getItemComposition(item.getId());
      if (itemComposition.getPlaceholderTemplateId() == -1) {
        items.add(new ItemStack(item.getId(), item.getQuantity(), plugin));
      }
    }

    updateLastUpdated();

    return true;
  }

  @Override
  protected ArrayList<String> getSaveValues() {
    ArrayList<String> saveValues = super.getSaveValues();

    saveValues.add(SaveFieldFormatter.format(items, hasStaticItems));

    return saveValues;
  }

  @Override
  protected void loadValues(ArrayList<String> values) {
    super.loadValues(values);

    if (hasStaticItems) {
      SaveFieldLoader.loadItemsIntoList(values, items);
    } else {
      items = SaveFieldLoader.loadItems(values, items, plugin);
    }
  }

  @Override
  public long getTotalValue() {
    long sum = 0L;
    for (ItemStack item : items) {
      sum += item.getTotalGePrice();
    }
    return sum;
  }

  @Override
  public void reset() {
    resetItems();

    super.reset();
  }

  protected void resetItems() {
    if (hasStaticItems) {
      items.forEach(item -> item.setQuantity(0));
    } else {
      items.clear();
    }
  }

  /**
   * Removes a quantity of items with the id specified.
   *
   * @param id       the item id of the item to remove
   * @param quantity the amount of the item to remove
   * @return the amount of items removed from the storage
   */
  public long remove(int id, long quantity) {
    if (quantity <= 0) {
      return 0;
    }

    long itemsRemoved = 0;
    Iterator<ItemStack> listIterator = items.iterator();
    while (listIterator.hasNext() && quantity > 0) {
      ItemStack itemStack = listIterator.next();
      if (itemStack.getId() != id) {
        continue;
      }

      long qtyToRemove = Math.min(quantity, itemStack.getQuantity());
      quantity -= qtyToRemove;
      itemsRemoved += qtyToRemove;
      itemStack.setQuantity(itemStack.getQuantity() - qtyToRemove);
      if (itemStack.getQuantity() <= 0) {
        listIterator.remove();
      }
    }

    return itemsRemoved;
  }
}

package dev.thource.runelite.dudewheresmystuff;

import java.awt.event.KeyEvent;
import javax.annotation.Nullable;
import javax.inject.Inject;
import lombok.Setter;
import net.runelite.client.input.KeyListener;

public class ItemCountInputListener implements KeyListener {

  private final DudeWheresMyStuffConfig dudeWheresMyStuffConfig;
  @Setter @Nullable private ItemCountOverlay itemCountOverlay;

  @Inject
  private ItemCountInputListener(DudeWheresMyStuffConfig dudeWheresMyStuffConfig) {
    this.dudeWheresMyStuffConfig = dudeWheresMyStuffConfig;
  }

  @Override
  public void keyTyped(KeyEvent keyEvent) {
    // not needed
  }

  @Override
  public void keyPressed(KeyEvent keyEvent) {
    if (itemCountOverlay == null) {
      return;
    }

    if (dudeWheresMyStuffConfig.storedItemCountTooltipKeybind().matches(keyEvent)) {
      itemCountOverlay.setKeybindPressed(true);
    }
  }

  @Override
  public void keyReleased(KeyEvent keyEvent) {
    if (itemCountOverlay == null) {
      return;
    }

    if (dudeWheresMyStuffConfig.storedItemCountTooltipKeybind().matches(keyEvent)) {
      itemCountOverlay.setKeybindPressed(false);
    }
  }
}

package dev.thource.runelite.dudewheresmystuff;

import dev.thource.runelite.dudewheresmystuff.death.DeathbankType;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

/**
 * SaveFieldFormatter converts strings into various data types so that they can be loaded.
 *
 * <p>This class is the opposite of SaveFieldFormatter.
 */
public class SaveFieldLoader {

  private SaveFieldLoader() {
  }

  /**
   * Pulls a string from the string list, converts it to a long and returns it or the default
   * value.
   *
   * @param stringList the string list
   * @param dfault     the fallback value to return
   * @return the converted first string of the string list, or the fallback value
   */
  public static long loadLong(List<String> stringList, long dfault) {
    if (stringList.isEmpty()) {
      return dfault;
    }

    try {
      return Long.parseLong(stringList.remove(0));
    } catch (NumberFormatException e) {
      return dfault;
    }
  }

  /**
   * Pulls a string from the string list, converts it to a UUID and returns it or the default
   * value.
   *
   * @param stringList the string list
   * @param dfault     the fallback value to return
   * @return the converted first string of the string list, or the fallback value
   */
  @SuppressWarnings("checkstyle:AbbreviationAsWordInName")
  public static UUID loadUUID(List<String> stringList, UUID dfault) {
    if (stringList.isEmpty()) {
      return dfault;
    }

    try {
      return UUID.fromString(stringList.remove(0));
    } catch (IllegalArgumentException e) {
      return dfault;
    }
  }

  /**
   * Pulls a string from the string list and uses it to set the quantities of the ItemStacks in
   * itemStacks.
   *
   * @param stringList the string list
   * @param itemStacks the list of items to modify the quantities of
   */
  public static void loadItemsIntoList(List<String> stringList, List<ItemStack> itemStacks) {
    if (stringList.isEmpty()) {
      return;
    }

    int i = 0;
    for (String quantity : stringList.remove(0).split(",")) {
      if (i >= itemStacks.size()) {
        break;
      }

      try {
        itemStacks.get(i).setQuantity(Long.parseLong(quantity));
      } catch (NumberFormatException e) {
        // do nothing
      }
      i++;
    }
  }

  /**
   * Pulls a string from the string list, converts it to a list of ItemStack and returns it or the
   * default value.
   *
   * @param stringList the string list
   * @param dfault     the fallback value to return
   * @return the converted first string of the string list, or the fallback value
   */
  public static List<ItemStack> loadItems(List<String> stringList, List<ItemStack> dfault,
      DudeWheresMyStuffPlugin plugin) {
    if (stringList.isEmpty()) {
      return dfault;
    }

    ArrayList<ItemStack> itemStacks = new ArrayList<>();
    for (String stackData : stringList.remove(0).split(",")) {
      String[] stackDataSplit = stackData.split("x");
      if (stackDataSplit.length != 2) {
        continue;
      }

      try {
        itemStacks.add(
            new ItemStack(Integer.parseInt(stackDataSplit[0]), Long.parseLong(stackDataSplit[1]),
                plugin));
      } catch (NumberFormatException e) {
        // do nothing
      }
    }

    return itemStacks;
  }

  /**
   * Pulls a string from the string list, converts it to a boolean and returns it or the default
   * value.
   *
   * @param stringList the string list
   * @param dfault     the fallback value to return
   * @return the converted first string of the string list, or the fallback value
   */
  public static boolean loadBoolean(List<String> stringList, boolean dfault) {
    if (stringList.isEmpty()) {
      return dfault;
    }

    return stringList.remove(0).equals("true");
  }

  /**
   * Pulls a string from the string list, converts it to a DeathbankType and returns it or the
   * default value.
   *
   * @param stringList the string list
   * @param dfault     the fallback value to return
   * @return the converted first string of the string list, or the fallback value
   */
  public static DeathbankType loadDeathbankType(List<String> stringList,
      DeathbankType dfault) {
    if (stringList.isEmpty()) {
      return dfault;
    }

    try {
      return DeathbankType.valueOf(stringList.remove(0));
    } catch (IllegalArgumentException e) {
      return dfault;
    }
  }

  /**
   * Pulls a string from the string list, converts it to a WorldPoint and returns it or the default
   * value.
   *
   * @param stringList the string list
   * @param dfault     the fallback value to return
   * @return the converted first string of the string list, or the fallback value
   */
  public static WorldPoint loadWorldPoint(List<String> stringList, WorldPoint dfault) {
    if (stringList.isEmpty()) {
      return dfault;
    }

    String[] splitData = stringList.remove(0).split(",");
    if (splitData.length != 3) {
      stringList.add(0, String.join(",", splitData));
      return dfault;
    }

    try {
      return new WorldPoint(Integer.parseInt(splitData[0]), Integer.parseInt(splitData[1]),
          Integer.parseInt(splitData[2]));
    } catch (NumberFormatException e) {
      return dfault;
    }
  }

  /**
   * Pulls a string from the string list, converts it to a WorldArea and returns it or the default
   * value.
   *
   * @param stringList the string list
   * @param dfault     the fallback value to return
   * @return the converted first string of the string list, or the fallback value
   */
  public static WorldArea loadWorldArea(List<String> stringList, WorldArea dfault) {
    if (stringList.isEmpty()) {
      return dfault;
    }

    String[] splitData = stringList.remove(0).split(",");
    if (splitData.length != 5) {
      stringList.add(0, String.join(",", splitData));
      return dfault;
    }

    try {
      return new WorldArea(Integer.parseInt(splitData[0]), Integer.parseInt(splitData[1]),
          Integer.parseInt(splitData[2]), Integer.parseInt(splitData[3]),
          Integer.parseInt(splitData[4]));
    } catch (NumberFormatException e) {
      return dfault;
    }
  }

  /**
   * Pulls a string from the string list, converts it to an int and returns it or the default
   * value.
   *
   * @param stringList the string list
   * @param dfault     the fallback value to return
   * @return the converted first string of the string list, or the fallback value
   */
  public static int loadInt(List<String> stringList, int dfault) {
    if (stringList.isEmpty()) {
      return dfault;
    }

    try {
      return Integer.parseInt(stringList.remove(0));
    } catch (NumberFormatException e) {
      return dfault;
    }
  }
}

package dev.thource.runelite.dudewheresmystuff;

import com.google.inject.Provides;
import com.google.inject.name.Named;
import dev.thource.runelite.dudewheresmystuff.carryable.CarryableStorageManager;
import dev.thource.runelite.dudewheresmystuff.coins.CoinsStorageManager;
import dev.thource.runelite.dudewheresmystuff.death.DeathStorageManager;
import dev.thource.runelite.dudewheresmystuff.death.ExpiringDeathStorageTextOverlay;
import dev.thource.runelite.dudewheresmystuff.death.ExpiringDeathStorageTilesOverlay;
import dev.thource.runelite.dudewheresmystuff.minigames.MinigamesStorageManager;
import dev.thource.runelite.dudewheresmystuff.playerownedhouse.PlayerOwnedHouseStorageManager;
import dev.thource.runelite.dudewheresmystuff.stash.StashStorageManager;
import dev.thource.runelite.dudewheresmystuff.world.WorldStorageManager;
import java.awt.Component;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import javax.inject.Inject;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.ItemContainer;
import net.runelite.api.KeyCode;
import net.runelite.api.MenuAction;
import net.runelite.api.VarClientInt;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.FocusChanged;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfile;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.ConfigSync;
import net.runelite.client.events.RuneScapeProfileChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.itemidentification.ItemIdentificationConfig;
import net.runelite.client.plugins.itemidentification.ItemIdentificationPlugin;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;

/**
 * DudeWheresMyStuffPlugin is a RuneLite plugin designed to help accounts of all types find their
 * items, coins and minigame points.
 */
@Slf4j
@PluginDescriptor(
    name = "Dude, Where's My Stuff?",
    description = "Helps you keep track of your stuff (items, gp, minigame points) by recording "
        + "and showing you where they are in an easy to view way.",
    tags = {"uim", "storage", "deathbank", "deathstorage", "death", "deathpile", "coins", "poh",
        "stash", "minigames", "leprechaun", "fossils"}
)
@PluginDependency(ItemIdentificationPlugin.class)
public class DudeWheresMyStuffPlugin extends Plugin {

  private static final String CONFIG_KEY_IS_MEMBER = "isMember";
  private static final String CONFIG_KEY_SAVE_MIGRATED = "saveMigrated";

  @Getter @Inject protected PluginManager pluginManager;
  @Getter @Inject protected ItemIdentificationPlugin itemIdentificationPlugin;
  @Getter @Inject protected ItemIdentificationConfig itemIdentificationConfig;

  @Inject @Getter @Named("developerMode") boolean developerMode;

  @Inject private ClientToolbar clientToolbar;
  @Getter @Inject private Notifier notifier;
  @Getter @Inject private Client client;
  @Getter @Inject private ClientThread clientThread;
  @Getter @Inject private InfoBoxManager infoBoxManager;
  @Getter @Inject private ItemManager itemManager;
  @Getter @Inject private SpriteManager spriteManager;
  @Getter @Inject private DudeWheresMyStuffConfig config;
  @Getter @Inject private ConfigManager configManager;
  @Inject private OverlayManager overlayManager;
  @Inject private KeyManager keyManager;
  @Getter @Inject private ChatMessageManager chatMessageManager;

  private ExpiringDeathStorageTilesOverlay expiringDeathStorageTilesOverlay;
  private ExpiringDeathStorageTextOverlay expiringDeathStorageTextOverlay;
  @Inject private ItemCountOverlay itemCountOverlay;
  @Inject private ItemCountInputListener itemCountInputListener;
  @Inject private DeathStorageManager deathStorageManager;
  @Inject private DeathStorageManager previewDeathStorageManager;
  @Inject private CoinsStorageManager coinsStorageManager;
  @Inject private CoinsStorageManager previewCoinsStorageManager;
  @Inject private CarryableStorageManager carryableStorageManager;
  @Inject private CarryableStorageManager previewCarryableStorageManager;
  @Getter @Inject private WorldStorageManager worldStorageManager;
  @Inject private WorldStorageManager previewWorldStorageManager;
  @Inject private StashStorageManager stashStorageManager;
  @Inject private StashStorageManager previewStashStorageManager;
  @Inject private PlayerOwnedHouseStorageManager playerOwnedHouseStorageManager;
  @Inject private PlayerOwnedHouseStorageManager previewPlayerOwnedHouseStorageManager;
  @Inject private MinigamesStorageManager minigamesStorageManager;
  @Inject private MinigamesStorageManager previewMinigamesStorageManager;
  private StorageManagerManager storageManagerManager;
  private StorageManagerManager previewStorageManagerManager;

  private DudeWheresMyStuffPanelContainer panelContainer;
  private NavigationButton navButton;
  private ClientState clientState = ClientState.LOGGED_OUT;
  private boolean pluginStartedAlreadyLoggedIn;
  private String profileKey;
  @Getter private String previewProfileKey;

  /**
   * Displays a confirmation popup to the user and returns true if they confirmed it.
   *
   * @param parentComponent the calling component
   * @param text            the description shown to the user
   * @param confirmText     the text displayed on the confirmation button
   * @return true if they clicked the confirmation button
   */
  public static boolean getConfirmation(Component parentComponent, String text,
      String confirmText) {
    int result = JOptionPane.CANCEL_OPTION;

    try {
      result =
          JOptionPane.showConfirmDialog(parentComponent, text, confirmText,
              JOptionPane.OK_CANCEL_OPTION, JOptionPane.WARNING_MESSAGE);
    } catch (Exception err) {
      log.warn("Unexpected exception occurred while check for confirm required", err);
    }

    return result == JOptionPane.OK_OPTION;
  }

  Stream<RuneScapeProfile> getProfilesWithData() {
    return configManager
        .getRSProfiles()
        .stream()
        .filter(profile -> configManager.getConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP,
            profile.getKey(), CONFIG_KEY_IS_MEMBER) != null);
  }

  @Override
  protected void startUp() {
    if (panelContainer == null) {
      expiringDeathStorageTilesOverlay = new ExpiringDeathStorageTilesOverlay(config, client,
          deathStorageManager, this);
      expiringDeathStorageTextOverlay = new ExpiringDeathStorageTextOverlay(config,
          deathStorageManager, client);
      deathStorageManager.setCarryableStorageManager(carryableStorageManager);
      deathStorageManager.setCoinsStorageManager(coinsStorageManager);
      worldStorageManager
          .getLeprechaun()
          .setBottomlessBucketStorage(carryableStorageManager.getBottomlessBucket());
      storageManagerManager =
          new StorageManagerManager(
              this,
              carryableStorageManager,
              coinsStorageManager,
              deathStorageManager,
              minigamesStorageManager,
              stashStorageManager,
              playerOwnedHouseStorageManager,
              worldStorageManager);

      previewCarryableStorageManager.setPreviewManager(true);
      previewCoinsStorageManager.setPreviewManager(true);
      previewDeathStorageManager.setPreviewManager(true);
      previewMinigamesStorageManager.setPreviewManager(true);
      previewStashStorageManager.setPreviewManager(true);
      previewPlayerOwnedHouseStorageManager.setPreviewManager(true);
      previewWorldStorageManager.setPreviewManager(true);

      previewDeathStorageManager.setCarryableStorageManager(previewCarryableStorageManager);
      previewDeathStorageManager.setCoinsStorageManager(previewCoinsStorageManager);
      previewWorldStorageManager
          .getLeprechaun()
          .setBottomlessBucketStorage(previewCarryableStorageManager.getBottomlessBucket());
      previewStorageManagerManager =
          new StorageManagerManager(
              this,
              previewCarryableStorageManager,
              previewCoinsStorageManager,
              previewDeathStorageManager,
              previewMinigamesStorageManager,
              previewStashStorageManager,
              previewPlayerOwnedHouseStorageManager,
              previewWorldStorageManager);

      panelContainer =
          new DudeWheresMyStuffPanelContainer(
              new DudeWheresMyStuffPanel(
                  this, configManager, storageManagerManager, false),
              new DudeWheresMyStuffPanel(
                  this,
                  configManager,
                  previewStorageManagerManager,
                  true
              ));

      SwingUtilities.invokeLater(
          () -> {
            storageManagerManager
                .getStorageManagers()
                .forEach(
                    storageManager ->
                        storageManager.getStorages()
                            .forEach(o -> o.createStoragePanel(storageManager)));

            previewStorageManagerManager
                .getStorageManagers()
                .forEach(
                    storageManager ->
                        storageManager.getStorages()
                            .forEach(o -> o.createStoragePanel(storageManager)));
          });

      clientThread.invoke(() -> navButton = buildNavigationButton());

      ItemContainerWatcher.init(client);
    }

    reset();

    clientThread.invoke(() -> clientToolbar.addNavigation(navButton));

    AtomicBoolean anyProfilesMigrated = new AtomicBoolean(false);
    getProfilesWithData().forEach(runeScapeProfile -> {
      if (configManager.getConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP,
          runeScapeProfile.getKey(), CONFIG_KEY_SAVE_MIGRATED) == null) {
        new SaveMigrator(configManager, runeScapeProfile.getKey()).migrate();
        anyProfilesMigrated.set(true);
      }
    });
    if (anyProfilesMigrated.get()) {
      configManager.sendConfig();
    }

    if (client.getGameState() == GameState.LOGGED_IN) {
      clientState = ClientState.LOGGING_IN;
      pluginStartedAlreadyLoggedIn = true;
    } else if (client.getGameState() == GameState.LOGGING_IN) {
      clientState = ClientState.LOGGING_IN;
    }

    deathStorageManager.refreshInfoBoxes();

    overlayManager.add(expiringDeathStorageTextOverlay);
    overlayManager.add(expiringDeathStorageTilesOverlay);
    overlayManager.add(itemCountOverlay);
    itemCountInputListener.setItemCountOverlay(itemCountOverlay);
    keyManager.registerKeyListener(itemCountInputListener);
  }

  private void reset() {
    clientState = ClientState.LOGGED_OUT;

    ItemContainerWatcher.reset();
    storageManagerManager.reset();
    panelContainer.reset();
  }

  @Override
  protected void shutDown() {
    save();

    clientToolbar.removeNavigation(navButton);

    infoBoxManager.removeIf(
        infoBox -> infoBox.getName().startsWith(this.getClass().getSimpleName()));

    overlayManager.remove(expiringDeathStorageTextOverlay);
    overlayManager.remove(expiringDeathStorageTilesOverlay);
    overlayManager.remove(itemCountOverlay);
    keyManager.unregisterKeyListener(itemCountInputListener);
  }

  @Subscribe
  public void onFocusChanged(FocusChanged focusChanged) {
    if (!focusChanged.isFocused()) {
      itemCountOverlay.setKeybindPressed(false);
    }
  }

  @Subscribe
  public void onConfigSync(ConfigSync configSync) {
    save();
  }

  @Subscribe
  public void onClientShutdown(ClientShutdown clientShutdown) {
    save();
  }

  private void load(String profileKey) {
    this.profileKey = profileKey;

    clientThread.invokeLater(
        () -> {
          storageManagerManager.reset();
          storageManagerManager.load(profileKey);
          SwingUtilities.invokeLater(panelContainer.getPanel()::softUpdate);
        });
  }

  private void save() {
    if (profileKey == null) {
      return;
    }

    storageManagerManager.save(profileKey);
  }

  @Subscribe
  void onConfigChanged(ConfigChanged configChanged) {
    if (!Objects.equals(configChanged.getGroup(), DudeWheresMyStuffConfig.CONFIG_GROUP)) {
      return;
    }

    switch (configChanged.getKey()) {
      case "showEmptyStorages":
        panelContainer.reorderStoragePanels();
        break;
      case "sidebarIcon":
        clientThread.invoke(() -> {
          clientToolbar.removeNavigation(navButton);

          navButton = buildNavigationButton();
          clientToolbar.addNavigation(navButton);
        });
        break;
      case "itemSortMode":
        ItemSortMode newValue = configChanged.getNewValue() != null ?
            ItemSortMode.valueOf(configChanged.getNewValue()):
            ItemSortMode.UNSORTED;
        setItemSortMode(newValue);
        break;
      case "deathpilesUseAccountPlayTime":
      case "deathbankInfoBox":
      case "deathpileInfoBox":
        deathStorageManager.refreshInfoBoxes();
        break;
      case "showDeathStorageRiskWarning":
        SwingUtilities.invokeLater(
            () -> deathStorageManager.getStorageTabPanel().reorderStoragePanels());
        break;
      case "deathpileColorScheme":
        deathStorageManager.refreshDeathpileColors();
        break;
      default:
        // do nothing
    }
  }

  private NavigationButton buildNavigationButton() {
    return NavigationButton.builder()
        .tooltip("Dude, Where's My Stuff?")
        .icon(config.sidebarIcon().getIcon(itemManager))
        .panel(panelContainer)
        .priority(4)
        .build();
  }

  @Subscribe
  void onActorDeath(ActorDeath actorDeath) {
    storageManagerManager.onActorDeath(actorDeath);
  }

  @Subscribe
  void onChatMessage(ChatMessage chatMessage) {
    if (clientState == ClientState.LOGGED_OUT) {
      return;
    }

    storageManagerManager.onChatMessage(chatMessage);
  }

  private String toTitleCase(String str) {
    if (str == null) {
      return null;
    }

    Pattern pattern = Pattern.compile("(_|^)(\\w)([^_]*)");
    Matcher matcher = pattern.matcher(str.toLowerCase());

    StringBuilder builder = new StringBuilder();
    while (matcher.find()) {
      builder.append(matcher.group(1)).append(matcher.group(2).toUpperCase())
          .append(matcher.group(3));
    }
    return builder.toString().replace("_", " ");
  }

  /**
   * Gets the display name for the supplied profileKey and appends the account type if not
   * standard.
   *
   * @param profileKey the profile key
   * @return display name, potentially with a suffix
   */
  public String getDisplayName(String profileKey) {
    RuneScapeProfile profile = configManager.getRSProfiles().stream()
        .filter(p -> p.getKey().equals(profileKey))
        .findFirst().orElse(null);

    return getDisplayName(profile);
  }

  /**
   * Gets the display name for the supplied profile and appends the account type if not standard.
   *
   * @param profile the profile
   * @return display name, potentially with a suffix
   */
  public String getDisplayName(RuneScapeProfile profile) {
    if (profile == null) {
      return "Unknown";
    }

    String displayName = profile.getDisplayName();
    if (profile.getType() != RuneScapeProfileType.STANDARD) {
      displayName += " - " + toTitleCase(profile.getType().toString());
    }

    return displayName;
  }

  @Subscribe
  void onRuneScapeProfileChanged(RuneScapeProfileChanged e) {
    save();
    load(configManager.getRSProfileKey());

    String displayName = getDisplayName(configManager.getRSProfileKey());
    if (Objects.equals(displayName, panelContainer.getPreviewPanel().getDisplayName())) {
      disablePreviewMode(false);
    }

    panelContainer.getPanel().setDisplayName(displayName);
  }

  @Subscribe
  void onGameStateChanged(GameStateChanged gameStateChanged) {
    storageManagerManager.onGameStateChanged(gameStateChanged);

    if (gameStateChanged.getGameState() == GameState.LOGGING_IN) {
      clientState = ClientState.LOGGING_IN;
    }
  }

  @Subscribe
  void onGameTick(GameTick gameTick) {
    if (clientState == ClientState.LOGGED_OUT) {
      return;
    }

    if (clientState == ClientState.LOGGING_IN) {
      final boolean isMember = client.getVarcIntValue(VarClientInt.MEMBERSHIP_STATUS) == 1;
      final int accountType = client.getVarbitValue(VarbitID.IRONMAN);
      final String displayName = getDisplayName(configManager.getRSProfileKey());

      // All saves should be migrated on plugin start, so this must be a new account
      if (configManager.getRSProfileConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP,
          CONFIG_KEY_SAVE_MIGRATED) == null) {
        configManager.setRSProfileConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP,
            CONFIG_KEY_SAVE_MIGRATED, true);
      }

      configManager.setRSProfileConfiguration(
          DudeWheresMyStuffConfig.CONFIG_GROUP, CONFIG_KEY_IS_MEMBER, isMember);
      configManager.setRSProfileConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP, "accountType",
          accountType);

      panelContainer.getPanel().logIn(isMember, accountType, displayName);
      clientState = ClientState.LOGGED_IN;

      if (pluginStartedAlreadyLoggedIn) {
        load(configManager.getRSProfileKey());

        clientThread.invokeLater(() -> {
          for (ItemContainer itemContainer : client.getItemContainers()) {
            onItemContainerChanged(new ItemContainerChanged(itemContainer.getId(), itemContainer));
          }

          var varbitChanged = new VarbitChanged();
          varbitChanged.setVarbitId(-999);
          onVarbitChanged(varbitChanged);
        });

        panelContainer.getPanel().setDisplayName(getDisplayName(configManager.getRSProfileKey()));

        pluginStartedAlreadyLoggedIn = false;
      }

      SwingUtilities.invokeLater(panelContainer.getPanel()::softUpdate);

      return;
    }

    expiringDeathStorageTextOverlay.updateSoonestExpiringDeathStorage();

    ItemContainerWatcher.onGameTick(this);
    storageManagerManager.onGameTick();

    SwingUtilities.invokeLater(panelContainer::softUpdate);
  }

  @Subscribe
  void onGameObjectSpawned(GameObjectSpawned gameObjectSpawned) {
    if (clientState == ClientState.LOGGED_OUT) {
      return;
    }

    storageManagerManager.onGameObjectSpawned(gameObjectSpawned);
  }

  @Subscribe
  void onMenuOptionClicked(MenuOptionClicked menuOption) {
    if (clientState == ClientState.LOGGED_OUT) {
      return;
    }

    storageManagerManager.onMenuOptionClicked(menuOption);
  }

  @Subscribe
  void onMenuEntryAdded(MenuEntryAdded menuEntryAdded) {
    final boolean hotKeyPressed = client.isKeyPressed(KeyCode.KC_SHIFT);
    if (!isDeveloperMode() || !menuEntryAdded.getOption().equals("Walk here") || !hotKeyPressed) {
      return;
    }

    if (Objects.equals(configManager.getConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP, "debug.menu.createDeathpile"), "true")) {
      client
          .getMenu()
          .createMenuEntry(-1)
          .setOption("Create deathpile")
          .setType(MenuAction.RUNELITE)
          .onClick(
              e -> {
                var target = client.getTopLevelWorldView().getSelectedSceneTile();
                if (target != null) {
                  SwingUtilities.invokeLater(
                      () ->
                          deathStorageManager
                              .getDeathItemsStorage()
                              .createDebugDeathpile(
                                  WorldPoint.fromLocalInstance(client, target.getLocalLocation())));
                }
              });
    }

    if (Objects.equals(configManager.getConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP, "debug.menu.logCoords"), "true")) {
      client
          .getMenu()
          .createMenuEntry(-1)
          .setOption("Log co-ords")
          .setType(MenuAction.RUNELITE)
          .onClick(
              e -> {
                var target = client.getTopLevelWorldView().getSelectedSceneTile();
                if (target != null) {
                  var worldPoint = WorldPoint.fromLocalInstance(client, target.getLocalLocation());
                  log.info(
                      "Co-ords: {}, {}, {}",
                      worldPoint.getX(),
                      worldPoint.getY(),
                      worldPoint.getPlane());
                }
              });
    }
  }

  @Subscribe
  void onWidgetLoaded(WidgetLoaded widgetLoaded) {
    if (clientState == ClientState.LOGGED_OUT) {
      return;
    }

    storageManagerManager.onWidgetLoaded(widgetLoaded);
  }

  @Subscribe
  void onWidgetClosed(WidgetClosed widgetClosed) {
    if (clientState == ClientState.LOGGED_OUT) {
      return;
    }

    storageManagerManager.onWidgetClosed(widgetClosed);
  }

  @Subscribe
  void onVarbitChanged(VarbitChanged varbitChanged) {
    if (clientState == ClientState.LOGGED_OUT) {
      return;
    }

    storageManagerManager.onVarbitChanged(varbitChanged);
  }

  @Subscribe
  void onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
    if (clientState == ClientState.LOGGED_OUT) {
      return;
    }

    storageManagerManager.onItemContainerChanged(itemContainerChanged);
  }

  @Subscribe
  void onItemDespawned(ItemDespawned itemDespawned) {
    if (clientState == ClientState.LOGGED_OUT) {
      return;
    }

    storageManagerManager.onItemDespawned(itemDespawned);
  }

  @Provides
  DudeWheresMyStuffConfig provideConfig(ConfigManager configManager) {
    return configManager.getConfig(DudeWheresMyStuffConfig.class);
  }

  void disablePreviewMode(boolean deleteData) {
    previewStorageManagerManager.reset();

    if (deleteData) {
      for (String key :
          configManager.getRSProfileConfigurationKeys(
              DudeWheresMyStuffConfig.CONFIG_GROUP, previewProfileKey, "")) {
        configManager.unsetConfiguration(
            DudeWheresMyStuffConfig.CONFIG_GROUP, previewProfileKey, key);
      }

      if (Objects.equals(previewProfileKey, configManager.getRSProfileKey())) {
        storageManagerManager.reset();

        storageManagerManager
            .getStorageManagers()
            .forEach(
                storageManager -> {
                  storageManager
                      .getStorages()
                      .forEach(storage -> {
                        if (storage.getStoragePanel() != null) {
                          storage.getStoragePanel().refreshItems();
                          SwingUtilities.invokeLater(() -> storage.getStoragePanel().update());
                        }
                      });

                  SwingUtilities.invokeLater(
                      () -> storageManager.getStorageTabPanel().reorderStoragePanels());
                });
      }
    }

    SwingUtilities.invokeLater(
        () -> {
          panelContainer.getPreviewPanel().logOut();

          panelContainer.disablePreviewMode();
        });
    this.previewProfileKey = null;
  }

  void enablePreviewMode(String profileKey, String displayName) {
    this.previewProfileKey = profileKey;

    Integer playedMinutes = configManager.getConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP,
        profileKey, "minutesPlayed", int.class);
    previewDeathStorageManager.setStartPlayedMinutes(playedMinutes == null ? 0 : playedMinutes);
    clientThread.invoke(
        () -> {
          previewStorageManagerManager.load(profileKey);

          panelContainer
              .getPreviewPanel()
              .logIn(
                  configManager.getConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP, profileKey,
                      CONFIG_KEY_IS_MEMBER, boolean.class),
                  configManager.getConfiguration(
                      DudeWheresMyStuffConfig.CONFIG_GROUP,
                      profileKey,
                      "accountType",
                      int.class),
                  displayName
              );

          panelContainer.enablePreviewMode();
        });
  }

  public void setItemSortMode(ItemSortMode itemSortMode) {
    panelContainer.setItemSortMode(itemSortMode);
  }

  void deleteAllData() {
    getProfilesWithData().forEach(runeScapeProfile -> {
      for (String configKey : configManager.getRSProfileConfigurationKeys(
          DudeWheresMyStuffConfig.CONFIG_GROUP, runeScapeProfile.getKey(),
          "")) {
        configManager.unsetConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP,
            runeScapeProfile.getKey(), configKey);
      }
    });
    configManager.sendConfig();
  }

  public long getWithdrawableItemCount(int id) {
    int canonicalId = itemManager.canonicalize(id);

    return storageManagerManager.getStoredItemCountStorages()
        .mapToLong(storage -> storage.getItemCount(canonicalId)).sum();
  }

  public Map<Storage<?>, Long> getDetailedWithdrawableItemCount(int id) {
    int canonicalId = itemManager.canonicalize(id);

    HashMap<Storage<?>, Long> map = new HashMap<>();

    storageManagerManager.getStoredItemCountStorages()
        .forEach(storage -> {
          long count = storage.getItemCount(canonicalId);

          if (count > 0) {
            map.put(storage, count);
          }
        });

    return map;
  }
}

/*
 * Copyright (c) 2022, Thource <https://github.com/Thource>
 * Copyright (c) 2018, Daniel Teo <https://github.com/takuyakanbr>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package dev.thource.runelite.dudewheresmystuff;

import com.google.common.collect.ImmutableMap;
import dev.thource.runelite.dudewheresmystuff.export.DataDestination;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.JPopupMenu.Separator;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;

@Slf4j
class OverviewTabPanel extends TabContentPanel {

  private static final String LOGGED_OUT_SUMMARY = "Log in to find your stuff!";
  private static final String GP_TOTAL = "%,d gp";
  private static final String DELETE_SAVE_WARNING = "Are you sure you want to delete your save data?\nThis cannot be undone.";
  private static final String DELETE_ALL_DEATHPILES_WARNING = "Are you sure you want to delete all"
      + " of your deathpiles/graves (including any active ones)?\nThis cannot be undone.";
  private static final String DELETE_ALL_EXPIRED_DEATHPILES_WARNING = "Are you sure you want to"
      + " delete all of your expired deathpiles/graves?\nThis cannot be undone.";
  private static final String DELETE_ALL_DEATHBANKS_WARNING = "Are you sure you want to delete all"
      + " of your deathbanks (including any active ones)?\nThis cannot be undone.";
  private static final String DELETE_ALL_LOST_DEATHBANKS_WARNING = "Are you sure you want to"
      + " delete all of your lost deathbanks?\nThis cannot be undone.";
  private static final String DELETE_ALL_SAVE_WARNING = "Are you sure you want to delete ALL of your save data?\nThis cannot be undone.";
  private static final String DELETE_ALL_SAVE_FINAL_WARNING = "Are you REALLY sure you want to "
      + "delete ALL of your save data?\nThis REALLY cannot be undone.";
  private static final String EXPORT_ITEMS_TO_CSV_TEXT = "Export items to CSV";
  private static final String EXPORT_ITEMS_TO_GOOGLE_SHEETS_TEXT = "Export items to Google Sheets";
  private static final String CONFIRM_DELETION_TEXT = "Confirm deletion";

  @Getter private final Map<Tab, OverviewItemPanel> overviews;
  private final OverviewItemPanel summaryOverview;
  private final DudeWheresMyStuffPanel pluginPanel;
  private final transient DudeWheresMyStuffPlugin plugin;
  private final transient StorageManagerManager storageManagerManager;

  OverviewTabPanel(
      DudeWheresMyStuffPlugin plugin,
      DudeWheresMyStuffPanel pluginPanel,
      ItemManager itemManager,
      ConfigManager configManager,
      StorageManagerManager storageManagerManager,
      boolean developerMode) {
    this.pluginPanel = pluginPanel;
    this.plugin = plugin;
    this.storageManagerManager = storageManagerManager;

    setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
    setBackground(ColorScheme.DARK_GRAY_COLOR);

    summaryOverview =
        new OverviewItemPanel(itemManager, null, () -> false, ItemID.HW16_CLUE_LIBRARY, 1, LOGGED_OUT_SUMMARY);
    add(summaryOverview);
    add(Box.createVerticalStrut(8));
    if (developerMode) {
      summaryOverview.addMouseListener(
          new MouseAdapter() {
            int clicks;
            long lastClick;

            @Override
            public void mouseClicked(MouseEvent e) {
              if (System.currentTimeMillis() - lastClick < 500) {
                if (++clicks == 5) {
                  clicks = 0;
                  FakeDataService.createData(configManager);
                  log.info("Created fake data!");
                  resetSummaryContextMenu();
                }
              } else {
                clicks = 1;
              }

              lastClick = System.currentTimeMillis();
            }
          });
    }
    resetSummaryContextMenu();

    //noinspection UnstableApiUsage
    overviews =
        Tab.TABS.stream()
            .filter(v -> v != Tab.OVERVIEW && v != Tab.SEARCH)
            .collect(
                ImmutableMap.toImmutableMap(
                    Function.identity(),
                    t -> {
                      OverviewItemPanel p =
                          new OverviewItemPanel(itemManager, pluginPanel, t, t.getName());
                      add(p);
                      add(Box.createVerticalStrut(8));
                      p.setVisible(false);
                      return p;
                    }));

    createDeathStoragePopupMenu();
  }

  private void createDeathStoragePopupMenu() {
    JMenuItem deleteAllDeathpiles = new JMenuItem("Delete all deathpiles/graves");
    deleteAllDeathpiles.addActionListener(
        e -> {
          if (DudeWheresMyStuffPlugin.getConfirmation(this, DELETE_ALL_DEATHPILES_WARNING, CONFIRM_DELETION_TEXT)) {
            storageManagerManager.getDeathStorageManager().deleteExpiringDeathStorages(true);
          }
        });
    JMenuItem deleteExpiredDeathpiles = new JMenuItem("Delete expired deathpiles/graves");
    deleteExpiredDeathpiles.addActionListener(
        e -> {
          if (DudeWheresMyStuffPlugin.getConfirmation(this, DELETE_ALL_EXPIRED_DEATHPILES_WARNING, CONFIRM_DELETION_TEXT)) {
            storageManagerManager.getDeathStorageManager().deleteExpiringDeathStorages(false);
          }
        });
    JMenuItem deleteAllDeathbanks = new JMenuItem("Delete all deathbanks");
    deleteAllDeathbanks.addActionListener(
        e -> {
          if (DudeWheresMyStuffPlugin.getConfirmation(this, DELETE_ALL_DEATHBANKS_WARNING, CONFIRM_DELETION_TEXT)) {
            storageManagerManager.getDeathStorageManager().deleteDeathbanks(true);
          }
        });
    JMenuItem deleteLostDeathbanks = new JMenuItem("Delete lost deathbanks");
    deleteLostDeathbanks.addActionListener(
        e -> {
          if (DudeWheresMyStuffPlugin.getConfirmation(this, DELETE_ALL_LOST_DEATHBANKS_WARNING, CONFIRM_DELETION_TEXT)) {
            storageManagerManager.getDeathStorageManager().deleteDeathbanks(false);
          }
        });

    JPopupMenu popupMenu = new JPopupMenu();
    popupMenu.add(deleteAllDeathpiles);
    popupMenu.add(deleteExpiredDeathpiles);
    popupMenu.add(deleteAllDeathbanks);
    popupMenu.add(deleteLostDeathbanks);
    overviews.get(Tab.DEATH).setComponentPopupMenu(popupMenu);
  }

  @Override
  public void softUpdate() {
    resetSummaryContextMenu();

    if (Objects.equals(pluginPanel.getDisplayName(), "")) {
      summaryOverview.setTitle(LOGGED_OUT_SUMMARY);
      summaryOverview.updateStatus("Right-click to preview data.");
    } else {
      summaryOverview.setTitle(pluginPanel.getDisplayName());

      if (pluginPanel.isPreviewPanel()
          && !Objects.equals(pluginPanel.getDisplayName(), "Thource")) {
        summaryOverview.updateStatus(
            String.format(
                "<html><body style=\"margin: 0; padding: 0;\">%,d gp<br>Right-click to exit preview"
                    + ".</body></html>",
                getTotalValue()));
      } else {
        summaryOverview.updateStatus(String.format(GP_TOTAL, getTotalValue()));
      }
    }

    overviews
        .get(Tab.DEATH)
        .updateStatus(
            String.format(
                GP_TOTAL, storageManagerManager.getDeathStorageManager().getTotalValue()));
    overviews
        .get(Tab.COINS)
        .updateStatus(
            String.format(
                GP_TOTAL, storageManagerManager.getCoinsStorageManager().getTotalValue()));
    overviews
        .get(Tab.CARRYABLE_STORAGE)
        .updateStatus(
            String.format(
                GP_TOTAL, storageManagerManager.getCarryableStorageManager().getTotalValue()));
    overviews
        .get(Tab.STASH_UNITS)
        .updateStatus(
            String.format(
                GP_TOTAL, storageManagerManager.getStashStorageManager().getTotalValue()));
    overviews
        .get(Tab.POH_STORAGE)
        .updateStatus(
            String.format(
                GP_TOTAL,
                storageManagerManager.getPlayerOwnedHouseStorageManager().getTotalValue()));
    overviews
        .get(Tab.WORLD)
        .updateStatus(
            String.format(
                GP_TOTAL, storageManagerManager.getWorldStorageManager().getTotalValue()));
  }

  private long getTotalValue() {
    return storageManagerManager.getItems().stream().mapToLong(ItemStack::getTotalGePrice).sum();
  }

  void resetSummaryContextMenu() {
    SwingUtilities.invokeLater(
        () -> {
          final JPopupMenu popupMenu = new JPopupMenu();
          popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
          summaryOverview.setComponentPopupMenu(popupMenu);

          if (pluginPanel.isPreviewPanel()) {
            addDeleteDeathbankMenuOption(popupMenu);
            addExitPreviewModeMenuOption(popupMenu);
          } else {
            addPreviewModeMenuOption(popupMenu);
            addDeleteAllDataMenuOption(popupMenu);
          }
          addExportToCsvMenuOption(popupMenu);
          addExportToGoogleSheetsMenuOption(popupMenu);
        });
  }

  private void addExportToCsvMenuOption(JPopupMenu popupMenu) {
    if (!Objects.equals(pluginPanel.getDisplayName(), "")) {
      final JMenuItem exportItems = new JMenuItem(EXPORT_ITEMS_TO_CSV_TEXT);
      exportItems.addActionListener(e -> storageManagerManager.exportItems(DataDestination.CSV));
      popupMenu.add(exportItems);
    }
  }

  private void addExportToGoogleSheetsMenuOption(JPopupMenu popupMenu) {
    if (!Objects.equals(pluginPanel.getDisplayName(), "")) {
      final JMenuItem exportItems = new JMenuItem(EXPORT_ITEMS_TO_GOOGLE_SHEETS_TEXT);
      exportItems.addActionListener(
          e -> storageManagerManager.exportItems(DataDestination.GOOGLE_SHEETS));
      popupMenu.add(exportItems);
    }
  }

  private void addDeleteAllDataMenuOption(JPopupMenu popupMenu) {
    if (plugin.getProfilesWithData().findAny().isPresent()) {
      popupMenu.add(new Separator());

      final JMenuItem deleteAllData = new JMenuItem("Delete all data");
      deleteAllData.addActionListener(
          e -> {
            if (DudeWheresMyStuffPlugin.getConfirmation(this, DELETE_ALL_SAVE_WARNING,
                CONFIRM_DELETION_TEXT) && DudeWheresMyStuffPlugin.getConfirmation(this,
                DELETE_ALL_SAVE_FINAL_WARNING, CONFIRM_DELETION_TEXT)) {
              plugin.deleteAllData();

              resetSummaryContextMenu();
            }
          });
      popupMenu.add(deleteAllData);
    }
  }

  private void addExitPreviewModeMenuOption(JPopupMenu popupMenu) {
    final JMenuItem exitPreviewMode = new JMenuItem("Exit preview mode");
    exitPreviewMode.addActionListener(e -> plugin.disablePreviewMode(false));
    popupMenu.add(exitPreviewMode);
  }

  private void addDeleteDeathbankMenuOption(JPopupMenu popupMenu) {
    final JMenuItem clearDeathbank = new JMenuItem("Delete data");
    clearDeathbank.addActionListener(
        e -> {
          if (DudeWheresMyStuffPlugin.getConfirmation(this, DELETE_SAVE_WARNING, CONFIRM_DELETION_TEXT)) {
            plugin.disablePreviewMode(true);
            resetSummaryContextMenu();
          }
        });
    popupMenu.add(clearDeathbank);
  }

  private void addPreviewModeMenuOption(JPopupMenu popupMenu) {
    JMenu previewMenu = new JMenu("Preview data");

    plugin.getProfilesWithData()
        .filter(runeScapeProfile -> !plugin.getDisplayName(runeScapeProfile)
            .equals(pluginPanel.getDisplayName()))
        .forEach(
            profile -> {
              String displayName = plugin.getDisplayName(profile);
              final JMenuItem previewItem = new JMenuItem(displayName);
              previewItem.addActionListener(
                  e -> {
                    if (Objects.equals(pluginPanel.getDisplayName(), displayName)) {
                      return;
                    }

                    plugin.enablePreviewMode(profile.getKey(), displayName);
                  });
              previewMenu.add(previewItem);
            });

    if (previewMenu.getSubElements().length != 0) {
      popupMenu.add(previewMenu);
    }
  }
}

package dev.thource.runelite.dudewheresmystuff;

import java.awt.Color;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import javax.swing.BoxLayout;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

/** StorageTabPanel is a base class that shows the player their data. */
public abstract class StorageTabPanel<
    T extends StorageType, S extends Storage<T>, M extends StorageManager<T, S>>
    extends TabContentPanel {

  protected final transient DudeWheresMyStuffPlugin plugin;
  @Getter protected final transient M storageManager;
  protected final JPanel storagePanelContainer;
  @Getter protected final JComboBox<ItemSortMode> sortItemsDropdown;
  protected final transient List<StoragePanel> storagePanels = new ArrayList<>();

  protected StorageTabPanel(DudeWheresMyStuffPlugin plugin, M storageManager) {
    this.plugin = plugin;
    this.storageManager = storageManager;
    storageManager.setStorageTabPanel(this);

    setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
    setBackground(ColorScheme.DARK_GRAY_COLOR);

    JPanel sortItemsContainer = new JPanel();
    sortItemsContainer.setLayout(new BoxLayout(sortItemsContainer, BoxLayout.X_AXIS));
    add(sortItemsContainer);

    JLabel sortItemsLabel = new JLabel();
    sortItemsLabel.setFont(FontManager.getRunescapeFont());
    sortItemsLabel.setForeground(Color.WHITE);
    sortItemsLabel.setText("Sort items by");
    sortItemsLabel.setBorder(new EmptyBorder(0, 0, 0, 8));
    sortItemsContainer.add(sortItemsLabel);

    sortItemsDropdown = new JComboBox<>();
    sortItemsDropdown.setFont(FontManager.getRunescapeFont());
    sortItemsDropdown.setForeground(Color.WHITE);
    sortItemsDropdown.addItem(ItemSortMode.VALUE);
    sortItemsDropdown.addItem(ItemSortMode.UNSORTED);
    sortItemsDropdown.setSelectedItem(plugin.getConfig().itemSortMode());
    sortItemsDropdown.addItemListener(
        i -> plugin.getConfig().setItemSortMode((ItemSortMode) i.getItem()));
    sortItemsDropdown.setPreferredSize(new Dimension(-1, 30));
    sortItemsContainer.add(sortItemsDropdown);

    storagePanelContainer = new JPanel();
    storagePanelContainer.setLayout(new BoxLayout(storagePanelContainer, BoxLayout.Y_AXIS));
    add(storagePanelContainer);
  }

  protected Comparator<S> getStorageSorter() {
    return Comparator.comparingLong(S::getTotalValue)
        .reversed()
        .thenComparingInt(s -> -s.getItems().size())
        .thenComparing(s -> s.getType().getName());
  }

  /** Sorts all the storage panels to be in the order specified by getStorageSorter. */
  public void reorderStoragePanels() {
    EnhancedSwingUtilities.fastRemoveAll(storagePanelContainer, plugin.getChatMessageManager());
    storagePanels.clear();

    storageManager.getStorages().stream()
        .filter(storage -> storage.getStoragePanel() != null)
        .filter(
            storage ->
                plugin.getConfig().showEmptyStorages()
                    || !storage.getStoragePanel().getItemBoxes().isEmpty())
        .sorted(getStorageSorter())
        .forEach(
            storage -> {
              storagePanelContainer.add(storage.getStoragePanel());
              storagePanels.add(storage.getStoragePanel());
            });

    storagePanelContainer.revalidate();
  }

  @Override
  public void softUpdate() {
    storagePanels.forEach(panel -> panel.getStorage().softUpdate());
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.math.NumberUtils;

/**
 * PlankSack is responsible for tracking how many planks the player has stored in their plank sack.
 */
@Getter
public class PlankSack extends CarryableStorage {

  // Thanks for using \u00A0, Jagex...
  private static final Pattern chatPattern =
      Pattern.compile(
          "Basic\\u00A0planks:\\u00A0(\\d+), Oak\\u00A0planks:\\u00A0(\\d+), "
              + "Teak\\u00A0planks:\\u00A0(\\d+), Mahogany\\u00A0planks:\\u00A0(\\d+)");
  private static final Pattern usePattern = Pattern.compile(".*[Pp]lank -> Plank sack");

  private final ItemStack plankStack;
  private final ItemStack oakPlankStack;
  private final ItemStack teakPlankStack;
  private final ItemStack mahoganyPlankStack;

  PlankSack(DudeWheresMyStuffPlugin plugin) {
    super(CarryableStorageType.PLANK_SACK, plugin);

    hasStaticItems = true;

    plankStack = new ItemStack(ItemID.WOODPLANK, plugin);
    oakPlankStack = new ItemStack(ItemID.PLANK_OAK, plugin);
    teakPlankStack = new ItemStack(ItemID.PLANK_TEAK, plugin);
    mahoganyPlankStack = new ItemStack(ItemID.PLANK_MAHOGANY, plugin);

    items.add(plankStack);
    items.add(oakPlankStack);
    items.add(teakPlankStack);
    items.add(mahoganyPlankStack);
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (chatMessage.getType() != ChatMessageType.SPAM
        && chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
      return false;
    }

    if (chatMessage.getMessage().equals("Your sack is empty.")) {
      plankStack.setQuantity(0);
      oakPlankStack.setQuantity(0);
      teakPlankStack.setQuantity(0);
      mahoganyPlankStack.setQuantity(0);
      updateLastUpdated();
      return true;
    }

    Matcher matcher = chatPattern.matcher(Text.removeTags(chatMessage.getMessage()));
    if (!matcher.matches()) {
      return false;
    }

    plankStack.setQuantity(NumberUtils.toInt(matcher.group(1)));
    oakPlankStack.setQuantity(NumberUtils.toInt(matcher.group(2)));
    teakPlankStack.setQuantity(NumberUtils.toInt(matcher.group(3)));
    mahoganyPlankStack.setQuantity(NumberUtils.toInt(matcher.group(4)));
    updateLastUpdated();
    return true;
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.gameval.ItemID;

/**
 * ForestryKit is responsible for tracking what the player has stored in their Forestry Kit.
 */
@Slf4j
public class ForestryKit extends CarryableStorage {

  ForestryKit(DudeWheresMyStuffPlugin plugin) {
    super(CarryableStorageType.FORESTRY_KIT, plugin);

    hasStaticItems = true;

    // Basic Forestry Kit storage
    items.add(new ItemStack(ItemID.FORESTRY_CURRENCY, plugin));
    items.add(new ItemStack(ItemID.NATURE_OFFERINGS, plugin));
    items.add(new ItemStack(ItemID.FORESTRY_RATION, plugin));
    items.add(new ItemStack(ItemID.FORESTRY_SECATEURS_ATTACHMENT, plugin));
    items.add(new ItemStack(ItemID.LEAVES, plugin));
    items.add(new ItemStack(ItemID.LEAVES_OAK, plugin));
    items.add(new ItemStack(ItemID.LEAVES_WILLOW, plugin));
    items.add(new ItemStack(ItemID.LEAVES_MAPLE, plugin));
    items.add(new ItemStack(ItemID.LEAVES_YEW, plugin));
    items.add(new ItemStack(ItemID.LEAVES_MAGIC, plugin));
    items.add(new ItemStack(ItemID.FORESTRY_LUMBERJACK_TOP, plugin));
    items.add(new ItemStack(ItemID.FORESTRY_LUMBERJACK_LEGS, plugin));
    items.add(new ItemStack(ItemID.FORESTRY_LUMBERJACK_HAT, plugin));
    items.add(new ItemStack(ItemID.FORESTRY_LUMBERJACK_BOOTS, plugin));
    items.add(new ItemStack(ItemID.SKILLCAPE_WOODCUTTING_TRIMMED, plugin));

    // TODO: Forestry Basket Log Storage
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;

@RequiredArgsConstructor
@Getter
class SuspendedItem {
  private final int inventorySlot;
  private final int id;
  private final int quantity;
  @Setter private int ticksLeft = 3;
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.gameval.ItemID;

/**
 * HuntsmansKit is responsible for tracking what the player has stored in their Huntsman's Kit.
 */
@Slf4j
public class HuntsmansKit extends CarryableStorage {

  HuntsmansKit(DudeWheresMyStuffPlugin plugin) {
    super(CarryableStorageType.HUNTSMANS_KIT, plugin);

    hasStaticItems = true;

    // General Hunter items
    items.add(new ItemStack(ItemID.HUNTING_OJIBWAY_BIRD_SNARE, 0, plugin));
    items.add(new ItemStack(ItemID.NOOSE_WAND, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_BUTTERFLY_NET, 0, plugin));
    items.add(new ItemStack(ItemID.II_MAGIC_BUTTERFLY_NET, 0, plugin));
    items.add(new ItemStack(ItemID.BUTTERFLY_JAR, 0, plugin));
    items.add(new ItemStack(ItemID.II_IMPLING_JAR, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_BOX_TRAP, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_SNARE, 0, plugin));
    items.add(new ItemStack(ItemID.TORCH_UNLIT, 0, plugin));
    items.add(new ItemStack(ItemID.NET, 0, plugin));
    items.add(new ItemStack(ItemID.ROPE, 0, plugin));
    items.add(new ItemStack(ItemID.MAGIC_IMP_BOX, 0, plugin));
    items.add(new ItemStack(ItemID.MAGIC_IMP_BOX_FULL, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_TEASING_STICK, 0, plugin));
    items.add(new ItemStack(ItemID.HG_HUNTER_SPEAR, 0, plugin));
    items.add(new ItemStack(ItemID.RING_OF_PURSUIT, 0, plugin));

    // Crafting Gear
    items.add(new ItemStack(ItemID.HUNTING_CAMOFLAUGE_ROBE_WOOD, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_TROUSERS_WOOD, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_CAMOFLAUGE_ROBE_POLAR, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_TROUSERS_POLAR, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_CAMOFLAUGE_ROBE_JUNGLE, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_TROUSERS_JUNGLE, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_CAMOFLAUGE_ROBE_DESERT, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_TROUSERS_DESERT, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_HAT_JAGUAR, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_TORSO_JAGUAR, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_TROUSERS_JAGUAR, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_HAT_LEOPARD, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_TORSO_LEOPARD, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_TROUSERS_LEOPARD, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_HAT_TIGER, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_TORSO_TIGER, 0, plugin));
    items.add(new ItemStack(ItemID.HUNTING_TROUSERS_TIGER, 0, plugin));

    // Guild Hunter Gear
    items.add(new ItemStack(ItemID.HG_HUNTER_HOOD, 0, plugin));
    items.add(new ItemStack(ItemID.HG_HUNTER_LEGS, 0, plugin));
    items.add(new ItemStack(ItemID.HG_HUNTER_TOP, 0, plugin));
    items.add(new ItemStack(ItemID.HG_HUNTER_BOOTS, 0, plugin));

    // Hunter Cape/Hood
    items.add(new ItemStack(ItemID.SKILLCAPE_HUNTING, 0, plugin));
    items.add(new ItemStack(ItemID.SKILLCAPE_HUNTING_HOOD, 0, plugin));
    items.add(new ItemStack(ItemID.SKILLCAPE_HUNTING_TRIMMED, 0, plugin));
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.ItemStorage;
import lombok.Getter;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.events.ItemContainerChanged;

/**
 * CarryableStorage is responsible for tracking storages that the player can carry (looting bag,
 * rune pouch, etc).
 */
@Getter
public class CarryableStorage extends ItemStorage<CarryableStorageType> {

  protected CarryableStorage(CarryableStorageType type, DudeWheresMyStuffPlugin plugin) {
    super(type, plugin);
  }

  @Override
  public boolean onGameTick() {
    boolean updated = super.onGameTick();

    if (type == CarryableStorageType.EQUIPMENT && updated) {
      ItemStack empty = new ItemStack(-1, "empty", 1, 0, 0, false);

      if (items.size() < 14) {
        for (int i = items.size(); i < 14; i++) {
          items.add(empty);
        }
      }

      // move ammo into the correct place if the slot exists
      ItemStack ammo = items.remove(EquipmentInventorySlot.AMMO.getSlotIdx());
      items.add(3, ammo);

      items.remove(12); // remove empty space between boots and ring

      // pad it out to fit the 4 wide grid
      items.add(0, empty);
      items.add(2, empty);
      items.add(3, empty);
      items.add(7, empty);
      items.add(11, empty);
      items.add(15, empty);

      items.forEach(
          itemStack -> itemStack.setId(plugin.getItemManager().canonicalize(itemStack.getId())));
    }

    return updated;
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.StorageType;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

/** CarryableStorageType is used to identify CarryableStorages. */
@RequiredArgsConstructor
@Getter
public enum CarryableStorageType implements StorageType {
  INVENTORY("Inventory", InventoryID.INV, true, "inventory", false, new ArrayList<>(), -1),
  EQUIPMENT("Equipment", InventoryID.WORN, true, "equipment", false, new ArrayList<>(), -1),
  LOOTING_BAG(
      "Looting Bag",
      InventoryID.LOOTING_BAG,
      false,
      "lootingbag",
      true,
      Arrays.asList(ItemID.LOOTING_BAG, ItemID.LOOTING_BAG_OPEN),
      -1),
  SEED_BOX(
      "Seed Box",
      InventoryID.SEED_BOX,
      false,
      "seedbox",
      true,
      Arrays.asList(ItemID.SEED_BOX, ItemID.SEED_BOX_OPEN),
      VarbitID.EMPTYONDEATH_SEEDBOX),
  RUNE_POUCH(
      "Rune Pouch",
      -1,
      true,
      "runepouch",
      true,
      Arrays.asList(
          ItemID.BH_RUNE_POUCH,
          ItemID.BH_RUNE_POUCH_TROUVER,
          ItemID.DIVINE_RUNE_POUCH,
          ItemID.DIVINE_RUNE_POUCH_TROUVER),
      VarbitID.EMPTYONDEATH_RUNEPOUCH),
  BOTTOMLESS_BUCKET(
      "Bottomless Compost Bucket", -1, false, "bottomlessbucket", true, new ArrayList<>(), -1),
  PLANK_SACK("Plank Sack", -1, false, "planksack", true, new ArrayList<>(), -1),
  BOLT_POUCH(
      "Bolt Pouch",
      -1,
      true,
      "boltpouch",
      true,
      Collections.singletonList(ItemID.XBOWS_BOLT_POUCH),
      VarbitID.EMPTYONDEATH_BOLTPOUCH),
  GNOMISH_FIRELIGHTER(
      "Gnomish Firelighter",
      -1,
      false,
      "gnomishfirelighter",
      true,
      Collections.singletonList(ItemID.GNOMISH_FIRELIGHTER_CHARGED),
      -1),
  MASTER_SCROLL_BOOK(
      "Master Scroll Book", -1, true, "masterscrollbook", true, new ArrayList<>(), -1),
  HUNTSMANS_KIT(
      "Huntsman's Kit",
      InventoryID.HUNTSMANS_KIT,
      false,
      "huntsmanskit",
      true,
      Collections.singletonList(ItemID.HUNTSMANS_KIT),
      -1),
  FORESTRY_KIT(
      "Forestry Kit",
      InventoryID.FORESTRY_KIT,
      false,
      "forestrykit",
      true,
      Arrays.asList(
          ItemID.FORESTRY_KIT, ItemID.FORESTRY_BASKET_CLOSED, ItemID.FORESTRY_BASKET_OPEN),
      -1),
  TACKLE_BOX(
      "Tackle Box",
      InventoryID.TACKLE_BOX,
      false,
      "tackleBox",
      true,
      Collections.singletonList(ItemID.TACKLE_BOX),
      VarbitID.EMPTYONDEATH_TACKLEBOX),
  HERB_SACK(
      "Herb Sack",
      -1,
      false,
      "herbSack",
      true,
      List.of(ItemID.SLAYER_HERB_SACK, ItemID.SLAYER_HERB_SACK_OPEN),
      VarbitID.EMPTYONDEATH_HERBSACK),
  CHUGGING_BARREL(
      "Chugging Barrel",
      InventoryID.PREPOT_DEVICE_INV,
      false,
      "chuggingBarrel",
      true,
      Collections.singletonList(ItemID.MM_PREPOT_DEVICE),
      -1),
  DIZANAS_QUIVER(
      "Dizana's Quiver",
      -1,
      true,
      "dizanasQuiver",
      true,
      List.of(
          ItemID.DIZANAS_QUIVER_UNCHARGED,
          ItemID.DIZANAS_QUIVER_CHARGED,
          ItemID.DIZANAS_QUIVER_UNCHARGED_TROUVER,
          ItemID.DIZANAS_QUIVER_CHARGED_TROUVER),
      -1);

  private final String name;
  private final int itemContainerId;
  // Whether the storage can be updated with no action required by the player
  private final boolean automatic;
  private final String configKey;
  private final boolean membersOnly;
  private final List<Integer> accountTypeBlacklist = null;
  // ids of container items (the id of the rune pouch item, for example)
  private final List<Integer> containerIds;
  private final int emptyOnDeathVarbit;
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.ItemStackUtils;
import dev.thource.runelite.dudewheresmystuff.Seed;
import java.util.Arrays;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/** SeedBox is responsible for tracking how many seeds the player has stored in their seed box. */
@Getter
public class SeedBox extends CarryableStorage {

  private static final Pattern[] additionPatterns = {
      Pattern.compile("Stored (?<count>\\d+) x (?<seed>.+) in your seed box\\."),
      Pattern.compile("You put (?<count>\\d+) x (?<seed>.+) straight into your open seed box\\."),
      Pattern.compile(
          "The following stolen loot gets added to your seed box: (?<seed>.+) x (?<count>\\d+)\\."),
      Pattern.compile("You put the stolen (?<seed>.+) into your seed box\\."),
  };
  private static final Pattern[] removalPatterns = {
      Pattern.compile("Emptied (?<count>\\d+) x (?<seed>.+) to your inventory\\."),
  };

  SeedBox(DudeWheresMyStuffPlugin plugin) {
    super(CarryableStorageType.SEED_BOX, plugin);
  }

  @Override
  public boolean onGameTick() {
    boolean didUpdate = super.onGameTick();

    Widget seedBoxWidget = plugin.getClient().getWidget(128, 11);
    if (seedBoxWidget == null) {
      return didUpdate;
    }

    Widget[] seedBoxItems = seedBoxWidget.getChildren();
    if (seedBoxItems == null
        || Arrays.stream(seedBoxWidget.getChildren()).anyMatch(w -> w.getItemId() != -1)) {
      return didUpdate;
    }

    items.clear();
    updateLastUpdated();
    return true;
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (chatMessage.getType() != ChatMessageType.SPAM
        && chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
      return false;
    }

    return checkForAdditions(chatMessage.getMessage())
        || checkForRemovals(chatMessage.getMessage());
  }

  private boolean checkForAdditions(String chatMessage) {
    for (Pattern pattern : additionPatterns) {
      Matcher matcher = pattern.matcher(chatMessage);
      if (!matcher.matches()) {
        continue;
      }

      int quantity = 1;
      try {
        quantity = NumberUtils.toInt(matcher.group("count"));
      } catch (IllegalArgumentException e) {
        // Do nothing, count is an optional group
      }

      Optional<Seed> optionalSeed = Seed.findByName(matcher.group("seed"));
      if (!optionalSeed.isPresent()) {
        return false;
      }

      ItemStackUtils.addItemStack(
          items, new ItemStack(optionalSeed.get().getItemId(), quantity, plugin));
      updateLastUpdated();
      return true;
    }

    return false;
  }

  private boolean checkForRemovals(String chatMessage) {
    for (Pattern pattern : removalPatterns) {
      Matcher matcher = pattern.matcher(chatMessage);
      if (!matcher.matches()) {
        continue;
      }

      int quantity = NumberUtils.toInt(matcher.group("count"), 1);
      Optional<Seed> optionalSeed = Seed.findByName(matcher.group("seed"));
      if (!optionalSeed.isPresent()) {
        return false;
      }

      ItemStackUtils.removeItemStack(
          items, new ItemStack(optionalSeed.get().getItemId(), quantity, plugin));
      updateLastUpdated();
      return true;
    }

    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemContainerWatcher;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.ItemStackUtils;
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
import java.util.Objects;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.gameval.InterfaceID.Inventory;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.Widget;

/** TackleBox is responsible for tracking the player's items in their tackle box. */
@Getter
public class TackleBox extends CarryableStorage {

  private final List<SuspendedItem> itemsUsed = new ArrayList<>();

  public TackleBox(DudeWheresMyStuffPlugin plugin) {
    super(CarryableStorageType.TACKLE_BOX, plugin);
  }

  @Override
  public boolean onGameTick() {
    boolean didUpdate = super.onGameTick();

    if (checkUsedItems()) {
      didUpdate = true;
    }

    return didUpdate;
  }

  private boolean checkUsedItems() {
    boolean updated = false;

    for (ItemStack itemStack :
        ItemContainerWatcher.getInventoryWatcher().getItemsRemovedLastTick()) {
      if (itemsUsed.stream().anyMatch(i -> i.getId() == itemStack.getId())) {
        ItemStackUtils.addItemStack(items, itemStack);
        updated = true;
      }
    }

    ListIterator<SuspendedItem> listIterator = itemsUsed.listIterator();
    while (listIterator.hasNext()) {
      SuspendedItem item = listIterator.next();

      if (item.getTicksLeft() <= 1) {
        listIterator.remove();
      } else {
        item.setTicksLeft(item.getTicksLeft() - 1);
      }
    }

    if (updated) {
      updateLastUpdated();
    }

    return updated;
  }

  @Override
  public boolean onMenuOptionClicked(MenuOptionClicked menuOption) {
    Widget item1Widget = plugin.getClient().getSelectedWidget();

    if (menuOption.getWidget() == null || menuOption.getWidget().getParentId() != Inventory.ITEMS) {
      return false;
    }

    Widget item2Widget = menuOption.getWidget();
    if (item1Widget == null) {
      if (!menuOption.getMenuOption().equals("Use")
          && !menuOption.getMenuOption().equals("Examine")) {
        itemsUsed.removeIf(item -> item.getInventorySlot() == item2Widget.getIndex());
      }

      return false;
    }

    // one of the widgets is not an item
    if (item1Widget.getItemId() == -1 || item2Widget.getItemId() == -1) {
      return false;
    }

    boolean item1IsTackleBox = type.getContainerIds().contains(item1Widget.getItemId());
    // Item wasn't used on a tackle box
    if (!item1IsTackleBox && !type.getContainerIds().contains(item2Widget.getItemId())) {
      return false;
    }

    Widget itemWidget = (item1IsTackleBox ? item2Widget : item1Widget);
    itemsUsed.add(
        new SuspendedItem(
            itemWidget.getIndex(),
            itemWidget.getItemId(),
            Objects.requireNonNull(plugin.getClient().getItemContainer(InventoryID.INV))
                .count(itemWidget.getItemId())));

    return false;
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (chatMessage.getType() != ChatMessageType.SPAM
        && chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
      return false;
    }

    if (chatMessage.getMessage().startsWith("The tackle box is now empty")) {
      resetItems();
      updateLastUpdated();
    }

    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemContainerWatcher;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.regex.Pattern;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;

/** HerbSack is responsible for tracking the player's items in their herb sack. */
public class HerbSack extends CarryableStorage {

  private static final Pattern CHECK_PATTERN = Pattern.compile("(\\d+) x (.*)");
  private static final Pattern PICK_UP_PATTERN =
      Pattern.compile("You put the (.*) herb into your herb sack");
  private static final Pattern USE_PATTERN = Pattern.compile("You add the (.*) to your sack");

  private boolean checkingSack;
  private boolean addingToSack;
  private boolean removingToInv;
  private boolean removingToBank;

  public HerbSack(DudeWheresMyStuffPlugin plugin) {
    super(CarryableStorageType.HERB_SACK, plugin);

    hasStaticItems = true;

    items.add(new ItemStack(ItemID.UNIDENTIFIED_GUAM, 0, plugin));
    items.add(new ItemStack(ItemID.UNIDENTIFIED_MARENTILL, 0, plugin));
    items.add(new ItemStack(ItemID.UNIDENTIFIED_TARROMIN, 0, plugin));
    items.add(new ItemStack(ItemID.UNIDENTIFIED_HARRALANDER, 0, plugin));
    items.add(new ItemStack(ItemID.UNIDENTIFIED_RANARR, 0, plugin));
    items.add(new ItemStack(ItemID.UNIDENTIFIED_TOADFLAX, 0, plugin));
    items.add(new ItemStack(ItemID.UNIDENTIFIED_IRIT, 0, plugin));
    items.add(new ItemStack(ItemID.UNIDENTIFIED_AVANTOE, 0, plugin));
    items.add(new ItemStack(ItemID.UNIDENTIFIED_KWUARM, 0, plugin));
    items.add(new ItemStack(ItemID.UNIDENTIFIED_HUASCA, 0, plugin));
    items.add(new ItemStack(ItemID.UNIDENTIFIED_SNAPDRAGON, 0, plugin));
    items.add(new ItemStack(ItemID.UNIDENTIFIED_CADANTINE, 0, plugin));
    items.add(new ItemStack(ItemID.UNIDENTIFIED_LANTADYME, 0, plugin));
    items.add(new ItemStack(ItemID.UNIDENTIFIED_DWARF_WEED, 0, plugin));
    items.add(new ItemStack(ItemID.UNIDENTIFIED_TORSTOL, 0, plugin));
  }

  private void addQuantityByName(String name, int quantity) {
    items.stream()
        .filter(itemStack -> itemStack.getName().equals(name))
        .findFirst()
        .ifPresent(
            itemStack ->
                itemStack.setQuantity(
                    Math.min(30, Math.max(0, itemStack.getQuantity() + quantity))));
  }

  private void setQuantityByName(String name, int quantity) {
    items.stream()
        .filter(itemStack -> itemStack.getName().equals(name))
        .findFirst()
        .ifPresent(itemStack -> itemStack.setQuantity(quantity));
  }

  @Override
  public boolean onGameTick() {
    boolean didUpdate = super.onGameTick();

    if (checkingSack) {
      checkingSack = false;
      updateLastUpdated();
      didUpdate = true;
    }

    if (addingToSack) {
      ItemContainerWatcher.getInventoryWatcher()
          .getItemsRemovedLastTick()
          .forEach(itemStack -> addQuantityByName(itemStack.getName(), 1));

      addingToSack = false;
      updateLastUpdated();
      didUpdate = true;
    }

    if (removingToInv) {
      ItemContainerWatcher.getInventoryWatcher()
          .getItemsAddedLastTick()
          .forEach(itemStack -> addQuantityByName(itemStack.getName(), -1));

      removingToInv = false;
      updateLastUpdated();
      didUpdate = true;
    }

    if (removingToBank) {
      ItemContainerWatcher.getBankWatcher()
          .getItemsAddedLastTick()
          .forEach(
              itemStack -> addQuantityByName(itemStack.getName(), (int) -itemStack.getQuantity()));

      removingToBank = false;
      updateLastUpdated();
      didUpdate = true;
    }

    return didUpdate;
  }

  @Override
  public boolean onMenuOptionClicked(MenuOptionClicked menuOption) {
    if (menuOption.getWidget() == null
        || !type.getContainerIds().contains(menuOption.getWidget().getItemId())
        || !menuOption.getMenuOption().equals("Empty")) {
      return false;
    }

    if (menuOption.getWidget().getParentId() == InterfaceID.Bankside.ITEMS) {
      removingToBank = true;
      return false;
    }

    if (menuOption.getWidget().getParentId() == InterfaceID.BankDepositbox.INVENTORY) {
      plugin.getWorldStorageManager().getBank().addItems(items);

      resetItems();
      updateLastUpdated();
      return true;
    }

    return false;
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (chatMessage.getType() != ChatMessageType.SPAM
        && chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
      return false;
    }

    if (chatMessage.getMessage().startsWith("The herb sack is empty")) {
      resetItems();
      updateLastUpdated();
      return true;
    }

    if (checkingSack) {
      var matcher = CHECK_PATTERN.matcher(chatMessage.getMessage());
      if (matcher.find()) {
        var quantity = Integer.parseInt(matcher.group(1));
        var name = matcher.group(2);

        setQuantityByName(name, quantity);

        return true;
      }

      return false;
    }

    var pickUpMatcher = PICK_UP_PATTERN.matcher(chatMessage.getMessage());
    if (pickUpMatcher.find()) {
      var name = pickUpMatcher.group(1);
      addQuantityByName(name, 1);

      updateLastUpdated();
      return true;
    }

    if (USE_PATTERN.matcher(chatMessage.getMessage()).find()
        || chatMessage.getMessage().startsWith("You add the herbs to your sack")) {
      addingToSack = true;
    } else if (chatMessage.getMessage().startsWith("You look in your herb sack")) {
      checkingSack = true;
    } else if (chatMessage
        .getMessage()
        .startsWith("You rummage around to see if you can extract any herbs from your herb sack")) {
      removingToInv = true;
    }

    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Var;
import lombok.Getter;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.ConfigManager;

/**
 * RunePouch is responsible for tracking how many runes the player has stored in their rune pouch.
 */
@Getter
public class RunePouch extends CarryableStorage {

  private static final int[] RUNE_TYPE_VARBITS = {
    VarbitID.RUNE_POUCH_TYPE_1,
    VarbitID.RUNE_POUCH_TYPE_2,
    VarbitID.RUNE_POUCH_TYPE_3,
    VarbitID.RUNE_POUCH_TYPE_4,
  };
  private static final int[] RUNE_QUANTITY_VARBITS = {
    VarbitID.RUNE_POUCH_QUANTITY_1,
    VarbitID.RUNE_POUCH_QUANTITY_2,
    VarbitID.RUNE_POUCH_QUANTITY_3,
    VarbitID.RUNE_POUCH_QUANTITY_4,
  };
  private static final int MAX_RUNE_TYPES = RUNE_TYPE_VARBITS.length;

  RunePouch(DudeWheresMyStuffPlugin plugin) {
    super(CarryableStorageType.RUNE_POUCH, plugin);

    resetItems();
  }

  @Override
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    var updated = false;
    var client = plugin.getClient();

    for (int i = 0; i < MAX_RUNE_TYPES; i++) {
      var quantityBit = Var.bit(varbitChanged, RUNE_QUANTITY_VARBITS[i]);
      var typeBit = Var.bit(varbitChanged, RUNE_TYPE_VARBITS[i]);
      if (!quantityBit.wasChanged() && !typeBit.wasChanged()) {
        continue;
      }

      var runeStack = items.get(i);
      if (quantityBit.wasChanged()) {
        var newQuantity = quantityBit.getValue(client);
        if (newQuantity != runeStack.getQuantity()) {
          runeStack.setQuantity(newQuantity);
          updated = true;
        }
      }

      if (typeBit.wasChanged()) {
        EnumComposition runepouchEnum = plugin.getClient().getEnum(EnumID.RUNEPOUCH_RUNE);

        int runeId = runepouchEnum.getIntValue(typeBit.getValue(client));
        if (runeId != runeStack.getId()) {
          runeStack.setId(runeId, plugin);
          updated = true;
        }
      }
    }

    return updated;
  }

  @Override
  public void load(ConfigManager configManager, String managerConfigKey, String profileKey) {
    super.load(configManager, managerConfigKey, profileKey);

    while (items.size() < 4) {
      items.add(new ItemStack(-1, 0, plugin));
    }
  }

  @Override
  protected void resetItems() {
    for (int i = 0; i < MAX_RUNE_TYPES; i++) {
      items.add(new ItemStack(-1, 0, plugin));
    }
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/**
 * GnomishFirelighter is responsible for tracking how many charges of which type of firelighter the
 * player has stored in their gnomish firelighter.
 */
@Slf4j
public class GnomishFirelighter extends CarryableStorage {

  private static final Pattern chargesPattern = Pattern.compile(
      "(\\d+) (\\w+) firelighter charges");

  GnomishFirelighter(DudeWheresMyStuffPlugin plugin) {
    super(CarryableStorageType.GNOMISH_FIRELIGHTER, plugin);

    hasStaticItems = true;

    items.add(new ItemStack(ItemID.GNOMISH_FIRELIGHTER_RED, 0, plugin));
    items.add(new ItemStack(ItemID.GNOMISH_FIRELIGHTER_GREEN, 0, plugin));
    items.add(new ItemStack(ItemID.GNOMISH_FIRELIGHTER_BLUE, 0, plugin));
    items.add(new ItemStack(ItemID.TRAIL_GNOMISH_FIRELIGHTER_PURPLE, 0, plugin));
    items.add(new ItemStack(ItemID.TRAIL_GNOMISH_FIRELIGHTER_WHITE, 0, plugin));
  }

  @Override
  public boolean onGameTick() {
    Widget widget = plugin.getClient().getWidget(193, 2);
    if (widget == null) {
      return false;
    }

    String widgetText = widget.getText().replace("<br>", " ");
    if (!widgetText.contains("gnomish firelighter")) {
      return false;
    }

    if (widgetText.contains("is empty")) {
      items.forEach(itemStack -> itemStack.setQuantity(0));
      updateLastUpdated();
      return true;
    }

    Matcher matcher = chargesPattern.matcher(widgetText);
    int charges = 0;
    Optional<ItemStack> itemStack = Optional.empty();
    if (matcher.find()) {
      charges = NumberUtils.toInt(matcher.group(1));
      itemStack = items.stream().filter(i -> i.getName().contains(matcher.group(2))).findFirst();
    }

    if (!itemStack.isPresent()) {
      return false;
    }

    itemStack.get().setQuantity(charges);
    updateLastUpdated();

    return true;
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (chatMessage.getType() != ChatMessageType.SPAM
        && chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
      return false;
    }

    if (!chatMessage.getMessage().startsWith("You uncharge the gnomish firelighter")) {
      return false;
    }

    items.forEach(itemStack -> itemStack.setQuantity(0));
    updateLastUpdated();
    return true;
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.regex.Pattern;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/** ChuggingBarrel is responsible for tracking the player's potions in their chugging barrel. */
public class ChuggingBarrel extends CarryableStorage {

  private static final Pattern DRINK_PATTERN =
      Pattern.compile("You drink (?:some of )?(?:the|your)? (.*)\\.");
  private static final Pattern DOSES_LEFT_PATTERN =
      Pattern.compile("You have (\\d+) doses? of (.*) left in your barrel\\.");
  private static final Pattern EMPTY_PATTERN =
      Pattern.compile("You have finished all doses of (.*) in your barrel\\.");
  private static final Pattern DEPOSIT_PATTERN =
      Pattern.compile("Your chugging barrel has been filled with (\\d+) doses? of (.*)\\.");

  private final HashMap<String, ItemStack> depositMap = new HashMap<>();
  private final HashMap<String, ArrayList<ItemStack>> drinkMap = new HashMap<>();

  private boolean drinking;

  ChuggingBarrel(DudeWheresMyStuffPlugin plugin) {
    super(CarryableStorageType.CHUGGING_BARREL, plugin);

    hasStaticItems = true;

    // regular potions
    addPotion("Agility potion(1)", "agility potion", ItemID._1DOSE1AGILITY);
    addPotion("Ancient brew(1)", "foul liquid", ItemID._1DOSEANCIENTBREW);
    addPotion("Anti-venom(1)", "antivenom potion", ItemID.ANTIVENOM1);
    addPotion("Anti-venom+(1)", "super antivenom+ potion", ItemID.ANTIVENOM_1);
    addPotion("Antidote+(1)", "antipoison potion", ItemID.ANTIDOTE_1);
    addPotion("Antidote++(1)", "antipoison potion", ItemID.ANTIDOTE__1);
    addPotion("Antifire potion(1)", "antifire potion", ItemID._1DOSE1ANTIDRAGON);
    addPotion("Antipoison(1)", "antipoison potion", ItemID._1DOSEANTIPOISON);
    addPotion("Attack potion(1)", "attack potion", ItemID._1DOSE1ATTACK);
    addPotion("Battlemage potion(1)", "battlemage potion", ItemID._1DOSEBATTLEMAGE);
    addPotion("Bastion potion(1)", "bastion potion", ItemID._1DOSEBASTION);
    addPotion(
        "Blighted super restore(1)",
        "blighted super restore potion",
        ItemID.BLIGHTED_1DOSE2RESTORE);
    addPotion("Combat potion(1)", "combat potion", ItemID._1DOSECOMBAT);
    addPotion("Defence potion(1)", "defence potion", ItemID._1DOSE1DEFENSE);
    addPotion("Divine bastion potion(1)", "divine bastion potion", ItemID._1DOSEDIVINEBASTION);
    addPotion(
        "Divine battlemage potion(1)", "divine battlemage potion", ItemID._1DOSEDIVINEBATTLEMAGE);
    addPotion("Divine magic potion(1)", "divine magic potion", ItemID._1DOSEDIVINEMAGIC);
    addPotion("Divine ranging potion(1)", "divine ranging potion", ItemID._1DOSEDIVINERANGE);
    addPotion(
        "Divine super attack potion(1)", "divine super attack potion", ItemID._1DOSEDIVINEATTACK);
    addPotion("Divine super combat potion(1)", "divine combat potion", ItemID._1DOSEDIVINECOMBAT);
    addPotion(
        "Divine super defence potion(1)",
        "divine super defence potion",
        ItemID._1DOSEDIVINEDEFENCE);
    addPotion(
        "Divine super strength potion(1)",
        "divine super strength potion",
        ItemID._1DOSEDIVINESTRENGTH);
    addPotion("Energy potion(1)", "energy potion", ItemID._1DOSE1ENERGY);
    addPotion(
        "Extended anti-venom+(1)", "extended super antivenom+ potion", ItemID.EXTENDED_ANTIVENOM_1);
    addPotion("Extended antifire(1)", "extended antifire potion", ItemID._1DOSE2ANTIDRAGON);
    addPotion(
        "Extended super antifire(1)", "extended super antifire potion", ItemID._1DOSE4ANTIDRAGON);
    addPotion("Fishing potion(1)", "fishing potion", ItemID._1DOSEFISHERSPOTION);
    addPotion("Forgotten brew(1)", "foul liquid", ItemID._1DOSEFORGOTTENBREW);
    addPotion("Goading potion(1)", "goading potion", ItemID._1DOSEGOADING);
    addPotion("Hunter potion(1)", "Hunter potion", ItemID._1DOSEHUNTING);
    addPotion("Magic essence(1)", "potion of magic essence", ItemID._1DOSEMAGICESS);
    addPotion("Magic potion(1)", "magic potion", ItemID._1DOSE1MAGIC);
    addPotion("Menaphite remedy(1)", "Menaphite remedy", ItemID._1DOSESTATRENEWAL);
    addPotion("Prayer potion(1)", "restore prayer potion", ItemID._1DOSEPRAYERRESTORE);
    addPotion(
        "Prayer regeneration potion(1)",
        "prayer regeneration potion",
        ItemID._1DOSE1PRAYER_REGENERATION);
    addPotion("Ranging potion(1)", "ranging potion", ItemID._1DOSERANGERSPOTION);
    addPotion("Relicym's balm(1)", "Relicym's Balm", ItemID.RELICYMS_BALM1);
    addPotion("Restore potion(1)", "stat restoration potion", ItemID._1DOSESTATRESTORE);
    addPotion("Sanfew serum(1)", "Sanfew Serum", ItemID.SANFEW_SALVE_1_DOSE);
    addPotion("Saradomin brew(1)", "foul liquid", ItemID._1DOSEPOTIONOFSARADOMIN);
    addPotion("Stamina potion(1)", "stamina potion", ItemID._1DOSESTAMINA);
    addPotion("Strength potion(1)", "strength potion", ItemID._1DOSE1STRENGTH);
    addPotion("Super antifire potion(1)", "super antifire potion", ItemID._1DOSE3ANTIDRAGON);
    addPotion("Super attack(1)", "attack potion", ItemID._1DOSE2ATTACK);
    addPotion("Super combat potion(1)", "super combat potion", ItemID._1DOSE2COMBAT);
    addPotion("Super defence(1)", "defence potion", ItemID._1DOSE2DEFENSE);
    addPotion("Super energy(1)", "super energy potion", ItemID._1DOSE2ENERGY);
    addPotion("Super restore(1)", "super restore potion", ItemID._1DOSE2RESTORE);
    addPotion("Super strength(1)", "strength potion", ItemID._1DOSE2STRENGTH);
    addPotion("Superantipoison(1)", "antipoison potion", ItemID._1DOSE2ANTIPOISON);
    addPotion("Zamorak brew(1)", "foul liquid", ItemID._1DOSEPOTIONOFZAMORAK);

    // brutal potions
    addPotion("Agility mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE1AGILITY);
    addPotion("Ancient mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSEANCIENTBREW);
    addPotion("Antifire mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE1ANTIDRAGON);
    addPotion("Antipoison mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSEANTIPOISON);
    addPotion("Antidote+ mix(1)", "lumpy potion", ItemID.BRUTAL_ANTIDOTE_1);
    addPotion("Attack mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE1ATTACK);
    addPotion("Combat mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSECOMBAT);
    addPotion("Defence mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE1DEFENSE);
    addPotion("Energy mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE1ENERGY);
    addPotion("Extended antifire mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE2ANTIDRAGON);
    addPotion("Extended super antifire mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE4ANTIDRAGON);
    addPotion("Fishing mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSEFISHERSPOTION);
    addPotion("Hunting mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE1HUNTING);
    addPotion("Magic essence mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSEMAGICESS);
    addPotion("Magic mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE1MAGIC);
    addPotion("Prayer mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSEPRAYERRESTORE);
    addPotion("Ranging mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSERANGERSPOTION);
    addPotion("Restore mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSESTATRESTORE);
    addPotion("Stamina mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSESTAMINA);
    addPotion("Strength mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE1STRENGTH);
    addPotion("Super antifire mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE3ANTIDRAGON);
    addPotion("Superattack mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE2ATTACK);
    addPotion("Super def. mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE2DEFENSE);
    addPotion("Super energy mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE2ENERGY);
    addPotion("Super restore mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE2RESTORE);
    addPotion("Super str. mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE2STRENGTH);
    addPotion("Anti-poison supermix(1)", "lumpy potion", ItemID.BRUTAL_1DOSE2ANTIPOISON);
    addPotion("Zamorak mix(1)", "lumpy potion", ItemID.BRUTAL_1DOSEPOTIONOFZAMORAK);
    addPotion("Relicym's mix(1)", "lumpy potion", ItemID.BRUTAL_RELICYMS_BALM1);
  }

  private void addPotion(String depositText, String drinkText, int oneDoseId) {
    var itemStack = new ItemStack(oneDoseId, plugin);
    items.add(itemStack);
    depositMap.put(depositText, itemStack);
    drinkMap.computeIfAbsent(drinkText, (t) -> new ArrayList<>()).add(itemStack);
  }

  @Override
  public boolean onMenuOptionClicked(MenuOptionClicked menuOption) {
    if (menuOption.getWidget() != null
        && type.getContainerIds().contains(menuOption.getWidget().getItemId())
        && menuOption.getMenuOption().equals("Drink")) {
      drinking = true;
    }

    return false;
  }

  @Override
  public boolean onGameTick() {
    boolean didUpdate = super.onGameTick();

    if (drinking) {
      drinking = false;
      updateLastUpdated();
      didUpdate = true;
    }

    Widget textWidget = plugin.getClient().getWidget(InterfaceID.ObjectboxDouble.TEXT);
    if (textWidget != null && textWidget.getText().equals("You disassemble the Chugging barrel.")) {
      resetItems();
      updateLastUpdated();
      didUpdate = true;
    }

    return didUpdate;
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (chatMessage.getType() != ChatMessageType.SPAM
        && chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
      return false;
    }

    if (drinking) {
      var drinkMatcher = DRINK_PATTERN.matcher(chatMessage.getMessage());
      if (drinkMatcher.find()) {
        var drinkText = drinkMatcher.group(1);

        var drankPotions = drinkMap.get(drinkText);
        if (drankPotions != null) {
          drankPotions.stream()
              .filter(is -> is.getQuantity() > 0)
              .forEach(is -> is.setQuantity(is.getQuantity() - 1));
        }
      }
    }

    var depositMatcher = DEPOSIT_PATTERN.matcher(chatMessage.getMessage());
    if (depositMatcher.find()) {
      var doses = NumberUtils.toInt(depositMatcher.group(1));
      var potionName = depositMatcher.group(2);

      var depositedPotion = depositMap.get(potionName);
      if (depositedPotion != null) {
        depositedPotion.setQuantity(depositedPotion.getQuantity() + doses);
        updateLastUpdated();
        return true;
      }
    }

    var dosesLeftMatcher = DOSES_LEFT_PATTERN.matcher(chatMessage.getMessage());
    if (dosesLeftMatcher.find()) {
      var doses = NumberUtils.toInt(dosesLeftMatcher.group(1));
      var potionName = dosesLeftMatcher.group(2);

      var potion = depositMap.get(potionName);
      if (potion != null) {
        potion.setQuantity(doses);
        updateLastUpdated();
        return true;
      }
    }

    var emptyMatcher = EMPTY_PATTERN.matcher(chatMessage.getMessage());
    if (emptyMatcher.find()) {
      var potionName = emptyMatcher.group(1);

      var emptiedPotion = depositMap.get(potionName);
      if (emptiedPotion != null) {
        emptiedPotion.setQuantity(0);
        updateLastUpdated();
        return true;
      }
    }

    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Var;
import lombok.Getter;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarPlayerID;

/**
 * DizanasQuiver is responsible for tracking how many arrows the player has stored in their Dizana's
 * quiver.
 */
@Getter
public class DizanasQuiver extends CarryableStorage {

  private ItemStack ammo;

  DizanasQuiver(DudeWheresMyStuffPlugin plugin) {
    super(CarryableStorageType.DIZANAS_QUIVER, plugin);

    resetItems();
  }

  @Override
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    var client = plugin.getClient();

    var typeVar = Var.player(varbitChanged, VarPlayerID.DIZANAS_QUIVER_TEMP_AMMO);
    if (typeVar.wasChanged()) {
      var newType = typeVar.getValue(client);
      if (newType != ammo.getId()) {
        ammo.setId(newType, plugin);
        return true;
      }

      return false;
    }

    var quantityVar = Var.player(varbitChanged, VarPlayerID.DIZANAS_QUIVER_TEMP_AMMO_AMOUNT);
    if (quantityVar.wasChanged()) {
      var newQuantity = quantityVar.getValue(client);
      if (newQuantity != ammo.getQuantity()) {
        ammo.setQuantity(newQuantity);
        return true;
      }

      return false;
    }

    return false;
  }

  @Override
  protected void resetItems() {
    items.clear();
    ammo = new ItemStack(-1, 0, plugin);
    items.add(ammo);
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

/**
 * MasterScrollBook is responsible for tracking which scrolls the player has stored in their master
 * scroll book.
 */
@Slf4j
public class MasterScrollBook extends CarryableStorage {

  MasterScrollBook(DudeWheresMyStuffPlugin plugin) {
    super(CarryableStorageType.MASTER_SCROLL_BOOK, plugin);

    hasStaticItems = true;

    varbits =
        new int[] {
          VarbitID.BOOKOFSCROLLS_NARDAH,
          VarbitID.BOOKOFSCROLLS_DIGSITE,
          VarbitID.BOOKOFSCROLLS_FELDIP,
          VarbitID.BOOKOFSCROLLS_LUNARISLE,
          VarbitID.BOOKOFSCROLLS_MORTTON,
          VarbitID.BOOKOFSCROLLS_PESTCONTROL,
          VarbitID.BOOKOFSCROLLS_PISCATORIS,
          VarbitID.BOOKOFSCROLLS_TAIBWO,
          VarbitID.BOOKOFSCROLLS_ELF,
          VarbitID.BOOKOFSCROLLS_MOSLES,
          VarbitID.BOOKOFSCROLLS_LUMBERYARD,
          VarbitID.BOOKOFSCROLLS_ZULANDRA,
          VarbitID.BOOKOFSCROLLS_CERBERUS,
          VarbitID.BOOKOFSCROLLS_REVENANTS,
          VarbitID.BOOKOFSCROLLS_WATSON_LOWBITS,
          VarbitID.BOOKOFSCROLLS_GUTHIXIAN_TEMPLE,
          VarbitID.BOOKOFSCROLLS_SPIDERCAVE,
          VarbitID.BOOKOFSCROLLS_COLOSSAL_WYRM
        };

    items.add(new ItemStack(ItemID.TELEPORTSCROLL_NARDAH, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_DIGSITE, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_FELDIP, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_LUNARISLE, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_MORTTON, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_PESTCONTROL, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_PISCATORIS, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_TAIBWO, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_ELF, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_MOSLES, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_LUMBERYARD, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_ZULANDRA, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_CERBERUS, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_REVENANTS, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_WATSON, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_GUTHIXIAN_TEMPLE, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_SPIDERCAVE, 0, plugin));
    items.add(new ItemStack(ItemID.TELEPORTSCROLL_COLOSSAL_WYRM, 0, plugin));
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Var;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.ConfigManager;

/** BoltPouch is responsible for tracking which bolts the player has in the bolt pouch. */
@Slf4j
public class BoltPouch extends CarryableStorage {

  private static final int[] BOLT_TYPE_VARBITS = {
    VarbitID.XBOWS_POUCH_SLOT1,
    VarbitID.XBOWS_POUCH_SLOT2,
    VarbitID.XBOWS_POUCH_SLOT3,
    VarbitID.XBOWS_POUCH_SLOT4
  };
  private static final int[] BOLT_COUNT_VARBITS = {
    VarbitID.XBOWS_POUCH_NUM1,
    VarbitID.XBOWS_POUCH_NUM2,
    VarbitID.XBOWS_POUCH_NUM3,
    VarbitID.XBOWS_POUCH_NUM4
  };
  private static final int[] BOLT_ITEM_IDS = {
    -1,
    ItemID.BOLT,
    ItemID.XBOWS_CROSSBOW_BOLTS_BLURITE,
    ItemID.XBOWS_CROSSBOW_BOLTS_IRON,
    ItemID.XBOWS_CROSSBOW_BOLTS_STEEL,
    ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL,
    ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE,
    ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE,
    ItemID.XBOWS_CROSSBOW_BOLTS_SILVER, // 8
    ItemID.POISON_BOLT,
    ItemID.XBOWS_CROSSBOW_BOLTS_BLURITE_POISONED,
    ItemID.XBOWS_CROSSBOW_BOLTS_IRON_POISONED,
    ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_POISONED,
    ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED,
    ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED,
    ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED,
    ItemID.XBOWS_CROSSBOW_BOLTS_SILVER_POISONED, // 16
    ItemID.POISON_BOLT_,
    ItemID.XBOWS_CROSSBOW_BOLTS_BLURITE_POISONED_,
    ItemID.XBOWS_CROSSBOW_BOLTS_IRON_POISONED_,
    ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_POISONED_,
    ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED_,
    ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED_,
    ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED_,
    ItemID.XBOWS_CROSSBOW_BOLTS_SILVER_POISONED_, // 24
    ItemID.POISON_BOLT__,
    ItemID.XBOWS_CROSSBOW_BOLTS_BLURITE_POISONED__,
    ItemID.XBOWS_CROSSBOW_BOLTS_IRON_POISONED__,
    ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_POISONED__,
    ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED__,
    ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED__,
    ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED__,
    ItemID.XBOWS_CROSSBOW_BOLTS_SILVER_POISONED__, // 32
    ItemID.OPAL_BOLT,
    ItemID.XBOWS_CROSSBOW_BOLTS_BLURITE_TIPPED_JADE,
    ItemID.PEARL_BOLT,
    ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_TIPPED_REDTOPAZ,
    ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_SAPPHIRE,
    ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_EMERALD,
    ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_RUBY,
    ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_DIAMOND, // 40
    ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_DRAGONSTONE,
    ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_ONYX,
    ItemID.XBOWS_CROSSBOW_BOLTS_BRONZE_TIPPED_OPAL_ENCHANTED,
    ItemID.XBOWS_CROSSBOW_BOLTS_BLURITE_TIPPED_JADE_ENCHANTED,
    ItemID.XBOWS_CROSSBOW_BOLTS_IRON_TIPPED_PEARL_ENCHANTED,
    ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_TIPPED_REDTOPAZ_ENCHANTED,
    ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_SAPPHIRE_ENCHANTED,
    ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_EMERALD_ENCHANTED, // 48
    ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_RUBY_ENCHANTED,
    ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_DIAMOND_ENCHANTED,
    ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_DRAGONSTONE_ENCHANTED,
    ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_ONYX_ENCHANTED,
    ItemID.XBOWS_GRAPPLE_TIP_BOLT_MITHRIL_ROPE,
    ItemID.BARBED_BOLT,
    ItemID.DTTD_BONE_CROSSBOW_BOLT,
    ItemID.SLAYER_BROAD_BOLT, // 56
    ItemID.SLAYER_BROAD_BOLT_AMETHYST,
    ItemID.DRAGON_BOLTS,
    ItemID.DRAGON_BOLTS_P,
    ItemID.DRAGON_BOLTS_P_,
    ItemID.DRAGON_BOLTS_P__,
    ItemID.DRAGON_BOLTS_UNENCHANTED_OPAL,
    ItemID.DRAGON_BOLTS_UNENCHANTED_JADE,
    ItemID.DRAGON_BOLTS_UNENCHANTED_PEARL, // 64
    ItemID.DRAGON_BOLTS_UNENCHANTED_TOPAZ,
    ItemID.DRAGON_BOLTS_UNENCHANTED_SAPPHIRE,
    ItemID.DRAGON_BOLTS_UNENCHANTED_EMERALD,
    ItemID.DRAGON_BOLTS_UNENCHANTED_RUBY,
    ItemID.DRAGON_BOLTS_UNENCHANTED_DIAMOND,
    ItemID.DRAGON_BOLTS_UNENCHANTED_DRAGONSTONE,
    ItemID.DRAGON_BOLTS_UNENCHANTED_ONYX,
    ItemID.DRAGON_BOLTS_ENCHANTED_OPAL, // 72
    ItemID.DRAGON_BOLTS_ENCHANTED_JADE,
    ItemID.DRAGON_BOLTS_ENCHANTED_PEARL,
    ItemID.DRAGON_BOLTS_ENCHANTED_TOPAZ,
    ItemID.DRAGON_BOLTS_ENCHANTED_SAPPHIRE,
    ItemID.DRAGON_BOLTS_ENCHANTED_EMERALD,
    ItemID.DRAGON_BOLTS_ENCHANTED_RUBY,
    ItemID.DRAGON_BOLTS_ENCHANTED_DIAMOND,
    ItemID.DRAGON_BOLTS_ENCHANTED_DRAGONSTONE, // 80
    ItemID.DRAGON_BOLTS_ENCHANTED_ONYX,
    ItemID.BARROWS_KARIL_AMMO,
  };

  BoltPouch(DudeWheresMyStuffPlugin plugin) {
    super(CarryableStorageType.BOLT_POUCH, plugin);

    resetItems();
  }

  @Override
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    var updated = false;

    for (int i = 0; i < BOLT_TYPE_VARBITS.length; i++) {
      var countVar = Var.bit(varbitChanged, BOLT_COUNT_VARBITS[i]);
      var typeVar = Var.bit(varbitChanged, BOLT_TYPE_VARBITS[i]);
      if (!countVar.wasChanged() && !typeVar.wasChanged()) {
        continue;
      }

      var client = plugin.getClient();
      var boltStack = items.get(i);
      if (countVar.wasChanged()) {
        var newCount = countVar.getValue(client);
        if (newCount != boltStack.getQuantity()) {
          boltStack.setQuantity(newCount);
          updated = true;
        }
      }

      if (typeVar.wasChanged()) {
        int boltItemId = getBoltItemId(typeVar.getValue(client));
        if (boltItemId != boltStack.getId()) {
          boltStack.setId(boltItemId, plugin);
          updated = true;
        }
      }
    }

    return updated;
  }

  private int getBoltItemId(int varbitValue) {
    if (varbitValue < 0 || varbitValue >= BOLT_ITEM_IDS.length) {
      return -1;
    }

    return BOLT_ITEM_IDS[varbitValue];
  }

  @Override
  public void load(ConfigManager configManager, String managerConfigKey, String profileKey) {
    super.load(configManager, managerConfigKey, profileKey);

    while (items.size() < 4) {
      items.add(new ItemStack(-1, 0, plugin));
    }
  }

  @Override
  protected void resetItems() {
    for (int i = 0; i < BOLT_TYPE_VARBITS.length; i++) {
      items.add(new ItemStack(-1, 0, plugin));
    }
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/**
 * BottomlessBucket is responsible for tracking how many charges of which type of compost the player
 * has stored in their bottomless compost bucket.
 */
@Slf4j
public class BottomlessBucket extends CarryableStorage {

  private static final Pattern chargesPattern = Pattern.compile("(\\d+) uses");

  private final ItemStack compostStack;
  private final ItemStack supercompostStack;
  private final ItemStack ultracompostStack;

  BottomlessBucket(DudeWheresMyStuffPlugin plugin) {
    super(CarryableStorageType.BOTTOMLESS_BUCKET, plugin);

    hasStaticItems = true;

    compostStack = new ItemStack(ItemID.BUCKET_COMPOST, plugin);
    supercompostStack = new ItemStack(ItemID.BUCKET_SUPERCOMPOST, plugin);
    ultracompostStack = new ItemStack(ItemID.BUCKET_ULTRACOMPOST, plugin);

    items.add(compostStack);
    items.add(supercompostStack);
    items.add(ultracompostStack);

    plugin.getClientThread().invokeLater(() -> items.forEach(ItemStack::stripPrices));
  }

  @Override
  public boolean onGameTick() {
    Widget widget = plugin.getClient().getWidget(193, 2);
    if (widget == null) {
      return false;
    }

    String widgetText = widget.getText().replace("<br>", " ").replace(",", "");
    if (!widgetText.contains("compost bucket")) {
      return false;
    }

    if (widgetText.contains("currently empty") || widgetText.startsWith("You discard")) {
      compostStack.setQuantity(0);
      supercompostStack.setQuantity(0);
      ultracompostStack.setQuantity(0);
      updateLastUpdated();
      return true;
    }

    Matcher matcher = chargesPattern.matcher(widgetText);
    int charges = 1;
    if (matcher.find()) {
      charges = NumberUtils.toInt(matcher.group(1));
    } else if (!widgetText.contains("one use")) {
      return false;
    }

    compostStack.setQuantity(0);
    supercompostStack.setQuantity(0);
    ultracompostStack.setQuantity(0);
    updateLastUpdated();

    if (widgetText.contains("ultracompost")) {
      ultracompostStack.setQuantity(charges);
    } else if (widgetText.contains("supercompost")) {
      supercompostStack.setQuantity(charges);
    } else {
      compostStack.setQuantity(charges);
    }

    return true;
  }

  /**
   * Updates the compost count, for use by Leprechaun.
   *
   * @param type    0 = missing, 1 = empty, 2 = compost, 3 = supercompost, 4 = ultracompost
   * @param charges the amount of charges
   */
  public void updateCompost(int type, int charges) {
    // Don't update on type 0, bucket has been withdrawn so charges are 0
    if (type == 0) {
      return;
    }

    compostStack.setQuantity(0);
    supercompostStack.setQuantity(0);
    ultracompostStack.setQuantity(0);
    updateLastUpdated();

    if (type == 2) {
      compostStack.setQuantity(charges);
    } else if (type == 3) {
      supercompostStack.setQuantity(charges);
    } else if (type == 4) {
      ultracompostStack.setQuantity(charges);
    }
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (chatMessage.getType() != ChatMessageType.SPAM
        && chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
      return false;
    }

    if (!chatMessage.getMessage().startsWith("Your bottomless compost bucket has")) {
      return false;
    }

    if (chatMessage.getMessage().contains("run out")) {
      compostStack.setQuantity(0);
      supercompostStack.setQuantity(0);
      ultracompostStack.setQuantity(0);
      updateLastUpdated();
      return true;
    }

    Matcher matcher = chargesPattern.matcher(chatMessage.getMessage().replace(",", ""));
    int charges = 1;
    if (matcher.find()) {
      charges = NumberUtils.toInt(matcher.group(1));
    } else if (!chatMessage.getMessage().contains("single use")) {
      return false;
    }

    compostStack.setQuantity(0);
    supercompostStack.setQuantity(0);
    ultracompostStack.setQuantity(0);
    updateLastUpdated();

    if (chatMessage.getMessage().contains("ultracompost")) {
      ultracompostStack.setQuantity(charges);
    } else if (chatMessage.getMessage().contains("supercompost")) {
      supercompostStack.setQuantity(charges);
    } else {
      compostStack.setQuantity(charges);
    }

    return true;
  }

  @Override
  public boolean isWithdrawable() {
    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.StorageTabPanel;

/** CarryableStorageTabPanel is responsible for displaying carryable storage data to the player. */
public class CarryableStorageTabPanel
    extends StorageTabPanel<CarryableStorageType, CarryableStorage, CarryableStorageManager> {

  public CarryableStorageTabPanel(
      DudeWheresMyStuffPlugin plugin, CarryableStorageManager storageManager) {
    super(plugin, storageManager);
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemContainerWatcher;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.ItemStackUtils;
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
import java.util.Objects;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.gameval.InterfaceID.Inventory;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.Widget;

/** LootingBag is responsible for tracking the player's items in their looting bag. */
@Getter
public class LootingBag extends CarryableStorage {

  private final List<SuspendedItem> itemsUsedOnBag = new ArrayList<>();

  public LootingBag(DudeWheresMyStuffPlugin plugin) {
    super(CarryableStorageType.LOOTING_BAG, plugin);
  }

  @Override
  public boolean onGameTick() {
    boolean didUpdate = super.onGameTick();

    if (checkUsedItems()) {
      didUpdate = true;
    }

    Widget lootingBagWidget = plugin.getClient().getWidget(81, 5);
    if (lootingBagWidget != null) {
      Widget emptyText = lootingBagWidget.getChild(28);
      if (emptyText != null && Objects.equals(emptyText.getText(), "The bag is empty.")) {
        items.clear();
        updateLastUpdated();

        return true;
      }

      if (checkForDeposit()) {
        didUpdate = true;
      }
    }

    return didUpdate;
  }

  private boolean checkUsedItems() {
    boolean updated = false;

    Widget depositDialog = plugin.getClient().getWidget(219, 1);
    boolean depositDialogOpen = false;
    if (depositDialog != null) {
      Widget titleWidget = depositDialog.getChild(0);
      depositDialogOpen =
          titleWidget != null && titleWidget.getText().equals("How many do you want to deposit?");
    }

    for (ItemStack itemStack : ItemContainerWatcher.getInventoryWatcher()
        .getItemsRemovedLastTick()) {
      if (itemsUsedOnBag.stream().anyMatch(i -> i.getId() == itemStack.getId())) {
        ItemStackUtils.addItemStack(items, itemStack);
        updated = true;
      }
    }

    ListIterator<SuspendedItem> listIterator = itemsUsedOnBag.listIterator();
    while (listIterator.hasNext()) {
      SuspendedItem item = listIterator.next();

      if (item.getQuantity() == 1 || !depositDialogOpen) {
        if (item.getTicksLeft() <= 1) {
          listIterator.remove();
        } else {
          item.setTicksLeft(item.getTicksLeft() - 1);
        }
      }
    }

    if (updated) {
      updateLastUpdated();
    }

    return updated;
  }

  private boolean checkForDeposit() {
    Widget widgetTitle = plugin.getClient().getWidget(81, 1);
    if (widgetTitle != null && widgetTitle.getText().equals("Add to bag")) {
      boolean updated = false;
      for (ItemStack itemStack : ItemContainerWatcher.getInventoryWatcher()
          .getItemsRemovedLastTick()) {
        ItemStackUtils.addItemStack(items, itemStack);
        updated = true;
      }

      if (updated) {
        updateLastUpdated();

        return true;
      }
    }

    return false;
  }

  @Override
  public boolean onMenuOptionClicked(MenuOptionClicked menuOption) {
    Widget item1Widget = plugin.getClient().getSelectedWidget();

    if (menuOption.getWidget() == null
        || menuOption.getWidget().getParentId() != Inventory.ITEMS) {
      return false;
    }

    Widget item2Widget = menuOption.getWidget();
    if (item1Widget == null) {
      if (!menuOption.getMenuOption().equals("Use")
          && !menuOption.getMenuOption().equals("Examine")) {
        itemsUsedOnBag.removeIf(item -> item.getInventorySlot() == item2Widget.getIndex());
      }

      return false;
    }

    // one of the widgets is not an item
    if (item1Widget.getItemId() == -1 || item2Widget.getItemId() == -1) {
      return false;
    }

    boolean item1IsLootingBag = type.getContainerIds().contains(item1Widget.getItemId());
    // Item wasn't used on a looting bag
    if (!item1IsLootingBag
        && !type.getContainerIds().contains(item2Widget.getItemId())) {
      return false;
    }

    Widget itemWidget = (item1IsLootingBag ? item2Widget : item1Widget);
    itemsUsedOnBag.add(new SuspendedItem(itemWidget.getIndex(), itemWidget.getItemId(),
        Objects.requireNonNull(plugin.getClient().getItemContainer(InventoryID.INV))
            .count(itemWidget.getItemId())));

    return false;
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (chatMessage.getType() != ChatMessageType.SPAM
        && chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
      return false;
    }

    if (chatMessage.getMessage().startsWith("You can't put items in the looting bag")) {
      itemsUsedOnBag.clear();
    }

    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.carryable;

import com.google.inject.Inject;
import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

/** CarryableStorageManager is responsible for managing all CarryableStorages. */
@Slf4j
public class CarryableStorageManager
    extends StorageManager<CarryableStorageType, CarryableStorage> {

  @Getter private final BottomlessBucket bottomlessBucket;

  @Inject
  private CarryableStorageManager(DudeWheresMyStuffPlugin plugin) {
    super(plugin);

    bottomlessBucket = new BottomlessBucket(plugin);

    storages.add(new CarryableStorage(CarryableStorageType.EQUIPMENT, plugin));
    storages.add(new CarryableStorage(CarryableStorageType.INVENTORY, plugin));
    storages.add(new LootingBag(plugin));
    storages.add(new SeedBox(plugin));
    storages.add(new RunePouch(plugin));
    storages.add(bottomlessBucket);
    storages.add(new PlankSack(plugin));
    storages.add(new BoltPouch(plugin));
    storages.add(new GnomishFirelighter(plugin));
    storages.add(new MasterScrollBook(plugin));
    storages.add(new HuntsmansKit(plugin));
    storages.add(new ForestryKit(plugin));
    storages.add(new TackleBox(plugin));
    storages.add(new HerbSack(plugin));
    storages.add(new ChuggingBarrel(plugin));
    storages.add(new DizanasQuiver(plugin));
  }

  @Override
  public String getConfigKey() {
    return "carryable";
  }

}

package dev.thource.runelite.dudewheresmystuff;

import com.google.inject.Inject;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.itemidentification.ItemIdentificationConfig;
import net.runelite.client.plugins.itemidentification.ItemIdentificationPlugin;

/**
 * StorageManager manages Storages that are assigned to it, it passes on RuneLite events so that the
 * Storages can do their jobs.
 */
public abstract class StorageManager<T extends StorageType, S extends Storage<T>> {

  @Getter protected final List<S> storages = new ArrayList<>();
  protected final DudeWheresMyStuffPlugin plugin;
  @Inject protected Client client;
  @Inject protected ItemManager itemManager;
  @Getter @Inject protected ConfigManager configManager;
  @Getter @Inject protected PluginManager pluginManager;
  @Getter @Inject protected ItemIdentificationPlugin itemIdentificationPlugin;
  @Getter @Inject protected ItemIdentificationConfig itemIdentificationConfig;
  @Getter @Inject protected ClientThread clientThread;
  @Getter protected boolean enabled = true;
  @Getter @Setter protected boolean isPreviewManager = false;
  @Getter @Setter protected StorageTabPanel<T, S, ? extends StorageManager<?, ?>> storageTabPanel;

  protected StorageManager(DudeWheresMyStuffPlugin plugin) {
    this.plugin = plugin;
  }

  public long getTotalValue() {
    return storages.stream().filter(Storage::isWithdrawable).mapToLong(Storage::getTotalValue)
        .sum();
  }

  protected void updateStorages(List<? extends S> storages) {
    if (!storages.isEmpty()) {
      storages.forEach(
          storage -> {
            if (storage.getStoragePanel() != null) {
              storage.getStoragePanel().refreshItems();
              SwingUtilities.invokeLater(storage.getStoragePanel()::update);
            }
          });

      SwingUtilities.invokeLater(storageTabPanel::reorderStoragePanels);
    }
  }

  /** Pass onGameTick through to enabled storages. */
  public void onGameTick() {
    if (enabled) {
      updateStorages(
          storages.stream()
              .filter(storage -> storage.isEnabled() && storage.onGameTick())
              .collect(Collectors.toList()));
    }
  }

  /** Pass onGameObjectSpawned through to enabled storages. */
  public void onGameObjectSpawned(GameObjectSpawned gameObjectSpawned) {
    if (enabled) {
      updateStorages(
          storages.stream()
              .filter(storage -> storage.isEnabled() && storage.onGameObjectSpawned(gameObjectSpawned))
              .collect(Collectors.toList()));
    }
  }

  /** Pass onWidgetLoaded through to enabled storages. */
  public void onWidgetLoaded(WidgetLoaded widgetLoaded) {
    if (enabled) {
      updateStorages(
          storages.stream()
              .filter(storage -> storage.isEnabled() && storage.onWidgetLoaded(widgetLoaded))
              .collect(Collectors.toList()));
    }
  }

  /** Pass onWidgetClosed through to enabled storages. */
  public void onWidgetClosed(WidgetClosed widgetClosed) {
    if (enabled) {
      storages.stream().filter(Storage::isEnabled)
          .forEach(storage -> storage.onWidgetClosed(widgetClosed));
    }
  }

  /** Pass onVarbitChanged through to enabled storages. */
  public void onVarbitChanged(VarbitChanged varbitChanged) {
    if (enabled) {
      updateStorages(
          storages.stream()
              .filter(storage -> storage.isEnabled() && storage.onVarbitChanged(varbitChanged))
              .collect(Collectors.toList()));
    }
  }

  /** Pass onItemContainerChanged through to enabled storages. */
  public void onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
    if (enabled) {
      updateStorages(
          storages.stream()
              .filter(
                  storage ->
                      storage.isEnabled() && storage.onItemContainerChanged(itemContainerChanged))
              .collect(Collectors.toList()));
    }
  }

  public void onGameStateChanged(GameStateChanged gameStateChanged) {
  }

  public void onActorDeath(ActorDeath actorDeath) {
  }

  public void reset() {
    storages.forEach(Storage::reset);
    enable();
  }

  public abstract String getConfigKey();

  /**
   * Save all Storages.
   *
   * @param profileKey the profile key to save the storages with
   */
  public void save(String profileKey) {
    if (!enabled) {
      return;
    }

    storages.forEach(storage -> storage.save(configManager, profileKey, getConfigKey()));
  }

  /** Load all Storages. */
  public void load(String profileKey) {
    if (!enabled || profileKey == null) {
      return;
    }

    storages.forEach(storage -> storage.load(configManager, getConfigKey(), profileKey));
  }

  public void disable() {
    enabled = false;
  }

  public void enable() {
    enabled = true;
  }

  public void onItemDespawned(ItemDespawned itemDespawned) {
  }

  /** Pass onChatMessage through to enabled storages. */
  public void onChatMessage(ChatMessage chatMessage) {
    if (enabled) {
      updateStorages(
          storages.stream()
              .filter(storage -> storage.isEnabled() && storage.onChatMessage(chatMessage))
              .collect(Collectors.toList()));
    }
  }

  /** Pass onMenuOptionClicked through to enabled storages. */
  public void onMenuOptionClicked(MenuOptionClicked menuOption) {
    if (enabled) {
      updateStorages(
          storages.stream()
              .filter(storage -> storage.isEnabled() && storage.onMenuOptionClicked(menuOption))
              .collect(Collectors.toList()));
    }
  }
}

package dev.thource.runelite.dudewheresmystuff.export.utils;

import com.google.api.services.sheets.v4.model.GridRange;

public class SheetUtils {
  public static GridRange getGridRange(
      int sheetId, int startColumnNumber, int startRow, int endColumnNumber, int endRow) {
    return new GridRange()
        .setSheetId(sheetId)
        .setStartColumnIndex(startColumnNumber)
        .setStartRowIndex(startRow)
        .setEndColumnIndex(endColumnNumber)
        .setEndRowIndex(endRow);
  }
}

package dev.thource.runelite.dudewheresmystuff.export.utils;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

import com.google.api.client.auth.oauth2.Credential;
import com.google.api.client.extensions.java6.auth.oauth2.AuthorizationCodeInstalledApp;
import com.google.api.client.extensions.jetty.auth.oauth2.LocalServerReceiver;
import com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeFlow;
import com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets;
import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.JsonFactory;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.client.util.store.FileDataStoreFactory;
import com.google.api.services.sheets.v4.Sheets;
import com.google.api.services.sheets.v4.SheetsScopes;
import dev.thource.runelite.dudewheresmystuff.export.writers.GoogleSheetsWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.security.GeneralSecurityException;
import java.util.Collections;
import java.util.List;

public class GoogleSheetConnectionUtils {
  private static final String APPLICATION_NAME = "Where's My Stuff Dev";
  private static final JsonFactory JSON_FACTORY = GsonFactory.getDefaultInstance();
  private static final String TOKENS_DIRECTORY_PATH =
      new File(RUNELITE_DIR, "dudewheresmystuff/tokens").getAbsolutePath();

  private static final List<String> SCOPES = Collections.singletonList(SheetsScopes.DRIVE_FILE);
  private static final String CREDENTIALS_FILE_PATH = "/credentials.json";

  private static Credential getCredentials(final NetHttpTransport HTTP_TRANSPORT, String userEmail)
      throws IOException {
    // Load client secrets.
    InputStream in = GoogleSheetsWriter.class.getResourceAsStream(CREDENTIALS_FILE_PATH);
    if (in == null) {
      throw new FileNotFoundException("Resource not found: " + CREDENTIALS_FILE_PATH);
    }
    GoogleClientSecrets clientSecrets =
        GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));

    // Build flow and trigger user authorization request.
    GoogleAuthorizationCodeFlow flow =
        new GoogleAuthorizationCodeFlow.Builder(HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES)
            .setDataStoreFactory(new FileDataStoreFactory(new java.io.File(TOKENS_DIRECTORY_PATH)))
            .setAccessType("offline")
            .build();

    LocalServerReceiver receiver = new LocalServerReceiver.Builder().setPort(8888).build();
    return new AuthorizationCodeInstalledApp(flow, receiver).authorize(userEmail);
  }

  public static Sheets getSheetsConnection(String userEmail) {
    final NetHttpTransport HTTP_TRANSPORT;
    try {
      HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
      return new Sheets.Builder(
              HTTP_TRANSPORT, JSON_FACTORY, getCredentials(HTTP_TRANSPORT, userEmail))
          .setApplicationName(APPLICATION_NAME)
          .build();
    } catch (GeneralSecurityException | IOException e) {
      throw new RuntimeException(e);
    }
  }

  public static void invalidateCredentials() {
    File f = new File(TOKENS_DIRECTORY_PATH, "StoredCredential");
    f.delete();
  }
}

package dev.thource.runelite.dudewheresmystuff.export.clients;

import com.google.api.services.sheets.v4.Sheets;
import com.google.api.services.sheets.v4.model.AddSheetRequest;
import com.google.api.services.sheets.v4.model.BatchUpdateSpreadsheetRequest;
import com.google.api.services.sheets.v4.model.BatchUpdateSpreadsheetResponse;
import com.google.api.services.sheets.v4.model.CellData;
import com.google.api.services.sheets.v4.model.ClearValuesRequest;
import com.google.api.services.sheets.v4.model.GridRange;
import com.google.api.services.sheets.v4.model.Request;
import com.google.api.services.sheets.v4.model.RowData;
import com.google.api.services.sheets.v4.model.Sheet;
import com.google.api.services.sheets.v4.model.SheetProperties;
import com.google.api.services.sheets.v4.model.Spreadsheet;
import com.google.api.services.sheets.v4.model.SpreadsheetProperties;
import com.google.api.services.sheets.v4.model.UpdateCellsRequest;
import dev.thource.runelite.dudewheresmystuff.export.utils.GoogleSheetConnectionUtils;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class GoogleSheetClient {
  private final Sheets sheetsService;

  public GoogleSheetClient(String email) {
    this.sheetsService = GoogleSheetConnectionUtils.getSheetsConnection(email);
  }

  public BatchUpdateSpreadsheetResponse writeCellData(
      String spreadsheetId, GridRange gridRange, List<List<CellData>> cellData) {
    try {
      List<RowData> rowData =
          cellData.stream().map(x -> new RowData().setValues(x)).collect(Collectors.toList());
      return sheetsService
          .spreadsheets()
          .batchUpdate(
              spreadsheetId,
              new BatchUpdateSpreadsheetRequest()
                  .setRequests(
                      List.of(
                          new Request()
                              .setUpdateCells(
                                  new UpdateCellsRequest()
                                      .setFields("*")
                                      .setRange(gridRange)
                                      .setRows(new ArrayList<>(rowData))))))
          .execute();
    } catch (Exception e) {
      log.error("Encountered issue with batch write: ", e);
      throw new RuntimeException(e);
    }
  }

  public List<Sheet> getSheetList(String spreadsheetId) {
    try {
      Spreadsheet spreadsheet = sheetsService.spreadsheets().get(spreadsheetId).execute();
      return spreadsheet.getSheets();

    } catch (Exception e) {
      log.error(
          String.format("Encountered error in getSheetList, spreadsheetId: %s", spreadsheetId), e);
      throw new RuntimeException(e);
    }
  }

  public Sheet getSheet(String spreadsheetId, String sheetTitle) {
    List<Sheet> sheets = getSheetList(spreadsheetId);
    return sheets.stream()
        .filter(x -> x.getProperties().getTitle().equalsIgnoreCase(sheetTitle))
        .findFirst()
        .orElseThrow(
            () -> {
              RuntimeException e =
                  new RuntimeException(
                      String.format(
                          "Failed to retrieve sheet that should have been created for spreadsheetId: %s",
                          spreadsheetId));
              log.error("Unexpected Exception While Writing Headers", e);
              return e;
            });
  }

  public Spreadsheet createOrGetSpreadsheet(String spreadsheetId, String displayName) {
    try {
      if (Objects.equals(spreadsheetId, "")) {
        return sheetsService
            .spreadsheets()
            .create(
                new Spreadsheet().setProperties(new SpreadsheetProperties().setTitle(displayName)))
            .execute();
      }
      return sheetsService.spreadsheets().get(spreadsheetId).execute();
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  public boolean maybeCreateSheet(String spreadsheetId, String sheetTitle) {
    if (!getSheetExists(spreadsheetId, sheetTitle)) {
      try {
        sheetsService
            .spreadsheets()
            .batchUpdate(
                spreadsheetId,
                new BatchUpdateSpreadsheetRequest()
                    .setRequests(
                        List.of(
                            new Request()
                                .setAddSheet(
                                    new AddSheetRequest()
                                        .setProperties(
                                            new SheetProperties().setTitle(sheetTitle))))))
            .execute();
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
      return true;
    }
    return false;
  }

  public boolean maybeClearSheet(String spreadsheetId, String sheetTitle) {
    if (getSheetExists(spreadsheetId, sheetTitle)) {
      ClearValuesRequest request = new ClearValuesRequest();
      try {
        sheetsService.spreadsheets().values().clear(spreadsheetId, sheetTitle, request).execute();
        return true;
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }
    return false;
  }

  public boolean getSheetExists(String spreadsheetId, String sheetTitle) {
    try {
      Spreadsheet spreadsheet = sheetsService.spreadsheets().get(spreadsheetId).execute();
      List<Sheet> sheets = spreadsheet.getSheets();
      return sheets.stream()
          .anyMatch(x -> x.getProperties().getTitle().equalsIgnoreCase(sheetTitle));
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }
}

package dev.thource.runelite.dudewheresmystuff.export.writers;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Storage;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import dev.thource.runelite.dudewheresmystuff.export.DataExportWriter;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import javax.annotation.Nullable;
import joptsimple.internal.Strings;

public class CsvWriter implements DataExportWriter {
  private static final File EXPORT_DIR = new File(RUNELITE_DIR, "dudewheresmystuff");

  private final BufferedWriter writer;

  private final String fileLocation;

  public CsvWriter(String displayName) {
    if (displayName.equals("")) {
      throw new IllegalArgumentException("No display name");
    }

    File userDir = new File(EXPORT_DIR, displayName);
    String fileName = new SimpleDateFormat("yyyyMMdd'T'HHmmss'.csv'").format(new Date());
    this.fileLocation = userDir + File.separator + fileName;
    userDir.mkdirs();
    try {
      this.writer = new BufferedWriter(new FileWriter(this.fileLocation));
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  @Override
  public void writeItemStack(
      ItemStack itemStack,
      @Nullable StorageManager<?, ?> storageManager,
      @Nullable Storage<?> storage,
      boolean mergeItems) {
    try {
      writer.write(itemStack.toCsvString(mergeItems, storageManager, storage));
    } catch (Exception ex) {
      throw new RuntimeException(ex);
    }
  }

  @Override
  public void writeHeader(boolean mergeItems, boolean shouldSplitUp) {
    try {
      String headers = Strings.join(ItemStack.getHeaders(mergeItems, shouldSplitUp), ",") + '\n';
      if (mergeItems) {
        writer.write(headers);
      } else {
        writer.write(headers);
      }
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  @Override
  public String getFileLocation() {
    return this.fileLocation;
  }

  @Override
  public void close() {
    try {
      writer.close();
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }
}

package dev.thource.runelite.dudewheresmystuff.export.writers;

import com.google.api.services.sheets.v4.model.CellData;
import com.google.api.services.sheets.v4.model.ExtendedValue;
import com.google.api.services.sheets.v4.model.GridRange;
import com.google.api.services.sheets.v4.model.Sheet;
import com.google.api.services.sheets.v4.model.Spreadsheet;
import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Storage;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import dev.thource.runelite.dudewheresmystuff.export.DataExportWriter;
import dev.thource.runelite.dudewheresmystuff.export.clients.GoogleSheetClient;
import dev.thource.runelite.dudewheresmystuff.export.utils.SheetUtils;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class GoogleSheetsWriter implements DataExportWriter {
  DudeWheresMyStuffPlugin plugin;

  @Getter private String spreadsheetId;

  private final String displayName;

  private final GoogleSheetClient googleSheetClient;

  private final List<List<CellData>> itemBuffer;

  public GoogleSheetsWriter(DudeWheresMyStuffPlugin plugin, String displayName) {
    this.plugin = plugin;
    this.spreadsheetId = plugin.getConfig().googleSpreadSheetId();
    this.displayName = displayName;
    this.googleSheetClient = new GoogleSheetClient("rldudewms@gmail.com");
    itemBuffer = new ArrayList<>();
  }

  @Override
  public void writeItemStack(
      ItemStack itemStack,
      @Nullable StorageManager<?, ?> storageManager,
      @Nullable Storage<?> storage,
      boolean mergeItems) {
    itemBuffer.add(itemStack.getCellDataList(mergeItems, storageManager, storage));
  }

  @Override
  public void writeHeader(boolean mergeItems, boolean shouldSplitUp) {
    Spreadsheet spreadsheet = googleSheetClient.createOrGetSpreadsheet(spreadsheetId, displayName);
    spreadsheetId = spreadsheet.getSpreadsheetId();
    plugin.getConfig().setGoogleSpreadSheetId(spreadsheetId);
    plugin.getConfig().setGoogleSpreadSheetUrl(spreadsheet.getSpreadsheetUrl());
    googleSheetClient.maybeClearSheet(spreadsheetId, displayName);
    googleSheetClient.maybeCreateSheet(spreadsheetId, displayName);

    List<CellData> headers =
        ItemStack.getHeaders(mergeItems, shouldSplitUp).stream()
            .map(x -> new CellData().setUserEnteredValue(new ExtendedValue().setStringValue(x)))
            .collect(Collectors.toList());
    Sheet sheet = googleSheetClient.getSheet(spreadsheetId, displayName);

    GridRange gridRange =
        SheetUtils.getGridRange(sheet.getProperties().getSheetId(), 0, 0, headers.size() + 1, 1);
    googleSheetClient.writeCellData(spreadsheetId, gridRange, List.of(headers));
  }

  @Override
  public String getFileLocation() {
    return googleSheetClient.createOrGetSpreadsheet(spreadsheetId, displayName).getSpreadsheetUrl();
  }

  @Override
  public void close() {
    if (itemBuffer.isEmpty()) return;
    Sheet sheet = googleSheetClient.getSheet(spreadsheetId, displayName);
    GridRange range =
        SheetUtils.getGridRange(
            sheet.getProperties().getSheetId(),
            0,
            1,
            itemBuffer.get(0).size() + 1,
            itemBuffer.size() + 1);
    googleSheetClient.writeCellData(spreadsheetId, range, itemBuffer);
    itemBuffer.clear();
  }
}

package dev.thource.runelite.dudewheresmystuff.export.exporters;

import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Storage;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import dev.thource.runelite.dudewheresmystuff.StorageManagerManager;
import dev.thource.runelite.dudewheresmystuff.export.DataExportWriter;
import dev.thource.runelite.dudewheresmystuff.export.DataExporter;
import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.TreeMap;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class StorageManagerExporter implements DataExporter {

  private final DataExportWriter writer;

  private final StorageManagerManager storageManagerManager;

  public StorageManagerExporter(
      DataExportWriter writer, StorageManagerManager storageManagerManager) {
    this.writer = writer;
    this.storageManagerManager = storageManagerManager;
  }

  private String writeMergedItems() throws IOException {
    // Include a CSV header describing the columns
    writer.writeHeader(true, false);

    for (ItemStack itemStack : getMergedItems()) {
      writer.writeItemStack(itemStack, null, null, true);
    }

    return writer.getFileLocation();
  }

  private void writeStorageManager(StorageManager<?, ?> storageManager, boolean mergeItems) {
    if (!storageManager.isEnabled()) {
      return;
    }

    for (Storage<?> storage : storageManager.getStorages()) {
      if (!storage.isEnabled() || !storage.isWithdrawable()) {
        continue;
      }

      for (ItemStack itemStack : storage.getItems()) {
        if (itemStack.getQuantity() == 0 || itemStack.getId() == -1) {
          continue;
        }

        writer.writeItemStack(itemStack, storageManager, storage, mergeItems);
      }
    }
  }

  private String writeAll() throws IOException {

    // Include a CSV header describing the columns
    writer.writeHeader(false, true);

    for (StorageManager<?, ?> storageManager : storageManagerManager.getStorageManagers()) {
      writeStorageManager(storageManager, false);
    }
    return writer.getFileLocation();
  }

  public String export(boolean mergeItems) throws IllegalArgumentException, IOException {
    if (mergeItems) {
      return writeMergedItems();
    } else {
      return writeAll();
    }
  }

  /**
   * Gets all known withdrawable items
   *
   * <p>If the same item is in multiple storages, the item stacks are combined. "Same item" refers
   * to items with the same canonical ID, but note that the actual ID of the stack will be set to
   * the ID of one of the items arbitrarily. It is therefore recommended that callers do not use the
   * IDs, only the canonical IDs.
   *
   * @return The item stacks
   */
  private Collection<ItemStack> getMergedItems() {
    // We need to deduplicate and combine item stacks if they're in multiple
    // storages. This is a map from the stack's canonical (unnoted,
    // un-placeholdered) ID to its stack.
    TreeMap<Integer, ItemStack> items = new TreeMap<>();

    storageManagerManager
        .getStorages()
        .filter(Storage::isWithdrawable)
        .map(Storage::getItems)
        .flatMap(List::stream)
        .forEach(
            (ItemStack stack) -> {
              if (stack.getQuantity() == 0 || stack.getId() == -1) {
                return;
              }

              int id = stack.getCanonicalId();

              ItemStack existing = items.get(id);
              if (existing == null) {
                // No item yet, insert a copy so that we can modify their quantities later if
                // necessary
                items.put(id, new ItemStack(stack));
              } else {
                // This item was already in there. Update the quantity to include the new stack.
                existing.setQuantity(stack.getQuantity() + existing.getQuantity());
              }
            });

    return items.values();
  }
}

package dev.thource.runelite.dudewheresmystuff.export;

import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Storage;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import java.io.IOException;
import javax.annotation.Nullable;

public interface DataExportWriter {
  void writeItemStack(
      ItemStack itemStack,
      @Nullable StorageManager<?, ?> storageManager,
      @Nullable Storage<?> storage,
      boolean mergeItems);

  void writeHeader(boolean mergeItems, boolean shouldSplitUp) throws IOException;

  String getFileLocation();

  void close();
}

package dev.thource.runelite.dudewheresmystuff.export;

public enum DataDestination {
  CSV,
  GOOGLE_SHEETS
}

package dev.thource.runelite.dudewheresmystuff.export;

import java.io.IOException;

public interface DataExporter {
  String export(boolean mergeItems) throws IOException;
}

/*
 * Copyright (c) 2022, Thource <https://github.com/Thource>
 * Copyright (c) 2018, Daniel Teo <https://github.com/takuyakanbr>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package dev.thource.runelite.dudewheresmystuff;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.BooleanSupplier;
import javax.annotation.Nullable;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.EmptyBorder;
import net.runelite.api.Constants;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

public class OverviewItemPanel extends JPanel {

  private static final ImageIcon ARROW_RIGHT_ICON;

  private static final Color HOVER_COLOR = ColorScheme.DARKER_GRAY_HOVER_COLOR;

  static {
    ARROW_RIGHT_ICON =
        new ImageIcon(
            ImageUtil.loadImageResource(DudeWheresMyStuffPlugin.class, "/util/arrow_right.png"));
  }

  private final JPanel textContainer;
  private final JLabel statusLabel;
  private final JLabel arrowLabel;
  private final transient BooleanSupplier isSelectable;
  private final JLabel titleLabel;
  private boolean isHighlighted;
  @Nullable private JButton popupButton;
  private final Container rightContainer;

  OverviewItemPanel(
      ItemManager itemManager,
      DudeWheresMyStuffPanel pluginPanel,
      @Nullable Tab tab,
      String title) {
    this(
        itemManager,
        () -> pluginPanel.switchTab(tab),
        () -> true,
        tab != null ? tab.getItemId() : -1,
        tab != null ? tab.getItemQuantity() : -1,
        title);
  }

  public OverviewItemPanel(
      ItemManager itemManager,
      @Nullable Runnable onTabSwitched,
      BooleanSupplier isSelectable,
      int iconItemId,
      int iconItemQuantity,
      String title) {
    this.isSelectable = isSelectable;

    setBackground(ColorScheme.DARKER_GRAY_COLOR);
    setLayout(new BorderLayout());
    setBorder(new EmptyBorder(7, 7, 7, 7));

    if (iconItemId != -1) {
      JLabel iconLabel = new JLabel();
      iconLabel.setMinimumSize(
          new Dimension(Constants.ITEM_SPRITE_WIDTH, Constants.ITEM_SPRITE_HEIGHT));
      itemManager.getImage(iconItemId, iconItemQuantity, false).addTo(iconLabel);
      add(iconLabel, BorderLayout.WEST);
    }

    textContainer = new JPanel();
    textContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    textContainer.setLayout(new GridLayout(2, 1));
    textContainer.setBorder(new EmptyBorder(5, 7, 5, 7));

    if (isSelectable.getAsBoolean()) {
      addMouseListener(
          new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent mouseEvent) {
              if (mouseEvent.getButton() != MouseEvent.BUTTON1) {
                return;
              }

              if (onTabSwitched != null) {
                onTabSwitched.run();
              }

              setHighlighted(false);
            }

            @Override
            public void mouseReleased(MouseEvent e) {
              setHighlighted(true);
            }

            @Override
            public void mouseEntered(MouseEvent e) {
              setHighlighted(true);
            }

            @Override
            public void mouseExited(MouseEvent e) {
              setHighlighted(false);
            }
          });
    }
    addMouseListener(new MouseAdapter() {
      private final Component rigidArea = Box.createRigidArea(new Dimension(5, 0));

      @Override
      public void mouseEntered(MouseEvent e) {
        if (popupButton == null) {
          return;
        }

        rightContainer.add(rigidArea);
        rightContainer.add(popupButton);
        revalidate();
      }

      @Override
      public void mouseExited(MouseEvent e) {
        if (popupButton == null || !isShowing() || getVisibleRect().contains(e.getPoint())) {
          return;
        }

        rightContainer.remove(rigidArea);
        rightContainer.remove(popupButton);
        revalidate();
      }
    });

    titleLabel = new JLabel(title);
    titleLabel.setForeground(Color.WHITE);
    titleLabel.setFont(FontManager.getRunescapeSmallFont());

    statusLabel = new JLabel();
    statusLabel.setForeground(Color.LIGHT_GRAY);
    statusLabel.setFont(FontManager.getRunescapeSmallFont());

    textContainer.add(titleLabel);
    textContainer.add(statusLabel);

    add(textContainer, BorderLayout.CENTER);

    rightContainer = new Container();
    rightContainer.setLayout(new BoxLayout(rightContainer, BoxLayout.X_AXIS));

    arrowLabel = new JLabel(ARROW_RIGHT_ICON);
    arrowLabel.setVisible(isSelectable.getAsBoolean());
    rightContainer.add(arrowLabel);

    add(rightContainer, BorderLayout.EAST);
  }

  @Override
  public void setComponentPopupMenu(JPopupMenu popup) {
    super.setComponentPopupMenu(popup);

    if (popup == null) {
      if (popupButton != null) {
        rightContainer.remove(popupButton);
        popupButton = null;
      }

      return;
    }

    if (popupButton != null) {
      return;
    }

    popupButton = new JButton("");
    popupButton.setPreferredSize(new Dimension(20, -1));
    popupButton.addMouseListener(new MouseAdapter() {
      @Override
      public void mousePressed(MouseEvent mouseEvent) {
        getComponentPopupMenu().show(popupButton, mouseEvent.getX(), mouseEvent.getY());
      }
    });
  }

  public void updateStatus(String text) {
    statusLabel.setText(text);

    arrowLabel.setVisible(isSelectable.getAsBoolean());

    if (isHighlighted && !isSelectable.getAsBoolean()) {
      setHighlighted(false);
    }
  }

  private void setHighlighted(boolean highlighted) {
    if (highlighted && !isSelectable.getAsBoolean()) {
      return;
    }

    setBackground(highlighted ? HOVER_COLOR : ColorScheme.DARKER_GRAY_COLOR);
    setCursor(
        new Cursor(
            highlighted && getMousePosition(true) != null
                ? Cursor.HAND_CURSOR
                : Cursor.DEFAULT_CURSOR));
    textContainer.setBackground(highlighted ? HOVER_COLOR : ColorScheme.DARKER_GRAY_COLOR);

    isHighlighted = highlighted;
  }

  void setTitle(String title) {
    this.titleLabel.setText(title);
  }

  public void setTitleColor(Color color) {
    titleLabel.setForeground(color);
  }
}

package dev.thource.runelite.dudewheresmystuff;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

/** ItemSortMode is used to decide how to sort items within the plugin. */
@Getter
@RequiredArgsConstructor
public enum ItemSortMode {
  VALUE("Value"),
  UNSORTED("Unsorted");

  private final String name;

  @Override
  public String toString() {
    return name;
  }
}

/*
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package dev.thource.runelite.dudewheresmystuff;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JPanel;

/**
 * This class will be a container (group) for the new Material Tabs. It will contain a list of tabs
 * and a display (JPanel). When a tab is selected, the JPanel "display" will display the content
 * associated with that tab.
 *
 * <p>How to use these tabs:
 *
 * <ol>
 *   <li>1 - Create displays (JPanels) for each tab
 *   <li>2 - Create an empty JPanel to serve as the group's display
 *   <li>3 - Create a new MaterialGroup, passing the panel in step 2 as a param
 *   <li>4 - Create new tabs, passing the group in step 3 and one of the panels in step 1 as params
 *   <li>5 - Add the tabs to the group using the MaterialTabGroup#addTab method
 *   <li>6 - Select one of the tabs using the MaterialTab#select method
 * </ol>
 *
 * @author Psikoi
 */
public class FasterMaterialTabGroup extends JPanel {

  /* The panel on which the content tab's content will be displayed on. */
  private final JPanel display;
  /* A list of all the tabs contained in this group. */
  private final List<FasterMaterialTab> tabs = new ArrayList<>();
  private final List<FasterMaterialTab> endTabs = new ArrayList<>();
  private final transient DudeWheresMyStuffPlugin plugin;
  private final GridBagLayout gridBagLayout;

  FasterMaterialTabGroup(JPanel display, DudeWheresMyStuffPlugin plugin) {
    this.display = display;
    this.plugin = plugin;
    if (display != null) {
      this.display.setLayout(new BorderLayout());
    }
    this.gridBagLayout = new GridBagLayout();
    setLayout(gridBagLayout);
    setOpaque(false);
  }

  public void addTab(FasterMaterialTab tab) {
    tabs.add(tab);
    add(tab);
  }

  public void addTabToEnd(FasterMaterialTab tab) {
    endTabs.add(tab);
    this.addTab(tab);
  }

  public void resetGrid() {
    GridBagConstraints constraints = new GridBagConstraints();
    // reduce padding if there are 6 tabs (f2p) so that kofi is distinguished from the other tabs
    int padding = tabs.stream().filter(Component::isVisible).count() == 6 ? 6 : 8;

    int visibleTabs = 0;
    for (FasterMaterialTab tab : tabs) {
      if (!tab.isVisible()) {
        continue;
      }

      constraints.anchor =
          endTabs.contains(tab) ? GridBagConstraints.EAST : GridBagConstraints.WEST;
      constraints.gridx = endTabs.contains(tab) ? 5 : visibleTabs % 6;
      constraints.gridy = visibleTabs / 6;
      constraints.weightx = endTabs.contains(tab) ? 1 : 0.1;
      constraints.insets = new Insets(constraints.gridy == 0 ? 0 : padding,
          constraints.gridx == 0 ? 0 : padding, 0, 0);
      gridBagLayout.setConstraints(tab, constraints);

      visibleTabs++;
    }
  }

  /**
   * Selects a tab from the group, and sets the display's content to the tab's associated content.
   *
   * @param selectedTab - The tab to select
   */
  public void select(FasterMaterialTab selectedTab) {
    if (!tabs.contains(selectedTab)) {
      return;
    }

    // If the OnTabSelected returned false, exit the method to prevent tab switching
    if (!selectedTab.select()) {
      return;
    }

    // If the display is available, switch from the old to the new display
    if (display != null) {
      EnhancedSwingUtilities.fastRemoveAll(display, plugin.getChatMessageManager());
      display.add(selectedTab.getContent());
      display.revalidate();
      display.repaint();
    }

    // Unselected all other tabs
    for (FasterMaterialTab tab : tabs) {
      if (!tab.equals(selectedTab)) {
        tab.unselect();
      }
    }
  }
}

package dev.thource.runelite.dudewheresmystuff;

import java.awt.image.BufferedImage;
import javax.annotation.Nullable;
import javax.swing.ImageIcon;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.QuantityFormatter;

class ItemBox extends JPanel {

  private static final String HTML_CLOSE_TAG = "</html>";

  @Getter private int itemId = -1;
  @Getter private long itemQuantity = 1;

  ItemBox(
      DudeWheresMyStuffPlugin plugin, @Nullable ItemStack itemStack, boolean displayEmptyStacks) {
    setBackground(ColorScheme.DARKER_GRAY_COLOR);

    if (itemStack != null
        && itemStack.getId() != -1
        && (displayEmptyStacks || itemStack.getQuantity() != 0)) {
      itemId = itemStack.getId();
      itemQuantity = itemStack.getQuantity();

      final ItemImageLabel imageLabel = new ItemImageLabel(plugin);
      imageLabel.setToolTipText(buildToolTip(itemStack));
      imageLabel.setVerticalAlignment(SwingConstants.CENTER);
      imageLabel.setHorizontalAlignment(SwingConstants.CENTER);

      imageLabel.setItemStack(itemStack);

      if (itemStack.getSpriteId() != -1) {
        plugin.getSpriteManager().getSpriteAsync(itemStack.getSpriteId(), 0, (image) -> {
          if (image != null) {
            var spriteImage = new BufferedImage(36, 32, BufferedImage.TYPE_INT_ARGB);
            var spriteGraphics = spriteImage.createGraphics();
            spriteGraphics.drawImage(image, (spriteImage.getWidth() - image.getWidth()) / 2, (spriteImage.getHeight() - image.getHeight()) / 2, null);
            spriteGraphics.dispose();

            imageLabel.setIcon(new ImageIcon(spriteImage));
          }
        });
      } else {
        AsyncBufferedImage itemImage =
            plugin
                .getItemManager()
                .getImage(
                    itemStack.getId(),
                    (int) Math.min(itemStack.getQuantity(), Integer.MAX_VALUE),
                    itemStack.isStackable() || itemStack.getQuantity() > 1);
        itemImage.addTo(imageLabel);
      }

      add(imageLabel);
    }
  }

  // Suppress string literal warnings, defining a constant for "</html>" is dumb
  private static String buildToolTip(ItemStack item) {
    final String name = item.getName();
    final long quantity = item.getQuantity();
    final long gePrice = item.getTotalGePrice();
    final long haPrice = item.getTotalHaPrice();
    final StringBuilder sb = new StringBuilder("<html>");
    sb.append(name).append(" x ").append(QuantityFormatter.formatNumber(quantity));
    if (item.getId() == ItemID.COINS) {
      sb.append(HTML_CLOSE_TAG);
      return sb.toString();
    }

    if (gePrice > 0) {
      sb.append("<br>GE: ").append(QuantityFormatter.quantityToStackSize(gePrice));
      if (quantity > 1) {
        sb.append(" (")
            .append(QuantityFormatter.quantityToStackSize(item.getGePrice()))
            .append(" ea)");
      }
    }

    if (item.getId() == ItemID.PLATINUM) {
      sb.append(HTML_CLOSE_TAG);
      return sb.toString();
    }

    if (haPrice > 0) {
      sb.append("<br>HA: ").append(QuantityFormatter.quantityToStackSize(haPrice));
      if (quantity > 1) {
        sb.append(" (")
            .append(QuantityFormatter.quantityToStackSize(item.getHaPrice()))
            .append(" ea)");
      }
    }
    sb.append(HTML_CLOSE_TAG);
    return sb.toString();
  }
}

package dev.thource.runelite.dudewheresmystuff;

class SearchStorageManager extends StorageManager<StorageType, Storage<StorageType>> {

  protected SearchStorageManager(DudeWheresMyStuffPlugin plugin) {
    super(plugin);
  }

  @Override
  public void load(String profileKey) {
    // No loading necessary
  }

  @Override
  public void save(String profileKey) {
    // No saving necessary
  }

  @Override
  public String getConfigKey() {
    return null;
  }

}

/*
 * Copyright (c) 2022, Thource <https://github.com/Thource>
 * Copyright (c) 2018, Abex
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package dev.thource.runelite.dudewheresmystuff;

import dev.thource.runelite.dudewheresmystuff.carryable.CarryableStorageTabPanel;
import dev.thource.runelite.dudewheresmystuff.coins.CoinsStorageTabPanel;
import dev.thource.runelite.dudewheresmystuff.death.DeathStorageTabPanel;
import dev.thource.runelite.dudewheresmystuff.minigames.MinigamesStorageTabPanel;
import dev.thource.runelite.dudewheresmystuff.playerownedhouse.PlayerOwnedHouseStorageTabPanel;
import dev.thource.runelite.dudewheresmystuff.stash.StashStorageTabPanel;
import dev.thource.runelite.dudewheresmystuff.world.WorldStorageTabPanel;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Image;
import java.awt.event.ItemListener;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.EnumMap;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;
import javax.swing.ImageIcon;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

/**
 * DudeWheresMyStuffPanel is responsible for hosting all the StorageTabPanels, so that the player
 * can see their data.
 */
public class DudeWheresMyStuffPanel extends JPanel {

  private static final ImageIcon SEARCH_ICON;

  static {
    SEARCH_ICON =
        new ImageIcon(
            ImageUtil.loadImageResource(
                DudeWheresMyStuffPlugin.class, "/net/runelite/client/ui/components/search.png"));
  }

  private final EnumMap<Tab, FasterMaterialTab> uiTabs = new EnumMap<>(Tab.class);
  private final OverviewTabPanel overviewTab;
  private final EnumMap<Tab, StorageTabPanel<?, ?, ?>> storageTabPanelMap =
      new EnumMap<>(Tab.class);
  private final transient ItemManager itemManager;
  /* This is the panel the tabs' respective panels will be displayed on. */
  private final JPanel display = new JPanel();
  private final FasterMaterialTabGroup tabGroup;
  private final boolean previewMode;
  private final transient StorageManagerManager storageManagerManager;
  private final transient DudeWheresMyStuffPlugin plugin;
  @Setter private boolean active;
  @Getter private String displayName = "";
  @Nullable private TabContentPanel activeTabPanel = null;

  DudeWheresMyStuffPanel(
      DudeWheresMyStuffPlugin plugin,
      ConfigManager configManager,
      StorageManagerManager storageManagerManager,
      boolean previewMode) {
    super();

    this.plugin = plugin;
    this.itemManager = plugin.getItemManager();
    this.storageManagerManager = storageManagerManager;
    this.previewMode = previewMode;
    this.tabGroup = new FasterMaterialTabGroup(display, plugin);

    setLayout(new BorderLayout());
    setBorder(new EmptyBorder(0, 0, 0, 0));
    setBackground(ColorScheme.DARK_GRAY_COLOR);

    display.setBorder(new EmptyBorder(10, 10, 8, 10));
    tabGroup.setBorder(new EmptyBorder(10, 10, 0, 10));

    add(tabGroup, BorderLayout.NORTH);
    add(display, BorderLayout.CENTER);

    overviewTab =
        new OverviewTabPanel(
            plugin,
            this,
            itemManager,
            configManager,
            storageManagerManager,
            plugin.isDeveloperMode());
    addTab(Tab.OVERVIEW, overviewTab);

    addTab(
        Tab.DEATH,
        new DeathStorageTabPanel(plugin, storageManagerManager.getDeathStorageManager()));
    addTab(
        Tab.COINS,
        new CoinsStorageTabPanel(plugin, storageManagerManager.getCoinsStorageManager()));
    addTab(
        Tab.CARRYABLE_STORAGE,
        new CarryableStorageTabPanel(plugin, storageManagerManager.getCarryableStorageManager()));
    addTab(
        Tab.STASH_UNITS,
        new StashStorageTabPanel(plugin, storageManagerManager.getStashStorageManager()));
    addTab(
        Tab.POH_STORAGE,
        new PlayerOwnedHouseStorageTabPanel(
            plugin, storageManagerManager.getPlayerOwnedHouseStorageManager()));
    addTab(
        Tab.WORLD,
        new WorldStorageTabPanel(plugin, storageManagerManager.getWorldStorageManager()));
    addTab(
        Tab.MINIGAMES,
        new MinigamesStorageTabPanel(plugin, storageManagerManager.getMinigamesStorageManager()));

    addTab(Tab.SEARCH, new SearchTabPanel(plugin, storageManagerManager));

    addTab(Tab.DEBUG, new DebugPanel(plugin));

    FasterMaterialTab donateTab = new FasterMaterialTab(
        new ImageIcon(ImageUtil.loadImageResource(DudeWheresMyStuffPlugin.class, "kofi.png")),
        tabGroup, null);
    donateTab.setPreferredSize(new Dimension(30, 27));
    donateTab.setName("Support me");
    donateTab.setToolTipText("Buy me a coffee? :)");
    donateTab.setOnSelectEvent(() -> {
      LinkBrowser.browse("https://ko-fi.com/thource");
      return false;
    });
    tabGroup.addTabToEnd(donateTab);

    for (Tab tab : Tab.TABS) {
      if (tab == Tab.OVERVIEW) {
        continue;
      }

      Optional.ofNullable(uiTabs.get(tab)).ifPresent(materialTab -> materialTab.setVisible(false));
    }
    tabGroup.resetGrid();
  }

  void setItemSortMode(ItemSortMode itemSortMode) {
    storageTabPanelMap.forEach((tab, tabPanel) -> {
      if (tab == Tab.OVERVIEW) {
        return;
      }

      plugin.getClientThread().invoke(() -> tabPanel.getStorageManager().getStorages().stream()
          .map(Storage::getStoragePanel)
          .filter(Objects::nonNull)
          .forEach(panel -> {
            panel.refreshItems();
            SwingUtilities.invokeLater(panel::update);
          }));

      JComboBox<ItemSortMode> sortDropdown = tabPanel.getSortItemsDropdown();
      final ItemListener[] itemListeners = sortDropdown.getItemListeners();

      // We need to remove and re-add the item listeners to avoid recursion
      Arrays.stream(itemListeners).forEach(sortDropdown::removeItemListener);
      sortDropdown.setSelectedItem(itemSortMode);
      Arrays.stream(itemListeners).forEach(sortDropdown::addItemListener);
    });

    ((SearchTabPanel) storageTabPanelMap.get(Tab.SEARCH)).refreshItemSortMode();
  }

  private void addTab(Tab tab, TabContentPanel tabContentPanel) {
    if (tabContentPanel instanceof StorageTabPanel) {
      storageTabPanelMap.put(tab, (StorageTabPanel<?, ?, ?>) tabContentPanel);
    }

    JPanel wrapped = new JPanel(new BorderLayout());
    wrapped.add(tabContentPanel, BorderLayout.NORTH);
    wrapped.setBackground(ColorScheme.DARK_GRAY_COLOR);

    JScrollPane scrollPane = new JScrollPane(new ScrollableContainer(wrapped));
    scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
    scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(16, 0));
    scrollPane.getVerticalScrollBar().setBorder(new EmptyBorder(0, 9, 0, 0));
    scrollPane.getVerticalScrollBar().setUnitIncrement(21);
    scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);

    // Use a placeholder icon until the async image gets loaded
    FasterMaterialTab materialTab = new FasterMaterialTab(new ImageIcon(), tabGroup, scrollPane);
    materialTab.setPreferredSize(new Dimension(30, 27));
    materialTab.setName(tab.getName());
    materialTab.setToolTipText(tab.getName());

    if (tab == Tab.SEARCH) {
      materialTab.setIcon(SEARCH_ICON);
    } else {
      AsyncBufferedImage icon = itemManager.getImage(tab.getItemId(), tab.getItemQuantity(), false);
      Runnable resize =
          () -> {
            BufferedImage subIcon = icon.getSubimage(0, 0, 32, 32);
            materialTab.setIcon(
                new ImageIcon(subIcon.getScaledInstance(24, 24, Image.SCALE_SMOOTH)));
          };
      icon.onLoaded(resize);
      resize.run();
    }

    materialTab.setOnSelectEvent(
        () -> {
          activeTabPanel = tabContentPanel;
          softUpdate();
          return true;
        });

    uiTabs.put(tab, materialTab);
    tabGroup.addTab(materialTab);

    if (tab == Tab.OVERVIEW) {
      tabGroup.select(materialTab);
    }
  }

  void switchTab(Tab tab) {
    tabGroup.select(uiTabs.get(tab));
  }

  void softUpdate() {
    if (!active || activeTabPanel == null) {
      return;
    }

    activeTabPanel.softUpdate();
  }

  void setDisplayName(String name) {
    displayName = name;
    storageManagerManager.setDisplayName(name);
  }

  void reset() {
    SwingUtilities.invokeLater(
        () -> {
          logOut();
          softUpdate();
        });
  }

  void logOut() {
    uiTabs.forEach(
        (tab, materialTab) -> {
          if (tab == Tab.OVERVIEW) {
            return;
          }

          materialTab.setVisible(false);
        });

    overviewTab
        .getOverviews()
        .forEach(
            (tab, overviewItemPanel) -> {
              if (tab == Tab.OVERVIEW) {
                return;
              }

              overviewItemPanel.setVisible(false);
            });

    uiTabs.get(Tab.DEBUG).setVisible(plugin.isDeveloperMode());
    ((SearchTabPanel) storageTabPanelMap.get(Tab.SEARCH)).getSearchBar().setText("");
    switchTab(Tab.OVERVIEW);
    tabGroup.resetGrid();

    setDisplayName("");
  }

  void logIn(boolean isMember, int accountType, String displayName) {
    storageTabPanelMap.forEach(
        (tab, storageTabPanel) -> {
          StorageManager<?, ?> storageManager = storageTabPanel.storageManager;
          if (storageManager != null) {
            storageManager.getStorages().forEach(storage -> storage.disable(isMember, accountType));

            if (tab != Tab.DEATH
                && storageManager.getStorages().stream().noneMatch(Storage::isEnabled)) {
              storageManager.disable();
              return;
            }
          }

          Optional.ofNullable(uiTabs.get(tab))
              .ifPresent(materialTab -> materialTab.setVisible(true));
          Optional.ofNullable(overviewTab.getOverviews().get(tab))
              .ifPresent(overviewItemPanel -> overviewItemPanel.setVisible(true));
        });
    uiTabs.get(Tab.SEARCH).setVisible(true);
    uiTabs.get(Tab.DEBUG).setVisible(plugin.isDeveloperMode());
    tabGroup.resetGrid();
    setDisplayName(displayName);
  }

  public boolean isPreviewPanel() {
    return previewMode;
  }

  void reorderStoragePanels() {
    storageManagerManager
        .getStorageManagers()
        .forEach(storageManager -> storageManager.getStorageTabPanel().reorderStoragePanels());
  }
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package dev.thource.runelite.dudewheresmystuff;

import java.awt.Dimension;
import javax.swing.JPanel;
import net.runelite.client.ui.PluginPanel;

class FixedWidthPanel extends JPanel {
  @Override
  public Dimension getPreferredSize() {
    return new Dimension(PluginPanel.PANEL_WIDTH, super.getPreferredSize().height);
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import net.runelite.api.gameval.InterfaceID.Objectbox;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;

/** Nest is responsible for tracking what the player has stored in the Nest (nice). */
public class Nest extends WorldStorage {
  protected Nest(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.NEST, plugin);
  }

  private int getConvertedItemId(int itemId) {
    switch (itemId) {
      case ItemID.TOA_LOOT_POO:
        return ItemID.VARLAMORE_NASTY_TOKEN_1;
      case ItemID.RAW_CHICKEN:
        return ItemID.COOKED_CHICKEN;
      case ItemID.GNOME_SPICE:
        return ItemID.IRON_PICKAXE;
      case ItemID.ROPE:
        return ItemID.LEATHER_GLOVES;
      case ItemID.DRAGON_CLAWS:
        return ItemID.EGG;
      case ItemID.RUNE_PLATELEGS:
        return ItemID.RUNITE_BAR;
      case ItemID.ADAMANT_SCIMITAR:
        return ItemID.CAKE;
      case ItemID.XBOWS_CROSSBOW_LIMBS_MITHRIL:
        return ItemID.XBOWS_CROSSBOW_MITHRIL;
      case ItemID.STEEL_DAGGER:
        return ItemID.SNELM_ROUND_YELLOW;
      case ItemID.KWUARMVIAL:
        return ItemID.WEAPON_POISON;
      default:
    }

    return itemId;
  }

  @Override
  public boolean onGameTick() {
    Widget textWidget = plugin.getClient().getWidget(Objectbox.TEXT);
    if (textWidget == null) {
      return false;
    }

    var isDeposit = textWidget.getText().equals("You place your item in the nest.");
    var isRetrieval = textWidget.getText().equals("You retrieve your item from the nest.");
    if (!isDeposit && !isRetrieval) {
      return false;
    }

    Widget itemWidget = plugin.getClient().getWidget(Objectbox.ITEM);
    if (itemWidget == null) {
      return false;
    }

    updateLastUpdated();

    var itemId = getConvertedItemId(itemWidget.getItemId());
    if (isDeposit) {
      if (items.isEmpty() || items.get(0).getId() != itemId) {
        items.clear();
        items.add(new ItemStack(itemId, 1, plugin));

        return true;
      }
    } else if (!items.isEmpty()) {
      items.clear();

      return true;
    }

    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/**
 * ForestryShop is responsible for tracking how many logs the player has stored in the forestry
 * shop.
 */
public class ForestryShop extends WorldStorage {

  private final Pattern[] checkPatterns = {
      Pattern.compile("Oak\\s+logs:\\s+(\\d+)"),
      Pattern.compile("Willow\\s+logs:\\s+(\\d+)"),
      Pattern.compile("Yew\\s+logs:\\s+(\\d+)"),
      Pattern.compile("Maple\\s+logs:\\s+(\\d+)"),
      Pattern.compile("Magic\\s+logs:\\s+(\\d+)"),
      Pattern.compile("Teak\\s+logs:\\s+(\\d+)"),
      Pattern.compile("Mahogany\\s+logs:\\s+(\\d+)"),
      Pattern.compile("Redwood\\s+logs:\\s+(\\d+)"),
      Pattern.compile("Arctic\\s+pine\\s+logs:\\s+(\\d+)")
  };

  protected ForestryShop(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.FORESTRY_SHOP, plugin);

    hasStaticItems = true;

    items.add(new ItemStack(ItemID.OAK_LOGS, plugin));
    items.add(new ItemStack(ItemID.WILLOW_LOGS, plugin));
    items.add(new ItemStack(ItemID.YEW_LOGS, plugin));
    items.add(new ItemStack(ItemID.MAPLE_LOGS, plugin));
    items.add(new ItemStack(ItemID.MAGIC_LOGS, plugin));
    items.add(new ItemStack(ItemID.TEAK_LOGS, plugin));
    items.add(new ItemStack(ItemID.MAHOGANY_LOGS, plugin));
    items.add(new ItemStack(ItemID.REDWOOD_LOGS, plugin));
    items.add(new ItemStack(ItemID.ARCTIC_PINE_LOG, plugin));

    plugin.getClientThread().invokeLater(() -> items.forEach(ItemStack::stripPrices));
  }

  @Override
  public boolean onGameTick() {
    return checkForCheck();
  }

  private boolean checkForCheck() {
    Widget widget = plugin.getClient().getWidget(229, 1);
    if (widget == null || !widget.getText().startsWith("Your log storage contains:")) {
      return false;
    }

    String widgetText = widget.getText().replace("<br>", " ").replace(",", "");

    boolean updated = false;
    for (int i = 0; i < checkPatterns.length; i++) {
      Pattern checkPattern = checkPatterns[i];
      Matcher matcher = checkPattern.matcher(widgetText);
      int quantity = 0;
      if (matcher.find()) {
        quantity = NumberUtils.toInt(matcher.group(1), 0);
      }

      ItemStack itemStack = items.get(i);
      if (itemStack.getQuantity() != quantity) {
        itemStack.setQuantity(quantity);
        updated = true;
      }
    }

    if (updated) {
      updateLastUpdated();
    }

    return updated;
  }

  @Override
  public boolean isWithdrawable() {
    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

/**
 * BlastFurnace is responsible for tracking how many ores/bars the player has stored at Blast
 * Furnace.
 */
public class BlastFurnace extends WorldStorage {

  protected BlastFurnace(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.BLAST_FURNACE, plugin);

    hasStaticItems = true;
    varbits =
        new int[] {
          VarbitID.BLAST_FURNACE_COPPER_ORE,
          VarbitID.BLAST_FURNACE_TIN_ORE,
          VarbitID.BLAST_FURNACE_IRON_ORE,
          VarbitID.BLAST_FURNACE_COAL,
          VarbitID.BLAST_FURNACE_MITHRIL_ORE,
          VarbitID.BLAST_FURNACE_ADAMANTITE_ORE,
          VarbitID.BLAST_FURNACE_RUNITE_ORE,
          VarbitID.BLAST_FURNACE_SILVER_ORE,
          VarbitID.BLAST_FURNACE_GOLD_ORE,
          VarbitID.BLAST_FURNACE_BRONZE_BARS,
          VarbitID.BLAST_FURNACE_IRON_BARS,
          VarbitID.BLAST_FURNACE_STEEL_BARS,
          VarbitID.BLAST_FURNACE_MITHRIL_BARS,
          VarbitID.BLAST_FURNACE_ADAMANTITE_BARS,
          VarbitID.BLAST_FURNACE_RUNITE_BARS,
          VarbitID.BLAST_FURNACE_SILVER_BARS,
          VarbitID.BLAST_FURNACE_GOLD_BARS
        };

    items.add(new ItemStack(ItemID.COPPER_ORE, plugin));
    items.add(new ItemStack(ItemID.TIN_ORE, plugin));
    items.add(new ItemStack(ItemID.IRON_ORE, plugin));
    items.add(new ItemStack(ItemID.COAL, plugin));
    items.add(new ItemStack(ItemID.MITHRIL_ORE, plugin));
    items.add(new ItemStack(ItemID.ADAMANTITE_ORE, plugin));
    items.add(new ItemStack(ItemID.RUNITE_ORE, plugin));
    items.add(new ItemStack(ItemID.SILVER_ORE, plugin));
    items.add(new ItemStack(ItemID.GOLD_ORE, plugin));
    items.add(new ItemStack(ItemID.BRONZE_BAR, plugin));
    items.add(new ItemStack(ItemID.IRON_BAR, plugin));
    items.add(new ItemStack(ItemID.STEEL_BAR, plugin));
    items.add(new ItemStack(ItemID.MITHRIL_BAR, plugin));
    items.add(new ItemStack(ItemID.ADAMANTITE_BAR, plugin));
    items.add(new ItemStack(ItemID.RUNITE_BAR, plugin));
    items.add(new ItemStack(ItemID.SILVER_BAR, plugin));
    items.add(new ItemStack(ItemID.GOLD_BAR, plugin));
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemContainerWatcher;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.HashMap;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;

/** PotionStorage is responsible for tracking what the player has stored in their potion storage. */
@Slf4j
public class PotionStorage extends WorldStorage {

  @RequiredArgsConstructor
  @Getter
  private static class PotionDoseInfo {
    private final int doses;
    private final ItemStack itemStack;
  }

  private final ItemStack vials;
  private final HashMap<String, ItemStack> potionMap = new HashMap<>();
  @Getter private final HashMap<Integer, PotionDoseInfo> doseMap = new HashMap<>();

  protected PotionStorage(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.POTION_STORAGE, plugin);

    hasStaticItems = true;

    vials = new ItemStack(ItemID.VIAL_EMPTY, plugin);
    items.add(vials);
    doseMap.put(ItemID.VIAL_EMPTY, new PotionDoseInfo(0, vials));

    // regular potions
    addPotion(
        "Agility potion",
        ItemID._1DOSE1AGILITY,
        ItemID._2DOSE1AGILITY,
        ItemID._3DOSE1AGILITY,
        ItemID._4DOSE1AGILITY);
    addPotion(
        "Ancient brew",
        ItemID._1DOSEANCIENTBREW,
        ItemID._2DOSEANCIENTBREW,
        ItemID._3DOSEANCIENTBREW,
        ItemID._4DOSEANCIENTBREW);
    addPotion(
        "Anti-venom", ItemID.ANTIVENOM1, ItemID.ANTIVENOM2, ItemID.ANTIVENOM3, ItemID.ANTIVENOM4);
    addPotion(
        "Anti-venom+",
        ItemID.ANTIVENOM_1,
        ItemID.ANTIVENOM_2,
        ItemID.ANTIVENOM_3,
        ItemID.ANTIVENOM_4);
    addPotion(
        "Antidote+", ItemID.ANTIDOTE_1, ItemID.ANTIDOTE_2, ItemID.ANTIDOTE_3, ItemID.ANTIDOTE_4);
    addPotion(
        "Antidote++",
        ItemID.ANTIDOTE__1,
        ItemID.ANTIDOTE__2,
        ItemID.ANTIDOTE__3,
        ItemID.ANTIDOTE__4);
    addPotion(
        "Antifire potion",
        ItemID._1DOSE1ANTIDRAGON,
        ItemID._2DOSE1ANTIDRAGON,
        ItemID._3DOSE1ANTIDRAGON,
        ItemID._4DOSE1ANTIDRAGON);
    addPotion(
        "Antipoison",
        ItemID._1DOSEANTIPOISON,
        ItemID._2DOSEANTIPOISON,
        ItemID._3DOSEANTIPOISON,
        ItemID._4DOSEANTIPOISON);
    addPotion(
        "Attack potion",
        ItemID._1DOSE1ATTACK,
        ItemID._2DOSE1ATTACK,
        ItemID._3DOSE1ATTACK,
        ItemID._4DOSE1ATTACK);
    addPotion(
        "Battlemage potion",
        ItemID._1DOSEBATTLEMAGE,
        ItemID._2DOSEBATTLEMAGE,
        ItemID._3DOSEBATTLEMAGE,
        ItemID._4DOSEBATTLEMAGE);
    addPotion(
        "Bastion potion",
        ItemID._1DOSEBASTION,
        ItemID._2DOSEBASTION,
        ItemID._3DOSEBASTION,
        ItemID._4DOSEBASTION);
    addPotion(
        "Blighted super restore",
        ItemID.BLIGHTED_1DOSE2RESTORE,
        ItemID.BLIGHTED_2DOSE2RESTORE,
        ItemID.BLIGHTED_3DOSE2RESTORE,
        ItemID.BLIGHTED_4DOSE2RESTORE);
    addPotion(
        "Combat potion",
        ItemID._1DOSECOMBAT,
        ItemID._2DOSECOMBAT,
        ItemID._3DOSECOMBAT,
        ItemID._4DOSECOMBAT);
    addPotion(
        "Compost potion",
        ItemID.SUPERCOMPOST_POTION_1,
        ItemID.SUPERCOMPOST_POTION_2,
        ItemID.SUPERCOMPOST_POTION_3,
        ItemID.SUPERCOMPOST_POTION_4);
    addPotion(
        "Defence potion",
        ItemID._1DOSE1DEFENSE,
        ItemID._2DOSE1DEFENSE,
        ItemID._3DOSE1DEFENSE,
        ItemID._4DOSE1DEFENSE);
    addPotion(
        "Divine bastion",
        ItemID._1DOSEDIVINEBASTION,
        ItemID._2DOSEDIVINEBASTION,
        ItemID._3DOSEDIVINEBASTION,
        ItemID._4DOSEDIVINEBASTION);
    addPotion(
        "Divine battlemage",
        ItemID._1DOSEDIVINEBATTLEMAGE,
        ItemID._2DOSEDIVINEBATTLEMAGE,
        ItemID._3DOSEDIVINEBATTLEMAGE,
        ItemID._4DOSEDIVINEBATTLEMAGE);
    addPotion(
        "Divine magic",
        ItemID._1DOSEDIVINEMAGIC,
        ItemID._2DOSEDIVINEMAGIC,
        ItemID._3DOSEDIVINEMAGIC,
        ItemID._4DOSEDIVINEMAGIC);
    addPotion(
        "Divine ranging",
        ItemID._1DOSEDIVINERANGE,
        ItemID._2DOSEDIVINERANGE,
        ItemID._3DOSEDIVINERANGE,
        ItemID._4DOSEDIVINERANGE);
    addPotion(
        "Divine super attack",
        ItemID._1DOSEDIVINEATTACK,
        ItemID._2DOSEDIVINEATTACK,
        ItemID._3DOSEDIVINEATTACK,
        ItemID._4DOSEDIVINEATTACK);
    addPotion(
        "Divine super combat",
        ItemID._1DOSEDIVINECOMBAT,
        ItemID._2DOSEDIVINECOMBAT,
        ItemID._3DOSEDIVINECOMBAT,
        ItemID._4DOSEDIVINECOMBAT);
    addPotion(
        "Divine super defence",
        ItemID._1DOSEDIVINEDEFENCE,
        ItemID._2DOSEDIVINEDEFENCE,
        ItemID._3DOSEDIVINEDEFENCE,
        ItemID._4DOSEDIVINEDEFENCE);
    addPotion(
        "Divine super strength",
        ItemID._1DOSEDIVINESTRENGTH,
        ItemID._2DOSEDIVINESTRENGTH,
        ItemID._3DOSEDIVINESTRENGTH,
        ItemID._4DOSEDIVINESTRENGTH);
    addPotion(
        "Energy potion",
        ItemID._1DOSE1ENERGY,
        ItemID._2DOSE1ENERGY,
        ItemID._3DOSE1ENERGY,
        ItemID._4DOSE1ENERGY);
    addPotion(
        "Extended anti-venom+",
        ItemID.EXTENDED_ANTIVENOM_1,
        ItemID.EXTENDED_ANTIVENOM_2,
        ItemID.EXTENDED_ANTIVENOM_3,
        ItemID.EXTENDED_ANTIVENOM_4);
    addPotion(
        "Extended antifire",
        ItemID._1DOSE2ANTIDRAGON,
        ItemID._2DOSE2ANTIDRAGON,
        ItemID._3DOSE2ANTIDRAGON,
        ItemID._4DOSE2ANTIDRAGON);
    addPotion(
        "Extended super antifire",
        ItemID._1DOSE4ANTIDRAGON,
        ItemID._2DOSE4ANTIDRAGON,
        ItemID._3DOSE4ANTIDRAGON,
        ItemID._4DOSE4ANTIDRAGON);
    addPotion(
        "Fishing potion",
        ItemID._1DOSEFISHERSPOTION,
        ItemID._2DOSEFISHERSPOTION,
        ItemID._3DOSEFISHERSPOTION,
        ItemID._4DOSEFISHERSPOTION);
    addPotion(
        "Forgotten brew",
        ItemID._1DOSEFORGOTTENBREW,
        ItemID._2DOSEFORGOTTENBREW,
        ItemID._3DOSEFORGOTTENBREW,
        ItemID._4DOSEFORGOTTENBREW);
    addPotion(
        "Goading potion",
        ItemID._1DOSEGOADING,
        ItemID._2DOSEGOADING,
        ItemID._3DOSEGOADING,
        ItemID._4DOSEGOADING);
    addPotion(
        "Guthix balance",
        ItemID.BURGH_GUTHIX_BALANCE_1,
        ItemID.BURGH_GUTHIX_BALANCE_2,
        ItemID.BURGH_GUTHIX_BALANCE_3,
        ItemID.BURGH_GUTHIX_BALANCE_4);
    addPotion(
        "Hunter potion",
        ItemID._1DOSEHUNTING,
        ItemID._2DOSEHUNTING,
        ItemID._3DOSEHUNTING,
        ItemID._4DOSEHUNTING);
    addPotion(
        "Magic essence",
        ItemID._1DOSEMAGICESS,
        ItemID._2DOSEMAGICESS,
        ItemID._3DOSEMAGICESS,
        ItemID._4DOSEMAGICESS);
    addPotion(
        "Magic potion",
        ItemID._1DOSE1MAGIC,
        ItemID._2DOSE1MAGIC,
        ItemID._3DOSE1MAGIC,
        ItemID._4DOSE1MAGIC);
    addPotion(
        "Menaphite remedy",
        ItemID._1DOSESTATRENEWAL,
        ItemID._2DOSESTATRENEWAL,
        ItemID._3DOSESTATRENEWAL,
        ItemID._4DOSESTATRENEWAL);
    addPotion(
        "Prayer potion",
        ItemID._1DOSEPRAYERRESTORE,
        ItemID._2DOSEPRAYERRESTORE,
        ItemID._3DOSEPRAYERRESTORE,
        ItemID._4DOSEPRAYERRESTORE);
    addPotion(
        "Prayer regeneration",
        ItemID._1DOSE1PRAYER_REGENERATION,
        ItemID._2DOSE1PRAYER_REGENERATION,
        ItemID._3DOSE1PRAYER_REGENERATION,
        ItemID._4DOSE1PRAYER_REGENERATION);
    addPotion(
        "Ranging potion",
        ItemID._1DOSERANGERSPOTION,
        ItemID._2DOSERANGERSPOTION,
        ItemID._3DOSERANGERSPOTION,
        ItemID._4DOSERANGERSPOTION);
    addPotion(
        "Relicym's balm",
        ItemID.RELICYMS_BALM1,
        ItemID.RELICYMS_BALM2,
        ItemID.RELICYMS_BALM3,
        ItemID.RELICYMS_BALM4);
    addPotion(
        "Restore potion",
        ItemID._1DOSESTATRESTORE,
        ItemID._2DOSESTATRESTORE,
        ItemID._3DOSESTATRESTORE,
        ItemID._4DOSESTATRESTORE);
    addPotion(
        "Sanfew serum",
        ItemID.SANFEW_SALVE_1_DOSE,
        ItemID.SANFEW_SALVE_2_DOSE,
        ItemID.SANFEW_SALVE_3_DOSE,
        ItemID.SANFEW_SALVE_4_DOSE);
    addPotion(
        "Saradomin brew",
        ItemID._1DOSEPOTIONOFSARADOMIN,
        ItemID._2DOSEPOTIONOFSARADOMIN,
        ItemID._3DOSEPOTIONOFSARADOMIN,
        ItemID._4DOSEPOTIONOFSARADOMIN);
    addPotion(
        "Serum 207",
        ItemID.MORT_SERUM1,
        ItemID.MORT_SERUM2,
        ItemID.MORT_SERUM3,
        ItemID.MORT_SERUM4);
    addPotion(
        "Stamina potion",
        ItemID._1DOSESTAMINA,
        ItemID._2DOSESTAMINA,
        ItemID._3DOSESTAMINA,
        ItemID._4DOSESTAMINA);
    addPotion(
        "Strength potion",
        ItemID._1DOSE1STRENGTH,
        ItemID._2DOSE1STRENGTH,
        ItemID._3DOSE1STRENGTH,
        ItemID.STRENGTH4);
    addPotion(
        "Super antifire potion",
        ItemID._1DOSE3ANTIDRAGON,
        ItemID._2DOSE3ANTIDRAGON,
        ItemID._3DOSE3ANTIDRAGON,
        ItemID._4DOSE3ANTIDRAGON);
    addPotion(
        "Super attack",
        ItemID._1DOSE2ATTACK,
        ItemID._2DOSE2ATTACK,
        ItemID._3DOSE2ATTACK,
        ItemID._4DOSE2ATTACK);
    addPotion(
        "Super combat potion",
        ItemID._1DOSE2COMBAT,
        ItemID._2DOSE2COMBAT,
        ItemID._3DOSE2COMBAT,
        ItemID._4DOSE2COMBAT);
    addPotion(
        "Super defence",
        ItemID._1DOSE2DEFENSE,
        ItemID._2DOSE2DEFENSE,
        ItemID._3DOSE2DEFENSE,
        ItemID._4DOSE2DEFENSE);
    addPotion(
        "Super energy",
        ItemID._1DOSE2ENERGY,
        ItemID._2DOSE2ENERGY,
        ItemID._3DOSE2ENERGY,
        ItemID._4DOSE2ENERGY);
    addPotion(
        "Super restore",
        ItemID._1DOSE2RESTORE,
        ItemID._2DOSE2RESTORE,
        ItemID._3DOSE2RESTORE,
        ItemID._4DOSE2RESTORE);
    addPotion(
        "Super strength",
        ItemID._1DOSE2STRENGTH,
        ItemID._2DOSE2STRENGTH,
        ItemID._3DOSE2STRENGTH,
        ItemID._4DOSE2STRENGTH);
    addPotion(
        "Superantipoison",
        ItemID._1DOSE2ANTIPOISON,
        ItemID._2DOSE2ANTIPOISON,
        ItemID._3DOSE2ANTIPOISON,
        ItemID._4DOSE2ANTIPOISON);
    addPotion("Weapon poison", ItemID.WEAPON_POISON);
    addPotion("Weapon poison(+)", ItemID.WEAPON_POISON_);
    addPotion("Weapon poison(++)", ItemID.WEAPON_POISON__);
    addPotion(
        "Zamorak brew",
        ItemID._1DOSEPOTIONOFZAMORAK,
        ItemID._2DOSEPOTIONOFZAMORAK,
        ItemID._3DOSEPOTIONOFZAMORAK,
        ItemID._4DOSEPOTIONOFZAMORAK);

    // brutal potions
    addPotion("Agility mix", ItemID.BRUTAL_1DOSE1AGILITY, ItemID.BRUTAL_2DOSE1AGILITY);
    addPotion("Ancient mix", ItemID.BRUTAL_1DOSEANCIENTBREW, ItemID.BRUTAL_2DOSEANCIENTBREW);
    addPotion("Antifire mix", ItemID.BRUTAL_1DOSE1ANTIDRAGON, ItemID.BRUTAL_2DOSE1ANTIDRAGON);
    addPotion("Antipoison mix", ItemID.BRUTAL_1DOSEANTIPOISON, ItemID.BRUTAL_2DOSEANTIPOISON);
    addPotion("Antidote+ mix", ItemID.BRUTAL_ANTIDOTE_1, ItemID.BRUTAL_ANTIDOTE_2);
    addPotion("Attack mix", ItemID.BRUTAL_1DOSE1ATTACK, ItemID.BRUTAL_2DOSE1ATTACK);
    addPotion("Combat mix", ItemID.BRUTAL_1DOSECOMBAT, ItemID.BRUTAL_2DOSECOMBAT);
    addPotion("Defence mix", ItemID.BRUTAL_1DOSE1DEFENSE, ItemID.BRUTAL_2DOSE1DEFENSE);
    addPotion("Energy mix", ItemID.BRUTAL_1DOSE1ENERGY, ItemID.BRUTAL_2DOSE1ENERGY);
    addPotion(
        "Extended antifire mix", ItemID.BRUTAL_1DOSE2ANTIDRAGON, ItemID.BRUTAL_2DOSE2ANTIDRAGON);
    addPotion(
        "Ext. super antifire mix", ItemID.BRUTAL_1DOSE4ANTIDRAGON, ItemID.BRUTAL_2DOSE4ANTIDRAGON);
    addPotion("Fishing mix", ItemID.BRUTAL_1DOSEFISHERSPOTION, ItemID.BRUTAL_2DOSEFISHERSPOTION);
    addPotion("Hunting mix", ItemID.BRUTAL_1DOSE1HUNTING, ItemID.BRUTAL_2DOSE1HUNTING);
    addPotion("Magic essence mix", ItemID.BRUTAL_1DOSEMAGICESS, ItemID.BRUTAL_2DOSEMAGICESS);
    addPotion("Magic mix", ItemID.BRUTAL_1DOSE1MAGIC, ItemID.BRUTAL_2DOSE1MAGIC);
    addPotion("Prayer mix", ItemID.BRUTAL_1DOSEPRAYERRESTORE, ItemID.BRUTAL_2DOSEPRAYERRESTORE);
    addPotion("Ranging mix", ItemID.BRUTAL_1DOSERANGERSPOTION, ItemID.BRUTAL_2DOSERANGERSPOTION);
    addPotion("Restore mix", ItemID.BRUTAL_1DOSESTATRESTORE, ItemID.BRUTAL_2DOSESTATRESTORE);
    addPotion("Stamina mix", ItemID.BRUTAL_1DOSESTAMINA, ItemID.BRUTAL_2DOSESTAMINA);
    addPotion("Strength mix", ItemID.BRUTAL_1DOSE1STRENGTH, ItemID.BRUTAL_2DOSE1STRENGTH);
    addPotion("Super antifire mix", ItemID.BRUTAL_1DOSE3ANTIDRAGON, ItemID.BRUTAL_2DOSE3ANTIDRAGON);
    addPotion("Superattack mix", ItemID.BRUTAL_1DOSE2ATTACK, ItemID.BRUTAL_2DOSE2ATTACK);
    addPotion("Super def. mix", ItemID.BRUTAL_1DOSE2DEFENSE, ItemID.BRUTAL_2DOSE2DEFENSE);
    addPotion("Super energy mix", ItemID.BRUTAL_1DOSE2ENERGY, ItemID.BRUTAL_2DOSE2ENERGY);
    addPotion("Super restore mix", ItemID.BRUTAL_1DOSE2RESTORE, ItemID.BRUTAL_2DOSE2RESTORE);
    addPotion("Super str. mix", ItemID.BRUTAL_1DOSE2STRENGTH, ItemID.BRUTAL_2DOSE2STRENGTH);
    addPotion(
        "Anti-poison supermix", ItemID.BRUTAL_1DOSE2ANTIPOISON, ItemID.BRUTAL_2DOSE2ANTIPOISON);
    addPotion(
        "Zamorak mix", ItemID.BRUTAL_1DOSEPOTIONOFZAMORAK, ItemID.BRUTAL_2DOSEPOTIONOFZAMORAK);
    addPotion("Relicym's mix", ItemID.BRUTAL_RELICYMS_BALM1, ItemID.BRUTAL_RELICYMS_BALM2);

    // unfinished potions
    addPotion("Avantoe potion (unf)", ItemID.AVANTOEVIAL);
    addPotion("Cadantine blood potion (unf)", ItemID.CADANTINE_BLOODVIAL);
    addPotion("Cadantine potion (unf)", ItemID.CADANTINEVIAL);
    addPotion("Dwarf weed potion (unf)", ItemID.DWARFWEEDVIAL);
    addPotion("Guam potion (unf)", ItemID.GUAMVIAL);
    addPotion("Harralander potion (unf)", ItemID.HARRALANDERVIAL);
    addPotion("Huasca potion (unf)", ItemID.HUASCAVIAL);
    addPotion("Irit potion (unf)", ItemID.IRITVIAL);
    addPotion("Kwuarm potion (unf)", ItemID.KWUARMVIAL);
    addPotion("Lantadyme potion (unf)", ItemID.LANTADYMEVIAL);
    addPotion("Marrentill potion (unf)", ItemID.MARRENTILLVIAL);
    addPotion("Ranarr potion (unf)", ItemID.RANARRVIAL);
    addPotion("Snapdragon potion (unf)", ItemID.SNAPDRAGONVIAL);
    addPotion("Tarromin potion (unf)", ItemID.TARROMINVIAL);
    addPotion("Toadflax potion (unf)", ItemID.TOADFLAXVIAL);
    addPotion("Torstol potion (unf)", ItemID.TORSTOLVIAL);
  }

  private void addPotion(String storageText, int oneDoseId, int... otherDoseIds) {
    var itemStack = new ItemStack(oneDoseId, plugin);
    items.add(itemStack);
    potionMap.put(storageText, itemStack);

    doseMap.put(oneDoseId, new PotionDoseInfo(1, itemStack));
    var doses = 1;
    for (int otherDoseId : otherDoseIds) {
      doseMap.put(otherDoseId, new PotionDoseInfo(++doses, itemStack));
    }
  }

  private boolean updateFromPotionStorageWidget() {
    var potionStorageWidget = plugin.getClient().getWidget(InterfaceID.Bankmain.POTIONSTORE_ITEMS);

    if (potionStorageWidget == null
        || potionStorageWidget.isHidden()
        || potionStorageWidget.getChildren() == null) {
      return false;
    }

    var doseMap = new HashMap<String, Integer>();
    var updated = false;
    String currentPotionString = null;
    for (Widget widget : potionStorageWidget.getChildren()) {
      var widgetText = widget.getText();
      if (widgetText.startsWith("Vials:")) {
        var newVials = Integer.parseInt(widgetText.replace("Vials: ", ""));
        if (newVials != vials.getQuantity()) {
          updated = true;
          vials.setQuantity(newVials);
        }

        continue;
      }

      if (widgetText.startsWith("Doses:")) {
        if (currentPotionString != null) {
          doseMap.put(currentPotionString, Integer.parseInt(widgetText.replace("Doses: ", "")));
        }

        continue;
      }

      if (widgetText.contains("(")) {
        currentPotionString = widgetText;
        if (!potionMap.containsKey(currentPotionString)) {
          var textSplit = widgetText.split("\\s*\\(");
          currentPotionString = textSplit[0];
        }
      }
    }

    for (var entry : potionMap.entrySet()) {
      var potionString = entry.getKey();
      var potionStack = entry.getValue();

      var newQuantity = doseMap.getOrDefault(potionString, 0);
      if (newQuantity != potionStack.getQuantity()) {
        updated = true;
        potionStack.setQuantity(newQuantity);
      }
    }

    updateLastUpdated();
    return updated;
  }

  private boolean updateFromDepositBoxOrBank() {
    var client = plugin.getClient();
    if (client.getVarbitValue(VarbitID.BANK_DEPOSITPOTION) != 1) {
      return false;
    }

    var depositBoxWidget = client.getWidget(InterfaceID.BankDepositbox.FRAME);
    var depositBoxOpen = depositBoxWidget != null && !depositBoxWidget.isHidden();
    var bankWidget = client.getWidget(InterfaceID.Bankmain.ITEMS);
    var bankOpen = bankWidget != null && !bankWidget.isHidden();
    if (bankOpen) {
      var potionStorageWidget =
          plugin.getClient().getWidget(InterfaceID.Bankmain.POTIONSTORE_ITEMS);
      var potionStorageOpen =
          potionStorageWidget != null
              && !potionStorageWidget.isHidden()
              && potionStorageWidget.getChildren() != null;
      if (potionStorageOpen) {
        return false;
      }
    } else if (!depositBoxOpen) {
      return false;
    }

    var updated = false;
    for (ItemStack itemStack :
        ItemContainerWatcher.getInventoryWatcher().getItemsRemovedLastTick()) {

      var potionDoseInfo = doseMap.get(itemStack.getCanonicalId());
      if (potionDoseInfo != null) {
        var potionStack = potionDoseInfo.getItemStack();
        potionStack.setQuantity(
            potionStack.getQuantity() + itemStack.getQuantity() * potionDoseInfo.getDoses());

        vials.setQuantity(vials.getQuantity() + itemStack.getQuantity());

        updated = true;
      }
    }

    if (updated) {
      updateLastUpdated();
    }

    return updated;
  }

  @Override
  public boolean onGameTick() {
    var updated = updateFromPotionStorageWidget();

    if (updateFromDepositBoxOrBank()) {
      updated = true;
    }

    return updated;
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemContainerWatcher;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.ItemStackUtils;
import java.util.List;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarbitID;

/** Bank is responsible for tracking what the player has in their bank. */
public class Bank extends WorldStorage {

  private boolean updatedExternally;

  protected Bank(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.BANK, plugin);
  }

  public void addItems(List<ItemStack> itemsToAdd) {
    for (ItemStack itemStack : itemsToAdd) {
      ItemStackUtils.addItemStack(items, itemStack, true);
    }

    updatedExternally = true;
  }

  @Override
  public boolean onGameTick() {
    var updated = super.onGameTick() || updatedExternally;

    var client = plugin.getClient();
    var depositBoxWidget = client.getWidget(InterfaceID.BankDepositbox.FRAME);
    if (depositBoxWidget != null && !depositBoxWidget.isHidden()) {
      PotionStorage potionStorage = null;
      if (client.getVarbitValue(VarbitID.BANK_DEPOSITPOTION) == 1) {
        potionStorage = plugin.getWorldStorageManager().getPotionStorage();
      }

      for (ItemStack itemStack :
          ItemContainerWatcher.getInventoryWatcher().getItemsRemovedLastTick()) {
        // Check if the item will be sent to PotionStorage
        if (potionStorage != null
            && potionStorage.getDoseMap().get(itemStack.getCanonicalId()) != null) {
          continue;
        }

        ItemStackUtils.addItemStack(items, itemStack, true);

        updated = true;
      }
    }

    if (updated) {
      updateLastUpdated();
    }

    return updated;
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.util.Text;

/** Nulodion is responsible for tracking when the player can claim a new cannon from Nulodion. */
public class Nulodion extends WorldStorage {
  protected Nulodion(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.NULODION, plugin);

    hasStaticItems = true;

    items.add(new ItemStack(ItemID.TWPART2, plugin));
    items.add(new ItemStack(ItemID.TWPART1, plugin));
    items.add(new ItemStack(ItemID.TWPART4, plugin));
    items.add(new ItemStack(ItemID.TWPART3, plugin));
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (chatMessage.getType() == ChatMessageType.GAMEMESSAGE) {
      String message = Text.removeTags(chatMessage.getMessage());
      if (message.startsWith("Your cannon has decayed")) {
        items.forEach(itemStack -> itemStack.setQuantity(1));
        updateLastUpdated();
        return true;
      }

      if (message.startsWith("The dwarf gives you a new cannon")) {
        items.forEach(itemStack -> itemStack.setQuantity(0));
        updateLastUpdated();
        return true;
      }
    }

    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemContainerWatcher;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/**
 * Sandstorm is responsible for tracking how many buckets and sand the player has stored in the
 * Sandstorm machine.
 */
public class Sandstorm extends WorldStorage {

  private final Pattern checkPattern = Pattern.compile("I have (\\d+) of your buckets and "
      + "you've ground enough sandstone for (\\d+) buckets of sand.");

  private final Pattern sandstoneDepositPattern =
      Pattern.compile("sandstone (?:equivalent to|for) (\\d+|one) buckets? of sand");

  private final Pattern bucketDepositPattern =
      Pattern.compile("holding onto (\\d+|one) buckets? for ya");
  private final ItemStack buckets;
  private final ItemStack sand;
  private boolean justWithdrawn;

  protected Sandstorm(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.SANDSTORM, plugin);

    hasStaticItems = true;

    buckets = new ItemStack(ItemID.BUCKET_EMPTY, plugin);
    sand = new ItemStack(ItemID.HANDSAND_SAND, plugin);

    items.add(buckets);
    items.add(sand);

    plugin.getClientThread().invokeLater(() -> items.forEach(ItemStack::stripPrices));
  }

  @Override
  public boolean onGameTick() {
    Widget widget = plugin.getClient().getWidget(231, 6);

    if (!justWithdrawn) {
      if (widget != null && widget.getText().startsWith("If ya need any more sand")) {
        justWithdrawn = true;

        Optional<ItemStack> addedBuckets = ItemContainerWatcher.getInventoryWatcher()
            .getItemsAddedLastTick().stream().filter(itemStack -> itemStack.getId() == 1784)
            .findFirst();

        if (addedBuckets.isPresent()) {
          buckets.setQuantity(buckets.getQuantity() - addedBuckets.get().getQuantity());
          sand.setQuantity(sand.getQuantity() - addedBuckets.get().getQuantity());
          updateLastUpdated();

          return true;
        }
      }
    } else if (widget == null || !widget.getText().startsWith("If ya need any more sand")) {
      justWithdrawn = false;
    }

    return checkForCheck() || checkForSandstoneDeposit() || checkForBucketDeposit();
  }

  private Matcher checkWidget(Pattern pattern) {
    Widget widget = plugin.getClient().getWidget(231, 6);
    if (widget == null) {
      return null;
    }

    Matcher matcher = pattern.matcher(widget.getText().replace("<br>", " ").replace(",", ""));
    if (!matcher.find()) {
      return null;
    }

    return matcher;
  }

  private boolean checkForCheck() {
    Matcher matcher = checkWidget(checkPattern);
    if (matcher == null) {
      return false;
    }

    boolean updated = false;

    int newBuckets = NumberUtils.toInt(matcher.group(1), 0);
    if (newBuckets != buckets.getQuantity()) {
      buckets.setQuantity(newBuckets);
      updated = true;
    }

    int newSand = NumberUtils.toInt(matcher.group(2), 0);
    if (newSand != sand.getQuantity()) {
      sand.setQuantity(newSand);
      updated = true;
    }

    if (updated) {
      updateLastUpdated();
    }

    return updated;
  }

  private boolean checkForSandstoneDeposit() {
    Matcher matcher = checkWidget(sandstoneDepositPattern);
    if (matcher == null) {
      return false;
    }

    String quantityString = matcher.group(1);
    int quantity =
        Objects.equals(quantityString, "one") ? 1 : NumberUtils.toInt(matcher.group(1), 0);
    if (sand.getQuantity() == quantity) {
      return false;
    }

    sand.setQuantity(quantity);
    updateLastUpdated();
    return true;
  }

  private boolean checkForBucketDeposit() {
    Matcher matcher = checkWidget(bucketDepositPattern);
    if (matcher == null) {
      return false;
    }

    String quantityString = matcher.group(1);
    int quantity =
        Objects.equals(quantityString, "one") ? 1 : NumberUtils.toInt(matcher.group(1), 0);
    if (buckets.getQuantity() == quantity) {
      return false;
    }

    buckets.setQuantity(quantity);
    updateLastUpdated();
    return true;
  }

  @Override
  public boolean isWithdrawable() {
    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

/** FossilStorage is responsible for tracking the players fossil island fossil storage. */
public class FossilStorage extends WorldStorage {

  protected FossilStorage(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.FOSSIL_STORAGE, plugin);

    hasStaticItems = true;

    varbits =
        new int[] {
          VarbitID.FOSSIL_STORAGE_SMALL_UNID,
          VarbitID.FOSSIL_STORAGE_MEDIUM_UNID,
          VarbitID.FOSSIL_STORAGE_LARGE_UNID,
          VarbitID.FOSSIL_STORAGE_RARE_UNID,
          VarbitID.FOSSIL_STORAGE_SMALL_1,
          VarbitID.FOSSIL_STORAGE_SMALL_2,
          VarbitID.FOSSIL_STORAGE_SMALL_3,
          VarbitID.FOSSIL_STORAGE_SMALL_4,
          VarbitID.FOSSIL_STORAGE_SMALL_5,
          VarbitID.FOSSIL_STORAGE_MEDIUM_1,
          VarbitID.FOSSIL_STORAGE_MEDIUM_2,
          VarbitID.FOSSIL_STORAGE_MEDIUM_3,
          VarbitID.FOSSIL_STORAGE_MEDIUM_4,
          VarbitID.FOSSIL_STORAGE_MEDIUM_5,
          VarbitID.FOSSIL_STORAGE_LARGE_1,
          VarbitID.FOSSIL_STORAGE_LARGE_2,
          VarbitID.FOSSIL_STORAGE_LARGE_3,
          VarbitID.FOSSIL_STORAGE_LARGE_4,
          VarbitID.FOSSIL_STORAGE_LARGE_5,
          VarbitID.FOSSIL_STORAGE_PLANT_1,
          VarbitID.FOSSIL_STORAGE_PLANT_2,
          VarbitID.FOSSIL_STORAGE_PLANT_3,
          VarbitID.FOSSIL_STORAGE_PLANT_4,
          VarbitID.FOSSIL_STORAGE_PLANT_5,
          VarbitID.FOSSIL_STORAGE_RARE_1,
          VarbitID.FOSSIL_STORAGE_RARE_2,
          VarbitID.FOSSIL_STORAGE_RARE_3,
          VarbitID.FOSSIL_STORAGE_RARE_4,
          VarbitID.FOSSIL_STORAGE_RARE_5,
          VarbitID.FOSSIL_STORAGE_RARE_6,
        };

    items.add(new ItemStack(ItemID.FOSSIL_SMALL_UNID, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_MEDIUM_UNID, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_LARGE_UNID, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_RARE_UNID, plugin));

    items.add(new ItemStack(ItemID.FOSSIL_SMALL_1, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_SMALL_2, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_SMALL_3, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_SMALL_4, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_SMALL_5, plugin));

    items.add(new ItemStack(ItemID.FOSSIL_MEDIUM_1, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_MEDIUM_2, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_MEDIUM_3, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_MEDIUM_4, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_MEDIUM_5, plugin));

    items.add(new ItemStack(ItemID.FOSSIL_LARGE_1, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_LARGE_2, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_LARGE_3, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_LARGE_4, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_LARGE_5, plugin));

    items.add(new ItemStack(ItemID.FOSSIL_PLANT_1, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_PLANT_2, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_PLANT_3, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_PLANT_4, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_PLANT_5, plugin));

    items.add(new ItemStack(ItemID.FOSSIL_RARE_1, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_RARE_2, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_RARE_3, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_RARE_4, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_RARE_5, plugin));
    items.add(new ItemStack(ItemID.FOSSIL_RARE_6, plugin));
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.StorageTabPanel;

/** WorldStorageTabPanel is responsible for displaying world storage data to the player. */
public class WorldStorageTabPanel
    extends StorageTabPanel<WorldStorageType, WorldStorage, WorldStorageManager> {

  public WorldStorageTabPanel(DudeWheresMyStuffPlugin plugin, WorldStorageManager storageManager) {
    super(plugin, storageManager);
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Item;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.http.api.item.ItemPrice;

/** Eyatlalli is responsible for tracking the player's cold storage weapon. */
public class Eyatlalli extends WorldStorage {

  private static final Pattern LOGIN_MESSAGE_PATTERN = Pattern.compile(
      "Eyatlalli is holding onto your ([^.]+)\\.");

  protected Eyatlalli(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.EYATLALLI, plugin);
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (chatMessage.getType() != ChatMessageType.SPAM
        && chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
      return false;
    }

    String message = chatMessage.getMessage();
    // "<col=00e6e6>Your weapon freezes over. You're forced to let go!</col>"
    if (message.contains("Your weapon freezes over.")) {
      updateLastUpdated();
      resetItems();

      Item[] equippedItems = plugin.getClient().getItemContainer(InventoryID.WORN)
          .getItems();
      if (equippedItems.length > 3) {
        Item item = equippedItems[3];
        items.add(new ItemStack(item.getId(), item.getQuantity(), plugin));
      }

      return true;
    }

    // "Eyatlalli returns your lost weapon to you."
    // "Eyatlalli retrieves your weapon for you as you escape."
    // "You retrieve your weapon from within the cracked ice."
    // "As the icicle bursts, your weapon careens towards you, damaging you as you catch it."
    if (message.startsWith("Eyatlalli returns your lost weapon")
        || message.startsWith("Eyatlalli retrieves your weapon")
        || message.startsWith("You retrieve your weapon")
        || message.startsWith("As the icicle bursts, your weapon")) {
      updateLastUpdated();
      resetItems();

      return true;
    }

    // "Eyatlalli is holding onto your Elder maul. Speak to her to retrieve it."
    Matcher loginMessageMatcher = LOGIN_MESSAGE_PATTERN.matcher(message);
    if (loginMessageMatcher.find()) {
      updateLastUpdated();

      String itemName = loginMessageMatcher.group(1);
      Optional<ItemPrice> foundItem = plugin.getItemManager().search(itemName).stream()
          .filter(p -> p.getName().equals(itemName))
          .findFirst();
      if (!foundItem.isPresent() || items.isEmpty() || items.get(0).getId() != foundItem.get()
          .getId()) {
        resetItems();
        items.add(
            new ItemStack(foundItem.map(ItemPrice::getId).orElse(ItemID.MACRO_QUIZ_MYSTERY_BOX), 1, plugin));
      }

      return true;
    }

    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Var;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

/** ElnockInquisitor is responsible for tracking imp catching tools stored at Elnock Inquisitor. */
public class ElnockInquisitor extends WorldStorage {

  private final ItemStack netStack;
  private final ItemStack magicNetStack;

  protected ElnockInquisitor(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.ELNOCK_INQUISITOR, plugin);

    hasStaticItems = true;

    varbits = new int[] {VarbitID.II_STORED_REPELLENT, VarbitID.II_STORED_IMPLING_JARS};
    varbitItemOffset = 2;

    netStack = new ItemStack(ItemID.HUNTING_BUTTERFLY_NET, plugin);
    magicNetStack = new ItemStack(ItemID.II_MAGIC_BUTTERFLY_NET, plugin);

    items.add(netStack);
    items.add(magicNetStack);
    items.add(new ItemStack(ItemID.II_IMP_REPELLENT, plugin));
    items.add(new ItemStack(ItemID.II_IMPLING_JAR, plugin));
  }

  @Override
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    var updated = super.onVarbitChanged(varbitChanged);

    var netVar = Var.bit(varbitChanged, VarbitID.II_STORED_NET);
    if (netVar.wasChanged()) {
      int newNet = netVar.getValue(plugin.getClient());

      if (newNet == 0 && (netStack.getQuantity() != 0 || magicNetStack.getQuantity() != 0)) {
        netStack.setQuantity(0);
        magicNetStack.setQuantity(0);
        updated = true;
      } else if (newNet == 1 && netStack.getQuantity() != 1) {
        netStack.setQuantity(1);
        magicNetStack.setQuantity(0);
        updated = true;
      } else if (newNet == 2 && magicNetStack.getQuantity() != 1) {
        netStack.setQuantity(0);
        magicNetStack.setQuantity(1);
        updated = true;
      }
    }

    return updated;
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

/** Annette is responsible for tracking how many drift nets the player has stored with Annette. */
public class Annette extends WorldStorage {

  protected Annette(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.ANNETTE, plugin);

    hasStaticItems = true;
    varbits = new int[]{VarbitID.FOSSIL_DRIFTNET_STORE};

    items.add(new ItemStack(ItemID.FOSSIL_DRIFT_NET, plugin));
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStorage;
import lombok.Getter;

/**
 * WorldStorage is responsible for tracking storages in the world that hold the players items
 * (leprechaun, fossil storage, stash units, etc).
 */
@Getter
public class WorldStorage extends ItemStorage<WorldStorageType> {

  protected WorldStorage(WorldStorageType type, DudeWheresMyStuffPlugin plugin) {
    super(type, plugin);
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.StorageType;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.InventoryID;

/** WorldStorageType is used to identify WorldStorages. */
@RequiredArgsConstructor
@Getter
public enum WorldStorageType implements StorageType {
  LEPRECHAUN("Tool Leprechaun", -1, true, "leprechaun", true, null),
  BANK("Bank", InventoryID.BANK, false, "bank", false, Collections.singletonList(2)), // no uims
  GROUP_STORAGE(
      "Group Storage",
      InventoryID.INV_GROUP_TEMP,
      false,
      "groupstorage",
      false,
      Arrays.asList(
          0, // normal
          1, // iron
          2, // uim
          3)), // hcim
  BLAST_FURNACE("Blast Furnace", -1, true, "blastfurnace", true, null),
  LOG_STORAGE("Log Storage", -1, false, "logstorage", true, null),
  FOSSIL_STORAGE("Fossil Storage", -1, true, "fossilstorage", true, null),
  VYRE_WELL("Vyre Well", -1, true, "vyrewell", true, null),
  SEED_VAULT(
      "Seed Vault",
      InventoryID.SEED_VAULT,
      false,
      "seedvault",
      true,
      Collections.singletonList(2)), // no uims
  ANNETTE("Annette", -1, true, "annette", true, null),
  ELNOCK_INQUISITOR("Elnock Inquisitor", -1, true, "elnock", true, null),
  PICKAXE_STATUE("Pickaxe Statue", -1, true, "pickaxestatue", true, null),
  NULODION("Nulodion", -1, false, "nulodion", true, null),
  FORESTRY_SHOP(
      "Forestry Shop",
      -1,
      false,
      "forestryshop",
      true,
      Arrays.asList(0, 1, 3, 4, 5, 6)), // uim only
  SANDSTORM("Sandstorm", -1, false, "sandstorm", true, null),
  EYATLALLI("Eyatlalli", -1, false, "eyatlalli", true, null),
  POTION_STORAGE(
      "Potion Storage", -1, false, "potionStorage", true, Collections.singletonList(2)), // no uims
  COMPOST_BINS("Compost Bins", -1, false, "compostBins", true, null),
  NEST("Nest", -1, false, "nest", true, null);

  private final String name;
  private final int itemContainerId;
  // Whether the storage can be updated with no action required by the player
  private final boolean automatic;
  private final String configKey;
  private final boolean membersOnly;
  private final List<Integer> accountTypeBlacklist;
}

package dev.thource.runelite.dudewheresmystuff.world;

import com.google.inject.Inject;
import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

/** WorldStorageManager is responsible for managing all WorldStorages. */
@Slf4j
public class WorldStorageManager extends StorageManager<WorldStorageType, WorldStorage> {

  @Getter private final Leprechaun leprechaun;
  @Getter private final PotionStorage potionStorage;
  @Getter private final Bank bank;

  @Inject
  private WorldStorageManager(DudeWheresMyStuffPlugin plugin) {
    super(plugin);

    leprechaun = new Leprechaun(plugin);
    storages.add(leprechaun);
    bank = new Bank(plugin);
    storages.add(bank);
    storages.add(new WorldStorage(WorldStorageType.GROUP_STORAGE, plugin));
    storages.add(new WorldStorage(WorldStorageType.SEED_VAULT, plugin));
    storages.add(new BlastFurnace(plugin));
    storages.add(new LogStorage(plugin));
    storages.add(new FossilStorage(plugin));
    storages.add(new VyreWell(plugin));
    storages.add(new Annette(plugin));
    storages.add(new ElnockInquisitor(plugin));
    storages.add(new PickaxeStatue(plugin));
    storages.add(new Nulodion(plugin));
    storages.add(new ForestryShop(plugin));
    storages.add(new Sandstorm(plugin));
    storages.add(new Eyatlalli(plugin));
    potionStorage = new PotionStorage(plugin);
    storages.add(potionStorage);
    storages.add(new CompostBins(plugin));
    storages.add(new Nest(plugin));
  }

  @Override
  public String getConfigKey() {
    return "world";
  }

}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

/**
 * VyreWell is responsible for tracking how many blood runes and vials the player has stored in the
 * vyre well.
 */
public class VyreWell extends WorldStorage {

  private final ItemStack vialsOfBlood;
  private final ItemStack bloodRunes;

  protected VyreWell(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.VYRE_WELL, plugin);

    hasStaticItems = true;

    varbits = new int[] {VarbitID.TOB_LOBBY_WELL_CONTENTS};

    vialsOfBlood = new ItemStack(ItemID.VIAL_BLOOD, plugin);
    items.add(vialsOfBlood);
    bloodRunes = new ItemStack(ItemID.BLOODRUNE, plugin);
    items.add(bloodRunes);
  }

  @Override
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    boolean updated = super.onVarbitChanged(varbitChanged);

    if (updated) {
      bloodRunes.setQuantity(vialsOfBlood.getQuantity() * 200L);
    }

    return updated;
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.math.NumberUtils;

/**
 * LogStorage is responsible for tracking how many logs the player has stored in their hot air
 * balloon log storage.
 */
public class LogStorage extends WorldStorage {

  private final Pattern checkPattern = Pattern.compile("This crate currently contains (\\d+) logs,"
      + " (\\d+) oak logs, (\\d+) willow logs, (\\d+) yew logs and (\\d+) magic logs.");

  private final Pattern depositPattern =
      Pattern.compile("You put the (.*) in the crate. You now have (\\d+) stored.");

  private final Pattern chatPattern =
      Pattern.compile("You have (\\d+) sets of (.*) left in storage.");

  protected LogStorage(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.LOG_STORAGE, plugin);

    hasStaticItems = true;

    ItemStack logs = new ItemStack(ItemID.LOGS, plugin);
    ItemStack oakLogs = new ItemStack(ItemID.OAK_LOGS, plugin);
    ItemStack willowLogs = new ItemStack(ItemID.WILLOW_LOGS, plugin);
    ItemStack yewLogs = new ItemStack(ItemID.YEW_LOGS, plugin);
    ItemStack magicLogs = new ItemStack(ItemID.MAGIC_LOGS, plugin);

    items.add(logs);
    items.add(oakLogs);
    items.add(willowLogs);
    items.add(yewLogs);
    items.add(magicLogs);

    plugin.getClientThread().invokeLater(() -> items.forEach(ItemStack::stripPrices));
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (chatMessage.getType() != ChatMessageType.SPAM
        && chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
      return false;
    }

    Matcher matcher = chatPattern.matcher(chatMessage.getMessage());
    if (!matcher.find()) {
      return false;
    }

    Optional<ItemStack> itemStack =
        items.stream().filter(i -> Objects.equals(i.getName(), matcher.group(2))).findFirst();
    if (!itemStack.isPresent()) {
      return false;
    }

    int quantity = NumberUtils.toInt(matcher.group(1), 0);
    if (itemStack.get().getQuantity() == quantity) {
      return false;
    }

    itemStack.get().setQuantity(quantity);
    updateLastUpdated();
    return true;
  }

  @Override
  public boolean onGameTick() {
    return checkForCheck() || checkForDeposit();
  }

  private boolean checkForCheck() {
    Widget widget = plugin.getClient().getWidget(229, 1);
    if (widget == null) {
      return false;
    }

    Matcher matcher = checkPattern.matcher(widget.getText().replace("<br>", " "));
    if (!matcher.find()) {
      return false;
    }

    boolean updated = false;

    for (int i = 0; i < items.size(); i++) {
      ItemStack itemStack = items.get(i);
      int quantity = NumberUtils.toInt(matcher.group(i + 1), 0);

      if (itemStack.getQuantity() != quantity) {
        itemStack.setQuantity(quantity);
        updated = true;
      }
    }

    if (updated) {
      updateLastUpdated();
    }

    return updated;
  }

  private boolean checkForDeposit() {
    Widget widget = plugin.getClient().getWidget(193, 2);
    if (widget == null) {
      return false;
    }

    Matcher matcher = depositPattern.matcher(widget.getText().replace("<br>", " "));
    if (!matcher.find()) {
      return false;
    }

    Optional<ItemStack> itemStack =
        items.stream().filter(i -> Objects.equals(i.getName(), matcher.group(1))).findFirst();
    if (!itemStack.isPresent()) {
      return false;
    }

    int quantity = NumberUtils.toInt(matcher.group(2), 0);
    if (itemStack.get().getQuantity() == quantity) {
      return false;
    }

    itemStack.get().setQuantity(quantity);
    updateLastUpdated();
    return true;
  }

  @Override
  public boolean isWithdrawable() {
    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Var;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.ConfigManager;

/**
 * PickaxeStatue is responsible for tracking which pickaxe the player has stored in the pickaxe
 * statue located in ToA (Path of Het).
 */
public class PickaxeStatue extends WorldStorage {

  private static final int[] PICKAXE_IDS = {
    ItemID.BRONZE_PICKAXE,
    ItemID.IRON_PICKAXE,
    ItemID.STEEL_PICKAXE,
    ItemID.BLACK_PICKAXE,
    ItemID.MITHRIL_PICKAXE,
    ItemID.ADAMANT_PICKAXE,
    ItemID.RUNE_PICKAXE,
    ItemID.TRAIL_GILDED_PICKAXE, // unconfirmed
    ItemID.DRAGON_PICKAXE,
    ItemID.DRAGON_PICKAXE_PRETTY, // unconfirmed
    ItemID.ZALCANO_PICKAXE, // unconfirmed
    ItemID.TRAILBLAZER_PICKAXE_NO_INFERNAL, // unconfirmed
    ItemID.INFERNAL_PICKAXE, // unconfirmed
    ItemID.TRAILBLAZER_PICKAXE, // unconfirmed
    ItemID.CRYSTAL_PICKAXE,
    ItemID.CRYSTAL_PICKAXE_INACTIVE,
    ItemID._3A_PICKAXE // unconfirmed
  };
  private ItemStack pickaxe;

  protected PickaxeStatue(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.PICKAXE_STATUE, plugin);

    pickaxe = new ItemStack(PICKAXE_IDS[0], plugin);
    items.add(pickaxe);
  }

  @Override
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    var typeVar = Var.bit(varbitChanged, VarbitID.TOA_PICKAXE_STORED);
    if (!typeVar.wasChanged()) {
      return false;
    }

    int pickaxeId = getPickaxeId(typeVar.getValue(plugin.getClient()));
    if (pickaxe.getId() != pickaxeId) {
      pickaxe.setId(pickaxeId, plugin);
      pickaxe.setQuantity(pickaxe.getId() == PICKAXE_IDS[0] ? 0 : 1);
      return true;
    }

    return false;
  }

  private int getPickaxeId(int varbitValue) {
    if (varbitValue < 0 || varbitValue >= PICKAXE_IDS.length) {
      varbitValue = 0;
    }

    return PICKAXE_IDS[varbitValue];
  }

  @Override
  public void load(ConfigManager configManager, String managerConfigKey, String profileKey) {
    super.load(configManager, managerConfigKey, profileKey);

    if (items.isEmpty()) {
      items.add(new ItemStack(PICKAXE_IDS[0], plugin));
    }
    pickaxe = items.get(0);
    // Ensures bronze pickaxe removal changes are picked up on plugin update
    if (pickaxe.getId() == PICKAXE_IDS[0]) {
      pickaxe.setQuantity(0);
    }
  }

  @Override
  public void reset() {
    super.reset();

    pickaxe = new ItemStack(PICKAXE_IDS[0], plugin);
    items.add(pickaxe);
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.SaveFieldFormatter;
import dev.thource.runelite.dudewheresmystuff.SaveFieldLoader;
import dev.thource.runelite.dudewheresmystuff.Var;
import dev.thource.runelite.dudewheresmystuff.carryable.BottomlessBucket;
import java.util.ArrayList;
import javax.swing.SwingUtilities;
import lombok.Setter;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.ConfigManager;

/** Leprechaun is responsible for tracking the player's leprechaun-stored farming equipment. */
public class Leprechaun extends WorldStorage {

  private static final int[] WATERING_CAN_IDS = {
    -1,
    ItemID.WATERING_CAN_0,
    ItemID.WATERING_CAN_1,
    ItemID.WATERING_CAN_2,
    ItemID.WATERING_CAN_3,
    ItemID.WATERING_CAN_4,
    ItemID.WATERING_CAN_5,
    ItemID.WATERING_CAN_6,
    ItemID.WATERING_CAN_7,
    ItemID.WATERING_CAN_8,
    ItemID.ZEAH_WATERINGCAN
  };
  private final ItemStack rakes;
  private final ItemStack seedDibbers;
  private final ItemStack spades;
  private final ItemStack secateurs;
  private final ItemStack wateringCan;
  private final ItemStack trowels;
  private final ItemStack plantCures;
  private final ItemStack bottomlessBucket;
  private final ItemStack buckets;
  private final ItemStack composts;
  private final ItemStack superComposts;
  private final ItemStack ultraComposts;
  // 0 = normal, 1 = magic
  private int secateursType;
  // WATERING_CAN_IDS
  private int wateringCanType;
  // 0 = none, 1 = empty, 2 = compost, 3 = supercompost, 4 = ultracompost
  private int bottomlessBucketType;
  private int bottomlessBucketCharges;
  @Setter private BottomlessBucket bottomlessBucketStorage;

  /** A constructor. */
  public Leprechaun(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.LEPRECHAUN, plugin);

    hasStaticItems = true;

    rakes = new ItemStack(ItemID.RAKE, plugin);
    seedDibbers = new ItemStack(ItemID.DIBBER, plugin);
    spades = new ItemStack(ItemID.SPADE, plugin);
    secateurs = new ItemStack(ItemID.SECATEURS, plugin);
    wateringCan = new ItemStack(ItemID.WATERING_CAN_0, plugin);
    trowels = new ItemStack(ItemID.GARDENING_TROWEL, plugin);
    plantCures = new ItemStack(ItemID.PLANT_CURE, plugin);
    bottomlessBucket = new ItemStack(ItemID.BOTTOMLESS_COMPOST_BUCKET, plugin);
    buckets = new ItemStack(ItemID.BUCKET_EMPTY, plugin);
    composts = new ItemStack(ItemID.BUCKET_COMPOST, plugin);
    superComposts = new ItemStack(ItemID.BUCKET_SUPERCOMPOST, plugin);
    ultraComposts = new ItemStack(ItemID.BUCKET_ULTRACOMPOST, plugin);

    items.add(rakes);
    items.add(seedDibbers);
    items.add(spades);
    items.add(secateurs);
    items.add(wateringCan);
    items.add(trowels);
    items.add(plantCures);
    items.add(bottomlessBucket);
    items.add(buckets);
    items.add(composts);
    items.add(superComposts);
    items.add(ultraComposts);
  }

  public static int[] getWateringCanIds() {
    return WATERING_CAN_IDS.clone();
  }

  @Override
  protected ArrayList<String> getSaveValues() {
    ArrayList<String> saveValues = super.getSaveValues();

    saveValues.add(SaveFieldFormatter.format(secateursType));
    saveValues.add(SaveFieldFormatter.format(wateringCanType));
    saveValues.add(SaveFieldFormatter.format(bottomlessBucketType));
    saveValues.add(SaveFieldFormatter.format(bottomlessBucketCharges));

    return saveValues;
  }

  @Override
  protected void loadValues(ArrayList<String> values) {
    super.loadValues(values);

    secateursType = SaveFieldLoader.loadInt(values, secateursType);
    wateringCanType = SaveFieldLoader.loadInt(values, wateringCanType);
    bottomlessBucketType = SaveFieldLoader.loadInt(values, bottomlessBucketType);
    bottomlessBucketCharges = SaveFieldLoader.loadInt(values, bottomlessBucketCharges);
  }

  @Override
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    boolean updated = updateRakes(varbitChanged);

    if (updateSeedDibbers(varbitChanged)) {
      updated = true;
    }
    if (updateSpades(varbitChanged)) {
      updated = true;
    }
    if (updateSecateurs(varbitChanged)) {
      updated = true;
    }
    if (updateWateringCan(varbitChanged)) {
      updated = true;
    }
    if (updateTrowels(varbitChanged)) {
      updated = true;
    }
    if (updatePlantCures(varbitChanged)) {
      updated = true;
    }
    if (updateBottomlessBucket(varbitChanged)) {
      updated = true;
    }
    if (updateBuckets(varbitChanged)) {
      updated = true;
    }
    if (updateComposts(varbitChanged)) {
      updated = true;
    }
    if (updateSuperComposts(varbitChanged)) {
      updated = true;
    }
    if (updateUltraComposts(varbitChanged)) {
      updated = true;
    }

    return updated;
  }

  private boolean updateBottomlessBucket(VarbitChanged varbitChanged) {
    var typeVar = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_BOTTOMLESS_BUCKET_TYPE);
    var quantityVar = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_BOTTOMLESS_BUCKET_QUANTITY);

    if (!typeVar.wasChanged() && !quantityVar.wasChanged()) {
      return false;
    }

    var client = plugin.getClient();
    return setBottomlessBucketVars(typeVar.getValue(client), quantityVar.getValue(client));
  }

  private boolean updateRakes(VarbitChanged varbitChanged) {
    var var1 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_RAKE);
    var var2 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_EXTRARAKES);

    if (!var1.wasChanged() && !var2.wasChanged()) {
      return false;
    }

    var client = plugin.getClient();
    var quantity = var1.getValue(client) + var2.getValue(client) * 2;
    if (quantity == rakes.getQuantity()) {
      return false;
    }

    rakes.setQuantity(quantity);
    return true;
  }

  private boolean updateSeedDibbers(VarbitChanged varbitChanged) {
    var var1 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_DIBBER);
    var var2 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_EXTRADIBBERS);

    if (!var1.wasChanged() && !var2.wasChanged()) {
      return false;
    }

    var client = plugin.getClient();
    var quantity = var1.getValue(client) + var2.getValue(client) * 2;
    if (quantity == seedDibbers.getQuantity()) {
      return false;
    }

    seedDibbers.setQuantity(quantity);
    return true;
  }

  private boolean updateSpades(VarbitChanged varbitChanged) {
    var var1 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_SPADE);
    var var2 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_EXTRASPADES);

    if (!var1.wasChanged() && !var2.wasChanged()) {
      return false;
    }

    var client = plugin.getClient();
    var quantity = var1.getValue(client) + var2.getValue(client) * 2;
    if (quantity == spades.getQuantity()) {
      return false;
    }

    spades.setQuantity(quantity);
    return true;
  }

  private boolean updateSecateurs(VarbitChanged varbitChanged) {
    var var1 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_SECATEURS);
    var var2 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_EXTRASECATEURS);
    var typeVar = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_FAIRYSECATEURS);

    if (!var1.wasChanged() && !var2.wasChanged() && !typeVar.wasChanged()) {
      return false;
    }

    boolean updated = false;

    var client = plugin.getClient();
    var quantity = var1.getValue(client) + var2.getValue(client) * 2;
    if (quantity != secateurs.getQuantity()) {
      secateurs.setQuantity(quantity);
      updated = true;
    }

    if (setSecateursType(typeVar.getValue(client))) {
      updated = true;
    }

    return updated;
  }

  private boolean updateTrowels(VarbitChanged varbitChanged) {
    var var1 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_TROWEL);
    var var2 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_EXTRATROWELS);

    if (!var1.wasChanged() && !var2.wasChanged()) {
      return false;
    }

    var client = plugin.getClient();
    var quantity = var1.getValue(client) + var2.getValue(client) * 2;
    if (quantity == trowels.getQuantity()) {
      return false;
    }

    trowels.setQuantity(quantity);
    return true;
  }

  private boolean updatePlantCures(VarbitChanged varbitChanged) {
    var var = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_PLANTCURE);
    if (!var.wasChanged()) {
      return false;
    }

    var quantity = var.getValue(plugin.getClient());
    if (quantity == plantCures.getQuantity()) {
      return false;
    }

    plantCures.setQuantity(quantity);
    return true;
  }

  private boolean updateBuckets(VarbitChanged varbitChanged) {
    var var1 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_BUCKETS);
    var var2 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_EXTRABUCKETS);
    var var3 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_EXTRA2BUCKETS);

    if (!var1.wasChanged() && !var2.wasChanged() && !var3.wasChanged()) {
      return false;
    }

    var client = plugin.getClient();
    var quantity = var1.getValue(client) + var2.getValue(client) * 32 + var3.getValue(client) * 256;
    if (quantity == buckets.getQuantity()) {
      return false;
    }

    buckets.setQuantity(quantity);
    return true;
  }

  private boolean updateComposts(VarbitChanged varbitChanged) {
    var var1 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_COMPOST);
    var var2 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_EXTRACOMPOST);

    if (!var1.wasChanged() && !var2.wasChanged()) {
      return false;
    }

    var client = plugin.getClient();
    var quantity = var1.getValue(client) + var2.getValue(client) * 256;
    if (quantity == composts.getQuantity()) {
      return false;
    }

    composts.setQuantity(quantity);
    return true;
  }

  private boolean updateSuperComposts(VarbitChanged varbitChanged) {
    var var1 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_SUPERCOMPOST);
    var var2 = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_EXTRASUPERCOMPOST);

    if (!var1.wasChanged() && !var2.wasChanged()) {
      return false;
    }

    var client = plugin.getClient();
    var quantity = var1.getValue(client) + var2.getValue(client) * 256;
    if (quantity == superComposts.getQuantity()) {
      return false;
    }

    superComposts.setQuantity(quantity);
    return true;
  }

  private boolean updateUltraComposts(VarbitChanged varbitChanged) {
    var var = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_ULTRACOMPOST);
    if (!var.wasChanged()) {
      return false;
    }

    var quantity = var.getValue(plugin.getClient());
    if (quantity == ultraComposts.getQuantity()) {
      return false;
    }

    ultraComposts.setQuantity(quantity);
    return true;
  }

  private boolean updateWateringCan(VarbitChanged varbitChanged) {
    var var = Var.bit(varbitChanged, VarbitID.FARMING_TOOLS_WATERINGCAN);
    if (!var.wasChanged()) {
      return false;
    }

    var wateringCanState = var.getValue(plugin.getClient());
    if (wateringCanState >= WATERING_CAN_IDS.length) {
      return false;
    }

    return setWateringCanType(wateringCanState);
  }

  private boolean setSecateursType(int secateursType) {
    this.secateursType = secateursType;

    int secateursId = secateursType == 1 ? ItemID.FAIRY_ENCHANTED_SECATEURS : ItemID.SECATEURS;

    if (secateurs.getId() == secateursId) {
      return false;
    }

    secateurs.setId(secateursId, plugin);
    return true;
  }

  private boolean setWateringCanType(int wateringCanType) {
    this.wateringCanType = wateringCanType;
    int wateringCanId = WATERING_CAN_IDS[wateringCanType];
    if (wateringCanId == -1) {
      if (wateringCan.getQuantity() == 0) {
        return false;
      }

      wateringCan.setQuantity(0);
      return true;
    }

    if (wateringCan.getQuantity() == 1 && wateringCan.getId() == wateringCanId) {
      return false;
    }

    wateringCan.setId(wateringCanId, plugin);
    wateringCan.setQuantity(1);
    return true;
  }

  private boolean setBottomlessBucketVars(int bottomlessBucketType, int bottomlessBucketCharges) {
    final int oldBottomlessBucketCharges = this.bottomlessBucketCharges;
    this.bottomlessBucketType = bottomlessBucketType;
    this.bottomlessBucketCharges = bottomlessBucketCharges;

    int itemId = ItemID.BOTTOMLESS_COMPOST_BUCKET;

    if (bottomlessBucketType == 1) {
      bottomlessBucket.setName("Bottomless compost bucket");
    } else if (bottomlessBucketType != 0) {
      itemId = ItemID.BOTTOMLESS_COMPOST_BUCKET_FILLED;
    }

    if (oldBottomlessBucketCharges == bottomlessBucketCharges
        && itemId == bottomlessBucket.getId()) {
      return false;
    }

    bottomlessBucket.setId(itemId);
    String name = "Bottomless compost bucket";
    if (bottomlessBucketCharges > 0) {
      name += " (" + bottomlessBucketCharges + " ";
      if (bottomlessBucketType == 2) {
        name += "compost)";
      } else if (bottomlessBucketType == 3) {
        name += "supercompost)";
      } else if (bottomlessBucketType == 4) {
        name += "ultracompost)";
      }
    }
    bottomlessBucket.setName(name);
    bottomlessBucket.setQuantity(bottomlessBucketType == 0 ? 0 : 1);
    if (bottomlessBucketStorage != null) {
      bottomlessBucketStorage.updateCompost(bottomlessBucketType, bottomlessBucketCharges);

      if (bottomlessBucketStorage.getStoragePanel() != null) {
        bottomlessBucketStorage.getStoragePanel().refreshItems();
        SwingUtilities.invokeLater(bottomlessBucketStorage.getStoragePanel()::update);
      }
    }
    return true;
  }

  @Override
  public void reset() {
    super.reset();
    secateursType = 0;
    wateringCanType = 0;
    bottomlessBucketType = 0;
  }

  @Override
  public void load(ConfigManager configManager, String managerConfigKey, String profileKey) {
    super.load(configManager, managerConfigKey, profileKey);

    setSecateursType(secateursType);
    setWateringCanType(wateringCanType);
    setBottomlessBucketVars(bottomlessBucketType, bottomlessBucketCharges);
  }
}

package dev.thource.runelite.dudewheresmystuff.world;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import dev.thource.runelite.dudewheresmystuff.StoragePanel;
import dev.thource.runelite.dudewheresmystuff.Var;
import java.util.HashMap;
import java.util.Objects;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;

public class CompostBins extends WorldStorage {
  @RequiredArgsConstructor
  @Getter
  private static class CompostBinData {
    private final String areaName;
    private final boolean bigCompost;
    private final int varbitId;
    @Setter private ItemStack compostStack;
    @Setter private ItemStack superCompostStack;
    @Setter private ItemStack ultraCompostStack;
    @Setter private ItemStack rottenTomatoStack;

    boolean setStackQuantities(int binValue) {
      final var oldCompostQuantity = compostStack.getQuantity();
      final var oldSuperCompostQuantity = superCompostStack.getQuantity();
      final var oldUltraCompostQuantity = ultraCompostStack.getQuantity();
      final var oldRottenTomatoQuantity = rottenTomatoStack.getQuantity();
      compostStack.setQuantity(0);
      superCompostStack.setQuantity(0);
      ultraCompostStack.setQuantity(0);
      rottenTomatoStack.setQuantity(0);

      if (bigCompost) {
        if (binValue >= 16 && binValue <= 30) {
          compostStack.setQuantity(binValue - 15);
        } else if (binValue >= 48 && binValue <= 62) {
          superCompostStack.setQuantity(binValue - 47);
        } else if (binValue >= 78 && binValue <= 92) {
          compostStack.setQuantity(15 + binValue - 77);
        } else if (binValue == 93) {
          compostStack.setQuantity(30);
        } else if (binValue == 99) {
          superCompostStack.setQuantity(30);
        } else if (binValue >= 100 && binValue <= 114) {
          superCompostStack.setQuantity(15 + binValue - 99);
        } else if (binValue >= 144 && binValue <= 158) {
          rottenTomatoStack.setQuantity(binValue - 143);
        } else if (binValue >= 176 && binValue <= 205) {
          ultraCompostStack.setQuantity(binValue - 175);
        } else if (binValue >= 207 && binValue <= 221) {
          rottenTomatoStack.setQuantity(15 + binValue - 206);
        } else if (binValue == 222) {
          rottenTomatoStack.setQuantity(30);
        }
      } else {
        if (binValue >= 16 && binValue <= 30) {
          compostStack.setQuantity(binValue - 15);
        } else if (binValue >= 48 && binValue <= 62) {
          superCompostStack.setQuantity(binValue - 47);
        } else if (binValue == 94) {
          compostStack.setQuantity(15);
        } else if (binValue == 126) {
          superCompostStack.setQuantity(15);
        } else if (binValue >= 144 && binValue <= 158) {
          rottenTomatoStack.setQuantity(binValue - 143);
        } else if (binValue == 160) {
          rottenTomatoStack.setQuantity(15);
        } else if (binValue >= 176 && binValue <= 190) {
          ultraCompostStack.setQuantity(binValue - 175);
        }
      }

      return oldCompostQuantity != compostStack.getQuantity()
          || oldSuperCompostQuantity != superCompostStack.getQuantity()
          || oldUltraCompostQuantity != ultraCompostStack.getQuantity()
          || oldRottenTomatoQuantity != rottenTomatoStack.getQuantity();
    }
  }

  private final HashMap<Integer, CompostBinData> regionBinMap = new HashMap<>();

  private int lastRegionId = -1;

  public CompostBins(DudeWheresMyStuffPlugin plugin) {
    super(WorldStorageType.COMPOST_BINS, plugin);

    hasStaticItems = true;

    addBin(new CompostBinData("Ardougne", false, VarbitID.FARMING_TRANSMIT_E), 10548);
    addBin(new CompostBinData("Catherby", false, VarbitID.FARMING_TRANSMIT_E), 11062);
    addBin(new CompostBinData("Falador", false, VarbitID.FARMING_TRANSMIT_E), 12083);
    addBin(new CompostBinData("Kourend", false, VarbitID.FARMING_TRANSMIT_E), 6967, 6711);
    addBin(new CompostBinData("Morytania", false, VarbitID.FARMING_TRANSMIT_E), 14391, 14390);
    addBin(
        new CompostBinData("Farming Guild", true, VarbitID.FARMING_TRANSMIT_N),
        4922,
        5177,
        5178,
        5179,
        4921,
        4923,
        4665,
        4666,
        4667);
    addBin(
        new CompostBinData("Prifddinas", false, VarbitID.FARMING_TRANSMIT_D),
        13151,
        12895,
        12894,
        13150,
        /* Underground */ 12994,
        12993,
        12737,
        12738,
        12126,
        12127,
        13250);
  }

  private void addBin(CompostBinData compostBinData, int... regionIds) {
    var compostStack = new ItemStack(ItemID.BUCKET_COMPOST, plugin);
    items.add(compostStack);
    var superCompostStack = new ItemStack(ItemID.BUCKET_SUPERCOMPOST, plugin);
    items.add(superCompostStack);
    var ultraCompostStack = new ItemStack(ItemID.BUCKET_ULTRACOMPOST, plugin);
    items.add(ultraCompostStack);
    var rottenTomatoStack = new ItemStack(ItemID.ROTTEN_TOMATO, plugin);
    items.add(rottenTomatoStack);

    compostBinData.setCompostStack(compostStack);
    compostBinData.setSuperCompostStack(superCompostStack);
    compostBinData.setUltraCompostStack(ultraCompostStack);
    compostBinData.setRottenTomatoStack(rottenTomatoStack);

    for (var regionId : regionIds) {
      regionBinMap.put(regionId, compostBinData);
    }

    plugin
        .getClientThread()
        .invokeLater(
            () -> {
              if (Objects.equals(compostStack.getName(), "Loading")) {
                return false;
              }

              compostStack.setName(
                  compostStack.getName() + " (" + compostBinData.getAreaName() + ")");
              superCompostStack.setName(
                  superCompostStack.getName() + " (" + compostBinData.getAreaName() + ")");
              ultraCompostStack.setName(
                  ultraCompostStack.getName() + " (" + compostBinData.getAreaName() + ")");
              rottenTomatoStack.setName(
                  rottenTomatoStack.getName() + " (" + compostBinData.getAreaName() + ")");

              return true;
            });
  }

  @Override
  public boolean onGameTick() {
    var client = plugin.getClient();
    var location = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());

    if (location.getRegionID() == lastRegionId) {
      return false;
    }

    lastRegionId = location.getRegionID();

    var bin = regionBinMap.get(location.getRegionID());
    if (bin != null) {
      var compostValue = client.getVarbitValue(bin.getVarbitId());
      if (bin.setStackQuantities(compostValue)) {
        updateLastUpdated();
        return true;
      }
    }

    return false;
  }

  @Override
  public void reset() {
    super.reset();

    lastRegionId = -1;
  }

  @Override
  protected void createStoragePanel(StorageManager<?, ?> storageManager) {
    storagePanel = new StoragePanel(plugin, this, true, false, false);

    createComponentPopupMenu(storageManager);
  }
}

package dev.thource.runelite.dudewheresmystuff;

import java.util.List;

/** StorageType is used to identify Storages. */
public interface StorageType {

  String getName();

  int getItemContainerId();

  boolean isAutomatic();

  String getConfigKey();

  boolean isMembersOnly();

  List<Integer> getAccountTypeBlacklist();
}

package dev.thource.runelite.dudewheresmystuff;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.util.Objects;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.DynamicGridLayout;

class DebugPanel extends TabContentPanel {
  static final int PANEL_WIDTH = 225;

  private final DudeWheresMyStuffPlugin plugin;
  private final JPanel mainPanel;

  DebugPanel(DudeWheresMyStuffPlugin plugin) {
    super();
    this.plugin = plugin;

    mainPanel = new FixedWidthPanel();
    mainPanel.setBorder(new EmptyBorder(8, 10, 10, 10));
    mainPanel.setLayout(new DynamicGridLayout(0, 1, 0, 5));
    mainPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

    JPanel northPanel = new FixedWidthPanel();
    northPanel.setLayout(new BorderLayout());
    northPanel.add(mainPanel, BorderLayout.NORTH);

    JScrollPane scrollPane = new JScrollPane(northPanel);
    scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
    add(scrollPane, BorderLayout.CENTER);

    mainPanel.add(
        createCheckbox(
            "\"Create deathpile\" menu action",
            "Adds a menu option to create a deathpile on the clicked tile.<br>Shift must be held for it to appear.",
            "debug.menu.createDeathpile"));
    mainPanel.add(
        createCheckbox(
            "\"Log co-ords\" menu action",
            "Adds a menu option to log co-ords of the clicked tile.<br>Shift must be held for it to appear.",
            "debug.menu.logCoords"));
    mainPanel.add(
        createCheckbox(
            "Show remote deathpile areas",
            "Draws a rect over remote deathpile death areas and pile areas.",
            "debug.render.remoteDeathpileAreas"));
  }

  JPanel createCheckbox(String name, String description, String configName) {
    JPanel panel = new JPanel();
    panel.setLayout(new BorderLayout());
    panel.setMinimumSize(new Dimension(PANEL_WIDTH, 0));
    JLabel configEntryName = new JLabel(name);
    configEntryName.setForeground(Color.WHITE);
    if (!"".equals(description)) {
      configEntryName.setToolTipText("<html>" + name + ":<br>" + description + "</html>");
    }
    panel.add(configEntryName, BorderLayout.CENTER);

    var checkbox = new JCheckBox();
    checkbox.setSelected(
        Objects.equals(
            plugin
                .getConfigManager()
                .getConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP, configName),
            "true"));
    checkbox.addActionListener(
        ae ->
            plugin
                .getConfigManager()
                .setConfiguration(
                    DudeWheresMyStuffConfig.CONFIG_GROUP, configName, checkbox.isSelected()));
    panel.add(checkbox, BorderLayout.EAST);

    return panel;
  }

  @Override
  public void softUpdate() {}
}

package dev.thource.runelite.dudewheresmystuff.stash;

import dev.thource.runelite.dudewheresmystuff.StorageType;
import java.util.List;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

/** StashStorageType is used to identify StashStorages. */
@RequiredArgsConstructor
@Getter
public enum StashStorageType implements StorageType {
  STASH("Stash", -1, false, "stash", true);

  private final String name;
  private final int itemContainerId;
  // Whether the storage can be updated with no action required by the player
  private final boolean automatic;
  private final String configKey;
  private final boolean membersOnly;
  private final List<Integer> accountTypeBlacklist = null;
}

/*
 * Copyright (c) 2022, Thource <https://github.com/Thource>
 * Copyright (c) 2018, Lotto <https://github.com/devLotto>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package dev.thource.runelite.dudewheresmystuff.stash;

import javax.annotation.Nonnull;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.plugins.cluescrolls.clues.emote.STASHUnit;
import net.runelite.client.plugins.cluescrolls.clues.item.ItemRequirement;
import net.runelite.client.plugins.cluescrolls.clues.item.ItemRequirements;

/** StashUnit is used to define which items live at which locations. */
// Suppress duplicate string literal warning because this class is copied from runelite
@SuppressWarnings("java:S1192")
@Getter
public enum StashUnit {
  NORTHEAST_CORNER_OF_THE_KHARAZI_JUNGLE(
      "Kharazi Jungle",
      "North-east corner of the Kharazi Jungle",
      STASHUnit.NORTHEAST_CORNER_OF_THE_KHARAZI_JUNGLE,
      new int[]{ItemID.TRAIL_GUTHIX_SCARF, ItemID.RUNE_HERALDIC_KITESHIELD1},
      ItemRequirements.any(
          "Any stole",
          ItemRequirements.item(ItemID.TRAIL_GUTHIX_SCARF),
          ItemRequirements.item(ItemID.TRAIL_SARADOMIN_SCARF),
          ItemRequirements.item(ItemID.TRAIL_ZAMORAK_SCARF),
          ItemRequirements.item(ItemID.TRAIL_ARMADYL_SCARF),
          ItemRequirements.item(ItemID.TRAIL_BANDOS_SCARF),
          ItemRequirements.item(ItemID.TRAIL_ANCIENT_SCARF)),
      ItemRequirements.any(
          "Any heraldic rune shield",
          ItemRequirements.item(ItemID.RUNE_HERALDIC_KITESHIELD1),
          ItemRequirements.item(ItemID.RUNE_HERALDIC_KITESHIELD2),
          ItemRequirements.item(ItemID.RUNE_HERALDIC_KITESHIELD3),
          ItemRequirements.item(ItemID.RUNE_HERALDIC_KITESHIELD4),
          ItemRequirements.item(ItemID.RUNE_HERALDIC_KITESHIELD5))),
  BARBARIAN_OUTPOST_OBSTACLE_COURSE(
      "Barbarian Outpost",
      "Barbarian Outpost obstacle course",
      STASHUnit.BARBARIAN_OUTPOST_OBSTACLE_COURSE,
      new int[]{ItemID.STEEL_PLATEBODY, ItemID.MAPLE_SHORTBOW, ItemID.WILDERNESS_CAPE_1},
      ItemRequirements.item(ItemID.STEEL_PLATEBODY),
      ItemRequirements.item(ItemID.MAPLE_SHORTBOW),
      ItemRequirements.any(
          "Any team cape",
          ItemRequirements.range(ItemID.WILDERNESS_CAPE_1, ItemID.WILDERNESS_CAPE_50),
          ItemRequirements.item(ItemID.WILDERNESS_CAPE_I),
          ItemRequirements.item(ItemID.WILDERNESS_CAPE_X),
          ItemRequirements.item(ItemID.WILDERNESS_CAPE_ZERO)
      )),
  SOUTHEAST_CORNER_OF_THE_MONASTERY(
      "Edgeville Monastery",
      "South-east corner of the Monastery",
      STASHUnit.SOUTHEAST_CORNER_OF_THE_MONASTERY,
      new int[]{ItemID.SARADOMINBOOK_COMPLETE},
      ItemRequirements.any(
          "Any god book",
          ItemRequirements.item(ItemID.SARADOMINBOOK_COMPLETE),
          ItemRequirements.item(ItemID.GUTHIXBOOK_COMPLETE),
          ItemRequirements.item(ItemID.ZAMORAKBOOK_COMPLETE),
          ItemRequirements.item(ItemID.ARMADYLBOOK_COMPLETE),
          ItemRequirements.item(ItemID.BANDOSBOOK_COMPLETE),
          ItemRequirements.item(ItemID.ZAROSBOOK_COMPLETE),
          ItemRequirements.item(ItemID.LEAGUE_3_BOOK_SARADOMIN),
          ItemRequirements.item(ItemID.LEAGUE_3_BOOK_GUTHIX),
          ItemRequirements.item(ItemID.LEAGUE_3_BOOK_ZAMORAK),
          ItemRequirements.item(ItemID.LEAGUE_3_BOOK_ARMADYL),
          ItemRequirements.item(ItemID.LEAGUE_3_BOOK_BANDOS),
          ItemRequirements.item(ItemID.LEAGUE_3_BOOK_ZAROS))),
  ENTRANCE_OF_THE_CAVE_OF_DAMIS(
      "Shadow dungeon",
      "Entrance of the cave of Damis",
      STASHUnit.ENTRANCE_OF_THE_CAVE_OF_DAMIS,
      new int[]{
          ItemID.TRAIL_GUTHIX_MITRE, ItemID.XBOWS_CROSSBOW_RUNITE, ItemID.DEATH_CLIMBINGBOOTS,
          ItemID.FD_RING_VISIBILITY
      },
      ItemRequirements.any(
          "Any mitre",
          ItemRequirements.item(ItemID.TRAIL_GUTHIX_MITRE),
          ItemRequirements.item(ItemID.TRAIL_SARADOMIN_MITRE),
          ItemRequirements.item(ItemID.TRAIL_ZAMORAK_MITRE),
          ItemRequirements.item(ItemID.TRAIL_ANCIENT_MITRE),
          ItemRequirements.item(ItemID.TRAIL_BANDOS_MITRE),
          ItemRequirements.item(ItemID.TRAIL_ARMADYL_MITRE)),
      ItemRequirements.any(
          "Rune crossbow",
          ItemRequirements.item(ItemID.XBOWS_CROSSBOW_RUNITE),
          ItemRequirements.item(ItemID.LEAGUE_3_RUNE_XBOW)),
      ItemRequirements.any(
          "Climbing boots",
          ItemRequirements.item(ItemID.DEATH_CLIMBINGBOOTS),
          ItemRequirements.item(ItemID.CLIMBING_BOOTS_G)),
      ItemRequirements.any(
          "Ring of visibility or ring of shadows",
          ItemRequirements.item(ItemID.FD_RING_VISIBILITY),
          ItemRequirements.item(ItemID.RING_OF_SHADOWS),
          ItemRequirements.item(ItemID.RING_OF_SHADOWS_UNCHARGED))),
  AGILITY_PYRAMID(
      "Agility Pyramid",
      "Agility Pyramid",
      STASHUnit.AGILITY_PYRAMID,
      new int[]{ItemID.MYSTIC_ROBE_TOP, ItemID.RUNE_HERALDIC_KITESHIELD1},
      ItemRequirements.item(ItemID.MYSTIC_ROBE_TOP),
      ItemRequirements.any(
          "Any rune heraldic shield",
          ItemRequirements.item(ItemID.RUNE_HERALDIC_KITESHIELD1),
          ItemRequirements.item(ItemID.RUNE_HERALDIC_KITESHIELD2),
          ItemRequirements.item(ItemID.RUNE_HERALDIC_KITESHIELD3),
          ItemRequirements.item(ItemID.RUNE_HERALDIC_KITESHIELD4),
          ItemRequirements.item(ItemID.RUNE_HERALDIC_KITESHIELD5))),
  WELL_OF_VOYAGE(
      "Iban's temple",
      "Well of Voyage",
      STASHUnit.WELL_OF_VOYAGE,
      new int[]{ItemID.IBANSTAFF, ItemID.MYSTIC_ROBE_TOP_DARK, ItemID.MYSTIC_ROBE_BOTTOM_DARK},
      ItemRequirements.any(
          "Any iban's staff",
          ItemRequirements.item(ItemID.IBANSTAFF),
          ItemRequirements.item(ItemID.IBANSTAFF_UPGRADED)),
      ItemRequirements.item(ItemID.MYSTIC_ROBE_TOP_DARK),
      ItemRequirements.item(ItemID.MYSTIC_ROBE_BOTTOM_DARK)),
  SOUTHEAST_CORNER_OF_THE_FISHING_PLATFORM(
      "Fishing Platform",
      "South-east corner of the Fishing Platform",
      STASHUnit.SOUTHEAST_CORNER_OF_THE_FISHING_PLATFORM,
      new int[]{ItemID.AMULET_OF_GLORY, ItemID.HUNDRED_GAUNTLETS_LEVEL_10, ItemID.DRAGON_MED_HELM},
      ItemRequirements.any(
          "Any amulet of glory",
          ItemRequirements.item(ItemID.AMULET_OF_GLORY),
          ItemRequirements.item(ItemID.AMULET_OF_GLORY_1),
          ItemRequirements.item(ItemID.AMULET_OF_GLORY_2),
          ItemRequirements.item(ItemID.AMULET_OF_GLORY_3),
          ItemRequirements.item(ItemID.AMULET_OF_GLORY_4),
          ItemRequirements.item(ItemID.AMULET_OF_GLORY_5),
          ItemRequirements.item(ItemID.AMULET_OF_GLORY_6),
          ItemRequirements.item(ItemID.AMULET_OF_GLORY_INF)),
      ItemRequirements.item(ItemID.HUNDRED_GAUNTLETS_LEVEL_10),
      ItemRequirements.item(ItemID.DRAGON_MED_HELM)),
  DEATH_ALTAR(
      "Death altar",
      "Death Altar",
      STASHUnit.DEATH_ALTAR,
      new int[]{ItemID.RING_OF_WEALTH, ItemID.TIARA_DEATH, ItemID.CAPE_OF_LEGENDS},
      ItemRequirements.any(
          "Any ring of wealth",
          ItemRequirements.item(ItemID.RING_OF_WEALTH),
          ItemRequirements.item(ItemID.RING_OF_WEALTH_1),
          ItemRequirements.item(ItemID.RING_OF_WEALTH_2),
          ItemRequirements.item(ItemID.RING_OF_WEALTH_3),
          ItemRequirements.item(ItemID.RING_OF_WEALTH_4),
          ItemRequirements.item(ItemID.RING_OF_WEALTH_5),
          ItemRequirements.item(ItemID.RING_OF_WEALTH_I),
          ItemRequirements.item(ItemID.RING_OF_WEALTH_I1),
          ItemRequirements.item(ItemID.RING_OF_WEALTH_I2),
          ItemRequirements.item(ItemID.RING_OF_WEALTH_I3),
          ItemRequirements.item(ItemID.RING_OF_WEALTH_I4),
          ItemRequirements.item(ItemID.RING_OF_WEALTH_I5)),
      ItemRequirements.item(ItemID.TIARA_DEATH),
      ItemRequirements.item(ItemID.CAPE_OF_LEGENDS)),
  OUTSIDE_THE_BAR_BY_THE_FIGHT_ARENA(
      "Fight Arena pub",
      "Outside the bar by the Fight Arena",
      STASHUnit.OUTSIDE_THE_BAR_BY_THE_FIGHT_ARENA,
      new int[]{ItemID.PIRATE_BANDANNA, ItemID.DRAGONSTONE_NECKLACE, ItemID.MAGIC_LONGBOW},
      ItemRequirements.any(
          "Any pirate bandana",
          ItemRequirements.item(ItemID.PIRATE_BANDANNA),
          ItemRequirements.item(ItemID.PIRATE_BANDANA_RED),
          ItemRequirements.item(ItemID.PIRATE_BANDANA_BLUE),
          ItemRequirements.item(ItemID.PIRATE_BANDANA_BROWN)),
      ItemRequirements.item(ItemID.DRAGONSTONE_NECKLACE),
      ItemRequirements.item(ItemID.MAGIC_LONGBOW)),
  BARROWS_CHEST(
      "Barrows chest",
      "Barrows Chest",
      STASHUnit.BARROWS_CHEST,
      new int[]{
          ItemID.BARROWS_DHAROK_HEAD,
          ItemID.BARROWS_DHAROK_WEAPON,
          ItemID.BARROWS_DHAROK_BODY,
          ItemID.BARROWS_DHAROK_LEGS
      },
      ItemRequirements.any(
          "Any full barrows set",
          ItemRequirements.all(
              ItemRequirements.any(
                  "Ahrim's hood",
                  ItemRequirements.item(ItemID.BARROWS_AHRIM_HEAD),
                  ItemRequirements.range(ItemID.BARROWS_AHRIM_HEAD_100,
                      ItemID.BARROWS_AHRIM_HEAD_BROKEN)),
              ItemRequirements.any(
                  "Ahrim's staff",
                  ItemRequirements.item(ItemID.BARROWS_AHRIM_WEAPON),
                  ItemRequirements.range(ItemID.BARROWS_AHRIM_WEAPON_100,
                      ItemID.BARROWS_AHRIM_WEAPON_BROKEN)),
              ItemRequirements.any(
                  "Ahrim's robetop",
                  ItemRequirements.item(ItemID.BARROWS_AHRIM_BODY),
                  ItemRequirements.range(ItemID.BARROWS_AHRIM_BODY_100,
                      ItemID.BARROWS_AHRIM_BODY_BROKEN)),
              ItemRequirements.any(
                  "Ahrim's robeskirt",
                  ItemRequirements.item(ItemID.BARROWS_AHRIM_LEGS),
                  ItemRequirements.range(ItemID.BARROWS_AHRIM_LEGS_100,
                      ItemID.BARROWS_AHRIM_LEGS_BROKEN))),
          ItemRequirements.all(
              ItemRequirements.any(
                  "Dharok's helm",
                  ItemRequirements.item(ItemID.BARROWS_DHAROK_HEAD),
                  ItemRequirements.range(ItemID.BARROWS_DHAROK_HEAD_100,
                      ItemID.BARROWS_DHAROK_HEAD_BROKEN)),
              ItemRequirements.any(
                  "Dharok's greataxe",
                  ItemRequirements.item(ItemID.BARROWS_DHAROK_WEAPON),
                  ItemRequirements.range(ItemID.BARROWS_DHAROK_WEAPON_100,
                      ItemID.BARROWS_DHAROK_WEAPON_BROKEN)),
              ItemRequirements.any(
                  "Dharok's platebody",
                  ItemRequirements.item(ItemID.BARROWS_DHAROK_BODY),
                  ItemRequirements.range(ItemID.BARROWS_DHAROK_BODY_100,
                      ItemID.BARROWS_DHAROK_BODY_BROKEN)),
              ItemRequirements.any(
                  "Dharok's platelegs",
                  ItemRequirements.item(ItemID.BARROWS_DHAROK_LEGS),
                  ItemRequirements.range(
                      ItemID.BARROWS_DHAROK_LEGS_100, ItemID.BARROWS_DHAROK_LEGS_BROKEN))),
          ItemRequirements.all(
              ItemRequirements.any(
                  "Guthan's helm",
                  ItemRequirements.item(ItemID.BARROWS_GUTHAN_HEAD),
                  ItemRequirements.range(ItemID.BARROWS_GUTHAN_HEAD_100,
                      ItemID.BARROWS_GUTHAN_HEAD_BROKEN)),
              ItemRequirements.any(
                  "Guthan's warspear",
                  ItemRequirements.item(ItemID.BARROWS_GUTHAN_WEAPON),
                  ItemRequirements.range(ItemID.BARROWS_GUTHAN_WEAPON_100,
                      ItemID.BARROWS_GUTHAN_WEAPON_BROKEN)),
              ItemRequirements.any(
                  "Guthan's platebody",
                  ItemRequirements.item(ItemID.BARROWS_GUTHAN_BODY),
                  ItemRequirements.range(ItemID.BARROWS_GUTHAN_BODY_100,
                      ItemID.BARROWS_GUTHAN_BODY_BROKEN)),
              ItemRequirements.any(
                  "Guthan's chainskirt",
                  ItemRequirements.item(ItemID.BARROWS_GUTHAN_LEGS),
                  ItemRequirements.range(
                      ItemID.BARROWS_GUTHAN_LEGS_100, ItemID.BARROWS_GUTHAN_LEGS_BROKEN))),
          ItemRequirements.all(
              ItemRequirements.any(
                  "Karil's coif",
                  ItemRequirements.item(ItemID.BARROWS_KARIL_HEAD),
                  ItemRequirements.range(ItemID.BARROWS_KARIL_HEAD_100,
                      ItemID.BARROWS_KARIL_HEAD_BROKEN)),
              ItemRequirements.any(
                  "Karil's crossbow",
                  ItemRequirements.item(ItemID.BARROWS_KARIL_WEAPON),
                  ItemRequirements.range(ItemID.BARROWS_KARIL_WEAPON_100,
                      ItemID.BARROWS_KARIL_WEAPON_BROKEN)),
              ItemRequirements.any(
                  "Karil's leathertop",
                  ItemRequirements.item(ItemID.BARROWS_KARIL_BODY),
                  ItemRequirements.range(ItemID.BARROWS_KARIL_BODY_100,
                      ItemID.BARROWS_KARIL_BODY_BROKEN)),
              ItemRequirements.any(
                  "Karil's leatherskirt",
                  ItemRequirements.item(ItemID.BARROWS_KARIL_LEGS),
                  ItemRequirements.range(
                      ItemID.BARROWS_KARIL_LEGS_100, ItemID.BARROWS_KARIL_LEGS_BROKEN))),
          ItemRequirements.all(
              ItemRequirements.any(
                  "Torag's helm",
                  ItemRequirements.item(ItemID.BARROWS_TORAG_HEAD),
                  ItemRequirements.range(ItemID.BARROWS_TORAG_HEAD_100,
                      ItemID.BARROWS_TORAG_HEAD_BROKEN)),
              ItemRequirements.any(
                  "Torag's hammers",
                  ItemRequirements.item(ItemID.BARROWS_TORAG_WEAPON),
                  ItemRequirements.range(ItemID.BARROWS_TORAG_WEAPON_100,
                      ItemID.BARROWS_TORAG_WEAPON_BROKEN)),
              ItemRequirements.any(
                  "Torag's platebody",
                  ItemRequirements.item(ItemID.BARROWS_TORAG_BODY),
                  ItemRequirements.range(ItemID.BARROWS_TORAG_BODY_100,
                      ItemID.BARROWS_TORAG_BODY_BROKEN)),
              ItemRequirements.any(
                  "Torag's platelegs",
                  ItemRequirements.item(ItemID.BARROWS_TORAG_LEGS),
                  ItemRequirements.range(ItemID.BARROWS_TORAG_LEGS_100,
                      ItemID.BARROWS_TORAG_LEGS_BROKEN))),
          ItemRequirements.all(
              ItemRequirements.any(
                  "Verac's helm",
                  ItemRequirements.item(ItemID.BARROWS_VERAC_HEAD),
                  ItemRequirements.range(ItemID.BARROWS_VERAC_HEAD_100,
                      ItemID.BARROWS_VERAC_HEAD_BROKEN)),
              ItemRequirements.any(
                  "Verac's flail",
                  ItemRequirements.item(ItemID.BARROWS_VERAC_WEAPON),
                  ItemRequirements.range(ItemID.BARROWS_VERAC_WEAPON_100,
                      ItemID.BARROWS_VERAC_WEAPON_BROKEN)),
              ItemRequirements.any(
                  "Verac's brassard",
                  ItemRequirements.item(ItemID.BARROWS_VERAC_BODY),
                  ItemRequirements.range(ItemID.BARROWS_VERAC_BODY_100,
                      ItemID.BARROWS_VERAC_BODY_BROKEN)),
              ItemRequirements.any(
                  "Verac's plateskirt",
                  ItemRequirements.item(ItemID.BARROWS_VERAC_LEGS),
                  ItemRequirements.range(
                      ItemID.BARROWS_VERAC_LEGS_100, ItemID.BARROWS_VERAC_LEGS_BROKEN))))),
  IN_THE_MIDDLE_OF_JIGGIG(
      "Jiggig",
      "In the middle of Jiggig",
      STASHUnit.IN_THE_MIDDLE_OF_JIGGIG,
      new int[]{ItemID.TRAIL_HERALDIC_HELM_1_RUNE, ItemID.RUNE_SPEAR, ItemID.RUNE_PLATELEGS},
      ItemRequirements.range(ItemID.TRAIL_HERALDIC_HELM_1_RUNE, ItemID.TRAIL_HERALDIC_HELM_5_RUNE),
      ItemRequirements.item(ItemID.RUNE_SPEAR),
      ItemRequirements.item(ItemID.RUNE_PLATELEGS)),
  BY_THE_BEAR_CAGE_IN_VARROCK_PALACE_GARDENS(
      "Varrock Castle",
      "By the bear cage in Varrock Palace gardens",
      STASHUnit.BY_THE_BEAR_CAGE_IN_VARROCK_PALACE_GARDENS,
      new int[]{ItemID.ZGS},
      ItemRequirements.any(
          "Zamorak godsword",
          ItemRequirements.item(ItemID.ZGS),
          ItemRequirements.item(ItemID.ZGSG))),
  BEHIND_MISS_SCHISM_IN_DRAYNOR_VILLAGE(
      "Draynor Village",
      "Behind Miss Schism in Draynor Village",
      STASHUnit.BEHIND_MISS_SCHISM_IN_DRAYNOR_VILLAGE,
      new int[]{ItemID.ABYSSAL_WHIP, ItemID.CAPE_OF_LEGENDS, ItemID.DAGGANOTH_RANGED_LEGS},
      ItemRequirements.any(
          "Abyssal whip",
          ItemRequirements.item(ItemID.ABYSSAL_WHIP),
          ItemRequirements.item(ItemID.ABYSSAL_WHIP_LAVA),
          ItemRequirements.item(ItemID.ABYSSAL_WHIP_ICE),
          ItemRequirements.item(ItemID.LEAGUE_3_WHIP),
          ItemRequirements.item(ItemID.ABYSSAL_TENTACLE),
          ItemRequirements.item(ItemID.LEAGUE_3_WHIP_TENTACLE)),
      ItemRequirements.item(ItemID.CAPE_OF_LEGENDS),
      ItemRequirements.item(ItemID.DAGGANOTH_RANGED_LEGS)),
  CRYSTALLINE_MAPLE_TREES(
      "North of Prifddinas",
      "North of Prifddinas by several maple trees",
      STASHUnit.CRYSTALLINE_MAPLE_TREES,
      new int[]{ItemID.NATURE_STAFF_UNCHARGED, ItemID.TIARA_NATURE},
      ItemRequirements.range(ItemID.NATURE_STAFF_UNCHARGED, ItemID.NATURE_STAFF_CHARGED),
      ItemRequirements.item(ItemID.TIARA_NATURE)),
  DIGSITE(
      "Digsite",
      "Digsite",
      STASHUnit.DIGSITE,
      new int[]{ItemID.GNOME_HAT_GREEN, ItemID.SNAKESKIN_BOOTS, ItemID.IRON_PICKAXE},
      ItemRequirements.item(ItemID.GNOME_HAT_GREEN),
      ItemRequirements.item(ItemID.SNAKESKIN_BOOTS),
      ItemRequirements.item(ItemID.IRON_PICKAXE)),
  SOUTH_OF_THE_SHRINE_IN_TAI_BWO_WANNAI_VILLAGE(
      "Tai Bwo Wannai",
      "South of the shrine in Tai Bwo Wannai Village",
      STASHUnit.SOUTH_OF_THE_SHRINE_IN_TAI_BWO_WANNAI_VILLAGE,
      new int[]{ItemID.DRAGONHIDE_CHAPS, ItemID.RING_OF_DUELING_1, ItemID.MITHRIL_MED_HELM},
      ItemRequirements.item(ItemID.DRAGONHIDE_CHAPS),
      ItemRequirements.any(
          "Ring of dueling",
          ItemRequirements.item(ItemID.RING_OF_DUELING_1),
          ItemRequirements.item(ItemID.RING_OF_DUELING_2),
          ItemRequirements.item(ItemID.RING_OF_DUELING_3),
          ItemRequirements.item(ItemID.RING_OF_DUELING_4),
          ItemRequirements.item(ItemID.RING_OF_DUELING_5),
          ItemRequirements.item(ItemID.RING_OF_DUELING_6),
          ItemRequirements.item(ItemID.RING_OF_DUELING_7),
          ItemRequirements.item(ItemID.RING_OF_DUELING_8)),
      ItemRequirements.item(ItemID.MITHRIL_MED_HELM)),
  WEST_OF_THE_SHAYZIEN_COMBAT_RING(
      "Shayzien Combat Ring",
      "North of the Shayzien combat ring",
      STASHUnit.WEST_OF_THE_SHAYZIEN_COMBAT_RING,
      new int[]{ItemID.ADAMANT_PLATELEGS, ItemID.ADAMANT_PLATEBODY, ItemID.ADAMANT_FULL_HELM},
      ItemRequirements.item(ItemID.ADAMANT_PLATELEGS),
      ItemRequirements.item(ItemID.ADAMANT_PLATEBODY),
      ItemRequirements.item(ItemID.ADAMANT_FULL_HELM)),
  TENT_IN_LORD_IORWERTHS_ENCAMPMENT(
      "Lord Iorwerth's camp",
      "Tent in Lord Iorwerth's encampment",
      STASHUnit.TENT_IN_LORD_IORWERTHS_ENCAMPMENT,
      new int[]{ItemID.CRYSTAL_BOW},
      ItemRequirements.any(
          "Crystal Bow",
          ItemRequirements.item(ItemID.CRYSTAL_BOW),
          ItemRequirements.item(ItemID.CRYSTAL_BOW_2500),
          ItemRequirements.item(ItemID.BOW_OF_FAERDHINEN),
          ItemRequirements.item(ItemID.BOW_OF_FAERDHINEN_INFINITE),
          ItemRequirements.item(ItemID.BOW_OF_FAERDHINEN_INFINITE_DUMMY),
          ItemRequirements.item(ItemID.BOW_OF_FAERDHINEN_INFINITE_ITHELL),
          ItemRequirements.item(ItemID.BOW_OF_FAERDHINEN_INFINITE_IORWERTH),
          ItemRequirements.item(ItemID.BOW_OF_FAERDHINEN_INFINITE_TRAHAEARN),
          ItemRequirements.item(ItemID.BOW_OF_FAERDHINEN_INFINITE_CADARN),
          ItemRequirements.item(ItemID.BOW_OF_FAERDHINEN_INFINITE_CRWYS),
          ItemRequirements.item(ItemID.BOW_OF_FAERDHINEN_INFINITE_MEILYR),
          ItemRequirements.item(ItemID.BOW_OF_FAERDHINEN_INFINITE_AMLODD),
          ItemRequirements.item(ItemID.BOW_OF_FAERDHINEN_INACTIVE))),
  OUTSIDE_THE_LEGENDS_GUILD_GATES(
      "Legend's Guild",
      "Outside the Legends' Guild gates",
      STASHUnit.OUTSIDE_THE_LEGENDS_GUILD_GATES,
      new int[]{ItemID.IRON_PLATELEGS, ItemID.OAK_LONGBOW, ItemID.STRUNG_EMERALD_AMULET},
      ItemRequirements.item(ItemID.IRON_PLATELEGS),
      ItemRequirements.item(ItemID.OAK_LONGBOW),
      ItemRequirements.item(ItemID.STRUNG_EMERALD_AMULET)),
  OUTSIDE_THE_LEGENDS_GUILD_DOOR(
      "Legend's Guild",
      "Outside the Legends' Guild door",
      STASHUnit.OUTSIDE_THE_LEGENDS_GUILD_DOOR,
      new int[]{ItemID.CAPE_OF_LEGENDS, ItemID.DRAGON_BATTLEAXE, ItemID.AMULET_OF_GLORY},
      ItemRequirements.item(ItemID.CAPE_OF_LEGENDS),
      ItemRequirements.item(ItemID.DRAGON_BATTLEAXE),
      ItemRequirements.any(
          "Any amulet of glory",
          ItemRequirements.item(ItemID.AMULET_OF_GLORY),
          ItemRequirements.item(ItemID.AMULET_OF_GLORY_1),
          ItemRequirements.item(ItemID.AMULET_OF_GLORY_2),
          ItemRequirements.item(ItemID.AMULET_OF_GLORY_3),
          ItemRequirements.item(ItemID.AMULET_OF_GLORY_4),
          ItemRequirements.item(ItemID.AMULET_OF_GLORY_5),
          ItemRequirements.item(ItemID.AMULET_OF_GLORY_6),
          ItemRequirements.item(ItemID.AMULET_OF_GLORY_INF))),
  MUBARIZS_ROOM_AT_THE_DUEL_ARENA(
      "Emir's Arena",
      "Mubariz's room at the Emir's Arena",
      STASHUnit.EMIRS_ARENA_TICKET_OFFICE,
      new int[]{ItemID.IRON_CHAINBODY, ItemID.LEATHER_CHAPS, ItemID.COIF},
      ItemRequirements.item(ItemID.IRON_CHAINBODY),
      ItemRequirements.item(ItemID.LEATHER_CHAPS),
      ItemRequirements.item(ItemID.COIF)),
  TOP_FLOOR_OF_THE_LIGHTHOUSE(
      "Lighthouse",
      "Top floor of the Lighthouse",
      STASHUnit.TOP_FLOOR_OF_THE_LIGHTHOUSE,
      new int[]{ItemID.BLUE_DRAGONHIDE_BODY, ItemID.BLUE_DRAGON_VAMBRACES},
      ItemRequirements.item(ItemID.BLUE_DRAGONHIDE_BODY),
      ItemRequirements.item(ItemID.BLUE_DRAGON_VAMBRACES)),
  SHILO_VILLAGE_BANK(
      "Shilo Village",
      "Shilo Village bank",
      STASHUnit.SHILO_VILLAGE_BANK,
      new int[]{ItemID.MYSTIC_HAT, ItemID.CAVE_GOBLIN_BONE_SPEAR, ItemID.RUNE_PLATEBODY},
      ItemRequirements.item(ItemID.MYSTIC_HAT),
      ItemRequirements.item(ItemID.CAVE_GOBLIN_BONE_SPEAR),
      ItemRequirements.item(ItemID.RUNE_PLATEBODY)),
  NEAR_A_LADDER_IN_THE_WILDERNESS_LAVA_MAZE(
      "Lava maze",
      "Near a ladder in the Wilderness Lava Maze",
      STASHUnit.NEAR_A_LADDER_IN_THE_WILDERNESS_LAVA_MAZE,
      new int[]{ItemID.BLACK_DRAGONHIDE_CHAPS, ItemID.HUNTING_LIGHT_CAPE, ItemID.HUNDRED_ROLLINGPIN},
      ItemRequirements.item(ItemID.BLACK_DRAGONHIDE_CHAPS),
      ItemRequirements.any(
          "Spotted cape",
          ItemRequirements.item(ItemID.HUNTING_LIGHT_CAPE),
          ItemRequirements.item(ItemID.HUNTING_LIGHT_CAPE_WORN)),
      ItemRequirements.item(ItemID.HUNDRED_ROLLINGPIN)),
  OUTSIDE_KRIL_TSUTSAROTHS_ROOM(
      "K'ril's chamber",
      "Outside K'ril Tsutsaroth's room",
      STASHUnit.OUTSIDE_KRIL_TSUTSAROTHS_ROOM,
      new int[]{ItemID.RUNE_FULL_HELM_ZAMORAK, ItemID.SHADOW_MAJ_SHADOW_SWORD},
      ItemRequirements.item(ItemID.RUNE_FULL_HELM_ZAMORAK),
      ItemRequirements.item(ItemID.SHADOW_MAJ_SHADOW_SWORD)),
  TAVERLEY_STONE_CIRCLE(
      "Taverley stone circle",
      "Taverley Stone Circle",
      STASHUnit.TAVERLEY_STONE_CIRCLE,
      new int[]{ItemID.BLUEWIZHAT, ItemID.BRONZE_2H_SWORD, ItemID.HAM_BOOTS},
      ItemRequirements.item(ItemID.BLUEWIZHAT),
      ItemRequirements.item(ItemID.BRONZE_2H_SWORD),
      ItemRequirements.item(ItemID.HAM_BOOTS)),
  NORTH_OF_EVIL_DAVES_HOUSE_IN_EDGEVILLE(
      "Edgeville",
      "North of Evil Dave's house in Edgeville",
      STASHUnit.NORTH_OF_EVIL_DAVES_HOUSE_IN_EDGEVILLE,
      new int[]{ItemID.BROWN_APRON, ItemID.LEATHER_BOOTS, ItemID.LEATHER_GLOVES},
      ItemRequirements.item(ItemID.BROWN_APRON),
      ItemRequirements.item(ItemID.LEATHER_BOOTS),
      ItemRequirements.item(ItemID.LEATHER_GLOVES)),
  OGRE_CAGE_IN_KING_LATHAS_TRAINING_CAMP(
      "King Lathas' camp",
      "Ogre cage in the Ardougne Training Camp",
      STASHUnit.OGRE_CAGE_IN_KING_LATHAS_TRAINING_CAMP,
      new int[]{ItemID.DRAGONHIDE_BODY, ItemID.DRAGONHIDE_CHAPS, ItemID.STEEL_SQ_SHIELD},
      ItemRequirements.item(ItemID.DRAGONHIDE_BODY),
      ItemRequirements.item(ItemID.DRAGONHIDE_CHAPS),
      ItemRequirements.item(ItemID.STEEL_SQ_SHIELD)),
  ENTRANA_CHAPEL(
      "Entrana church",
      "Entrana Chapel",
      STASHUnit.ENTRANA_CHAPEL,
      new int[]{ItemID.BLACK_DRAGON_VAMBRACES, ItemID.BLACK_DRAGONHIDE_CHAPS,
          ItemID.BLACK_DRAGONHIDE_BODY},
      ItemRequirements.item(ItemID.BLACK_DRAGON_VAMBRACES),
      ItemRequirements.item(ItemID.BLACK_DRAGONHIDE_CHAPS),
      ItemRequirements.item(ItemID.BLACK_DRAGONHIDE_BODY)),
  NEAR_THE_ENTRANA_FERRY_IN_PORT_SARIM(
      "Port Sarim",
      "Near the Entrana ferry in Port Sarim",
      STASHUnit.NEAR_THE_ENTRANA_FERRY_IN_PORT_SARIM,
      new int[]{ItemID.COIF, ItemID.STEEL_PLATESKIRT, ItemID.SAPPHIRE_NECKLACE},
      ItemRequirements.item(ItemID.COIF),
      ItemRequirements.item(ItemID.STEEL_PLATESKIRT),
      ItemRequirements.item(ItemID.SAPPHIRE_NECKLACE)),
  OUTSIDE_THE_DIGSITE_EXAM_CENTRE(
      "Exam Centre",
      "Outside the Digsite Exam Centre",
      STASHUnit.OUTSIDE_THE_DIGSITE_EXAM_CENTRE,
      new int[]{ItemID.WHITE_APRON, ItemID.GNOME_BOOTS_GREEN, ItemID.LEATHER_GLOVES},
      ItemRequirements.item(ItemID.WHITE_APRON),
      ItemRequirements.item(ItemID.GNOME_BOOTS_GREEN),
      ItemRequirements.item(ItemID.LEATHER_GLOVES)),
  ON_THE_BRIDGE_TO_THE_MISTHALIN_WIZARDS_TOWER(
      "Wizards' Tower",
      "On the bridge to the Misthalin Wizards' Tower",
      STASHUnit.ON_THE_BRIDGE_TO_THE_MISTHALIN_WIZARDS_TOWER,
      new int[]{ItemID.IRON_MED_HELM, ItemID.EMERALD_RING, ItemID.WHITE_APRON},
      ItemRequirements.item(ItemID.IRON_MED_HELM),
      ItemRequirements.item(ItemID.EMERALD_RING),
      ItemRequirements.item(ItemID.WHITE_APRON)),
  UPSTAIRS_IN_THE_ARDOUGNE_WINDMILL(
      "East Ardougne",
      "Upstairs in the Ardougne windmill",
      STASHUnit.UPSTAIRS_IN_THE_ARDOUGNE_WINDMILL,
      new int[]{ItemID.GNOME_ROBETOP_BLUE, ItemID.HAM_ROBE, ItemID.TIARA},
      ItemRequirements.item(ItemID.GNOME_ROBETOP_BLUE),
      ItemRequirements.item(ItemID.HAM_ROBE),
      ItemRequirements.item(ItemID.TIARA)),
  OUTSIDE_THE_SEERS_VILLAGE_COURTHOUSE(
      "Seers Village",
      "Outside the Seers' Village courthouse",
      STASHUnit.OUTSIDE_THE_SEERS_VILLAGE_COURTHOUSE,
      new int[]{ItemID.ADAMANT_HALBERD, ItemID.MYSTIC_ROBE_BOTTOM, ItemID.DIAMOND_RING},
      ItemRequirements.item(ItemID.ADAMANT_HALBERD),
      ItemRequirements.item(ItemID.MYSTIC_ROBE_BOTTOM),
      ItemRequirements.item(ItemID.DIAMOND_RING)),
  OUTSIDE_THE_WILDERNESS_AXE_HUT(
      "Magic axe hut",
      "Outside the Wilderness axe hut",
      STASHUnit.OUTSIDE_THE_WILDERNESS_AXE_HUT,
      new int[]{ItemID.TRAIL_FLARED_PANTS, ItemID.LOCKPICK},
      ItemRequirements.item(ItemID.TRAIL_FLARED_PANTS),
      ItemRequirements.item(ItemID.LOCKPICK)),
  NORTH_OF_MOUNT_KARUULM(
      "Mount Karuulm",
      "North of Mount Karuulm",
      STASHUnit.NORTH_OF_MOUNT_KARUULM,
      new int[]{ItemID.ADAMNT_WARHAMMER, ItemID.RING_OF_LIFE, ItemID.MITHRIL_ARMOURED_BOOTS},
      ItemRequirements.item(ItemID.ADAMNT_WARHAMMER),
      ItemRequirements.item(ItemID.RING_OF_LIFE),
      ItemRequirements.item(ItemID.MITHRIL_ARMOURED_BOOTS)),
  HICKTONS_ARCHERY_EMPORIUM(
      "Catherby",
      "Hickton's Archery Emporium",
      STASHUnit.HICKTONS_ARCHERY_EMPORIUM,
      new int[]{ItemID.GNOME_BOOTS_BLUE, ItemID.HARDLEATHER_BODY, ItemID.SILVER_SICKLE},
      ItemRequirements.item(ItemID.GNOME_BOOTS_BLUE),
      ItemRequirements.item(ItemID.HARDLEATHER_BODY),
      ItemRequirements.item(ItemID.SILVER_SICKLE)),
  OUTSIDE_HARRYS_FISHING_SHOP_IN_CATHERBY(
      "Catherby",
      "Outside Harry's Fishing Shop in Catherby",
      STASHUnit.OUTSIDE_HARRYS_FISHING_SHOP_IN_CATHERBY,
      new int[]{ItemID.ADAMANT_SQ_SHIELD, ItemID.DTTD_BONE_DAGGER, ItemID.MITHRIL_PLATEBODY},
      ItemRequirements.item(ItemID.ADAMANT_SQ_SHIELD),
      ItemRequirements.item(ItemID.DTTD_BONE_DAGGER),
      ItemRequirements.item(ItemID.MITHRIL_PLATEBODY)),
  GNOME_STRONGHOLD_BALANCING_ROPE(
      "Gnome Stronghold",
      "Gnome Stronghold balancing rope",
      STASHUnit.GNOME_STRONGHOLD_BALANCING_ROPE,
      new int[]{ItemID.STEEL_KITESHIELD, ItemID.RING_OF_FORGING, ItemID.DRAGONHIDE_CHAPS},
      ItemRequirements.item(ItemID.STEEL_KITESHIELD),
      ItemRequirements.item(ItemID.RING_OF_FORGING),
      ItemRequirements.item(ItemID.DRAGONHIDE_CHAPS)),
  TZHAAR_GEM_STORE(
      "Tzhaar gem store",
      "TzHaar gem store",
      STASHUnit.TZHAAR_GEM_STORE,
      new int[]{ItemID.TZHAAR_CAPE_FIRE, ItemID.TZHAAR_THROWINGRING},
      ItemRequirements.any(
          "Fire cape",
          ItemRequirements.item(ItemID.TZHAAR_CAPE_FIRE),
          ItemRequirements.item(ItemID.TZHAAR_CAPE_FIRE_TROUVER),
          ItemRequirements.item(ItemID.SKILLCAPE_MAX_FIRECAPE),
          ItemRequirements.item(ItemID.SKILLCAPE_MAX_FIRECAPE_TROUVER),
          ItemRequirements.item(ItemID.INFERNAL_CAPE),
          ItemRequirements.item(ItemID.INFERNAL_CAPE_TROUVER),
          ItemRequirements.item(ItemID.SKILLCAPE_MAX_INFERNALCAPE),
          ItemRequirements.item(ItemID.SKILLCAPE_MAX_INFERNALCAPE_TROUVER)),
      ItemRequirements.item(ItemID.TZHAAR_THROWINGRING)),
  OUTSIDE_DRAYNOR_VILLAGE_JAIL(
      "Draynor Village jail",
      "Outside Draynor Village jail",
      STASHUnit.OUTSIDE_DRAYNOR_VILLAGE_JAIL,
      new int[]{ItemID.ADAMANT_SWORD, ItemID.STRUNG_SAPPHIRE_AMULET, ItemID.ADAMANT_PLATESKIRT},
      ItemRequirements.item(ItemID.ADAMANT_SWORD),
      ItemRequirements.item(ItemID.STRUNG_SAPPHIRE_AMULET),
      ItemRequirements.item(ItemID.ADAMANT_PLATESKIRT)),
  CROSSROADS_NORTH_OF_DRAYNOR_VILLAGE(
      "Draynor Village",
      "Crossroads north of Draynor Village",
      STASHUnit.CROSSROADS_NORTH_OF_DRAYNOR_VILLAGE,
      new int[]{ItemID.IRON_CHAINBODY, ItemID.SAPPHIRE_RING, ItemID.LONGBOW},
      ItemRequirements.item(ItemID.IRON_CHAINBODY),
      ItemRequirements.item(ItemID.SAPPHIRE_RING),
      ItemRequirements.item(ItemID.LONGBOW)),
  OUTSIDE_THE_FALADOR_PARTY_ROOM(
      "Falador Party Room",
      "Outside the Falador Party Room",
      STASHUnit.OUTSIDE_THE_FALADOR_PARTY_ROOM,
      new int[]{ItemID.STEEL_FULL_HELM, ItemID.STEEL_PLATEBODY, ItemID.IRON_PLATESKIRT},
      ItemRequirements.item(ItemID.STEEL_FULL_HELM),
      ItemRequirements.item(ItemID.STEEL_PLATEBODY),
      ItemRequirements.item(ItemID.IRON_PLATESKIRT)),
  NEAR_A_SHED_IN_LUMBRIDGE_SWAMP(
      "Lumbridge swamp",
      "Near a shed in Lumbridge Swamp",
      STASHUnit.NEAR_A_SHED_IN_LUMBRIDGE_SWAMP,
      new int[]{ItemID.BRONZE_DAGGER, ItemID.IRON_FULL_HELM, ItemID.GOLD_RING},
      ItemRequirements.item(ItemID.BRONZE_DAGGER),
      ItemRequirements.item(ItemID.IRON_FULL_HELM),
      ItemRequirements.item(ItemID.GOLD_RING)),
  LUMBRIDGE_SWAMP_CAVES(
      "Lumbridge swamp caves",
      "Lumbridge Swamp caves",
      STASHUnit.LUMBRIDGE_SWAMP_CAVES,
      new int[]{ItemID.STAFF_OF_AIR, ItemID.BRONZE_FULL_HELM, ItemID.AMULET_OF_POWER},
      ItemRequirements.item(ItemID.STAFF_OF_AIR),
      ItemRequirements.item(ItemID.BRONZE_FULL_HELM),
      ItemRequirements.item(ItemID.AMULET_OF_POWER)),
  OUTSIDE_THE_GREAT_PYRAMID_OF_SOPHANEM(
      "Pyramid Of Sophanem",
      "Outside the great pyramid of Sophanem",
      STASHUnit.OUTSIDE_THE_GREAT_PYRAMID_OF_SOPHANEM,
      new int[]{ItemID.RING_OF_LIFE, ItemID.AMULET_OF_GLORY, ItemID.ADAMANT_2H_SWORD},
      ItemRequirements.item(ItemID.RING_OF_LIFE),
      ItemRequirements.item(ItemID.AMULET_OF_GLORY),
      ItemRequirements.item(ItemID.ADAMANT_2H_SWORD)),
  CENTRE_OF_CANIFIS(
      "Canifis",
      "Centre of Canifis",
      STASHUnit.CENTRE_OF_CANIFIS,
      new int[]{ItemID.GNOME_ROBETOP_GREEN, ItemID.MITHRIL_PLATELEGS, ItemID.IRON_2H_SWORD},
      ItemRequirements.item(ItemID.GNOME_ROBETOP_GREEN),
      ItemRequirements.item(ItemID.MITHRIL_PLATELEGS),
      ItemRequirements.item(ItemID.IRON_2H_SWORD)),
  KING_BLACK_DRAGONS_LAIR(
      "King black dragon's lair",
      "King Black Dragon's lair",
      STASHUnit.KING_BLACK_DRAGONS_LAIR,
      new int[]{ItemID.BLACK_DRAGONHIDE_BODY, ItemID.BLACK_DRAGON_VAMBRACES,
          ItemID.DRAGONMASK_BLACK},
      ItemRequirements.item(ItemID.BLACK_DRAGONHIDE_BODY),
      ItemRequirements.item(ItemID.BLACK_DRAGON_VAMBRACES),
      ItemRequirements.item(ItemID.DRAGONMASK_BLACK)),
  SOUTH_OF_THE_GRAND_EXCHANGE(
      "Grand Exchange",
      "South of the Grand Exchange",
      STASHUnit.SOUTH_OF_THE_GRAND_EXCHANGE,
      new int[]{ItemID.PINK_SKIRT, ItemID.GNOME_ROBETOP_PINK, ItemID.TIARA_BODY},
      ItemRequirements.item(ItemID.PINK_SKIRT),
      ItemRequirements.item(ItemID.GNOME_ROBETOP_PINK),
      ItemRequirements.item(ItemID.TIARA_BODY)),
  OUTSIDE_MUDKNUCKLES_HUT(
      "Goblin Village",
      "Outside Mudknuckles' hut",
      STASHUnit.OUTSIDE_MUDKNUCKLES_HUT,
      new int[]{ItemID.RUNE_PLATEBODY_BANDOS, ItemID.TRAIL_BANDOS_CLOAK, ItemID.BGS},
      ItemRequirements.item(ItemID.RUNE_PLATEBODY_BANDOS),
      ItemRequirements.item(ItemID.TRAIL_BANDOS_CLOAK),
      ItemRequirements.any(
          "Bandos godsword",
          ItemRequirements.item(ItemID.BGS),
          ItemRequirements.item(ItemID.BGSG))),
  AL_KHARID_SCORPION_MINE(
      "Al Kharid mine",
      "Al Kharid scorpion mine",
      STASHUnit.AL_KHARID_SCORPION_MINE,
      new int[]{ItemID.DESERT_SHIRT, ItemID.LEATHER_GLOVES, ItemID.LEATHER_BOOTS},
      ItemRequirements.item(ItemID.DESERT_SHIRT),
      ItemRequirements.item(ItemID.LEATHER_GLOVES),
      ItemRequirements.item(ItemID.LEATHER_BOOTS)),
  INSIDE_THE_DIGSITE_EXAM_CENTRE(
      "Exam Centre",
      "Inside the Digsite Exam Centre",
      STASHUnit.INSIDE_THE_DIGSITE_EXAM_CENTRE,
      new int[]{ItemID.MYSTIC_FIRE_STAFF, ItemID.JEWL_DIAMOND_BRACELET, ItemID.RUNE_ARMOURED_BOOTS},
      ItemRequirements.item(ItemID.MYSTIC_FIRE_STAFF),
      ItemRequirements.item(ItemID.JEWL_DIAMOND_BRACELET),
      ItemRequirements.item(ItemID.RUNE_ARMOURED_BOOTS)),
  OUTSIDE_THE_SLAYER_TOWER_GARGOYLE_ROOM(
      "Slayer Tower",
      "Outside the Slayer Tower gargoyle room",
      STASHUnit.OUTSIDE_THE_SLAYER_TOWER_GARGOYLE_ROOM,
      new int[]{ItemID.DAGANOTH_CAVE_MAGIC_SHORTBOW, ItemID.JEWL_BRACELET_OF_COMBAT_4,
          ItemID.FRIS_KINGLY_HELM},
      ItemRequirements.item(ItemID.DAGANOTH_CAVE_MAGIC_SHORTBOW),
      ItemRequirements.any(
          "Combat bracelet",
          ItemRequirements.range(ItemID.JEWL_BRACELET_OF_COMBAT_4, ItemID.JEWL_BRACELET_OF_COMBAT),
          ItemRequirements.item(ItemID.JEWL_BRACELET_OF_COMBAT_5),
          ItemRequirements.item(ItemID.JEWL_BRACELET_OF_COMBAT_6)),
      ItemRequirements.item(ItemID.FRIS_KINGLY_HELM)),
  OUTSIDE_THE_FISHING_GUILD(
      "Fishing Guild",
      "Outside the Fishing Guild",
      STASHUnit.OUTSIDE_THE_FISHING_GUILD,
      new int[]{ItemID.EMERALD_RING, ItemID.STRUNG_SAPPHIRE_AMULET, ItemID.BRONZE_CHAINBODY},
      ItemRequirements.item(ItemID.EMERALD_RING),
      ItemRequirements.item(ItemID.STRUNG_SAPPHIRE_AMULET),
      ItemRequirements.item(ItemID.BRONZE_CHAINBODY)),
  SHANTAY_PASS(
      "Shantay Pass",
      "Shantay Pass",
      STASHUnit.SHANTAY_PASS,
      new int[]{ItemID.SNELM_POINT_BLUE, ItemID.STAFF_OF_AIR, ItemID.BRONZE_SQ_SHIELD},
      ItemRequirements.any(
          "Bruise blue snelm (pointed)", ItemRequirements.item(ItemID.SNELM_POINT_BLUE)),
      ItemRequirements.item(ItemID.STAFF_OF_AIR),
      ItemRequirements.item(ItemID.BRONZE_SQ_SHIELD)),
  AUBURYS_SHOP_IN_VARROCK(
      "Varrock rune store",
      "Aubury's shop in Varrock",
      STASHUnit.AUBURYS_SHOP_IN_VARROCK,
      new int[]{ItemID.TIARA_AIR, ItemID.STAFF_OF_WATER},
      ItemRequirements.item(ItemID.TIARA_AIR),
      ItemRequirements.item(ItemID.STAFF_OF_WATER)),
  CATHERBY_BEEHIVE_FIELD(
      "Catherby",
      "Catherby beehive field",
      STASHUnit.CATHERBY_BEEHIVE_FIELD,
      new int[]{ItemID.DESERT_SHIRT, ItemID.GNOME_ROBEBOTTOMS_GREEN, ItemID.STEEL_AXE},
      ItemRequirements.item(ItemID.DESERT_SHIRT),
      ItemRequirements.item(ItemID.GNOME_ROBEBOTTOMS_GREEN),
      ItemRequirements.item(ItemID.STEEL_AXE)),
  OUTSIDE_YANILLE_BANK(
      "Yanille",
      "Outside Yanille bank",
      STASHUnit.OUTSIDE_YANILLE_BANK,
      new int[]{ItemID.BROWN_APRON, ItemID.ADAMANT_MED_HELM, ItemID.SNAKESKIN_CHAPS},
      ItemRequirements.item(ItemID.BROWN_APRON),
      ItemRequirements.item(ItemID.ADAMANT_MED_HELM),
      ItemRequirements.item(ItemID.SNAKESKIN_CHAPS)),
  TZHAAR_WEAPONS_STORE(
      "Tzhaar weapon store",
      "TzHaar weapons store",
      STASHUnit.TZHAAR_WEAPONS_STORE,
      new int[]{ItemID.STEEL_LONGSWORD, ItemID.BLUE_DRAGONHIDE_BODY, ItemID.MYSTIC_GLOVES},
      ItemRequirements.item(ItemID.STEEL_LONGSWORD),
      ItemRequirements.item(ItemID.BLUE_DRAGONHIDE_BODY),
      ItemRequirements.item(ItemID.MYSTIC_GLOVES)),
  ENTRANCE_OF_THE_CAVERN_UNDER_THE_WHIRLPOOL(
      "Ancient cavern",
      "Entrance of the cavern under the whirlpool",
      STASHUnit.ENTRANCE_OF_THE_CAVERN_UNDER_THE_WHIRLPOOL,
      new int[]{ItemID.GRANITE_SHIELD, ItemID.SPLITBARK_BODY, ItemID.TRAIL_HERALDIC_HELM_1_RUNE},
      ItemRequirements.item(ItemID.GRANITE_SHIELD),
      ItemRequirements.item(ItemID.SPLITBARK_BODY),
      ItemRequirements.range(ItemID.TRAIL_HERALDIC_HELM_1_RUNE, ItemID.TRAIL_HERALDIC_HELM_5_RUNE)),
  NEAR_A_RUNITE_ROCK_IN_THE_FREMENNIK_ISLES(
      "Fremennik Isles",
      "Near a runite rock in the Fremennik Isles",
      STASHUnit.NEAR_A_RUNITE_ROCK_IN_THE_FREMENNIK_ISLES,
      new int[]{ItemID.RUNE_ARMOURED_BOOTS, ItemID.BASIC_TK_RANK2_BODY, ItemID.DRAGONSTONE_RING},
      ItemRequirements.item(ItemID.RUNE_ARMOURED_BOOTS),
      ItemRequirements.item(ItemID.BASIC_TK_RANK2_BODY),
      ItemRequirements.item(ItemID.DRAGONSTONE_RING)),
  NEAR_THE_PIER_IN_ZULANDRA(
      "Zul-Andra",
      "Near the pier in Zul-Andra",
      STASHUnit.NEAR_THE_PIER_IN_ZULANDRA,
      new int[]{ItemID.DRAGON_2H_SWORD, ItemID.BANDOS_BOOTS, ItemID.TZHAAR_CAPE_OBSIDIAN},
      ItemRequirements.item(ItemID.DRAGON_2H_SWORD),
      ItemRequirements.any(
          "Bandos boots",
          ItemRequirements.item(ItemID.BANDOS_BOOTS),
          ItemRequirements.item(ItemID.GUARDIAN_BOOTS),
          ItemRequirements.item(ItemID.ECHO_BOOTS)),
      ItemRequirements.item(ItemID.TZHAAR_CAPE_OBSIDIAN)),
  FOUNTAIN_OF_HEROES(
      "Fountain of heroes",
      "Fountain of Heroes",
      STASHUnit.FOUNTAIN_OF_HEROES,
      new int[]{ItemID.SPLITBARK_LEGS, ItemID.DRAGON_BOOTS, ItemID.RUNE_LONGSWORD},
      ItemRequirements.item(ItemID.SPLITBARK_LEGS),
      ItemRequirements.any(
          "Dragon boots",
          ItemRequirements.item(ItemID.DRAGON_BOOTS),
          ItemRequirements.item(ItemID.DRAGON_BOOTS_GOLD),
          ItemRequirements.item(ItemID.PRIMORDIAL_BOOTS)),
      ItemRequirements.item(ItemID.RUNE_LONGSWORD)),
  MOUNTAIN_CAMP_GOAT_ENCLOSURE(
      "Mountain Camp",
      "Mountain Camp goat enclosure",
      STASHUnit.MOUNTAIN_CAMP_GOAT_ENCLOSURE,
      new int[]{ItemID.RUNE_FULL_HELM, ItemID.BLUE_DRAGONHIDE_CHAPS, ItemID.FIRE_BATTLESTAFF},
      ItemRequirements.item(ItemID.RUNE_FULL_HELM),
      ItemRequirements.item(ItemID.BLUE_DRAGONHIDE_CHAPS),
      ItemRequirements.item(ItemID.FIRE_BATTLESTAFF)),
  ROAD_JUNCTION_SOUTH_OF_SINCLAIR_MANSION(
      "Sinclair Mansion",
      "Road junction south of Sinclair Mansion",
      STASHUnit.ROAD_JUNCTION_SOUTH_OF_SINCLAIR_MANSION,
      new int[]{ItemID.LEATHER_COWL, ItemID.WIZARDS_ROBE, ItemID.IRON_SCIMITAR},
      ItemRequirements.item(ItemID.LEATHER_COWL),
      ItemRequirements.item(ItemID.WIZARDS_ROBE),
      ItemRequirements.item(ItemID.IRON_SCIMITAR)),
  NEAR_THE_GEM_STALL_IN_ARDOUGNE_MARKET(
      "Ardougne",
      "Near the gem stall in Ardougne market",
      STASHUnit.NEAR_THE_GEM_STALL_IN_ARDOUGNE_MARKET,
      new int[]{ItemID.JEWL_CASTLEWARS_BRACELET3, ItemID.STRUNG_DRAGONSTONE_AMULET,
          ItemID.RING_OF_FORGING},
      ItemRequirements.any(
          "Castle wars bracelet",
          ItemRequirements.range(ItemID.JEWL_CASTLEWARS_BRACELET3, ItemID.JEWL_CASTLEWARS_BRACELET)),
      ItemRequirements.item(ItemID.STRUNG_DRAGONSTONE_AMULET),
      ItemRequirements.item(ItemID.RING_OF_FORGING)),
  LIMESTONE_MINE(
      "Limestone Mine",
      "Limestone mine",
      STASHUnit.LIMESTONE_MINE,
      new int[]{ItemID.BRONZE_PLATELEGS, ItemID.STEEL_PICKAXE, ItemID.STEEL_MED_HELM},
      ItemRequirements.item(ItemID.BRONZE_PLATELEGS),
      ItemRequirements.item(ItemID.STEEL_PICKAXE),
      ItemRequirements.item(ItemID.STEEL_MED_HELM)),
  MAUSOLEUM_OFF_THE_MORYTANIA_COAST(
      "Morytania mausoleum",
      "Mausoleum off the Morytania coast",
      STASHUnit.MAUSOLEUM_OFF_THE_MORYTANIA_COAST,
      new int[]{ItemID.MITHRIL_PLATESKIRT, ItemID.MAPLE_LONGBOW},
      ItemRequirements.item(ItemID.MITHRIL_PLATESKIRT),
      ItemRequirements.item(ItemID.MAPLE_LONGBOW)),
  VOLCANO_IN_THE_NORTHEASTERN_WILDERNESS(
      "Wilderness volcano",
      "Volcano in the north-eastern Wilderness",
      STASHUnit.VOLCANO_IN_THE_NORTHEASTERN_WILDERNESS,
      new int[]{ItemID.HEADBAND_RED, ItemID.TRAIL_ANCIENT_STAFF},
      ItemRequirements.any(
          "Any headband",
          ItemRequirements.range(ItemID.HEADBAND_RED, ItemID.HEADBAND_BROWN),
          ItemRequirements.range(ItemID.HEADBAND_WHITE, ItemID.HEADBAND_GREEN)),
      ItemRequirements.any(
          "Any crozier",
          ItemRequirements.item(ItemID.TRAIL_ANCIENT_STAFF),
          ItemRequirements.item(ItemID.TRAIL_ARMADYL_STAFF),
          ItemRequirements.item(ItemID.TRAIL_BANDOS_STAFF),
          ItemRequirements.range(ItemID.TRAIL_SARADOMIN_STAFF, ItemID.TRAIL_ZAMORAK_STAFF))),
  GNOME_GLIDER_ON_WHITE_WOLF_MOUNTAIN(
      "White Wolf Mountain",
      "Gnome Glider on White Wolf Mountain",
      STASHUnit.GNOME_GLIDER_ON_WHITE_WOLF_MOUNTAIN,
      new int[]{ItemID.MITHRIL_PLATELEGS, ItemID.RING_OF_LIFE, ItemID.RUNE_AXE},
      ItemRequirements.item(ItemID.MITHRIL_PLATELEGS),
      ItemRequirements.item(ItemID.RING_OF_LIFE),
      ItemRequirements.item(ItemID.RUNE_AXE)),
  SOUTHEAST_CORNER_OF_LAVA_DRAGON_ISLE(
      "Lava dragon isle",
      "South-east corner of Lava Dragon Isle",
      STASHUnit.SOUTHEAST_CORNER_OF_LAVA_DRAGON_ISLE,
      new int[]{
          ItemID.DRAGON_MED_HELM, ItemID.TZHAAR_SPIKESHIELD, ItemID.OLAF2_BRINE_SABRE,
          ItemID.RUNE_PLATEBODY,
          ItemID.AMULET_OF_GLORY
      },
      ItemRequirements.item(ItemID.DRAGON_MED_HELM),
      ItemRequirements.item(ItemID.TZHAAR_SPIKESHIELD),
      ItemRequirements.item(ItemID.OLAF2_BRINE_SABRE),
      ItemRequirements.item(ItemID.RUNE_PLATEBODY),
      ItemRequirements.any(
          "Uncharged Amulet of glory", ItemRequirements.item(ItemID.AMULET_OF_GLORY))),
  HALFWAY_DOWN_TROLLWEISS_MOUNTAIN(
      "Trollweiss mountain",
      "Half-way down Trollweiss Mountain",
      STASHUnit.HALFWAY_DOWN_TROLLWEISS_MOUNTAIN,
      new int[]{
          ItemID.BLUE_DRAGON_VAMBRACES, ItemID.DRAGON_SPEAR, ItemID.RUNE_PLATESKIRT,
          ItemID.TROLLROMANCE_TOBOGGON_WAXED
      },
      ItemRequirements.item(ItemID.BLUE_DRAGON_VAMBRACES),
      ItemRequirements.item(ItemID.DRAGON_SPEAR),
      ItemRequirements.item(ItemID.RUNE_PLATESKIRT),
      ItemRequirements.item(ItemID.TROLLROMANCE_TOBOGGON_WAXED)),
  WARRIORS_GUILD_BANK_29047(
      "Warriors' guild",
      "Warriors' Guild bank (master)",
      STASHUnit.WARRIORS_GUILD_BANK_29047,
      new int[]{ItemID.DRAGON_BATTLEAXE, ItemID.DRAGON_PARRYINGDAGGER, ItemID.SLAYER_HELM},
      ItemRequirements.item(ItemID.DRAGON_BATTLEAXE),
      ItemRequirements.any(
          "Dragon defender or Avernic defender",
          ItemRequirements.item(ItemID.DRAGON_PARRYINGDAGGER),
          ItemRequirements.item(ItemID.DRAGON_PARRYINGDAGGER_T),
          ItemRequirements.item(ItemID.DRAGON_PARRYINGDAGGER_TROUVER),
          ItemRequirements.item(ItemID.INFERNAL_DEFENDER),
          ItemRequirements.item(ItemID.INFERNAL_DEFENDER_TROUVER),
          ItemRequirements.item(ItemID.INFERNAL_DEFENDER_GHOMMAL_5),
          ItemRequirements.item(ItemID.INFERNAL_DEFENDER_GHOMMAL_5_TROUVER),
          ItemRequirements.item(ItemID.INFERNAL_DEFENDER_GHOMMAL_6),
          ItemRequirements.item(ItemID.INFERNAL_DEFENDER_GHOMMAL_6_TROUVER)),
      ItemRequirements.any(
          "Any slayer helmet",
          ItemRequirements.item(ItemID.SLAYER_HELM),
          ItemRequirements.item(ItemID.SLAYER_HELM_BLACK),
          ItemRequirements.item(ItemID.SLAYER_HELM_GREEN),
          ItemRequirements.item(ItemID.SLAYER_HELM_PURPLE),
          ItemRequirements.item(ItemID.SLAYER_HELM_RED),
          ItemRequirements.item(ItemID.SLAYER_HELM_TURQUOISE),
          ItemRequirements.item(ItemID.SLAYER_HELM_HYDRA),
          ItemRequirements.item(ItemID.SLAYER_HELM_TWISTED),
          ItemRequirements.item(ItemID.SLAYER_HELM_JAD),
          ItemRequirements.item(ItemID.SLAYER_HELM_VERZIK),
          ItemRequirements.item(ItemID.SLAYER_HELM_ZUK),
          ItemRequirements.item(ItemID.SLAYER_HELM_I),
          ItemRequirements.item(ItemID.SLAYER_HELM_I_BLACK),
          ItemRequirements.item(ItemID.SLAYER_HELM_I_GREEN),
          ItemRequirements.item(ItemID.SLAYER_HELM_I_PURPLE),
          ItemRequirements.item(ItemID.SLAYER_HELM_I_RED),
          ItemRequirements.item(ItemID.SLAYER_HELM_I_TURQUOISE),
          ItemRequirements.item(ItemID.SLAYER_HELM_I_HYDRA),
          ItemRequirements.item(ItemID.SLAYER_HELM_I_TWISTED),
          ItemRequirements.item(ItemID.SLAYER_HELM_I_JAD),
          ItemRequirements.item(ItemID.SLAYER_HELM_I_VERZIK),
          ItemRequirements.item(ItemID.SLAYER_HELM_I_ZUK),
          ItemRequirements.item(ItemID.SW_SLAYER_HELM_I),
          ItemRequirements.item(ItemID.SW_SLAYER_HELM_I_BLACK),
          ItemRequirements.item(ItemID.SW_SLAYER_HELM_I_GREEN),
          ItemRequirements.item(ItemID.SW_SLAYER_HELM_I_RED),
          ItemRequirements.item(ItemID.SW_SLAYER_HELM_I_PURPLE),
          ItemRequirements.item(ItemID.SW_SLAYER_HELM_I_TURQUOISE),
          ItemRequirements.item(ItemID.SW_SLAYER_HELM_I_HYDRA),
          ItemRequirements.item(ItemID.SW_SLAYER_HELM_I_TWISTED),
          ItemRequirements.item(ItemID.SW_SLAYER_HELM_I_JAD),
          ItemRequirements.item(ItemID.SW_SLAYER_HELM_I_VERZIK),
          ItemRequirements.item(ItemID.SW_SLAYER_HELM_I_ZUK))),
  NEAR_THE_PARROTS_IN_ARDOUGNE_ZOO(
      "Ardougne Zoo",
      "Near the parrots in Ardougne Zoo",
      STASHUnit.NEAR_THE_PARROTS_IN_ARDOUGNE_ZOO,
      new int[]{ItemID.STUDDED_BODY, ItemID.BRONZE_PLATELEGS, ItemID.PLAINSTAFF},
      ItemRequirements.item(ItemID.STUDDED_BODY),
      ItemRequirements.item(ItemID.BRONZE_PLATELEGS),
      ItemRequirements.item(ItemID.PLAINSTAFF)),
  OUTSIDE_KEEP_LE_FAYE(
      "Keep Le Faye",
      "Outside Keep Le Faye",
      STASHUnit.OUTSIDE_KEEP_LE_FAYE,
      new int[]{ItemID.COIF, ItemID.IRON_PLATEBODY, ItemID.LEATHER_GLOVES},
      ItemRequirements.item(ItemID.COIF),
      ItemRequirements.item(ItemID.IRON_PLATEBODY),
      ItemRequirements.item(ItemID.LEATHER_GLOVES)),
  FISHING_GUILD_BANK(
      "Fishing Guild",
      "Fishing Guild bank",
      STASHUnit.FISHING_GUILD_BANK,
      new int[]{ItemID.ELEMENTAL_SHIELD, ItemID.BLUE_DRAGONHIDE_CHAPS, ItemID.RUNE_WARHAMMER},
      ItemRequirements.item(ItemID.ELEMENTAL_SHIELD),
      ItemRequirements.item(ItemID.BLUE_DRAGONHIDE_CHAPS),
      ItemRequirements.item(ItemID.RUNE_WARHAMMER)),
  WEST_SIDE_OF_THE_KARAMJA_BANANA_PLANTATION(
      "Karamja",
      "West side of the Karamja banana plantation",
      STASHUnit.WEST_SIDE_OF_THE_KARAMJA_BANANA_PLANTATION,
      new int[]{ItemID.DIAMOND_RING, ItemID.AMULET_OF_POWER},
      ItemRequirements.item(ItemID.DIAMOND_RING),
      ItemRequirements.item(ItemID.AMULET_OF_POWER)),
  WARRIORS_GUILD_BANK(
      "Warriors' guild",
      "Warriors' Guild bank",
      STASHUnit.WARRIORS_GUILD_BANK,
      new int[]{ItemID.BLACK_SALAMANDER},
      ItemRequirements.item(ItemID.BLACK_SALAMANDER)),
  HOSIDIUS_MESS(
      "Hosidius mess hall",
      "Hosidius Mess",
      STASHUnit.HOSIDIUS_MESS,
      new int[]{ItemID.RUNE_HALBERD, ItemID.RUNE_PLATEBODY, ItemID.AMULET_OF_STRENGTH},
      ItemRequirements.item(ItemID.RUNE_HALBERD),
      ItemRequirements.item(ItemID.RUNE_PLATEBODY),
      ItemRequirements.item(ItemID.AMULET_OF_STRENGTH)),
  RIMMINGTON_MINE(
      "Rimmington mine",
      "Rimmington mine",
      STASHUnit.RIMMINGTON_MINE,
      new int[]{ItemID.GOLD_NECKLACE, ItemID.GOLD_RING, ItemID.BRONZE_SPEAR},
      ItemRequirements.item(ItemID.GOLD_NECKLACE),
      ItemRequirements.item(ItemID.GOLD_RING),
      ItemRequirements.item(ItemID.BRONZE_SPEAR)),
  OUTSIDE_CATHERBY_BANK(
      "Catherby",
      "Outside Catherby bank",
      STASHUnit.OUTSIDE_CATHERBY_BANK,
      new int[]{ItemID.MAPLE_LONGBOW, ItemID.DRAGONHIDE_CHAPS, ItemID.IRON_MED_HELM},
      ItemRequirements.item(ItemID.MAPLE_LONGBOW),
      ItemRequirements.item(ItemID.DRAGONHIDE_CHAPS),
      ItemRequirements.item(ItemID.IRON_MED_HELM)),
  CHAOS_TEMPLE_IN_THE_SOUTHEASTERN_WILDERNESS(
      "East of the Level 19 Wilderness Obelisk",
      "Chaos Temple in the south-eastern Wilderness",
      STASHUnit.EAST_OF_THE_LEVEL_19_WILDERNESS_OBELISK,
      new int[]{ItemID.RUNE_PLATELEGS, ItemID.IRON_PLATEBODY, ItemID.BLUE_DRAGON_VAMBRACES},
      ItemRequirements.item(ItemID.RUNE_PLATELEGS),
      ItemRequirements.item(ItemID.IRON_PLATEBODY),
      ItemRequirements.item(ItemID.BLUE_DRAGON_VAMBRACES)),
  SHAYZIEN_WAR_TENT(
      "Shayzien war tent",
      "Shayzien War Tent",
      STASHUnit.SHAYZIEN_WAR_TENT,
      new int[]{ItemID.MYSTIC_ROBE_BOTTOM, ItemID.RUNE_KITESHIELD, ItemID.TRAIL_BOB_SHIRT_RED},
      ItemRequirements.item(ItemID.MYSTIC_ROBE_BOTTOM),
      ItemRequirements.item(ItemID.RUNE_KITESHIELD),
      ItemRequirements.range(ItemID.TRAIL_BOB_SHIRT_RED, ItemID.TRAIL_BOB_SHIRT_PURPLE)),
  CENTRE_OF_THE_CATACOMBS_OF_KOUREND(
      "Kourend catacombs",
      "Centre of the Catacombs of Kourend",
      STASHUnit.CENTRE_OF_THE_CATACOMBS_OF_KOUREND,
      new int[]{ItemID.ARCLIGHT, ItemID.DAMNED_AMULET_DEGRADED},
      ItemRequirements.any("Arclight or Emberlight", ItemRequirements.item(ItemID.ARCLIGHT),
          ItemRequirements.item(ItemID.EMBERLIGHT)),
      ItemRequirements.any(
          "Amulet of the damned",
          ItemRequirements.item(ItemID.DAMNED_AMULET_DEGRADED),
          ItemRequirements.item(ItemID.DAMNED_AMULET))),
  ROAD_JUNCTION_NORTH_OF_RIMMINGTON(
      "Rimmington",
      "Road junction north of Rimmington",
      STASHUnit.ROAD_JUNCTION_NORTH_OF_RIMMINGTON,
      new int[]{ItemID.GNOME_HAT_GREEN, ItemID.GNOME_ROBETOP_CREAM, ItemID.LEATHER_CHAPS},
      ItemRequirements.item(ItemID.GNOME_HAT_GREEN),
      ItemRequirements.item(ItemID.GNOME_ROBETOP_CREAM),
      ItemRequirements.item(ItemID.LEATHER_CHAPS)),
  DRAYNOR_MANOR_BY_THE_FOUNTAIN(
      "Draynor Manor",
      "Draynor Manor by the fountain",
      STASHUnit.DRAYNOR_MANOR_BY_THE_FOUNTAIN,
      new int[]{ItemID.IRON_PLATEBODY, ItemID.STUDDED_CHAPS, ItemID.BRONZE_FULL_HELM},
      ItemRequirements.item(ItemID.IRON_PLATEBODY),
      ItemRequirements.item(ItemID.STUDDED_CHAPS),
      ItemRequirements.item(ItemID.BRONZE_FULL_HELM)),
  SOUL_ALTAR(
      "Soul altar",
      "Soul Altar",
      STASHUnit.SOUL_ALTAR,
      new int[]{ItemID.DRAGON_PICKAXE, ItemID.FRIS_KINGLY_HELM, ItemID.RUNE_ARMOURED_BOOTS},
      ItemRequirements.any(
          "Dragon or Crystal pickaxe",
          ItemRequirements.item(ItemID.DRAGON_PICKAXE),
          ItemRequirements.item(ItemID.DRAGON_PICKAXE_PRETTY),
          ItemRequirements.item(ItemID.INFERNAL_PICKAXE),
          ItemRequirements.item(ItemID.INFERNAL_PICKAXE_EMPTY),
          ItemRequirements.item(ItemID.ZALCANO_PICKAXE),
          ItemRequirements.item(ItemID.TRAILBLAZER_PICKAXE_NO_INFERNAL),
          ItemRequirements.item(ItemID.CRYSTAL_PICKAXE),
          ItemRequirements.item(ItemID.CRYSTAL_PICKAXE_INACTIVE),
          ItemRequirements.item(ItemID.TRAILBLAZER_PICKAXE),
          ItemRequirements.item(ItemID.TRAILBLAZER_PICKAXE_EMPTY)),
      ItemRequirements.item(ItemID.FRIS_KINGLY_HELM),
      ItemRequirements.item(ItemID.RUNE_ARMOURED_BOOTS)),
  OUTSIDE_VARROCK_PALACE_COURTYARD(
      "Varrock Castle",
      "Outside Varrock Palace courtyard",
      STASHUnit.OUTSIDE_VARROCK_PALACE_COURTYARD,
      new int[]{ItemID.BLACK_AXE, ItemID.COIF, ItemID.RUBY_RING},
      ItemRequirements.item(ItemID.BLACK_AXE),
      ItemRequirements.item(ItemID.COIF),
      ItemRequirements.item(ItemID.RUBY_RING)),
  CHAPEL_IN_WEST_ARDOUGNE(
      "West Ardougne Church",
      "Chapel in West Ardougne",
      STASHUnit.CHAPEL_IN_WEST_ARDOUGNE,
      new int[]{ItemID.DRAGON_SPEAR, ItemID.RED_DRAGONHIDE_CHAPS},
      ItemRequirements.item(ItemID.DRAGON_SPEAR),
      ItemRequirements.item(ItemID.RED_DRAGONHIDE_CHAPS)),
  EAST_OF_THE_BARBARIAN_VILLAGE_BRIDGE(
      "Barbarian Village",
      "East of the Barbarian Village bridge",
      STASHUnit.EAST_OF_THE_BARBARIAN_VILLAGE_BRIDGE,
      new int[]{ItemID.WOLFENGLOVES_PURPLE, ItemID.STEEL_KITESHIELD, ItemID.MITHRIL_FULL_HELM},
      ItemRequirements.item(ItemID.WOLFENGLOVES_PURPLE),
      ItemRequirements.item(ItemID.STEEL_KITESHIELD),
      ItemRequirements.item(ItemID.MITHRIL_FULL_HELM)),
  NORTHWESTERN_CORNER_OF_THE_ENCHANTED_VALLEY(
      "Enchanted Valley (BKQ)",
      "North-western corner of the Enchanted Valley",
      STASHUnit.NORTHWESTERN_CORNER_OF_THE_ENCHANTED_VALLEY,
      new int[]{ItemID.DRAGON_AXE},
      ItemRequirements.any(
          "Dragon or Crystal axe",
          ItemRequirements.item(ItemID.DRAGON_AXE),
          ItemRequirements.item(ItemID.TRAILBLAZER_AXE_NO_INFERNAL),
          ItemRequirements.item(ItemID.DRAGON_AXE_2H),
          ItemRequirements.item(ItemID.CRYSTAL_AXE),
          ItemRequirements.item(ItemID.CRYSTAL_AXE_INACTIVE),
          ItemRequirements.item(ItemID.CRYSTAL_AXE_2H),
          ItemRequirements.item(ItemID.CRYSTAL_AXE_2H_INACTIVE),
          ItemRequirements.item(ItemID.INFERNAL_AXE),
          ItemRequirements.item(ItemID.INFERNAL_AXE_EMPTY),
          ItemRequirements.item(ItemID.TRAILBLAZER_AXE),
          ItemRequirements.item(ItemID.TRAILBLAZER_AXE_EMPTY))),
  WHEAT_FIELD_NEAR_THE_LUMBRIDGE_WINDMILL(
      "Lumbridge mill",
      "Wheat field near the Lumbridge windmill",
      STASHUnit.WHEAT_FIELD_NEAR_THE_LUMBRIDGE_WINDMILL,
      new int[]{ItemID.GNOME_ROBETOP_BLUE, ItemID.GNOME_ROBEBOTTOMS_TURQUOISE, ItemID.OAK_SHORTBOW},
      ItemRequirements.item(ItemID.GNOME_ROBETOP_BLUE),
      ItemRequirements.item(ItemID.GNOME_ROBEBOTTOMS_TURQUOISE),
      ItemRequirements.item(ItemID.OAK_SHORTBOW)),
  OBSERVATORY(
      "Observatory",
      "Observatory",
      STASHUnit.OBSERVATORY,
      new int[]{ItemID.MITHRIL_CHAINBODY, ItemID.DRAGONHIDE_CHAPS, ItemID.STRUNG_RUBY_AMULET},
      ItemRequirements.item(ItemID.MITHRIL_CHAINBODY),
      ItemRequirements.item(ItemID.DRAGONHIDE_CHAPS),
      ItemRequirements.item(ItemID.STRUNG_RUBY_AMULET)),
  NEAR_THE_SAWMILL_OPERATORS_BOOTH(
      "Lumber Yard",
      "Near the Sawmill Operator's booth",
      STASHUnit.NEAR_THE_SAWMILL_OPERATORS_BOOTH,
      new int[]{ItemID.HARDLEATHER_BODY, ItemID.LEATHER_CHAPS, ItemID.BRONZE_AXE},
      ItemRequirements.item(ItemID.HARDLEATHER_BODY),
      ItemRequirements.item(ItemID.LEATHER_CHAPS),
      ItemRequirements.item(ItemID.BRONZE_AXE)),
  NEAR_HERQUINS_SHOP_IN_FALADOR(
      "Falador",
      "Near Herquin's shop in Falador",
      STASHUnit.NEAR_HERQUINS_SHOP_IN_FALADOR,
      new int[]{ItemID.MITHRIL_PICKAXE, ItemID.BLACK_PLATEBODY, ItemID.IRON_KITESHIELD},
      ItemRequirements.item(ItemID.MITHRIL_PICKAXE),
      ItemRequirements.item(ItemID.BLACK_PLATEBODY),
      ItemRequirements.item(ItemID.IRON_KITESHIELD)),
  MUDSKIPPER_POINT(
      "Mudskipper Point (AIQ)",
      "Mudskipper Point",
      STASHUnit.MUDSKIPPER_POINT,
      new int[]{ItemID.BLACK_CAPE, ItemID.LEATHER_CHAPS, ItemID.STEEL_MACE},
      ItemRequirements.item(ItemID.BLACK_CAPE),
      ItemRequirements.item(ItemID.LEATHER_CHAPS),
      ItemRequirements.item(ItemID.STEEL_MACE)),
  NORTHERN_WALL_OF_CASTLE_DRAKAN(
      "Castle Drakan",
      "Northern wall of Castle Drakan",
      STASHUnit.NORTHERN_WALL_OF_CASTLE_DRAKAN,
      new int[]{ItemID.DRAGON_SQ_SHIELD, ItemID.SPLITBARK_BODY, ItemID.STRAWBOATER_RED},
      ItemRequirements.any(
          "Dragon sq shield",
          ItemRequirements.item(ItemID.DRAGON_SQ_SHIELD),
          ItemRequirements.item(ItemID.DRAGON_SQ_SHIELD_GOLD)),
      ItemRequirements.item(ItemID.SPLITBARK_BODY),
      ItemRequirements.any(
          "Any boater",
          ItemRequirements.item(ItemID.STRAWBOATER_RED),
          ItemRequirements.item(ItemID.STRAWBOATER_ORANGE),
          ItemRequirements.item(ItemID.STRAWBOATER_GREEN),
          ItemRequirements.item(ItemID.STRAWBOATER_BLUE),
          ItemRequirements.item(ItemID.STRAWBOATER_BLACK),
          ItemRequirements.item(ItemID.STRAWBOATER_PINK),
          ItemRequirements.item(ItemID.STRAWBOATER_PURPLE),
          ItemRequirements.item(ItemID.STRAWBOATER_WHITE))),
  SEVENTH_CHAMBER_OF_JALSAVRAH(
      "Pyramid Plunder",
      "7th Chamber of Jalsavrah",
      STASHUnit._7TH_CHAMBER_OF_JALSAVRAH,
      new int[]{
          ItemID.NTK_JEWELLED_SCEPTRE_3,
          ItemID.ROGUETRADER_MENAPHITE_HAT,
          ItemID.ROGUETRADER_MENAPHITE_TOP,
          ItemID.ROGUETRADER_MENAPHITE_LEGS
      },
      ItemRequirements.any(
          "Pharaoh's sceptre",
          ItemRequirements.item(ItemID.NTK_JEWELLED_SCEPTRE_3),
          ItemRequirements.item(ItemID.NTK_JEWELLED_SCEPTRE_3),
          ItemRequirements.item(ItemID.CERT_NTK_JEWELLED_SCEPTRE_3),
          ItemRequirements.item(ItemID.NTK_JEWELLED_SCEPTRE_2),
          ItemRequirements.item(ItemID.CERT_NTK_JEWELLED_SCEPTRE_2),
          ItemRequirements.item(ItemID.NTK_JEWELLED_SCEPTRE_1),
          ItemRequirements.item(ItemID.CERT_NTK_JEWELLED_SCEPTRE_1),
          ItemRequirements.item(ItemID.NTK_JEWELLED_SCEPTRE_0),
          ItemRequirements.item(ItemID.CERT_NTK_JEWELLED_SCEPTRE_0),
          ItemRequirements.item(ItemID.NTK_JEWELLED_SCEPTRE_8),
          ItemRequirements.item(ItemID.NTK_JEWELLED_SCEPTRE_7),
          ItemRequirements.item(ItemID.NTK_JEWELLED_SCEPTRE_5),
          ItemRequirements.item(ItemID.NTK_JEWELLED_SCEPTRE_4),
          ItemRequirements.item(ItemID.PLACEHOLDER_NTK_JEWELLED_SCEPTRE_8),
          ItemRequirements.item(ItemID.PLACEHOLDER_NTK_JEWELLED_SCEPTRE_1),
          ItemRequirements.item(ItemID.PLACEHOLDER_NTK_JEWELLED_SCEPTRE_0),
          ItemRequirements.item(ItemID.PHARAOHS_SCEPTRE_CHARGED),
          ItemRequirements.item(ItemID.PHARAOHS_SCEPTRE_CHARGED_INITIAL)),
      ItemRequirements.any(
          "Full set of menaphite robes",
          ItemRequirements.all(
              ItemRequirements.item(ItemID.ROGUETRADER_MENAPHITE_HAT),
              ItemRequirements.item(ItemID.ROGUETRADER_MENAPHITE_TOP),
              ItemRequirements.range(ItemID.ROGUETRADER_MENAPHITE_LEGS,
                  ItemID.ROGUETRADER_MENAPHITE_LEGS2)),
          ItemRequirements.all(
              ItemRequirements.item(ItemID.ROGUETRADER_MENAPHITE_HAT_RED),
              ItemRequirements.item(ItemID.ROGUETRADER_MENAPHITE_TOP_RED),
              ItemRequirements.range(ItemID.ROGUETRADER_MENAPHITE_LEGS_RED,
                  ItemID.ROGUETRADER_MENAPHITE_LEGS_RED2)))),
  VARROCK_PALACE_LIBRARY(
      "Varrock Castle",
      "Varrock Palace Library",
      STASHUnit.VARROCK_PALACE_LIBRARY,
      new int[]{ItemID.GNOME_ROBETOP_GREEN, ItemID.HAM_ROBE, ItemID.IRON_WARHAMMER},
      ItemRequirements.item(ItemID.GNOME_ROBETOP_GREEN),
      ItemRequirements.item(ItemID.HAM_ROBE),
      ItemRequirements.item(ItemID.IRON_WARHAMMER)),
  DRAYNOR_VILLAGE_MARKET(
      "Draynor",
      "Draynor Village market",
      STASHUnit.DRAYNOR_VILLAGE_MARKET,
      new int[]{ItemID.STUDDED_CHAPS, ItemID.IRON_KITESHIELD, ItemID.STEEL_LONGSWORD},
      ItemRequirements.item(ItemID.STUDDED_CHAPS),
      ItemRequirements.item(ItemID.IRON_KITESHIELD),
      ItemRequirements.item(ItemID.STEEL_LONGSWORD)),
  CASTLE_WARS_BANK(
      "Castle Wars",
      "Castle Wars bank",
      STASHUnit.CASTLE_WARS_BANK,
      new int[]{ItemID.STRUNG_RUBY_AMULET, ItemID.MITHRIL_SCIMITAR, ItemID.WILDERNESS_CAPE_1},
      ItemRequirements.item(ItemID.STRUNG_RUBY_AMULET),
      ItemRequirements.item(ItemID.MITHRIL_SCIMITAR),
      ItemRequirements.range(ItemID.WILDERNESS_CAPE_1, ItemID.WILDERNESS_CAPE_50)),
  NOTERAZZOS_SHOP_IN_THE_WILDERNESS(
      "Rogues general store",
      "Noterazzo's shop in the Wilderness",
      STASHUnit.NOTERAZZOS_SHOP_IN_THE_WILDERNESS,
      new int[]{ItemID.ADAMANT_SQ_SHIELD, ItemID.BLUE_DRAGON_VAMBRACES, ItemID.RUNE_PICKAXE},
      ItemRequirements.item(ItemID.ADAMANT_SQ_SHIELD),
      ItemRequirements.item(ItemID.BLUE_DRAGON_VAMBRACES),
      ItemRequirements.item(ItemID.RUNE_PICKAXE)),
  ON_TOP_OF_TROLLHEIM_MOUNTAIN(
      "Trollheim Mountain",
      "On top of Trollheim Mountain",
      STASHUnit.ON_TOP_OF_TROLLHEIM_MOUNTAIN,
      new int[]{ItemID.LAVA_BATTLESTAFF, ItemID.BLACK_DRAGON_VAMBRACES,
          ItemID.ELEMENTAL_MIND_SHIELD},
      ItemRequirements.any(
          "Lava battlestaff",
          ItemRequirements.item(ItemID.LAVA_BATTLESTAFF),
          ItemRequirements.item(ItemID.LAVA_BATTLESTAFF_PRETTY)),
      ItemRequirements.item(ItemID.BLACK_DRAGON_VAMBRACES),
      ItemRequirements.item(ItemID.ELEMENTAL_MIND_SHIELD)),
  ENTRANCE_OF_THE_ARCEUUS_LIBRARY(
      "Arceuus library",
      "Entrance of the Arceuus library",
      STASHUnit.ENTRANCE_OF_THE_ARCEUUS_LIBRARY,
      new int[]{ItemID.BLUE_DRAGON_VAMBRACES, ItemID.ADAMANT_ARMOURED_BOOTS, ItemID.ADAMANT_DAGGER},
      ItemRequirements.item(ItemID.BLUE_DRAGON_VAMBRACES),
      ItemRequirements.item(ItemID.ADAMANT_ARMOURED_BOOTS),
      ItemRequirements.item(ItemID.ADAMANT_DAGGER)),
  TOP_FLOOR_OF_THE_YANILLE_WATCHTOWER(
      "Yanille Watchtower",
      "Top floor of the Yanille Watchtower",
      STASHUnit.TOP_FLOOR_OF_THE_YANILLE_WATCHTOWER,
      new int[]{
          ItemID.DRAGON_PLATESKIRT,
          ItemID.DEATH_CLIMBINGBOOTS,
          ItemID.DRAGON_CHAINBODY,
          ItemID.BULLROARER
      },
      ItemRequirements.any(
          "Dragon plateskirt",
          ItemRequirements.item(ItemID.DRAGON_PLATESKIRT),
          ItemRequirements.item(ItemID.DRAGON_PLATESKIRT_GOLD)),
      ItemRequirements.item(ItemID.DEATH_CLIMBINGBOOTS),
      ItemRequirements.any(
          "Dragon chainbody",
          ItemRequirements.item(ItemID.DRAGON_CHAINBODY),
          ItemRequirements.item(ItemID.DRAGON_CHAINBODY_GOLD)),
      ItemRequirements.item(ItemID.BULLROARER)),
  GYPSY_TENT_ENTRANCE(
      "Varrock",
      "Aris's tent",
      STASHUnit.GYPSY_TENT_ENTRANCE,
      new int[]{ItemID.GOLD_RING, ItemID.GOLD_NECKLACE},
      ItemRequirements.item(ItemID.GOLD_RING),
      ItemRequirements.item(ItemID.GOLD_NECKLACE)),
  FINE_CLOTHES_ENTRANCE(
      "Varrock",
      "Iffie Nitter in Varrock",
      STASHUnit.FINE_CLOTHES_ENTRANCE,
      new int[]{ItemID.CHEFS_HAT, ItemID.RED_CAPE},
      ItemRequirements.item(ItemID.CHEFS_HAT),
      ItemRequirements.item(ItemID.RED_CAPE)),
  BOB_AXES_ENTRANCE(
      "Lumbridge",
      "Bob's Brilliant Axes in Lumbridge",
      STASHUnit.BOB_AXES_ENTRANCE,
      new int[]{ItemID.BRONZE_AXE, ItemID.LEATHER_BOOTS},
      ItemRequirements.item(ItemID.BRONZE_AXE),
      ItemRequirements.item(ItemID.LEATHER_BOOTS)),
  CHARCOAL_BURNERS(
      "Charcoal Burners",
      "Near the Charcoal Burners",
      STASHUnit.CHARCOAL_BURNERS,
      new int[]{ItemID.TITHE_REWARD_HAT_MALE, ItemID.SHAYZIEN_BODY_5, ItemID.PYROMANCER_BOTTOM},
      ItemRequirements.any(
          "Farmer's strawhat",
          ItemRequirements.item(ItemID.TITHE_REWARD_HAT_MALE),
          ItemRequirements.item(ItemID.TITHE_REWARD_HAT_FEMALE)),
      ItemRequirements.item(ItemID.SHAYZIEN_BODY_5),
      ItemRequirements.item(ItemID.PYROMANCER_BOTTOM)),
  FORTIS_GRAND_MUSEUM(
      "Fortis Grand Museum",
      "Near the entrance of the Civitas illa Fortis Grand Museum",
      STASHUnit.FORTIS_GRAND_MUSEUM,
      new int[]{ItemID.EMERALD_NECKLACE, ItemID.BLUE_SKIRT, ItemID.GNOME_ROBETOP_TURQUOISE},
      ItemRequirements.item(ItemID.EMERALD_NECKLACE),
      ItemRequirements.item(ItemID.BLUE_SKIRT),
      ItemRequirements.item(ItemID.GNOME_ROBETOP_TURQUOISE)),
  CAM_TORUM_ENTRANCE(
      "Cam Torum",
      "South of the gates to Cam Torum",
      STASHUnit.CAM_TORUM_ENTRANCE,
      new int[]{ItemID.FROST_MOON_HELM, ItemID.FROST_MOON_CHESTPLATE, ItemID.FROST_MOON_TASSETS,
          ItemID.FROSTMOON_SPEAR},
      ItemRequirements.any(
          "Blue moon helm",
          ItemRequirements.item(ItemID.FROST_MOON_HELM),
          ItemRequirements.item(ItemID.FROST_MOON_HELM_DEGRADED)),
      ItemRequirements.any("Blue moon chestplate",
          ItemRequirements.item(ItemID.FROST_MOON_CHESTPLATE),
          ItemRequirements.item(ItemID.FROST_MOON_CHESTPLATE_DEGRADED)),
      ItemRequirements.any("Blue moon tassets",
          ItemRequirements.item(ItemID.FROST_MOON_TASSETS),
          ItemRequirements.item(ItemID.FROST_MOON_TASSETS_DEGRADED)),
      ItemRequirements.item(ItemID.FROSTMOON_SPEAR)
  ),
  TEMPLE_SOUTHEAST_OF_THE_BAZAAR(
      "Civitas illa Fortis",
      "Outside the temple in Civitas illa Fortis",
      STASHUnit.TEMPLE_SOUTHEAST_OF_THE_BAZAAR,
      new int[]{ItemID.SUNFIRE_HELM, ItemID.SUNFIRE_BODY,
          ItemID.SUNFIRE_LEGS},
      ItemRequirements.any(
          "Any piece of Sunfire Fanatic armour",
          ItemRequirements.item(ItemID.SUNFIRE_HELM),
          ItemRequirements.item(ItemID.SUNFIRE_BODY),
          ItemRequirements.item(ItemID.SUNFIRE_LEGS))),
  TWILIGHT_TEMPLE_MINE(
      "Twilight Temple mine",
      "North of the Twilight Temple",
      STASHUnit.TWILIGHT_TEMPLE_MINE,
      new int[]{ItemID.MAPLE_LONGBOW, ItemID.STRUNG_RUBY_AMULET, ItemID.STEEL_PLATELEGS},
      ItemRequirements.item(ItemID.MAPLE_LONGBOW),
      ItemRequirements.item(ItemID.STRUNG_RUBY_AMULET),
      ItemRequirements.item(ItemID.STEEL_PLATELEGS)),
  ORTUS_MEETS_PROUDSPIRE(
      "East of Proudspire",
      "Where the River Ortus meets the Proudspire",
      STASHUnit.ORTUS_MEETS_PROUDSPIRE,
      new int[]{ItemID.BLUEWIZHAT, ItemID.WIZARDS_ROBE},
      ItemRequirements.item(ItemID.BLUEWIZHAT),
      ItemRequirements.item(ItemID.WIZARDS_ROBE)),
  OUTSIDE_TWILIGHT_TEMPLE(
      "Twilight Temple",
      "Twilight Temple",
      STASHUnit.OUTSIDE_TWILIGHT_TEMPLE,
      new int[]{ItemID.RUNE_LONGSWORD, ItemID.RUNE_PLATEBODY, ItemID.RUNE_PLATESKIRT},
      ItemRequirements.item(ItemID.RUNE_LONGSWORD),
      ItemRequirements.item(ItemID.RUNE_PLATEBODY),
      ItemRequirements.item(ItemID.RUNE_PLATESKIRT)),
  WESTERN_SALVAGER_OVERLOOK(
      "Western Salvager Overlook",
      "West side of Salvager Overlook",
      STASHUnit.WESTERN_SALVAGER_OVERLOOK,
      new int[]{ItemID.HUEY_COIF, ItemID.HUEY_VAMBRACES},
      ItemRequirements.item(ItemID.HUEY_COIF),
      ItemRequirements.item(ItemID.HUEY_VAMBRACES));

  private final String locationName;
  private final String chartText;
  private final STASHUnit stashUnitData;
  private final int[] defaultItemIds;
  private final ItemRequirement[] itemRequirements;

  StashUnit(
      String locationName,
      String chartText,
      STASHUnit stashUnitData,
      @Nonnull int[] defaultItemIds,
      @Nonnull ItemRequirement... itemRequirements) {
    this.locationName = locationName;
    this.stashUnitData = stashUnitData;
    this.chartText = chartText;
    this.defaultItemIds = defaultItemIds;
    this.itemRequirements = itemRequirements;
  }
}

package dev.thource.runelite.dudewheresmystuff.stash;

import com.google.inject.Inject;
import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import java.util.Objects;
import java.util.Optional;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.Widget;

/** StashStorageManager is responsible for managing all StashStorages. */
@Slf4j
public class StashStorageManager extends StorageManager<StashStorageType, StashStorage> {

  private boolean updatedThisOpening = false;

  @Inject
  private StashStorageManager(DudeWheresMyStuffPlugin plugin) {
    super(plugin);

    for (StashUnit stashUnit : StashUnit.values()) {
      storages.add(new StashStorage(plugin, stashUnit));
    }
  }

  @Override
  public void onGameTick() {
    super.onGameTick();

    Widget stashChartWidget = client.getWidget(493, 2);
    if (stashChartWidget == null) {
      updatedThisOpening = false;
      return;
    }
    if (updatedThisOpening) {
      return;
    }

    updatedThisOpening = true;

    boolean updated = updateBeginnerStashChartItems();
    if (updateEasyStashChartItems()) {
      updated = true;
    }
    if (updateMediumStashChartItems()) {
      updated = true;
    }
    if (updateHardStashChartItems()) {
      updated = true;
    }
    if (updateEliteStashChartItems()) {
      updated = true;
    }
    if (updateMasterStashChartItems()) {
      updated = true;
    }

    if (updated) {
      updateStorages(storages);
    }
  }

  private boolean updateBeginnerStashChartItems() {
    return updateStashChartItems(4);
  }

  private boolean updateEasyStashChartItems() {
    return updateStashChartItems(6);
  }

  private boolean updateMediumStashChartItems() {
    return updateStashChartItems(8);
  }

  private boolean updateHardStashChartItems() {
    return updateStashChartItems(10);
  }

  private boolean updateEliteStashChartItems() {
    return updateStashChartItems(12);
  }

  private boolean updateMasterStashChartItems() {
    return updateStashChartItems(14);
  }

  private boolean updateStashChartItems(int childId) {
    Widget stashWidget = client.getWidget(493, childId);
    if (stashWidget == null) {
      return false;
    }

    Widget[] widgetChildren = stashWidget.getChildren();
    if (widgetChildren == null) {
      return false;
    }

    Optional<StashStorage> stashStorage = Optional.empty();
    boolean built = false;
    boolean filled = false;
    for (Widget widget : widgetChildren) {
      if (widget.getType() == 4) {
        if (stashStorage.isPresent()) {
          updateStashChartItem(stashStorage.get(), filled);
        }

        stashStorage = findStashStorageFromChartText(getChartText(widget, childId));
        if (!stashStorage.isPresent()) {
          log.info("Missing " + childId + " STASH unit: " + getChartText(widget, childId));
        }
        built = false;
        filled = false;
      } else if (widget.getType() == 5 && stashStorage.isPresent()) {
        if (built) {
          filled = true;
        } else {
          built = true;
        }
      }
    }
    if (stashStorage.isPresent()) {
      updateStashChartItem(stashStorage.get(), filled);
    }

    return true;
  }

  private String getChartText(Widget widget, int childId) {
    if (Objects.equals(widget.getText(), "Warriors' Guild bank") && childId == 14) {
      return "Warriors' Guild bank (master)";
    }

    return widget.getText();
  }

  private void updateStashChartItem(StashStorage stashStorage, boolean filled) {
    stashStorage.setLastUpdated(System.currentTimeMillis());

    if (filled && stashStorage.getItems().isEmpty()) {
      for (int defaultItemId : stashStorage.getStashUnit().getDefaultItemIds()) {
        stashStorage.getItems().add(new ItemStack(defaultItemId, 1, plugin));
      }
    } else if (!filled && !stashStorage.getItems().isEmpty()) {
      stashStorage.getItems().clear();
    }
  }

  private Optional<StashStorage> findStashStorageFromChartText(String text) {
    return storages.stream()
        .filter(s -> Objects.equals(s.getStashUnit().getChartText(), text))
        .findFirst();
  }

  @Override
  public String getConfigKey() {
    return "stash";
  }

}

package dev.thource.runelite.dudewheresmystuff.stash;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.StorageTabPanel;

/** StashStorageTabPanel is responsible for displaying STASH unit data to the player. */
public class StashStorageTabPanel
    extends StorageTabPanel<StashStorageType, StashStorage, StashStorageManager> {

  public StashStorageTabPanel(DudeWheresMyStuffPlugin plugin, StashStorageManager storageManager) {
    super(plugin, storageManager);
  }
}

package dev.thource.runelite.dudewheresmystuff.stash;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemContainerWatcher;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.ItemStorage;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import java.util.Objects;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.plugins.cluescrolls.clues.item.ItemRequirement;

/** StashStorage is responsible for tracking storages that the players STASH units. */
@Getter
public class StashStorage extends ItemStorage<StashStorageType> {

  private final StashUnit stashUnit;
  private boolean handleWithdrawOnTick = false;
  private boolean handleDepositOnTick = false;

  protected StashStorage(DudeWheresMyStuffPlugin plugin, StashUnit stashUnit) {
    super(StashStorageType.STASH, plugin);
    this.stashUnit = stashUnit;
  }

  @Override
  protected void createStoragePanel(StorageManager<?, ?> storageManager) {
    super.createStoragePanel(storageManager);
    assert storagePanel != null;

    storagePanel.setTitleToolTip(stashUnit.getChartText());

    createComponentPopupMenu(storageManager);
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (chatMessage.getType() != ChatMessageType.SPAM
        && chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
      return false;
    }

    if (stashUnit
        .getStashUnitData()
        .getWorldPoints()[0]
        .distanceTo(plugin.getClient().getLocalPlayer().getWorldLocation())
        > 3) {
      return false;
    }

    if (Objects.equals(chatMessage.getMessage(), "You withdraw your items from the STASH unit.")) {
      handleWithdrawOnTick = true;
    } else if (Objects.equals(
        chatMessage.getMessage(), "You deposit your items into the STASH unit.")) {
      handleDepositOnTick = true;
    }

    return true;
  }

  @Override
  public boolean onGameTick() {
    if (handleWithdrawOnTick && handleDepositOnTick) {
      return false;
    }

    final boolean updated = handleWithdrawOnTick || handleDepositOnTick;
    if (handleWithdrawOnTick) {
      handleWithdraw();
    }
    if (handleDepositOnTick) {
      handleDeposit();
    }

    handleWithdrawOnTick = false;
    handleDepositOnTick = false;
    return updated;
  }

  private void handleWithdraw() {
    updateLastUpdated();
    items.clear();
  }

  private void handleDeposit() {
    updateLastUpdated();
    items.clear();
    for (ItemStack itemStack :
        ItemContainerWatcher.getInventoryWatcher().getItemsRemovedLastTick()) {
      for (ItemRequirement itemRequirement : stashUnit.getItemRequirements()) {
        if (itemRequirement.fulfilledBy(itemStack.getId())) {
          items.add(itemStack);
          break;
        }
      }
    }
  }

  @Override
  public String getName() {
    if (stashUnit == null) {
      return "";
    }

    return stashUnit.getLocationName();
  }

  @Override
  protected String getConfigKey(String managerConfigKey) {
    return managerConfigKey + "." + stashUnit.getStashUnitData().getObjectId();
  }
}

package dev.thource.runelite.dudewheresmystuff;

import dev.thource.runelite.dudewheresmystuff.death.DeathpileColorScheme;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Range;

/** DudeWheresMyStuffConfig manages the config for the plugin. */
@SuppressWarnings("SameReturnValue")
@ConfigGroup("dudewheresmystuff")
public interface DudeWheresMyStuffConfig extends Config {

  String CONFIG_GROUP = "dudewheresmystuff";

  @ConfigSection(
      name = "Data Export",
      description = "Settings for data exports",
      position = 100)
  String DATA_EXPORT_OPTIONS = "Data Export";

  @ConfigSection(
      name = "Deathpiles / Graves",
      description = "Settings for deathpiles and graves",
      position = 100
  )
  String DEATHPILE_OPTIONS_SECTION = "Deathpiles / Graves";

  @ConfigItem(
      keyName = "showEmptyStorages",
      name = "Show empty storages",
      description = "Whether storages with no items should be shown")
  default boolean showEmptyStorages() {
    return true;
  }

  @ConfigItem(
      keyName = "sidebarIcon",
      name = "Sidebar icon",
      description = "Which icon to display in the RuneLite sidebar")
  default SidebarIcon sidebarIcon() {
    return SidebarIcon.DEFAULT;
  }

  @ConfigItem(
      keyName = "exportCombineItems",
      name = "Combine items in Export",
      section = DATA_EXPORT_OPTIONS,
      position = 2,
      description =
          "When enabled, items from different storages will be combined into a single "
              + "row in the exported CSV file. This means that the CSV won't contain which item is in "
              + "which storage.")
  default boolean exportCombineItems() {
    return false;
  }

  @ConfigItem(
      keyName = "googleSpreadSheetId",
      name = "Google Spreadsheet ID",
      section = DATA_EXPORT_OPTIONS,
      position = 101,
      description =
          "Google spreadsheet ID if you have an existing sheet. The target sheet must have been created by the plugin. If you do not provide this, we will create one and populate this field.")
  default String googleSpreadSheetId() {
    return "";
  }

  @ConfigItem(keyName = "googleSpreadSheetId", name = "", description = "", hidden = true)
  void setGoogleSpreadSheetId(String spreadSheetId);

  @ConfigItem(
      keyName = "googleSpreadSheetUrl",
      name = "Google Spreadsheet URL",
      section = DATA_EXPORT_OPTIONS,
      position = 101,
      description = "Google spreadsheet URL to the sheet. Auto populated.")
  default String googleSpreadSheetUrl() {
    return "";
  }

  @ConfigItem(keyName = "googleSpreadSheetUrl", name = "", description = "", hidden = true)
  void setGoogleSpreadSheetUrl(String spreadSheetUrl);

  @ConfigSection(
      name = "Item Count Tooltip",
      description = "Settings for the item count tooltip",
      position = 100
  )
  String ITEM_COUNT_TOOLTIP_SECTION = "Item Count Tooltip";

  @ConfigItem(
      keyName = "storedItemCountTooltip",
      name = "Display mode",
      description = "Adds a tooltip when you hover items that tells you how many of those item you "
          + "have stored. \"Simple\" mode shows a sum, \"Detailed\" mode tells you where they are "
          + "stored.",
      section = ITEM_COUNT_TOOLTIP_SECTION)
  default StoredItemCountTooltipMode storedItemCountTooltip() {
    return StoredItemCountTooltipMode.OFF;
  }

  @ConfigItem(
      keyName = "storedItemCountTooltipKeybind",
      name = "Keybind",
      description = "Hold this key down to display the item count tooltip.",
      section = ITEM_COUNT_TOOLTIP_SECTION
  )
  default Keybind storedItemCountTooltipKeybind() {
    return Keybind.NOT_SET;
  }

  @ConfigItem(
      keyName = "storedItemCountInclude.carryable",
      name = "Include carry-able storages",
      description = "Whether carry-able storages should be included in the item count.",
      section = ITEM_COUNT_TOOLTIP_SECTION,
      position = 100
  )
  default boolean storedItemCountIncludeCarryable() {
    return true;
  }

  @ConfigItem(
      keyName = "storedItemCountInclude.coins",
      name = "Include coin storages",
      description = "Whether coin storages should be included in the item count.",
      section = ITEM_COUNT_TOOLTIP_SECTION,
      position = 101
  )
  default boolean storedItemCountIncludeCoins() {
    return true;
  }

  @ConfigItem(
      keyName = "storedItemCountInclude.death",
      name = "Include death storages",
      description = "Whether death storages should be included in the item count.",
      section = ITEM_COUNT_TOOLTIP_SECTION,
      position = 102
  )
  default boolean storedItemCountIncludeDeath() {
    return true;
  }

  @ConfigItem(
      keyName = "storedItemCountInclude.minigames",
      name = "Include minigame storages",
      description = "Whether minigame storages should be included in the item count.",
      section = ITEM_COUNT_TOOLTIP_SECTION,
      position = 103
  )
  default boolean storedItemCountIncludeMinigames() {
    return true;
  }

  @ConfigItem(
      keyName = "storedItemCountInclude.poh",
      name = "Include POH storages",
      description = "Whether POH storages should be included in the item count.",
      section = ITEM_COUNT_TOOLTIP_SECTION,
      position = 104
  )
  default boolean storedItemCountIncludePOH() {
    return true;
  }

  @ConfigItem(
      keyName = "storedItemCountInclude.stash",
      name = "Include stash storages",
      description = "Whether stash storages should be included in the item count.",
      section = ITEM_COUNT_TOOLTIP_SECTION,
      position = 105
  )
  default boolean storedItemCountIncludeStash() {
    return true;
  }

  @ConfigItem(
      keyName = "storedItemCountInclude.world",
      name = "Include world storages",
      description = "Whether world storages should be included in the item count.",
      section = ITEM_COUNT_TOOLTIP_SECTION,
      position = 106
  )
  default boolean storedItemCountIncludeWorld() {
    return true;
  }

  @ConfigItem(
      keyName = "deathbankInfoBox",
      name = "Show infobox for deathbank",
      description = "When enabled, an infobox will be displayed while you have an active "
          + "deathbank.")
  default boolean deathbankInfoBox() {
    return true;
  }

  @ConfigItem(
      keyName = "showDeathStorageRiskWarning",
      name = "Display death storage risk warning",
      description = "When enabled, a banner is displayed at the top of the death storage tab, "
          + "warning against relying solely on the plugin for death storages."
  )
  default boolean showDeathStorageRiskWarning() {
    return true;
  }

  @ConfigItem(
      keyName = "deathpileColorScheme",
      name = "Color scheme",
      description = "Which color scheme should be used for deathpiles.",
      section = DEATHPILE_OPTIONS_SECTION,
      position = 100
  )
  default DeathpileColorScheme deathpileColorScheme() {
    return DeathpileColorScheme.FULL_COLOR;
  }

  @ConfigItem(
      keyName = "deathpilesUseAccountPlayTime",
      name = "Cross-client tracking",
      description = "When enabled, deathpile/grave expiry will be based on account play time, this "
          + "means that if you play for 5 minutes on another client (like mobile) your "
          + "deathpile/grave timer will still be accurate.<br><br>Using this option requires you "
          + "to set your quest tab to the \"Character summary\" tab (brown star icon) once per "
          + "login. With this option enabled, an infobox will be displayed prompting you to swap "
          + "to the \"Character summary\" tab when the plugin doesn't know your play time.<br><br>"
          + "If the plugin doesn't know your play time at the time of your death, the "
          + "deathpile/grave will default to non cross-client tracking mode.",
      section = DEATHPILE_OPTIONS_SECTION,
      position = 101
  )
  default boolean deathpilesUseAccountPlayTime() {
    return false;
  }

  @ConfigItem(
      keyName = "deathpileInfoBox",
      name = "Show infoboxes",
      description = "When enabled, infoboxes will be displayed while you have active deathpiles / "
          + "graves.",
      section = DEATHPILE_OPTIONS_SECTION,
      position = 102
  )
  default boolean deathpileInfoBox() {
    return true;
  }

  @ConfigItem(
      keyName = "deathpileTileMarkers",
      name = "Show tile markers",
      description = "When enabled, activate deathpiles / graves will be indicated by tile markers.",
      section = DEATHPILE_OPTIONS_SECTION,
      position = 103
  )
  default boolean deathpileTileMarkers() {
    return true;
  }

  @Range(
      min = 1,
      max = 59
  )
  @ConfigItem(
      keyName = "deathpileContingencyMinutes",
      name = "Contingency (minutes)",
      description = "This amount of minutes is removed from the deathpile / grave timer. If set to "
          + "15, any new deathpiles / graves will start with 45 minutes until expiry.",
      section = DEATHPILE_OPTIONS_SECTION,
      position = 104
  )
  default int deathpileContingencyMinutes() {
    return 1;
  }

  @ConfigItem(
      keyName = "flashExpiringDeathpileInfoboxes",
      name = "Flash expiring infoboxes",
      description = "Flash the infoboxes of expiring deathpiles / graves red.",
      section = DEATHPILE_OPTIONS_SECTION,
      position = 105
  )
  default boolean flashExpiringDeathpileInfoboxes() {
    return true;
  }

  @ConfigItem(
      keyName = "flashExpiringDeathpileTiles",
      name = "Flash expiring tiles",
      description = "Flash the tile borders of expiring deathpiles / graves red.",
      section = DEATHPILE_OPTIONS_SECTION,
      position = 106
  )
  default boolean flashExpiringDeathpileTiles() {
    return true;
  }

  @ConfigItem(
      keyName = "showDeathpileExpiryText",
      name = "Show expiry text",
      description = "Show on-screen text when your oldest deathpile / grave is expiring.",
      section = DEATHPILE_OPTIONS_SECTION,
      position = 107
  )
  default boolean showDeathpileExpiryText() {
    return false;
  }

  @ConfigItem(
      keyName = "deathpileExpiryWarningTime",
      name = "Expiry warning time",
      description = "The minutes remaining on your oldest deathpile / grave before you start getting alerted.",
      section = DEATHPILE_OPTIONS_SECTION,
      position = 108
  )
  default int deathpileExpiryWarningTime() {
    return 5;
  }

  @ConfigItem(
      keyName = "deathpileExpiryWarningFontSize",
      name = "Expiry font size",
      description = "Font size for the deathpile / grave expiry text warning.",
      section = DEATHPILE_OPTIONS_SECTION,
      position = 109
  )
  default int deathpileExpiryWarningFontSize() {
    return 32;
  }

  @ConfigItem(
      keyName = "itemSortMode",
      name = "Item Sort Mode",
      description = "Which mode to use when sorting items",
      hidden = true)
  default ItemSortMode itemSortMode() {
    return ItemSortMode.UNSORTED;
  }

  @ConfigItem(keyName = "itemSortMode", name = "", description = "", hidden = true)
  void setItemSortMode(ItemSortMode itemSortMode);
}

package dev.thource.runelite.dudewheresmystuff;

import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.client.ui.PluginPanel;

/**
 * DudeWheresMyStuffPanelContainer hosts 2 DudeWheresMyStuffPanels, one for active data and one for
 * preview.
 */
public class DudeWheresMyStuffPanelContainer extends PluginPanel {

  @Getter private final DudeWheresMyStuffPanel panel;
  @Getter private final DudeWheresMyStuffPanel previewPanel;
  private boolean previewing;
  private boolean active;

  DudeWheresMyStuffPanelContainer(
      DudeWheresMyStuffPanel panel, DudeWheresMyStuffPanel previewPanel) {
    super(false);

    this.panel = panel;
    this.previewPanel = previewPanel;

    setLayout(new InvisibleGridLayout(0, 1));
    setBorder(new EmptyBorder(0, 0, 0, 0));

    add(panel);
    add(previewPanel);

    reset();
  }

  void reset() {
    panel.reset();
    previewPanel.reset();

    disablePreviewMode();
  }

  void disablePreviewMode() {
    panel.setVisible(true);
    panel.setActive(active);

    previewPanel.setVisible(false);
    previewPanel.setActive(false);

    previewing = false;
    softUpdate();
  }

  void enablePreviewMode() {
    panel.setVisible(false);
    panel.setActive(false);

    previewPanel.setVisible(true);
    previewPanel.setActive(active);

    previewing = true;
    softUpdate();
  }

  void softUpdate() {
    if (!active) {
      return;
    }

    previewPanel.softUpdate();
    panel.softUpdate();
  }

  @Override
  public void onActivate() {
    active = true;

    if (previewing) {
      previewPanel.setActive(true);
    } else {
      panel.setActive(true);
    }

    softUpdate();
  }

  @Override
  public void onDeactivate() {
    active = false;

    previewPanel.setActive(false);
    panel.setActive(false);
  }

  void reorderStoragePanels() {
    if (previewing) {
      previewPanel.reorderStoragePanels();
    } else {
      panel.reorderStoragePanels();
    }
  }

  void setItemSortMode(ItemSortMode itemSortMode) {
    panel.setItemSortMode(itemSortMode);
    previewPanel.setItemSortMode(itemSortMode);
  }
}

package dev.thource.runelite.dudewheresmystuff;

import java.util.List;
import java.util.Locale;
import java.util.stream.Collectors;
import lombok.Setter;

class SearchStoragePanel extends StoragePanel {

  @Setter private String searchText = "";

  public SearchStoragePanel(DudeWheresMyStuffPlugin plugin, Storage<?> storage) {
    super(plugin, storage, false, false, true);
  }

  @Override
  protected List<ItemStack> getNewItems() {
    return super.getNewItems().stream()
        .filter(
            item ->
                searchText == null
                    || item.getName()
                    .toLowerCase(Locale.ROOT)
                    .contains(searchText.toLowerCase(Locale.ROOT)))
        .collect(Collectors.toList());
  }
}

package dev.thource.runelite.dudewheresmystuff;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;

/** DurationFormatter formats millisecond durations into human-readable Strings. */
public class DurationFormatter {

  private static final List<Long> times =
      Arrays.asList(
          TimeUnit.DAYS.toMillis(365),
          TimeUnit.DAYS.toMillis(30),
          TimeUnit.DAYS.toMillis(1),
          TimeUnit.HOURS.toMillis(1),
          TimeUnit.MINUTES.toMillis(1),
          TimeUnit.SECONDS.toMillis(1));
  private static final List<String> timesString =
      Arrays.asList("year", "month", "day", "hour", "minute", "second");

  private DurationFormatter() {
  }

  /**
   * Converts a millisecond duration into a human-readable String.
   *
   * @param duration millisecond duration
   * @return a human-readable String
   */
  public static String format(long duration) {
    StringBuilder res = new StringBuilder();
    for (int i = 0; i < DurationFormatter.times.size(); i++) {
      Long current = DurationFormatter.times.get(i);
      long temp = duration / current;
      if (temp > 0) {
        res.append(temp)
            .append(" ")
            .append(DurationFormatter.timesString.get(i))
            .append(temp != 1 ? "s" : "");
        break;
      }
    }
    if ("".contentEquals(res)) {
      return "0 seconds";
    } else {
      return res.toString();
    }
  }
}

/*
 * Copyright (c) 2019, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package dev.thource.runelite.dudewheresmystuff;

import com.google.common.collect.ImmutableMap;
import java.util.Map;
import java.util.function.Predicate;
import lombok.AllArgsConstructor;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.plugins.itemidentification.ItemIdentificationConfig;

// Suppress duplicate string literal warning because this class is copied from runelite
@SuppressWarnings("java:S1192")
enum ItemIdentification {
  // Seeds
  GUAM_SEED(Type.SEED_HERB, "Guam", "G", ItemID.GUAM_SEED),
  MARRENTILL_SEED(Type.SEED_HERB, "Marren", "M", ItemID.MARRENTILL_SEED),
  TARROMIN_SEED(Type.SEED_HERB, "Tarro", "TAR", ItemID.TARROMIN_SEED),
  HARRALANDER_SEED(Type.SEED_HERB, "Harra", "H", ItemID.HARRALANDER_SEED),
  RANARR_SEED(Type.SEED_HERB, "Ranarr", "R", ItemID.RANARR_SEED),
  TOADFLAX_SEED(Type.SEED_HERB, "Toad", "TOA", ItemID.TOADFLAX_SEED),
  IRIT_SEED(Type.SEED_HERB, "Irit", "I", ItemID.IRIT_SEED),
  AVANTOE_SEED(Type.SEED_HERB, "Avan", "A", ItemID.AVANTOE_SEED),
  KWUARM_SEED(Type.SEED_HERB, "Kwuarm", "K", ItemID.KWUARM_SEED),
  SNAPDRAGON_SEED(Type.SEED_HERB, "Snap", "S", ItemID.SNAPDRAGON_SEED),
  CADANTINE_SEED(Type.SEED_HERB, "Cadan", "C", ItemID.CADANTINE_SEED),
  LANTADYME_SEED(Type.SEED_HERB, "Lanta", "L", ItemID.LANTADYME_SEED),
  DWARF_WEED_SEED(Type.SEED_HERB, "Dwarf", "D", ItemID.DWARF_WEED_SEED),
  TORSTOL_SEED(Type.SEED_HERB, "Torstol", "TOR", ItemID.TORSTOL_SEED),

  REDBERRY_SEED(Type.SEED_BERRY, "Redberry", "RED", ItemID.REDBERRY_BUSH_SEED),
  CADAVABERRY_SEED(Type.SEED_BERRY, "Cadava", "CAD", ItemID.CADAVABERRY_BUSH_SEED),
  DWELLBERRY_SEED(Type.SEED_BERRY, "Dwell", "DWEL", ItemID.DWELLBERRY_BUSH_SEED),
  JANGERBERRY_SEED(Type.SEED_BERRY, "Janger", "JANG", ItemID.JANGERBERRY_BUSH_SEED),
  WHITEBERRY_SEED(Type.SEED_BERRY, "White", "WHIT", ItemID.WHITEBERRY_BUSH_SEED),
  POISON_IVY_SEED(Type.SEED_BERRY, "Ivy", "POI", ItemID.POISONIVY_BUSH_SEED),

  GRAPE_SEED(Type.SEED_SPECIAL, "Grape", "GRA", ItemID.GRAPE_SEED),
  MUSHROOM_SPORE(Type.SEED_SPECIAL, "Mushroom", "MUSH", ItemID.MUSHROOM_SEED),
  BELLADONNA_SEED(Type.SEED_SPECIAL, "Bella", "BELL", ItemID.BELLADONNA_SEED),
  SEAWEED_SPORE(Type.SEED_SPECIAL, "Seaweed", "SW", ItemID.SEAWEED_SEED),
  HESPORI_SEED(Type.SEED_SPECIAL, "Hespori", "HES", ItemID.HESPORI_SEED),
  KRONOS_SEED(Type.SEED_SPECIAL, "Kronos", "KRO", ItemID.KRONOS_SEED),
  IASOR_SEED(Type.SEED_SPECIAL, "Iasor", "IA", ItemID.IASOR_SEED),
  ATTAS_SEED(Type.SEED_SPECIAL, "Attas", "AT", ItemID.ATTAS_SEED),
  CACTUS_SEED(Type.SEED_SPECIAL, "Cactus", "CAC", ItemID.CACTUS_SEED),
  POTATO_CACTUS_SEED(Type.SEED_SPECIAL, "P.Cact", "P.CAC", ItemID.POTATO_CACTUS_SEED),

  ACORN(Type.SEED_TREE, "Oak", "OAK", ItemID.ACORN),
  WILLOW_SEED(Type.SEED_TREE, "Willow", "WIL", ItemID.WILLOW_SEED),
  MAPLE_SEED(Type.SEED_TREE, "Maple", "MAP", ItemID.MAPLE_SEED),
  YEW_SEED(Type.SEED_TREE, "Yew", "YEW", ItemID.YEW_SEED),
  MAGIC_SEED(Type.SEED_TREE, "Magic", "MAG", ItemID.MAGIC_TREE_SEED),
  REDWOOD_SEED(Type.SEED_TREE, "Red", "RED", ItemID.REDWOOD_TREE_SEED),
  TEAK_SEED(Type.SEED_TREE, "Teak", "TEAK", ItemID.TEAK_SEED),
  MAHOGANY_SEED(Type.SEED_TREE, "Mahog", "MAH", ItemID.MAHOGANY_SEED),
  CRYSTAL_ACORN(Type.SEED_TREE, "Crystal", "CRY", ItemID.CRYSTAL_TREE_SEED),
  CELASTRUS_SEED(Type.SEED_TREE, "Celas", "CEL", ItemID.CELASTRUS_TREE_SEED),
  SPIRIT_SEED(Type.SEED_TREE, "Spirit", "SPI", ItemID.SPIRIT_TREE_SEED),
  CALQUAT_SEED(Type.SEED_TREE, "Calquat", "CAL", ItemID.CALQUAT_TREE_SEED),

  APPLE_TREE_SEED(Type.SEED_FRUIT_TREE, "Apple", "APP", ItemID.APPLE_TREE_SEED),
  BANANA_TREE_SEED(Type.SEED_FRUIT_TREE, "Banana", "BAN", ItemID.BANANA_TREE_SEED),
  ORANGE_TREE_SEED(Type.SEED_FRUIT_TREE, "Orange", "ORA", ItemID.ORANGE_TREE_SEED),
  CURRY_TREE_SEED(Type.SEED_FRUIT_TREE, "Curry", "CUR", ItemID.CURRY_TREE_SEED),
  PINEAPPLE_SEED(Type.SEED_FRUIT_TREE, "Pine.A", "PINE", ItemID.PINEAPPLE_TREE_SEED),
  PAPAYA_TREE_SEED(Type.SEED_FRUIT_TREE, "Papaya", "PAPA", ItemID.PAPAYA_TREE_SEED),
  PALM_TREE_SEED(Type.SEED_FRUIT_TREE, "Palm", "PALM", ItemID.PALM_TREE_SEED),
  DRAGONFRIUT_TREE_SEED(Type.SEED_FRUIT_TREE, "Dragon", "DRA", ItemID.DRAGONFRUIT_TREE_SEED),

  POTATO_SEED(Type.SEED_ALLOTMENT, "Potato", "POT", ItemID.POTATO_SEED),
  ONION_SEED(Type.SEED_ALLOTMENT, "Onion", "ONI", ItemID.ONION_SEED),
  CABBAGE_SEED(Type.SEED_ALLOTMENT, "Cabbage", "CAB", ItemID.CABBAGE_SEED),
  TOMATO_SEED(Type.SEED_ALLOTMENT, "Tomato", "TOM", ItemID.TOMATO_SEED),
  SWEETCORN_SEED(Type.SEED_ALLOTMENT, "S.Corn", "CORN", ItemID.SWEETCORN_SEED),
  STRAWBERRY_SEED(Type.SEED_ALLOTMENT, "S.Berry", "STRA", ItemID.STRAWBERRY_SEED),
  WATERMELON_SEED(Type.SEED_ALLOTMENT, "Melon", "MEL", ItemID.WATERMELON_SEED),
  SNAPE_GRASS_SEED(Type.SEED_ALLOTMENT, "Snape", "SNA", ItemID.SNAPE_GRASS_SEED),

  MARIGOLD_SEED(Type.SEED_FLOWER, "Marigo", "MARI", ItemID.MARIGOLD_SEED),
  ROSEMARY_SEED(Type.SEED_FLOWER, "Rosemar", "ROSE", ItemID.ROSEMARY_SEED),
  NASTURTIUM_SEED(Type.SEED_FLOWER, "Nastur", "NAS", ItemID.NASTURTIUM_SEED),
  WOAD_SEED(Type.SEED_FLOWER, "Woad", "WOAD", ItemID.WOAD_SEED),
  LIMPWURT_SEED(Type.SEED_FLOWER, "Limpwurt", "LIMP", ItemID.LIMPWURT_SEED),
  WHITE_LILY_SEED(Type.SEED_FLOWER, "Lily", "LILY", ItemID.WHITE_LILY_SEED),

  BARLEY_SEED(Type.HOPS_SEED, "Barley", "BAR", ItemID.BARLEY_SEED),
  HAMMERSTONE_SEED(Type.HOPS_SEED, "Hammer", "HAMM", ItemID.HAMMERSTONE_HOP_SEED),
  ASGARNIAN_SEED(Type.HOPS_SEED, "Asgar", "ASG", ItemID.ASGARNIAN_HOP_SEED),
  JUTE_SEED(Type.HOPS_SEED, "Jute", "JUTE", ItemID.JUTE_SEED),
  YANILLIAN_SEED(Type.HOPS_SEED, "Yani", "YAN", ItemID.YANILLIAN_HOP_SEED),
  KRANDORIAN_SEED(Type.HOPS_SEED, "Krand", "KRA", ItemID.KRANDORIAN_HOP_SEED),
  WILDBLOOD_SEED(Type.HOPS_SEED, "Wild.B", "WILD", ItemID.WILDBLOOD_HOP_SEED),

  // Sacks
  SACK(Type.SACK, "Empty", "EMP", ItemID.SACK_EMPTY),
  CABBAGE_SACK(
      Type.SACK,
      "Cabbage",
      "CAB",
      ItemID.SACK_CABBAGE_1,
      ItemID.SACK_CABBAGE_2,
      ItemID.SACK_CABBAGE_3,
      ItemID.SACK_CABBAGE_4,
      ItemID.SACK_CABBAGE_5,
      ItemID.SACK_CABBAGE_6,
      ItemID.SACK_CABBAGE_7,
      ItemID.SACK_CABBAGE_8,
      ItemID.SACK_CABBAGE_9,
      ItemID.SACK_CABBAGE_10),
  ONION_SACK(
      Type.SACK,
      "Onion",
      "ONI",
      ItemID.SACK_ONION_1,
      ItemID.SACK_ONION_2,
      ItemID.SACK_ONION_3,
      ItemID.SACK_ONION_4,
      ItemID.SACK_ONION_5,
      ItemID.SACK_ONION_6,
      ItemID.SACK_ONION_7,
      ItemID.SACK_ONION_8,
      ItemID.SACK_ONION_9,
      ItemID.SACK_ONION_10),
  POTATO_SACK(
      Type.SACK,
      "Potato",
      "POT",
      ItemID.SACK_POTATO_1,
      ItemID.SACK_POTATO_2,
      ItemID.SACK_POTATO_3,
      ItemID.SACK_POTATO_4,
      ItemID.SACK_POTATO_5,
      ItemID.SACK_POTATO_6,
      ItemID.SACK_POTATO_7,
      ItemID.SACK_POTATO_8,
      ItemID.SACK_POTATO_9,
      ItemID.SACK_POTATO_10),

  // Herbs
  GUAM(Type.HERB, "Guam", "G", ItemID.GUAM_LEAF, ItemID.UNIDENTIFIED_GUAM),
  MARRENTILL(Type.HERB, "Marren", "M", ItemID.MARENTILL, ItemID.UNIDENTIFIED_MARENTILL),
  TARROMIN(Type.HERB, "Tarro", "TAR", ItemID.TARROMIN, ItemID.UNIDENTIFIED_TARROMIN),
  HARRALANDER(Type.HERB, "Harra", "H", ItemID.HARRALANDER, ItemID.UNIDENTIFIED_HARRALANDER),
  RANARR(Type.HERB, "Ranarr", "R", ItemID.RANARR_WEED, ItemID.UNIDENTIFIED_RANARR),
  TOADFLAX(Type.HERB, "Toad", "TOA", ItemID.TOADFLAX, ItemID.UNIDENTIFIED_TOADFLAX),
  IRIT(Type.HERB, "Irit", "I", ItemID.IRIT_LEAF, ItemID.UNIDENTIFIED_IRIT),
  AVANTOE(Type.HERB, "Avan", "A", ItemID.AVANTOE, ItemID.UNIDENTIFIED_AVANTOE),
  KWUARM(Type.HERB, "Kwuarm", "K", ItemID.KWUARM, ItemID.UNIDENTIFIED_KWUARM),
  SNAPDRAGON(Type.HERB, "Snap", "S", ItemID.SNAPDRAGON, ItemID.UNIDENTIFIED_SNAPDRAGON),
  CADANTINE(Type.HERB, "Cadan", "C", ItemID.CADANTINE, ItemID.UNIDENTIFIED_CADANTINE),
  LANTADYME(Type.HERB, "Lanta", "L", ItemID.LANTADYME, ItemID.UNIDENTIFIED_LANTADYME),
  DWARF_WEED(Type.HERB, "Dwarf", "D", ItemID.DWARF_WEED, ItemID.UNIDENTIFIED_DWARF_WEED),
  TORSTOL(Type.HERB, "Torstol", "TOR", ItemID.TORSTOL, ItemID.UNIDENTIFIED_TORSTOL),

  ARDRIGAL(Type.HERB, "Ardrig", "ARD", ItemID.ARDRIGAL, ItemID.UNIDENTIFIED_ARDRIGAL),
  ROGUES_PURSE(Type.HERB, "Rogue", "ROG", ItemID.ROGUES_PURSE, ItemID.UNIDENTIFIED_ROGUES_PURSE),
  SITO_FOIL(Type.HERB, "Sito", "SF", ItemID.SITO_FOIL, ItemID.UNIDENTIFIED_SITO_FOIL),
  SNAKE_WEED(Type.HERB, "Snake", "SW", ItemID.SNAKE_WEED, ItemID.UNIDENTIFIED_SNAKE_WEED),
  VOLENCIA_MOSS(Type.HERB, "Volenc", "V", ItemID.VOLENCIA_MOSS, ItemID.UNIDENTIFIED_VOLENCIA_MOSS),

  // Logs
  RED_LOGS(Type.LOGS, "Red", "RED", ItemID.RED_LOGS),
  GREEN_LOGS(Type.LOGS, "Green", "GRE", ItemID.GREEN_LOGS),
  BLUE_LOGS(Type.LOGS, "Blue", "BLU", ItemID.BLUE_LOGS),
  WHITE_LOGS(Type.LOGS, "White", "WHI", ItemID.TRAIL_LOGS_WHITE),
  PURPLE_LOGS(Type.LOGS, "Purple", "PUR", ItemID.TRAIL_LOGS_PURPLE),

  SCRAPEY_TREE_LOGS(Type.LOGS, "Scrapey", "SCRAP", ItemID.BREW_SCRAPEY_LOGS),

  LOG(Type.LOGS, "Log", "LOG", ItemID.LOGS),
  ACHEY_TREE_LOG(Type.LOGS, "Achey", "ACH", ItemID.ACHEY_TREE_LOGS),
  OAK_LOG(Type.LOGS, "Oak", "OAK", ItemID.OAK_LOGS),
  WILLOW_LOG(Type.LOGS, "Willow", "WIL", ItemID.WILLOW_LOGS),
  TEAK_LOG(Type.LOGS, "Teak", "TEAK", ItemID.TEAK_LOGS),
  JUNIPER_LOG(Type.LOGS, "Juniper", "JUN", ItemID.JUNIPER_LOGS),
  MAPLE_LOG(Type.LOGS, "Maple", "MAP", ItemID.MAPLE_LOGS),
  MAHOGANY_LOG(Type.LOGS, "Mahog", "MAH", ItemID.MAHOGANY_LOGS),
  ARCTIC_PINE_LOG(Type.LOGS, "Arctic", "ARC", ItemID.ARCTIC_PINE_LOG),
  YEW_LOG(Type.LOGS, "Yew", "YEW", ItemID.YEW_LOGS),
  BLISTERWOOD_LOG(Type.LOGS, "Blister", "BLI", ItemID.BLISTERWOOD_LOGS),
  MAGIC_LOG(Type.LOGS, "Magic", "MAG", ItemID.MAGIC_LOGS),
  REDWOOD_LOG(Type.LOGS, "Red", "RED", ItemID.REDWOOD_LOGS),

  PYRE_LOGS(Type.LOGS_PYRE, "Pyre", "P", ItemID.LOGS_PYRE),
  ARCTIC_PYRE_LOGS(Type.LOGS_PYRE, "Art P", "AP", ItemID.ARCTIC_PINE_LOGS_PYRE),
  OAK_PYRE_LOGS(Type.LOGS_PYRE, "Oak P", "OAKP", ItemID.OAK_LOGS_PYRE),
  WILLOW_PYRE_LOGS(Type.LOGS_PYRE, "Wil P", "WILP", ItemID.WILLOW_LOGS_PYRE),
  TEAK_PYRE_LOGS(Type.LOGS_PYRE, "Teak P", "TEAKP", ItemID.TEAK_LOGS_PYRE),
  MAPLE_PYRE_LOGS(Type.LOGS_PYRE, "Map P", "MAPP", ItemID.MAPLE_LOGS_PYRE),
  MAHOGANY_PYRE_LOGS(Type.LOGS_PYRE, "Mah P", "MAHP", ItemID.MAHOGANY_LOGS_PYRE),
  YEW_PYRE_LOGS(Type.LOGS_PYRE, "Yew P", "YEWP", ItemID.YEW_LOGS_PYRE),
  MAGIC_PYRE_LOGS(Type.LOGS_PYRE, "Mag P", "MAGP", ItemID.MAGIC_LOGS_PYRE),
  REDWOOD_PYRE_LOGS(Type.LOGS_PYRE, "Red P", "REDP", ItemID.REDWOOD_LOGS_PYRE),

  // Planks
  PLANK(Type.PLANK, "Plank", "PLANK", ItemID.WOODPLANK),
  OAK_PLANK(Type.PLANK, "Oak", "OAK", ItemID.PLANK_OAK),
  TEAK_PLANK(Type.PLANK, "Teak", "TEAK", ItemID.PLANK_TEAK),
  MAHOGANY_PLANK(Type.PLANK, "Mahog", "MAH", ItemID.PLANK_MAHOGANY),
  WAXWOOD_PLANK(Type.PLANK, "Wax", "WAX", ItemID.DADDYSHOME_WAXWOOD_PLANK),
  MALLIGNUM_ROOT_PLANK(Type.PLANK, "Mallig", "MALL", ItemID.RAIDS_PLANK),

  // Saplings
  OAK_SAPLING(
      Type.SAPLING, "Oak", "OAK", ItemID.PLANTPOT_OAK_SAPLING, ItemID.PLANTPOT_ACORN,
      ItemID.PLANTPOT_ACORN_WATERED),
  WILLOW_SAPLING(
      Type.SAPLING,
      "Willow",
      "WIL",
      ItemID.PLANTPOT_WILLOW_SAPLING,
      ItemID.PLANTPOT_WILLOW_SEED,
      ItemID.PLANTPOT_WILLOW_SEED_WATERED),
  MAPLE_SAPLING(
      Type.SAPLING,
      "Maple",
      "MAP",
      ItemID.PLANTPOT_MAPLE_SAPLING,
      ItemID.PLANTPOT_MAPLE_SEED,
      ItemID.PLANTPOT_MAPLE_SEED_WATERED),
  YEW_SAPLING(
      Type.SAPLING, "Yew", "YEW", ItemID.PLANTPOT_YEW_SAPLING, ItemID.PLANTPOT_YEW_SEED,
      ItemID.PLANTPOT_YEW_SEED_WATERED),
  MAGIC_SAPLING(
      Type.SAPLING,
      "Magic",
      "MAG",
      ItemID.PLANTPOT_MAGIC_TREE_SAPLING,
      ItemID.PLANTPOT_MAGIC_TREE_SEED,
      ItemID.PLANTPOT_MAGIC_TREE_SEED_WATERED),
  REDWOOD_SAPLING(
      Type.SAPLING,
      "Red",
      "RED",
      ItemID.PLANTPOT_REDWOOD_TREE_SAPLING,
      ItemID.PLANTPOT_REDWOOD_TREE_SEED,
      ItemID.PLANTPOT_REDWOOD_TREE_SEED_WATERED),
  SPIRIT_SAPLING(
      Type.SAPLING,
      "Spirit",
      "SPI",
      ItemID.PLANTPOT_SPIRIT_TREE_SAPLING,
      ItemID.PLANTPOT_SPIRIT_TREE_SEED,
      ItemID.PLANTPOT_SPIRIT_TREE_SEED_WATERED),
  CRYSTAL_SAPLING(
      Type.SAPLING,
      "Crystal",
      "CRY",
      ItemID.PLANTPOT_CRYSTAL_TREE_SAPLING,
      ItemID.PLANTPOT_CRYSTAL_TREE_SEED,
      ItemID.PLANTPOT_CRYSTAL_TREE_SEED_WATERED),

  APPLE_SAPLING(
      Type.SAPLING,
      "Apple",
      "APP",
      ItemID.PLANTPOT_APPLE_SAPLING,
      ItemID.PLANTPOT_APPLE_SEED,
      ItemID.PLANTPOT_APPLE_SEED_WATERED),
  BANANA_SAPLING(
      Type.SAPLING,
      "Banana",
      "BAN",
      ItemID.PLANTPOT_BANANA_SAPLING,
      ItemID.PLANTPOT_BANANA_SEED,
      ItemID.PLANTPOT_BANANA_SEED_WATERED),
  ORANGE_SAPLING(
      Type.SAPLING,
      "Orange",
      "ORA",
      ItemID.PLANTPOT_ORANGE_SAPLING,
      ItemID.PLANTPOT_ORANGE_SEED,
      ItemID.PLANTPOT_ORANGE_SEED_WATERED),
  CURRY_SAPLING(
      Type.SAPLING,
      "Curry",
      "CUR",
      ItemID.PLANTPOT_CURRY_SAPLING,
      ItemID.PLANTPOT_CURRY_SEED,
      ItemID.PLANTPOT_CURRY_SEED_WATERED),
  PINEAPPLE_SAPLING(
      Type.SAPLING,
      "Pine",
      "PINE",
      ItemID.PLANTPOT_PINEAPPLE_SAPLING,
      ItemID.PLANTPOT_PINEAPPLE_SEED,
      ItemID.PLANTPOT_PINEAPPLE_SEED_WATERED),
  PAPAYA_SAPLING(
      Type.SAPLING,
      "Papaya",
      "PAP",
      ItemID.PLANTPOT_PAPAYA_SAPLING,
      ItemID.PLANTPOT_PAPAYA_SEED,
      ItemID.PLANTPOT_PAPAYA_SEED_WATERED),
  PALM_SAPLING(
      Type.SAPLING,
      "Palm",
      "PALM",
      ItemID.PLANTPOT_PALM_SAPLING,
      ItemID.PLANTPOT_PALM_SEED,
      ItemID.PLANTPOT_PALM_SEED_WATERED),
  DRAGONFRUIT_SAPLING(
      Type.SAPLING,
      "Dragon",
      "DRAG",
      ItemID.PLANTPOT_DRAGONFRUIT_SAPLING,
      ItemID.PLANTPOT_DRAGONFRUIT_SEED,
      ItemID.PLANTPOT_DRAGONFRUIT_SEED_WATERED),

  TEAK_SAPLING(
      Type.SAPLING,
      "Teak",
      "TEAK",
      ItemID.PLANTPOT_TEAK_SAPLING,
      ItemID.PLANTPOT_TEAK_SEED,
      ItemID.PLANTPOT_TEAK_SEED_WATERED),
  MAHOGANY_SAPLING(
      Type.SAPLING,
      "Mahog",
      "MAHOG",
      ItemID.PLANTPOT_MAHOGANY_SAPLING,
      ItemID.PLANTPOT_MAHOGANY_SEED,
      ItemID.PLANTPOT_MAHOGANY_SEED_WATERED),
  CALQUAT_SAPLING(
      Type.SAPLING,
      "Calquat",
      "CALQ",
      ItemID.PLANTPOT_CALQUAT_SAPLING,
      ItemID.PLANTPOT_CALQUAT_SEED,
      ItemID.PLANTPOT_CALQUAT_SEED_WATERED),
  CELASTRUS_SAPLING(
      Type.SAPLING,
      "Celas",
      "CEL",
      ItemID.PLANTPOT_CELASTRUS_TREE_SAPLING,
      ItemID.PLANTPOT_CELASTRUS_TREE_SEED,
      ItemID.PLANTPOT_CELASTRUS_TREE_SEED_WATERED),

  // Compost
  COMPOST(Type.COMPOST, "Compost", "COM", ItemID.BUCKET_COMPOST),
  SUPERCOMPOST(Type.COMPOST, "Sup Com", "SCOM", ItemID.BUCKET_SUPERCOMPOST),
  ULTRACOMPOST(Type.COMPOST, "Ult Com", "UCOM", ItemID.BUCKET_ULTRACOMPOST),

  // Ores
  COPPER_ORE(Type.ORE, "Copper", "COP", ItemID.COPPER_ORE),
  TIN_ORE(Type.ORE, "Tin", "TIN", ItemID.TIN_ORE),
  IRON_ORE(Type.ORE, "Iron", "IRO", ItemID.IRON_ORE),
  SILVER_ORE(Type.ORE, "Silver", "SIL", ItemID.SILVER_ORE),
  COAL_ORE(Type.ORE, "Coal", "COA", ItemID.COAL),
  GOLD_ORE(Type.ORE, "Gold", "GOL", ItemID.GOLD_ORE),
  MITHRIL_ORE(Type.ORE, "Mithril", "MIT", ItemID.MITHRIL_ORE),
  ADAMANTITE_ORE(Type.ORE, "Adaman", "ADA", ItemID.ADAMANTITE_ORE),
  RUNITE_ORE(Type.ORE, "Runite", "RUN", ItemID.RUNITE_ORE),

  RUNE_ESSENCE(Type.ORE, "R.Ess", "R.E.", ItemID.BLANKRUNE),
  PURE_ESSENCE(Type.ORE, "P.Ess", "P.E.", ItemID.BLANKRUNE_HIGH),

  PAYDIRT(Type.ORE, "Paydirt", "PAY", ItemID.PAYDIRT),
  AMETHYST(Type.ORE, "Amethy", "AME", ItemID.AMETHYST),
  LOVAKITE_ORE(Type.ORE, "Lovakit", "LOV", ItemID.LOVAKITE_ORE),
  BLURITE_ORE(Type.ORE, "Blurite", "BLU", ItemID.BLURITE_ORE),
  ELEMENTAL_ORE(Type.ORE, "Element", "ELE", ItemID.ELEMENTAL_WORKSHOP_ORE),
  DAEYALT_ORE(Type.ORE, "Daeyalt", "DAE", ItemID.SANG_JAS_ORE),
  LUNAR_ORE(Type.ORE, "Lunar", "LUN", ItemID.QUEST_LUNAR_MAGIC_ORE),

  // Bars
  BRONZE_BAR(Type.BAR, "Bronze", "BRO", ItemID.BRONZE_BAR),
  IRON_BAR(Type.BAR, "Iron", "IRO", ItemID.IRON_BAR),
  SILVER_BAR(Type.BAR, "Silver", "SIL", ItemID.SILVER_BAR),
  STEEL_BAR(Type.BAR, "Steel", "STE", ItemID.STEEL_BAR),
  GOLD_BAR(Type.BAR, "Gold", "GOL", ItemID.GOLD_BAR),
  MITHRIL_BAR(Type.BAR, "Mithril", "MIT", ItemID.MITHRIL_BAR),
  ADAMANTITE_BAR(Type.BAR, "Adaman", "ADA", ItemID.ADAMANTITE_BAR),
  RUNITE_BAR(Type.BAR, "Runite", "RUN", ItemID.RUNITE_BAR),

  // Gems
  SAPPHIRE(Type.GEM, "Sapphir", "S", ItemID.UNCUT_SAPPHIRE, ItemID.SAPPHIRE),
  EMERALD(Type.GEM, "Emerald", "E", ItemID.UNCUT_EMERALD, ItemID.EMERALD),
  RUBY(Type.GEM, "Ruby", "R", ItemID.UNCUT_RUBY, ItemID.RUBY),
  DIAMOND(Type.GEM, "Diamon", "DI", ItemID.UNCUT_DIAMOND, ItemID.DIAMOND),
  OPAL(Type.GEM, "Opal", "OP", ItemID.UNCUT_OPAL, ItemID.OPAL),
  JADE(Type.GEM, "Jade", "J", ItemID.UNCUT_JADE, ItemID.JADE),
  RED_TOPAZ(Type.GEM, "Topaz", "T", ItemID.UNCUT_RED_TOPAZ, ItemID.RED_TOPAZ),
  DRAGONSTONE(Type.GEM, "Dragon", "DR", ItemID.UNCUT_DRAGONSTONE, ItemID.DRAGONSTONE),
  ONYX(Type.GEM, "Onyx", "ON", ItemID.UNCUT_ONYX, ItemID.ONYX),
  ZENYTE(Type.GEM, "Zenyte", "Z", ItemID.UNCUT_ZENYTE, ItemID.ZENYTE),

  // Potions
  ATTACK(
      Type.POTION,
      "Att",
      "A",
      ItemID._4DOSE1ATTACK,
      ItemID._3DOSE1ATTACK,
      ItemID._2DOSE1ATTACK,
      ItemID._1DOSE1ATTACK),
  STRENGTH(
      Type.POTION,
      "Str",
      "S",
      ItemID.STRENGTH4,
      ItemID._3DOSE1STRENGTH,
      ItemID._2DOSE1STRENGTH,
      ItemID._1DOSE1STRENGTH),
  DEFENCE(
      Type.POTION,
      "Def",
      "D",
      ItemID._4DOSE1DEFENSE,
      ItemID._3DOSE1DEFENSE,
      ItemID._2DOSE1DEFENSE,
      ItemID._1DOSE1DEFENSE),
  COMBAT(
      Type.POTION,
      "Com",
      "C",
      ItemID._4DOSECOMBAT,
      ItemID._3DOSECOMBAT,
      ItemID._2DOSECOMBAT,
      ItemID._1DOSECOMBAT),
  MAGIC(
      Type.POTION,
      "Magic",
      "M",
      ItemID._4DOSE1MAGIC,
      ItemID._3DOSE1MAGIC,
      ItemID._2DOSE1MAGIC,
      ItemID._1DOSE1MAGIC),
  RANGING(
      Type.POTION,
      "Range",
      "R",
      ItemID._4DOSERANGERSPOTION,
      ItemID._3DOSERANGERSPOTION,
      ItemID._2DOSERANGERSPOTION,
      ItemID._1DOSERANGERSPOTION),
  BASTION(
      Type.POTION,
      "Bastion",
      "B",
      ItemID._4DOSEBASTION,
      ItemID._3DOSEBASTION,
      ItemID._2DOSEBASTION,
      ItemID._1DOSEBASTION),
  BATTLEMAGE(
      Type.POTION,
      "BatMage",
      "B.M",
      ItemID._4DOSEBATTLEMAGE,
      ItemID._3DOSEBATTLEMAGE,
      ItemID._2DOSEBATTLEMAGE,
      ItemID._1DOSEBATTLEMAGE),

  SUPER_ATTACK(
      Type.POTION,
      "S.Att",
      "S.A",
      ItemID._4DOSE2ATTACK,
      ItemID._3DOSE2ATTACK,
      ItemID._2DOSE2ATTACK,
      ItemID._1DOSE2ATTACK),
  SUPER_STRENGTH(
      Type.POTION,
      "S.Str",
      "S.S",
      ItemID._4DOSE2STRENGTH,
      ItemID._3DOSE2STRENGTH,
      ItemID._2DOSE2STRENGTH,
      ItemID._1DOSE2STRENGTH),
  SUPER_DEFENCE(
      Type.POTION,
      "S.Def",
      "S.D",
      ItemID._4DOSE2DEFENSE,
      ItemID._3DOSE2DEFENSE,
      ItemID._2DOSE2DEFENSE,
      ItemID._1DOSE2DEFENSE),
  SUPER_COMBAT(
      Type.POTION,
      "S.Com",
      "S.C",
      ItemID._4DOSE2COMBAT,
      ItemID._3DOSE2COMBAT,
      ItemID._2DOSE2COMBAT,
      ItemID._1DOSE2COMBAT),
  SUPER_RANGING(
      Type.POTION,
      "S.Range",
      "S.Ra",
      ItemID.NZONE4DOSE2RANGERSPOTION,
      ItemID.NZONE3DOSE2RANGERSPOTION,
      ItemID.NZONE2DOSE2RANGERSPOTION,
      ItemID.NZONE1DOSE2RANGERSPOTION),
  SUPER_MAGIC(
      Type.POTION,
      "S.Magic",
      "S.M",
      ItemID.NZONE4DOSE2MAGICPOTION,
      ItemID.NZONE3DOSE2MAGICPOTION,
      ItemID.NZONE2DOSE2MAGICPOTION,
      ItemID.NZONE1DOSE2MAGICPOTION),

  DIVINE_SUPER_ATTACK(
      Type.POTION,
      "S.Att",
      "S.A",
      ItemID._4DOSEDIVINEATTACK,
      ItemID._3DOSEDIVINEATTACK,
      ItemID._2DOSEDIVINEATTACK,
      ItemID._1DOSEDIVINEATTACK),
  DIVINE_SUPER_DEFENCE(
      Type.POTION,
      "S.Def",
      "S.D",
      ItemID._4DOSEDIVINEDEFENCE,
      ItemID._3DOSEDIVINEDEFENCE,
      ItemID._2DOSEDIVINEDEFENCE,
      ItemID._1DOSEDIVINEDEFENCE),
  DIVINE_SUPER_STRENGTH(
      Type.POTION,
      "S.Str",
      "S.S",
      ItemID._4DOSEDIVINESTRENGTH,
      ItemID._3DOSEDIVINESTRENGTH,
      ItemID._2DOSEDIVINESTRENGTH,
      ItemID._1DOSEDIVINESTRENGTH),
  DIVINE_SUPER_COMBAT(
      Type.POTION,
      "S.Com",
      "S.C",
      ItemID._4DOSEDIVINECOMBAT,
      ItemID._3DOSEDIVINECOMBAT,
      ItemID._2DOSEDIVINECOMBAT,
      ItemID._1DOSEDIVINECOMBAT),
  DIVINE_RANGING(
      Type.POTION,
      "Range",
      "R",
      ItemID._4DOSEDIVINERANGE,
      ItemID._3DOSEDIVINERANGE,
      ItemID._2DOSEDIVINERANGE,
      ItemID._1DOSEDIVINERANGE),
  DIVINE_MAGIC(
      Type.POTION,
      "Magic",
      "M",
      ItemID._4DOSEDIVINEMAGIC,
      ItemID._3DOSEDIVINEMAGIC,
      ItemID._2DOSEDIVINEMAGIC,
      ItemID._1DOSEDIVINEMAGIC),
  DIVINE_BASTION(
      Type.POTION,
      "Bastion",
      "B",
      ItemID._4DOSEDIVINEBASTION,
      ItemID._3DOSEDIVINEBASTION,
      ItemID._2DOSEDIVINEBASTION,
      ItemID._1DOSEDIVINEBASTION),
  DIVINE_BATTLEMAGE(
      Type.POTION,
      "BatMage",
      "B.M",
      ItemID._4DOSEDIVINEBATTLEMAGE,
      ItemID._3DOSEDIVINEBATTLEMAGE,
      ItemID._2DOSEDIVINEBATTLEMAGE,
      ItemID._1DOSEDIVINEBATTLEMAGE),

  RESTORE(
      Type.POTION,
      "Restore",
      "Re",
      ItemID._4DOSESTATRESTORE,
      ItemID._3DOSESTATRESTORE,
      ItemID._2DOSESTATRESTORE,
      ItemID._1DOSESTATRESTORE),
  GUTHIX_BALANCE(
      Type.POTION,
      "GuthBal",
      "G.B.",
      ItemID.BURGH_GUTHIX_BALANCE_4,
      ItemID.BURGH_GUTHIX_BALANCE_3,
      ItemID.BURGH_GUTHIX_BALANCE_2,
      ItemID.BURGH_GUTHIX_BALANCE_1),
  SUPER_RESTORE(
      Type.POTION,
      "S.Rest",
      "S.Re",
      ItemID._4DOSE2RESTORE,
      ItemID._3DOSE2RESTORE,
      ItemID._2DOSE2RESTORE,
      ItemID._1DOSE2RESTORE),
  PRAYER(
      Type.POTION,
      "Prayer",
      "P",
      ItemID._4DOSEPRAYERRESTORE,
      ItemID._3DOSEPRAYERRESTORE,
      ItemID._2DOSEPRAYERRESTORE,
      ItemID._1DOSEPRAYERRESTORE),
  ENERGY(
      Type.POTION,
      "Energy",
      "En",
      ItemID._4DOSE1ENERGY,
      ItemID._3DOSE1ENERGY,
      ItemID._2DOSE1ENERGY,
      ItemID._1DOSE1ENERGY),
  SUPER_ENERGY(
      Type.POTION,
      "S.Energ",
      "S.En",
      ItemID._4DOSE2ENERGY,
      ItemID._3DOSE2ENERGY,
      ItemID._2DOSE2ENERGY,
      ItemID._1DOSE2ENERGY),
  STAMINA(
      Type.POTION,
      "Stamina",
      "St",
      ItemID._4DOSESTAMINA,
      ItemID._3DOSESTAMINA,
      ItemID._2DOSESTAMINA,
      ItemID._1DOSESTAMINA),
  OVERLOAD(
      Type.POTION,
      "Overloa",
      "OL",
      ItemID.NZONE4DOSEOVERLOADPOTION,
      ItemID.NZONE3DOSEOVERLOADPOTION,
      ItemID.NZONE2DOSEOVERLOADPOTION,
      ItemID.NZONE1DOSEOVERLOADPOTION),
  ABSORPTION(
      Type.POTION,
      "Absorb",
      "Ab",
      ItemID.NZONE4DOSEABSORPTIONPOTION,
      ItemID.NZONE3DOSEABSORPTIONPOTION,
      ItemID.NZONE2DOSEABSORPTIONPOTION,
      ItemID.NZONE1DOSEABSORPTIONPOTION),

  ZAMORAK_BREW(
      Type.POTION,
      "ZammyBr",
      "Za",
      ItemID._4DOSEPOTIONOFZAMORAK,
      ItemID._3DOSEPOTIONOFZAMORAK,
      ItemID._2DOSEPOTIONOFZAMORAK,
      ItemID._1DOSEPOTIONOFZAMORAK),
  SARADOMIN_BREW(
      Type.POTION,
      "SaraBr",
      "Sa",
      ItemID._4DOSEPOTIONOFSARADOMIN,
      ItemID._3DOSEPOTIONOFSARADOMIN,
      ItemID._2DOSEPOTIONOFSARADOMIN,
      ItemID._1DOSEPOTIONOFSARADOMIN),
  ANCIENT_BREW(
      Type.POTION,
      "AncBr",
      "A.Br",
      ItemID._4DOSEANCIENTBREW,
      ItemID._3DOSEANCIENTBREW,
      ItemID._2DOSEANCIENTBREW,
      ItemID._1DOSEANCIENTBREW),

  ANTIPOISON(
      Type.POTION,
      "AntiP",
      "AP",
      ItemID._4DOSEANTIPOISON,
      ItemID._3DOSEANTIPOISON,
      ItemID._2DOSEANTIPOISON,
      ItemID._1DOSEANTIPOISON),
  SUPERANTIPOISON(
      Type.POTION,
      "S.AntiP",
      "S.AP",
      ItemID._4DOSE2ANTIPOISON,
      ItemID._3DOSE2ANTIPOISON,
      ItemID._2DOSE2ANTIPOISON,
      ItemID._1DOSE2ANTIPOISON),
  ANTIDOTE_P(
      Type.POTION,
      "Antid+",
      "A+",
      ItemID.ANTIDOTE_4,
      ItemID.ANTIDOTE_3,
      ItemID.ANTIDOTE_2,
      ItemID.ANTIDOTE_1),
  ANTIDOTE_PP(
      Type.POTION,
      "Antid++",
      "A++",
      ItemID.ANTIDOTE__4,
      ItemID.ANTIDOTE__3,
      ItemID.ANTIDOTE__2,
      ItemID.ANTIDOTE__1),
  ANTIVENOM(
      Type.POTION,
      "Anti-V",
      "AV",
      ItemID.ANTIVENOM4,
      ItemID.ANTIVENOM3,
      ItemID.ANTIVENOM2,
      ItemID.ANTIVENOM1),
  ANTIVENOM_P(
      Type.POTION,
      "Anti-V+",
      "AV+",
      ItemID.ANTIVENOM_4,
      ItemID.ANTIVENOM_3,
      ItemID.ANTIVENOM_2,
      ItemID.ANTIVENOM_1),

  RELICYMS_BALM(
      Type.POTION,
      "Relicym",
      "R.B",
      ItemID.RELICYMS_BALM4,
      ItemID.RELICYMS_BALM3,
      ItemID.RELICYMS_BALM2,
      ItemID.RELICYMS_BALM1),
  SANFEW_SERUM(
      Type.POTION,
      "Sanfew",
      "Sf",
      ItemID.SANFEW_SALVE_4_DOSE,
      ItemID.SANFEW_SALVE_3_DOSE,
      ItemID.SANFEW_SALVE_2_DOSE,
      ItemID.SANFEW_SALVE_1_DOSE),
  ANTIFIRE(
      Type.POTION,
      "Antif",
      "Af",
      ItemID._4DOSE1ANTIDRAGON,
      ItemID._3DOSE1ANTIDRAGON,
      ItemID._2DOSE1ANTIDRAGON,
      ItemID._1DOSE1ANTIDRAGON),
  EXTENDED_ANTIFIRE(
      Type.POTION,
      "E.Antif",
      "E.Af",
      ItemID._4DOSE2ANTIDRAGON,
      ItemID._3DOSE2ANTIDRAGON,
      ItemID._2DOSE2ANTIDRAGON,
      ItemID._1DOSE2ANTIDRAGON),
  SUPER_ANTIFIRE(
      Type.POTION,
      "S.Antif",
      "S.Af",
      ItemID._4DOSE3ANTIDRAGON,
      ItemID._3DOSE3ANTIDRAGON,
      ItemID._2DOSE3ANTIDRAGON,
      ItemID._1DOSE3ANTIDRAGON),
  EXTENDED_SUPER_ANTIFIRE(
      Type.POTION,
      "ES.Antif",
      "ES.Af",
      ItemID._4DOSE4ANTIDRAGON,
      ItemID._3DOSE4ANTIDRAGON,
      ItemID._2DOSE4ANTIDRAGON,
      ItemID._1DOSE4ANTIDRAGON),

  SERUM_207(
      Type.POTION,
      "Ser207",
      "S7",
      ItemID.MORT_SERUM4,
      ItemID.MORT_SERUM3,
      ItemID.MORT_SERUM2,
      ItemID.MORT_SERUM1),
  SERUM_208(
      Type.POTION,
      "Ser208",
      "S8",
      ItemID.MORT_SERUM_PERM4,
      ItemID.MORT_SERUM_PERM3,
      ItemID.MORT_SERUM_PERM2,
      ItemID.MORT_SERUM_PERM1),
  COMPOST_POTION(
      Type.POTION,
      "Compost",
      "COM",
      ItemID.SUPERCOMPOST_POTION_4,
      ItemID.SUPERCOMPOST_POTION_3,
      ItemID.SUPERCOMPOST_POTION_2,
      ItemID.SUPERCOMPOST_POTION_1),

  AGILITY(
      Type.POTION,
      "Agility",
      "Ag",
      ItemID._4DOSE1AGILITY,
      ItemID._3DOSE1AGILITY,
      ItemID._2DOSE1AGILITY,
      ItemID._1DOSE1AGILITY),
  FISHING(
      Type.POTION,
      "Fishing",
      "Fi",
      ItemID._4DOSEFISHERSPOTION,
      ItemID._3DOSEFISHERSPOTION,
      ItemID._2DOSEFISHERSPOTION,
      ItemID._1DOSEFISHERSPOTION),
  HUNTER(
      Type.POTION,
      "Hunter",
      "Hu",
      ItemID._4DOSEHUNTING,
      ItemID._3DOSEHUNTING,
      ItemID._2DOSEHUNTING,
      ItemID._1DOSEHUNTING),

  GOBLIN(
      Type.POTION,
      "Goblin",
      "G",
      ItemID.LOTG_4DOSEGOBLIN,
      ItemID.LOTG_3DOSEGOBLIN,
      ItemID.LOTG_2DOSEGOBLIN,
      ItemID.LOTG_1DOSEGOBLIN),
  MAGIC_ESS(
      Type.POTION,
      "MagEss",
      "M.E",
      ItemID._4DOSEMAGICESS,
      ItemID._3DOSEMAGICESS,
      ItemID._2DOSEMAGICESS,
      ItemID._1DOSEMAGICESS),
  REJUVENATION(
      Type.POTION,
      "Rejuv",
      "Rj",
      ItemID.WINT_POTION4,
      ItemID.WINT_POTION3,
      ItemID.WINT_POTION2,
      ItemID.WINT_POTION1),

  // Unfinished Potions
  GUAM_POTION(Type.POTION, "Guam", "G", ItemID.GUAMVIAL),
  MARRENTILL_POTION(Type.POTION, "Marren", "M", ItemID.MARRENTILLVIAL),
  TARROMIN_POTION(Type.POTION, "Tarro", "TAR", ItemID.TARROMINVIAL),
  HARRALANDER_POTION(Type.POTION, "Harra", "H", ItemID.HARRALANDERVIAL),
  RANARR_POTION(Type.POTION, "Ranarr", "R", ItemID.RANARRVIAL),
  TOADFLAX_POTION(Type.POTION, "Toad", "TOA", ItemID.TOADFLAXVIAL),
  IRIT_POTION(Type.POTION, "Irit", "I", ItemID.IRITVIAL),
  AVANTOE_POTION(Type.POTION, "Avan", "A", ItemID.AVANTOEVIAL),
  KWUARM_POTION(Type.POTION, "Kwuarm", "K", ItemID.KWUARMVIAL),
  SNAPDRAGON_POTION(Type.POTION, "Snap", "S", ItemID.SNAPDRAGONVIAL),
  CADANTINE_POTION(Type.POTION, "Cadan", "C", ItemID.CADANTINEVIAL),
  LANTADYME_POTION(Type.POTION, "Lanta", "L", ItemID.LANTADYMEVIAL),
  DWARF_WEED_POTION(Type.POTION, "Dwarf", "D", ItemID.DWARFWEEDVIAL),
  TORSTOL_POTION(Type.POTION, "Torstol", "TOR", ItemID.TORSTOLVIAL),

  // Impling jars
  BABY_IMPLING(Type.IMPLING_JAR, "Baby", "B", ItemID.II_CAPTURED_IMPLING_1),
  YOUNG_IMPLING(Type.IMPLING_JAR, "Young", "Y", ItemID.II_CAPTURED_IMPLING_2),
  GOURMET_IMPLING(Type.IMPLING_JAR, "Gourmet", "G", ItemID.II_CAPTURED_IMPLING_3),
  EARTH_IMPLING(Type.IMPLING_JAR, "Earth", "EAR", ItemID.II_CAPTURED_IMPLING_4),
  ESSENCE_IMPLING(Type.IMPLING_JAR, "Essen", "ESS", ItemID.II_CAPTURED_IMPLING_5),
  ECLECTIC_IMPLING(Type.IMPLING_JAR, "Eclect", "ECL", ItemID.II_CAPTURED_IMPLING_6),
  NATURE_IMPLING(Type.IMPLING_JAR, "Nature", "NAT", ItemID.II_CAPTURED_IMPLING_7),
  MAGPIE_IMPLING(Type.IMPLING_JAR, "Magpie", "M", ItemID.II_CAPTURED_IMPLING_8),
  NINJA_IMPLING(Type.IMPLING_JAR, "Ninja", "NIN", ItemID.II_CAPTURED_IMPLING_9),
  CRYSTAL_IMPLING(Type.IMPLING_JAR, "Crystal", "C", ItemID.II_CAPTURED_IMPLING_12),
  DRAGON_IMPLING(Type.IMPLING_JAR, "Dragon", "D", ItemID.II_CAPTURED_IMPLING_10),
  LUCKY_IMPLING(Type.IMPLING_JAR, "Lucky", "L", ItemID.II_CAPTURED_IMPLING_11),

  // Tablets
  VARROCK_TELEPORT(Type.TABLET, "Varro", "VAR", ItemID.POH_TABLET_VARROCKTELEPORT),
  LUMBRIDGE_TELEPORT(Type.TABLET, "Lumbr", "LUM", ItemID.POH_TABLET_LUMBRIDGETELEPORT),
  FALADOR_TELEPORT(Type.TABLET, "Fala", "FAL", ItemID.POH_TABLET_FALADORTELEPORT),
  CAMELOT_TELEPORT(Type.TABLET, "Cammy", "CAM", ItemID.POH_TABLET_CAMELOTTELEPORT),
  ARDOUGNE_TELEPORT(Type.TABLET, "Ardoug", "ARD", ItemID.POH_TABLET_ARDOUGNETELEPORT),
  WATCHTOWER_TELEPORT(Type.TABLET, "W.tow", "WT", ItemID.POH_TABLET_WATCHTOWERTELEPORT),
  TELEPORT_TO_HOUSE(Type.TABLET, "House", "POH", ItemID.POH_TABLET_TELEPORTTOHOUSE),

  ENCHANT_SAPPHIRE_OR_OPAL(Type.TABLET, "E.Saph", "E SO", ItemID.POH_TABLET_ENCHANTSAPPHIRE),
  ENCHANT_EMERALD_OR_JADE(Type.TABLET, "E.Emer", "E EJ", ItemID.POH_TABLET_ENCHANTEMERALD),
  ENCHANT_RUBY_OR_TOPAZ(Type.TABLET, "E.Ruby", "E RT", ItemID.POH_TABLET_ENCHANTRUBY),
  ENCHANT_DIAMOND(Type.TABLET, "E.Diam", "E DIA", ItemID.POH_TABLET_ENCHANTDIAMOND),
  ENCHANT_DRAGONSTONE(Type.TABLET, "E.Dstn", "E DS", ItemID.POH_TABLET_ENCHANTDRAGONSTONE),
  ENCHANT_ONYX(Type.TABLET, "E.Onyx", "E ONX", ItemID.POH_TABLET_ENCHANTONYX),

  TELEKINETIC_GRAB(Type.TABLET, "T.grab", "T.GRB", ItemID.POH_TABLET_TELEGRAB),
  BONES_TO_PEACHES(Type.TABLET, "Peach", "BtP", ItemID.POH_TABLET_BONESTOPEACHES),
  BONES_TO_BANANAS(Type.TABLET, "Banana", "BtB", ItemID.POH_TABLET_BONESTOBANANAS),

  RIMMINGTON_TELEPORT(Type.TABLET, "Rimmi", "RIM", ItemID.NZONE_TELETAB_RIMMINGTON),
  TAVERLEY_TELEPORT(Type.TABLET, "Taver", "TAV", ItemID.NZONE_TELETAB_TAVERLEY),
  POLLNIVNEACH_TELEPORT(Type.TABLET, "Pollnv", "POL", ItemID.NZONE_TELETAB_POLLNIVNEACH),
  RELLEKKA_TELEPORT(Type.TABLET, "Rell", "REL", ItemID.NZONE_TELETAB_RELLEKKA),
  BRIMHAVEN_TELEPORT(Type.TABLET, "Brimh", "BRIM", ItemID.NZONE_TELETAB_BRIMHAVEN),
  YANILLE_TELEPORT(Type.TABLET, "Yanille", "YAN", ItemID.NZONE_TELETAB_YANILLE),
  TROLLHEIM_TELEPORT(Type.TABLET, "Trollh", "T.HM", ItemID.NZONE_TELETAB_TROLLHEIM),
  PRIFDDINAS_TELEPORT(Type.TABLET, "Prifd", "PRIF", ItemID.NZONE_TELETAB_PRIFDDINAS),
  HOSIDIUS_TELEPORT(Type.TABLET, "Hosid", "HOS", ItemID.NZONE_TELETAB_KOUREND),

  ANNAKARL_TELEPORT(Type.TABLET, "Annak", "GDZ", ItemID.TABLET_ANNAKARL),
  CARRALLANGER_TELEPORT(Type.TABLET, "Carra", "CAR", ItemID.TABLET_CARRALLANGAR),
  DAREEYAK_TELEPORT(Type.TABLET, "Dareey", "DAR", ItemID.TABLET_DAREEYAK),
  GHORROCK_TELEPORT(Type.TABLET, "Ghorr", "GHRK", ItemID.TABLET_GHORROCK),
  KHARYRLL_TELEPORT(Type.TABLET, "Khary", "KHRL", ItemID.TABLET_KHARYLL),
  LASSAR_TELEPORT(Type.TABLET, "Lass", "LSR", ItemID.TABLET_LASSAR),
  PADDEWWA_TELEPORT(Type.TABLET, "Paddew", "PDW", ItemID.TABLET_PADDEWA),
  SENNTISTEN_TELEPORT(Type.TABLET, "Sennt", "SNT", ItemID.TABLET_SENNTISTEN),

  ARCEUUS_LIBRARY_TELEPORT(Type.TABLET, "Arc.Lib", "A.LIB", ItemID.TELETAB_LUMBRIDGE),
  DRAYNOR_MANOR_TELEPORT(Type.TABLET, "D.Manor", "D.MNR", ItemID.TELETAB_DRAYNOR),
  MIND_ALTAR_TELEPORT(Type.TABLET, "M.Altar", "M.ALT", ItemID.TELETAB_MIND_ALTAR),
  SALVE_GRAVEYARD_TELEPORT(Type.TABLET, "S.Grave", "S.GRV", ItemID.TELETAB_SALVE),
  FENKENSTRAINS_CASTLE_TELEPORT(Type.TABLET, "Fenk", "FNK", ItemID.TELETAB_FENK),
  WEST_ARDOUGNE_TELEPORT(Type.TABLET, "W.Ardy", "W.ARD", ItemID.TELETAB_WESTARDY),
  HARMONY_ISLAND_TELEPORT(Type.TABLET, "H.Isle", "HRM", ItemID.TELETAB_HARMONY),
  CEMETERY_TELEPORT(Type.TABLET, "Cemet", "CEM", ItemID.TELETAB_CEMETERY),
  BARROWS_TELEPORT(Type.TABLET, "Barrow", "BAR", ItemID.TELETAB_BARROWS),
  APE_ATOLL_TELEPORT(Type.TABLET, "Atoll", "APE", ItemID.TELETAB_APE),
  BATTLEFRONT_TELEPORT(Type.TABLET, "B.Front", "BF", ItemID.TELETAB_BATTLEFRONT),

  MOONCLAN_TELEPORT(Type.TABLET, "Moon", "MOON", ItemID.LUNAR_TABLET_MOONCLAN_TELEPORT),
  OURANIA_TELEPORT(Type.TABLET, "Ourania", "ZMI", ItemID.LUNAR_TABLET_OURANIA_TELEPORT),
  WATERBIRTH_TELEPORT(Type.TABLET, "W.Birth", "WAT", ItemID.LUNAR_TABLET_WATERBIRTH_TELEPORT),
  BARBARIAN_TELEPORT(Type.TABLET, "Barb", "BARB", ItemID.LUNAR_TABLET_BARBARIAN_TELEPORT),
  KHAZARD_TELEPORT(Type.TABLET, "Khaz", "KHA", ItemID.LUNAR_TABLET_KHAZARD_TELEPORT),
  FISHING_GUILD_TELEPORT(Type.TABLET, "Fish G.", "FIS", ItemID.LUNAR_TABLET_FISHING_GUILD_TELEPORT),
  CATHERBY_TELEPORT(Type.TABLET, "Cathy", "CATH", ItemID.LUNAR_TABLET_CATHERBY_TELEPORT),
  ICE_PLATEAU(Type.TABLET, "Ice Pl.", "ICE", ItemID.LUNAR_TABLET_ICE_PLATEAU_TELEPORT),

  TARGET_TELEPORT(Type.TABLET, "Target", "TRG", ItemID.TABLET_TARGET),
  VOLCANIC_MINE_TELEPORT(Type.TABLET, "V.Mine", "VM", ItemID.FOSSIL_TABLET_VOLCANOTELEPORT),
  WILDERNESS_CRABS_TELEPORT(Type.TABLET, "W.Crab", "CRAB", ItemID.TABLET_WILDYCRABS),

  // Scrolls
  NARDAH_TELEPORT(Type.SCROLL, "Nardah", "NAR", ItemID.TELEPORTSCROLL_NARDAH),
  DIGSITE_TELEPORT(Type.SCROLL, "Digsite", "DIG", ItemID.TELEPORTSCROLL_DIGSITE),
  FELDIP_HILLS_TELEPORT(Type.SCROLL, "F.Hills", "F.H", ItemID.TELEPORTSCROLL_FELDIP),
  LUNAR_ISLE_TELEPORT(Type.SCROLL, "L.Isle", "L.I", ItemID.TELEPORTSCROLL_LUNARISLE),
  MORTTON_TELEPORT(Type.SCROLL, "Mort'ton", "MORT", ItemID.TELEPORTSCROLL_MORTTON),
  PEST_CONTROL_TELEPORT(Type.SCROLL, "P.Cont", "PEST", ItemID.TELEPORTSCROLL_PESTCONTROL),
  PISCATORIS_TELEPORT(Type.SCROLL, "Pisca", "PISC", ItemID.TELEPORTSCROLL_PISCATORIS),
  TAI_BWO_WANNAI_TELEPORT(Type.SCROLL, "TaiBwo", "TAI", ItemID.TELEPORTSCROLL_TAIBWO),
  IORWERTH_CAMP_TELEPORT(Type.SCROLL, "Iorwerth", "IOR", ItemID.TELEPORTSCROLL_ELF),
  MOS_LEHARMLESS_TELEPORT(Type.SCROLL, "M.LeHarm", "M.L", ItemID.TELEPORTSCROLL_MOSLES),
  LUMBERYARD_TELEPORT(Type.SCROLL, "Lumber", "LUMB", ItemID.TELEPORTSCROLL_LUMBERYARD),

  ZUL_ANDRA_TELEPORT(Type.SCROLL, "Zul-andra", "ZUL", ItemID.TELEPORTSCROLL_ZULANDRA),
  KEY_MASTER_TELEPORT(Type.SCROLL, "Key master", "KEY", ItemID.TELEPORTSCROLL_CERBERUS),
  REVENANT_CAVE_TELEPORT(Type.SCROLL, "Rev cave", "REV", ItemID.TELEPORTSCROLL_REVENANTS),
  WATSON_TELEPORT(Type.SCROLL, "Watson", "WATS", ItemID.TELEPORTSCROLL_WATSON),

  // Jewellery
  OPAL_JEWELLERY(
      Type.JEWELLERY,
      "Opal",
      "OP",
      ItemID.OPAL_RING,
      ItemID.OPAL_NECKLACE,
      ItemID.OPAL_BRACELET,
      ItemID.UNSTRUNG_OPAL_AMULET,
      ItemID.STRUNG_OPAL_AMULET),
  JADE_JEWELLERY(
      Type.JEWELLERY,
      "Jade",
      "J",
      ItemID.JADE_RING,
      ItemID.JADE_NECKLACE,
      ItemID.JADE_BRACELET,
      ItemID.UNSTRUNG_JADE_AMULET,
      ItemID.STRUNG_JADE_AMULET),
  TOPAZ_JEWELLERY(
      Type.JEWELLERY,
      "Topaz",
      "T",
      ItemID.TOPAZ_RING,
      ItemID.TOPAZ_NECKLACE,
      ItemID.TOPAZ_BRACELET,
      ItemID.UNSTRUNG_TOPAZ_AMULET,
      ItemID.STRUNG_TOPAZ_AMULET),
  GOLD_JEWELLERY(
      Type.JEWELLERY,
      "Gold",
      "GOL",
      ItemID.GOLD_RING,
      ItemID.GOLD_NECKLACE,
      ItemID.JEWL_GOLD_BRACELET_DUMMY,
      ItemID.UNSTRUNG_GOLD_AMULET,
      ItemID.STRUNG_GOLD_AMULET),
  SAPPHIRE_JEWELLERY(
      Type.JEWELLERY,
      "Sapphir",
      "S",
      ItemID.SAPPHIRE_RING,
      ItemID.SAPPHIRE_NECKLACE,
      ItemID.JEWL_SAPPHIRE_BRACELET_DUMMY,
      ItemID.UNSTRUNG_SAPPHIRE_AMULET,
      ItemID.STRUNG_SAPPHIRE_AMULET),
  EMERALD_JEWELLERY(
      Type.JEWELLERY,
      "Emerald",
      "E",
      ItemID.EMERALD_RING,
      ItemID.EMERALD_NECKLACE,
      ItemID.JEWL_EMERALD_BRACELET,
      ItemID.UNSTRUNG_EMERALD_AMULET,
      ItemID.STRUNG_EMERALD_AMULET),
  RUBY_JEWELLERY(
      Type.JEWELLERY,
      "Ruby",
      "R",
      ItemID.RUBY_RING,
      ItemID.RUBY_NECKLACE,
      ItemID.JEWL_RUBY_BRACELET,
      ItemID.UNSTRUNG_RUBY_AMULET,
      ItemID.STRUNG_RUBY_AMULET),
  DIAMOND_JEWELLERY(
      Type.JEWELLERY,
      "Diamon",
      "DI",
      ItemID.DIAMOND_RING,
      ItemID.DIAMOND_NECKLACE,
      ItemID.JEWL_DIAMOND_BRACELET,
      ItemID.UNSTRUNG_DIAMOND_AMULET,
      ItemID.STRUNG_DIAMOND_AMULET),
  DRAGONSTONE_JEWELLERY(
      Type.JEWELLERY,
      "Dragon",
      "DR",
      ItemID.DRAGONSTONE_RING,
      ItemID.DRAGONSTONE_NECKLACE,
      ItemID.JEWL_DRAGONSTONE_BRACELET,
      ItemID.UNSTRUNG_DRAGONSTONE_AMULET,
      ItemID.STRUNG_DRAGONSTONE_AMULET),
  ONYX_JEWELLERY(
      Type.JEWELLERY,
      "Onyx",
      "ON",
      ItemID.ONYX_RING,
      ItemID.ONYX_NECKLACE,
      ItemID.JEWL_ONYX_BRACELET,
      ItemID.UNSTRUNG_ONYX_AMULET,
      ItemID.STRUNG_ONYX_AMULET),
  ZENYTE_JEWELLERY(
      Type.JEWELLERY,
      "Zenyte",
      "Z",
      ItemID.ZENYTE_RING,
      ItemID.ZENYTE_NECKLACE,
      ItemID.ZENYTE_BRACELET_DUMMY,
      ItemID.UNSTRUNG_ZENYTE_AMULET,
      ItemID.ZENYTE_AMULET),

  // Enchanted Jewellery
  RING_OF_PURSUIT(Type.JEWELLERY_ENCHANTED, "Pursuit", "PUR", ItemID.RING_OF_PURSUIT),
  DODGY_NECKLACE(Type.JEWELLERY_ENCHANTED, "Dodgy", "DOD", ItemID.DODGY_NECKLACE),
  EXPEDITIOUS_BRACELET(Type.JEWELLERY_ENCHANTED, "Exped", "EXP", ItemID.EXPEDITIOUS_BRACELET),
  AMULET_OF_BOUNTY(Type.JEWELLERY_ENCHANTED, "Bounty", "BOU", ItemID.AMULET_OF_BOUNTY),

  RING_OF_RETURNING(
      Type.JEWELLERY_ENCHANTED,
      "Return",
      "RET",
      ItemID.RING_OF_RETURNING_1,
      ItemID.RING_OF_RETURNING_2,
      ItemID.RING_OF_RETURNING_3,
      ItemID.RING_OF_RETURNING_4,
      ItemID.RING_OF_RETURNING_5),
  NECKLACE_OF_PASSAGE(
      Type.JEWELLERY_ENCHANTED,
      "Passage",
      "PASS",
      ItemID.NECKLACE_OF_PASSAGE_1,
      ItemID.NECKLACE_OF_PASSAGE_2,
      ItemID.NECKLACE_OF_PASSAGE_3,
      ItemID.NECKLACE_OF_PASSAGE_4,
      ItemID.NECKLACE_OF_PASSAGE_5),
  FLAMTAER_BRACELET(Type.JEWELLERY_ENCHANTED, "Flamta", "FLA", ItemID.FLAMTAER_BRACELET),
  AMULET_OF_CHEMISTRY(Type.JEWELLERY_ENCHANTED, "Chem", "CH", ItemID.AMULET_OF_CHEMISTRY),

  EFARITAYS_AID(Type.JEWELLERY_ENCHANTED, "Efarit", "EFA", ItemID.VAMPYRE_RING),
  NECKLACE_OF_FAITH(Type.JEWELLERY_ENCHANTED, "Faith", "FAI", ItemID.NECKLACE_OF_FAITH),
  BRACELET_OF_SLAUGHTER(Type.JEWELLERY_ENCHANTED, "Slaught", "SLA", ItemID.BRACELET_OF_SLAUGHTER),
  BURNING_AMULET(
      Type.JEWELLERY_ENCHANTED,
      "Burning",
      "BUR",
      ItemID.BURNING_AMULET_1,
      ItemID.BURNING_AMULET_2,
      ItemID.BURNING_AMULET_3,
      ItemID.BURNING_AMULET_4,
      ItemID.BURNING_AMULET_5),

  RING_OF_RECOIL(Type.JEWELLERY_ENCHANTED, "Recoil", "REC", ItemID.RING_OF_RECOIL),
  GAMES_NECKLACE(
      Type.JEWELLERY_ENCHANTED,
      "Games",
      "GAME",
      ItemID.NECKLACE_OF_MINIGAMES_1,
      ItemID.NECKLACE_OF_MINIGAMES_2,
      ItemID.NECKLACE_OF_MINIGAMES_3,
      ItemID.NECKLACE_OF_MINIGAMES_4,
      ItemID.NECKLACE_OF_MINIGAMES_5,
      ItemID.NECKLACE_OF_MINIGAMES_6,
      ItemID.NECKLACE_OF_MINIGAMES_7,
      ItemID.NECKLACE_OF_MINIGAMES_8),
  BRACELET_OF_CLAY(Type.JEWELLERY_ENCHANTED, "Clay", "CLA", ItemID.JEWL_BRACELET_OF_CLAY),
  AMULET_OF_MAGIC(Type.JEWELLERY_ENCHANTED, "Magic", "MAG", ItemID.AMULET_OF_MAGIC),

  RING_OF_DUELING(
      Type.JEWELLERY_ENCHANTED,
      "Duel",
      "DU",
      ItemID.RING_OF_DUELING_1,
      ItemID.RING_OF_DUELING_2,
      ItemID.RING_OF_DUELING_3,
      ItemID.RING_OF_DUELING_4,
      ItemID.RING_OF_DUELING_5,
      ItemID.RING_OF_DUELING_6,
      ItemID.RING_OF_DUELING_7,
      ItemID.RING_OF_DUELING_8),
  BINDING_NECKLACE(Type.JEWELLERY_ENCHANTED, "Binding", "BIND", ItemID.MAGIC_EMERALD_NECKLACE),
  CASTLE_WARS_BRACELET(
      Type.JEWELLERY_ENCHANTED,
      "Castle",
      "CAS",
      ItemID.JEWL_CASTLEWARS_BRACELET,
      ItemID.JEWL_CASTLEWARS_BRACELET2,
      ItemID.JEWL_CASTLEWARS_BRACELET3),
  AMULET_OF_DEFENCE(Type.JEWELLERY_ENCHANTED, "Defence", "DEF", ItemID.AMULET_OF_DEFENCE),
  AMULET_OF_NATURE(Type.JEWELLERY_ENCHANTED, "Nature", "NAT", ItemID.NATURE_AMULET),

  RING_OF_FORGING(Type.JEWELLERY_ENCHANTED, "Forging", "FOR", ItemID.RING_OF_FORGING),
  DIGSITE_PENDANT(
      Type.JEWELLERY_ENCHANTED,
      "Digsite",
      "DIG",
      ItemID.NECKLACE_OF_DIGSITE_1,
      ItemID.NECKLACE_OF_DIGSITE_2,
      ItemID.NECKLACE_OF_DIGSITE_3,
      ItemID.NECKLACE_OF_DIGSITE_4,
      ItemID.NECKLACE_OF_DIGSITE_5),
  INOCULATION_BRACELET(Type.JEWELLERY_ENCHANTED, "Inocul", "INO",
      ItemID.JEWL_BRACELET_OF_INNOCULATION),
  AMULET_OF_STRENGTH(Type.JEWELLERY_ENCHANTED, "Strengt", "STR", ItemID.AMULET_OF_STRENGTH),

  RING_OF_LIFE(Type.JEWELLERY_ENCHANTED, "Life", "LI", ItemID.RING_OF_LIFE),
  PHOENIX_NECKLACE(Type.JEWELLERY_ENCHANTED, "Phoenix", "PHO", ItemID.JEWL_NECKLACE_OF_PHOENIX),
  ABYSSAL_BRACELET(
      Type.JEWELLERY_ENCHANTED,
      "Abyss",
      "ABY",
      ItemID.JEWL_RUNERUNNING_BRACELET_1,
      ItemID.JEWL_RUNERUNNING_BRACELET_2,
      ItemID.JEWL_RUNERUNNING_BRACELET_3,
      ItemID.JEWL_RUNERUNNING_BRACELET_4,
      ItemID.JEWL_RUNERUNNING_BRACELET_5),
  AMULET_OF_POWER(Type.JEWELLERY_ENCHANTED, "Power", "POW", ItemID.AMULET_OF_POWER),

  RING_OF_WEALTH(
      Type.JEWELLERY_ENCHANTED,
      "Wealth",
      "WE",
      ItemID.RING_OF_WEALTH,
      ItemID.RING_OF_WEALTH_1,
      ItemID.RING_OF_WEALTH_2,
      ItemID.RING_OF_WEALTH_3,
      ItemID.RING_OF_WEALTH_4,
      ItemID.RING_OF_WEALTH_5),
  SKILLS_NECKLACE(
      Type.JEWELLERY_ENCHANTED,
      "Skill",
      "SK",
      ItemID.JEWL_NECKLACE_OF_SKILLS,
      ItemID.JEWL_NECKLACE_OF_SKILLS_1,
      ItemID.JEWL_NECKLACE_OF_SKILLS_2,
      ItemID.JEWL_NECKLACE_OF_SKILLS_3,
      ItemID.JEWL_NECKLACE_OF_SKILLS_4,
      ItemID.JEWL_NECKLACE_OF_SKILLS_5,
      ItemID.JEWL_NECKLACE_OF_SKILLS_6),
  COMBAT_BRACELET(
      Type.JEWELLERY_ENCHANTED,
      "Combat",
      "COM",
      ItemID.JEWL_BRACELET_OF_COMBAT,
      ItemID.JEWL_BRACELET_OF_COMBAT_1,
      ItemID.JEWL_BRACELET_OF_COMBAT_2,
      ItemID.JEWL_BRACELET_OF_COMBAT_3,
      ItemID.JEWL_BRACELET_OF_COMBAT_4,
      ItemID.JEWL_BRACELET_OF_COMBAT_5,
      ItemID.JEWL_BRACELET_OF_COMBAT_6),
  AMULET_OF_GLORY(
      Type.JEWELLERY_ENCHANTED,
      "Glory",
      "GLO",
      ItemID.AMULET_OF_GLORY,
      ItemID.AMULET_OF_GLORY_1,
      ItemID.AMULET_OF_GLORY_2,
      ItemID.AMULET_OF_GLORY_3,
      ItemID.AMULET_OF_GLORY_4,
      ItemID.AMULET_OF_GLORY_5,
      ItemID.AMULET_OF_GLORY_6,
      ItemID.AMULET_OF_GLORY_INF),

  RING_OF_STONE(Type.JEWELLERY_ENCHANTED, "Stone", "STO", ItemID.ENCHANTED_ONYX_RING),
  BERSERKER_NECKLACE(Type.JEWELLERY_ENCHANTED, "Berserk", "BER", ItemID.JEWL_BESERKER_NECKLACE),
  REGEN_BRACELET(Type.JEWELLERY_ENCHANTED, "Regen", "REG", ItemID.JEWL_BRACELET_REGEN),
  AMULET_OF_FURY(Type.JEWELLERY_ENCHANTED, "Fury", "FU", ItemID.ENCHANTED_ONYX_AMULET),

  RING_OF_SUFFERING(Type.JEWELLERY_ENCHANTED, "Suffer", "SUF", ItemID.ZENYTE_RING_ENCHANTED),
  NECKLACE_OF_ANGUISH(Type.JEWELLERY_ENCHANTED, "Anguish", "ANG", ItemID.ZENYTE_NECKLACE_ENCHANTED),
  TORMENTED_BRACELET(Type.JEWELLERY_ENCHANTED, "Torment", "TOR", ItemID.ZENYTE_BRACELET_ENCHANTED),
  AMULET_OF_TORTURE(Type.JEWELLERY_ENCHANTED, "Torture", "TOR", ItemID.ZENYTE_AMULET_ENCHANTED),

  OCCULT_NECKLACE(Type.JEWELLERY_ENCHANTED, "Occult", "OCC", ItemID.OCCULT_NECKLACE),
  DRAGONBONE_NECKLACE(Type.JEWELLERY_ENCHANTED, "Dragon", "DRA", ItemID.DRAGONBONE_NECKLACE),
  SLAYER_RING(
      Type.JEWELLERY_ENCHANTED,
      "Slayer",
      "SLA",
      ItemID.SLAYER_RING_1,
      ItemID.SLAYER_RING_2,
      ItemID.SLAYER_RING_3,
      ItemID.SLAYER_RING_4,
      ItemID.SLAYER_RING_5,
      ItemID.SLAYER_RING_6,
      ItemID.SLAYER_RING_7,
      ItemID.SLAYER_RING_8,
      ItemID.SLAYER_RING_ETERNAL);

  private static final Map<Integer, ItemIdentification> itemIdentifications;

  static {
    ImmutableMap.Builder<Integer, ItemIdentification> builder = new ImmutableMap.Builder<>();

    for (ItemIdentification i : values()) {
      for (int id : i.itemIds) {
        builder.put(id, i);
      }
    }

    itemIdentifications = builder.build();
  }

  final Type type;
  final String medName;
  final String shortName;
  final int[] itemIds;

  ItemIdentification(Type type, String medName, String shortName, int... ids) {
    this.type = type;
    this.medName = medName;
    this.shortName = shortName;
    this.itemIds = ids;
  }

  static ItemIdentification get(int id) {
    return itemIdentifications.get(id);
  }

  @AllArgsConstructor
  enum Type {
    SEED_HERB(ItemIdentificationConfig::showHerbSeeds),
    SEED_BERRY(ItemIdentificationConfig::showBerrySeeds),
    SEED_ALLOTMENT(ItemIdentificationConfig::showAllotmentSeeds),
    SEED_SPECIAL(ItemIdentificationConfig::showSpecialSeeds),
    SEED_TREE(ItemIdentificationConfig::showTreeSeeds),
    SEED_FRUIT_TREE(ItemIdentificationConfig::showFruitTreeSeeds),
    SEED_FLOWER(ItemIdentificationConfig::showFlowerSeeds),
    HOPS_SEED(ItemIdentificationConfig::showHopsSeeds),
    SACK(ItemIdentificationConfig::showSacks),
    HERB(ItemIdentificationConfig::showHerbs),
    LOGS(ItemIdentificationConfig::showLogs),
    LOGS_PYRE(ItemIdentificationConfig::showPyreLogs),
    PLANK(ItemIdentificationConfig::showPlanks),
    SAPLING(ItemIdentificationConfig::showSaplings),
    COMPOST(ItemIdentificationConfig::showComposts),
    ORE(ItemIdentificationConfig::showOres),
    BAR(ItemIdentificationConfig::showBars),
    GEM(ItemIdentificationConfig::showGems),
    POTION(ItemIdentificationConfig::showPotions),
    IMPLING_JAR(ItemIdentificationConfig::showImplingJars),
    TABLET(ItemIdentificationConfig::showTablets),
    SCROLL(ItemIdentificationConfig::showTeleportScrolls),
    JEWELLERY(ItemIdentificationConfig::showJewellery),
    JEWELLERY_ENCHANTED(ItemIdentificationConfig::showEnchantedJewellery);

    final Predicate<ItemIdentificationConfig> enabled;
  }
}

/*
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package dev.thource.runelite.dudewheresmystuff;

import com.google.common.base.Strings;
import java.awt.Color;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.BooleanSupplier;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.ColorScheme;

/**
 * This class represents a Material Design inspired tab.
 *
 * <p>Each tab will communicate with it's containing group when it's clicked and that group will
 * display the tab's content on its own display.
 *
 * @author Psikoi
 */
public class FasterMaterialTab extends JLabel {

  private static final Border SELECTED_BORDER =
      new CompoundBorder(
          BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.BRAND_ORANGE),
          BorderFactory.createEmptyBorder(5, 10, 4, 10));

  private static final Border UNSELECTED_BORDER = BorderFactory.createEmptyBorder(5, 10, 5, 10);

  /* The tab's associated content display */
  @Getter private final JComponent content;

  /* To be executed when the tab is selected */
  @Setter private transient BooleanSupplier onSelectEvent;

  @Getter private boolean selected;

  FasterMaterialTab(FasterMaterialTabGroup group, JComponent content) {
    super("");

    this.content = content;

    unselect();

    addMouseListener(
        new MouseAdapter() {
          @Override
          public void mousePressed(MouseEvent mouseEvent) {
            group.select(FasterMaterialTab.this);
          }
        });

    if (!Strings.isNullOrEmpty("")) {
      addMouseListener(
          new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
              FasterMaterialTab tab = (FasterMaterialTab) e.getSource();
              tab.setForeground(Color.WHITE);
            }

            @Override
            public void mouseExited(MouseEvent e) {
              FasterMaterialTab tab = (FasterMaterialTab) e.getSource();
              if (!tab.isSelected()) {
                tab.setForeground(Color.GRAY);
              }
            }
          });
    }
  }

  FasterMaterialTab(ImageIcon icon, FasterMaterialTabGroup group, JComponent content) {
    this(group, content);
    setIcon(icon);
    setOpaque(true);
    setVerticalAlignment(SwingConstants.CENTER);
    setHorizontalAlignment(SwingConstants.CENTER);
    setBackground(ColorScheme.DARKER_GRAY_COLOR);

    addMouseListener(
        new MouseAdapter() {
          @Override
          public void mouseEntered(MouseEvent e) {
            FasterMaterialTab tab = (FasterMaterialTab) e.getSource();
            tab.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
          }

          @Override
          public void mouseExited(MouseEvent e) {
            FasterMaterialTab tab = (FasterMaterialTab) e.getSource();
            tab.setBackground(ColorScheme.DARKER_GRAY_COLOR);
          }
        });
  }

  boolean select() {
    if (onSelectEvent != null && !onSelectEvent.getAsBoolean()) {
      return false;
    }

    setBorder(SELECTED_BORDER);
    setForeground(Color.WHITE);
    selected = true;
    return true;
  }

  void unselect() {
    setBorder(UNSELECTED_BORDER);
    setForeground(Color.GRAY);
    selected = false;
  }
}

/*
 * Copyright (c) 2018, Danny <DannysPVM@gmail.com>
 * Copyright (c) 2022, Thource <https://github.com/Thource>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package dev.thource.runelite.dudewheresmystuff.death;

import java.awt.Graphics;
import java.awt.image.BufferedImage;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;
import net.runelite.client.util.ImageUtil;

class DeathWorldMapPoint extends WorldMapPoint {

  private final ItemManager itemManager;
  private final BufferedImage worldmapHintArrow;
  private final Point worldmapHintArrowPoint;
  private BufferedImage mapArrow;

  DeathWorldMapPoint(final WorldPoint worldPoint, ItemManager itemManager, int index) {
    super(worldPoint, null);
    this.itemManager = itemManager;

    worldmapHintArrow =
        new BufferedImage(
            getMapArrow().getWidth(), getMapArrow().getHeight(), BufferedImage.TYPE_INT_ARGB);
    Graphics graphics = worldmapHintArrow.getGraphics();
    graphics.drawImage(getMapArrow(), 0, 0, null);
    graphics.drawImage(itemManager.getImage(ItemID.BONES), 0, 0, null);
    worldmapHintArrowPoint =
        new Point(worldmapHintArrow.getWidth() / 2, worldmapHintArrow.getHeight());

    this.setSnapToEdge(true);
    this.setJumpOnClick(true);
    this.setImage(worldmapHintArrow);
    this.setImagePoint(worldmapHintArrowPoint);
    this.setTooltip("Deathpile");
    this.setName("Deathpile " + index);
  }

  BufferedImage getMapArrow() {
    if (mapArrow != null) {
      return mapArrow;
    }

    mapArrow = ImageUtil.loadImageResource(getClass(), "/util/clue_arrow.png");

    return mapArrow;
  }

  @Override
  public void onEdgeSnap() {
    this.setImage(itemManager.getImage(ItemID.BONES));
    this.setImagePoint(null);
    this.setTooltip(null);
  }

  @Override
  public void onEdgeUnsnap() {
    this.setImage(worldmapHintArrow);
    this.setImagePoint(worldmapHintArrowPoint);
    this.setTooltip("Deathpile");
  }

  @Override
  public boolean equals(Object o) {
    return super.equals(o);
  }

  @Override
  public int hashCode() {
    return super.hashCode();
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffConfig;
import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.Region;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import javax.annotation.Nonnull;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.util.QuantityFormatter;

class ExpiringDeathStorageInfoBox extends InfoBox {

  @Getter private final ExpiringDeathStorage storage;
  private final DudeWheresMyStuffConfig config;
  private final String regionName;
  private final BufferedImage icon;
  private final BufferedImage yellowIcon;
  private final BufferedImage redIcon;
  @Setter @Getter private boolean imageDirty = false;
  private final Client client;

  public ExpiringDeathStorageInfoBox(@Nonnull DudeWheresMyStuffPlugin plugin,
      ExpiringDeathStorage storage, int iconId) {
    super(null, plugin);

    config = plugin.getConfig();
    client = plugin.getClient();
    icon = plugin.getItemManager().getImage(iconId);
    yellowIcon = tintImage(icon, new Color(255, 210, 0, 80));
    redIcon = tintImage(icon, new Color(230, 0, 0, 80));

    setImage(icon);
    this.storage = storage;

    var region = storage.getRegion();
    regionName = (region == null ? "Unknown" : region.getName());
    refreshTooltip();
  }

  private static BufferedImage tintImage(BufferedImage originalImage, Color color) {
    BufferedImage tintedImage = new BufferedImage(originalImage.getWidth(),
        originalImage.getHeight(), BufferedImage.TYPE_INT_ARGB);

    Graphics2D g2d = tintedImage.createGraphics();
    g2d.setColor(color);
    g2d.fillRect(0, 0, tintedImage.getWidth(), tintedImage.getHeight());
    g2d.drawImage(originalImage, 0, 0, null);
    g2d.dispose();

    return tintedImage;
  }

  void refreshTooltip() {
    String deathpileValue = QuantityFormatter.quantityToStackSize(
        storage.getTotalValue());

    setTooltip(
        regionName + " " + this.storage.getName().toLowerCase() + " (" + deathpileValue
            + " gp)");

    if (storage.isUseAccountPlayTime()
        && storage.getDeathStorageManager().getStartPlayedMinutes() <= 0) {
      if (getImage() != yellowIcon) {
        setImage(yellowIcon);
        imageDirty = true;
      }

      return;
    }

    if (config.flashExpiringDeathpileInfoboxes()) {
      int minutesLeft =
          (int) Math.floor(
              (storage.getExpiryMs() - System.currentTimeMillis()) / 60000f);

      if (minutesLeft <= config.deathpileExpiryWarningTime()) {
        if ((client.getTickCount() + 1) % 2 == 0) {
          setImage(redIcon);
        } else {
          setImage(icon);
        }

        imageDirty = true;
        return;
      }
    }

    if (getImage() != icon) {
      setImage(icon);
      imageDirty = true;
    }
  }

  @Override
  public String getText() {
    if (storage.isUseAccountPlayTime()
        && storage.getDeathStorageManager().getStartPlayedMinutes() <= 0) {
      return "??";
    }

    int minutesLeft =
        (int) Math.floor(
            (storage.getExpiryMs() - System.currentTimeMillis()) / 60000f);

    return (minutesLeft > 0 ? minutesLeft : "<1") + "m";
  }

  @Override
  public Color getTextColor() {
    return storage.getColor();
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

public enum DyingState {
  NOT_DYING,
  TICK_1,
  TICK_2,
  TICK_3,
  RECORDING_DATA,
  WAITING_FOR_RESPAWN
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.OverviewItemPanel;
import dev.thource.runelite.dudewheresmystuff.StorageTabPanel;
import java.awt.Color;
import java.util.Comparator;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.gameval.ItemID;

/** DeathStorageTabPanel is responsible for displaying death storage data to the player. */
@Slf4j
public class DeathStorageTabPanel
    extends StorageTabPanel<DeathStorageType, DeathStorage, DeathStorageManager> {

  public DeathStorageTabPanel(DudeWheresMyStuffPlugin plugin, DeathStorageManager storageManager) {
    super(plugin, storageManager);
  }

  @Override
  public void reorderStoragePanels() {
    super.reorderStoragePanels();

    if (plugin.getConfig().showDeathStorageRiskWarning()) {
      OverviewItemPanel warningPanel = new OverviewItemPanel(plugin.getItemManager(), null,
          () -> false, ItemID.SIGIL_OF_CONSISTENCY_ATTUNED, 1, "WARNING!");
      warningPanel.updateStatus(
          "<HTML>The information displayed<br> in this tab can be inaccurate!<br><br>By relying on this information,<br>you are risking your items!</HTML>");
      warningPanel.setTitleColor(Color.RED);
      warningPanel.setToolTipText(
          "<html>Every effort has been made to make death tracking as accurate<br>" +
              "as possible, but the information shown in this plugin isn't <br>" +
              "guaranteed to be 100% accurate.<br><br>" +
              "Jagex send very little information about death storages to <br>" +
              "the client, so the plugin has to try to piece your death storages<br>" +
              "together based on the information that it can get.<br><br>" +
              "Timers may be wrong, items may be wrong, it's possible for you<br>" +
              "to have death storages that aren't visible in the plugin.<br><br>" +
              "Please do not rely 100% on this plugin to track your death<br>" +
              "storages, you may lose items.</html>"
      );
      storagePanelContainer.add(warningPanel, 0);
      storagePanelContainer.revalidate();
    }
  }

  @Override
  protected Comparator<DeathStorage> getStorageSorter() {
    return Comparator.comparingLong(
        s -> {
          if (s instanceof ExpiringDeathStorage) {
            ExpiringDeathStorage storage = (ExpiringDeathStorage) s;

            // Move expired deathpiles/graves to the bottom of the list and sort them the opposite
            // way (newest first)
            if (storage.hasExpired()) {
              return Long.MAX_VALUE - storage.getExpiryMs();
            }

            return Long.MIN_VALUE + storage.getExpiryMs();
          } else if (s instanceof DeathItems || s instanceof DeathsOffice) {
            return Long.MIN_VALUE;
          } else {
            Deathbank deathbank = (Deathbank) s;

            if (deathbank.getLostAt() != -1L) {
              return Long.MAX_VALUE - deathbank.getLostAt();
            }

            return Long.MIN_VALUE + 1;
          }
        });
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;

/** DeathsOffice shows the user what items they have stored in death's office. */
public class DeathsOffice extends DeathStorage {

  protected DeathsOffice(DudeWheresMyStuffPlugin plugin) {
    super(DeathStorageType.DEATHS_OFFICE, plugin);
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.Region;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * DeathbankType is used to identify Deathbanks.
 */
@RequiredArgsConstructor
@Getter
public enum DeathbankType {
  UNKNOWN("Unknown Deathbank", -100, -100, null, null),
  VOLCANIC_MINE("Volcanic Mine", 1, 2, Region.MG_VOLCANIC_MINE, "FossilIsland"), // confirmed
  GUARDIANS("Grotesque Guardians", 3, 4, Region.BOSS_GROTESQUE_GUARDIANS, null), // confirmed
  VORKATH("Vorkath", 5, 6, Region.BOSS_VORKATH, "Rellekka"), // confirmed
  QUEST_DS2("Dragon Slayer II", 7, 8, Region.REGION_GALVEK_SHIPWRECKS, null),
  QUEST_ATOH("A Taste of Hope", 9, 10, null, null),
  TOB("Theatre of Blood", 11, 12, Region.RAIDS_THEATRE_OF_BLOOD, "TheatreofBlood"), // confirmed
  HYDRA("Alchemical Hydra", 13, 14, Region.BOSS_HYDRA, "KaruulmSlayerDungeon"), // confirmed
  HESPORI("Hespori", 15, 16, Region.BOSS_HESPORI, "FarmingGuild"), // confirmed
  MIMIC("The Mimic", 17, 18, null, null),
  QUEST_SOTE("Song of the Elves", 19, 20, null, "elvenrebel"),
  QUEST_SOTE2("Song of the Elves", 21, 22, null, "elvenrebel"),
  QUEST_TFE("The Fremennik Exiles", 23, 24, null, null),
  NIGHTMARE("The Nightmare", 25, 26, Region.BOSS_NIGHTMARE, "Shura"), // confirmed
  PHOSANI("Phosani's Nightmare", 27, 28, Region.BOSS_NIGHTMARE, "SisterSenga"), // confirmed
  SEPULCHRE("Hallowed Sepulchre", 29, 30, Region.MG_HALLOWED_SEPULCHRE, null), // confirmed
  QUEST_SOTF("Sins of the Father", 31, 32, null, null),
  ZULRAH("Zulrah", 33, 0, Region.BOSS_ZULRAH, "Zul-Andra"), // confirmed
  NEX("Nex", 36, 37, Region.BOSS_NEX, null); // confirmed

  private final String name;
  private final int deathBankLockedState;
  private final int deathBankUnlockedState;
  private final Region region;
  private final String deathWindowLocationText;
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import dev.thource.runelite.dudewheresmystuff.StoragePanel;
import java.util.Collections;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.config.ConfigManager;

/** DeathItems shows the user what items they will lose on death. */
@Slf4j
public class DeathItems extends DeathStorage {

  private final DeathStorageManager deathStorageManager;

  protected DeathItems(DudeWheresMyStuffPlugin plugin, DeathStorageManager deathStorageManager) {
    super(DeathStorageType.DEATH_ITEMS, plugin);

    this.deathStorageManager = deathStorageManager;
  }

  @Override
  protected void createStoragePanel(StorageManager<?, ?> storageManager) {
    storagePanel = new StoragePanel(plugin, this, false, false, true);

    storagePanel.collapse(true);

    createComponentPopupMenu(storageManager);
  }

  public void createDebugDeathpile(WorldPoint worldPoint) {
    var deathpile = deathStorageManager.createDeathpile(RemoteDeathpileAreas.getPileArea(plugin.getClient(), worldPoint), items);
    SwingUtilities.invokeLater(() ->
        plugin.getClientThread().invoke(() ->
            deathStorageManager.updateStorages(Collections.singletonList(deathpile))));
  }

  public void createDebugGrave(WorldPoint worldPoint) {
    var grave = deathStorageManager.createGrave(RemoteDeathpileAreas.getPileArea(plugin.getClient(), worldPoint), items);
    SwingUtilities.invokeLater(() ->
        plugin.getClientThread().invoke(() ->
            deathStorageManager.updateStorages(Collections.singletonList(grave))));
  }

  public void createDebugDeathbank() {
    if (deathStorageManager.getDeathbank() != null) {
      deathStorageManager.getDeathbank().setLostAt(System.currentTimeMillis());
    }

    deathStorageManager.createMysteryDeathbank(DeathbankType.UNKNOWN);
    var deathbank = deathStorageManager.getDeathbank();
    deathbank.getItems().clear();
    deathbank.getItems().addAll(items);
  }

  @Override
  protected void createComponentPopupMenu(StorageManager<?, ?> storageManager) {
    if (!plugin.isDeveloperMode() || deathStorageManager.isPreviewManager()
        || storagePanel == null) {
      return;
    }

    final JPopupMenu popupMenu = new JPopupMenu();
    popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
    storagePanel.setComponentPopupMenu(popupMenu);

    final JMenuItem createDeathpileItem = new JMenuItem("Create Deathpile");
    createDeathpileItem.addActionListener(e -> {
      var client = plugin.getClient();
      createDebugDeathpile(
          WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation()));
    });
    popupMenu.add(createDeathpileItem);

    final JMenuItem createGrave = new JMenuItem("Create Grave");
    createGrave.addActionListener(e -> {
      var client = plugin.getClient();
      createDebugGrave(
          WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation()));
    });
    popupMenu.add(createGrave);

    final JMenuItem createDeathbank = new JMenuItem("Create Deathbank");
    createDeathbank.addActionListener(e -> createDebugDeathbank());
    popupMenu.add(createDeathbank);
  }

  @Override
  public void softUpdate() {
    plugin.getClientThread().invoke(() -> {
      items.clear();
      items.addAll(deathStorageManager.getDeathItems());

      if (storagePanel != null) {
        storagePanel.refreshItems();

        SwingUtilities.invokeLater(() -> storagePanel.update());
      }
    });
  }

  @Override
  public void save(ConfigManager configManager, String profileKey,
      String managerConfigKey) {
    // No saving
  }

  @Override
  public void load(ConfigManager configManager, String managerConfigKey, String profileKey) {
    // No loading
  }

  @Override
  public boolean isWithdrawable() {
    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import javax.annotation.Nonnull;
import net.runelite.api.gameval.ItemID;

class DeathpileInfoBox extends ExpiringDeathStorageInfoBox {

  public DeathpileInfoBox(@Nonnull DudeWheresMyStuffPlugin plugin, Deathpile deathpile) {
    super(plugin, deathpile, ItemID.BONES);
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import java.awt.Color;
import javax.annotation.Nonnull;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.ui.overlay.infobox.InfoBox;

class DeathbankInfoBox extends InfoBox {

  @Getter private final Deathbank deathbank;

  public DeathbankInfoBox(@Nonnull DudeWheresMyStuffPlugin plugin, Deathbank deathbank) {
    super(plugin.getItemManager().getImage(ItemID.OSB7_CAT_HAIR), plugin);
    this.deathbank = deathbank;

    setTooltip("Active deathbank: " + deathbank.getDeathbankType().getName());
  }

  @Override
  public String getText() {
    return null;
  }

  @Override
  public Color getTextColor() {
    return null;
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import com.google.common.base.Strings;
import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffConfig;
import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Stroke;
import java.util.Objects;
import javax.annotation.Nullable;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

public class ExpiringDeathStorageTilesOverlay extends Overlay {

  private final Client client;
  private final DeathStorageManager deathStorageManager;
  private final DudeWheresMyStuffConfig config;
  private final DudeWheresMyStuffPlugin plugin;

  public ExpiringDeathStorageTilesOverlay(
      DudeWheresMyStuffConfig config,
      Client client,
      DeathStorageManager deathStorageManager,
      DudeWheresMyStuffPlugin plugin) {
    this.config = config;
    this.client = client;
    this.deathStorageManager = deathStorageManager;
    this.plugin = plugin;

    setPosition(OverlayPosition.DYNAMIC);
    setPriority(0.0f);
    setLayer(OverlayLayer.ABOVE_SCENE);
  }

  private String getExpiryText(ExpiringDeathStorage expiringDeathStorage) {
    if (expiringDeathStorage.isUseAccountPlayTime()
        && expiringDeathStorage.getDeathStorageManager().getStartPlayedMinutes() <= 0) {
      return "??";
    }

    int minutesLeft =
        (int)
            Math.floor((expiringDeathStorage.getExpiryMs() - System.currentTimeMillis()) / 60000f);

    return (minutesLeft > 0 ? minutesLeft : "<1") + "m";
  }

  @Override
  public Dimension render(Graphics2D graphics) {
    if (plugin.isDeveloperMode()
        && Objects.equals(
            plugin
                .getConfigManager()
                .getConfiguration(
                    DudeWheresMyStuffConfig.CONFIG_GROUP, "debug.render.remoteDeathpileAreas"),
            "true")) {
      for (RemoteDeathpileAreas remoteDeathpileArea : RemoteDeathpileAreas.values()) {
        var deathArea = remoteDeathpileArea.getDeathArea();
        var deathRegions = remoteDeathpileArea.getDeathRegionIds();
        if (deathArea != null) {
          drawArea(
              graphics,
              deathArea,
              Color.ORANGE,
              remoteDeathpileArea.name() + " death area",
              new BasicStroke(2));
        } else if (deathRegions != null) {
          for (Integer deathRegionId : remoteDeathpileArea.getDeathRegionIds()) {
            drawTile(
                graphics,
                WorldPoint.fromRegion(deathRegionId, 32, 32, remoteDeathpileArea.getDeathPlane()),
                Color.ORANGE,
                remoteDeathpileArea.name() + " death region",
                new BasicStroke(2));
          }
        }

        drawArea(
            graphics,
            remoteDeathpileArea.getPileArea(),
            Color.GREEN,
            remoteDeathpileArea.name() + " pile area",
            new BasicStroke(2));
      }
    }

    if (!config.deathpileTileMarkers()) {
      return null;
    }

    deathStorageManager
        .getExpiringDeathStorages()
        .filter(storage -> !storage.hasExpired())
        .forEach(
            storage -> {
              Color tileColor = storage.getColor();

              if (config.flashExpiringDeathpileTiles()
                  && (int)
                          Math.floor((storage.getExpiryMs() - System.currentTimeMillis()) / 60_000f)
                      <= config.deathpileExpiryWarningTime()
                  && client.getTickCount() % 2 == 0) {
                tileColor = Color.RED;
              }

              var worldPoint = storage.getWorldPoint();
              if (worldPoint != null) {
                drawTile(
                    graphics,
                    storage.getWorldPoint(),
                    tileColor,
                    storage.getName() + " (" + getExpiryText(storage) + ")",
                    new BasicStroke(2));
              }

              var worldArea = storage.getWorldArea();
              if (worldArea != null) {
                drawArea(
                    graphics,
                    storage.getWorldArea(),
                    tileColor,
                    storage.getName() + " area (" + getExpiryText(storage) + ")",
                    new BasicStroke(2));
              }
            });

    return null;
  }

  private void drawArea(
      Graphics2D graphics,
      WorldArea area,
      Color color,
      @Nullable String label,
      Stroke borderStroke) {
    WorldPoint playerLocation =
        WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());

    if (area.distanceTo(playerLocation) >= 32) {
      return;
    }

    var worldView = client.getTopLevelWorldView();
    for (WorldPoint worldPoint : WorldPoint.toLocalInstance(worldView, area.toWorldPoint())) {
      LocalPoint lp =
          LocalPoint.fromWorld(
              worldView,
              worldPoint.getX() + area.getWidth() / 2,
              worldPoint.getY() + area.getHeight() / 2);
      if (lp == null) {
        return;
      }

      Polygon poly =
          Perspective.getCanvasTileAreaPoly(
              client, lp, area.getWidth(), area.getHeight(), area.getPlane(), 0);
      if (poly != null) {
        OverlayUtil.renderPolygon(graphics, poly, color, new Color(0, 0, 0, 0.3f), borderStroke);
      }

      if (!Strings.isNullOrEmpty(label)) {
        Point canvasTextLocation =
            Perspective.getCanvasTextLocation(client, graphics, lp, label, 0);
        if (canvasTextLocation != null) {
          OverlayUtil.renderTextLocation(
              graphics,
              new Point(canvasTextLocation.getX(), canvasTextLocation.getY() + 20),
              label,
              color);
        }
      }
    }
  }

  private void drawTile(
      Graphics2D graphics,
      WorldPoint point,
      Color color,
      @Nullable String label,
      Stroke borderStroke) {
    WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

    if (point.distanceTo(playerLocation) >= 32) {
      return;
    }

    var worldView = client.getTopLevelWorldView();
    LocalPoint lp = LocalPoint.fromWorld(worldView, point);
    if (lp == null) {
      return;
    }

    Polygon poly = Perspective.getCanvasTilePoly(client, lp);
    if (poly != null) {
      OverlayUtil.renderPolygon(graphics, poly, color, new Color(0, 0, 0, 0.3f), borderStroke);
    }

    if (!Strings.isNullOrEmpty(label)) {
      Point canvasTextLocation = Perspective.getCanvasTextLocation(client, graphics, lp, label, 0);
      if (canvasTextLocation != null) {
        OverlayUtil.renderTextLocation(
            graphics,
            new Point(canvasTextLocation.getX(), canvasTextLocation.getY() + 20),
            label,
            color);
      }
    }
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

/** DeathpileExpiryWarningType is used to decide how expiring deathpiles will be shown. */
@Getter
@RequiredArgsConstructor
public enum DeathpileExpiryWarningType {
  OFF("Off"),
  TEXT("Screen text"),
  INFOBOX("Infobox flashing"),
  BOTH("BOTH");

  private final String name;

  @Override
  public String toString() {
    return name;
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.StorageType;
import java.util.Collections;
import java.util.List;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.InventoryID;

/** DeathStorageType is used to identify DeathStorages. */
@RequiredArgsConstructor
@Getter
public enum DeathStorageType implements StorageType {
  DEATH_ITEMS("Death Items", -1, true, "", false, null),
  DEATHPILE("Deathpile", -1, true, "deathpile", false, null),
  GRAVE("Grave", -1, true, "grave", false, null),
  DEATHBANK("Deathbank", -1, false, "deathbank", true, null),
  DEATHS_OFFICE("Death's Office", InventoryID.DEATH_PERMANENT, false, "deathsoffice", false, Collections.singletonList(2));

  private final String name;
  private final int itemContainerId;
  // Whether the storage can be updated with no action required by the player
  private final boolean automatic;
  private final String configKey;
  private final boolean membersOnly;
  private final List<Integer> accountTypeBlacklist;
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;
import javax.swing.JLabel;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.VarbitID;

/** Grave is responsible for tracking the player's items that are in a grave. */
@Getter
@Slf4j
public class Grave extends ExpiringDeathStorage {

  Grave(DudeWheresMyStuffPlugin plugin, WorldArea worldArea,
      DeathStorageManager deathStorageManager, List<ItemStack> deathItems) {
    super(plugin, false, worldArea, deathStorageManager, deathItems,
        DeathStorageType.GRAVE);
  }

  static Grave load(DudeWheresMyStuffPlugin plugin, DeathStorageManager deathStorageManager,
      String profileKey, String uuid) {
    Grave grave = new Grave(
        plugin,
        null,
        deathStorageManager,
        new ArrayList<>()
    );

    grave.uuid = UUID.fromString(uuid);
    grave.load(deathStorageManager.getConfigManager(), deathStorageManager.getConfigKey(),
        profileKey);

    return grave;
  }

  @Override
  public boolean onChatMessage(ChatMessage chatMessage) {
    if (!hasExpired() && (chatMessage.getType() == ChatMessageType.SPAM
        || chatMessage.getType() == ChatMessageType.GAMEMESSAGE) && (Objects.equals(
        chatMessage.getMessage(),
        "You successfully retrieved everything from your gravestone."))) {
      // invoke this later, so that it doesn't cause concurrent modification
      deathStorageManager.getClientThread()
          .invokeLater(() -> deathStorageManager.deleteStorage(this));

    }

    return false;
  }

  @Override
  public boolean onGameTick() {
    if (hasExpired()) {
      return false;
    }

    int newExpiryTime = plugin.getClient().getVarbitValue(VarbitID.GRAVESTONE_DURATION);
    if (newExpiryTime <= 0) {
      if (expiryTime >= 6) {
        // invoke this later, so that it doesn't cause concurrent modification
        deathStorageManager.getClientThread()
            .invokeLater(() -> deathStorageManager.deleteStorage(this));

        return false;
      }

      expire();
      return true;
    }

    expiryTime = newExpiryTime;

    if (worldPoint == null) {
      locate();
    }

    return true;
  }

  private void locate() {
    Optional<NPC> graveObject = plugin.getClient().getNpcs().stream()
        .filter(
            n -> n.getId() == NpcID.GRAVESTONE_DEFAULT || n.getId() == NpcID.GRAVESTONE_ANGEL)
        .findFirst();
    if (graveObject.isEmpty()) {
      return;
    }

    if (worldArea != null && !worldArea.contains(graveObject.get().getWorldLocation())) {
      return;
    }

    worldPoint = graveObject.get().getWorldLocation();
    worldArea = null;
    deathStorageManager.refreshMapPoints();
    SwingUtilities.invokeLater(this::setSubTitle);
  }

  void expire() {
    expiredAt = System.currentTimeMillis();

    deathStorageManager.getDeathsOffice().getItems().addAll(items);
    deathStorageManager.updateStorages(
        Collections.singletonList(deathStorageManager.getDeathsOffice()));

    SwingUtilities.invokeLater(() -> {
      if (storagePanel == null) {
        return;
      }

      JLabel footerLabel = storagePanel.getFooterLabel();
      footerLabel.setIcon(null);
      footerLabel.setToolTipText(null);
    });
  }

  @Override
  public int getTotalLifeInMinutes() {
    return 15;
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import java.util.Arrays;
import java.util.List;
import javax.annotation.Nullable;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

@Getter
enum RemoteDeathpileAreas {
  BOSS_ARAXXOR(new WorldArea(3616, 9797, 35, 40, 0), new WorldArea(3657, 9812, 5, 7, 0)),
  BOSS_CERBERUS(List.of(4883, 5140, 5395), 0, new WorldArea(1307, 1247, 7, 6, 0)),
  BOSS_COLOSSEUM(new WorldArea(1805, 3087, 40, 40, 0), new WorldArea(1800, 9504, 5, 5, 0)),
  BOSS_DOOM(List.of(5269), 0, new WorldArea(1309, 9549, 5, 8, 0)),
  BOSS_DT2_DUKE(new WorldArea(3028, 6434, 23, 24, 0), new WorldArea(3038, 6428, 3, 5, 0)),
  BOSS_DT2_LEVIATHAN(List.of(8291), 0, new WorldArea(2059, 6433, 8, 5, 0)),
  BOSS_DT2_VARDORVIS(new WorldArea(1118, 3407, 23, 21, 0), new WorldArea(1113, 3426, 7, 8, 0)),
  BOSS_DT2_WHISPERER(List.of(9571, 10595, 12898), 0, new WorldArea(2921, 5821, 3, 6, 0)),
  BOSS_GWD_ARMADYL(new WorldArea(2823, 5295, 21, 15, 2), new WorldArea(2834, 5288, 11, 7, 2)),
  BOSS_GWD_BANDOS(new WorldArea(2863, 5351, 15, 21, 2), new WorldArea(2857, 5349, 6, 11, 2)),
  BOSS_GWD_SARADOMIN(new WorldArea(2888, 5257, 21, 20, 0), new WorldArea(2908, 5261, 7, 10, 0)),
  BOSS_GWD_ZAMORAK(new WorldArea(2917, 5317, 21, 16, 2), new WorldArea(2923, 5333, 7, 7, 2)),
  BOSS_MUSPAH(List.of(11330), 0, new WorldArea(2908, 10313, 7, 10, 0)),
  BOSS_ROYAL_TITANS(new WorldArea(2908, 9560, 7, 15, 0), new WorldArea(2949, 9571, 7, 7, 0)),
  BOSS_SKOTIZO(List.of(9048), 0, new WorldArea(1658, 10042, 12, 12, 0)),
  BOSS_YAMA(List.of(6045), 0, new WorldArea(1438, 10074, 4, 6, 0)),
  QUEST_SECRETS_OF_THE_NORTH_MUSPAH(List.of(11330), 0, new WorldArea(2844, 10333, 5, 6, 0)),
  //  QUEST_BENEATH_CURSED_SANDS_AKH(new WorldArea(), new WorldArea()),
  QUEST_BENEATH_CURSED_SANDS_CHAMPION(List.of(13456), 0, new WorldArea(3411, 2843, 7, 10, 0)),
  QUEST_CURSE_OF_ARRAV(new WorldArea(3613, 4578, 28, 10, 0), new WorldArea(3577, 4602, 5, 5, 0)),
  //  QUEST_DESERT_TREASURE_2_SHADOW_REALM(new WorldArea(), new WorldArea()),
  //  QUEST_DESERT_TREASURE_2_STRANGLEWOOD(new WorldArea(), new WorldArea()),
  //  QUEST_FREMENNIK_EXILES(new WorldArea(), new WorldArea()),
  QUEST_MONKEY_MADNESS_2_KRUK(
      new WorldArea(2517, 9201, 33, 28, 1), new WorldArea(2531, 9232, 16, 9, 1)),
  QUEST_MONKEY_MADNESS_2_END_SURFACE(List.of(8023), 0, new WorldArea(2427, 3514, 14, 6, 0)),
  QUEST_MONKEY_MADNESS_2_END_CAVE(List.of(8280, 8536), 0, new WorldArea(2427, 3514, 14, 6, 0)),
  ;

  @Nullable private final WorldArea deathArea;
  @Nullable private final List<Integer> deathRegionIds;
  private final int deathPlane;
  private final WorldArea pileArea;

  RemoteDeathpileAreas(List<Integer> deathRegionIds, int deathPlane, WorldArea pileArea) {
    this.deathArea = null;
    this.deathRegionIds = deathRegionIds;
    this.deathPlane = deathPlane;
    this.pileArea = pileArea;
  }

  RemoteDeathpileAreas(WorldArea deathArea, WorldArea pileArea) {
    this.deathArea = deathArea;
    this.deathRegionIds = null;
    this.deathPlane = -1;
    this.pileArea = pileArea;
  }

  static WorldArea getPileArea(Client client, WorldPoint worldPoint) {
    var regionId = worldPoint.getRegionID();
    if (regionId == 11330) {
      return (Quest.SECRETS_OF_THE_NORTH.getState(client) == QuestState.FINISHED
              ? BOSS_MUSPAH
              : QUEST_SECRETS_OF_THE_NORTH_MUSPAH)
          .getPileArea();
    }

    if ((regionId == 8023 || regionId == 8280 || regionId == 8536)
        && Quest.MONKEY_MADNESS_II.getState(client) == QuestState.FINISHED) {
      return worldPoint.toWorldArea();
    }

    var remotePoint =
        Arrays.stream(values())
            .filter(
                l -> {
                  if (l.getDeathArea() != null) {
                    return l.getDeathArea().contains(worldPoint);
                  }

                  if (l.getDeathRegionIds() != null) {
                    return worldPoint.getPlane() == l.getDeathPlane()
                        && l.getDeathRegionIds().contains(regionId);
                  }

                  return false;
                })
            .findFirst();

    if (remotePoint.isPresent()) {
      return remotePoint.get().getPileArea();
    }

    return worldPoint.toWorldArea();
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.coords.WorldPoint;

@RequiredArgsConstructor
@Getter
class SuspendedGroundItem {
  private final int id;
  private final WorldPoint worldPoint;
  @Setter private int ticksLeft;
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffConfig;
import dev.thource.runelite.dudewheresmystuff.Region;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import net.runelite.api.Client;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;

public class ExpiringDeathStorageTextOverlay extends Overlay {

  private final DudeWheresMyStuffConfig config;
  private final DeathStorageManager deathStorageManager;
  private ExpiringDeathStorage storage;
  private String regionName = null;
  private final Client client;

  public ExpiringDeathStorageTextOverlay(DudeWheresMyStuffConfig config,
      DeathStorageManager deathStorageManager, Client client) {
    this.config = config;
    this.deathStorageManager = deathStorageManager;
    this.client = client;

    setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
  }

  // Updates every game tick
  public void updateSoonestExpiringDeathStorage() {
    ExpiringDeathStorage newStorage;
    if (client.getVarbitValue(VarbitID.IRONMAN) == 2) {
      newStorage = deathStorageManager.getSoonestExpiringDeathpile();
    } else {
      newStorage = deathStorageManager.getGrave();
    }
    if (newStorage == storage) {
      return;
    }

    storage = newStorage;
    if (storage != null) {
      var region = storage.getRegion();
      regionName = (region == null ? null : region.getName());
    }
  }

  // If there is a storage expiring soon that matches the config criteria
  private boolean shouldRenderOverlay() {
    return storage != null
        && config.showDeathpileExpiryText()
        && (int) Math.floor((storage.getExpiryMs() - System.currentTimeMillis()) / 60_000f)
        <= config.deathpileExpiryWarningTime();
  }

  @Override
  public Dimension render(Graphics2D graphics) {
    if (shouldRenderOverlay()) {
      return renderText(graphics);
    }

    return null;
  }

  private Dimension renderText(Graphics2D graphics) {
    Font font = FontManager.getRunescapeFont()
        .deriveFont(Font.PLAIN, config.deathpileExpiryWarningFontSize());
    graphics.setFont(font);

    String text = "Your " + storage.getName().toLowerCase() + " ";
    if (regionName != null) {
      text += "in " + regionName + " ";
    }
    text += storage.getExpireText().toLowerCase();

    // Alternates between two colors, this could be customized by the user later
    Color textColor = client.getTickCount() % 2 == 0 ? Color.RED : Color.WHITE;
    graphics.setColor(textColor);

    FontMetrics metrics = graphics.getFontMetrics(font);

    int textWidth = metrics.stringWidth(text);
    int textHeight = metrics.getHeight();

    graphics.drawString(text, 0, textHeight);

    return new Dimension(textWidth, textHeight);
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import java.awt.Color;
import java.util.Random;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * DeathpileColorScheme is used to specify which color scheme should be used for deathpiles.
 */
@RequiredArgsConstructor
@Getter
public enum DeathpileColorScheme {
  FULL_COLOR("Full color", DeathpileColorSchemeType.FULL_COLOR),
  PASTEL("Pastel", DeathpileColorSchemeType.PASTEL),
  GRAYSCALE("Grayscale", DeathpileColorSchemeType.GRAYSCALE),
  REDSCALE("Redscale", DeathpileColorSchemeType.REDSCALE),
  GREENSCALE("Greenscale", DeathpileColorSchemeType.GREENSCALE),
  BLUESCALE("Bluescale", DeathpileColorSchemeType.BLUESCALE),
  MAGMA("Magma", DeathpileColorSchemeType.MAGMA),
  INFERNO("Inferno", DeathpileColorSchemeType.INFERNO),
  PLASMA("Plasma", DeathpileColorSchemeType.PLASMA),
  VIRIDIS("Viridis", DeathpileColorSchemeType.VIRIDIS),
  WHITE("White", DeathpileColorSchemeType.WHITE),
  YELLOW("Yellow", DeathpileColorSchemeType.YELLOW);

  private final String name;
  private final DeathpileColorSchemeType type;

  Color generateColor(Random random) {
    if (this.type == DeathpileColorSchemeType.MAGMA
        || this.type == DeathpileColorSchemeType.INFERNO
        || this.type == DeathpileColorSchemeType.PLASMA
        || this.type == DeathpileColorSchemeType.VIRIDIS) {
      random.nextFloat();
      return ColormapGetter.getColor(this.type, random.nextFloat());
    }

    if (this.type == DeathpileColorSchemeType.FULL_COLOR) {
      float saturation = 0.7f + random.nextFloat() * 0.3f;
      float hue = random.nextFloat();

      return Color.getHSBColor(hue, saturation, 0.8f);
    } else if (this.type == DeathpileColorSchemeType.PASTEL) {
      random.nextFloat();
      return Color.getHSBColor(random.nextFloat(), 0.5f, 0.8f);
    } else if (this.type == DeathpileColorSchemeType.GRAYSCALE) {
      random.nextFloat();
      return Color.getHSBColor(0, 0, random.nextFloat());
    } else if (this.type == DeathpileColorSchemeType.REDSCALE) {
      random.nextFloat();
      return Color.getHSBColor(0, 1, random.nextFloat());
    } else if (this.type == DeathpileColorSchemeType.GREENSCALE) {
      random.nextFloat();
      return Color.getHSBColor(0.333f, 1, random.nextFloat());
    } else if (this.type == DeathpileColorSchemeType.BLUESCALE) {
      random.nextFloat();
      return Color.getHSBColor(0.666f, 1, random.nextFloat());
    } else if (this.type == DeathpileColorSchemeType.YELLOW) {
      return Color.YELLOW;
    }

    return Color.WHITE;
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import java.awt.Color;

public class ColormapGetter {
  private static final Color[] magmaData = {
      new Color(0.001462f, 0.000466f, 0.013866f),
      new Color(0.002258f, 0.001295f, 0.018331f),
      new Color(0.003279f, 0.002305f, 0.023708f),
      new Color(0.004512f, 0.003490f, 0.029965f),
      new Color(0.005950f, 0.004843f, 0.037130f),
      new Color(0.007588f, 0.006356f, 0.044973f),
      new Color(0.009426f, 0.008022f, 0.052844f),
      new Color(0.011465f, 0.009828f, 0.060750f),
      new Color(0.013708f, 0.011771f, 0.068667f),
      new Color(0.016156f, 0.013840f, 0.076603f),
      new Color(0.018815f, 0.016026f, 0.084584f),
      new Color(0.021692f, 0.018320f, 0.092610f),
      new Color(0.024792f, 0.020715f, 0.100676f),
      new Color(0.028123f, 0.023201f, 0.108787f),
      new Color(0.031696f, 0.025765f, 0.116965f),
      new Color(0.035520f, 0.028397f, 0.125209f),
      new Color(0.039608f, 0.031090f, 0.133515f),
      new Color(0.043830f, 0.033830f, 0.141886f),
      new Color(0.048062f, 0.036607f, 0.150327f),
      new Color(0.052320f, 0.039407f, 0.158841f),
      new Color(0.056615f, 0.042160f, 0.167446f),
      new Color(0.060949f, 0.044794f, 0.176129f),
      new Color(0.065330f, 0.047318f, 0.184892f),
      new Color(0.069764f, 0.049726f, 0.193735f),
      new Color(0.074257f, 0.052017f, 0.202660f),
      new Color(0.078815f, 0.054184f, 0.211667f),
      new Color(0.083446f, 0.056225f, 0.220755f),
      new Color(0.088155f, 0.058133f, 0.229922f),
      new Color(0.092949f, 0.059904f, 0.239164f),
      new Color(0.097833f, 0.061531f, 0.248477f),
      new Color(0.102815f, 0.063010f, 0.257854f),
      new Color(0.107899f, 0.064335f, 0.267289f),
      new Color(0.113094f, 0.065492f, 0.276784f),
      new Color(0.118405f, 0.066479f, 0.286321f),
      new Color(0.123833f, 0.067295f, 0.295879f),
      new Color(0.129380f, 0.067935f, 0.305443f),
      new Color(0.135053f, 0.068391f, 0.315000f),
      new Color(0.140858f, 0.068654f, 0.324538f),
      new Color(0.146785f, 0.068738f, 0.334011f),
      new Color(0.152839f, 0.068637f, 0.343404f),
      new Color(0.159018f, 0.068354f, 0.352688f),
      new Color(0.165308f, 0.067911f, 0.361816f),
      new Color(0.171713f, 0.067305f, 0.370771f),
      new Color(0.178212f, 0.066576f, 0.379497f),
      new Color(0.184801f, 0.065732f, 0.387973f),
      new Color(0.191460f, 0.064818f, 0.396152f),
      new Color(0.198177f, 0.063862f, 0.404009f),
      new Color(0.204935f, 0.062907f, 0.411514f),
      new Color(0.211718f, 0.061992f, 0.418647f),
      new Color(0.218512f, 0.061158f, 0.425392f),
      new Color(0.225302f, 0.060445f, 0.431742f),
      new Color(0.232077f, 0.059889f, 0.437695f),
      new Color(0.238826f, 0.059517f, 0.443256f),
      new Color(0.245543f, 0.059352f, 0.448436f),
      new Color(0.252220f, 0.059415f, 0.453248f),
      new Color(0.258857f, 0.059706f, 0.457710f),
      new Color(0.265447f, 0.060237f, 0.461840f),
      new Color(0.271994f, 0.060994f, 0.465660f),
      new Color(0.278493f, 0.061978f, 0.469190f),
      new Color(0.284951f, 0.063168f, 0.472451f),
      new Color(0.291366f, 0.064553f, 0.475462f),
      new Color(0.297740f, 0.066117f, 0.478243f),
      new Color(0.304081f, 0.067835f, 0.480812f),
      new Color(0.310382f, 0.069702f, 0.483186f),
      new Color(0.316654f, 0.071690f, 0.485380f),
      new Color(0.322899f, 0.073782f, 0.487408f),
      new Color(0.329114f, 0.075972f, 0.489287f),
      new Color(0.335308f, 0.078236f, 0.491024f),
      new Color(0.341482f, 0.080564f, 0.492631f),
      new Color(0.347636f, 0.082946f, 0.494121f),
      new Color(0.353773f, 0.085373f, 0.495501f),
      new Color(0.359898f, 0.087831f, 0.496778f),
      new Color(0.366012f, 0.090314f, 0.497960f),
      new Color(0.372116f, 0.092816f, 0.499053f),
      new Color(0.378211f, 0.095332f, 0.500067f),
      new Color(0.384299f, 0.097855f, 0.501002f),
      new Color(0.390384f, 0.100379f, 0.501864f),
      new Color(0.396467f, 0.102902f, 0.502658f),
      new Color(0.402548f, 0.105420f, 0.503386f),
      new Color(0.408629f, 0.107930f, 0.504052f),
      new Color(0.414709f, 0.110431f, 0.504662f),
      new Color(0.420791f, 0.112920f, 0.505215f),
      new Color(0.426877f, 0.115395f, 0.505714f),
      new Color(0.432967f, 0.117855f, 0.506160f),
      new Color(0.439062f, 0.120298f, 0.506555f),
      new Color(0.445163f, 0.122724f, 0.506901f),
      new Color(0.451271f, 0.125132f, 0.507198f),
      new Color(0.457386f, 0.127522f, 0.507448f),
      new Color(0.463508f, 0.129893f, 0.507652f),
      new Color(0.469640f, 0.132245f, 0.507809f),
      new Color(0.475780f, 0.134577f, 0.507921f),
      new Color(0.481929f, 0.136891f, 0.507989f),
      new Color(0.488088f, 0.139186f, 0.508011f),
      new Color(0.494258f, 0.141462f, 0.507988f),
      new Color(0.500438f, 0.143719f, 0.507920f),
      new Color(0.506629f, 0.145958f, 0.507806f),
      new Color(0.512831f, 0.148179f, 0.507648f),
      new Color(0.519045f, 0.150383f, 0.507443f),
      new Color(0.525270f, 0.152569f, 0.507192f),
      new Color(0.531507f, 0.154739f, 0.506895f),
      new Color(0.537755f, 0.156894f, 0.506551f),
      new Color(0.544015f, 0.159033f, 0.506159f),
      new Color(0.550287f, 0.161158f, 0.505719f),
      new Color(0.556571f, 0.163269f, 0.505230f),
      new Color(0.562866f, 0.165368f, 0.504692f),
      new Color(0.569172f, 0.167454f, 0.504105f),
      new Color(0.575490f, 0.169530f, 0.503466f),
      new Color(0.581819f, 0.171596f, 0.502777f),
      new Color(0.588158f, 0.173652f, 0.502035f),
      new Color(0.594508f, 0.175701f, 0.501241f),
      new Color(0.600868f, 0.177743f, 0.500394f),
      new Color(0.607238f, 0.179779f, 0.499492f),
      new Color(0.613617f, 0.181811f, 0.498536f),
      new Color(0.620005f, 0.183840f, 0.497524f),
      new Color(0.626401f, 0.185867f, 0.496456f),
      new Color(0.632805f, 0.187893f, 0.495332f),
      new Color(0.639216f, 0.189921f, 0.494150f),
      new Color(0.645633f, 0.191952f, 0.492910f),
      new Color(0.652056f, 0.193986f, 0.491611f),
      new Color(0.658483f, 0.196027f, 0.490253f),
      new Color(0.664915f, 0.198075f, 0.488836f),
      new Color(0.671349f, 0.200133f, 0.487358f),
      new Color(0.677786f, 0.202203f, 0.485819f),
      new Color(0.684224f, 0.204286f, 0.484219f),
      new Color(0.690661f, 0.206384f, 0.482558f),
      new Color(0.697098f, 0.208501f, 0.480835f),
      new Color(0.703532f, 0.210638f, 0.479049f),
      new Color(0.709962f, 0.212797f, 0.477201f),
      new Color(0.716387f, 0.214982f, 0.475290f),
      new Color(0.722805f, 0.217194f, 0.473316f),
      new Color(0.729216f, 0.219437f, 0.471279f),
      new Color(0.735616f, 0.221713f, 0.469180f),
      new Color(0.742004f, 0.224025f, 0.467018f),
      new Color(0.748378f, 0.226377f, 0.464794f),
      new Color(0.754737f, 0.228772f, 0.462509f),
      new Color(0.761077f, 0.231214f, 0.460162f),
      new Color(0.767398f, 0.233705f, 0.457755f),
      new Color(0.773695f, 0.236249f, 0.455289f),
      new Color(0.779968f, 0.238851f, 0.452765f),
      new Color(0.786212f, 0.241514f, 0.450184f),
      new Color(0.792427f, 0.244242f, 0.447543f),
      new Color(0.798608f, 0.247040f, 0.444848f),
      new Color(0.804752f, 0.249911f, 0.442102f),
      new Color(0.810855f, 0.252861f, 0.439305f),
      new Color(0.816914f, 0.255895f, 0.436461f),
      new Color(0.822926f, 0.259016f, 0.433573f),
      new Color(0.828886f, 0.262229f, 0.430644f),
      new Color(0.834791f, 0.265540f, 0.427671f),
      new Color(0.840636f, 0.268953f, 0.424666f),
      new Color(0.846416f, 0.272473f, 0.421631f),
      new Color(0.852126f, 0.276106f, 0.418573f),
      new Color(0.857763f, 0.279857f, 0.415496f),
      new Color(0.863320f, 0.283729f, 0.412403f),
      new Color(0.868793f, 0.287728f, 0.409303f),
      new Color(0.874176f, 0.291859f, 0.406205f),
      new Color(0.879464f, 0.296125f, 0.403118f),
      new Color(0.884651f, 0.300530f, 0.400047f),
      new Color(0.889731f, 0.305079f, 0.397002f),
      new Color(0.894700f, 0.309773f, 0.393995f),
      new Color(0.899552f, 0.314616f, 0.391037f),
      new Color(0.904281f, 0.319610f, 0.388137f),
      new Color(0.908884f, 0.324755f, 0.385308f),
      new Color(0.913354f, 0.330052f, 0.382563f),
      new Color(0.917689f, 0.335500f, 0.379915f),
      new Color(0.921884f, 0.341098f, 0.377376f),
      new Color(0.925937f, 0.346844f, 0.374959f),
      new Color(0.929845f, 0.352734f, 0.372677f),
      new Color(0.933606f, 0.358764f, 0.370541f),
      new Color(0.937221f, 0.364929f, 0.368567f),
      new Color(0.940687f, 0.371224f, 0.366762f),
      new Color(0.944006f, 0.377643f, 0.365136f),
      new Color(0.947180f, 0.384178f, 0.363701f),
      new Color(0.950210f, 0.390820f, 0.362468f),
      new Color(0.953099f, 0.397563f, 0.361438f),
      new Color(0.955849f, 0.404400f, 0.360619f),
      new Color(0.958464f, 0.411324f, 0.360014f),
      new Color(0.960949f, 0.418323f, 0.359630f),
      new Color(0.963310f, 0.425390f, 0.359469f),
      new Color(0.965549f, 0.432519f, 0.359529f),
      new Color(0.967671f, 0.439703f, 0.359810f),
      new Color(0.969680f, 0.446936f, 0.360311f),
      new Color(0.971582f, 0.454210f, 0.361030f),
      new Color(0.973381f, 0.461520f, 0.361965f),
      new Color(0.975082f, 0.468861f, 0.363111f),
      new Color(0.976690f, 0.476226f, 0.364466f),
      new Color(0.978210f, 0.483612f, 0.366025f),
      new Color(0.979645f, 0.491014f, 0.367783f),
      new Color(0.981000f, 0.498428f, 0.369734f),
      new Color(0.982279f, 0.505851f, 0.371874f),
      new Color(0.983485f, 0.513280f, 0.374198f),
      new Color(0.984622f, 0.520713f, 0.376698f),
      new Color(0.985693f, 0.528148f, 0.379371f),
      new Color(0.986700f, 0.535582f, 0.382210f),
      new Color(0.987646f, 0.543015f, 0.385210f),
      new Color(0.988533f, 0.550446f, 0.388365f),
      new Color(0.989363f, 0.557873f, 0.391671f),
      new Color(0.990138f, 0.565296f, 0.395122f),
      new Color(0.990871f, 0.572706f, 0.398714f),
      new Color(0.991558f, 0.580107f, 0.402441f),
      new Color(0.992196f, 0.587502f, 0.406299f),
      new Color(0.992785f, 0.594891f, 0.410283f),
      new Color(0.993326f, 0.602275f, 0.414390f),
      new Color(0.993834f, 0.609644f, 0.418613f),
      new Color(0.994309f, 0.616999f, 0.422950f),
      new Color(0.994738f, 0.624350f, 0.427397f),
      new Color(0.995122f, 0.631696f, 0.431951f),
      new Color(0.995480f, 0.639027f, 0.436607f),
      new Color(0.995810f, 0.646344f, 0.441361f),
      new Color(0.996096f, 0.653659f, 0.446213f),
      new Color(0.996341f, 0.660969f, 0.451160f),
      new Color(0.996580f, 0.668256f, 0.456192f),
      new Color(0.996775f, 0.675541f, 0.461314f),
      new Color(0.996925f, 0.682828f, 0.466526f),
      new Color(0.997077f, 0.690088f, 0.471811f),
      new Color(0.997186f, 0.697349f, 0.477182f),
      new Color(0.997254f, 0.704611f, 0.482635f),
      new Color(0.997325f, 0.711848f, 0.488154f),
      new Color(0.997351f, 0.719089f, 0.493755f),
      new Color(0.997351f, 0.726324f, 0.499428f),
      new Color(0.997341f, 0.733545f, 0.505167f),
      new Color(0.997285f, 0.740772f, 0.510983f),
      new Color(0.997228f, 0.747981f, 0.516859f),
      new Color(0.997138f, 0.755190f, 0.522806f),
      new Color(0.997019f, 0.762398f, 0.528821f),
      new Color(0.996898f, 0.769591f, 0.534892f),
      new Color(0.996727f, 0.776795f, 0.541039f),
      new Color(0.996571f, 0.783977f, 0.547233f),
      new Color(0.996369f, 0.791167f, 0.553499f),
      new Color(0.996162f, 0.798348f, 0.559820f),
      new Color(0.995932f, 0.805527f, 0.566202f),
      new Color(0.995680f, 0.812706f, 0.572645f),
      new Color(0.995424f, 0.819875f, 0.579140f),
      new Color(0.995131f, 0.827052f, 0.585701f),
      new Color(0.994851f, 0.834213f, 0.592307f),
      new Color(0.994524f, 0.841387f, 0.598983f),
      new Color(0.994222f, 0.848540f, 0.605696f),
      new Color(0.993866f, 0.855711f, 0.612482f),
      new Color(0.993545f, 0.862859f, 0.619299f),
      new Color(0.993170f, 0.870024f, 0.626189f),
      new Color(0.992831f, 0.877168f, 0.633109f),
      new Color(0.992440f, 0.884330f, 0.640099f),
      new Color(0.992089f, 0.891470f, 0.647116f),
      new Color(0.991688f, 0.898627f, 0.654202f),
      new Color(0.991332f, 0.905763f, 0.661309f),
      new Color(0.990930f, 0.912915f, 0.668481f),
      new Color(0.990570f, 0.920049f, 0.675675f),
      new Color(0.990175f, 0.927196f, 0.682926f),
      new Color(0.989815f, 0.934329f, 0.690198f),
      new Color(0.989434f, 0.941470f, 0.697519f),
      new Color(0.989077f, 0.948604f, 0.704863f),
      new Color(0.988717f, 0.955742f, 0.712242f),
      new Color(0.988367f, 0.962878f, 0.719649f),
      new Color(0.988033f, 0.970012f, 0.727077f),
      new Color(0.987691f, 0.977154f, 0.734536f),
      new Color(0.987387f, 0.984288f, 0.742002f),
      new Color(0.987053f, 0.991438f, 0.749504f)
  };

  private static final Color[] infernoData = {
      new Color(0.001462f, 0.000466f, 0.013866f),
      new Color(0.002267f, 0.001270f, 0.018570f),
      new Color(0.003299f, 0.002249f, 0.024239f),
      new Color(0.004547f, 0.003392f, 0.030909f),
      new Color(0.006006f, 0.004692f, 0.038558f),
      new Color(0.007676f, 0.006136f, 0.046836f),
      new Color(0.009561f, 0.007713f, 0.055143f),
      new Color(0.011663f, 0.009417f, 0.063460f),
      new Color(0.013995f, 0.011225f, 0.071862f),
      new Color(0.016561f, 0.013136f, 0.080282f),
      new Color(0.019373f, 0.015133f, 0.088767f),
      new Color(0.022447f, 0.017199f, 0.097327f),
      new Color(0.025793f, 0.019331f, 0.105930f),
      new Color(0.029432f, 0.021503f, 0.114621f),
      new Color(0.033385f, 0.023702f, 0.123397f),
      new Color(0.037668f, 0.025921f, 0.132232f),
      new Color(0.042253f, 0.028139f, 0.141141f),
      new Color(0.046915f, 0.030324f, 0.150164f),
      new Color(0.051644f, 0.032474f, 0.159254f),
      new Color(0.056449f, 0.034569f, 0.168414f),
      new Color(0.061340f, 0.036590f, 0.177642f),
      new Color(0.066331f, 0.038504f, 0.186962f),
      new Color(0.071429f, 0.040294f, 0.196354f),
      new Color(0.076637f, 0.041905f, 0.205799f),
      new Color(0.081962f, 0.043328f, 0.215289f),
      new Color(0.087411f, 0.044556f, 0.224813f),
      new Color(0.092990f, 0.045583f, 0.234358f),
      new Color(0.098702f, 0.046402f, 0.243904f),
      new Color(0.104551f, 0.047008f, 0.253430f),
      new Color(0.110536f, 0.047399f, 0.262912f),
      new Color(0.116656f, 0.047574f, 0.272321f),
      new Color(0.122908f, 0.047536f, 0.281624f),
      new Color(0.129285f, 0.047293f, 0.290788f),
      new Color(0.135778f, 0.046856f, 0.299776f),
      new Color(0.142378f, 0.046242f, 0.308553f),
      new Color(0.149073f, 0.045468f, 0.317085f),
      new Color(0.155850f, 0.044559f, 0.325338f),
      new Color(0.162689f, 0.043554f, 0.333277f),
      new Color(0.169575f, 0.042489f, 0.340874f),
      new Color(0.176493f, 0.041402f, 0.348111f),
      new Color(0.183429f, 0.040329f, 0.354971f),
      new Color(0.190367f, 0.039309f, 0.361447f),
      new Color(0.197297f, 0.038400f, 0.367535f),
      new Color(0.204209f, 0.037632f, 0.373238f),
      new Color(0.211095f, 0.037030f, 0.378563f),
      new Color(0.217949f, 0.036615f, 0.383522f),
      new Color(0.224763f, 0.036405f, 0.388129f),
      new Color(0.231538f, 0.036405f, 0.392400f),
      new Color(0.238273f, 0.036621f, 0.396353f),
      new Color(0.244967f, 0.037055f, 0.400007f),
      new Color(0.251620f, 0.037705f, 0.403378f),
      new Color(0.258234f, 0.038571f, 0.406485f),
      new Color(0.264810f, 0.039647f, 0.409345f),
      new Color(0.271347f, 0.040922f, 0.411976f),
      new Color(0.277850f, 0.042353f, 0.414392f),
      new Color(0.284321f, 0.043933f, 0.416608f),
      new Color(0.290763f, 0.045644f, 0.418637f),
      new Color(0.297178f, 0.047470f, 0.420491f),
      new Color(0.303568f, 0.049396f, 0.422182f),
      new Color(0.309935f, 0.051407f, 0.423721f),
      new Color(0.316282f, 0.053490f, 0.425116f),
      new Color(0.322610f, 0.055634f, 0.426377f),
      new Color(0.328921f, 0.057827f, 0.427511f),
      new Color(0.335217f, 0.060060f, 0.428524f),
      new Color(0.341500f, 0.062325f, 0.429425f),
      new Color(0.347771f, 0.064616f, 0.430217f),
      new Color(0.354032f, 0.066925f, 0.430906f),
      new Color(0.360284f, 0.069247f, 0.431497f),
      new Color(0.366529f, 0.071579f, 0.431994f),
      new Color(0.372768f, 0.073915f, 0.432400f),
      new Color(0.379001f, 0.076253f, 0.432719f),
      new Color(0.385228f, 0.078591f, 0.432955f),
      new Color(0.391453f, 0.080927f, 0.433109f),
      new Color(0.397674f, 0.083257f, 0.433183f),
      new Color(0.403894f, 0.085580f, 0.433179f),
      new Color(0.410113f, 0.087896f, 0.433098f),
      new Color(0.416331f, 0.090203f, 0.432943f),
      new Color(0.422549f, 0.092501f, 0.432714f),
      new Color(0.428768f, 0.094790f, 0.432412f),
      new Color(0.434987f, 0.097069f, 0.432039f),
      new Color(0.441207f, 0.099338f, 0.431594f),
      new Color(0.447428f, 0.101597f, 0.431080f),
      new Color(0.453651f, 0.103848f, 0.430498f),
      new Color(0.459875f, 0.106089f, 0.429846f),
      new Color(0.466100f, 0.108322f, 0.429125f),
      new Color(0.472328f, 0.110547f, 0.428334f),
      new Color(0.478558f, 0.112764f, 0.427475f),
      new Color(0.484789f, 0.114974f, 0.426548f),
      new Color(0.491022f, 0.117179f, 0.425552f),
      new Color(0.497257f, 0.119379f, 0.424488f),
      new Color(0.503493f, 0.121575f, 0.423356f),
      new Color(0.509730f, 0.123769f, 0.422156f),
      new Color(0.515967f, 0.125960f, 0.420887f),
      new Color(0.522206f, 0.128150f, 0.419549f),
      new Color(0.528444f, 0.130341f, 0.418142f),
      new Color(0.534683f, 0.132534f, 0.416667f),
      new Color(0.540920f, 0.134729f, 0.415123f),
      new Color(0.547157f, 0.136929f, 0.413511f),
      new Color(0.553392f, 0.139134f, 0.411829f),
      new Color(0.559624f, 0.141346f, 0.410078f),
      new Color(0.565854f, 0.143567f, 0.408258f),
      new Color(0.572081f, 0.145797f, 0.406369f),
      new Color(0.578304f, 0.148039f, 0.404411f),
      new Color(0.584521f, 0.150294f, 0.402385f),
      new Color(0.590734f, 0.152563f, 0.400290f),
      new Color(0.596940f, 0.154848f, 0.398125f),
      new Color(0.603139f, 0.157151f, 0.395891f),
      new Color(0.609330f, 0.159474f, 0.393589f),
      new Color(0.615513f, 0.161817f, 0.391219f),
      new Color(0.621685f, 0.164184f, 0.388781f),
      new Color(0.627847f, 0.166575f, 0.386276f),
      new Color(0.633998f, 0.168992f, 0.383704f),
      new Color(0.640135f, 0.171438f, 0.381065f),
      new Color(0.646260f, 0.173914f, 0.378359f),
      new Color(0.652369f, 0.176421f, 0.375586f),
      new Color(0.658463f, 0.178962f, 0.372748f),
      new Color(0.664540f, 0.181539f, 0.369846f),
      new Color(0.670599f, 0.184153f, 0.366879f),
      new Color(0.676638f, 0.186807f, 0.363849f),
      new Color(0.682656f, 0.189501f, 0.360757f),
      new Color(0.688653f, 0.192239f, 0.357603f),
      new Color(0.694627f, 0.195021f, 0.354388f),
      new Color(0.700576f, 0.197851f, 0.351113f),
      new Color(0.706500f, 0.200728f, 0.347777f),
      new Color(0.712396f, 0.203656f, 0.344383f),
      new Color(0.718264f, 0.206636f, 0.340931f),
      new Color(0.724103f, 0.209670f, 0.337424f),
      new Color(0.729909f, 0.212759f, 0.333861f),
      new Color(0.735683f, 0.215906f, 0.330245f),
      new Color(0.741423f, 0.219112f, 0.326576f),
      new Color(0.747127f, 0.222378f, 0.322856f),
      new Color(0.752794f, 0.225706f, 0.319085f),
      new Color(0.758422f, 0.229097f, 0.315266f),
      new Color(0.764010f, 0.232554f, 0.311399f),
      new Color(0.769556f, 0.236077f, 0.307485f),
      new Color(0.775059f, 0.239667f, 0.303526f),
      new Color(0.780517f, 0.243327f, 0.299523f),
      new Color(0.785929f, 0.247056f, 0.295477f),
      new Color(0.791293f, 0.250856f, 0.291390f),
      new Color(0.796607f, 0.254728f, 0.287264f),
      new Color(0.801871f, 0.258674f, 0.283099f),
      new Color(0.807082f, 0.262692f, 0.278898f),
      new Color(0.812239f, 0.266786f, 0.274661f),
      new Color(0.817341f, 0.270954f, 0.270390f),
      new Color(0.822386f, 0.275197f, 0.266085f),
      new Color(0.827372f, 0.279517f, 0.261750f),
      new Color(0.832299f, 0.283913f, 0.257383f),
      new Color(0.837165f, 0.288385f, 0.252988f),
      new Color(0.841969f, 0.292933f, 0.248564f),
      new Color(0.846709f, 0.297559f, 0.244113f),
      new Color(0.851384f, 0.302260f, 0.239636f),
      new Color(0.855992f, 0.307038f, 0.235133f),
      new Color(0.860533f, 0.311892f, 0.230606f),
      new Color(0.865006f, 0.316822f, 0.226055f),
      new Color(0.869409f, 0.321827f, 0.221482f),
      new Color(0.873741f, 0.326906f, 0.216886f),
      new Color(0.878001f, 0.332060f, 0.212268f),
      new Color(0.882188f, 0.337287f, 0.207628f),
      new Color(0.886302f, 0.342586f, 0.202968f),
      new Color(0.890341f, 0.347957f, 0.198286f),
      new Color(0.894305f, 0.353399f, 0.193584f),
      new Color(0.898192f, 0.358911f, 0.188860f),
      new Color(0.902003f, 0.364492f, 0.184116f),
      new Color(0.905735f, 0.370140f, 0.179350f),
      new Color(0.909390f, 0.375856f, 0.174563f),
      new Color(0.912966f, 0.381636f, 0.169755f),
      new Color(0.916462f, 0.387481f, 0.164924f),
      new Color(0.919879f, 0.393389f, 0.160070f),
      new Color(0.923215f, 0.399359f, 0.155193f),
      new Color(0.926470f, 0.405389f, 0.150292f),
      new Color(0.929644f, 0.411479f, 0.145367f),
      new Color(0.932737f, 0.417627f, 0.140417f),
      new Color(0.935747f, 0.423831f, 0.135440f),
      new Color(0.938675f, 0.430091f, 0.130438f),
      new Color(0.941521f, 0.436405f, 0.125409f),
      new Color(0.944285f, 0.442772f, 0.120354f),
      new Color(0.946965f, 0.449191f, 0.115272f),
      new Color(0.949562f, 0.455660f, 0.110164f),
      new Color(0.952075f, 0.462178f, 0.105031f),
      new Color(0.954506f, 0.468744f, 0.099874f),
      new Color(0.956852f, 0.475356f, 0.094695f),
      new Color(0.959114f, 0.482014f, 0.089499f),
      new Color(0.961293f, 0.488716f, 0.084289f),
      new Color(0.963387f, 0.495462f, 0.079073f),
      new Color(0.965397f, 0.502249f, 0.073859f),
      new Color(0.967322f, 0.509078f, 0.068659f),
      new Color(0.969163f, 0.515946f, 0.063488f),
      new Color(0.970919f, 0.522853f, 0.058367f),
      new Color(0.972590f, 0.529798f, 0.053324f),
      new Color(0.974176f, 0.536780f, 0.048392f),
      new Color(0.975677f, 0.543798f, 0.043618f),
      new Color(0.977092f, 0.550850f, 0.039050f),
      new Color(0.978422f, 0.557937f, 0.034931f),
      new Color(0.979666f, 0.565057f, 0.031409f),
      new Color(0.980824f, 0.572209f, 0.028508f),
      new Color(0.981895f, 0.579392f, 0.026250f),
      new Color(0.982881f, 0.586606f, 0.024661f),
      new Color(0.983779f, 0.593849f, 0.023770f),
      new Color(0.984591f, 0.601122f, 0.023606f),
      new Color(0.985315f, 0.608422f, 0.024202f),
      new Color(0.985952f, 0.615750f, 0.025592f),
      new Color(0.986502f, 0.623105f, 0.027814f),
      new Color(0.986964f, 0.630485f, 0.030908f),
      new Color(0.987337f, 0.637890f, 0.034916f),
      new Color(0.987622f, 0.645320f, 0.039886f),
      new Color(0.987819f, 0.652773f, 0.045581f),
      new Color(0.987926f, 0.660250f, 0.051750f),
      new Color(0.987945f, 0.667748f, 0.058329f),
      new Color(0.987874f, 0.675267f, 0.065257f),
      new Color(0.987714f, 0.682807f, 0.072489f),
      new Color(0.987464f, 0.690366f, 0.079990f),
      new Color(0.987124f, 0.697944f, 0.087731f),
      new Color(0.986694f, 0.705540f, 0.095694f),
      new Color(0.986175f, 0.713153f, 0.103863f),
      new Color(0.985566f, 0.720782f, 0.112229f),
      new Color(0.984865f, 0.728427f, 0.120785f),
      new Color(0.984075f, 0.736087f, 0.129527f),
      new Color(0.983196f, 0.743758f, 0.138453f),
      new Color(0.982228f, 0.751442f, 0.147565f),
      new Color(0.981173f, 0.759135f, 0.156863f),
      new Color(0.980032f, 0.766837f, 0.166353f),
      new Color(0.978806f, 0.774545f, 0.176037f),
      new Color(0.977497f, 0.782258f, 0.185923f),
      new Color(0.976108f, 0.789974f, 0.196018f),
      new Color(0.974638f, 0.797692f, 0.206332f),
      new Color(0.973088f, 0.805409f, 0.216877f),
      new Color(0.971468f, 0.813122f, 0.227658f),
      new Color(0.969783f, 0.820825f, 0.238686f),
      new Color(0.968041f, 0.828515f, 0.249972f),
      new Color(0.966243f, 0.836191f, 0.261534f),
      new Color(0.964394f, 0.843848f, 0.273391f),
      new Color(0.962517f, 0.851476f, 0.285546f),
      new Color(0.960626f, 0.859069f, 0.298010f),
      new Color(0.958720f, 0.866624f, 0.310820f),
      new Color(0.956834f, 0.874129f, 0.323974f),
      new Color(0.954997f, 0.881569f, 0.337475f),
      new Color(0.953215f, 0.888942f, 0.351369f),
      new Color(0.951546f, 0.896226f, 0.365627f),
      new Color(0.950018f, 0.903409f, 0.380271f),
      new Color(0.948683f, 0.910473f, 0.395289f),
      new Color(0.947594f, 0.917399f, 0.410665f),
      new Color(0.946809f, 0.924168f, 0.426373f),
      new Color(0.946392f, 0.930761f, 0.442367f),
      new Color(0.946403f, 0.937159f, 0.458592f),
      new Color(0.946903f, 0.943348f, 0.474970f),
      new Color(0.947937f, 0.949318f, 0.491426f),
      new Color(0.949545f, 0.955063f, 0.507860f),
      new Color(0.951740f, 0.960587f, 0.524203f),
      new Color(0.954529f, 0.965896f, 0.540361f),
      new Color(0.957896f, 0.971003f, 0.556275f),
      new Color(0.961812f, 0.975924f, 0.571925f),
      new Color(0.966249f, 0.980678f, 0.587206f),
      new Color(0.971162f, 0.985282f, 0.602154f),
      new Color(0.976511f, 0.989753f, 0.616760f),
      new Color(0.982257f, 0.994109f, 0.631017f),
      new Color(0.988362f, 0.998364f, 0.644924f)
  };

  private static final Color[] plasmaData = {
      new Color(0.050383f, 0.029803f, 0.527975f),
      new Color(0.063536f, 0.028426f, 0.533124f),
      new Color(0.075353f, 0.027206f, 0.538007f),
      new Color(0.086222f, 0.026125f, 0.542658f),
      new Color(0.096379f, 0.025165f, 0.547103f),
      new Color(0.105980f, 0.024309f, 0.551368f),
      new Color(0.115124f, 0.023556f, 0.555468f),
      new Color(0.123903f, 0.022878f, 0.559423f),
      new Color(0.132381f, 0.022258f, 0.563250f),
      new Color(0.140603f, 0.021687f, 0.566959f),
      new Color(0.148607f, 0.021154f, 0.570562f),
      new Color(0.156421f, 0.020651f, 0.574065f),
      new Color(0.164070f, 0.020171f, 0.577478f),
      new Color(0.171574f, 0.019706f, 0.580806f),
      new Color(0.178950f, 0.019252f, 0.584054f),
      new Color(0.186213f, 0.018803f, 0.587228f),
      new Color(0.193374f, 0.018354f, 0.590330f),
      new Color(0.200445f, 0.017902f, 0.593364f),
      new Color(0.207435f, 0.017442f, 0.596333f),
      new Color(0.214350f, 0.016973f, 0.599239f),
      new Color(0.221197f, 0.016497f, 0.602083f),
      new Color(0.227983f, 0.016007f, 0.604867f),
      new Color(0.234715f, 0.015502f, 0.607592f),
      new Color(0.241396f, 0.014979f, 0.610259f),
      new Color(0.248032f, 0.014439f, 0.612868f),
      new Color(0.254627f, 0.013882f, 0.615419f),
      new Color(0.261183f, 0.013308f, 0.617911f),
      new Color(0.267703f, 0.012716f, 0.620346f),
      new Color(0.274191f, 0.012109f, 0.622722f),
      new Color(0.280648f, 0.011488f, 0.625038f),
      new Color(0.287076f, 0.010855f, 0.627295f),
      new Color(0.293478f, 0.010213f, 0.629490f),
      new Color(0.299855f, 0.009561f, 0.631624f),
      new Color(0.306210f, 0.008902f, 0.633694f),
      new Color(0.312543f, 0.008239f, 0.635700f),
      new Color(0.318856f, 0.007576f, 0.637640f),
      new Color(0.325150f, 0.006915f, 0.639512f),
      new Color(0.331426f, 0.006261f, 0.641316f),
      new Color(0.337683f, 0.005618f, 0.643049f),
      new Color(0.343925f, 0.004991f, 0.644710f),
      new Color(0.350150f, 0.004382f, 0.646298f),
      new Color(0.356359f, 0.003798f, 0.647810f),
      new Color(0.362553f, 0.003243f, 0.649245f),
      new Color(0.368733f, 0.002724f, 0.650601f),
      new Color(0.374897f, 0.002245f, 0.651876f),
      new Color(0.381047f, 0.001814f, 0.653068f),
      new Color(0.387183f, 0.001434f, 0.654177f),
      new Color(0.393304f, 0.001114f, 0.655199f),
      new Color(0.399411f, 0.000859f, 0.656133f),
      new Color(0.405503f, 0.000678f, 0.656977f),
      new Color(0.411580f, 0.000577f, 0.657730f),
      new Color(0.417642f, 0.000564f, 0.658390f),
      new Color(0.423689f, 0.000646f, 0.658956f),
      new Color(0.429719f, 0.000831f, 0.659425f),
      new Color(0.435734f, 0.001127f, 0.659797f),
      new Color(0.441732f, 0.001540f, 0.660069f),
      new Color(0.447714f, 0.002080f, 0.660240f),
      new Color(0.453677f, 0.002755f, 0.660310f),
      new Color(0.459623f, 0.003574f, 0.660277f),
      new Color(0.465550f, 0.004545f, 0.660139f),
      new Color(0.471457f, 0.005678f, 0.659897f),
      new Color(0.477344f, 0.006980f, 0.659549f),
      new Color(0.483210f, 0.008460f, 0.659095f),
      new Color(0.489055f, 0.010127f, 0.658534f),
      new Color(0.494877f, 0.011990f, 0.657865f),
      new Color(0.500678f, 0.014055f, 0.657088f),
      new Color(0.506454f, 0.016333f, 0.656202f),
      new Color(0.512206f, 0.018833f, 0.655209f),
      new Color(0.517933f, 0.021563f, 0.654109f),
      new Color(0.523633f, 0.024532f, 0.652901f),
      new Color(0.529306f, 0.027747f, 0.651586f),
      new Color(0.534952f, 0.031217f, 0.650165f),
      new Color(0.540570f, 0.034950f, 0.648640f),
      new Color(0.546157f, 0.038954f, 0.647010f),
      new Color(0.551715f, 0.043136f, 0.645277f),
      new Color(0.557243f, 0.047331f, 0.643443f),
      new Color(0.562738f, 0.051545f, 0.641509f),
      new Color(0.568201f, 0.055778f, 0.639477f),
      new Color(0.573632f, 0.060028f, 0.637349f),
      new Color(0.579029f, 0.064296f, 0.635126f),
      new Color(0.584391f, 0.068579f, 0.632812f),
      new Color(0.589719f, 0.072878f, 0.630408f),
      new Color(0.595011f, 0.077190f, 0.627917f),
      new Color(0.600266f, 0.081516f, 0.625342f),
      new Color(0.605485f, 0.085854f, 0.622686f),
      new Color(0.610667f, 0.090204f, 0.619951f),
      new Color(0.615812f, 0.094564f, 0.617140f),
      new Color(0.620919f, 0.098934f, 0.614257f),
      new Color(0.625987f, 0.103312f, 0.611305f),
      new Color(0.631017f, 0.107699f, 0.608287f),
      new Color(0.636008f, 0.112092f, 0.605205f),
      new Color(0.640959f, 0.116492f, 0.602065f),
      new Color(0.645872f, 0.120898f, 0.598867f),
      new Color(0.650746f, 0.125309f, 0.595617f),
      new Color(0.655580f, 0.129725f, 0.592317f),
      new Color(0.660374f, 0.134144f, 0.588971f),
      new Color(0.665129f, 0.138566f, 0.585582f),
      new Color(0.669845f, 0.142992f, 0.582154f),
      new Color(0.674522f, 0.147419f, 0.578688f),
      new Color(0.679160f, 0.151848f, 0.575189f),
      new Color(0.683758f, 0.156278f, 0.571660f),
      new Color(0.688318f, 0.160709f, 0.568103f),
      new Color(0.692840f, 0.165141f, 0.564522f),
      new Color(0.697324f, 0.169573f, 0.560919f),
      new Color(0.701769f, 0.174005f, 0.557296f),
      new Color(0.706178f, 0.178437f, 0.553657f),
      new Color(0.710549f, 0.182868f, 0.550004f),
      new Color(0.714883f, 0.187299f, 0.546338f),
      new Color(0.719181f, 0.191729f, 0.542663f),
      new Color(0.723444f, 0.196158f, 0.538981f),
      new Color(0.727670f, 0.200586f, 0.535293f),
      new Color(0.731862f, 0.205013f, 0.531601f),
      new Color(0.736019f, 0.209439f, 0.527908f),
      new Color(0.740143f, 0.213864f, 0.524216f),
      new Color(0.744232f, 0.218288f, 0.520524f),
      new Color(0.748289f, 0.222711f, 0.516834f),
      new Color(0.752312f, 0.227133f, 0.513149f),
      new Color(0.756304f, 0.231555f, 0.509468f),
      new Color(0.760264f, 0.235976f, 0.505794f),
      new Color(0.764193f, 0.240396f, 0.502126f),
      new Color(0.768090f, 0.244817f, 0.498465f),
      new Color(0.771958f, 0.249237f, 0.494813f),
      new Color(0.775796f, 0.253658f, 0.491171f),
      new Color(0.779604f, 0.258078f, 0.487539f),
      new Color(0.783383f, 0.262500f, 0.483918f),
      new Color(0.787133f, 0.266922f, 0.480307f),
      new Color(0.790855f, 0.271345f, 0.476706f),
      new Color(0.794549f, 0.275770f, 0.473117f),
      new Color(0.798216f, 0.280197f, 0.469538f),
      new Color(0.801855f, 0.284626f, 0.465971f),
      new Color(0.805467f, 0.289057f, 0.462415f),
      new Color(0.809052f, 0.293491f, 0.458870f),
      new Color(0.812612f, 0.297928f, 0.455338f),
      new Color(0.816144f, 0.302368f, 0.451816f),
      new Color(0.819651f, 0.306812f, 0.448306f),
      new Color(0.823132f, 0.311261f, 0.444806f),
      new Color(0.826588f, 0.315714f, 0.441316f),
      new Color(0.830018f, 0.320172f, 0.437836f),
      new Color(0.833422f, 0.324635f, 0.434366f),
      new Color(0.836801f, 0.329105f, 0.430905f),
      new Color(0.840155f, 0.333580f, 0.427455f),
      new Color(0.843484f, 0.338062f, 0.424013f),
      new Color(0.846788f, 0.342551f, 0.420579f),
      new Color(0.850066f, 0.347048f, 0.417153f),
      new Color(0.853319f, 0.351553f, 0.413734f),
      new Color(0.856547f, 0.356066f, 0.410322f),
      new Color(0.859750f, 0.360588f, 0.406917f),
      new Color(0.862927f, 0.365119f, 0.403519f),
      new Color(0.866078f, 0.369660f, 0.400126f),
      new Color(0.869203f, 0.374212f, 0.396738f),
      new Color(0.872303f, 0.378774f, 0.393355f),
      new Color(0.875376f, 0.383347f, 0.389976f),
      new Color(0.878423f, 0.387932f, 0.386600f),
      new Color(0.881443f, 0.392529f, 0.383229f),
      new Color(0.884436f, 0.397139f, 0.379860f),
      new Color(0.887402f, 0.401762f, 0.376494f),
      new Color(0.890340f, 0.406398f, 0.373130f),
      new Color(0.893250f, 0.411048f, 0.369768f),
      new Color(0.896131f, 0.415712f, 0.366407f),
      new Color(0.898984f, 0.420392f, 0.363047f),
      new Color(0.901807f, 0.425087f, 0.359688f),
      new Color(0.904601f, 0.429797f, 0.356329f),
      new Color(0.907365f, 0.434524f, 0.352970f),
      new Color(0.910098f, 0.439268f, 0.349610f),
      new Color(0.912800f, 0.444029f, 0.346251f),
      new Color(0.915471f, 0.448807f, 0.342890f),
      new Color(0.918109f, 0.453603f, 0.339529f),
      new Color(0.920714f, 0.458417f, 0.336166f),
      new Color(0.923287f, 0.463251f, 0.332801f),
      new Color(0.925825f, 0.468103f, 0.329435f),
      new Color(0.928329f, 0.472975f, 0.326067f),
      new Color(0.930798f, 0.477867f, 0.322697f),
      new Color(0.933232f, 0.482780f, 0.319325f),
      new Color(0.935630f, 0.487712f, 0.315952f),
      new Color(0.937990f, 0.492667f, 0.312575f),
      new Color(0.940313f, 0.497642f, 0.309197f),
      new Color(0.942598f, 0.502639f, 0.305816f),
      new Color(0.944844f, 0.507658f, 0.302433f),
      new Color(0.947051f, 0.512699f, 0.299049f),
      new Color(0.949217f, 0.517763f, 0.295662f),
      new Color(0.951344f, 0.522850f, 0.292275f),
      new Color(0.953428f, 0.527960f, 0.288883f),
      new Color(0.955470f, 0.533093f, 0.285490f),
      new Color(0.957469f, 0.538250f, 0.282096f),
      new Color(0.959424f, 0.543431f, 0.278701f),
      new Color(0.961336f, 0.548636f, 0.275305f),
      new Color(0.963203f, 0.553865f, 0.271909f),
      new Color(0.965024f, 0.559118f, 0.268513f),
      new Color(0.966798f, 0.564396f, 0.265118f),
      new Color(0.968526f, 0.569700f, 0.261721f),
      new Color(0.970205f, 0.575028f, 0.258325f),
      new Color(0.971835f, 0.580382f, 0.254931f),
      new Color(0.973416f, 0.585761f, 0.251540f),
      new Color(0.974947f, 0.591165f, 0.248151f),
      new Color(0.976428f, 0.596595f, 0.244767f),
      new Color(0.977856f, 0.602051f, 0.241387f),
      new Color(0.979233f, 0.607532f, 0.238013f),
      new Color(0.980556f, 0.613039f, 0.234646f),
      new Color(0.981826f, 0.618572f, 0.231287f),
      new Color(0.983041f, 0.624131f, 0.227937f),
      new Color(0.984199f, 0.629718f, 0.224595f),
      new Color(0.985301f, 0.635330f, 0.221265f),
      new Color(0.986345f, 0.640969f, 0.217948f),
      new Color(0.987332f, 0.646633f, 0.214648f),
      new Color(0.988260f, 0.652325f, 0.211364f),
      new Color(0.989128f, 0.658043f, 0.208100f),
      new Color(0.989935f, 0.663787f, 0.204859f),
      new Color(0.990681f, 0.669558f, 0.201642f),
      new Color(0.991365f, 0.675355f, 0.198453f),
      new Color(0.991985f, 0.681179f, 0.195295f),
      new Color(0.992541f, 0.687030f, 0.192170f),
      new Color(0.993032f, 0.692907f, 0.189084f),
      new Color(0.993456f, 0.698810f, 0.186041f),
      new Color(0.993814f, 0.704741f, 0.183043f),
      new Color(0.994103f, 0.710698f, 0.180097f),
      new Color(0.994324f, 0.716681f, 0.177208f),
      new Color(0.994474f, 0.722691f, 0.174381f),
      new Color(0.994553f, 0.728728f, 0.171622f),
      new Color(0.994561f, 0.734791f, 0.168938f),
      new Color(0.994495f, 0.740880f, 0.166335f),
      new Color(0.994355f, 0.746995f, 0.163821f),
      new Color(0.994141f, 0.753137f, 0.161404f),
      new Color(0.993851f, 0.759304f, 0.159092f),
      new Color(0.993482f, 0.765499f, 0.156891f),
      new Color(0.993033f, 0.771720f, 0.154808f),
      new Color(0.992505f, 0.777967f, 0.152855f),
      new Color(0.991897f, 0.784239f, 0.151042f),
      new Color(0.991209f, 0.790537f, 0.149377f),
      new Color(0.990439f, 0.796859f, 0.147870f),
      new Color(0.989587f, 0.803205f, 0.146529f),
      new Color(0.988648f, 0.809579f, 0.145357f),
      new Color(0.987621f, 0.815978f, 0.144363f),
      new Color(0.986509f, 0.822401f, 0.143557f),
      new Color(0.985314f, 0.828846f, 0.142945f),
      new Color(0.984031f, 0.835315f, 0.142528f),
      new Color(0.982653f, 0.841812f, 0.142303f),
      new Color(0.981190f, 0.848329f, 0.142279f),
      new Color(0.979644f, 0.854866f, 0.142453f),
      new Color(0.977995f, 0.861432f, 0.142808f),
      new Color(0.976265f, 0.868016f, 0.143351f),
      new Color(0.974443f, 0.874622f, 0.144061f),
      new Color(0.972530f, 0.881250f, 0.144923f),
      new Color(0.970533f, 0.887896f, 0.145919f),
      new Color(0.968443f, 0.894564f, 0.147014f),
      new Color(0.966271f, 0.901249f, 0.148180f),
      new Color(0.964021f, 0.907950f, 0.149370f),
      new Color(0.961681f, 0.914672f, 0.150520f),
      new Color(0.959276f, 0.921407f, 0.151566f),
      new Color(0.956808f, 0.928152f, 0.152409f),
      new Color(0.954287f, 0.934908f, 0.152921f),
      new Color(0.951726f, 0.941671f, 0.152925f),
      new Color(0.949151f, 0.948435f, 0.152178f),
      new Color(0.946602f, 0.955190f, 0.150328f),
      new Color(0.944152f, 0.961916f, 0.146861f),
      new Color(0.941896f, 0.968590f, 0.140956f),
      new Color(0.940015f, 0.975158f, 0.131326f)
  };

  private static final Color[] viridisData = {
      new Color(0.267004f, 0.004874f, 0.329415f),
      new Color(0.268510f, 0.009605f, 0.335427f),
      new Color(0.269944f, 0.014625f, 0.341379f),
      new Color(0.271305f, 0.019942f, 0.347269f),
      new Color(0.272594f, 0.025563f, 0.353093f),
      new Color(0.273809f, 0.031497f, 0.358853f),
      new Color(0.274952f, 0.037752f, 0.364543f),
      new Color(0.276022f, 0.044167f, 0.370164f),
      new Color(0.277018f, 0.050344f, 0.375715f),
      new Color(0.277941f, 0.056324f, 0.381191f),
      new Color(0.278791f, 0.062145f, 0.386592f),
      new Color(0.279566f, 0.067836f, 0.391917f),
      new Color(0.280267f, 0.073417f, 0.397163f),
      new Color(0.280894f, 0.078907f, 0.402329f),
      new Color(0.281446f, 0.084320f, 0.407414f),
      new Color(0.281924f, 0.089666f, 0.412415f),
      new Color(0.282327f, 0.094955f, 0.417331f),
      new Color(0.282656f, 0.100196f, 0.422160f),
      new Color(0.282910f, 0.105393f, 0.426902f),
      new Color(0.283091f, 0.110553f, 0.431554f),
      new Color(0.283197f, 0.115680f, 0.436115f),
      new Color(0.283229f, 0.120777f, 0.440584f),
      new Color(0.283187f, 0.125848f, 0.444960f),
      new Color(0.283072f, 0.130895f, 0.449241f),
      new Color(0.282884f, 0.135920f, 0.453427f),
      new Color(0.282623f, 0.140926f, 0.457517f),
      new Color(0.282290f, 0.145912f, 0.461510f),
      new Color(0.281887f, 0.150881f, 0.465405f),
      new Color(0.281412f, 0.155834f, 0.469201f),
      new Color(0.280868f, 0.160771f, 0.472899f),
      new Color(0.280255f, 0.165693f, 0.476498f),
      new Color(0.279574f, 0.170599f, 0.479997f),
      new Color(0.278826f, 0.175490f, 0.483397f),
      new Color(0.278012f, 0.180367f, 0.486697f),
      new Color(0.277134f, 0.185228f, 0.489898f),
      new Color(0.276194f, 0.190074f, 0.493001f),
      new Color(0.275191f, 0.194905f, 0.496005f),
      new Color(0.274128f, 0.199721f, 0.498911f),
      new Color(0.273006f, 0.204520f, 0.501721f),
      new Color(0.271828f, 0.209303f, 0.504434f),
      new Color(0.270595f, 0.214069f, 0.507052f),
      new Color(0.269308f, 0.218818f, 0.509577f),
      new Color(0.267968f, 0.223549f, 0.512008f),
      new Color(0.266580f, 0.228262f, 0.514349f),
      new Color(0.265145f, 0.232956f, 0.516599f),
      new Color(0.263663f, 0.237631f, 0.518762f),
      new Color(0.262138f, 0.242286f, 0.520837f),
      new Color(0.260571f, 0.246922f, 0.522828f),
      new Color(0.258965f, 0.251537f, 0.524736f),
      new Color(0.257322f, 0.256130f, 0.526563f),
      new Color(0.255645f, 0.260703f, 0.528312f),
      new Color(0.253935f, 0.265254f, 0.529983f),
      new Color(0.252194f, 0.269783f, 0.531579f),
      new Color(0.250425f, 0.274290f, 0.533103f),
      new Color(0.248629f, 0.278775f, 0.534556f),
      new Color(0.246811f, 0.283237f, 0.535941f),
      new Color(0.244972f, 0.287675f, 0.537260f),
      new Color(0.243113f, 0.292092f, 0.538516f),
      new Color(0.241237f, 0.296485f, 0.539709f),
      new Color(0.239346f, 0.300855f, 0.540844f),
      new Color(0.237441f, 0.305202f, 0.541921f),
      new Color(0.235526f, 0.309527f, 0.542944f),
      new Color(0.233603f, 0.313828f, 0.543914f),
      new Color(0.231674f, 0.318106f, 0.544834f),
      new Color(0.229739f, 0.322361f, 0.545706f),
      new Color(0.227802f, 0.326594f, 0.546532f),
      new Color(0.225863f, 0.330805f, 0.547314f),
      new Color(0.223925f, 0.334994f, 0.548053f),
      new Color(0.221989f, 0.339161f, 0.548752f),
      new Color(0.220057f, 0.343307f, 0.549413f),
      new Color(0.218130f, 0.347432f, 0.550038f),
      new Color(0.216210f, 0.351535f, 0.550627f),
      new Color(0.214298f, 0.355619f, 0.551184f),
      new Color(0.212395f, 0.359683f, 0.551710f),
      new Color(0.210503f, 0.363727f, 0.552206f),
      new Color(0.208623f, 0.367752f, 0.552675f),
      new Color(0.206756f, 0.371758f, 0.553117f),
      new Color(0.204903f, 0.375746f, 0.553533f),
      new Color(0.203063f, 0.379716f, 0.553925f),
      new Color(0.201239f, 0.383670f, 0.554294f),
      new Color(0.199430f, 0.387607f, 0.554642f),
      new Color(0.197636f, 0.391528f, 0.554969f),
      new Color(0.195860f, 0.395433f, 0.555276f),
      new Color(0.194100f, 0.399323f, 0.555565f),
      new Color(0.192357f, 0.403199f, 0.555836f),
      new Color(0.190631f, 0.407061f, 0.556089f),
      new Color(0.188923f, 0.410910f, 0.556326f),
      new Color(0.187231f, 0.414746f, 0.556547f),
      new Color(0.185556f, 0.418570f, 0.556753f),
      new Color(0.183898f, 0.422383f, 0.556944f),
      new Color(0.182256f, 0.426184f, 0.557120f),
      new Color(0.180629f, 0.429975f, 0.557282f),
      new Color(0.179019f, 0.433756f, 0.557430f),
      new Color(0.177423f, 0.437527f, 0.557565f),
      new Color(0.175841f, 0.441290f, 0.557685f),
      new Color(0.174274f, 0.445044f, 0.557792f),
      new Color(0.172719f, 0.448791f, 0.557885f),
      new Color(0.171176f, 0.452530f, 0.557965f),
      new Color(0.169646f, 0.456262f, 0.558030f),
      new Color(0.168126f, 0.459988f, 0.558082f),
      new Color(0.166617f, 0.463708f, 0.558119f),
      new Color(0.165117f, 0.467423f, 0.558141f),
      new Color(0.163625f, 0.471133f, 0.558148f),
      new Color(0.162142f, 0.474838f, 0.558140f),
      new Color(0.160665f, 0.478540f, 0.558115f),
      new Color(0.159194f, 0.482237f, 0.558073f),
      new Color(0.157729f, 0.485932f, 0.558013f),
      new Color(0.156270f, 0.489624f, 0.557936f),
      new Color(0.154815f, 0.493313f, 0.557840f),
      new Color(0.153364f, 0.497000f, 0.557724f),
      new Color(0.151918f, 0.500685f, 0.557587f),
      new Color(0.150476f, 0.504369f, 0.557430f),
      new Color(0.149039f, 0.508051f, 0.557250f),
      new Color(0.147607f, 0.511733f, 0.557049f),
      new Color(0.146180f, 0.515413f, 0.556823f),
      new Color(0.144759f, 0.519093f, 0.556572f),
      new Color(0.143343f, 0.522773f, 0.556295f),
      new Color(0.141935f, 0.526453f, 0.555991f),
      new Color(0.140536f, 0.530132f, 0.555659f),
      new Color(0.139147f, 0.533812f, 0.555298f),
      new Color(0.137770f, 0.537492f, 0.554906f),
      new Color(0.136408f, 0.541173f, 0.554483f),
      new Color(0.135066f, 0.544853f, 0.554029f),
      new Color(0.133743f, 0.548535f, 0.553541f),
      new Color(0.132444f, 0.552216f, 0.553018f),
      new Color(0.131172f, 0.555899f, 0.552459f),
      new Color(0.129933f, 0.559582f, 0.551864f),
      new Color(0.128729f, 0.563265f, 0.551229f),
      new Color(0.127568f, 0.566949f, 0.550556f),
      new Color(0.126453f, 0.570633f, 0.549841f),
      new Color(0.125394f, 0.574318f, 0.549086f),
      new Color(0.124395f, 0.578002f, 0.548287f),
      new Color(0.123463f, 0.581687f, 0.547445f),
      new Color(0.122606f, 0.585371f, 0.546557f),
      new Color(0.121831f, 0.589055f, 0.545623f),
      new Color(0.121148f, 0.592739f, 0.544641f),
      new Color(0.120565f, 0.596422f, 0.543611f),
      new Color(0.120092f, 0.600104f, 0.542530f),
      new Color(0.119738f, 0.603785f, 0.541400f),
      new Color(0.119512f, 0.607464f, 0.540218f),
      new Color(0.119423f, 0.611141f, 0.538982f),
      new Color(0.119483f, 0.614817f, 0.537692f),
      new Color(0.119699f, 0.618490f, 0.536347f),
      new Color(0.120081f, 0.622161f, 0.534946f),
      new Color(0.120638f, 0.625828f, 0.533488f),
      new Color(0.121380f, 0.629492f, 0.531973f),
      new Color(0.122312f, 0.633153f, 0.530398f),
      new Color(0.123444f, 0.636809f, 0.528763f),
      new Color(0.124780f, 0.640461f, 0.527068f),
      new Color(0.126326f, 0.644107f, 0.525311f),
      new Color(0.128087f, 0.647749f, 0.523491f),
      new Color(0.130067f, 0.651384f, 0.521608f),
      new Color(0.132268f, 0.655014f, 0.519661f),
      new Color(0.134692f, 0.658636f, 0.517649f),
      new Color(0.137339f, 0.662252f, 0.515571f),
      new Color(0.140210f, 0.665859f, 0.513427f),
      new Color(0.143303f, 0.669459f, 0.511215f),
      new Color(0.146616f, 0.673050f, 0.508936f),
      new Color(0.150148f, 0.676631f, 0.506589f),
      new Color(0.153894f, 0.680203f, 0.504172f),
      new Color(0.157851f, 0.683765f, 0.501686f),
      new Color(0.162016f, 0.687316f, 0.499129f),
      new Color(0.166383f, 0.690856f, 0.496502f),
      new Color(0.170948f, 0.694384f, 0.493803f),
      new Color(0.175707f, 0.697900f, 0.491033f),
      new Color(0.180653f, 0.701402f, 0.488189f),
      new Color(0.185783f, 0.704891f, 0.485273f),
      new Color(0.191090f, 0.708366f, 0.482284f),
      new Color(0.196571f, 0.711827f, 0.479221f),
      new Color(0.202219f, 0.715272f, 0.476084f),
      new Color(0.208030f, 0.718701f, 0.472873f),
      new Color(0.214000f, 0.722114f, 0.469588f),
      new Color(0.220124f, 0.725509f, 0.466226f),
      new Color(0.226397f, 0.728888f, 0.462789f),
      new Color(0.232815f, 0.732247f, 0.459277f),
      new Color(0.239374f, 0.735588f, 0.455688f),
      new Color(0.246070f, 0.738910f, 0.452024f),
      new Color(0.252899f, 0.742211f, 0.448284f),
      new Color(0.259857f, 0.745492f, 0.444467f),
      new Color(0.266941f, 0.748751f, 0.440573f),
      new Color(0.274149f, 0.751988f, 0.436601f),
      new Color(0.281477f, 0.755203f, 0.432552f),
      new Color(0.288921f, 0.758394f, 0.428426f),
      new Color(0.296479f, 0.761561f, 0.424223f),
      new Color(0.304148f, 0.764704f, 0.419943f),
      new Color(0.311925f, 0.767822f, 0.415586f),
      new Color(0.319809f, 0.770914f, 0.411152f),
      new Color(0.327796f, 0.773980f, 0.406640f),
      new Color(0.335885f, 0.777018f, 0.402049f),
      new Color(0.344074f, 0.780029f, 0.397381f),
      new Color(0.352360f, 0.783011f, 0.392636f),
      new Color(0.360741f, 0.785964f, 0.387814f),
      new Color(0.369214f, 0.788888f, 0.382914f),
      new Color(0.377779f, 0.791781f, 0.377939f),
      new Color(0.386433f, 0.794644f, 0.372886f),
      new Color(0.395174f, 0.797475f, 0.367757f),
      new Color(0.404001f, 0.800275f, 0.362552f),
      new Color(0.412913f, 0.803041f, 0.357269f),
      new Color(0.421908f, 0.805774f, 0.351910f),
      new Color(0.430983f, 0.808473f, 0.346476f),
      new Color(0.440137f, 0.811138f, 0.340967f),
      new Color(0.449368f, 0.813768f, 0.335384f),
      new Color(0.458674f, 0.816363f, 0.329727f),
      new Color(0.468053f, 0.818921f, 0.323998f),
      new Color(0.477504f, 0.821444f, 0.318195f),
      new Color(0.487026f, 0.823929f, 0.312321f),
      new Color(0.496615f, 0.826376f, 0.306377f),
      new Color(0.506271f, 0.828786f, 0.300362f),
      new Color(0.515992f, 0.831158f, 0.294279f),
      new Color(0.525776f, 0.833491f, 0.288127f),
      new Color(0.535621f, 0.835785f, 0.281908f),
      new Color(0.545524f, 0.838039f, 0.275626f),
      new Color(0.555484f, 0.840254f, 0.269281f),
      new Color(0.565498f, 0.842430f, 0.262877f),
      new Color(0.575563f, 0.844566f, 0.256415f),
      new Color(0.585678f, 0.846661f, 0.249897f),
      new Color(0.595839f, 0.848717f, 0.243329f),
      new Color(0.606045f, 0.850733f, 0.236712f),
      new Color(0.616293f, 0.852709f, 0.230052f),
      new Color(0.626579f, 0.854645f, 0.223353f),
      new Color(0.636902f, 0.856542f, 0.216620f),
      new Color(0.647257f, 0.858400f, 0.209861f),
      new Color(0.657642f, 0.860219f, 0.203082f),
      new Color(0.668054f, 0.861999f, 0.196293f),
      new Color(0.678489f, 0.863742f, 0.189503f),
      new Color(0.688944f, 0.865448f, 0.182725f),
      new Color(0.699415f, 0.867117f, 0.175971f),
      new Color(0.709898f, 0.868751f, 0.169257f),
      new Color(0.720391f, 0.870350f, 0.162603f),
      new Color(0.730889f, 0.871916f, 0.156029f),
      new Color(0.741388f, 0.873449f, 0.149561f),
      new Color(0.751884f, 0.874951f, 0.143228f),
      new Color(0.762373f, 0.876424f, 0.137064f),
      new Color(0.772852f, 0.877868f, 0.131109f),
      new Color(0.783315f, 0.879285f, 0.125405f),
      new Color(0.793760f, 0.880678f, 0.120005f),
      new Color(0.804182f, 0.882046f, 0.114965f),
      new Color(0.814576f, 0.883393f, 0.110347f),
      new Color(0.824940f, 0.884720f, 0.106217f),
      new Color(0.835270f, 0.886029f, 0.102646f),
      new Color(0.845561f, 0.887322f, 0.099702f),
      new Color(0.855810f, 0.888601f, 0.097452f),
      new Color(0.866013f, 0.889868f, 0.095953f),
      new Color(0.876168f, 0.891125f, 0.095250f),
      new Color(0.886271f, 0.892374f, 0.095374f),
      new Color(0.896320f, 0.893616f, 0.096335f),
      new Color(0.906311f, 0.894855f, 0.098125f),
      new Color(0.916242f, 0.896091f, 0.100717f),
      new Color(0.926106f, 0.897330f, 0.104071f),
      new Color(0.935904f, 0.898570f, 0.108131f),
      new Color(0.945636f, 0.899815f, 0.112838f),
      new Color(0.955300f, 0.901065f, 0.118128f),
      new Color(0.964894f, 0.902323f, 0.123941f),
      new Color(0.974417f, 0.903590f, 0.130215f),
      new Color(0.983868f, 0.904867f, 0.136897f),
      new Color(0.993248f, 0.906157f, 0.143936f)
  };

  static Color getColor(DeathpileColorSchemeType type, float value) {
    Color[] colorData;
    if (type == DeathpileColorSchemeType.MAGMA) {
      colorData = magmaData;
    } else if (type == DeathpileColorSchemeType.INFERNO) {
      colorData = infernoData;
    } else if (type == DeathpileColorSchemeType.PLASMA) {
      colorData = plasmaData;
    } else if (type == DeathpileColorSchemeType.VIRIDIS) {
      colorData = viridisData;
    } else {
      return Color.WHITE;
    }

    int numColors = colorData.length;
    int index = (int) (value * (numColors - 1));
    float fraction = value * (numColors - 1) - index;

    Color startColor = colorData[index];
    Color endColor = colorData[index + 1];

    int r = interpolate(startColor.getRed(), endColor.getRed(), fraction);
    int g = interpolate(startColor.getGreen(), endColor.getGreen(), fraction);
    int b = interpolate(startColor.getBlue(), endColor.getBlue(), fraction);


    return new Color(r, g, b);
  }

  private static int interpolate(int start, int end, float fraction) {
    return Math.round(start + (end - start) * fraction);
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.UUID;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Scene;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

/** Deathpile is responsible for tracking the player's deathpiled items. */
@Getter
@Slf4j
public class Deathpile extends ExpiringDeathStorage {

  Deathpile(
      DudeWheresMyStuffPlugin plugin,
      boolean useAccountPlayTime,
      WorldArea worldArea,
      DeathStorageManager deathStorageManager,
      List<ItemStack> deathItems) {
    super(
        plugin,
        useAccountPlayTime,
        worldArea,
        deathStorageManager,
        deathItems,
        DeathStorageType.DEATHPILE);
    refreshColor();
  }

  @Override
  public boolean onGameTick() {
    var updated = super.onGameTick();

    if (hasExpired()) {
      return updated;
    }

    if (worldPoint == null) {
      return locate() || updated;
    }

    return updated;
  }

  private List<TileItem> getTileGroundItems(
      Tile[][] sceneTilesPlane, Scene scene, WorldPoint tilePoint) {
    var sceneX = tilePoint.getX() - scene.getBaseX();
    if (sceneX >= sceneTilesPlane.length) {
      return null;
    }

    var sceneY = tilePoint.getY() - scene.getBaseY();
    var sceneTilesX = sceneTilesPlane[sceneX];
    if (sceneY >= sceneTilesX.length) {
      return null;
    }

    var sceneTile = sceneTilesX[sceneY];
    if (sceneTile == null) {
      return null;
    }

    return sceneTile.getGroundItems();
  }

  private boolean locate() {
    if (worldArea == null) {
      return false;
    }

    var client = plugin.getClient();
    WorldPoint playerLocation =
        WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());
    if (worldArea.distanceTo(playerLocation) >= 32) {
      return false;
    }

    var worldView = client.getTopLevelWorldView();
    LocalPoint lp =
        LocalPoint.fromWorld(
            worldView,
            worldArea.getX() + worldArea.getWidth() / 2,
            worldArea.getY() + worldArea.getHeight() / 2);
    if (lp == null) {
      return false;
    }

    var scene = worldView.getScene();
    var sceneTiles = scene.getTiles();
    if (worldArea.getPlane() >= sceneTiles.length) {
      return false;
    }

    var sceneTilesPlane = sceneTiles[worldArea.getPlane()];
    for (WorldPoint tilePoint : worldArea.toWorldPointList()) {
      var groundItems = getTileGroundItems(sceneTilesPlane, scene, tilePoint);
      if (groundItems == null) {
        continue;
      }

      var itemsToMatch = new ArrayList<>(items);
      for (TileItem groundItem : groundItems) {
        var itemToRemove = itemsToMatch.stream().filter(is -> is.getId() == groundItem.getId() && is.getQuantity() == groundItem.getQuantity()).findAny();
        itemToRemove.ifPresent(itemsToMatch::remove);

        if (itemsToMatch.size() <= items.size() / 2) {
          break;
        }
      }

      if (itemsToMatch.size() <= items.size() / 2) {
        worldPoint = tilePoint;
        worldArea = null;
        deathStorageManager.refreshMapPoints();
        SwingUtilities.invokeLater(this::setSubTitle);
        return true;
      }
    }

    return false;
  }

  static Deathpile load(
      DudeWheresMyStuffPlugin plugin,
      DeathStorageManager deathStorageManager,
      String profileKey,
      String uuid) {
    Deathpile deathpile =
        new Deathpile(plugin, true, null, deathStorageManager, new ArrayList<>());

    deathpile.uuid = UUID.fromString(uuid);
    deathpile.load(
        deathStorageManager.getConfigManager(), deathStorageManager.getConfigKey(), profileKey);

    return deathpile;
  }

  private Color generateColor() {
    if (worldPoint == null) {
      return Color.WHITE;
    }

    Random rand =
        new Random(
            worldPoint.getX() * 200L + worldPoint.getY() * 354L + worldPoint.getPlane() * 42L);

    return plugin.getConfig().deathpileColorScheme().generateColor(rand);
  }

  @Override
  public void softUpdate() {
    super.softUpdate();

    storagePanel.setSubTitle(items.size() + " stacks");
  }

  @Override
  protected void loadValues(ArrayList<String> values) {
    super.loadValues(values);

    refreshColor();
  }

  void refreshColor() {
    color = generateColor();
  }

  @Override
  public int getTotalLifeInMinutes() {
    return 60;
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import javax.annotation.Nonnull;
import net.runelite.api.gameval.ItemID;

class GraveInfoBox extends ExpiringDeathStorageInfoBox {

  public GraveInfoBox(@Nonnull DudeWheresMyStuffPlugin plugin, Grave storage) {
    super(plugin, storage, ItemID.SIRENS_TOME);
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import java.awt.Color;
import javax.annotation.Nonnull;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.util.ImageUtil;

class CheckPlayTimeInfoBox extends InfoBox {

  public CheckPlayTimeInfoBox(@Nonnull DudeWheresMyStuffPlugin plugin) {
    super(ImageUtil.loadImageResource(DudeWheresMyStuffPlugin.class, "icon-28.png"), plugin);
  }

  @Override
  public String getText() {
    return null;
  }

  @Override
  public Color getTextColor() {
    return null;
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStorage;
import lombok.Getter;

/**
 * DeathStorage is responsible for tracking death storages that hold the players items (deathpiles,
 * deathbanks).
 */
@Getter
public class DeathStorage extends ItemStorage<DeathStorageType> {

  protected DeathStorage(DeathStorageType type, DudeWheresMyStuffPlugin plugin) {
    super(type, plugin);
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.DurationFormatter;
import dev.thource.runelite.dudewheresmystuff.SaveFieldFormatter;
import dev.thource.runelite.dudewheresmystuff.SaveFieldLoader;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import java.util.ArrayList;
import java.util.UUID;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

/** Deathbank is responsible for tracking the player's deathbanked items. */
@Slf4j
@Getter
@Setter
public class Deathbank extends DeathStorage {

  protected UUID uuid = UUID.randomUUID();
  private boolean locked = false;
  @Getter private long lostAt = -1L;
  private DeathbankType deathbankType;
  private DeathStorageManager deathStorageManager;

  Deathbank(
      DeathbankType deathbankType,
      DudeWheresMyStuffPlugin plugin,
      DeathStorageManager deathStorageManager) {
    super(DeathStorageType.DEATHBANK, plugin);

    this.deathbankType = deathbankType;
    this.deathStorageManager = deathStorageManager;
  }

  static Deathbank load(DudeWheresMyStuffPlugin plugin, DeathStorageManager deathStorageManager,
      String profileKey, String uuid) {
    Deathbank deathbank = new Deathbank(
        DeathbankType.UNKNOWN,
        plugin,
        deathStorageManager
    );

    deathbank.uuid = UUID.fromString(uuid);
    deathbank.load(deathStorageManager.getConfigManager(), deathStorageManager.getConfigKey(),
        profileKey);

    if (deathbank.getItems().isEmpty()) {
      deathbank.deleteData(deathStorageManager);
      return null;
    }

    return deathbank;
  }

  @Override
  protected String getConfigKey(String managerConfigKey) {
    return super.getConfigKey(managerConfigKey) + "." + uuid;
  }

  @Override
  protected ArrayList<String> getSaveValues() {
    ArrayList<String> saveValues = super.getSaveValues();

    saveValues.add(SaveFieldFormatter.format(uuid));
    saveValues.add(SaveFieldFormatter.format(locked));
    saveValues.add(SaveFieldFormatter.format(lostAt));
    saveValues.add(SaveFieldFormatter.format(deathbankType));

    return saveValues;
  }

  @Override
  protected void loadValues(ArrayList<String> values) {
    super.loadValues(values);

    uuid = SaveFieldLoader.loadUUID(values, uuid);
    locked = SaveFieldLoader.loadBoolean(values, locked);
    lostAt = SaveFieldLoader.loadLong(values, lostAt);
    deathbankType = SaveFieldLoader.loadDeathbankType(values, deathbankType);
  }

  @Override
  protected void createStoragePanel(StorageManager<?, ?> storageManager) {
    super.createStoragePanel(storageManager);
    assert storagePanel != null; // storagePanel can't be null here as it's set in super kl

    storagePanel.setTitle(deathbankType.getName());
    storagePanel.setSubTitle(locked ? "Locked" : "Unlocked");

    createComponentPopupMenu(storageManager);
  }

  @Override
  protected void createComponentPopupMenu(StorageManager<?, ?> storageManager) {
    if (storagePanel == null) {
      return;
    }

    final JPopupMenu popupMenu = new JPopupMenu();
    popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
    storagePanel.setComponentPopupMenu(popupMenu);

    final JMenuItem clearDeathbank = new JMenuItem("Delete Deathbank");
    clearDeathbank.addActionListener(
        e -> {
          boolean confirmed = lostAt != -1L || DudeWheresMyStuffPlugin.getConfirmation(storagePanel,
              "Are you sure you want to delete this deathbank?\nThis cannot be undone.",
              "Confirm deletion");

          if (confirmed) {
            if (this == deathStorageManager.getDeathbank()) {
              deathStorageManager.clearDeathbank(false);
            } else {
              deathStorageManager.getStorages().remove(this);
              deleteData(deathStorageManager);
            }
            deathStorageManager.getStorageTabPanel().reorderStoragePanels();
          }
        });
    popupMenu.add(clearDeathbank);
    createDebugMenuOptions(storageManager, popupMenu);
  }

  private void createDebugMenuOptions(StorageManager<?, ?> storageManager, JPopupMenu popupMenu) {
    if (plugin.isDeveloperMode()) {
      var debugMenu = new JMenu("Debug");
      popupMenu.add(debugMenu);

      var setTypeMenu = new JMenu("Set type");
      debugMenu.add(setTypeMenu);

      for (DeathbankType dbType : DeathbankType.values()) {
        var setType = new JMenuItem(dbType.getName());
        setType.addActionListener(
            e -> setDeathbankType(dbType));
        setTypeMenu.add(setType);
      }

      var expire = new JMenuItem("Set as lost");
      debugMenu.add(expire);
      expire.addActionListener(
          e -> {
            lostAt = System.currentTimeMillis();
            softUpdate();
            storageManager.getStorageTabPanel().reorderStoragePanels();
          });

      var lock = new JMenuItem("Toggle lock");
      debugMenu.add(lock);
      lock.addActionListener(
          e -> setLocked(!locked));
    }
  }

  void setLocked(boolean locked) {
    this.locked = locked;

    SwingUtilities.invokeLater(() -> {
      if (storagePanel != null) {
        storagePanel.setSubTitle(locked ? "Locked" : "Unlocked");
      }
    });
  }

  void setDeathbankType(DeathbankType dbType) {
    deathbankType = dbType;

    SwingUtilities.invokeLater(() -> {
      if (storagePanel != null) {
        storagePanel.setTitle(deathbankType.getName());
      }
    });
  }

  @Override
  public void reset() {
    // deathbanks get removed instead of reset
  }

  @Override
  public void softUpdate() {
    if (storagePanel != null && lostAt != -1) {
      long timeSinceLost = System.currentTimeMillis() - lostAt;
      storagePanel.setFooterText(
          "Lost " + DurationFormatter.format(Math.abs(timeSinceLost)) + " ago");
      return;
    }

    super.softUpdate();
  }

  /**
   * Checks if the deathbank has not been lost.
   *
   * @return true if lostAt == -1
   */
  public boolean isActive() {
    return lostAt == -1L;
  }

  @Override
  public boolean isWithdrawable() {
    // If the items were lost, then they can't be withdrawn
    return super.isWithdrawable() && isActive();
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

import com.google.common.collect.ImmutableSet;
import com.google.inject.Inject;
import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffConfig;
import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemContainerWatcher;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.ItemStackUtils;
import dev.thource.runelite.dudewheresmystuff.Region;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import dev.thource.runelite.dudewheresmystuff.Var;
import dev.thource.runelite.dudewheresmystuff.carryable.CarryableStorageManager;
import dev.thource.runelite.dudewheresmystuff.carryable.CarryableStorageType;
import dev.thource.runelite.dudewheresmystuff.coins.CoinsStorageManager;
import dev.thource.runelite.dudewheresmystuff.coins.CoinsStorageType;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.MenuAction;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;
import net.runelite.api.TileItem;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;
import net.runelite.client.util.Text;

/** DeathStorageManager is responsible for managing all DeathStorages. */
@Slf4j
public class DeathStorageManager extends StorageManager<DeathStorageType, DeathStorage> {

  private static final Set<Integer> RESPAWN_REGIONS =
      ImmutableSet.of(
          6457, // Kourend
          12850, // Lumbridge
          11828, // Falador
          12342, // Edgeville
          11062, // Camelot
          13150, // Prifddinas (it's possible to spawn in 2 adjacent regions)
          12894, // Prifddinas
          14642, // ToB
          12172, // Gauntlet
          12633, // death's office
          12600, // Ferox
          6705, // Civitas illa Fortis
          7316, // Colosseum lobby
          5789, // Chasm of Fire (Yama)
          5269 // Doom
          );
  private static final Set<Region> SAFE_DEATH_REGIONS =
      ImmutableSet.of(
          Region.REGION_POH,
          Region.MG_LAST_MAN_STANDING_DESERTED_ISLAND,
          Region.MG_LAST_MAN_STANDING_WILD_VARROCK);
  private final CheckPlayTimeInfoBox playTimeInfoBox = new CheckPlayTimeInfoBox(plugin);
  private final List<ExpiringDeathStorageInfoBox> expiringDeathStorageInfoBoxes = new ArrayList<>();
  @Getter private final DeathsOffice deathsOffice;
  long startMs = 0L;
  @Getter @Nullable private Deathbank deathbank = null;
  @Getter private final DeathItems deathItemsStorage;
  @Getter @Nullable private Grave grave = null;
  @Setter private CarryableStorageManager carryableStorageManager;
  @Setter private CoinsStorageManager coinsStorageManager;
  @Inject private WorldMapPointManager worldMapPointManager;
  @Getter @Setter private int startPlayedMinutes = -1;
  private DyingState dyingState = DyingState.NOT_DYING;
  private WorldArea deathPileArea;
  private List<ItemStack> deathItems;
  private DeathbankInfoBox deathbankInfoBox;
  private int entryModeTob; // 1 = entering entry mode, 2 = entry mode
  private final List<SuspendedGroundItem> itemsPickedUp = new ArrayList<>();

  @Inject
  private DeathStorageManager(DudeWheresMyStuffPlugin plugin) {
    super(plugin);

    playTimeInfoBox.setTooltip(
        "Navigate to the quest tab and swap to</br>the Character Summary tab"
            + " (brown star) to</br>track cross-client deathpiles.");

    deathItemsStorage = new DeathItems(plugin, this);
    storages.add(deathItemsStorage);
    deathsOffice = new DeathsOffice(plugin);
    storages.add(deathsOffice);
  }

  @Override
  public void onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
    if (!enabled) {
      return;
    }

    if (itemContainerChanged.getContainerId() == InventoryID.GRAVESTONE) {
      if (client.getWidget(672, 0) == null) {
        updateDeathbankItems(itemContainerChanged.getItemContainer().getItems());

        SwingUtilities.invokeLater(
            () ->
                plugin
                    .getClientThread()
                    .invoke(() -> updateStorages(Collections.singletonList(deathbank))));
      } else {
        updateGraveItems(itemContainerChanged.getItemContainer().getItems());

        SwingUtilities.invokeLater(
            () ->
                plugin
                    .getClientThread()
                    .invoke(() -> updateStorages(Collections.singletonList(grave))));
      }
    }
  }

  @Override
  public void onVarbitChanged(VarbitChanged varbitChanged) {
    var durationVar = Var.bit(varbitChanged, VarbitID.GRAVESTONE_DURATION);
    if (!durationVar.wasChanged()) {
      return;
    }

    if (grave == null) {
      if (durationVar.getValue(plugin.getClient()) > 0
          && client.getBoostedSkillLevel(Skill.HITPOINTS) > 0) {
        createMysteryGrave();
      }

      return;
    }

    if (grave.hasExpired()) {
      grave = null;
    }
  }

  private void updateGraveItems(Item[] items) {
    if (grave == null) {
      createMysteryGrave();
    }

    grave.getItems().clear();
    for (Item item : items) {
      if (item.getId() == -1) {
        continue;
      }

      grave.getItems().add(new ItemStack(item.getId(), item.getQuantity(), plugin));
    }
  }

  private void updateDeathbankItems(Item[] items) {
    int deathbankVarp = client.getVarpValue(VarPlayerID.IF1);
    DeathbankType deathbankType =
        Arrays.stream(DeathbankType.values())
            .filter(
                s ->
                    s.getDeathBankLockedState() == deathbankVarp
                        || s.getDeathBankUnlockedState() == deathbankVarp)
            .findFirst()
            .orElse(DeathbankType.UNKNOWN);

    if (deathbank == null) {
      deathbank = new Deathbank(deathbankType, plugin, this);
      storages.add(deathbank);
      SwingUtilities.invokeLater(() -> deathbank.createStoragePanel(this));
    } else {
      deathbank.setDeathbankType(deathbankType);
      deathbank.getItems().clear();
    }

    deathbank.setLocked(deathbankType.getDeathBankLockedState() == deathbankVarp);
    deathbank.setLastUpdated(System.currentTimeMillis());

    for (Item item : items) {
      if (item.getId() == -1) {
        continue;
      }

      deathbank.getItems().add(new ItemStack(item.getId(), item.getQuantity(), plugin));
    }
  }

  private boolean updateFromWatchers() {
    var updated = updateDeathbankFromWatcher(ItemContainerWatcher.getInventoryWatcher());

    if (plugin.getClient().getVarbitValue(VarbitID.SETTINGS_GRAVESTONE_AUTOEQUIP) == 1
        && updateDeathbankFromWatcher(ItemContainerWatcher.getWornWatcher())) {
      updated = true;
    }

    return updated;
  }

  private boolean updateDeathbankFromWatcher(ItemContainerWatcher watcher) {
    boolean updated = false;

    if (deathbank == null
        || deathbank.getDeathbankType() != DeathbankType.ZULRAH
        || client.getLocalPlayer() == null
        || Region.get(client.getLocalPlayer().getWorldLocation().getRegionID())
            != Region.CITY_ZULANDRA) {
      return false;
    }

    var itemsAddedLastTick = watcher.getItemsAddedLastTick();
    removeItemsFromList(deathbank.getItems(), itemsAddedLastTick);

    if (!itemsAddedLastTick.isEmpty()) {
      deathbank.setLastUpdated(System.currentTimeMillis());
      updated = true;
    }

    if (deathbank.getItems().isEmpty()) {
      clearDeathbank(false);
    }

    return updated;
  }

  private void removeItemsFromList(
      List<ItemStack> listToRemoveFrom, List<ItemStack> itemsToRemove) {
    for (ItemStack itemToRemove : itemsToRemove) {
      ItemStackUtils.removeItemStack(listToRemoveFrom, itemToRemove, false);
    }
  }

  private void removeItemsFromList(List<ItemStack> listToRemoveFrom, Item[] itemsToRemove) {
    for (Item item : itemsToRemove) {
      ItemStackUtils.removeItemStack(
          listToRemoveFrom, new ItemStack(item.getId(), "", item.getQuantity(), 0, 0, true), false);
    }
  }

  void clearDeathbank(boolean wasLost) {
    if (deathbank != null) {
      if (wasLost) {
        deathbank.setLostAt(System.currentTimeMillis());
      } else {
        storages.remove(deathbank);
        deathbank.deleteData(this);
      }
    }

    deathbank = null;
  }

  @Override
  public void onGameStateChanged(GameStateChanged gameStateChanged) {
    if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN
        || gameStateChanged.getGameState() == GameState.HOPPING) {
      startPlayedMinutes = -1;
      startMs = 0L;
    }
  }

  // the use of | instead of || is not an accident, each function should be executed
  @SuppressWarnings("java:S2178")
  @Override
  public void onGameTick() {
    super.onGameTick();

    updateStartPlayedMinutes();

    if (dyingState == DyingState.TICK_1) {
      dyingState = DyingState.TICK_2;
    } else if (dyingState == DyingState.TICK_2) {
      dyingState = DyingState.TICK_3;
    } else if (dyingState == DyingState.TICK_3) {
      dyingState = DyingState.RECORDING_DATA;
    } else if (dyingState == DyingState.RECORDING_DATA) {
      WorldArea worldArea =
          RemoteDeathpileAreas.getPileArea(
              client,
              WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation()));
      List<ItemStack> items =
          getDeathItems().stream()
              .filter(itemStack -> itemStack.getId() != -1)
              .collect(Collectors.toList());

      if (items.isEmpty()) {
        dyingState = DyingState.NOT_DYING;
      } else {
        dyingState = DyingState.WAITING_FOR_RESPAWN;
        deathPileArea = worldArea;
        deathItems = items;
      }
    }

    if ((deathbank != null && checkIfDeathbankWindowIsEmpty())
        | processDeath()
        | checkItemsLostOnDeathWindow()
        | updateFromWatchers()) {

      SwingUtilities.invokeLater(
          () -> plugin.getClientThread().invoke(() -> updateStorages(storages)));
    }

    refreshInfoBoxes();
    updateWorldMapPoints();

    if (entryModeTob > 0) {
      WorldPoint location =
          WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());
      Region region = Region.get(location.getRegionID());
      if (entryModeTob == 1) {
        if (region == Region.RAIDS_THEATRE_OF_BLOOD) {
          entryModeTob = 2;
        }
      } else if (entryModeTob == 2) {
        if (region != Region.RAIDS_THEATRE_OF_BLOOD) {
          entryModeTob = 0;
        }
      }
    }

    var listIterator = itemsPickedUp.listIterator();
    while (listIterator.hasNext()) {
      var item = listIterator.next();

      if (item.getTicksLeft() <= 1) {
        listIterator.remove();
      } else {
        item.setTicksLeft(item.getTicksLeft() - 1);
      }
    }
  }

  public Deathpile getSoonestExpiringDeathpile() {
    return getDeathpiles()
        .filter(deathpile -> !deathpile.hasExpired())
        .min(Comparator.comparing(Deathpile::getExpiryMs))
        .orElse(null);
  }

  private boolean checkIfDeathbankWindowIsEmpty() {
    Widget itemWindow = client.getWidget(602, 3);
    // This checks if the item collection window has been emptied while it was open
    if (itemWindow != null && client.getVarpValue(VarPlayerID.IF1) == -1) {
      clearDeathbank(false);
      return true;
    }

    return false;
  }

  private void updateStartPlayedMinutes() {
    int playedMinutes = client.getVarcIntValue(526);
    if (playedMinutes != startPlayedMinutes) {
      if (startPlayedMinutes == -1) {
        refreshMapPoints();
      }

      SwingUtilities.invokeLater(storageTabPanel::reorderStoragePanels);

      startPlayedMinutes = playedMinutes;
      startMs = System.currentTimeMillis();

      if (startPlayedMinutes > 0) {
        getExpiringDeathStorages()
            .filter(ExpiringDeathStorage::isUseAccountPlayTime)
            .filter(storage -> storage.getStoragePanel() != null)
            .forEach(storage -> storage.getStoragePanel().getFooterLabel().setToolTipText(null));
      }
    }

    if (startPlayedMinutes > 0) {
      Integer savedPlayedMinutes =
          configManager.getRSProfileConfiguration(
              DudeWheresMyStuffConfig.CONFIG_GROUP, "minutesPlayed", int.class);
      if (savedPlayedMinutes == null || savedPlayedMinutes != getPlayedMinutes()) {
        configManager.setRSProfileConfiguration(
            DudeWheresMyStuffConfig.CONFIG_GROUP, "minutesPlayed", getPlayedMinutes());
      }
    }
  }

  Stream<Deathpile> getDeathpiles() {
    return storages.stream().filter(Deathpile.class::isInstance).map(Deathpile.class::cast);
  }

  Stream<Grave> getGraves() {
    return storages.stream().filter(Grave.class::isInstance).map(Grave.class::cast);
  }

  Stream<ExpiringDeathStorage> getExpiringDeathStorages() {
    return storages.stream()
        .filter(ExpiringDeathStorage.class::isInstance)
        .map(ExpiringDeathStorage.class::cast);
  }

  /** Checks if any infoboxes need adding or removing. */
  public void refreshInfoBoxes() {
    refreshCheckPlayTimeInfoBox();
    refreshDeathbankInfoBox();
    refreshExpiringDeathStorageInfoBoxes();
  }

  private void pruneExpiringDeathStorageInfoBoxes(
      List<ExpiringDeathStorage> activeExpiringDeathStorages,
      InfoBoxManager infoBoxManager,
      List<InfoBox> currentInfoBoxes) {
    ListIterator<ExpiringDeathStorageInfoBox> iterator =
        expiringDeathStorageInfoBoxes.listIterator();
    while (iterator.hasNext()) {
      ExpiringDeathStorageInfoBox infoBox = iterator.next();

      if (!activeExpiringDeathStorages.contains(infoBox.getStorage())) {
        if (currentInfoBoxes.contains(infoBox)) {
          infoBoxManager.removeInfoBox(infoBox);
        }

        iterator.remove();
      }
    }
  }

  private void refreshInfoBoxImage(ExpiringDeathStorageInfoBox infoBox) {
    if (!infoBox.isImageDirty()) {
      return;
    }

    InfoBoxManager infoBoxManager = plugin.getInfoBoxManager();
    List<InfoBox> currentInfoBoxes = infoBoxManager.getInfoBoxes();
    if (currentInfoBoxes.contains(infoBox)) {
      infoBoxManager.updateInfoBoxImage(infoBox);
    }

    infoBox.setImageDirty(false);
  }

  private void refreshExpiringDeathStorageInfoBoxes() {
    InfoBoxManager infoBoxManager = plugin.getInfoBoxManager();
    List<InfoBox> currentInfoBoxes = infoBoxManager.getInfoBoxes();
    List<ExpiringDeathStorage> activeExpiringDeathStorages =
        getExpiringDeathStorages()
            .filter(storage -> !storage.hasExpired())
            .collect(Collectors.toList());

    pruneExpiringDeathStorageInfoBoxes(
        activeExpiringDeathStorages, infoBoxManager, currentInfoBoxes);

    activeExpiringDeathStorages.forEach(
        storage -> {
          if (expiringDeathStorageInfoBoxes.stream()
              .noneMatch(infoBox -> infoBox.getStorage() == storage)) {
            ExpiringDeathStorageInfoBox infoBox;
            if (storage instanceof Deathpile) {
              infoBox = new DeathpileInfoBox(plugin, (Deathpile) storage);
            } else {
              infoBox = new GraveInfoBox(plugin, (Grave) storage);
            }

            expiringDeathStorageInfoBoxes.add(infoBox);
          }
        });

    for (ExpiringDeathStorageInfoBox infoBox : expiringDeathStorageInfoBoxes) {
      if (plugin.getConfig().deathpileInfoBox()) {
        infoBox.refreshTooltip();

        refreshInfoBoxImage(infoBox);

        if (!currentInfoBoxes.contains(infoBox)) {
          infoBoxManager.addInfoBox(infoBox);
        }
      } else if (currentInfoBoxes.contains(infoBox)) {
        infoBoxManager.removeInfoBox(infoBox);
      }
    }
  }

  private void refreshDeathbankInfoBox() {
    boolean showInfoBox = deathbank != null && plugin.getConfig().deathbankInfoBox();
    boolean hasDeathbankChanged =
        (showInfoBox && deathbankInfoBox == null)
            || (deathbankInfoBox != null && deathbankInfoBox.getDeathbank() != deathbank);
    List<InfoBox> infoBoxes = plugin.getInfoBoxManager().getInfoBoxes();

    if (deathbankInfoBox != null
        && (!showInfoBox || hasDeathbankChanged)
        && infoBoxes.contains(deathbankInfoBox)) {
      plugin.getInfoBoxManager().removeInfoBox(deathbankInfoBox);
    }

    if (hasDeathbankChanged) {
      deathbankInfoBox = deathbank == null ? null : new DeathbankInfoBox(plugin, deathbank);
    }

    if (showInfoBox && !infoBoxes.contains(deathbankInfoBox)) {
      plugin.getInfoBoxManager().addInfoBox(deathbankInfoBox);
    }
  }

  private boolean doesAnyActiveExpiringDeathStorageUseAccountPlayTime() {
    return getExpiringDeathStorages()
        .filter(storage -> !storage.hasExpired())
        .anyMatch(ExpiringDeathStorage::isUseAccountPlayTime);
  }

  private void refreshCheckPlayTimeInfoBox() {
    boolean showInfoBox =
        startPlayedMinutes <= 0
            && (plugin.getConfig().deathpilesUseAccountPlayTime()
                || doesAnyActiveExpiringDeathStorageUseAccountPlayTime());
    boolean isAdded = plugin.getInfoBoxManager().getInfoBoxes().contains(playTimeInfoBox);

    if (!showInfoBox && isAdded) {
      plugin.getInfoBoxManager().removeInfoBox(playTimeInfoBox);
    } else if (showInfoBox && !isAdded) {
      plugin.getInfoBoxManager().addInfoBox(playTimeInfoBox);
    }
  }

  @Override
  public void onChatMessage(ChatMessage chatMessage) {
    super.onChatMessage(chatMessage);

    if (chatMessage.getType() != ChatMessageType.SPAM
        && chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
      return;
    }

    String message = Text.removeTags(chatMessage.getMessage());
    if (message.startsWith("You enter the Theatre of Blood (Entry Mode)")) {
      entryModeTob = 1;
      return;
    }

    if (dyingState != DyingState.NOT_DYING) {
      Region region = Region.get(deathPileArea.toWorldPoint().getRegionID());
      if (region == Region.RAIDS_THEATRE_OF_BLOOD
          && message.startsWith("You feel refreshed as your health is replenished")) {
        dyingState = DyingState.NOT_DYING;
        deathPileArea = null;
        deathItems = null;
        return;
      }
    }

    if (deathbank != null
        || !message.startsWith("You have items stored in an item retrieval service.")) {
      return;
    }

    String finalMessage = message.replace(" ", "");
    DeathbankType deathbankType =
        Arrays.stream(DeathbankType.values())
            .filter(type -> type.getDeathWindowLocationText() != null)
            .filter(type -> finalMessage.contains(type.getDeathWindowLocationText()))
            .findFirst()
            .orElse(DeathbankType.UNKNOWN);

    if (deathbankType == DeathbankType.UNKNOWN && client.getVarbitValue(VarbitID.IRONMAN) != 2) {
      createMysteryGrave();
      updateStorages(Collections.singletonList(grave));
      return;
    }

    createMysteryDeathbank(deathbankType);
    updateStorages(Collections.singletonList(deathbank));
  }

  private boolean checkItemsLostOnDeathWindow() {
    if (deathbank == null) {
      Widget deathbankTextWidget = client.getWidget(4, 3);
      if (deathbankTextWidget != null) {
        Widget textWidget = deathbankTextWidget.getChild(3);
        if (textWidget != null) {
          String deathbankText = Text.removeTags(textWidget.getText()).replace(" ", "");

          // check for unsafe death message
          //noinspection SpellCheckingInspection
          if (deathbankText.contains("theywillbedeleted")) {
            DeathbankType type =
                Arrays.stream(DeathbankType.values())
                    .filter(
                        t ->
                            t.getDeathWindowLocationText() != null
                                && deathbankText.contains(t.getDeathWindowLocationText()))
                    .findFirst()
                    .orElse(DeathbankType.UNKNOWN);

            createMysteryDeathbank(type);

            return true;
          }
        }
      }
    }

    return false;
  }

  private void createMysteryGrave() {
    if (grave != null) {
      return;
    }

    grave = new Grave(plugin, null, this, new ArrayList<>());
    storages.add(grave);
    grave.getItems().add(new ItemStack(ItemID.MACRO_QUIZ_MYSTERY_BOX, 1, plugin));

    SwingUtilities.invokeLater(
        () -> {
          grave.createStoragePanel(this);

          plugin.getClientThread().invoke(() -> updateStorages(Collections.singletonList(grave)));
        });
  }

  void createMysteryDeathbank(DeathbankType type) {
    deathbank = new Deathbank(type, plugin, this);
    storages.add(deathbank);
    deathbank.setLastUpdated(System.currentTimeMillis());
    deathbank.setLocked(
        type != DeathbankType.ZULRAH || client.getVarbitValue(VarbitID.IRONMAN) != 2); // not uim
    deathbank.getItems().add(new ItemStack(ItemID.MACRO_QUIZ_MYSTERY_BOX, 1, plugin));

    SwingUtilities.invokeLater(
        () -> {
          deathbank.createStoragePanel(this);

          plugin
              .getClientThread()
              .invoke(() -> updateStorages(Collections.singletonList(deathbank)));
        });
  }

  @Override
  protected void updateStorages(List<? extends DeathStorage> storages) {
    if (!storages.isEmpty()) {
      storages.forEach(
          storage -> {
            if (storage.getStoragePanel() != null) {
              storage.getStoragePanel().refreshItems();
            }
          });

      SwingUtilities.invokeLater(
          () ->
              storages.forEach(
                  storage -> {
                    if (storage.getStoragePanel() != null) {
                      storage.getStoragePanel().update();
                    }
                  }));

      SwingUtilities.invokeLater(storageTabPanel::reorderStoragePanels);
    }
  }

  private void updateWorldMapPoints() {
    if (storages.stream()
        .filter(Deathpile.class::isInstance)
        .map(Deathpile.class::cast)
        .anyMatch(
            deathpile -> {
              if (deathpile.worldMapPoint == null) {
                return !deathpile.hasExpired();
              }
              if (deathpile.hasExpired()) {
                return true;
              }
              if (deathpile.worldMapPoint.getTooltip() == null) {
                return false;
              }

              deathpile.worldMapPoint.setTooltip("Deathpile (" + deathpile.getExpireText() + ")");
              return false;
            })) {
      refreshMapPoints();
    }
  }

  private boolean processDeath() {
    if (client.getLocalPlayer() == null
        || dyingState != DyingState.WAITING_FOR_RESPAWN
        || client.getBoostedSkillLevel(Skill.HITPOINTS) < 10) {
      return false;
    }

    boolean updated = false;

    Region deathPileRegion = Region.get(deathPileArea.toWorldPoint().getRegionID());

    if (!RESPAWN_REGIONS.contains(client.getLocalPlayer().getWorldLocation().getRegionID())) {
      // Player has died but is still safe unless their team dies
      if (deathPileRegion == Region.RAIDS_THEATRE_OF_BLOOD) {
        return false;
      }

      log.info(
          "Died, but did not respawn in a known respawn location: "
              + client.getLocalPlayer().getWorldLocation().getRegionID());
    } else if (!SAFE_DEATH_REGIONS.contains(deathPileRegion)) {
      updated = true;
      registerDeath(deathPileRegion);
    }

    dyingState = DyingState.NOT_DYING;
    deathPileArea = null;
    deathItems = null;

    return updated;
  }

  private void registerDeath(Region deathRegion) {
    clearDeathbank(true);

    // Don't create deathpiles/graves for gauntlet deaths
    if (deathRegion == Region.MG_CORRUPTED_GAUNTLET || deathRegion == Region.MG_GAUNTLET) {
      return;
    }

    clearCarryableStorage();

    // Remove any items that were kept on death from the death items
    Stream.of(InventoryID.INV, InventoryID.WORN)
        .map(id -> client.getItemContainer(id))
        .filter(Objects::nonNull)
        .forEach(i -> removeItemsFromList(deathItems, i.getItems()));

    Optional<DeathbankType> deathbankType = getDeathbankType(deathRegion);
    if (deathbankType.isPresent()) {
      deathbank = new Deathbank(deathbankType.get(), plugin, this);
      storages.add(deathbank);
      SwingUtilities.invokeLater(() -> deathbank.createStoragePanel(this));
      deathbank.setLastUpdated(System.currentTimeMillis());
      deathbank.setLocked(
          deathbankType.get() != DeathbankType.ZULRAH
              || client.getVarbitValue(VarbitID.IRONMAN) != 2); // not uim
      deathbank.getItems().addAll(deathItems);
    } else if (client.getVarbitValue(VarbitID.IRONMAN) == 2) { // uim
      createDeathpile(deathPileArea, deathItems);
    } else {
      createGrave(deathPileArea, deathItems);
    }

    refreshMapPoints();
  }

  private void clearCarryableStorage() {
    coinsStorageManager.getStorages().stream()
        .filter(s -> s.getType() == CoinsStorageType.LOOTING_BAG)
        .forEach(
            s -> {
              s.getCoinStack().setQuantity(0);

              if (s.getStoragePanel() != null) {
                s.getStoragePanel().refreshItems();
                SwingUtilities.invokeLater(() -> s.getStoragePanel().update());
              }
            });
    SwingUtilities.invokeLater(coinsStorageManager.getStorageTabPanel()::reorderStoragePanels);

    carryableStorageManager.getStorages().stream()
        .filter(
            s ->
                s.getType() == CarryableStorageType.LOOTING_BAG
                    || (s.getType().getEmptyOnDeathVarbit() != -1
                        && client.getVarbitValue(s.getType().getEmptyOnDeathVarbit()) == 1))
        .forEach(
            s -> {
              s.getItems().clear();
              if (s.getStoragePanel() != null) {
                s.getStoragePanel().refreshItems();
                SwingUtilities.invokeLater(() -> s.getStoragePanel().update());
              }
            });
    SwingUtilities.invokeLater(carryableStorageManager.getStorageTabPanel()::reorderStoragePanels);
  }

  Deathpile createDeathpile(WorldArea area, List<ItemStack> items) {
    boolean useAccountPlayTime = deathpilesUseAccountPlayTime();
    Deathpile deathpile = new Deathpile(plugin, useAccountPlayTime, area, this, items);
    SwingUtilities.invokeLater(() -> deathpile.createStoragePanel(this));
    storages.add(deathpile);

    return deathpile;
  }

  Grave createGrave(WorldArea area, List<ItemStack> items) {
    // If the player already has a grave, their items get added to it and the timer restarts
    if (grave != null) {
      grave.getItems().addAll(items);
      updateStorages(Collections.singletonList(grave));

      return grave;
    }

    grave = new Grave(plugin, area, this, items);
    SwingUtilities.invokeLater(() -> grave.createStoragePanel(this));
    storages.add(grave);

    return grave;
  }

  private Optional<DeathbankType> getDeathbankType(Region deathRegion) {
    if (deathRegion == null) {
      return Optional.empty();
    }

    if (deathRegion == Region.BOSS_VORKATH) {
      return Optional.of(
          Quest.DRAGON_SLAYER_II.getState(client) == QuestState.IN_PROGRESS
              ? DeathbankType.QUEST_DS2
              : DeathbankType.VORKATH);
    } else if (deathRegion == Region.BOSS_NIGHTMARE) {
      // TODO: work out how to differentiate between nightmare and phosani's
      return Optional.of(DeathbankType.NIGHTMARE);
    }

    return Arrays.stream(DeathbankType.values())
        .filter(s -> s.getRegion() == deathRegion)
        .findFirst();
  }

  @Override
  public void onActorDeath(ActorDeath actorDeath) {
    if (client.getLocalPlayer() == null
        || actorDeath.getActor() != client.getLocalPlayer()
        || entryModeTob == 2) {
      return;
    }

    dyingState = DyingState.TICK_1;
  }

  @Override
  public void onMenuOptionClicked(MenuOptionClicked menuOption) {
    if (menuOption.getMenuAction() != MenuAction.GROUND_ITEM_THIRD_OPTION
        && menuOption.getMenuAction() != MenuAction.WIDGET_TARGET_ON_GROUND_ITEM) {
      return;
    }

    var worldView = client.getTopLevelWorldView();
    if (worldView == null) {
      return;
    }

    var worldPoint =
        WorldPoint.fromScene(
            worldView, menuOption.getParam0(), menuOption.getParam1(), worldView.getPlane());
    getDeathpiles()
        .filter(deathpile -> !deathpile.hasExpired() && deathpile.getWorldPoint() != null)
        .filter(deathpile -> deathpile.getWorldPoint().equals(worldPoint))
        .findFirst()
        .ifPresent(
            (dp) -> {
              var suspendedGroundItem = new SuspendedGroundItem(menuOption.getId(), worldPoint);
              suspendedGroundItem.setTicksLeft(100);

              for (SuspendedGroundItem i : itemsPickedUp) {
                if (i.getTicksLeft() > 2) {
                  i.setTicksLeft(2);
                }
              }

              itemsPickedUp.add(suspendedGroundItem);
            });
  }

  @Override
  public void onItemDespawned(ItemDespawned itemDespawned) {
    var worldPoint = itemDespawned.getTile().getWorldLocation();
    var despawnedItem = itemDespawned.getItem();

    if (itemsPickedUp.stream()
        .noneMatch(
            i -> i.getWorldPoint().equals(worldPoint) && i.getId() == despawnedItem.getId())) {
      return;
    }

    itemsPickedUp.stream()
        .filter(i -> i.getId() == despawnedItem.getId())
        .forEach(i -> {
          if (i.getTicksLeft() > 2) {
            i.setTicksLeft(2);
          }
        });

    var updatedDeathpiles = removeFromDeathpiles(despawnedItem, worldPoint);
    if (updatedDeathpiles.isEmpty()) {
      return;
    }

    var iterator = updatedDeathpiles.listIterator();
    while (iterator.hasNext()) {
      var deathpile = iterator.next();

      if (deathpile.getItems().isEmpty()) {
        deathpile.deleteData(this);
        storages.remove(deathpile);
        iterator.remove();
      }
    }

    if (updatedDeathpiles.isEmpty()) {
      SwingUtilities.invokeLater(storageTabPanel::reorderStoragePanels);
    } else {
      updateStorages(updatedDeathpiles);
    }
  }

  /**
   * Removes the specified TileItem from all deathpiles on the specified WorldPoint.
   *
   * @param item the TileItem to remove from the deathpiles
   * @param worldPoint the WorldPoint that the deathpiles must be on
   * @return a list of deathpiles that were affected
   */
  private List<Deathpile> removeFromDeathpiles(TileItem item, WorldPoint worldPoint) {
    AtomicLong quantityToRemove = new AtomicLong(item.getQuantity());
    if (quantityToRemove.get() == 65535) {
      quantityToRemove.set(Long.MAX_VALUE);
    }

    return getDeathpiles()
        .filter(deathpile -> !deathpile.hasExpired() && deathpile.getWorldPoint() != null)
        .filter(deathpile -> deathpile.getWorldPoint().equals(worldPoint))
        .filter(
            deathpile -> {
              long itemsRemoved = deathpile.remove(item.getId(), quantityToRemove.get());
              quantityToRemove.addAndGet(-itemsRemoved);

              return itemsRemoved > 0;
            })
        .collect(Collectors.toList());
  }

  @Override
  public String getConfigKey() {
    return "death";
  }

  int getPlayedMinutes() {
    if (isPreviewManager) {
      return startPlayedMinutes;
    }

    return (int) (startPlayedMinutes + ((System.currentTimeMillis() - startMs) / 60000));
  }

  List<ItemStack> getDeathItems() {
    List<ItemStack> itemStacks =
        carryableStorageManager.getStorages().stream()
            .filter(
                s ->
                    s.getType() == CarryableStorageType.INVENTORY
                        || s.getType() == CarryableStorageType.EQUIPMENT)
            .sorted(
                Comparator.comparingInt(s -> s.getType() == CarryableStorageType.INVENTORY ? 0 : 1))
            .flatMap(s -> s.getItems().stream())
            .collect(Collectors.toList());

    return ItemStackUtils.compound(
        ItemStackUtils.filterDestroyedOnDeath(
                ItemStackUtils.explodeStorageItems(itemStacks, carryableStorageManager))
            .stream()
            .filter(i -> i.getId() != -1 && i.getQuantity() > 0)
            .collect(Collectors.toList()),
        false);
  }

  @Override
  public void load(String profileKey) {
    if (!enabled) {
      return;
    }

    loadDeathpiles(profileKey);
    loadGraves(profileKey);
    loadDeathbanks(profileKey);
    deathsOffice.load(configManager, getConfigKey(), profileKey);
  }

  @Override
  public void reset() {
    storages.removeIf(s -> s instanceof ExpiringDeathStorage || s instanceof Deathbank);
    deathbank = null;
    enable();
    refreshMapPoints();
  }

  void refreshMapPoints() {
    if (worldMapPointManager == null || isPreviewManager) {
      return;
    }

    worldMapPointManager.removeIf(DeathWorldMapPoint.class::isInstance);

    AtomicInteger index = new AtomicInteger(1);
    storages.stream()
        .filter(Deathpile.class::isInstance)
        .map(Deathpile.class::cast)
        .filter(deathpile -> !deathpile.hasExpired())
        .forEach(
            deathpile -> {
              var worldPoint =
                  deathpile.getWorldPoint() != null
                      ? deathpile.getWorldPoint()
                      : deathpile.getWorldArea().toWorldPoint();
              deathpile.worldMapPoint =
                  new DeathWorldMapPoint(worldPoint, itemManager, index.getAndIncrement());
              worldMapPointManager.add(deathpile.getWorldMapPoint());
            });
  }

  private void loadDeathpiles(String profileKey) {
    for (String configurationKey :
        configManager.getRSProfileConfigurationKeys(
            DudeWheresMyStuffConfig.CONFIG_GROUP,
            profileKey,
            getConfigKey() + "." + DeathStorageType.DEATHPILE.getConfigKey() + ".")) {
      Deathpile deathpile =
          Deathpile.load(plugin, this, profileKey, configurationKey.split("\\.")[2]);
      SwingUtilities.invokeLater(
          () -> {
            deathpile.createStoragePanel(this);

            if (deathpile.getStoragePanel() != null) {
              plugin
                  .getClientThread()
                  .invoke(
                      () -> {
                        deathpile.getStoragePanel().refreshItems();
                        SwingUtilities.invokeLater(() -> deathpile.getStoragePanel().update());
                      });
            }
          });
      storages.add(deathpile);
    }

    refreshMapPoints();
  }

  private void loadGraves(String profileKey) {
    for (String configurationKey :
        configManager.getRSProfileConfigurationKeys(
            DudeWheresMyStuffConfig.CONFIG_GROUP,
            profileKey,
            getConfigKey() + "." + DeathStorageType.GRAVE.getConfigKey() + ".")) {
      Grave loadedGrave = Grave.load(plugin, this, profileKey, configurationKey.split("\\.")[2]);
      SwingUtilities.invokeLater(
          () -> {
            loadedGrave.createStoragePanel(this);

            if (loadedGrave.getStoragePanel() != null) {
              plugin
                  .getClientThread()
                  .invoke(
                      () -> {
                        loadedGrave.getStoragePanel().refreshItems();
                        SwingUtilities.invokeLater(() -> loadedGrave.getStoragePanel().update());
                      });
            }
          });
      if (!loadedGrave.hasExpired()) {
        if (grave != null) {
          if (grave.getExpiryMs() < loadedGrave.getExpiryMs()) {
            grave.expire();
            grave = loadedGrave;
          } else {
            loadedGrave.expire();
          }
        } else {
          grave = loadedGrave;
        }
      }
      storages.add(loadedGrave);
    }

    refreshMapPoints();
  }

  private void loadDeathbanks(String profileKey) {
    for (String configurationKey :
        configManager.getRSProfileConfigurationKeys(
            DudeWheresMyStuffConfig.CONFIG_GROUP,
            profileKey,
            getConfigKey() + "." + DeathStorageType.DEATHBANK.getConfigKey() + ".")) {
      Deathbank loadedDeathbank =
          Deathbank.load(plugin, this, profileKey, configurationKey.split("\\.")[2]);

      if (loadedDeathbank == null) {
        continue;
      }

      SwingUtilities.invokeLater(() -> loadedDeathbank.createStoragePanel(this));
      if (loadedDeathbank.isActive()) {
        if (deathbank != null) {
          if (deathbank.getLastUpdated() <= loadedDeathbank.getLastUpdated()) {
            deathbank.setLostAt(System.currentTimeMillis());
            deathbank = loadedDeathbank;
          } else {
            loadedDeathbank.setLostAt(System.currentTimeMillis());
          }
        } else {
          deathbank = loadedDeathbank;
        }
      }
      storages.add(loadedDeathbank);
    }
  }

  private boolean deathpilesUseAccountPlayTime() {
    return plugin.getConfig().deathpilesUseAccountPlayTime() && startPlayedMinutes != 0;
  }

  /**
   * Deletes deathpiles/graves from the plugin.
   *
   * @param includeActive if true, even non-expired deathpiles/graves will be deleted.
   */
  public void deleteExpiringDeathStorages(boolean includeActive) {
    Iterator<DeathStorage> iterator = storages.iterator();
    while (iterator.hasNext()) {
      DeathStorage storage = iterator.next();
      if (!(storage instanceof Deathpile || storage instanceof Grave)
          || (!includeActive && !((ExpiringDeathStorage) storage).hasExpired())) {
        continue;
      }

      iterator.remove();
      storage.deleteData(this);
    }
    SwingUtilities.invokeLater(storageTabPanel::reorderStoragePanels);
  }

  /**
   * Deletes deathbanks from the plugin.
   *
   * @param includeActive if true, even non-lost deathbanks will be deleted.
   */
  public void deleteDeathbanks(boolean includeActive) {
    Iterator<DeathStorage> iterator = storages.iterator();
    while (iterator.hasNext()) {
      DeathStorage storage = iterator.next();
      if (!(storage instanceof Deathbank) || (!includeActive && ((Deathbank) storage).isActive())) {
        continue;
      }

      iterator.remove();
      storage.deleteData(this);
    }
    SwingUtilities.invokeLater(storageTabPanel::reorderStoragePanels);
  }

  void deleteStorage(ExpiringDeathStorage expiringDeathStorage) {
    storages.remove(expiringDeathStorage);
    refreshMapPoints();
    SwingUtilities.invokeLater(() -> getStorageTabPanel().reorderStoragePanels());
    expiringDeathStorage.deleteData(this);

    if (expiringDeathStorage instanceof Grave && expiringDeathStorage == grave) {
      grave = null;
    }
  }

  public void refreshDeathpileColors() {
    getDeathpiles().forEach(Deathpile::refreshColor);
  }
}

package dev.thource.runelite.dudewheresmystuff.death;

enum DeathpileColorSchemeType {
  FULL_COLOR,
  PASTEL,
  GRAYSCALE,
  REDSCALE,
  GREENSCALE,
  BLUESCALE,
  MAGMA,
  INFERNO,
  PLASMA,
  VIRIDIS,
  WHITE,
  YELLOW
}

package dev.thource.runelite.dudewheresmystuff.death;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.DurationFormatter;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Region;
import dev.thource.runelite.dudewheresmystuff.SaveFieldFormatter;
import dev.thource.runelite.dudewheresmystuff.SaveFieldLoader;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.util.ImageUtil;

public abstract class ExpiringDeathStorage extends DeathStorage {

  private static final ImageIcon WARNING_ICON =
      new ImageIcon(ImageUtil.loadImageResource(DudeWheresMyStuffPlugin.class, "warning.png"));
  @Getter protected final DeathStorageManager deathStorageManager;
  @Getter protected WorldPoint worldPoint;
  @Getter protected WorldArea worldArea;
  @Getter @Setter protected int expiryTime;
  protected long expiredAt = -1L;
  @Getter @Setter protected DeathWorldMapPoint worldMapPoint;
  @Getter protected Color color = Color.WHITE;
  protected UUID uuid = UUID.randomUUID();
  // when useAccountPlayTime is true, expiryTime is the account played minutes that the
  // deathpile will expire at.
  // when useAccountPlayTime is false, expiryTime is the amount of ticks left until
  // the deathpile expires, ticking down only while the player is logged in.
  //
  // This is unused for graves, because grave timers are 100% accurate and provided by jagex
  @Getter private boolean useAccountPlayTime;

  ExpiringDeathStorage(
      DudeWheresMyStuffPlugin plugin,
      boolean useAccountPlayTime,
      WorldArea worldArea,
      DeathStorageManager deathStorageManager,
      List<ItemStack> deathItems,
      DeathStorageType storageType) {
    super(storageType, plugin);
    this.useAccountPlayTime = useAccountPlayTime;
    if (worldArea != null && worldArea.getWidth() == 1 && worldArea.getHeight() == 1) {
      this.worldPoint = worldArea.toWorldPoint();
    } else {
      this.worldArea = worldArea;
    }
    this.deathStorageManager = deathStorageManager;
    this.items.addAll(deathItems);

    int duration = getTotalLifeInMinutes();
    if (this instanceof Deathpile) {
      duration -= plugin.getConfig().deathpileContingencyMinutes();
    } else {
      duration -= 1;
    }
    this.expiryTime =
        useAccountPlayTime ? deathStorageManager.getPlayedMinutes() + duration : duration * 100;
  }

  @Override
  protected String getConfigKey(String managerConfigKey) {
    return super.getConfigKey(managerConfigKey) + "." + uuid;
  }

  @Override
  protected ArrayList<String> getSaveValues() {
    ArrayList<String> saveValues = super.getSaveValues();

    saveValues.add(SaveFieldFormatter.format(uuid));
    if (worldPoint != null) {
      saveValues.add(SaveFieldFormatter.format(worldPoint));
    } else {
      saveValues.add(SaveFieldFormatter.format(worldArea));
    }
    saveValues.add(SaveFieldFormatter.format(useAccountPlayTime));
    saveValues.add(SaveFieldFormatter.format(expiryTime));
    saveValues.add(SaveFieldFormatter.format(expiredAt));

    return saveValues;
  }

  @Override
  protected void loadValues(ArrayList<String> values) {
    super.loadValues(values);

    uuid = SaveFieldLoader.loadUUID(values, uuid);
    var point = SaveFieldLoader.loadWorldPoint(values, null);
    if (point != null) {
      worldPoint = point;
    } else {
      worldArea = SaveFieldLoader.loadWorldArea(values, null);
    }
    useAccountPlayTime = SaveFieldLoader.loadBoolean(values, useAccountPlayTime);
    expiryTime = SaveFieldLoader.loadInt(values, expiryTime);
    expiredAt = SaveFieldLoader.loadLong(values, expiredAt);
  }

  @Override
  protected void createStoragePanel(StorageManager<?, ?> storageManager) {
    super.createStoragePanel(storageManager);
    assert storagePanel != null;

    setSubTitle();

    JLabel footerLabel = storagePanel.getFooterLabel();
    if (hasExpired()) {
      if (!useAccountPlayTime) {
        footerLabel.setIconTextGap(66);
        footerLabel.setHorizontalTextPosition(SwingConstants.LEFT);
        footerLabel.setIcon(WARNING_ICON);
        footerLabel.setToolTipText(
            "This "
                + this.getName().toLowerCase()
                + " is using tick-based tracking, which means "
                + "that the timer could be out of sync. To use the more accurate play time based "
                + "timers, enable cross-client timers in the plugin settings.");
      } else if (deathStorageManager.getStartPlayedMinutes() <= 0) {
        footerLabel.setToolTipText(
            "This "
                + this.getName().toLowerCase()
                + " is using play time based tracking, but the "
                + "plugin doesn't know what your current play time is. To update your play time, "
                + "swap the quest interface to the \"Character summary\" tab (brown star).");
      }
    }

    createComponentPopupMenu(storageManager);
  }

  protected void setSubTitle() {
    if (storagePanel == null) {
      return;
    }

    var region = getRegion();
    if (region == null) {
      storagePanel.setSubTitle("Unknown");
    } else {
      storagePanel.setSubTitle(region.getName());
    }
  }

  public Region getRegion() {
    if (worldPoint == null && worldArea == null) {
      return null;
    }

    return Region.get((worldPoint != null ? worldPoint : worldArea.toWorldPoint()).getRegionID());
  }

  @Override
  protected void createComponentPopupMenu(StorageManager<?, ?> storageManager) {
    if (storagePanel == null) {
      return;
    }

    final JPopupMenu popupMenu = new JPopupMenu();
    popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
    storagePanel.setComponentPopupMenu(popupMenu);

    final JMenuItem delete = new JMenuItem("Delete " + this.getName());
    delete.addActionListener(
        e -> {
          boolean confirmed =
              hasExpired()
                  || DudeWheresMyStuffPlugin.getConfirmation(
                      storagePanel,
                      "Are you sure you want to delete this "
                          + this.getName().toLowerCase()
                          + "?\nThis cannot be undone.",
                      "Confirm deletion");

          if (confirmed) {
            deathStorageManager.deleteStorage(this);
          }
        });
    popupMenu.add(delete);

    createDebugMenuOptions(storageManager, popupMenu);
  }

  private void createDebugMenuOptions(StorageManager<?, ?> storageManager, JPopupMenu popupMenu) {
    if (plugin.isDeveloperMode()) {
      JMenu debugMenu = new JMenu("Debug");
      popupMenu.add(debugMenu);

      JMenuItem setExpiresIn = new JMenuItem("Set expires in");
      debugMenu.add(setExpiresIn);
      setExpiresIn.addActionListener(
          e -> {
            int minutes = 0;
            try {
              minutes =
                  Integer.parseInt(JOptionPane.showInputDialog("Enter expiry in minutes from now"));
            } catch (NumberFormatException nfe) {
              // Do nothing
            }

            if (minutes <= 0) {
              return;
            }

            if (useAccountPlayTime) {
              expiryTime = deathStorageManager.getPlayedMinutes() + minutes;
            } else {
              expiryTime = minutes * 100;
            }
            expiredAt = -1L;
            softUpdate();
            storageManager.getStorageTabPanel().reorderStoragePanels();
          });

      JMenuItem expire = new JMenuItem("Expire");
      debugMenu.add(expire);
      expire.addActionListener(
          e -> {
            expiredAt = -1L;
            expiryTime = 0;
            softUpdate();
            storageManager.getStorageTabPanel().reorderStoragePanels();
          });
    }
  }

  @Override
  public boolean onGameTick() {
    if (expiredAt != -1L) {
      return false;
    }

    if (!useAccountPlayTime) {
      expiryTime--;
      if (expiryTime <= 0) {
        expiredAt = System.currentTimeMillis();

        SwingUtilities.invokeLater(
            () -> {
              if (storagePanel == null) {
                return;
              }

              JLabel footerLabel = storagePanel.getFooterLabel();
              footerLabel.setIcon(null);
              footerLabel.setToolTipText(null);
            });
      }

      return true;
    }

    if (deathStorageManager.getStartPlayedMinutes() > 0
        && deathStorageManager.getPlayedMinutes() >= expiryTime) {
      expiredAt = System.currentTimeMillis();

      return true;
    }

    return false;
  }

  @Override
  public void reset() {
    // these get removed instead of reset
  }

  String getExpireText() {
    if (expiredAt != -1L) {
      return "Expired " + DurationFormatter.format(System.currentTimeMillis() - expiredAt) + " ago";
    }

    if (useAccountPlayTime && deathStorageManager.getStartPlayedMinutes() <= 0) {
      return "Waiting for play time";
    }

    return "Expires in " + DurationFormatter.format(getExpiryMs() - System.currentTimeMillis());
  }

  public abstract int getTotalLifeInMinutes();

  /**
   * Returns a unix timestamp of the expiry.
   *
   * <p>If previewMode is true, this will change so that it is static when displayed.
   *
   * @return Unix timestamp of the expiry
   */
  public long getExpiryMs() {
    if (expiredAt != -1L) {
      return expiredAt;
    }

    if (!useAccountPlayTime) {
      return System.currentTimeMillis() + (expiryTime * 600L);
    }

    // We don't know the player's play time yet, so assume the storage is fresh for sorting purposes
    if (deathStorageManager.getStartPlayedMinutes() <= 0) {
      return System.currentTimeMillis() + getTotalLifeInMinutes() * 60_000L;
    }

    int minutesLeft = expiryTime - deathStorageManager.getPlayedMinutes();
    if (deathStorageManager.isPreviewManager()) {
      return System.currentTimeMillis() + (minutesLeft * 60000L);
    }

    return System.currentTimeMillis()
        + (minutesLeft * 60000L)
        - ((System.currentTimeMillis() - deathStorageManager.startMs) % 60000);
  }

  public boolean hasExpired() {
    return getExpiryMs() < System.currentTimeMillis();
  }

  @Override
  public void softUpdate() {
    if (storagePanel == null) {
      return;
    }

    storagePanel.setFooterText(getExpireText());
  }

  @Override
  public boolean isWithdrawable() {
    return super.isWithdrawable() && !hasExpired();
  }
}

package dev.thource.runelite.dudewheresmystuff;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import javax.swing.JLabel;
import lombok.Setter;
import net.runelite.client.plugins.itemidentification.ItemIdentificationMode;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.components.TextComponent;

class ItemImageLabel extends JLabel {

  @Setter private transient ItemStack itemStack;
  private final transient DudeWheresMyStuffPlugin plugin;

  public ItemImageLabel(DudeWheresMyStuffPlugin plugin) {
    this.plugin = plugin;
  }

  @Override
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);

    if (itemStack == null) {
      return;
    }

    if (itemStack.getSpriteId() != -1) {
      final TextComponent quantityText = new TextComponent();
      quantityText.setPosition(new Point(0, 10));
      quantityText.setFont(FontManager.getRunescapeSmallFont());
      quantityText.setColor(Color.YELLOW);
      quantityText.setText(String.valueOf(itemStack.getQuantity()));
      quantityText.render((Graphics2D) g);
    }

    if (itemStack.getItemIdentification() == null
        || !plugin.getPluginManager().isPluginEnabled(plugin.getItemIdentificationPlugin())
        || !itemStack
        .getItemIdentification()
        .type
        .enabled
        .test(plugin.getItemIdentificationConfig())) {
      return;
    }

    final TextComponent textComponent = new TextComponent();
    textComponent.setPosition(new Point(-1, getHeight() - 1));
    textComponent.setFont(FontManager.getRunescapeSmallFont());
    textComponent.setColor(plugin.getItemIdentificationConfig().textColor());
    ItemIdentificationMode itemIdentificationMode =
        plugin.getItemIdentificationConfig().identificationType();
    if (itemIdentificationMode == ItemIdentificationMode.SHORT) {
      textComponent.setText(itemStack.getItemIdentification().shortName);
    } else if (itemIdentificationMode == ItemIdentificationMode.MEDIUM) {
      textComponent.setText(itemStack.getItemIdentification().medName);
    }
    textComponent.render((Graphics2D) g);
  }
}

package dev.thource.runelite.dudewheresmystuff;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Rectangle;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JViewport;
import javax.swing.Scrollable;
import javax.swing.SwingConstants;

class ScrollableContainer extends JPanel implements Scrollable {

  private final JPanel content;

  public ScrollableContainer(JPanel content) {
    super(new BorderLayout());
    this.content = content;
    add(content);
  }

  @Override
  public Dimension getPreferredScrollableViewportSize() {
    Dimension preferredSize = content.getPreferredSize();
    if (getParent() instanceof JViewport) {
      preferredSize.width +=
          ((JScrollPane) getParent().getParent()).getVerticalScrollBar().getPreferredSize().width;
    }
    return preferredSize;
  }

  @Override
  public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction) {
    return orientation == SwingConstants.HORIZONTAL
        ? Math.max(visibleRect.width * 9 / 10, 1)
        : Math.max(visibleRect.height * 9 / 10, 1);
  }

  @Override
  public boolean getScrollableTracksViewportHeight() {
    if (getParent() instanceof JViewport) {
      JViewport viewport = (JViewport) getParent();
      return getPreferredSize().height < viewport.getHeight();
    }
    return false;
  }

  @Override
  public boolean getScrollableTracksViewportWidth() {
    return true;
  }

  @Override
  public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction) {
    return orientation == SwingConstants.HORIZONTAL
        ? Math.max(visibleRect.width / 10, 1)
        : Math.max(visibleRect.height / 10, 1);
  }
}

package dev.thource.runelite.dudewheresmystuff.playerownedhouse;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.StorageTabPanel;

/** PlayerOwnedHouseStorageTabPanel is responsible for displaying POH storage data to the player. */
public class PlayerOwnedHouseStorageTabPanel
    extends StorageTabPanel<
    PlayerOwnedHouseStorageType, PlayerOwnedHouseStorage, PlayerOwnedHouseStorageManager> {

  public PlayerOwnedHouseStorageTabPanel(
      DudeWheresMyStuffPlugin plugin, PlayerOwnedHouseStorageManager storageManager) {
    super(plugin, storageManager);
  }
}

package dev.thource.runelite.dudewheresmystuff.playerownedhouse;

import com.google.inject.Inject;
import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.Region;
import dev.thource.runelite.dudewheresmystuff.StorageManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;

/** PlayerOwnedHouseStorageManager is responsible for managing all PlayerOwnedHouseStorages. */
@Slf4j
public class PlayerOwnedHouseStorageManager
    extends StorageManager<PlayerOwnedHouseStorageType, PlayerOwnedHouseStorage> {

  @Inject
  private PlayerOwnedHouseStorageManager(DudeWheresMyStuffPlugin plugin) {
    super(plugin);

    for (PlayerOwnedHouseStorageType type : PlayerOwnedHouseStorageType.values()) {
      if (type == PlayerOwnedHouseStorageType.MENAGERIE
          || type == PlayerOwnedHouseStorageType.CAPE_HANGER) {
        continue;
      }

      storages.add(new PlayerOwnedHouseStorage(type, plugin));
    }

    storages.add(new CapeHanger(plugin));
    storages.add(new Menagerie(plugin));
    storages.add(new SpiceRack(plugin));
  }

  private boolean notInHouse() {
    if (client.getLocalPlayer() == null) {
      return true;
    }

    WorldPoint worldPoint = WorldPoint.fromLocalInstance(client,
        client.getLocalPlayer().getLocalLocation());
    return Region.get(worldPoint.getRegionID()) != Region.REGION_POH;
  }

  @Override
  public void onChatMessage(ChatMessage chatMessage) {
    if (notInHouse()) {
      return;
    }

    super.onChatMessage(chatMessage);
  }

  @Override
  public void onActorDeath(ActorDeath actorDeath) {
    if (notInHouse()) {
      return;
    }

    super.onActorDeath(actorDeath);
  }

  @Override
  public void onGameObjectSpawned(GameObjectSpawned gameObjectSpawned) {
    if (notInHouse()) {
      return;
    }

    super.onGameObjectSpawned(gameObjectSpawned);
  }

  @Override
  public void onGameStateChanged(GameStateChanged gameStateChanged) {
    if (notInHouse()) {
      return;
    }

    super.onGameStateChanged(gameStateChanged);
  }

  @Override
  public void onGameTick() {
    if (notInHouse()) {
      return;
    }

    super.onGameTick();
  }

  @Override
  public void onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
    if (notInHouse()) {
      return;
    }

    super.onItemContainerChanged(itemContainerChanged);
  }

  @Override
  public void onItemDespawned(ItemDespawned itemDespawned) {
    if (notInHouse()) {
      return;
    }

    super.onItemDespawned(itemDespawned);
  }

  @Override
  public void onMenuOptionClicked(MenuOptionClicked menuOption) {
    if (notInHouse()) {
      return;
    }

    super.onMenuOptionClicked(menuOption);
  }

  @Override
  public void onVarbitChanged(VarbitChanged varbitChanged) {
    if (notInHouse()) {
      return;
    }

    super.onVarbitChanged(varbitChanged);
  }

  @Override
  public void onWidgetClosed(WidgetClosed widgetClosed) {
    if (notInHouse()) {
      return;
    }

    super.onWidgetClosed(widgetClosed);
  }

  @Override
  public void onWidgetLoaded(WidgetLoaded widgetLoaded) {
    if (notInHouse()) {
      return;
    }

    super.onWidgetLoaded(widgetLoaded);
  }

  @Override
  public String getConfigKey() {
    return "poh";
  }
}

package dev.thource.runelite.dudewheresmystuff.playerownedhouse;

import com.google.common.collect.ImmutableList;
import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemContainerWatcher;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.Region;
import dev.thource.runelite.dudewheresmystuff.SaveFieldFormatter;
import dev.thource.runelite.dudewheresmystuff.SaveFieldLoader;
import dev.thource.runelite.dudewheresmystuff.Var;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.ListIterator;
import net.runelite.api.Item;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.client.config.ConfigManager;

/** Menagerie is responsible for tracking which pets the player has in their POH menagerie. */
public class Menagerie extends PlayerOwnedHouseStorage {

  private static final List<Integer> ITEM_CONTAINER_ITEM_IDS =
      Arrays.asList(
          ItemID.VT_USELESS_ROCK,
          ItemID.KITTENOBJECT,
          ItemID.KITTENOBJECT_LIGHT,
          ItemID.KITTENOBJECT_BROWN,
          ItemID.KITTENOBJECT_BLACK,
          ItemID.KITTENOBJECT_BROWNGREY,
          ItemID.KITTENOBJECT_BLUEGREY,
          ItemID.GROWNCATOBJECT,
          ItemID.GROWNCATOBJECT_LIGHT,
          ItemID.GROWNCATOBJECT_BROWN,
          ItemID.GROWNCATOBJECT_BLACK,
          ItemID.GROWNCATOBJECT_BROWNGREY,
          ItemID.GROWNCATOBJECT_BLUEGREY,
          ItemID.OVERGROWNCATOBJECT,
          ItemID.OVERGROWNCATOBJECT_LIGHT,
          ItemID.OVERGROWNCATOBJECT_BROWN,
          ItemID.OVERGROWNCATOBJECT_BLACK,
          ItemID.OVERGROWNCATOBJECT_BROWNGREY,
          ItemID.OVERGROWNCATOBJECT_BLUEGREY,
          ItemID.WILEYCATOBJECT_LIGHT,
          ItemID.WILEYCATOBJECT,
          ItemID.WILEYCATOBJECT_BROWN,
          ItemID.WILEYCATOBJECT_BLACK,
          ItemID.WILEYCATOBJECT_BROWNGREY,
          ItemID.WILEYCATOBJECT_BLUEGREY,
          ItemID.LAZYCATOBJECT_LIGHT,
          ItemID.LAZYCATOBJECT,
          ItemID.LAZYCATOBJECT_BROWN,
          ItemID.LAZYCATOBJECT_BLACK,
          ItemID.LAZYCATOBJECT_BROWNGREY,
          ItemID.LAZYCATOBJECT_BLUEGREY,
          ItemID.KITTENOBJECT_HELL,
          ItemID.GROWNCATOBJECT_HELL,
          ItemID.OVERGROWNCATOBJECT_HELL,
          ItemID.WILEYCATOBJECT_HELL,
          ItemID.LAZYCATOBJECT_HELL,
          ItemID.FISHBOWL_BLUEFISH,
          ItemID.FISHBOWL_GREENFISH,
          ItemID.FISHBOWL_SPINEFISH,
          ItemID.POH_TOY_CAT,
          ItemID.WGS_BROAV);
  public static final List<List<Integer>> VARPLAYER_BITS_TO_ITEM_IDS_LIST;

  static {
    ImmutableList.Builder<List<Integer>> builder = new ImmutableList.Builder<>();

    builder.add(
        Arrays.asList(
            ItemID.CHAOSELEPET,
            ItemID.SUPREMEPET,
            ItemID.PRIMEPET,
            ItemID.REXPET,
            ItemID.PENANCEPET,
            ItemID.ARMADYLPET,
            ItemID.BANDOSPET,
            ItemID.SARADOMINPET,
            ItemID.ZAMORAKPET,
            ItemID.MOLEPET,
            ItemID.KBDPET,
            ItemID.KQPET_WALKING,
            ItemID.SMOKEPET,
            ItemID.KRAKENPET,
            ItemID.COREPET,
            ItemID.SNAKEPET,
            ItemID.CHOMPYBIRD_PET,
            ItemID.VENENATIS_PET,
            ItemID.CALLISTO_PET,
            ItemID.VETION_PET,
            ItemID.SCORPIA_PET,
            ItemID.JAD_PET,
            ItemID.HELL_PET,
            ItemID.ABYSSALSIRE_PET,
            ItemID.SKILLPETFISH,
            ItemID.SKILLPETMINING,
            ItemID.SKILLPETWC,
            ItemID.SKILLPETHUNTER_RED,
            ItemID.BLOODHOUND_PET,
            ItemID.SKILLPETAGILITY,
            ItemID.SKILLPETFARMING,
            ItemID.SKILLPETRUNECRAFTING_FIRE));
    builder.add(
        Arrays.asList(
            ItemID.SKILLPETTHIEVING,
            ItemID.PHOENIXPET,
            ItemID.OLMPET,
            ItemID.SKOTIZOPET,
            ItemID.INFERNOPET,
            ItemID.HERBIBOARPET,
            ItemID.DAWNPET,
            ItemID.VORKATHPET,
            ItemID.VERZIKPET,
            ItemID.HYDRAPET,
            ItemID.SARACHNISPET,
            ItemID.GAUNTLETPET,
            ItemID.ZALCANOPET,
            ItemID.NIGHTMAREPET,
            ItemID.SOULWARSPET_BLUE,
            ItemID.TEMPOROSSPET,
            ItemID.NEXPET,
            ItemID.ABYSSALPET,
            ItemID.WARDENPET_TUMEKEN,
            ItemID.MUSPAHPET,
            ItemID.DUKESUCELLUSPET,
            ItemID.VARDORVISPET,
            ItemID.LEVIATHANPET,
            ItemID.WHISPERERPET,
            ItemID.SCURRIUSPET,
            ItemID.SOLHEREDITPET,
            ItemID.QUETZALPET,
            ItemID.ARAXXORPET,
            ItemID.ARAXXORPET_CUTE,
            ItemID.HUEYPET,
            ItemID.AMOXLIATLPET,
            ItemID.RTBRANDAPET,
            ItemID.RTELDRICPET,
            ItemID.YAMAPET));

    VARPLAYER_BITS_TO_ITEM_IDS_LIST = builder.build();
  }

  private int petBits1;
  private int petBits2;
  private final List<ItemStack> compiledItems = new ArrayList<>();
  private final List<ItemStack> varplayerItems = new ArrayList<>();
  private boolean wasBeingFollowedLastTick = false;

  protected Menagerie(DudeWheresMyStuffPlugin plugin) {
    super(PlayerOwnedHouseStorageType.MENAGERIE, plugin);
  }

  @Override
  protected ArrayList<String> getSaveValues() {
    ArrayList<String> saveValues = super.getSaveValues();

    saveValues.add(SaveFieldFormatter.format(petBits1));
    saveValues.add(SaveFieldFormatter.format(petBits2));

    return saveValues;
  }

  @Override
  protected void loadValues(ArrayList<String> values) {
    super.loadValues(values);

    petBits1 = SaveFieldLoader.loadInt(values, petBits1);
    petBits2 = SaveFieldLoader.loadInt(values, petBits2);
  }

  private void updateItems() {
    compiledItems.clear();
    compiledItems.addAll(items);
    compiledItems.addAll(varplayerItems);
  }

  private boolean updateRemovedInventoryItems() {
    boolean updated = false;
    ItemContainerWatcher inventoryWatcher = ItemContainerWatcher.getInventoryWatcher();

    // Remove items that were added to the inventory
    for (ItemStack itemStack : inventoryWatcher.getItemsAddedLastTick()) {
      if (ITEM_CONTAINER_ITEM_IDS.contains(itemStack.getId())) {
        ListIterator<ItemStack> listIterator = items.listIterator();

        while (listIterator.hasNext()) {
          ItemStack item = listIterator.next();
          if (item.getId() == itemStack.getId()) {
            listIterator.remove();
            updated = true;
            break;
          }
        }
      }
    }

    return updated;
  }

  private boolean updateFromInventoryWatcher(boolean isBeingFollowed) {
    boolean updated = false;
    ItemContainerWatcher inventoryWatcher = ItemContainerWatcher.getInventoryWatcher();

    // Add items that disappeared from the inventory if the player is not being followed or was
    // already being followed last tick (pet not dropped this tick)
    if (!isBeingFollowed || wasBeingFollowedLastTick) {
      for (ItemStack itemStack : inventoryWatcher.getItemsRemovedLastTick()) {
        if (ITEM_CONTAINER_ITEM_IDS.contains(itemStack.getId())) {
          items.add(itemStack);
          updated = true;
        }
      }
    }

    if (updateRemovedInventoryItems()) {
      updated = true;
    }

    return updated;
  }

  @Override
  public boolean onGameTick() {
    WorldPoint worldPoint =
        WorldPoint.fromLocalInstance(
            plugin.getClient(), plugin.getClient().getLocalPlayer().getLocalLocation());

    if (Region.get(worldPoint.getRegionID()) != Region.REGION_POH) {
      return false;
    }

    boolean isBeingFollowed = plugin.getClient().getVarpValue(VarPlayerID.FOLLOWER_NPC) != -1;
    boolean updated = updateFromInventoryWatcher(isBeingFollowed);

    if (updated) {
      updateLastUpdated();
      updateItems();
    }

    wasBeingFollowedLastTick = isBeingFollowed;

    return updated;
  }

  @Override
  public boolean onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
    if (itemContainerChanged.getContainerId() != type.getItemContainerId()) {
      return false;
    }

    updateLastUpdated();
    items.clear();
    for (Item item : itemContainerChanged.getItemContainer().getItems()) {
      if (item.getId() != -1) {
        items.add(new ItemStack(item.getId(), 1, plugin));
      }
    }
    updateItems();

    return true;
  }

  void rebuildPetsFromBits() {
    varplayerItems.clear();
    int varpIndex = 0;
    for (List<Integer> itemIds : VARPLAYER_BITS_TO_ITEM_IDS_LIST) {
      int value = varpIndex == 0 ? petBits1 : petBits2;
      for (int i = 0; i < itemIds.size(); i++) {
        if ((value & (1L << i)) == 0) {
          continue;
        }

        varplayerItems.add(new ItemStack(itemIds.get(i), 1, plugin));
      }

      varpIndex++;
    }

    updateItems();
  }

  @Override
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    var petVar1 = Var.player(varbitChanged, VarPlayerID.PRAYER20);
    var petVar2 = Var.player(varbitChanged, VarPlayerID.MENAGERIE_CONTENTS2);
    if (!petVar1.wasChanged() && !petVar2.wasChanged()) {
      return false;
    }

    final var oldPetBits1 = petBits1;
    final var oldPetBits2 = petBits2;
    var client = plugin.getClient();
    petBits1 = petVar1.getValue(client);
    petBits2 = petVar2.getValue(client);

    if (petBits1 != oldPetBits1 || petBits2 != oldPetBits2) {
      rebuildPetsFromBits();
      updateLastUpdated();
      return true;
    }

    return false;
  }

  @Override
  public List<ItemStack> getItems() {
    return compiledItems;
  }

  @Override
  public void reset() {
    super.reset();

    items.clear();
    compiledItems.clear();
    varplayerItems.clear();
    petBits1 = 0;
    petBits2 = 0;
  }

  @Override
  public void load(ConfigManager configManager, String managerConfigKey, String profileKey) {
    super.load(configManager, managerConfigKey, profileKey);

    rebuildPetsFromBits();
  }
}

package dev.thource.runelite.dudewheresmystuff.playerownedhouse;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemContainerWatcher;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.regex.Pattern;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;

/**
 * SpiceRack is responsible for tracking how many of each spice the player has in their POH spice
 * rack.
 */
public class SpiceRack extends PlayerOwnedHouseStorage {

  @RequiredArgsConstructor
  @Getter
  private static class SpiceData {

    private final int doses;
    private final ItemStack itemStack;
  }

  private static final Pattern CHECK_PATTERN =
      Pattern.compile("(\\d+) x Red Spice.<br>(\\d+) x Brown Spice.<br>(\\d+) x Yellow Spice."
          + "<br>(\\d+) x Orange Spice.");

  private final ItemStack redSpice;
  private final ItemStack brownSpice;
  private final ItemStack yellowSpice;
  private final ItemStack orangeSpice;
  private final Map<Integer, SpiceData> spiceMap = new HashMap<>();

  private State state = State.NONE;

  private enum State {
    NONE,
    WITHDRAWING,
    CHECK_WITHDRAW,
    CHECK_WITHDRAW_TWICE,
    CHECKED_DEPOSIT,
  }

  protected SpiceRack(DudeWheresMyStuffPlugin plugin) {
    super(PlayerOwnedHouseStorageType.SPICE_RACK, plugin);

    hasStaticItems = true;

    redSpice = new ItemStack(ItemID.HUNDRED_DAVE_SPICE_RED_1, plugin);
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_RED_1, new SpiceData(1, redSpice));
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_RED_2, new SpiceData(2, redSpice));
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_RED_3, new SpiceData(3, redSpice));
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_RED_4, new SpiceData(4, redSpice));
    items.add(redSpice);

    brownSpice = new ItemStack(ItemID.HUNDRED_DAVE_SPICE_BROWN_1, plugin);
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_BROWN_1, new SpiceData(1, brownSpice));
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_BROWN_2, new SpiceData(2, brownSpice));
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_BROWN_3, new SpiceData(3, brownSpice));
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_BROWN_4, new SpiceData(4, brownSpice));
    items.add(brownSpice);

    yellowSpice = new ItemStack(ItemID.HUNDRED_DAVE_SPICE_YELLOW_1, plugin);
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_YELLOW_1, new SpiceData(1, yellowSpice));
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_YELLOW_2, new SpiceData(2, yellowSpice));
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_YELLOW_3, new SpiceData(3, yellowSpice));
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_YELLOW_4, new SpiceData(4, yellowSpice));
    items.add(yellowSpice);

    orangeSpice = new ItemStack(ItemID.HUNDRED_DAVE_SPICE_ORANGE_1, plugin);
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_ORANGE_1, new SpiceData(1, orangeSpice));
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_ORANGE_2, new SpiceData(2, orangeSpice));
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_ORANGE_3, new SpiceData(3, orangeSpice));
    spiceMap.put(ItemID.HUNDRED_DAVE_SPICE_ORANGE_4, new SpiceData(4, orangeSpice));
    items.add(orangeSpice);
  }

  @Override
  public boolean onGameTick() {
    var updated = false;

    var client = plugin.getClient();
    var withdrawWidget = client.getWidget(InterfaceID.Chatbox.MES_TEXT);
    if (withdrawWidget != null && !withdrawWidget.isHidden() && Objects.equals(
        withdrawWidget.getText(),
        "How much spice would you like to take?:")) {
      state = State.WITHDRAWING;
    } else if (state == State.WITHDRAWING) {
      state = State.CHECK_WITHDRAW;
    }

    if (state == State.CHECK_WITHDRAW || state == State.CHECK_WITHDRAW_TWICE) {
      for (ItemStack itemStack : ItemContainerWatcher.getInventoryWatcher()
          .getItemsAddedLastTick()) {
        var spiceData = spiceMap.get(itemStack.getId());
        if (spiceData != null) {
          var spiceStack = spiceData.getItemStack();
          spiceStack.setQuantity(
              spiceStack.getQuantity() - spiceData.getDoses() * itemStack.getQuantity());
        }
      }
      updated = true;
      updateLastUpdated();

      if (state == State.CHECK_WITHDRAW) {
        state = State.CHECK_WITHDRAW_TWICE;
      } else {
        state = State.NONE;
      }
    }

    var messageBoxTextWidget = client.getWidget(InterfaceID.Messagebox.TEXT);
    if (messageBoxTextWidget != null && Objects.equals(messageBoxTextWidget.getText(),
        "Your spices have been stored.")) {
      if (state != State.CHECKED_DEPOSIT) {
        for (ItemStack itemStack : ItemContainerWatcher.getInventoryWatcher()
            .getItemsRemovedLastTick()) {
          var spiceData = spiceMap.get(itemStack.getId());
          if (spiceData != null) {
            var spiceStack = spiceData.getItemStack();
            spiceStack.setQuantity(
                spiceStack.getQuantity() + spiceData.getDoses() * itemStack.getQuantity());
          }
        }
        updated = true;
        updateLastUpdated();

        state = State.CHECKED_DEPOSIT;
      }
    } else if (state == State.CHECKED_DEPOSIT) {
      state = State.NONE;
    }

    if (messageBoxTextWidget != null) {
      var checkMatcher = CHECK_PATTERN.matcher(messageBoxTextWidget.getText());
      if (checkMatcher.matches()) {
        var redQuantity = Integer.parseInt(checkMatcher.group(1));
        var brownQuantity = Integer.parseInt(checkMatcher.group(2));
        var yellowQuantity = Integer.parseInt(checkMatcher.group(3));
        var orangeQuantity = Integer.parseInt(checkMatcher.group(4));

        updateLastUpdated();
        if (redQuantity != redSpice.getQuantity() || brownQuantity != brownSpice.getQuantity()
            || yellowQuantity != yellowSpice.getQuantity()
            || orangeQuantity != orangeSpice.getQuantity()) {
          redSpice.setQuantity(redQuantity);
          brownSpice.setQuantity(brownQuantity);
          yellowSpice.setQuantity(yellowQuantity);
          orangeSpice.setQuantity(orangeQuantity);

          updated = true;
        }
      }
    }

    return updated;
  }
}

package dev.thource.runelite.dudewheresmystuff.playerownedhouse;

import com.google.common.collect.ImmutableMap;
import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import java.util.Map;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.ObjectID;

/** CapeHanger is responsible for tracking which cape the player has on their POH cape hanger. */
public class CapeHanger extends PlayerOwnedHouseStorage {

  private static final Map<Integer, Integer[]> objectIdItemIdMap;

  static {
    ImmutableMap.Builder<Integer, Integer[]> builder = new ImmutableMap.Builder<>();

    builder.put(ObjectID.POH_MOUNTED_INFERNAL_CAPE, new Integer[]{ItemID.INFERNAL_CAPE});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE_INFERNALCAPE,
        new Integer[]{ItemID.SKILLCAPE_MAX_INFERNALCAPE,
            ItemID.SKILLCAPE_MAX_HOOD_INFERNALCAPE});
    builder.put(ObjectID.POH_MOUNTED_DIARY_CAPE,
        new Integer[]{ItemID.SKILLCAPE_AD, ItemID.SKILLCAPE_AD_HOOD});
    builder.put(ObjectID.POH_MOUNTED_DIARY_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_AD_TRIMMED, ItemID.SKILLCAPE_AD_HOOD});
    builder.put(ObjectID.POH_MOUNTED_FIRE_CAPE, new Integer[]{ItemID.TZHAAR_CAPE_FIRE});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE, new Integer[]{ItemID.SKILLCAPE_MAX,
        ItemID.SKILLCAPE_MAX_HOOD});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE_FIRE,
        new Integer[]{ItemID.SKILLCAPE_MAX_FIRECAPE, ItemID.SKILLCAPE_MAX_HOOD_FIRECAPE});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE_SARADOMIN,
        new Integer[]{ItemID.SKILLCAPE_MAX_SARADOMIN, ItemID.SKILLCAPE_MAX_HOOD_SARADOMIN});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE_ZAMORAK,
        new Integer[]{ItemID.SKILLCAPE_MAX_ZAMORAK, ItemID.SKILLCAPE_MAX_HOOD_ZAMORAK});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE_GUTHIX,
        new Integer[]{ItemID.SKILLCAPE_MAX_GUTHIX, ItemID.SKILLCAPE_MAX_HOOD_GUTHIX});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE_AVA,
        new Integer[]{ItemID.SKILLCAPE_MAX_ANMA, ItemID.SKILLCAPE_MAX_HOOD_ANMA});
    builder.put(
        ObjectID.POH_MOUNTED_MUSIC_CAPE, new Integer[]{ItemID.MUSIC_CAPE, ItemID.MUSIC_CAPE_HOOD});
    builder.put(ObjectID.POH_MOUNTED_MUSIC_CAPE_TRIM,
        new Integer[]{ItemID.MUSIC_CAPE_TRIMMED, ItemID.MUSIC_CAPE_HOOD});
    builder.put(ObjectID.POH_MOUNTED_QUEST_CAPE,
        new Integer[]{ItemID.SKILLCAPE_QP, ItemID.SKILLCAPE_QP_HOOD});
    builder.put(ObjectID.POH_MOUNTED_QUEST_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_QP_TRIMMED, ItemID.SKILLCAPE_QP_HOOD});
    builder.put(ObjectID.POH_MOUNTED_AGILITY_CAPE,
        new Integer[]{ItemID.SKILLCAPE_AGILITY, ItemID.SKILLCAPE_AGILITY_HOOD});
    builder.put(ObjectID.POH_MOUNTED_AGILITY_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_AGILITY_TRIMMED, ItemID.SKILLCAPE_AGILITY_HOOD});
    builder.put(ObjectID.POH_MOUNTED_ATTACK_CAPE,
        new Integer[]{ItemID.SKILLCAPE_ATTACK, ItemID.SKILLCAPE_ATTACK_HOOD});
    builder.put(ObjectID.POH_MOUNTED_ATTACK_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_ATTACK_TRIMMED, ItemID.SKILLCAPE_ATTACK_HOOD});
    builder.put(ObjectID.POH_MOUNTED_CONSTRUCTION_CAPE,
        new Integer[]{ItemID.SKILLCAPE_CONSTRUCTION, ItemID.SKILLCAPE_CONSTRUCTION_HOOD});
    builder.put(ObjectID.POH_MOUNTED_CONSTRUCTION_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED, ItemID.SKILLCAPE_CONSTRUCTION_HOOD});
    builder.put(ObjectID.POH_MOUNTED_COOKING_CAPE,
        new Integer[]{ItemID.SKILLCAPE_COOKING, ItemID.SKILLCAPE_COOKING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_COOKING_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_COOKING_TRIMMED, ItemID.SKILLCAPE_COOKING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_CRAFTING_CAPE,
        new Integer[]{ItemID.SKILLCAPE_CRAFTING, ItemID.SKILLCAPE_CRAFTING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_CRAFTING_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_CRAFTING_TRIMMED, ItemID.SKILLCAPE_CRAFTING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_DEFENCE_CAPE,
        new Integer[]{ItemID.SKILLCAPE_DEFENCE, ItemID.SKILLCAPE_DEFENCE_HOOD});
    builder.put(ObjectID.POH_MOUNTED_DEFENCE_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_DEFENCE_TRIMMED, ItemID.SKILLCAPE_DEFENCE_HOOD});
    builder.put(ObjectID.POH_MOUNTED_FARMING_CAPE,
        new Integer[]{ItemID.SKILLCAPE_FARMING, ItemID.SKILLCAPE_FARMING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_FARMING_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_FARMING_TRIMMED, ItemID.SKILLCAPE_FARMING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_FIREMAKING_CAPE,
        new Integer[]{ItemID.SKILLCAPE_FIREMAKING, ItemID.SKILLCAPE_FIREMAKING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_FIREMAKING_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_FIREMAKING_TRIMMED, ItemID.SKILLCAPE_FIREMAKING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_FISHING_CAPE,
        new Integer[]{ItemID.SKILLCAPE_FISHING, ItemID.SKILLCAPE_FISHING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_FISHING_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_FISHING_TRIMMED, ItemID.SKILLCAPE_FISHING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_FLETCHING_CAPE,
        new Integer[]{ItemID.SKILLCAPE_FLETCHING, ItemID.SKILLCAPE_FLETCHING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_FLETCHING_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_FLETCHING_TRIMMED, ItemID.SKILLCAPE_FLETCHING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_HERBLORE_CAPE,
        new Integer[]{ItemID.SKILLCAPE_HERBLORE, ItemID.SKILLCAPE_HERBLORE_HOOD});
    builder.put(ObjectID.POH_MOUNTED_HERBLORE_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_HERBLORE_TRIMMED, ItemID.SKILLCAPE_HERBLORE_HOOD});
    builder.put(ObjectID.POH_MOUNTED_HITPOINTS_CAPE,
        new Integer[]{ItemID.SKILLCAPE_HITPOINTS, ItemID.SKILLCAPE_HITPOINTS_HOOD});
    builder.put(ObjectID.POH_MOUNTED_HITPOINTS_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_HITPOINTS_TRIMMED, ItemID.SKILLCAPE_HITPOINTS_HOOD});
    builder.put(ObjectID.POH_MOUNTED_HUNTING_CAPE,
        new Integer[]{ItemID.SKILLCAPE_HUNTING, ItemID.SKILLCAPE_HUNTING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_HUNTING_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_HUNTING_TRIMMED, ItemID.SKILLCAPE_HUNTING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_MAGIC_CAPE, new Integer[]{ItemID.SKILLCAPE_MAGIC,
        ItemID.SKILLCAPE_MAGIC_HOOD});
    builder.put(ObjectID.POH_MOUNTED_MAGIC_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_MAGIC_TRIMMED, ItemID.SKILLCAPE_MAGIC_HOOD});
    builder.put(ObjectID.POH_MOUNTED_MINING_CAPE,
        new Integer[]{ItemID.SKILLCAPE_MINING, ItemID.SKILLCAPE_MINING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_MINING_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_MINING_TRIMMED, ItemID.SKILLCAPE_MINING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_PRAYER_CAPE,
        new Integer[]{ItemID.SKILLCAPE_PRAYER, ItemID.SKILLCAPE_PRAYER_HOOD});
    builder.put(ObjectID.POH_MOUNTED_PRAYER_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_PRAYER_TRIMMED, ItemID.SKILLCAPE_PRAYER_HOOD});
    builder.put(ObjectID.POH_MOUNTED_RANGED_CAPE,
        new Integer[]{ItemID.SKILLCAPE_RANGING, ItemID.SKILLCAPE_RANGING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_RANGED_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_RANGING_TRIMMED, ItemID.SKILLCAPE_RANGING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_RUNECRAFTING_CAPE,
        new Integer[]{ItemID.SKILLCAPE_RUNECRAFTING, ItemID.SKILLCAPE_RUNECRAFTING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_RUNECRAFTING_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_RUNECRAFTING_TRIMMED, ItemID.SKILLCAPE_RUNECRAFTING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_SLAYER_CAPE,
        new Integer[]{ItemID.SKILLCAPE_SLAYER, ItemID.SKILLCAPE_SLAYER_HOOD});
    builder.put(ObjectID.POH_MOUNTED_SLAYER_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_SLAYER_TRIMMED, ItemID.SKILLCAPE_SLAYER_HOOD});
    builder.put(ObjectID.POH_MOUNTED_SMITHING_CAPE,
        new Integer[]{ItemID.SKILLCAPE_SMITHING, ItemID.SKILLCAPE_SMITHING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_SMITHING_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_SMITHING_TRIMMED, ItemID.SKILLCAPE_SMITHING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_STRENGTH_CAPE,
        new Integer[]{ItemID.SKILLCAPE_STRENGTH, ItemID.SKILLCAPE_STRENGTH_HOOD});
    builder.put(ObjectID.POH_MOUNTED_STRENGTH_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_STRENGTH_TRIMMED, ItemID.SKILLCAPE_STRENGTH_HOOD});
    builder.put(ObjectID.POH_MOUNTED_THIEVING_CAPE,
        new Integer[]{ItemID.SKILLCAPE_THIEVING, ItemID.SKILLCAPE_THIEVING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_THIEVING_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_THIEVING_TRIMMED, ItemID.SKILLCAPE_THIEVING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_WOODCUTTING_CAPE,
        new Integer[]{ItemID.SKILLCAPE_WOODCUTTING, ItemID.SKILLCAPE_WOODCUTTING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_WOODCUTTING_CAPE_TRIM,
        new Integer[]{ItemID.SKILLCAPE_WOODCUTTING_TRIMMED, ItemID.SKILLCAPE_WOODCUTTING_HOOD});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE_ARDY,
        new Integer[]{ItemID.SKILLCAPE_MAX_ARDY, ItemID.SKILLCAPE_MAX_HOOD_ARDY});
    builder.put(ObjectID.POH_MOUNTED_CHAMPIONSCAPE, new Integer[]{ItemID.CHAMPION_CAPE});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE_ASSEMBLER_MASORI,
        new Integer[]{ItemID.SKILLCAPE_MAX_ASSEMBLER_MASORI,
            ItemID.SKILLCAPE_MAX_HOOD_ASSEMBLER_MASORI});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE_SARADOMIN2,
        new Integer[]{ItemID.SKILLCAPE_MAX_SARADOMIN2, ItemID.SKILLCAPE_MAX_HOOD_SARADOMIN2});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE_ZAMORAK2,
        new Integer[]{ItemID.SKILLCAPE_MAX_ZAMORAK2, ItemID.SKILLCAPE_MAX_HOOD_ZAMORAK2});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE_GUTHIX2,
        new Integer[]{ItemID.SKILLCAPE_MAX_GUTHIX2, ItemID.SKILLCAPE_MAX_HOOD_GUTHIX2});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE_ASSEMBLER,
        new Integer[]{ItemID.SKILLCAPE_MAX_ASSEMBLER, ItemID.SKILLCAPE_MAX_HOOD_ASSEMBLER});
    builder.put(ObjectID.POH_MOUNTED_MYTHICALCAPE, new Integer[]{ItemID.MYTHICAL_CAPE});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE_MYTHICAL,
        new Integer[]{ItemID.SKILLCAPE_MAX_MYTHICAL, ItemID.SKILLCAPE_MAX_HOOD_MYTHICAL});
    builder.put(ObjectID.POH_MOUNTED_MAX_CAPE_DIZANAS,
        new Integer[]{ItemID.SKILLCAPE_MAX_DIZANAS, ItemID.SKILLCAPE_MAX_HOOD_DIZANAS});
    builder.put(ObjectID.POH_MOUNTED_COX_T1, new Integer[]{ItemID.COX_CHALLENGE_CAPE_T1});
    builder.put(ObjectID.POH_MOUNTED_COX_T2, new Integer[]{ItemID.COX_CHALLENGE_CAPE_T2});
    builder.put(ObjectID.POH_MOUNTED_COX_T3, new Integer[]{ItemID.COX_CHALLENGE_CAPE_T3});
    builder.put(ObjectID.POH_MOUNTED_COX_T4, new Integer[]{ItemID.COX_CHALLENGE_CAPE_T4});
    builder.put(ObjectID.POH_MOUNTED_COX_T5, new Integer[]{ItemID.COX_CHALLENGE_CAPE_T5});

    objectIdItemIdMap = builder.build();
  }

  protected CapeHanger(DudeWheresMyStuffPlugin plugin) {
    super(PlayerOwnedHouseStorageType.CAPE_HANGER, plugin);
  }

  @Override
  public boolean onGameObjectSpawned(GameObjectSpawned gameObjectSpawned) {
    // It is not possible to check if the player is in their own POH,
    //   so going to someone else's POH can reset your cape hanger storage.

    int id = gameObjectSpawned.getGameObject().getId();
    Integer[] itemIds = objectIdItemIdMap.get(id);

    if (id == 29166 || itemIds != null) {
      updateLastUpdated();
      items.clear();

      if (itemIds != null) {
        for (Integer itemId : itemIds) {
          items.add(new ItemStack(itemId, 1, plugin));
        }
      }

      return true;
    }

    return false;
  }
}

package dev.thource.runelite.dudewheresmystuff.playerownedhouse;

import dev.thource.runelite.dudewheresmystuff.StorageType;
import java.util.Arrays;
import java.util.List;
import javax.annotation.Nullable;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;

/** PlayerOwnedHouseStorageType is used to identify PlayerOwnedHouseStorages. */
@RequiredArgsConstructor
@Getter
public enum PlayerOwnedHouseStorageType implements StorageType {
  TREASURE_CHEST_BEGINNER(
      "Treasure Chest (Beginner)",
      33405,
      "treasureChestBeginner",
      Arrays.asList(
          ItemID.AMULET_OF_DEFENCE_T,
          ItemID.BEAR_SLIPPERS,
          ItemID.DEMON_SLIPPERS,
          ItemID.FROG_SLIPPERS,
          ItemID.JESTER_CAPE,
          ItemID.MOLE_SLIPPERS,
          ItemID.MONK_ROBEBOTTOM_T,
          ItemID.MONK_ROBETOP_T,
          ItemID.RUNE_SCIMITAR_GUTHIX,
          ItemID.RUNE_SCIMITAR_SARADOMIN,
          ItemID.RUNE_SCIMITAR_ZAMORAK,
          ItemID.SANDWICH_LADY_HAT,
          ItemID.SANDWICH_LADY_TOP,
          ItemID.SANDWICH_LADY_BOTTOM,
          ItemID.SHOULDER_PARROT)),
  TREASURE_CHEST_EASY(
      "Treasure Chest (Easy)",
      33405,
      "treasureChestEasy",
      Arrays.asList(
          ItemID.TRAIL_AMULET_OF_MAGIC,
          ItemID.TRAIL_POWER_AMMY,
          ItemID.BEANIE_HAT,
          ItemID.BERRET_BLACK,
          ItemID.BERRET_BLUE,
          ItemID.BERRET_RED,
          ItemID.BERRET_WHITE,
          ItemID.PIRATE_HAT_BERRET_MIME_MASK,
          ItemID.BLACK_FULL_HELM_GOLD,
          ItemID.BLACK_PLATEBODY_GOLD,
          ItemID.BLACK_PLATESKIRT_GOLD,
          ItemID.BLACK_PLATELEGS_GOLD,
          ItemID.BLACK_KITESHIELD_GOLD,
          ItemID.BLACK_FULL_HELM_TRIM,
          ItemID.BLACK_PLATEBODY_TRIM,
          ItemID.BLACK_PLATESKIRT_TRIM,
          ItemID.BLACK_PLATELEGS_TRIM,
          ItemID.BLACK_KITESHIELD_TRIM,
          ItemID.TRAIL_HERALDIC_HELM_1_BLACK,
          ItemID.TRAIL_HERALDIC_HELM_2_BLACK,
          ItemID.TRAIL_HERALDIC_HELM_3_BLACK,
          ItemID.TRAIL_HERALDIC_HELM_4_BLACK,
          ItemID.TRAIL_HERALDIC_HELM_5_BLACK,
          ItemID.BLACK_HERALDIC_KITESHIELD1,
          ItemID.BLACK_HERALDIC_KITESHIELD2,
          ItemID.BLACK_HERALDIC_KITESHIELD3,
          ItemID.BLACK_HERALDIC_KITESHIELD4,
          ItemID.BLACK_HERALDIC_KITESHIELD5,
          ItemID.BLACK_PICKAXE,
          ItemID.BLACK_PLATEBODY_H1,
          ItemID.BLACK_PLATEBODY_H2,
          ItemID.BLACK_PLATEBODY_H3,
          ItemID.BLACK_PLATEBODY_H4,
          ItemID.BLACK_PLATEBODY_H5,
          ItemID.BLACKWIZHAT_GOLD,
          ItemID.BLACK_WIZARDS_ROBE_GOLD,
          ItemID.BLACK_SKIRT_GOLD,
          ItemID.BLACKWIZHAT_TRIM,
          ItemID.BLACK_WIZARDS_ROBE_TRIM,
          ItemID.BLACK_SKIRT_TRIM,
          ItemID.BLESSING_ZAROS,
          ItemID.BLESSING_SARADOMIN,
          ItemID.BLESSING_ARMADYL,
          ItemID.BLESSING_GUTHIX,
          ItemID.BLESSING_ZAMORAK,
          ItemID.BLESSING_BANDOS,
          ItemID.BLUEWIZHAT_TRIM_GOLD,
          ItemID.WIZARDS_ROBE_TRIM_GOLD,
          ItemID.BLUE_SKIRT_TRIM_GOLD,
          ItemID.BLUEWIZHAT_TRIM,
          ItemID.WIZARDS_ROBE_TRIM,
          ItemID.BLUE_SKIRT_TRIM,
          ItemID.TRAIL_BOB_SHIRT_BLACK,
          ItemID.TRAIL_BOB_SHIRT_BLUE,
          ItemID.TRAIL_BOB_SHIRT_GREEN,
          ItemID.TRAIL_BOB_SHIRT_PURPLE,
          ItemID.TRAIL_BOB_SHIRT_RED,
          ItemID.BRONZE_FULL_HELM_GOLD,
          ItemID.BRONZE_PLATEBODY_GOLD,
          ItemID.BRONZE_PLATESKIRT_GOLD,
          ItemID.BRONZE_PLATELEGS_GOLD,
          ItemID.BRONZE_KITESHIELD_GOLD,
          ItemID.BRONZE_FULL_HELM_TRIM,
          ItemID.BRONZE_PLATEBODY_TRIM,
          ItemID.BRONZE_PLATESKIRT_TRIM,
          ItemID.BRONZE_PLATELEGS_TRIM,
          ItemID.BRONZE_KITESHIELD_TRIM,
          ItemID.BLACK_CANE,
          ItemID.CAPE_OF_SKULLS,
          ItemID.TRAIL_COMPOSITE_BOW_WILLOW,
          ItemID.TRAIL_ELEGANT_SHIRT_MALE_G,
          ItemID.TRAIL_ELEGANT_PANTS_MALE_G,
          ItemID.TRAIL_ELEGANT_SHIRT_FEMALE_G,
          ItemID.TRAIL_ELEGANT_PANTS_FEMALE_G,
          ItemID.TRAIL_ELEGANT_SHIRT_MALE_B,
          ItemID.TRAIL_ELEGANT_PANTS_MALE_B,
          ItemID.TRAIL_ELEGANT_SHIRT_FEMALE_B,
          ItemID.TRAIL_ELEGANT_PANTS_FEMALE_B,
          ItemID.TRAIL_ELEGANT_SHIRT_MALE_R,
          ItemID.TRAIL_ELEGANT_PANTS_MALE_R,
          ItemID.TRAIL_ELEGANT_SHIRT_FEMALE_R,
          ItemID.TRAIL_ELEGANT_PANTS_FEMALE_R,
          ItemID.TRAIL_FLARED_PANTS,
          ItemID.GOLDEN_APRON,
          ItemID.CHEFS_HAT_GOLD,
          ItemID.JOINT_OF_HAM,
          ItemID.HIGHWAYMANMASK,
          ItemID.IRON_FULL_HELM_GOLD,
          ItemID.IRON_PLATEBODY_GOLD,
          ItemID.IRON_PLATESKIRT_GOLD,
          ItemID.IRON_PLATELEGS_GOLD,
          ItemID.IRON_KITESHIELD_GOLD,
          ItemID.IRON_FULL_HELM_TRIM,
          ItemID.IRON_PLATEBODY_TRIM,
          ItemID.IRON_PLATESKIRT_TRIM,
          ItemID.IRON_PLATELEGS_TRIM,
          ItemID.IRON_KITESHIELD_TRIM,
          ItemID.LARGE_SPADE,
          ItemID.LEATHER_ARMOUR_TRIM_GOLD,
          ItemID.LEATHER_CHAPS_TRIM_GOLD,
          ItemID.GOBLIN_MASK,
          ItemID.IMP_MASK,
          ItemID.MONK_ROBETOP_GOLD,
          ItemID.MONK_ROBEBOTTOM_GOLD,
          ItemID.TRAIL_PANTALOONS,
          ItemID.RAIN_BOW,
          ItemID.TRAIL_SLEEPING_CAP,
          ItemID.STAFF_OF_BOBCAT,
          ItemID.STEEL_FULL_HELM_GOLD,
          ItemID.STEEL_PLATEBODY_GOLD,
          ItemID.STEEL_PLATESKIRT_GOLD,
          ItemID.STEEL_PLATELEGS_GOLD,
          ItemID.STEEL_KITESHIELD_GOLD,
          ItemID.STEEL_FULL_HELM_TRIM,
          ItemID.STEEL_PLATEBODY_TRIM,
          ItemID.STEEL_PLATESKIRT_TRIM,
          ItemID.STEEL_PLATELEGS_TRIM,
          ItemID.STEEL_KITESHIELD_TRIM,
          ItemID.STUDDED_BODY_TRIM_FUR,
          ItemID.STUDDED_CHAPS_TRIM_FUR,
          ItemID.STUDDED_BODY_TRIM_GOLD,
          ItemID.STUDDED_CHAPS_TRIM_GOLD,
          ItemID.TRAIL_ANCIENT_ROBE_T,
          ItemID.TRAIL_ANCIENT_ROBE_L,
          ItemID.TRAIL_ANCIENT_MITRE,
          ItemID.TRAIL_ANCIENT_CLOAK,
          ItemID.TRAIL_ANCIENT_STAFF,
          ItemID.TRAIL_ANCIENT_SCARF,
          ItemID.TRAIL_ARMADYL_ROBE_T,
          ItemID.TRAIL_ARMADYL_ROBE_L,
          ItemID.TRAIL_ARMADYL_MITRE,
          ItemID.TRAIL_ARMADYL_CLOAK,
          ItemID.TRAIL_ARMADYL_STAFF,
          ItemID.TRAIL_ARMADYL_SCARF,
          ItemID.TRAIL_BANDOS_ROBE_T,
          ItemID.TRAIL_BANDOS_ROBE_L,
          ItemID.TRAIL_BANDOS_MITRE,
          ItemID.TRAIL_BANDOS_CLOAK,
          ItemID.TRAIL_BANDOS_STAFF,
          ItemID.TRAIL_BANDOS_SCARF,
          ItemID.TRAIL_GUTHIX_ROBE_T,
          ItemID.TRAIL_GUTHIX_ROBE_L,
          ItemID.TRAIL_GUTHIX_MITRE,
          ItemID.TRAIL_GUTHIX_CLOAK,
          ItemID.TRAIL_GUTHIX_STAFF,
          ItemID.TRAIL_GUTHIX_SCARF,
          ItemID.TRAIL_SARADOMIN_ROBE_T,
          ItemID.TRAIL_SARADOMIN_ROBE_L,
          ItemID.TRAIL_SARADOMIN_MITRE,
          ItemID.CASTLEWARS_CLOAK_SARADOMIN,
          ItemID.TRAIL_SARADOMIN_STAFF,
          ItemID.TRAIL_SARADOMIN_SCARF,
          ItemID.TRAIL_ZAMORAK_ROBE_T,
          ItemID.TRAIL_ZAMORAK_ROBE_L,
          ItemID.TRAIL_ZAMORAK_MITRE,
          ItemID.CASTLEWARS_CLOAK_ZAMORAK,
          ItemID.TRAIL_ZAMORAK_STAFF,
          ItemID.TRAIL_ZAMORAK_SCARF,
          ItemID.TRAIL_WIG,
          ItemID.WOODEN_SHIELD_GOLD)),
  TREASURE_CHEST_MEDIUM(
      "Treasure Chest (Medium)",
      33405,
      "treasureChestMedium",
      Arrays.asList(
          ItemID.ADAMANT_FULL_HELM_GOLD,
          ItemID.ADAMANT_PLATEBODY_GOLD,
          ItemID.ADAMANT_PLATESKIRT_GOLD,
          ItemID.ADAMANT_PLATELEGS_GOLD,
          ItemID.ADAMANT_KITESHIELD_GOLD,
          ItemID.ADAMANT_FULL_HELM_TRIM,
          ItemID.ADAMANT_PLATEBODY_TRIM,
          ItemID.ADAMANT_PLATESKIRT_TRIM,
          ItemID.ADAMANT_PLATELEGS_TRIM,
          ItemID.ADAMANT_KITESHIELD_TRIM,
          ItemID.TRAIL_HERALDIC_HELM_1_ADAMANT,
          ItemID.TRAIL_HERALDIC_HELM_2_ADAMANT,
          ItemID.TRAIL_HERALDIC_HELM_3_ADAMANT,
          ItemID.TRAIL_HERALDIC_HELM_4_ADAMANT,
          ItemID.TRAIL_HERALDIC_HELM_5_ADAMANT,
          ItemID.ADAMANT_HERALDIC_KITESHIELD1,
          ItemID.ADAMANT_HERALDIC_KITESHIELD2,
          ItemID.ADAMANT_HERALDIC_KITESHIELD3,
          ItemID.ADAMANT_HERALDIC_KITESHIELD4,
          ItemID.ADAMANT_HERALDIC_KITESHIELD5,
          ItemID.ADAMANT_PLATEBODY_H1,
          ItemID.ADAMANT_PLATEBODY_H2,
          ItemID.ADAMANT_PLATEBODY_H3,
          ItemID.ADAMANT_PLATEBODY_H4,
          ItemID.ADAMANT_PLATEBODY_H5,
          ItemID.TRAIL_AMULET_OF_STRENGTH,
          ItemID.CABBAGE_SHIELD,
          ItemID.ADAMANT_CANE,
          ItemID.CLIMBING_BOOTS_G,
          ItemID.CLUELESS_SCROLL,
          ItemID.TRAIL_COMPOSITE_BOW_YEW,
          ItemID.TRAIL_ELEGANT_SHIRT_MALE,
          ItemID.TRAIL_ELEGANT_PANTS_MALE,
          ItemID.TRAIL_ELEGANT_SHIRT_FEMALE,
          ItemID.TRAIL_ELEGANT_PANTS_FEMALE,
          ItemID.TRAIL_ELEGANT_SHIRT_MALE_GOLD,
          ItemID.TRAIL_ELEGANT_PANTS_MALE_GOLD,
          ItemID.TRAIL_ELEGANT_SHIRT_FEMALE_GOLD,
          ItemID.TRAIL_ELEGANT_PANTS_FEMALE_GOLD,
          ItemID.TRAIL_ELEGANT_SHIRT_MALE_PINK,
          ItemID.TRAIL_ELEGANT_PANTS_MALE_PINK,
          ItemID.TRAIL_ELEGANT_SHIRT_FEMALE_PINK,
          ItemID.TRAIL_ELEGANT_PANTS_FEMALE_PINK,
          ItemID.TRAIL_ELEGANT_SHIRT_MALE_P,
          ItemID.TRAIL_ELEGANT_PANTS_MALE_P,
          ItemID.TRAIL_ELEGANT_SHIRT_FEMALE_P,
          ItemID.TRAIL_ELEGANT_PANTS_FEMALE_P,
          ItemID.DRAGONHIDE_BODY_TRIM_GOLD,
          ItemID.DRAGONHIDE_CHAPS_TRIM_GOLD,
          ItemID.DRAGONHIDE_BODY_TRIM,
          ItemID.DRAGONHIDE_CHAPS_TRIM,
          ItemID.HEADBAND_BLACK,
          ItemID.HEADBAND_BLUE,
          ItemID.HEADBAND_BROWN,
          ItemID.HEADBAND_GOLD,
          ItemID.HEADBAND_GREEN,
          ItemID.HEADBAND_PINK,
          ItemID.HEADBAND_RED,
          ItemID.HEADBAND_WHITE,
          ItemID.HOLY_SANDALS,
          ItemID.ARCEUUS_BANNER,
          ItemID.HOSIDIUS_BANNER,
          ItemID.LOVAKENGJ_BANNER,
          ItemID.PISCARILIUS_BANNER,
          ItemID.SHAYZIEN_BANNER,
          ItemID.LEPRECHAUN_HAT,
          ItemID.BLACK_LEPRECHAUN_HAT,
          ItemID.BLACK_UNICORN_MASK,
          ItemID.CAT_MASK,
          ItemID.PENGUIN_MASK,
          ItemID.WHITE_UNICORN_MASK,
          ItemID.WOLF_MASK,
          ItemID.MITHRIL_FULL_HELM_GOLD,
          ItemID.MITHRIL_PLATEBODY_GOLD,
          ItemID.MITHRIL_PLATESKIRT_GOLD,
          ItemID.MITHRIL_PLATELEGS_GOLD,
          ItemID.MITHRIL_KITESHIELD_GOLD,
          ItemID.MITHRIL_FULL_HELM_TRIM,
          ItemID.MITHRIL_PLATEBODY_TRIM,
          ItemID.MITHRIL_PLATESKIRT_TRIM,
          ItemID.MITHRIL_PLATELEGS_TRIM,
          ItemID.MITHRIL_KITESHIELD_TRIM,
          ItemID.BOOTS_RANGER,
          ItemID.SPIKED_MANACLES,
          ItemID.STRAWBOATER_BLACK,
          ItemID.STRAWBOATER_BLUE,
          ItemID.STRAWBOATER_GREEN,
          ItemID.STRAWBOATER_ORANGE,
          ItemID.STRAWBOATER_PINK,
          ItemID.STRAWBOATER_PURPLE,
          ItemID.STRAWBOATER_RED,
          ItemID.STRAWBOATER_WHITE,
          ItemID.TRAIL_CRIER_HAT,
          ItemID.TOWN_CRIER_COAT,
          ItemID.TOWN_CRIER_BELL,
          ItemID.BOOTS_WIZARD,
          ItemID.WOLF_CLOAK)),
  TREASURE_CHEST_HARD(
      "Treasure Chest (Hard)",
      33405,
      "treasureChestHard",
      Arrays.asList(
          ItemID.TRAIL_MAGE_AMULET,
          ItemID.TRAIL_MAGE_HAT,
          ItemID.TRAIL_MAGE_LEGS,
          ItemID.TRAIL_MAGE_TORSO,
          ItemID.TRAIL_FIGHTER_HELM,
          ItemID.TRAIL_FIGHTER_SHIELD,
          ItemID.TRAIL_SILVER_PLATE_LEGS,
          ItemID.TRAIL_SILVER_PLATE_SKIRT,
          ItemID.TRAIL_SILVER_PLATE_CHEST,
          ItemID.TRAIL_RANGER_COIF,
          ItemID.TRAIL_RANGER_LEGS,
          ItemID.TRAIL_RANGER_TORSO,
          ItemID.TRAIL_RANGER_VAMBRACES,
          ItemID.TRAIL_AMULET_OF_GLORY,
          ItemID.TRAIL_ANCIENT_COIF,
          ItemID.TRAIL_ANCIENT_CHEST,
          ItemID.TRAIL_ANCIENT_CHAPS,
          ItemID.TRAIL_ANCIENT_VAMBRACES,
          ItemID.TRAIL_ARMADYL_COIF,
          ItemID.TRAIL_ARMADYL_CHEST,
          ItemID.TRAIL_ARMADYL_CHAPS,
          ItemID.TRAIL_ARMADYL_VAMBRACES,
          ItemID.TRAIL_BANDOS_COIF,
          ItemID.TRAIL_BANDOS_CHEST,
          ItemID.TRAIL_BANDOS_CHAPS,
          ItemID.TRAIL_BANDOS_VAMBRACES,
          ItemID.TRAIL_GUTHIX_COIF,
          ItemID.TRAIL_GUTHIX_CHEST,
          ItemID.TRAIL_GUTHIX_CHAPS,
          ItemID.TRAIL_GUTHIX_VAMBRACES,
          ItemID.TRAIL_SARADOMIN_COIF,
          ItemID.TRAIL_SARADOMIN_CHEST,
          ItemID.TRAIL_SARADOMIN_CHAPS,
          ItemID.TRAIL_SARADOMIN_VAMBRACES,
          ItemID.TRAIL_ZAMORAK_COIF,
          ItemID.TRAIL_ZAMORAK_CHEST,
          ItemID.TRAIL_ZAMORAK_CHAPS,
          ItemID.TRAIL_ZAMORAK_VAMBRACES,
          ItemID.BLUE_DRAGONHIDE_BODY_TRIM_GOLD,
          ItemID.BLUE_DRAGONHIDE_CHAPS_TRIM_GOLD,
          ItemID.BLUE_DRAGONHIDE_BODY_TRIM,
          ItemID.BLUE_DRAGONHIDE_CHAPS_TRIM,
          ItemID.RUNE_CANE,
          ItemID.CAVALIER_BLACK,
          ItemID.CAVALIER_NAVY,
          ItemID.CAVALIER_BROWN,
          ItemID.CAVALIER_DARK,
          ItemID.CAVALIER_RED,
          ItemID.CAVALIER_WHITE,
          ItemID.PIRATE_HAT_CAVALIER_HIGHWAY_MASK,
          ItemID.TRAIL_COMPOSITE_BOW_MAGIC,
          ItemID.CYCLOPS_MASK,
          ItemID.DRAGON_BOOTS_GOLD,
          ItemID.DRAGONMASK_BLACK,
          ItemID.DRAGONMASK_BLUE,
          ItemID.DRAGONMASK_GREEN,
          ItemID.DRAGONMASK_RED,
          ItemID.BLESSED_BOOTS_ANCIENT,
          ItemID.BLESSED_BOOTS_ARMADYL,
          ItemID.BLESSED_BOOTS_BANDOS,
          ItemID.BLESSED_BOOTS_GUTHIX,
          ItemID.BLESSED_BOOTS_SARADOMIN,
          ItemID.BLESSED_BOOTS_ZAMORAK,
          ItemID.BLESSED_DHIDE_SHIELD_ANCIENT,
          ItemID.BLESSED_DHIDE_SHIELD_ARMADYL,
          ItemID.BLESSED_DHIDE_SHIELD_BANDOS,
          ItemID.BLESSED_DHIDE_SHIELD_GUTHIX,
          ItemID.BLESSED_DHIDE_SHIELD_SARADOMIN,
          ItemID.BLESSED_DHIDE_SHIELD_ZAMORAK,
          ItemID.DUAL_SAI,
          ItemID.ENCHANTED_HAT,
          ItemID.ENCHANTED_ROBETOP,
          ItemID.ENCHANTED_ROBELEGS,
          ItemID.EXPLORER_BACKPACK,
          ItemID.NUNCHUCKS,
          ItemID.PIRATEHAT,
          ItemID.PITH_HELMET,
          ItemID.RED_DRAGONHIDE_BODY_GOLD,
          ItemID.RED_DRAGONHIDE_CHAPS_GOLD,
          ItemID.RED_DRAGONHIDE_BODY_TRIM,
          ItemID.RED_DRAGONHIDE_CHAPS_TRIM,
          ItemID.ROBINHOODHAT,
          ItemID.RUNE_2H_SWORD_GOLD,
          ItemID.RUNE_FULL_HELM_ANCIENT,
          ItemID.RUNE_PLATEBODY_ANCIENT,
          ItemID.RUNE_PLATELEGS_ANCIENT,
          ItemID.RUNE_KITESHIELD_ANCIENT,
          ItemID.RUNE_PLATESKIRT_ANCIENT,
          ItemID.RUNE_FULL_HELM_ARMADYL,
          ItemID.RUNE_PLATEBODY_ARMADYL,
          ItemID.RUNE_PLATELEGS_ARMADYL,
          ItemID.RUNE_KITESHIELD_ARMADYL,
          ItemID.RUNE_PLATESKIRT_ARMADYL,
          ItemID.RUNE_FULL_HELM_BANDOS,
          ItemID.RUNE_PLATEBODY_BANDOS,
          ItemID.RUNE_PLATELEGS_BANDOS,
          ItemID.RUNE_KITESHIELD_BANDOS,
          ItemID.RUNE_PLATESKIRT_BANDOS,
          ItemID.RUNE_FULL_HELM_GOLDPLATE,
          ItemID.RUNE_PLATEBODY_GOLDPLATE,
          ItemID.RUNE_PLATELEGS_GOLDPLATE,
          ItemID.RUNE_PLATESKIRT_GOLDPLATE,
          ItemID.RUNE_KITESHIELD_GOLDPLATE,
          ItemID.RUNE_FULL_HELM_GOLD,
          ItemID.RUNE_PLATEBODY_GOLD,
          ItemID.RUNE_PLATELEGS_GOLD,
          ItemID.RUNE_KITESHIELD_GOLD,
          ItemID.RUNE_PLATESKIRT_GOLD,
          ItemID.RUNE_FULL_HELM_GUTHIX,
          ItemID.RUNE_PLATEBODY_GUTHIX,
          ItemID.RUNE_PLATELEGS_GUTHIX,
          ItemID.RUNE_KITESHIELD_GUTHIX,
          ItemID.RUNE_PLATESKIRT_GUTHIX,
          ItemID.RUNE_FULL_HELM_SARADOMIN,
          ItemID.RUNE_PLATEBODY_SARADOMIN,
          ItemID.RUNE_PLATELEGS_SARADOMIN,
          ItemID.RUNE_KITESHIELD_SARADOMIN,
          ItemID.RUNE_PLATESKIRT_SARADOMIN,
          ItemID.RUNE_FULL_HELM_TRIM,
          ItemID.RUNE_PLATEBODY_TRIM,
          ItemID.RUNE_PLATELEGS_TRIM,
          ItemID.RUNE_KITESHIELD_TRIM,
          ItemID.RUNE_PLATESKIRT_TRIM,
          ItemID.RUNE_FULL_HELM_ZAMORAK,
          ItemID.RUNE_PLATEBODY_ZAMORAK,
          ItemID.RUNE_PLATELEGS_ZAMORAK,
          ItemID.RUNE_KITESHIELD_ZAMORAK,
          ItemID.RUNE_PLATESKIRT_ZAMORAK,
          ItemID.RUNE_CHAINBODY_GOLD,
          ItemID.BRUT_RUNE_SPEAR_GOLD,
          ItemID.TRAIL_HERALDIC_HELM_1_RUNE,
          ItemID.TRAIL_HERALDIC_HELM_2_RUNE,
          ItemID.TRAIL_HERALDIC_HELM_3_RUNE,
          ItemID.TRAIL_HERALDIC_HELM_4_RUNE,
          ItemID.TRAIL_HERALDIC_HELM_5_RUNE,
          ItemID.RUNE_HERALDIC_KITESHIELD1,
          ItemID.RUNE_HERALDIC_KITESHIELD2,
          ItemID.RUNE_HERALDIC_KITESHIELD3,
          ItemID.RUNE_HERALDIC_KITESHIELD4,
          ItemID.RUNE_HERALDIC_KITESHIELD5,
          ItemID.RUNE_MED_HELM_GOLD,
          ItemID.RUNE_PLATEBODY_H1,
          ItemID.RUNE_PLATEBODY_H2,
          ItemID.RUNE_PLATEBODY_H3,
          ItemID.RUNE_PLATEBODY_H4,
          ItemID.RUNE_PLATEBODY_H5,
          ItemID.RUNE_SPEAR_GOLD,
          ItemID.RUNE_SQ_SHIELD_GOLD,
          ItemID.THIEVING_BAG,
          ItemID.ZOMBIE_HEAD)),
  TREASURE_CHEST_ELITE(
      "Treasure Chest (Elite)",
      33405,
      "treasureChestElite",
      Arrays.asList(
          ItemID.TRAIL_RANGER_BOW,
          ItemID.TRAIL_THIRD_CAPE,
          ItemID.TRAIL_FIGHTER_SWORD,
          ItemID.TRAIL_MAGE_WAND,
          ItemID.AFRO,
          ItemID.BLACK_DRAGONHIDE_BODY_GOLD,
          ItemID.BLACK_DRAGONHIDE_CHAPS_GOLD,
          ItemID.BLACK_DRAGONHIDE_BODY_TRIM,
          ItemID.BLACK_DRAGONHIDE_CHAPS_TRIM,
          ItemID.BLACKSMITH_HELM,
          ItemID.TRAIL_BRIEFCASE,
          ItemID.BUCKET_HELM,
          ItemID.DRAGON_CANE,
          ItemID.DEERSTALKER,
          ItemID.DRAGON_FULL_HELM_GOLD,
          ItemID.DRAGON_PLATEBODY_GOLD,
          ItemID.DRAGON_CHAINBODY_GOLD,
          ItemID.DRAGON_PLATESKIRT_GOLD,
          ItemID.DRAGON_PLATELEGS_GOLD,
          ItemID.DRAGON_KITESHIELD_GOLD,
          ItemID.DRAGON_SQ_SHIELD_GOLD,
          ItemID.DRAGONMASK_ADAMANT,
          ItemID.DRAGONMASK_BRONZE,
          ItemID.DRAGONMASK_IRON,
          ItemID.DRAGONMASK_LAVA,
          ItemID.DRAGONMASK_MITH,
          ItemID.DRAGONMASK_RUNE,
          ItemID.DRAGONMASK_STEEL,
          ItemID.DRAGON_SCIMITAR_ORNAMENT,
          ItemID.TRAIL_GILDED_DHIDE_COIF,
          ItemID.TRAIL_GILDED_DHIDE_VAMBRACES,
          ItemID.TRAIL_GILDED_DHIDE_TOP,
          ItemID.TRAIL_GILDED_DHIDE_CHAPS,
          ItemID.FREMENNIK_KILT,
          ItemID.GIANT_BOOT,
          ItemID.HEAVY_CASKET,
          ItemID.HOLY_WRAPS,
          ItemID.KATANA,
          ItemID.ZEAH_SCARF_ARCEUUS,
          ItemID.ZEAH_SCARF_HOSIDIUS,
          ItemID.ZEAH_SCARF_LOVAKENGJ,
          ItemID.ZEAH_SCARF_PISCARILIUS,
          ItemID.ZEAH_SCARF_SHAYZIEN,
          ItemID.MONACLE,
          ItemID.MUSKETEER_HAT,
          ItemID.MUSKETEER_TOP,
          ItemID.MUSKETEER_LEGS,
          ItemID.WOM_HEAD,
          ItemID.PIRATEHAT_EYEPATCH,
          ItemID.TRAIL_PIRATE_HAT,
          ItemID.RANGER_TUNIC,
          ItemID.RANGERS_TIGHTS,
          ItemID.RANGER_GLOVES,
          ItemID.RING_OF_3RD_AGE,
          ItemID.RING_OF_NATURE,
          ItemID.ROYAL_CROWN,
          ItemID.ROYAL_TOP,
          ItemID.ROYAL_BOTTOM,
          ItemID.ROYAL_SCEPTRE,
          ItemID.TRAIL_GILDED_AXE,
          ItemID.RUNE_BOOTS_GOLD,
          ItemID.TRAIL_GILDED_PICKAXE,
          ItemID.RUNE_SCIMITAR_GOLD,
          ItemID.WISE_SPECTACLES,
          ItemID.TRAIL_GILDED_SPADE,
          ItemID.TOP_HAT,
          ItemID.TOPHAT_MONACLE,
          ItemID.TUXEDO_BOWTIE,
          ItemID.TUXEDO_BODY,
          ItemID.TUXEDO_HANDS,
          ItemID.TUXEDO_LEGS,
          ItemID.TUXEDO_FEET,
          ItemID.TUXEDO_BOWTIE_WHITE,
          ItemID.TUXEDO_BODY_WHITE,
          ItemID.TUXEDO_HANDS_WHITE,
          ItemID.TUXEDO_LEGS_WHITE,
          ItemID.TUXEDO_FEET_WHITE,
          ItemID.URIS_HAT)),
  TREASURE_CHEST_MASTER(
      "Treasure Chest (Master)",
      33405,
      "treasureChestMaster",
      Arrays.asList(
          ItemID._3A_AXE,
          ItemID._3A_DRUIDIC_CLOAK,
          ItemID._3A_DRUIDIC_BOTTOMS,
          ItemID._3A_DRUIDIC_TOP,
          ItemID._3A_DRUIDIC_STAFF,
          ItemID._3A_PICKAXE,
          ItemID.ALE_GODS,
          ItemID.ANKOU_HEAD,
          ItemID.ANKOU_BODY,
          ItemID.ANKOU_LEGS,
          ItemID.ANKOU_HANDS,
          ItemID.ANKOU_FEET,
          ItemID.THE_BOWL,
          ItemID.BUCKET_HELM_GOLD,
          ItemID.DOUBLE_EYE_PATCH,
          ItemID.EYE_PATCH,
          ItemID.EYE_PATCH_02,
          ItemID.FANCY_TIARA,
          ItemID.HALF_MOON_SPECTACLES,
          ItemID.ZEAH_HOOD_ARCEUUS,
          ItemID.ZEAH_HOOD_HOSIDIUS,
          ItemID.ZEAH_HOOD_LOVAKENGJ,
          ItemID.ZEAH_HOOD_PISCARILIUS,
          ItemID.ZEAH_HOOD_SHAYZIEN,
          ItemID.BLACK_DEMON_MASK,
          ItemID.GREATER_DEMON_MASK,
          ItemID.JUNGLE_DEMON_MASK,
          ItemID.LESSER_DEMON_MASK,
          ItemID.OLD_DEMON_MASK,
          ItemID.MUMMY_HEAD,
          ItemID.MUMMY_BODY,
          ItemID.MUMMY_LEGS,
          ItemID.MUMMY_HANDS,
          ItemID.MUMMY_FEET,
          ItemID.TZHAAR_CAPE_OBSIDIAN_R,
          ItemID.RING_OF_COINS,
          ItemID.ROBE_DARKNESS_HEAD,
          ItemID.ROBE_DARKNESS_TOP,
          ItemID.ROBE_DARKNESS_LEGS,
          ItemID.ROBE_DARKNESS_HANDS,
          ItemID.ROBE_DARKNESS_FEET,
          ItemID.SAMURAI_HAT,
          ItemID.SAMURAI_TOP,
          ItemID.SAMURAI_LEGS,
          ItemID.SAMURAI_GLOVES,
          ItemID.SAMURAI_BOOTS,
          ItemID.SCROLL_SACK)),
  ARMOUR_CASE(
      "Armour Case",
      33405,
      "armourCase",
      Arrays.asList(
          ItemID.ADVENTURERS_HOOD_T1,
          ItemID.ADVENTURERS_TOP_T1,
          ItemID.ADVENTURERS_LEGS_T1,
          ItemID.ADVENTURERS_BOOTS_T1,
          ItemID.ADVENTURERS_HOOD_T2,
          ItemID.ADVENTURERS_TOP_T2,
          ItemID.ADVENTURERS_LEGS_T2,
          ItemID.ADVENTURERS_BOOTS_T2,
          ItemID.ADVENTURERS_HOOD_T3,
          ItemID.ADVENTURERS_TOP_T3,
          ItemID.ADVENTURERS_LEGS_T3,
          ItemID.ADVENTURERS_BOOTS_T3,
          ItemID.ADVENTURERS_VAMBRACES,
          ItemID.ADVENTURERS_CAPE,
          ItemID.MM_ALCHEMIST_HAT,
          ItemID.MM_ALCHEMIST_HAT_ALT,
          ItemID.MM_ALCHEMIST_BODY,
          ItemID.MM_ALCHEMIST_BODY_ALT,
          ItemID.MM_ALCHEMIST_LEGS,
          ItemID.MM_ALCHEMIST_LEGS_ALT,
          ItemID.MM_ALCHEMIST_GLOVES,
          ItemID.TRAWLER_REWARD_HAT,
          ItemID.TRAWLER_REWARD_TOP,
          ItemID.TRAWLER_REWARD_LEGS,
          ItemID.TRAWLER_REWARD_BOOTS,
          ItemID.SPIRIT_ANGLER_HAT,
          ItemID.SPIRIT_ANGLER_TOP,
          ItemID.SPIRIT_ANGLER_LEGS,
          ItemID.SPIRIT_ANGLER_BOOTS,
          ItemID.ARDOUGNE_KNIGHT_HELM,
          ItemID.ARDOUGNE_KNIGHT_BODY,
          ItemID.ARDOUGNE_KNIGHT_LEGS,
          ItemID.STEEL_PLATELEGS,
          ItemID.ZEP_BOMBER_CAP,
          ItemID.ZEP_BOMBER_CAP_GOGGLES,
          ItemID.ZEP_BOMBER_JACKET,
          ItemID.TOL_PLAYER_CONSTRUCTION_HARDHAT,
          ItemID.TOL_PLAYER_CONSTRUCTION_SHIRT,
          ItemID.TOL_PLAYER_CONSTRUCTION_TROUSERS,
          ItemID.TOL_PLAYER_CONSTRUCTION_BOOTS,
          ItemID.DOTI_BUTLERUNIFORM_VILLA,
          ItemID.DOTI_BUTLERUNIFORM_LEGS_VILLA,
          ItemID.DOTI_BUTLERUNIFORM,
          ItemID.DOTI_BUTLERUNIFORM_LEGS,
          ItemID.HUNTING_CAMOFLAUGE_ROBE_DESERT,
          ItemID.HUNTING_TROUSERS_DESERT,
          ItemID.HUNTING_CAMOFLAUGE_ROBE_JUNGLE,
          ItemID.HUNTING_TROUSERS_JUNGLE,
          ItemID.HUNTING_CAMOFLAUGE_ROBE_POLAR,
          ItemID.HUNTING_TROUSERS_POLAR,
          ItemID.HUNTING_CAMOFLAUGE_ROBE_WOOD,
          ItemID.HUNTING_TROUSERS_WOOD,
          ItemID.LEAGUE5_RELIC_HUNTER_CANE,
          ItemID.LEAGUE_3_CANE,
          ItemID.TRAILBLAZER_CANE,
          ItemID.TWISTED_CANE,
          ItemID.CASTLEWARS_ARMOUR_BODY,
          ItemID.CASTLEWARS_ARMOUR_LEGS,
          ItemID.CASTLEWARS_ARMOUR_BODY_2,
          ItemID.CASTLEWARS_ARMOUR_LEGS_2,
          ItemID.CASTLEWARS_ARMOUR_BODY_3,
          ItemID.CASTLEWARS_ARMOUR_LEGS_3,
          ItemID.CASTLEWARS_ARMOUR_SKIRT,
          ItemID.CASTLEWARS_ARMOUR_SKIRT_2,
          ItemID.CASTLEWARS_ARMOUR_SKIRT_3,
          ItemID.CASTLEWARS_MED_HELM,
          ItemID.CASTLEWARS_MED_HELM_2,
          ItemID.CASTLEWARS_MED_HELM_3,
          ItemID.CASTLEWARS_SHIELD,
          ItemID.CASTLEWARS_SHIELD_2,
          ItemID.CASTLEWARS_SHIELD_3,
          ItemID.CASTLEWARS_FULL_HELM,
          ItemID.CASTLEWARS_FULL_HELM_2,
          ItemID.CASTLEWARS_FULL_HELM_3,
          ItemID.CASTLEWARS_BOOTS,
          ItemID.CASTLEWARS_BOOTS_2,
          ItemID.CASTLEWARS_BOOTS_3,
          ItemID.CASTLEWARS_SWORD,
          ItemID.CASTLEWARS_SWORD_2,
          ItemID.CASTLEWARS_SWORD_3,
          // Decorative mage
          ItemID.CASTLEWARS_MAGE_TOP,
          ItemID.CASTLEWARS_MAGE_LEGS,
          ItemID.CASTLEWARS_MAGE_HAT,
          // Decorative range
          ItemID.CASTLEWARS_RANGE_TOP,
          ItemID.CASTLEWARS_RANGE_LEGS,
          ItemID.CASTLEWARS_RANGE_QUIVER,
          ItemID.RAEDWALD_HELM,
          ItemID.CLUE_HUNTER_GARB,
          ItemID.CLUE_HUNTER_TROUSERS,
          ItemID.CLUE_HUNTER_GLOVES,
          ItemID.CLUE_HUNTER_BOOTS,
          ItemID.CLUE_HUNTER_CLOAK,
          ItemID.RAIDS_CLUEFEST_HELM,
          ItemID.RAIDS_CLUEFEST_KITESHIELD,
          ItemID.RAIDS_CLUEFEST_PLATEBODY,
          ItemID.RAIDS_CLUEFEST_PLATELEGS,
          ItemID.RAIDS_CLUEFEST_PLATESKIRT,
          ItemID.DEADMAN_CAPE,
          ItemID.DEADMAN_BODY,
          ItemID.DEADMAN_LEGS,
          ItemID.DRAGONSTONE_HELMET,
          ItemID.DRAGONSTONE_PLATEBODY,
          ItemID.DRAGONSTONE_PLATELEGS,
          ItemID.DRAGONSTONE_ARMOURED_BOOTS,
          ItemID.DRAGONSTONE_GAUNTLETS,
          ItemID.ELITE_BLACK_FULL_HELM,
          ItemID.ELITE_BLACK_PLATEBODY,
          ItemID.ELITE_BLACK_PLATELEGS,
          ItemID.TITHE_REWARD_FEET_MALE,
          ItemID.TITHE_REWARD_FEET_FEMALE,
          ItemID.TITHE_REWARD_LEGS_MALE,
          ItemID.TITHE_REWARD_LEGS_FEMALE,
          ItemID.TITHE_REWARD_HAT_MALE,
          ItemID.TITHE_REWARD_HAT_FEMALE,
          ItemID.TITHE_REWARD_HAT_MALE_DUMMY,
          ItemID.TITHE_REWARD_HAT_FEMALE_DUMMY,
          ItemID.TITHE_REWARD_TORSO_MALE,
          ItemID.TITHE_REWARD_TORSO_FEMALE,
          ItemID.FEDORA,
          ItemID.GIANT_STOPWATCH,
          ItemID.HAM_HOOD,
          ItemID.HAM_SHIRT,
          ItemID.HAM_ROBE,
          ItemID.HAM_GLOVES,
          ItemID.HAM_BOOTS,
          ItemID.HAM_CLOAK,
          ItemID.HAM_BADGE,
          ItemID.ZAROS_HALO,
          ItemID.ARMADYL_HALO,
          ItemID.BANDOS_HALO,
          ItemID.BRASSICA_HALO,
          ItemID.CASTLEWARS_GUTHIX_HALO,
          ItemID.CASTLEWARS_SARADOMIN_HALO,
          ItemID.SEREN_HALO,
          ItemID.CASTLEWARS_ZAMORAK_HALO,
          ItemID.RAEDWALD_HELM,
          ItemID.HUNTING_HAT_LEOPARD,
          ItemID.HUNTING_TORSO_LEOPARD,
          ItemID.HUNTING_TROUSERS_LEOPARD,
          ItemID.HUNTING_HAT_TIGER,
          ItemID.HUNTING_TORSO_TIGER,
          ItemID.HUNTING_TROUSERS_TIGER,
          ItemID.HUNTING_HAT_JAGUAR,
          ItemID.HUNTING_TORSO_JAGUAR,
          ItemID.HUNTING_TROUSERS_JAGUAR,
          ItemID.HG_HUNTER_HOOD,
          ItemID.HG_HUNTER_TOP,
          ItemID.HG_HUNTER_LEGS,
          ItemID.HG_HUNTER_BOOTS,
          ItemID.INQUISITORS_HELM,
          ItemID.INQUISITORS_BODY,
          ItemID.INQUISITORS_SKIRT,
          ItemID.JUSTICIAR_FACEGUARD,
          ItemID.JUSTICIAR_CHESTGUARD,
          ItemID.JUSTICIAR_LEG_GUARDS,
          ItemID.RAMBLE_LUMBERJACK_HAT,
          ItemID.RAMBLE_LUMBERJACK_TOP,
          ItemID.RAMBLE_LUMBERJACK_LEGS,
          ItemID.RAMBLE_LUMBERJACK_BOOTS,
          ItemID.FORESTRY_LUMBERJACK_HAT,
          ItemID.FORESTRY_LUMBERJACK_TOP,
          ItemID.FORESTRY_LUMBERJACK_LEGS,
          ItemID.FORESTRY_LUMBERJACK_BOOTS,
          ItemID.MASORI_MASK,
          ItemID.MASORI_BODY,
          ItemID.MASORI_CHAPS,
          ItemID.MASORI_MASK_FORTIFIED,
          ItemID.MASORI_BODY_FORTIFIED,
          ItemID.MASORI_CHAPS_FORTIFIED,
          ItemID.MGUILD_GLOVES,
          ItemID.MGUILD_GLOVES_SUPERIOR,
          ItemID.MGUILD_GLOVES_EXPERT,
          ItemID.HIDE_TOP,
          ItemID.HIDE_LEGS,
          ItemID.HIDE_BOOTS,
          ItemID.HIDE_CAPE,
          ItemID.GASMASK,
          ItemID.MOURNING_MOURNER_TOP,
          ItemID.MOURNING_MOURNER_LEGS,
          ItemID.MOURNING_MOURNER_BOOTS,
          ItemID.MOURNING_MOURNER_GLOVES,
          ItemID.MOURNING_MOURNER_CLOAK,
          ItemID.OBSIDIAN_HELMET,
          ItemID.OBSIDIAN_PLATEBODY,
          ItemID.OBSIDIAN_PLATELEGS,
          ItemID.ORNATE_HELM,
          ItemID.ORNATE_TOP,
          ItemID.ORNATE_LEGS,
          ItemID.ORNATE_GLOVES,
          ItemID.ORNATE_BOOTS,
          ItemID.ORNATE_CAPE,
          ItemID.BARBASSAULT_PENANCE_FIGHTER_HAT,
          ItemID.BARBASSAULT_PENANCE_FIGHTER_TORSO,
          ItemID.BARBASSAULT_PENANCE_GLOVES,
          ItemID.BARBASSAULT_PENANCE_HEALER_HAT,
          ItemID.BARBASSAULT_PENANCE_RANGER_HAT,
          ItemID.BARBASSAULT_PENANCE_RUNNER_BOOTS,
          ItemID.BARBASSAULT_PENANCE_RUNNER_HAT,
          ItemID.BARBASSAULT_PENANCE_RANGER_LEGS,
          ItemID.MOTHERLODE_REWARD_HAT,
          ItemID.MOTHERLODE_REWARD_TOP,
          ItemID.MOTHERLODE_REWARD_LEGS,
          ItemID.MOTHERLODE_REWARD_BOOTS,
          ItemID.MOTHERLODE_REWARD_HAT_GOLD,
          ItemID.MOTHERLODE_REWARD_TOP_GOLD,
          ItemID.MOTHERLODE_REWARD_LEGS_GOLD,
          ItemID.MOTHERLODE_REWARD_BOOTS_GOLD,
          ItemID.LEAGUE5_RELIC_HUNTER_HAT_T1,
          ItemID.LEAGUE5_RELIC_HUNTER_TOP_T1,
          ItemID.LEAGUE5_RELIC_HUNTER_LEGS_T1,
          ItemID.LEAGUE5_RELIC_HUNTER_BOOTS_T1,
          ItemID.LEAGUE5_RELIC_HUNTER_HAT_T2,
          ItemID.LEAGUE5_RELIC_HUNTER_TOP_T2,
          ItemID.LEAGUE5_RELIC_HUNTER_LEGS_T2,
          ItemID.LEAGUE5_RELIC_HUNTER_BOOTS_T2,
          ItemID.LEAGUE5_RELIC_HUNTER_HAT_T3,
          ItemID.LEAGUE5_RELIC_HUNTER_TOP_T3,
          ItemID.LEAGUE5_RELIC_HUNTER_LEGS_T3,
          ItemID.LEAGUE5_RELIC_HUNTER_BOOTS_T3,
          ItemID.DAGGANOTH_MELEE_HELM,
          ItemID.DAGGANOTH_MELEE_BODY,
          ItemID.DAGGANOTH_MELEE_LEGS,
          ItemID.DAGGANOTH_MELEE_GLOVES,
          ItemID.DAGGANOTH_MELEE_FEET,
          ItemID.ROGUESDEN_BOOTS,
          ItemID.ROGUESDEN_GLOVES,
          ItemID.ROGUESDEN_HELM,
          ItemID.ROGUESDEN_BODY,
          ItemID.ROGUESDEN_LEGS,
          ItemID.LEAGUE_3_RELIC_HUNTER_HOOD_T1,
          ItemID.LEAGUE_3_RELIC_HUNTER_TOP_T1,
          ItemID.LEAGUE_3_RELIC_HUNTER_LEGS_T1,
          ItemID.LEAGUE_3_RELIC_HUNTER_BOOTS_T1,
          ItemID.LEAGUE_3_RELIC_HUNTER_HOOD_T2,
          ItemID.LEAGUE_3_RELIC_HUNTER_TOP_T2,
          ItemID.LEAGUE_3_RELIC_HUNTER_LEGS_T2,
          ItemID.LEAGUE_3_RELIC_HUNTER_BOOTS_T2,
          ItemID.LEAGUE_3_RELIC_HUNTER_HOOD_T3,
          ItemID.LEAGUE_3_RELIC_HUNTER_TOP_T3,
          ItemID.LEAGUE_3_RELIC_HUNTER_LEGS_T3,
          ItemID.LEAGUE_3_RELIC_HUNTER_BOOTS_T3,
          ItemID.SHAYZIEN_BOOTS_1,
          ItemID.SHAYZIEN_GLOVES_1,
          ItemID.SHAYZIEN_LEGS_1,
          ItemID.SHAYZIEN_HELM_1,
          ItemID.SHAYZIEN_BODY_1,
          ItemID.SHAYZIEN_BOOTS_2,
          ItemID.SHAYZIEN_GLOVES_2,
          ItemID.SHAYZIEN_LEGS_2,
          ItemID.SHAYZIEN_HELM_2,
          ItemID.SHAYZIEN_BODY_2,
          ItemID.SHAYZIEN_BOOTS_3,
          ItemID.SHAYZIEN_GLOVES_3,
          ItemID.SHAYZIEN_LEGS_3,
          ItemID.SHAYZIEN_HELM_3,
          ItemID.SHAYZIEN_BODY_3,
          ItemID.SHAYZIEN_BOOTS_4,
          ItemID.SHAYZIEN_GLOVES_4,
          ItemID.SHAYZIEN_LEGS_4,
          ItemID.SHAYZIEN_HELM_4,
          ItemID.SHAYZIEN_BODY_4,
          ItemID.SHAYZIEN_BOOTS_5,
          ItemID.SHAYZIEN_GLOVES_5,
          ItemID.SHAYZIEN_LEGS_5,
          ItemID.SHAYZIEN_HELM_5,
          ItemID.SHAYZIEN_BODY_5,
          ItemID.SNAKESKIN_BANDANA,
          ItemID.SNAKESKIN_BODY,
          ItemID.SNAKESKIN_BOOTS,
          ItemID.SNAKESKIN_CHAPS,
          ItemID.SNAKESKIN_VAMBRACES,
          ItemID.DAGGANOTH_RANGED_HELM,
          ItemID.DAGGANOTH_RANGED_BODY,
          ItemID.DAGGANOTH_RANGED_LEGS,
          ItemID.DAGGANOTH_RANGE_GLOVES,
          ItemID.DAGGANOTH_RANGE_FEET,
          ItemID.SOS_BOOTS,
          ItemID.SOS_BOOTS2,
          ItemID.SOS_BOOTS3,
          ItemID.SUNFIRE_HELM,
          ItemID.SUNFIRE_BODY,
          ItemID.SUNFIRE_LEGS,
          ItemID.SWIFT_BLADE,
          ItemID.BASIC_TK_HELM,
          ItemID.BASIC_TK_BODY,
          ItemID.BASIC_TK_LEGS,
          ItemID.BASIC_TK_RANK2_HELM,
          ItemID.BASIC_TK_RANK2_BODY,
          ItemID.BASIC_TK_RANK2_LEGS,
          ItemID.BASIC_TK_RANK2_PLATESKIRT,
          ItemID.LEAGUE_4_TORCH,
          ItemID.TRAILBLAZER_RELIC_HUNTER_HOOD_T1,
          ItemID.TRAILBLAZER_RELIC_HUNTER_TOP_T1,
          ItemID.TRAILBLAZER_RELIC_HUNTER_LEGS_T1,
          ItemID.TRAILBLAZER_RELIC_HUNTER_BOOTS_T1,
          ItemID.TRAILBLAZER_RELIC_HUNTER_HOOD_T2,
          ItemID.TRAILBLAZER_RELIC_HUNTER_TOP_T2,
          ItemID.TRAILBLAZER_RELIC_HUNTER_LEGS_T2,
          ItemID.TRAILBLAZER_RELIC_HUNTER_BOOTS_T2,
          ItemID.TRAILBLAZER_RELIC_HUNTER_HOOD_T3,
          ItemID.TRAILBLAZER_RELIC_HUNTER_TOP_T3,
          ItemID.TRAILBLAZER_RELIC_HUNTER_LEGS_T3,
          ItemID.TRAILBLAZER_RELIC_HUNTER_BOOTS_T3,
          ItemID.LEAGUE_4_RELIC_HUNTER_HAT_T1,
          ItemID.LEAGUE_4_RELIC_HUNTER_TOP_T1,
          ItemID.LEAGUE_4_RELIC_HUNTER_LEGS_T1,
          ItemID.LEAGUE_4_RELIC_HUNTER_BOOTS_T1,
          ItemID.LEAGUE_4_RELIC_HUNTER_HAT_T2,
          ItemID.LEAGUE_4_RELIC_HUNTER_TOP_T2,
          ItemID.LEAGUE_4_RELIC_HUNTER_LEGS_T2,
          ItemID.LEAGUE_4_RELIC_HUNTER_BOOTS_T2,
          ItemID.LEAGUE_4_RELIC_HUNTER_HAT_T3,
          ItemID.LEAGUE_4_RELIC_HUNTER_TOP_T3,
          ItemID.LEAGUE_4_RELIC_HUNTER_LEGS_T3,
          ItemID.LEAGUE_4_RELIC_HUNTER_BOOTS_T3,
          ItemID.BROODOOMASK_POISON,
          ItemID.BROODOOMASK_DISEASE,
          ItemID.BROODOOMASK_COMBAT,
          ItemID.TWISTED_RELIC_HUNTER_HAT_T1,
          ItemID.TWISTED_RELIC_HUNTER_TOP_T1,
          ItemID.TWISTED_RELIC_HUNTER_LEGS_T1,
          ItemID.TWISTED_RELIC_HUNTER_BOOTS_T1,
          ItemID.TWISTED_RELIC_HUNTER_HAT_T2,
          ItemID.TWISTED_RELIC_HUNTER_TOP_T2,
          ItemID.TWISTED_RELIC_HUNTER_LEGS_T2,
          ItemID.TWISTED_RELIC_HUNTER_BOOTS_T2,
          ItemID.TWISTED_RELIC_HUNTER_HAT_T3,
          ItemID.TWISTED_RELIC_HUNTER_TOP_T3,
          ItemID.TWISTED_RELIC_HUNTER_LEGS_T3,
          ItemID.TWISTED_RELIC_HUNTER_BOOTS_T3,
          ItemID.LEAGUE_3_VOID_KNIGHT_GLOVES,
          ItemID.LEAGUE_3_VOID_KNIGHT_ROBES,
          ItemID.LEAGUE_3_VOID_KNIGHT_TOP,
          ItemID.PEST_VOID_KNIGHT_GLOVES,
          ItemID.PEST_VOID_KNIGHT_ROBES,
          ItemID.PEST_VOID_KNIGHT_TOP,
          ItemID.LEAGUE_3_VOID_KNIGHT_ROBES_ELITE,
          ItemID.LEAGUE_3_VOID_KNIGHT_TOP_ELITE,
          ItemID.ELITE_VOID_KNIGHT_ROBES,
          ItemID.ELITE_VOID_KNIGHT_TOP,
          ItemID.GAME_PEST_MAGE_HELM,
          ItemID.LEAGUE_3_VOID_MAGE_HELM,
          ItemID.GAME_PEST_ARCHER_HELM,
          ItemID.LEAGUE_3_VOID_RANGE_HELM,
          ItemID.GAME_PEST_MELEE_HELM,
          ItemID.LEAGUE_3_VOID_MELEE_HELM,
          ItemID.VYRELORD_SHOES,
          ItemID.VYRELORD_LEGS,
          ItemID.VYRELORD_TORSO,
          ItemID.WHITE_FULL_HELM,
          ItemID.WHITE_PLATEBODY,
          ItemID.WHITE_PLATESKIRT,
          ItemID.WHITE_PLATELEGS,
          ItemID.WHITE_GLOVES,
          ItemID.WHITE_ARMOURED_BOOTS,
          ItemID.WHITE_KITESHIELD,
          ItemID.XERIC_HAT,
          ItemID.XERIC_TOP,
          ItemID.XERIC_ROBE)),
  MAGIC_WARDROBE(
      "Magic Wardrobe",
      33405,
      "magicWardrobe",
      Arrays.asList(
          ItemID.WEARABLE_SAW,
          ItemID.WEARABLE_SAW_OFFHAND,
          ItemID.ANCESTRAL_HAT,
          ItemID.ANCESTRAL_ROBE_TOP,
          ItemID.ANCESTRAL_ROBE_BOTTOM,
          ItemID.ANCESTRAL_HAT_TWISTED,
          ItemID.ANCESTRAL_ROBE_BOTTOM_TWISTED,
          ItemID.ANCESTRAL_ROBE_TOP_TWISTED,
          ItemID.ANCIENT_CEREMONIAL_MASK,
          ItemID.ANCIENT_CEREMONIAL_TOP,
          ItemID.ANCIENT_CEREMONIAL_LEGS,
          ItemID.ANCIENT_CEREMONIAL_GLOVES,
          ItemID.ANCIENT_CEREMONIAL_BOOTS,
          ItemID.BLOODBARK_HELM,
          ItemID.BLOODBARK_BODY,
          ItemID.BLOODBARK_LEGS,
          ItemID.BLOODBARK_GAUNTLETS,
          ItemID.BLOODBARK_GREAVES,
          ItemID.BH_HAT_TIER1,
          ItemID.BH_HAT_TIER2,
          ItemID.BH_HAT_TIER3,
          ItemID.BH_HAT_TIER4,
          ItemID.BH_HAT_TIER5,
          ItemID.BH_HAT_TIER6,
          ItemID.WINT_TORCH,
          ItemID.WINT_TORCH_OFFHAND,
          ItemID.CONSTRUCTION_HAT,
          ItemID.CONSTRUCTION_SHIRT,
          ItemID.CONSTRUCTION_TROUSERS,
          ItemID.CONSTRUCTION_BOOTS,
          ItemID.DAGONHAI_HAT,
          ItemID.DAGONHAI_ROBE_TOP,
          ItemID.DAGONHAI_ROBE_BOTTOM,
          ItemID.DARK_FLIPPERS,
          ItemID.WGS_DARK_SQUALL_HOOD,
          ItemID.WGS_DARK_SQUALL_ROBE_TOP,
          ItemID.WGS_DARK_SQUALL_ROBE_BOTTOM,
          ItemID.ELDERCHAOS_HOOD,
          ItemID.ELDERCHAOS_TOP,
          ItemID.ELDERCHAOS_BOTTOM,
          ItemID.ELDERCHAOS_HOOD_PRETTY,
          ItemID.ELDERCHAOS_TOP_PRETTY,
          ItemID.ELDERCHAOS_BOTTOM_PRETTY,
          ItemID.EVIL_CHICKEN_HEAD,
          ItemID.EVIL_CHICKEN_WINGS,
          ItemID.EVIL_CHICKEN_LEGS,
          ItemID.EVIL_CHICKEN_FEET,
          ItemID.FISH_SACK,
          ItemID.FISH_SACK_BARREL_CLOSED,
          ItemID.BREW_FLAG_3,
          ItemID.BREW_FLAG_1,
          ItemID.BREW_FLAG_2,
          ItemID.BREW_FLAG_4,
          ItemID.BREW_FLAG_6,
          ItemID.BREW_FLAG_5,
          ItemID.FORESTRY_BASKET_CLOSED,
          ItemID.FORESTRY_KIT,
          ItemID.SECRET_GHOST_BOOTS,
          ItemID.SECRET_GHOST_CLOAK,
          ItemID.SECRET_GHOST_GLOVES,
          ItemID.SECRET_GHOST_HAT,
          ItemID.SECRET_GHOST_TOP,
          ItemID.SECRET_GHOST_BOTTOM,
          ItemID.GOLDEN_TENCH,
          ItemID.GRACEFUL_HOOD,
          ItemID.GRACEFUL_CAPE,
          ItemID.GRACEFUL_TOP,
          ItemID.GRACEFUL_LEGS,
          ItemID.GRACEFUL_GLOVES,
          ItemID.GRACEFUL_BOOTS,
          // Adventure graceful
          ItemID.ZEAH_GRACEFUL_HOOD_ARCEUUS,
          ItemID.ZEAH_GRACEFUL_CAPE_ARCEUUS,
          ItemID.ZEAH_GRACEFUL_TOP_ARCEUUS,
          ItemID.ZEAH_GRACEFUL_LEGS_ARCEUUS,
          ItemID.ZEAH_GRACEFUL_GLOVES_ARCEUUS,
          ItemID.ZEAH_GRACEFUL_BOOTS_ARCEUUS,
          // Agility Arena graceful
          ItemID.ZEAH_GRACEFUL_HOOD_PISCARILIUS,
          ItemID.ZEAH_GRACEFUL_CAPE_PISCARILIUS,
          ItemID.ZEAH_GRACEFUL_TOP_PISCARILIUS,
          ItemID.ZEAH_GRACEFUL_LEGS_PISCARILIUS,
          ItemID.ZEAH_GRACEFUL_GLOVES_PISCARILIUS,
          ItemID.ZEAH_GRACEFUL_BOOTS_PISCARILIUS,
          // Arceuus graceful
          ItemID.ZEAH_GRACEFUL_HOOD_LOVAKENGJ,
          ItemID.ZEAH_GRACEFUL_CAPE_LOVAKENGJ,
          ItemID.ZEAH_GRACEFUL_TOP_LOVAKENGJ,
          ItemID.ZEAH_GRACEFUL_LEGS_LOVAKENGJ,
          ItemID.ZEAH_GRACEFUL_GLOVES_LOVAKENGJ,
          ItemID.ZEAH_GRACEFUL_BOOTS_LOVAKENGJ,
          // Hallowed graceful
          ItemID.ZEAH_GRACEFUL_HOOD_SHAYZIEN,
          ItemID.ZEAH_GRACEFUL_CAPE_SHAYZIEN,
          ItemID.ZEAH_GRACEFUL_TOP_SHAYZIEN,
          ItemID.ZEAH_GRACEFUL_LEGS_SHAYZIEN,
          ItemID.ZEAH_GRACEFUL_GLOVES_SHAYZIEN,
          ItemID.ZEAH_GRACEFUL_BOOTS_SHAYZIEN,
          // Hosidius graceful
          ItemID.ZEAH_GRACEFUL_HOOD_HOSIDIUS,
          ItemID.ZEAH_GRACEFUL_CAPE_HOSIDIUS,
          ItemID.ZEAH_GRACEFUL_TOP_HOSIDIUS,
          ItemID.ZEAH_GRACEFUL_LEGS_HOSIDIUS,
          ItemID.ZEAH_GRACEFUL_GLOVES_HOSIDIUS,
          ItemID.ZEAH_GRACEFUL_BOOTS_HOSIDIUS,
          // Kourend graceful
          ItemID.ZEAH_GRACEFUL_HOOD_KOUREND,
          ItemID.ZEAH_GRACEFUL_CAPE_KOUREND,
          ItemID.ZEAH_GRACEFUL_TOP_KOUREND,
          ItemID.ZEAH_GRACEFUL_LEGS_KOUREND,
          ItemID.ZEAH_GRACEFUL_GLOVES_KOUREND,
          ItemID.ZEAH_GRACEFUL_BOOTS_KOUREND,
          // Lovakengj graceful
          ItemID.GRACEFUL_HOOD_SKILLCAPECOLOUR,
          ItemID.GRACEFUL_CAPE_SKILLCAPECOLOUR,
          ItemID.GRACEFUL_TOP_SKILLCAPECOLOUR,
          ItemID.GRACEFUL_LEGS_SKILLCAPECOLOUR,
          ItemID.GRACEFUL_GLOVES_SKILLCAPECOLOUR,
          ItemID.GRACEFUL_BOOTS_SKILLCAPECOLOUR,
          // Piscarilius graceful
          ItemID.GRACEFUL_HOOD_HALLOWED,
          ItemID.GRACEFUL_CAPE_HALLOWED,
          ItemID.GRACEFUL_TOP_HALLOWED,
          ItemID.GRACEFUL_LEGS_HALLOWED,
          ItemID.GRACEFUL_GLOVES_HALLOWED,
          ItemID.GRACEFUL_BOOTS_HALLOWED,
          // Shayzien graceful
          ItemID.GRACEFUL_HOOD_TRAILBLAZER,
          ItemID.GRACEFUL_CAPE_TRAILBLAZER,
          ItemID.GRACEFUL_TOP_TRAILBLAZER,
          ItemID.GRACEFUL_LEGS_TRAILBLAZER,
          ItemID.GRACEFUL_GLOVES_TRAILBLAZER,
          ItemID.GRACEFUL_BOOTS_TRAILBLAZER,
          // Trailblazer graceful
          ItemID.GRACEFUL_HOOD_ADVENTURER,
          ItemID.GRACEFUL_CAPE_ADVENTURER,
          ItemID.GRACEFUL_TOP_ADVENTURER,
          ItemID.GRACEFUL_LEGS_ADVENTURER,
          ItemID.GRACEFUL_GLOVES_ADVENTURER,
          ItemID.GRACEFUL_BOOTS_ADVENTURER,
          // Varlamore graceful
          ItemID.GRACEFUL_HOOD_WYRM,
          ItemID.GRACEFUL_CAPE_WYRM,
          ItemID.GRACEFUL_TOP_WYRM,
          ItemID.GRACEFUL_LEGS_WYRM,
          ItemID.GRACEFUL_GLOVES_WYRM,
          ItemID.GRACEFUL_BOOTS_WYRM,
          ItemID.IMCANDO_HAMMER,
          ItemID.IMCANDO_HAMMER_OFFHAND,
          ItemID.MAGICTRAINING_INFINITYHAT,
          ItemID.MAGICTRAINING_INFINITYTOP,
          ItemID.MAGICTRAINING_INFINITYBOTTOM,
          ItemID.MAGICTRAINING_INFINITYGLOVES,
          ItemID.MAGICTRAINING_INFINITYBOOTS,
          ItemID.INFINITY_HAT_TRIM,
          ItemID.INFINITY_TOP_TRIM,
          ItemID.INFINITY_BOTTOM_TRIM,
          ItemID.INFINITY_HAT_GOLD,
          ItemID.INFINITY_TOP_GOLD,
          ItemID.INFINITY_BOTTOM_GOLD,
          ItemID.FORESTRY_BASKET_CLOSED,
          ItemID.LOG_BASKET_CLOSED,
          ItemID.LUNAR_AMULET,
          ItemID.LUNAR_BOOTS,
          ItemID.LUNAR_CAPE,
          ItemID.LUNAR_GLOVES,
          ItemID.LUNAR_HELMET,
          ItemID.LUNAR_LEGS,
          ItemID.LUNAR_RING,
          ItemID.LUNAR_TORSO,
          ItemID.TOA_AMASCUT_MASK,
          ItemID.LUNAR_MOONCLAN_TORSO,
          ItemID.LUNAR_MOONCLAN_BOOTS,
          ItemID.LUNAR_MOONCLAN_CAPE,
          ItemID.LUNAR_MOONCLAN_GLOVES,
          ItemID.LUNAR_MOONCLAN_HEADGEAR,
          ItemID.LUNAR_MOONCLAN_SKIRT,
          ItemID.MUDSKIPPER_HAT,
          ItemID.MUDSKIPPER_FLIPPERS,
          ItemID.MYSTIC_HAT,
          ItemID.MYSTIC_ROBE_TOP,
          ItemID.MYSTIC_ROBE_BOTTOM,
          ItemID.MYSTIC_GLOVES,
          ItemID.MYSTIC_BOOTS,
          ItemID.MYSTIC_HAT_DARK,
          ItemID.MYSTIC_ROBE_TOP_DARK,
          ItemID.MYSTIC_ROBE_BOTTOM_DARK,
          ItemID.MYSTIC_GLOVES_DARK,
          ItemID.MYSTIC_BOOTS_DARK,
          ItemID.MYSTIC_HAT_DUSK,
          ItemID.MYSTIC_ROBE_TOP_DUSK,
          ItemID.MYSTIC_ROBE_BOTTOM_DUSK,
          ItemID.MYSTIC_GLOVES_DUSK,
          ItemID.MYSTIC_BOOTS_DUSK,
          ItemID.MYSTIC_HAT_LIGHT,
          ItemID.MYSTIC_ROBE_TOP_LIGHT,
          ItemID.MYSTIC_ROBE_BOTTOM_LIGHT,
          ItemID.MYSTIC_GLOVES_LIGHT,
          ItemID.MYSTIC_BOOTS_LIGHT,
          ItemID.LEAGUE_3_MYSTIC_HAT,
          ItemID.LEAGUE_3_MYSTIC_ROBE_TOP,
          ItemID.LEAGUE_3_MYSTIC_ROBE_BOTTOM,
          ItemID.LEAGUE_3_MYSTIC_GLOVES,
          ItemID.LEAGUE_3_MYSTIC_BOOTS,
          ItemID.BREW_TRICORN_BLACK,
          ItemID.BREW_UNIFORM_BLACK,
          ItemID.BREW_NAVY_SLACKS_BLACK,
          ItemID.BREW_TRICORN_BLUE,
          ItemID.BREW_UNIFORM_BLUE,
          ItemID.BREW_NAVY_SLACKS_BLUE,
          ItemID.BREW_TRICORN_BROWN,
          ItemID.BREW_UNIFORM_BROWN,
          ItemID.BREW_NAVY_SLACKS_BROWN,
          ItemID.BREW_TRICORN_GREEN,
          ItemID.BREW_UNIFORM_GREEN,
          ItemID.BREW_NAVY_SLACKS_GREEN,
          ItemID.BREW_TRICORN_GREY,
          ItemID.BREW_UNIFORM_GREY,
          ItemID.BREW_NAVY_SLACKS_GREY,
          ItemID.BREW_TRICORN_PURPLE,
          ItemID.BREW_UNIFORM_PURPLE,
          ItemID.BREW_NAVY_SLACKS_PURPLE,
          ItemID.BREW_TRICORN_RED,
          ItemID.BREW_UNIFORM_RED,
          ItemID.BREW_NAVY_SLACKS_RED,
          ItemID.FISHINGROD_PEARL_OILY,
          ItemID.FISHINGROD_PEARL_BRUT,
          ItemID.FISHINGROD_PEARL,
          ItemID.FISHINGROD_PEARL_FLY,
          ItemID.FORESTRY_PHEASANT_HAT,
          ItemID.FORESTRY_PHEASANT_LEGS,
          ItemID.FORESTRY_PHEASANT_BOOTS,
          ItemID.FORESTRY_PHEASANT_CAPE,
          ItemID.PYROMANCER_HOOD,
          ItemID.PYROMANCER_TOP,
          ItemID.PYROMANCER_BOTTOM,
          ItemID.PYROMANCER_BOOTS,
          ItemID.HAT_OF_THE_EYE,
          ItemID.ROBE_TOP_OF_THE_EYE,
          ItemID.ROBE_BOTTOM_OF_THE_EYE,
          ItemID.BOOTS_OF_THE_EYE,
          ItemID.HAT_OF_THE_EYE_BLUE,
          ItemID.ROBE_TOP_OF_THE_EYE_BLUE,
          ItemID.ROBE_BOTTOM_OF_THE_EYE_BLUE,
          ItemID.HAT_OF_THE_EYE_GREEN,
          ItemID.ROBE_TOP_OF_THE_EYE_GREEN,
          ItemID.ROBE_BOTTOM_OF_THE_EYE_GREEN,
          ItemID.HAT_OF_THE_EYE_RED,
          ItemID.ROBE_TOP_OF_THE_EYE_RED,
          ItemID.ROBE_BOTTOM_OF_THE_EYE_RED,
          ItemID.ROBESOFRUIN_HOOD,
          ItemID.ROBESOFRUIN_TOP,
          ItemID.ROBESOFRUIN_BOTTOM,
          ItemID.ROBESOFRUIN_GLOVES,
          ItemID.ROBESOFRUIN_SOCKS,
          ItemID.ROBESOFRUIN_CLOAK,
          ItemID.DAGGANOTH_MAGE_FEET,
          ItemID.DAGGANOTH_MAGE_LEGS,
          ItemID.DAGGANOTH_MAGE_GLOVES,
          ItemID.DAGGANOTH_MAGE_HELM,
          ItemID.DAGGANOTH_MAGE_BODY,
          ItemID.SMITHING_UNIFORM_BOOTS,
          ItemID.SMITHING_UNIFORM_GLOVES,
          ItemID.SMITHING_UNIFORM_GLOVES_ICE,
          ItemID.SMITHING_UNIFORM_LEGS,
          ItemID.SMITHING_UNIFORM_TORSO,
          ItemID.SPLITBARK_HELM,
          ItemID.SPLITBARK_BODY,
          ItemID.SPLITBARK_GAUNTLETS,
          ItemID.SPLITBARK_LEGS,
          ItemID.SPLITBARK_GREAVES,
          ItemID.SWAMPBARK_HELM,
          ItemID.SWAMPBARK_BODY,
          ItemID.SWAMPBARK_LEGS,
          ItemID.SWAMPBARK_GAUNTLETS,
          ItemID.SWAMPBARK_GREAVES,
          ItemID.TBW_VILLAGER_HAT_CREAM,
          ItemID.TBW_VILLAGER_SHIRT_CREAM,
          ItemID.TBW_VILLAGER_ROBE_CREAM,
          ItemID.TBW_VILLAGER_ARMBAND_CREAM,
          ItemID.TBW_VILLAGER_SANDALS_CREAM,
          ItemID.TBW_VILLAGER_HAT_BLUE,
          ItemID.TBW_VILLAGER_SHIRT_BLUE,
          ItemID.TBW_VILLAGER_ROBE_BLUE,
          ItemID.TBW_VILLAGER_ARMBAND_BLUE,
          ItemID.TBW_VILLAGER_SANDALS_BLUE,
          ItemID.TBW_VILLAGER_HAT_YELLOW,
          ItemID.TBW_VILLAGER_SHIRT_YELLOW,
          ItemID.TBW_VILLAGER_ROBE_YELLOW,
          ItemID.TBW_VILLAGER_ARMBAND_YELLOW,
          ItemID.TBW_VILLAGER_SANDALS_YELLOW,
          ItemID.TBW_VILLAGER_HAT_PURPLE,
          ItemID.TBW_VILLAGER_SHIRT_PURPLE,
          ItemID.TBW_VILLAGER_ROBE_PURPLE,
          ItemID.TBW_VILLAGER_ARMBAND_PURPLE,
          ItemID.TBW_VILLAGER_SANDALS_PURPLE,
          ItemID.VMQ3_CULTIST_HOOD,
          ItemID.VMQ3_CULTIST_ROBE_TOP,
          ItemID.VMQ3_CULTIST_ROBE_BOTTOM,
          ItemID.VMQ3_CULTIST_SANDALS,
          ItemID.VIRTUS_MASK,
          ItemID.VIRTUS_TOP,
          ItemID.VIRTUS_LEGS,
          ItemID.VIRTUS_MASK_ORNAMENT,
          ItemID.VIRTUS_TOP_ORNAMENT,
          ItemID.VIRTUS_LEGS_ORNAMENT,
          ItemID.PYROMANCER_GLOVES,
          ItemID.SHADES_PRAYER_BOOTS,
          ItemID.SHADES_PRAYER_HELM,
          ItemID.SHADES_PRAYER_BOTTOM,
          ItemID.SHADES_PRAYER_TOP)),
  FANCY_DRESS_BOX(
      "Fancy Dress Box",
      33405,
      "fancyDressBox",
      Arrays.asList(
          ItemID.BEEKEEPER_HAT,
          ItemID.BEEKEEPER_TOP,
          ItemID.BEEKEEPER_LEGS,
          ItemID.BEEKEEPER_GLOVES,
          ItemID.BEEKEEPER_BOOTS,
          ItemID.DRILL_HELM,
          ItemID.CERT_DRILL_HELM,
          ItemID.DRILL_TOP,
          ItemID.CERT_DRILL_TOP,
          ItemID.DRILL_BOTTOMS,
          ItemID.CERT_DRILL_BOTTOMS,
          ItemID.MACRO_FROG_MASK,
          ItemID.MACRO_PRINCE_TORSO,
          ItemID.MACRO_PRINCE_LEGS,
          ItemID.MACRO_PRINCESS_TORSO,
          ItemID.MACRO_PRINCESS_LEGS,
          ItemID.LADERHOSEN_HAT,
          ItemID.LADERHOSEN_TOP,
          ItemID.LADERHOSEN_LEGS,
          ItemID.MACRO_MIME_MASK,
          ItemID.MACRO_MIME_TOP,
          ItemID.MACRO_MIME_LEGS,
          ItemID.MACRO_MIME_GLOVES,
          ItemID.MACRO_MIME_BOOTS,
          ItemID.BLACKROBEBOTTOM,
          ItemID.BLACKROBETOP,
          ItemID.STALE_BAGUETTE,
          ItemID.MACRO_DIGGER_MASK,
          ItemID.MACRO_DIGGER_SHIRT,
          ItemID.MACRO_DIGGER_LEGS,
          ItemID.MACRO_DIGGER_GLOVES,
          ItemID.MACRO_DIGGER_BOOTS)),
  CAPE_RACK(
      "Cape Rack",
      33405,
      "capeRack",
      Arrays.asList(
          ItemID.SKILLCAPE_AD,
          ItemID.SKILLCAPE_AD_HOOD,
          ItemID.SKILLCAPE_AD_TRIMMED,
          ItemID.SKILLCAPE_AGILITY,
          ItemID.SKILLCAPE_AGILITY_HOOD,
          ItemID.SKILLCAPE_AGILITY_TRIMMED,
          ItemID.SKILLCAPE_ATTACK,
          ItemID.SKILLCAPE_ATTACK_HOOD,
          ItemID.SKILLCAPE_ATTACK_TRIMMED,
          ItemID.CHAMPION_CAPE,
          ItemID.SKILLCAPE_CONSTRUCTION,
          ItemID.SKILLCAPE_CONSTRUCTION_HOOD,
          ItemID.SKILLCAPE_CONSTRUCTION_TRIMMED,
          ItemID.SKILLCAPE_COOKING,
          ItemID.SKILLCAPE_COOKING_HOOD,
          ItemID.SKILLCAPE_COOKING_TRIMMED,
          ItemID.SKILLCAPE_CRAFTING,
          ItemID.SKILLCAPE_CRAFTING_HOOD,
          ItemID.SKILLCAPE_CRAFTING_TRIMMED,
          ItemID.SKILLCAPE_DEFENCE,
          ItemID.SKILLCAPE_DEFENCE_HOOD,
          ItemID.SKILLCAPE_DEFENCE_TRIMMED,
          ItemID.SKILLCAPE_FARMING,
          ItemID.SKILLCAPE_FARMING_HOOD,
          ItemID.SKILLCAPE_FARMING_TRIMMED,
          ItemID.TZHAAR_CAPE_FIRE,
          ItemID.TZHAAR_CAPE_FIRE_TROUVER,
          ItemID.SKILLCAPE_FIREMAKING,
          ItemID.SKILLCAPE_FIREMAKING_HOOD,
          ItemID.SKILLCAPE_FIREMAKING_TRIMMED,
          ItemID.SKILLCAPE_FISHING,
          ItemID.SKILLCAPE_FISHING_HOOD,
          ItemID.SKILLCAPE_FISHING_TRIMMED,
          ItemID.SKILLCAPE_FLETCHING,
          ItemID.SKILLCAPE_FLETCHING_HOOD,
          ItemID.SKILLCAPE_FLETCHING_TRIMMED,
          ItemID.GAUNTLET_CRYSTALLINE_CAPE,
          ItemID.SKILLCAPE_HERBLORE,
          ItemID.SKILLCAPE_HERBLORE_HOOD,
          ItemID.SKILLCAPE_HERBLORE_TRIMMED,
          ItemID.SKILLCAPE_HITPOINTS,
          ItemID.SKILLCAPE_HITPOINTS_HOOD,
          ItemID.SKILLCAPE_HITPOINTS_TRIMMED,
          ItemID.SKILLCAPE_HUNTING,
          ItemID.SKILLCAPE_HUNTING_HOOD,
          ItemID.SKILLCAPE_HUNTING_TRIMMED,
          ItemID.ICTHLARINS_SHROUD_1,
          ItemID.ICTHLARINS_SHROUD_2,
          ItemID.ICTHLARINS_SHROUD_3,
          ItemID.ICTHLARINS_SHROUD_4,
          ItemID.ICTHLARINS_SHROUD_5,
          ItemID.INFERNAL_CAPE,
          ItemID.CAPE_OF_LEGENDS,
          ItemID.GUTHIX_CAPE,
          ItemID.MA2_GUTHIX_CAPE,
          ItemID.MA2_GUTHIX_CAPE_TROUVER,
          ItemID.SARADOMIN_CAPE,
          ItemID.MA2_SARADOMIN_CAPE,
          ItemID.MA2_SARADOMIN_CAPE_TROUVER,
          ItemID.ZAMORAK_CAPE,
          ItemID.MA2_ZAMORAK_CAPE,
          ItemID.MA2_ZAMORAK_CAPE_TROUVER,
          ItemID.SKILLCAPE_MAGIC,
          ItemID.SKILLCAPE_MAGIC_HOOD,
          ItemID.SKILLCAPE_MAGIC_TRIMMED,
          ItemID.SKILLCAPE_MAX,
          ItemID.SKILLCAPE_MAX_WORN,
          ItemID.SKILLCAPE_MAX_ANMA,
          ItemID.SKILLCAPE_MAX_ARDY,
          ItemID.SKILLCAPE_MAX_ASSEMBLER,
          ItemID.SKILLCAPE_MAX_DIZANAS,
          ItemID.SKILLCAPE_MAX_FIRECAPE,
          ItemID.SKILLCAPE_MAX_GUTHIX,
          ItemID.SKILLCAPE_MAX_GUTHIX2,
          ItemID.SKILLCAPE_MAX_SARADOMIN2,
          ItemID.SKILLCAPE_MAX_ZAMORAK2,
          ItemID.SKILLCAPE_MAX_INFERNALCAPE_DUMMY,
          ItemID.SKILLCAPE_MAX_SARADOMIN,
          ItemID.SKILLCAPE_MAX_MYTHICAL,
          ItemID.SKILLCAPE_MAX_ZAMORAK,
          ItemID.SKILLCAPE_MAX_HOOD,
          ItemID.SKILLCAPE_MAX_HOOD_ANMA,
          ItemID.SKILLCAPE_MAX_HOOD_ARDY,
          ItemID.SKILLCAPE_MAX_HOOD_ASSEMBLER,
          ItemID.SKILLCAPE_MAX_HOOD_DIZANAS,
          ItemID.SKILLCAPE_MAX_HOOD_FIRECAPE,
          ItemID.SKILLCAPE_MAX_HOOD_GUTHIX,
          ItemID.SKILLCAPE_MAX_HOOD_GUTHIX2,
          ItemID.SKILLCAPE_MAX_HOOD_SARADOMIN2,
          ItemID.SKILLCAPE_MAX_HOOD_ZAMORAK2,
          ItemID.SKILLCAPE_MAX_HOOD_INFERNALCAPE,
          ItemID.SKILLCAPE_MAX_HOOD_SARADOMIN,
          ItemID.SKILLCAPE_MAX_HOOD_MYTHICAL,
          ItemID.SKILLCAPE_MAX_HOOD_ZAMORAK,
          ItemID.SKILLCAPE_MINING,
          ItemID.SKILLCAPE_MINING_HOOD,
          ItemID.SKILLCAPE_MINING_TRIMMED,
          ItemID.MUSIC_CAPE,
          ItemID.MUSIC_CAPE_HOOD,
          ItemID.MUSIC_CAPE_TRIMMED,
          ItemID.POH_TROPHY_MYTHICAL_CAPE,
          ItemID.TZHAAR_CAPE_OBSIDIAN,
          ItemID.SKILLCAPE_PRAYER,
          ItemID.SKILLCAPE_PRAYER_HOOD,
          ItemID.SKILLCAPE_PRAYER_TRIMMED,
          ItemID.SKILLCAPE_QP,
          ItemID.SKILLCAPE_QP_HOOD,
          ItemID.SKILLCAPE_QP_TRIMMED,
          ItemID.SKILLCAPE_RANGING,
          ItemID.SKILLCAPE_RANGING_HOOD,
          ItemID.SKILLCAPE_RANGING_TRIMMED,
          ItemID.SKILLCAPE_RUNECRAFTING,
          ItemID.SKILLCAPE_RUNECRAFTING_HOOD,
          ItemID.SKILLCAPE_RUNECRAFTING_TRIMMED,
          ItemID.SOUL_CAPE_RED,
          ItemID.SINHAZA_SHROUD_TIER1,
          ItemID.SINHAZA_SHROUD_TIER2,
          ItemID.SINHAZA_SHROUD_TIER3,
          ItemID.SINHAZA_SHROUD_TIER4,
          ItemID.SINHAZA_SHROUD_TIER5,
          ItemID.SKILLCAPE_SLAYER,
          ItemID.SKILLCAPE_SLAYER_HOOD,
          ItemID.SKILLCAPE_SLAYER_TRIMMED,
          ItemID.SKILLCAPE_SMITHING,
          ItemID.SKILLCAPE_SMITHING_HOOD,
          ItemID.SKILLCAPE_SMITHING_TRIMMED,
          ItemID.HUNTING_LIGHT_CAPE,
          ItemID.HUNTING_LIGHTER_CAPE,
          ItemID.SKILLCAPE_STRENGTH,
          ItemID.SKILLCAPE_STRENGTH_HOOD,
          ItemID.SKILLCAPE_STRENGTH_TRIMMED,
          ItemID.SKILLCAPE_THIEVING,
          ItemID.SKILLCAPE_THIEVING_HOOD,
          ItemID.SKILLCAPE_THIEVING_TRIMMED,
          ItemID.BR_CAPE_1,
          ItemID.BR_CAPE_10,
          ItemID.BR_CAPE_50,
          ItemID.BR_CAPE_100,
          ItemID.BR_CAPE_500,
          ItemID.BR_CAPE_1000,
          ItemID.WILDERNESS_CAPE_1,
          ItemID.WILDERNESS_CAPE_2,
          ItemID.WILDERNESS_CAPE_3,
          ItemID.WILDERNESS_CAPE_4,
          ItemID.WILDERNESS_CAPE_5,
          ItemID.WILDERNESS_CAPE_6,
          ItemID.WILDERNESS_CAPE_7,
          ItemID.WILDERNESS_CAPE_8,
          ItemID.WILDERNESS_CAPE_9,
          ItemID.WILDERNESS_CAPE_10,
          ItemID.WILDERNESS_CAPE_11,
          ItemID.WILDERNESS_CAPE_12,
          ItemID.WILDERNESS_CAPE_13,
          ItemID.WILDERNESS_CAPE_14,
          ItemID.WILDERNESS_CAPE_15,
          ItemID.WILDERNESS_CAPE_16,
          ItemID.WILDERNESS_CAPE_17,
          ItemID.WILDERNESS_CAPE_18,
          ItemID.WILDERNESS_CAPE_19,
          ItemID.WILDERNESS_CAPE_20,
          ItemID.WILDERNESS_CAPE_21,
          ItemID.WILDERNESS_CAPE_22,
          ItemID.WILDERNESS_CAPE_23,
          ItemID.WILDERNESS_CAPE_24,
          ItemID.WILDERNESS_CAPE_25,
          ItemID.WILDERNESS_CAPE_26,
          ItemID.WILDERNESS_CAPE_27,
          ItemID.WILDERNESS_CAPE_28,
          ItemID.WILDERNESS_CAPE_29,
          ItemID.WILDERNESS_CAPE_30,
          ItemID.WILDERNESS_CAPE_31,
          ItemID.WILDERNESS_CAPE_32,
          ItemID.WILDERNESS_CAPE_33,
          ItemID.WILDERNESS_CAPE_34,
          ItemID.WILDERNESS_CAPE_35,
          ItemID.WILDERNESS_CAPE_36,
          ItemID.WILDERNESS_CAPE_37,
          ItemID.WILDERNESS_CAPE_38,
          ItemID.WILDERNESS_CAPE_39,
          ItemID.WILDERNESS_CAPE_40,
          ItemID.WILDERNESS_CAPE_41,
          ItemID.WILDERNESS_CAPE_42,
          ItemID.WILDERNESS_CAPE_43,
          ItemID.WILDERNESS_CAPE_44,
          ItemID.WILDERNESS_CAPE_45,
          ItemID.WILDERNESS_CAPE_46,
          ItemID.WILDERNESS_CAPE_47,
          ItemID.WILDERNESS_CAPE_48,
          ItemID.WILDERNESS_CAPE_49,
          ItemID.WILDERNESS_CAPE_50,
          ItemID.WILDERNESS_CAPE_ZERO,
          ItemID.WILDERNESS_CAPE_I,
          ItemID.WILDERNESS_CAPE_X,
          ItemID.SKILLCAPE_WOODCUTTING,
          ItemID.SKILLCAPE_WOODCUTTING_HOOD,
          ItemID.SKILLCAPE_WOODCUTTING_TRIMMED,
          ItemID.COX_CHALLENGE_CAPE_T5,
          ItemID.COX_CHALLENGE_CAPE_T4,
          ItemID.COX_CHALLENGE_CAPE_T1,
          ItemID.COX_CHALLENGE_CAPE_T3,
          ItemID.COX_CHALLENGE_CAPE_T2)),
  MENAGERIE("Menagerie", InventoryID.POH_MENAGERIE_PETS, "menagerie", null),
  BOSS_LAIR_DISPLAY(
      "Boss Lair Display",
      33405,
      "bossLairDisplay",
      Arrays.asList(
          ItemID.JAR_OF_DIRT,
          ItemID.JAR_OF_SWAMP,
          ItemID.JAR_OF_SAND,
          ItemID.JAR_OF_SOULS,
          ItemID.JAR_OF_MIASMA,
          ItemID.JAR_OF_DARKNESS,
          ItemID.JAR_OF_STONE,
          ItemID.JAR_OF_DECAY,
          ItemID.JAR_OF_CHEMICALS,
          ItemID.JAR_OF_EYES,
          ItemID.JAR_OF_DREAMS,
          ItemID.JAR_OF_SPIRITS,
          ItemID.JAR_OF_SMOKE,
          ItemID.JAR_OF_VENOM
      )),
  CAPE_HANGER("Cape Hanger", -1, "capeHanger", null),
  SPICE_RACK("Spice Rack", -1, "spiceRack", null),
  ;

  private final String name;
  private final int itemContainerId;
  // Whether the storage can be updated with no action required by the player
  private final boolean automatic = false;
  private final String configKey;
  private final boolean membersOnly = true;
  @Nullable private final List<Integer> storableItemIds;
  private final List<Integer> accountTypeBlacklist = null;
}

package dev.thource.runelite.dudewheresmystuff.playerownedhouse;

import dev.thource.runelite.dudewheresmystuff.DudeWheresMyStuffPlugin;
import dev.thource.runelite.dudewheresmystuff.ItemStack;
import dev.thource.runelite.dudewheresmystuff.ItemStorage;
import lombok.Getter;
import net.runelite.api.Item;
import net.runelite.api.events.ItemContainerChanged;

/** PlayerOwnedHouseStorage is responsible for tracking storages in the player's house. */
@Getter
public class PlayerOwnedHouseStorage extends ItemStorage<PlayerOwnedHouseStorageType> {

  protected PlayerOwnedHouseStorage(
      PlayerOwnedHouseStorageType type, DudeWheresMyStuffPlugin plugin) {
    super(type, plugin);
  }

  @Override
  public boolean onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
    if (itemContainerChanged.getContainerId() != type.getItemContainerId()) {
      return false;
    }

    updateLastUpdated();
    items.clear();
    for (Item item : itemContainerChanged.getItemContainer().getItems()) {
      if (type.getStorableItemIds() == null || type.getStorableItemIds().contains(item.getId())) {
        items.add(new ItemStack(item.getId(), item.getQuantity(), plugin));
      }
    }

    return true;
  }
}

package dev.thource.runelite.dudewheresmystuff;

import java.awt.Component;
import java.awt.Container;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.util.SwingUtil;

/** EnhancedSwingUtilities fixes some inefficiencies with SwingUtilities. */
@Slf4j
public class EnhancedSwingUtilities {

  private static boolean isInSecondaryLoop;

  private EnhancedSwingUtilities() {
  }

  public static void fastRemoveAll(Container c, ChatMessageManager chatMessageManager) {
    if (!SwingUtilities.isEventDispatchThread()) {
      log.error("fastRemoveAll called outside of the EDT?", new Throwable());

      final ChatMessageBuilder message = new ChatMessageBuilder()
          .append(ChatColorType.HIGHLIGHT)
          .append("Dude, Wheres My Stuff? has just encountered an error!")
          .append(ChatColorType.NORMAL)
          .append(" Please help me fix this issue by sending your runelite client.log file to "
              + "Thource on Discord or attach it to "
              + "https://github.com/Thource/dude-wheres-my-stuff/issues/256");

      chatMessageManager.queue(QueuedMessage.builder()
          .type(ChatMessageType.CONSOLE)
          .runeLiteFormattedMessage(message.build())
          .build());

      return;
    }

    fastRemoveAll(c, true);
  }

  private static void fastRemoveAll(Container c, boolean isMainParent) {
    // If we are not on the EDT this will deadlock, in addition to being totally unsafe
    assert SwingUtilities.isEventDispatchThread();

    // when a component is removed it has to be resized for some reason, but only if it's valid,
    // so we make sure to invalidate everything before removing it
    c.invalidate();
    for (int i = 0; i < c.getComponentCount(); i++) {
      Component ic = c.getComponent(i);

      // removeAll and removeNotify are both recursive, so we have to recurse before them
      if (ic instanceof Container) {
        fastRemoveAll((Container) ic, false);
      }

      // pumpPendingEvents can cause this function to be ran again
      // this conditional stops stack overflows as a result of that
      if (!isInSecondaryLoop) {
        isInSecondaryLoop = true;

        // each removeNotify needs to remove anything from the event queue that is for that widget
        // this however requires taking a lock, and is moderately slow, so we just execute all of
        // those events with a secondary event loop
        SwingUtil.pumpPendingEvents();

        isInSecondaryLoop = false;
      }

      // call removeNotify early; this is most of the work in removeAll, and generates events that
      // the next secondaryLoop will pick up
      ic.removeNotify();
    }

    if (isMainParent) {
      // Actually remove anything
      c.removeAll();
    }
  }
}

package dev.thource.runelite.dudewheresmystuff;

import dev.thource.runelite.dudewheresmystuff.carryable.CarryableStorageType;
import dev.thource.runelite.dudewheresmystuff.coins.CoinsStorageType;
import dev.thource.runelite.dudewheresmystuff.death.DeathbankType;
import dev.thource.runelite.dudewheresmystuff.minigames.MinigamesStorageType;
import dev.thource.runelite.dudewheresmystuff.playerownedhouse.Menagerie;
import dev.thource.runelite.dudewheresmystuff.playerownedhouse.PlayerOwnedHouseStorageType;
import dev.thource.runelite.dudewheresmystuff.stash.StashUnit;
import dev.thource.runelite.dudewheresmystuff.world.Leprechaun;
import dev.thource.runelite.dudewheresmystuff.world.WorldStorageType;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.config.ConfigManager;

/** SaveMigrator converts the player's data from the v1 format to the v2 format. */
@Slf4j
public class SaveMigrator {

  private static final String PREFIX_COINS = "coins.";
  private static final String PREFIX_CARRYABLE = "carryable.";
  private static final String PREFIX_POH = "poh.";
  private static final String PREFIX_MINIGAMES = "minigames.";
  private static final String PREFIX_WORLD = "world.";

  private final ConfigManager configManager;
  private final String rsProfileKey;

  public SaveMigrator(ConfigManager configManager, String rsProfileKey) {
    this.configManager = configManager;
    this.rsProfileKey = rsProfileKey;
  }

  void migrate() {
    log.info("Migrating data for profile: " + rsProfileKey);

    Map<String, String> map = new HashMap<>();
    migrateCoins(map);
    migrateCarryables(map);
    migrateDeaths(map);
    migrateMinigames(map);
    migratePlayerOwnedHouse(map);
    migrateStashes(map);
    migrateWorld(map);

    map.forEach((key, value) -> configManager.setConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP,
        rsProfileKey, key, value));
    configManager.setConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP, rsProfileKey,
        "saveMigrated", true);
    log.info("Profile data migrated!");
  }

  private void migrateCoins(Map<String, String> map) {
    stripLastUpdated(map, PREFIX_COINS + CoinsStorageType.NMZ.getConfigKey());
    stripLastUpdated(map, PREFIX_COINS + CoinsStorageType.LMS.getConfigKey());
    stripLastUpdated(map, PREFIX_COINS + CoinsStorageType.BF.getConfigKey());
    stripLastUpdated(map, PREFIX_COINS + CoinsStorageType.INVENTORY.getConfigKey());
  }

  private void migrateCarryables(Map<String, String> map) {
    simpleItemsMigration(map, PREFIX_CARRYABLE + CarryableStorageType.INVENTORY.getConfigKey(),
        true);
    simpleItemsMigration(map, PREFIX_CARRYABLE + CarryableStorageType.EQUIPMENT.getConfigKey(),
        true);
    simpleItemsMigration(map, PREFIX_CARRYABLE + CarryableStorageType.LOOTING_BAG.getConfigKey(),
        false);
    simpleItemsMigration(map, PREFIX_CARRYABLE + CarryableStorageType.SEED_BOX.getConfigKey(),
        false);
    simpleItemsMigration(map, PREFIX_CARRYABLE + CarryableStorageType.RUNE_POUCH.getConfigKey(),
        true);
    staticItemsMigration(map,
        PREFIX_CARRYABLE + CarryableStorageType.BOTTOMLESS_BUCKET.getConfigKey());
    staticItemsMigration(map, PREFIX_CARRYABLE + CarryableStorageType.PLANK_SACK.getConfigKey()
    );
  }

  private void migrateDeaths(Map<String, String> map) {
    migrateDeathpiles(map);
    migrateDeathbanks(map);
  }

  private void migrateDeathpiles(Map<String, String> map) {
    String oldValue = configManager.getConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        rsProfileKey,
        "death.deathpiles"
    );
    if (oldValue == null) {
      return;
    }

    for (String deathpileData : oldValue.split("\\$")) {
      String[] deathpileDatas = deathpileData.split(";");
      if (deathpileDatas.length < 3) {
        continue;
      }

      UUID uuid = UUID.randomUUID();

      map.put(
          "death.deathpile." + uuid,
          deathpileDatas[2].replace(",", "x").replace("=", ",") + ";"
              + uuid + ";"
              + deathpileDatas[1] + ";"
              + "true;"
              + deathpileDatas[0]
      );
    }
  }

  private void migrateDeathbanks(Map<String, String> map) {
    String currentDeathbankData = configManager.getConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        rsProfileKey,
        "death.deathbank"
    );
    if (currentDeathbankData != null) {
      String[] deathbankDatas = currentDeathbankData.split(";");
      if (deathbankDatas.length >= 4) {
        UUID uuid = UUID.randomUUID();

        map.put(
            "death.deathbank." + uuid,
            deathbankDatas[2] + ";"
                + deathbankDatas[3].replace(",", "x").replace("=", ",") + ";"
                + uuid + ";"
                + deathbankDatas[1] + ";"
                + "-1;"
                + getDeathbankType(deathbankDatas[0])
        );
      }
    }

    String lostDeathbanksData = configManager.getConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        rsProfileKey,
        "death.lostdeathbanks"
    );

    if (lostDeathbanksData != null) {
      for (String lostDeathbankData : lostDeathbanksData.split("\\$")) {
        String[] deathbankDatas = lostDeathbankData.split(";");
        if (deathbankDatas.length >= 3) {
          UUID uuid = UUID.randomUUID();

          map.put(
              "death.deathbank." + uuid,
              deathbankDatas[1] + ";"
                  + deathbankDatas[2].replace(",", "x").replace("=", ",") + ";"
                  + uuid + ";"
                  + "false;"
                  + deathbankDatas[1] + ";"
                  + getDeathbankType(deathbankDatas[0])
          );
        }
      }
    }
  }

  private void migrateMinigames(Map<String, String> map) {
    minigamePointsMigration(map,
        PREFIX_MINIGAMES + MinigamesStorageType.MAGE_TRAINING_ARENA.getConfigKey());
    minigamePointsMigration(map, PREFIX_MINIGAMES + MinigamesStorageType.TITHE_FARM.getConfigKey());
    minigamePointsMigration(map,
        PREFIX_MINIGAMES + MinigamesStorageType.NIGHTMARE_ZONE.getConfigKey());
    minigamePointsMigration(map,
        PREFIX_MINIGAMES + MinigamesStorageType.BARBARIAN_ASSAULT.getConfigKey());
    minigamePointsMigration(map,
        PREFIX_MINIGAMES + MinigamesStorageType.GUARDIANS_OF_THE_RIFT.getConfigKey());
  }

  private void migratePlayerOwnedHouse(Map<String, String> map) {
    simpleItemsMigration(map, PREFIX_POH + PlayerOwnedHouseStorageType.ARMOUR_CASE.getConfigKey(),
        false);
    simpleItemsMigration(map, PREFIX_POH + PlayerOwnedHouseStorageType.CAPE_RACK.getConfigKey(),
        false);
    simpleItemsMigration(map,
        PREFIX_POH + PlayerOwnedHouseStorageType.FANCY_DRESS_BOX.getConfigKey(), false);
    simpleItemsMigration(map,
        PREFIX_POH + PlayerOwnedHouseStorageType.MAGIC_WARDROBE.getConfigKey(), false);
    simpleItemsMigration(map,
        PREFIX_POH + PlayerOwnedHouseStorageType.TREASURE_CHEST_BEGINNER.getConfigKey(), false);
    simpleItemsMigration(map,
        PREFIX_POH + PlayerOwnedHouseStorageType.TREASURE_CHEST_EASY.getConfigKey(), false);
    simpleItemsMigration(map,
        PREFIX_POH + PlayerOwnedHouseStorageType.TREASURE_CHEST_MEDIUM.getConfigKey(), false);
    simpleItemsMigration(map,
        PREFIX_POH + PlayerOwnedHouseStorageType.TREASURE_CHEST_HARD.getConfigKey(), false);
    simpleItemsMigration(map,
        PREFIX_POH + PlayerOwnedHouseStorageType.TREASURE_CHEST_ELITE.getConfigKey(), false);
    simpleItemsMigration(map,
        PREFIX_POH + PlayerOwnedHouseStorageType.TREASURE_CHEST_MASTER.getConfigKey(), false);

    simpleItemsMigration(map, PREFIX_POH + PlayerOwnedHouseStorageType.MENAGERIE.getConfigKey(),
        false);
    String menagerieData = map.get(
        PREFIX_POH + PlayerOwnedHouseStorageType.MENAGERIE.getConfigKey());
    if (menagerieData == null) {
      return;
    }

    String[] menagerieDataSplit = menagerieData.split(";");
    if (menagerieDataSplit.length < 3) {
      return;
    }

    int petBits1 = 0;
    int petBits2 = 0;
    for (String itemStackData : menagerieDataSplit[2].split(",")) {
      int itemId = Integer.parseInt(itemStackData.split("x")[0]);

      int bitId = 0;
      for (List<Integer> itemIds : Menagerie.VARPLAYER_BITS_TO_ITEM_IDS_LIST) {
        int itemIndex = itemIds.indexOf(itemId);

        if (itemIndex != -1) {
          if (bitId == 0) {
            petBits1 |= 1 << itemIndex;
          } else {
            petBits2 |= 1 << itemIndex;
          }

          break;
        }

        bitId += 1;
      }
    }

    map.put(
        PREFIX_POH + PlayerOwnedHouseStorageType.MENAGERIE.getConfigKey(),
        menagerieDataSplit[0] + ";" + menagerieDataSplit[1] + ";" + petBits1 + ";" + petBits2
    );
  }

  private void migrateStashes(Map<String, String> map) {
    for (StashUnit stashUnit : StashUnit.values()) {
      simpleItemsMigration(map, "stash." + stashUnit.getStashUnitData().getObjectId(), false);
    }
  }

  private void migrateWorld(Map<String, String> map) {
    simpleItemsMigration(map, PREFIX_WORLD + WorldStorageType.LOG_STORAGE.getConfigKey(), false);
    simpleItemsMigration(map, PREFIX_WORLD + WorldStorageType.BLAST_FURNACE.getConfigKey(), false);
    simpleItemsMigration(map, PREFIX_WORLD + WorldStorageType.BANK.getConfigKey(), false);
    simpleItemsMigration(map, PREFIX_WORLD + WorldStorageType.GROUP_STORAGE.getConfigKey(), false);
    simpleItemsMigration(map, PREFIX_WORLD + WorldStorageType.LEPRECHAUN.getConfigKey(), true);

    String leprechaunData = map.get(PREFIX_WORLD + WorldStorageType.LEPRECHAUN.getConfigKey());
    if (leprechaunData == null) {
      return;
    }

    List<Integer> itemIds = Arrays.stream(leprechaunData.split(","))
        .map(is -> Integer.parseInt(is.split("x")[0])).collect(
            Collectors.toList());
    List<Long> itemQuantities = Arrays.stream(leprechaunData.split(","))
        .map(is -> Long.parseLong(is.split("x")[1])).collect(
            Collectors.toList());

    int wateringCanIndex = 0;
    if (itemQuantities.get(4) > 0) {
      wateringCanIndex = (Arrays.stream(Leprechaun.getWateringCanIds()).boxed()
          .collect(Collectors.toList()).indexOf(itemIds.get(4)));
    }
    map.put(
        PREFIX_WORLD + WorldStorageType.LEPRECHAUN.getConfigKey(),
        itemQuantities.stream().map(Object::toString).collect(Collectors.joining(","))
            + ";"
            + (itemIds.get(3) == ItemID.FAIRY_ENCHANTED_SECATEURS ? "1" : "0") + ";"
            + wateringCanIndex
    );
  }

  private String stripLastUpdated(String data) {
    return data.substring(data.indexOf(";") + 1);
  }

  private void stripLastUpdated(Map<String, String> map, String configKey) {
    String oldValue = configManager.getConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        rsProfileKey,
        configKey
    );
    if (oldValue == null) {
      return;
    }

    map.put(configKey, stripLastUpdated(oldValue));
  }

  private void simpleItemsMigration(Map<String, String> map, String configKey,
      boolean removeLastUpdated) {
    String oldValue = configManager.getConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        rsProfileKey,
        configKey
    );
    if (oldValue == null) {
      return;
    }

    if (removeLastUpdated) {
      oldValue = stripLastUpdated(oldValue);
    }

    map.put(configKey, oldValue.replace(",", "x").replace("=", ","));
  }

  private void staticItemsMigration(Map<String, String> map, String configKey) {
    String oldValue = configManager.getConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        rsProfileKey,
        configKey
    );
    if (oldValue == null) {
      return;
    }

    String[] parts = oldValue.split(";", 2);
    map.put(configKey, parts[0] + ";" + parts[1].replace(";", ","));
  }

  private void minigamePointsMigration(Map<String, String> map, String configKey) {
    String oldValue = configManager.getConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        rsProfileKey,
        configKey
    );
    if (oldValue == null) {
      return;
    }

    map.put(configKey, oldValue.replace("=", ","));
  }

  private DeathbankType getDeathbankType(String deathbankData) {
    switch (deathbankData) {
      case "hydra":
        return DeathbankType.HYDRA;
      case "guardians":
        return DeathbankType.GUARDIANS;
      case "sepulchre":
        return DeathbankType.SEPULCHRE;
      case "hespori":
        return DeathbankType.HESPORI;
      case "mimic":
        return DeathbankType.MIMIC;
      case "nex":
        return DeathbankType.NEX;
      case "nightmare":
        return DeathbankType.NIGHTMARE;
      case "phosani":
        return DeathbankType.PHOSANI;
      case "tob":
        return DeathbankType.TOB;
      case "volcanicmine":
        return DeathbankType.VOLCANIC_MINE;
      case "vorkath":
        return DeathbankType.VORKATH;
      case "zulrah":
        return DeathbankType.ZULRAH;
      case "questds2":
        return DeathbankType.QUEST_DS2;
      case "questatoh":
        return DeathbankType.QUEST_ATOH;
      case "questsotf":
        return DeathbankType.QUEST_SOTF;
      case "questsote":
        return DeathbankType.QUEST_SOTE;
      case "questtfe":
        return DeathbankType.QUEST_TFE;
      case "unknown":
      default:
        return DeathbankType.UNKNOWN;
    }
  }
}

package dev.thource.runelite.dudewheresmystuff;

import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.events.VarbitChanged;

@RequiredArgsConstructor(access = AccessLevel.PRIVATE)
public class Var {
  private final int varbitId;
  private final int varpId;
  private final VarbitChanged varbitChanged;

  public static Var bit(VarbitChanged varbitChanged, int id) {
    return new Var(id, -1, varbitChanged);
  }

  public static Var player(VarbitChanged varbitChanged, int id) {
    return new Var(-1, id, varbitChanged);
  }

  public int getValue(Client client) {
    if (wasChanged() && varbitChanged.getVarbitId() != -999) {
      return varbitChanged.getValue();
    }

    if (varbitId != -1) {
      return client.getVarbitValue(varbitId);
    }

    return client.getVarpValue(varpId);
  }

  public boolean wasChanged() {
    return varbitChanged.getVarbitId() == -999
        || (varbitId != -1 && varbitChanged.getVarbitId() == varbitId)
        || (varpId != -1 && varbitChanged.getVarpId() == varpId);
  }
}

package dev.thource.runelite.dudewheresmystuff;

import dev.thource.runelite.dudewheresmystuff.carryable.CarryableStorage;
import dev.thource.runelite.dudewheresmystuff.carryable.CarryableStorageManager;
import dev.thource.runelite.dudewheresmystuff.carryable.CarryableStorageType;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.ListIterator;
import net.runelite.api.gameval.ItemID;

/** ItemStackUtils provides methods that interact with Lists of ItemStack. */
public class ItemStackUtils {

  public static final List<Integer> ITEM_IDS_DESTROYED_ON_DEATH = Collections.unmodifiableList(
      Arrays.asList(
          ItemID.LOOTING_BAG,
          ItemID.LOOTING_BAG_OPEN,
          ItemID.BH_CLUE_BOX,
          ItemID.FLAMTAER_BAG,
          ItemID.FLAMTAER_BAG_DUMMY,
          ItemID.LUNAR_HELMET,
          ItemID.LUNAR_TORSO,
          ItemID.LUNAR_LEGS,
          ItemID.LUNAR_GLOVES,
          ItemID.LUNAR_BOOTS,
          ItemID.LUNAR_CAPE,
          ItemID.LUNAR_AMULET,
          ItemID.LUNAR_RING,
          ItemID.LUNAR_MOONCLAN_LIMINAL_STAFF,
          ItemID.RING_OF_CHAROS,
          ItemID.RING_OF_CHAROS_UNLOCKED,
          ItemID.CHRONICLE,
          ItemID.STEEL_GAUNTLETS,
          ItemID.GAUNTLETS_OF_COOKING,
          ItemID.GAUNTLETS_OF_GOLDSMITHING,
          ItemID.GAUNTLETS_OF_CHAOS,
          ItemID.II_MAGIC_BUTTERFLY_NET,
          ItemID.II_JAR_GENERATOR,
          ItemID.DAMNED_AMULET_DEGRADED,
          ItemID.LEAGUE_3_BRONZE_TROPHY,
          ItemID.LEAGUE_3_IRON_TROPHY,
          ItemID.LEAGUE_3_STEEL_TROPHY,
          ItemID.LEAGUE_3_MITHRIL_TROPHY,
          ItemID.LEAGUE_3_ADAMANT_TROPHY,
          ItemID.LEAGUE_3_RUNE_TROPHY,
          ItemID.LEAGUE_3_DRAGON_TROPHY,
          ItemID.TRAILBLAZER_BRONZE_TROPHY,
          ItemID.TRAILBLAZER_IRON_TROPHY,
          ItemID.TRAILBLAZER_STEEL_TROPHY,
          ItemID.TRAILBLAZER_MITHRIL_TROPHY,
          ItemID.TRAILBLAZER_ADAMANT_TROPHY,
          ItemID.TRAILBLAZER_RUNE_TROPHY,
          ItemID.TRAILBLAZER_DRAGON_TROPHY,
          ItemID.TWISTED_BRONZE_TROPHY,
          ItemID.TWISTED_IRON_TROPHY,
          ItemID.TWISTED_STEEL_TROPHY,
          ItemID.TWISTED_MITHRIL_TROPHY,
          ItemID.TWISTED_ADAMANT_TROPHY,
          ItemID.TWISTED_RUNE_TROPHY,
          ItemID.TWISTED_DRAGON_TROPHY,
          ItemID.CRYSTAL_SEED_OLD_SMALL,
          ItemID.EYEGLO_CRYSTAL_SAW
      )
  );

  private ItemStackUtils() {
  }

  /**
   * Compounds a List of ItemStacks, merging ItemStacks with the same id.
   *
   * @param itemStacks           ItemStacks to be compounded
   * @param compoundUnstackables Whether unstackable ItemStacks should be compounded
   * @return a new List of new ItemStacks
   */
  public static List<ItemStack> compound(List<ItemStack> itemStacks, boolean compoundUnstackables) {
    ArrayList<ItemStack> compoundedItemStacks = new ArrayList<>();

    itemStacks.forEach(
        itemStack -> {
          if (itemStack.getId() == -1) {
            return;
          }

          boolean wasCompounded = false;
          if (itemStack.isStackable() || compoundUnstackables) {
            for (ItemStack compoundedItemStack : compoundedItemStacks) {
              if (compoundedItemStack.getId() != itemStack.getId() || compoundedItemStack.getId() < 0) {
                continue;
              }

              compoundedItemStack.setQuantity(
                  compoundedItemStack.getQuantity() + itemStack.getQuantity());
              wasCompounded = true;
            }
          }

          if (!wasCompounded) {
            compoundedItemStacks.add(new ItemStack(itemStack));
          }
        });

    return compoundedItemStacks;
  }

  /**
   * Adds an ItemStack to the supplied List of ItemStacks. If the item is stackable and already
   * exists in the list, it will merge quantities. If there's an empty slot, it will fill it,
   * otherwise it'll be added to the end of the list.
   *
   * @param items     ItemStacks to be added to
   * @param itemToAdd ItemStack to add
   */
  public static void addItemStack(List<ItemStack> items, ItemStack itemToAdd) {
    addItemStack(items, itemToAdd, false);
  }

  /**
   * Adds an ItemStack to the supplied List of ItemStacks. If the item is stackable and already
   * exists in the list, it will merge quantities. If there's an empty slot, it will fill it,
   * otherwise it'll be added to the end of the list.
   *
   * @param items         ItemStacks to be added to
   * @param itemToAdd     ItemStack to add
   * @param forceStacking Whether to stack non-stackable items (like in the bank)
   */
  public static void addItemStack(List<ItemStack> items, ItemStack itemToAdd,
      boolean forceStacking) {
    if (itemToAdd.isStackable() || forceStacking) {
      for (ItemStack item : items) {
        if (item.getId() != itemToAdd.getId()) {
          continue;
        }

        item.setQuantity(item.getQuantity() + itemToAdd.getQuantity());
        return;
      }
    }

    ListIterator<ItemStack> listIterator = items.listIterator();
    while (listIterator.hasNext()) {
      ItemStack item = listIterator.next();
      if (item.getId() != -1) {
        continue;
      }

      listIterator.set(itemToAdd);
      return;
    }

    items.add(itemToAdd);
  }

  /**
   * Removes an ItemStack from the supplied List of ItemStacks. Any removed ItemStacks will be
   * replaced with empty slots.
   *
   * @param items            ItemStacks to remove from
   * @param itemToRemove     ItemStack to remove
   * @param replaceWithEmpty whether fully removed items should be replaced by an "empty" item
   */
  public static void removeItemStack(
      List<ItemStack> items, ItemStack itemToRemove, boolean replaceWithEmpty) {
    if (itemToRemove.getId() == -1) {
      return;
    }

    long quantityToRemove = itemToRemove.getQuantity();

    ListIterator<ItemStack> listIterator = items.listIterator();
    while (listIterator.hasNext() && quantityToRemove > 0) {
      ItemStack inventoryItem = listIterator.next();

      if (inventoryItem.getId() != itemToRemove.getId()) {
        continue;
      }

      long qtyToRemove = Math.min(quantityToRemove, inventoryItem.getQuantity());
      quantityToRemove -= qtyToRemove;
      inventoryItem.setQuantity(inventoryItem.getQuantity() - qtyToRemove);
      if (inventoryItem.getQuantity() == 0) {
        if (replaceWithEmpty) {
          listIterator.set(new ItemStack(-1, "empty", 1, 0, 0, false));
        } else {
          listIterator.remove();
        }
      }
    }
  }

  public static void removeItemStack(List<ItemStack> items, ItemStack itemToRemove) {
    removeItemStack(items, itemToRemove, true);
  }

  /**
   * Removes a list of items from another list of items.
   *
   * @param itemsToModify the list of items to remove from
   * @param itemsToRemove the list of items to be removed
   */
  public static void removeItems(List<ItemStack> itemsToModify, List<ItemStack> itemsToRemove) {
    for (ItemStack itemStack : itemsToRemove) {
      ItemStackUtils.removeItemStack(itemsToModify, itemStack, false);
    }
  }

  public static List<ItemStack> explodeStorageItems(List<ItemStack> itemStacks,
      CarryableStorageManager carryableStorageManager) {
    ArrayList<ItemStack> explodedItemStacks = new ArrayList<>();
    itemStacks.forEach(itemStack -> explodedItemStacks.add(new ItemStack(itemStack)));

    boolean isLootingBagPresent = false;
    ListIterator<ItemStack> itemStacksIterator = explodedItemStacks.listIterator();
    while (itemStacksIterator.hasNext()) {
      ItemStack itemStack = itemStacksIterator.next();

      for (CarryableStorage storage : carryableStorageManager.getStorages()) {
        CarryableStorageType storageType = storage.getType();

        if (storageType == CarryableStorageType.LOOTING_BAG
            || storageType.getContainerIds().isEmpty()
            || !storageType.getContainerIds().contains(itemStack.getId())
            || storageType.getEmptyOnDeathVarbit() == -1
            || storage.getPlugin().getClient().getVarbitValue(storageType.getEmptyOnDeathVarbit())
                != 1) {
          continue;
        }

        storage.getItems().forEach(itemStacksIterator::add);
      }

      if (CarryableStorageType.LOOTING_BAG.getContainerIds().contains(itemStack.getId())) {
        isLootingBagPresent = true;
      }
    }

    if (isLootingBagPresent) {
      carryableStorageManager.getStorages().stream()
          .filter(s -> s.getType() == CarryableStorageType.LOOTING_BAG)
          .findFirst()
          .ifPresent(lootingBag -> explodedItemStacks.addAll(lootingBag.getItems()));
    }

    return explodedItemStacks;
  }

  public static List<ItemStack> filterDestroyedOnDeath(List<ItemStack> itemStacks) {
    ArrayList<ItemStack> filteredItemStacks = new ArrayList<>();
    itemStacks.forEach(itemStack -> filteredItemStacks.add(new ItemStack(itemStack)));

    filteredItemStacks.removeIf(
        itemStack -> ITEM_IDS_DESTROYED_ON_DEATH.contains(itemStack.getId()));

    return filteredItemStacks;
  }
}

/*
 * Copyright (c) 2022, Thource <https://github.com/Thource>
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package dev.thource.runelite.dudewheresmystuff;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.ListIterator;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.client.util.Text;

/** StoragePanel is responsible for displaying items to the player. */
public class StoragePanel extends JPanel {

  private static final int ITEMS_PER_ROW = 4;
  private static final int TITLE_PADDING = 5;

  private final JPanel titlePanel = new JPanel();
  private final JLabel titleLabel = new JLabel();
  private final JLabel subTitleLabel = new JLabel();
  private final JLabel priceLabel;
  private final JPanel itemContainer = new JPanel();
  private final JPanel footerPanel = new JPanel();
  @Getter private final JLabel footerLabel = new JLabel();
  private final transient DudeWheresMyStuffPlugin plugin;
  @Getter private final transient Storage<?> storage;
  private final boolean displayEmptyStacks;
  private final boolean combineIdenticalStacks;
  @Getter private List<ItemBox> itemBoxes = new ArrayList<>();
  @Nullable private JComponent popupButton;
  private final List<ItemStack> items = new ArrayList<>();

  /**
   * A constructor.
   *
   * @param plugin                 the plugin
   * @param storage                the storage that this panel represents
   * @param showPrice              if prices should be shown
   * @param displayEmptyStacks     if empty stacks should be shown
   * @param combineIdenticalStacks if stacks should be compounded
   */
  public StoragePanel(
      DudeWheresMyStuffPlugin plugin,
      Storage<?> storage,
      boolean showPrice,
      boolean displayEmptyStacks,
      boolean combineIdenticalStacks) {
    this.plugin = plugin;
    this.storage = storage;
    this.displayEmptyStacks = displayEmptyStacks;
    this.combineIdenticalStacks = combineIdenticalStacks;

    setLayout(new BorderLayout(0, 1));
    setBorder(new EmptyBorder(5, 0, 0, 0));
    setBackground(null);

    titlePanel.setLayout(new BoxLayout(titlePanel, BoxLayout.X_AXIS));
    titlePanel.setBorder(new EmptyBorder(7, 7, 7, 7));
    titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
    titlePanel.setInheritsPopupMenu(true);

    titleLabel.setText(Text.removeTags(storage.getName()));
    titleLabel.setFont(FontManager.getRunescapeSmallFont());
    titleLabel.setForeground(Color.WHITE);
    // Set a size to make BoxLayout truncate the name
    titleLabel.setMinimumSize(new Dimension(1, titleLabel.getPreferredSize().height));
    titleLabel.setInheritsPopupMenu(true);

    subTitleLabel.setFont(FontManager.getRunescapeSmallFont());
    subTitleLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
    subTitleLabel.setInheritsPopupMenu(true);

    titlePanel.add(titleLabel);
    titlePanel.add(Box.createRigidArea(new Dimension(TITLE_PADDING, 0)));
    titlePanel.add(subTitleLabel);
    titlePanel.add(Box.createHorizontalGlue());
    titlePanel.add(Box.createRigidArea(new Dimension(TITLE_PADDING, 0)));

    titlePanel.addMouseListener(new MouseAdapter() {
      private final Component rigidArea = Box.createRigidArea(new Dimension(TITLE_PADDING, 0));

      @Override
      public void mouseEntered(MouseEvent e) {
        if (popupButton == null) {
          return;
        }

        titlePanel.add(rigidArea);
        titlePanel.add(popupButton);
        titlePanel.revalidate();
      }

      @Override
      public void mouseExited(MouseEvent e) {
        if (popupButton == null || !isShowing() || titlePanel.getVisibleRect().contains(e.getPoint())) {
          return;
        }

        titlePanel.remove(rigidArea);
        titlePanel.remove(popupButton);
        titlePanel.revalidate();
      }
    });
    MouseAdapter toggleListener =
        new MouseAdapter() {
          @Override
          public void mouseClicked(MouseEvent e) {
            if (e.getButton() == 1) {
              toggle();
            }
          }
        };
    titlePanel.addMouseListener(toggleListener);
    subTitleLabel.addMouseListener(toggleListener);

    if (showPrice) {
      priceLabel = new JLabel();
      priceLabel.setFont(FontManager.getRunescapeSmallFont());
      priceLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
      titlePanel.add(priceLabel);
      priceLabel.addMouseListener(toggleListener);
    } else {
      priceLabel = null;
    }

    itemContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

    footerPanel.setLayout(new BoxLayout(footerPanel, BoxLayout.X_AXIS));
    footerPanel.setBorder(new EmptyBorder(7, 7, 7, 7));
    footerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    footerPanel.setVisible(false);

    footerLabel.setFont(FontManager.getRunescapeSmallFont());
    footerLabel.setForeground(Color.WHITE);
    footerLabel.setText("Placeholder");
    // Set a size to make BoxLayout truncate the name
    footerLabel.setMinimumSize(new Dimension(1, footerLabel.getPreferredSize().height));
    footerLabel.setText("");
    footerPanel.add(footerLabel);

    add(titlePanel, BorderLayout.NORTH);
    add(itemContainer, BorderLayout.CENTER);
    add(footerPanel, BorderLayout.SOUTH);

    update();
  }

  @Override
  public void setComponentPopupMenu(JPopupMenu popup) {
    super.setComponentPopupMenu(popup);
    if (popup == null) {
      if (popupButton != null) {
        titlePanel.remove(popupButton);
        popupButton = null;
      }

      return;
    }

    if (popupButton != null) {
      return;
    }

    popupButton = new JButton("");
    popupButton.setPreferredSize(new Dimension(20, -1));
    popupButton.addMouseListener(new MouseAdapter() {
      @Override
      public void mousePressed(MouseEvent mouseEvent) {
        getComponentPopupMenu().show(popupButton, mouseEvent.getX(), mouseEvent.getY());
      }
    });
  }

  public String getTitle() {
    return titleLabel.getText();
  }

  public void setTitle(String text) {
    titleLabel.setText(text);
  }

  public String getSubTitle() {
    return subTitleLabel.getText();
  }

  public void setSubTitle(String text) {
    subTitleLabel.setText(text);
    subTitleLabel.setToolTipText(text);
  }

  public String getFooterText() {
    return footerLabel.getText();
  }

  public void setFooterText(String text) {
    footerPanel.setVisible(!Objects.equals(text, ""));
    footerLabel.setText(text);
  }

  private void updatePrice() {
    if (priceLabel != null) {
      long totalPrice = 0;
      synchronized (items) {
        for (ItemStack item : items) {
          totalPrice += item.getTotalGePrice();
        }
      }

      priceLabel.setText(QuantityFormatter.quantityToStackSize(totalPrice) + " gp");
      priceLabel.setToolTipText(QuantityFormatter.formatNumber(totalPrice) + " gp");
    }
  }

  private void redrawItems() {
    EnhancedSwingUtilities.fastRemoveAll(itemContainer, plugin.getChatMessageManager());
    itemContainer.setLayout(null);

    if (itemBoxes.stream().anyMatch(itemBox -> itemBox.getItemId() != -1)) {
      // Calculates how many rows need to be display to fit all items
      final int rowSize =
          ((itemBoxes.size() % ITEMS_PER_ROW == 0) ? 0 : 1) + itemBoxes.size() / ITEMS_PER_ROW;

      itemContainer.setLayout(new GridLayout(rowSize, ITEMS_PER_ROW, 1, 1));

      for (int i = 0; i < rowSize * ITEMS_PER_ROW; i++) {
        if (i < itemBoxes.size()) {
          itemContainer.add(itemBoxes.get(i));
        } else {
          itemContainer.add(new ItemBox(plugin, null, displayEmptyStacks));
        }
      }
    }
  }

  private void updateItems() {
    if (storage.getType().isAutomatic() || storage.getLastUpdated() != -1) {
      synchronized (items) {
        itemBoxes =
            items.stream()
                .filter(item -> displayEmptyStacks || item.getQuantity() > 0)
                .map(
                    itemStack -> {
                      ListIterator<ItemBox> itemBoxesIterator = itemBoxes.listIterator();
                      while (itemBoxesIterator.hasNext()) {
                        ItemBox box = itemBoxesIterator.next();
                        if (box.getItemId() == itemStack.getId()
                            && box.getItemQuantity() == itemStack.getQuantity()) {
                          itemBoxesIterator.remove();
                          return box;
                        }
                      }

                      return new ItemBox(plugin, itemStack, displayEmptyStacks);
                    })
                .collect(Collectors.toList());
      }
    } else {
      itemBoxes.clear();
    }

    redrawItems();
  }

  protected List<ItemStack> getNewItems() {
    ItemSortMode itemSortMode = plugin.getConfig().itemSortMode();
    Stream<ItemStack> newItemStream = storage.getItems().stream().map(ItemStack::new);

    if (itemSortMode == ItemSortMode.VALUE) {
      newItemStream = newItemStream.sorted(Comparator.comparingLong(ItemStack::getTotalGePrice)
          .thenComparing(ItemStack::getTotalHaPrice).reversed());
    }

    List<ItemStack> newItems = newItemStream.collect(Collectors.toList());
    if (itemSortMode != ItemSortMode.UNSORTED && combineIdenticalStacks) {
      newItems = ItemStackUtils.compound(newItems, true);
    }

    return newItems;
  }

  public void refreshItems() {
    synchronized (items) {
      items.clear();
      items.addAll(getNewItems());
    }
  }

  /** Updates the total price and all items in the storage. */
  public void update() {
    updatePrice();
    updateItems();

    revalidate();
  }

  /** Toggles the storage between expanded/collapsed state. */
  public void toggle() {
    if (isCollapsed()) {
      expand();
    } else {
      collapse();
    }
  }

  public void collapse() {
    collapse(false);
  }

  /**
   * Collapses the storage, reducing it to just the header and footer bars.
   *
   * @param force collapse the storage even if there are no items in it
   */
  public void collapse(boolean force) {
    if (!force && itemBoxes.isEmpty()) {
      return;
    }

    if (!isCollapsed()) {
      itemContainer.setVisible(false);
      applyDimmer(false, titlePanel);
    }
  }

  /** Expands the storage, making the items visible again. */
  public void expand() {
    if (itemBoxes.isEmpty()) {
      return;
    }

    if (isCollapsed()) {
      itemContainer.setVisible(true);
      applyDimmer(true, titlePanel);
    }
  }

  public boolean isCollapsed() {
    return !itemContainer.isVisible();
  }

  private void applyDimmer(boolean brighten, JPanel panel) {
    for (Component component : panel.getComponents()) {
      Color color = component.getForeground();

      component.setForeground(brighten ? color.brighter() : color.darker());
    }
  }

  public String getTitleToolTip() {
    return titleLabel.getToolTipText();
  }

  public void setTitleToolTip(String text) {
    titleLabel.setToolTipText(text);
  }
}

package dev.thource.runelite.dudewheresmystuff;

public enum StoredItemCountTooltipMode {
  OFF,
  SIMPLE,
  DETAILED
}

package dev.thource.runelite.dudewheresmystuff;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.util.Comparator;
import java.util.List;
import java.util.ListIterator;
import java.util.stream.Collectors;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.IconTextField;

class SearchTabPanel
    extends StorageTabPanel<
    StorageType, Storage<StorageType>, StorageManager<StorageType, Storage<StorageType>>> {

  private static final String EMPTY_SEARCH_TEXT =
      "<html>Type at least 3 characters in the search bar to find your stuff</html>";
  private static final String NO_RESULTS_TEXT =
      "<html>No items found for your search criteria</html>";
  @Getter private final IconTextField searchBar;
  private final transient StorageManagerManager storageManagerManager;
  private final JLabel searchStatusLabel;
  private final JPanel searchStatusPanel;

  SearchTabPanel(DudeWheresMyStuffPlugin plugin, StorageManagerManager storageManagerManager) {
    super(plugin, new SearchStorageManager(plugin));
    this.storageManagerManager = storageManagerManager;

    searchBar = new IconTextField();
    searchBar.setIcon(IconTextField.Icon.SEARCH);
    searchBar.setPreferredSize(new Dimension(getWidth(), 30));
    searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
    searchBar
        .getDocument()
        .addDocumentListener(
            new DocumentListener() {
              @Override
              public void insertUpdate(DocumentEvent e) {
                onSearchBarChanged();
              }

              @Override
              public void removeUpdate(DocumentEvent e) {
                onSearchBarChanged();
              }

              @Override
              public void changedUpdate(DocumentEvent e) {
                onSearchBarChanged();
              }
            });

    JPanel searchBarContainer = new JPanel();
    searchBarContainer.setLayout(new BoxLayout(searchBarContainer, BoxLayout.Y_AXIS));
    searchBarContainer.setBorder(new EmptyBorder(6, 0, 2, 0));
    searchBarContainer.add(searchBar);

    searchStatusLabel = new JLabel(EMPTY_SEARCH_TEXT);
    searchStatusLabel.setFont(FontManager.getRunescapeFont());
    searchStatusLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
    searchStatusLabel.setVerticalAlignment(SwingConstants.CENTER);
    searchStatusLabel.setHorizontalAlignment(SwingConstants.CENTER);

    searchStatusPanel = new JPanel(new BorderLayout());
    searchStatusPanel.setBorder(new EmptyBorder(7, 7, 7, 7));
    searchStatusPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    searchStatusPanel.add(searchStatusLabel);

    add(searchBarContainer, 1);
    add(searchStatusPanel, 2);
  }

  private void onSearchBarChanged() {
    if (searchBar.getText().length() >= 3) {
      searchStatusPanel.setVisible(false);

      plugin.getClientThread().invoke(() -> {
        storagePanels.forEach(
            panel -> {
              ((SearchStoragePanel) panel).setSearchText(searchBar.getText());
              panel.refreshItems();
            });

        SwingUtilities.invokeLater(() -> {
          storagePanels.forEach(StoragePanel::update);

          reorderStoragePanels();

          if (storagePanelContainer.getComponentCount() == 0) {
            searchStatusLabel.setText(NO_RESULTS_TEXT);
            searchStatusPanel.setVisible(true);
          }
        });
      });
    } else {
      searchStatusLabel.setText(EMPTY_SEARCH_TEXT);
      searchStatusPanel.setVisible(true);

      EnhancedSwingUtilities.fastRemoveAll(storagePanelContainer, plugin.getChatMessageManager());
      storagePanelContainer.revalidate();
    }

    softUpdate();
  }

  @Override
  public void reorderStoragePanels() {
    EnhancedSwingUtilities.fastRemoveAll(storagePanelContainer, plugin.getChatMessageManager());
    storagePanels.stream()
        .filter(panel -> !panel.getItemBoxes().isEmpty())
        .sorted(Comparator.comparing(panel -> panel.getStorage().getName()))
        .forEach(storagePanelContainer::add);

    storagePanelContainer.revalidate();
  }

  @Override
  protected Comparator<Storage<StorageType>> getStorageSorter() {
    return Comparator.comparing(Storage::getName);
  }

  @Override
  public void softUpdate() {
    List<? extends Storage<? extends Enum<? extends Enum<?>>>> storages =
        storageManagerManager.getStorages().filter(Storage::isEnabled).collect(Collectors.toList());

    storages.forEach(
        storage -> {
          if (storagePanels.stream().noneMatch(panel -> panel.getStorage() == storage)) {
            storagePanels.add(new SearchStoragePanel(plugin, storage));
          }
        });

    ListIterator<StoragePanel> iterator = storagePanels.listIterator();
    while (iterator.hasNext()) {
      Storage<?> storage = iterator.next().getStorage();

      if (!storages.contains(storage)) {
        iterator.remove();
      }
    }

    storagePanels.stream()
        .filter(panel -> panel.getParent() != null && panel.getStorage().getStoragePanel() != null)
        .forEach(
            panel -> {
              panel.getStorage().softUpdate();

              StoragePanel sourcePanel = panel.getStorage().getStoragePanel();
              panel.setTitle(sourcePanel.getTitle());
              panel.setTitleToolTip(sourcePanel.getTitleToolTip());
              panel.setSubTitle(sourcePanel.getSubTitle());
              panel.setFooterText(sourcePanel.getFooterText());
            });

    super.softUpdate();
  }

  public void refreshItemSortMode() {
    plugin.getClientThread().invoke(() -> storagePanels.forEach(panel -> {
      panel.refreshItems();
      SwingUtilities.invokeLater(panel::update);
    }));
  }
}

package dev.thource.runelite.dudewheresmystuff;

import dev.thource.runelite.dudewheresmystuff.coins.CoinsStorageType;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.annotation.Nullable;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.config.ConfigManager;

/** Storage serves as a base class for all trackable data in the plugin. */
@Slf4j
@Getter
public abstract class Storage<T extends StorageType> {

  protected final DudeWheresMyStuffPlugin plugin;
  protected final T type;
  protected boolean enabled = true;
  @Nullable protected StoragePanel storagePanel;
  @Nullable protected String lastSaveString;
  @Setter protected long lastUpdated = -1L;

  protected Storage(T type, DudeWheresMyStuffPlugin plugin) {
    this.type = type;
    this.plugin = plugin;
  }

  protected void createComponentPopupMenu(StorageManager<?, ?> storageManager) {
    if (storagePanel == null) {
      return;
    }

    final JPopupMenu popupMenu = new JPopupMenu();
    popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));

    if (!type.isAutomatic()) {
      final JMenuItem reset = new JMenuItem("Reset");
      reset.addActionListener(
          e -> {
            boolean confirmed =
                DudeWheresMyStuffPlugin.getConfirmation(
                    storagePanel,
                    "Are you sure you want to reset your "
                        + type.getName()
                        + " data?\nThis cannot be undone.",
                    "Confirm reset");

            if (confirmed) {
              deleteData(storageManager);
              plugin
                  .getClientThread()
                  .invoke(
                      () -> {
                        storagePanel.refreshItems();

                        SwingUtilities.invokeLater(
                            () -> {
                              storagePanel.update();
                              softUpdate();
                              storageManager.getStorageTabPanel().reorderStoragePanels();
                            });
                      });
            }
          });
      popupMenu.add(reset);
    }

    if (!storageManager.isPreviewManager() && type != CoinsStorageType.INVENTORY
        && type != CoinsStorageType.LOOTING_BAG && type != CoinsStorageType.BANK) {
      final var itemCountConfigKey = "storedItemCountInclude." + getConfigKey(storageManager.getConfigKey());
      var storageIncluded = new AtomicBoolean(
          Objects.equals(Objects.requireNonNullElse(plugin.getConfigManager().getConfiguration(
              DudeWheresMyStuffConfig.CONFIG_GROUP,
              itemCountConfigKey
          ), "true"), "true")
      );
      final JMenuItem toggleItemCountInclusion = new JMenuItem(
          (storageIncluded.get() ? "Exclude from" : "Include in") + " item count tooltip"
      );
      toggleItemCountInclusion.addActionListener(
          e -> {
            storageIncluded.set(!storageIncluded.get());
            plugin.getConfigManager().setConfiguration(
                DudeWheresMyStuffConfig.CONFIG_GROUP,
                itemCountConfigKey,
                storageIncluded.get()
            );

            toggleItemCountInclusion.setText(
                (storageIncluded.get() ? "Exclude from" : "Include in") + " item count tooltip"
            );
          });
      popupMenu.add(toggleItemCountInclusion);
    }

    if (popupMenu.getSubElements().length > 0) {
      storagePanel.setComponentPopupMenu(popupMenu);
    }
  }

  /**
   * Deletes the data for this storage from the config and resets the storage.
   *
   * @param storageManager the storage manager that relates to this storage
   */
  public void deleteData(StorageManager<?, ?> storageManager) {
    String profileKey = storageManager.isPreviewManager() ? plugin.getPreviewProfileKey()
        : storageManager.getConfigManager().getRSProfileKey();

    storageManager.getConfigManager().unsetConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        profileKey,
        getConfigKey(storageManager.getConfigKey())
    );
    reset();
  }

  protected void createStoragePanel(StorageManager<?, ?> storageManager) {
    storagePanel = new StoragePanel(plugin, this, true, false, true);

    createComponentPopupMenu(storageManager);
  }

  public long getTotalValue() {
    return 0;
  }

  public boolean onGameTick() {
    return false;
  }

  public boolean onGameObjectSpawned(GameObjectSpawned gameObjectSpawned) {
    return false;
  }

  @SuppressWarnings("java:S1172") // the parameter is used in child classes
  public boolean onWidgetLoaded(WidgetLoaded widgetLoaded) {
    return false;
  }

  @SuppressWarnings("java:S1172") // the parameter is used in child classes
  public void onWidgetClosed(WidgetClosed widgetClosed) {
  }

  @SuppressWarnings("java:S1172") // the parameter is used in child classes
  public boolean onChatMessage(ChatMessage chatMessage) {
    return false;
  }

  @SuppressWarnings("java:S1172") // the parameter is used in child classes
  public boolean onVarbitChanged(VarbitChanged varbitChanged) {
    return false;
  }

  @SuppressWarnings({"java:S1172", "unused"}) // the parameter is used in child classes
  public boolean onMenuOptionClicked(MenuOptionClicked menuOption) {
    return false;
  }

  /**
   * Can the items in this storage be withdrawn?
   *
   * <p>Should be overridden by subclasses. Should be false for things like minigame points,
   * expired deathbanks, or deposit-only storages such as balloon log storage.
   *
   * <p>NOTE: this abstraction does not work for storages where some items are real and others are
   * not. For example, the ores in blast furnace storage cannot be withdrawn but bars can. Also,
   * some items in the POH may be unable to be withdrawn by UIMs without getting the full set.
   *
   * @return true if the items are withdrawable, otherwise false
   */
  public boolean isWithdrawable() {
    return enabled;
  }

  /**
   * tells the Storage that the onItemContainerChanged event was called and that it should update
   * the player's trackable data.
   *
   * @param itemContainerChanged the ItemContainerChanged event
   * @return whether the data changed
   */
  public boolean onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
    return false;
  }

  /**
   * resets the Storage back to it's initial state, useful for when the player logs out, for
   * example.
   */
  public void reset() {
    lastUpdated = -1;
    lastSaveString = null;
    enable();
  }

  /** saves the Storage data to the player's RuneLite RS profile config. */
  public void save(ConfigManager configManager, String profileKey, String managerConfigKey) {
    if (!type.isAutomatic() && lastUpdated == -1L) {
      return;
    }

    String saveString = getSaveString();
    if (Objects.equals(lastSaveString, saveString)) {
      return;
    }

    this.lastSaveString = saveString;
    configManager.setConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP, profileKey,
        getConfigKey(managerConfigKey), saveString);
  }

  public String getSaveString() {
    return String.join(";", getSaveValues());
  }

  protected ArrayList<String> getSaveValues() {
    ArrayList<String> saveValues = new ArrayList<>();

    if (!type.isAutomatic()) {
      saveValues.add(SaveFieldFormatter.format(lastUpdated));
    }

    return saveValues;
  }

  /** loads the Storage data from the specified RuneLite RS profile config. */
  public void load(ConfigManager configManager, String managerConfigKey, String profileKey) {
    String data =
        configManager.getConfiguration(
            DudeWheresMyStuffConfig.CONFIG_GROUP,
            profileKey,
            getConfigKey(managerConfigKey),
            String.class);

    if (data == null) {
      return;
    }

    this.lastSaveString = data;
    loadValues(new ArrayList<>(Arrays.asList(data.split(";"))));
  }

  protected void loadValues(ArrayList<String> values) {
    if (!type.isAutomatic()) {
      lastUpdated = SaveFieldLoader.loadLong(values, lastUpdated);
    }
  }

  protected String getConfigKey(String managerConfigKey) {
    return managerConfigKey + "." + type.getConfigKey();
  }

  /** Disables the storage. */
  public void disable() {
    enabled = false;

    if (storagePanel != null) {
      SwingUtilities.invokeLater(() -> storagePanel.setVisible(false));
    }
  }

  /** Disables the storage. */
  public void disable(boolean isMember, int accountType) {
    if ((type.isMembersOnly() && !isMember)
        || (type.getAccountTypeBlacklist() != null
        && type.getAccountTypeBlacklist().contains(accountType))) {
      disable();
    }
  }

  /** Enables the storage. */
  public void enable() {
    enabled = true;

    if (storagePanel != null) {
      SwingUtilities.invokeLater(() -> storagePanel.setVisible(true));
    }
  }

  public String getName() {
    return type.getName();
  }

  /** Updates the storage's panel. */
  public void softUpdate() {
    if (storagePanel == null) {
      return;
    }

    if (!type.isAutomatic()) {
      if (lastUpdated == -1) {
        storagePanel.setFooterText("No data");
      } else {
        long timeSinceLastUpdate = System.currentTimeMillis() - lastUpdated;
        storagePanel.setFooterText(
            "Updated " + DurationFormatter.format(Math.abs(timeSinceLastUpdate)) + " ago");
      }
    }
  }

  public List<ItemStack> getItems() {
    return new ArrayList<>();
  }

  public long getItemCount(int canonicalId) {
    return getItems().stream().filter(stack -> stack.getCanonicalId() == canonicalId)
        .mapToLong(ItemStack::getQuantity).sum();
  }

  protected void updateLastUpdated() {
    lastUpdated = System.currentTimeMillis();
  }

  public boolean includeInStoredItemCount(String managerConfigKey) {
    var configManager = plugin.getConfigManager();

    var managerIncludedValue = configManager.getConfiguration(DudeWheresMyStuffConfig.CONFIG_GROUP,
        "storedItemCountInclude." + managerConfigKey);
    if (Objects.equals(managerIncludedValue, "false")) {
      return false;
    }

    var storageIncludedValue = Objects.requireNonNullElse(configManager.getConfiguration(
        DudeWheresMyStuffConfig.CONFIG_GROUP,
        "storedItemCountInclude." + getConfigKey(managerConfigKey)
    ), "true");
    return Objects.equals(storageIncludedValue, "true");
  }
}

package dev.thource.runelite.dudewheresmystuff;

import java.awt.image.BufferedImage;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.ImageUtil;

/** Represents which icon to show in the runelite sidebar. */
@Getter
@RequiredArgsConstructor
public enum SidebarIcon {
  DEFAULT(null),
  OVERVIEW(Tab.OVERVIEW),
  DEATH(Tab.DEATH),
  COINS(Tab.COINS),
  CARRYABLE_STORAGE(Tab.CARRYABLE_STORAGE),
  STASH_UNITS(Tab.STASH_UNITS),
  POH_STORAGE(Tab.POH_STORAGE),
  WORLD(Tab.WORLD),
  MINIGAMES(Tab.MINIGAMES);

  private final Tab tab;

  @Override
  public String toString() {
    if (tab == null) {
      return "Default";
    }

    return tab.getName();
  }

  /**
   * Gets the icon to be used in the sidebar.
   *
   * @param itemManager item manager
   * @return sidebar icon
   */
  public BufferedImage getIcon(ItemManager itemManager) {
    if (tab == null) {
      return ImageUtil.loadImageResource(getClass(), "icon.png");
    }

    return itemManager.getImage(tab.getItemId(), tab.getItemQuantity(), false);
  }
}

package dev.thource.runelite.dudewheresmystuff;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.LayoutManager;

/** InvisibleGridLayout works exactly like GridLayout, but it works with hidden children. */
public class InvisibleGridLayout implements LayoutManager, java.io.Serializable {

  private static final String ZERO_ROW_COL_ERROR_TEXT = "rows and cols cannot both be zero";
  private final int hgap;
  private final int vgap;
  private final int rows;
  private final int cols;

  public InvisibleGridLayout(int rows, int cols) {
    this(rows, cols, 0, 0);
  }

  /** A constructor. */
  public InvisibleGridLayout(int rows, int cols, int hgap, int vgap) {
    if ((rows == 0) && (cols == 0)) {
      throw new IllegalArgumentException(ZERO_ROW_COL_ERROR_TEXT);
    }
    this.rows = rows;
    this.cols = cols;
    this.hgap = hgap;
    this.vgap = vgap;
  }

  public void addLayoutComponent(String name, Component comp) {
    // empty because this file was copy-pasted and that's just the way it is
  }

  public void removeLayoutComponent(Component comp) {
    // empty because this file was copy-pasted and that's just the way it is
  }

  /** A method. */
  public Dimension preferredLayoutSize(Container parent) {
    synchronized (parent.getTreeLock()) {
      Insets insets = parent.getInsets();
      int ncomponents = getVisibleComponents(parent);
      int nrows = rows;
      int ncols = cols;

      if (nrows > 0) {
        ncols = (ncomponents + nrows - 1) / nrows;
      } else {
        nrows = (ncomponents + ncols - 1) / ncols;
      }
      int w = 0;
      int h = 0;
      for (int i = 0; i < parent.getComponentCount(); i++) {
        Component comp = parent.getComponent(i);

        if (!comp.isVisible()) {
          continue; // added
        }

        Dimension d = comp.getPreferredSize();
        if (w < d.width) {
          w = d.width;
        }
        if (h < d.height) {
          h = d.height;
        }
      }

      return new Dimension(
          insets.left + insets.right + ncols * w + (ncols - 1) * hgap,
          insets.top + insets.bottom + nrows * h + (nrows - 1) * vgap);
    }
  }

  /** A method. */
  public Dimension minimumLayoutSize(Container parent) {
    synchronized (parent.getTreeLock()) {
      Insets insets = parent.getInsets();
      int ncomponents = getVisibleComponents(parent);
      int nrows = rows;
      int ncols = cols;

      if (nrows > 0) {
        ncols = (ncomponents + nrows - 1) / nrows;
      } else {
        nrows = (ncomponents + ncols - 1) / ncols;
      }
      int w = 0;
      int h = 0;
      for (int i = 0; i < parent.getComponentCount(); i++) {
        Component comp = parent.getComponent(i);

        if (!comp.isVisible()) {
          continue; // added
        }

        Dimension d = comp.getMinimumSize();
        if (w < d.width) {
          w = d.width;
        }
        if (h < d.height) {
          h = d.height;
        }
      }

      return new Dimension(
          insets.left + insets.right + ncols * w + (ncols - 1) * hgap,
          insets.top + insets.bottom + nrows * h + (nrows - 1) * vgap);
    }
  }

  /** A method. */
  @SuppressWarnings("java:S3776")
  public void layoutContainer(Container parent) {
    synchronized (parent.getTreeLock()) {
      Insets insets = parent.getInsets();
      int ncomponents = getVisibleComponents(parent);
      int nrows = rows;
      int ncols = cols;

      if (ncomponents == 0) {
        return;
      }
      if (nrows > 0) {
        ncols = (ncomponents + nrows - 1) / nrows;
      } else {
        nrows = (ncomponents + ncols - 1) / ncols;
      }

      int w = parent.getSize().width - (insets.left + insets.right);
      int h = parent.getSize().height - (insets.top + insets.bottom);
      w = (w - (ncols - 1) * hgap) / ncols;
      h = (h - (nrows - 1) * vgap) / nrows;

      int i = 0;

      boolean ltr = parent.getComponentOrientation().isLeftToRight();
      if (ltr) {
        for (int r = 0, y = insets.top; r < nrows; r++, y += h + vgap) {
          int c = 0;
          int x = insets.left;

          while (c < ncols) {
            if (i >= parent.getComponentCount()) {
              break;
            }

            Component component = parent.getComponent(i);

            if (component.isVisible()) {
              parent.getComponent(i).setBounds(x, y, w, h);
              c++;
              x += w + hgap;
            }

            i++;
          }
        }
      }
    }
  }

  private int getVisibleComponents(Container parent) {
    int visible = 0;

    for (Component c : parent.getComponents()) {
      if (c.isVisible()) {
        visible++;
      }
    }

    return visible;
  }

  /** A method. */
  public String toString() {
    return getClass().getName()
        + "[hgap="
        + hgap
        + ",vgap="
        + vgap
        + ",rows="
        + rows
        + ",cols="
        + cols
        + "]";
  }
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * Copyright (c) 2018, PandahRS <https://github.com/PandahRS>
 * Copyright (c) 2020, Brooklyn <https://github.com/Broooklyn>
 * Copyright (c) 2022, Thource <https://github.com/Thource>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package dev.thource.runelite.dudewheresmystuff;

import com.google.common.collect.ImmutableMap;
import java.util.Map;
import lombok.Getter;

/** Region serves as a way to get a descriptive name of a WorldLocation. */
@Getter
public enum Region {
  // Bosses
  BOSS_ABYSSAL_SIRE("Abyssal Sire", 11851, 11850, 12363, 12362),
  BOSS_ARAXXOR("Araxxor", 14489),
  BOSS_CERBERUS("Cerberus", 4883, 5140, 5395),
  BOSS_COMMANDER_ZILYANA("Commander Zilyana", 11602),
  BOSS_CORP("Corporeal Beast", 11842, 11844),
  BOSS_DKS("Dagannoth Kings", 11588, 11589),
  BOSS_DUKE_SUCELLUS("Duke Sucellus", 12132),
  BOSS_DOOM("Doom of Mokhaiotl", 5269),
  BOSS_GENERAL_GRAARDOR("General Graardor", 11347),
  BOSS_GIANT_MOLE("Giant Mole", 6993, 6992),
  BOSS_GROTESQUE_GUARDIANS("Grotesque Guardians", 6727),
  BOSS_HESPORI("Hespori", 5021),
  BOSS_HYDRA("Alchemical Hydra", 5536),
  BOSS_KQ("Kalphite Queen", 13972),
  BOSS_KRAKEN("Kraken", 9116),
  BOSS_KREEARRA("Kree'arra", 11346),
  BOSS_KRIL_TSUTSAROTH("K'ril Tsutsaroth", 11603),
  BOSS_NEX("Nex", 11601),
  BOSS_NIGHTMARE("Nightmare of Ashihama", 15515),
  BOSS_PHANTOM_MUSPAH("Phantom Muspah", 11330),
  BOSS_SARACHNIS("Sarachnis", 7322),
  BOSS_SKOTIZO("Skotizo", 9048),
  BOSS_SMOKE_DEVIL("Thermonuclear smoke devil", 9363, 9619),
  BOSS_TEMPOROSS("Tempoross", 12078),
  BOSS_THE_LEVIATHAN("The Leviathan", 8291),
  BOSS_THE_ROYAL_TITANS("The Royal Titans", 11669),
  BOSS_THE_WHISPERER("The Whisperer", 10595),
  BOSS_VARDORVIS("Vardorvis", 4405),
  BOSS_VORKATH("Vorkath", 9023),
  BOSS_WINTERTODT("Wintertodt", 6462),
  BOSS_YAMA("Yama", 6045),
  BOSS_ZALCANO("Zalcano", 12126),
  BOSS_ZULRAH("Zulrah", 9007, 9008),

  // Cities
  CITY_AL_KHARID("Al Kharid", 13105, 13106),
  CITY_ARCEUUS_HOUSE("Arceuus", 6458, 6459, 6460, 6714, 6715),
  CITY_ARDOUGNE("Ardougne", 9779, 9780, 10035, 10036, 10291, 10292, 10547, 10548),
  CITY_BANDIT_CAMP("Bandit Camp", 12590),
  CITY_BARBARIAN_OUTPOST("Barbarian Outpost", 10039),
  CITY_BARBARIAN_VILLAGE("Barbarian Village", 12341),
  CITY_BEDABIN_CAMP("Bedabin Camp", 12591),
  CITY_BRIMHAVEN("Brimhaven", 11057, 11058),
  CITY_BURGH_DE_ROTT("Burgh de Rott", 13874, 13873, 14130, 14129),
  CITY_BURTHORPE("Burthorpe", 11319, 11575),
  CITY_CAM_TORUM("Cam Torum", 5525, 5780, 5781, 6037),
  CITY_CANIFIS("Canifis", 13878),
  CITY_CATHERBY("Catherby", 11317, 11318, 11061),
  CITY_CIVITAS_ILLA_FORTIS("Civitas Illa Fortis", 6448, 6449, 6704, 6705, 6960, 6961),
  CITY_CORSAIR_COVE("Corsair Cove", 10028, 10284),
  CITY_DARKMEYER("Darkmeyer", 14388, 14644),
  CITY_DORGESH_KAAN("Dorgesh-Kaan", 10835, 10834),
  CITY_DRAYNOR("Draynor", 12338, 12339),
  CITY_EDGEVILLE("Edgeville", 12342),
  CITY_ENTRANA("Entrana", 11060, 11316),
  CITY_ETCETERIA("Etceteria", 10300),
  CITY_FALADOR("Falador", 11828, 11572, 11827, 12084),
  CITY_GUTANOTH("Gu'Tanoth", 10031),
  CITY_GWENITH("Gwenith", 8757),
  CITY_HOSIDIUS_HOUSE(
      "Hosidius", 6710, 6711, 6712, 6455, 6456, 6966, 6967, 6968, 7221, 7223, 7224, 7478, 7479),
  CITY_JATIZSO("Jatizso", 9531),
  CITY_KELDAGRIM("Keldagrim", 11423, 11422, 11679, 11678),
  CITY_LANDS_END("Land's End", 5941),
  CITY_LASSAR_UNDERCITY(
      "Lassar Undercity", 9314, 9315, 9316, 9571, 9572, 9828, 10338, 10339, 10340, 10596, 10852),
  CITY_LLETYA("Lletya", 9265, 11103),
  CITY_LOVAKENGJ_HOUSE("Lovakengj", 5692, 5691, 5947, 6203, 6202, 5690, 5946),
  CITY_LUMBRIDGE("Lumbridge", 12850),
  CITY_LUNAR_ISLE("Lunar Isle", 8253, 8252, 8509, 8508),
  CITY_MARIM("Marim", 11051),
  CITY_MEIYERDITCH("Meiyerditch", 14132, 14387, 14386, 14385),
  CITY_MENAPHOS("Menaphos", 12843),
  CITY_MISCELLANIA("Miscellania", 10044),
  CITY_MOR_UL_REK("Mor Ul Rek", 9808, 9807, 10064, 10063),
  CITY_MORTTON("Mort'ton", 13875),
  CITY_MOS_LE_HARMLESS("Mos Le'Harmless", 14637, 14638, 14639, 14894, 14895, 15151, 15406, 15407),
  CITY_MOUNT_KARUULM("Mount Karuulm", 5179, 4923, 5180),
  CITY_MOUNTAIN_CAMP("Mountain Camp", 11065),
  CITY_MYNYDD("Mynydd", 8501),
  CITY_NARDAH("Nardah", 13613),
  CITY_NEITIZNOT("Neitiznot", 9275),
  CITY_PISCARILIUS_HOUSE("Port Piscarilius", 6969, 6971, 7227, 6970, 7225, 7226),
  CITY_PISCATORIS("Piscatoris", 9273),
  CITY_POLLNIVNEACH("Pollnivneach", 13358),
  CITY_PORT_KHAZARD("Port Khazard", 10545),
  CITY_PORT_PHASMATYS("Port Phasmatys", 14646),
  CITY_PORT_SARIM("Port Sarim", 12081, 12082),
  CITY_PRIFDDINAS(
      "Prifddinas", 8499, 8500, 8755, 8756, 9011, 9012, 9013, 12894, 12895, 13150, 13151),
  CITY_RELLEKKA("Rellekka", 10297, 10553),
  CITY_RIMMINGTON("Rimmington", 11826, 11570),
  CITY_SEERS_VILLAGE("Seers' Village", 10806),
  CITY_SHAYZIEN_HOUSE("Shayzien", 5944, 5943, 6200, 6199, 5686, 5687, 5688, 5689, 5945),
  CITY_SHILO_VILLAGE("Shilo Village", 11310),
  CITY_SLEPE("Slepe", 14643, 14899, 14900, 14901),
  CITY_SOPHANEM("Sophanem", 13099),
  CITY_TAI_BWO_WANNAI("Tai Bwo Wannai", 11056, 11055),
  CITY_TAVERLEY("Taverley", 11574, 11573),
  CITY_TREE_GNOME_STRONGHOLD("Tree Gnome Stronghold", 9525, 9526, 9782, 9781),
  CITY_TREE_GNOME_VILLAGE("Tree Gnome Village", 10033),
  CITY_TROLL_STRONGHOLD("Troll Stronghold", 11321, 11421),
  CITY_UZER("Uzer", 13872),
  CITY_UZER_OASIS("Uzer Oasis", 13871),
  CITY_VARROCK("Varrock", 12596, 12597, 12852, 12853, 12854, 13108, 13109, 13110),
  CITY_VER_SINHAZA("Ver Sinhaza", 14642),
  CITY_VOID_OUTPOST("Void Knights' Outpost", 10537),
  CITY_WEISS("Weiss", 11325, 11581),
  CITY_WITCHHAVEN("Witchaven", 10803),
  CITY_YANILLE("Yanille", 10288, 10032),
  CITY_ZANARIS("Zanaris", 9285, 9541, 9540, 9797),
  CITY_ZULANDRA("Zul-Andra", 8495, 8751),

  // Dungeons
  DUNGEON_ABANDONED_MINE("Abandoned Mine", 13618, 13718, 11079, 11078, 11077, 10823, 10822, 10821),
  DUNGEON_AH_ZA_RHOON("Ah Za Rhoon", 11666),
  DUNGEON_ANCIENT_CAVERN("Ancient Cavern", 6483, 6995),
  DUNGEON_APE_ATOLL("Ape Atoll Dungeon", 11150, 10894),
  DUNGEON_APE_ATOLL_BANANA_PLANTATION("Ape Atoll Banana Plantation", 10895),
  DUNGEON_ARDY_BASEMENT("West Ardougne Basement", 10135),
  DUNGEON_ARDY_SEWERS("Ardougne Sewers", 10134, 10136, 10391, 10647),
  DUNGEON_ASGARNIAN_ICE_CAVES("Asgarnian Ice Caves", 11925, 12181),
  DUNGEON_BERVIRIUS_TOMB("Tomb of Bervirius", 11154),
  DUNGEON_BRIMHAVEN("Brimhaven Dungeon", 10901, 10900, 10899, 10645, 10644, 10643),
  DUNGEON_BRINE_RAT_CAVERN("Brine Rat Cavern", 10910),
  DUNGEON_CATACOMBS_OF_KOUREND("Catacombs of Kourend", 6557, 6556, 6813, 6812),
  DUNGEON_CERBERUS_LAIR("Cerberus' Lair", 5139),
  DUNGEON_CHAMPIONS_CHALLENGE("Champions' Challenge", 12696),
  DUNGEON_CHAOS_DRUID_TOWER("Chaos Druid Tower", 10392),
  DUNGEON_CHASM_OF_FIRE("Chasm of Fire", 5789),
  DUNGEON_CHASM_OF_TEARS("Chasm of Tears", 12948),
  DUNGEON_CHINCHOMPA("Chinchompa Hunting Ground", 10129),
  DUNGEON_CIVITAS_ILLA_FORTIS("Civitas illa Fortis Underground", 6549, 6804, 6805),
  DUNGEON_CLOCK_TOWER("Clock Tower Basement", 10390),
  DUNGEON_CORSAIR_COVE("Corsair Cove Dungeon", 8076, 8332),
  DUNGEON_CRABCLAW_CAVES("Crabclaw Caves", 6553, 6809),
  DUNGEON_CRANDOR("Crandor Dungeon", 11414),
  DUNGEON_CRASH_SITE_CAVERN("Crash Site Cavern", 8280, 8536),
  DUNGEON_CRUMBLING_TOWER("Crumbling Tower", 7827),
  DUNGEON_DAEYALT_ESSENCE_MINE("Daeyalt Essence Mine", 14744),
  DUNGEON_DIGSITE("Digsite Dungeon", 13464, 13465),
  DUNGEON_DORGESHKAAN("Dorgesh-Kaan South Dungeon", 10833),
  DUNGEON_DORGESHUUN_MINES("Dorgeshuun Mines", 12950, 13206),
  DUNGEON_DRAYNOR_SEWERS("Draynor Sewers", 12439, 12438),
  DUNGEON_DWARVEN_MINES("Dwarven Mines", 12185, 12184, 12183),
  DUNGEON_EAGLES_PEAK("Eagles' Peak Dungeon", 8013),
  DUNGEON_ECTOFUNTUS("Ectofuntus", 14746),
  DUNGEON_EDGEVILLE("Edgeville Dungeon", 12441, 12442, 12443, 12698),
  DUNGEON_ELEMENTAL_WORKSHOP("Elemental Workshop", 10906, 7760),
  DUNGEON_ELVEN_RABBIT_CAVE("Elven rabbit cave", 13252),
  DUNGEON_ENAKHRAS_TEMPLE("Enakhra's Temple", 12423),
  DUNGEON_EVIL_CHICKENS_LAIR("Evil Chicken's Lair", 9796),
  DUNGEON_EXPERIMENT_CAVE("Experiment Cave", 14235, 13979),
  DUNGEON_FEROX_ENCLAVE("Ferox Enclave Dungeon", 12700),
  DUNGEON_FORTHOS("Forthos Dungeon", 7323),
  DUNGEON_FREMENNIK_SLAYER("Fremennik Slayer Dungeon", 10907, 10908, 11164),
  DUNGEON_GLARIALS_TOMB("Glarial's Tomb", 10137),
  DUNGEON_GOBLIN_CAVE("Goblin Cave", 10393),
  DUNGEON_GRAND_TREE_TUNNELS("Grand Tree Tunnels", 9882),
  DUNGEON_HAM_HIDEOUT("H.A.M. Hideout", 12694),
  DUNGEON_HAM_STORE_ROOM("H.A.M. Store room", 10321),
  DUNGEON_HEROES_GUILD("Heroes' Guild Mine", 11674),
  DUNGEON_IORWERTH("Iorwerth Dungeon", 12737, 12738, 12993, 12994),
  DUNGEON_ISLE_OF_SOULS("Isle of Souls Dungeon", 8593),
  DUNGEON_JATIZSO_MINES("Jatizso Mines", 9631),
  DUNGEON_JIGGIG_BURIAL_TOMB("Jiggig Burial Tomb", 9875, 9874),
  DUNGEON_JOGRE("Jogre Dungeon", 11412),
  DUNGEON_KARAMJA("Karamja Dungeon", 11413),
  DUNGEON_KARUULM(
      "Karuulm Slayer Dungeon", 5280, 5279, 5023, 5535, 5022, 4766, 4510, 4511, 4767, 4768, 4512),
  DUNGEON_KGP_HEADQUARTERS("KGP Headquarters", 10658),
  DUNGEON_KRUK(
      "Kruk's Dungeon",
      9358,
      9359,
      9360,
      9615,
      9616,
      9871,
      10125,
      10126,
      10127,
      10128,
      10381,
      10382,
      10383,
      10384,
      10637,
      10638,
      10639,
      10640),
  DUNGEON_LEGENDS_GUILD("Legends' Guild Dungeon", 10904),
  DUNGEON_LIGHTHOUSE("Lighthouse", 10140),
  DUNGEON_LIZARDMAN_CAVES("Lizardman Caves", 5275),
  DUNGEON_LIZARDMAN_TEMPLE("Lizardman Temple", 5277),
  DUNGEON_LUMBRIDGE_SWAMP_CAVES("Lumbridge Swamp Caves", 12693, 12949),
  DUNGEON_LUNAR_ISLE_MINE("Lunar Isle Mine", 9377),
  DUNGEON_MANIACAL_HUNTER("Maniacal Monkey Hunter Area", 11662),
  DUNGEON_MEIYERDITCH_MINE("Meiyerditch Mine", 9544),
  DUNGEON_MISCELLANIA("Miscellania Dungeon", 10144, 10400),
  DUNGEON_MOGRE_CAMP("Mogre Camp", 11924),
  DUNGEON_MOS_LE_HARMLESS_CAVES("Mos Le'Harmless Caves", 14994, 14995, 15251),
  DUNGEON_MOTHERLODE_MINE(
      "Motherlode Mine", 14679, 14680, 14681, 14935, 14936, 14937, 15191, 15192, 15193),
  DUNGEON_MOURNER_TUNNELS("Mourner Tunnels", 7752, 8008),
  DUNGEON_MOUSE_HOLE("Mouse Hole", 9046),
  DUNGEON_MEIYERDITCH_LABORATORIES("Meiyerditch Laboratories", 14232, 14233, 14487, 14488),
  DUNGEON_MYREQUE("Myreque Hideout", 13721, 13974, 13977, 13978),
  DUNGEON_MYTHS_GUILD("Myths' Guild Dungeon", 7564, 7820, 7821),
  DUNGEON_OBSERVATORY("Observatory Dungeon", 9362),
  DUNGEON_OGRE_ENCLAVE("Ogre Enclave", 10387),
  DUNGEON_OURANIA("Ourania Cave", 12119),
  DUNGEON_QUIDAMORTEM_CAVE("Quidamortem Cave", 4763),
  DUNGEON_RASHILIYIAS_TOMB("Rashiliyta's Tomb", 11668),
  DUNGEON_RUINS_OF_CAMDOZAAL(
      "Ruins of Camdozaal", 11609, 11610, 11611, 11865, 11866, 11867, 12121, 12122, 12123),
  DUNGEON_SALT_MINE("Salt Mine", 11425),
  DUNGEON_SARADOMINSHRINE("Saradomin Shrine (Paterdomus)", 13722),
  DUNGEON_SHADE_CATACOMBS("Shade Catacombs", 13975),
  DUNGEON_SHADOW("Shadow Dungeon", 10575, 10831),
  DUNGEON_SHAYZIEN_CRYPTS("Shayzien Crypts", 6043),
  DUNGEON_SISTERHOOD_SANCTUARY(
      "Sisterhood Sanctuary", 14999, 15000, 15001, 15255, 15256, 15257, 15511, 15512, 15513),
  DUNGEON_SMOKE("Smoke Dungeon", 12946, 13202),
  DUNGEON_SOPHANEM("Sophanem Dungeon", 13200),
  DUNGEON_SOURHOG_CAVE("Sourhog Cave", 12695),
  DUNGEON_STRONGHOLD_SECURITY("Stronghold of Security", 7505, 8017, 8530, 9297),
  DUNGEON_STRONGHOLD_SLAYER("Stronghold Slayer Cave", 9624, 9625, 9880, 9881),
  DUNGEON_TARNS_LAIR("Tarn's Lair", 12616, 12615),
  DUNGEON_TAVERLEY("Taverley Dungeon", 11416, 11417, 11671, 11672, 11673, 11928, 11929),
  DUNGEON_TEMPLE_OF_IKOV("Temple of Ikov", 10649, 10905, 10650),
  DUNGEON_TEMPLE_OF_LIGHT("Temple of Light", 7496),
  DUNGEON_TEMPLE_OF_MARIMBO("Temple of Marimbo", 11151),
  DUNGEON_THE_BURROW("The Burrow", 6291),
  DUNGEON_THE_WARRENS("The Warrens", 7070, 7326),
  DUNGEON_TOLNA("Dungeon of Tolna", 13209),
  DUNGEON_TOWER_OF_LIFE("Tower of Life Basement", 12100),
  DUNGEON_TRAHAEARN_MINE("Trahaearn Mine", 13250),
  DUNGEON_TUNNEL_OF_CHAOS("Tunnel of Chaos", 12625),
  DUNGEON_UNDERGROUND_PASS("Underground Pass", 9369, 9370),
  DUNGEON_VARROCKSEWERS("Varrock Sewers", 12954, 13210),
  DUNGEON_VIYELDI_CAVES("Viyeldi Caves", 9545, 11153),
  DUNGEON_WARRIORS_GUILD("Warriors' Guild Basement", 11675),
  DUNGEON_WATER_RAVINE("Water Ravine", 13461),
  DUNGEON_WATERBIRTH("Waterbirth Dungeon", 9886, 10142, 7492, 7748),
  DUNGEON_WATERFALL("Waterfall Dungeon", 10394),
  DUNGEON_WEREWOLF_AGILITY("Werewolf Agility Course", 14234),
  DUNGEON_WHITE_WOLF_MOUNTAIN_CAVES("White Wolf Mountain Caves", 11418, 11419),
  DUNGEON_WITCHAVEN_SHRINE("Witchhaven Shrine Dungeon", 10903),
  DUNGEON_WIZARDS_TOWER("Wizards' Tower Basement", 12437),
  DUNGEON_WOODCUTTING_GUILD("Woodcutting Guild Dungeon", 6298),
  DUNGEON_WYVERN_CAVE("Wyvern Cave", 14495, 14496),
  DUNGEON_YANILLE_AGILITY("Yanille Agility Dungeon", 10388),

  // Minigames
  MG_ARDOUGNE_RAT_PITS("Ardougne Rat Pits", 10646),
  MG_BARBARIAN_ASSAULT("Barbarian Assault", 7508, 7509, 10322),
  MG_BARROWS("Barrows", 14131, 14231),
  MG_BLAST_FURNACE("Blast Furnace", 7757),
  MG_BRIMHAVEN_AGILITY_ARENA("Brimhaven Agility Arena", 11157),
  MG_BURTHORPE_GAMES_ROOM("Burthorpe Games Room", 8781),
  MG_CASTLE_WARS("Castle Wars", 9520, 9620),
  MG_CLAN_WARS(
      "Clan Wars",
      12621,
      12622,
      12623,
      13130,
      13131,
      13133,
      13134,
      13135,
      13386,
      13387,
      13390,
      13641,
      13642,
      13643,
      13644,
      13645,
      13646,
      13647,
      13899,
      13900,
      14155,
      14156),
  MG_PVP_ARENA("PvP Arena", 13362, 13363),
  MG_FISHING_TRAWLER("Fishing Trawler", 7499),
  MG_FORTIS_COLOSSEUM("Fortis Colosseum", 7216),
  MG_FORTIS_COLOSSEUM_LOBBY("Fortis Colosseum Lobby", 7316),
  MG_GAUNTLET("The Gauntlet", 12127, 7512),
  MG_CORRUPTED_GAUNTLET("Corrupted Gauntlet", 7768),
  MG_GIANTS_FOUNDRY("Giants' Foundry", 13491),
  MG_GUARDIANS_OF_THE_RIFT("Guardians of the Rift", 14484),
  MG_HALLOWED_SEPULCHRE(
      "Hallowed Sepulchre",
      8797,
      9051,
      9052,
      9053,
      9054,
      9309,
      9563,
      9565,
      9821,
      10074,
      10075,
      10077),
  MG_INFERNO("The Inferno", 9043),
  MG_KELDAGRIM_RAT_PITS("Keldagrim Rat Pits", 7753),
  MG_LAST_MAN_STANDING_DESERTED_ISLAND(
      "LMS - Deserted Island", 13658, 13659, 13660, 13914, 13915, 13916),
  MG_LAST_MAN_STANDING_WILD_VARROCK(
      "LMS - Wild Varrock", 13918, 13919, 13920, 14174, 14175, 14176, 14430, 14431, 14432),
  MG_MAGE_TRAINING_ARENA("Mage Training Arena", 13462, 13463),
  MG_NIGHTMARE_ZONE("Nightmare Zone", 9033),
  MG_PEST_CONTROL("Pest Control", 10536),
  MG_PORT_SARIM_RAT_PITS("Port Sarim Rat Pits", 11926),
  MG_PYRAMID_PLUNDER("Pyramid Plunder", 7749),
  MG_ROGUES_DEN("Rogues' Den", 11854, 11855, 12109, 12110, 12111),
  MG_SORCERESS_GARDEN("Sorceress's Garden", 11605),
  MG_SOUL_WARS("Soul Wars", 8493, 8748, 8749, 9005),
  MG_TEMPLE_TREKKING("Temple Trekking", 8014, 8270, 8256, 8782, 9038, 9294, 9550, 9806),
  MG_TITHE_FARM("Tithe Farm", 7222),
  MG_TROUBLE_BREWING("Trouble Brewing", 15150),
  MG_TZHAAR_FIGHT_CAVES("Tzhaar Fight Caves", 9551),
  MG_TZHAAR_FIGHT_PITS("Tzhaar Fight Pits", 9552),
  MG_VARROCK_RAT_PITS("Varrock Rat Pits", 11599),
  MG_VOLCANIC_MINE("Volcanic Mine", 15263, 15262),

  // Raids
  RAIDS_CHAMBERS_OF_XERIC(
      "Chambers of Xeric",
      12889,
      13136,
      13137,
      13138,
      13139,
      13140,
      13141,
      13145,
      13393,
      13394,
      13395,
      13396,
      13397,
      13401),
  RAIDS_THEATRE_OF_BLOOD(
      "Theatre of Blood", 12611, 12612, 12613, 12867, 12869, 13122, 13123, 13125, 13379),
  RAIDS_TOMBS_OF_AMASCUT(
      "Tombs of Amascut",
      14160,
      14162,
      14164,
      14674,
      14676,
      15184,
      15186,
      15188,
      15696,
      15698,
      15700),
  RAIDS_JALTEVAS_PYRAMID("Jaltevas Pyramid", 13454),
  RAIDS_OSMUMTENS_BURIAL_CHAMBER("Osmumten's Burial Chamber", 14672),

  // Other
  REGION_ABYSSAL_AREA("Abyssal Area", 12108),
  REGION_ABYSSAL_NEXUS("Abyssal Nexus", 12106),
  REGION_AGILITY_PYRAMID("Agility Pyramid", 12105, 13356),
  REGION_AIR_ALTAR("Air Altar", 11339),
  REGION_AL_KHARID_MINE("Al Kharid Mine", 13107),
  REGION_ANCIENT_VAULT("Ancient Vault", 12644, 13156),
  REGION_APE_ATOLL("Ape Atoll", 10794, 10795, 10974, 11050),
  REGION_ARANDAR("Arandar", 9266, 9267, 9523),
  REGION_ASGARNIA("Asgarnia", 11825, 11829, 11830, 12085, 12086),
  REGION_AVIUM_SAVANNAH(
      "Avium Savannah",
      5935,
      5936,
      5937,
      6189,
      6445,
      6446,
      6447,
      6701,
      6702,
      6703,
      6957,
      6958,
      6959,
      7215),
  REGION_BATTLEFIELD("Battlefield", 10034),
  REGION_BATTLEFRONT("Battlefront", 5433, 5434),
  REGION_BLAST_MINE("Blast Mine", 5948),
  REGION_BODY_ALTAR("Body Altar", 10059),
  REGION_CHAOS_ALTAR("Chaos Altar", 9035),
  REGION_COSMIC_ALTAR("Cosmic Altar", 8523),
  REGION_COSMIC_ENTITYS_PLANE("Cosmic Entity's Plane", 8267),
  REGION_CRABCLAW_ISLE("Crabclaw Isle", 6965),
  REGION_CRAFTING_GUILD("Crafting Guild", 11571),
  REGION_CRANDOR("Crandor", 11314, 11315),
  REGION_CRASH_ISLAND("Crash Island", 11562),
  REGION_DARK_ALTAR("Dark Altar", 6716),
  REGION_DEATH_ALTAR("Death Altar", 8779),
  REGION_DEATH_PLATEAU("Death Plateau", 11320),
  REGION_DENSE_ESSENCE("Dense Essence Mine", 6972),
  REGION_DESERT_PLATEAU("Desert Plateau", 13361, 13617),
  REGION_DIGSITE("Digsite", 13365),
  REGION_DRAGONTOOTH("Dragontooth Island", 15159),
  REGION_DRAYNOR_MANOR("Draynor Manor", 12340),
  REGION_DRILL_SERGEANT("Drill Sergeant's Training Camp", 12619),
  REGION_EAGLES_PEAK("Eagles' Peak", 9270),
  REGION_EARTH_ALTAR("Earth Altar", 10571),
  REGION_ENCHANTED_VALLEY("Enchanted Valley", 12102),
  REGION_EVIL_TWIN("Evil Twin Crane Room", 7504),
  REGION_EXAM_CENTRE("Exam Centre", 13364),
  REGION_FALADOR_FARM("Falador Farm", 12083),
  REGION_FARMING_GUILD("Farming Guild", 4922),
  REGION_FELDIP_HILLS("Feldip Hills", 9773, 9774, 10029, 10030, 10285, 10286, 10287, 10542, 10543),
  REGION_FENKENSTRAIN("Fenkenstrain's Castle", 14135),
  REGION_FIGHT_ARENA("Fight Arena", 10289),
  REGION_FIRE_ALTAR("Fire Altar", 10315),
  REGION_FISHER_REALM("Fisher Realm", 10569),
  REGION_FISHING_GUILD("Fishing Guild", 10293),
  REGION_FISHING_PLATFORM("Fishing Platform", 11059),
  REGION_FORSAKEN_TOWER("The Forsaken Tower", 5435),
  REGION_FOSSIL_ISLAND(
      "Fossil Island", 14650, 14651, 14652, 14906, 14907, 14908, 15162, 15163, 15164),
  REGION_FREAKY_FORESTER("Freaky Forester's Clearing", 10314),
  REGION_FREMENNIK("Fremennik Province", 10296, 10552, 10808, 10809, 10810, 10811, 11064),
  REGION_FREMENNIK_ISLES("Fremennik Isles", 9276, 9532),
  REGION_FROGLAND("Frogland", 9802),
  REGION_GALVEK_SHIPWRECKS("Galvek Shipwrecks", 6486, 6487, 6488, 6489, 6742, 6743, 6744, 6745),
  REGION_GHORROCK_DUNGEON("Ghorrock Dungeon", 11681),
  REGION_GORAKS_PLANE("Gorak's Plane", 12115),
  REGION_GRAND_EXCHANGE("Grand Exchange", 12598),
  REGION_GWD("God Wars Dungeon", 11578),
  REGION_HARMONY("Harmony Island", 15148),
  REGION_HAZELMERE("Hazelmere's Island", 10544),
  REGION_HUNTER_GUILD("Hunter Guild", 6191),
  REGION_ICE_PATH("Ice Path", 11322, 11323),
  REGION_ICEBERG("Iceberg", 10558, 10559),
  REGION_ICYENE_GRAVEYARD("Icyene Graveyard", 14641, 14897, 14898),
  REGION_ISAFDAR("Isafdar", 8497, 8753, 8754, 9009, 9010),
  REGION_ISLAND_OF_STONE("Island of Stone", 9790),
  REGION_ISLE_OF_SOULS(
      "Isle of Souls",
      8236,
      8237,
      8238,
      8491,
      8492,
      8494,
      8747,
      8750,
      9003,
      9004,
      9006,
      9260,
      9261,
      9262),
  REGION_JIGGIG("Jiggig", 9775),
  REGION_KANDARIN(
      "Kandarin",
      9268,
      9269,
      9014,
      9263,
      9264,
      9519,
      9524,
      9527,
      9776,
      9783,
      10037,
      10290,
      10294,
      10546,
      10551,
      10805,
      11062),
  REGION_KARAMJA(
      "Karamja", 10801, 10802, 11054, 11311, 11312, 11313, 11566, 11567, 11568, 11569, 11822),
  REGION_KEBOS_LOWLANDS("Kebos Lowlands", 4665, 4666, 4667, 4921, 5178),
  REGION_KEBOS_SWAMP("Kebos Swamp", 4664, 4920, 5174, 5175, 5176, 5430, 5431),
  REGION_KHARAZI_JUNGLE("Kharazi Jungle", 11053, 11309, 11565, 11821),
  REGION_KHARIDIAN_DESERT(
      "Kharidian Desert",
      12587,
      12844,
      12845,
      12846,
      12847,
      12848,
      13100,
      13101,
      13102,
      13103,
      13104,
      13357,
      13359,
      13360,
      13614,
      13615,
      13616,
      13869,
      13870),
  REGION_KILLERWATT_PLANE("Killerwatt Plane", 10577),
  REGION_KOUREND("Great Kourend", 6201, 6457, 6713),
  REGION_KOUREND_WOODLAND("Kourend Woodland", 5942, 6197, 6453),
  REGION_LAW_ALTAR("Law Altar", 9803),
  REGION_LEGENDS_GUILD("Legends' Guild", 10804),
  REGION_LIGHTHOUSE("Lighthouse", 10040),
  REGION_LITHKREN("Lithkren", 14142, 14398),
  REGION_LUMBRIDGE_SWAMP("Lumbridge Swamp", 12593, 12849),
  REGION_MAX_ISLAND("Max Island", 11063),
  REGION_MCGRUBORS_WOOD("McGrubor's Wood", 10550),
  REGION_MIME_STAGE("Mime's Stage", 8010),
  REGION_MIND_ALTAR("Mind Altar", 11083),
  REGION_MISTHALIN("Misthalin", 12594, 12595, 12851),
  REGION_MOLCH("Molch", 5177),
  REGION_MOLCH_ISLAND("Molch Island", 5432),
  REGION_MORYTANIA(
      "Morytania",
      13619,
      13620,
      13621,
      13622,
      13876,
      13877,
      13879,
      14133,
      14134,
      14389,
      14390,
      14391,
      14645,
      14647),
  REGION_MOUNT_QUIDAMORTEM("Mount Quidamortem", 4662, 4663, 4918, 4919),
  REGION_MR_MORDAUTS_CLASSROOM("Mr. Mordaut's Classroom", 7502),
  REGION_MUDSKIPPER("Mudskipper Point", 11824),
  REGION_MYSTERIOUS_OLD_MAN_MAZE("Mysterious Old Man's Maze", 11590, 11591, 11846, 11847),
  REGION_MYTHS_GUILD("Myths' Guild", 9772),
  REGION_NATURE_ALTAR("Nature Altar", 9547),
  REGION_NECROPOLIS("Necropolis", 13098, 13353, 13354, 13609, 13610),
  REGION_NORTHERN_TUNDRAS("Northern Tundras", 6204, 6205, 6717),
  REGION_OBSERVATORY("Observatory", 9777),
  REGION_ODD_ONE_OUT("Odd One Out", 7754),
  REGION_ORTUS_FARM("Ortus Farm", 6192, 6193),
  REGION_OTTOS_GROTTO("Otto's Grotto", 10038),
  REGION_OURANIA_HUNTER("Ourania Hunter Area", 9778),
  REGION_PIRATES_COVE("Pirates' Cove", 8763),
  REGION_PISCATORIS_HUNTER_AREA("Piscatoris Hunter Area", 9015, 9016, 9271, 9272, 9528),
  REGION_POH("Player Owned House", 7257, 7513, 7514, 7769, 7770, 8025, 8026),
  REGION_POISON_WASTE("Poison Waste", 8752),
  REGION_PORT_TYRAS("Port Tyras", 8496),
  REGION_PURO_PURO("Puro-Puro", 10307),
  REGION_QUARRY("Quarry", 12589),
  REGION_RALOS_RISE("Ralos' Rise", 5424, 5425, 5679, 5680, 5681, 5682),
  REGION_RANGING_GUILD("Ranging Guild", 10549),
  REGION_RATCATCHERS_MANSION("Ratcatchers Mansion", 11343),
  REGION_RUINS_OF_UNKAH("Ruins of Unkah", 12588),
  REGION_RUINS_OF_ULLEK("Ruins of Ullek", 13355, 13611, 13612),
  REGION_RUNE_ESSENCE_MINE("Rune Essence Mine", 11595),
  // The Beekeper, Pinball, and Gravedigger randoms share a region (7758), and although they are not
  // technically ScapeRune, that name is most commonly
  // associated with random events, so those three have been denoted ScapeRune to avoid leaving
  // multiple random event regions without an assigned name.
  REGION_SCAPERUNE("ScapeRune", 10058, 7758, 8261),
  REGION_SEA_SPIRIT_DOCK("Sea Spirit Dock", 12332),
  REGION_SHIP_YARD("Ship Yard", 11823),
  REGION_SILVAREA("Silvarea", 13366),
  REGION_SINCLAR_MANSION("Sinclair Mansion", 10807),
  REGION_SLAYER_TOWER("Slayer Tower", 13623, 13723),
  REGION_SOUL_ALTAR("Soul Altar", 7228),
  REGION_STRANGLEWOOD_TEMPLE("Stranglewood Temple", 4761),
  REGION_SUNSET_COAST("Sunset Coast", 5934, 6190),
  REGION_THE_SCAR("The Scar", 8036, 8292),
  REGION_THE_STRANGLEWOOD("The Stranglewood", 4403, 4404, 4659, 4660, 4661, 4916, 4917),
  REGION_TROLL_ARENA("Troll Arena", 11576),
  REGION_TROLLHEIM("Trollheim", 11577),
  REGION_TROLLWEISS_MTN("Trollweiss Mountain", 11066, 11067, 11068),
  REGION_TUTORIAL_ISLAND("Tutorial Island", 12079, 12080, 12335, 12336, 12436, 12592),
  REGION_UNDERWATER("Underwater", 15008, 15264),
  REGION_WATER_ALTAR("Water Altar", 10827),
  REGION_WATERBIRTH_ISLAND("Waterbirth Island", 10042),
  REGION_WINTERTODT_CAMP("Wintertodt Camp", 6461),
  REGION_WIZARDS_TOWER("Wizards' Tower", 12337),
  REGION_WOODCUTTING_GUILD("Woodcutting Guild", 6198, 6454),
  REGION_WRATH_ALTAR("Wrath Altar", 9291),

  // Wilderness
  WILDERNESS_1_8("Wilderness 1-8", 11831, 12087, 12343, 12599, 12855, 13111, 13367),
  WILDERNESS_9_16("Wilderness 9-16", 11832, 12088, 12344, 12600, 12856, 13112, 13368),
  WILDERNESS_17_24("Wilderness 17-24", 11833, 12089, 12345, 12601, 12857, 13113, 13369),
  WILDERNESS_25_32("Wilderness 25-32", 11834, 12090, 12346, 12602, 12858, 13114, 13370),
  WILDERNESS_33_40("Wilderness 33-40", 11835, 12091, 12347, 12603, 12859, 13115, 13371),
  WILDERNESS_41_48("Wilderness 41-48", 11836, 12092, 12348, 12604, 12860, 13116, 13372),
  WILDERNESS_49_56("Wilderness 49-56", 11837, 12093, 12349, 12605, 12861, 13117, 13373);

  private static final Map<Integer, Region> FROM_REGION;

  static {
    ImmutableMap.Builder<Integer, Region> regionMapBuilder = new ImmutableMap.Builder<>();
    for (Region region : Region.values()) {
      for (int regionId : region.ids) {
        regionMapBuilder.put(regionId, region);
      }
    }
    FROM_REGION = regionMapBuilder.build();
  }

  private final String name;
  private final int[] ids;

  Region(String name, int... ids) {
    this.name = name;
    this.ids = ids;
  }

  public static Region get(final int regionId) {
    return FROM_REGION.get(regionId);
  }
}

/*
 * Copyright (c) 2022, Thource <https://github.com/Thource>
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package dev.thource.runelite.dudewheresmystuff;

import com.google.api.services.sheets.v4.model.CellData;
import com.google.api.services.sheets.v4.model.ExtendedValue;
import java.util.List;
import javax.annotation.Nullable;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.GameState;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;

/** ItemStack represents an OSRS item with a quantity. */
@Getter
@EqualsAndHashCode
public class ItemStack {

  private int id;
  @Setter private long quantity;
  @Setter private int spriteId = -1;
  @EqualsAndHashCode.Exclude @Setter private String name;
  @EqualsAndHashCode.Exclude private int gePrice;
  @EqualsAndHashCode.Exclude private int haPrice;
  @EqualsAndHashCode.Exclude @Setter private boolean stackable;
  @EqualsAndHashCode.Exclude private ItemIdentification itemIdentification;
  @EqualsAndHashCode.Exclude private int canonicalId;

  /**
   * A constructor.
   *
   * @param id     OSRS item ID
   * @param plugin plugin
   */
  public ItemStack(int id, DudeWheresMyStuffPlugin plugin) {
    this.id = id;
    this.name = "Loading";
    this.quantity = 0L;

    plugin.getClientThread().invoke(() -> populateFromComposition(plugin));
  }

  /**
   * A constructor.
   *
   * @param id OSRS  item ID
   * @param quantity quantity
   * @param plugin   plugin
   */
  public ItemStack(int id, long quantity, DudeWheresMyStuffPlugin plugin) {
    this(id, plugin);

    this.quantity = quantity;
  }

  /**
   * A constructor.
   *
   * @param itemStack itemStack to clone
   */
  public ItemStack(ItemStack itemStack) {
    this(
        itemStack.getId(),
        itemStack.getName(),
        itemStack.getQuantity(),
        itemStack.getGePrice(),
        itemStack.getHaPrice(),
        itemStack.isStackable());

    this.itemIdentification = itemStack.getItemIdentification();
    this.canonicalId = itemStack.canonicalId;
    this.spriteId = itemStack.spriteId;
  }

  /**
   * A constructor.
   *
   * <p>WARNING: ItemStacks created using this constructor will not have an ItemIdentification
   * attached.
   *
   * @param id        the item's id
   * @param name      the item's name
   * @param quantity  the quantity of the item
   * @param gePrice   the GE price
   * @param haPrice   the high alchemy price
   * @param stackable if the item is stackable
   */
  public ItemStack(
      int id, String name, long quantity, int gePrice, int haPrice, boolean stackable) {
    this.id = id;
    this.name = name;
    this.quantity = quantity;
    this.gePrice = gePrice;
    this.haPrice = haPrice;
    this.stackable = stackable;
    this.canonicalId = id;
  }

  /**
   * Populates an item's data from the item id.
   *
   * @param plugin plugin
   */
  private boolean populateFromComposition(DudeWheresMyStuffPlugin plugin) {
    if (plugin.getClient().getGameState().getState() < GameState.LOGIN_SCREEN.getState()) {
      return false;
    }

    ItemManager itemManager = plugin.getItemManager();
    ItemComposition composition = itemManager.getItemComposition(id);
    name = composition.getName();
    gePrice = itemManager.getItemPrice(id);
    haPrice = composition.getHaPrice();
    stackable = composition.isStackable();
    canonicalId = itemManager.canonicalize(id);
    itemIdentification = ItemIdentification.get(canonicalId);

    return true;
  }

  long getTotalGePrice() {
    return gePrice * quantity;
  }

  long getTotalHaPrice() {
    return haPrice * quantity;
  }

  public void setId(int id) {
    this.id = id;
  }

  public void setId(int id, DudeWheresMyStuffPlugin plugin) {
    this.id = id;
    populateFromComposition(plugin);
  }

  public void stripPrices() {
    haPrice = 0;
    gePrice = 0;
  }

  public String toCsvString(
      boolean mergeItems,
      @Nullable StorageManager<?, ?> storageManager,
      @Nullable Storage<?> storage) {
    boolean canSplitUp = (!mergeItems && storage != null && storageManager != null);
    String fmtString = "%d,%s,%d" + (mergeItems || !canSplitUp ? "" : ",%s,%s") + "%n";
    String escapedName = getEscapedName(mergeItems);

    return (mergeItems || !canSplitUp)
        ? String.format(fmtString, getCanonicalId(), escapedName, getQuantity())
        : String.format(
            fmtString,
            getCanonicalId(),
            escapedName,
            getQuantity(),
            storageManager.getConfigKey(),
            storage.getName());
  }

  public static List<String> getHeaders(boolean mergeItems, boolean shouldSplitUp) {
    boolean canSplitUp = (!mergeItems && shouldSplitUp);

    if (canSplitUp) {
      return List.of("ID", "Name", "Quantity", "Storage Category", "Storage Type");
    } else {
      return List.of("ID", "Name", "Quantity");
    }
  }

  public List<CellData> getCellDataList(
      boolean mergeItems,
      @Nullable StorageManager<?, ?> storageManager,
      @Nullable Storage<?> storage) {
    boolean canSplitUp = (!mergeItems && storage != null && storageManager != null);
    final CellData ID =
        new CellData()
            .setUserEnteredValue(new ExtendedValue().setNumberValue((double) getCanonicalId()));
    final CellData NAME =
        new CellData()
            .setUserEnteredValue(new ExtendedValue().setStringValue(getEscapedName(false)));
    final CellData QUANTITY =
        new CellData()
            .setUserEnteredValue(new ExtendedValue().setNumberValue((double) getQuantity()));
    if (mergeItems || !canSplitUp) {
      return List.of(ID, NAME, QUANTITY);
    } else {
      final CellData STORAGE_CATEGORY =
          new CellData()
              .setUserEnteredValue(
                  new ExtendedValue().setStringValue(storageManager.getConfigKey()));
      final CellData STORAGE_TYPE =
          new CellData().setUserEnteredValue(new ExtendedValue().setStringValue(storage.getName()));
      return List.of(ID, NAME, QUANTITY, STORAGE_CATEGORY, STORAGE_TYPE);
    }
  }

  private String getEscapedName(boolean mergeItems) {
    String name = getName();
    if (!mergeItems && getId() != getCanonicalId() && isStackable()) {
      name += " (noted)";
    }
    return name.replace(",", "").replace("\n", "");
  }
}

package dev.thource.runelite.dudewheresmystuff;

import com.google.common.collect.ImmutableMap;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.ItemID;

/** Seed serves as a way to match seed names to their item ids. */
@RequiredArgsConstructor
@Getter
public enum Seed {
  // Allotment seeds
  POTATO(ItemID.POTATO_SEED, "Potato seed"),
  ONION(ItemID.ONION_SEED, "Onion seed"),
  CABBAGE(ItemID.CABBAGE_SEED, "Cabbage seed"),
  TOMATO(ItemID.TOMATO_SEED, "Tomato seed"),
  SWEETCORN(ItemID.SWEETCORN_SEED, "Sweetcorn seed"),
  STRAWBERRY(ItemID.STRAWBERRY_SEED, "Strawberry seed"),
  WATERMELON(ItemID.WATERMELON_SEED, "Watermelon seed"),
  SNAPE_GRASS(ItemID.SNAPE_GRASS_SEED, "Snape grass seed"),

  // Flower seeds
  MARIGOLD(ItemID.MARIGOLD_SEED, "Marigold seed"),
  ROSEMARY(ItemID.ROSEMARY_SEED, "Rosemary seed"),
  NASTURTIUM(ItemID.NASTURTIUM_SEED, "Nasturtium seed"),
  WOAD(ItemID.WOAD_SEED, "Woad seed"),
  LIMPWURT(ItemID.LIMPWURT_SEED, "Limpwurt seed"),
  WHITE_LILY(ItemID.WHITE_LILY_SEED, "White lily seed"),

  // Herb seeds
  GUAM(ItemID.GUAM_SEED, "Guam seed"),
  MARRENTILL(ItemID.MARRENTILL_SEED, "Marrentill seed"),
  TARROMIN(ItemID.TARROMIN_SEED, "Tarromin seed"),
  HARRALANDER(ItemID.HARRALANDER_SEED, "Harralander seed"),
  GOUT_TUBER(ItemID.VILLAGE_RARE_TUBER, "Gout tuber"),
  RANARR(ItemID.RANARR_SEED, "Ranarr seed"),
  TOADFLAX(ItemID.TOADFLAX_SEED, "Toadflax seed"),
  IRIT(ItemID.IRIT_SEED, "Irit seed"),
  AVANTOE(ItemID.AVANTOE_SEED, "Avantoe seed"),
  KWUARM(ItemID.KWUARM_SEED, "Kwuarm seed"),
  SNAPDRAGON(ItemID.SNAPDRAGON_SEED, "Snapdragon seed"),
  CADANTINE(ItemID.CADANTINE_SEED, "Cadantine seed"),
  LANTADYME(ItemID.LANTADYME_SEED, "Lantadyme seed"),
  DWARF_WEED(ItemID.DWARF_WEED_SEED, "Dwarf weed seed"),
  TORSTOL(ItemID.TORSTOL_SEED, "Torstol seed"),

  // Hops seeds
  BARLEY(ItemID.BARLEY_SEED, "Barley seed"),
  HAMMERSTONE(ItemID.HAMMERSTONE_HOP_SEED, "Hammerstone seed"),
  ASGARNIAN(ItemID.ASGARNIAN_HOP_SEED, "Asgarnian seed"),
  JUTE(ItemID.JUTE_SEED, "Jute seed"),
  YANILLIAN(ItemID.YANILLIAN_HOP_SEED, "Yanillian seed"),
  KRANDORIAN(ItemID.KRANDORIAN_HOP_SEED, "Krandorian seed"),
  WILDBLOOD(ItemID.WILDBLOOD_HOP_SEED, "Wildblood seed"),

  // Bush seeds
  REDBERRY(ItemID.REDBERRY_BUSH_SEED, "Redberry seed"),
  CADAVABERRY(ItemID.CADAVABERRY_BUSH_SEED, "Cadavaberry seed"),
  DWELLBERRY(ItemID.DWELLBERRY_BUSH_SEED, "Dwellberry seed"),
  JANGERBERRY(ItemID.JANGERBERRY_BUSH_SEED, "Jangerberry seed"),
  WHITEBERRY(ItemID.WHITEBERRY_BUSH_SEED, "Whiteberry seed"),
  POISON_IVY(ItemID.POISONIVY_BUSH_SEED, "Poison ivy seed"),

  // Tree seeds
  ACORN(ItemID.ACORN, "Acorn"),
  WILLOW(ItemID.WILLOW_SEED, "Willow seed"),
  MAPLE(ItemID.MAPLE_SEED, "Maple seed"),
  YEW(ItemID.YEW_SEED, "Yew seed"),
  MAGIC(ItemID.MAGIC_TREE_SEED, "Magic seed"),

  // Fruit tree seeds
  APPLE(ItemID.APPLE_TREE_SEED, "Apple tree seed"),
  BANANA(ItemID.BANANA_TREE_SEED, "Banana tree seed"),
  ORANGE(ItemID.ORANGE_TREE_SEED, "Orange tree seed"),
  CURRY(ItemID.CURRY_TREE_SEED, "Curry tree seed"),
  PINEAPPLE(ItemID.PINEAPPLE_TREE_SEED, "Pineapple seed"),
  PAPAYA(ItemID.PAPAYA_TREE_SEED, "Papaya tree seed"),
  PALM(ItemID.PALM_TREE_SEED, "Palm tree seed"),
  DRAGONFRUIT(ItemID.DRAGONFRUIT_TREE_SEED, "Dragonfruit tree seed"),

  // Special seeds
  SEAWEED(ItemID.SEAWEED_SEED, "Seaweed spore"),
  GRAPE(ItemID.GRAPE_SEED, "Grape seed"),
  MUSHROOM(ItemID.MUSHROOM_SEED, "Mushroom spore"),
  BELLADONNA(ItemID.BELLADONNA_SEED, "Belladonna seed"),
  HESPORI(ItemID.HESPORI_SEED, "Hespori seed"),

  // Anima seeds
  KRONOS(ItemID.KRONOS_SEED, "Kronos seed"),
  IASOR(ItemID.IASOR_SEED, "Iasor seed"),
  ATTAS(ItemID.ATTAS_SEED, "Attas seed"),

  // Special tree seeds
  TEAK(ItemID.TEAK_SEED, "Teak seed"),
  MAHOGANY(ItemID.MAHOGANY_SEED, "Mahogany seed"),
  CALQUAT(ItemID.CALQUAT_TREE_SEED, "Calquat tree seed"),
  CRYSTAL(ItemID.CRYSTAL_TREE_SEED, "Crystal acorn"),
  SPIRIT(ItemID.SPIRIT_TREE_SEED, "Spirit seed"),
  CELASTRUS(ItemID.CELASTRUS_TREE_SEED, "Celastrus seed"),
  REDWOOD(ItemID.REDWOOD_TREE_SEED, "Redwood tree seed"),

  // Cactus seeds
  CACTUS(ItemID.CACTUS_SEED, "Cactus seed"),
  POTATO_CACTUS(ItemID.POTATO_CACTUS_SEED, "Potato cactus seed");

  private static final Map<String, Seed> FROM_NAME;

  static {
    ImmutableMap.Builder<String, Seed> nameMapBuilder = new ImmutableMap.Builder<>();
    for (Seed seed : Seed.values()) {
      nameMapBuilder.put(seed.getName().toLowerCase(Locale.ROOT), seed);
    }
    FROM_NAME = nameMapBuilder.build();
  }

  private final int itemId;
  private final String name;

  public static Optional<Seed> findByName(String name) {
    return Optional.ofNullable(FROM_NAME.get(name.toLowerCase(Locale.ROOT)));
  }
}

package dev.thource.runelite.dudewheresmystuff;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class DudeWheresMyStuffPluginTest {

  @SuppressWarnings("unchecked")
  public static void main(String[] args) throws Exception {
    ExternalPluginManager.loadBuiltin(DudeWheresMyStuffPlugin.class);
    RuneLite.main(args);
  }
}

