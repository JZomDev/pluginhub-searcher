/*
 * Copyright (c) 2018, Levi <me@levischuck.com>
 * Copyright (c) 2020, Anthony <https://github.com/while-loop>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Units;

import java.time.LocalDate;

@ConfigGroup("timeToMax")
public interface TimeToMaxConfig extends Config
{
	@ConfigSection(
		name = "Maxing Settings",
		description = "Settings related to max calculations",
		position = 0
	)
	String maxingSection = "maxing";

	@ConfigSection(
		name = "Info Label Settings",
		description = "Settings for the info labels",
		position = 1
	)
	String infoLabelSection = "infolabel";

	@ConfigSection(
		name = "Overlay",
		description = "Canvas overlay options.",
		position = 2
	)
	String overlaySection = "overlay";

	@ConfigItem(
		section = maxingSection,
		position = 0,
		keyName = "targetDate",
		name = "Target Date",
		description = "The target date to reach max level (format: YYYY-MM-DD)"
	)
	default String targetDate()
	{
		// Default to 1 year from now
		return LocalDate.now().plusYears(1).toString();
	}

	@ConfigItem(
		section = maxingSection,
		position = 1,
		keyName = "trackingInterval",
		name = "Tracking Interval",
		description = "The interval used for tracking XP progress (day, week, month)"
	)
	default TrackingInterval trackingInterval()
	{
		return TrackingInterval.DAY;
	}

	@ConfigItem(
		section = maxingSection,
		position = 2,
		keyName = "maxSkillMode",
		name = "Max Skill Mode",
		description = "Use level 99, or 200m as xp goal"
	)
	default MaxSkillMode maxSkillMode()
	{
		return MaxSkillMode.NORMAL;
	}

	@ConfigItem(
		section = maxingSection,
		position = 3,
		keyName = "prioritizeRecentXpSkills",
		name = "Move recently trained skills to top",
		description = "Configures whether skills should be organized by most recently gained XP."
	)
	default boolean prioritizeRecentXpSkills()
	{
		return true;
	}

	@ConfigItem(
		section = maxingSection,
		position = 4,
		keyName = "pinCompletedSkillsToBottom",
		name = "Pin completed skills to bottom",
		description = "Configures whether completed skills should be pinned to the bottom of the list."
	)
	default boolean pinCompletedSkillsToBottom()
	{
		return true;
	}

	@ConfigItem(
		section = maxingSection,
		position = 5,
		keyName = "collapseCompletedSkills",
		name = "Collapse completed skills",
		description = "Configures whether completed skills should be collapsed."
	)
	default boolean collapseCompletedSkills()
	{
		return true;
	}

	@ConfigItem(
		section = infoLabelSection,
		position = 0,
		keyName = "logoutPausing",
		name = "Pause on logout",
		description = "Configures whether skills should pause on logout."
	)
	default boolean pauseOnLogout()
	{
		return true;
	}

	@ConfigItem(
		section = infoLabelSection,
		position = 1,
		keyName = "pauseSkillAfter",
		name = "Auto pause after",
		description = "Configures how many minutes passes before pausing a skill while in game and there's no XP, 0 means disabled."
	)
	@Units(Units.MINUTES)
	default int pauseSkillAfter()
	{
		return 0;
	}

	@ConfigItem(
		section = infoLabelSection,
		position = 2,
		keyName = "resetSkillRateAfter",
		name = "Auto reset after",
		description = "Configures how many minutes passes before resetting a skill's per hour rates while in game and there's no XP, 0 means disabled."
	)
	@Units(Units.MINUTES)
	default int resetSkillRateAfter()
	{
		return 0;
	}

	@ConfigItem(
		section = infoLabelSection,
		position = 3,
		keyName = "xpPanelLabel1",
		name = "Top-left XP info label",
		description = "Configures the information displayed in the top-left of XP info box."
	)
	default XpPanelLabel xpPanelLabel1()
	{
		return XpPanelLabel.XP_GAINED;
	}

	@ConfigItem(
		section = infoLabelSection,
		position = 4,
		keyName = "xpPanelLabel2",
		name = "Top-right XP info label",
		description = "Configures the information displayed in the top-right of XP info box."
	)

	default XpPanelLabel xpPanelLabel2()
	{
		return XpPanelLabel.XP_LEFT;
	}

	@ConfigItem(
		section = infoLabelSection,
		position = 5,
		keyName = "xpPanelLabel3",
		name = "Bottom-left XP info label",
		description = "Configures the information displayed in the bottom-left of XP info box."
	)
	default XpPanelLabel xpPanelLabel3()
	{
		return XpPanelLabel.XP_HOUR;
	}

	@ConfigItem(
		section = infoLabelSection,
		position = 6,
		keyName = "xpPanelLabel4",
		name = "Bottom-right XP info label",
		description = "Configures the information displayed in the bottom-right of XP info box."
	)
	default XpPanelLabel xpPanelLabel4()
	{
		return XpPanelLabel.ACTIONS_LEFT;
	}

	@ConfigItem(
		section = infoLabelSection,
		position = 7,
		keyName = "progressBarLabel",
		name = "Progress bar label",
		description = "Configures the info box progress bar to show time to goal or percentage complete."
	)
	default XpProgressBarLabel progressBarLabel()
	{
		return XpProgressBarLabel.PERCENTAGE;
	}

	@ConfigItem(
		section = infoLabelSection,
		position = 8,
		keyName = "progressBarTooltipLabel",
		name = "Tooltip label",
		description = "Configures the info box progress bar tooltip to show time to goal or percentage complete."
	)
	default XpProgressBarLabel progressBarTooltipLabel()
	{
		return XpProgressBarLabel.TIME_TO_LEVEL;
	}

	@ConfigItem(
		position = 0,
		keyName = "skillTabOverlayMenuOptions",
		name = "Add skill tab canvas menu option",
		description = "Configures whether a menu option to show/hide canvas XP trackers will be added to skills on the skill tab.",
		section = overlaySection
	)
	default boolean skillTabOverlayMenuOptions()
	{
		return true;
	}

	@ConfigItem(
		position = 1,
		keyName = "onScreenDisplayMode",
		name = "On-screen tracker display mode (top)",
		description = "Configures the information displayed in the first line of on-screen XP overlays.",
		section = overlaySection
	)
	default XpPanelLabel onScreenDisplayMode()
	{
		return XpPanelLabel.XP_GAINED;
	}

	@ConfigItem(
		position = 2,
		keyName = "onScreenDisplayModeBottom",
		name = "On-screen tracker display mode (bottom)",
		description = "Configures the information displayed in the second line of on-screen XP overlays.",
		section = overlaySection
	)
	default XpPanelLabel onScreenDisplayModeBottom()
	{
		return XpPanelLabel.XP_HOUR;
	}
}

/*
 * Copyright (c) 2020, Anthony <https://github.com/while-loop>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.function.Function;

import static com.timetomax.XpInfoBox.TWO_DECIMAL_FORMAT;

@Getter
@AllArgsConstructor
public enum XpProgressBarLabel
{
	PERCENTAGE((snap) -> TWO_DECIMAL_FORMAT.format(snap.getSkillProgressToGoal()) + "%"),
	TIME_TO_LEVEL(XpSnapshotSingle::getTimeTillGoal),
	HOURS_TO_LEVEL(XpSnapshotSingle::getTimeTillGoalHours);

	private final Function<XpSnapshotSingle, String> valueFunc;
}

/*
 * Copyright (c) 2018, Levi <me@levischuck.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

import java.util.EnumSet;
import java.util.Set;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
class XpPauseStateSingle
{
	private final Set<XpPauseReason> pauseReasons = EnumSet.noneOf(XpPauseReason.class);
	@Getter
	private long lastChangeMillis;
	@Getter
	private long xp;

	boolean isPaused()
	{
		return !pauseReasons.isEmpty();
	}

	boolean login()
	{
		return pauseReasons.remove(XpPauseReason.PAUSED_LOGOUT);
	}

	boolean logout()
	{
		return pauseReasons.add(XpPauseReason.PAUSED_LOGOUT);
	}

	boolean timeout()
	{
		return pauseReasons.add(XpPauseReason.PAUSED_TIMEOUT);
	}

	boolean manualPause()
	{
		return pauseReasons.add(XpPauseReason.PAUSE_MANUAL);
	}

	boolean xpChanged(long xp)
	{
		this.xp = xp;
		this.lastChangeMillis = System.currentTimeMillis();
		return clearAll();
	}

	boolean unpause()
	{
		this.lastChangeMillis = System.currentTimeMillis();
		return clearAll();
	}

	private boolean clearAll()
	{
		if (pauseReasons.isEmpty())
		{
			return false;
		}

		pauseReasons.clear();
		return true;
	}

	private enum XpPauseReason
	{
		PAUSE_MANUAL,
		PAUSED_LOGOUT,
		PAUSED_TIMEOUT
	}
}

package com.timetomax;

import java.util.EnumMap;
import java.util.Map;
import net.runelite.api.Skill;

class XpPauseState
{
	// Internal state
	private final Map<Skill, XpPauseStateSingle> skillPauses = new EnumMap<>(Skill.class);
	private final XpPauseStateSingle overall = new XpPauseStateSingle();
	private boolean prevIsLoggedIn = false;

	boolean pauseSkill(Skill skill)
	{
		return findPauseState(skill).manualPause();
	}

	boolean pauseOverall()
	{
		return overall.manualPause();
	}

	boolean unpauseSkill(Skill skill)
	{
		return findPauseState(skill).unpause();
	}

	boolean unpauseOverall()
	{
		return overall.unpause();
	}

	boolean isPaused(Skill skill)
	{
		return findPauseState(skill).isPaused();
	}

	boolean isOverallPaused()
	{
		return overall.isPaused();
	}

	void tickXp(Skill skill, long currentXp, int pauseAfterMinutes)
	{
		final XpPauseStateSingle state = findPauseState(skill);
		tick(state, currentXp, pauseAfterMinutes);
	}

	void tickOverall(long currentXp, int pauseAfterMinutes)
	{
		tick(overall, currentXp, pauseAfterMinutes);
	}

	private void tick(XpPauseStateSingle state, long currentXp, int pauseAfterMinutes)
	{
		if (state.getXp() != currentXp)
		{
			state.xpChanged(currentXp);
		}
		else if (pauseAfterMinutes > 0)
		{
			final long now = System.currentTimeMillis();
			final int pauseAfterMillis = pauseAfterMinutes * 60 * 1000;
			final long lastChangeMillis = state.getLastChangeMillis();
			// When config.pauseSkillAfter is 0, it is effectively disabled
			if (lastChangeMillis != 0 && (now - lastChangeMillis) >= pauseAfterMillis)
			{
				state.timeout();
			}
		}
	}

	void tickLogout(boolean pauseOnLogout, boolean loggedIn)
	{
		// Deduplicated login and logout calls
		if (!prevIsLoggedIn && loggedIn)
		{
			prevIsLoggedIn = true;

			for (Skill skill : Skill.values())
			{
				findPauseState(skill).login();
			}
			overall.login();
		}
		else if (prevIsLoggedIn && !loggedIn)
		{
			prevIsLoggedIn = false;

			// If configured, then let the pause state know to pause with reason: logout
			if (pauseOnLogout)
			{
				for (Skill skill : Skill.values())
				{
					findPauseState(skill).logout();
				}
				overall.logout();
			}
		}
	}

	private XpPauseStateSingle findPauseState(Skill skill)
	{
		return skillPauses.computeIfAbsent(skill, (s) -> new XpPauseStateSingle());
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * Copyright (c) 2020, Anthony <https://github.com/while-loop>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.Skill;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.SkillColor;
import net.runelite.client.ui.components.MouseDragEventForwarder;
import net.runelite.client.ui.components.ProgressBar;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.QuantityFormatter;

class XpInfoBox extends JPanel
{
	static final DecimalFormat TWO_DECIMAL_FORMAT = new DecimalFormat("0.00");

	static
	{
		TWO_DECIMAL_FORMAT.setRoundingMode(RoundingMode.DOWN);
	}

	// Templates
	private static final String PROGRESS_BAR_TOOLTIP =
		"<html>%s Actions done<br/>"
			+ "%s Actions/hr<br/>"
			+ "%s %s%s</html>";
	private static final String PROGRESS_BAR_TOOLTIP_NO_ACTIONS =
		"<html>%s %s%s</html>";
	private static final String HTML_LABEL_TEMPLATE =
		"<html><body style='color:%s; max-height:16px; white-space: nowrap; overflow: hidden;'>%s<span style='color:white;'>%s</span></body></html>";

	private static final String REMOVE_STATE = "Remove from canvas";
	private static final String ADD_STATE = "Add to canvas";

	private static final EmptyBorder DEFAULT_PROGRESS_WRAPPER_BORDER = new EmptyBorder(0, 7, 7, 7);
	private static final EmptyBorder COMPACT_PROGRESS_WRAPPER_BORDER = new EmptyBorder(5, 1, 5, 5);

	// Instance members
	private final JComponent panel;

	@Getter(AccessLevel.PACKAGE)
	private final Skill skill;

	/* The tracker's wrapping container */
	private final JPanel container = new JPanel();

	/* Contains the skill icon and the stats panel */
	private final JPanel headerPanel = new JPanel();

	/* Contains all the skill information (exp gained, per hour, etc) */
	private final JPanel statsPanel = new JPanel();

	// Contains progress bar and compact-view icon
	private final JPanel progressWrapper = new JPanel();

	// Contains skill icon
	private final JLabel compactSkillIcon;

	private final ProgressBar progressBar = new ProgressBar();

	private final JLabel topLeftStat = new JLabel();
	private final JLabel bottomLeftStat = new JLabel();
	private final JLabel topRightStat = new JLabel();
	private final JLabel bottomRightStat = new JLabel();
	//private final JLabel targetXpStat = new JLabel();
	private final JMenuItem pauseSkill = new JMenuItem("Pause");
	private final JMenuItem canvasItem = new JMenuItem(ADD_STATE);

	private final TimeToMaxConfig config;

	private boolean paused = false;

	XpInfoBox(TimeToMaxPlugin timeToMaxPlugin, TimeToMaxConfig config, JComponent panel, Skill skill, SkillIconManager iconManager)
	{
		this.config = config;
		this.panel = panel;
		this.skill = skill;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(5, 0, 0, 0));

		container.setLayout(new BorderLayout());
		container.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// Create reset per hour menu
		final JMenuItem resetPerHour = new JMenuItem("Reset/hr");
		resetPerHour.addActionListener(e -> timeToMaxPlugin.resetSkillPerHourState(skill));

		// Create reset others menu
		pauseSkill.addActionListener(e -> timeToMaxPlugin.pauseSkill(skill, !paused));

		// Create popup menu
		final JPopupMenu popupMenu = new JPopupMenu();
		popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
		popupMenu.add(resetPerHour);
		popupMenu.add(pauseSkill);
		popupMenu.add(canvasItem);
		popupMenu.addPopupMenuListener(new PopupMenuListener()
		{
			@Override
			public void popupMenuWillBecomeVisible(PopupMenuEvent popupMenuEvent)
			{
				canvasItem.setText(timeToMaxPlugin.hasOverlay(skill) ? REMOVE_STATE : ADD_STATE);
			}

			@Override
			public void popupMenuWillBecomeInvisible(PopupMenuEvent popupMenuEvent)
			{
			}

			@Override
			public void popupMenuCanceled(PopupMenuEvent popupMenuEvent)
			{
			}
		});

		canvasItem.addActionListener(e ->
		{
			if (canvasItem.getText().equals(REMOVE_STATE))
			{
				timeToMaxPlugin.removeOverlay(skill);
			}
			else
			{
				timeToMaxPlugin.addOverlay(skill);
			}
		});

		headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		headerPanel.setLayout(new BorderLayout());
		statsPanel.setLayout(new DynamicGridLayout(2, 2));
		statsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		statsPanel.setBorder(new EmptyBorder(9, 2, 9, 2));

		topLeftStat.setFont(FontManager.getRunescapeSmallFont());
		bottomLeftStat.setFont(FontManager.getRunescapeSmallFont());
		topRightStat.setFont(FontManager.getRunescapeSmallFont());
		bottomRightStat.setFont(FontManager.getRunescapeSmallFont());


		statsPanel.add(topLeftStat);     // top left
		statsPanel.add(topRightStat);    // top right
		statsPanel.add(bottomLeftStat);  // bottom left
		statsPanel.add(bottomRightStat); // bottom right

		JLabel headerSkillIcon = getSkillIcon(iconManager, skill, 35, 35, false);
		headerPanel.add(headerSkillIcon, BorderLayout.WEST);
		headerPanel.add(statsPanel, BorderLayout.CENTER);

		progressWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		progressWrapper.setLayout(new BorderLayout());
		progressWrapper.setBorder(DEFAULT_PROGRESS_WRAPPER_BORDER);

		progressBar.setMaximumValue(100);
		progressBar.setBackground(new Color(61, 56, 49));
		progressBar.setForeground(SkillColor.find(skill).getColor());
		progressBar.setDimmedText("Paused");
		progressBar.setFont(FontManager.getRunescapeSmallFont());
		progressBar.setLeftLabel("0%");
		progressBar.setRightLabel("100%");
		progressBar.setCenterLabel("0%");

		compactSkillIcon = getSkillIcon(iconManager, skill, 25, 16, true);
		compactSkillIcon.setVisible(false);

		progressWrapper.add(compactSkillIcon, BorderLayout.WEST);
		progressWrapper.add(progressBar, BorderLayout.CENTER);

		container.add(headerPanel, BorderLayout.NORTH);
		container.add(progressWrapper, BorderLayout.SOUTH);

		container.setComponentPopupMenu(popupMenu);
		progressBar.setComponentPopupMenu(popupMenu);

		// forward mouse drag events to parent panel for drag and drop reordering
		MouseDragEventForwarder mouseDragEventForwarder = new MouseDragEventForwarder(panel);
		container.addMouseListener(mouseDragEventForwarder);
		container.addMouseMotionListener(mouseDragEventForwarder);
		progressBar.addMouseListener(mouseDragEventForwarder);
		progressBar.addMouseMotionListener(mouseDragEventForwarder);

		// collapse/expand on mouse click
		final MouseAdapter clickToggleCompact = new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (e.getButton() == MouseEvent.BUTTON1)
				{
					toggleCompactView();
				}
			}
		};
		container.addMouseListener(clickToggleCompact);
		progressBar.addMouseListener(clickToggleCompact);

		add(container, BorderLayout.NORTH);
	}

	void reset()
	{
		canvasItem.setText(ADD_STATE);
		setCompactView(false);
		panel.remove(this);
		panel.revalidate();
	}

	void update(boolean updated, boolean paused, XpSnapshotSingle xpSnapshotSingle)
	{
		SwingUtilities.invokeLater(() -> rebuildAsync(updated, paused, xpSnapshotSingle));
	}

	private void toggleCompactView()
	{
		final boolean isCompact = !headerPanel.isVisible();
		setCompactView(!isCompact);
	}

	private void setCompactView(final boolean compact)
	{
		progressWrapper.setBorder(compact ? COMPACT_PROGRESS_WRAPPER_BORDER : DEFAULT_PROGRESS_WRAPPER_BORDER);
		headerPanel.setVisible(!compact);
		compactSkillIcon.setVisible(compact);
	}

	private static JLabel getSkillIcon(SkillIconManager iconManager, Skill skill, int width, int height, boolean small)
	{
		JLabel skillIcon = new JLabel();

		skillIcon.setIcon(new ImageIcon(iconManager.getSkillImage(skill, small)));
		skillIcon.setPreferredSize(new Dimension(width, height));
		skillIcon.setHorizontalAlignment(SwingConstants.CENTER);
		skillIcon.setVerticalAlignment(SwingConstants.CENTER);

		return skillIcon;
	}

	private void rebuildAsync(boolean updated, boolean skillPaused, XpSnapshotSingle xpSnapshotSingle)
	{
		if (updated)
		{
			if (getParent() != panel)
			{
				panel.add(this);
				panel.revalidate();
			}

			// Handle prioritized skills (move to top)
			if (config.prioritizeRecentXpSkills())
			{
				panel.setComponentZOrder(this, 0);
			}

			// Handle completed skills (move to bottom)
			if (config.pinCompletedSkillsToBottom())
			{
				int goalStartXp = xpSnapshotSingle.getStartGoalXp();
				int xpGained = xpSnapshotSingle.getXpGainedInSession();
				int currentXp = goalStartXp + xpGained;

				// If we have goal information and enough XP to determine completion
				try
				{
					// If skill target is met, move to bottom of panel
					var startGoalXp = xpSnapshotSingle.getStartGoalXp();
					if (Math.max(0, currentXp - startGoalXp) >= XpCalculator.getRequiredXpPerInterval(startGoalXp, config))
					{
						panel.setComponentZOrder(this, panel.getComponentCount() - 1);
						panel.revalidate();
					}
				}
				catch (Exception e)
				{
					// Don't change positioning if we can't determine completion status
				}
			}

			paused = skillPaused;

			// Always use consistent XP values from the snapshot
			int goalStartXp = xpSnapshotSingle.getStartGoalXp();
			int xpGained = xpSnapshotSingle.getXpGainedInSession();
			int requiredXpForInterval = XpCalculator.getRequiredXpPerInterval(goalStartXp, config);

			// Update progress bar
			progressBar.setValue((int) xpSnapshotSingle.getSkillProgressToGoal());
			progressBar.setCenterLabel(config.progressBarLabel().getValueFunc().apply(xpSnapshotSingle));
			progressBar.setLeftLabel("");
			progressBar.setRightLabel(QuantityFormatter.quantityToRSDecimalStack(requiredXpForInterval, true));

			// Set center label based on completion status
			if ((int) xpSnapshotSingle.getSkillProgressToGoal() >= 100)
			{
				progressBar.setCenterLabel("Complete");
				// collapse progress bar if completed
				if (config.collapseCompletedSkills())
				{
					setCompactView(true);
				}
			}
			else
			{
				setCompactView(false);
				progressBar.setValue((int) xpSnapshotSingle.getSkillProgressToGoal());
				progressBar.setCenterLabel(config.progressBarLabel().getValueFunc().apply(xpSnapshotSingle));
			}

			// Prepare tooltip text
			XpProgressBarLabel tooltipLabel = config.progressBarTooltipLabel();
			String targetProgressText = String.format(
				"<br/>%s/%s target XP for %s",
				QuantityFormatter.quantityToRSDecimalStack(xpGained, true),
				QuantityFormatter.quantityToRSDecimalStack(requiredXpForInterval, true),
				config.trackingInterval().toString().toLowerCase());

			// Set tooltip based on skill type
			if (isCombatSkill(skill))
			{
				progressBar.setToolTipText(String.format(
					PROGRESS_BAR_TOOLTIP_NO_ACTIONS,
					tooltipLabel.getValueFunc().apply(xpSnapshotSingle),
					tooltipLabel == XpProgressBarLabel.PERCENTAGE ? "of goal" : "till goal xp",
					targetProgressText));
			}
			else
			{
				progressBar.setToolTipText(String.format(
					PROGRESS_BAR_TOOLTIP,
					xpSnapshotSingle.getActionsInSession(),
					xpSnapshotSingle.getActionsPerHour(),
					tooltipLabel.getValueFunc().apply(xpSnapshotSingle),
					tooltipLabel == XpProgressBarLabel.PERCENTAGE ? "of goal" : "till goal xp",
					targetProgressText));
			}

			progressBar.setDimmed(skillPaused);
		}
		// Handle paused state changes
		else if (!paused && skillPaused)
		{
			progressBar.setDimmed(true);
			paused = true;
			pauseSkill.setText("Unpause");
		}
		else if (paused && !skillPaused)
		{
			progressBar.setDimmed(false);
			paused = false;
			pauseSkill.setText("Pause");
		}

		// Update information labels
		// Update exp per hour separately, every time (not only when there's an update)
		topLeftStat.setText(htmlLabel(config.xpPanelLabel1(), xpSnapshotSingle));
		topRightStat.setText(htmlLabel(config.xpPanelLabel2(), xpSnapshotSingle));
		bottomLeftStat.setText(htmlLabel(config.xpPanelLabel3(), xpSnapshotSingle));
		bottomRightStat.setText(htmlLabel(config.xpPanelLabel4(), xpSnapshotSingle));
	}

	private String htmlLabel(XpPanelLabel panelLabel, XpSnapshotSingle xpSnapshotSingle)
	{
		// hide actions for combat skills
		if (isActions(panelLabel) && isCombatSkill(skill))
		{
			return "";
		}

		String key = panelLabel.getKey() + ": ";
		String value = panelLabel.getValueFunc().apply(xpSnapshotSingle);
		return htmlLabel(key, value);
	}

	private static boolean isActions(XpPanelLabel panelLabel)
	{
		return panelLabel == XpPanelLabel.ACTIONS_LEFT || panelLabel == XpPanelLabel.ACTIONS_HOUR || panelLabel == XpPanelLabel.ACTIONS_DONE;
	}

	private static boolean isCombatSkill(Skill skill)
	{
		return skill == Skill.ATTACK || skill == Skill.STRENGTH || skill == Skill.DEFENCE || skill == Skill.HITPOINTS || skill == Skill.RANGED;
	}

	static String htmlLabel(String key, int value)
	{
		String valueStr = QuantityFormatter.quantityToRSDecimalStack(value, true);
		return htmlLabel(key, valueStr);
	}

	static String htmlLabel(String key, String valueStr)
	{
		return String.format(HTML_LABEL_TEMPLATE, ColorUtil.toHexColor(ColorScheme.LIGHT_GRAY_COLOR), key, valueStr);
	}
}

/*
 * Copyright (c) 2017, Cameron <moberg@tuta.io>
 * Copyright (c) 2018, Levi <me@levischuck.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

import com.google.common.annotations.VisibleForTesting;
import static com.google.common.base.MoreObjects.firstNonNull;
import com.google.inject.Binder;
import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.EnumSet;
import javax.inject.Inject;
import lombok.AccessLevel;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Experience;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.Player;
import net.runelite.api.Skill;
import net.runelite.api.WorldType;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.StatChanged;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.RuneScapeProfileChanged;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import static com.timetomax.XpWorldType.NORMAL;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

@PluginDescriptor(
	name = "Time To Max",
	description = "Enable the XP Tracker panel",
	tags = {"experience", "levels", "panel"}
)
@Slf4j
public class TimeToMaxPlugin extends Plugin
{
	private static final String MENUOP_ADD_CANVAS_TRACKER = "Add to canvas";
	private static final String MENUOP_REMOVE_CANVAS_TRACKER = "Remove from canvas";

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private SkillIconManager skillIconManager;

	@Inject
	private TimeToMaxConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private XpState xpState;

	@Inject
	private ConfigManager configManager;

	private NavigationButton navButton;
	@Setter(AccessLevel.PACKAGE)
	@VisibleForTesting
	private XpPanel xpPanel;
	private XpWorldType lastWorldType;
	private long lastAccount;
	private long lastTickMillis = 0;
	private int initializeTracker;

	private final XpPauseState xpPauseState = new XpPauseState();

	@Provides
	TimeToMaxConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TimeToMaxConfig.class);
	}

	@Override
	public void configure(Binder binder)
	{
		binder.bind(TimeToMaxService.class).to(TimeToMaxServiceImpl.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		// Create panel first
		xpPanel = new XpPanel(this, config, client, skillIconManager);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "timetomax.png");

		navButton = NavigationButton.builder()
			.tooltip("Time to Max")
			.icon(icon)
			.priority(3)
			.panel(xpPanel)
			.build();

		clientToolbar.addNavigation(navButton);

		// Initialize values
		lastAccount = -1L;
		lastTickMillis = 0;

		// Use clientThread for operations that interact with the game client
		clientThread.invokeLater(() -> {
			if (client.getGameState() == GameState.LOGGED_IN)
			{
				lastAccount = client.getAccountHash();
				lastWorldType = worldSetToType(client.getWorldType());
			}
		});
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.removeIf(e -> e instanceof XpInfoBoxOverlay);
		xpState.reset();
		clientToolbar.removeNavigation(navButton);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		GameState state = event.getGameState();
		if (state == GameState.LOGGED_IN)
		{
			// LOGGED_IN is triggered between region changes too.
			// Check that the username changed or the world type changed.
			XpWorldType type = worldSetToType(client.getWorldType());

			if (client.getAccountHash() != lastAccount || lastWorldType != type)
			{
				// Reset
				log.debug("World change: {} -> {}, {} -> {}",
					lastAccount, client.getAccountHash(),
					firstNonNull(lastWorldType, "<unknown>"),
					firstNonNull(type, "<unknown>"));

				lastAccount = client.getAccountHash();
				lastWorldType = type;
				resetState();

				// Must be set from hitting the LOGGING_IN or HOPPING case below
				assert initializeTracker > 0;
			}
		}
		else if (state == GameState.LOGGING_IN || state == GameState.HOPPING)
		{
			initializeTracker = 2;
		}
		else if (state == GameState.LOGIN_SCREEN)
		{
			Player local = client.getLocalPlayer();
			if (local == null)
			{
				return;
			}

			String username = local.getName();
			if (username == null)
			{
				return;
			}
		}
	}

	@Subscribe
	public void onRuneScapeProfileChanged(RuneScapeProfileChanged event)
	{
		XpSave save = xpState.save();
		if (save != null)
		{
			saveSaveState(event.getPreviousProfile(), save);
		}
	}

	@Subscribe
	public void onClientShutdown(ClientShutdown event)
	{
		XpSave save = xpState.save();
		if (save != null)
		{
			saveSaveState(configManager.getRSProfileKey(), save);
		}
	}

	private XpWorldType worldSetToType(EnumSet<WorldType> types)
	{
		XpWorldType xpType = NORMAL;
		for (WorldType type : types)
		{
			XpWorldType t = XpWorldType.of(type);
			if (t != NORMAL)
			{
				xpType = t;
			}
		}
		return xpType;
	}

	/**
	 * Adds an overlay to the canvas for tracking a specific skill.
	 *
	 * @param skill the skill for which the overlay should be added
	 */
	void addOverlay(Skill skill)
	{
		removeOverlay(skill);
		overlayManager.add(new XpInfoBoxOverlay(this, config, skill, skillIconManager.getSkillImage(skill)));
	}

	/**
	 * Removes an overlay from the overlayManager if it's present.
	 *
	 * @param skill the skill for which the overlay should be removed.
	 */
	void removeOverlay(Skill skill)
	{
		overlayManager.removeIf(e -> e instanceof XpInfoBoxOverlay && ((XpInfoBoxOverlay) e).getSkill() == skill);
	}

	/**
	 * Check if there is an overlay on the canvas for the skill.
	 *
	 * @param skill the skill which should have an overlay.
	 * @return true if the skill has an overlay.
	 */
	boolean hasOverlay(final Skill skill)
	{
		return overlayManager.anyMatch(o -> o instanceof XpInfoBoxOverlay && ((XpInfoBoxOverlay) o).getSkill() == skill);
	}

	/**
	 * Reset internal state and re-initialize all skills with XP currently cached by the RS client
	 * This is called by the user manually clicking resetSkillState in the UI.
	 * It reloads the current skills from the client after resetting internal state.
	 */
	void resetAndInitState()
	{
		clearSaveState(configManager.getRSProfileKey());
		resetState();

		for (Skill skill : Skill.values())
		{
			long currentXp = client.getSkillExperience(skill);
			xpState.initializeSkill(skill, currentXp);
			removeOverlay(skill);
		}

		xpState.initializeOverall(client.getOverallExperience());
	}

	/**
	 * Throw out everything, the user has chosen a different account or world type.
	 * This resets both the internal state and UI elements
	 */
	private void resetState()
	{
		xpState.reset();
		xpPanel.resetAllInfoBoxes();
		xpPanel.updateTotal(new XpSnapshotSingle.XpSnapshotSingleBuilder().build());
		overlayManager.removeIf(e -> e instanceof XpInfoBoxOverlay);
	}

	/**
	 * Reset an individual skill with the client's current known state of the skill
	 * Will also clear the skill from the UI and reset its baseline XP.
	 *
	 * @param skill Skill to reset
	 */
	void resetSkillState(Skill skill)
	{
		int currentXp = client.getSkillExperience(skill);
		xpState.initializeSkill(skill, currentXp);
		xpPanel.resetSkill(skill);
		removeOverlay(skill);
	}

	/**
	 * Reset all skills except for the one provided
	 *
	 * @param skill Skill to ignore during reset
	 */
	void resetOtherSkillState(Skill skill)
	{
		for (Skill s : Skill.values())
		{
			if (skill != s)
			{
				resetSkillState(s);
			}
		}
	}

	/**
	 * Reset the xp gained since last reset of the skill
	 * Does not clear the skill from the UI.
	 *
	 * @param skill Skill to reset per hour rate
	 */
	void resetSkillPerHourState(Skill skill)
	{
		xpState.resetSkillPerHour(skill);
	}

	/**
	 * Reset the xp gained since last reset of all skills including OVERALL
	 * Does not clear the UI.
	 */
	void resetAllSkillsPerHourState()
	{
		for (Skill skill : Skill.values())
		{
			xpState.resetSkillPerHour(skill);
		}
		xpState.resetOverallPerHour();
	}

	@Subscribe
	public void onStatChanged(StatChanged statChanged)
	{
		final Skill skill = statChanged.getSkill();
		final int currentXp = statChanged.getXp();
		final int currentLevel = Experience.getLevelForXp(currentXp);

		// Skip processing for skills that are already maxed
		if (config.maxSkillMode() == MaxSkillMode.NORMAL)
		{
			if (currentLevel >= Experience.MAX_REAL_LEVEL)
			{
				xpPanel.resetSkill(skill);
				removeOverlay(skill);
				return;
			}
		}
		else if (config.maxSkillMode() == MaxSkillMode.COMPLETIONIST)
		{
			if (currentXp == Experience.MAX_SKILL_XP)
			{
				xpPanel.resetSkill(skill);
				removeOverlay(skill);
				return;
			}
		}

		// If this is the initial skill sync on login, initialize but don't process
		if (initializeTracker > 0)
		{
			return;
		}

		// Calculate goal XP values using the period tracking system
		final int goalStartXp = (int) getSkillState(skill).getStartXp();
		final int intervalXp = XpCalculator.getRequiredXpPerInterval(
			goalStartXp,
			config);
		final int goalEndXp = goalStartXp + intervalXp;

		// Update the skill state and UI
		final XpUpdateResult updateResult = xpState.updateSkill(
			skill,
			currentXp,
			goalStartXp,
			goalEndXp);

		xpPanel.updateSkillExperience(updateResult == XpUpdateResult.UPDATED, xpPauseState.isPaused(skill),
			skill, getSkillSnapshot(skill));

		// Also update the total experience
		xpState.updateOverall(client.getOverallExperience());
		xpPanel.updateTotal(xpState.getTotalSnapshot());

		// Update the target panel to reflect current XP rates
		xpPanel.updateTargetPanel(config);
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (initializeTracker > 0 && --initializeTracker == 0)
		{
			XpSave save;
			// Restore from saved state
			if (!xpState.isOverallInitialized() && (save = loadSaveState(configManager.getRSProfileKey())) != null)
			{
				log.debug("Loading xp state from save");
				xpState.restore(save);

				for (Skill skill : save.skills.keySet())
				{
					XpStateSingle skillState = getSkillState(skill);
					int startXp = (int) skillState.getStartXp();
					int intervalXp = XpCalculator.getRequiredXpPerInterval(startXp, config);
					int goalXp = startXp + intervalXp;
					skillState.updateGoals(startXp, goalXp);
				}

				// apply state to the panel
				for (Skill skill : save.skills.keySet())
				{
					xpPanel.updateSkillExperience(true, false, skill, getSkillSnapshot(skill));
				}
			}

			// Check for xp gained while logged out
			for (Skill skill : Skill.values())
			{
				if (!xpState.isInitialized(skill))
				{
					continue;
				}

				XpStateSingle skillState = getSkillState(skill);
				final int currentXp = client.getSkillExperience(skill);
				if (skillState.getCurrentXp() != currentXp)
				{
					if (currentXp < skillState.getCurrentXp())
					{
						log.debug("Xp is going backwards! {} {} -> {}", skill, skillState.getCurrentXp(), currentXp);
						resetState();
						clearSaveState(configManager.getRSProfileKey());
						break;
					}

					log.debug("Skill xp for {} changed when offline: {} -> {}", skill, skillState.getCurrentXp(), currentXp);
					// Offset start xp for offline gains
					long diff = currentXp - skillState.getCurrentXp();
					skillState.setStartXp(skillState.getStartXp() + diff);
				}

				XpCalculator.recordIntervalStartDate(
					skill,
					LocalDate.parse(config.targetDate()),
					config.trackingInterval());
			}

			// Initialize the tracker with the initial xp if not already initialized
			for (Skill skill : Skill.values())
			{
				if (!xpState.isInitialized(skill))
				{
					final int currentXp = client.getSkillExperience(skill);
					// goal exps are not necessary for skill initialization
					XpUpdateResult xpUpdateResult = xpState.updateSkill(skill, currentXp, -1, -1);
					assert xpUpdateResult == XpUpdateResult.INITIALIZED;
				}
			}

			// Initialize all non-maxed skills
			initializeNonMaxedSkills();

			// Initialize the overall xp
			if (!xpState.isOverallInitialized())
			{
				long overallXp = client.getOverallExperience();
				log.debug("Initializing XP tracker with {} overall exp", overallXp);
				xpState.initializeOverall(overallXp);
			}
		}

	}

	private void initializeNonMaxedSkills()
	{
		for (Skill skill : Skill.values())
		{
			final int currentXp = client.getSkillExperience(skill);
			final int currentLevel = Experience.getLevelForXp(currentXp);

			// Only show non-maxed skills
			if (config.maxSkillMode() == MaxSkillMode.NORMAL)
			{
				if ((currentLevel < Experience.MAX_REAL_LEVEL))
				{
					setCalculatedSkillExperience(skill, currentXp);
				}
			}
			else if (config.maxSkillMode() == MaxSkillMode.COMPLETIONIST)
			{
				if (currentXp < Experience.MAX_SKILL_XP)
				{
					setCalculatedSkillExperience(skill, currentXp);
				}
			}
		}
	}

	private void setCalculatedSkillExperience(Skill skill, int startXp)
	{
		// Calculate the interval goal based on current XP
		final int intervalXp = XpCalculator.getRequiredXpPerInterval(
			startXp,
			config);
		final int endGoalXp = startXp + intervalXp;

		XpStateSingle x = getSkillState(skill);
		x.updateGoals(startXp, endGoalXp);
		x.update(client.getSkillExperience(skill));

		xpPanel.updateSkillExperience(true, xpPauseState.isPaused(skill),
			skill, getSkillSnapshot(skill));
	}

	@Subscribe
	public void onMenuEntryAdded(final MenuEntryAdded event)
	{
		int widgetID = event.getActionParam1();

		if (WidgetUtil.componentToInterface(widgetID) != InterfaceID.STATS
			|| !event.getOption().startsWith("View")
			|| !config.skillTabOverlayMenuOptions())
		{
			return;
		}

		// Get skill from menu option, eg. "View <col=ff981f>Attack</col> guide"
		final String skillText = event.getOption().split(" ")[1];
		final Skill skill;

		try
		{
			skill = Skill.valueOf(Text.removeTags(skillText).toUpperCase());
		}
		catch (IllegalArgumentException ignored)
		{
			return;
		}
		client.getMenu().createMenuEntry(-1)
			.setTarget(skillText)
			.setOption(hasOverlay(skill) ? MENUOP_REMOVE_CANVAS_TRACKER : MENUOP_ADD_CANVAS_TRACKER)
			.setType(MenuAction.RUNELITE)
			.onClick(e ->
			{
				if (hasOverlay(skill))
				{
					removeOverlay(skill);
				}
				else
				{
					addOverlay(skill);
				}
			});
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted commandExecuted)
	{
		if (commandExecuted.getCommand().equals("ttmreset"))
		{
			log.info("TTM Reset command triggered by command");
			handleTTMReset();
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "TTM has been reset by user.", null);
		}
	}

	XpStateSingle getSkillState(Skill skill)
	{
		return xpState.getSkill(skill);
	}

	XpSnapshotSingle getSkillSnapshot(Skill skill)
	{
		return xpState.getSkillSnapshot(skill);
	}

	/**
	 * Get the injected ConfigManager for other components to use
	 * @return the ConfigManager instance
	 */
	public ConfigManager getInjectedConfigManager()
	{
		return configManager;
	}

	@Schedule(
		period = 1,
		unit = ChronoUnit.SECONDS
	)
	public void tickSkillTimes()
	{
		int pauseSkillAfter = config.pauseSkillAfter();
		// Adjust unpause states
		for (Skill skill : Skill.values())
		{
			long skillExperience = client.getSkillExperience(skill);
			xpPauseState.tickXp(skill, skillExperience, pauseSkillAfter);
		}
		xpPauseState.tickOverall(client.getOverallExperience(), pauseSkillAfter);

		final boolean loggedIn = client.getGameState().getState() >= GameState.LOADING.getState();
		xpPauseState.tickLogout(config.pauseOnLogout(), loggedIn);

		if (lastTickMillis == 0)
		{
			lastTickMillis = System.currentTimeMillis();
			return;
		}

		final long nowMillis = System.currentTimeMillis();
		final long tickDelta = nowMillis - lastTickMillis;
		lastTickMillis = nowMillis;

		for (Skill skill : Skill.values())
		{
			if (!xpPauseState.isPaused(skill))
			{
				xpState.tick(skill, tickDelta);
			}
		}
		if (!xpPauseState.isOverallPaused())
		{
			xpState.tickOverall(tickDelta);
		}

		rebuildSkills();

		xpPanel.updateTargetPanel(config);
	}

	@Schedule(
		period = 1,
		unit = ChronoUnit.MINUTES,
		asynchronous = true
	)
	public void tickStateSave()
	{
		if (xpState == null)
		{
			log.debug("Cannot save XP state: xpState is null");
			return;
		}

		XpSave save = xpState.save();
		if (save != null)
		{
			String profile = configManager.getRSProfileKey();
			saveSaveState(profile, save);
			log.debug("Saved XP state for profile: {}", profile);
		}

		// Check for interval reset - should be skill-agnostic to avoid multiple resets
		TrackingInterval interval = config.trackingInterval();
		
		// Find the earliest period start date from any skill
		LocalDate earliestPeriodStart = null;
		for (Skill skill : Skill.values())
		{
			LocalDate skillPeriodStart = XpCalculator.getIntervalStartDate(skill);
			if (skillPeriodStart != null && (earliestPeriodStart == null || skillPeriodStart.isBefore(earliestPeriodStart)))
			{
				earliestPeriodStart = skillPeriodStart;
			}
		}
		
		// If we have a period start date and we need to start a new period, trigger reset
		if (earliestPeriodStart != null && XpCalculator.shouldStartNewIntervalForDate(interval, earliestPeriodStart))
		{
			log.info("Interval change detected for {} interval - triggering reset", interval);
			handleTTMReset();
			String message = String.format("Time to Max: New %s has been detected. Resetting xp tracker", interval);
			clientThread.invoke(() ->{
				client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, null);
			});
		}
	}

	private void rebuildSkills()
	{
		// Rebuild calculated values like xp/hr in panel
		for (Skill skill : Skill.values())
		{
			xpPanel.updateSkillExperience(false, xpPauseState.isPaused(skill), skill, getSkillSnapshot(skill));
		}

		xpPanel.updateTotal(xpState.getTotalSnapshot());
	}

	void pauseSkill(Skill skill, boolean pause)
	{
		if (pause ? xpPauseState.pauseSkill(skill) : xpPauseState.unpauseSkill(skill))
		{
			xpPanel.updateSkillExperience(false, xpPauseState.isPaused(skill), skill, getSkillSnapshot(skill));
		}
	}

	void pauseAllSkills(boolean pause)
	{
		for (Skill skill : Skill.values())
		{
			pauseSkill(skill, pause);
		}
		if (pause)
		{
			xpPauseState.pauseOverall();
		}
		else
		{
			xpPauseState.unpauseOverall();
		}
	}

	private void saveSaveState(String profile, XpSave state)
	{
		if (state != null && profile != null && !profile.isEmpty())
		{
			// Save to config
			try
			{
				configManager.setConfiguration("timeToMax", profile, "state", state);
				log.debug("Successfully saved XP state for profile: {}", profile);
			}
			catch (Exception e)
			{
				log.warn("Failed to save XP state", e);
			}
		}
	}

	private void clearSaveState(String profile)
	{
		if (profile != null && !profile.isEmpty())
		{
			configManager.unsetConfiguration("timeToMax", profile, "state");
		}
	}

	private XpSave loadSaveState(String profile)
	{
		return configManager.getConfiguration("timeToMax", profile, "state", XpSave.class);
	}

	private void handleTTMReset()
	{
		resetAndInitState();
		for (Skill s : Skill.values())
		{
			xpState.unInitializeSkill(s);
		}
		xpState.unInitializeOverall();
		XpSave save = new XpSave();
		saveSaveState(configManager.getRSProfileKey(), save);
		initializeTracker = 1;
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!"timeToMax".equals(event.getGroup()))
		{
			return;
		}

		// Check if the changed key is one we need to respond to
		if ("targetDate".equals(event.getKey()) || "trackingInterval".equals(event.getKey()) ||
			"maxSkillMode".equals(event.getKey()))
		{
			log.debug("Config changed: {} - Triggering recalculation", event.getKey());

			// Update the target panel with new config values
			xpPanel.updateTargetPanel(config);

			// Trigger reinitialization for all non-maxed skills
			if (client.getGameState() == GameState.LOGGED_IN)
			{
				for (Skill skill : Skill.values())
				{
					final int currentXp = client.getSkillExperience(skill);
					final int currentLevel = Experience.getLevelForXp(currentXp);
					final int startXp = getSkillState(skill).getStartXp() == -1 ? currentXp : (int) getSkillState(skill).getStartXp();

					if (config.maxSkillMode() == MaxSkillMode.NORMAL)
					{
						// Remove skills over level 99
						if (currentLevel >= Experience.MAX_REAL_LEVEL)
						{
							xpPanel.resetSkill(skill);
							removeOverlay(skill);
						}
						else
						{
							// Recalculate goals for skills under level 99
							setCalculatedSkillExperience(skill, startXp);
						}
					}
					else if (config.maxSkillMode() == MaxSkillMode.COMPLETIONIST)
					{
						// Ensure skills under 200m XP are displayed and goals recalculated
						if (currentXp == Experience.MAX_SKILL_XP)
						{
							xpPanel.resetSkill(skill);
							removeOverlay(skill);
						}
						else
						{
							setCalculatedSkillExperience(skill, startXp);
						}
					}
				}
			}
		}
	}
}

/*
 * Copyright (c) 2018, Levi <me@levischuck.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

import lombok.Builder;
import lombok.Value;

@Builder
@Value
class XpSnapshotSingle
{
	private int startLevel;
	private int endLevel;
	private int startGoalXp;
	private int endGoalXp;
	private int xpGainedInSession;
	private int xpRemainingToGoal;
	private int xpPerHour;
	private double skillProgressToGoal;
	private int actionsInSession;
	private int actionsRemainingToGoal;
	private int actionsPerHour;
	private String timeTillGoal;
	private String timeTillGoalHours;
	private String timeTillGoalShort;
}

/*
 * Copyright (c) 2018, Levi <me@levischuck.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

enum XpUpdateResult
{
	NO_CHANGE,
	INITIALIZED,
	UPDATED,
}

package com.timetomax;

public enum MaxSkillMode
{
	NORMAL("Normal"),
	COMPLETIONIST("Completionist");

	private final String mode;

	MaxSkillMode(String mode)
	{
		this.mode = mode;
	}

	@Override
	public String toString()
	{
		return mode;
	}
}

package com.timetomax;

public enum TrackingInterval
{
	DAY("Day"),
	WEEK("Week"),
	MONTH("Month");

	private final String name;

	TrackingInterval(String name)
	{
		this.name = name;
	}

	@Override
	public String toString()
	{
		return name;
	}
}
/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Skill;

@Singleton
class TimeToMaxServiceImpl implements TimeToMaxService
{
	private final TimeToMaxPlugin plugin;

	@Inject
	TimeToMaxServiceImpl(TimeToMaxPlugin plugin)
	{
		this.plugin = plugin;
	}

	@Override
	public int getActions(Skill skill)
	{
		return plugin.getSkillSnapshot(skill).getActionsInSession();
	}

	@Override
	public int getActionsHr(Skill skill)
	{
		return plugin.getSkillSnapshot(skill).getActionsPerHour();
	}

	@Override
	public int getActionsLeft(Skill skill)
	{
		return plugin.getSkillSnapshot(skill).getActionsRemainingToGoal();
	}

	@Override
	public int getXpHr(Skill skill)
	{
		return plugin.getSkillSnapshot(skill).getXpPerHour();
	}

	@Override
	public int getStartGoalXp(Skill skill)
	{
		return plugin.getSkillSnapshot(skill).getStartGoalXp();
	}

	@Override
	public int getEndGoalXp(Skill skill)
	{
		return plugin.getSkillSnapshot(skill).getEndGoalXp();
	}

	@Override
	public String getTimeTilGoal(Skill skill)
	{
		return plugin.getSkillSnapshot(skill).getTimeTillGoalShort();
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

import net.runelite.api.Client;
import net.runelite.api.WorldType;

enum XpWorldType
{
	NORMAL,
	TOURNEY,
	DMM
		{
			@Override
			int modifier(Client client)
			{
				return 5;
			}
		},
	LEAGUE
		{
			@Override
			int modifier(Client client)
			{
				return 5;
			}
		};

	int modifier(Client client)
	{
		return 1;
	}

	static XpWorldType of(WorldType type)
	{
		switch (type)
		{
			case NOSAVE_MODE:
				return TOURNEY;
			case DEADMAN:
				return DMM;
			case SEASONAL:
				return LEAGUE;
			default:
				return NORMAL;
		}
	}
}

/*
 * Copyright (c) 2017, Cameron <moberg@tuta.io>
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.time.DayOfWeek;
import java.time.Duration;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.Map;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.util.Date;
import javax.swing.JSpinner;
import javax.swing.SpinnerDateModel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.DragAndDropReorderPane;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;

@Slf4j
class XpPanel extends PluginPanel
{
	private final Map<Skill, XpInfoBox> infoBoxes = new HashMap<>();
	private final JLabel overallExpGained = new JLabel(XpInfoBox.htmlLabel("Gained: ", 0));
	private final JLabel overallExpHour = new JLabel(XpInfoBox.htmlLabel("Per hour: ", 0));

	private final JPanel overallPanel = new JPanel();

	// New panel for target XP information
	private final JPanel targetPanel = new JPanel();
	private final JLabel targetDateLabel = new JLabel(XpInfoBox.htmlLabel("Target Date: ", ""));
	private final JLabel targetIntervalLabel = new JLabel(XpInfoBox.htmlLabel("Tracking: ", ""));
	private final JLabel intervalsRemainingLabel = new JLabel(XpInfoBox.htmlLabel("Intervals remaining: ", ""));
	// Configuration controls panel
	private final JPanel configPanel = new JPanel();
	private final JPanel configHeaderPanel = new JPanel();
	private final JButton configToggleButton = new JButton(" Configuration");	private final JPanel configContentPanel = new JPanel();
	private final JSpinner targetDateSpinner = new JSpinner(new SpinnerDateModel());
	private final JComboBox<TrackingInterval> trackingIntervalCombo = new JComboBox<>(TrackingInterval.values());
	private final JComboBox<MaxSkillMode> maxSkillModeCombo = new JComboBox<>(MaxSkillMode.values());
	private boolean configExpanded = false;
	// Reference to plugin for accessing injected dependencies
	//private final TimeToMaxPlugin plugin;
	private final ConfigManager configManager;

	/* This displays the "track xp" text */
	private final PluginErrorPanel errorPanel = new PluginErrorPanel();
	/**
	 * Sets up the configuration panel with controls for changing config values
	 */	private void setupConfigPanel(TimeToMaxConfig config)
	{
		// Set up main config panel
		configPanel.setLayout(new BorderLayout());
		configPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		// Add thin white border around the entire config panel
		configPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
		
		// Set up header panel with toggle button
		configHeaderPanel.setLayout(new BorderLayout());
		configHeaderPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		configHeaderPanel.setBorder(new EmptyBorder(5, 5, 5, 5));
		
		configToggleButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		configToggleButton.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		configToggleButton.setBorderPainted(false);
		configToggleButton.setFocusPainted(false);
		configToggleButton.setContentAreaFilled(false);
		configToggleButton.addActionListener(e -> toggleConfigPanel());
		
		configHeaderPanel.add(configToggleButton, BorderLayout.WEST);
		configPanel.add(configHeaderPanel, BorderLayout.NORTH);
		
		// Set up content panel
		configContentPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		configContentPanel.setLayout(new GridLayout(6, 2, 5, 5));
		configContentPanel.setBorder(new EmptyBorder(5, 5, 5, 5));
				// Target Date
		configContentPanel.add(new JLabel("Target Date:"));
		
		// Set up date spinner
		targetDateSpinner.setEditor(new JSpinner.DateEditor(targetDateSpinner, "yyyy-MM-dd"));
		try {
			LocalDate configDate = LocalDate.parse(config.targetDate());
			Date date = Date.from(configDate.atStartOfDay().atZone(java.time.ZoneId.systemDefault()).toInstant());
			targetDateSpinner.setValue(date);
		} catch (Exception e) {
			// Default to today's date if parsing fails
			targetDateSpinner.setValue(new Date());
		}
		
		targetDateSpinner.addChangeListener(e -> {
			Date selectedDate = (Date) targetDateSpinner.getValue();
			LocalDate localDate = selectedDate.toInstant().atZone(java.time.ZoneId.systemDefault()).toLocalDate();
			updateConfigValue("targetDate", localDate.toString());
		});
		
		configContentPanel.add(targetDateSpinner);
		
		// Tracking Interval
		configContentPanel.add(new JLabel("Tracking Interval:"));
		trackingIntervalCombo.setSelectedItem(config.trackingInterval());
		trackingIntervalCombo.addActionListener(e -> updateConfigValue("trackingInterval", ((TrackingInterval) trackingIntervalCombo.getSelectedItem()).name()));
		configContentPanel.add(trackingIntervalCombo);

		// Max Skill Mode
		configContentPanel.add(new JLabel("Max Skill Mode:"));
		maxSkillModeCombo.setSelectedItem(config.maxSkillMode());
		maxSkillModeCombo.addActionListener(e -> updateConfigValue("maxSkillMode", ((MaxSkillMode) maxSkillModeCombo.getSelectedItem()).name()));
		configContentPanel.add(maxSkillModeCombo);
		
		// Start collapsed by default
		configContentPanel.setVisible(false);
		configExpanded = false;
	}
	
	/**
	 * Toggles the visibility of the config panel content
	 */
	private void toggleConfigPanel()
	{
		configExpanded = !configExpanded;
		configContentPanel.setVisible(configExpanded);
		configToggleButton.setText(configExpanded ? " Configuration" : " Configuration");
		
		// Add or remove content panel based on expanded state
		if (configExpanded && configContentPanel.getParent() == null)
		{
			configPanel.add(configContentPanel, BorderLayout.CENTER);
		}
		else if (!configExpanded && configContentPanel.getParent() != null)
		{
			configPanel.remove(configContentPanel);
		}
		
		configPanel.revalidate();
		configPanel.repaint();
		this.revalidate();
		this.repaint();
	}

	/**
	 * Updates a config value using the ConfigManager
	 */
	private void updateConfigValue(String key, String value)
	{
		try
		{
			configManager.setConfiguration("timeToMax", key, value);
		}
		catch (Exception e)
		{
			// Handle validation errors gracefully - for now just log the error
			XpPanel.log.debug("Failed to update config value {} to '{}': {}", key, value, e.getMessage());
		}
	}

	XpPanel(TimeToMaxPlugin timeToMaxPlugin, TimeToMaxConfig timeToMaxConfig, Client client, SkillIconManager iconManager)
	{
		super();

		this.configManager = timeToMaxPlugin.getInjectedConfigManager();

		setBorder(new EmptyBorder(6, 6, 6, 6));
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setLayout(new BorderLayout());

		final JPanel layoutPanel = new JPanel();
		BoxLayout boxLayout = new BoxLayout(layoutPanel, BoxLayout.Y_AXIS);
		layoutPanel.setLayout(boxLayout);
		add(layoutPanel, BorderLayout.NORTH);

		// Initialize config panel
		setupConfigPanel(timeToMaxConfig);

		overallPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
		overallPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		overallPanel.setLayout(new BorderLayout());
		overallPanel.setVisible(false);

		// Create reset all per hour menu
		final JMenuItem resetPerHour = new JMenuItem("Reset All/hr");
		resetPerHour.addActionListener(e -> timeToMaxPlugin.resetAllSkillsPerHourState());

		// Create pause all menu
		final JMenuItem pauseAll = new JMenuItem("Pause All");
		pauseAll.addActionListener(e -> timeToMaxPlugin.pauseAllSkills(true));

		// Create unpause all menu
		final JMenuItem unpauseAll = new JMenuItem("Unpause All");
		unpauseAll.addActionListener(e -> timeToMaxPlugin.pauseAllSkills(false));


		// Create popup menu
		final JPopupMenu popupMenu = new JPopupMenu();
		popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
		popupMenu.add(resetPerHour);
		popupMenu.add(pauseAll);
		popupMenu.add(unpauseAll);

		overallPanel.setComponentPopupMenu(popupMenu);

		final JLabel overallIcon = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(), "/skill_icons/overall.png")));

		final JPanel overallInfo = new JPanel();
		overallInfo.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		overallInfo.setLayout(new GridLayout(2, 1));
		overallInfo.setBorder(new EmptyBorder(0, 10, 0, 0));
		// Initialize the target panel
		targetPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
		targetPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		targetPanel.setLayout(new GridLayout(4, 1));
		targetPanel.setVisible(true); // Make target panel visible by default

		targetDateLabel.setFont(FontManager.getRunescapeSmallFont());
		targetIntervalLabel.setFont(FontManager.getRunescapeSmallFont());
		intervalsRemainingLabel.setFont(FontManager.getRunescapeSmallFont());

		targetPanel.add(targetDateLabel);
		targetPanel.add(targetIntervalLabel);
		targetPanel.add(intervalsRemainingLabel);

		// Set initial values
		updateTargetPanel(timeToMaxConfig);

		overallExpGained.setFont(FontManager.getRunescapeSmallFont());
		overallExpHour.setFont(FontManager.getRunescapeSmallFont());

		overallInfo.add(overallExpGained);
		overallInfo.add(overallExpHour);
		overallPanel.add(overallIcon, BorderLayout.WEST);
		overallPanel.add(overallInfo, BorderLayout.CENTER);

		final JComponent infoBoxPanel = new DragAndDropReorderPane();
		// Add target panel to layout
		layoutPanel.add(targetPanel);
		
		// Add config panel to layout
		layoutPanel.add(configPanel);

		errorPanel.setContent("Time To Max", "To start tracking how much XP you need per interval, make sure to:\n" +
			"<br/>\n" +
			"<br/>- Log in to your account\n" +
			"<br/>- Earn some XP\n" +
			"<br/><br/>Once you've done both, this plugin will begin calculating your XP needs automatically!");
		add(errorPanel);

		layoutPanel.add(overallPanel);
		layoutPanel.add(infoBoxPanel);

		for (Skill skill : Skill.values())
		{
			infoBoxes.put(skill, new XpInfoBox(timeToMaxPlugin, timeToMaxConfig, infoBoxPanel, skill, iconManager));
		}
	}

	void showOverallPanel()
	{
		overallPanel.setVisible(true);
	}

	void resetAllInfoBoxes()
	{
		infoBoxes.forEach((skill, xpInfoBox) -> xpInfoBox.reset());
	}

	void resetSkill(Skill skill)
	{
		final XpInfoBox xpInfoBox = infoBoxes.get(skill);
		xpInfoBox.reset();
	}

	void updateSkillExperience(boolean updated, boolean paused, Skill skill, XpSnapshotSingle xpSnapshotSingle)
	{
		final XpInfoBox xpInfoBox = infoBoxes.get(skill);
		xpInfoBox.update(updated, paused, xpSnapshotSingle);
	}

	void updateTotal(XpSnapshotSingle xpSnapshotTotal)
	{
		// if player has gained exp and hasn't switched displays yet, hide error panel and show overall info
		if (xpSnapshotTotal.getXpGainedInSession() > 0 && !overallPanel.isVisible())
		{
			overallPanel.setVisible(true);
			remove(errorPanel);
		}
		else if (xpSnapshotTotal.getXpGainedInSession() == 0 && overallPanel.isVisible())
		{
			overallPanel.setVisible(false);
			add(errorPanel);
		}

		SwingUtilities.invokeLater(() -> rebuildAsync(xpSnapshotTotal));
	}

	private void rebuildAsync(XpSnapshotSingle xpSnapshotTotal)
	{
		overallExpGained.setText(XpInfoBox.htmlLabel("Gained: ", xpSnapshotTotal.getXpGainedInSession()));
		overallExpHour.setText(XpInfoBox.htmlLabel("Per hour: ", xpSnapshotTotal.getXpPerHour()));
	}

	/**
	 * Updates the target panel with the current configuration values
	 */
	void updateTargetPanel(TimeToMaxConfig config)
	{
		try
		{
			LocalDate targetDate = LocalDate.parse(config.targetDate());
			TrackingInterval interval = config.trackingInterval();
			LocalDate now = LocalDate.now();

			long intervalsRemaining;
			String timeLeftInCurrentInterval;
			String intervalUnit;
			String currentIntervalLabel;

			LocalDateTime currentTime = LocalDateTime.now();
			LocalDateTime nextIntervalEnd;

			switch (interval)
			{
				case DAY:
					intervalUnit = "Day";
					currentIntervalLabel = "day";
					intervalsRemaining = ChronoUnit.DAYS.between(now, targetDate);
					nextIntervalEnd = currentTime.toLocalDate().atTime(23, 59, 59);
					break;
				case WEEK:
					intervalUnit = "Week";
					currentIntervalLabel = "week";
					intervalsRemaining = ChronoUnit.WEEKS.between(now, targetDate);
					// End of week (Sunday 23:59:59)
					int daysUntilEndOfWeek = DayOfWeek.SUNDAY.getValue() - currentTime.getDayOfWeek().getValue();
					if (daysUntilEndOfWeek < 0) daysUntilEndOfWeek += 7;
					nextIntervalEnd = currentTime.toLocalDate().plusDays(daysUntilEndOfWeek).atTime(23, 59, 59);
					break;
				case MONTH:
					intervalUnit = "Month";
					currentIntervalLabel = "month";
					intervalsRemaining = ChronoUnit.MONTHS.between(now.withDayOfMonth(1), targetDate.withDayOfMonth(1));
					LocalDate lastDayOfMonth = currentTime.toLocalDate().withDayOfMonth(currentTime.toLocalDate().lengthOfMonth());
					nextIntervalEnd = lastDayOfMonth.atTime(23, 59, 59);
					break;
				default:
					intervalUnit = "Interval";
					currentIntervalLabel = "interval";
					intervalsRemaining = Math.max(0, ChronoUnit.DAYS.between(now, targetDate));
					nextIntervalEnd = currentTime.plusDays(1).withHour(23).withMinute(59).withSecond(59);
			}

			Duration duration = Duration.between(currentTime, nextIntervalEnd);
			long totalSeconds = duration.getSeconds();
			if (totalSeconds < 0) totalSeconds = 0;

			long months = 0;
			long days = 0;
			long hours = 0;
			long minutes = 0;

			// Calculate months and days if needed
			java.time.LocalDateTime temp = currentTime;
			if (totalSeconds > 30L * 24 * 3600) {
				// More than 30 days
				months = ChronoUnit.MONTHS.between(temp.toLocalDate(), nextIntervalEnd.toLocalDate());
				temp = temp.plusMonths(months);
			}
			if (totalSeconds > 24 * 3600) {
				days = ChronoUnit.DAYS.between(temp.toLocalDate(), nextIntervalEnd.toLocalDate());
				temp = temp.plusDays(days);
			}
			Duration remainder = Duration.between(temp, nextIntervalEnd);
			hours = remainder.toHours();
			minutes = remainder.toMinutes() % 60;

			StringBuilder sb = new StringBuilder();
			if (totalSeconds > 30L * 24 * 3600) {
				if (months > 0) sb.append(months).append(" month").append(months != 1 ? "s " : " ");
				if (days > 0) sb.append(days).append(" day").append(days != 1 ? "s " : " ");
				sb.append(String.format("%02d:%02d", hours, minutes));
			} else if (totalSeconds > 24 * 3600) {
				if (days > 0) sb.append(days).append(" day").append(days != 1 ? "s " : " ");
				sb.append(String.format("%02d:%02d", hours, minutes));
			} else {
				sb.append(String.format("%02d:%02d", hours, minutes));
			}
			timeLeftInCurrentInterval = sb.toString().trim();

			targetDateLabel.setText(XpInfoBox.htmlLabel("Target Date: ", targetDate.toString()));
			targetIntervalLabel.setText(XpInfoBox.htmlLabel("Tracking: ", "Per " + interval.toString().toLowerCase()));

			String intervalsRemainingText = intervalUnit + "s remaining to goal: ";
			String timeLeftText = "Time left in current " + currentIntervalLabel + ": ";

			intervalsRemainingLabel.setText(XpInfoBox.htmlLabel(intervalsRemainingText, String.valueOf(intervalsRemaining)));
			JLabel timeLeftLabel = new JLabel(XpInfoBox.htmlLabel(timeLeftText, timeLeftInCurrentInterval));
			timeLeftLabel.setFont(FontManager.getRunescapeSmallFont());

			targetPanel.removeAll();
			targetPanel.add(targetDateLabel);
			targetPanel.add(targetIntervalLabel);
			targetPanel.add(intervalsRemainingLabel);
			targetPanel.add(timeLeftLabel);
			targetPanel.setVisible(true);
			targetPanel.revalidate();
			targetPanel.repaint();
			
			// Update config controls to reflect current values
			refreshConfigControls(config);
		}
		catch (DateTimeParseException e)
		{
			targetDateLabel.setText(XpInfoBox.htmlLabel("Target Date: ", "Invalid date format"));
			targetIntervalLabel.setText(XpInfoBox.htmlLabel("Tracking: ", config.trackingInterval().toString()));
			intervalsRemainingLabel.setText(XpInfoBox.htmlLabel("Intervals remaining: ", "Unknown"));

			targetPanel.setVisible(true);
			targetPanel.revalidate();
			targetPanel.repaint();
			
			// Update config controls to reflect current values even on error
			refreshConfigControls(config);
		}
	}
		/**
	 * Refreshes the config control values to match the current configuration
	 */	private void refreshConfigControls(TimeToMaxConfig config)
	{
		try {
			// Update all config controls to reflect current values
			try {
				LocalDate configDate = LocalDate.parse(config.targetDate());
				Date date = Date.from(configDate.atStartOfDay().atZone(java.time.ZoneId.systemDefault()).toInstant());
				targetDateSpinner.setValue(date);
			} catch (Exception e) {
				// Default to today's date if parsing fails
				targetDateSpinner.setValue(new Date());
			}
			
			trackingIntervalCombo.setSelectedItem(config.trackingInterval());
			maxSkillModeCombo.setSelectedItem(config.maxSkillMode());
		} catch (Exception e) {
			// If there are any config errors (like invalid enum values), reset to defaults
			log.debug("Error refreshing config controls, resetting to defaults: {}", e.getMessage());
			
			// Reset enum configs to their default values
			try {
				configManager.setConfiguration("timeToMax", "trackingInterval", TrackingInterval.DAY.name());
				configManager.setConfiguration("timeToMax", "maxSkillMode", MaxSkillMode.NORMAL.name());
			} catch (Exception resetError) {
				log.debug("Failed to reset config to defaults: {}", resetError.getMessage());
			}
			
			// Set UI to default values
			targetDateSpinner.setValue(new Date());
			trackingIntervalCombo.setSelectedItem(TrackingInterval.DAY);
			maxSkillModeCombo.setSelectedItem(MaxSkillMode.NORMAL);
		}
	}
}

/*
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

import net.runelite.api.Skill;

public interface TimeToMaxService
{
	/**
	 * Get the number of actions done
	 */
	int getActions(Skill skill);

	/**
	 * Get the number of actions per hour
	 */
	int getActionsHr(Skill skill);

	/**
	 * Get the number of actions remaining
	 */
	int getActionsLeft(Skill skill);

	/**
	 * Get the amount of xp per hour
	 */
	int getXpHr(Skill skill);

	/**
	 * Get the start goal XP
	 */
	int getStartGoalXp(Skill skill);

	/**
	 * Get the amount of XP left until goal level
	 */
	int getEndGoalXp(Skill skill);

	/**
	 * Get the amount of time left until goal level
	 */
	String getTimeTilGoal(Skill skill);
}

package com.timetomax;

import java.time.LocalDate;
import java.time.temporal.ChronoField;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.Map;
import net.runelite.api.Skill;

/**
 * Utility class for XP calculations and display
 */
public class XpCalculator
{
	// XP required for level 99 in each skill
	public static final int LEVEL_99_XP = 13_034_431;
	public static final int MAX_XP = 200_000_000;

	// Store starting XP for each skill for target tracking
	private static final Map<Skill, LocalDate> intervalStartDates = new HashMap<>();
	private static LocalDate lastTargetDate = null;

	/**
	 * Check if a new period should start for a skill based on the interval
	 *
	 * @param skill    The skill to check
	 * @param interval The current tracking interval
	 * @return true if a new period should start
	 */
	public static boolean shouldStartNewPeriod(Skill skill, TrackingInterval interval)
	{
		LocalDate periodStart = intervalStartDates.get(skill);
		if (periodStart == null)
		{
			return true;
		}

		LocalDate now = LocalDate.now();
		switch (interval)
		{
			case DAY:
				return !now.equals(periodStart);
			case WEEK:
				return ChronoUnit.WEEKS.between(periodStart, now) > 0;
			case MONTH:
				return ChronoUnit.MONTHS.between(periodStart, now) > 0;
			default:
				return true;
		}
	}

	/**
	 * Records the starting XP for target tracking and updates period tracking
	 *
	 * @param skill      The skill to record
	 * @param targetDate The target date (to detect changes)
	 * @param interval   The tracking interval
	 */
	public static void recordIntervalStartDate(Skill skill, LocalDate targetDate, TrackingInterval interval)
	{
		// Reset tracking if target date changes
		if (lastTargetDate == null || !lastTargetDate.equals(targetDate))
		{
			intervalStartDates.clear();
			lastTargetDate = targetDate;
		}

		if (!intervalStartDates.containsKey(skill))
		{
			intervalStartDates.put(skill, LocalDate.now());
		}
		else if (shouldStartNewPeriod(skill, interval))
		{
			intervalStartDates.put(skill, LocalDate.now());
		}
	}

	/**
	 * Get the required XP per day to reach max level by the target date
	 *
	 * @param startXp    Start XP in the skill
	 * @param config     Instance of the TimeToMaxConfig
	 * @return XP required per day
	 */
	public static int getRequiredXpPerDay(int startXp, TimeToMaxConfig config)
	{
		long daysUntilTarget = ChronoUnit.DAYS.between(LocalDate.now(), LocalDate.parse(config.targetDate()));
		if (daysUntilTarget <= 0)
		{
			if (config.maxSkillMode() == MaxSkillMode.NORMAL)
			{
				return LEVEL_99_XP - startXp; // Target date is today or in the past
			}
			else if (config.maxSkillMode() == MaxSkillMode.COMPLETIONIST)
			{
				return MAX_XP - startXp;
			}
		}

		int xpRemaining = 0;

		if (config.maxSkillMode() == MaxSkillMode.NORMAL)
		{
			xpRemaining = LEVEL_99_XP - startXp;
			if (xpRemaining <= 0)
			{
				return 0;
			}
		}
		else if (config.maxSkillMode() == MaxSkillMode.COMPLETIONIST)
		{
			xpRemaining = MAX_XP - startXp;
			if (xpRemaining <= 0)
			{
				return 0;
			}

		}

		return (int) Math.ceil((double) xpRemaining / daysUntilTarget);
	}

	/**
	 * Get the required XP per interval to reach max level by the target date
	 *
	 * @param startXp    Start XP in the skill
	 * @param config instance of TimeToMaxConfig
	 * @return XP required per interval
	 */
	public static int getRequiredXpPerInterval(int startXp, TimeToMaxConfig config)
	{
		int xpPerDay = getRequiredXpPerDay(startXp, config);

		switch (config.trackingInterval())
		{
			case WEEK:
				return xpPerDay * 7;
			case MONTH:
				return xpPerDay * 30;
			default:
				return xpPerDay;
		}
	}

	/**
	 * Check if a new interval should start based only on the interval type and reference date.
	 * This is interval-specific but skill-agnostic.
	 *
	 * @param interval      The current tracking interval
	 * @param referenceDate The reference date to compare against
	 * @return true if a new interval should start
	 */
	public static boolean shouldStartNewIntervalForDate(TrackingInterval interval, LocalDate referenceDate)
	{
		if (referenceDate == null)
		{
			return true;
		}

		LocalDate now = LocalDate.now();
		switch (interval)
		{
			case DAY:
				return !now.equals(referenceDate);
			case WEEK:
				// Check if the current date is in a different ISO week than the reference date
				return now.get(ChronoField.ALIGNED_WEEK_OF_YEAR) != referenceDate.get(ChronoField.ALIGNED_WEEK_OF_YEAR)
						|| now.getYear() != referenceDate.getYear();
			case MONTH:
				// Check if the current date is in a different calendar month than the reference date
				return now.getMonth() != referenceDate.getMonth() || now.getYear() != referenceDate.getYear();
			default:
				return true;
		}
	}

	/**
	 * Get the interval start date for a skill
	 *
	 * @param skill The skill to get the interval start date for
	 * @return The interval start date for the skill or null if not set
	 */
	public static LocalDate getIntervalStartDate(Skill skill)
	{
		return intervalStartDates.get(skill);
	}
}
/*
 * Copyright (c) 2017, Cameron <moberg@tuta.io>
 * Copyright (c) 2018, Levi <me@levischuck.com>
 * Copyright (c) 2020, Anthony <https://github.com/while-loop>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

import java.util.Arrays;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Experience;

@Slf4j
class XpStateSingle
{
	private int actions = 0;
	private int actionsSinceReset = 0;
	private boolean actionsHistoryInitialized = false;
	private final int[] actionExps = new int[10];
	private int actionExpIndex = 0;

	@Getter
	@Setter
	private long startXp;

	@Getter
	@Setter
	private long endXp;

	@Getter
	private int xpGainedSinceReset = 0;

	private int xpGainedBeforeReset = 0;

	// how long the skill has been trained for in ms
	@Setter
	private long skillTime = 0;
	// the last time the skill xp changed in ms
	@Getter
	private long lastChangeMillis;
	private int startLevelExp = 0;
	private int endLevelExp = 0;

	XpStateSingle(long startXp, long endXp)
	{
		this.startXp = startXp;
		this.endXp = endXp;
	}

	XpStateSingle(long startXp)
	{
		this.startXp = startXp;
	}

	long getCurrentXp()
	{
		return startXp + getTotalXpGained();
	}

	int getTotalXpGained()
	{
		return xpGainedBeforeReset + xpGainedSinceReset;
	}

	private int getActionsHr()
	{
		return toHourly(actionsSinceReset);
	}

	private int toHourly(int value)
	{
		return (int) ((1.0 / (getTimeElapsedInSeconds() / 3600.0)) * value);
	}

	private long getTimeElapsedInSeconds()
	{
		// If the skill started just now, we can divide by near zero, this results in odd behavior.
		// To prevent that, pretend the skill has been active for a minute (60 seconds)
		// This will create a lower estimate for the first minute,
		// but it isn't ridiculous like saying 2 billion XP per hour.
		return Math.max(60, skillTime / 1000);
	}

	private int getXpRemaining()
	{
		// Always use endLevelExp which is the current goal (either user defined or next level)
		// endLevelExp is properly set in updateGoals based on the user's configured goal
		int xpGained = getTotalXpGained();
		int xpGoal = endLevelExp - startLevelExp;
		return Math.max(0, xpGoal - xpGained);
	}

	private int getActionsRemaining()
	{
		if (actionsHistoryInitialized)
		{
			// Use XP remaining to the actual goal (endLevelExp) rather than next level
			long xpRemaining = getXpRemaining() * actionExps.length;
			long totalActionXp = 0;

			for (int actionXp : actionExps)
			{
				totalActionXp += actionXp;
			}

			// Let's not divide by zero (or negative)
			if (totalActionXp > 0)
			{
				// Make sure to account for the very last action at the end
				long remainder = xpRemaining % totalActionXp;
				long quotient = xpRemaining / totalActionXp;
				return Math.toIntExact(quotient + (remainder > 0 ? 1 : 0));
			}
		}

		return Integer.MAX_VALUE;
	}

	private double getSkillProgress()
	{
		double xpGained = getTotalXpGained();
		double xpGoal = endLevelExp - startLevelExp;
		return (xpGained / xpGoal) * 100;
	}

	private long getSecondsTillLevel()
	{
		long seconds = getTimeElapsedInSeconds();
		if (seconds <= 0 || xpGainedSinceReset <= 0)
		{
			return -1;
		}

		// formula is xpRemaining / xpPerSecond
		// xpPerSecond being total xp gained / seconds
		// This can be simplified so division is only done once and we can work in whole numbers!
		return (getXpRemaining() * seconds) / xpGainedSinceReset;
	}

	private String getTimeTillLevel(XpGoalTimeType goalTimeType)
	{
		long remainingSeconds = getSecondsTillLevel();
		if (remainingSeconds < 0)
		{
			return "\u221e";
		}

		// Java 8 doesn't have good duration / period objects to represent spans of time that can be formatted
		// Rather than importing another dependency like joda time (which is practically built into java 10)
		// below will be a custom formatter that handles spans larger than 1 day
		long durationDays = remainingSeconds / (24 * 60 * 60);
		long durationHours = (remainingSeconds % (24 * 60 * 60)) / (60 * 60);
		long durationHoursTotal = remainingSeconds / (60 * 60);
		long durationMinutes = (remainingSeconds % (60 * 60)) / 60;
		long durationSeconds = remainingSeconds % 60;

		switch (goalTimeType)
		{
			case DAYS:
				if (durationDays > 1)
				{
					return String.format("%d days %02d:%02d:%02d", durationDays, durationHours, durationMinutes, durationSeconds);
				}
				else if (durationDays == 1)
				{
					return String.format("1 day %02d:%02d:%02d", durationHours, durationMinutes, durationSeconds);
				}
			case HOURS:
				if (durationHoursTotal > 1)
				{
					return String.format("%d hours %02d:%02d", durationHoursTotal, durationMinutes, durationSeconds);
				}
				else if (durationHoursTotal == 1)
				{
					return String.format("1 hour %02d:%02d", durationMinutes, durationSeconds);
				}
			case SHORT:
			default:
				// durationDays = 0 or durationHoursTotal = 0 or goalTimeType = SHORT if we got here.
				// return time remaining in hh:mm:ss or mm:ss format where hh can be > 24
				if (durationHoursTotal > 0)
				{
					return String.format("%d:%02d:%02d", durationHoursTotal, durationMinutes, durationSeconds);
				}

				// Minutes and seconds will always be present
				return String.format("%02d:%02d", durationMinutes, durationSeconds);
		}
	}

	int getXpHr()
	{
		return toHourly(xpGainedSinceReset);
	}

	void resetPerHour()
	{
		//reset actions per hour
		actionsSinceReset = 0;

		//preserve total xp gained while resetting the per-hour tracking
		xpGainedBeforeReset += xpGainedSinceReset;
		xpGainedSinceReset = 0;
		lastChangeMillis = System.currentTimeMillis();
		setSkillTime(0);
	}

	boolean update(long currentXp)
	{
		if (startXp == -1)
		{
			log.warn("Attempted to update skill state {} but was not initialized with current xp", this);
			return false;
		}

		// Calculate XP gained since last update
		long previousTotal = getTotalXpGained();
		int actionExp = (int) (currentXp - (startXp + previousTotal));

		// No experience gained
		if (actionExp == 0)
		{
			return false;
		}

		if (actionsHistoryInitialized)
		{
			actionExps[actionExpIndex] = actionExp;
		}
		else
		{
			// populate all values in our action history array with this first value that we see
			// so the average value of our action history starts out as this first value we see
			Arrays.fill(actionExps, actionExp);
			actionsHistoryInitialized = true;
		}

		actionExpIndex = (actionExpIndex + 1) % actionExps.length;
		actions++;
		actionsSinceReset++;

		// Calculate experience gained
		xpGainedSinceReset = (int) (currentXp - (startXp + xpGainedBeforeReset));
		lastChangeMillis = System.currentTimeMillis();

		return true;
	}

	void updateGoals(int goalStartXp, int goalEndXp)
	{
		// Since we're calculating start and end goal, we just set the values directly
		// Default to 0 if the goal is not set
		startLevelExp = Math.max(goalStartXp, 0);

		endLevelExp = Math.max(goalEndXp, 0);
		endXp = endLevelExp;
	}

	public void tick(long delta)
	{
		// Track time as long as we have gained XP since baseline
		if (xpGainedSinceReset <= 0)
		{
			return;
		}
		skillTime += delta;
	}

	XpSnapshotSingle snapshot()
	{
		return XpSnapshotSingle.builder()
			.startLevel(Experience.getLevelForXp(startLevelExp))
			.endLevel(Experience.getLevelForXp(endLevelExp))
			.xpGainedInSession(getTotalXpGained())
			.xpRemainingToGoal(getXpRemaining())
			.xpPerHour(getXpHr())
			.skillProgressToGoal(getSkillProgress())
			.actionsInSession(actions)
			.actionsRemainingToGoal(getActionsRemaining())
			.actionsPerHour(getActionsHr())
			.timeTillGoal(getTimeTillLevel(XpGoalTimeType.DAYS))
			.timeTillGoalHours(getTimeTillLevel(XpGoalTimeType.HOURS))
			.timeTillGoalShort(getTimeTillLevel(XpGoalTimeType.SHORT))
			.startGoalXp(startLevelExp)
			.endGoalXp(endLevelExp)
			.build();
	}

	XpSaveSingle save()
	{
		XpSaveSingle save = new XpSaveSingle();
		save.startXp = startXp;
		save.endXp = endXp;
		save.xpGainedBeforeReset = xpGainedBeforeReset;
		save.xpGainedSinceReset = xpGainedSinceReset;
		save.time = skillTime;
		return save;
	}

	void restore(XpSaveSingle save)
	{
		startXp = save.startXp;
		endXp = save.endXp;
		xpGainedBeforeReset = save.xpGainedBeforeReset;
		xpGainedSinceReset = save.xpGainedSinceReset;
		skillTime = save.time;
	}
}

/*
 * Copyright (c) 2025, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;
import com.google.inject.Inject;
import java.util.LinkedHashMap;
import java.util.Map;
import net.runelite.api.Skill;
import net.runelite.client.config.ConfigSerializer;
import net.runelite.client.config.Serializer;

@ConfigSerializer(XpSaveSerializer.class)
class XpSave
{
	Map<Skill, XpSaveSingle> skills = new LinkedHashMap<>();
	XpSaveSingle overall;
}

class XpSaveSingle
{
	@SerializedName("s")
	long startXp;
	@SerializedName("e")
	long endXp;
	@SerializedName("br")
	int xpGainedBeforeReset;
	@SerializedName("ar")
	int xpGainedSinceReset;
	@SerializedName("t")
	long time; // ms
}

class XpSaveSerializer implements Serializer<XpSave>
{
	private final Gson gson;

	@Inject
	private XpSaveSerializer(Gson gson)
	{
		this.gson = gson;
	}

	@Override
	public String serialize(XpSave value)
	{
		return gson.toJson(value);
	}

	@Override
	public XpSave deserialize(String s)
	{
		return gson.fromJson(s, XpSave.class);
	}
}
/*
 * Copyright (c) 2020, Anthony <https://github.com/while-loop>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

import java.util.function.Function;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.client.util.QuantityFormatter;

@Getter
@AllArgsConstructor
public enum XpPanelLabel
{
	TIME_TO_LEVEL("TTL", XpSnapshotSingle::getTimeTillGoalShort),

	XP_GAINED("XP Gained", snap -> format(snap.getXpGainedInSession())),
	XP_HOUR("XP/hr", snap -> format(snap.getXpPerHour())),
	XP_LEFT("XP Left", snap -> format(snap.getXpRemainingToGoal())),

	ACTIONS_LEFT("Actions", snap -> format(snap.getActionsRemainingToGoal())),
	ACTIONS_HOUR("Actions/hr", snap -> format(snap.getActionsPerHour())),
	ACTIONS_DONE("Actions Done", snap -> format(snap.getActionsInSession())),
	;

	private final String key;
	private final Function<XpSnapshotSingle, String> valueFunc;

	private static String format(int val)
	{
		// actions remaining uses Integer.MAX_VALUE if the action history isn't initialized, which can happen
		// from restoring a save.
		return val == Integer.MAX_VALUE ? "N/A" : QuantityFormatter.quantityToRSDecimalStack(val, true);
	}
}

package com.timetomax;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import javax.inject.Inject;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Skill;

/**
 * Internal state for the TimeToMaxPlugin
 */
@Slf4j
class XpState
{
	private final Map<Skill, XpStateSingle> xpSkills = new EnumMap<>(Skill.class);
	// this is keeping a copy of the panel skill order so that serialization keeps the order
	private final List<Skill> order = new ArrayList<>(Skill.values().length);
	private XpStateSingle overall = new XpStateSingle(-1, -1);

	@Inject
	private TimeToMaxConfig config;

	/**
	 * Destroys all internal state, however any XpSnapshotSingle or XpSnapshotTotal remain unaffected.
	 */
	void reset()
	{
		xpSkills.clear();
		order.clear();
		overall = new XpStateSingle(-1, -1);
	}

	/**
	 * Resets the per hour rates of a single skill
	 *
	 * @param skill Skill to reset per hour rates
	 */
	void resetSkillPerHour(Skill skill)
	{
		xpSkills.get(skill).resetPerHour();
	}

	void resetOverallPerHour()
	{
		overall.resetPerHour();
	}

	/**
	 * Updates a skill with the current known XP.
	 * When the result of this operation is XpUpdateResult.UPDATED, the UI should be updated accordingly.
	 * This is to distinguish events that reload all the skill's current values (such as world hopping)
	 * and also first-login when the skills are not initialized (the start XP will be -1 in this case).
	 *
	 * @param skill       Skill to update
	 * @param currentXp   Current known XP for this skill
	 * @param goalStartXp Possible XP start goal
	 * @param goalEndXp   Possible XP end goal
	 * @return Whether or not the skill has been initialized, there was no change, or it has been updated
	 */
	XpUpdateResult updateSkill(Skill skill, long currentXp, int goalStartXp, int goalEndXp)
	{
		XpStateSingle state = xpSkills.get(skill);

		if (state == null || state.getStartXp() == -1)
		{
			assert currentXp >= 0;
			initializeSkill(skill, currentXp);
			return XpUpdateResult.INITIALIZED;
		}
		else
		{
			long startXp = state.getStartXp();
			int gainedXp = state.getTotalXpGained();

			if (startXp + gainedXp > currentXp)
			{
				// Reinitialize with lesser currentXp, this can happen with negative xp lamps
				initializeSkill(skill, currentXp);
				return XpUpdateResult.INITIALIZED;
			}
			else
			{
				if (!state.update(currentXp))
				{
					return XpUpdateResult.NO_CHANGE;
				}

				state.updateGoals(goalStartXp, goalEndXp);
				updateOrder(skill);
				return XpUpdateResult.UPDATED;
			}
		}
	}

	void updateOverall(long currentXp)
	{
		if (overall == null || overall.getStartXp() + overall.getTotalXpGained() > currentXp)
		{
			overall = new XpStateSingle(currentXp);
		}
		else
		{
			overall.update(currentXp);
		}
	}

	void tick(Skill skill, long delta)
	{
		final XpStateSingle state = getSkill(skill);
		tick(state, delta);
	}

	void tickOverall(long delta)
	{
		tick(overall, delta);
	}

	private void tick(XpStateSingle state, long delta)
	{
		state.tick(delta);

		int resetAfterMinutes = config.resetSkillRateAfter();
		if (resetAfterMinutes > 0)
		{
			final long now = System.currentTimeMillis();
			final int resetAfterMillis = resetAfterMinutes * 60 * 1000;
			final long lastChangeMillis = state.getLastChangeMillis();
			// When pauseSkillAfter is 0, it is effectively disabled
			if (lastChangeMillis != 0 && (now - lastChangeMillis) >= resetAfterMillis)
			{
				state.resetPerHour();
			}
		}
	}

	/**
	 * Forcefully initialize a skill with a known start XP from the current XP.
	 * This is used in resetAndInitState by the plugin. It should not result in showing the XP in the UI.
	 *
	 * @param skill     Skill to initialize
	 * @param currentXp Current known XP for the skill
	 */
	void initializeSkill(Skill skill, long currentXp)
	{
		xpSkills.put(skill, new XpStateSingle(currentXp));
	}

	void initializeOverall(long currentXp)
	{
		overall = new XpStateSingle(currentXp);
	}

	boolean isInitialized(Skill skill)
	{
		XpStateSingle xpStateSingle = xpSkills.get(skill);
		return xpStateSingle != null && xpStateSingle.getStartXp() != -1;
	}

	void unInitializeSkill(Skill skill)
	{
		XpStateSingle xpStateSingle = xpSkills.get(skill);
		xpStateSingle.setStartXp(-1);
	}

	void unInitializeOverall()
	{
		overall = new XpStateSingle(-1);
	}

	boolean isOverallInitialized()
	{
		return overall.getStartXp() != -1;
	}

	@NonNull
	XpStateSingle getSkill(Skill skill)
	{
		return xpSkills.computeIfAbsent(skill, (s) -> new XpStateSingle(-1, -1));
	}

	/**
	 * Obtain an immutable snapshot of the provided skill
	 * intended for use with the UI which operates on another thread
	 *
	 * @param skill Skill to obtain the snapshot for
	 * @return An immutable snapshot of the specified skill for this session since first login or last reset
	 */
	@NonNull
	XpSnapshotSingle getSkillSnapshot(Skill skill)
	{
		return getSkill(skill).snapshot();
	}

	/**
	 * Obtain an immutable snapshot of the provided skill
	 * intended for use with the UI which operates on another thread
	 *
	 * @return An immutable snapshot of total information for this session since first login or last reset
	 */
	@NonNull
	XpSnapshotSingle getTotalSnapshot()
	{
		return overall.snapshot();
	}

	/**
	 * Gets the current state for a skill
	 *
	 * @param skill The skill to get the state for
	 * @return The XpStateSingle for the skill, or null if not initialized
	 */
	XpStateSingle getSkillState(Skill skill)
	{
		return xpSkills.get(skill);
	}

	private void updateOrder(Skill skill)
	{
		if (config.prioritizeRecentXpSkills())
		{
			int idx = order.indexOf(skill);
			if (idx != 0)
			{
				order.remove(skill);
				order.add(0, skill);
			}
		}
		else
		{
			if (!order.contains(skill))
			{
				order.add(skill);
			}
		}
	}

	XpSave save()
	{
		if (overall.getStartXp() == -1)
		{
			return null;
		}

		XpSave save = new XpSave();
		for (Skill skill : order)
		{
			XpStateSingle state = xpSkills.get(skill);
			if (state.getTotalXpGained() > 0)
			{
				save.skills.put(skill, state.save());
			}
		}
		save.overall = overall.save();
		return save;
	}

	void restore(XpSave save)
	{
		reset();

		if (save.skills.entrySet().isEmpty())
		{
			log.debug("No skills in save!");
			return;
		}

		for (Map.Entry<Skill, XpSaveSingle> entry : save.skills.entrySet())
		{
			Skill skill = entry.getKey();
			XpSaveSingle s = entry.getValue();
			XpStateSingle state = new XpStateSingle(s.startXp, s.endXp);
			state.restore(s);
			xpSkills.put(skill, state);
			order.add(skill);
		}
		overall.restore(save.overall);
	}
}

/*
 * Copyright (c) 2020, Hamelot <devintinsley@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

public enum XpGoalTimeType
{
	DAYS,
	HOURS,
	SHORT
}

/*
 * Copyright (c) 2018, Jasper Ketelaar <Jasper0781@gmail.com>
 * Copyright (c) 2020, Anthony <https://github.com/while-loop>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.timetomax;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.Experience;
import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import net.runelite.api.Skill;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.SkillColor;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.ComponentOrientation;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.ProgressBarComponent;
import net.runelite.client.ui.overlay.components.SplitComponent;

class XpInfoBoxOverlay extends OverlayPanel
{
	private static final int BORDER_SIZE = 2;
	private static final int XP_AND_PROGRESS_BAR_GAP = 2;
	private static final int XP_AND_ICON_GAP = 4;
	private static final Rectangle XP_AND_ICON_COMPONENT_BORDER = new Rectangle(2, 1, 4, 0);

	private final PanelComponent iconXpSplitPanel = new PanelComponent();
	private final TimeToMaxPlugin plugin;
	private final TimeToMaxConfig config;

	@Getter(AccessLevel.PACKAGE)
	private final Skill skill;
	private final BufferedImage icon;

	XpInfoBoxOverlay(
		TimeToMaxPlugin plugin,
		TimeToMaxConfig config,
		Skill skill,
		BufferedImage icon)
	{
		super(plugin);
		this.plugin = plugin;
		this.config = config;
		this.skill = skill;
		this.icon = icon;
		panelComponent.setBorder(new Rectangle(BORDER_SIZE, BORDER_SIZE, BORDER_SIZE, BORDER_SIZE));
		panelComponent.setGap(new Point(0, XP_AND_PROGRESS_BAR_GAP));
		iconXpSplitPanel.setBorder(XP_AND_ICON_COMPONENT_BORDER);
		iconXpSplitPanel.setBackgroundColor(null);
		addMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "XP Tracker overlay");
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		iconXpSplitPanel.getChildren().clear();

		//Setting the font to rs small font so that the overlay isn't huge
		graphics.setFont(FontManager.getRunescapeSmallFont());

		final XpSnapshotSingle snapshot = plugin.getSkillSnapshot(skill);

		final String leftStr = config.onScreenDisplayMode().getKey();
		final String rightNum = config.onScreenDisplayMode().getValueFunc().apply(snapshot);

		final LineComponent xpLine = LineComponent.builder()
			.left(leftStr + ":")
			.right(rightNum)
			.build();

		final String bottomLeftStr = config.onScreenDisplayModeBottom().getKey();
		final String bottomRightNum = config.onScreenDisplayModeBottom().getValueFunc().apply(snapshot);

		final LineComponent xpLineBottom = LineComponent.builder()
			.left(bottomLeftStr + ":")
			.right(bottomRightNum)
			.build();

		final SplitComponent xpSplit = SplitComponent.builder()
			.first(xpLine)
			.second(xpLineBottom)
			.orientation(ComponentOrientation.VERTICAL)
			.build();

		final ImageComponent imageComponent = new ImageComponent(icon);
		final SplitComponent iconXpSplit = SplitComponent.builder()
			.first(imageComponent)
			.second(xpSplit)
			.orientation(ComponentOrientation.HORIZONTAL)
			.gap(new Point(XP_AND_ICON_GAP, 0))
			.build();

		iconXpSplitPanel.getChildren().add(iconXpSplit);

		final ProgressBarComponent progressBarComponent = new ProgressBarComponent();

		progressBarComponent.setBackgroundColor(new Color(61, 56, 49));
		progressBarComponent.setForegroundColor(SkillColor.find(skill).getColor());

		progressBarComponent.setLeftLabel(String.valueOf(snapshot.getStartLevel()));
		progressBarComponent.setRightLabel(snapshot.getEndGoalXp() == Experience.MAX_SKILL_XP
			? "200M"
			: String.valueOf(snapshot.getEndLevel()));

		progressBarComponent.setValue(snapshot.getSkillProgressToGoal());

		panelComponent.getChildren().add(iconXpSplitPanel);
		panelComponent.getChildren().add(progressBarComponent);

		return super.render(graphics);
	}

	@Override
	public String getName()
	{
		return super.getName() + skill.getName();
	}
}

package com.timetomax;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TimeToMaxPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TimeToMaxPlugin.class);
		RuneLite.main(args);
	}
}
