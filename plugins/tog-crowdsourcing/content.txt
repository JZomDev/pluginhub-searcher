package com.togcrowdsourcing;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ToGCrowdsourcingPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ToGCrowdsourcingPlugin.class);
		RuneLite.main(args);
	}
}
/*

BSD 2-Clause License

Copyright (c) 2022, JC Arbelbide
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.togcrowdsourcing;

import net.runelite.api.DecorativeObject;
import net.runelite.api.ObjectID;
import net.runelite.api.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.ComponentOrientation;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.ui.overlay.components.SplitComponent;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.ArrayList;

import static com.togcrowdsourcing.StreamOrderDetector.NUMBER_OF_TEAR_STREAMS;


class ToGCrowdsourcingOverlay extends OverlayPanel
{
	private final StreamOrderDetector streamOrderDetector;
	private final ToGCrowdsourcingConfig config;
	private static final int OVERLAY_SPLIT_GAP = 20;

	@Inject
	SpriteManager spriteManager;

	@Inject
	private ToGCrowdsourcingOverlay(StreamOrderDetector streamOrderDetector, ToGCrowdsourcingConfig config)
	{
		this.config = config;
		this.streamOrderDetector = streamOrderDetector;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.showOverlay()) { return null; }
		if (streamOrderDetector.getClient().getLocalPlayer().getWorldLocation().getRegionID() != streamOrderDetector.TOG_REGION) return null;

		ArrayList<TearStream> paddedList = padWithNull(streamOrderDetector.getStreamList());

		TripleLineComponent topLine = TripleLineComponent.builder()
				.left(streamToString(paddedList.get(0)))
				.middle(streamToString(paddedList.get(1)))
				.right(streamToString(paddedList.get(2)))
				.leftColor(paddedList.get(0).getColor())
				.middleColor(paddedList.get(1).getColor())
				.rightColor(paddedList.get(2).getColor())
				.build();

		TripleLineComponent bottomLine = TripleLineComponent.builder()
				.left(streamToString(paddedList.get(3)))
				.middle(streamToString(paddedList.get(4)))
				.right(streamToString(paddedList.get(5)))
				.leftColor(paddedList.get(3).getColor())
				.middleColor(paddedList.get(4).getColor())
				.rightColor(paddedList.get(5).getColor())
				.build();

		SplitComponent tearColorsSplitComponent = SplitComponent.builder()
				.first(topLine)
				.second(bottomLine)
				.orientation(ComponentOrientation.VERTICAL)
				.build();


		ImageComponent checkboxImageComponent = new ImageComponent(getCheckBoxImage());
		SplitComponent tearColorsAndCheckboxSplitComponent = SplitComponent.builder()
				.first(tearColorsSplitComponent)
				.second(checkboxImageComponent)
				.orientation(ComponentOrientation.HORIZONTAL)
				.gap(new Point(OVERLAY_SPLIT_GAP, 0))
				.build();

		panelComponent.getChildren().add(
				tearColorsAndCheckboxSplitComponent
		);

		return super.render(graphics);
	}

	public String streamToString(TearStream object)
	{
		DecorativeObject tearStreamObject = object.getTearStreamObject();
		if (tearStreamObject == null)
		{
			return "-";
		}
		if (	tearStreamObject.getId() == ObjectID.BLUE_TEARS ||
				tearStreamObject.getId() == ObjectID.BLUE_TEARS_6665)
		{
			return "Blue";
		}
		if (	tearStreamObject.getId() == ObjectID.GREEN_TEARS ||
				tearStreamObject.getId() == ObjectID.GREEN_TEARS_6666)
		{
			return "Green";
		}
		else { return "Error"; }
	}

	public ArrayList<TearStream> padWithNull(ArrayList<TearStream> streamList)
	{
		ArrayList<TearStream> paddedList = new ArrayList<>();
		for (int i = 0; i < streamList.size(); i++)
		{
			paddedList.add(streamList.get(i));
		}

		for (int i = 0; i < NUMBER_OF_TEAR_STREAMS - streamList.size(); i++) {
			paddedList.add(new TearStream(null, 0, Instant.now()));
		}

		return paddedList;
	}

	private BufferedImage getCheckBoxImage()
	{
		int spriteID = streamOrderDetector.isDataValid() ? SpriteID.OPTIONS_ROUND_CHECK_BOX_CHECKED : SpriteID.OPTIONS_ROUND_CHECK_BOX_CROSSED;
		return spriteManager.getSprite(spriteID, 0);
	}
}
/*
 * Copyright (c) 2019, Weird Gloop <admin@weirdgloop.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.togcrowdsourcing;

import javax.inject.Inject;
import javax.inject.Singleton;

import com.google.gson.*;
import com.togcrowdsourcing.ui.WorldHopper;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import java.io.IOException;
import java.util.ArrayList;

@Slf4j
@Singleton
public class CrowdsourcingManager
{
    private static final String CROWDSOURCING_BASE = "https://togcrowdsourcing.com/worldinfo";
//    private static final String CROWDSOURCING_BASE = "http://127.0.0.1:8080/worldinfo";           // For debug
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private Gson gson;

    protected void submitToAPI(WorldData worldData, WorldHopper worldHopper)
    {
        Request r = new Request.Builder()
                .url(CROWDSOURCING_BASE)
                .post(RequestBody.create(JSON, gson.toJson(worldData)))
                .build();

        okHttpClient.newCall(r).enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failure sending to crowdsourcing server.");
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                makeGetRequest(worldHopper);
                response.close();
            }

        });
    }

    public void makeGetRequest(WorldHopper worldHopper)
    {
        try
        {
            Request r = new Request.Builder()
                    .url(CROWDSOURCING_BASE)
                    .build();
            okHttpClient.newCall(r).enqueue(new Callback()
            {
                @Override
                public void onFailure(Call call, IOException e)
                {
                    log.debug("Error retrieving tog crowdsourcing data", e);

                    worldHopper.setGetError(true);

                    worldHopper.updateList();
                }

                @Override
                public void onResponse(Call call, Response response)
                {
                    if (response.isSuccessful())
                    {
                        try
                        {
                            worldHopper.setGetError(false);
                            JsonArray j = gson.newBuilder().create().fromJson(response.body().string(), JsonArray.class);
                            worldHopper.setWorldData(parseData(j));
                            worldHopper.updateList();
                        }
                        catch (IOException | JsonSyntaxException e)
                        {
                            log.error(e.getMessage());
                        }
                    }
                    else
                    {
                        log.error("Get request unsuccessful");
                    }
                }
            });
        }
        catch (IllegalArgumentException e)
        {
            log.error("Bad URL given: " + e.getLocalizedMessage());
        }
    }

    private ArrayList<WorldData> parseData(JsonArray j)
    {
        ArrayList<WorldData> l = new ArrayList<>();

        if (j == null) {return l;}

        for (JsonElement jsonElement : j)
        {
            JsonObject jObj = jsonElement.getAsJsonObject();
            WorldData d = new WorldData(
                    jObj.get("world_number").getAsInt(),
                    jObj.get("stream_order").getAsString(),
                    jObj.get("hits").getAsInt());
            l.add(d);
        }
        return l;
    }

}

/*

BSD 2-Clause License

Copyright (c) 2022, JC Arbelbide
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.togcrowdsourcing;

import javax.inject.Inject;

import com.google.inject.Provides;
import com.togcrowdsourcing.ui.WorldHopper;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.task.Schedule;

import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

@PluginDescriptor(
		name = "Tears of Guthix Crowdsourcing",
		description = "Crowdsource ToG stream orders to help players find the optimal world for the week."
)
public class ToGCrowdsourcingPlugin extends Plugin
{
	private static final int REFRESH_INTERVAL_ON_ERROR = 10;
	private int numFailedCallsToAPI = 0;

	@Inject
	private EventBus eventBus;

	@Inject
	private ToGCrowdsourcingConfig config;

	@Inject
	private StreamOrderDetector streamOrderDetector;

	@Inject
	private WorldHopper worldHopper;

	@Override
	protected void startUp() throws Exception
	{
		eventBus.register(streamOrderDetector);
		streamOrderDetector.startUpStreamOrderDetector(config, worldHopper);

		eventBus.register(worldHopper);
		worldHopper.startUpWorldHopper(config);
	}

	@Override
	protected void shutDown() throws Exception
	{
		eventBus.unregister(streamOrderDetector);
		streamOrderDetector.shutDownStreamOrderDetector();

		eventBus.unregister(worldHopper);
		worldHopper.shutDownWorldHopper();
	}

	@Schedule(
			period = REFRESH_INTERVAL_ON_ERROR,
			unit = ChronoUnit.SECONDS,
			asynchronous = true
	)
	public void refreshOnError()
	{
		if (!worldHopper.isGetError()) {
			numFailedCallsToAPI = 0;
			return;
		}

		numFailedCallsToAPI++;

		if (!shouldRetry()) {
			return;
		}

		synchronized (worldHopper)
		{
			worldHopper.getCrowdsourcingManager().makeGetRequest(worldHopper);
			worldHopper.updateList();
		}
	}

	private boolean shouldRetry()
	{
		// Seconds passed between failed calls is numFailedCallsToAPI * 10
		// we can attempt to retry at the following intervals:
		// 10, 20, 30, 60, 120, 300, 300, 300, ..., 300
		ArrayList<Integer> retryIntervalWhitelist = new ArrayList<>(Arrays.asList(0, 1, 2, 3, 6, 12, 30));
		int maxRetryInterval = Collections.max(retryIntervalWhitelist);

		// If the number of current retries is in the whitelist, we should retry.
		if (retryIntervalWhitelist.contains(numFailedCallsToAPI)) {
			return true;
		}

		// Cap out retry interval to the greatest one defined
		if (numFailedCallsToAPI % maxRetryInterval == 0) {
			return true;
		}

		return false;
	}

	@Provides
	ToGCrowdsourcingConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ToGCrowdsourcingConfig.class);
	}
}

/*

BSD 2-Clause License

Copyright (c) 2022, JC Arbelbide
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.togcrowdsourcing;

import lombok.Data;

@Data
public class WorldData
{
    private final int world_number;
    private final String stream_order;
    private final int hits;

    public WorldData(int world_number, String stream_order, int hits) {
        this.world_number = world_number;
        this.stream_order = stream_order;
        this.hits = hits;
    }
}

/*

BSD 2-Clause License

Copyright (c) 2022, JC Arbelbide
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.togcrowdsourcing;

import javax.inject.Inject;

import com.togcrowdsourcing.ui.WorldHopper;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.DecorativeObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayManager;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.concurrent.CompletableFuture;

@Slf4j
public class StreamOrderDetector
{
    public static final int TOG_REGION = 12948;
    private static final int STREAM_SHORT_INTERVAL = 600;
    private static final int STREAM_LONG_INTERVAL = 6600;
    private static final double STREAM_INTERVAL_TOLERANCE = 0.2;
    public static final int NUMBER_OF_TEAR_STREAMS = 6;

    @Getter
    private boolean dataValid;

    private Instant lastSpawnInstant = Instant.now();

    @Getter
    @Inject
    private Client client;

    private ToGCrowdsourcingConfig config;

    private WorldHopper worldHopper;

    @Inject
    private ToGCrowdsourcingOverlay overlay;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private CrowdsourcingManager crowdsourcingManager;

    @Getter
    private ArrayList<TearStream> streamList = new ArrayList<>();

    @Inject
    private StreamOrderDetector()
    {

    }

    public void startUpStreamOrderDetector(ToGCrowdsourcingConfig config, WorldHopper worldHopper)
    {
        log.info("ToG Started");
        dataValid = false;
        this.config = config;
        this.worldHopper = worldHopper;
        overlayManager.add(overlay);
    }

    public void shutDownStreamOrderDetector()
    {
        log.info("ToG Started");
        overlayManager.remove(overlay);
        streamList.clear();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        switch (event.getGameState())
        {
            case LOADING:
            case LOGIN_SCREEN:
            case HOPPING:
        }
        dataValid = false;
        streamList.clear();
    }

    @Subscribe
    public void onDecorativeObjectSpawned(DecorativeObjectSpawned event)
    {
        if (dataValid) { return; }
        if (client.getGameState() != GameState.LOGGED_IN) { return; }
        if (client.getLocalPlayer().getWorldLocation().getRegionID() != TOG_REGION) return;

        // Keep track of the time between the last stream and the current stream. If above a certain threshold and data is not yet valid, then clear working list

        DecorativeObject object = event.getDecorativeObject();

        if (object.getId() == ObjectID.BLUE_TEARS || object.getId() == ObjectID.BLUE_TEARS_6665 ||
                object.getId() == ObjectID.GREEN_TEARS || object.getId() == ObjectID.GREEN_TEARS_6666)
        {
            Instant spawnInstant = Instant.now();
            long timeSinceLastSpawn = ChronoUnit.MILLIS.between(lastSpawnInstant, spawnInstant);
            TearStream tearStream = new TearStream(object, timeSinceLastSpawn, spawnInstant);
            lastSpawnInstant = spawnInstant;

//            System.out.println("Color: " + overlay.streamToString(tearStream) + " Time since last spawn: " + timeSinceLastSpawn);
            // Do not want to update unless it has been around 1 tick. Otherwise, it could be the client loading streams in at a random time and calling this function 6 times in quick succession.
            // If the above comment is true, then clear the list and return. It is potentially bad data.
            // TODO: Implement this function above. In addition, look into taking out lastInstant. See if we can just use the last element in the array.
            if (timeSinceLastSpawn < STREAM_SHORT_INTERVAL * (1 - STREAM_INTERVAL_TOLERANCE))
            {
                streamList.clear();
//                System.out.println("Stream Cleared from onDecorativeObjectSpawned");
                return;
            }

            streamList.add(tearStream);
//            System.out.println(streamListToStringForAPI(overlay.padWithNull(streamList)));
        }


    }

    @Subscribe
    private void onGameTick(GameTick event)
    {
        if (dataValid) { return; }
        verifyDataIsValid();
    }

    private void verifyDataIsValid()
    {
        // If stream list has 6 in a row with short delays, then we know its valid
        if (streamList.size() == 0) { return; }
        else if (streamList.size() > NUMBER_OF_TEAR_STREAMS)
        {
            streamList.clear();
        }
        else if (streamList.size() < NUMBER_OF_TEAR_STREAMS)
        {
            // TODO: May want to consider ignoring first index. Only time it would matter is if somehow the first index
            //  is less than a game tick since last spawn, which I think is unlikely if not impossible to occur. Could
            //  only occur during a hop. Even then, can it occur?
            // If it has been longer than STREAM_SHORT_INTERVAL ms, then clear the list.
            // However, we do not want to clear the list if its too short either. But the problem is, this function gets
            // called almost right after adding a stream.
            // We need two conditions:
            // 		1. Clear if the time between last stream is less than SHORT interval.
            // 		2. Clear if it has been longer than SHORT since the last time we added a stream.
            Instant currentInstant = Instant.now();
            Instant lastSpawnInstant = streamList.get(streamList.size() - 1).getSpawnInstant();
            long timeSinceLastSpawn = ChronoUnit.MILLIS.between(lastSpawnInstant, currentInstant);
            long timeBetweenSpawnForLatestTear = streamList.get(streamList.size() - 1).getTimeSinceLastSpawn();
//            System.out.println("5 or under streams");
            if (timeBetweenSpawnForLatestTear < STREAM_SHORT_INTERVAL * (1 - STREAM_INTERVAL_TOLERANCE) ||      // Self explanatory, if the time between spawns stored in the latest tear is less than the short interval, clear. Should never happen.
                    timeSinceLastSpawn > STREAM_SHORT_INTERVAL * (1 - STREAM_INTERVAL_TOLERANCE))               // If the time between now and the last spawn was greater than the short interval (600ms), clear the list. Streams need to spawn within 600ms of each other.
            {
                streamList.clear();
//                System.out.println("Stream Cleared from verifyDataValid. Since: " + timeSinceLastSpawn + " Between: " + timeBetweenSpawnForLatestTear);
            }
        }
        else if (streamList.size() == NUMBER_OF_TEAR_STREAMS)
        {
            // If it manages to store 6 streams with all of our checks, the data is always valid. Every hop, the stream
            // list is cleared, so no worries about getting a stream from a previous world. If it only reaches 5 because
            // we hopped in the middle of the streams changing, then the whole list will be cleared from the previous if
            // statement (and onGameStateChanged()).
//            System.out.println("Data IS valid!");
            dataValid = true;
            submitToAPI();
            return;
        }
    }

    public ArrayList<String> streamListToStringArray(ArrayList<TearStream> tearStreamArrayList)
    {
        ArrayList<String> streamListStringArray = new ArrayList<>();

        for (TearStream tearStream : tearStreamArrayList)
        {
            streamListStringArray.add(overlay.streamToString(tearStream));
        }

        return streamListStringArray;
    }

    private String streamListToStringForAPI(ArrayList<TearStream> tearStreamArrayList)
    {
        StringBuilder stringBuilder = new StringBuilder();

        for (TearStream tearStream : tearStreamArrayList)
        {
            stringBuilder.append(streamToStringForAPI(tearStream));
        }

        return stringBuilder.toString();
    }

    private String streamToStringForAPI(TearStream object)
    {
        DecorativeObject tearStreamObject = object.getTearStreamObject();
        if (tearStreamObject == null)
        {
            return "-";
        }
        if (	tearStreamObject.getId() == ObjectID.BLUE_TEARS ||
                tearStreamObject.getId() == ObjectID.BLUE_TEARS_6665)
        {
            return "b";
        }
        if (	tearStreamObject.getId() == ObjectID.GREEN_TEARS ||
                tearStreamObject.getId() == ObjectID.GREEN_TEARS_6666)
        {
            return "g";
        }
        else { return "Error"; }
    }

    private void submitToAPI()
    {
        int currentWorld = client.getWorld();
        String streamOrder = streamListToStringForAPI(streamList);
        WorldData worldData = new WorldData(currentWorld, streamOrder, 1);

        crowdsourcingManager.submitToAPI(worldData, worldHopper);
    }
}

/*

BSD 2-Clause License

Copyright (c) 2022, JC Arbelbide
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.togcrowdsourcing;

import lombok.Getter;
import net.runelite.api.DecorativeObject;
import net.runelite.api.ObjectID;
import net.runelite.client.util.ColorUtil;

import java.awt.Color;
import java.time.Instant;

public class TearStream
{
    private final Color BLUE_TEARS_COLOR = ColorUtil.colorWithAlpha(Color.CYAN, 100);
    private final Color GREEN_TEARS_COLOR = ColorUtil.colorWithAlpha(Color.GREEN, 100);

    @Getter
    private DecorativeObject tearStreamObject;

    @Getter
    private long timeSinceLastSpawn;

    @Getter
    private Color color;

    @Getter
    private Instant spawnInstant;

    TearStream(DecorativeObject tearStreamObject, long timeSinceLastChange, Instant spawnInstant)
    {
        this.tearStreamObject = tearStreamObject;
        this.timeSinceLastSpawn = timeSinceLastChange;
        this.spawnInstant = spawnInstant;
        this.color = determineColor(tearStreamObject);
    }

    private Color determineColor(DecorativeObject object) {
        if (object == null)
        {
            return Color.RED;
        }
        if (	object.getId() == ObjectID.BLUE_TEARS ||
                object.getId() == ObjectID.BLUE_TEARS_6665)
        {
            return BLUE_TEARS_COLOR;
        }
        if (	object.getId() == ObjectID.GREEN_TEARS ||
                object.getId() == ObjectID.GREEN_TEARS_6666)
        {
            return GREEN_TEARS_COLOR;
        }
        else { return Color.RED; }
    }
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.togcrowdsourcing;

import com.google.common.base.MoreObjects;
import com.google.common.base.Strings;
import lombok.Builder;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.util.Text;

import java.awt.*;

@Setter
@Builder
public class TripleLineComponent implements LayoutableRenderableEntity
{
	private String left;
	private String right;
	private String middle;

	@Builder.Default
	private Color leftColor = Color.WHITE;

	@Builder.Default
	private Color rightColor = Color.WHITE;

	@Builder.Default
	private Color middleColor = Color.WHITE;

	private Font leftFont;

	private Font rightFont;

	private Font middleFont;

	@Builder.Default
	private Point preferredLocation = new Point();

	@Builder.Default
	private Dimension preferredSize = new Dimension(ComponentConstants.STANDARD_WIDTH, 0);

	@Builder.Default
	@Getter
	private final Rectangle bounds = new Rectangle();

	@Override
	public Dimension render(Graphics2D graphics)
	{
		// Prevent NPEs
		final String left = MoreObjects.firstNonNull(this.left, "");
		final String right = MoreObjects.firstNonNull(this.right, "");
		final String middle = MoreObjects.firstNonNull(this.middle, "");

		final Font leftFont = MoreObjects.firstNonNull(this.leftFont, graphics.getFont());
		final Font rightFont = MoreObjects.firstNonNull(this.rightFont, graphics.getFont());
		final Font middleFont = MoreObjects.firstNonNull(this.middleFont, graphics.getFont());

		final FontMetrics lfm = graphics.getFontMetrics(leftFont);
		final FontMetrics rfm = graphics.getFontMetrics(rightFont);
		final FontMetrics mfm = graphics.getFontMetrics(middleFont);

		final int fmHeight = Math.max(lfm.getHeight(), Math.max(rfm.getHeight(), mfm.getHeight()));
		final int baseX = preferredLocation.x;
		final int baseY = preferredLocation.y + fmHeight;
		int x = baseX;
		int y = baseY;
		final int leftFullWidth = getLineWidth(left, lfm);
		final int rightFullWidth = getLineWidth(right, rfm);
		final int middleFullWidth = getLineWidth(middle, rfm);
		final TextComponent textComponent = new TextComponent();

		if (preferredSize.width < leftFullWidth + rightFullWidth + middleFullWidth)
		{
			int leftSmallWidth = preferredSize.width;
			int rightSmallWidth = 0;
			int middleSmallWidth = 0;

			if (!Strings.isNullOrEmpty(right))
			{
				rightSmallWidth = (preferredSize.width / 3);
				leftSmallWidth -= rightSmallWidth;
			}

			if (!Strings.isNullOrEmpty(middle))
			{
				middleSmallWidth = (preferredSize.width / 3);
				leftSmallWidth -= middleSmallWidth;
			}

			final String[] leftSplitLines = lineBreakText(left, leftSmallWidth, lfm);
			final String[] rightSplitLines = lineBreakText(right, rightSmallWidth, rfm);
			final String[] middleSplitLines = lineBreakText(middle, middleSmallWidth, mfm);

			int lineCount = Math.max(leftSplitLines.length, Math.max(rightSplitLines.length, middleSplitLines.length));

			for (int i = 0; i < lineCount; i++)
			{
				if (i < leftSplitLines.length)
				{
					final String leftText = leftSplitLines[i];
					textComponent.setPosition(new Point(x, y));
					textComponent.setText(leftText);
					textComponent.setColor(leftColor);
					textComponent.setFont(leftFont);
					textComponent.render(graphics);
				}

				if (i < rightSplitLines.length)
				{
					final String rightText = rightSplitLines[i];
					textComponent.setPosition(new Point(x + preferredSize.width - getLineWidth(rightText, rfm), y));
					textComponent.setText(rightText);
					textComponent.setColor(rightColor);
					textComponent.setFont(rightFont);
					textComponent.render(graphics);
				}

				if (i < middleSplitLines.length)
				{
					final String middleText = middleSplitLines[i];
					textComponent.setPosition(new Point(x + (preferredSize.width - getLineWidth(middleText, mfm) / 2), y));
					textComponent.setText(middleText);
					textComponent.setColor(middleColor);
					textComponent.setFont(middleFont);
					textComponent.render(graphics);
				}

				y += fmHeight;
			}

			final Dimension dimension = new Dimension(preferredSize.width, y - baseY);
			bounds.setLocation(preferredLocation);
			bounds.setSize(dimension);
			return dimension;
		}

		if (!left.isEmpty())
		{
			textComponent.setPosition(new Point(x, y));
			textComponent.setText(left);
			textComponent.setColor(leftColor);
			textComponent.setFont(leftFont);
			textComponent.render(graphics);
		}

		if (!right.isEmpty())
		{
			textComponent.setPosition(new Point(x + preferredSize.width - rightFullWidth, y));
			textComponent.setText(right);
			textComponent.setColor(rightColor);
			textComponent.setFont(rightFont);
			textComponent.render(graphics);
		}

		if (!middle.isEmpty())
		{
			textComponent.setPosition(new Point(x + (preferredSize.width - middleFullWidth) / 2, y));
			textComponent.setText(middle);
			textComponent.setColor(middleColor);
			textComponent.setFont(middleFont);
			textComponent.render(graphics);
		}

		y += fmHeight;

		final Dimension dimension = new Dimension(preferredSize.width, y - baseY);
		bounds.setLocation(preferredLocation);
		bounds.setSize(dimension);
		return dimension;
	}

	private static int getLineWidth(final String line, final FontMetrics metrics)
	{
		return metrics.stringWidth(Text.removeTags(line));
	}

	private static String[] lineBreakText(String text, int maxWidth, FontMetrics metrics)
	{
		final String[] words = text.split(" ");

		if (words.length == 0)
		{
			return new String[0];
		}

		final StringBuilder wrapped = new StringBuilder(words[0]);
		int spaceLeft = maxWidth - metrics.stringWidth(wrapped.toString());

		for (int i = 1; i < words.length; i++)
		{
			final String word = words[i];
			final int wordLen = metrics.stringWidth(word);
			final int spaceWidth = metrics.stringWidth(" ");

			if (wordLen + spaceWidth > spaceLeft)
			{
				wrapped.append("\n").append(word);
				spaceLeft = maxWidth - wordLen;
			}
			else
			{
				wrapped.append(" ").append(word);
				spaceLeft -= spaceWidth + wordLen;
			}
		}

		return wrapped.toString().split("\n");
	}
}


/*

BSD 2-Clause License

Copyright (c) 2022, JC Arbelbide
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.togcrowdsourcing;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("togcrowdsourcing")
public interface ToGCrowdsourcingConfig extends Config
{
	String GROUP = "togcrowdsourcing";

	@ConfigItem(
			keyName = "hidePVPWorlds",
			name = "Hide PVP Worlds",
			description = "Hide PVP worlds in the list of worlds. On by default. ",
			position = 1
	)
	default boolean hidePVPWorlds()
	{
		return true;
	}

	@ConfigItem(
			keyName = "hideHighRiskWorlds",
			name = "Hide High Risk Worlds",
			description = "Hide High Risk worlds in the list of worlds. Off by default. ",
			position = 2
	)
	default boolean hideHighRiskWorlds()
	{
		return false;
	}

	@ConfigItem(
			keyName = "onlyShowOptimalWorlds",
			name = "Only Show Optimal Worlds",
			description = "Only show worlds that have a 'gggbbb' or 'bbbggg' pattern. Off by default. ",
			position = 3
	)
	default boolean onlyShowOptimalWorlds()
	{
		return false;
	}

	@ConfigItem(
			keyName = "showSidebar",
			name = "Show world switcher sidebar",
			description = "Show sidebar containing all worlds that mimics in-game interface",
			position = 4
	)
	default boolean showSidebar()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showOverlay",
			name = "Show stream order overlay",
			description = "Show the overlay that shows the tear stream data being collected.",
			position = 5
	)
	default boolean showOverlay()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showMessage",
			name = "Show world hop message in chat",
			description = "Shows what world is being hopped to in the chat",
			position = 6
	)
	default boolean showWorldHopMessage()
	{
		return true;
	}
}

/*
 * Copyright (c) 2018, Psikoi <https://github.com/Psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.togcrowdsourcing.ui;

import com.togcrowdsourcing.WorldData;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldRegion;
import net.runelite.http.api.worlds.WorldType;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.Consumer;
import net.runelite.client.plugins.worldhopper.WorldHopperPlugin;

class WorldTableRow extends JPanel
{
	private static final ImageIcon FLAG_AUS;
	private static final ImageIcon FLAG_UK;
	private static final ImageIcon FLAG_US;
	private static final ImageIcon FLAG_US_EAST;
	private static final ImageIcon FLAG_US_WEST;
	private static final ImageIcon FLAG_GER;

	private static final int WORLD_COLUMN_WIDTH = WorldSwitcherPanel.getWORLD_COLUMN_WIDTH();
	private static final int HITS_COLUMN_WIDTH = WorldSwitcherPanel.getHITS_COLUMN_WIDTH();

	private static final Color CURRENT_WORLD = new Color(66, 227, 17);
	private static final Color DANGEROUS_WORLD = new Color(251, 62, 62);
	private static final Color TOURNAMENT_WORLD = new Color(79, 145, 255);
	private static final Color MEMBERS_WORLD = new Color(210, 193, 53);
	private static final Color FREE_WORLD = new Color(200, 200, 200);
	private static final Color SEASONAL_WORLD = new Color(133, 177, 178);
	private static final Color GGGBBB_WORLD = new Color(36, 195, 250);
	private static final Color BBBGGG_WORLD = new Color(128, 217, 255);
//	private static final Color BBBGGG_WORLD = new Color(187, 113, 255);

	static
	{
		FLAG_AUS = new ImageIcon(ImageUtil.loadImageResource(WorldHopperPlugin.class, "flag_aus.png"));
		FLAG_UK = new ImageIcon(ImageUtil.loadImageResource(WorldHopperPlugin.class, "flag_uk.png"));
		FLAG_US = new ImageIcon(ImageUtil.loadImageResource(WorldHopperPlugin.class, "flag_us.png"));
		FLAG_US_EAST = new ImageIcon(ImageUtil.loadImageResource(WorldHopperPlugin.class, "flag_us_east.png"));
		FLAG_US_WEST = new ImageIcon(ImageUtil.loadImageResource(WorldHopperPlugin.class, "flag_us_west.png"));
		FLAG_GER = new ImageIcon(ImageUtil.loadImageResource(WorldHopperPlugin.class, "flag_ger.png"));
	}

	private static final int LOCATION_US_WEST = -73;
	private static final int LOCATION_US_EAST = -42;

	private JLabel worldField;
	private JLabel hitsField;
	private JLabel streamOrderField;
	private final int worldLocation; // from enum WORLD_LOCATIONS

	@Getter
	private final World world;

	@Getter
	private final WorldData worldData;

	@Getter(AccessLevel.PACKAGE)
	private int updatedHitsCount;

	private Color lastBackground;

	WorldTableRow(World world, WorldData worldData, boolean current, Consumer<World> onSelect, int worldLocation)
	{
		this.world = world;
		this.worldData = worldData;
		this.updatedHitsCount = worldData.getHits();
		this.worldLocation = worldLocation;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(2, 0, 2, 0));

		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					if (onSelect != null)
					{
						onSelect.accept(world);
					}
				}
			}

			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					setBackground(getBackground().brighter());
				}
			}

			@Override
			public void mouseReleased(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					setBackground(getBackground().darker());
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				WorldTableRow.this.lastBackground = getBackground();
				setBackground(getBackground().brighter());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				setBackground(lastBackground);
			}
		});

		final JPopupMenu popupMenu = new JPopupMenu();
		popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));

		setComponentPopupMenu(popupMenu);

		JPanel leftSide = new JPanel(new BorderLayout());
		JPanel rightSide = new JPanel(new BorderLayout());
		leftSide.setOpaque(false);
		rightSide.setOpaque(false);

		JPanel worldField = buildWorldField();
		worldField.setPreferredSize(new Dimension(WORLD_COLUMN_WIDTH, 0));
		worldField.setOpaque(false);

		JPanel hitsField = buildHitsField();
		hitsField.setPreferredSize(new Dimension(HITS_COLUMN_WIDTH, 0));
		hitsField.setOpaque(false);

		JPanel activityField = buildStreamOrderField();
		activityField.setBorder(new EmptyBorder(5, 5, 5, 5));
		activityField.setOpaque(false);

		recolour(current);

		leftSide.add(worldField, BorderLayout.WEST);
		leftSide.add(hitsField, BorderLayout.CENTER);
		rightSide.add(activityField, BorderLayout.CENTER);

		add(leftSide, BorderLayout.WEST);
		add(rightSide, BorderLayout.CENTER);
	}

	private static String hitsCountString(int hitsCount)
	{
		return hitsCount < 0 ? "OFF" : Integer.toString(hitsCount);
	}

	public void recolour(boolean current)
	{
		hitsField.setForeground(current ? CURRENT_WORLD : Color.WHITE);

		if (current)
		{
			streamOrderField.setForeground(CURRENT_WORLD);
			worldField.setForeground(CURRENT_WORLD);
			return;
		}
		else if (world.getTypes().contains(WorldType.PVP)
			|| world.getTypes().contains(WorldType.HIGH_RISK)
			|| world.getTypes().contains(WorldType.DEADMAN))
		{
			streamOrderField.setForeground(DANGEROUS_WORLD);
		}
		else if (world.getTypes().contains(WorldType.SEASONAL))
		{
			streamOrderField.setForeground(SEASONAL_WORLD);
		}
		else if (world.getTypes().contains(WorldType.NOSAVE_MODE))
		{
			streamOrderField.setForeground(TOURNAMENT_WORLD);
		}
		else if (worldData.getStream_order().equals("gggbbb"))
		{
			streamOrderField.setForeground(GGGBBB_WORLD);
		}
		else if (worldData.getStream_order().equals("bbbggg"))
		{
			streamOrderField.setForeground(BBBGGG_WORLD);
		}
		else
		{
			streamOrderField.setForeground(Color.WHITE);
		}

		worldField.setForeground(world.getTypes().contains(WorldType.MEMBERS) ? MEMBERS_WORLD : FREE_WORLD);
	}

	/**
	 * Builds the hits list field (containing the amount of hits logged in that world).
	 */
	private JPanel buildHitsField()
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 5, 0, 5));

		hitsField = new JLabel(hitsCountString(worldData.getHits()));
		hitsField.setFont(FontManager.getRunescapeSmallFont());

		column.add(hitsField, BorderLayout.WEST);

		return column;
	}

	/**
	 * Builds the activity list field (containing that world's activity/theme).
	 */
	private JPanel buildStreamOrderField()
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 5, 0, 5));

		String streamOrder = worldData.getStream_order();
		streamOrderField = new JLabel(streamOrder);
		streamOrderField.setFont(FontManager.getRunescapeSmallFont());
		if (streamOrder != null && streamOrder.length() > 16)
		{
			streamOrderField.setToolTipText(streamOrder);
			// Pass up events - https://stackoverflow.com/a/14932443
			streamOrderField.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mouseClicked(MouseEvent e)
				{
					dispatchEvent(e);
				}

				@Override
				public void mousePressed(MouseEvent e)
				{
					dispatchEvent(e);
				}

				@Override
				public void mouseReleased(MouseEvent e)
				{
					dispatchEvent(e);
				}

				@Override
				public void mouseEntered(MouseEvent e)
				{
					dispatchEvent(e);
				}

				@Override
				public void mouseExited(MouseEvent e)
				{
					dispatchEvent(e);
				}
			});
		}

		column.add(streamOrderField, BorderLayout.WEST);

		return column;
	}

	/**
	 * Builds the world list field (containing the country's flag and the world index).
	 */
	private JPanel buildWorldField()
	{
		JPanel column = new JPanel(new BorderLayout(7, 0));
		column.setBorder(new EmptyBorder(0, 5, 0, 5));

		worldField = new JLabel(world.getId() + "");

		ImageIcon flagIcon = getFlag(world.getRegion(), worldLocation);
		if (flagIcon != null)
		{
			JLabel flag = new JLabel(flagIcon);
			column.add(flag, BorderLayout.WEST);
		}
		column.add(worldField, BorderLayout.CENTER);

		return column;
	}

	private static ImageIcon getFlag(WorldRegion region, int worldLocation)
	{
		if (region == null)
		{
			return null;
		}

		switch (region)
		{
			case UNITED_STATES_OF_AMERICA:
				switch (worldLocation)
				{
					case LOCATION_US_WEST:
						return FLAG_US_WEST;
					case LOCATION_US_EAST:
						return FLAG_US_EAST;
					default:
						return FLAG_US;
				}
			case UNITED_KINGDOM:
				return FLAG_UK;
			case AUSTRALIA:
				return FLAG_AUS;
			case GERMANY:
				return FLAG_GER;
			default:
				return null;
		}
	}
}

/*
 * Copyright (c) 2018, Psikoi <https://github.com/Psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.togcrowdsourcing.ui;

import net.runelite.client.plugins.worldhopper.WorldHopperPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.annotation.Nonnull;
import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.image.BufferedImage;

class WorldTableHeader extends JPanel
{
	private static final ImageIcon ARROW_UP;
	private static final ImageIcon HIGHLIGHT_ARROW_DOWN;
	private static final ImageIcon HIGHLIGHT_ARROW_UP;

	private static final Color ARROW_COLOR = ColorScheme.LIGHT_GRAY_COLOR;
	private static final Color HIGHLIGHT_COLOR = ColorScheme.BRAND_ORANGE;

	static
	{
		final BufferedImage arrowDown = ImageUtil.loadImageResource(WorldHopperPlugin.class, "arrow_down.png");
		final BufferedImage arrowUp = ImageUtil.rotateImage(arrowDown, Math.PI);
		final BufferedImage arrowUpFaded = ImageUtil.luminanceOffset(arrowUp, -80);
		ARROW_UP = new ImageIcon(arrowUpFaded);

		final BufferedImage highlightArrowDown = ImageUtil.fillImage(arrowDown, HIGHLIGHT_COLOR);
		final BufferedImage highlightArrowUp = ImageUtil.fillImage(arrowUp, HIGHLIGHT_COLOR);
		HIGHLIGHT_ARROW_DOWN = new ImageIcon(highlightArrowDown);
		HIGHLIGHT_ARROW_UP = new ImageIcon(highlightArrowUp);
	}

	private final JLabel textLabel = new JLabel();
	private final JLabel arrowLabel = new JLabel();
	// Determines if this header column is being used to order the list
	private boolean ordering = false;

	WorldTableHeader(String title, boolean ordered, boolean ascending, @Nonnull Runnable onRefresh)
	{
		setLayout(new BorderLayout(5, 0));
		setBorder(new CompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 0, 1, ColorScheme.MEDIUM_GRAY_COLOR),
			new EmptyBorder(0, 5, 0, 2)));
		setBackground(ColorScheme.SCROLL_TRACK_COLOR);

		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				textLabel.setForeground(HIGHLIGHT_COLOR);
				if (!ordering)
				{
					arrowLabel.setIcon(HIGHLIGHT_ARROW_UP);
				}
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				if (!ordering)
				{
					textLabel.setForeground(ARROW_COLOR);
					arrowLabel.setIcon(ARROW_UP);
				}
			}
		});

		textLabel.setText(title);
		textLabel.setFont(FontManager.getRunescapeSmallFont());

		final JMenuItem refresh = new JMenuItem("Refresh worlds");
		refresh.addActionListener( e -> onRefresh.run() );

		final JPopupMenu popupMenu = new JPopupMenu();
		popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
		popupMenu.add(refresh);

		textLabel.setComponentPopupMenu(popupMenu);
		setComponentPopupMenu(popupMenu);

		highlight(ordered, ascending);

		add(textLabel, BorderLayout.WEST);
		add(arrowLabel, BorderLayout.EAST);
	}

	/**
	 * The labels inherit the parent's mouse listeners.
	 */
	@Override
	public void addMouseListener(MouseListener mouseListener)
	{
		super.addMouseListener(mouseListener);
		textLabel.addMouseListener(mouseListener);
		arrowLabel.addMouseListener(mouseListener);
	}

	/**
	 * If this column header is being used to order, then it should be
	 * highlighted, changing its font color and icon.
	 */
	public void highlight(boolean on, boolean ascending)
	{
		ordering = on;
		arrowLabel.setIcon(on ? (ascending ? HIGHLIGHT_ARROW_DOWN : HIGHLIGHT_ARROW_UP) : ARROW_UP);
		textLabel.setForeground(on ? HIGHLIGHT_COLOR : ARROW_COLOR);
	}

}

/*
 * Copyright (c) 2018, Psikoi <https://github.com/Psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.togcrowdsourcing.ui;

import com.google.common.collect.Ordering;
import com.togcrowdsourcing.ToGCrowdsourcingConfig;
import com.togcrowdsourcing.WorldData;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.PluginPanel;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldResult;
import net.runelite.http.api.worlds.WorldType;
import net.runelite.api.EnumComposition;

import javax.swing.JPanel;
import javax.swing.JLabel;
import javax.swing.SwingUtilities;
import javax.annotation.Nullable;
import java.awt.Color;
import java.awt.GridLayout;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

class WorldSwitcherPanel extends PluginPanel
{
	private static final Color ODD_ROW = new Color(44, 44, 44);

	@Getter
	private static final int WORLD_COLUMN_WIDTH = 60;

	@Getter
	private static final int HITS_COLUMN_WIDTH = 50;

	private final JPanel listContainer = new JPanel();

	private WorldTableHeader worldHeader;
	private WorldTableHeader hitsHeader;
	private WorldTableHeader activityHeader;

	private WorldOrder orderIndex = WorldOrder.STREAM_ORDER;
	private boolean ascendingOrder = false;

	private final ArrayList<WorldTableRow> rows = new ArrayList<>();
	private final WorldHopper worldHopper;

	WorldSwitcherPanel(WorldHopper worldHopper)
	{
		this.worldHopper = worldHopper;

		setBorder(null);
		setLayout(new DynamicGridLayout(0, 1));

		JPanel headerContainer = buildHeader();

		listContainer.setLayout(new GridLayout(0, 1));

		add(headerContainer);
		add(listContainer);
	}

	void switchCurrentHighlight(int newWorld, int lastWorld)
	{
		for (WorldTableRow row : rows)
		{
			if (row.getWorld().getId() == newWorld)
			{
				row.recolour(true);
			}
			else if (row.getWorld().getId() == lastWorld)
			{
				row.recolour(false);
			}
		}
	}

	void updateList()
	{
		rows.sort((r1, r2) ->
		{
			switch (orderIndex)
			{
				case WORLD:
					return getCompareValue(r1, r2, row -> row.getWorld().getId());
				case HITS:
					return getCompareValue(r1, r2, WorldTableRow::getUpdatedHitsCount);
				case STREAM_ORDER:
					return getCompareValueStreamOrder(r1, r2);
				default:
					return 0;
			}
		});

		listContainer.removeAll();

		for (int i = 0; i < rows.size(); i++)
		{
			WorldTableRow row = rows.get(i);
			row.setBackground(i % 2 == 0 ? ODD_ROW : ColorScheme.DARK_GRAY_COLOR);
			listContainer.add(row);
		}

		listContainer.revalidate();
		listContainer.repaint();
	}

	private int getCompareValueStreamOrder(WorldTableRow r1, WorldTableRow r2) {
		int order = !ascendingOrder ? 1 : -1;
		if (r1.getWorldData().getStream_order().equals("gggbbb"))
		{
			if (r2.getWorldData().getStream_order().equals("gggbbb"))
			{
				return getCompareHits(r1, r2) * order;
			}
			else
			{
				return -1 * order;
			}
		}
		if (r1.getWorldData().getStream_order().equals("bbbggg"))
		{
			if (r2.getWorldData().getStream_order().equals("gggbbb"))
			{
				return 1 * order;
			}
			else if (r2.getWorldData().getStream_order().equals("bbbggg"))
			{
				return getCompareHits(r1, r2) * order;
			}
			else
			{
				return -1 * order;
			}
		}
		if (r2.getWorldData().getStream_order().equals("gggbbb"))
		{
			if (r1.getWorldData().getStream_order().equals("gggbbb"))
			{
				return getCompareHits(r1, r2) * order;
			}
			else
			{
				return 1 * order;
			}
		}
		if (r2.getWorldData().getStream_order().equals("bbbggg"))
		{
			if (r1.getWorldData().getStream_order().equals("gggbbb"))
			{
				return -1 * order;
			}
			else if (r1.getWorldData().getStream_order().equals("bbbggg"))
			{
				return getCompareHits(r1, r2) * order;
			}
			else
			{
				return 1 * order;
			}
		}
		return r1.getWorldData().getWorld_number() - r2.getWorldData().getWorld_number();
	}

	private int getCompareHits(WorldTableRow r1, WorldTableRow r2)
	{
		int c = r2.getWorldData().getHits() - r1.getWorldData().getHits();

		if (c == 0)
		{
			return r1.getWorldData().getWorld_number() - r2.getWorldData().getWorld_number();
		}
		else
		{
			return c;
		}
	}

	private int getCompareValue(WorldTableRow row1, WorldTableRow row2, Function<WorldTableRow, Comparable> compareByFn)
	{
		Ordering<Comparable> ordering = Ordering.natural();
		if (!ascendingOrder)
		{
			ordering = ordering.reverse();
		}
		ordering = ordering.nullsLast();
		return ordering.compare(compareByFn.apply(row1), compareByFn.apply(row2));
	}

	void addNoDataMessage()
	{
		final GridBagConstraints c = new GridBagConstraints();
		final String[] messages = new String[]
		{
			" ",
			"    Worlds have reset!",
			" ",
			"    Please help to gather data",
			"    by hopping worlds :)",
		};

		for (String message : messages)
		{
			listContainer.add(new JLabel(message), c);
		}
	}

	void addGetErrorMessage()
	{
		final GridBagConstraints c = new GridBagConstraints();
		final String[] messages = new String[]
				{
						" ",
						"    Error getting world data",
						" ",
						"    Server may be down,",
						"    Please try again later.",
						"    Really sorry for the inconvenience :(",
						" ",
						" ",
						" ",
						"    If this continues, please consider",
						"    posting an issue on the github repo",
						"    and I will try to resolve this asap:",
						" ",
						"    https://github.com/jcarbelbide",
						"    /tog-crowdsourcing-server/issues",
				};

		for (String message : messages)
		{
			listContainer.add(new JLabel(message), c);
		}
	}

	void populate(List<WorldData> worldDataList, ToGCrowdsourcingConfig config, @Nullable EnumComposition worldLocations)
	{
		rows.clear();

		if (worldHopper.isGetError())
		{
			listContainer.removeAll();
			addGetErrorMessage();
			return;
		}

		if (worldDataList.size() == 0)
		{
			listContainer.removeAll();
			addNoDataMessage();
			return;
		}

		WorldResult worldResult = worldHopper.getWorldService().getWorlds();
		if (worldResult == null) { return; }

		for (int i = 0; i < worldDataList.size(); i++)
		{
			WorldData worldData = worldDataList.get(i);
			World world = worldResult.findWorld(worldData.getWorld_number());
			if (shouldWorldBeSkipped(world, worldData, config)) { continue; }

			boolean isCurrentWorld = worldData.getWorld_number() == worldHopper.getCurrentWorld() && worldHopper.getLastWorld() != 0;

			rows.add(buildRow(
					worldData,
					i % 2 == 0,
					isCurrentWorld,
					worldLocations != null ? worldLocations.getIntValue(world.getId()) : -1)
			);
		}
		updateList();
	}

	private boolean shouldWorldBeSkipped(World world, WorldData worldData, ToGCrowdsourcingConfig config) {
		if (world == null) { return true; }
		if (world.getTypes().contains(WorldType.PVP) && config.hidePVPWorlds()) { return true; }		// Hide PVP Worlds if config item set.
		if (world.getTypes().contains(WorldType.HIGH_RISK) && config.hideHighRiskWorlds()) { return true; }
		if (!world.getTypes().contains(WorldType.MEMBERS)) { return true; }
		if (world.getTypes().contains(WorldType.NOSAVE_MODE)) { return true; }
		if (world.getTypes().contains(WorldType.DEADMAN)) { return true; }
		if (world.getTypes().contains(WorldType.TOURNAMENT)) { return true; }
		if (world.getTypes().contains(WorldType.SEASONAL)) { return true; }

		if (config.onlyShowOptimalWorlds() && !(worldData.getStream_order().equals("gggbbb") || worldData.getStream_order().equals("bbbggg"))) { return true; }

		return false;
	}

	private void orderBy(WorldOrder order)
	{
		worldHeader.highlight(false, ascendingOrder);
		hitsHeader.highlight(false, ascendingOrder);
		activityHeader.highlight(false, ascendingOrder);

		switch (order)
		{
			case WORLD:
				worldHeader.highlight(true, ascendingOrder);
				break;
			case HITS:
				hitsHeader.highlight(true, ascendingOrder);
				break;
			case STREAM_ORDER:
				activityHeader.highlight(true, ascendingOrder);
				break;
		}

		orderIndex = order;
		updateList();
	}

	/**
	 * Builds the entire table header.
	 */
	private JPanel buildHeader()
	{
		JPanel header = new JPanel(new BorderLayout());
		JPanel leftSide = new JPanel(new BorderLayout());
		JPanel rightSide = new JPanel(new BorderLayout());

		worldHeader = new WorldTableHeader("World", orderIndex == WorldOrder.WORLD, ascendingOrder, worldHopper::refresh);
		worldHeader.setPreferredSize(new Dimension(WORLD_COLUMN_WIDTH, 0));
		worldHeader.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isRightMouseButton(mouseEvent))
				{
					return;
				}
				ascendingOrder = orderIndex != WorldOrder.WORLD || !ascendingOrder;
				orderBy(WorldOrder.WORLD);
			}
		});

		hitsHeader = new WorldTableHeader("Hits", orderIndex == WorldOrder.HITS, ascendingOrder, worldHopper::refresh);
		hitsHeader.setPreferredSize(new Dimension(HITS_COLUMN_WIDTH, 0));
		hitsHeader.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isRightMouseButton(mouseEvent))
				{
					return;
				}
				ascendingOrder = orderIndex != WorldOrder.HITS || !ascendingOrder;
				orderBy(WorldOrder.HITS);
			}
		});

		activityHeader = new WorldTableHeader("Stream Order", orderIndex == WorldOrder.STREAM_ORDER, ascendingOrder, worldHopper::refresh);
		activityHeader.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isRightMouseButton(mouseEvent))
				{
					return;
				}
				ascendingOrder = orderIndex != WorldOrder.STREAM_ORDER || !ascendingOrder;
				orderBy(WorldOrder.STREAM_ORDER);
			}
		});

		leftSide.add(worldHeader, BorderLayout.WEST);
		leftSide.add(hitsHeader, BorderLayout.CENTER);

		rightSide.add(activityHeader, BorderLayout.CENTER);

		header.add(leftSide, BorderLayout.WEST);
		header.add(rightSide, BorderLayout.CENTER);

		return header;
	}

	/**
	 * Builds a table row, that displays the world's information.
	 */
	private WorldTableRow buildRow(WorldData worldData, boolean stripe, boolean current, int worldLocation)
	{
		World world = worldHopper.getWorldService().getWorlds().findWorld(worldData.getWorld_number());
		WorldTableRow row = new WorldTableRow(
				world, worldData, current,
			worldHopper::hopTo,
			worldLocation
		);
		row.setBackground(stripe ? ODD_ROW : ColorScheme.DARK_GRAY_COLOR);
		return row;
	}

	/**
	 * Enumerates the multiple ordering options for the world list.
	 */
	private enum WorldOrder
	{
		WORLD,
		HITS,
		STREAM_ORDER
	}
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Lotto <https://github.com/devLotto>
 * Copyright (c) 2019, gregg1494 <https://github.com/gregg1494>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.togcrowdsourcing.ui;

import com.togcrowdsourcing.CrowdsourcingManager;
import com.togcrowdsourcing.ToGCrowdsourcingConfig;
import com.togcrowdsourcing.ToGCrowdsourcingPlugin;
import com.togcrowdsourcing.WorldData;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.WorldsFetch;
import net.runelite.client.game.WorldService;
import net.runelite.client.input.KeyManager;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.*;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldResult;
import net.runelite.api.EnumID;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;

@Slf4j
public class WorldHopper
{
	private static final int REFRESH_THROTTLE = 60_000; // ms
	private static final int MAX_PLAYER_COUNT = 1950;

	private static final int DISPLAY_SWITCHER_MAX_ATTEMPTS = 3;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private KeyManager keyManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	private ToGCrowdsourcingConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Getter
	@Inject
	private WorldService worldService;

	@Getter
	@Inject
	private CrowdsourcingManager crowdsourcingManager;

	private ScheduledExecutorService hopperExecutorService;

	private NavigationButton navButton;
	private WorldSwitcherPanel panel;

	private net.runelite.api.World quickHopTargetWorld;
	private int displaySwitcherAttempts = 0;

	@Getter
	private int lastWorld;

	private int currentWorld;
	private Instant lastFetch;

	@Getter
	@Setter
	private boolean getError;

	@Getter
	@Setter
	private ArrayList<WorldData> worldData = new ArrayList<>();

	@Inject
	private WorldHopper()
	{

	}

	public void startUpWorldHopper(ToGCrowdsourcingConfig config)
	{
		panel = new WorldSwitcherPanel(this);
		this.config = config;

		final BufferedImage icon = ImageUtil.loadImageResource(ToGCrowdsourcingPlugin.class, "/tog-icon.png");
		navButton = NavigationButton.builder()
			.tooltip("ToG Crowdsourcing")
			.icon(icon)
			.priority(10)
			.panel(panel)
			.build();

		if (config.showSidebar())
		{
			clientToolbar.addNavigation(navButton);
		}

		// populate initial world list
		updateList();

		crowdsourcingManager.makeGetRequest(this);
	}

	public void shutDownWorldHopper()
	{
		clientToolbar.removeNavigation(navButton);

	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged event)
	{
		if (event.getGroup().equals(ToGCrowdsourcingConfig.GROUP))
		{
			switch (event.getKey())
			{
				case "showSidebar":
					if (config.showSidebar())
					{
						clientToolbar.addNavigation(navButton);
					}
					else
					{
						clientToolbar.removeNavigation(navButton);
					}
					break;
			}
			if (event.getKey().equals("showOverlay")) { return; }
			else { updateList(); }
		}
	}

	int getCurrentWorld()
	{
		return client.getWorld();
	}

	void hopTo(World world)
	{
		clientThread.invoke(() -> hop(world.getId()));
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		// If the player has disabled the side bar plugin panel, do not update the UI
		if (config.showSidebar() && gameStateChanged.getGameState() == GameState.LOGGED_IN)
		{
			if (lastWorld != client.getWorld())
			{
				int newWorld = client.getWorld();
				panel.switchCurrentHighlight(newWorld, lastWorld);
				lastWorld = newWorld;
			}
		}
	}

	// This is the right click refresh menu item
	void refresh()
	{
		Instant now = Instant.now();
		if (lastFetch != null && now.toEpochMilli() - lastFetch.toEpochMilli() < REFRESH_THROTTLE)
		{
			log.debug("Throttling world refresh");
			return;
		}

		lastFetch = now;
		worldService.refresh();
	}

	@Subscribe
	public void onWorldsFetch(WorldsFetch worldsFetch)
	{
//		System.out.println("onWorldFetch");
		synchronized (this)
		{
			crowdsourcingManager.makeGetRequest(this);
			updateList();
		}
	}

	/**
	 * This method ONLY updates the list's UI, not the actual world list and data it displays.
	 */
	public void updateList()
	{
//		SwingUtilities.invokeLater(() -> panel.populate(worldData, config));
		clientThread.invokeLater(() ->
		{
			EnumComposition locationEnum = client.getGameState().getState() >= GameState.LOGIN_SCREEN.getState() ? client.getEnum(EnumID.WORLD_LOCATIONS) : null;
			SwingUtilities.invokeLater(() -> panel.populate(worldData, config, locationEnum));
		});
	}

	private void hop(int worldId)
	{
		assert client.isClientThread();

		WorldResult worldResult = worldService.getWorlds();
		// Don't try to hop if the world doesn't exist
		World world = worldResult.findWorld(worldId);
		if (world == null)
		{
			return;
		}

		final net.runelite.api.World rsWorld = client.createWorld();
		rsWorld.setActivity(world.getActivity());
		rsWorld.setAddress(world.getAddress());
		rsWorld.setId(world.getId());
		rsWorld.setPlayerCount(world.getPlayers());
		rsWorld.setLocation(world.getLocation());
		rsWorld.setTypes(WorldUtil.toWorldTypes(world.getTypes()));

		if (client.getGameState() == GameState.LOGIN_SCREEN)
		{
			// on the login screen we can just change the world by ourselves
			client.changeWorld(rsWorld);
			return;
		}

		if (config.showWorldHopMessage())
		{
			String chatMessage = new ChatMessageBuilder()
				.append(ChatColorType.NORMAL)
				.append("Quick-hopping to World ")
				.append(ChatColorType.HIGHLIGHT)
				.append(Integer.toString(world.getId()))
				.append(ChatColorType.NORMAL)
				.append("..")
				.build();

			chatMessageManager
				.queue(QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage(chatMessage)
					.build());
		}

		quickHopTargetWorld = rsWorld;
		displaySwitcherAttempts = 0;
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (quickHopTargetWorld == null)
		{
			return;
		}

		if (client.getWidget(ComponentID.WORLD_SWITCHER_WORLD_LIST) == null)
		{
			client.openWorldHopper();

			if (++displaySwitcherAttempts >= DISPLAY_SWITCHER_MAX_ATTEMPTS)
			{
				String chatMessage = new ChatMessageBuilder()
					.append(ChatColorType.NORMAL)
					.append("Failed to quick-hop after ")
					.append(ChatColorType.HIGHLIGHT)
					.append(Integer.toString(displaySwitcherAttempts))
					.append(ChatColorType.NORMAL)
					.append(" attempts.")
					.build();

				chatMessageManager
					.queue(QueuedMessage.builder()
						.type(ChatMessageType.CONSOLE)
						.runeLiteFormattedMessage(chatMessage)
						.build());

				resetQuickHopper();
			}
		}
		else
		{
			client.hopToWorld(quickHopTargetWorld);
			resetQuickHopper();
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		if (event.getMessage().equals("Please finish what you're doing before using the World Switcher."))
		{
			resetQuickHopper();
		}
	}

	private void resetQuickHopper()
	{
		displaySwitcherAttempts = 0;
		quickHopTargetWorld = null;
	}

}

