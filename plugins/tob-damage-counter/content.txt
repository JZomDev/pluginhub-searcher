/*
 * Copyright (c) 2020, Trevor <https://github.com/Trevor159>, 2025 Aronson <https://github.com/aronson>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.pingas.tobdamage;

import com.google.common.collect.ImmutableSet;
import net.runelite.api.gameval.NpcID;
import java.util.HashMap;

class NormalTobRooms extends TobRooms {
    NormalTobRooms() {
        phaseMap = new HashMap<>();
        ImmutableSet<Integer> maiden = ImmutableSet.of(
                NpcID.TOB_MAIDEN_100,
                NpcID.TOB_MAIDEN_70,
                NpcID.TOB_MAIDEN_50,
                NpcID.TOB_MAIDEN_30,
                NpcID.TOB_MAIDEN_DYING_A,
                NpcID.TOB_MAIDEN_DYING_B,
                NpcID.MAIDEN_ELEMENTAL,
                NpcID.MAIDEN_BLOOD_SLUG
        );
        phaseMap.put(TobPhase.Maiden, maiden);
        ImmutableSet<Integer> bloat = ImmutableSet.of(
                NpcID.TOB_BLOAT
        );
        phaseMap.put(TobPhase.Bloat, bloat);
        ImmutableSet<Integer> waves = ImmutableSet.of(
                NpcID.TOB_NYLOCAS_INCOMING_MELEE,
                NpcID.TOB_NYLOCAS_INCOMING_MAGIC,
                NpcID.TOB_NYLOCAS_INCOMING_RANGED,
                NpcID.TOB_NYLOCAS_BIG_INCOMING_MELEE,
                NpcID.TOB_NYLOCAS_BIG_INCOMING_MAGIC,
                NpcID.TOB_NYLOCAS_BIG_INCOMING_RANGED,
                NpcID.TOB_NYLOCAS_FIGHTING_MELEE,
                NpcID.TOB_NYLOCAS_FIGHTING_MAGIC,
                NpcID.TOB_NYLOCAS_FIGHTING_RANGED,
                NpcID.TOB_NYLOCAS_BIG_FIGHTING_MELEE,
                NpcID.TOB_NYLOCAS_BIG_FIGHTING_MAGIC,
                NpcID.TOB_NYLOCAS_BIG_FIGHTING_RANGED
        );
        phaseMap.put(TobPhase.NylocasWaves, waves);
        ImmutableSet<Integer> nylocas = ImmutableSet.of(
                NpcID.NYLOCAS_BOSS_SPAWNING,
                NpcID.NYLOCAS_BOSS_MELEE,
                NpcID.NYLOCAS_BOSS_MAGIC,
                NpcID.NYLOCAS_BOSS_RANGED
        );
        phaseMap.put(TobPhase.NylocasBoss, nylocas);
        ImmutableSet<Integer> sotetseg = ImmutableSet.of(
                NpcID.TOB_SOTETSEG_NONCOMBAT,
                NpcID.TOB_SOTETSEG_COMBAT,
                NpcID.TOB_SOTETSEG_CREEPER
        );
        phaseMap.put(TobPhase.Sotetseg, sotetseg);
        ImmutableSet<Integer> xarpus = ImmutableSet.of(
                NpcID.TOB_XARPUS_COMBAT,
                NpcID.TOB_XARPUS_STATIC,
                NpcID.TOB_XARPUS_FEEDING,
                NpcID.XARPUS_DEATH
        );
        phaseMap.put(TobPhase.Xarpus, xarpus);
        ImmutableSet<Integer> verzikPhase1 = ImmutableSet.of(NpcID.VERZIK_PHASE1);
        phaseMap.put(TobPhase.VerzikPhase1, verzikPhase1);
        ImmutableSet<Integer> verzikPhase2 = ImmutableSet.of(
                NpcID.VERZIK_PHASE1_TO2_TRANSITION,
                NpcID.VERZIK_PHASE2,
                NpcID.VERZIK_NYLOCAS_MAGIC,
                NpcID.VERZIK_NYLOCAS_MELEE,
                NpcID.VERZIK_NYLOCAS_RANGED,
                NpcID.TOB_VERZIK_PHASE2_ARMOUREDNYLOCAS,
                NpcID.TOB_VERZIK_PHASE2_BLOODNYLOCAS
        );
        phaseMap.put(TobPhase.VerzikPhase2, verzikPhase2);
        ImmutableSet<Integer> verzikPhase3 = ImmutableSet.of(
                NpcID.VERZIK_PHASE2_TO3_TRANSITION,
                NpcID.VERZIK_PHASE3,
                NpcID.VERZIK_NYLOCAS_MAGIC,
                NpcID.VERZIK_NYLOCAS_MELEE,
                NpcID.VERZIK_NYLOCAS_RANGED,
                NpcID.VERZIK_WEB_NPC
        );
        phaseMap.put(TobPhase.VerzikPhase3, verzikPhase3);
    }
}

package org.pingas.tobdamage;

import com.google.common.collect.ImmutableSet;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.gameval.NpcID;

import java.util.Map;
import java.util.Set;

import java.util.stream.Stream;

abstract class TobMode {
    Set<Integer> maidenSpawns;
    Set<Integer> verzikIDs;

    @Getter
    TobPhase currentPhase;
    @Getter
    TobRooms rooms;

    ImmutableSet<Integer> getNpcIDs() {
        return rooms.phaseMap.get(currentPhase);
    }

    void onHitsplat(HitsplatApplied hitsplatApplied, NPC npc, Map<TobPhase, TobDamageCounterPlugin.Damage> damageMap, TobDamageCounterConfig config) {
        Hitsplat hitsplat = hitsplatApplied.getHitsplat();

        if (currentPhase == null) {
            return;
        }

        // Filter out other NPCs (not Maiden, Verzik) for MVP?
        if (config.showMVPDamage()) {
            // Guard clause for maiden spawns
            if (currentPhase == TobPhase.Maiden && maidenSpawns.contains(npc.getId())) {
                return;
            }

            // Guard clause for Verzik crabs/web/etc.
            if ((Stream.of(TobPhase.VerzikPhase1, TobPhase.VerzikPhase2, TobPhase.VerzikPhase3)
                    .anyMatch(tobPhase -> currentPhase == tobPhase))
                    && !verzikIDs.contains(npc.getId())) {
                return;
            }
        }

        // Damage done by player
        if (hitsplat.isMine()) {
            damageMap.get(currentPhase).addDamage(hitsplat.getAmount(), true);
            // Damage done by allies
        } else if (hitsplat.isOthers()) {
            damageMap.get(currentPhase).addDamage(hitsplat.getAmount(), false);
            // Healing done by party
        } else if (hitsplat.getHitsplatType() == HitsplatID.HEAL) {
            damageMap.get(currentPhase).addHealing(hitsplat.getAmount());
        }
    }
}

class HardTobMode extends TobMode {
    HardTobMode() {
        maidenSpawns = ImmutableSet.of(NpcID.MAIDEN_BLOOD_SLUG_HARD, NpcID.MAIDEN_ELEMENTAL_HARD);
        verzikIDs = ImmutableSet.of(NpcID.VERZIK_INITIAL_HARD, NpcID.VERZIK_PHASE2_HARD, NpcID.VERZIK_PHASE3_HARD);
        rooms = new HardTobRooms();
    }
}

class NormalTobMode extends TobMode {
    NormalTobMode() {
        maidenSpawns = ImmutableSet.of(NpcID.MAIDEN_ELEMENTAL_HARD);
        verzikIDs = ImmutableSet.of(NpcID.VERZIK_INITIAL, NpcID.VERZIK_PHASE2, NpcID.VERZIK_PHASE3);
        rooms = new NormalTobRooms();
    }
}

/*
 * Copyright (c) 2025, Aronson <https://github.com/aronson>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.pingas.tobdamage;

import com.google.common.collect.ImmutableSet;
import net.runelite.api.gameval.NpcID;
import java.util.HashMap;

class HardTobRooms extends TobRooms
{
    HardTobRooms() {
        phaseMap = new HashMap<>();
        ImmutableSet<Integer> maiden = ImmutableSet.of(
                NpcID.TOB_MAIDEN_100_HARD,
                NpcID.TOB_MAIDEN_70_HARD,
                NpcID.TOB_MAIDEN_50_HARD,
                NpcID.TOB_MAIDEN_30_HARD,
                NpcID.TOB_MAIDEN_DYING_A_HARD,
                NpcID.TOB_MAIDEN_DYING_B_HARD,
                NpcID.MAIDEN_ELEMENTAL_HARD,
                NpcID.MAIDEN_BLOOD_SLUG_HARD
        );
        phaseMap.put(TobPhase.Maiden, maiden);
        ImmutableSet<Integer> bloat = ImmutableSet.of(
                NpcID.TOB_BLOAT_HARD
        );
        phaseMap.put(TobPhase.Bloat, bloat);
        ImmutableSet<Integer> waves = ImmutableSet.of(
                NpcID.TOB_NYLOCAS_INCOMING_MELEE_HARD,
                NpcID.TOB_NYLOCAS_INCOMING_MAGIC_HARD,
                NpcID.TOB_NYLOCAS_INCOMING_RANGED_HARD,
                NpcID.TOB_NYLOCAS_BIG_INCOMING_MELEE_HARD,
                NpcID.TOB_NYLOCAS_BIG_INCOMING_MAGIC_HARD,
                NpcID.TOB_NYLOCAS_BIG_INCOMING_RANGED_HARD,
                NpcID.TOB_NYLOCAS_FIGHTING_MELEE_HARD,
                NpcID.TOB_NYLOCAS_FIGHTING_MAGIC_HARD,
                NpcID.TOB_NYLOCAS_FIGHTING_RANGED_HARD,
                NpcID.TOB_NYLOCAS_BIG_FIGHTING_MELEE_HARD,
                NpcID.TOB_NYLOCAS_BIG_FIGHTING_MAGIC_HARD,
                NpcID.TOB_NYLOCAS_BIG_FIGHTING_RANGED_HARD,
                NpcID.NYLOCAS_MINIBOSS_SPAWNING_HARD,
                NpcID.NYLOCAS_MINIBOSS_MELEE_HARD,
                NpcID.NYLOCAS_MINIBOSS_MAGIC_HARD,
                NpcID.NYLOCAS_MINIBOSS_RANGED_HARD
        );
        phaseMap.put(TobPhase.NylocasWaves, waves);
        ImmutableSet<Integer> nylocas = ImmutableSet.of(
                NpcID.NYLOCAS_BOSS_SPAWNING_HARD,
                NpcID.NYLOCAS_BOSS_MELEE_HARD,
                NpcID.NYLOCAS_BOSS_MAGIC_HARD,
                NpcID.NYLOCAS_BOSS_RANGED_HARD
        );
        phaseMap.put(TobPhase.NylocasBoss, nylocas);
        ImmutableSet<Integer> sotetseg = ImmutableSet.of(
                NpcID.TOB_SOTETSEG_COMBAT_HARD,
                NpcID.TOB_SOTETSEG_CREEPER_HARD,
                NpcID.TOB_SOTETSEG_NONCOMBAT_HARD
        );
        phaseMap.put(TobPhase.Sotetseg, sotetseg);
        ImmutableSet<Integer> xarpus = ImmutableSet.of(
                NpcID.TOB_XARPUS_COMBAT_HARD,
                NpcID.TOB_XARPUS_STATIC_HARD,
                NpcID.TOB_XARPUS_FEEDING_HARD,
                NpcID.XARPUS_DEATH_HARD
        );
        phaseMap.put(TobPhase.Xarpus, xarpus);
        ImmutableSet<Integer> verzikPhase1 = ImmutableSet.of(
                NpcID.VERZIK_PHASE1_HARD
        );
        phaseMap.put(TobPhase.VerzikPhase1, verzikPhase1);
        ImmutableSet<Integer> verzikPhase2 = ImmutableSet.of(
                NpcID.VERZIK_PHASE1_TO2_TRANSITION_HARD,
                NpcID.VERZIK_PHASE2_HARD,
                NpcID.VERZIK_NYLOCAS_MAGIC_HARD,
                NpcID.VERZIK_NYLOCAS_MELEE_HARD,
                NpcID.VERZIK_NYLOCAS_RANGED_HARD,
                NpcID.TOB_VERZIK_PHASE2_ARMOUREDNYLOCAS_HARD,
                NpcID.TOB_VERZIK_PHASE2_BLOODNYLOCAS_HARD
        );
        phaseMap.put(TobPhase.VerzikPhase2, verzikPhase2);
        ImmutableSet<Integer> verzikPhase3 = ImmutableSet.of(
                NpcID.VERZIK_PHASE2_TO3_TRANSITION_HARD,
                NpcID.VERZIK_PHASE3_HARD,
                NpcID.VERZIK_NYLOCAS_MAGIC_HARD,
                NpcID.VERZIK_NYLOCAS_MELEE_HARD,
                NpcID.VERZIK_NYLOCAS_RANGED_HARD,
                NpcID.VERZIK_WEB_NPC_HARD
        );
        phaseMap.put(TobPhase.VerzikPhase3, verzikPhase3);
    }
}

package org.pingas.tobdamage;

import com.google.common.collect.ImmutableSet;
import com.google.inject.Provides;
import lombok.Data;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.SpotanimID;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import java.text.DecimalFormat;
import java.util.*;


@Slf4j
@PluginDescriptor(name = "TOB Damage Counter", description = "Shows personal and total damage for each room in the theatre of blood", tags = {"counter", "tracker"})
public class TobDamageCounterPlugin extends Plugin {
    private static final Set<Integer> blacklistNPCs = ImmutableSet.of(NpcID.VERZIK_HARD_PILLAR_NPC, NpcID.VERZIK_PILLAR_NPC);
    private static final Set<Integer> SALVE_IDS = ImmutableSet.of(ItemID.SALVE_AMULET_E, ItemID.SALVE_AMULETEI, ItemID.SALVE_AMULET, ItemID.SALVE_AMULETI);
    private static final DecimalFormat DECIMAL_FORMAT = new DecimalFormat("###.##");
    private static final DecimalFormat DAMAGE_FORMAT = new DecimalFormat("#,###");

    private static final TobPhase[] phases = {
            TobPhase.Maiden,
            TobPhase.Bloat,
            TobPhase.NylocasWaves,
            TobPhase.NylocasBoss,
            TobPhase.Sotetseg,
            TobPhase.Xarpus,
            TobPhase.VerzikPhase1,
            TobPhase.VerzikPhase2,
            TobPhase.VerzikPhase3
    };
    private static final HardTobRooms hardRooms = new HardTobRooms();
    private static final NormalTobRooms normalRooms = new NormalTobRooms();

    // world point they put a player in while they check if he is in a raid
    private static final WorldPoint TEMP_LOCATION = new WorldPoint(3370, 5152, 2);

    private static final int TOB_VAR_STATE = 6440;
    private static final int LOCAL_TOB_ORB_VARB = 6441;
    @Getter
    private final Map<TobPhase, Damage> damageMap = new HashMap<>();
    @Getter
    private TobMode tobMode = null;
    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private ChatMessageManager chatMessageManager;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private TobDamageOverlay tobDamageOverlay;
    @Inject
    private TobDamageCounterConfig config;
    @Getter
    private boolean inTob;
    //index of local player in tob party
    @Getter
    private int localPlayerIndex;
    @Getter
    private Damage raidDamage;
    private boolean shouldCalc;
    private boolean loggedIn;

    @Provides
    TobDamageCounterConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(TobDamageCounterConfig.class);
    }

    @Override
    protected void startUp() throws Exception {
        clientThread.invokeLater(this::calcInTob);
        overlayManager.add(tobDamageOverlay);
    }

    @Override
    protected void shutDown() throws Exception {
        overlayManager.remove(tobDamageOverlay);
        reset();
    }

    private void reset() {
        damageMap.clear();
        inTob = false;
        raidDamage = null;
        shouldCalc = false;
        tobMode = null;
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied hitsplatApplied) {
        if (!inTob) {
            return;
        }

        Actor actor = hitsplatApplied.getActor();

        if (!(actor instanceof NPC)) {
            return;
        }

        NPC npc = (NPC) actor;

        if (blacklistNPCs.contains(npc.getId())) {
            return;
        }

        determineAndUpdateCurrentRoom(npc.getId());

        if (tobMode == null) {
            return;
        }
        tobMode.onHitsplat(hitsplatApplied, npc, damageMap, config);
    }

    @Subscribe
    public void onNpcDespawned(NpcDespawned event) {
        // If we're not both in the ToB raid and the final Verzik bat just despawned, don't print status
        if (!(inTob && event.getNpc().getId() == NpcID.VERZIK_DEATH_BAT) &&
                !(inTob && event.getNpc().getId() == NpcID.VERZIK_DEATH_BAT_HARD)) {
            return;
        }

        if (config.showDamageSummary()) {
            // raid over
            for (TobPhase room : phases) {
                printRoomDamage(room, damageMap.get(room));
            }

            printRoomDamage(null, raidDamage);
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() == GameState.LOGGED_IN && !loggedIn) {
            if (client.getLocalPlayer() != null && client.getLocalPlayer().getWorldLocation().equals(TEMP_LOCATION)) {
                return;
            }

            shouldCalc = true;
        } else if (client.getGameState() == GameState.LOGIN_SCREEN || client.getGameState() == GameState.CONNECTION_LOST) {
            loggedIn = false;
        } else if (client.getGameState() == GameState.HOPPING) {
            reset();
        }
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        if (shouldCalc) {
            calcInTob();
            shouldCalc = false;
            loggedIn = true;
        }
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event) {
        boolean tempInTob = getTobState();
        localPlayerIndex = client.getVarbitValue(LOCAL_TOB_ORB_VARB);

        if (tempInTob != inTob) {
            if (loggedIn) {
                if (tempInTob) {
                    initializeTob();
                } else {
                    reset();
                }
            }

            inTob = tempInTob;
        }
    }

    @Subscribe
    public void onGraphicChanged(GraphicChanged event) {
        if (!inTob) {
            return;
        }

        if (event.getActor().hasSpotAnim(SpotanimID.VERZIK_P3_CREEPER_SPOT)) {
            if (config.showLeechMessages()) {
                String chatMessage = new ChatMessageBuilder().append(ChatColorType.HIGHLIGHT).append(event.getActor().getName() + " has leeched and healed Verzik.").build();

                chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.FRIENDSCHATNOTIFICATION).runeLiteFormattedMessage(chatMessage).build());
            }

            if (event.getActor() instanceof Player) {
                damageMap.get(tobMode.currentPhase).addLeech((Player) event.getActor());
            }
        }
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged event) {
        if (!inTob || !(event.getActor() instanceof Player)) {
            return;
        }

        Player p = (Player) event.getActor();

        Actor interacting = p.getInteracting();
        if (!(interacting instanceof NPC)) {
            return;
        }

        NPC npc = (NPC) interacting;
        int npcId = npc.getId();
        if ((npcId != NpcID.TOB_BLOAT_HARD && npcId != NpcID.TOB_BLOAT)
                || p.getAnimation() == -1) {
            return;
        }

        determineAndUpdateCurrentRoom(npcId);

        int amulet_id = p.getPlayerComposition().getEquipmentId(KitType.AMULET);

        if (SALVE_IDS.contains(amulet_id)) {
            return;
        }

        if (config.showLeechMessages()) {
            Integer leechCount = damageMap.get(tobMode.currentPhase).getLeechCounts().get(p);
            if (leechCount == null) {
                String chatMessage = new ChatMessageBuilder().append(ChatColorType.HIGHLIGHT).append(p.getName() + " is leeching and is not attacking with a salve.").build();

                chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.FRIENDSCHATNOTIFICATION).runeLiteFormattedMessage(chatMessage).build());
            }
        }

        if (event.getActor() instanceof Player) {
            damageMap.get(tobMode.currentPhase).addLeech((Player) event.getActor());
        }
    }

    private void determineAndUpdateCurrentRoom(int npcID) {
        // If we're in ToB but don't know if it's normal or hard mode, hunt for the condition
        if (tobMode == null) {
            // Seek a case where it does match to set the phase
            for (TobPhase phase : phases) {
                Set<Integer> hardNpcIDs = hardRooms.phaseMap.get(phase);
                Set<Integer> normalNpcIDs = normalRooms.phaseMap.get(phase);
                if (hardNpcIDs.contains(npcID)) {
                    tobMode = new HardTobMode();
                } else if (normalNpcIDs.contains(npcID)) {
                    tobMode = new NormalTobMode();
                }
                if (tobMode != null) {
                    tobMode.currentPhase = phase;
                }
            }
            if (tobMode == null) {
                return;
            }
        }
        // Return early if this NPC's type is on the mode matcher for the current room
        if (tobMode.currentPhase != null && tobMode.getNpcIDs().contains(npcID)) {
            return;
            // Search if this NPC was in another phase (which the party now must be in if this NPC is present)
        } else {
            for (TobPhase phase : phases) {
                // Seek a case where it does match to set the phase
                if (!hardRooms.phaseMap.get(phase).contains(npcID)
                        && (!normalRooms.phaseMap.get(phase).contains(npcID))) {
                    continue;
                }
                tobMode.currentPhase = phase;
                return;
            }
        }

        if (tobMode != null) {
            tobMode.currentPhase = null;
        }
        log.warn("NPC ID not handled: {}", npcID);
    }

    private void calcInTob() {
        if (client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        boolean tempInTob = getTobState();

        if (tempInTob != inTob) {
            if (!tempInTob) {
                reset();
            } else {
                initializeTob();
            }

            inTob = tempInTob;
        }
    }

    private void initializeTob() {
        for (TobPhase phase : TobPhase.values()) {
            damageMap.put(phase, new Damage());
        }
    }

    private boolean getTobState() {
        return client.getVarbitValue(TOB_VAR_STATE) == 2 || client.getVarbitValue(TOB_VAR_STATE) == 3;
    }

    private void printRoomDamage(TobPhase phase, Damage damage) {
        int totalDamage = damage.getTotalDamage();
        int personalDamage = damage.getPersonalDamage();

        ChatMessageBuilder builder = new ChatMessageBuilder()
                .append(ChatColorType.NORMAL)
                .append("Total " +
                        (phase != null
                                ? TobPhase.GetPhaseName(phase)
                                : "raid")
                        + " damage: ")
                .append(ChatColorType.HIGHLIGHT)
                .append(DAMAGE_FORMAT.format(totalDamage));
        if (personalDamage > 0 && totalDamage > 0) {
            double percentage = personalDamage / (totalDamage / 100.0);
            builder
                    .append(ChatColorType.NORMAL)
                    .append(", Personal damage: ")

                    .append(ChatColorType.HIGHLIGHT)
                    .append(DAMAGE_FORMAT.format(personalDamage))
                    .append(ChatColorType.NORMAL)

                    .append(" (")
                    .append(ChatColorType.HIGHLIGHT)
                    .append(DECIMAL_FORMAT.format(percentage))
                    .append(ChatColorType.NORMAL)
                    .append("%)");
        }
        String chatMessage = builder.build();

        chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.FRIENDSCHATNOTIFICATION).runeLiteFormattedMessage(chatMessage).build());
    }

    @Data
    class Damage {
        private int personalDamage = 0;
        private int totalDamage = 0;
        private int totalHealing = 0;
        private Map<Player, Integer> leechCounts = new HashMap<>();

        void addDamage(int damage, boolean isLocalPlayer) {
            if (this != raidDamage) {
                if (raidDamage == null) {
                    raidDamage = new Damage();
                }
                raidDamage.addDamage(damage, isLocalPlayer);
            }

            totalDamage += damage;


            if (isLocalPlayer) {
                personalDamage += damage;
            }
        }

        void addLeech(Player player) {
            leechCounts.merge(player, 1, Integer::sum);
        }

        void addHealing(int amount) {
            totalHealing += amount;
        }
    }
}

package org.pingas.tobdamage;

import com.google.common.collect.ImmutableSet;
import java.util.Map;

abstract class TobRooms {
    Map<TobPhase, ImmutableSet<Integer>> phaseMap;
}

package org.pingas.tobdamage;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("tobdamagecounter")
public interface TobDamageCounterConfig extends Config
{
	@ConfigItem(
		keyName = "healCount",
		name = "Show Heal Count",
		description = "Show the total amount healed to each boss on the overlay."
	)
	default boolean showHealCount()
	{
		return true;
	}

	@ConfigItem(
		keyName = "damageSummary",
		name = "Print Raid Summary",
		description = "Print the damage of all the rooms when the raid ends."
	)
	default boolean showDamageSummary()
	{
		return true;
	}

	@ConfigItem(
		keyName = "leechMessages",
		name = "Leech Messages",
		description = "Print messages when a player leeches"
	)
	default boolean showLeechMessages() {
		return true;
	}

	@ConfigItem(
		keyName = "leechOverlay",
		name = "Leech Overlay",
		description = "Show leech counts on the overlay"
	)
	default boolean showLeechOverlay() {
		return true;
	}

	@ConfigItem(
		keyName = "mvpDamage",
		name = "Only count MVP damage",
		description = "Only count damage that contributes to raid MVP"
	)
	default boolean showMVPDamage()
	{
		return false;
	}
}

/*
 * Copyright (c) 2020, Trevor <https://github.com/Trevor159>, Aronson <https://github.com/aronson/>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.pingas.tobdamage;

import net.runelite.api.Player;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.runelite.client.util.QuantityFormatter;

import javax.inject.Inject;
import java.awt.*;
import java.util.Map;

class TobDamageOverlay extends OverlayPanel {
    private final TobDamageCounterPlugin plugin;
    private final TobDamageCounterConfig config;

    @Inject
    TobDamageOverlay(TobDamageCounterPlugin plugin, TobDamageCounterConfig config) {
        super(plugin);
        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.isInTob()) {
            return null;
        }

        TobMode currentMode = plugin.getTobMode();
        if (currentMode == null) {
            return null;
        }

        // no damage yet
        if (plugin.getRaidDamage() == null) {
            return null;
        }

        TobPhase currentPhase = currentMode.currentPhase;
        final String title = currentPhase == null
                ? "Tob Damage"
                : TobPhase.GetPhaseName(currentPhase) + " Damage";
        panelComponent.getChildren().add(
                TitleComponent.builder()
                        .text(title)
                        .build());

        TobDamageCounterPlugin.Damage damage;

        if (currentPhase != null) {
            damage = plugin.getDamageMap().get(currentPhase);
        } else {
            damage = plugin.getRaidDamage();
        }


        String left;
        String right;
        if (plugin.getLocalPlayerIndex() != 0) {
            left = "Personal Damage";
            right = QuantityFormatter.formatNumber(damage.getPersonalDamage());
            panelComponent.getChildren().add(
                    LineComponent.builder()
                            .left(left)
                            .right(right)
                            .build());
        }

        left = "Total Damage";
        right = QuantityFormatter.formatNumber(damage.getTotalDamage());
        panelComponent.getChildren().add(
                LineComponent.builder()
                        .left(left)
                        .right(right)
                        .build());

        if (config.showHealCount() && damage.getTotalHealing() != 0) {
            panelComponent.getChildren().add(
                    LineComponent.builder()
                            .left("Total Healing")
                            .right(QuantityFormatter.formatNumber(damage.getTotalHealing()))
                            .build()
            );
        }

        if (config.showLeechOverlay() && !damage.getLeechCounts().isEmpty()) {
            panelComponent.getChildren().add(LineComponent.builder().build());

            panelComponent.getChildren().add(
                    TitleComponent.builder()
                            .text("Leech Count")
                            .build());

            Map<Player, Integer> leeches = damage.getLeechCounts();
            for (Player p : leeches.keySet()) {
                panelComponent.getChildren().add(
                        LineComponent.builder()
                                .left(p.getName())
                                .right(leeches.get(p) + "")
                                .build());
            }
        }


        return super.render(graphics);
    }

}

package org.pingas.tobdamage;

enum TobPhase {
    Maiden,
    Bloat,
    NylocasWaves,
    NylocasBoss,
    Sotetseg,
    Xarpus,
    VerzikPhase1,
    VerzikPhase2,
    VerzikPhase3;

    static String GetPhaseName(TobPhase phase) {
        switch (phase) {
            case Maiden:
                return "Maiden";
            case Bloat:
                return "Bloat";
            case NylocasWaves:
                return "Nylocas Waves";
            case NylocasBoss:
                return "Nylocas Boss";
            case Sotetseg:
                return "Sotetseg";
            case Xarpus:
                return "Xarpus";
            case VerzikPhase1:
                return "Verzik P1";
            case VerzikPhase2:
                return "Verzik P2";
            case VerzikPhase3:
                return "Verzik P3";
        }
        return "";
    }
}

package org.pingas.tobdamage;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TobDamageCounterPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TobDamageCounterPlugin.class);
		RuneLite.main(args);
	}
}
