/*
 * Copyright (c) 2020, MMagicala <https://github.com/MMagicala>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.github.mmagicala.gnomeRestaurant;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("gnomerestaurant")
public interface GnomeRestaurantConfig extends Config {

    @ConfigItem(
            keyName = GnomeRestaurantPlugin.SHOW_OVERLAY,
            name = "Show Overlay",
            description = "Configures whether to show the overlay window"
    )
    default boolean showOverlay() {
        return true;
    }

    @ConfigItem(
            keyName = GnomeRestaurantPlugin.SHOW_ORDER_TIMER,
            name = "Show Order Timer",
            description = "Configures whether to show the order timer"
    )
    default boolean showOrderTimer() {
        return true;
    }

    @ConfigItem(
            keyName = GnomeRestaurantPlugin.SHOW_DELAY_TIMER,
            name = "Show Delay Timer",
            description = "Configures whether to show the order delay timer"
    )
    default boolean showDelayTimer() {
        return true;
    }

    @ConfigItem(
            keyName = GnomeRestaurantPlugin.SHOW_HINT_ARROW,
            name = "Show Hint Arrow",
            description = "Configures whether to show the hint arrow toward the order recipient"
    )
    default boolean showHintArrow() {
        return true;
    }

    @ConfigItem(
            keyName = GnomeRestaurantPlugin.SHOW_WORLD_MAP_POINT,
            name = "Show World Map Point",
            description = "Configures whether to show the recipient's location in the world map"
    )
    default boolean showWorldMapPoint() {
        return true;
    }
}

/*
 * Copyright (c) 2020, MMagicala <https://github.com/MMagicala>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.github.mmagicala.gnomeRestaurant;

import com.google.inject.Provides;
import io.github.mmagicala.gnomeRestaurant.order.Customer;
import io.github.mmagicala.gnomeRestaurant.order.OrderDifficulty;
import io.github.mmagicala.gnomeRestaurant.overlay.GnomeRestaurantOverlay;
import io.github.mmagicala.gnomeRestaurant.overlay.OverlayHeader;
import io.github.mmagicala.gnomeRestaurant.overlay.OverlayTableEntry;
import io.github.mmagicala.gnomeRestaurant.recipe.Ingredient;
import io.github.mmagicala.gnomeRestaurant.recipe.Order;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.api.NPC;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.ui.overlay.infobox.Timer;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;

@PluginDescriptor(name = "Gnome Restaurant")
public class GnomeRestaurantPlugin extends Plugin {

    private static final Logger LOGGER = LoggerFactory.getLogger(GnomeRestaurantPlugin.class);

    @Inject
    private Client client;

    @Inject
    private GnomeRestaurantConfig config;

    @Inject
    private InfoBoxManager infoBoxManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private ItemManager itemManager;

    @Inject
    private ClientThread clientThread;

    @Inject
    private WorldMapPointManager worldMapPointManager;

    // UI

    private Timer timer;
    private Overlay overlay;
    private WorldMapPoint worldMapPoint;

    private String tooltipText;

    private boolean refusedHardOrder = false;
    private boolean queuedUpdate = false;

    // Current order information

    private Order order;
    private Customer customer;
    private int stepIdx;

    // Overlay

    private OverlayHeader overlayHeader = new OverlayHeader("null", -1, -1);
    private final List<OverlayTableEntry> stepIngredientsOverlayTable = new ArrayList<>();
    private final List<OverlayTableEntry> nextRawIngredientsOverlayTable = new ArrayList<>();

    public OverlayHeader overlayHeader() {
        return overlayHeader;
    }

    @Override
    protected void shutDown() {
        resetPlugin();
    }

    private void resetPlugin() {
        removeTimer();
        removeOverlay();
        removeWorldMapPoint();
        client.clearHintArrow();

        stepIdx = 0;

        refusedHardOrder = false;

        order = null;
        customer = null;
    }

    private void onRefusedHardOrder() {
        resetPlugin();

        setupRefusedOrderTimer();
        refusedHardOrder = true;
    }

    private void updateOrder() {
        updateOrderStep();
        setupUI();
    }

    private void queueUpdateOrder() {
        if (queuedUpdate) {
            return;
        }
        clientThread.invokeAtTickEnd(() -> {
            LOGGER.debug("Updating ui for order={}, customer={}", order, customer);
            updateOrder();
            queuedUpdate = false;
        });
        queuedUpdate = true;
    }

    private void setupRefusedOrderTimer() {
        timer = new Timer(5, ChronoUnit.MINUTES, itemManager.getImage(ItemID.ALUFT_DELIVERY_BOX), this);
        timer.setTooltip("Refused hard order cooldown");
        infoBoxManager.addInfoBox(timer);
    }

    /**
     * Update the step we are working on in the recipe
     * Returns whether a step has been updated or not
     **/
    private boolean updateOrderStep() {
        // Go from the beginning of the recipe to the final item produced

        int newStepIdx = 0;

        for (int i = 0; i < order.getSteps().size() - 1; i++) {
            int producedId = order.getSteps().get(i).getProducedItemId();
            if (getItemCount(producedId) > 0) {
                // We produced the item for this step
                newStepIdx = i + 1;
            }
        }
        boolean stepUpdated = newStepIdx != stepIdx;

        stepIdx = newStepIdx;
        return stepUpdated;
    }

    private int getItemCount(int itemId) {
        // Assume the inventory is empty (and player just logged in) if it is null
        ItemContainer inventory = client.getItemContainer(InventoryID.INV);

        if (inventory == null) {
            return 0;
        } else {
            return inventory.count(itemId);
        }
    }

    private void setupUI() {
        tooltipText = "Deliver " + order.getName() + " to " + customer.getName();

        if (config.showOverlay()) {
            setupOverlay();
        }

        if (config.showOrderTimer()) {
            setupOrderTimer();
        }

        if (config.showHintArrow()) {
            showHintArrow();
        }

        if (config.showWorldMapPoint()) {
            showWorldMapPoint();
        }
    }

    private void setupOverlay() {
        if (overlay != null) {
            removeOverlay();
        }
        updateOverlayHeader();
        rebuildOverlayTables();

        // Display overlay
        overlay = new GnomeRestaurantOverlay(this, stepIngredientsOverlayTable, nextRawIngredientsOverlayTable);
        overlayManager.add(overlay);
    }

    private void setupOrderTimer() {
        LOGGER.debug("Setting up order timer");
        int numSecondsLeft;

        if (customer.getDifficulty() == OrderDifficulty.HARD) {
            numSecondsLeft = 660;
        } else {
            numSecondsLeft = 360;
        }

        if (timer != null) {
            LOGGER.debug("Removing previous order timer");
            removeTimer();
        }
        timer = new Timer(numSecondsLeft, ChronoUnit.SECONDS, itemManager.getImage(order.getItemId()), this);
        timer.setTooltip(tooltipText);

        infoBoxManager.addInfoBox(timer);
    }

    private void showHintArrow() {
        if (!setHintArrowToCustomer()) {
            // NPC not in sight
            // Show hint arrow in minimap instead
            client.setHintArrow(customer.getLocation(client));
        }
    }

    private void showWorldMapPoint() {
        if (worldMapPoint != null) {
            removeWorldMapPoint();
        }

        worldMapPoint = WorldMapPoint.builder().name(customer.getName())
                                     .worldPoint(customer.getLocation(client))
                                     .image(itemManager.getImage(ItemID.ALUFT_DELIVERY_BOX))
                                     .build();
        worldMapPoint.setSnapToEdge(true);
        worldMapPoint.setJumpOnClick(true);
        worldMapPoint.setTooltip(tooltipText);
        worldMapPointManager.add(worldMapPoint);
    }

    private boolean setHintArrowToCustomer() {
        var npcs = client.getTopLevelWorldView().npcs();

        for (NPC npc : npcs) {
            if (npc.getId() == customer.getNpcTypeId(client)) {
                client.setHintArrow(npc);
                return true;
            }
        }
        return false;
    }

    @Subscribe
    public void onNpcSpawned(final NpcSpawned event) {
        var npc = event.getNpc();

        if (order == null || !config.showHintArrow()) {
            return;
        }
        if (npc.getId() == customer.getNpcTypeId(client)) {
            client.setHintArrow(npc);
        }
    }

    @Subscribe
    public void onNpcDespawned(final NpcDespawned event) {
        var npc = event.getNpc();

        if (order == null || !config.showHintArrow()) {
            return;
        }
        if (npc.getId() == customer.getNpcTypeId(client)) {
            client.setHintArrow(customer.getLocation(client));
        }
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event) {
        switch (event.getVarbitId()) {
            case VarbitID.ALUFT_MINIGAME_STARTED:
                onAluftMinigameStarted(event.getValue());
                break;
            case VarbitID.ALUFT_CURRENT_CUSTOMER:
                onAluftCustomerChanged(event.getValue());
                break;
            case VarbitID.ALUFT_CURRENT_ORDER:
                onAluftOrderChanged(event.getValue());
                break;
            case VarbitID.ALUFT_REFUSED_HARD_ORDER:
                onAluftRefusedOrderChanged(event.getValue());
                break;
        }
    }

    private void onAluftMinigameStarted(int value) {
        LOGGER.debug("Aluft Minigame started is {}", value);

        if (value == 0) {
            resetPlugin();
        }
    }

    private void onAluftCustomerChanged(int customerId) {
        if (customerId == 0) {
            customer = null;
            return;
        }
        customer = Customer.forId(customerId);
        LOGGER.debug("Customer is now {}", customer);
        queueUpdateOrder();
    }

    private void onAluftOrderChanged(int orderId) {
        if (orderId == 0) {
            order = null;
            return;
        }
        order = Order.forId(orderId);
        LOGGER.debug("Order is now {}", order);
        queueUpdateOrder();
    }

    private void onAluftRefusedOrderChanged(int value) {
        if (value == 1) {
            LOGGER.debug("Refused hard order, setting up timer");
            onRefusedHardOrder();
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event) {
        if (event.getContainerId() != InventoryID.INV) {
            return;
        }
        if (order == null) {
            return;
        }
        // Has player finished a step?

        if (updateOrderStep()) {
            updateOverlayHeader();
            rebuildOverlayTables();
        } else {
            updateOverlayTables();
        }
    }

    private void updateOverlayHeader() {
        var instruction = order.getSteps().get(stepIdx).getInstruction().getOverlayDirections();
        overlayHeader = new OverlayHeader(instruction, stepIdx + 1, order.getSteps().size());
    }

    private void rebuildOverlayTables() {
        clearOverlayTables();

        List<Ingredient> stepIngredients = order.getSteps().get(stepIdx).getIngredients();
        rebuildOverlayTable(stepIngredients, stepIngredientsOverlayTable);

        List<Ingredient> nextRawIngredients = order.getNextRawIngredients(stepIdx);
        rebuildOverlayTable(nextRawIngredients, nextRawIngredientsOverlayTable);
    }

    private void rebuildOverlayTable(List<Ingredient> ingredients, List<OverlayTableEntry> overlayTable) {
        for (Ingredient ingredient : ingredients) {
            int itemId = ingredient.getItemId();
            String itemName = itemManager.getItemComposition(itemId).getName();
            int inventoryCount = getItemCount(itemId);
            int expectedCount = ingredient.getCount();

            overlayTable.add(new OverlayTableEntry(itemId, itemName, inventoryCount, expectedCount));
        }
    }

    private void updateOverlayTables() {
        updateOverlayTable(stepIngredientsOverlayTable);
        updateOverlayTable(nextRawIngredientsOverlayTable);
    }

    private void updateOverlayTable(List<OverlayTableEntry> overlayTable) {
        for (OverlayTableEntry entry : overlayTable) {
            int inventoryCount = getItemCount(entry.getItemId());
            if (entry.getInventoryCount() != inventoryCount) {
                entry.setInventoryCount(inventoryCount);
            }
        }
    }

    // Config

    @Provides
    GnomeRestaurantConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(GnomeRestaurantConfig.class);
    }

    // Config group keys

    public static final String SHOW_DELAY_TIMER = "showDelayTimer";
    public static final String SHOW_ORDER_TIMER = "showOrderTimer";
    public static final String SHOW_OVERLAY = "showOverlay";
    public static final String SHOW_HINT_ARROW = "showHintArrow";
    public static final String SHOW_WORLD_MAP_POINT = "showWorldMapPoint";

    /**
     * Monitor changes to plugin config and update the plugin accordingly
     *
     * @param event indicates the setting that was changed and its new value
     */
    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (order != null) {
            if (event.getKey().equals(SHOW_ORDER_TIMER)) {
                if (event.getNewValue().equals("false")) {
                    removeTimer();
                }
            } else if (event.getKey().equals(SHOW_OVERLAY)) {
                if (event.getNewValue().equals("false")) {
                    removeOverlay();
                } else {
                    // Must be called from client thread
                    clientThread.invoke(this::setupOverlay);
                }
            } else if (event.getKey().equals(SHOW_HINT_ARROW)) {
                if (event.getNewValue().equals("false")) {
                    client.clearHintArrow();
                } else {
                    showHintArrow();
                }
            } else if (event.getKey().equals(SHOW_WORLD_MAP_POINT)) {
                if (event.getNewValue().equals("false")) {
                    removeWorldMapPoint();
                } else {
                    showWorldMapPoint();
                }
            }
        } else {
            if (!event.getGroup().equals("gnomerestaurant")) {
                // This plugin's config has not changed
                return;
            } else if (event.getKey().equals(SHOW_DELAY_TIMER) && refusedHardOrder) {
                if (event.getNewValue().equals("false")) {
                    removeTimer();
                }
            }
        }
    }

    // UI cleaning

    private void removeTimer() {
        infoBoxManager.removeInfoBox(timer);
        timer = null;
    }

    private void removeOverlay() {
        clearOverlayTables();
        overlayManager.remove(overlay);
        overlay = null;
    }

    private void removeWorldMapPoint() {
        worldMapPointManager.remove(worldMapPoint);
        worldMapPoint = null;
    }

    private void clearOverlayTables() {
        stepIngredientsOverlayTable.clear();
        nextRawIngredientsOverlayTable.clear();
    }
}

package io.github.mmagicala.gnomeRestaurant.order;

import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.NpcID;

import java.security.InvalidParameterException;

public enum Customer {

    TRAINER_NACKLEPEN(1, "Trainer Nacklepen", CustomerLocation.fixed(NpcID.GNOME_TORTOISE_TRAINER, 2421, 3525)),
    HIS_ROYAL_HIGHNESS_KING_NARNODE(2, "King Narnode Shareen", CustomerLocation.fixed(NpcID.GRANDTREE_NARNODE, 2466, 3497)),
    FEMI(3, "Femi", CustomerLocation.fixed(NpcID.GRANDTREE_FEMI, 2459, 3382)),
    HECKEL_FUNCH(4, "Heckel Funch", CustomerLocation.fixed(NpcID.GNOME_HECKELFUNCH, 2493, 3488)),
    GULLUCK(5, "Gulluck", CustomerLocation.fixed(NpcID.GNOME_GULLUCK, 2468, 3487)),
    ROMETTI(6, "Rometti", CustomerLocation.fixed(NpcID.GNOME_ROMETTI, 2482, 3510)),
    COACH(7, "Gnome Coach", CustomerLocation.fixed(NpcID.GNOME_BALL_COACH, 2406, 3498)),
    WURBEL(8, "Wurbel", CustomerLocation.fixed(NpcID.ALUFT_GNOMEBALL_FAN, 2395, 3477)),
    EEBEL(9, "Eebel", CustomerLocation.fixed(NpcID.ALUFT_CUSTOMER_MALE, 2416, 3414)),
    DAMWIN(10, "Damwin", CustomerLocation.fixed(NpcID.ALUFT_GNOME_CHEERLEADER, 2417, 3496)),
    SARBLE(11, "Sarble", CustomerLocation.fixed(NpcID.ALUFT_TOAD_HANDLER, 2417, 3517)),
    BURKOR(12, "Burkor", CustomerLocation.fixed(NpcID.ALUFT_GNOMEKNIGHT, 2420, 3474)),
    MEEGLE(13, "Meegle", CustomerLocation.fixed(NpcID.ALUFT_GNOME_TERRORBIRD_TRAINER, 2378, 3433)),
    GUARD_VEMMELDO(14, "Guard Vemmeldo", CustomerLocation.fixed(NpcID.GNOME_BANK_GUARD, 2446, 3418)),
    ERMIN(15, "Ermin", CustomerLocation.fixed(NpcID.ALUFT_CUSTOMER_SPINNER, 2488, 3409)),
    FROONO(16, "Froono", CustomerLocation.fixed(NpcID.ALUFT_GNOME_CHILD, 2435, 3403)),
    BRIMSTAIL(17, "Brimstail", CustomerLocation.fixed(NpcID.GNOME_BRIMSTAIL, 2409, 9817)),
    CAPTAIN_ERRDO(18, "Captain Errdo", CustomerLocation.fixed(NpcID.PILOT_DIGSITE, 2464, 3501)),
    PERRDUR(19, "Perrdur", CustomerLocation.fixed(NpcID.ALUFT_GNOME_CUSTOMER_ONE, 2447, 3501)),
    DALILA(20, "Dalila", CustomerLocation.fixed(NpcID.ALUFT_GNOME_CUSTOMER_TWO, 2448, 3500)),

    // Hard NPCs
    HAZELMERE(101, "Hazelmere", CustomerLocation.fixed(NpcID.GRANDTREE_HAZELMERE_MULTI, 2678, 3086)),
    GNORMADIUM_AVLAFRIM(102, "Gnormadium Avlafrim", CustomerLocation.fixed(NpcID.GNORMADIUM_AVLAFRIM_GLIDER, 2544, 2973)),
    CAPTAIN_NINTO(103, "Captain Ninto", CustomerLocation.fixed(NpcID.ALUFT_PILOT_NINTO, 2869, 9877)),
    CAPTAIN_DAERKIN(104, "Captain Daerkin", CustomerLocation.fixed(NpcID.ALUFT_PILOT_DAERKIN, 3362, 3222)),
    BRAMBICKLE(105, "Brambickle", CustomerLocation.fixed(NpcID.ALUFT_GNOME_EXPLORER_MOUNTAIN, 2786, 3862)),
    WINGSTONE(106, "Wingstone", CustomerLocation.fixed(NpcID.ALUFT_GNOME_EXPLORER_SAFARI, 3380, 2893)),
    PENWIE(107, "Penwie", CustomerLocation.fixed(NpcID.ALUFT_GNOME_EXPLORER_JUNGLE, 2932, 2972)),
    AMBASSADOR_GIMBLEWAP(108, "Ambassador Gimblewap", CustomerLocation.fixed(NpcID.ALUFT_GNOME_DIPLOMAT_ARDOUGNE, 2572, 3299)),
    AMBASSADOR_SPANFIPPLE(109, "Ambassador Spanfipple", CustomerLocation.fixed(NpcID.ALUFT_GNOME_DIPLOMAT_FALADOR, 2984, 3342)),
    AMBASSADOR_FERRNOOK(110, "Ambassador Ferrnook", CustomerLocation.fixed(NpcID.ALUFT_GNOME_DIPLOMAT_VARROCK, 3209, 3474)),
    PROFESSOR_IMBLEWYN(111, "Professor Imblewyn", CustomerLocation.fixed(NpcID.ALUFT_GNOME_MAGE_2, 2590, 3092)),
    PROFESSOR_MANGLETHORP(112, "Professor Manglethorp", CustomerLocation.fixed(NpcID.ALUFT_GNOME_INVENTOR, 2868, 10198)),
    PROFESSOR_ONGLEWIP(113, "Professor Onglewip", CustomerLocation.fixed(NpcID.ALUFT_GNOME_MAGE, 3115, 3160)),
    GARKOR(114, "Garkor", new GarkorLocation()),
    KING_BOLREN(115, "King Bolren", CustomerLocation.fixed(NpcID.KING_BOLREN, 2542, 3169)),
    GLO_CARANOCK(116, "G.L.O. Caranock", CustomerLocation.fixed(NpcID.MM_CARANOCK, 2956, 3025)),
    LIEUTENANT_SCHEPBUR(117, "Lieutenant Schepbur", CustomerLocation.fixed(NpcID.GNOME_TORTOISE_COMMANDER, 2515, 3205)),
    CAPTAIN_DALBUR(118, "Captain Dalbur", CustomerLocation.fixed(NpcID.PILOT_AL_KHARID_BASE, 3284, 3212)),
    CAPTAIN_BLEEMADGE(119, "Captain Bleemadge", CustomerLocation.fixed(NpcID.PILOT_WHITE_WOLF_BASE, 2847, 3499)),
    CAPTAIN_KLEMFOODLE(120, "Captain Klemfoodle", CustomerLocation.fixed(NpcID.PILOT_KARAMJA_BASE, 2970, 2973));

    private final int id;
    private final String name;
    private final CustomerLocation location;

    public static Customer forId(int id) {
        for (var recipient : values()) {
            if (recipient.id == id) {
                return recipient;
            }
        }
        throw new InvalidParameterException("No customer found with the id " + id);
    }

    Customer(int id, String name, CustomerLocation location) {
        this.id = id;
        this.name = name;
        this.location = location;
    }

    public String getName() {
        return this.name;
    }

    public OrderDifficulty getDifficulty() {
        return id > 100 ? OrderDifficulty.HARD : OrderDifficulty.EASY;
    }

    public int getNpcTypeId(Client client) {
        return this.location.npcTypeId(client);
    }

    public WorldPoint getLocation(Client client) {
        return this.location.resolve(client);
    }
}

package io.github.mmagicala.gnomeRestaurant.order;

import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;

public interface CustomerLocation {

    int npcTypeId(Client client);

    WorldPoint resolve(Client client);

    static CustomerLocation fixed(int npcTypeId, int x, int y) {
        return fixed(npcTypeId, x, y, 0);
    }

    static CustomerLocation fixed(int npcTypeId, int x, int y, int plane) {
        return new StaticCustomerLocation(npcTypeId, new WorldPoint(x, y, plane));
    }

    class StaticCustomerLocation implements CustomerLocation {

        private final int npcTypeId;
        private final WorldPoint worldPoint;

        private StaticCustomerLocation(int npcTypeId, WorldPoint worldPoint) {
            this.npcTypeId = npcTypeId;
            this.worldPoint = worldPoint;
        }

        @Override
        public int npcTypeId(Client client) {
            return npcTypeId;
        }

        @Override
        public WorldPoint resolve(Client client) {
            return worldPoint;
        }
    }
}

package io.github.mmagicala.gnomeRestaurant.order;

import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.VarbitID;

public class GarkorLocation implements CustomerLocation {

    @Override
    public int npcTypeId(Client client) {
        var mm2progress = client.getVarbitValue(VarbitID.MM2_PROGRESS);

        if (mm2progress >= 195 && mm2progress <= 200) {
            // Post mm2
            return NpcID.MM_GARKOR_GS;
        } else if (mm2progress >= 140 && mm2progress <= 175) {
            // Gnome Stronghold Fence
            return NpcID.MM2_GARKOR_BREACH;
        } else {
            // Ape Atoll
            return NpcID.MM_GARKOR_AA;
        }
    }

    @Override
    public WorldPoint resolve(Client client) {
        var mm2progress = client.getVarbitValue(VarbitID.MM2_PROGRESS);

        if (mm2progress >= 195 && mm2progress <= 200) {
            // Post mm2
            return new WorldPoint(2479, 3463, 0);
        } else if (mm2progress >= 140 && mm2progress <= 175) {
            // Gnome Stronghold Fence
            return new WorldPoint(2434, 3519, 0);
        } else {
            // Ape Atoll
            return new WorldPoint(2805, 2762, 0);
        }
    }
}

package io.github.mmagicala.gnomeRestaurant.order;

public enum OrderDifficulty {
    EASY,
    HARD
}

/*
 * Copyright (c) 2020, MMagicala <https://github.com/MMagicala>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.github.mmagicala.gnomeRestaurant.overlay;

import io.github.mmagicala.gnomeRestaurant.GnomeRestaurantPlugin;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.List;

public class GnomeRestaurantOverlay extends OverlayPanel {

    // Overlay contents
    private final GnomeRestaurantPlugin plugin;
    private final List<OverlayTableEntry> stepIngredientsOverlayTable;
    private final List<OverlayTableEntry> futureRawIngredientsOverlayTable;

    private static final int PADDING = 10;

    @Inject
    public GnomeRestaurantOverlay(
            GnomeRestaurantPlugin plugin,
            List<OverlayTableEntry> stepIngredientsOverlayTable,
            List<OverlayTableEntry> futureRawIngredientsOverlayTable
    ) {
        super(plugin);
        this.plugin = plugin;
        this.stepIngredientsOverlayTable = stepIngredientsOverlayTable;
        this.futureRawIngredientsOverlayTable = futureRawIngredientsOverlayTable;

        // Padding
        panelComponent.setBorder(new Rectangle(PADDING, PADDING, PADDING, PADDING));

        // Gap between panel items
        panelComponent.setGap(new Point(0, ComponentConstants.STANDARD_BORDER));
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        // Header
        var header = plugin.overlayHeader();
        String headerText = "Step " + header.stepNum + "/" + header.totalSteps + ": " + header.instruction;

        LineComponent headerComponent = LineComponent.builder().left(headerText).build();
        panelComponent.getChildren().add(headerComponent);

        // Overlay tables

        renderOverlayTable(stepIngredientsOverlayTable, "Current Step");

        if (!futureRawIngredientsOverlayTable.isEmpty()) {
            // Only render future ingredients if there are any left
            renderOverlayTable(futureRawIngredientsOverlayTable, "Needed Later");
        }

        return super.render(graphics);
    }

    private void renderOverlayTable(List<OverlayTableEntry> overlayTable, String title) {
        // Table header

        TitleComponent titleComponent = TitleComponent.builder().text(title).build();
        panelComponent.getChildren().add(titleComponent);

        // Table contents

        for (OverlayTableEntry tableEntry : overlayTable) {
            Color ingredientColor;
            if (tableEntry.getInventoryCount() >= tableEntry.getRequiredCount()) {
                ingredientColor = Color.GREEN;
            } else if (tableEntry.getInventoryCount() == 0) {
                ingredientColor = Color.RED;
            } else {
                ingredientColor = Color.YELLOW;
            }

            LineComponent ingredientRow = LineComponent.builder()
                                                       .left(tableEntry.getItemName())
                                                       .leftColor(ingredientColor)
                                                       .right(tableEntry.getInventoryCount() + "/" + tableEntry.getRequiredCount())
                                                       .rightColor(ingredientColor)
                                                       .build();
            panelComponent.getChildren().add(ingredientRow);
        }
    }
}

package io.github.mmagicala.gnomeRestaurant.overlay;

public class OverlayHeader {

    public final String instruction;
    public final int stepNum;
    public final int totalSteps;

    public OverlayHeader(String instruction, int stepNum, int totalSteps) {
        this.instruction = instruction;
        this.stepNum = stepNum;
        this.totalSteps = totalSteps;
    }
}

package io.github.mmagicala.gnomeRestaurant.overlay;

public class OverlayTableEntry {
    // Used by plugin to update entry

    private final int itemId;
    // Used by overlay table for output
    private final String itemName;
    private final int requiredCount;
    private int inventoryCount;

    public OverlayTableEntry(int itemId, String itemName, int inventoryCount, int requiredCount) {
        this.itemId = itemId;
        this.itemName = itemName;
        this.inventoryCount = inventoryCount;
        this.requiredCount = requiredCount;
    }

    public int getItemId() {
        return this.itemId;
    }

    public String getItemName() {
        return this.itemName;
    }

    public int getInventoryCount() {
        return this.inventoryCount;
    }

    public int getRequiredCount() {
        return this.requiredCount;
    }

    public void setInventoryCount(int inventoryCount) {
        this.inventoryCount = inventoryCount;
    }
}

/*
 * Copyright (c) 2020, MMagicala <https://github.com/MMagicala>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.github.mmagicala.gnomeRestaurant.recipe;

public class Ingredient {

    private final int itemId;
    private final int count;
    private final boolean isIntermediate;

    public Ingredient(int itemId, int count) {
        this(itemId, count, false);
    }

    public Ingredient(int itemId, int count, boolean isIntermediate) {
        this.itemId = itemId;
        this.count = count;
        this.isIntermediate = isIntermediate;
    }

    public int getItemId() {
        return this.itemId;
    }

    public int getCount() {
        return this.count;
    }

    public boolean isIntermediate() {
        return this.isIntermediate;
    }
}

package io.github.mmagicala.gnomeRestaurant.recipe;

import net.runelite.api.gameval.ItemID;

import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.List;

public enum Order {

    FRUIT_BLAST(1, "Fruit Blast", createCocktailRecipe(
            List.of(
                    new Ingredient(ItemID.PINEAPPLE, 1),
                    new Ingredient(ItemID.LEMON, 1),
                    new Ingredient(ItemID.ORANGE, 1)
            ),
            ItemID.ALUFT_SHAKER_FRUIT_BLAST,
            new Ingredient(ItemID.LEMON_SLICES, 1),
            ItemID.FRUIT_BLAST)
    ),

    PINEAPPLE_PUNCH(2, "Pineapple Punch", createCocktailRecipe(
            List.of(
                    new Ingredient(ItemID.PINEAPPLE, 2),
                    new Ingredient(ItemID.LEMON, 1),
                    new Ingredient(ItemID.ORANGE, 1)
            ),
            ItemID.ALUFT_SHAKER_PINEAPPLE_PUNCH,
            List.of(
                    new Ingredient(ItemID.LIME_CHUNKS, 1),
                    new Ingredient(ItemID.PINEAPPLE_CHUNKS, 1),
                    new Ingredient(ItemID.ORANGE_SLICES, 1)
            ),
            ItemID.PINEAPPLE_PUNCH)
    ),

    TOAD_CRUNCHIES(3, "Toad Crunchies", createBakedRecipe(
            BakedRecipeType.CRUNCHIES,
            List.of(
                    new Ingredient(ItemID.TOADS_LEGS, 2),
                    new Ingredient(ItemID.GNOME_SPICE, 1)
            ),
            ItemID.ALUFT_HALF_BAKED_TOAD_CRUNCHY,
            ItemID.ALUFT_BAKED_TOAD_CRUNCHY,
            new Ingredient(ItemID.EQUA_LEAVES, 1),
            ItemID.TOAD_CRUNCHIES)
    ),

    SPICY_CRUNCHIES(4, "Spicy Crunchies", createBakedRecipe(
            BakedRecipeType.CRUNCHIES,
            List.of(
                    new Ingredient(ItemID.EQUA_LEAVES, 2),
                    new Ingredient(ItemID.GNOME_SPICE, 1)
            ),
            ItemID.ALUFT_HALF_BAKED_SPICY_CRUNCHY,
            ItemID.ALUFT_BAKED_SPICY_CRUNCHY,
            new Ingredient(ItemID.GNOME_SPICE, 1),
            ItemID.SPICY_CRUNCHIES)
    ),

    WORM_CRUNCHIES(5, "Worm Crunchies", createBakedRecipe(
            BakedRecipeType.CRUNCHIES,
            List.of(
                    new Ingredient(ItemID.KING_WORM, 2),
                    new Ingredient(ItemID.GNOME_SPICE, 1),
                    new Ingredient(ItemID.EQUA_LEAVES, 1)
            ),
            ItemID.ALUFT_HALF_BAKED_WORM_CRUNCHY,
            ItemID.ALUFT_BAKED_WORM_CRUNCHY,
            new Ingredient(ItemID.GNOME_SPICE, 1),
            ItemID.WORM_CRUNCHIES)
    ),

    CHOC_CHIP_CRUNCHIES(6, "Choc Chip Crunchies", createBakedRecipe(
            BakedRecipeType.CRUNCHIES,
            List.of(
                    new Ingredient(ItemID.CHOCOLATE_BAR, 2),
                    new Ingredient(ItemID.GNOME_SPICE, 1)
            ),
            ItemID.ALUFT_HALF_BAKED_CHOC_CHIP_CRUNCHY,
            ItemID.ALUFT_BAKED_CHOC_CHIP_CRUNCHY,
            new Ingredient(ItemID.CHOCOLATE_DUST, 1),
            ItemID.CHOCCHIP_CRUNCHIES)
    ),

    WIZARD_BLIZZARD(7, "Wizard Blizzard", createCocktailRecipe(
            List.of(
                    new Ingredient(ItemID.VODKA, 2),
                    new Ingredient(ItemID.GIN, 1),
                    new Ingredient(ItemID.LIME, 1),
                    new Ingredient(ItemID.LEMON, 1),
                    new Ingredient(ItemID.ORANGE, 1)
            ),
            ItemID.ALUFT_SHAKER_WIZZARD_BLIZZARD,
            List.of(
                    new Ingredient(ItemID.PINEAPPLE_CHUNKS, 1),
                    new Ingredient(ItemID.LIME_SLICES, 1)
            ),
            ItemID.WIZARD_BLIZZARD)
    ),

    SHORT_GREEN_GUY(8, "Short Green Guy", createCocktailRecipe(
            List.of(
                    new Ingredient(ItemID.VODKA, 1),
                    new Ingredient(ItemID.LIME, 3)
            ),
            ItemID.ALUFT_SHAKER_SGG,
            List.of(
                    new Ingredient(ItemID.LIME_SLICES, 1),
                    new Ingredient(ItemID.EQUA_LEAVES, 1)
            ),
            ItemID.SGG)
    ),

    FRUIT_BATTA(9, "Fruit Batta", createBakedRecipe(
            BakedRecipeType.BATTA,
            List.of(
                    new Ingredient(ItemID.EQUA_LEAVES, 4),
                    new Ingredient(ItemID.LIME_CHUNKS, 1),
                    new Ingredient(ItemID.ORANGE_CHUNKS, 1),
                    new Ingredient(ItemID.PINEAPPLE_CHUNKS, 1)
            ),
            ItemID.ALUFT_HALF_MADE_FRUIT_BATTA,
            ItemID.ALUFT_BAKED_FRUIT_BATTA,
            new Ingredient(ItemID.GNOME_SPICE, 1),
            ItemID.FRUIT_BATTA)
    ),

    TOAD_BATTA(10, "Toad Batta", createBakedRecipe(
            BakedRecipeType.BATTA,
            List.of(
                    new Ingredient(ItemID.EQUA_LEAVES, 1),
                    new Ingredient(ItemID.GNOME_SPICE, 1),
                    new Ingredient(ItemID.CHEESE, 1),
                    new Ingredient(ItemID.TOADS_LEGS, 1)
            ),
            ItemID.ALUFT_HALF_MADE_TOAD_BATTA,
            ItemID.TOAD_BATTA)
    ),

    WORM_BATTA(11, "Worm Batta", createBakedRecipe(
            BakedRecipeType.BATTA,
            List.of(
                    new Ingredient(ItemID.KING_WORM, 1),
                    new Ingredient(ItemID.CHEESE, 1),
                    new Ingredient(ItemID.GNOME_SPICE, 1)
            ),
            ItemID.ALUFT_HALF_MADE_WORM_BATTA,
            ItemID.ALUFT_BAKED_WORM_BATTA,
            new Ingredient(ItemID.EQUA_LEAVES, 1),
            ItemID.WORM_BATTA)
    ),

    VEGETABLE_BATTA(12, "Vegetable Batta", createBakedRecipe(
            BakedRecipeType.BATTA,
            List.of(
                    new Ingredient(ItemID.TOMATO, 2),
                    new Ingredient(ItemID.DWELLBERRIES, 1),
                    new Ingredient(ItemID.ONION, 1),
                    new Ingredient(ItemID.CHEESE, 1),
                    new Ingredient(ItemID.CABBAGE, 1)
            ),
            ItemID.ALUFT_HALF_MADE_VEG_BATTA,
            ItemID.ALUFT_BAKED_VEG_BATTA,
            new Ingredient(ItemID.EQUA_LEAVES, 1),
            ItemID.VEGETABLE_BATTA)
    ),

    CHEESE_AND_TOMATO_BATTA(13, "Cheese and Tomato Batta", createBakedRecipe(
            BakedRecipeType.BATTA,
            List.of(
                    new Ingredient(ItemID.CHEESE, 1),
                    new Ingredient(ItemID.TOMATO, 1)
            ),
            ItemID.ALUFT_HALF_MADE_CHEESE_TOM_BATTA,
            ItemID.ALUFT_BAKED_CHEESE_TOM_BATTA,
            new Ingredient(ItemID.EQUA_LEAVES, 1),
            ItemID.CHEESE_TOM_BATTA)
    ),

    WORM_HOLE(14, "Worm Hole", createBakedRecipe(
            BakedRecipeType.GNOMEBOWL,
            List.of(
                    new Ingredient(ItemID.KING_WORM, 4),
                    new Ingredient(ItemID.ONION, 2),
                    new Ingredient(ItemID.GNOME_SPICE, 1)
            ),
            ItemID.ALUFT_HALF_BAKED_WORM_HOLE,
            ItemID.ALUFT_BAKED_WORM_HOLE,
            new Ingredient(ItemID.EQUA_LEAVES, 1),
            ItemID.WORM_HOLE)
    ),

    DRUNK_DRAGON(15, "Drunk Dragon", createDrunkDragonRecipe()),

    VEGETABLE_BALL(16, "Vegetable Ball", createBakedRecipe(
            BakedRecipeType.GNOMEBOWL,
            List.of(
                    new Ingredient(ItemID.POTATO, 2),
                    new Ingredient(ItemID.ONION, 2),
                    new Ingredient(ItemID.GNOME_SPICE, 1)
            ),
            ItemID.ALUFT_HALF_BAKED_VEG_BALL,
            ItemID.ALUFT_BAKED_VEG_BALL,
            new Ingredient(ItemID.EQUA_LEAVES, 1),
            ItemID.VEG_BALL)
    ),

    CHOCOLATE_SATURDAY(17, "Chocolate Saturday", createChocSaturdayRecipe()),

    BLURBERRY_SPECIAL(18, "Blurberry Special", createCocktailRecipe(
            List.of(
                    new Ingredient(ItemID.VODKA, 1),
                    new Ingredient(ItemID.BRANDY, 1),
                    new Ingredient(ItemID.GIN, 1),
                    new Ingredient(ItemID.LEMON, 2),
                    new Ingredient(ItemID.ORANGE, 1)
            ),
            ItemID.ALUFT_SHAKER_BLURBERRY_SPECIAL,
            List.of(
                    new Ingredient(ItemID.LEMON_CHUNKS, 1),
                    new Ingredient(ItemID.ORANGE_CHUNKS, 1),
                    new Ingredient(ItemID.EQUA_LEAVES, 1),
                    new Ingredient(ItemID.LIME_SLICES, 1)
            ),
            ItemID.BLURBERRY_SPECIAL)
    ),

    TANGLED_TOADS_LEGS(19, "Tangled Toads Legs", createBakedRecipe(
            BakedRecipeType.GNOMEBOWL,
            List.of(
                    new Ingredient(ItemID.TOADS_LEGS, 4),
                    new Ingredient(ItemID.GNOME_SPICE, 1),
                    new Ingredient(ItemID.CHEESE, 2),
                    new Ingredient(ItemID.DWELLBERRIES, 1),
                    new Ingredient(ItemID.EQUA_LEAVES, 2)
            ),
            ItemID.ALUFT_HALF_BAKED_TANGLED_TOADS_LEGS,
            ItemID.TANGLED_TOADS_LEGS)
    ),

    CHOCOLATE_BOMB(20, "Chocolate Bomb", createBakedRecipe(
            BakedRecipeType.GNOMEBOWL,
            List.of(
                    new Ingredient(ItemID.CHOCOLATE_BAR, 4),
                    new Ingredient(ItemID.EQUA_LEAVES, 1)
            ),
            ItemID.ALUFT_HALF_BAKED_CHOC_BOMB,
            ItemID.ALUFT_BAKED_CHOC_BOMB,
            List.of(
                    new Ingredient(ItemID.CHOCOLATE_DUST, 1),
                    new Ingredient(ItemID.POT_OF_CREAM, 2)
            ),
            ItemID.CHOCOLATE_BOMB)
    );

    private static final int NO_PRODUCED_ITEM_ID = -1;

    private final int id;
    private final String name;
    private final List<RecipeStep> steps;

    Order(int id, String name, List<RecipeStep> steps) {
        this.id = id;
        this.name = name;
        this.steps = steps;
    }

    /**
     * Return the item id of the final product
     **/
    public int getItemId() {
        int numSteps = steps.size();
        RecipeStep deliveryStep = steps.get(numSteps - 1);
        return deliveryStep.getIngredients().get(0).getItemId();
    }

    /**
     * Return raw ingredients used in a recipe at step number @stepIdx + 1
     **/
    public List<Ingredient> getNextRawIngredients(int stepIdx) {
        List<Ingredient> ingredients = new ArrayList<>();

        // Collect raw ingredients from each step
        int numSteps = steps.size();
        for (int i = stepIdx + 1; i < numSteps; i++) {
            List<Ingredient> rawIngredients = steps.get(i).getRawIngredients();
            ingredients.addAll(rawIngredients);
        }

        return ingredients;
    }

    public String getName() {
        return this.name;
    }

    public List<RecipeStep> getSteps() {
        return this.steps;
    }

    public static Order forId(int id) {
        for (var order : values()) {
            if (order.id == id) {
                return order;
            }
        }
        throw new InvalidParameterException("Order with id " + id + " not found");
    }
    // Cocktail recipe builders

    // Internal enum to create baked recipes

    private enum BakedRecipeType {
        CRUNCHIES(ItemID.RAW_CRUNCHIES, ItemID.CRUNCHY_TRAY, ItemID.HALF_BAKED_CRUNCHY),
        BATTA(ItemID.RAW_BATTA, ItemID.BATTA_TIN, ItemID.HALF_BAKED_BATTA),
        GNOMEBOWL(ItemID.RAW_GNOMEBOWL, ItemID.GNOMEBOWL_MOULD, ItemID.HALF_BAKED_BOWL);

        private final int rawId, toolId, halfBakedId;

        BakedRecipeType(int rawId, int toolId, int halfBakedId) {
            this.rawId = rawId;
            this.halfBakedId = halfBakedId;
            this.toolId = toolId;
        }

        public int getRawId() {
            return this.rawId;
        }

        public int getToolId() {
            return this.toolId;
        }

        public int getHalfBakedId() {
            return this.halfBakedId;
        }
    }

    /**
     * Partially create baked recipe. The steps are: raw item -> half baked item -> half made item
     *
     * @param ingredients Combined with half-baked item to create half-made item
     * @return Unfinished recipe
     */
    private static List<RecipeStep> createBakedRecipeHelper(BakedRecipeType bakedRecipeType, List<Ingredient> ingredients, int halfMadeId) {
        List<RecipeStep> unfinishedRecipe = new ArrayList<>();

        // Create raw item

        unfinishedRecipe.add(new RecipeStep(RecipeInstruction.CREATE_RAW,
                List.of(
                        new Ingredient(ItemID.GIANNE_DOUGH, 1),
                        new Ingredient(bakedRecipeType.getToolId(), 1)
                ),
                bakedRecipeType.getRawId())
        );

        // Raw item -> half baked item

        unfinishedRecipe.add(new RecipeStep(RecipeInstruction.CREATE_HALF_BAKED,
                new Ingredient(bakedRecipeType.getRawId(), 1, true),
                bakedRecipeType.getHalfBakedId())
        );

        // Half baked item -> half made item

        List<Ingredient> halfBakedIngredients = new ArrayList<>(ingredients);
        halfBakedIngredients.add(new Ingredient(bakedRecipeType.getHalfBakedId(), 1, true));

        unfinishedRecipe.add(new RecipeStep(RecipeInstruction.COMBINE_INGREDIENTS,
                halfBakedIngredients,
                halfMadeId));

        return unfinishedRecipe;
    }

    /**
     * Create baked recipe with no topped ingredients
     *
     * @param ingredients Combined with half-baked item to create half-made item
     * @param finishedId  Final product of recipe
     */
    private static List<RecipeStep> createBakedRecipe(BakedRecipeType bakedRecipeType, List<Ingredient> ingredients, int halfMadeId, int finishedId) {
        // Create raw item -> half baked item -> half made item

        List<RecipeStep> recipe = createBakedRecipeHelper(bakedRecipeType, ingredients, halfMadeId);

        // Half made item -> finished item

        recipe.add(new RecipeStep(RecipeInstruction.BAKE_HALF_MADE,
                new Ingredient(halfMadeId, 1, true),
                finishedId));

        // Deliver finished item

        recipe.add(new RecipeStep(RecipeInstruction.DELIVER, new Ingredient(finishedId, 1,
                true), NO_PRODUCED_ITEM_ID));

        return recipe;
    }

    /**
     * Create baked recipe with multiple topped ingredients
     *
     * @param firstIngredients   Combined with half-baked item to create half-made item
     * @param toppingIngredients Combined with unfinished item to create finished item
     * @param finishedId         Final product of recipe
     */
    private static List<RecipeStep> createBakedRecipe(
            BakedRecipeType bakedRecipeType,
            List<Ingredient> firstIngredients,
            int halfMadeId,
            int unfinishedId,
            List<Ingredient> toppingIngredients,
            int finishedId
    ) {
        // Create raw item -> half baked item -> half made item

        List<RecipeStep> recipe = createBakedRecipeHelper(bakedRecipeType, firstIngredients, halfMadeId);

        // Half made item -> unfinished item

        recipe.add(new RecipeStep(RecipeInstruction.BAKE_HALF_MADE,
                new Ingredient(halfMadeId, 1, true),
                unfinishedId));

        // unfinished item -> finished item

        List<Ingredient> unfinishedIngredients = new ArrayList<>();
        unfinishedIngredients.add(new Ingredient(unfinishedId, 1, true));
        unfinishedIngredients.addAll(toppingIngredients);

        recipe.add(new RecipeStep(RecipeInstruction.ADD_TOPPINGS,
                unfinishedIngredients,
                finishedId));

        // Deliver finished item

        recipe.add(new RecipeStep(RecipeInstruction.DELIVER, new Ingredient(finishedId, 1, true), NO_PRODUCED_ITEM_ID));

        return recipe;
    }

    /**
     * Create baked recipe with one topped ingredient
     *
     * @param firstIngredients  Combined with half-baked item to create half-made item
     * @param toppingIngredient Combined with unfinished item to create finished item
     * @param finishedId        Final product of recipe
     */
    private static List<RecipeStep> createBakedRecipe(
            BakedRecipeType bakedRecipeType,
            List<Ingredient> firstIngredients,
            int halfMadeId,
            int unfinishedId,
            Ingredient toppingIngredient,
            int finishedId
    ) {
        List<Ingredient> toppingIngredients = new ArrayList<>();
        toppingIngredients.add(toppingIngredient);

        return createBakedRecipe(bakedRecipeType, firstIngredients, halfMadeId, unfinishedId, toppingIngredients, finishedId);
    }

    // Cocktail recipe builders

    /**
     * Partially create cocktail recipe. Only adds the step to create mixed cocktail.
     **/
    private static List<RecipeStep> createCocktailRecipeHelper(List<Ingredient> shakedIngredients, int mixedItem) {
        List<RecipeStep> unfinishedRecipe = new ArrayList<>();

        List<Ingredient> mixIngredients = new ArrayList<>(shakedIngredients);
        mixIngredients.add(new Ingredient(ItemID.COCKTAIL_SHAKER, 1, true));

        unfinishedRecipe.add(new RecipeStep(RecipeInstruction.MIX_COCKTAIL,
                mixIngredients,
                mixedItem)
        );

        return unfinishedRecipe;
    }

    /**
     * Partially creates cocktail recipe. The steps are: mix cocktail -> pour
     *
     * @param isCompleteRecipe Flag that tells whether this is a complete or partial recipe
     */
    private static List<RecipeStep> createCocktailRecipeHelper(
            List<Ingredient> shakedIngredients,
            int mixedItem,
            List<Ingredient> pouredIngredients,
            int pouredItem,
            boolean isCompleteRecipe
    ) {
        // Create mixed cocktail

        List<RecipeStep> recipe = createCocktailRecipeHelper(shakedIngredients, mixedItem);

        // Mixed cocktail -> poured cocktail

        List<Ingredient> ingredients = new ArrayList<>();
        ingredients.add(new Ingredient(ItemID.COCKTAIL_GLASS_EMPTY, 1, true));
        ingredients.add(new Ingredient(mixedItem, 1, true));
        ingredients.addAll(pouredIngredients);

        recipe.add(new RecipeStep(RecipeInstruction.POUR,
                ingredients,
                pouredItem)
        );

        // Deliver poured item if we finished making the recipe item

        if (isCompleteRecipe) {
            recipe.add(new RecipeStep(RecipeInstruction.DELIVER, new Ingredient(pouredItem, 1,
                    true), NO_PRODUCED_ITEM_ID));
        }

        return recipe;
    }

    /**
     * Simple cocktail recipe with several poured ingredients
     **/
    private static List<RecipeStep> createCocktailRecipe(
            List<Ingredient> shakedIngredients,
            int mixedItem,
            List<Ingredient> pouredIngredients,
            int finishedItem
    ) {
        return createCocktailRecipeHelper(shakedIngredients, mixedItem, pouredIngredients, finishedItem, true);
    }

    /**
     * Simple cocktail recipe with one poured ingredient
     **/
    private static List<RecipeStep> createCocktailRecipe(
            List<Ingredient> shakedIngredients,
            int mixedItem,
            Ingredient pouredIngredient,
            int finishedItem
    ) {
        List<Ingredient> pouredIngredients = new ArrayList<>();
        pouredIngredients.add(pouredIngredient);

        return createCocktailRecipe(shakedIngredients, mixedItem, pouredIngredients, finishedItem);
    }

    // Heated cocktail recipes

    private static List<RecipeStep> createDrunkDragonRecipe() {
        // Create mixed cocktail -> poured cocktail

        List<Ingredient> shakedIngredients = List.of(
                new Ingredient(ItemID.VODKA, 1),
                new Ingredient(ItemID.GIN, 1),
                new Ingredient(ItemID.DWELLBERRIES, 1)
        );

        List<Ingredient> toppedIngredients = List.of(
                new Ingredient(ItemID.PINEAPPLE_CHUNKS, 1),
                new Ingredient(ItemID.POT_OF_CREAM, 1)
        );

        List<RecipeStep> recipe = createCocktailRecipeHelper(shakedIngredients, ItemID.ALUFT_SHAKER_DRUNK_DRAGON,
                List.of(), ItemID.ALUFT_SHAKER_DRUNK_DRAGON_PREFINISH, false);

        // Poured cocktail -> unfinished item

        List<Ingredient> unfinishedIngredients = new ArrayList<>();
        unfinishedIngredients.add(new Ingredient(ItemID.ALUFT_SHAKER_DRUNK_DRAGON_PREFINISH, 1, true));
        unfinishedIngredients.addAll(toppedIngredients);

        recipe.add(new RecipeStep(RecipeInstruction.ADD_TOPPINGS,
                unfinishedIngredients,
                ItemID.ALUFT_SHAKER_DRUNK_DRAGON_PREHEAT));

        // Unfinished item -> finished item

        recipe.add(new RecipeStep(RecipeInstruction.HEAT_COCKTAIL,
                new Ingredient(ItemID.ALUFT_SHAKER_DRUNK_DRAGON_PREHEAT, 1, true), ItemID.DRUNK_DRAGON));

        // Deliver finished item

        recipe.add(new RecipeStep(RecipeInstruction.DELIVER, new Ingredient(ItemID.DRUNK_DRAGON, 1,
                true), NO_PRODUCED_ITEM_ID));

        return recipe;
    }

    private static List<RecipeStep> createChocSaturdayRecipe() {
        // Create mixed cocktail -> poured cocktail

        List<Ingredient> shakedIngredients = List.of(
                new Ingredient(ItemID.WHISKY, 1),
                new Ingredient(ItemID.CHOCOLATE_BAR, 1),
                new Ingredient(ItemID.EQUA_LEAVES, 1),
                new Ingredient(ItemID.BUCKET_MILK, 1)
        );

        List<RecipeStep> recipe = createCocktailRecipeHelper(shakedIngredients, ItemID.ALUFT_SHAKER_CHOC_SATURDAY, List.of(), ItemID.ALUFT_SHAKER_CHOC_SATURDAY_PREHEAT, false);

        // poured cocktail -> unfinished item

        recipe.add(new RecipeStep(RecipeInstruction.HEAT_COCKTAIL,
                new Ingredient(ItemID.ALUFT_SHAKER_CHOC_SATURDAY_PREHEAT, 1, true), ItemID.ALUFT_SHAKER_CHOC_SATURDAY_HEATED));

        // unfinished item -> finished item

        List<Ingredient> ingredients = new ArrayList<>();
        ingredients.add(new Ingredient(ItemID.ALUFT_SHAKER_CHOC_SATURDAY_HEATED, 1, true));
        ingredients.add(new Ingredient(ItemID.CHOCOLATE_DUST, 1));
        ingredients.add(new Ingredient(ItemID.POT_OF_CREAM, 1));

        recipe.add(new RecipeStep(RecipeInstruction.ADD_TOPPINGS,
                ingredients,
                ItemID.CHOCOLATE_SATURDAY));

        // Deliver finished item

        recipe.add(new RecipeStep(RecipeInstruction.DELIVER, new Ingredient(ItemID.ALUFT_CHOC_SATURDAY, 1,
                true), NO_PRODUCED_ITEM_ID));

        return recipe;
    }
}

/*
 * Copyright (c) 2020, MMagicala <https://github.com/MMagicala>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.github.mmagicala.gnomeRestaurant.recipe;

public enum RecipeInstruction {
    CREATE_RAW("Create the raw batter"),
    CREATE_HALF_BAKED("Bake the raw batter"),
    COMBINE_INGREDIENTS("Combine ingredients"),
    BAKE_HALF_MADE("Bake item again"),
    ADD_TOPPINGS("Add topping ingredients"),

    MIX_COCKTAIL("Mix ingredients in the cocktail shaker"),
    POUR("Pour mix into the cocktail glass"),
    HEAT_COCKTAIL("Heat the cocktail"),

    DELIVER("Deliver the item to recipient");

    private final String overlayDirections;

    RecipeInstruction(String overlayDirections) {
        this.overlayDirections = overlayDirections;
    }

    public String getOverlayDirections() {
        return this.overlayDirections;
    }
}

/*
 * Copyright (c) 2020, MMagicala <https://github.com/MMagicala>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.github.mmagicala.gnomeRestaurant.recipe;

import java.util.ArrayList;
import java.util.List;

public class RecipeStep {

    private final RecipeInstruction instruction;
    private final List<Ingredient> ingredients;
    private final int producedItemId;

    public RecipeStep(RecipeInstruction instruction, List<Ingredient> ingredients, int producedItemId) {
        this.instruction = instruction;
        this.ingredients = ingredients;
        this.producedItemId = producedItemId;
    }

    // Step only requires one ingredient
    public RecipeStep(RecipeInstruction instruction, Ingredient ingredient, int producedItemId) {
        this(instruction, new ArrayList<>(), producedItemId);
        this.ingredients.add(ingredient);
    }

    public List<Ingredient> getRawIngredients() {
        List<Ingredient> rawIngredients = new ArrayList<>(ingredients);
        rawIngredients.removeIf(Ingredient::isIntermediate);
        return rawIngredients;
    }

    public RecipeInstruction getInstruction() {
        return this.instruction;
    }

    public List<Ingredient> getIngredients() {
        return this.ingredients;
    }

    public int getProducedItemId() {
        return this.producedItemId;
    }
}

/*
 * Copyright (c) 2020, MMagicala <https://github.com/MMagicala>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.github.mmagicala.gnomeRestaurant;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class GnomeRestaurantPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GnomeRestaurantPlugin.class);
		RuneLite.main(args);
	}
}
