/*
 * Copyright (c) 2020, MMagicala <https://github.com/MMagicala>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.github.mmagicala.gnomeRestaurant;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class GnomeRestaurantPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GnomeRestaurantPlugin.class);
		RuneLite.main(args);
	}
}
package io.github.mmagicala.gnomeRestaurant.order;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

public class OrderRecipient
{
	@Getter
	private final String addressedName, inGameName;

	@Getter
	private final OrderDifficulty difficulty;

	@Getter
	private WorldPoint location;

	/** Gianne jnr uses the same name as this NPC's in-game name **/
	public OrderRecipient(String addressedName, OrderDifficulty difficulty, WorldPoint location)
	{
		this(addressedName, addressedName, difficulty, location);
	}

	/** Gianne jnr uses a different name from this NPC's in-game name **/
	public OrderRecipient(String addressedName, String inGameName, OrderDifficulty difficulty, WorldPoint location)
	{
		this.addressedName = addressedName;
		this.inGameName = inGameName;
		this.difficulty = difficulty;
		this.location = location;
	}
}

package io.github.mmagicala.gnomeRestaurant.order;

public enum OrderDifficulty
{
	EASY, HARD
}

/*
 * Copyright (c) 2020, MMagicala <https://github.com/MMagicala>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.github.mmagicala.gnomeRestaurant;

import com.google.inject.Provides;
import io.github.mmagicala.gnomeRestaurant.data.OrderRecipients;
import io.github.mmagicala.gnomeRestaurant.data.Recipes;
import io.github.mmagicala.gnomeRestaurant.order.OrderDifficulty;
import io.github.mmagicala.gnomeRestaurant.order.OrderRecipient;
import io.github.mmagicala.gnomeRestaurant.overlay.GnomeRestaurantOverlay;
import io.github.mmagicala.gnomeRestaurant.overlay.OverlayHeader;
import io.github.mmagicala.gnomeRestaurant.overlay.OverlayTableEntry;
import io.github.mmagicala.gnomeRestaurant.recipe.Ingredient;
import io.github.mmagicala.gnomeRestaurant.recipe.Recipe;
import java.security.InvalidParameterException;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.inject.Named;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.ui.overlay.infobox.Timer;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;

@Slf4j
@PluginDescriptor(
	name = "Gnome Restaurant"
)
public class GnomeRestaurantPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private GnomeRestaurantConfig config;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ClientThread clientThread;

	@Inject
	private WorldMapPointManager worldMapPointManager;

	// UI

	private Timer timer;
	private Overlay overlay;
	private WorldMapPoint worldMapPoint;

	private String tooltipText;

	// Flags

	@Inject
	@Named("developerMode")
	boolean developerMode;

	private static final int VARBIT_IS_DELIVERING = 2478;

	private boolean isDelayed = false;

	// Current order information

	private Recipe recipe;
	private OrderRecipient recipient;
	private int stepIdx;

	// Overlay

	private final OverlayHeader overlayHeader = new OverlayHeader("null", -1, -1);
	private final ArrayList<OverlayTableEntry> stepIngredientsOverlayTable = new ArrayList<>();
	private final ArrayList<OverlayTableEntry> nextRawIngredientsOverlayTable = new ArrayList<>();

	// Gianne jr. dialogue

	private static final Pattern DELIVERY_START_PATTERN = Pattern.compile("([\\w .]+) wants (?:some|a) ([\\w ]+)");
	private static final String EASY_DELIVERY_CANCEL_TEXT = "Fine, your loss. If you want another easy job one come " +
		"back in five minutes and maybe I'll be able to find you one.";
	private static final String HARD_DELIVERY_CANCEL_TEXT = "Fine, your loss. I may have an easier job for you, since" +
		" you chickened out of that one, If you want another hard one come back in five minutes and maybe I'll be" +
		" able to find you a something.";

	@Override
	protected void shutDown() throws Exception
	{
		resetPlugin();
	}

	private void resetPlugin()
	{
		removeTimer();
		removeOverlay();
		removeWorldMapPoint();
		client.clearHintArrow();

		stepIdx = 0;

		isDelayed = false;

		recipe = null;
		recipient = null;
	}

	// Monitor dialogue for Gianne jnr's new order
	@Subscribe
	public void onGameTick(GameTick event)
	{
		boolean isDialogueOpen = client.getWidget(WidgetInfo.DIALOG_NPC_NAME) != null;
		if (!isDialogueOpen)
		{
			return;
		}

		boolean isTalkingToGianneJnr = client.getWidget(WidgetInfo.DIALOG_NPC_NAME).getText().equals("Gianne jnr.");
		if (!isTalkingToGianneJnr)
		{
			return;
		}

		String dialog = client.getWidget(WidgetInfo.DIALOG_NPC_TEXT).getText();
		// Treat dialogue as a single line
		dialog = dialog.replace("<br>", " ");
		Matcher matcher = DELIVERY_START_PATTERN.matcher(dialog);

		if (matcher.find())
		{
			final String matchedRecipient = matcher.group(1);
			final String matchedRecipe = matcher.group(2);

			if (recipient != null && recipient.getAddressedName().equals(matchedRecipient)
				&& recipe != null && recipe.getName().equals(matchedRecipe))
			{
				// We are still viewing the same delivery as is already recorded
				return;
			}

			// Configure plugin
			resetPlugin();
			startPlugin(matchedRecipient, matchedRecipe);
		}

		boolean playerCancelledOrder = dialog.contains(EASY_DELIVERY_CANCEL_TEXT) ||
			dialog.contains(HARD_DELIVERY_CANCEL_TEXT);

		if (config.showDelayTimer() && !isDelayed && playerCancelledOrder)
		{
			cancelOrder();
		}
	}

	private void cancelOrder()
	{
		resetPlugin();

		setupDelayTimer();
		isDelayed = true;
	}

	private void startPlugin(String recipientName, String recipeName)
	{
		parseOrder(recipientName, recipeName);
		updateStep();
		setupUI();
	}

	private void setupDelayTimer()
	{
		timer = new Timer(5, ChronoUnit.MINUTES, itemManager.getImage(ItemID.ALUFT_ALOFT_BOX), this);
		timer.setTooltip("Cannot place an order at this time");
		infoBoxManager.addInfoBox(timer);
	}

	private void parseOrder(String addressedName, String recipeName)
	{
		recipe = Recipes.getRecipe(recipeName);
		recipient = OrderRecipients.getRecipient(addressedName);
	}

	/**
	 * Update the step we are working on in the recipe
	 * Returns whether step has been updated or not
	 **/
	private boolean updateStep()
	{
		// Go from beginning of recipe to final item produced

		int newStepIdx = 0;

		for (int i = 0; i < recipe.getSteps().size() - 1; i++)
		{
			int producedId = recipe.getSteps().get(i).getProducedItemId();
			if (getItemCount(producedId) > 0)
			{
				// We produced the item for this step
				newStepIdx = i + 1;
			}
		}

		boolean stepUpdated = false;

		if (newStepIdx != stepIdx)
		{
			stepUpdated = true;
		}

		stepIdx = newStepIdx;
		return stepUpdated;
	}

	private int getItemCount(int itemId)
	{
		// Assume the inventory is empty (and player just logged in) if it is null
		ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);

		if (inventory == null)
		{
			return 0;
		}
		else
		{
			return inventory.count(itemId);
		}
	}

	private void setupUI()
	{
		tooltipText = "Deliver " + recipe.getName() + " to " + recipient.getInGameName();

		if (config.showOverlay())
		{
			setupOverlay();
		}

		if (config.showOrderTimer())
		{
			setupOrderTimer();
		}

		// Draw hint arrow if we can immediately find the NPC

		if (config.showHintArrow())
		{
			showHintArrow();
		}

		if (config.showWorldMapPoint())
		{
			showWorldMapPoint();
		}
	}

	private void setupOverlay()
	{
		// Overlay contents
		updateOverlayHeader();
		rebuildOverlayTables();

		// Display overlay
		overlay = new GnomeRestaurantOverlay(this, overlayHeader, stepIngredientsOverlayTable,
			nextRawIngredientsOverlayTable);
		overlayManager.add(overlay);
	}

	private void setupOrderTimer()
	{
		int numSecondsLeft;

		if (recipient.getDifficulty() == OrderDifficulty.HARD)
		{
			numSecondsLeft = 660;
		}
		else
		{
			numSecondsLeft = 360;
		}

		timer = new Timer(numSecondsLeft, ChronoUnit.SECONDS, itemManager.getImage(recipe.getItemId()),
			this);
		timer.setTooltip(tooltipText);

		infoBoxManager.addInfoBox(timer);
	}

	private void showHintArrow()
	{
		if (!markNPCInCache())
		{
			// NPC not in sight
			// Show hint arrow in mini map instead
			client.setHintArrow(recipient.getLocation());
		}
	}

	private void showWorldMapPoint()
	{
		worldMapPoint = new WorldMapPoint(recipient.getLocation(), itemManager.getImage(ItemID.ALUFT_ALOFT_BOX));
		worldMapPoint.setSnapToEdge(true);
		worldMapPoint.setJumpOnClick(true);
		worldMapPoint.setTooltip(tooltipText);
		worldMapPointManager.add(worldMapPoint);
	}

	/**
	 * Mark the recipient if they are in the surrounding area
	 *
	 * @return true if recipient was marked
	 */
	private boolean markNPCInCache()
	{
		List<NPC> npcs = client.getNpcs();

		for (NPC npc : npcs)
		{
			if (npc.getName() == null)
			{
				continue;
			}

			if (npc.getName().equals(recipient.getInGameName()))
			{
				client.setHintArrow(npc);
				return true;
			}
		}
		return false;
	}

	// Mark matching NPC that shows up

	@Subscribe
	public void onNpcSpawned(final NpcSpawned event)
	{
		// TODO: use ID instead of name

		if (event.getNpc() == null || event.getNpc().getName() == null)
		{
			return;
		}

		if (recipe != null && event.getNpc().getName().equals(recipient.getInGameName()) && config.showHintArrow())
		{
			client.setHintArrow(event.getNpc());
		}
	}

	// Revert to marking world point if NPC disappears

	@Subscribe
	public void onNpcDespawned(final NpcDespawned event)
	{
		if (event.getNpc() == null || event.getNpc().getName() == null)
		{
			return;
		}

		if (recipe != null && event.getNpc().getName().equals(recipient.getInGameName()) && config.showHintArrow())
		{
			client.setHintArrow(recipient.getLocation());
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		if (recipe != null && client.getVarbitValue(VARBIT_IS_DELIVERING) == 0)
		{
			// Delivery successful or failed
			resetPlugin();
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		if (overlay != null)
		{
			if (event.getContainerId() != InventoryID.INVENTORY.getId())
			{
				return;
			}

			// Has player finished a step?

			if (updateStep())
			{
				updateOverlayHeader();
				rebuildOverlayTables();
			}
			else
			{
				updateOverlayTables();
			}
		}
	}

	private void updateOverlayHeader()
	{
		overlayHeader.instruction = recipe.getSteps().get(stepIdx).getInstruction().getOverlayDirections();
		overlayHeader.stepNum = stepIdx + 1;
		overlayHeader.totalSteps = recipe.getSteps().size();
	}

	private void rebuildOverlayTables()
	{
		clearOverlayTables();

		ArrayList<Ingredient> stepIngredients = recipe.getSteps().get(stepIdx).getIngredients();
		rebuildOverlayTable(stepIngredients, stepIngredientsOverlayTable);

		ArrayList<Ingredient> nextRawIngredients = recipe.getNextRawIngredients(stepIdx);
		rebuildOverlayTable(nextRawIngredients, nextRawIngredientsOverlayTable);
	}

	private void rebuildOverlayTable(ArrayList<Ingredient> ingredients,
									 ArrayList<OverlayTableEntry> overlayTable)
	{
		for (Ingredient ingredient : ingredients)
		{
			int itemId = ingredient.getItemId();
			String itemName = itemManager.getItemComposition(itemId).getName();
			int inventoryCount = getItemCount(itemId);
			int expectedCount = ingredient.getCount();

			overlayTable.add(new OverlayTableEntry(itemId, itemName, inventoryCount, expectedCount));
		}
	}

	private void updateOverlayTables()
	{
		updateOverlayTable(stepIngredientsOverlayTable);
		updateOverlayTable(nextRawIngredientsOverlayTable);
	}

	private void updateOverlayTable(ArrayList<OverlayTableEntry> overlayTable)
	{
		for (OverlayTableEntry entry : overlayTable)
		{
			int inventoryCount = getItemCount(entry.getItemId());
			if (entry.getInventoryCount() != inventoryCount)
			{
				entry.setInventoryCount(inventoryCount);
			}
		}
	}

	// Config

	@Provides
	GnomeRestaurantConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(GnomeRestaurantConfig.class);
	}

	// Config group keys

	public static final String SHOW_DELAY_TIMER = "showDelayTimer";
	public static final String SHOW_ORDER_TIMER = "showOrderTimer";
	public static final String SHOW_OVERLAY = "showOverlay";
	public static final String SHOW_HINT_ARROW = "showHintArrow";
	public static final String SHOW_WORLD_MAP_POINT = "showWorldMapPoint";

	/**
	 * Monitor changes to plugin config and update the plugin accordingly
	 *
	 * @param event indicates the setting that was changed and its new value
	 */
	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (recipe != null)
		{
			if (event.getKey().equals(SHOW_ORDER_TIMER))
			{
				if (event.getNewValue().equals("false"))
				{
					removeTimer();
				}
			}
			else if (event.getKey().equals(SHOW_OVERLAY))
			{
				if (event.getNewValue().equals("false"))
				{
					removeOverlay();
				}
				else
				{
					// Must be called from client thread
					clientThread.invoke(this::setupOverlay);
				}
			}
			else if (event.getKey().equals(SHOW_HINT_ARROW))
			{
				if (event.getNewValue().equals("false"))
				{
					client.clearHintArrow();
				}
				else
				{
					showHintArrow();
				}
			}
			else if (event.getKey().equals(SHOW_WORLD_MAP_POINT))
			{
				if (event.getNewValue().equals("false"))
				{
					removeWorldMapPoint();
				}
				else
				{
					showWorldMapPoint();
				}
			}
		}
		else
		{
			if (!event.getGroup().equals("gnomerestaurant"))
			{
				// This plugin's config has not changed
				return;
			}
			else if (event.getKey().equals(SHOW_DELAY_TIMER) && isDelayed)
			{
				if (event.getNewValue().equals("false"))
				{
					removeTimer();
				}
			}
		}
	}

	// UI cleaning

	private void removeTimer()
	{
		infoBoxManager.removeInfoBox(timer);
		timer = null;
	}

	private void removeOverlay()
	{
		clearOverlayTables();
		overlayManager.remove(overlay);
		overlay = null;
	}

	private void removeWorldMapPoint()
	{
		worldMapPointManager.remove(worldMapPoint);
		worldMapPoint = null;
	}

	private void clearOverlayTables()
	{
		stepIngredientsOverlayTable.clear();
		nextRawIngredientsOverlayTable.clear();
	}

	// Plugin testing

	@Subscribe
	public void onCommandExecuted(CommandExecuted commandExecuted)
	{
		// Must be in developer mode to send command

		if (!developerMode)
		{
			return;
		}

		// Not the right command

		if (!commandExecuted.getCommand().equals("gnome"))
		{
			return;
		}

		// Invalid command usage

		if (commandExecuted.getArguments().length < 1)
		{
			printUsage();
			return;
		}

		if (commandExecuted.getArguments()[0].equals("reset"))
		{
			resetTestOrder();
			return;
		}
		else if (commandExecuted.getArguments()[0].equals("cancel"))
		{
			cancelTestOrder();
			return;
		}

		if (commandExecuted.getArguments().length < 2)
		{
			printUsage();
			return;
		}

		if (recipe != null)
		{
			printChatMessage("Cannot test an order while another delivery is in progress");
			return;
		}

		String recipientName = commandExecuted.getArguments()[0].replace("_", " ");
		String recipeName = commandExecuted.getArguments()[1].replace("_", " ");

		printChatMessage("Testing order with recipient: '" + recipientName + "' and recipe '" + recipeName + "'");

		try
		{
			startPlugin(recipientName, recipeName);
		}
		catch (InvalidParameterException e)
		{
			resetTestOrder();
			printChatMessage("Error: InvalidParameterException caught: " + e.getMessage());
		}

		// Manually set varbit to simulate real order
		client.setVarbitValue(client.getVarps(), VARBIT_IS_DELIVERING, 1);
	}

	private void cancelTestOrder()
	{
		cancelOrder();
		client.setVarbitValue(client.getVarps(), VARBIT_IS_DELIVERING, 0);
		printChatMessage("Order cancelled");
	}

	private void resetTestOrder()
	{
		resetPlugin();
		client.setVarbitValue(client.getVarps(), VARBIT_IS_DELIVERING, 0);
		printChatMessage("Plugin reset");
	}

	private void printUsage()
	{
		printChatMessage("Usage '::gnome npc_addressed_name recipe_name'");
		printChatMessage("Usage '::gnome reset'");
	}

	private void printChatMessage(String message)
	{
		chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).value(message).build());
	}
}

package io.github.mmagicala.gnomeRestaurant.data;

import io.github.mmagicala.gnomeRestaurant.order.OrderDifficulty;
import io.github.mmagicala.gnomeRestaurant.order.OrderRecipient;
import java.security.InvalidParameterException;
import java.util.ArrayList;
import net.runelite.api.coords.WorldPoint;

public class OrderRecipients
{
	public static final ArrayList<OrderRecipient> list = new ArrayList<OrderRecipient>()
	{
		{
			add(new OrderRecipient("Burkor", OrderDifficulty.EASY, new WorldPoint(2420, 3474, 0)));
			add(new OrderRecipient("Brimstail", OrderDifficulty.EASY, new WorldPoint(2409, 9817, 0)));
			add(new OrderRecipient("Captain Errdo", OrderDifficulty.EASY, new WorldPoint(2464, 3501, 0)));
			add(new OrderRecipient("Coach", "Gnome Coach", OrderDifficulty.EASY, new WorldPoint(2406, 3498, 0)));
			add(new OrderRecipient("Dalila", OrderDifficulty.EASY, new WorldPoint(2448, 3500, 0)));
			add(new OrderRecipient("Damwin", OrderDifficulty.EASY, new WorldPoint(2417, 3496, 0)));
			add(new OrderRecipient("Eebel", OrderDifficulty.EASY, new WorldPoint(2416, 3414, 0)));
			add(new OrderRecipient("Ermin", OrderDifficulty.EASY, new WorldPoint(2488, 3409, 0)));
			add(new OrderRecipient("Femi", OrderDifficulty.EASY, new WorldPoint(2459, 3382, 0)));
			add(new OrderRecipient("Froono", OrderDifficulty.EASY, new WorldPoint(2435, 3403, 0)));
			add(new OrderRecipient("Guard Vemmeldo", OrderDifficulty.EASY, new WorldPoint(2446, 3418, 0)));
			add(new OrderRecipient("Gulluck", OrderDifficulty.EASY, new WorldPoint(2468, 3487, 0)));
			add(new OrderRecipient("His Royal Highness King Narnode", "King Narnode Shareen",
				OrderDifficulty.EASY, new WorldPoint(2466, 3497, 0)));
			add(new OrderRecipient("Meegle", OrderDifficulty.EASY, new WorldPoint(2378, 3433, 0)));
			add(new OrderRecipient("Perrdur", OrderDifficulty.EASY, new WorldPoint(2447, 3501, 0)));
			add(new OrderRecipient("Rometti", OrderDifficulty.EASY, new WorldPoint(2482, 3510, 0)));
			add(new OrderRecipient("Sarble", OrderDifficulty.EASY, new WorldPoint(2417, 3517, 0)));
			add(new OrderRecipient("Trainer Nacklepen", OrderDifficulty.EASY, new WorldPoint(2421, 3525, 0)));
			add(new OrderRecipient("Wurbel", OrderDifficulty.EASY, new WorldPoint(2395, 3477, 0)));
			add(new OrderRecipient("Heckel Funch", OrderDifficulty.EASY, new WorldPoint(2493, 3488, 0)));

			// Hard NPCs
			add(new OrderRecipient("Ambassador Ferrnook", OrderDifficulty.HARD, new WorldPoint(3209, 3474, 0)));
			add(new OrderRecipient("Ambassador Gimblewap", OrderDifficulty.HARD, new WorldPoint(2572, 3299, 0)));
			add(new OrderRecipient("Ambassador Spanfipple", OrderDifficulty.HARD, new WorldPoint(2984, 3342, 0)));
			add(new OrderRecipient("Brambickle", OrderDifficulty.HARD, new WorldPoint(2786, 3862, 0)));
			add(new OrderRecipient("Captain Bleemadge", OrderDifficulty.HARD, new WorldPoint(2847, 3499, 0)));
			add(new OrderRecipient("Captain Daerkin", OrderDifficulty.HARD, new WorldPoint(3362, 3222, 0)));
			add(new OrderRecipient("Captain Dalbur", OrderDifficulty.HARD, new WorldPoint(3284, 3212, 0)));
			add(new OrderRecipient("Captain Klemfoodle", OrderDifficulty.HARD, new WorldPoint(2970, 2973, 0)));
			add(new OrderRecipient("Captain Ninto", OrderDifficulty.HARD, new WorldPoint(2869, 9877, 0)));
			add(new OrderRecipient("G.L.O Caranock", "G.L.O. Caranock", OrderDifficulty.HARD, new WorldPoint(2956, 3025, 0)));
			add(new OrderRecipient("Garkor", OrderDifficulty.HARD, new WorldPoint(2434, 3519, 0)));
			add(new OrderRecipient("Gnormadium Avlafrim", OrderDifficulty.HARD, new WorldPoint(2544, 2973, 0)));
			add(new OrderRecipient("Hazelmere", OrderDifficulty.HARD, new WorldPoint(2678, 3086, 0)));
			add(new OrderRecipient("King Bolren", OrderDifficulty.HARD, new WorldPoint(2542, 3169, 0)));
			add(new OrderRecipient("Lieutenant Schepbur", OrderDifficulty.HARD, new WorldPoint(2515, 3205, 0)));
			add(new OrderRecipient("Penwie", OrderDifficulty.HARD, new WorldPoint(2932, 2972, 0)));
			add(new OrderRecipient("Professor Imblewyn", OrderDifficulty.HARD, new WorldPoint(2590, 3092, 0)));
			add(new OrderRecipient("Professor Manglethorp", OrderDifficulty.HARD, new WorldPoint(2868, 10198, 0)));
			add(new OrderRecipient("Professor Onglewip", OrderDifficulty.HARD, new WorldPoint(3115, 3160, 0)));
			add(new OrderRecipient("Wingstone", OrderDifficulty.HARD, new WorldPoint(3380, 2893, 0)));
		}
	};

	public static OrderRecipient getRecipient(String addressedName)
	{
		for (OrderRecipient npc: list)
		{
			if (npc.getAddressedName().equals(addressedName))
			{
				return npc;
			}
		}

		throw new InvalidParameterException("No recipient found with the name " + addressedName);
	}
}

package io.github.mmagicala.gnomeRestaurant.data;

import io.github.mmagicala.gnomeRestaurant.recipe.Ingredient;
import io.github.mmagicala.gnomeRestaurant.recipe.RecipeInstruction;
import io.github.mmagicala.gnomeRestaurant.recipe.Recipe;
import io.github.mmagicala.gnomeRestaurant.recipe.RecipeStep;
import java.security.InvalidParameterException;
import java.util.ArrayList;
import lombok.Getter;
import net.runelite.api.ItemID;

public class Recipes
{
	private static final int NO_PRODUCED_ITEM_ID = -1;

	public static final ArrayList<Recipe> list = new ArrayList<Recipe>()
	{
		{
			// Gnomebowls

			add(new Recipe("worm hole", createBakedRecipe(
				BakedRecipeType.GNOMEBOWL,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.KING_WORM, 4));
						add(new Ingredient(ItemID.ONION, 2));
						add(new Ingredient(ItemID.GNOME_SPICE, 1));
					}
				},
				ItemID.HALF_MADE_BOWL_9559,
				ItemID.UNFINISHED_BOWL_9560,
				new Ingredient(ItemID.EQUA_LEAVES, 1),
				ItemID.WORM_HOLE)
			));

			add(new Recipe("vegetable ball", createBakedRecipe(
				BakedRecipeType.GNOMEBOWL,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.POTATO, 2));
						add(new Ingredient(ItemID.ONION, 2));
						add(new Ingredient(ItemID.GNOME_SPICE, 1));
					}
				},
				ItemID.HALF_MADE_BOWL_9561,
				ItemID.UNFINISHED_BOWL_9562,
				new Ingredient(ItemID.EQUA_LEAVES, 1),
				ItemID.VEG_BALL)
			));

			add(new Recipe("tangled toads legs", createBakedRecipe(
				BakedRecipeType.GNOMEBOWL,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.TOADS_LEGS, 4));
						add(new Ingredient(ItemID.GNOME_SPICE, 1));
						add(new Ingredient(ItemID.CHEESE, 2));
						add(new Ingredient(ItemID.DWELLBERRIES, 1));
						add(new Ingredient(ItemID.EQUA_LEAVES, 2));
					}
				},
				ItemID.HALF_MADE_BOWL,
				ItemID.TANGLED_TOADS_LEGS)
			));

			add(new Recipe("chocolate bomb", createBakedRecipe(
				BakedRecipeType.GNOMEBOWL,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.CHOCOLATE_BAR, 4));
						add(new Ingredient(ItemID.EQUA_LEAVES, 1));
					}
				},
				ItemID.HALF_MADE_BOWL_9563,
				ItemID.UNFINISHED_BOWL_9564,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.CHOCOLATE_DUST, 1));
						add(new Ingredient(ItemID.POT_OF_CREAM, 2));
					}
				},
				ItemID.CHOCOLATE_BOMB)
			));

			// Battas

			add(new Recipe("fruit batta", createBakedRecipe(
				BakedRecipeType.BATTA,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.EQUA_LEAVES, 4));
						add(new Ingredient(ItemID.LIME_CHUNKS, 1));
						add(new Ingredient(ItemID.ORANGE_CHUNKS, 1));
						add(new Ingredient(ItemID.PINEAPPLE_CHUNKS, 1));
					}
				},
				ItemID.HALF_MADE_BATTA,
				ItemID.UNFINISHED_BATTA_9479,
				new Ingredient(ItemID.GNOME_SPICE, 1),
				ItemID.FRUIT_BATTA)
			));

			add(new Recipe("toad batta", createBakedRecipe(
				BakedRecipeType.BATTA,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.EQUA_LEAVES, 1));
						add(new Ingredient(ItemID.GNOME_SPICE, 1));
						add(new Ingredient(ItemID.CHEESE, 1));
						add(new Ingredient(ItemID.TOADS_LEGS, 1));
					}
				},
				ItemID.HALF_MADE_BATTA_9482,
				ItemID.TOAD_BATTA)
			));

			add(new Recipe("worm batta", createBakedRecipe(
				BakedRecipeType.BATTA,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.KING_WORM, 1));
						add(new Ingredient(ItemID.CHEESE, 1));
						add(new Ingredient(ItemID.GNOME_SPICE, 1));
					}
				},
				ItemID.HALF_MADE_BATTA_9480,
				ItemID.UNFINISHED_BATTA_9481,
				new Ingredient(ItemID.EQUA_LEAVES, 1),
				ItemID.WORM_BATTA)
			));

			add(new Recipe("vegetable batta", createBakedRecipe(
				BakedRecipeType.BATTA,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.TOMATO, 2));
						add(new Ingredient(ItemID.DWELLBERRIES, 1));
						add(new Ingredient(ItemID.ONION, 1));
						add(new Ingredient(ItemID.CHEESE, 1));
						add(new Ingredient(ItemID.CABBAGE, 1));
					}
				},
				ItemID.HALF_MADE_BATTA_9485,
				ItemID.UNFINISHED_BATTA_9486,
				new Ingredient(ItemID.EQUA_LEAVES, 1),
				ItemID.VEGETABLE_BATTA)
			));

			add(new Recipe("cheese and tomato batta", createBakedRecipe(
				BakedRecipeType.BATTA,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.CHEESE, 1));
						add(new Ingredient(ItemID.TOMATO, 1));
					}
				},
				ItemID.HALF_MADE_BATTA_9483,
				ItemID.UNFINISHED_BATTA_9484,
				new Ingredient(ItemID.EQUA_LEAVES, 1),
				ItemID.CHEESETOM_BATTA)
			));

			// Crunchies

			add(new Recipe("choc chip crunchies", createBakedRecipe(
				BakedRecipeType.CRUNCHIES,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.CHOCOLATE_BAR, 2));
						add(new Ingredient(ItemID.GNOME_SPICE, 1));
					}
				},
				ItemID.HALF_MADE_CRUNCHY,
				ItemID.UNFINISHED_CRUNCHY_9578,
				new Ingredient(ItemID.CHOCOLATE_DUST, 1),
				ItemID.CHOCCHIP_CRUNCHIES)
			));

			add(new Recipe("spicy crunchies", createBakedRecipe(
				BakedRecipeType.CRUNCHIES,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.EQUA_LEAVES, 2));
						add(new Ingredient(ItemID.GNOME_SPICE, 1));
					}
				},
				ItemID.HALF_MADE_CRUNCHY_9579,
				ItemID.UNFINISHED_CRUNCHY_9580,
				new Ingredient(ItemID.GNOME_SPICE, 1),
				ItemID.SPICY_CRUNCHIES)
			));

			add(new Recipe("toad crunchies", createBakedRecipe(
				BakedRecipeType.CRUNCHIES,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.TOADS_LEGS, 2));
						add(new Ingredient(ItemID.GNOME_SPICE, 1));
					}
				},
				ItemID.HALF_MADE_CRUNCHY_9581,
				ItemID.UNFINISHED_CRUNCHY_9582,
				new Ingredient(ItemID.EQUA_LEAVES, 1),
				ItemID.TOAD_CRUNCHIES)
			));

			add(new Recipe("worm crunchies", createBakedRecipe(
				BakedRecipeType.CRUNCHIES,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.KING_WORM, 2));
						add(new Ingredient(ItemID.GNOME_SPICE, 1));
						add(new Ingredient(ItemID.EQUA_LEAVES, 1));
					}
				},
				ItemID.HALF_MADE_CRUNCHY_9583,
				ItemID.UNFINISHED_CRUNCHY_9584,
				new Ingredient(ItemID.GNOME_SPICE, 1),
				ItemID.WORM_CRUNCHIES)
			));

			// Cocktails

			add(new Recipe("fruit blast", createCocktailRecipe(
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.PINEAPPLE, 1));
						add(new Ingredient(ItemID.LEMON, 1));
						add(new Ingredient(ItemID.ORANGE, 1));
					}
				},
				ItemID.MIXED_BLAST,
				new Ingredient(ItemID.LEMON_SLICES, 1),
				ItemID.FRUIT_BLAST)
			));

			add(new Recipe("pineapple punch", createCocktailRecipe(
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.PINEAPPLE, 2));
						add(new Ingredient(ItemID.LEMON, 1));
						add(new Ingredient(ItemID.ORANGE, 1));
					}
				},
				ItemID.MIXED_PUNCH,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.LIME_CHUNKS, 1));
						add(new Ingredient(ItemID.PINEAPPLE_CHUNKS, 1));
						add(new Ingredient(ItemID.ORANGE_SLICES, 1));
					}
				},
				ItemID.PINEAPPLE_PUNCH)
			));

			add(new Recipe("wizard blizzard", createCocktailRecipe(
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.VODKA, 2));
						add(new Ingredient(ItemID.GIN, 1));
						add(new Ingredient(ItemID.LIME, 1));
						add(new Ingredient(ItemID.LEMON, 1));
						add(new Ingredient(ItemID.ORANGE, 1));
					}
				},
				ItemID.MIXED_BLIZZARD,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.PINEAPPLE_CHUNKS, 1));
						add(new Ingredient(ItemID.LIME_SLICES, 1));
					}
				},
				ItemID.WIZARD_BLIZZARD)
			));

			add(new Recipe("short green guy", createCocktailRecipe(
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.VODKA, 1));
						add(new Ingredient(ItemID.LIME, 3));
					}
				},
				ItemID.MIXED_SGG,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.LIME_SLICES, 1));
						add(new Ingredient(ItemID.EQUA_LEAVES, 1));
					}
				},
				ItemID.SHORT_GREEN_GUY)
			));

			add(new Recipe("drunk dragon", createDrunkDragonRecipe()));
			add(new Recipe("chocolate saturday", createChocSaturdayRecipe()));

			add(new Recipe("Blurberry special", createCocktailRecipe(
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.VODKA, 1));
						add(new Ingredient(ItemID.BRANDY, 1));
						add(new Ingredient(ItemID.GIN, 1));
						add(new Ingredient(ItemID.LEMON, 2));
						add(new Ingredient(ItemID.ORANGE, 1));
					}
				},
				ItemID.MIXED_SPECIAL,
				new ArrayList<Ingredient>()
				{
					{
						add(new Ingredient(ItemID.LEMON_CHUNKS, 1));
						add(new Ingredient(ItemID.ORANGE_CHUNKS, 1));
						add(new Ingredient(ItemID.EQUA_LEAVES, 1));
						add(new Ingredient(ItemID.LIME_SLICES, 1));
					}
				},
				ItemID.BLURBERRY_SPECIAL)
			));
		}
	};

	// Cocktail recipe builders

	// Internal enum to create baked recipes

	private enum BakedRecipeType
	{
		CRUNCHIES(ItemID.RAW_CRUNCHIES, ItemID.CRUNCHY_TRAY, ItemID.HALF_BAKED_CRUNCHY),
		BATTA(ItemID.RAW_BATTA, ItemID.BATTA_TIN, ItemID.HALF_BAKED_BATTA),
		GNOMEBOWL(ItemID.RAW_GNOMEBOWL, ItemID.GNOMEBOWL_MOULD, ItemID.HALF_BAKED_BOWL);

		@Getter
		private int rawId, toolId, halfBakedId;

		BakedRecipeType(int rawId, int toolId, int halfBakedId)
		{
			this.rawId = rawId;
			this.halfBakedId = halfBakedId;
			this.toolId = toolId;
		}
	}

	/**
	 * Partially create baked recipe. The steps are: raw item -> half baked item -> half made item
	 *
	 * @param ingredients Combined with half-baked item to create half-made item
	 * @return Unfinished recipe
	 */
	private static ArrayList<RecipeStep> createBakedRecipeHelper(BakedRecipeType bakedRecipeType,
																 ArrayList<Ingredient> ingredients, int halfMadeId)
	{
		ArrayList<RecipeStep> unfinishedRecipe = new ArrayList<>();

		// Create raw item

		unfinishedRecipe.add(new RecipeStep(RecipeInstruction.CREATE_RAW,
			new ArrayList<Ingredient>()
			{
				{
					add(new Ingredient(ItemID.GIANNE_DOUGH, 1));
					add(new Ingredient(bakedRecipeType.getToolId(), 1));
				}
			},
			bakedRecipeType.getRawId())
		);

		// Raw item -> half baked item

		unfinishedRecipe.add(new RecipeStep(RecipeInstruction.CREATE_HALF_BAKED,
			new Ingredient(bakedRecipeType.getRawId(), 1, true),
			bakedRecipeType.getHalfBakedId())
		);

		// Half baked item -> half made item

		unfinishedRecipe.add(new RecipeStep(RecipeInstruction.COMBINE_INGREDIENTS,
			new ArrayList<Ingredient>()
			{
				{
					addAll(ingredients);
					add(new Ingredient(bakedRecipeType.getHalfBakedId(), 1, true));
				}
			},
			halfMadeId));

		return unfinishedRecipe;
	}

	/**
	 * Create baked recipe with no topped ingredients
	 *
	 * @param ingredients Combined with half-baked item to create half-made item
	 * @param finishedId  Final product of recipe
	 */
	private static ArrayList<RecipeStep> createBakedRecipe(BakedRecipeType bakedRecipeType, ArrayList<Ingredient> ingredients,
														   int halfMadeId, int finishedId)
	{
		// Create raw item -> half baked item -> half made item

		ArrayList<RecipeStep> recipe = createBakedRecipeHelper(bakedRecipeType, ingredients, halfMadeId);

		// Half made item -> finished item

		recipe.add(new RecipeStep(RecipeInstruction.BAKE_HALF_MADE,
			new Ingredient(halfMadeId, 1, true),
			finishedId));

		// Deliver finished item

		recipe.add(new RecipeStep(RecipeInstruction.DELIVER, new Ingredient(finishedId, 1,
			true), NO_PRODUCED_ITEM_ID));

		return recipe;
	}

	/**
	 * Create baked recipe with multiple topped ingredients
	 *
	 * @param firstIngredients   Combined with half-baked item to create half-made item
	 * @param toppingIngredients Combined with unfinished item to create finished item
	 * @param finishedId         Final product of recipe
	 */
	private static ArrayList<RecipeStep> createBakedRecipe(BakedRecipeType bakedRecipeType,
														   ArrayList<Ingredient> firstIngredients, int halfMadeId,
														   int unfinishedId, ArrayList<Ingredient> toppingIngredients,
														   int finishedId)
	{
		// Create raw item -> half baked item -> half made item

		ArrayList<RecipeStep> recipe = createBakedRecipeHelper(bakedRecipeType, firstIngredients, halfMadeId);

		// Half made item -> unfinished item

		recipe.add(new RecipeStep(RecipeInstruction.BAKE_HALF_MADE,
			new Ingredient(halfMadeId, 1, true),
			unfinishedId));

		// unfinished item -> finished item

		recipe.add(new RecipeStep(RecipeInstruction.ADD_TOPPINGS,
			new ArrayList<Ingredient>()
			{
				{
					add(new Ingredient(unfinishedId, 1, true));
					addAll(toppingIngredients);
				}
			},
			finishedId));

		// Deliver finished item

		recipe.add(new RecipeStep(RecipeInstruction.DELIVER, new Ingredient(finishedId, 1,
			true), NO_PRODUCED_ITEM_ID));

		return recipe;
	}

	/**
	 * Create baked recipe with one topped ingredient
	 *
	 * @param firstIngredients  Combined with half-baked item to create half-made item
	 * @param toppingIngredient Combined with unfinished item to create finished item
	 * @param finishedId        Final product of recipe
	 */
	private static ArrayList<RecipeStep> createBakedRecipe(BakedRecipeType bakedRecipeType,
														   ArrayList<Ingredient> firstIngredients, int halfMadeId,
														   int unfinishedId, Ingredient toppingIngredient,
														   int finishedId)
	{
		ArrayList<Ingredient> toppingIngredients = new ArrayList<>();
		toppingIngredients.add(toppingIngredient);

		return createBakedRecipe(bakedRecipeType, firstIngredients, halfMadeId, unfinishedId, toppingIngredients,
			finishedId);
	}

	// Cocktail recipe builders

	/**
	 * Partially create cocktail recipe. Only adds the step to create mixed cocktail.
	 **/
	private static ArrayList<RecipeStep> createCocktailRecipeHelper(ArrayList<Ingredient> shakedIngredients,
																	int mixedItem)
	{
		ArrayList<RecipeStep> unfinishedRecipe = new ArrayList<>();

		unfinishedRecipe.add(new RecipeStep(RecipeInstruction.MIX_COCKTAIL,
			new ArrayList<Ingredient>()
			{
				{
					addAll(shakedIngredients);
					add(new Ingredient(ItemID.COCKTAIL_SHAKER, 1, true));
				}
			},
			mixedItem)
		);

		return unfinishedRecipe;
	}

	/**
	 * Partially creates cocktail recipe. The steps are: mix cocktail -> pour
	 *
	 * @param isCompleteRecipe Flag that tells whether this is a complete or partial recipe
	 */
	private static ArrayList<RecipeStep> createCocktailRecipeHelper(ArrayList<Ingredient> shakedIngredients,
																	int mixedItem,
																	ArrayList<Ingredient> pouredIngredients,
																	int pouredItem, boolean isCompleteRecipe)
	{
		// Create mixed cocktail

		ArrayList<RecipeStep> recipe = createCocktailRecipeHelper(shakedIngredients, mixedItem);

		// Mixed cocktail -> poured cocktail

		recipe.add(new RecipeStep(RecipeInstruction.POUR, new ArrayList<Ingredient>()
			{
				{
					add(new Ingredient(ItemID.COCKTAIL_GLASS, 1, true));
					add(new Ingredient(mixedItem, 1, true));
					addAll(pouredIngredients);
				}
			},
				pouredItem)
		);

		// Deliver poured item if we finished making the recipe item

		if (isCompleteRecipe)
		{
			recipe.add(new RecipeStep(RecipeInstruction.DELIVER, new Ingredient(pouredItem, 1,
				true), NO_PRODUCED_ITEM_ID));
		}

		return recipe;
	}

	/**
	 * Simple cocktail recipe with several poured ingredients
	 **/
	private static ArrayList<RecipeStep> createCocktailRecipe(ArrayList<Ingredient> shakedIngredients,
															  int mixedItem,
															  ArrayList<Ingredient> pouredIngredients,
															  int finishedItem)
	{
		return createCocktailRecipeHelper(shakedIngredients, mixedItem, pouredIngredients, finishedItem, true);
	}

	/**
	 * Simple cocktail recipe with one poured ingredient
	 **/
	private static ArrayList<RecipeStep> createCocktailRecipe(ArrayList<Ingredient> shakedIngredients, int mixedItem,
															  Ingredient pouredIngredient, int finishedItem)
	{
		ArrayList<Ingredient> pouredIngredients = new ArrayList<>();
		pouredIngredients.add(pouredIngredient);

		return createCocktailRecipe(shakedIngredients, mixedItem, pouredIngredients, finishedItem);
	}

	// Heated cocktail recipes

	private static ArrayList<RecipeStep> createDrunkDragonRecipe()
	{
		// Create mixed cocktail -> poured cocktail

		ArrayList<Ingredient> shakedIngredients = new ArrayList<Ingredient>()
		{
			{
				add(new Ingredient(ItemID.VODKA, 1));
				add(new Ingredient(ItemID.GIN, 1));
				add(new Ingredient(ItemID.DWELLBERRIES, 1));
			}
		};

		ArrayList<Ingredient> toppedIngredients = new ArrayList<Ingredient>()
		{
			{
				add(new Ingredient(ItemID.PINEAPPLE_CHUNKS, 1));
				add(new Ingredient(ItemID.POT_OF_CREAM, 1));
			}
		};

		ArrayList<RecipeStep> recipe = createCocktailRecipeHelper(shakedIngredients, ItemID.MIXED_DRAGON,
			new ArrayList<>(), ItemID.MIXED_DRAGON_9575, false);

		// Poured cocktail -> unfinished item

		recipe.add(new RecipeStep(RecipeInstruction.ADD_TOPPINGS,
			new ArrayList<Ingredient>()
			{
				{
					add(new Ingredient(ItemID.MIXED_DRAGON_9575, 1, true));
					addAll(toppedIngredients);
				}
			},
			ItemID.MIXED_DRAGON_9576));

		// Unfinished item -> finished item

		recipe.add(new RecipeStep(RecipeInstruction.HEAT_COCKTAIL,
			new Ingredient(ItemID.MIXED_DRAGON_9576, 1, true), ItemID.DRUNK_DRAGON));

		// Deliver finished item

		recipe.add(new RecipeStep(RecipeInstruction.DELIVER, new Ingredient(ItemID.DRUNK_DRAGON, 1,
			true), NO_PRODUCED_ITEM_ID));

		return recipe;
	}

	private static ArrayList<RecipeStep> createChocSaturdayRecipe()
	{
		// Create mixed cocktail -> poured cocktail

		ArrayList<Ingredient> shakedIngredients = new ArrayList<Ingredient>()
		{
			{
				add(new Ingredient(ItemID.WHISKY, 1));
				add(new Ingredient(ItemID.CHOCOLATE_BAR, 1));
				add(new Ingredient(ItemID.EQUA_LEAVES, 1));
				add(new Ingredient(ItemID.BUCKET_OF_MILK, 1));
			}
		};

		ArrayList<RecipeStep> recipe = createCocktailRecipeHelper(shakedIngredients, ItemID.MIXED_SATURDAY,
			new ArrayList<>(), ItemID.MIXED_SATURDAY_9572, false);

		// poured cocktail -> unfinished item

		recipe.add(new RecipeStep(RecipeInstruction.HEAT_COCKTAIL,
			new Ingredient(ItemID.MIXED_SATURDAY_9572, 1, true), ItemID.MIXED_SATURDAY_9573));

		// unfinished item -> finished item

		recipe.add(new RecipeStep(RecipeInstruction.ADD_TOPPINGS,
			new ArrayList<Ingredient>()
			{
				{
					add(new Ingredient(ItemID.MIXED_SATURDAY_9573, 1, true));
					add(new Ingredient(ItemID.CHOCOLATE_DUST, 1));
					add(new Ingredient(ItemID.POT_OF_CREAM, 1));

				}
			}
			, ItemID.CHOC_SATURDAY));

		// Deliver finished item

		recipe.add(new RecipeStep(RecipeInstruction.DELIVER, new Ingredient(ItemID.CHOC_SATURDAY, 1,
			true), NO_PRODUCED_ITEM_ID));

		return recipe;
	}

	/**
	 * Get recipe by name
	 **/
	public static Recipe getRecipe(String name)
	{
		for (Recipe recipe : list)
		{
			if (recipe.getName().equals(name))
			{
				return recipe;
			}
		}

		throw new InvalidParameterException("Recipe with name " + name + " not found");
	}
}

/*
 * Copyright (c) 2020, MMagicala <https://github.com/MMagicala>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.github.mmagicala.gnomeRestaurant.recipe;

import java.util.ArrayList;
import java.util.Collections;
import lombok.Getter;

public class RecipeStep
{
	@Getter
	private final RecipeInstruction instruction;

	@Getter
	private final ArrayList<Ingredient> ingredients;

	@Getter
	private final int producedItemId;

	public RecipeStep(RecipeInstruction instruction, ArrayList<Ingredient> ingredients, int producedItemId)
	{
		this.instruction = instruction;
		this.ingredients = ingredients;
		this.producedItemId = producedItemId;
	}

	// Step only requires one ingredient
	public RecipeStep(RecipeInstruction instruction, Ingredient ingredient, int producedItemId)
	{
		this(instruction, new ArrayList<>(), producedItemId);
		this.ingredients.add(ingredient);
	}

	public ArrayList<Ingredient> getRawIngredients()
	{
		ArrayList<Ingredient> rawIngredients = new ArrayList<>(ingredients);
		rawIngredients.removeIf(Ingredient::isIntermediate);
		return rawIngredients;
	}
}

package io.github.mmagicala.gnomeRestaurant.recipe;

import java.util.ArrayList;
import lombok.Getter;

public class Recipe
{
	@Getter
	private String name;
	@Getter
	private ArrayList<RecipeStep> steps;

	public Recipe(String name, ArrayList<RecipeStep> steps)
	{
		this.name = name;
		this.steps = steps;
	}

	/**
	 * Return the item id of the final product
	 **/
	public int getItemId()
	{
		int numSteps = steps.size();
		RecipeStep deliveryStep = steps.get(numSteps - 1);
		return deliveryStep.getIngredients().get(0).getItemId();
	}

	/**
	 * Return raw ingredients used in a recipe at step number @stepIdx + 1
	 **/
	public ArrayList<Ingredient> getNextRawIngredients(int stepIdx)
	{
		ArrayList<Ingredient> ingredients = new ArrayList<>();

		// Collect raw ingredients from each step
		int numSteps = steps.size();
		for (int i = stepIdx + 1; i < numSteps; i++)
		{
			ArrayList<Ingredient> rawIngredients = steps.get(i).getRawIngredients();
			ingredients.addAll(rawIngredients);
		}

		return ingredients;
	}
}

/*
 * Copyright (c) 2020, MMagicala <https://github.com/MMagicala>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.github.mmagicala.gnomeRestaurant.recipe;

import lombok.Getter;

public class Ingredient
{
	@Getter
	private int itemId, count;

	@Getter
	private boolean isIntermediate;

	public Ingredient(int itemId, int count){
		this(itemId, count, false);
	}

	public Ingredient(int itemId, int count, boolean isIntermediate){
		this.itemId = itemId;
		this.count = count;
		this.isIntermediate = isIntermediate;
	}
}

/*
 * Copyright (c) 2020, MMagicala <https://github.com/MMagicala>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.github.mmagicala.gnomeRestaurant.recipe;

import lombok.Getter;

public enum RecipeInstruction
{
	CREATE_RAW("Create the raw batter"),
	CREATE_HALF_BAKED("Bake the raw batter"),
	COMBINE_INGREDIENTS("Combine ingredients"),
	BAKE_HALF_MADE("Bake item again"),
	ADD_TOPPINGS("Add topping ingredients"),

	MIX_COCKTAIL("Mix ingredients in the cocktail shaker"),
	POUR("Pour mix into the cocktail glass"),
	HEAT_COCKTAIL("Heat the cocktail"),

	DELIVER("Deliver the item to recipient");

	@Getter
	String overlayDirections;

	RecipeInstruction(String overlayDirections)
	{
		this.overlayDirections = overlayDirections;
	}
}

/*
 * Copyright (c) 2020, MMagicala <https://github.com/MMagicala>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.github.mmagicala.gnomeRestaurant;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("gnomerestaurant")
public interface GnomeRestaurantConfig extends Config
{
	@ConfigItem(
		keyName = GnomeRestaurantPlugin.SHOW_OVERLAY,
		name = "Show Overlay",
		description = "Configures whether to show the overlay window"
	)
	default boolean showOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = GnomeRestaurantPlugin.SHOW_ORDER_TIMER,
		name = "Show Order Timer",
		description = "Configures whether to show the order timer"
	)
	default boolean showOrderTimer()
	{
		return true;
	}

	@ConfigItem(
		keyName = GnomeRestaurantPlugin.SHOW_DELAY_TIMER,
		name = "Show Delay Timer",
		description = "Configures whether to show the order delay timer"
	)
	default boolean showDelayTimer()
	{
		return true;
	}

	@ConfigItem(
		keyName = GnomeRestaurantPlugin.SHOW_HINT_ARROW,
		name = "Show Hint Arrow",
		description = "Configures whether to show the hint arrow toward the order recipient"
	)
	default boolean showHintArrow()
	{
		return true;
	}

	@ConfigItem(
		keyName = GnomeRestaurantPlugin.SHOW_WORLD_MAP_POINT,
		name = "Show World Map Point",
		description = "Configures whether to show the recipient's location in the world map"
	)
	default boolean showWorldMapPoint()
	{
		return true;
	}
}

package io.github.mmagicala.gnomeRestaurant.overlay;

import lombok.Getter;
import lombok.Setter;

public class OverlayTableEntry
{
	// Used by plugin to update entry

	@Getter
	private int itemId;

	// Used by overlay table for output

	@Getter
	private String itemName;

	@Getter
	@Setter
	private int inventoryCount;

	@Getter
	private int requiredCount;

	public OverlayTableEntry(int itemId, String itemName, int inventoryCount, int requiredCount)
	{
		this.itemId = itemId;
		this.itemName = itemName;
		this.inventoryCount = inventoryCount;
		this.requiredCount = requiredCount;
	}

}

package io.github.mmagicala.gnomeRestaurant.overlay;

public class RewardsOverlay
{
}

package io.github.mmagicala.gnomeRestaurant.overlay;

import lombok.Getter;

public class OverlayHeader
{
	public String instruction;
	public int stepNum, totalSteps;

	public OverlayHeader(String instruction, int stepNum, int totalSteps)
	{
		this.instruction = instruction;
		this.stepNum = stepNum;
		this.totalSteps = totalSteps;
	}
}

/*
 * Copyright (c) 2020, MMagicala <https://github.com/MMagicala>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.github.mmagicala.gnomeRestaurant.overlay;

import io.github.mmagicala.gnomeRestaurant.GnomeRestaurantPlugin;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Map;
import javax.inject.Inject;
import net.runelite.api.ItemComposition;
import net.runelite.api.MenuAction;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

public class GnomeRestaurantOverlay extends OverlayPanel
{
	// Overlay contents
	private final OverlayHeader header;
	private final ArrayList<OverlayTableEntry> stepIngredientsOverlayTable;
	private final ArrayList<OverlayTableEntry> futureRawIngredientsOverlayTable;

	private final GnomeRestaurantPlugin plugin;
	private static final int PADDING = 10;

	@Inject
	public GnomeRestaurantOverlay(GnomeRestaurantPlugin plugin, OverlayHeader header,
									 ArrayList<OverlayTableEntry> stepIngredientsOverlayTable,
									 ArrayList<OverlayTableEntry> futureRawIngredientsOverlayTable)
	{
		super(plugin);
		this.plugin = plugin;

		this.header = header;
		this.stepIngredientsOverlayTable = stepIngredientsOverlayTable;
		this.futureRawIngredientsOverlayTable = futureRawIngredientsOverlayTable;

		// Padding
		panelComponent.setBorder(new Rectangle(PADDING, PADDING, PADDING, PADDING));

		// Gap between panel items
		panelComponent.setGap(new Point(0, ComponentConstants.STANDARD_BORDER));
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		// Header

		String headerText = "Step " + header.stepNum + "/" + header.totalSteps + ": " +
			header.instruction;

		LineComponent headerComponent = LineComponent.builder().left(headerText).build();
		panelComponent.getChildren().add(headerComponent);

		// Overlay tables

		renderOverlayTable(stepIngredientsOverlayTable, "Current Step");

		if (futureRawIngredientsOverlayTable.size() > 0)
		{
			// Only render future ingredients if there are any left
			renderOverlayTable(futureRawIngredientsOverlayTable, "Needed Later");
		}

		return super.render(graphics);
	}

	private void renderOverlayTable(ArrayList<OverlayTableEntry> overlayTable, String title)
	{
		// Table header

		TitleComponent titleComponent = TitleComponent.builder().text(title).build();
		panelComponent.getChildren().add(titleComponent);

		// Table contents

		for (OverlayTableEntry tableEntry : overlayTable)
		{
			Color ingredientColor;
			if (tableEntry.getInventoryCount() >= tableEntry.getRequiredCount())
			{
				ingredientColor = Color.GREEN;
			}
			else if (tableEntry.getInventoryCount() == 0)
			{
				ingredientColor = Color.RED;
			}
			else
			{
				ingredientColor = Color.YELLOW;
			}

			LineComponent ingredientRow = LineComponent.builder()
				.left(tableEntry.getItemName())
				.leftColor(ingredientColor)
				.right(tableEntry.getInventoryCount() + "/" + tableEntry.getRequiredCount())
				.rightColor(ingredientColor)
				.build();
			panelComponent.getChildren().add(ingredientRow);
		}
	}
}

