package com.gimp;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class GimPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GimPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.gimps;

import com.gimp.GimPlugin;
import com.gimp.GimPluginConfig;
import java.awt.Color;
import java.io.IOException;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.Skill;
import net.runelite.api.clan.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.hiscore.HiscoreEndpoint;
import net.runelite.client.hiscore.HiscoreManager;
import net.runelite.client.hiscore.HiscoreResult;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;
import javax.inject.Inject;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;

@Slf4j
public class Group
{
	// TODO: Let the player choose their own color?
	private final static Color[] GIMP_COLORS = new Color[]{new Color(48, 227, 192), new Color(241, 120, 68), new Color(78, 54, 236), new Color(239, 208, 21), new Color(201, 21, 217)};

	@Getter
	final private List<GimPlayer> gimps = new ArrayList<>();

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	public GimPluginConfig config;

	@Inject
	private WorldMapPointManager worldMapPointManager;

	@Inject
	private HiscoreManager hiscoreManager;

	@Getter
	private boolean loaded = false;

	@Getter
	private String name;

	final private ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();

	/**
	 * Poll for completion of future containing result of loaded clan settings.
	 *
	 * @return future of result of loaded clan settings
	 */
	private CompletableFuture<Void> waitForClan()
	{
		CompletableFuture<Void> completionFuture = new CompletableFuture<>();
		final ScheduledFuture<?> checkFuture = executor.scheduleAtFixedRate(() -> {
			if (client.getClanSettings(ClanID.GROUP_IRONMAN) != null)
			{
				completionFuture.complete(null);
			}
		}, 0, 1, TimeUnit.SECONDS);
		completionFuture.whenComplete((result, ex) -> {
			checkFuture.cancel(true);
		});
		return completionFuture;
	}

	/**
	 * Loads player data to the Group once the client has finished loading clan
	 * data. Initializes data for the local gimp.
	 *
	 * @return result of loading gimps
	 */
	public CompletableFuture<Void> load()
	{
		CompletableFuture<Void> loadingResult = new CompletableFuture<>();
		// Call executor to poll for clan settings
		waitForClan().whenCompleteAsync((result, ex) -> {
			ClanSettings gimClanSettings = client.getClanSettings(ClanID.GROUP_IRONMAN);
			assert gimClanSettings != null;
			name = gimClanSettings.getName();
			List<ClanMember> clanMembers = gimClanSettings.getMembers();
			for (int i = 0; i < clanMembers.size(); i++)
			{
				final ClanMember member = clanMembers.get(i);
				// For some reason, clan member names with spaces use the no-break
				// space character, so we must sanitize it
				String name = sanitize(member.getName());
				int world = getCurrentWorld(name);
				gimps.add(new GimPlayer(name, world, GIMP_COLORS[i]));
			}
			// Load local gimp data, including hiscores
			localLoad().whenCompleteAsync((r, e) -> {
				loaded = true;
				loadingResult.complete(null);
			});
		});
		return loadingResult;
	}

	/**
	 * Loads data for the local GimPlayer, including fetching its hiscores.
	 *
	 * @return result of loading local gimp data
	 */
	public CompletableFuture<Void> localLoad()
	{
		CompletableFuture<Void> loadingResult = new CompletableFuture<>();
		Player localPlayer = client.getLocalPlayer();
		GimPlayer localGimp = getLocalGimp();
		// If no local player or gimp, complete load
		if (localPlayer == null || localGimp == null)
		{
			loadingResult.cancel(true);
			return loadingResult;
		}
		localUpdate();
		setHiscores(localGimp.getName()).whenCompleteAsync((result, ext) -> {
			loadingResult.complete(null);
		});
		return loadingResult;
	}

	/**
	 * Maps a raw GimPlayer data object to a GimPlayer in the Group.
	 *
	 * @param gimpData a GimPlayer instance holding broadcast data
	 */
	public void update(GimPlayer gimpData)
	{
		for (GimPlayer gimp : gimps)
		{
			String gimpName = gimpData.getName();
			if (gimp.getName().equals(gimpName))
			{
				if (gimpData.getHp() != null)
				{
					gimp.setHp(gimpData.getHp());
				}
				if (gimpData.getMaxHp() != null)
				{
					gimp.setMaxHp(gimpData.getMaxHp());
				}
				if (gimpData.getPrayer() != null)
				{
					gimp.setPrayer(gimpData.getPrayer());
				}
				if (gimpData.getMaxPrayer() != null)
				{
					gimp.setMaxPrayer(gimpData.getMaxPrayer());
				}
				if (gimpData.getNotes() != null)
				{
					gimp.setNotes(gimpData.getNotes());
				}
				// Must set ghost mode before location!
				if (gimpData.getGhostMode() != null)
				{
					setGhostMode(gimpName, gimpData.getGhostMode());
				}
				if (gimpData.getLocation() != null)
				{
					setLocation(gimpName, gimpData.getLocation());
				}
				if (gimpData.getLastActivity() != null)
				{
					gimp.setLastActivity(gimpData.getLastActivity());
				}
			}
		}
	}

	public void unload()
	{
		gimps.clear();
		loaded = false;
	}

	public GimPlayer getGimp(String name)
	{
		for (GimPlayer gimp : gimps)
		{
			if (gimp.getName().equals(name))
			{
				return gimp;
			}
		}
		return null;
	}

	public GimPlayer getLocalGimp()
	{
		final Player localPlayer = client.getLocalPlayer();
		if (localPlayer != null)
		{
			return getGimp(localPlayer.getName());
		}
		return null;
	}

	/**
	 * Updates the local GimPlayer if that player exists using data
	 * available on the client.
	 */
	public void localUpdate()
	{
		Player localPlayer = client.getLocalPlayer();
		GimPlayer localGimp = getLocalGimp();
		if (localPlayer != null && localGimp != null)
		{
			localGimp.setHp(client.getBoostedSkillLevel(Skill.HITPOINTS));
			localGimp.setMaxHp(client.getRealSkillLevel(Skill.HITPOINTS));
			localGimp.setPrayer(client.getBoostedSkillLevel(Skill.PRAYER));
			localGimp.setMaxPrayer(client.getRealSkillLevel(Skill.PRAYER));
			localGimp.setGhostMode(config.ghostMode());
			setWorld(localGimp.getName(), client.getWorld());
			setLocation(localGimp.getName(), new GimLocation(localPlayer.getWorldLocation()));
		}
	}

	/**
	 * Hydrates specific data on local GimPlayer, meant to be invoked after
	 * player has received a local update. These properties might depend on
	 * data from server before falling back on a local source.
	 *
	 * @param gimpData GimPlayer data
	 */
	public void localHydrate(GimPlayer gimpData)
	{
		Player localPlayer = client.getLocalPlayer();
		GimPlayer localGimp = getLocalGimp();
		if (localPlayer != null && localGimp != null)
		{
			// Notes must come from the server if they exist
			String gimpNotes;
			if (gimpData.getNotes() != null)
			{
				gimpNotes = gimpData.getNotes();
			}
			// Otherwise, fall back on notes data saved to config
			else
			{
				gimpNotes = config.notesData();
			}
			localGimp.setNotes(gimpNotes);
		}
	}

	public List<String> getNames()
	{
		List<String> names = new ArrayList<>();
		for (GimPlayer gimp : gimps)
		{
			names.add(gimp.getName());
		}
		return names;
	}

	/**
	 * Sets a GimPlayer's location using the provided location data and
	 * updates its icon on the world map if the gimp is online and doesn't
	 * have ghost mode enabled.
	 *
	 * @param name     GimPlayer name
	 * @param location GimPlayer location data
	 */
	public void setLocation(String name, GimLocation location)
	{
		GimPlayer gimp = getGimp(name);
		if (gimp == null)
		{
			return;
		}
		// Create new GimLocation from raw data
		GimLocation newGimLocation = new GimLocation(location.getX(), location.getY(), location.getPlane());
		// Set GimPlayer location to new location
		gimp.setLocation(newGimLocation);
	}

	/**
	 * Sets the world number of the GimPlayer by name and removes
	 * the map point if the world number is 0, e.g. the player is offline.
	 *
	 * @param name  GimPlayer name
	 * @param world world number
	 */
	public void setWorld(String name, int world)
	{
		GimPlayer gimp = getGimp(name);
		if (gimp == null)
		{
			return;
		}
		gimp.setWorld(world);
	}

	/**
	 * Sets the ghost mode value of the GimPlayer by name. If the GimPlayer
	 * has a location stored, either removes the corresponding map point or
	 * creates one, depending on the new ghost mode setting.
	 *
	 * @param name      GimPlayer name
	 * @param ghostMode ghost mode setting
	 */
	public void setGhostMode(String name, boolean ghostMode)
	{
		GimPlayer gimp = getGimp(name);
		if (gimp == null)
		{
			return;
		}
		gimp.setGhostMode(ghostMode);
	}

	/**
	 * Gets the world of a player by name, returns 0 if the player
	 * is offline.
	 *
	 * @param name GimPlayer name
	 * @return world number
	 */
	public int getCurrentWorld(String name)
	{
		ClanChannel gimClanChannel = client.getClanChannel(ClanID.GROUP_IRONMAN);
		if (validateGimpName(name) && gimClanChannel != null)
		{
			ClanChannelMember onlineMember = gimClanChannel.findMember(name);
			GimPlayer gimp = getGimp(name);
			// If you cannot find member in clan, or GimPlayer is in ghost mode
			if (onlineMember == null || (gimp != null && gimp.getGhostMode()))
			{
				return GimPlugin.OFFLINE_WORLD;
			}
			return onlineMember.getWorld();
		}
		return GimPlugin.OFFLINE_WORLD;
	}

	public CompletableFuture<HiscoreResult> setHiscores(String name)
	{
		GimPlayer gimp = getGimp(name);
		return getHiscores(name).whenCompleteAsync((result, ext) -> {
			gimp.setHiscores(result);
		});
	}

	/**
	 * Fetches player hiscores via HiscoreManager, caching the result
	 * and returning the pending result to the invoker.
	 *
	 * @param name GimPlayer name
	 * @return player hiscores result
	 */
	public CompletableFuture<HiscoreResult> getHiscores(String name)
	{
		CompletableFuture<HiscoreResult> hiscoreResult = new CompletableFuture<>();
		try
		{
			HiscoreResult result = hiscoreManager.lookup(name, HiscoreEndpoint.NORMAL);
			if (result == null)
			{
				log.warn("Could not find hiscore data for " + name);
			}
			hiscoreResult.complete(result);
		}
		catch (IOException e)
		{
			log.error("Error fetching hiscores: " + e);
			hiscoreResult.completeExceptionally(e);
		}
		return hiscoreResult;
	}

	public boolean isEmpty()
	{
		return gimps.isEmpty();
	}

	private static String sanitize(String lookup)
	{
		return lookup.replace('\u00A0', ' ');
	}

	private boolean validateGimpName(String name)
	{
		return getGimp(name) != null;
	}
}

/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.gimps;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;

import java.util.HashMap;
import java.util.Map;

@Slf4j
public class GimLocation
{
	public enum Coordinate
	{
		plane,
		x,
		y
	}

	@Getter
	final int x;

	@Getter
	final int y;

	@Getter
	final int plane;

	public GimLocation(WorldPoint worldPoint)
	{
		x = worldPoint.getX();
		y = worldPoint.getY();
		plane = worldPoint.getPlane();
	}

	public GimLocation(int x, int y, int plane)
	{
		this.x = x;
		this.y = y;
		this.plane = plane;
	}

	/**
	 * Maps member coordinates x, y, and plane to HashMap.
	 *
	 * @return map: coordinateName => coordinateValue
	 */
	public Map<String, Integer> getLocation()
	{
		Map<String, Integer> location = new HashMap<>();
		location.put(Coordinate.x.toString(), x);
		location.put(Coordinate.y.toString(), y);
		location.put(Coordinate.plane.toString(), plane);
		return location;
	}

	public WorldPoint toWorldPoint()
	{
		return new WorldPoint(x, y, plane);
	}

	public double getDistanceTo(GimLocation other)
	{
		return Math.sqrt(Math.pow(other.x - x, 2) + Math.pow(other.y - y, 2));
	}

	public static boolean compare(GimLocation loc1, GimLocation loc2)
	{
		return (loc1.getX() == loc2.getX())
			&& (loc1.getY() == loc2.getY())
			&& (loc1.getPlane() == loc2.getPlane());
	}
}

/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.gimps;

import java.awt.Color;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.hiscore.HiscoreResult;
import net.runelite.client.plugins.party.messages.TilePing;
import javax.annotation.Nullable;
import javax.inject.Inject;
import java.util.HashMap;
import java.util.Map;

@Slf4j
public class GimPlayer
{
	@Getter
	final private String name;

	@Setter
	@Getter
	private Integer hp;

	@Setter
	@Getter
	private Integer maxHp;

	@Setter
	@Getter
	private Integer prayer;

	@Setter
	@Getter
	private Integer maxPrayer;

	@Setter
	@Getter
	private HiscoreResult hiscores;

	@Setter
	@Getter
	private String notes;

	@Setter
	@Getter
	private TilePing tilePing;

	@Setter
	@Getter
	private Integer world;

	@Nullable
	@Getter
	private GimLocation location;

	@Setter
	@Getter
	private Boolean ghostMode = false;

	@Setter
	@Getter
	private String lastActivity = IN_GAME_ACTIVITY;

	public static final String IN_GAME_ACTIVITY = "IN_GAME_ACTIVITY";

	/**
	 * Speed of this player in tiles per second.
	 */
	@Getter
	private double speed;

	/**
	 * Timestamp of the last location update (in system time milliseconds).
	 * Used for computing the effective "speed" of the player.
	 */
	private long locationTimestamp;

	@Getter
	private final Color color;

	@Inject
	public GimPlayer(String name, int world, Color color)
	{
		this.name = name;
		this.world = world;
		this.color = color;
	}

	public void setLocation(GimLocation location)
	{
		// Determine the "speed" of the player
		if (this.location != null)
		{
			final long millisSinceLastLocation = System.currentTimeMillis() - locationTimestamp;
			final double distance = this.location.getDistanceTo(location);
			if (this.location.plane != location.plane)
			{
				// If switching between planes, keep the speed at zero
				speed = 0;
			}
			else
			{
				// Otherwise, compute the speed (doesn't account for teleports, but oh well...)
				speed = distance * 1000.0 / millisSinceLastLocation;
			}
		}
		// Set location to new GimLocation
		this.location = location;
		// Update timestamp
		locationTimestamp = System.currentTimeMillis();
	}

	public Map<String, Object> getData()
	{
		Map<String, Object> data = new HashMap<>();
		data.put("name", name);
		return data;
	}

	public boolean shouldIncludeLocation()
	{
		return ghostMode == null || !ghostMode;
	}

	/**
	 * Retrieves GimPlayer data for a broadcast. Suppresses and/or
	 * modifies data for this purpose.
	 *
	 * @return GimPlayer broadcast-ready data
	 */
	public Map<String, Object> getGimpData()
	{
		Map<String, Object> gimpData = new HashMap<>();
		gimpData.put("name", name);
		gimpData.put("hp", hp);
		gimpData.put("maxHp", maxHp);
		gimpData.put("prayer", prayer);
		gimpData.put("maxPrayer", maxPrayer);
		gimpData.put("notes", notes);
		gimpData.put("ghostMode", ghostMode);
		// Don't get location if ghostMode is active
		if (location != null && this.shouldIncludeLocation())
		{
			gimpData.put("location", location.getLocation());
		}
		gimpData.put("lastActivity", lastActivity);
		return gimpData;
	}
}

/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp;

import com.gimp.gimps.*;
import com.gimp.ui.GimNotes;
import com.gimp.ui.GimTab;
import com.gimp.ui.GimTabGroup;
import com.google.common.collect.ImmutableList;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import javax.inject.Inject;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Experience;
import net.runelite.api.Player;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanID;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.ProgressBar;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;
import net.runelite.client.hiscore.HiscoreSkill;
import static net.runelite.client.hiscore.HiscoreSkill.*;
import net.runelite.client.hiscore.HiscoreResult;
import net.runelite.client.hiscore.HiscoreSkillType;
import net.runelite.client.hiscore.Skill;
import org.apache.commons.lang3.StringUtils;

@Slf4j
public class GimPluginPanel extends PluginPanel
{
	private static final ImageIcon GIMP_ICON_SMALL;

	private static final ImageIcon GITHUB_ICON;

	/**
	 * Real skills, ordered in the way they should be displayed in the panel.
	 */
	private static final List<HiscoreSkill> SKILLS = ImmutableList.of(
		ATTACK, HITPOINTS, MINING,
		STRENGTH, AGILITY, SMITHING,
		DEFENCE, HERBLORE, FISHING,
		RANGED, THIEVING, COOKING,
		PRAYER, CRAFTING, FIREMAKING,
		MAGIC, FLETCHING, WOODCUTTING,
		RUNECRAFT, SLAYER, FARMING,
		CONSTRUCTION, HUNTER
	);

	/**
	 * Bosses, ordered in the way they should be displayed in the panel.
	 */
	private static final List<HiscoreSkill> BOSSES = ImmutableList.of(
		ABYSSAL_SIRE, ALCHEMICAL_HYDRA, AMOXLIATL,
		ARAXXOR, ARTIO, BARROWS_CHESTS,
		BRYOPHYTA, CALLISTO, CALVARION,
		CERBERUS, CHAMBERS_OF_XERIC, CHAMBERS_OF_XERIC_CHALLENGE_MODE,
		CHAOS_ELEMENTAL, CHAOS_FANATIC, COMMANDER_ZILYANA,
		CORPOREAL_BEAST, CRAZY_ARCHAEOLOGIST, DAGANNOTH_PRIME,
		DAGANNOTH_REX, DAGANNOTH_SUPREME, DERANGED_ARCHAEOLOGIST,
		DUKE_SUCELLUS, GENERAL_GRAARDOR, GIANT_MOLE,
		GROTESQUE_GUARDIANS, HESPORI, KALPHITE_QUEEN,
		KING_BLACK_DRAGON, KRAKEN, KREEARRA,
		KRIL_TSUTSAROTH, LUNAR_CHESTS, MIMIC,
		NEX, NIGHTMARE, PHOSANIS_NIGHTMARE,
		OBOR, PHANTOM_MUSPAH, SARACHNIS,
		SCORPIA, SCURRIUS, SKOTIZO,
		SOL_HEREDIT, SPINDEL, TEMPOROSS,
		THE_GAUNTLET, THE_CORRUPTED_GAUNTLET, THE_HUEYCOATL,
		THE_LEVIATHAN, THE_WHISPERER, THEATRE_OF_BLOOD,
		THEATRE_OF_BLOOD_HARD_MODE, THERMONUCLEAR_SMOKE_DEVIL, TOMBS_OF_AMASCUT,
		TOMBS_OF_AMASCUT_EXPERT, TZKAL_ZUK, TZTOK_JAD,
		VARDORVIS, VENENATIS, VETION,
		VORKATH, WINTERTODT, ZALCANO,
		ZULRAH
	);

	private static final String HTML_LABEL_TEMPLATE = "<html><body style='color:%s'>%s<span style='color:white'>%s</span></body></html>";

	private final Group group;

	@Inject
	private Client client;

	// Not an EnumMap because we need null keys for combat
	private final Map<HiscoreSkill, JLabel> skillLabels = new HashMap<>();

	private static final Color HP_FG = new Color(0, 146, 54, 230);
	private static final Color HP_BG = new Color(102, 15, 16, 230);
	private static final Color PRAYER_FG = new Color(0, 149, 151);
	private static final Color PRAYER_BG = Color.black;

	private static final String CONNECTING_TEXT = "Trying to connect...";

	private final JLabel noDataLabel = new JLabel();
	private final JLabel connectionLabel = new JLabel();
	private final JLabel usernameLabel = new JLabel();
	private final JLabel worldLabel = new JLabel();
	private final ProgressBar hpBar = new ProgressBar();
	private final ProgressBar prayerBar = new ProgressBar();
	private final JButton refreshButton = new JButton("Refresh");
	private final JLabel activityLabel = new JLabel();

	private final GimNotes gimNotes = new GimNotes();

	/* Container of all the selectable gimp tabs */
	private GimTabGroup tabGroup;

	/* Index of the local gimp's tab or 0 */
	private int defaultTab;

	/* The currently selected gimp */
	private String selectedGimp;

	/* Used to prevent users from switching gimp tabs while the results are loading */
	private boolean loading = false;

	static
	{
		final BufferedImage gimpIconSmallImg = ImageUtil.loadImageResource(GimPluginPanel.class, "gimpoint-small.png");
		GIMP_ICON_SMALL = new ImageIcon(gimpIconSmallImg);
		final BufferedImage githubIcon = ImageUtil.loadImageResource(GimPluginPanel.class, "github.png");
		GITHUB_ICON = new ImageIcon(ImageUtil.resizeImage(githubIcon, 16, 16));
	}

	@Inject
	public GimPluginPanel(GimPlugin plugin)
	{
		this.group = plugin.getGroup();
		this.gimNotes.init(plugin);

		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setBorder(new EmptyBorder(10, 10, 10, 10));
		setLayout(new BorderLayout());
	}

	public void load()
	{
		final Player localPlayer = client.getLocalPlayer();
		List<String> gimps = group.getNames();
		try
		{
			SwingUtilities.invokeLater(() -> {
				// Remove noData text
				removeAll();
				// Create panel that will hold gimp data
				final JPanel container = new JPanel();
				container.setBackground(ColorScheme.DARK_GRAY_COLOR);
				container.setLayout(new GridBagLayout());

				// Expand sub items to fit width of panel, align to top of panel
				GridBagConstraints c = new GridBagConstraints();
				c.fill = GridBagConstraints.HORIZONTAL;
				c.gridx = 0;
				c.gridy = 0;
				c.weightx = 1;
				c.weighty = 0;
				c.insets = new Insets(0, 0, 10, 0);

				// Add connection status panel
				final JPanel statusPanel = makeStatusPanel();
				container.add(statusPanel, c);
				c.gridy++;

				// Add tabs for each gimp
				int gimpCount = gimps.size();
				tabGroup = new GimTabGroup();
				tabGroup.setLayout(new GridLayout(1, gimpCount, 7, 7));

				int tabIdx = 0;

				for (String username : gimps)
				{
					GimTab tab = new GimTab(GIMP_ICON_SMALL, tabGroup, username);
					// If gimp is online, set status dot color to green
					if (group.getCurrentWorld(username) != 0)
					{
						tab.setStatus(true);
					}
					tab.setToolTipText(username);
					tab.setOnSelectEvent(() -> {
						if (loading)
						{
							return false;
						}

						selectedGimp = username;
						// Removes focus border from refresh button on tab select
						tab.requestFocus();
						return true;
					});
					// Adding the lookup method to a mouseListener instead of the above onSelectedEvent
					// because sometimes you might want to switch the tab, without calling for lookup
					tab.addMouseListener(new MouseAdapter()
					{
						@Override
						public void mousePressed(MouseEvent mouseEvent)
						{
							if (loading)
							{
								return;
							}
							loadGimpData();
						}
					});
					// Set tab of local gimp, if none is defined yet will default to first
					if (localPlayer != null && username.equals(localPlayer.getName()))
					{
						defaultTab = tabIdx;
					}
					tabGroup.addTab(tab);
					tabIdx++;
				}

				// Default selected tab is you
				resetSelectedTab();

				container.add(tabGroup, c);
				c.gridy++;

				// Panel that hold gimp info and status
				JPanel infoPanel = makeInfoPanel();
				container.add(infoPanel, c);
				c.gridy++;

				// Panel that holds skill icons
				JPanel statsPanel = new JPanel();
				statsPanel.setLayout(new GridLayout(8, 3));
				statsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				statsPanel.setBorder(new EmptyBorder(5, 0, 2, 0));

				// For each skill on the in-game panel, create a Label and add it to the UI
				for (HiscoreSkill skill : SKILLS)
				{
					JPanel panel = makeHiscorePanel(skill);
					statsPanel.add(panel);
				}

				container.add(statsPanel, c);
				c.gridy++;

				JPanel totalPanel = new JPanel();
				totalPanel.setLayout(new GridLayout(1, 2));
				totalPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				statsPanel.setBorder(new EmptyBorder(5, 0, 2, 0));

				totalPanel.add(makeHiscorePanel(null)); // Combat has no hiscore skill, referred to as null
				totalPanel.add(makeHiscorePanel(OVERALL));

				container.add(totalPanel, c);
				c.gridy++;

				JPanel bossPanel = new JPanel();
				bossPanel.setLayout(new GridLayout(0, 3));
				bossPanel.setBackground((ColorScheme.DARKER_GRAY_COLOR));
				bossPanel.setBorder(new EmptyBorder(2, 0, 5, 0));

				// For each boss on the HiScores, create a Label and add it to the UI
				for (HiscoreSkill skill : BOSSES)
				{
					JPanel panel = makeHiscorePanel(skill);
					bossPanel.add(panel);
				}

				container.add(bossPanel, c);
				c.gridy++;

				// Create button to refresh gimp data
				refreshButton.addActionListener((e) -> {
					loadGimpData();
				});
				container.add(refreshButton, c);
				c.gridy++;

				JPanel notesPanel = makeNotesPanel();
				container.add(notesPanel, c);
				c.gridy++;

				// Add data container to panel
				add(container, BorderLayout.CENTER);
				// Revalidate layout and repaint
				revalidate();
				repaint();

				// Load gimp data into panel
				loadGimpData();
			});
		}
		catch (Exception e)
		{
			log.error(e.toString());
		}
	}

	public void unload()
	{
		SwingUtilities.invokeLater(() -> {
			// Remove GIMP data
			removeAll();
			// Create noData panel
			JPanel noDataPanel = makeNoDataPanel();
			add(noDataPanel, BorderLayout.CENTER);
			// Revalidate layout and repaint
			revalidate();
			repaint();
		});
	}

	private JPanel makeNoDataPanel()
	{
		assert SwingUtilities.isEventDispatchThread();

		JPanel container = new JPanel();
		container.setLayout(new BorderLayout());
		noDataLabel.setFont(FontManager.getRunescapeFont());
		noDataLabel.setText("<html><body style='text-align:center;'>You must be logged in to a group ironman to see GIMP data.</body></html>");
		container.add(noDataLabel);
		return container;
	}

	private JPanel makeStatusPanel()
	{
		assert SwingUtilities.isEventDispatchThread();

		// Create a panel to hold plugin status info
		final JPanel statusPanel = new JPanel();
		statusPanel.setLayout(new BorderLayout(4, 0));
		statusPanel.setBorder(new EmptyBorder(2, 8, 2, 8));
		// Create a panel to hold connection label
		final JPanel connectionPanel = new JPanel();
		connectionPanel.setLayout(new BorderLayout());
		connectionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		// Add connection status
		connectionLabel.setHorizontalAlignment(SwingConstants.CENTER);
		connectionLabel.setFont(FontManager.getRunescapeFont());
		connectionLabel.setText(CONNECTING_TEXT);
		connectionPanel.add(connectionLabel);
		statusPanel.add(connectionPanel);
		// Add GitHub button
		JButton githubBtn = makeGithubButton();
		statusPanel.add(githubBtn, BorderLayout.LINE_END);

		return statusPanel;
	}

	private JButton makeGithubButton()
	{
		JButton githubBtn = new JButton();
		SwingUtil.removeButtonDecorations(githubBtn);
		githubBtn.setIcon(GITHUB_ICON);
		githubBtn.setToolTipText("Report issues or contribute on GitHub");
		githubBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
		githubBtn.setUI(new BasicButtonUI());
		githubBtn.addActionListener((ev) -> LinkBrowser.browse("https://github.com/davidvorona/gim-plugin"));
		githubBtn.addMouseListener(new java.awt.event.MouseAdapter()
		{
			public void mouseEntered(java.awt.event.MouseEvent evt)
			{
				githubBtn.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
			}

			public void mouseExited(java.awt.event.MouseEvent evt)
			{
				githubBtn.setBackground(ColorScheme.DARK_GRAY_COLOR);
			}
		});
		return githubBtn;
	}

	private JPanel makeInfoPanel()
	{
		assert SwingUtilities.isEventDispatchThread();

		// Create panel that will contain overall data
		JPanel overallPanel = new JPanel();
		overallPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createMatteBorder(5, 0, 0, 0, ColorScheme.DARK_GRAY_COLOR), BorderFactory.createEmptyBorder(8, 10, 8, 10)));
		overallPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		overallPanel.setLayout(new BorderLayout());

		// Add icon and contents
		final JPanel overallInfo = new JPanel();
		overallInfo.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		overallInfo.setLayout(new DynamicGridLayout(3, 1, 0, 4));
		overallInfo.setBorder(new EmptyBorder(2, 10, 2, 10));

		// Add title panel
		JPanel titleWrapper = new JPanel();
		titleWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		titleWrapper.setLayout(new DynamicGridLayout(1, 2, 0, 0));
		titleWrapper.setBorder(new EmptyBorder(2, 0, 0, 0));
		// Add username label
		usernameLabel.setHorizontalAlignment(SwingConstants.LEFT);
		usernameLabel.setFont(FontManager.getRunescapeBoldFont());
		titleWrapper.add(usernameLabel);
		// Add world label
		worldLabel.setHorizontalAlignment(SwingConstants.RIGHT);
		worldLabel.setFont(FontManager.getRunescapeFont());
		titleWrapper.add(worldLabel);
		overallInfo.add(titleWrapper);

		// Add last activity label
		activityLabel.setBorder(new EmptyBorder(0, 0, 2, 0));
		activityLabel.setHorizontalAlignment(SwingConstants.LEFT);
		activityLabel.setFont(FontManager.getRunescapeSmallFont());
		overallInfo.add(activityLabel);

		// Add gimp status data
		JPanel statusWrapper = new JPanel();
		statusWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		statusWrapper.setLayout(new DynamicGridLayout(2, 1, 0, 2));
		statusWrapper.setBorder(new EmptyBorder(2, 0, 2, 0));
		// HP icon and bar
		JPanel hpWrapper = new JPanel();
		hpWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		hpWrapper.setLayout(new DynamicGridLayout(1, 2, 2, 0));
		hpBar.setBackground(HP_BG);
		hpBar.setForeground(HP_FG);
		String hpUri = "/skill_icons_small/hitpoints.png";
		ImageIcon hpIcon = new ImageIcon(ImageUtil.loadImageResource(getClass(), hpUri));
		JLabel hpLabel = new JLabel(hpIcon);
		hpWrapper.add(hpLabel);
		hpWrapper.add(hpBar);
		// Prayer icon and bar
		JPanel prayerWrapper = new JPanel();
		prayerWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		prayerWrapper.setLayout(new DynamicGridLayout(1, 2, 2, 0));
		prayerBar.setBackground(PRAYER_BG);
		prayerBar.setForeground(PRAYER_FG);
		String prayerUri = "/skill_icons_small/prayer.png";
		ImageIcon prayerIcon = new ImageIcon(ImageUtil.loadImageResource(getClass(), prayerUri));
		JLabel prayerLabel = new JLabel(prayerIcon);
		prayerWrapper.add(prayerLabel);
		prayerWrapper.add(prayerBar);
		// Add HP and prayer data to info panel
		statusWrapper.add(hpWrapper);
		statusWrapper.add(prayerWrapper);
		overallInfo.add(statusWrapper);

		// Add overall info to the container
		overallPanel.add(overallInfo);
		return overallPanel;
	}

	/**
	 * Builds a JPanel displaying an icon and level/number associated with it.
	 */
	private JPanel makeHiscorePanel(HiscoreSkill skill)
	{
		assert SwingUtilities.isEventDispatchThread();

		HiscoreSkillType skillType = skill == null ? HiscoreSkillType.SKILL : skill.getType();

		JLabel label = new JLabel();
		label.setToolTipText(skill == null ? "Combat" : skill.getName());
		label.setFont(FontManager.getRunescapeSmallFont());
		label.setText(pad("--", skillType));

		String directory;
		if (skill == null || skill == OVERALL)
		{
			directory = "/skill_icons/";
		}
		else if (skill.getType() == HiscoreSkillType.BOSS)
		{
			// Boss icons are kept in the hiscores plugin resources folder - this should be
			// okay since hiscores is an official RuneLite plugin.
			directory = "/net/runelite/client/plugins/hiscore/bosses/";
		}
		else
		{
			directory = "/skill_icons_small/";
		}

		String skillName = (skill == null ? "combat" : skill.name().toLowerCase());
		String skillIcon = directory + skillName + ".png";
		log.debug("Loading skill icon from {}", skillIcon);

		// Because the path to the boss icons is less reliable, we want to catch the exception
		// if boss icons are not found due to that path changing.
		try
		{
			label.setIcon(new ImageIcon(ImageUtil.loadImageResource(getClass(), skillIcon)));
		}
		catch (Exception e)
		{
			log.debug(e.toString());
		}

		boolean totalLabel = skill == OVERALL || skill == null; // overall or combat
		label.setIconTextGap(totalLabel ? 10 : 4);

		JPanel skillPanel = new JPanel();
		skillPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		skillPanel.setBorder(new EmptyBorder(2, 0, 2, 0));
		skillLabels.put(skill, label);
		skillPanel.add(label);

		return skillPanel;
	}

	private JPanel makeNotesPanel()
	{
		assert SwingUtilities.isEventDispatchThread();

		JPanel notesPanel = new JPanel();
		notesPanel.setLayout(new DynamicGridLayout(2, 1, 0, 2));
		notesPanel.setBorder(new EmptyBorder(2, 0, 2, 0));

		JLabel notesLabel = new JLabel();
		notesLabel.setText("Notes");
		notesLabel.setHorizontalAlignment(SwingConstants.LEFT);
		notesLabel.setFont(FontManager.getRunescapeBoldFont());
		notesLabel.setForeground(ColorScheme.BRAND_ORANGE);
		notesPanel.add(notesLabel);

		notesPanel.add(this.gimNotes);

		return notesPanel;
	}

	private void loadGimpData()
	{
		// If for some reason no tab was selected, default to normal
		if (selectedGimp == null)
		{
			resetSelectedTab();
		}

		final String gimpName = selectedGimp;

		// Sanity check, GIM clan channel definitely loaded by now
		ClanChannel gimClanChannel = client.getClanChannel(ClanID.GROUP_IRONMAN);
		if (gimClanChannel == null)
		{
			loading = false;
			return;
		}

		loading = true;

		// Display gimp data
		GimPlayer gimp = group.getGimp(gimpName);
		SwingUtilities.invokeLater(() -> {
			// Apply gimp data to panel
			applyGimpData(gimp);

			// Reinitialize hiscore data table
			for (Map.Entry<HiscoreSkill, JLabel> entry : skillLabels.entrySet())
			{
				HiscoreSkill skill = entry.getKey();
				JLabel label = entry.getValue();
				HiscoreSkillType skillType = skill == null ? HiscoreSkillType.SKILL : skill.getType();

				label.setText(pad("--", skillType));
				label.setToolTipText(skill == null ? "Combat" : skill.getName());
			}
		});

		// Fetch gimp hiscores and apply to empty table
		group.getHiscores(gimpName).whenCompleteAsync((result, ex) -> {
			if (!gimpName.equals(selectedGimp))
			{
				// Selected gimp has changed in the meantime
				return;
			}

			if (result == null)
			{
				loading = false;
				return;
			}

			// Successful player lookup
			loading = false;
			SwingUtilities.invokeLater(() -> {
				fillGimpStatusData(gimp, result);
				applyHiscoreResult(result);
			});
		});
	}

	public void updateGimpData(GimPlayer gimpData)
	{
		SwingUtilities.invokeLater(() -> {
			if (selectedGimp != null && selectedGimp.equals(gimpData.getName()))
			{
				GimPlayer gimp = group.getGimp(selectedGimp);
				if (gimpData.getHp() != null || gimpData.getMaxHp() != null)
				{
					int hpValue = gimpData.getHp() != null ? gimpData.getHp() : gimp.getHp();
					int maxHpValue = gimpData.getMaxHp() != null ? gimpData.getMaxHp() : gimp.getMaxHp();
					setHpBar(selectedGimp, hpValue, maxHpValue);
				}
				if (gimpData.getPrayer() != null || gimpData.getMaxPrayer() != null)
				{
					int prayerValue = gimpData.getPrayer() != null ? gimpData.getPrayer() : gimp.getPrayer();
					int maxPrayerValue = gimpData.getMaxPrayer() != null ? gimpData.getMaxPrayer() : gimp.getMaxPrayer();
					setPrayerBar(selectedGimp, prayerValue, maxPrayerValue);
				}
				if (gimpData.getLastActivity() != null)
				{
					setLastActivity(selectedGimp, gimpData.getLastActivity(), gimp.getWorld());
				}
				// Update more gimp data...
			}
		});
	}

	public void setConnectionStatus(boolean status)
	{
		String statusText = status ? "Connected" : "Disconnected";
		String openingTags = "<html><body style = 'padding: 5px;color:#989898'>";
		String closingTags = "</body></html>";
		String tooltipText = "<p><span style = 'color:white'>" + "You are currently " + statusText.toLowerCase(Locale.ROOT) + "." + "</span></p>";
		String helpText = "<p><span style = 'color:white'>" + "To connect, please follow " + "the instructions on the plugin help page." + "</span></p>";
		connectionLabel.setText(statusText);
		connectionLabel.setForeground(status ? Color.CYAN : ColorScheme.LIGHT_GRAY_COLOR);
		connectionLabel.setToolTipText(openingTags + tooltipText + (status ? "" : " " + helpText) + closingTags);
	}

	public void setHpBar(String gimpName, Integer hp, Integer maxHp)
	{
		if (selectedGimp != null && selectedGimp.equals(gimpName))
		{
			hpBar.setValue(formatStatusValue(hp));
			hpBar.setMaximumValue(formatStatusValue(maxHp));
			hpBar.setCenterLabel(formatStatusValue(hp) + "/" + formatStatusValue(maxHp));
		}
	}

	public void setPrayerBar(String gimpName, Integer prayer, Integer maxPrayer)
	{
		if (selectedGimp != null && selectedGimp.equals(gimpName))
		{
			prayerBar.setValue(formatStatusValue(prayer));
			prayerBar.setMaximumValue(formatStatusValue(maxPrayer));
			prayerBar.setCenterLabel(formatStatusValue(prayer) + "/" + formatStatusValue(maxPrayer));
		}
	}

	public void setLastActivity(String gimpName, String activity, int world)
	{
		if (selectedGimp != null && selectedGimp.equals(gimpName))
		{
			String activityText;

			// If activity is empty or reserved IN_GAME_ACTIVITY, use generic text
			if (activity == null || activity.isEmpty() || activity.equals(GimPlayer.IN_GAME_ACTIVITY))
			{
				activityText = world == 0 ? htmlLabelStr("Last activity:", "inactive") : htmlLabelStr("Currently:", "in game");
			}
			// Select descriptor text based on whether gimp is logged in
			else if (world == 0)
			{
				activityText = htmlLabelStr("Last activity:", activity.toLowerCase(Locale.ROOT));
			}
			else
			{
				activityText = htmlLabelStr("Currently:", "training " + activity.toLowerCase(Locale.ROOT));
			}
			activityLabel.setText(activityText);
		}
	}

	public void setWorld(String gimpName, int world)
	{
		boolean isOnline = world != 0;
		if (tabGroup != null)
		{
			GimTab tab = tabGroup.getTab(gimpName);
			tab.setStatus(isOnline);
		}
		if (selectedGimp != null && selectedGimp.equals(gimpName))
		{
			worldLabel.setText(isOnline ? "W" + world : "Offline");
			worldLabel.setForeground(isOnline ? Color.GREEN : Color.RED);
		}
	}

	public void setNotes(String gimpName, String notes)
	{
		if (selectedGimp != null && selectedGimp.equals(gimpName))
		{
			// First we check if we need to enable/disable the text area
			final Player localPlayer = client.getLocalPlayer();
			boolean isLocal = gimpName.equals(localPlayer.getName());
			gimNotes.setEnabled(isLocal);
			// Set the tooltip text depending on local player or not
			String toolTipText = isLocal ? "Share notes with the group!" : gimpName + "'s notes";
			gimNotes.setToolTipText(toolTipText);
			// Set the actual note text
			gimNotes.setNotes(notes);
		}
	}

	private void applyGimpData(GimPlayer gimp)
	{
		assert SwingUtilities.isEventDispatchThread();

		String gimpName = gimp.getName();
		usernameLabel.setText(gimpName);

		setWorld(gimpName, group.getCurrentWorld(gimpName));
		setHpBar(gimpName, gimp.getHp(), gimp.getMaxHp());
		setPrayerBar(gimpName, gimp.getPrayer(), gimp.getMaxPrayer());
		setLastActivity(gimpName, gimp.getLastActivity(), gimp.getWorld());
		setNotes(gimpName, gimp.getNotes());
	}

	/**
	 * Uses the hiscores result to fill missing HP/prayer status data.
	 *
	 * @param result HiscoreResult
	 */
	private void fillGimpStatusData(GimPlayer gimp, HiscoreResult result)
	{
		assert SwingUtilities.isEventDispatchThread();

		if (gimp.getMaxHp() == null)
		{
			setHpBar(gimp.getName(), gimp.getHp(), result.getSkill(HITPOINTS).getLevel());
		}
		if (gimp.getMaxPrayer() == null)
		{
			setPrayerBar(gimp.getName(), gimp.getPrayer(), result.getSkill(PRAYER).getLevel());
		}
	}

	private void applyHiscoreResult(HiscoreResult result)
	{
		assert SwingUtilities.isEventDispatchThread();

		for (Map.Entry<HiscoreSkill, JLabel> entry : skillLabels.entrySet())
		{
			HiscoreSkill skill = entry.getKey();
			JLabel label = entry.getValue();
			Skill s;

			if (skill == null)
			{
				if (result.getPlayer() != null)
				{
					int combatLevel = Experience.getCombatLevel(
						result.getSkill(ATTACK).getLevel(),
						result.getSkill(STRENGTH).getLevel(),
						result.getSkill(DEFENCE).getLevel(),
						result.getSkill(HITPOINTS).getLevel(),
						result.getSkill(MAGIC).getLevel(),
						result.getSkill(RANGED).getLevel(),
						result.getSkill(PRAYER).getLevel()
					);
					label.setText(Integer.toString(combatLevel));
				}
			}
			else if ((s = result.getSkill(skill)) != null)
			{
				final long exp = s.getExperience();
				final boolean isSkill = skill.getType() == HiscoreSkillType.SKILL;
				int level = -1;
				if (!isSkill || exp != -1L)
				{
					// For skills, level is only valid if exp is not -1
					// otherwise level is always valid
					level = s.getLevel();
				}

				if (level != -1)
				{
					label.setText(pad(formatLevel(level), skill.getType()));
				}
			}

			label.setToolTipText(detailsHtml(result, skill));
		}
	}

	/**
	 * Builds a html string to display on tooltip (when hovering a skill).
	 */
	private String detailsHtml(HiscoreResult result, HiscoreSkill skill)
	{
		String openingTags = "<html><body style = 'padding: 5px;color:#989898'>";
		String closingTags = "</body></html>";

		String content = "";

		if (skill == null)
		{
			double combatLevel = Experience.getCombatLevelPrecise(result.getSkill(ATTACK).getLevel(), result.getSkill(STRENGTH).getLevel(), result.getSkill(DEFENCE).getLevel(), result.getSkill(HITPOINTS).getLevel(), result.getSkill(MAGIC).getLevel(), result.getSkill(RANGED).getLevel(), result.getSkill(PRAYER).getLevel());

			double combatExperience = result.getSkill(ATTACK).getExperience() + result.getSkill(STRENGTH).getExperience() + result.getSkill(DEFENCE).getExperience() + result.getSkill(HITPOINTS).getExperience() + result.getSkill(MAGIC).getExperience() + result.getSkill(RANGED).getExperience() + result.getSkill(PRAYER).getExperience();

			content += "<p><span style = 'color:white'>Combat</span></p>";
			content += "<p><span style = 'color:white'>Exact Combat Level:</span> " + QuantityFormatter.formatNumber(combatLevel) + "</p>";
			content += "<p><span style = 'color:white'>Experience:</span> " + QuantityFormatter.formatNumber(combatExperience) + "</p>";
		}
		else
		{
			switch (skill)
			{
				case CLUE_SCROLL_ALL:
				{
					String allRank = (result.getSkill(CLUE_SCROLL_ALL).getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(result.getSkill(CLUE_SCROLL_ALL).getRank());
					String beginnerRank = (result.getSkill(CLUE_SCROLL_BEGINNER).getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(result.getSkill(CLUE_SCROLL_BEGINNER).getRank());
					String easyRank = (result.getSkill(CLUE_SCROLL_BEGINNER).getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(result.getSkill(CLUE_SCROLL_EASY).getRank());
					String mediumRank = (result.getSkill(CLUE_SCROLL_MEDIUM).getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(result.getSkill(CLUE_SCROLL_MEDIUM).getRank());
					String hardRank = (result.getSkill(CLUE_SCROLL_HARD).getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(result.getSkill(CLUE_SCROLL_HARD).getRank());
					String eliteRank = (result.getSkill(CLUE_SCROLL_ELITE).getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(result.getSkill(CLUE_SCROLL_ELITE).getRank());
					String masterRank = (result.getSkill(CLUE_SCROLL_MASTER).getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(result.getSkill(CLUE_SCROLL_MASTER).getRank());
					String all = (result.getSkill(CLUE_SCROLL_ALL).getLevel() == -1 ? "0" : QuantityFormatter.formatNumber(result.getSkill(CLUE_SCROLL_ALL).getLevel()));
					String beginner = (result.getSkill(CLUE_SCROLL_BEGINNER).getLevel() == -1 ? "0" : QuantityFormatter.formatNumber(result.getSkill(CLUE_SCROLL_BEGINNER).getLevel()));
					String easy = (result.getSkill(CLUE_SCROLL_EASY).getLevel() == -1 ? "0" : QuantityFormatter.formatNumber(result.getSkill(CLUE_SCROLL_EASY).getLevel()));
					String medium = (result.getSkill(CLUE_SCROLL_MEDIUM).getLevel() == -1 ? "0" : QuantityFormatter.formatNumber(result.getSkill(CLUE_SCROLL_MEDIUM).getLevel()));
					String hard = (result.getSkill(CLUE_SCROLL_HARD).getLevel() == -1 ? "0" : QuantityFormatter.formatNumber(result.getSkill(CLUE_SCROLL_HARD).getLevel()));
					String elite = (result.getSkill(CLUE_SCROLL_ELITE).getLevel() == -1 ? "0" : QuantityFormatter.formatNumber(result.getSkill(CLUE_SCROLL_ELITE).getLevel()));
					String master = (result.getSkill(CLUE_SCROLL_MASTER).getLevel() == -1 ? "0" : QuantityFormatter.formatNumber(result.getSkill(CLUE_SCROLL_MASTER).getLevel()));
					content += "<p><span style = 'color:white'>Clues</span></p>";
					content += "<p><span style = 'color:white'>All:</span> " + all + " <span style = 'color:white'>Rank:</span> " + allRank + "</p>";
					content += "<p><span style = 'color:white'>Beginner:</span> " + beginner + " <span style = 'color:white'>Rank:</span> " + beginnerRank + "</p>";
					content += "<p><span style = 'color:white'>Easy:</span> " + easy + " <span style = 'color:white'>Rank:</span> " + easyRank + "</p>";
					content += "<p><span style = 'color:white'>Medium:</span> " + medium + " <span style = 'color:white'>Rank:</span> " + mediumRank + "</p>";
					content += "<p><span style = 'color:white'>Hard:</span> " + hard + " <span style = 'color:white'>Rank:</span> " + hardRank + "</p>";
					content += "<p><span style = 'color:white'>Elite:</span> " + elite + " <span style = 'color:white'>Rank:</span> " + eliteRank + "</p>";
					content += "<p><span style = 'color:white'>Master:</span> " + master + " <span style = 'color:white'>Rank:</span> " + masterRank + "</p>";
					break;
				}
				case BOUNTY_HUNTER_ROGUE:
				{
					Skill bountyHunterRogue = result.getSkill(BOUNTY_HUNTER_ROGUE);
					String rank = (bountyHunterRogue.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(bountyHunterRogue.getRank());
					content += "<p><span style = 'color:white'>Bounty Hunter - Rogue</span></p>";
					content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
					if (bountyHunterRogue.getLevel() > -1)
					{
						content += "<p><span style = 'color:white'>Score:</span> " + QuantityFormatter.formatNumber(bountyHunterRogue.getLevel()) + "</p>";
					}
					break;
				}
				case BOUNTY_HUNTER_HUNTER:
				{
					Skill bountyHunterHunter = result.getSkill(BOUNTY_HUNTER_HUNTER);
					String rank = (bountyHunterHunter.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(bountyHunterHunter.getRank());
					content += "<p><span style = 'color:white'>Bounty Hunter - Hunter</span></p>";
					content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
					if (bountyHunterHunter.getLevel() > -1)
					{
						content += "<p><span style = 'color:white'>Score:</span> " + QuantityFormatter.formatNumber(bountyHunterHunter.getLevel()) + "</p>";
					}
					break;
				}
				case LAST_MAN_STANDING:
				{
					Skill lastManStanding = result.getSkill(LAST_MAN_STANDING);
					String rank = (lastManStanding.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(lastManStanding.getRank());
					content += "<p><span style = 'color:white'>Last Man Standing</span></p>";
					content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
					if (lastManStanding.getLevel() > -1)
					{
						content += "<p><span style = 'color:white'>Score:</span> " + QuantityFormatter.formatNumber(lastManStanding.getLevel()) + "</p>";
					}
					break;
				}
				case SOUL_WARS_ZEAL:
				{
					Skill soulWarsZeal = result.getSkill(SOUL_WARS_ZEAL);
					String rank = (soulWarsZeal.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(soulWarsZeal.getRank());
					content += "<p><span style = 'color:white'>Soul Wars Zeal</span></p>";
					content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
					if (soulWarsZeal.getLevel() > -1)
					{
						content += "<p><span style = 'color:white'>Score:</span> " + QuantityFormatter.formatNumber(soulWarsZeal.getLevel()) + "</p>";
					}
					break;
				}
				case LEAGUE_POINTS:
				{
					Skill leaguePoints = result.getSkill(LEAGUE_POINTS);
					String rank = (leaguePoints.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(leaguePoints.getRank());
					content += "<p><span style = 'color:white'>League Points</span></p>";
					content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
					if (leaguePoints.getLevel() > -1)
					{
						content += "<p><span style = 'color:white'>Points:</span> " + QuantityFormatter.formatNumber(leaguePoints.getLevel()) + "</p>";
					}
					break;
				}
				case OVERALL:
				{
					Skill requestedSkill = result.getSkill(skill);
					String rank = (requestedSkill.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(requestedSkill.getRank());
					String exp = (requestedSkill.getExperience() == -1L) ? "Unranked" : QuantityFormatter.formatNumber(requestedSkill.getExperience());
					content += "<p><span style = 'color:white'>" + skill.getName() + "</span></p>";
					content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
					content += "<p><span style = 'color:white'>Experience:</span> " + exp + "</p>";
					break;
				}
				default:
				{
					if (skill.getType() == HiscoreSkillType.BOSS)
					{
						String rank = "Unranked";
						String lvl = null;
						Skill requestedSkill = result.getSkill(skill);
						if (requestedSkill != null)
						{
							if (requestedSkill.getRank() > -1)
							{
								rank = QuantityFormatter.formatNumber(requestedSkill.getRank());
							}
							if (requestedSkill.getLevel() > -1)
							{
								lvl = QuantityFormatter.formatNumber(requestedSkill.getLevel());
							}
						}

						content += "<p><span style = 'color:white'>Boss:</span> " + skill.getName() + "</p>";
						content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
						if (lvl != null)
						{
							content += "<p><span style = 'color:white'>KC:</span> " + lvl + "</p>";
						}
					}
					else
					{
						Skill requestedSkill = result.getSkill(skill);
						final long experience = requestedSkill.getExperience();

						String rank = (requestedSkill.getRank() == -1) ? "Unranked" : QuantityFormatter.formatNumber(requestedSkill.getRank());
						String exp = (experience == -1L) ? "Unranked" : QuantityFormatter.formatNumber(experience);
						String remainingXp;
						if (experience == -1L)
						{
							remainingXp = "Unranked";
						}
						else
						{
							int currentLevel = Experience.getLevelForXp((int) experience);
							remainingXp = (currentLevel + 1 <= Experience.MAX_VIRT_LEVEL) ? QuantityFormatter.formatNumber(Experience.getXpForLevel(currentLevel + 1) - experience) : "0";
						}

						content += "<p><span style = 'color:white'>Skill:</span> " + skill.getName() + "</p>";
						content += "<p><span style = 'color:white'>Rank:</span> " + rank + "</p>";
						content += "<p><span style = 'color:white'>Experience:</span> " + exp + "</p>";
						content += "<p><span style = 'color:white'>Remaining XP:</span> " + remainingXp + "</p>";
					}
					break;
				}
			}
		}

		// Add a html progress bar to the hover information
		if (skill != null && skill.getType() == HiscoreSkillType.SKILL)
		{
			long experience = result.getSkill(skill).getExperience();
			if (experience >= 0)
			{
				int currentXp = (int) experience;
				int currentLevel = Experience.getLevelForXp(currentXp);
				int xpForCurrentLevel = Experience.getXpForLevel(currentLevel);
				int xpForNextLevel = currentLevel + 1 <= Experience.MAX_VIRT_LEVEL ? Experience.getXpForLevel(currentLevel + 1) : -1;

				double xpGained = currentXp - xpForCurrentLevel;
				double xpGoal = xpForNextLevel != -1 ? xpForNextLevel - xpForCurrentLevel : 100;
				int progress = (int) ((xpGained / xpGoal) * 100f);

				// Had to wrap the bar with an empty div, adding the margin directly to the bar causes issues
				content += "<div style = 'margin-top:3px'>" + "<div style = 'background: #070707; border: 1px solid #070707; height: 6px; width: 100%;'>" + "<div style = 'height: 6px; width: " + progress + "%; background: #dc8a00;'>" + "</div>" + "</div>" + "</div>";
			}
		}

		return openingTags + content + closingTags;
	}

	private static String htmlLabelInt(String key, int value)
	{
		final String valueStr = QuantityFormatter.quantityToStackSize(value);
		return String.format(HTML_LABEL_TEMPLATE, ColorUtil.toHexColor(ColorScheme.LIGHT_GRAY_COLOR), key, valueStr);
	}

	private static String htmlLabelStr(String key, String value)
	{
		String SPACE_CHAR = " ";
		return "<html><body style = 'color:#a5a5a5'>" + key + SPACE_CHAR + "<span style = 'color:white'>" + value + "</span></body></html>";
	}

	private void resetSelectedTab()
	{
		tabGroup.select(tabGroup.getTab(defaultTab));
	}

	private static int formatStatusValue(Integer statusValue)
	{
		if (statusValue == null)
		{
			return 0;
		}
		return statusValue;
	}

	private static String formatLevel(int level)
	{
		if (level < 10000)
		{
			return Integer.toString(level);
		}
		else
		{
			return (level / 1000) + "k";
		}
	}

	private static String pad(String str, HiscoreSkillType type)
	{
		// Left pad label text to keep labels aligned
		int pad = type == HiscoreSkillType.BOSS ? 4 : 2;
		return StringUtils.leftPad(str, pad);
	}
}

/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp;

import com.gimp.gimps.GimLocation;
import com.gimp.gimps.GimPlayer;
import com.gimp.gimps.Group;
import com.gimp.map.GimWorldMapPoint;
import com.gimp.map.GimWorldMapPointManager;
import com.gimp.tasks.Task;
import com.gimp.tasks.TaskManager;
import com.google.gson.Gson;
import com.google.inject.Provides;
import io.socket.emitter.Emitter;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanID;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.input.KeyManager;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.externalplugins.ExternalPluginManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.party.data.PartyTilePingData;
import net.runelite.client.plugins.party.messages.TilePing;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import okhttp3.OkHttpClient;
import org.json.JSONObject;

@Slf4j
@PluginDescriptor(name = "GIMP")
public class GimPlugin extends Plugin
{
	public final static int OFFLINE_WORLD = 0;
	private final static int MAP_POINT_TICK_PERIOD = 300;

	@Inject
	private TaskManager taskManager;

	@Inject
	@Getter
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private KeyManager keyManager;

	@Inject
	private OkHttpClient okHttpClient;

	@Inject
	@Getter
	private GimPluginConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	@Getter
	private Group group;

	@Inject
	private Gson gson;

	@Inject
	private GimPingOverlay gimPingOverlay;

	@Getter
	private final List<PartyTilePingData> pendingTilePings = Collections.synchronizedList(new ArrayList<>());

	private boolean pingHotkeyPressed = false;

	@Inject
	private GimWorldMapPointManager gimWorldMapPointManager;

	private GimBroadcastManager gimBroadcastManager;

	private GimPluginPanel panel;

	private NavigationButton navButton;

	/**
	 * Toggle to determine if we're on an "even" frame or an "odd" frame of map point ticking.
	 * This is the simplest way to keep map point motion smooth and consistent, as we can either
	 * move by one tile each frame (fast) or move by one tile every other frame (slow),
	 * without any variation in delay or distance between each frame.
	 */
	private boolean frameToggle;

	final private Emitter.Listener onBroadcastConnect = new Emitter.Listener()
	{
		@Override
		public void call(Object... args)
		{
			// Set connection status to connected
			panel.setConnectionStatus(true);
		}
	};

	final private Emitter.Listener onBroadcastDisconnect = new Emitter.Listener()
	{
		@Override
		public void call(Object... args)
		{
			// Set connection status to disconnected
			panel.setConnectionStatus(false);
		}
	};

	final private Emitter.Listener onBroadcastReconnect = new Emitter.Listener()
	{
		@Override
		public void call(Object... args)
		{
			clientThread.invoke(() -> {
				// Update panel connection status
				panel.setConnectionStatus(true);
				// Update local gimp
				group.localUpdate();
				// Send out broadcast
				broadcastUpdate(group.getLocalGimp().getGimpData());
				// Ping for initial gimp data
				pingForUpdate(false);
			});
		}
	};

	private final HotkeyListener hotkeyListener = new HotkeyListener(() -> config.pingHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			pingHotkeyPressed = true;
		}

		@Override
		public void hotkeyReleased()
		{
			pingHotkeyPressed = false;
		}
	};

	@Override
	protected void startUp()
	{
		log.debug("GIMP started!");
		// Add the panel to the sidebar
		addPanel();
		// If logged into ironman account, load gimp data and start broadcasting
		ClanChannel gimClanChannel = client.getClanChannel(ClanID.GROUP_IRONMAN);
		if (gimClanChannel != null && client.getGameState() == GameState.LOGGED_IN)
		{
			load();
		}
		// Otherwise, do nothing and display the unloaded panel
		else
		{
			panel.unload();
		}
		// Set up listener and overlay for pings
		keyManager.registerKeyListener(hotkeyListener);
		overlayManager.add(gimPingOverlay);
	}

	@Override
	protected void shutDown()
	{
		log.debug("GIMP stopped!");
		keyManager.unregisterKeyListener(hotkeyListener);
		overlayManager.remove(gimPingOverlay);
		unload();
		removePanel();
	}

	private void load()
	{
		group.load().whenCompleteAsync((result, ex) -> {
			panel.load();
			startBroadcast();
		});
	}

	private void unload()
	{
		stopBroadcast();
		gimWorldMapPointManager.clear();
		panel.unload();
		group.unload();
	}

	/* EVENTS */

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		// If game state changes to the login screen or hopping, or connection is lost, stop the broadcast
		GameState gameState = gameStateChanged.getGameState();
		if (gameState == GameState.LOGIN_SCREEN || gameState == GameState.HOPPING || gameState == GameState.CONNECTION_LOST)
		{
			unload();
		}
	}

	@Subscribe
	public void onClanChannelChanged(ClanChannelChanged clanChannelChanged)
	{
		Player localPlayer = client.getLocalPlayer();
		ClanChannel changedClanChannel = clanChannelChanged.getClanChannel();
		if (changedClanChannel != null && localPlayer != null)
		{
			ClanChannel gimClanChannel = client.getClanChannel(ClanID.GROUP_IRONMAN);
			if (changedClanChannel == gimClanChannel)
			{
				String gimClanChannelName = gimClanChannel.getName();
				log.debug("GIM clan joined: " + gimClanChannelName);
				// Once group is loaded, we can display panel and start the broadcast
				load();
			}
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		// Don't bother checking until gimps are loaded
		GimPlayer localGimp = group.getLocalGimp();
		if (localGimp != null)
		{
			final int currentHp = client.getBoostedSkillLevel(Skill.HITPOINTS);
			final int currentPrayer = client.getBoostedSkillLevel(Skill.PRAYER);
			// If HP value has changed, update
			if (currentHp != localGimp.getHp())
			{
				updateHp(currentHp);
			}
			// If prayer value has changed, update
			if (currentPrayer != localGimp.getPrayer())
			{
				updatePrayer(currentPrayer);
			}
			// If any gimp world / online status has changed, update
			for (GimPlayer gimp : group.getGimps())
			{
				final int currentWorld = group.getCurrentWorld(gimp.getName());
				final int lastWorld = gimp.getWorld();
				if (currentWorld != lastWorld)
				{
					updateWorld(gimp, currentWorld);
					// If logging in or out, update last activity panel text
					if (currentWorld == OFFLINE_WORLD || lastWorld == OFFLINE_WORLD)
					{
						panel.setLastActivity(gimp.getName(), gimp.getLastActivity(), currentWorld);
					}
				}
			}
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged statChanged)
	{
		// Don't bother checking until gimps are loaded
		GimPlayer localGimp = group.getLocalGimp();
		if (localGimp != null)
		{
			String activity = statChanged.getSkill().toString();
			final int currentHp = client.getBoostedSkillLevel(Skill.HITPOINTS);
			final int currentMaxHp = client.getRealSkillLevel(Skill.HITPOINTS);
			final int currentPrayer = client.getBoostedSkillLevel(Skill.PRAYER);
			final int currentMaxPrayer = client.getRealSkillLevel(Skill.PRAYER);
			if (
				// Except if the gimp's HP is going up/down
				!(statChanged.getSkill() == Skill.HITPOINTS && currentHp != localGimp.getHp())
					// or if the gimp's prayer is going up/down
					&& !(statChanged.getSkill() == Skill.PRAYER && currentPrayer != localGimp.getPrayer()))
			{
				// If max (real) HP value has changed, broadcast
				if (statChanged.getSkill() == Skill.HITPOINTS && currentMaxHp != localGimp.getMaxHp())
				{
					updateMaxHp(currentMaxHp);
				}
				// If max (real) prayer value has changed, broadcast
				else if (statChanged.getSkill() == Skill.PRAYER && currentMaxPrayer != localGimp.getMaxPrayer())
				{
					updateMaxPrayer(currentMaxPrayer);
				}
				// Process XP changed for last activity update, except never Hitpoints
				else if ((localGimp.getLastActivity() == null || !activity.equals(localGimp.getLastActivity())) && statChanged.getSkill() != Skill.HITPOINTS)
				{
					updateLastActivity(activity);
				}
			}
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		String CONFIG_GROUP = "gimp";
		String SERVER_ADDRESS_KEY = "serverAddress";
		String GHOST_MODE = "ghostMode";
		// Check if one of GIMP's server address config value has changed
		if (configChanged.getGroup().equals(CONFIG_GROUP) && configChanged.getKey().equals(SERVER_ADDRESS_KEY))
		{
			if (gimBroadcastManager != null && gimBroadcastManager.isSocketConnected())
			{
				// If socket is currently connected, disconnect and let it reconnect with new address
				log.debug("Server address changed, disconnecting socket client");
				gimBroadcastManager.disconnectSocketClient();
			}
		}
		else if (configChanged.getGroup().equals(CONFIG_GROUP) && configChanged.getKey().equals(GHOST_MODE))
		{
			updateGhostMode(config.ghostMode());
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		// Handle ping event
		if (!pingHotkeyPressed || client.isMenuOpen() || group.getGimps().isEmpty() || !config.pings())
		{
			return;
		}
		Tile selectedSceneTile = client.getSelectedSceneTile();
		if (selectedSceneTile == null)
		{
			return;
		}
		boolean isOnCanvas = false;
		for (MenuEntry menuEntry : client.getMenuEntries())
		{
			if (menuEntry == null)
			{
				continue;
			}

			if ("walk here".equalsIgnoreCase(menuEntry.getOption()))
			{
				isOnCanvas = true;
			}
		}
		if (!isOnCanvas)
		{
			return;
		}
		event.consume();

		// Get tile ping data and update gimp
		final TilePing tilePing = new TilePing(selectedSceneTile.getWorldLocation());
		Map<String, Object> tilePingData = group.getLocalGimp().getData();
		tilePingData.put("tilePing", tilePing);
		broadcastUpdate(tilePingData);

		// Handle tile ping on client
		onTilePing(group.getLocalGimp(), tilePing);
	}

	public void onTilePing(GimPlayer gimp, TilePing tilePing)
	{
		// If pings are enabled, show the ping on canvas
		if (config.pings())
		{
			final Color color = gimp.getColor() != null ? gimp.getColor() : Color.RED;
			pendingTilePings.add(new PartyTilePingData(tilePing.getPoint(), color));
		}
		// If ping sounds are enabled, and it's local to the player, play it
		if (config.pingSound())
		{
			WorldPoint point = tilePing.getPoint();
			if (point.getPlane() != client.getPlane() || !WorldPoint.isInScene(client, point.getX(), point.getY()))
			{
				return;
			}
			clientThread.invoke(() -> client.playSoundEffect(SoundEffectID.SMITH_ANVIL_TINK));
		}
	}

	/* PLUGIN PANEL */

	private void addPanel()
	{
		// Panel must be injected this way to avoid UI inconsistencies
		panel = injector.getInstance(GimPluginPanel.class);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "gimpoint-small.png");
		// This is pretty arbitrary, but currently places the nav button at
		// the bottom of the list if there are no third-party plugin panels
		int lowPriority = 15;
		navButton = NavigationButton.builder().tooltip("GIMP").icon(icon).priority(lowPriority).panel(panel).build();
		clientToolbar.addNavigation(navButton);
	}

	private void removePanel()
	{
		clientToolbar.removeNavigation(navButton);
	}

	/* MAIN ACTIONS */

	/**
	 * Starts the main broadcast, connecting to the socket
	 * client and sending out the initial ping for data / broadcast.
	 * It also starts all broadcast-related interval tasks.
	 */
	private void startBroadcast()
	{
		// Failsafe so we don't have clients with multiple ongoing socket connections
		if (gimBroadcastManager != null && gimBroadcastManager.isSocketConnected())
		{
			gimBroadcastManager.disconnectSocketClient();
		}
		log.debug("Starting broadcast...");
		gimBroadcastManager = new GimBroadcastManager(group.getName(), okHttpClient, config, gson);
		gimBroadcastManager.connectSocketClient();
		setConnectionListeners(false);
		// Send out initial broadcast
		broadcastUpdate(group.getLocalGimp().getGimpData());
		// Ping for initial gimp data
		pingForUpdate(true);
		// Start listening for server broadcast
		listenForBroadcast();
		// Start interval-based broadcast tasks
		startIntervalTasks();
	}

	/**
	 * Sets connection status and calls other side effects based on
	 * connection event.
	 *
	 * @param onReconnect whether connection is to reconnect
	 */
	private void setConnectionListeners(boolean onReconnect)
	{
		Emitter.Listener onConnect = onReconnect ? onBroadcastReconnect : onBroadcastConnect;
		gimBroadcastManager.onBroadcastConnect(onConnect);
		// Use disconnect handler for connect error event b/c we just
		// want to set connection status to disconnected
		gimBroadcastManager.onBroadcastConnectError(onBroadcastDisconnect);
		gimBroadcastManager.onBroadcastDisconnect(onBroadcastDisconnect);
	}

	/**
	 * Listens for the socket "broadcast" event and updates
	 * gimp data.
	 */
	private void listenForBroadcast()
	{
		gimBroadcastManager.listen(new Emitter.Listener()
		{
			@Override
			public void call(Object... args)
			{
				JSONObject dataJson = (JSONObject) args[0];
				log.debug(dataJson.toString());
				GimPlayer gimpData = gimBroadcastManager.parseBroadcastData(dataJson.toString());
				handleUpdate(gimpData);
			}
		});
	}

	/**
	 * Starts all broadcast interval tasks, including handling socket
	 * reconnects, broadcasting location, and pinging for gimp data
	 * via HTTP if sockets fail.
	 */
	private void startIntervalTasks()
	{
		// Sanity check
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer != null)
		{
			long FIVE_SECONDS = 5000;
			Task socketConnectTask = new Task(FIVE_SECONDS * 2)
			{
				@Override
				public void run()
				{
					if (!gimBroadcastManager.isSocketConnected())
					{
						gimBroadcastManager.connectSocketClient();
						setConnectionListeners(true);
					}
				}
			};
			Task locationBroadcastTask = new Task(FIVE_SECONDS)
			{
				@Override
				public void run()
				{
					final GimPlayer localGimp = group.getLocalGimp();
					if (localGimp != null)
					{
						GimLocation gimLocation = new GimLocation(localPlayer.getWorldLocation());
						GimLocation lastLocation = localGimp.getLocation();
						// Don't update location if it hasn't changed
						if (lastLocation != null && GimLocation.compare(lastLocation, gimLocation))
						{
							return;
						}
						updateLocation(gimLocation);
					}
				}

				@Override
				public long delay()
				{
					if (gimBroadcastManager.isSocketConnected())
					{
						return period / 2;
					}
					return period;
				}
			};
			Task httpFallbackPingTask = new Task(FIVE_SECONDS * 2)
			{
				@Override
				public void run()
				{
					// If socket is not connected, fetch data (instead of waiting for broadcast)
					if (!gimBroadcastManager.isSocketConnected())
					{
						pingForUpdate(false);
					}
				}

				@Override
				public long delay()
				{
					// Start with default period
					long nextDelay = period;
					final Widget worldMapView = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
					// Quarter delay to 2.5 secs if world map is open
					if (worldMapView != null)
					{
						nextDelay = nextDelay / 4;
					}
					// Half delay if socket is connected: 1.25 secs if map open, 5 secs if closed
					if (gimBroadcastManager.isSocketConnected())
					{
						nextDelay = nextDelay / 2;
					}
					return nextDelay;
				}
			};
			Task tickMapPoints = new Task(MAP_POINT_TICK_PERIOD)
			{
				@Override
				public void run()
				{
					frameToggle = !frameToggle;
					for (GimPlayer gimp : group.getGimps())
					{
						if (gimp != null)
						{
							refreshMapPointVisibility(gimp);
							if (gimWorldMapPointManager.hasPoint(gimp.getName()))
							{
								final GimWorldMapPoint gimWorldMapPoint = gimWorldMapPointManager.getPoint(gimp.getName());
								final boolean moved = gimWorldMapPoint.moveTowardPlayer(frameToggle);
								if (moved)
								{
									gimWorldMapPoint.addFootstep(gimWorldMapPointManager, config.showFootsteps());
								}
							}
						}
					}
				}
			};
			taskManager.schedule(locationBroadcastTask, 0);
			taskManager.schedule(httpFallbackPingTask, FIVE_SECONDS / 2);
			taskManager.schedule(socketConnectTask, FIVE_SECONDS * 2);
			taskManager.schedule(tickMapPoints, 0);
		}
	}

	/**
	 * Broadcasts any gimp data to the server, invoking the request in a thread
	 * separate from the client thread.
	 *
	 * @param gimpData gimp data
	 */
	private void broadcastUpdate(Map<String, Object> gimpData)
	{
		gimBroadcastManager.broadcast(gimpData);
	}

	/**
	 * Sends a ping via HTTP or socket for all server gimp data, handling the
	 * result asynchronously. Sent when the broadcast starts and as a fallback
	 * if the socket disconnects.
	 */
	private void pingForUpdate(boolean initial)
	{
		gimBroadcastManager.ping().whenCompleteAsync((result, ex) -> {
			if (result != null)
			{
				for (GimPlayer gimp : group.getGimps())
				{
					GimPlayer gimpData = result.get(gimp.getName());
					if (gimpData != null)
					{
						// We can ignore all incoming updates to the local player except for the
						// initial one, which might be necessary for hydrating certain properties
						if (gimp == group.getLocalGimp())
						{
							if (initial)
							{
								handleInitialLocalUpdate(gimpData);
							}
						}
						else
						{
							handleUpdate(gimpData);
						}
					}
				}
			}
		});
	}

	/**
	 * Stops the broadcast, canceling all broadcast-related
	 * behaviors that are not initiated by RuneLite events.
	 */
	private void stopBroadcast()
	{
		log.debug("Stopping broadcast...");
		taskManager.resetTasks();
		if (gimBroadcastManager != null)
		{
			gimBroadcastManager.stopListening();
			gimBroadcastManager.disconnectSocketClient();
		}
	}

	/* UPDATE FUNCTIONS */

	/**
	 * Handles an initial update to the local player, hydrating specific
	 * gimp data and calling other update functionality.
	 *
	 * @param gimpData GimPlayer data
	 */
	private void handleInitialLocalUpdate(GimPlayer gimpData)
	{
		GimPlayer localGimp = group.getLocalGimp();
		if (localGimp != null)
		{
			group.localHydrate(gimpData);
			onUpdate(gimpData);
		}
	}

	/**
	 * Handles a normal update from the server, mapping gimp data to the
	 * corresponding gimp and calling other update functionality.
	 *
	 * @param gimpData GimPlayer data
	 */
	private void handleUpdate(GimPlayer gimpData)
	{
		group.update(gimpData);
		onUpdate(gimpData);
	}

	private void onUpdate(GimPlayer gimpData)
	{
		panel.updateGimpData(gimpData);
		if (gimpData.getNotes() != null)
		{
			panel.setNotes(gimpData.getName(), gimpData.getNotes());
		}
		if (gimpData.getTilePing() != null)
		{
			GimPlayer gimp = group.getGimp(gimpData.getName());
			onTilePing(gimp, gimpData.getTilePing());
		}
		if (gimpData.getGhostMode() != null && gimpData.getGhostMode())
		{
			GimPlayer gimp = group.getGimp(gimpData.getName());
			updateWorld(gimp, OFFLINE_WORLD);
		}
	}

	/**
	 * Updates the local gimp HP value and broadcasts
	 * the change.
	 *
	 * @param hp HP value of the local GimPlayer
	 */
	private void updateHp(int hp)
	{
		GimPlayer localGimp = group.getLocalGimp();
		if (localGimp != null)
		{
			// Set it locally first, to prevent loops
			localGimp.setHp(hp);
			panel.updateGimpData(localGimp);
			// Broadcast new HP value
			Map<String, Object> hpData = localGimp.getData();
			hpData.put("hp", hp);
			broadcastUpdate(hpData);
		}
	}

	/**
	 * Updates the local gimp max HP value and broadcasts
	 * the change.
	 *
	 * @param maxHp max HP value of the local GimPlayer
	 */
	private void updateMaxHp(int maxHp)
	{
		GimPlayer localGimp = group.getLocalGimp();
		if (localGimp != null)
		{
			// Set it locally first, to prevent loops
			localGimp.setMaxHp(maxHp);
			panel.updateGimpData(localGimp);
			// Broadcast new max HP value
			Map<String, Object> hpData = localGimp.getData();
			hpData.put("maxHp", maxHp);
			broadcastUpdate(hpData);
		}
	}

	/**
	 * Updates the local gimp prayer value and broadcasts
	 * the change.
	 *
	 * @param prayer prayer value of the local GimPlayer
	 */
	private void updatePrayer(int prayer)
	{
		GimPlayer localGimp = group.getLocalGimp();
		if (localGimp != null)
		{
			// Set it locally first, to prevent loops
			localGimp.setPrayer(prayer);
			panel.updateGimpData(localGimp);
			// Broadcast new prayer value
			Map<String, Object> prayerData = localGimp.getData();
			prayerData.put("prayer", prayer);
			broadcastUpdate(prayerData);
		}
	}

	/**
	 * Updates the local gimp max prayer value and broadcasts
	 * the change.
	 *
	 * @param maxPrayer max prayer value of the local GimPlayer
	 */
	private void updateMaxPrayer(int maxPrayer)
	{
		GimPlayer localGimp = group.getLocalGimp();
		if (localGimp != null)
		{
			// Set it locally first, to prevent loops
			localGimp.setMaxPrayer(maxPrayer);
			panel.updateGimpData(localGimp);
			// Broadcast new max prayer value
			Map<String, Object> prayerData = localGimp.getData();
			prayerData.put("maxPrayer", maxPrayer);
			broadcastUpdate(prayerData);
		}
	}

	/**
	 * Updates the world of provided GimPlayer, and sets the last activity
	 * since it is dependent on online status (world == 0).
	 *
	 * @param world world number of GimPlayer
	 */
	private void updateWorld(GimPlayer gimp, int world)
	{
		group.setWorld(gimp.getName(), world);
		panel.setWorld(gimp.getName(), world);
		panel.setLastActivity(gimp.getName(), gimp.getLastActivity(), world);
	}

	/**
	 * Updates the local gimp ghost mode value and broadcasts
	 * the change to the server. If ghost mode is turned off,
	 * includes all local gimp data in broadcast.
	 *
	 * @param ghostMode ghost mode setting of local GimPlayer
	 */
	private void updateGhostMode(boolean ghostMode)
	{
		GimPlayer localGimp = group.getLocalGimp();
		if (localGimp != null)
		{
			// Set new ghost mode locally before broadcast
			group.setGhostMode(localGimp.getName(), ghostMode);
			Map<String, Object> ghostModeData = ghostMode ? localGimp.getData() : localGimp.getGimpData(); // if ghostMode off, broadcast all data
			ghostModeData.put("ghostMode", ghostMode);
			broadcastUpdate(ghostModeData);
		}
	}

	/**
	 * Updates the local gimp location and broadcasts the change
	 * if ghost mode is not enabled.
	 *
	 * @param gimLocation world location of local GimPlayer
	 */
	private void updateLocation(GimLocation gimLocation)
	{
		GimPlayer localGimp = group.getLocalGimp();
		if (localGimp != null)
		{
			// Set location locally before broadcast
			group.setLocation(localGimp.getName(), gimLocation);
			panel.updateGimpData(localGimp);
			// Do not broadcast location at all if ghost mode is active
			if (!config.ghostMode())
			{
				Map<String, Object> data = localGimp.getData();
				data.put("location", gimLocation.getLocation());
				broadcastUpdate(data);
			}
		}
	}

	private void updateLastActivity(String activity)
	{
		GimPlayer localGimp = group.getLocalGimp();
		if (localGimp != null)
		{
			// Set activity locally before broadcast
			localGimp.setLastActivity(activity);
			panel.updateGimpData(localGimp);
			Map<String, Object> activityData = localGimp.getData();
			activityData.put("lastActivity", activity);
			broadcastUpdate(activityData);
		}
	}

	/**
	 * Updates the notes data in the client config and broadcasts
	 * the change.
	 *
	 * @param notes notes text string
	 */
	public void updateNotes(String notes)
	{
		GimPlayer localGimp = group.getLocalGimp();
		if (localGimp != null)
		{
			localGimp.setNotes(notes);
			// Set the notes data in the config as a fallback
			config.notesData(notes);
			Map<String, Object> notesData = localGimp.getData();
			notesData.put("notes", notes);
			broadcastUpdate(notesData);
		}
	}

	/**
	 * Determine if the given player's world map point should be displayed or not,
	 * then either add or remove it accordingly.
	 *
	 * @param gimp the player whose map point is to be refreshed
	 */
	private void refreshMapPointVisibility(GimPlayer gimp)
	{
		final String name = gimp.getName();
		final boolean isLocalGimp = gimp == group.getLocalGimp();
		final boolean shouldShow =
			// Condition 1: Player must have a location
			gimp.getLocation() != null
				// Condition 2: Must be another player (unless "show self" is on)
				&& (!isLocalGimp || config.showSelf())
				// Condition 3: Must not be in ghost mode (unless it's the local player)
				&& (gimp.shouldIncludeLocation() || isLocalGimp)
				// Condition 4: Must be logged in
				&& gimp.getWorld() != OFFLINE_WORLD;
		// Add or remove the player's world map point accordingly
		if (shouldShow && !gimWorldMapPointManager.hasPoint(name))
		{
			gimWorldMapPointManager.addPoint(gimp);
		}
		else if (!shouldShow && gimWorldMapPointManager.hasPoint(name))
		{
			gimWorldMapPointManager.removePoint(name);
		}
	}

	@Provides
	GimPluginConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(GimPluginConfig.class);
	}

	// Support testing via Gradle "run" task
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GimPlugin.class);
		RuneLite.main(args);
	}
}

/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.requests;

import com.gimp.GimPluginConfig;
import io.socket.client.Ack;
import io.socket.client.Socket;
import io.socket.engineio.client.transports.Polling;
import io.socket.engineio.client.transports.WebSocket;
import java.net.URI;
import io.socket.client.IO;
import java.util.concurrent.CompletableFuture;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.json.JSONObject;

@Slf4j
public class SocketClient extends RequestClient
{
	@Getter
	public Socket client;

	private static final String EVENT_CONNECTION_ACK = "connection-ack";

	public SocketClient(String namespace, GimPluginConfig config)
	{
		this.namespace = namespace;
		this.config = config;
	}

	/**
	 * Connects the socket to the server at the base URL, using default config
	 * for the connection. On connection, sets up socket listeners for socket
	 * lifecycle events, e.g. connect, disconnect, connect_error.
	 */
	public void connect()
	{
		if (!validateUrl())
		{
			log.warn("Invalid socket URL, aborting");
			return;
		}
		URI uri = URI.create(getBaseUrl());
		IO.Options options = IO.Options.builder()
			// IO factory options
			.setForceNew(false).setMultiplex(true)

			// low-level engine options
			.setTransports(new String[]{Polling.NAME, WebSocket.NAME}).setUpgrade(true).setRememberUpgrade(false).setPath("/socket.io/").setQuery(null).setExtraHeaders(null)

			// Manager options
			.setReconnection(true).setReconnectionAttempts(Integer.MAX_VALUE).setReconnectionDelay(1_000).setReconnectionDelayMax(5_000).setRandomizationFactor(0.5).setTimeout(20_000)

			// Socket options
			.setAuth(null).build();
		if (client != null)
		{
			client.close();
		}
		client = IO.socket(uri, options);
		client.connect();

		client.on(Socket.EVENT_CONNECT, args -> {
			log.debug("Socket connected");
			String roomId = namespace;
			client.emit(EVENT_CONNECTION_ACK, roomId);
		});

		client.on(Socket.EVENT_DISCONNECT, args -> {
			log.debug("Socket disconnected");
		});

		client.on(Socket.EVENT_CONNECT_ERROR, args -> {
			log.warn("Failed to connect to socket server, closing");
			client.close();
		});
	}

	/**
	 * Disconnects the client from the socket server.
	 */
	public void disconnect()
	{
		if (client != null)
		{
			client.disconnect();
		}
	}

	/**
	 * Checks if the client is connected to a socket server.
	 *
	 * @return whether socket is connected
	 */
	public boolean isConnected()
	{
		if (client != null)
		{
			return client.connected();
		}
		return false;
	}

	/**
	 * Sends a socket message to the ping listener. Expects an acknowledgement
	 * from the server, and returns the JSON data in that acknowledgement.
	 *
	 * @return future of ack data in JSON
	 */
	public CompletableFuture<String> ping()
	{
		String EVENT_PING = "ping";
		CompletableFuture<String> socketResponse = new CompletableFuture<>();
		client.emit(EVENT_PING, (Ack) args -> {
			JSONObject data = (JSONObject) args[0];
			socketResponse.complete(data.toString());
		});
		return socketResponse;
	}

	/**
	 * Sends a socket message to the broadcast listener. Passes the JSON data
	 * as the data parameter and expects an acknowledgement from the server.
	 *
	 * @param dataJson future of ack data in JSON
	 * @return future of ack data in JSON
	 */
	public CompletableFuture<String> broadcast(String dataJson)
	{
		String EVENT_BROADCAST = "broadcast";
		CompletableFuture<String> socketResponse = new CompletableFuture<>();
		client.emit(EVENT_BROADCAST, dataJson, (Ack) args -> {
			JSONObject data = (JSONObject) args[0];
			socketResponse.complete(data.toString());
		});
		return socketResponse;
	}
}

/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.requests;

import com.gimp.GimPluginConfig;
import java.net.URL;
import java.util.concurrent.CompletableFuture;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class RequestClient
{
	public GimPluginConfig config;

	/* Used to join a server-side socket room and/or namespace HTTP requests. */
	public String namespace;

	/**
	 * Gets the base URL from the address injected from the plugin config.
	 *
	 * @return server base URL
	 */
	public String getBaseUrl()
	{
		String configServerAddress = config.serverAddress();
		// Remove trailing slash(es) if exists
		String trailingSlashes = "/+$";
		configServerAddress = configServerAddress.replaceAll(trailingSlashes, "");
		if (!configServerAddress.contains("http"))
		{
			return "http://" + configServerAddress;
		}
		return configServerAddress;
	}

	/**
	 * Validates the URL from the config server address.
	 *
	 * @return whether the URL is valid
	 */
	public boolean validateUrl()
	{
		final URL url;
		if (config.serverAddress().isEmpty())
		{
			return false;
		}
		try
		{
			url = new URL(getBaseUrl());
		}
		catch (Exception e)
		{
			return false;
		}
		// URL must use HTTP/S protocol
		return url.getProtocol().contains("http");
	}

	/**
	 * Sends a /ping request or emits "ping" to the server.
	 *
	 * @return future of response data in JSON
	 */
	abstract public CompletableFuture<String> ping();

	/**
	 * Send a /broadcast request or emits "broadcast" to the server.
	 *
	 * @param dataJson request data in JSON
	 * @return future of response data in JSON
	 */
	abstract public CompletableFuture<String> broadcast(String dataJson);
}

/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.requests;

import com.gimp.GimPluginConfig;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import lombok.NonNull;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.MediaType;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;
import okhttp3.OkHttpClient;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class HttpClient extends RequestClient
{
	@Getter(AccessLevel.PACKAGE)
	public OkHttpClient client;

	public static final MediaType JSON = MediaType.get("application/json; charset=utf-8");

	public static final int OK = 200;

	public static final String EMPTY_BODY = "";

	public HttpClient(String namespace, OkHttpClient client, GimPluginConfig config)
	{
		this.config = config;
		this.namespace = namespace;
		this.client = client;
	}

	/**
	 * Makes an HTTP request with the given method to the URI at the client's
	 * base URL. Accepts on optional body argument for appropriate request methods.
	 *
	 * @param method HTTP method
	 * @param uri    URI path following base URL
	 * @param body   request body data
	 * @return future of response data in JSON
	 */
	private CompletableFuture<String> request(String method, String uri, RequestBody body)
	{
		CompletableFuture<String> result = new CompletableFuture<>();
		Request request = new Request.Builder()
			.url(getBaseUrl() + uri)
			.method(method, body)
			.build();
		client.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(@NonNull Call call, @NonNull IOException e)
			{
				log.error("Request failed: " + e);
			}

			@Override
			public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException
			{
				try (ResponseBody bodyJson = response.body())
				{
					if (!response.isSuccessful())
					{
						throw new IOException(response.code() + ": " + bodyJson);
					}
					if (bodyJson == null)
					{
						throw new RuntimeException("Response body is null: " + response);
					}
					result.complete(bodyJson.string());
				}
			}
		});
		return result;
	}

	/**
	 * Makes an HTTP GET request to the ping endpoint at the URL injected
	 * from the plugin config. A future of the JSON response body is returned.
	 *
	 * @return future of response data in JSON
	 */
	public CompletableFuture<String> ping()
	{
		return request("GET", "/ping/" + namespace, null);
	}

	/**
	 * Makes an HTTP POST request to the broadcast endpoint at the
	 * URL injected from the plugin config. The JSON data is sent
	 * in the request body. Times out after 5 seconds.
	 *
	 * @param dataJson request data in JSON
	 */
	public CompletableFuture<String> broadcast(String dataJson)
	{
		RequestBody body = RequestBody.create(JSON, dataJson);
		return request("POST", "/broadcast/" + namespace, body);
	}
}

/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.tasks;

interface TaskRunner
{
	void run();

	long delay();
}

public class Task implements TaskRunner
{
	final public long period;

	public Task(long defaultPeriod)
	{
		period = defaultPeriod;
	}

	/**
	 * Runs code that can be overridden, meant to be called
	 * after a delay.
	 */
	public void run()
	{
	}

	/**
	 * Returns the delay, can be overridden for a dynamic delay.
	 *
	 * @return duration in milliseconds by which to delay task
	 */
	public long delay()
	{
		return period;
	}
}

/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.tasks;

import java.util.Timer;
import java.util.TimerTask;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class TaskManager
{
	@Inject
	private Timer timer;

	/**
	 * Schedules a task to run after the delay and then schedules
	 * it again after calculating the next delay.
	 *
	 * @param task  task to run after a delay and then reschedule
	 * @param delay initial duration in milliseconds by which to delay task
	 */
	public void schedule(Task task, long delay)
	{
		TimerTask timerTask = new TimerTask()
		{
			@Override
			public void run()
			{
				task.run();
				long nextDelay = task.delay();
				if (nextDelay != 0)
				{
					schedule(task, nextDelay);
				}
			}
		};
		timer.schedule(timerTask, delay);
	}

	/**
	 * Purges any canceled tasks and cancels the timer, then
	 * creates a new one.
	 */
	public void resetTasks()
	{
		timer.purge();
		timer.cancel();
		timer = new Timer();
	}
}

/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;

@ConfigGroup("gimp")
public interface GimPluginConfig extends Config
{
	@ConfigItem(
		position = 0,
		keyName = "serverAddress",
		name = "Server Address",
		description = "Address of the remote GIMP server, check the GitHub for a public server address"
	)
	default String serverAddress()
	{
		return "";
	}

	@ConfigItem(
		position = 1,
		keyName = "ghostMode",
		name = "Ghost Mode",
		description = "Hide your status and location from your fellow gimps"
	)
	default boolean ghostMode()
	{
		return false;
	}

	@ConfigItem(
		position = 2,
		keyName = "showFootsteps",
		name = "Show Footsteps",
		description = "Choose how many footsteps to show on the map"
	)
	default int showFootsteps()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "pings",
		name = "Pings",
		description = "Enable group pings.<br>"
			+ "To ping, hold the ping hotkey down and click on the tile you want to ping.",
		position = 3
	)
	default boolean pings()
	{
		return true;
	}

	@ConfigItem(
		keyName = "pingSound",
		name = "Ping Sound",
		description = "Enable sound notification on group ping",
		position = 4
	)
	default boolean pingSound()
	{
		return true;
	}

	@ConfigItem(
		keyName = "pingHotkey",
		name = "Ping hotkey",
		description = "Key to hold to send a tile ping.<br>"
			+ "To ping, hold the ping hotkey down and click on the tile you want to ping.",
		position = 5
	)
	default Keybind pingHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigSection(
		position = 6,
		name = "Developer",
		description = "Developer settings"
	)
	String developerSection = "developerSection";

	@ConfigItem(
		position = 7,
		section = developerSection,
		keyName = "showSelf",
		name = "Show Self",
		description = "Show yourself on the map"
	)
	default boolean showSelf()
	{
		return false;
	}

	@ConfigItem(
		keyName = "notesData",
		name = "",
		description = "",
		hidden = true
	)
	default String notesData()
	{
		return "";
	}

	@ConfigItem(
		keyName = "notesData",
		name = "",
		description = ""
	)
	void notesData(String str);
}

/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp;

import com.gimp.gimps.GimPlayer;
import com.gimp.requests.*;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import io.socket.client.Socket;
import io.socket.emitter.Emitter;
import java.lang.reflect.Type;
import java.util.concurrent.CompletableFuture;
import lombok.extern.slf4j.Slf4j;
import java.util.Map;
import okhttp3.OkHttpClient;

@Slf4j
public class GimBroadcastManager
{
	private static final Type pingDataTypeForJson = new TypeToken<Map<String, GimPlayer>>()
	{
	}.getType();

	private static final String EVENT_BROADCAST = "broadcast";

	private final HttpClient httpClient;

	private final SocketClient socketClient;

	private final Gson gson;

	public GimBroadcastManager(String groupName, OkHttpClient okHttpClient, GimPluginConfig config, Gson gson)
	{
		this.gson = gson;
		httpClient = new HttpClient(groupName, okHttpClient, config);
		socketClient = new SocketClient(groupName, config);
	}

	/**
	 * Parses JSON string of the ping data and adds to a GimPlayer Map.
	 *
	 * @param dataJson JSON string of ping data
	 * @return map: name => GimPlayer
	 */
	private Map<String, GimPlayer> parsePingData(String dataJson)
	{
		return gson.fromJson(dataJson, pingDataTypeForJson);
	}

	/**
	 * Parses JSON string of the broadcast data and maps to a GimPlayer instance.
	 *
	 * @param dataJson JSON string of broadcast data
	 * @return GimPlayer
	 */
	public GimPlayer parseBroadcastData(String dataJson)
	{
		return gson.fromJson(dataJson, GimPlayer.class);
	}

	/**
	 * Checks if socket client is connected.
	 *
	 * @return whether socket is connected
	 */
	public boolean isSocketConnected()
	{
		return socketClient.isConnected();
	}

	/**
	 * Connects socket client to the server and joins the group's room.
	 */
	public void connectSocketClient()
	{
		socketClient.connect();
	}

	/**
	 * Registers a "connect" listener.
	 *
	 * @param handleConnect listener for the connect event
	 */
	public void onBroadcastConnect(Emitter.Listener handleConnect)
	{
		Socket client = socketClient.getClient();
		if (client != null)
		{
			client.on(Socket.EVENT_CONNECT, handleConnect);
		}
	}

	/**
	 * Registers a "disconnect" listener.
	 *
	 * @param handleDisconnect listener for the disconnect event
	 */
	public void onBroadcastDisconnect(Emitter.Listener handleDisconnect)
	{
		Socket client = socketClient.getClient();
		if (client != null)
		{
			client.on(Socket.EVENT_DISCONNECT, handleDisconnect);
		}
	}

	/**
	 * Registers a "connect_error" listener.
	 *
	 * @param handleError listener for the connect_error event
	 */
	public void onBroadcastConnectError(Emitter.Listener handleError)
	{
		Socket client = socketClient.getClient();
		if (client != null)
		{
			client.on(Socket.EVENT_CONNECT_ERROR, handleError);
		}
	}

	/**
	 * Disconnects socket client from the server.
	 */
	public void disconnectSocketClient()
	{
		socketClient.disconnect();
	}

	/**
	 * Gets broadcast client, using the socket client if it's
	 * connected and falling back on the HTTP client.
	 *
	 * @return a SocketClient or HTTPClient
	 */
	private RequestClient getRequestClient()
	{
		if (socketClient.isConnected())
		{
			return socketClient;
		}
		else
		{
			return httpClient;
		}
	}

	/**
	 * Starts listening for the "broadcast" socket event and passes in a listener
	 * to handle the broadcast data.
	 *
	 * @param handleBroadcast handler for processing the broadcast data
	 */
	public void listen(Emitter.Listener handleBroadcast)
	{
		Socket client = socketClient.getClient();
		if (client != null)
		{
			client.on(EVENT_BROADCAST, handleBroadcast);
		}
	}

	/**
	 * Turns off the listener for the "broadcast" event.
	 */
	public void stopListening()
	{
		Socket client = socketClient.getClient();
		if (client != null)
		{
			client.off(EVENT_BROADCAST);
		}
	}

	/**
	 * Sends broadcast request to the server via HTTP or socket.
	 *
	 * @param data gimp data
	 */
	public void broadcast(Map<String, Object> data)
	{
		try
		{
			RequestClient requestClient = getRequestClient();
			String dataJson = gson.toJson(data);
			requestClient.broadcast(dataJson).thenAccept((result) -> log.debug("Broadcast data: " + result));
		}
		catch (Exception e)
		{
			log.error("Broadcast error: " + e);
		}
	}

	/**
	 * Sends ping request to the server via HTTP or socket.
	 *
	 * @return future of map: name => GimPlayer
	 */
	public CompletableFuture<Map<String, GimPlayer>> ping()
	{
		RequestClient requestClient = getRequestClient();
		try
		{
			return requestClient.ping().thenApply((result) -> {
				log.debug("Ping data: " + result);
				return parsePingData(result);
			});
		}
		catch (Exception e)
		{
			log.error("Ping error: " + e);
			return null;
		}
	}
}

/*
 * Copyright (c) 2022, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.ui;

import com.google.common.base.Strings;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.BooleanSupplier;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JLayeredPane;
import javax.swing.SwingConstants;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.ColorScheme;

public class GimTab extends JLayeredPane
{
	private static final Border SELECTED_BORDER = new CompoundBorder(BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.BRAND_ORANGE), BorderFactory.createEmptyBorder(5, 10, 4, 10));

	private static final Border UNSELECTED_BORDER = BorderFactory.createEmptyBorder(5, 10, 5, 10);

	private static final Color ONLINE_COLOR = new Color(0, 146, 54, 230);

	private static final Color OFFLINE_COLOR = Color.RED;

	private static final int STATUS_DOT_SIZE = 5;

	@Getter
	private final String gimp;

	private final JLabel label;

	private final FilledCircle statusDot;

	/* To be executed when the tab is selected */
	@Setter
	private BooleanSupplier onSelectEvent;

	@Getter
	private boolean selected;

	public GimTab(String string, GimTabGroup group, String gimp)
	{
		super();

		this.gimp = gimp;

		setLayout(new BorderLayout());

		this.label = new JLabel(string);
		// Pad the left side of the icon to account for the status dot
		this.label.setBorder(new EmptyBorder(0, STATUS_DOT_SIZE, 0, 0));
		add(this.label, BorderLayout.CENTER);
		setLayer(this.label, DEFAULT_LAYER);

		this.statusDot = new FilledCircle(STATUS_DOT_SIZE, STATUS_DOT_SIZE, OFFLINE_COLOR);
		add(this.statusDot, BorderLayout.EAST);
		setLayer(this.statusDot, PALETTE_LAYER);

		unselect();

		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				group.select(GimTab.this);
			}
		});

		if (!Strings.isNullOrEmpty(string))
		{
			addMouseListener(new MouseAdapter()
			{
				@Override
				public void mouseEntered(MouseEvent e)
				{
					GimTab tab = (GimTab) e.getSource();
					tab.setForeground(Color.WHITE);
				}

				@Override
				public void mouseExited(MouseEvent e)
				{
					GimTab tab = (GimTab) e.getSource();
					if (!tab.isSelected())
					{
						tab.setForeground(Color.GRAY);
					}
				}
			});
		}
	}

	public GimTab(ImageIcon icon, GimTabGroup group, String gimp)
	{
		this("", group, gimp);
		setOpaque(true);
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		this.drawLabel(icon);

		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				GimTab tab = (GimTab) e.getSource();
				tab.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				GimTab tab = (GimTab) e.getSource();
				tab.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

	}

	private void drawLabel(ImageIcon icon)
	{
		this.label.setIcon(icon);
		this.label.setOpaque(false);
		this.label.setVerticalAlignment(SwingConstants.CENTER);
		this.label.setHorizontalAlignment(SwingConstants.CENTER);
	}

	public void setStatus(boolean isOnline)
	{
		Color color = isOnline ? ONLINE_COLOR : OFFLINE_COLOR;
		this.statusDot.setColor(color);
		this.statusDot.repaint();
	}

	public boolean select()
	{
		if (onSelectEvent != null)
		{
			if (!onSelectEvent.getAsBoolean())
			{
				return false;
			}
		}

		setBorder(SELECTED_BORDER);
		setForeground(Color.WHITE);
		return selected = true;
	}

	public void unselect()
	{
		setBorder(UNSELECTED_BORDER);
		setForeground(Color.GRAY);
		selected = false;
	}

	@Override
	public void setForeground(Color fg)
	{
		super.setForeground(fg);
	}

	@Override
	public void setBackground(Color bg)
	{
		super.setBackground(bg);
	}
}

/*
 * Copyright (c) 2022, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.ui;

import javax.swing.*;
import java.awt.*;
import lombok.Setter;

public class FilledCircle extends JPanel
{
	@Setter
	private int width;

	@Setter
	private int height;

	@Setter
	private Color color;

	public FilledCircle(int width, int height, Color color)
	{
		setWidth(width);
		setHeight(height);
		setSize(width, height);
		setColor(color);
		setVisible(true);
	}

	@Override
	public void paint(Graphics g)
	{
		Graphics2D g2d = (Graphics2D) g;
		g2d.setColor(color);
		g2d.drawOval(0, 0, width, height);
		g2d.fillOval(0, 0, width, height);
	}
}

/*
 * Copyright (c) 2022, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.ui;

import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JPanel;

public class GimTabGroup extends JPanel
{
	/* The panel on which the content tab's content will be displayed on. */
	private final JPanel display;
	/* A list of all the tabs contained in this group. */
	private final List<GimTab> tabs = new ArrayList<>();

	public GimTabGroup(JPanel display)
	{
		this.display = display;
		if (display != null)
		{
			this.display.setLayout(new BorderLayout());
		}
		setLayout(new FlowLayout(FlowLayout.CENTER, 8, 0));
		setOpaque(false);
	}

	public GimTabGroup()
	{
		this(null);
	}

	/* Returns the tab on a certain index. */
	public GimTab getTab(int index)
	{

		if (tabs == null || tabs.isEmpty())
		{
			return null;
		}

		return tabs.get(index);
	}

	public GimTab getTab(String gimp)
	{
		if (tabs == null || tabs.isEmpty())
		{
			return null;
		}
		// Get a tab by the associated gimp
		for (GimTab tab : tabs)
		{
			if (tab.getGimp().equals(gimp))
			{
				return tab;
			}
		}
		return null;
	}

	public void addTab(GimTab tab)
	{
		tabs.add(tab);
		add(tab, BorderLayout.NORTH);
	}

	/***
	 * Selects a tab from the group, and sets the display's content to the
	 * tab's associated content.
	 * @param selectedTab - The tab to select
	 */
	public void select(GimTab selectedTab)
	{
		if (!tabs.contains(selectedTab))
		{
			return;
		}

		// If the OnTabSelected returned false, exit the method to prevent tab switching
		if (!selectedTab.select())
		{
			return;
		}

		// If the display is available, switch from the old to the new display
		if (display != null)
		{
			display.removeAll();
			display.revalidate();
			display.repaint();
		}

		// Unselected all other tabs
		for (GimTab tab : tabs)
		{
			if (!tab.equals(selectedTab))
			{
				tab.unselect();
			}
		}

	}
}

/*
 * Copyright (c) 2023, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.ui;

import com.gimp.GimPlugin;
import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import javax.swing.AbstractAction;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.KeyStroke;
import javax.swing.border.EmptyBorder;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.undo.CannotUndoException;
import javax.swing.undo.UndoManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

@Slf4j
public class GimNotes extends JPanel
{
	private final JTextArea notesEditor = new JTextArea();
	private final UndoManager undoRedo = new UndoManager();

	public void init(GimPlugin plugin)
	{
		setLayout(new BorderLayout());
		setBorder(BorderFactory.createEmptyBorder(5, 0, 10, 0));
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		notesEditor.setTabSize(2);
		notesEditor.setLineWrap(true);
		notesEditor.setWrapStyleWord(true);

		JPanel notesContainer = new JPanel();
		notesContainer.setLayout(new BorderLayout());
		notesContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		notesEditor.setOpaque(false);

		// setting the limit to a 500 as UndoManager registers every key press,
		// which means that be default we would be able to undo only a sentence.
		// note: the default limit is 100
		undoRedo.setLimit(500);
		notesEditor.getDocument().addUndoableEditListener(e -> undoRedo.addEdit(e.getEdit()));

		notesEditor.getInputMap().put(KeyStroke.getKeyStroke("control Z"), "Undo");
		notesEditor.getInputMap().put(KeyStroke.getKeyStroke("control Y"), "Redo");

		notesEditor.getActionMap().put("Undo", new AbstractAction("Undo")
		{
			@Override
			public void actionPerformed(ActionEvent e)
			{
				try
				{
					if (undoRedo.canUndo())
					{
						undoRedo.undo();
					}
				}
				catch (CannotUndoException ex)
				{
					log.warn("Notes Document Unable To Undo: " + ex);
				}
			}
		});

		notesEditor.getActionMap().put("Redo", new AbstractAction("Redo")
		{
			@Override
			public void actionPerformed(ActionEvent e)
			{
				try
				{
					if (undoRedo.canRedo())
					{
						undoRedo.redo();
					}
				}
				catch (CannotUndoException ex)
				{
					log.warn("Notes Document Unable To Redo: " + ex);
				}
			}
		});

		notesEditor.addFocusListener(new FocusListener()
		{
			@Override
			public void focusGained(FocusEvent e)
			{

			}

			@Override
			public void focusLost(FocusEvent e)
			{
				notesChanged(notesEditor.getDocument());
			}

			private void notesChanged(Document doc)
			{
				try
				{
					// get document text and save to config whenever editor is changed
					String data = doc.getText(0, doc.getLength());
					plugin.updateNotes(data);
				}
				catch (BadLocationException ex)
				{
					log.warn("Notes Document Bad Location: " + ex);
				}
			}
		});

		notesContainer.add(notesEditor, BorderLayout.CENTER);
		notesContainer.setBorder(new EmptyBorder(10, 10, 10, 10));

		add(notesContainer, BorderLayout.CENTER);
	}

	public void setNotes(String data)
	{
		notesEditor.setText(data);
	}

	public void setEnabled(boolean enabled)
	{
		notesEditor.setEnabled(enabled);
	}

	public void setToolTipText(String text)
	{
		notesEditor.setToolTipText(text);
	}
}

/*
 * Copyright (c) 2019, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp;

import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.plugins.party.data.PartyTilePingData;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;
import java.util.Iterator;

class GimPingOverlay extends Overlay
{
	private final Client client;
	private final GimPlugin plugin;

	@Inject
	private GimPingOverlay(final Client client, final GimPlugin plugin)
	{
		this.client = client;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.getGroup().isEmpty())
		{
			return null;
		}

		synchronized (plugin.getPendingTilePings())
		{
			final Iterator<PartyTilePingData> iterator = plugin.getPendingTilePings().iterator();

			while (iterator.hasNext())
			{
				PartyTilePingData next = iterator.next();

				if (next.getAlpha() <= 0)
				{
					iterator.remove();
					continue;
				}

				renderPing(graphics, next);
				next.setAlpha(next.getAlpha() - 5);
			}
		}

		return null;
	}

	private void renderPing(final Graphics2D graphics, final PartyTilePingData ping)
	{
		final LocalPoint localPoint = LocalPoint.fromWorld(client, ping.getPoint());

		if (localPoint == null)
		{
			return;
		}

		final Polygon poly = Perspective.getCanvasTilePoly(client, localPoint);

		if (poly == null)
		{
			return;
		}

		final Color color = new Color(
			ping.getColor().getRed(),
			ping.getColor().getGreen(),
			ping.getColor().getBlue(),
			ping.getAlpha());

		OverlayUtil.renderPolygon(graphics, poly, color);
	}
}

/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.map;

import com.gimp.GimPlugin;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import java.awt.*;
import java.awt.font.FontRenderContext;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;

/**
 * Utility for constructing and caching GIM world map icons.
 */
public class GimIconProvider
{
	final static Font FONT = FontManager.getRunescapeBoldFont();

	final private Map<String, BufferedImage> icons;

	public GimIconProvider()
	{
		icons = new HashMap<>(5);
	}

	public BufferedImage getIcon(String name)
	{
		return icons.computeIfAbsent(name, this::generateIcon);
	}

	private BufferedImage generateIcon(String name)
	{
		// Compute some info about username text size
		final Rectangle2D textBounds = FONT.getStringBounds(name,
			new FontRenderContext(null, true, true));
		final int textHeight = (int) textBounds.getHeight();
		final int textWidth = (int) textBounds.getWidth();

		// Load the GIMP logo
		final BufferedImage gimpLogo = ImageUtil.loadImageResource(GimPlugin.class, "gimpoint.png");

		// Initialize the resulting icon, must be large enough to fit everything with the GIMP logo centered
		final BufferedImage icon = new BufferedImage(textWidth + 4,
			gimpLogo.getHeight() + 2 * textHeight,
			BufferedImage.TYPE_INT_ARGB);

		// First, draw the GIMP logo onto the center of the icon
		final Graphics2D graphics = (Graphics2D) icon.getGraphics();
		graphics.drawImage(gimpLogo, (icon.getWidth() - gimpLogo.getWidth()) / 2, (icon.getHeight() - gimpLogo.getHeight()) / 2, null);
		// Then, draw the shadow of the username text (TODO: is there a proper way to do this?)
		final int textX = (icon.getWidth() - textWidth) / 2;
		final int textY = textHeight;
		graphics.setFont(FontManager.getRunescapeBoldFont());
		graphics.setColor(Color.BLACK);
		graphics.drawString(name, textX + 1, textY + 1);

		// Finally, draw the username text centered horizontally above the GIMP logo
		graphics.setColor(Color.WHITE);
		graphics.drawString(name, textX, textY);

		return icon;
	}
}

/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.map;

import com.gimp.gimps.GimLocation;
import com.gimp.gimps.GimPlayer;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.util.LinkedList;
import java.util.Queue;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;

/**
 * Wrapper around the built-in {@link WorldMapPoint}.
 * Creates abstraction for "moving" the world map point by altering the underlying map point location.
 * <p>
 * Supports fractional locations which allows for map points to be moved more slowly.
 * TODO: The current implementation doesn't actually need this due to the "frame toggle" approach; delete when sure.
 */
public class GimWorldMapPoint
{
	private final GimPlayer gimp;
	private final WorldMapPoint worldMapPoint;
	private double x;
	private double y;

	private final Queue<WorldMapPoint> footsteps;
	private final BufferedImage mmIcon;

	public GimWorldMapPoint(GimPlayer gimp, WorldMapPoint worldMapPoint)
	{
		this.gimp = gimp;
		this.worldMapPoint = worldMapPoint;
		x = this.worldMapPoint.getWorldPoint().getX();
		y = this.worldMapPoint.getWorldPoint().getY();
		footsteps = new LinkedList<>();

		// Initialize the footstep icon to be used
		final BufferedImage icon = new BufferedImage(12, 12, BufferedImage.TYPE_INT_ARGB);
		final Graphics2D g = icon.createGraphics();
		g.setColor(gimp.getColor());
		g.fillOval(0, 0, 12, 12);
		mmIcon = icon;

	}

	public void setX(double x)
	{
		this.x = x;
		refreshWorldPoint();
	}

	public void setY(double y)
	{
		this.y = y;
		refreshWorldPoint();
	}

	public void move(double dx, double dy)
	{
		x += dx;
		y += dy;
		refreshWorldPoint();
	}

	public void setWorldPoint(WorldPoint worldPoint)
	{
		worldMapPoint.setWorldPoint(worldPoint);
		x = worldPoint.getX();
		y = worldPoint.getY();
	}

	public WorldPoint getWorldPoint()
	{
		return worldMapPoint.getWorldPoint();
	}

	public WorldMapPoint getWorldMapPoint()
	{
		return worldMapPoint;
	}

	private void refreshWorldPoint()
	{
		if ((int) x != worldMapPoint.getWorldPoint().getX()
			|| (int) y != worldMapPoint.getWorldPoint().getY())
		{
			final WorldPoint newWorldPoint = new WorldPoint((int) x, (int) y, worldMapPoint.getWorldPoint().getPlane());
			worldMapPoint.setWorldPoint(newWorldPoint);
		}
	}

	public boolean moveTowardPlayer(boolean frameToggle)
	{
		final WorldPoint shownLocation = getWorldPoint();
		final GimLocation targetLocation = gimp.getLocation();
		if (shownLocation != null && targetLocation != null)
		{
			int dx = targetLocation.getX() - shownLocation.getX();
			int dy = targetLocation.getY() - shownLocation.getY();
			if (Math.abs(dx) > 30 || Math.abs(dy) > 30)
			{
				// If the target location is too far, instantly change the map point
				setWorldPoint(targetLocation.toWorldPoint());
				return true;
			}
			else if (dx != 0 || dy != 0)
			{
				// Otherwise if it's moved at all, smoothly move it toward the target location.
				// If moving fast (e.g. running), move every frame; otherwise, move every other frame.
				if (frameToggle || gimp.getSpeed() > 2.25)
				{
					// Only move by a max of 1 tile in a given axis (keeps it consistent/smooth)
					move(Math.min(1, Math.max(dx, -1)), Math.min(1, Math.max(dy, -1)));
					// If the plane has changed, update it while preserving the shown x/y coordinates
					if (shownLocation.getPlane() != targetLocation.getPlane())
					{
						setWorldPoint(new WorldPoint(shownLocation.getX(), shownLocation.getY(), targetLocation.getPlane()));
					}
					return true;
				}
			}
		}
		return false;
	}

	public void addFootstep(GimWorldMapPointManager gimWorldMapPointManager, int maxLength)
	{
		final WorldPoint worldPoint = worldMapPoint.getWorldPoint().dx(0);

		if (maxLength > 0)
		{
			// Optimization to reuse the tail WMP as the head WMP (since altering the underlying WMP ArrayList is expensive)
			if (footsteps.size() == maxLength)
			{
				final WorldMapPoint popped = footsteps.remove();
				popped.setWorldPoint(worldPoint);
				footsteps.add(popped);
				return;
			}

			final WorldMapPoint worldMapPoint = new WorldMapPoint(worldPoint, mmIcon);
			gimWorldMapPointManager.addAssociatedPoint(gimp.getName(), worldMapPoint);
			footsteps.add(worldMapPoint);
		}

		while (footsteps.size() > maxLength)
		{
			final WorldMapPoint popped = footsteps.remove();
			gimWorldMapPointManager.removeAssociatedPoint(gimp.getName(), popped);
		}

	}
}

/*
 * Copyright (c) 2021, David Vorona <davidavorona@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.gimp.map;

import com.gimp.gimps.GimPlayer;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;

/**
 * Wrapper around the built-in {@link WorldMapPointManager}.
 * Primarily adds support for tracking and fetching map points by name.
 */
@Slf4j
public class GimWorldMapPointManager
{
	@Inject
	private WorldMapPointManager _worldMapPointManager;

	private final Map<String, GimWorldMapPoint> points;
	private final Map<String, Collection<WorldMapPoint>> associatedPoints;
	private final GimIconProvider iconProvider;

	public GimWorldMapPointManager()
	{
		points = new HashMap<>();
		associatedPoints = new HashMap<>();
		iconProvider = new GimIconProvider();
	}

	public GimWorldMapPoint getPoint(String gimpName)
	{
		if (!points.containsKey(gimpName))
		{
			throw new IllegalArgumentException("WorldMapPoint does not exist for user " + gimpName);
		}
		return points.get(gimpName);
	}

	public boolean hasPoint(String gimpName)
	{
		return points.containsKey(gimpName);
	}

	/**
	 * Add the given map point to the world map for the given player.
	 *
	 * @param gimpName      name of the player
	 * @param worldMapPoint world map point to add
	 */
	public void addPoint(String gimpName, GimWorldMapPoint worldMapPoint)
	{
		if (!points.containsKey(gimpName))
		{
			points.put(gimpName, worldMapPoint);
			associatedPoints.put(gimpName, new LinkedList<>());
			_worldMapPointManager.add(worldMapPoint.getWorldMapPoint());
			log.debug("Add world map point for " + gimpName);
		}
		else
		{
			throw new IllegalStateException("WorldMapPoint for user " + gimpName + " already exists");
		}
	}

	/**
	 * For the given player, create and add a map point to the world map.
	 *
	 * @param gimp player for whom to create and add a map point
	 */
	public void addPoint(GimPlayer gimp)
	{
		final String name = gimp.getName();
		if (gimp.getLocation() != null)
		{
			final WorldPoint p = new WorldPoint(gimp.getLocation().getX(),
				gimp.getLocation().getY(),
				gimp.getLocation().getPlane());
			final WorldMapPoint worldMapPoint = new WorldMapPoint(p, iconProvider.getIcon(name));
			// Configure world map point
			worldMapPoint.setTarget(p);
			// Snaps to edge if outside of current map frame
			worldMapPoint.setSnapToEdge(true);
			// Jumps to location if clicked on
			worldMapPoint.setJumpOnClick(true);
			// Name is necessary for jumpOnClick behavior
			worldMapPoint.setName(name);

			addPoint(name, new GimWorldMapPoint(gimp, worldMapPoint));
		}
	}

	public void removePoint(String gimpName)
	{
		if (points.containsKey(gimpName))
		{
			// Remove the user's primary WMP
			_worldMapPointManager.remove(points.get(gimpName).getWorldMapPoint());
			points.remove(gimpName);

			// Remove the user's associated WMPs
			for (WorldMapPoint point : associatedPoints.get(gimpName))
			{
				_worldMapPointManager.removeIf(wmp -> wmp == point);
			}
			associatedPoints.remove(gimpName);

			log.debug("Remove map point for " + gimpName);
		}
		else
		{
			throw new IllegalStateException("Cannot remove nonexistent WorldMapPoint for user " + gimpName);
		}
	}

	public void addAssociatedPoint(String gimpName, WorldMapPoint associatedPoint)
	{
		associatedPoints.get(gimpName).add(associatedPoint);
		_worldMapPointManager.add(associatedPoint);
		// Re-add the gimp's WMP to ensure it's rendered on top (this might be expensive, so avoid if possible)
		_worldMapPointManager.remove(points.get(gimpName).getWorldMapPoint());
		_worldMapPointManager.add(points.get(gimpName).getWorldMapPoint());
	}

	public void removeAssociatedPoint(String gimpName, WorldMapPoint worldMapPoint)
	{
		associatedPoints.get(gimpName).removeIf(wmp -> wmp == worldMapPoint);
		_worldMapPointManager.removeIf(wmp -> wmp == worldMapPoint);
	}

	public void clear()
	{
		// Use key collection rather than iterator to avoid concurrent modification
		final Collection<String> gimpNames = new ArrayList<>(points.keySet());

		for (String gimpName : gimpNames)
		{
			if (hasPoint(gimpName))
			{
				removePoint(gimpName);
			}
		}
	}
}

