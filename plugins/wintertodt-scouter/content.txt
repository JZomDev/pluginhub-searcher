package com.wintertodt.scouter;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class WintertodtScouterPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(WintertodtScouterPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2021, nucleon
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.wintertodt.scouter;

import com.google.inject.Provides;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.swing.*;

import com.wintertodt.scouter.ui.WintertodtScouterPluginPanelBase;
import com.wintertodt.scouter.ui.condensed.WintertodtScouterCondensedPluginPanel;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.ComponentID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.WorldService;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.api.widgets.Widget;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.WorldUtil;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldResult;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


@Slf4j
@PluginDescriptor(
		name = "Wintertodt Scouter",
		description = "Crowdsources the health of the Wintertodt Boss in themed worlds",
		tags= {"firemaking", "wintertodt", "status", "health"}
)

public class WintertodtScouterPlugin extends Plugin
{
	public ArrayList<WintertodtBossData> localBossDataArrayList = new ArrayList<>();

	@Getter
	String apiVersion = "2";

	@Getter
	@Setter
	public ArrayList<WintertodtBossData> globalBossDataArrayList = new ArrayList<>();
	private WintertodtScouterCondensedPluginPanel panel;
	private static final int WINTERTODT_REGION = 6462;
	private final int SECONDS_BETWEEN_UPLINK = 2;
	private final int SECONDS_BETWEEN_DOWNLINK = 2;
	private final int SECONDS_BETWEEN_PANEL_REFRESH = 5;
	private boolean canRefresh;
	private final int SECONDS_BETWEEN_POLL_HEALTH = 1;
	public static final int WINTERTODT_HEALTH_PACKED_ID = 25952282;
	public static final int WINTERTODT_GAME_TIMER_ID = 25952282;

	static final String CONFIG_GROUP_KEY = "wintertodtscouter";

	@Inject
	private ChatMessageManager chatMessageManager;

	@Getter
	String wintertodtGetUplink;

	@Getter
	String wintertodtGetDownlink;

	@Getter
	@Setter
	private boolean postError = false;

	@Getter
	@Setter
	private boolean getError = false;

	@Inject
	Client client;

	@Inject
	private WintertodtScouterNetwork manager;

	@Inject
	@Getter
	private WintertodtScouterConfig config;

	@Inject
	private WintertodtScouterOverlayPanel overlayPanel;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ClientThread clientThread;

	@Inject
	@Getter
	private WorldService worldService;

	private WintertodtScouterPluginPanelBase wintertodtScouterPanel;
	private NavigationButton navButton = null;
	private final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/wintertodt-scouter-icon.png");

	@Override
	protected void startUp() throws Exception
	{
		log.info("Wintertodt-Scouter started!");
		canRefresh = true;
		// Set up config variables
		wintertodtGetUplink = config.wintertodtGetUplinkConfig();
		wintertodtGetDownlink = config.wintertodtGetDownlinkConfig();

		// Add the overlay to the OverlayManager
		overlayManager.add(overlayPanel);

		// Set up the sidebar panel
		loadPluginPanel();
	}

	@Override
	protected void shutDown() throws Exception
	{
		// Remove the overlay from the OverlayManager
		overlayManager.remove(overlayPanel);

		// Remove sidebar panel button
		clientToolbar.removeNavigation(navButton);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals(CONFIG_GROUP_KEY))
			return;
		switch (event.getKey())
		{
			case WintertodtScouterConfig.NETWORK_UPLINK:
				wintertodtGetUplink = event.getNewValue();
				break;
			case WintertodtScouterConfig.NETWORK_DOWNLINK:
				wintertodtGetDownlink = event.getNewValue();
				manager.makeGetRequest();
				break;
			default:
				updatePanelList();
				break;
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		handleHop();
		captureBossHealth();
	}

	private boolean isInWintertodtRegion()
	{
		if (client.getLocalPlayer() != null)
		{
			return client.getLocalPlayer().getWorldLocation().getRegionID() == WINTERTODT_REGION;
		}

		return false;
	}

	public void updatePanelList()
	{
		log.debug("Update panel list");
		SwingUtilities.invokeLater(() -> wintertodtScouterPanel.populate(globalBossDataArrayList.stream().filter(this::isAllowedWorld).collect(Collectors.toList())));
	}

	public void captureBossHealth() {
		// after hopping the widget contains the previous worlds data
		if (client.getGameState() != GameState.HOPPING) {
			// The Wintertodt Energy Bar packed ID
			Widget wintertodtEnergyWidget = client.getWidget(WINTERTODT_HEALTH_PACKED_ID);

			// Check if the player is in the Wintertodt boss fight region, also check if the widget is loaded
			if (isInWintertodtRegion() && wintertodtEnergyWidget != null) {

				// Pull just the numbers from the Widget's text property ("Wintertodt Energy: 100%")
				Pattern regex = Pattern.compile("\\d+");
				Matcher bossEnergy = regex.matcher(wintertodtEnergyWidget.getText().toString());

				// Isolate the numbers
				if (bossEnergy.find()) {

					// get ready to add it to the arraylist for further network processing
					int energy = Integer.parseInt(bossEnergy.group(0));
					int world = client.getWorld();
					long unixTime = Instant.now().getEpochSecond();

					if (energy == 0) {
						captureResetTimer();
						return;
					}

					WintertodtBossData current = new WintertodtBossData(energy, world, unixTime, false, -1);

					//check if the energy data is the same as the last upload; if so, skip this data.
					if (localBossDataArrayList.size() > 1) {
						WintertodtBossData previous = localBossDataArrayList.get(localBossDataArrayList.size() - 1);
						if (previous.getWorld() == current.getWorld()) {
							if (previous.getHealth() == current.getHealth()) {
								return;
							}
						}
					}
					// Prevents infinitely growing list by capping at 5
					if (localBossDataArrayList.size() > 5) {
						localBossDataArrayList.clear();
					}
					localBossDataArrayList.add(current);
				}
				if (localBossDataArrayList.size() > 0)
					log.debug(    localBossDataArrayList.get(localBossDataArrayList.size() - 1).getTime() +
							": Health: " + localBossDataArrayList.get(localBossDataArrayList.size() - 1).getHealth());
				updatePanelList();
			}
		}
	}

	public void captureResetTimer() {
		if (client.getGameState() != GameState.HOPPING) {
			Widget wintertodtResetWidget = client.getWidget(WINTERTODT_GAME_TIMER_ID);

			// Check if the player is in the Wintertodt boss fight region, also check if the widget is loaded
			if (isInWintertodtRegion() && wintertodtResetWidget != null) {

				// Pull just the numbers from the Widget's text property ("Wintertodt Energy: 100%")
				Pattern regex = Pattern.compile("\\d:\\d+");
				Matcher bossTimer = regex.matcher(wintertodtResetWidget.getText());

				// Isolate the numbers
				if (bossTimer.find()) {

					// get ready to add it to the arraylist for further network processing
					String time = bossTimer.group(0);
					String minute = time.split(":")[0];
					String second = time.split(":")[1];
					int seconds;
					if (minute.equals("1")) {
						seconds = 60 + Integer.parseInt(second);
					} else {
						seconds = Integer.parseInt(second);
					}
					int timer = seconds;
					int world = client.getWorld();
					long unixTime = Instant.now().getEpochSecond();

					WintertodtBossData current = new WintertodtBossData(-1, world, unixTime, false, timer);

					//check if the energy data is the same as the last upload; if so, skip this data.
					if (localBossDataArrayList.size() > 1) {

						WintertodtBossData previous = localBossDataArrayList.get(localBossDataArrayList.size() - 1);


						if (previous.getWorld() == current.getWorld()) {
							if (previous.getTimer() == current.getTimer()) {
								log.debug("- Skipped Data, it's the same.");
								return;
							}
						}
					}
					if (localBossDataArrayList.size() > 5) {
						localBossDataArrayList.clear();
					}
					localBossDataArrayList.add(current);
				}
				if (localBossDataArrayList.size() > 0)
					log.debug(localBossDataArrayList.get(localBossDataArrayList.size() - 1).getTime() + ": Timer: " + localBossDataArrayList.get(localBossDataArrayList.size() - 1).getTimer());
				updatePanelList();
			}
		}
	}

	// Takes the unix timestamp for each entry in the list, converts them to local date and orders them by oldest
	public static class WintertodtBossDataComparator implements Comparator<WintertodtBossData> {
		@Override
		public int compare(WintertodtBossData o1, WintertodtBossData o2) {
			return o1.convertToDate().compareTo(o2.convertToDate());
		}
	}

	private void loadPluginPanel()
	{
		if (navButton != null)
		{
			clientToolbar.removeNavigation(navButton);
		}

		wintertodtScouterPanel = new WintertodtScouterCondensedPluginPanel(this);
		navButton = NavigationButton.builder().tooltip("Wintertodt Scouter").icon(icon).priority(7).panel(wintertodtScouterPanel).build();
		clientToolbar.addNavigation(navButton);
	}

	@Provides
	WintertodtScouterConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(WintertodtScouterConfig.class);
	}
	private boolean isAllowedWorld(WintertodtBossData bossData) {
		// Protect against non-existent world ids
		WorldResult worldResult = worldService.getWorlds();
		if (worldResult == null) {
			return false;
		}
		World world = worldResult.findWorld(bossData.getWorld());
		if (world == null) {
			return false;
		}


		// Disallow various landing sites (depending on config)
		return true;
	}


	public int getCurrentWorld()
	{
		return client.getWorld();
	}

	private static final int DISPLAY_SWITCHER_MAX_ATTEMPTS = 3;
	private net.runelite.api.World quickHopTargetWorld;
	private int displaySwitcherAttempts = 0;

	public void hopTo(World world)
	{
		hopTo(world.getId());
	}

	public void hopTo(int worldId)
	{
		clientThread.invoke(() -> hop(worldId));
	}

	private void hop(int worldId)
	{
		assert client.isClientThread();

		if (!config.isWorldHopperEnabled())
		{
			return;
		}

		WorldResult worldResult = worldService.getWorlds();
		if (worldResult == null)
		{
			return;
		}
		// Don't try to hop if the world doesn't exist
		World world = worldResult.findWorld(worldId);
		if (world == null)
		{
			return;
		}

		final net.runelite.api.World rsWorld = client.createWorld();
		rsWorld.setActivity(world.getActivity());
		rsWorld.setAddress(world.getAddress());
		rsWorld.setId(world.getId());
		rsWorld.setPlayerCount(world.getPlayers());
		rsWorld.setLocation(world.getLocation());
		rsWorld.setTypes(WorldUtil.toWorldTypes(world.getTypes()));

		String chatMessage = new ChatMessageBuilder()
				.append(ChatColorType.NORMAL)
				.append("Quick-hopping to World ")
				.append(ChatColorType.HIGHLIGHT)
				.append(Integer.toString(world.getId()))
				.append(ChatColorType.NORMAL)
				.append("..")
				.build();

		chatMessageManager
				.queue(QueuedMessage.builder()
						.type(ChatMessageType.CONSOLE)
						.runeLiteFormattedMessage(chatMessage)
						.build());

		if (client.getGameState() == GameState.LOGIN_SCREEN)
		{
			// on the login screen we can just change the world by ourselves
			client.changeWorld(rsWorld);
			return;
		}

		quickHopTargetWorld = rsWorld;
	}

	private void handleHop()
	{
		if (quickHopTargetWorld == null)
		{
			return;
		}

		if (client.getWidget(ComponentID.WORLD_SWITCHER_WORLD_LIST) == null)
		{
			client.openWorldHopper();
			localBossDataArrayList.clear();
			if (++displaySwitcherAttempts >= DISPLAY_SWITCHER_MAX_ATTEMPTS)
			{
				String chatMessage = new ChatMessageBuilder()
						.append(ChatColorType.NORMAL)
						.append("Failed to quick-hop after ")
						.append(ChatColorType.HIGHLIGHT)
						.append(Integer.toString(displaySwitcherAttempts))
						.append(ChatColorType.NORMAL)
						.append(" attempts.")
						.build();

				chatMessageManager
						.queue(QueuedMessage.builder()
								.type(ChatMessageType.CONSOLE)
								.runeLiteFormattedMessage(chatMessage)
								.build());

				resetQuickHopper();
			}
		}
		else
		{
			client.hopToWorld(quickHopTargetWorld);
			resetQuickHopper();
		}
	}

	private void resetQuickHopper()
	{
		quickHopTargetWorld = null;
		displaySwitcherAttempts = 0;
		hitAPI();
	}
	public void hitAPI()
	{
		if (canRefresh)
		{

			if ((client.getGameState() == GameState.LOGGED_IN || client.getGameState() == GameState.HOPPING) && wintertodtScouterPanel.isOpen())
			{
				canRefresh = true;
				manager.makeGetRequest();
			}
		}
	}
	@Schedule(
			period = SECONDS_BETWEEN_UPLINK,
			unit = ChronoUnit.SECONDS,
			asynchronous = true
	)
	public void submitToAPI()
	{
		if ((client.getGameState() == GameState.LOGGED_IN || client.getGameState() != GameState.HOPPING) && isInWintertodtRegion()) {
			if (localBossDataArrayList.size() > 0) {
				WintertodtBossData last = localBossDataArrayList.get(localBossDataArrayList.size() - 1);
				last.setTime(Instant.now().getEpochSecond());
				if (!last.isUploaded()) {
					manager.submitToAPI(processLocalData(localBossDataArrayList));
				}
			}
		}

	}

	WintertodtBossData processLocalData(ArrayList<WintertodtBossData> localBossDataArrayList) {

		WintertodtBossData last = localBossDataArrayList.get(localBossDataArrayList.size() - 1);
		for (WintertodtBossData data : localBossDataArrayList) {
			if (!data.isUploaded()) {
				data.setUploaded(true);
			}
		}
		return last;
	}

	@Schedule(
			period = SECONDS_BETWEEN_DOWNLINK,
			unit = ChronoUnit.SECONDS,
			asynchronous = true
	)
	public void attemptGetRequest()
	{
		log.debug("Attempt get request");
		hitAPI();
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		if (event.getMessage().equals("Please finish what you're doing before using the World Switcher."))
		{
			resetQuickHopper();
		}
	}
}

/*
 * Copyright (c) 2019, Weird Gloop <admin@weirdgloop.org>
 * Copyright (c) 2021, Andrew McAdams
 * Copyright (c) 2021, nucleon
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.wintertodt.scouter;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonSyntaxException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

import static okhttp3.CacheControl.FORCE_NETWORK;

@Slf4j
@Singleton
public class WintertodtScouterNetwork
{
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private Gson gson;

    @Inject
    private WintertodtScouterPlugin plugin;


    protected void submitToAPI(WintertodtBossData data)
    {
        List<Object> temp = new ArrayList<>();
        synchronized (this)
        {
            if (data == null)
            {
                return;
            }
            temp.add(data);
        }
        makePostRequest(temp);
    }

    private ArrayList<WintertodtBossData> parseData(JsonArray j)
    {

        ArrayList<WintertodtBossData> list = new ArrayList<WintertodtBossData>();
        for (JsonElement jsonElement : j)
        {
            JsonObject jObj = jsonElement.getAsJsonObject();
            try
            {
                WintertodtBossData globalBossData = new WintertodtBossData(jObj.get("a").getAsInt(), jObj.get("b").getAsInt(), jObj.get("c").getAsLong(), false, jObj.get("d").getAsInt());
                list.add(globalBossData);
            } catch (UnsupportedOperationException uos) {
                log.error("Boss Data Json Error: " + uos.getLocalizedMessage());
            }
        }
        return list;
    }

    protected void makePostRequest(List<Object> temp)
    {
        try
        {
            Request r = new Request.Builder()
                    .url(plugin.getWintertodtGetUplink())
                    .addHeader("Authorization", "post")
                    .post(RequestBody.create(JSON, gson.toJson(temp)))
                    .build();

            okHttpClient.newCall(r).enqueue(new Callback()
            {
                @Override
                public void onFailure(Call call, IOException e)
                {
                    log.debug("Error sending wintertodt boss data", e);
                    plugin.setPostError(true);
                }

                @Override
                public void onResponse(Call call, Response response)
                {
                    if (response.isSuccessful())
                    {

                        log.debug("Successfully sent wintertodt boss data");
                        plugin.setPostError(false);
                        response.close();
                    }
                    else
                    {
                        log.debug("Post request unsuccessful");
                        plugin.setPostError(true);
                    }
                }
            });
        }
        catch (IllegalArgumentException e)
        {
            log.error("Bad URL given: " + e.getLocalizedMessage());
            plugin.setPostError(true);
        }
    }

    protected void makeGetRequest()
    {
        try
        {
            Request r = new Request.Builder()
                    .url(plugin.getWintertodtGetDownlink())
                    .addHeader("Authorization", plugin.apiVersion)
                    .cacheControl(FORCE_NETWORK)
                    .build();
            okHttpClient.newCall(r).enqueue(new Callback()
            {
                @Override
                public void onFailure(Call call, IOException e)
                {
                    log.debug("Error retrieving wintertodt boss data", e);
                    plugin.setGetError(true);
                }

                @Override
                public void onResponse(Call call, Response response)
                {
                    if (response.isSuccessful())
                    {
                        try
                        {
                            JsonArray j = gson.fromJson(response.body().string(), JsonArray.class);
                            try {
                                plugin.setGlobalBossDataArrayList(parseData(j));
                            } catch (NullPointerException e) {
                                log.error("null data from downlink: "+e.getMessage());
                            }
                            log.debug(j.toString());
                            plugin.setGetError(false);
                            plugin.updatePanelList();
                            response.close();
                        }
                        catch (IOException | JsonSyntaxException e)
                        {
                            plugin.setGetError(true);
                            log.error(e.getMessage());
                            response.close();
                        }
                    }
                    else
                    {
                        log.error("Get request unsuccessful");
                        plugin.setGetError(true);
                        response.close();;
                    }
                }
            });
        }
        catch (IllegalArgumentException e)
        {
            log.error("Bad URL given: " + e.getLocalizedMessage());
        }
    }
}

/*
 * Copyright (c) 2021, nucleon
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.wintertodt.scouter;

import java.util.Date;

import lombok.Data;
import lombok.Getter;
import lombok.Setter;

@Data
public class WintertodtBossData
{
    @Getter
    private final int world;

    @Getter
    private final int health;

    @Getter
    @Setter
    private boolean uploaded;

    @Getter
    private long time;

    @Getter
    private int timer;

    public WintertodtBossData(int health, int world, long time, boolean uploaded, int timer)
    {
        this.health = health;
        this.world = world;
        this.uploaded = uploaded;
        this.time = time;
        this.timer = timer;
    }

    public Date convertToDate() {
        return new java.util.Date( time * 1000);
    }
}

package com.wintertodt.scouter;

import com.wintertodt.scouter.ui.WintertodtScouterPanelType;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("wintertodtscouter")

public interface WintertodtScouterConfig extends Config
{
	String NETWORK_UPLINK = "wtUplink";
	String NETWORK_DOWNLINK = "wtDownlink";

	@ConfigItem
			(
				keyName = NETWORK_UPLINK,
				position = 0, name = "Realtime Uplink",
				description = "Web endpoint to upload boss data to"
			)
	default String wintertodtGetDownlinkConfig()
	{
		return "https://wintertodt-scouter.com/";
	}

	@ConfigItem(keyName = NETWORK_DOWNLINK,
				position = 1,
				name = "Realtime Downlink",
				description = "Web endpoint to get boss data from"
	)
	default String wintertodtGetUplinkConfig()
	{

		return "https://wintertodt-scouter.com/";
	}

	default WintertodtScouterPanelType wintertodtScouterPanelType()
	{
		return WintertodtScouterPanelType.CONDENSED;
	}

	@ConfigItem(
			keyName = "worldHopperEnabled",
			position = 2,
			name = "Double click to Hop",
			description = "Enables double clicking worlds in the side view panels to quick-hop to them"
	)
	default boolean isWorldHopperEnabled()
	{
		return true;
	}
}

/*
 * Copyright (c) 2021, Andrew McAdams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.wintertodt.scouter.ui.panels;

import com.wintertodt.scouter.WintertodtBossData;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.Consumer;

public class WintertodtScouterSinglePanel extends JPanel
{

	private final JLabel time;
	@Getter
	private final WintertodtBossData bossData;
	private Color lastBackground;
	public WintertodtScouterSinglePanel(WintertodtBossData bossData, Consumer<Integer> onSelect)
	{
		super();
		this.bossData = bossData;

		setLayout(new DynamicGridLayout(2, 1, 0, 5));
		setBorder(new EmptyBorder(5, 5, 5, 5));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setOpaque(false);

		JLabel world = new JLabel("World " + bossData.getWorld());
		JLabel nameLabel = new JLabel("<html>" + bossData.getHealth() + "</html>");
		nameLabel.setHorizontalAlignment(SwingConstants.LEFT);
		nameLabel.setBorder(new EmptyBorder(0, 10, 0, 0));

		topPanel.add(world, BorderLayout.WEST);
		topPanel.add(nameLabel, BorderLayout.CENTER);

		time = new JLabel();

		updateLabels();
		add(topPanel);
		add(time);

		// From WorldHopper/Condensed Stars Panel
		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					if (onSelect != null)
					{
						onSelect.accept(bossData.getWorld());
					}
				}
			}

			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					setBackground(getBackground().brighter());
				}
			}

			@Override
			public void mouseReleased(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					setBackground(getBackground().darker());
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				WintertodtScouterSinglePanel.this.lastBackground = getBackground();
				setBackground(getBackground().brighter());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				setBackground(lastBackground);
			}
		});
	}


	private void updateTime()
	{
		time.setText("" + bossData.getTime());
	}

	public void updateLabels()
	{
		updateTime();
		repaint();
		revalidate();
	}
}

/*
 * Copyright (c) 2021, Andrew McAdams, nucleon
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.wintertodt.scouter.ui.panels;

import com.wintertodt.scouter.WintertodtBossData;
import com.wintertodt.scouter.WintertodtScouterPlugin;
import com.wintertodt.scouter.ui.WintertodtScouterPluginPanelBase;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class WintertodtScouterPluginPanel extends WintertodtScouterPluginPanelBase
{
	FixedWidthPanel bossListPanel = new FixedWidthPanel();
	ArrayList<WintertodtScouterSinglePanel> bossList = new ArrayList<>();

	private final GridBagConstraints c = new GridBagConstraints();

	public WintertodtScouterPluginPanel(WintertodtScouterPlugin plugin)
	{
		super(plugin, false);

		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setLayout(new BorderLayout());

		// Create the container for the title and refresh task button
		JPanel topContainer = new JPanel();
		topContainer.setLayout(new BorderLayout());

		JPanel titlePanel = new JPanel();
		titlePanel.setBorder(new EmptyBorder(10, 10, 10, 10));
		titlePanel.setLayout(new BorderLayout());

		JLabel title = new JLabel();
		title.setText("Wintertodt Scouter");
		title.setForeground(Color.WHITE);
		titlePanel.add(title, BorderLayout.WEST);
		topContainer.add(titlePanel, BorderLayout.NORTH);

		add(topContainer, BorderLayout.NORTH);

		// Create the task list panel
		bossListPanel.setLayout(new GridBagLayout());
		bossListPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		c.insets = new Insets(0, 2, 2, 2);
		c.fill = GridBagConstraints.HORIZONTAL;
		c.weightx = 1;
		c.gridx = 0;
		c.anchor = GridBagConstraints.PAGE_START;

		JScrollPane scrollPane = new JScrollPane(bossListPanel);
		scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scrollPane.setBorder(new EmptyBorder(1, 0, 0, 0));
		scrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		add(scrollPane, BorderLayout.CENTER);
	}

	public void addBossData(JPanel wintertodtScouterPanel, WintertodtBossData data)
	{
		WintertodtScouterSinglePanel bossDataPanel = new WintertodtScouterSinglePanel(data, plugin::hopTo);
		wintertodtScouterPanel.add(bossDataPanel, c);
		c.gridy += 1;
		bossList.add(bossDataPanel);
	}

	@Override
	public void populate(List<WintertodtBossData> globalBossData)
	{
		c.gridy = 0;
		c.weighty = 0;
		// Remove all old panels
		for (WintertodtScouterSinglePanel bossSinglePanel : bossList)
		{
			bossListPanel.remove(bossSinglePanel);
		}
		bossList.clear();

		// Add new panels. Need to keep track of the last one to give it extra weighty (to put all extra space after it)
		WintertodtBossData lastData = null;
		for (WintertodtBossData bossData : globalBossData)
		{
			if (lastData != null)
				addBossData(bossListPanel, lastData);
			lastData = bossData;
		}

		// Add the last panel with weighty 1
		c.weighty = 1;
		if (lastData != null)
			addBossData(bossListPanel, lastData);

		repaint();
		revalidate();
	}

	@Override
	public void updateList()
	{
		for (WintertodtScouterSinglePanel bossSinglePanel : bossList)
		{
			bossSinglePanel.updateLabels();
		}
	}

}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.wintertodt.scouter.ui.panels;

import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import java.awt.*;

class FixedWidthPanel extends JPanel
{
	@Override
	public Dimension getPreferredSize()
	{
		return new Dimension(PluginPanel.PANEL_WIDTH, super.getPreferredSize().height);
	}

}

/*
 * Copyright (c) 2021, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.wintertodt.scouter.ui;

import com.wintertodt.scouter.ui.condensed.WintertodtScouterCondensedPluginPanel;
import com.wintertodt.scouter.ui.panels.WintertodtScouterPluginPanel;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum WintertodtScouterPanelType
{
	LARGE_PANELS("Large Panels", WintertodtScouterPluginPanel.class.asSubclass(WintertodtScouterPluginPanelBase.class)),
	CONDENSED("Condensed", WintertodtScouterCondensedPluginPanel.class.asSubclass(WintertodtScouterCondensedPluginPanel.class))
	;

	private final String name;
	private final Class<? extends WintertodtScouterPluginPanelBase> panelClass;

	@Override
	public String toString()
	{
		return getName();
	}
}

/*
 * Copyright (c) 2021, Andrew McAdams, Cyborger1, Psikoi <https://github.com/Psikoi> (Basis)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.wintertodt.scouter.ui.condensed;

import com.wintertodt.scouter.WintertodtBossData;
import com.wintertodt.scouter.WintertodtScouterPlugin;
import com.wintertodt.scouter.ui.WintertodtScouterPluginPanelBase;
import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Timer;
import java.util.TimerTask;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.WorldService;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.*;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.WorldUtil;
import net.runelite.http.api.worlds.World;


import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.List;
import java.util.function.Function;

import static java.util.Comparator.*;

public class WintertodtScouterCondensedPluginPanel extends WintertodtScouterPluginPanelBase
{
	private static final Color ODD_ROW = new Color(44, 44, 44);

	private static final int WORLD_COLUMN_WIDTH = 55;
	private static final int TIME_COLUMN_WIDTH = 55;

	private final JPanel listContainer = new JPanel();

	private WintertodtScouterPanelHeader worldHeader;
	private WintertodtScouterPanelHeader healthHeader;
	private WintertodtScouterPanelHeader timerHeader;

	private WintertodtScouterOrder orderIndex = WintertodtScouterOrder.HEALTH;
	private boolean ascendingOrder = true;

	private final ArrayList<WintertodtScouterTableRow> rows = new ArrayList<>();

	public WintertodtScouterCondensedPluginPanel(WintertodtScouterPlugin plugin)
	{
		super(plugin);

		setBorder(null);
		setLayout(new DynamicGridLayout(0, 1));
		JPanel title = title();
		JPanel tip = tip();
		JPanel headerContainer = buildHeader();
		JPanel p =new JPanel();
		listContainer.setLayout(new GridLayout(0, 1));

		add(title);
		add(headerContainer);
		add(listContainer);
		add(tip);
	}

	/**
	 * Builds the entire table header.
	 */

	private JPanel title()
	{
		JLabel title = new JLabel("Wintertodt Scouter");
		title.setFont(FontManager.getRunescapeBoldFont());
		JPanel panel = new JPanel(new BorderLayout());
		panel.setLayout(new GridBagLayout());
		panel.add(title);

		return panel;
	}

	private JPanel tip()
	{
		JPanel layout = new JPanel(new BorderLayout());
		JLabel tip = new JLabel("You can double click to hop worlds!");

		tip.setFont(FontManager.getRunescapeSmallFont());
		layout.add(tip);
		layout.setBorder(BorderFactory.createTitledBorder(BorderFactory.createRaisedBevelBorder(), "Tip"));

		return layout;
	}

	private JPanel buildHeader()
	{
		JPanel header = new JPanel(new BorderLayout());
		JPanel status = new JPanel(new BorderLayout());

		healthHeader = new WintertodtScouterPanelHeader("Health", orderIndex == WintertodtScouterOrder.HEALTH, ascendingOrder);
		healthHeader.setPreferredSize(new Dimension(WORLD_COLUMN_WIDTH, 50));
		healthHeader.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isRightMouseButton(mouseEvent))
				{
					return;
				}
				ascendingOrder = orderIndex != WintertodtScouterOrder.HEALTH || !ascendingOrder;
				orderBy(WintertodtScouterOrder.HEALTH);
			}
		});

		worldHeader = new WintertodtScouterPanelHeader("World", orderIndex == WintertodtScouterOrder.WORLD, ascendingOrder);
		worldHeader.setPreferredSize(new Dimension(TIME_COLUMN_WIDTH, 50));
		worldHeader.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isRightMouseButton(mouseEvent))
				{
					return;
				}
				ascendingOrder = orderIndex != WintertodtScouterOrder.WORLD || !ascendingOrder;
				orderBy(WintertodtScouterOrder.WORLD);
			}
		});

		timerHeader = new WintertodtScouterPanelHeader("Reset", orderIndex == WintertodtScouterOrder.TIMER, ascendingOrder);
		timerHeader.setPreferredSize(new Dimension(TIME_COLUMN_WIDTH, 50));
		timerHeader.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isRightMouseButton(mouseEvent))
				{
					return;
				}
				ascendingOrder = orderIndex != WintertodtScouterOrder.TIMER || !ascendingOrder;
				orderBy(WintertodtScouterOrder.TIMER);
			}
		});

		status.add(worldHeader, BorderLayout.WEST);
		status.add(healthHeader, BorderLayout.CENTER);
		status.add(timerHeader, BorderLayout.EAST);

		header.add(status, BorderLayout.CENTER);

		return header;
	}

	private void orderBy(WintertodtScouterOrder order)
	{
		worldHeader.highlight(false, ascendingOrder);
		healthHeader.highlight(false, ascendingOrder);
		timerHeader.highlight(false, ascendingOrder);

		switch (order)
		{
			case HEALTH:
				healthHeader.highlight(true, ascendingOrder);
				break;
			case WORLD:
				worldHeader.highlight(true, ascendingOrder);
				break;
			case TIMER:
				timerHeader.highlight(true, ascendingOrder);
				break;
		}

		orderIndex = order;
		updateList();
	}

	@Override
	public void updateList()
	{
		rows.sort((r1, r2) ->
		{
			switch (orderIndex)
			{
				case HEALTH:
					return getCompareValue(r1, r2, WintertodtScouterTableRow::getHealth);
				case WORLD:
					return getCompareValue(r1, r2, WintertodtScouterTableRow::getBossworld);
				case TIMER:
					return getCompareValue(r1, r2, WintertodtScouterTableRow::getTimer);
				default:
					return 0;
			}
		});

		listContainer.removeAll();

		int currentWorld = plugin.getCurrentWorld();

		int i = 0;

		for (WintertodtScouterTableRow row : rows)
		{
			row.updateStatus(row.getWorld().getId() == currentWorld);
			setColorOnRow(row, i++ % 2 == 0);
			listContainer.add(row);

		}

		listContainer.revalidate();
		listContainer.repaint();
	}

	@SuppressWarnings("rawtypes")
	private int getCompareValue(WintertodtScouterTableRow row1, WintertodtScouterTableRow row2, Function<WintertodtScouterTableRow, Comparable> compareByFn)
	{
		Comparator<WintertodtScouterTableRow> c = ascendingOrder ?
			comparing(compareByFn, naturalOrder()) : comparing(compareByFn, reverseOrder());
		// Always default to ordering by Max time for the second sort pass
		return c.thenComparing(WintertodtScouterTableRow::getHealth, naturalOrder()).compare(row1, row2);
	}

	@Override
	public void populate(List<WintertodtBossData> globalBossData)
	{
		rows.clear();

		for (int i = 0; i < globalBossData.size(); i++)
		{
			WintertodtBossData boss = globalBossData.get(i);
			rows.add(buildRow(globalBossData, i % 2 == 0, i));
		}

		updateList();
	}

	private WintertodtScouterTableRow buildRow(List<WintertodtBossData> bossData, boolean stripe, int index)
	{
		World world = plugin.getWorldService().getWorlds().findWorld(bossData.get(index).getWorld());
		boolean current = plugin.getCurrentWorld() == bossData.get(index).getWorld();
		WintertodtScouterTableRow row = new WintertodtScouterTableRow(world,
			bossData.get(index).getWorld(), current,
			bossData.get(index).getHealth(),
			bossData.get(index).getTimer(), bossData.get(index).getTime(), plugin::hopTo);
		setColorOnRow(row, stripe);
		return row;
	}

	private void setColorOnRow(WintertodtScouterTableRow row, boolean stripe)
	{
		Color c = stripe ? ODD_ROW : ColorScheme.DARK_GRAY_COLOR;

		row.setBackground(c);
	}

}

/*
 * Copyright (c) 2021, Cyborger1, Psikoi <https://github.com/Psikoi> (Basis)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.wintertodt.scouter.ui.condensed;

public enum WintertodtScouterOrder
{
	WORLD,
	HEALTH,
	TIMER,
}

/*
 * Copyright (c) 2021, Cyborger1, Psikoi <https://github.com/Psikoi> (Basis)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.wintertodt.scouter.ui.condensed;

import com.wintertodt.scouter.WintertodtScouterPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.image.BufferedImage;

class WintertodtScouterPanelHeader extends JPanel
{
	private static final ImageIcon ARROW_UP;
	private static final ImageIcon HIGHLIGHT_ARROW_DOWN;
	private static final ImageIcon HIGHLIGHT_ARROW_UP;

	private static final Color ARROW_COLOR = ColorScheme.LIGHT_GRAY_COLOR;
	private static final Color HIGHLIGHT_COLOR = ColorScheme.BRAND_ORANGE;

	static
	{
		final BufferedImage arrowDown = ImageUtil.loadImageResource(WintertodtScouterPlugin.class, "/arrow_down.png");
		final BufferedImage arrowUp = ImageUtil.rotateImage(arrowDown, Math.PI);
		final BufferedImage arrowUpFaded = ImageUtil.luminanceOffset(arrowUp, -80);
		ARROW_UP = new ImageIcon(arrowUpFaded);

		final BufferedImage highlightArrowDown = ImageUtil.fillImage(arrowDown, HIGHLIGHT_COLOR);
		final BufferedImage highlightArrowUp = ImageUtil.fillImage(arrowUp, HIGHLIGHT_COLOR);
		HIGHLIGHT_ARROW_DOWN = new ImageIcon(highlightArrowDown);
		HIGHLIGHT_ARROW_UP = new ImageIcon(highlightArrowUp);
	}

	private final JLabel textLabel = new JLabel();
	private final JLabel arrowLabel = new JLabel();
	// Determines if this header column is being used to order the list
	private boolean ordering = false;

	WintertodtScouterPanelHeader(String title, boolean ordered, boolean ascending)
	{
		setLayout(new BorderLayout(5, 0));
		setBorder(new CompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 0, 1, ColorScheme.MEDIUM_GRAY_COLOR),
			new EmptyBorder(0, 5, 0, 2)));
		setBackground(ColorScheme.SCROLL_TRACK_COLOR);

		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				textLabel.setForeground(HIGHLIGHT_COLOR);
				if (!ordering)
				{
					arrowLabel.setIcon(HIGHLIGHT_ARROW_UP);
				}
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				if (!ordering)
				{
					textLabel.setForeground(ARROW_COLOR);
					arrowLabel.setIcon(ARROW_UP);
				}
			}
		});

		textLabel.setText(title);
		textLabel.setFont(FontManager.getRunescapeSmallFont());

		highlight(ordered, ascending);

		add(textLabel, BorderLayout.WEST);
		add(arrowLabel, BorderLayout.EAST);
	}

	/**
	 * The labels inherit the parent's mouse listeners.
	 */
	@Override
	public void addMouseListener(MouseListener mouseListener)
	{
		super.addMouseListener(mouseListener);
		textLabel.addMouseListener(mouseListener);
		arrowLabel.addMouseListener(mouseListener);
	}

	/**
	 * If this column header is being used to order, then it should be
	 * highlighted, changing it's font color and icon.
	 */
	public void highlight(boolean on, boolean ascending)
	{
		ordering = on;
		arrowLabel.setIcon(on ? (ascending ? HIGHLIGHT_ARROW_DOWN : HIGHLIGHT_ARROW_UP) : ARROW_UP);
		textLabel.setForeground(on ? HIGHLIGHT_COLOR : ARROW_COLOR);
	}

}
/*
 * Copyright (c) 2021, Cyborger1, Psikoi <https://github.com/Psikoi> (Basis)
 * Copyright (c) 2021, nucleon
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.wintertodt.scouter.ui.condensed;

import com.wintertodt.scouter.WintertodtScouterPlugin;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Value;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.http.api.worlds.World;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.util.function.Consumer;

public class WintertodtScouterTableRow extends JPanel
{
	private static final int WORLD_COLUMN_WIDTH = 55;
	private static final int TIME_COLUMN_WIDTH = 55;

	private static final Color CURRENT_WORLD = new Color(66, 227, 17);

	final BufferedImage bar5 = ImageUtil.loadImageResource(WintertodtScouterPlugin.class, "/5.png");
	final BufferedImage bar4 = ImageUtil.loadImageResource(WintertodtScouterPlugin.class, "/4.png");
	final BufferedImage bar3 = ImageUtil.loadImageResource(WintertodtScouterPlugin.class, "/3.png");
	final BufferedImage bar2 = ImageUtil.loadImageResource(WintertodtScouterPlugin.class, "/2.png");
	final BufferedImage bar1 = ImageUtil.loadImageResource(WintertodtScouterPlugin.class, "/1.png");
	final BufferedImage bar0 = ImageUtil.loadImageResource(WintertodtScouterPlugin.class, "/0.png");

	private JLabel worldField;
	private JLabel healthField;
	private JLabel timerField;
	private JProgressBar healthBar;
	private JLabel latency;

	@Getter
	private final World world;

	@Getter
	private int bossworld;

	@Getter
	private int health;

	@Getter
	private int timer;

	@Getter
	private long time;

	private Color lastBackground;

	// bubble up events
	private final MouseAdapter labelMouseListener = new MouseAdapter()
	{
		@Override
		public void mouseClicked(MouseEvent mouseEvent)
		{
			dispatchEvent(mouseEvent);
		}

		@Override
		public void mousePressed(MouseEvent mouseEvent)
		{
			dispatchEvent(mouseEvent);
		}

		@Override
		public void mouseReleased(MouseEvent mouseEvent)
		{
			dispatchEvent(mouseEvent);
		}

		@Override
		public void mouseEntered(MouseEvent mouseEvent)
		{
			dispatchEvent(mouseEvent);
		}

		@Override
		public void mouseExited(MouseEvent mouseEvent)
		{
			dispatchEvent(mouseEvent);
		}
	};

	WintertodtScouterTableRow(World world, int bossworld, boolean current, int health, int timer, long time, Consumer<World> onSelect)
	{
		this.world = world;
		this.bossworld = bossworld;
		this.health = health;
		this.timer = timer;
		this.time = time;
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(2, 0, 2, 0));

		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					if (onSelect != null)
					{
						onSelect.accept(world);
					}
				}
			}

			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					setBackground(getBackground().brighter());
				}
			}

			@Override
			public void mouseReleased(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)
				{
					setBackground(getBackground().darker());
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				WintertodtScouterTableRow.this.lastBackground = getBackground();
				setBackground(getBackground().brighter());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				setBackground(lastBackground);
			}
		});

		JPanel status = new JPanel(new BorderLayout());
		JPanel rightSide = new JPanel(new BorderLayout());
		status.setOpaque(false);
		rightSide.setOpaque(false);

		JPanel worldField = buildWorldField();
		worldField.setPreferredSize(new Dimension(WORLD_COLUMN_WIDTH, 20));
		worldField.setOpaque(false);

		JPanel healthField = buildHealthField();
		healthField.setPreferredSize(new Dimension(TIME_COLUMN_WIDTH, 20));
		healthField.setOpaque(false);

		JPanel timerField = buildTimerField();
		timerField.setPreferredSize(new Dimension(TIME_COLUMN_WIDTH, 20));
		timerField.setOpaque(false);

		updateStatus(current);

		status.add(worldField, BorderLayout.WEST);
		status.add(healthField, BorderLayout.CENTER);
		status.add(timerField, BorderLayout.EAST);

		add(status, BorderLayout.CENTER);

	}

	void updateStatus(boolean current)
	{
		healthBar.setStringPainted(true);
		healthBar.setValue(getHealth());
		healthBar.setString(getHealth() + "%");
		healthBar.setForeground(Color.green);
		timerField.setText(""+ getTimer());

		if (getHealth() <= 60)
		{
			healthBar.setForeground(Color.orange);
		}

		if (getHealth() <= 50)
		{
			healthBar.setForeground(Color.red);
		}

		recolour(current);
	}

	void updateInfo(int health, int world, int timer, boolean current)
	{
		this.timer = timer;
		this.health = health;
		this.bossworld = world;
		updateStatus(current);
	}

	private static StringBool timeString(Instant time)
	{
		long s = Duration.between(Instant.now(), time).getSeconds();
		boolean negative = false;
		if (s < 0)
		{
			s *= -1;
			negative = true;
		}

		String str;
		long mins = s / 60;
		long secs = s % 60;

		if (negative)
		{
			if (mins > 9)
			{
				str = String.format("-%dm", mins);
			}
			else
			{
				str = String.format("-%1d:%02d", mins, secs);
			}
		}
		else
		{
			if (mins > 99)
			{
				str = String.format("%dm", mins);
			}
			else
			{
				str = String.format("%1d:%02d", mins, secs);
			}
		}

		return new StringBool(str, negative);
	}

	public void recolour(boolean current)
	{
		if (current)
		{
			worldField.setForeground(CURRENT_WORLD);
			return;
		}
	}

	private JPanel buildWorldField()
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 2, 0, 0));

		worldField = new JLabel(world.getId() + "");
		column.add(worldField, BorderLayout.WEST);
		long now = Instant.now().getEpochSecond();
		latency = new JLabel(new ImageIcon(bar0));
		long difference = now - time;
		latency.setIcon(new ImageIcon(bar5));
		if (difference > 5) {
			latency.setIcon(new ImageIcon(bar5));
		}
		if (difference > 10) {
			latency.setIcon(new ImageIcon(bar4));
		}
		if (difference> 15) {
			latency.setIcon(new ImageIcon(bar3));
		}
		if (difference > 20) {
			latency.setIcon(new ImageIcon(bar2));
		}
		if (difference > 25) {
			latency.setIcon(new ImageIcon(bar1));
		}
		if (difference > 30) {
			latency.setIcon(new ImageIcon(bar0));
		}
		column.add(latency, BorderLayout.EAST);

		latency.setBorder(new EmptyBorder(0,2,0,0));


		return column;
	}

	private JPanel buildHealthField()
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 5, 0, 5));

		healthBar = new JProgressBar();
		healthBar.setFont(FontManager.getRunescapeSmallFont());

		column.add(healthBar, BorderLayout.CENTER);

		return column;
	}


	private JPanel buildTimerField()
	{
		JPanel column = new JPanel(new BorderLayout());
		column.setBorder(new EmptyBorder(0, 5, 0, 0));

		timerField = new JLabel();
		timerField.setFont(FontManager.getRunescapeSmallFont());
		timerField.setHorizontalAlignment(SwingConstants.CENTER);
		column.add(timerField, BorderLayout.CENTER);

		return column;
	}


	@Value
	@AllArgsConstructor
	private static class StringBool
	{
		String string;
		boolean boolValue;
	}
}

/*
 * Copyright (c) 2021, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.wintertodt.scouter.ui;

import com.wintertodt.scouter.WintertodtBossData;
import com.wintertodt.scouter.WintertodtScouterPlugin;
import java.util.List;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.PluginPanel;

@Slf4j
public abstract class WintertodtScouterPluginPanelBase extends PluginPanel
{
	@Getter
	private boolean open = false;

	protected WintertodtScouterPlugin plugin;

	protected WintertodtScouterPluginPanelBase(WintertodtScouterPlugin plugin)
	{
		this(plugin, true);
	}

	protected WintertodtScouterPluginPanelBase(WintertodtScouterPlugin plugin, boolean wrap)
	{
		super(wrap);
		this.plugin = plugin;
	}

	public abstract void populate(List<WintertodtBossData> bossData);
	public abstract void updateList();

	public void onActivate()
	{
		// If the panel is opened, try to run a get request to populate/refresh the panel.
		log.debug("Activated");
		open = true;
		plugin.hitAPI();
	}

	public void onDeactivate()
	{
		log.debug("Deactivated");
		open = false;
	}
}

/*
 * Copyright (c) 2021, Andrew McAdams
 * Copyright (c) 2021, nucleon
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.wintertodt.scouter;

import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;

import com.wintertodt.scouter.WintertodtScouterPlugin;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;

public class WintertodtScouterOverlayPanel extends OverlayPanel
{
    private final WintertodtScouterPlugin plugin;

    @Inject
    private WintertodtScouterOverlayPanel(WintertodtScouterPlugin plugin)
    {
        super(plugin);
        this.plugin = plugin;

        setPosition(OverlayPosition.TOP_LEFT);
        setPriority(OverlayPriority.HIGH);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        panelComponent.getChildren().clear();

        if (plugin.isPostError())
        {
            LineComponent l = LineComponent.builder().left("Wintertodt Scouter Error: Failed to upload data, check uplink in config.").build();
            panelComponent.getChildren().add(l);
        }
        if (plugin.isGetError())
        {
            LineComponent l = LineComponent.builder().left("Wintertodt Scouter Error: Failed to download data, check downlink in config").build();
            panelComponent.getChildren().add(l);
        }

        return super.render(graphics);
    }
}

